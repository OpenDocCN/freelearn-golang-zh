- en: Chapter 10. Advanced Concurrency and Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。高级并发和最佳实践
- en: Once you're comfortable with the basic and intermediate usage of concurrency
    features in Go, you may find that you're able to handle the majority of your development
    use cases with bidirectional channels and standard concurrency tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您熟悉了Go中并发特性的基本和中级用法，您可能会发现您能够使用双向通道和标准并发工具处理大多数开发用例。
- en: In [Chapter 2](part0021_split_000.html#page "Chapter 2. Understanding the Concurrency
    Model"), *Understanding the Concurrency Model*, and [Chapter 3](part0032_split_000.html#page
    "Chapter 3. Developing a Concurrent Strategy"), *Developing a Concurrent Strategy*,
    we looked at the concurrency models, not just of Go but of other languages as
    well, and compared the way they—and distributed models—can work. In this chapter,
    we'll touch on those and some higher level concepts with regard to designing and
    managing your concurrent application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0021_split_000.html#page "第2章。理解并发模型")*理解并发模型*和[第3章](part0032_split_000.html#page
    "第3章。制定并发策略")*制定并发策略*中，我们不仅看了Go的并发模型，还比较了其他语言的并发模型以及分布式模型的工作方式。在本章中，我们将涉及这些内容以及一些关于设计和管理并发应用程序的更高级别概念。
- en: In particular, we're going to look at central management of goroutines and their
    associated channels—out of the box you may find goroutines to be a set-it-and-forget-it
    proposition; however, there are cases where we might want more granular control
    of a channel's state.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将研究goroutine及其相关通道的集中管理——通常情况下，您可能会发现goroutine是一种设置并忘记的命题；然而，在某些情况下，我们可能希望更精细地控制通道的状态。
- en: We've also looked quite a bit at testing and benchmarking from a high level,
    but we'll look at some more detailed and complex methods for testing. We'll also
    explore a primer on the Google App Engine, which will give us access to some specific
    testing tools we haven't yet used.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从高层次上看了测试和基准测试，但我们将研究一些更详细和复杂的测试方法。我们还将探讨一些关于Google App Engine的入门知识，这将使我们能够使用一些特定的测试工具。
- en: Finally, we'll touch upon some general best practices for Go, which will surely
    pertain not just to concurrent application design but your future work in general
    with the language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将涉及一些Go的一般最佳实践，这不仅适用于并发应用程序设计，而且适用于您将来在语言中的工作。
- en: Going beyond the basics with channels
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越基础的通道使用
- en: We've talked about quite a few different channel implementations—channels of
    different type (interfaces, functions, structs, and channels)—and touched upon
    the differences in buffered and unbuffered channels. However, there's still a
    lot more we can do with the design and flow of our channels and goroutines.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了许多不同类型的通道实现——不同类型的通道（接口、函数、结构体和通道），并且涉及了缓冲和非缓冲通道的区别。然而，我们在设计和流程中仍然可以做很多事情。
- en: By design, Go wants you to keep things simple. And that's fantastic for 90 percent
    of what you'll do with Go. But there are other times where you'll need to dig
    a little deeper for a solution, or when you'll need to save resources by preserving
    the amount of open goroutine processes, channels, and more.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计上讲，Go希望您保持简单。这对您在使用Go时的90%的工作来说是非常棒的。但是还有其他时候，您需要深入挖掘解决方案，或者需要通过保留开放的goroutine进程、通道等资源来节省资源。
- en: You may, at some point, want some hands on control of the size and state, and
    also the control of a running or closed goroutine, so we'll look at doing that.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，您可能希望对goroutine的大小和状态进行一些手动控制，以及对正在运行或关闭的goroutine进行控制，因此我们将研究如何做到这一点。
- en: Just as importantly, designing your goroutines to work in concert with the application
    design as a whole can be critical to unit testing, which is a topic we'll touch
    on in this final chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，将您的goroutine设计与整个应用程序设计协同工作对于单元测试至关重要，这是我们将在本章中涉及的一个主题。
- en: Building workers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建工作线程
- en: Earlier in this book, we talked about concurrency patterns and a bit about workers.
    We even brought the workers concept into play in the previous chapter, when we
    were building our logging systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前面，我们谈到了并发模式和一些关于工作线程的内容。甚至在上一章中，当我们构建日志系统时，我们也介绍了工作线程的概念。
- en: Truly speaking, "worker" is a fairly generic and ambiguous concept, not just
    in Go, but in general programming and development. In some languages, it's an
    object/instantiated class, and in others it's a concurrent actor. In functional
    programming languages, worker is a graduated function return passed to another.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，“工作线程”是一个相当通用和模糊的概念，不仅在Go中，而且在一般的编程和开发中也是如此。在某些语言中，它是一个对象/实例化类，而在其他语言中它是一个并发的执行者。在函数式编程语言中，工作线程是传递给另一个函数的返回值。
- en: If we go back to the preface, we will see that we have literally used the Go
    gopher as an example of a worker. In short, a worker is something more complex
    than a single function call or programmatic action that will perform a task one
    or more times.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到前言，我们会看到我们确实将Go gopher用作工作线程的示例。简而言之，工作线程是一个比单个函数调用或编程动作更复杂的东西，它将执行一个或多个任务。
- en: So why are we talking about it now? When we build our channels, we are creating
    a mechanism to do work. When we have a struct or an interface, we're combining
    methods and values at a single place, and then doing work using that *object*
    as both a mechanism for the work as well as a place to store information about
    that work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们现在要谈论它呢？当我们构建通道时，我们正在创建一个执行工作的机制。当我们有一个结构体或一个接口时，我们将方法和值组合在一个地方，然后使用该*对象*来执行工作，同时也作为存储有关该工作的信息的地方。
- en: This is particularly useful in application design, as we're able to delegate
    various elements of an application's functionality to distinct and well-defined
    workers. Consider, for example, a server pinging application that has specific
    pieces doing specific things in a self-contained, compartmentalized manner.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这在应用程序设计中特别有用，因为我们能够将应用程序功能的各个元素委托给独立和明确定义的工作线程。例如，考虑一个服务器ping应用程序，其中具体的部分以自包含、分隔的方式执行特定的任务。
- en: We'll attempt to check for server availability via the HTTP package, check the
    status code and errors, and back off if we find problems with any particular server.
    You can probably see where this is going—this is the most basic approach to load
    balancing. But an important design consideration is the way in which we manage
    our channels.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试通过HTTP包检查服务器的可用性，检查状态代码和错误，并在发现任何特定服务器存在问题时进行退避。您可能已经看出这将导致什么 - 这是负载平衡的最基本方法。但一个重要的设计考虑是我们管理通道的方式。
- en: We'll have a master channel, where all important global transactions should
    be accumulated and evaluated, but each individual server will also have its own
    channels for handling tasks that are important only to that individual struct.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个主通道，所有重要的全局事务都应该在这里累积和评估，但每个单独的服务器也将有自己的通道，用于处理只对该单独结构重要的任务。
- en: 'The design in the following code can be considered as a rudimentary pipeline,
    which is roughly akin to the producer/consumer model we talked about in the previous
    chapters:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中的设计可以被视为一个基本的管道，大致相当于我们在前几章中讨论的生产者/消费者模型：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code gives the configuration part of the application, setting
    scope on how frequently to check servers, the maximum amount of time for backing
    off, and the maximum amount of retries before giving up entirely.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给出了应用程序的配置部分，设置了多久检查服务器、备份的最长时间和在完全放弃之前重试的最大次数。
- en: 'The `DELAY_INCREMENT` value represents how much time we will add to our server
    checking process each time we discover a problem. Let''s take a look at how to
    create a server in the following section:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELAY_INCREMENT`值表示每次发现问题时我们将为服务器检查过程添加多少时间。让我们看看如何在以下部分创建服务器：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we design the basic server (using the following code), which contains
    its current status, the last time it was checked, the present delay between checks,
    its own channel for evaluating statuses and establishing the new status, and updated
    retry delay:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们设计基本的服务器（使用以下代码），其中包含其当前状态、上次检查时间、检查之间的延迟、用于评估状态和建立新状态的自己的通道，以及更新的重试延迟：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `checkServerStatus()` method is the meat and potatoes of our application
    here. We pass all of our servers through this method in the `main()` function
    to our `cycleServers()` loop, after which it becomes self-fulfilling.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkServerStatus()`方法是我们应用程序的核心。我们在`main()`函数中通过`cycleServers()`循环将所有服务器传递到这个方法中，之后它就变得自我实现了。'
- en: If our `Status` is set to `true`, we send the state to the console as `OK` (otherwise
    `down`) and set our `Server` status code with `s.StatusCode` as either the HTTP
    code or `0` if there was a network or other error.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`Status`设置为`true`，我们将状态发送到控制台作为`OK`（否则为`down`），并使用`s.StatusCode`设置我们的`Server`状态代码，作为HTTP代码或者如果有网络或其他错误则为`0`。
- en: 'Finally, set the last-checked time of `Server` to `Now()` and pass `Server`
    through the `serverChan` channel. In the following code, we''ll demonstrate how
    we''ll rotate through our available servers:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`Server`的上次检查时间设置为`Now()`，并通过`serverChan`通道传递`Server`。在以下代码中，我们将演示如何循环遍历我们可用的服务器：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is our initial loop, called from main. It simply loops through our available
    servers and initializes its listening goroutine as well as sending the first `checkServerStatus`
    request.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的初始循环，从主函数调用。它只是循环遍历我们可用的服务器，并初始化其监听goroutine，以及发送第一个`checkServerStatus`请求。
- en: 'It''s worth noting two things here: first, the channel invoked by `Server`
    will never actually die, but instead the application will stop checking the server.
    That''s fine for all practical purposes here, but if we have thousands and thousands
    of servers to check, we''re wasting resources on what essentially amounts to an
    unclosed channel and a map element that has not been removed. Later, we''ll broach
    the concept of manually killing goroutines, something we''ve only been able to
    do through abstraction by stopping the communication channel. Let''s now take
    a look at the following code that controls a server''s status and its next steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意两件事：首先，由`Server`调用的通道实际上永远不会死，而是应用程序将停止检查服务器。这对于这里的所有实际目的来说都是可以的，但是如果我们有成千上万台服务器要检查，我们会浪费资源，因为本质上相当于一个未关闭的通道和一个未被移除的映射元素。稍后，我们将讨论手动终止goroutines的概念，这是我们只能通过停止通信通道来抽象实现的。现在让我们来看一下控制服务器状态及其下一步的以下代码：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is where each `Server` will listen for changes in its status, as reported
    by `checkServerStatus()`. When any given `Server` struct receives a message that
    a change in status has been reported via our initial loop, it will evaluate that
    message and act accordingly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每个`Server`将监听其状态变化的地方，由`checkServerStatus()`报告。当任何给定的`Server`结构接收到通过我们的初始循环报告状态变化的消息时，它将评估该消息并相应地采取行动。
- en: If the `Status` is set to `false`, we know that the server was inaccessible
    for some reason. The `Server` reference itself will then add a delay to the next
    time it's checked. If it's set to `true`, the server was accessible and the delay
    will either be set or reset to the default retry value of `INIT_DELAY`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Status`设置为`false`，我们知道服务器由于某种原因无法访问。然后`Server`引用本身将延迟到下次检查的时间。如果设置为`true`，则服务器是可访问的，延迟将被设置或重置为`INIT_DELAY`的默认重试值。
- en: 'It finally sets a sleep mode on that goroutine before reinitializing the `checkServerStatus()`
    method on itself, passing the `serverChan` reference along in the initial goroutine
    loop in the `main()` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在重新初始化`checkServerStatus()`方法之前，它会在goroutine上设置睡眠模式，并在`main()`函数中的初始goroutine循环中传递`serverChan`引用：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One quick note here—in our slice of `Servers`, we intentionally introduced
    a typo in the last element. You''ll notice `amazon.zom`, which will provoke an
    HTTP error in the `checkServerStatus()` method. The following is the function
    to cycle through servers to find an appropriate match:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有一个快速的说明 - 在我们的`Servers`切片中，我们故意在最后一个元素中引入了一个拼写错误。您会注意到`amazon.zom`，这将在`checkServerStatus()`方法中引发一个HTTP错误。以下是循环遍历服务器以找到合适匹配的函数：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is an example of the output with the typo included:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包含拼写错误的输出示例：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We'll be taking the preceding code for one last spin through some concurrency
    patterns later in this chapter, turning it into something a bit more practical.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面通过一些并发模式再次运行前面的代码，将其转换为更实用的东西。
- en: Implementing nil channel blocks
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现nil通道阻塞
- en: One of the bigger problems in designing something like a pipeline or producer/consumer
    model is there's somewhat of a black hole when it comes to the state of any given
    goroutine at any given time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 设计管道或生产者/消费者模型等东西的一个更大的问题是，在任何给定时间，任何给定goroutine的状态都有点像黑洞。
- en: 'Consider the following loop, wherein a producer channel creates an arbitrary
    set of consumer channels and expects each to do one and only one thing:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下循环，在该循环中，生产者通道创建一组任意的消费者通道，并期望每个通道只执行一项任务：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Given a random amount of consumers to produce, we attach a channel to each and
    pass a message upstream to the `Producer` via that consumer's channel. We send
    just a single message (which we could handle with a buffered channel), but we
    simply close the channel after.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 给定要生成的消费者的随机数量，我们为每个消费者附加一个通道，并通过该消费者的通道将消息传递到`Producer`上游。我们只发送一条消息（我们可以使用缓冲通道处理），但是在发送完消息后我们简单地关闭通道。
- en: Whether in a multithreaded application, a distributed application, or a highly
    concurrent application, an essential attribute of a producer-consumer model is
    the ability for data to move across a queue/channel in a steady, reliable fashion.
    This requires some modicum of mutual knowledge to be shared between both the producer
    and consumers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是在多线程应用程序、分布式应用程序还是高并发应用程序中，生产者-消费者模型的一个基本属性是数据能够以稳定、可靠的方式在队列/通道之间移动。这需要在生产者和消费者之间共享一些相互的知识。
- en: 'Unlike environments that are distributed (or multicore), we do possess some
    inherent awareness of the status on both ends of that arrangement. We''ll next
    look at a listening loop for producer messages:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与分布式（或多核）环境不同，我们确实具有对该安排两端状态的某种固有意识。接下来我们将看一下生产者消息的监听循环：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The primary issue is that one of the `Producer` channel doesn't know much about
    any given `Consumer`, including when it's actively running. If we uncommented
    the `// consumer <- 1` line, we'll get a panic, because we're attempting to send
    a message on a closed channel.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是`Producer`通道之一对于任何给定的`Consumer`并不了解太多，包括它何时处于活动状态。如果我们取消注释`// consumer
    <- 1`行，我们将会得到一个恐慌，因为我们试图在关闭的通道上发送消息。
- en: As a message is passed across a secondary goroutine's channel, upstream to the
    channel of the `Producer`, we get an appropriate reception, but cannot detect
    when the downstream goroutine is closed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息通过次要goroutine的通道上游传递到`Producer`的通道时，我们会得到适当的接收，但无法检测下游goroutine何时关闭。
- en: Knowing when a goroutine has terminated is in many cases inconsequential, but
    consider an application that spawns new goroutines when a certain number of tasks
    are complete, effectively breaking a task into mini tasks. Perhaps each chunk
    is dependent on the total completion of the last chunk, and a broadcaster must
    know the status of the current goroutines before moving on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，知道goroutine何时终止并不重要，但是考虑一个应用程序，在完成一定数量的任务时生成新的goroutines，有效地将一个任务分解成小任务。也许每个块都依赖于上一个块的总体完成情况，并且广播器必须在继续之前了解当前goroutines的状态。
- en: Using nil channels
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用nil通道
- en: In the earlier versions of Go, you could communicate across uninitialized, thus
    nil or 0-value channels without a panic (although your results would be unpredictable).
    Starting from Go Version 1, communication across nil channels produced a consistent
    but sometimes confusing effect.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go的早期版本中，您可以在未初始化的、因此为nil或0值的通道之间进行通信而不会引发恐慌（尽管结果可能是不可预测的）。从Go版本1开始，跨nil通道的通信产生了一种一致但有时令人困惑的效果。
- en: 'It''s vital to note that within a select switch, transmission on a nil channel
    on its own will still cause a deadlock and panic. This is something that will
    most often creep up when utilizing global channels and not ever properly initializing
    them. The following is an example of such transmission on a nil channel:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在select开关内，单独在nil通道上进行传输仍会导致死锁和恐慌。这在使用全局通道并且从未正确初始化它们时最常见。以下是在nil通道上进行传输的示例：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As the channel is set to its `0` value (nil, in this case), it blocks perpetually
    and the Go compiler will detect this, at least in more recent versions. You can
    also duplicate this outside of a `select` statement, as shown in the following
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通道设置为其`0`值（在这种情况下为nil），它会永久阻塞，Go编译器将会检测到这一点，至少在较新的版本中是如此。您还可以在`select`语句之外复制这一点，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code will block forever without the panic, due to the default
    in the `select` statement keeping the main loop active while waiting for communication
    on the channel. If we initialize the channel, however, the application runs as
    expected.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`select`语句中的默认值使主循环在等待通道上的通信时保持活动状态，所以前面的代码将永远阻塞，没有恐慌。然而，如果我们初始化通道，应用程序将如预期般运行。
- en: With these two fringe cases—closed channels and nil channels—we need a way for
    a master channel to understand the state of a goroutine.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种边缘情况——关闭的通道和nil通道中，我们需要一种方法让主通道了解goroutine的状态。
- en: Implementing more granular control over goroutines with tomb
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tomb实现对goroutines的更精细控制
- en: As with many such problems—both niche and common—there exists a third-party
    utility for grabbing your goroutines by the horns.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多这类问题一样——无论是小众还是常见的——存在第三方实用程序，可以抓住你的goroutines。
- en: Tomb is a library that provides diagnostics to go along with any goroutine and
    channel—it can tell a master channel if another goroutine is dead or dying.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Tomb是一个库，它提供了与任何goroutine和通道一起使用的诊断功能——它可以告诉主通道另一个goroutine是死了还是快死了。
- en: In addition, it allows you to explicitly kill a goroutine, which is a bit more
    nuanced than simply closing the channel it is attached to. As previously mentioned,
    closing the channel is effectively neutering a goroutine, although it could ultimately
    still be active.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它允许您明确地终止goroutine，这比简单关闭它附加的通道更微妙。如前所述，关闭通道实际上是使goroutine失效，尽管它最终仍然可能是活动的。
- en: You are about to find a simple fetch-and-grab body script that takes a slice
    of URL structs (with status and URI) and attempts to grab the HTTP response for
    each and apply it to the struct. But instead of just reporting information from
    the goroutines, we'll have the ability to send "kill messages" to each of a "master"
    struct's child goroutines.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您将找到一个简单的获取和抓取主体脚本，它接受URL结构的切片（带有状态和URI），并尝试获取每个URL的HTTP响应并将其应用于结构。但是，我们不仅仅报告goroutines的信息，还可以向“主”结构的每个子goroutine发送“kill消息”的能力。
- en: 'In this example, we''ll run the script for 10 seconds, and if any of the goroutines
    fail to do their job in that allotted time, it will respond that it was unable
    to get the URL''s body due to a kill send from the master struct that invoked
    it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将运行脚本10秒，如果任何goroutine在分配的时间内未能完成其工作，它将响应说由于主结构发送的kill命令而无法获取URL的主体：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the minimum necessary structure required to create a parent or a master
    struct for all of your spawned goroutines. The `tomb.Tomb` struct is simply a
    mutex, two channels (one for dead and dying), and a reason error struct. The structure
    of the `URL` struct looks like the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建所有生成的goroutines的父结构或主结构所需的最低必要结构。`tomb.Tomb`结构只是一个互斥体，两个通道（一个用于死亡和一个用于垂死），以及一个原因错误结构。`URL`结构的结构如下代码所示：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our `URL` struct is fairly basic—`Status`, set to `false` by default and `true`
    when the body has been retrieved. It consists of the `URI` variable—which is the
    reference to the URL—and the `Body` variable for storing the retrieved data. The
    following function allows us to execute a "kill" on a `GoTomb` struct:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`URL`结构相当基本——`Status`默认设置为`false`，当主体被检索时设置为`true`。它包括`URI`变量——这是URL的引用——以及用于存储检索数据的`Body`变量。以下函数允许我们对`GoTomb`结构执行“kill”：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding method invokes `tomb.Kill` on our `GoTomb` struct. Here, we have
    set the sole parameter to `nil`, but this can easily be changed to a more descriptive
    error, such as `errors.New("Time to die, goroutine")`. Here, we''ll show the listener
    for the `GoTomb` struct:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法在我们的`GoTomb`结构上调用了`tomb.Kill`。在这里，我们将唯一的参数设置为`nil`，但这很容易改为一个更具描述性的错误，比如`errors.New("Time
    to die, goroutine")`。在这里，我们将展示`GoTomb`结构的监听器：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We invoke `TombListen` attached to our `GoTomb`, which sets a select that listens
    for the `Dying()` channel, as shown in the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用附加到我们的`GoTomb`的`TombListen`，它设置一个监听`Dying()`通道的选择，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we invoke `Fetch()`, we also set the tomb to `TombListen()`, which receives
    those "master" messages across all spawned goroutines. We impose an intentionally
    long wait to ensure that our last few attempts to `Fetch()` will come after the
    `Kill()` command. Finally, our `main()` function, which handles the overall setup:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`Fetch()`时，我们还将tomb设置为`TombListen()`，它接收所有生成的goroutines的“主”消息。我们故意设置一个很长的等待时间，以确保我们最后几次尝试`Fetch()`在`Kill()`命令之后进行。最后，我们的`main()`函数，处理整体设置：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By setting `time.Sleep` to `10` seconds and then killing our goroutines, we
    guarantee that the 5 second delays between `Fetch()` prevent the last of our goroutines
    from successfully finishing before being killed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`time.Sleep`设置为`10`秒，然后杀死我们的goroutines，我们保证在被杀死之前，`Fetch()`之间的5秒延迟会阻止我们的最后几个goroutines成功完成。
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the tomb package, go to [http://godoc.org/launchpad.net/tomb](http://godoc.org/launchpad.net/tomb)
    and install it using the `go get launchpad.net/tomb` command.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于tomb包，请访问[http://godoc.org/launchpad.net/tomb](http://godoc.org/launchpad.net/tomb)并使用`go
    get launchpad.net/tomb`命令进行安装。
- en: Timing out with channels
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通道超时
- en: One somewhat critical point with channels and `select` loops that we haven't
    examined particularly closely is the ability—and often necessity—to kill a `select`
    loop after a certain timeout.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于通道和`select`循环的一个相当关键的点，我们还没有特别仔细地检查过，那就是在一定的超时之后终止`select`循环的能力和通常的必要性。
- en: Many of the applications we've written so far are long-running or perpetually-running,
    but there are times when we'll want to put a finite time limit on how long goroutines
    can operate.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的许多应用程序都是长时间运行或永久运行的，但有时我们会希望对goroutines的运行时间设置有限的时间限制。
- en: The `for { select { } }` switch we've used so far will either live perpetually
    (with a default case) or wait to be broken from one or more of the cases.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止使用的`for { select { } }`开关要么永久存在（带有默认情况），要么等待从一个或多个情况中退出。
- en: There are two ways to manage interval-based tasks—both as part of the time package,
    unsurprisingly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种管理基于间隔的任务的方法——都作为时间包的一部分，这并不奇怪。
- en: 'The `time.Ticker` struct allows for any given operation after the specified
    period of time. It provides C, a blocking channel that can be used to detect activity
    sent after that period of time; refer to the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Ticker`结构允许在指定的时间段之后执行任何给定的操作。它提供了一个C，一个阻塞通道，可以用来检测在那段时间之后发送的活动；参考以下代码：'
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can extend this to end channels and concurrent execution after a certain
    amount of time. Take a look at the following modifications:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展这个方法，在一定时间后结束通道和并发执行。看一下以下修改：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Building a load balancer with concurrent patterns
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发模式构建负载均衡器
- en: When we built our server pinging application earlier in this chapter, it was
    probably pretty easy to imagine taking this to a more usable and valuable space.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章前面构建我们的服务器ping应用程序时，很容易想象将其带到一个更可用和有价值的空间。
- en: Pinging a server is often the first step in a health check for a load balancer.
    Just as Go provides a usable out-of-the-box web server solution, it also presents
    a very clean `Proxy` and `ReverseProxy` struct and methods, which makes creating
    a load balancer rather simple.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于负载均衡器的健康检查，ping服务器通常是第一步。正如Go提供了一个可用的开箱即用的Web服务器解决方案一样，它还提供了一个非常干净的“Proxy”和“ReverseProxy”结构和方法，使得创建负载均衡器变得非常简单。
- en: Of course, a round-robin load balancer will need a lot of background work, specifically
    on checking and rechecking as it changes the `ReverseProxy` location between requests.
    We'll handle these with the goroutines triggered with each request.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，循环负载均衡器将需要大量的后台工作，特别是在更改请求之间的“ReverseProxy”位置时进行检查和重新检查。我们将使用每个请求触发的goroutines来处理这些。
- en: 'Finally, note that we have some dummy URLs at the bottom in the configuration—changing
    those to production URLs should immediately turn the server that runs this into
    a working load balancer. Let''s look at the main setup for the application:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意我们在配置底部有一些虚拟URL——将这些更改为生产URL应立即将运行此服务器的服务器转换为工作负载均衡器。让我们看一下应用程序的主要设置：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the previous code, we defined our constants, much like we did previously.
    We have a `MAX_RETRIES`, which limits how many failures we can have, `MAX_TIMEOUT_SECONDS`,
    which defines the longest amount of time we''ll wait before trying again, and
    our `TIMEOUT_INCREMENT` for changing that value between failures. Next, let''s
    look at the basic construction of our `Server` struct:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了我们的常量，就像我们之前做的那样。我们有一个“MAX_RETRIES”，它限制了我们可以有多少次失败，“MAX_TIMEOUT_SECONDS”，它定义了我们在再次尝试之前等待的最长时间，以及我们的“TIMEOUT_INCREMENT”用于在失败之间更改该值。接下来，让我们看一下我们的“Server”结构的基本构造：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see in the previous code, we have a generic `Server` struct that maintains
    the present state, the last status code, and information on the last time the
    server was checked.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中看到的，我们有一个通用的“Server”结构，用于维护当前状态、最后的状态代码以及上次检查服务器的时间的信息。
- en: 'Note that we also have a `Recheck` channel that triggers the delayed attempt
    to check the `Server` again for availability. Each Boolean passed across this
    channel will either remove the server from the available pool or reannounce that
    it is still in service:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还有一个“Recheck”通道，触发延迟尝试检查“Server”是否再次可用。通过该通道传递的每个布尔值都将从可用池中删除服务器，或者重新宣布其仍在服务中：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is the instantiated method that listens on each server for messages delivered
    on the availability of a server at any given time. While running a goroutine,
    we keep a perpetually listening channel open to listen to Boolean responses from
    `checkStatus()`. If the server is available, the next delay is set to default;
    otherwise, `TIMEOUT_INCREMENT` is added to the delay. If the server has failed
    too many times, it''s taken out of rotation by setting its `InService` property
    to `false` and no longer invoking the `checkStatus()` method. Let''s next look
    at the method for checking the present status of `Server`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实例化的方法，它在每个服务器上监听在任何给定时间服务器的可用性的消息。在运行goroutine的同时，我们保持一个永久监听通道，以便从“checkStatus（）”接收布尔响应。如果服务器可用，则下一个延迟设置为默认值；否则，将“TIMEOUT_INCREMENT”添加到延迟中。如果服务器失败次数太多，通过将其“InService”属性设置为“false”并不再调用“checkStatus（）”方法来将其从轮换中取出。接下来让我们看一下检查“Server”当前状态的方法：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our `checkStatus()` method should look pretty familiar based on the server
    ping example. We look for the server; if it is available, we pass `true` to our
    `Recheck` channel; otherwise `false`, as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“checkStatus（）”方法应该看起来很熟悉，基于服务器ping示例。我们寻找服务器；如果它可用，我们向我们的“Recheck”通道传递“true”；否则传递“false”，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our `healthCheck` function simply kicks off the loop of each server checking
    (and re-checking) its status. It''s run only one time, and initializes the `Recheck`
    channel via the `make` statement:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“healthCheck”函数只是启动每个服务器检查（和重新检查）其状态的循环。它只运行一次，并通过“make”语句初始化“Recheck”通道：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `roundRobin` function first checks the next available `Server` in the queue—if
    that server happens to be down, it loops through the remaining to find the first
    available `Server`. If it loops through all, it will reset to `0`. Let''s look
    at the global configuration variables:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: “roundRobin”函数首先检查队列中的下一个可用“Server”——如果该服务器不可用，它将循环查找剩余的服务器，以找到第一个可用的“Server”。如果它循环遍历所有服务器，它将重置为“0”。让我们看一下全局配置变量：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These are our global variables—our `Servers` slice of `Server` structs, the
    `nextServerIndex` variable, which serves to increment the next `Server` to be
    returned, `ServersAvailable` and `ServerChan`, which start the load balancer only
    after a viable server is available, and then our `Proxy` variables, which tell
    our `http` handler where to go. This requires a `ReverseProxy` method, which we''ll
    look at now in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们的全局变量——我们的“Servers”切片的“Server”结构，用于递增下一个要返回的“Server”的“nextServerIndex”变量，“ServersAvailable”和“ServerChan”，它们在可用服务器可用后才启动负载均衡器，然后是我们的“Proxy”变量，告诉我们的“http”处理程序去哪里。这需要一个“ReverseProxy”方法，我们现在将在以下代码中查看：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that we''re operating on a `ReverseProxy` struct here, which is different
    from our previous forays into serving webpages. Our next function executes the
    round robin and gets our next available server:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里操作的是“ReverseProxy”结构，这与我们之前对提供网页服务的尝试不同。我们的下一个函数执行循环负载均衡，并获取我们的下一个可用服务器：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `setProxy` function is called after every request, and you can see it as
    the first line in our handler. Next we have the general listening function that
    looks out for requests we''ll be reverse proxying:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: “setProxy”函数在每个请求之后被调用，你可以在我们的处理程序中看到它是第一行。接下来，我们有一个通用的监听函数，用于监听我们将要进行反向代理的请求：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this application, we have a simple but extensible load balancer that works
    with the common, core components in Go. Its concurrency features keep it lean
    and fast, and we wrote it in a very small amount of code using exclusively standard
    Go.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个应用程序，我们拥有一个简单但可扩展的负载均衡器，它与Go中的常见核心组件一起工作。其并发特性使其保持精简和快速，我们只使用标准的Go编写了非常少量的代码。
- en: Choosing unidirectional and bidirectional channels
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择单向和双向通道
- en: For the purpose of simplicity, we've designed most of our applications and sample
    code with bidirectional channels, but of course any channel can be set unidirectionally.
    This essentially turns a channel into a "read-only" or "write-only" channel.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们设计了大部分应用程序和示例代码都使用双向通道，但当然任何通道都可以设置为单向。这基本上将通道转换为“只读”或“只写”通道。
- en: If you're wondering why you should bother limiting the direction of a channel
    when it doesn't save any resources or guarantee an issue, the reason boils down
    to simplicity of code and limiting the potential for panics.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么在不节省任何资源或保证问题的情况下限制通道的方向，原因归结为代码的简单性和限制恐慌的潜力。
- en: 'By now we know that sending data on a closed channel results in a panic, so
    if we have a write-only channel, we''ll never accidentally run into that problem
    in the wild. Much of this can also be mitigated with `WaitGroups`, but in this
    case that''s a sledgehammer being used on a nail. Consider the following loop:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道在关闭的通道上发送数据会导致恐慌，因此如果我们有一个只写通道，我们在野外永远不会意外遇到这个问题。许多情况下也可以通过 `WaitGroups`
    来减轻这种情况，但在这种情况下，这就像用锤子敲钉子。考虑以下循环：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since we're abruptly closing our `ch` channel one digit before the goroutine
    can finish, any writes to it cause a runtime error.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 goroutine 完成之前突然关闭了 `ch` 通道的一个数字，任何对它的写入都会导致运行时错误。
- en: In this case, we are invoking a read-only command, but it's in the `select`
    loop. We can safeguard this a bit more by allowing only specific actions to be
    sent on unidirectional channels. This application will always work up to the point
    where in the channel is closed prematurely, one shy of the `TOTAL_RANDOMS` constant.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在调用一个只读命令，但它在 `select` 循环中。我们可以通过只允许在单向通道上发送特定操作来更安全地进行这个操作。这个应用程序将始终在通道被过早关闭的情况下工作，比
    `TOTAL_RANDOMS` 常量少一个。
- en: Using receive-only or send-only channels
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用只接收或只发送的通道
- en: When we limit the direction or the read/write capability of our channels, we
    also reduce the potential for closed channel deadlocks if one or more of our processes
    inadvertently sends on such a channel.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们限制通道的方向或读/写能力时，我们还减少了如果我们的一个或多个进程无意中在这样的通道上发送时关闭通道死锁的可能性。
- en: So the short answer to the question "When is it appropriate to use a unidirectional
    channel?" is "Whenever you can."
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于问题“何时适合使用单向通道？”的简短答案是“只要可能”。
- en: Don't force the issue, but if you can set a channel to read/write only, it may
    preempt issues down the road.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不要强迫这个问题，但如果您可以将通道设置为只读或只写，可能会在将来避免问题。
- en: Using an indeterminate channel type
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不确定的通道类型
- en: One trick that can often come in handy, and we haven't yet addressed, is the
    ability to have what is effectively a typeless channel.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经常有用的技巧，我们还没有解决的是，能够拥有有效的无类型通道的能力。
- en: 'If you''re wondering why that might be useful, the short answer is concise
    code and application design thrift. Often this is a discouraged tactic, but you
    may find it useful from time to time, especially when you need to communicate
    one or more disparate concepts across a single channel. The following is an example
    of an indeterminate channel type:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么这可能有用，简短的答案是简洁的代码和应用程序设计节俭。通常这是一种不鼓励的策略，但您可能会发现它在某些时候很有用，特别是当您需要通过单个通道传达一个或多个不同的概念时。以下是一个不确定通道类型的示例：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using Go with unit testing
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Go 进行单元测试
- en: As with many of the basic and intermediate development and deployment requirements
    you may have, Go comes with a built-in application for handling unit tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与您可能有的许多基本和中级开发和部署要求一样，Go 自带了一个用于处理单元测试的内置应用程序。
- en: 'The basic premise behind testing is that you create your package and then create
    a testing package to run against the initial application. The following is a very
    basic example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的基本前提是您创建您的包，然后创建一个测试包来针对初始应用程序运行。以下是一个非常基本的示例：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A simple Go test in that subdirectory will give you the response you're looking
    for. While this was admittedly simple—and purposefully flawed—you can probably
    see how easy it is to break apart your code and test it incrementally. This is
    enough to do very basic unit tests out of the box.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在该子目录中进行简单的 Go 测试将给您所需的响应。虽然这显然很简单，而且故意有缺陷，但您可能会看到如何轻松地拆分您的代码并逐步测试它。这足以在开箱即用的情况下进行非常基本的单元测试。
- en: 'Correcting this would then be fairly simple—the same test would pass on the
    following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对此进行更正将相当简单——相同的测试将通过以下代码：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The testing package is somewhat limited; however, as it provides basic pass/fails
    without the ability to do assertions. There are two third-party packages that
    can step in and help in this regard, and we'll explore them in the following sections.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 测试包有一定的局限性；然而，它提供了基本的通过/失败，没有断言的能力。有两个第三方包可以在这方面提供帮助，我们将在以下部分进行探讨。
- en: GoCheck
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GoCheck
- en: '**GoCheck** extends the basic testing package primarily by augmenting it with
    assertions and verifications. You''ll also get some basic benchmarking utility
    out of it that works a little more fundamentally than anything you''d need to
    engineer using Go.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**GoCheck** 主要通过增加断言和验证来扩展基本测试包。您还将获得一些基本的基准测试实用程序，它的工作方式比您需要使用 Go 进行工程设计的任何东西更基本。'
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more details on GoCheck visit [http://labix.org/gocheck](http://labix.org/gocheck)
    and install it using `go get gopkg.in/check.v1`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 GoCheck 的更多详细信息，请访问 [http://labix.org/gocheck](http://labix.org/gocheck)
    并使用 `go get gopkg.in/check.v1` 进行安装。
- en: Ginkgo and Gomega
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ginkgo 和 Gomega
- en: This allows testing to be as granular as unit testing, but also expands the
    way we handle application usage in verbose and explicit behaviors.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得测试可以像单元测试一样细粒度，但也扩展了我们处理应用程序使用的方式，以详细和明确的行为。
- en: If BDD is something you or your organization is interested in, this is a fantastic,
    mature package for implementing deeper unit testing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 BDD 是您或您的组织感兴趣的内容，这是一个实现更深入单元测试的成熟包。
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more information on Ginkgo go to [https://github.com/onsi/ginkgo](https://github.com/onsi/ginkgo)
    and install it using `go get github.com/onsi/ginkgo/ginkgo`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ginkgo的更多信息，请访问[https://github.com/onsi/ginkgo](https://github.com/onsi/ginkgo)并使用`go
    get github.com/onsi/ginkgo/ginkgo`进行安装。
- en: For more information on dependency, refer to `go get github.com/onsi/gomega`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有关依赖性的更多信息，请参阅`go get github.com/onsi/gomega`。
- en: Using Google App Engine
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Google App Engine
- en: If you're unfamiliar with Google App Engine, the short version is it's a cloud
    environment that allows for simple building and deployment of **Platform-As-A-Service**
    (**paas**) solutions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Google App Engine不熟悉，简短的版本是它是一个云环境，允许简单构建和部署**平台即服务**（**PaaS**）解决方案。
- en: Compared to a lot of similar solutions, Google App Engine allows you to build
    and test your applications in a very simple and straightforward way. Google App
    Engine allows you to write and deploy in Python, Java, PHP, and of course, Go.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多类似的解决方案相比，Google App Engine允许您以非常简单和直接的方式构建和测试应用程序。Google App Engine允许您使用Python、Java、PHP和当然，Go来编写和部署。
- en: 'For the most part, Google App Engine provides a standard Go installation that
    makes it easy to dovetail off of the `http` package. But it also gives you a few
    noteworthy additional packages that are unique to Google App Engine itself:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，Google App Engine提供了一个标准的Go安装，使得可以轻松地与`http`软件包配合使用。但它还为您提供了一些独特于Google
    App Engine的值得注意的额外软件包：
- en: '| Package | Description |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 软件包 | 描述 |'
- en: '| --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `appengine/memcache` | This provides a distributed memcache installation
    unique to Google App Engine |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `appengine/memcache` | 这提供了一个分布式的内存缓存安装，是Google App Engine独有的 |'
- en: '| `appengine/mail` | This allows you to send e-mails through an SMTP-esque
    platform |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `appengine/mail` | 这允许您通过类似SMTP的平台发送电子邮件 |'
- en: '| `appengine/log` | Given your storage may be more ephemeral here, it formalizes
    a cloud version of the log |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `appengine/log` | 鉴于您的存储可能更短暂，它将日志的云版本正式化 |'
- en: '| `appengine/user` | This opens both identity and OAuth capabilities |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `appengine/user` | 这打开了身份和OAuth功能 |'
- en: '| `appengine/search` | This gives your application the power of Google search
    on your own data via datastore |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `appengine/search` | 这使您的应用程序可以通过数据存储库获得Google搜索的功能 |'
- en: '| `appengine/xmpp` | This provides Google Chat-like capabilities |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `appengine/xmpp` | 这提供了类似Google Chat的功能 |'
- en: '| `appengine/urlfetch` | This is a crawler functionality |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `appengine/urlfetch` | 这是一个爬虫功能 |'
- en: '| `appengine/aetest` | This extends unit testing for Google App Engine |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `appengine/aetest` | 这扩展了Google App Engine的单元测试 |'
- en: While Go is still considered beta for Google App Engine, you can expect that
    if anyone was able to competently deploy it in a cloud environment, it would be
    Google.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对于Google App Engine来说，Go仍然被认为是测试版，但您可以期待，如果有人能够在云环境中成功部署它，那就是Google。
- en: Utilizing best practices
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用最佳实践
- en: The wonderful thing with Go when it comes to best practices is that even if
    you don't necessarily do everything right, either Go will yell at you or provide
    you with the tools necessary to fix it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到最佳实践时，Go的美妙之处在于，即使您并不一定做对了一切，Go要么会警告您，要么会为您提供必要的工具来修复它。
- en: If you attempt to include code and not use it, or if you attempt to initialize
    a variable and not use it, Go will stop you. If you want to clean up your code's
    formatting, Go enables it with `go fmt`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试包含代码但不使用它，或者尝试初始化变量但不使用它，Go会阻止您。如果您想清理代码的格式，Go可以使用`go fmt`来实现。
- en: Structuring your code
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建您的代码
- en: 'One of the easiest things you can do when building a package from scratch is
    to structure your code directories in an idiomatic way. The standard for a new
    package would look something like the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始构建软件包时，最简单的事情之一就是以符合惯例的方式构建代码目录。新软件包的标准看起来可能是以下代码：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Setting up your Go code like this is not just helpful for your own organization,
    but allows you to distribute your package more easily.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 设置您的Go代码就像这样不仅对您自己的组织有帮助，还可以更轻松地分发您的软件包。
- en: Documenting your code
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录您的代码
- en: 'For anyone who has worked in a corporate or collaborative coding environment,
    documentation is sacrosanct. As you may recall earlier, using the `godoc` command
    allows you to quickly get information about a package at the command line or via
    an ad hoc localhost server. The following are the two basic ways you may use `godoc`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在企业或协作编码环境中工作过的人来说，文档是神圣的。正如您可能记得的那样，使用`godoc`命令可以让您快速获取有关软件包的信息，无论是在命令行还是通过特设的本地主机服务器。以下是您可以使用`godoc`的两种基本方式：
- en: '| Using godoc | Description |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 使用godoc | 描述 |'
- en: '| --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `godoc fmt` | This brings `fmt` documentation to the screen |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `godoc fmt` | 这将`fmt`文档显示在屏幕上 |'
- en: '| `godoc -http=:3000` | This hosts the documentation on port `:3030` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `godoc -http=:3000` | 这将在端口`:3030`上托管文档 |'
- en: 'Go makes it super easy to document your code, and you absolutely should. By
    simply adding single-line comments above each identifier (package, type, or function),
    you''ll append that to the contextual documentation, as shown in the following
    code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Go使得记录您的代码变得非常容易，而且您绝对应该这样做。只需在每个标识符（软件包、类型或函数）上方添加单行注释，您将把它附加到上下文文档中，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When installed, this will allow anyone to run the `godoc` documentation on your
    package and get as much detailed information as you're willing to supply.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，这将允许任何人在您的软件包上运行`godoc`文档，并获得您愿意提供的详细信息。
- en: You'll often see more robust examples of this in the Go core code itself, and
    it's worth reviewing that to compare your style of documentation to Google's and
    the Go community's.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常会在Go核心代码中看到更健壮的示例，值得审查以比较您的文档风格与Google和Go社区的风格。
- en: Making your code available via go get
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过go get使您的代码可用
- en: Assuming you've kept your code in a manner consistent with the organizational
    techniques as listed previously, making your code available via code repositories
    and hosts should be a cinch.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经按照之前列出的组织技术保持了代码的一致性，那么通过代码存储库和主机使您的代码可用应该是轻而易举的。
- en: 'Using GitHub as the standard, here''s how we might design our third-party application:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitHub作为标准，这是我们设计第三方应用程序的方式：
- en: Make sure you stick to the previous structural format.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您遵循先前的结构格式。
- en: Keep your source files under the directory structures they'll live in remotely.
    In other words, expect that your local structure will reflect the remote structure.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源文件保存在它们将在远程存储的目录结构下。换句话说，预期本地结构将反映远程结构。
- en: Perhaps obviously, commit only the files you wish to share in the remote repository.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显然，只提交您希望在远程存储库中共享的文件。
- en: Assuming your repository is public, anyone should be able to get (`go get`)
    and then install (`go install`) your package.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的存储库是公开的，任何人都应该能够获取（`go get`）并安装（`go install`）您的包。
- en: Keeping concurrency out of your packages
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免在您的包中使用并发
- en: One last point that might seem somewhat out of place given the context of the
    book—if you're building separate packages that will be imported, avoid including
    concurrent code whenever possible.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个可能看起来有些不合时宜的观点是，如果您正在构建将被导入的单独包，请尽量避免包含并发代码。
- en: This is not a hard-and-fast rule, but when you consider potential usage, it
    makes sense—let the main application handle the concurrency unless your package
    absolutely needs it. Doing so will prevent a lot of hidden and difficult-to-debug
    behavior that may make your library less appealing.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个死板的规则，但考虑到潜在的使用情况，这是有道理的——除非您的包绝对需要，并发，否则让主应用程序处理并发。这样做将防止许多隐藏的、难以调试的行为，这可能会使您的库不那么吸引人。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: It is my sincere hope that you've been able to explore, understand, and utilize
    the depths of Go's powerful abilities with concurrency through this book.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我真诚地希望您能够通过本书探索、理解并利用Go强大的并发能力。
- en: We've gone over a lot, from the most basic, channel-free concurrent goroutines
    to complex channel types, parallelism, and distributed computing, and we've brought
    some example code along at every step.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了很多内容，从最基本的、不涉及通道的并发goroutines到复杂的通道类型、并行性和分布式计算，并且在每一步都带来了一些示例代码。
- en: By now, you should be fully equipped to build anything your heart desires in
    code, in a manner that is highly concurrent, fast, and error-free. Beyond that,
    you should be able to produce well-formed, properly-structured, and documented
    code that can be used by you, your organization, or others to implement concurrency
    where it is best utilized.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经完全具备了以高度并发、快速和无错误的方式构建任何您心中所需的代码的能力。除此之外，您应该能够产生格式良好、结构合理、有文档的代码，可以被您、您的组织或其他人用来实现最佳利用并发的代码。
- en: Concurrency itself is a vague concept; it's one that means slightly different
    things to different people (and across multiple languages), but the core goal
    is always fast, efficient, and reliable code that can provide performance boosts
    to any application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 并发本身是一个模糊的概念；对不同的人（以及多种语言）来说，它的含义略有不同，但核心目标始终是快速、高效、可靠的代码，可以为任何应用程序提供性能提升。
- en: Armed with a full understanding of both the implementation of concurrency in
    Go as well as its inner workings, I hope you continue your Go journey as the language
    evolves and grows, and similarly implore you to consider contributing to the Go
    project itself as it develops.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了Go中并发实现以及其内部工作原理的全面理解，我希望您在语言不断发展和成长的过程中继续您的Go之旅，并呼吁您考虑在Go项目本身的发展中做出贡献。
