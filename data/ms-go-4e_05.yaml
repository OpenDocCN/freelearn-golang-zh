- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Reflection and Interfaces
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射与接口
- en: You might wonder what happens if you want to sort user-defined data structures,
    such as phone records or numeric data, based on your own criteria, such as a surname
    or a statistical property such as the mean value of a dataset. What happens when
    you want to sort different datasets that share a common behavior without having
    to implement sorting from scratch for each one of the different data types using
    multiple functions? Also, imagine that you want to write a utility that sorts
    uncommon data. For example, imagine that you want to sort a slice that holds various
    kinds of 3D shapes based on their volume. Can this be performed easily and in
    a way that makes sense?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果你想要根据你自己的标准，如姓氏或数据集的平均值等统计属性，对用户定义的数据结构，如电话记录或数值数据，进行排序，会发生什么。当你想要对具有共同行为的不同数据集进行排序，而无需为每种不同的数据类型从头实现排序功能时，会发生什么？此外，想象一下，如果你想要编写一个对不常见数据进行排序的工具。例如，想象一下，你想要根据体积对包含各种3D形状的切片进行排序。这能轻松且合理地完成吗？
- en: The answer to all these questions and concerns is the use of interfaces. However,
    interfaces are not just about data manipulation and sorting. Interfaces are about
    expressing abstractions and identifying and defining behaviors that can be shared
    among different data types. Once you have implemented an interface for a data
    type, a new world of functionality becomes available for the variables and the
    values of that type, which can save you time and increase your productivity. Interfaces
    work with *methods on types* or *type methods*, which are like functions attached
    to given data types, which, in Go, are usually structures. In Go, interfaces are
    satisfied implicitly. This means that you do not explicitly declare that a type
    implements an interface. Instead, a type is considered to implement an interface
    if it provides implementations for all the methods declared by that interface.
    Now, let us talk about the *empty interface*, which is represented by `interface{}`.
    The empty interface specifies zero methods, meaning that any type satisfies the
    empty interface. This can be powerful but also requires caution because it essentially
    says “I can hold a value of any type.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题的答案和担忧都是使用接口。然而，接口不仅仅是关于数据操作和排序。接口是关于表达抽象、识别和定义可以在不同数据类型之间共享的行为。一旦你为数据类型实现了一个接口，该类型变量和值的全新功能世界就变得可用，这可以节省你的时间并提高你的生产力。接口与*类型上的方法*或*类型方法*一起工作，这些方法类似于附加到给定数据类型上的函数，在Go中通常是结构体。在Go中，接口是隐式满足的。这意味着你不需要显式声明一个类型实现了接口。相反，如果一个类型为该接口声明了所有方法的实现，则认为该类型实现了接口。现在，让我们谈谈*空接口*，它由`interface{}`表示。空接口指定了零个方法，这意味着任何类型都满足空接口。这可能很强大，但也需要谨慎，因为它本质上意味着“我可以持有任何类型的值。”
- en: Another handy yet advanced Go feature is reflection, which allows you to examine
    the internal structure of a data type at execution time. However, as reflection
    is an advanced Go feature, you might not need to use it on a regular basis.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个实用且高级的Go语言特性是反射，它允许你在运行时检查数据类型的内部结构。然而，由于反射是一个高级的Go语言特性，你可能不需要经常使用它。
- en: 'This chapter covers:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖：
- en: Reflection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射
- en: Type methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型方法
- en: Interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Object-oriented programming in Go
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go语言中的面向对象编程
- en: Interfaces versus generics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口与泛型
- en: Reflection versus generics
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射与泛型
- en: Updating the statistics application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新统计应用程序
- en: Reflection
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射
- en: We begin this chapter with reflection, which is an advanced Go feature, not
    because it is an easy subject but because it is going to help you understand how
    Go works with different data types, including interfaces, and why it is needed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以反思作为本章的开端，这是Go语言的一个高级特性，不是因为这是一个容易的主题，而是因为它将帮助你理解Go如何与不同的数据类型一起工作，包括接口，以及为什么需要它。
- en: You might be wondering how you can find out the names of the fields of a structure
    at execution time. In such cases, you need to use reflection. Apart from enabling
    you to print the fields and the values of a structure, reflection also allows
    you to explore and manipulate unknown structures like the ones created from decoding
    JSON data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如何在运行时找出结构体的字段名称。在这种情况下，你需要使用反射。除了使你能够打印出结构和其值之外，反射还允许你探索和操作未知结构，例如从解码JSON数据创建的结构。
- en: 'The two main questions that I asked myself when I was introduced to reflection
    for the first time were the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次接触反射时，我向自己提出了以下两个主要问题：
- en: Why is reflection included in Go?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么反射被包含在 Go 中？
- en: When should reflection be used?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时应该使用反射？
- en: To answer the first question, reflection allows you to dynamically learn the
    type of an arbitrary object along with information about its structure. Go provides
    the `reflect` package for working with reflection. The `fmt.Println()` function
    is clever enough to understand the data types of its parameters and act accordingly
    because, behind the scenes, the `fmt` package uses reflection to do that.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答第一个问题，反射允许你动态地学习任意对象的类型及其结构信息。Go 提供了 `reflect` 包来处理反射。`fmt.Println()` 函数足够聪明，能够理解其参数的数据类型并相应地行动，因为，在幕后，`fmt`
    包使用反射来完成这项工作。
- en: As far as the second question is concerned, reflection allows you to handle
    and work with data types that do not exist at the time at which you write your
    code but might exist in the future, which is when we use an existing package with
    new user-defined data types—Go functions can accept unknown data types with the
    use of the empty interface. Additionally, reflection might come in handy when
    you have to work with data types that do not implement a common interface and
    therefore have an uncommon or unknown behavior—this does not mean that they have
    bad or erroneous behavior, just uncommon/unusual behavior such as user-defined
    structures.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第二个问题，反射允许你在编写代码时处理和操作那些当时不存在但未来可能存在的数据类型，这就是我们使用带有新用户定义数据类型的现有包的时候——Go 函数可以使用空接口接受未知的数据类型。此外，当你必须处理那些没有实现通用接口且因此具有不常见或未知行为的数据类型时，反射可能很有用——这并不意味着它们有不良或错误的行为，只是不常见或不寻常的行为，例如用户定义的结构体。
- en: Interfaces are covered later in this chapter, so stay tuned for more!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接口将在本章后面进行介绍，所以请继续关注更多内容！
- en: The introduction of generics in Go might make the use of reflection less frequent
    in some cases because, with generics, you can work with different data types more
    easily and without the need to know their exact data types in advance. However,
    nothing beats reflection for fully exploring the structure and the data types
    of a variable. We compare reflection with generics at the end of this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中泛型的引入可能会在某些情况下使反射的使用频率降低，因为，有了泛型，你可以更轻松地处理不同的数据类型，而无需事先知道它们的精确数据类型。然而，对于完全探索变量的结构和数据类型，没有什么能比得上反射。我们将在本章末尾比较反射和泛型。
- en: The most useful parts of the `reflect` package are two data types named `reflect.Value`
    and `reflect.Type`. `reflect.Value` is used for storing values of any type, whereas
    `reflect.Type` is used for representing Go types. There exist two functions named
    `reflect.TypeOf()` and `reflect.ValueOf()` that return `reflect.Type` and `reflect.Value`
    values, respectively. Note that `reflect.TypeOf()` returns the actual type of
    a variable—if we are examining a structure, it returns the name of the structure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect` 包最有用的部分是两个名为 `reflect.Value` 和 `reflect.Type` 的数据类型。`reflect.Value`
    用于存储任何类型的值，而 `reflect.Type` 用于表示 Go 类型。存在两个名为 `reflect.TypeOf()` 和 `reflect.ValueOf()`
    的函数，分别返回 `reflect.Type` 和 `reflect.Value` 值。请注意，`reflect.TypeOf()` 返回变量的实际类型——如果我们正在检查一个结构体，它返回结构体的名称。'
- en: As structures are really important in Go, the `reflect` package offers the `reflect.NumField()`
    method for listing the number of fields in a structure as well as the `Field()`
    method for getting the `reflect.Value` value of a specific field of a structure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结构体在 Go 中非常重要，`reflect` 包提供了 `reflect.NumField()` 方法来列出结构体中的字段数量，以及 `Field()`
    方法来获取结构体特定字段的 `reflect.Value` 值。
- en: 'The `reflect` package also defines the `reflect.Kind` data type, which is used
    for representing the specific data type of a variable: `int`, `struct`, etc. The
    documentation of the `reflect` package lists all possible values of the `reflect.Kind`
    data type. The `Kind()` function returns the kind of a variable.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect` 包还定义了 `reflect.Kind` 数据类型，它用于表示变量的具体数据类型：`int`、`struct` 等。`reflect`
    包的文档列出了 `reflect.Kind` 数据类型的所有可能值。`Kind()` 函数返回变量的类型。'
- en: Last, the `Int()` and `String()` methods return the integer and string value
    of `reflect.Value`, respectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Int()` 和 `String()` 方法分别返回 `reflect.Value` 的整数和字符串值。
- en: Reflection code can look unpleasant and hard to read sometimes. Therefore, according
    to the Go philosophy, you should rarely use reflection unless it is necessary
    because, despite its cleverness, it does not create clean code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 反射代码有时看起来不美观且难以阅读。因此，根据Go哲学，除非必要，否则你应该很少使用反射，因为尽管它很巧妙，但它不会创建干净的代码。
- en: Understanding the internal structure of a Go structure
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Go结构的内部结构
- en: The next utility shows how to use reflection to discover the internal structure
    and fields of a Go structure variable. Type it and save it as `reflection.go`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个实用工具展示了如何使用反射来发现Go结构变量的内部结构和字段。输入它并将其保存为`reflection.go`。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We begin by defining a `Record` structure variable that contains another structure
    value (`Secret{"Mihalis", "Tsoukalos"}`).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个包含另一个结构值（`Secret{"Mihalis", "Tsoukalos"}`）的`Record`结构变量。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This returns the `reflect.Value` of the `A` variable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了`A`变量的`reflect.Value`。
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using `Type()` is how we get the data type of a variable—in this case, variable
    `A`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Type()`是我们获取变量数据类型的方法——在这个例子中，变量`A`。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The previous `for` loop allows the visiting of all fields of a structure and
    the examination of their characteristics.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`for`循环允许访问结构的所有字段并检查它们的特征。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous `fmt.Printf()` statements return the name, the data type, and the
    value of the fields.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`fmt.Printf()`语句返回字段的名称、数据类型和值。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To check the data type of a variable with a string, we need to convert the data
    type into a `string` variable first.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用字符串检查变量的数据类型，我们首先需要将数据类型转换为`string`变量。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also use the internal representation of a data type during checking.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在检查过程中使用数据类型的内部表示。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running `reflection.go` produces the following output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`reflection.go`会产生以下输出：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`main.Record` is the full unique name of the structure as defined by Go—`main`
    is the package name and `Record` is the `struct` name. This happens so that Go
    can differentiate between the elements of different packages.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.Record`是Go定义的结构的全唯一名称——`main`是包名，`Record`是`struct`名。这样Go可以区分不同包的元素。'
- en: The presented code does not modify any values of the structure. If you were
    to make changes to the values of the structure fields, you would use the `Elem()`
    method and pass the structure as a pointer to `ValueOf()`—remember that pointers
    allow you to make changes to actual variables. There exist methods for modifying
    existing values. In our case, we are going to use `SetString()` to modify a `string`
    field and `SetInt()` to modify an `int` field.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的代码没有修改结构的任何值。如果你要修改结构字段的值，你会使用`Elem()`方法并将结构作为指针传递给`ValueOf()`——记住，指针允许你修改实际变量。存在修改现有值的方法。在我们的例子中，我们将使用`SetString()`来修改`string`字段，并使用`SetInt()`来修改`int`字段。
- en: This technique is illustrated in the next subsection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在下一小节中得到了说明。
- en: Changing structure values using reflection
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用反射修改结构值
- en: Learning about the internal structure of a Go structure is handy, but what is
    more practical is being able to change values in the Go structure, which is the
    subject of this subsection. However, keep in mind that this approach is an exception
    and that the vast majority of Go programs should not need to implement this.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Go结构的内部结构很有用，但更实际的是能够修改Go结构中的值，这正是本小节的主题。然而，请注意，这种方法是一个例外，绝大多数Go程序不需要实现这一点。
- en: Type the following Go code and save it as `setValues.go`—it can also be found
    in the GitHub repository of the book inside the `ch05` directory.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下Go代码并将其保存为`setValues.go`——它也可以在书的GitHub仓库中的`ch05`目录下找到。
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`A` is the variable that is being examined in this program.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`A`是本程序中被检查的变量。'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the use of `Elem()` and a pointer to variable `A`, variable `A` can be
    modified if needed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Elem()`和变量`A`的指针，如果需要的话可以修改变量`A`。
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We are using `SetInt()` to modify an integer value (`reflect.Int`) and `SetString()`
    to modify a string value (`reflect.String`). Integer values are set to `-100`
    and string values are set to `Changed!`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`SetInt()`来修改整数值（`reflect.Int`）和`SetString()`来修改字符串值（`reflect.String`）。整数值被设置为`-100`，字符串值被设置为`Changed!`。
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running `setValues.go` creates the following output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`setValues.go`会产生以下输出：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first line of output shows the initial version of `A`, whereas the last
    line shows the final version of `A` with the modified fields. The main use of
    such code is for dynamically changing the values of the fields of a structure
    without knowing the internals of the structure in advance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行显示了 `A` 的初始版本，而最后一行显示了经过修改的字段的最终版本 `A`。这种代码的主要用途是在不知道结构内部结构的情况下，动态地更改结构体字段的值。
- en: The three disadvantages of reflection
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射的三个缺点
- en: 'Without a doubt, reflection is a powerful Go feature. However, as with all
    tools, reflection should be used sparingly for three main reasons:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，反射是 Go 的一项强大功能。然而，与所有工具一样，反射应谨慎使用，主要有三个原因：
- en: The first reason is that extensive use of reflection will make your programs
    hard to read and maintain. A potential solution to this problem is good documentation,
    but developers are notorious for not having the time to write proper documentation.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个原因是过度使用反射会使你的程序难以阅读和维护。解决这个问题的一个潜在方法是良好的文档，但开发者以没有时间编写适当的文档而闻名。
- en: The second reason is that the Go code that uses reflection makes your programs
    slower. Generally speaking, **Go code that works with a particular data type is
    always faster than Go code that uses reflection to dynamically work with any Go
    data type**. Additionally, such dynamic code makes it difficult for tools to refactor
    or analyze your code.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个原因是使用反射的 Go 代码会使你的程序变慢。一般来说，**与特定数据类型工作的 Go 代码总是比使用反射动态处理任何 Go 数据类型的 Go 代码要快**。此外，这种动态代码使得工具难以重构或分析你的代码。
- en: The last reason is that reflection errors cannot be caught at build time and
    are reported at runtime as panics, which means that reflection errors can potentially
    crash your programs. This can happen months or even years after the development
    of a Go program! One solution to this problem is extensive testing before a dangerous
    function call. However, this adds even more Go code to your programs, which makes
    them even slower.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个原因是反射错误无法在构建时捕获，而是在运行时作为恐慌报告，这意味着反射错误可能会潜在地使你的程序崩溃。这可能会在 Go 程序开发后的几个月甚至几年后发生！解决这个问题的一个方法是在危险函数调用之前进行广泛的测试。然而，这会在你的程序中添加更多的
    Go 代码，使它们运行得更慢。
- en: With the disadvantages of reflection in mind, it is important to remember that
    reflection is needed for cases such as JSON and XML serialization, dynamic code
    generation, and dynamic mapping of Go structs to database tables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到反射的缺点，重要的是要记住，反射在处理 JSON 和 XML 序列化、动态代码生成以及动态将 Go 结构体映射到数据库表等情况下是必需的。
- en: Now that we know about reflection and what it can do for us, it is time to begin
    the discussion about type methods, which are necessary for understanding interfaces.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了反射及其能为我们做什么，现在是时候开始讨论类型方法了，这对于理解接口是必要的。
- en: Type methods
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型方法
- en: A **type method** is a *function that is attached to a specific data type*.
    Although type methods (or methods on types) are functions, in reality, they are
    defined and used in a slightly different way.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型方法**是一个*附加到特定数据类型的函数*。尽管类型方法（或类型上的方法）是函数，但实际上，它们的定义和使用方式略有不同。'
- en: The methods on types feature gives some object-oriented capabilities to Go,
    which is very handy, and it’s used extensively in Go. Additionally, interfaces
    require type methods to work.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型特性方法上，Go 语言获得了一些面向对象的能力，这非常方便，并且在 Go 语言中被广泛使用。此外，接口需要类型方法才能工作。
- en: Defining new type methods is as simple as creating new functions, provided that
    you follow certain rules that associate the function with a data type.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 定义新的类型方法就像创建新的函数一样简单，只要你遵循某些规则，将这些函数与数据类型关联起来。
- en: Creating type methods
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类型方法
- en: So, imagine that you want to do calculations with 2x2 matrices. A very natural
    way of implementing that is by defining a new data type and defining type methods
    for adding, subtracting, and multiplying 2x2 matrices using that new data type.
    To make it even more interesting and generic, we are going to create a command
    line utility that accepts the elements of two 2x2 matrices as command line arguments,
    which are eight integer values in total, and performs all three calculations between
    them using the defined type methods.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，想象一下你想用 2x2 矩阵进行计算。实现这一点的非常自然的方式是通过定义一个新的数据类型，并定义类型方法来添加、减去和乘以使用该新数据类型的 2x2
    矩阵。为了使其更加有趣和通用，我们将创建一个命令行实用程序，它接受两个 2x2 矩阵的元素作为命令行参数，总共八个整数值，并使用定义的类型方法在这两者之间执行所有三种计算。
- en: 'By having a data type called `ar2x2`, you can create a type method named `FunctionName`
    for it as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有名为`ar2x2`的数据类型，你可以为它创建一个名为`FunctionName`的类型方法，如下所示：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `(a ar2x2)` part is what makes the `FunctionName()` function a type method
    because it associates `FunctionName()` with the `ar2x2` data type. No other data
    type can use that function. However, you are free to implement `FunctionName()`
    for other data types or as a regular function. If you have an `ar2x2` variable
    named `varAr`, you can invoke `FunctionName()` as `varAr.FunctionName(...)`, which
    looks like selecting the field of a structure variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`(a ar2x2)`这一部分使得`FunctionName()`函数成为一个类型方法，因为它将`FunctionName()`与`ar2x2`数据类型关联起来。其他数据类型无法使用该函数。然而，你可以自由地为其他数据类型或作为常规函数实现`FunctionName()`。如果你有一个名为`varAr`的`ar2x2`变量，你可以像选择结构变量字段一样调用`FunctionName()`，即`varAr.FunctionName(...)`。'
- en: 'You are not obligated to develop type methods if you do not want to unless
    you are dealing with interfaces. Additionally, each type method can be rewritten
    as a regular function. Therefore, `FunctionName()` can be rewritten as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想开发类型方法，除非你正在处理接口，否则你没有义务这样做。此外，每个类型方法都可以重写为常规函数。因此，`FunctionName()`可以重写如下：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Bear in mind that, under the hood, the Go compiler does turn methods into regular
    function calls with the self-value as the first parameter. However, keep in mind
    that **interfaces require the use of type methods to work**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在底层，Go 编译器确实会将方法转换为带有自值的常规函数调用。然而，请注意，**接口需要使用类型方法才能工作**。
- en: The expressions used for selecting a field of a structure or a type method of
    a data type, which would replace the ellipsis after the variable name above, are
    called *selectors*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用于选择结构字段或数据类型的类型方法的表达式，将替换上面变量名后的省略号，被称为*选择器*。
- en: Performing calculations between matrices of a given predefined size is one of
    the rare cases where using an array instead of a slice makes more sense because
    you do not have to modify the size of the matrices. Some people might argue that
    using a slice instead of an array pointer is a better practice—you are allowed
    to use what makes more sense to you and the problem at hand. As a rule of thumb,
    arrays should be preferred to slices when a fixed-size, contiguous block of memory
    is required or when performance is a critical concern. So, it is common to use
    slices for most dynamic collections and arrays for situations where a fixed-size,
    performance-critical structure is needed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定预定义大小的矩阵之间执行计算是使用数组而不是切片更合理的一些罕见情况之一，因为你不需要修改矩阵的大小。有些人可能会争论说，使用切片而不是数组指针是更好的做法——你可以使用对你和当前问题更有意义的方法。一般来说，当需要固定大小的连续内存块或性能是关键问题时，应首选数组。因此，对于大多数动态集合，通常使用切片，而在需要固定大小、性能关键的结构时，使用数组。
- en: Most of the time, the results of a type method are saved in the variable that
    invoked the type method—in order to implement that for the `ar2x2` data type,
    we pass a pointer to the array that invoked the type method, like `func (a *ar2x2)`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，类型方法的输出保存在调用类型方法的变量中——为了为`ar2x2`数据类型实现这一点，我们传递调用类型方法的数组的指针，例如`func (a
    *ar2x2)`。
- en: Value and point receivers
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值接收器和指针接收器
- en: As you already know, a method can be associated with a named type, and the receiver
    of the method can be either a value receiver or a pointer receiver. A value receiver
    is a receiver associated with a method that operates on a copy of the value rather
    than the actual value itself. A pointer receiver is a receiver associated with
    a method that operates directly on the value pointed to by the receiver, rather
    than on a copy of the value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，一个方法可以与一个命名类型关联，方法的接收者可以是值接收器或指针接收器。值接收器是与方法关联的接收器，该方法操作的是值的副本而不是实际的值本身。指针接收器是与方法关联的接收器，该方法直接操作接收器指向的值，而不是值的副本。
- en: The choice between value and pointer receivers has implications for how the
    method behaves, particularly in terms of modifying the underlying value and performance
    considerations. In general, it is recommended to use a value receiver when the
    method does not need to modify the state of the receiver, when working with small,
    immutable types, or for methods that logically belong to the value itself, not
    a specific instance. On the other hand, you might prefer to use a pointer receiver
    when the method needs to modify the state of the receiver, when working with large
    data structures to avoid any copying overhead, or for methods that logically belong
    to a particular instance of the type.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在值接收器和指针接收器之间的选择会影响方法的行为，特别是在修改底层值和性能考虑方面。一般来说，当方法不需要修改接收器的状态时，当处理小型、不可变类型时，或者对于逻辑上属于值本身而不是特定实例的方法时，建议使用值接收器。另一方面，当方法需要修改接收器的状态时，当处理大型数据结构以避免任何复制开销，或者对于逻辑上属于类型的特定实例的方法时，你可能更愿意使用指针接收器。
- en: The next subsection illustrates type methods in action.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节将展示类型方法的应用。
- en: Using type methods
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型方法
- en: This subsection shows the use of type methods using the `ar2x2` data type as
    an example. The `Add()` function and the `Add()` method use the exact same algorithm
    for adding two matrices. The only difference between them is the way they are
    called and the fact that the function returns an array, whereas the method saves
    the result to the calling variable because of the use of a pointer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节以 `ar2x2` 数据类型为例，展示了类型方法的使用。`Add()` 函数和 `Add()` 方法使用完全相同的算法来添加两个矩阵。它们之间的唯一区别是它们的调用方式以及函数返回一个数组，而方法由于使用了指针，将结果保存到调用变量中。
- en: Although adding and subtracting matrices is a straightforward process—you just
    add or subtract each element of the first matrix with the element of the second
    matrix that is located at the same position—matrix multiplication is a more complex
    process. This is the main reason that both addition and subtraction use `for`
    loops, which means that the code can also work with bigger matrices, whereas multiplication
    uses static code that cannot be applied to bigger matrices without major changes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然矩阵的加法和减法是一个简单的过程——你只需将第一个矩阵的每个元素与位于相同位置的第二个矩阵的元素相加或相减——但矩阵乘法是一个更复杂的过程。这是加法和减法都使用
    `for` 循环的主要原因，这意味着代码也可以处理更大的矩阵，而乘法使用的是静态代码，不能在不进行重大更改的情况下应用于更大的矩阵。
- en: If you are defining type methods for a structure, you should make sure that
    the names of the type methods do not conflict with any field name of the structure
    because the Go compiler will reject such ambiguities.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为结构定义类型方法，你应该确保类型方法的名称不与结构的任何字段名称冲突，因为 Go 编译器将拒绝这种歧义。
- en: Type the following code and save it as `methods.go`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码并将其保存为 `methods.go`。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we have a traditional function that adds two `ar2x2` variables and returns
    their result.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个传统的函数，它将两个 `ar2x2` 变量相加并返回它们的和。
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we have a type method named `Add()` that is attached to the `ar2x2` data
    type. The result of the addition is not returned. What happens is that the `ar2x2`
    variable that called the `Add()` method is going to be modified and hold that
    result—this is the reason for using a pointer when defining the type method. If
    you do not want that behavior, you should modify the signature and the implementation
    of the type method to match your needs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为 `Add()` 的类型方法，它附加到 `ar2x2` 数据类型上。加法的结果不会返回。发生的情况是调用 `Add()` 方法的
    `ar2x2` 变量将被修改并保留该结果——这就是为什么在定义类型方法时使用指针的原因。如果你不希望这种行为，你应该修改类型方法的签名和实现以匹配你的需求。
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous method subtracts `ar2x2` `b` from `ar2x2` `a` and the result is
    saved in the `a` variable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法从 `ar2x2` `b` 中减去 `ar2x2` `a`，并将结果保存在 `a` 变量中。
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we are working with small arrays, we do the multiplications without using
    any `for` loops.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理小型数组，所以我们不使用任何 `for` 循环进行乘法。
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `main()` function gets the input and creates two 2x2 matrices. After that,
    it performs the desired calculations with these two matrices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数获取输入并创建两个 2x2 矩阵。之后，它使用这两个矩阵执行所需的计算。'
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We calculate `a+b` using two different ways: using a regular function and using
    a type method. As both `a.Add(b)` and `a.Subtract(a)` change the value of `a`,
    we have to initialize `a` before using it again.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两种不同的方式计算 `a+b`：使用常规函数和使用类型方法。由于 `a.Add(b)` 和 `a.Subtract(a)` 都会改变 `a` 的值，我们必须在使用它之前初始化
    `a`。
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Last, we calculate `a*b` and `b*a` to show that they are different because the
    commutative property does not apply to matrix multiplication.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算 `a*b` 和 `b*a` 来展示它们是不同的，因为交换律不适用于矩阵乘法。
- en: 'Running `methods.go` produces the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `methods.go` 产生以下输出：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The input here is two 2x2 matrices, `[[1 2] [0 0]]` and `[[2 1] [1 1]]`, and
    the output is their calculations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输入是两个 2x2 矩阵，`[[1 2] [0 0]]` 和 `[[2 1] [1 1]]`，输出是它们的计算结果。
- en: Now that we know about type methods, it is time to begin exploring interfaces
    as interfaces cannot be implemented without type methods.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了类型方法，是时候开始探索接口了，因为接口不能在没有类型方法的情况下实现。
- en: Interfaces
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: An interface is a Go mechanism for defining behavior that is implemented using
    a set of methods. Interfaces have a core role in Go and can simplify the code
    of your programs when they have to deal with multiple data types that perform
    the same task—recall that `fmt.Println()` works for almost all data types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是 Go 定义行为的机制，该行为通过一组方法实现。接口在 Go 中起着核心作用，当程序需要处理执行相同任务的多达多个数据类型时，它们可以简化你的程序代码——回想一下
    `fmt.Println()` 几乎适用于所有数据类型。
- en: But remember, interfaces should not be unnecessarily complex. If you decide
    to create your own interfaces, then you should begin with a common behavior that
    you want to be used by multiple data types. Additionally, you should not design
    your programs by defining interfaces. You should start designing your program
    and wait for common behaviors to reveal themselves and then convert those common
    behaviors into interfaces. Last, if the use of interfaces does not make your code
    simpler, consider removing some or all of your interfaces.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，接口不应该过于复杂。如果你决定创建自己的接口，那么你应该从一个你希望多个数据类型使用的共同行为开始。此外，你不应该通过定义接口来设计你的程序。你应该开始设计你的程序，等待共同行为显现出来，然后将这些共同行为转换为接口。最后，如果接口的使用没有使你的代码更简单，考虑移除一些或所有你的接口。
- en: Interfaces define none, a single, or multiple type methods that need to be implemented.
    **As you already know, once you implement the required type methods of an interface,
    that interface is satisfied implicitly**. In simpler terms, once you implement
    the methods of an interface for a given data type, that interface is satisfied
    automatically for that data type.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义了零个、一个或多个需要实现类型方法。**正如你已经知道的，一旦你实现了接口所需的所有类型方法，该接口就隐式满足**。用更简单的话说，一旦你为给定数据类型实现了接口的方法，该接口就自动满足该数据类型。
- en: The empty interface is defined as just `interface{}`. As the empty interface
    has no methods, it means that it is already implemented by all data types. In
    Go generics terms, the empty interface is called `any`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 空接口定义为 `interface{}`。由于空接口没有方法，这意味着它已经被所有数据类型实现。在 Go 泛型术语中，空接口被称为 `any`。
- en: 'In a more formal way, a Go interface type defines (or describes) the behavior
    of other types by specifying a set of methods that need to be implemented to support
    that behavior. For a data type to satisfy an interface, it needs to implement
    all the type methods required by that interface. Therefore, interfaces are abstract
    types that specify a set of methods that need to be implemented so that another
    type can be considered an instance of the interface. So, an interface is two things:
    a set of methods and a data type. Bear in mind that small and well-defined interfaces
    are usually the most popular ones because they can be used in a much larger variety
    of cases.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以更正式的方式来说，Go 接口类型通过指定一组需要实现以支持该行为的方法来定义（或描述）其他类型的行为。为了满足一个接口，数据类型需要实现该接口要求的所有类型方法。因此，接口是抽象类型，它指定了一组需要实现的方法，以便另一个类型可以被考虑为接口的实例。所以，接口是两件事：一组方法和一个数据类型。请记住，小型且定义良好的接口通常是最受欢迎的，因为它们可以在更多的情况下使用。
- en: As a rule of thumb, only create a new interface when you want to share a common
    behavior between two or more concrete data types. This is basically duck typing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，只有当你想在两个或多个具体数据类型之间共享共同行为时才创建新的接口。这基本上是鸭子类型。
- en: The biggest advantage you get from interfaces is that, if needed, you can pass
    a variable of a data type that implements a particular interface to any function
    that expects a parameter of that specific interface, which saves you from having
    to write separate functions for each supported data type. However, Go offers an
    alternative to this with the recent addition of generics.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从接口中获得的最大优势是，如果需要，你可以将实现了特定接口的数据类型的变量传递给任何期望该特定接口参数的函数，这让你免于为每种支持的数据类型编写单独的函数。然而，Go通过最近添加泛型提供了这一点的替代方案。
- en: Interfaces can also be used to provide a kind of polymorphism in Go, which is
    an object-oriented concept. *Polymorphism* offers a way of accessing objects of
    different types in the same uniform way when they share a common behavior.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以在Go中提供一种多态性，这是一种面向对象的概念。*多态性*提供了一种方式，当不同类型的对象具有共同的行为时，可以以相同统一的方式访问这些对象。
- en: Last, interfaces can be used for composition. In practice, this means that you
    can combine existing interfaces and create new ones that offer the combined behavior
    of the interfaces that were brought together. The next figure shows interface
    composition in a graphical way.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，接口还可以用于组合。在实践中，这意味着你可以组合现有的接口，创建新的接口，这些新接口提供了组合接口的行为。下一个图示以图形方式展示了接口组合。
- en: '![](img/B21003_05_01.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21003_05_01.png)'
- en: 'Figure 5.1: Interface composition'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：接口组合
- en: Put simply, the previous figure illustrates that because of its definition,
    satisfying interface `ABC` requires satisfying `InterfaceA`, `InterfaceB`, and
    `InterfaceC`. Additionally, any `ABC` variable can be used instead of an `InterfaceA`
    variable, an `InterfaceB` variable, or an `InterfaceC` variable because it supports
    all these three behaviors. Last, only `ABC` variables can be used where an `ABC`
    variable is expected. There is nothing prohibiting you from including additional
    methods in the definition of the `ABC` interface if the combination of existing
    interfaces does not describe the desired behavior accurately.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，前一个图示说明了由于定义的原因，要满足接口`ABC`，需要满足`InterfaceA`、`InterfaceB`和`InterfaceC`。此外，任何`ABC`变量都可以用来代替`InterfaceA`变量、`InterfaceB`变量或`InterfaceC`变量，因为它支持这三种行为。最后，只有`ABC`变量可以在期望`ABC`变量的地方使用。如果现有接口的组合不能准确描述所需的行为，你可以在`ABC`接口的定义中包含额外的函数，这并不会受到任何限制。
- en: When you combine existing interfaces, it is better that the interfaces do not
    contain methods with the same name.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当组合现有接口时，最好这些接口不包含具有相同名称的方法。
- en: What you should keep in mind is that there is no need for an interface to be
    impressive and require the implementation of a large number of methods. In fact,
    the fewer methods an interface has, the more generic and widely used it is going
    to be, which increases its usefulness and therefore its usage.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住的是，接口不需要令人印象深刻，也不需要实现大量的方法。实际上，接口拥有的方法越少，它就越通用、越广泛使用，这增加了它的有用性，因此也增加了它的使用频率。
- en: The subsection that follows illustrates the use of `sort.Interface`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节说明了`sort.Interface`的使用。
- en: The sort.Interface interface
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`sort.Interface`接口'
- en: 'The `sort` package contains an interface named `sort.Interface` that allows
    you to sort slices according to your needs and your data, provided that you implement
    `sort.Interface` for the custom data types stored in your slices. The `sort` package
    defines the `sort.Interface` as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`包包含一个名为`sort.Interface`的接口，它允许你根据需要和你的数据对切片进行排序，前提是你为存储在你切片中的自定义数据类型实现了`sort.Interface`。`sort`包定义`sort.Interface`如下：'
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What we can understand from the definition of `sort.Interface` is that in order
    to implement `sort.Interface`, we need to implement the following three type methods:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从`sort.Interface`的定义中我们可以理解，为了实现`sort.Interface`，我们需要实现以下三个类型方法：
- en: '`Len() int`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Len() int`'
- en: '`Less(i, j int) bool`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Less(i, j int) bool`'
- en: '`Swap(i, j int)`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Swap(i, j int)`'
- en: The `Len()` method returns the length of the slice that will be sorted and helps
    the interface to process all slice elements, whereas the `Less()` method, which
    compares and sorts elements in pairs, defines how elements, are going to be compared
    and therefore sorted. The return value of `Less()` is `bool`, which means that
    `Less()` only cares about whether the element at index `i` is bigger or not than
    the element at index `j` in the way that the two elements are being compared.
    Last, the `Swap()` method is used for swapping two elements of the slice, which
    is required for the sorting algorithm to work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Len()` 方法返回将要排序的切片的长度，并帮助接口处理所有切片元素，而 `Less()` 方法，它比较并成对排序元素，定义了元素如何进行比较和排序。`Less()`
    的返回值是 `bool`，这意味着 `Less()` 只关心索引 `i` 的元素是否大于索引 `j` 的元素，以及这两个元素是如何进行比较的。最后，`Swap()`
    方法用于交换切片中的两个元素，这对于排序算法的正常工作是必需的。'
- en: The following code, which can be found in `sort.go`, illustrates the use of
    `sort.Interface`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码，可以在 `sort.go` 中找到，说明了 `sort.Interface` 的使用。
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Person` structure includes a field named `F3` that is of the `Size` data
    type, which is also a structure.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person` 结构体包含一个名为 `F3` 的字段，其数据类型为 `Size`，它也是一个结构体。'
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You need to have a slice because all sorting operations work on slices. It is
    for this slice, which should be a new data type that in this case is called `Personslice`,
    that you are going to implement the three type methods of the `sort.Interface`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个切片，因为所有排序操作都是在切片上进行的。这就是你将要实现 `sort.Interface` 的三个类型方法的切片，它应该是一个新的数据类型，在这种情况下称为
    `Personslice`。
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here is the implementation of `Len()` for the `Personslice` data type. It is
    usually that simple.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Personslice` 数据类型的 `Len()` 的实现。这通常很简单。
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here is the implementation of `Less()` for the `Personslice` data type. This
    method defines the way elements get sorted. In this case, by using a field of
    the embedded data structure (`F3.F1`).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Personslice` 数据类型的 `Less()` 的实现。该方法定义了元素排序的方式。在这种情况下，通过使用嵌入的数据结构的一个字段（`F3.F1`）。
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is the implementation of the `Swap()` type method that defines the way
    to swap slice elements during sorting. It is usually that simple.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Swap()` 类型方法的实现，它定义了在排序过程中交换切片元素的方式。这通常很简单。
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once you have implemented `sort.Interface`, you are going to see that `sort.Reverse()`,
    which is used for reverse sorting your slice, works automatically.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了 `sort.Interface`，你就会看到 `sort.Reverse()`，它是用于反转排序切片的，会自动工作。
- en: 'Running `sort.go` generates the following output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `sort.go` 生成以下输出：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first line shows the elements of the slice as initially stored. The second
    line shows the sorted version, whereas the last line shows the reverse sorted
    version.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行显示了切片最初存储的元素。第二行显示了排序后的版本，而最后一行显示了反转排序后的版本。
- en: Let us now present the handy empty interface.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来介绍方便的空接口。
- en: The empty interface
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空接口
- en: As mentioned before, the empty interface is defined as just `interface{}` and
    is already implemented by all data types. Therefore, variables of any data type
    can be put in the place of a parameter of the empty interface data type.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，空接口被定义为仅 `interface{}`，并且所有数据类型都已经实现了它。因此，任何数据类型的变量都可以放在空接口数据类型参数的位置。
- en: Therefore, a function with an `interface{}` parameter can accept variables of
    any data type in this place. However, if you intend to work with `interface{}`
    function parameters without examining their data type inside the function, you
    should process them with statements that work on all data types; otherwise, your
    code may crash or misbehave. Alternatively, you can use generics with proper constraints
    to avoid any undesired effects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，具有 `interface{}` 参数的函数可以在这个位置接受任何数据类型的变量。然而，如果你打算在函数内部不检查其数据类型的情况下使用 `interface{}`
    函数参数，你应该使用适用于所有数据类型的语句来处理它们；否则，你的代码可能会崩溃或出现异常行为。或者，你可以使用具有适当约束的泛型来避免任何不期望的效果。
- en: The program that follows defines two structures named `S1` and `S2` but just
    a single function named `Print()` for printing any of them. This is allowed because
    `Print()` requires an `interface{}` parameter that can accept both `S1` and `S2`
    variables. The `fmt.Println(s)` statement inside `Print()` can work with both
    `S1` and `S2`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的程序定义了两个名为 `S1` 和 `S2` 的结构体，但只有一个名为 `Print()` 的函数用于打印它们中的任何一个。这是允许的，因为 `Print()`
    需要一个 `interface{}` 参数，它可以接受 `S1` 和 `S2` 变量。`Print()` 中的 `fmt.Println(s)` 语句可以与
    `S1` 和 `S2` 一起工作。
- en: If you create a function that accepts one or more `interface{}` parameters and
    you run a statement that can only be applied to a limited number of data types,
    things will not work out well. As an example, not all `interface{}` parameters
    can be multiplied by 5 or be used in `fmt.Printf()` with the `%d` control string.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个接受一个或多个 `interface{}` 参数的函数，并且运行只能应用于有限数据类型的语句，事情可能不会顺利。作为一个例子，并不是所有的
    `interface{}` 参数都可以乘以 5 或使用 `%d` 控制字符串在 `fmt.Printf()` 中使用。
- en: 'The source code of `empty.go` is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`empty.go` 的源代码如下：'
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Although `v1` and `v2` are of different data types, `Print()` can work with
    both of them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `v1` 和 `v2` 的数据类型不同，但 `Print()` 可以同时处理它们。
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`Print()` can also work with integers and strings.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print()` 也可以与整数和字符串一起使用。'
- en: 'Running `empty.go` produces the following output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `empty.go` 产生以下输出：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using the empty interface is easy as soon as you realize that you can pass any
    type of variable in the place of an `interface{}` parameter and you can return
    any data type as an `interface{}` return value. However, with great power comes
    great responsibility—you should be very careful with `interface{}` parameters
    and their return values because, in order to use their real values, you have to
    be sure about their underlying data type. We are going to discuss this in the
    next section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你意识到你可以在 `interface{}` 参数的位置传递任何类型的变量，并且你可以将任何数据类型作为 `interface{}` 返回值返回，使用空接口就变得简单了。然而，权力越大，责任越大——你应该非常小心地处理
    `interface{}` 参数及其返回值，因为，为了使用它们的实际值，你必须确定它们的底层数据类型。我们将在下一节讨论这个问题。
- en: Type assertions and type switches
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型断言和类型选择
- en: A *type assertion* is a mechanism for working with the underlying concrete value
    of an interface. This mainly happens because interfaces are virtual data types
    without their own values—interfaces just define behavior and do not hold data
    of their own. But what happens when you do not know the data type before attempting
    a type assertion? How can you differentiate between the supported data types and
    the unsupported ones? How can you choose a different action for each supported
    data type? The answer is by using type switches. Type switches use `switch` blocks
    for data types and allow you to differentiate between type assertion values, which
    are data types, and process each data type the way you want. Additionally, **to
    use the empty interface in type switches, you need to use type assertions**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型断言* 是一种处理接口底层具体值的机制。这主要是因为接口是虚拟数据类型，没有它们自己的值——接口只定义行为，不持有自己的数据。但是，在你尝试类型断言之前不知道数据类型会发生什么？你如何区分支持的数据类型和不支持的数据类型？你如何为每个支持的数据类型选择不同的操作？答案是使用类型选择。类型选择使用
    `switch` 块来处理数据类型，并允许你区分类型断言值，即数据类型，并以你想要的方式处理每个数据类型。此外，**要在类型选择中使用空接口，你需要使用类型断言**。'
- en: You can have type switches for all kinds of interfaces and data types in general.
    What is really important is to remember that the order of the `case` clauses in
    a `switch` statement is important as only the first match is going to be executed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为所有类型的接口和数据类型使用类型选择。真正重要的是要记住，`switch` 语句中 `case` 子句的顺序很重要，因为只有第一个匹配将会被执行。
- en: Therefore, the real work begins once you enter the function because this is
    where you need to define the supported data types and the actions that take place
    for each supported data type.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦你进入函数，真正的任务就开始了，因为这是你需要定义支持的数据类型以及每个支持的数据类型所采取的操作的地方。
- en: Type assertions use the `x.(T)` notation, where `x` is an interface type and
    `T` is a type, and help you extract the value that is hidden behind the empty
    interface. For a type assertion to work, `x` should not be `nil` and the dynamic
    type of `x` should be identical to the `T` type.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言使用 `x.(T)` 语法，其中 `x` 是接口类型，`T` 是类型，并帮助你提取隐藏在空接口背后的值。为了使类型断言生效，`x` 应该不是 `nil`，并且
    `x` 的动态类型应该与 `T` 类型相同。
- en: The following code can be found in `typeSwitch.go`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以在 `typeSwitch.go` 中找到。
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is a type switch with direct support for the `Secret` and `Entry` data
    types only. The `default` case handles the remaining data types.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只直接支持 `Secret` 和 `Entry` 数据类型的类型选择。`default` 情况处理剩余的数据类型。
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `Learn()` function prints the data type of its input parameter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Learn()` 函数打印其输入参数的数据类型。'
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last part of the code calls the desired functions to explore variable `A`.
    Running `typeSwitch.go` produces the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分调用了所需的函数来探索变量 `A`。运行 `typeSwitch.go` 产生以下输出：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, we have managed to execute different code based on the data
    type of the variable passed to `TestStruct()` and `Learn()`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经成功根据传递给`TestStruct()`和`Learn()`的变量的数据类型执行了不同的代码。
- en: 'Strictly speaking, type assertions allow you to perform two main tasks. The
    first task is checking whether an interface value keeps a particular type. When
    used this way, a type assertion returns two values: the underlying value and a
    `bool` value. The underlying value is what you might want to use. However, it
    is the value of the `bool` variable that tells you whether the type assertion
    was successful or not and, therefore, whether you can use the underlying value
    or not. For example, checking whether a variable named `aVar` is of the `int`
    type requires the use of the `aVar.(int)` notation, which returns two values.
    If successful, it returns the real `int` value of `aVar` and `true`. Otherwise,
    it returns `false` as the second value, which means that the type assertion was
    not successful and that the real value could not be extracted. And the second
    task is using the concrete value stored in an interface or assigning it to a new
    variable. This means that if there is a `float64` variable in an interface, a
    type assertion allows you to get that value.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，类型断言允许你执行两个主要任务。第一个任务是检查接口值是否保持特定的类型。当这样使用时，类型断言返回两个值：底层值和一个`bool`值。底层值可能是你想要使用的。然而，是`bool`变量的值告诉你类型断言是否成功，因此，你是否可以使用底层值。例如，检查名为`aVar`的变量是否为`int`类型需要使用`aVar.(int)`的表示法，它返回两个值。如果成功，它返回`aVar`的实际`int`值和`true`。否则，它返回第二个值为`false`，这意味着类型断言没有成功，实际值无法提取。第二个任务是使用接口中存储的具体值或将它赋给新变量。这意味着如果接口中有一个`float64`变量，类型断言允许你获取该值。
- en: The functionality offered by the `reflect` package helps Go identify the underlying
    data type and the real value of an `interface{}` variable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect`包提供的功能帮助Go识别接口变量的底层数据类型和实际值。'
- en: 'So far, we have seen a variation of the first case where we extract the data
    type stored in an empty interface variable. Now, we are going to learn how to
    extract the real value stored in an empty interface variable. As already explained,
    trying to extract the concrete value from an interface using a type assertion
    can have one of the following two outcomes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了第一种情况的变体，其中我们从空接口变量中提取了存储的数据类型。现在，我们将学习如何从空接口变量中提取存储的实际值。正如之前解释的那样，尝试使用类型断言从接口中提取具体值可能有两种结果：
- en: If you use the correct concrete data type, you get the underlying value without
    any issues.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用正确的具体数据类型，你可以无任何问题地获取底层值。
- en: If you use an incorrect concrete data type, your program will panic.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用不正确的具体数据类型，你的程序将会崩溃。
- en: All these are illustrated in `assertions.go`, which contains the next code as
    well as lots of code comments that explain the process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在`assertions.go`中得到了展示，其中还包含了下一行代码以及大量的代码注释，解释了整个过程。
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `returnNumber()` function returns an `int` value that is **wrapped in an
    empty interface**.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`returnNumber()`函数返回一个被**空接口**包裹的`int`类型值。'
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the previous code, we get the `int` value wrapped in an empty interface variable
    (`anInt`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们得到了被空接口变量（`anInt`）包裹的`int`值。
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The last statement panics the program because the `anInt` variable does not
    hold a `bool` value. Running `assertions.go` generates the following output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句会导致程序崩溃，因为`anInt`变量不包含`bool`类型的值。运行`assertions.go`会生成以下输出：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The reason for the panic is written onscreen: `panic: interface conversion:
    interface {} is int, not bool`. What else can the Go compiler do to help you?'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '崩溃的原因会显示在屏幕上：`panic: interface conversion: interface {} is int, not bool`。Go编译器还能做些什么来帮助你？'
- en: Next, we discuss the `map[string]interface{}` map and its use.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论`map[string]interface{}`映射及其用法。
- en: The map[string]interface{} map
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`map[string]interface{}`映射'
- en: You have a utility that processes its command line arguments; if everything
    goes as expected, then you get the supported types of command line arguments and
    everything goes smoothly. But what happens when something unexpected occurs? In
    that case, the `map[string]interface{}` map is here to help, and this subsection
    shows how! This is just one of the cases where the handy `map[string]interface{}`
    map can be used.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个处理其命令行参数的实用程序；如果一切如预期进行，那么您将得到支持的命令行参数类型，一切都会顺利。但是，当发生意外情况时会发生什么？在这种情况下，`map[string]interface{}`映射就在这里帮助，本节将展示如何使用！这只是`map[string]interface{}`映射方便之处的一个例子。
- en: Remember that the biggest advantage you get from using a `map[string]interface{}`
    map, or any map that stores an `interface{}` value in general, is that you still
    have your data in its original state and data type. If you use `map[string]string`
    instead, or anything similar, then any data you have is going to be converted
    into a string, which means that you are going to lose information about the original
    data type and the structure of the data you are storing in the map.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，您从使用`map[string]interface{}`映射或任何存储`interface{}`值的映射中获得的最大优势是，您仍然拥有您数据在其原始状态和数据类型。如果您使用`map[string]string`或类似的东西，那么您拥有的任何数据都将被转换为字符串，这意味着您将失去有关原始数据类型和您在映射中存储的数据结构的任何信息。
- en: 'Nowadays, web services work by exchanging JSON records. If you get a JSON record
    in an anticipated format, then you can process it as expected and everything will
    be fine. However, there are times when you might get an erroneous record or a
    record in an unsupported JSON format. In these cases, using `map[string]interface{}`
    for storing these unknown JSON records (arbitrary data) is a good choice because
    `map[string]interface{}` is good at storing JSON records of unknown types. We
    are going to illustrate that using a utility named `mapEmpty.go` that processes
    arbitrary JSON records given as command line arguments. We process the input JSON
    record in two ways that are similar but not identical. There is no real difference
    between the `exploreMap()` and `typeSwitch()` functions apart from the fact that
    `typeSwitch()` generates a much richer output. The code of `mapEmpty.go` is as
    follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，网络服务通过交换JSON记录来工作。如果您以预期的格式收到一个JSON记录，那么您可以按预期处理它，一切都会顺利。然而，有时您可能会收到一个错误的记录或一个不支持的JSON格式的记录。在这些情况下，使用`map[string]interface{}`来存储这些未知的JSON记录（任意数据）是一个不错的选择，因为`map[string]interface{}`擅长存储未知类型的JSON记录。我们将使用名为`mapEmpty.go`的实用程序来展示这一点，该实用程序处理作为命令行参数给出的任意JSON记录。我们以两种相似但不相同的方式处理输入的JSON记录。`exploreMap()`和`typeSwitch()`函数之间没有真正的区别，除了`typeSwitch()`生成更丰富的输出之外。`mapEmpty.go`的代码如下：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This global variable holds the default value of `JSONrecord`, in case there
    is no user input.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个全局变量持有`JSONrecord`的默认值，以防没有用户输入。
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `typeSwitch()` function uses a type switch for differentiating between the
    values in its input map. If a map is found, then we recursively call `typeSwitch()`
    on the new map in order to examine it even more. The `for` loop allows you to
    examine all the elements of the `map[string]interface{}` map.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeSwitch()`函数使用类型选择来区分其输入映射中的值。如果找到一个映射，那么我们将递归地调用`typeSwitch()`来检查新的映射，以便更深入地检查它。`for`循环允许您检查`map[string]interface{}`映射的所有元素。'
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `exploreMap()` function inspects the contents of its input map. If a map
    is found, then we call `exploreMap()` on the new map recursively in order to examine
    it on its own.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`exploreMap()`函数检查其输入映射的内容。如果找到一个映射，那么我们将递归地调用`exploreMap()`来检查新的映射，以便单独检查它。'
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you will learn in *Chapter 7*, *Telling a UNIX System What To Do*, `json.Unmarshal()`
    processes JSON data and converts it into a Go value. Although this value is usually
    a Go structure, in this case, we are using a map as specified by the `map[string]interface{}`
    variable. Strictly speaking, the second parameter of `json.Unmarshal()` is of
    the empty interface data type, which means that its data type can be anything.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如您将在**第7章**中学习的，**“告诉UNIX系统做什么”**，`json.Unmarshal()`处理JSON数据并将其转换为Go值。尽管这个值通常是Go结构体，但在这种情况下，我们使用`map[string]interface{}`变量指定的映射。严格来说，`json.Unmarshal()`的第二个参数是空接口数据类型，这意味着它的数据类型可以是任何类型。
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`map[string]interface{}` is extremely handy for storing JSON records when you
    do not know their schema in advance. In other words, `map[string]interface{}`
    is good at **storing arbitrary JSON data of unknown schema**.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当你事先不知道其模式时，`map[string]interface{}` 非常方便用于存储 JSON 记录。换句话说，`map[string]interface{}`
    擅长**存储未知模式的任意 JSON 数据**。
- en: 'Running `mapEmpty.go` produces the following output—bear in mind that you might
    see a different output since maps do not guarantee order:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `mapEmpty.go` 产生以下输出——请注意，你可能看到不同的输出，因为映射不保证顺序：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first run is without any command line parameters, which means that the utility
    uses the default value of `JSONrecord` and therefore outputs the hardcoded data.
    The other two executions use user-specified data. First, valid data, and then
    data that does not represent a valid JSON record. The error message in the third
    execution is generated by `json.Unmarshal()` as it cannot understand the schema
    of the erroneous JSON record.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行时没有任何命令行参数，这意味着工具使用了 `JSONrecord` 的默认值，因此输出了硬编码的数据。其他两次执行使用用户指定的数据。首先，有效数据，然后是表示无效
    JSON 记录的数据。第三次执行的错误信息是由 `json.Unmarshal()` 生成的，因为它无法理解错误 JSON 记录的模式。
- en: The error data type
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误数据类型
- en: 'As promised, we are revisiting the `error` data type because it is an interface
    defined as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，我们正在重新审视 `error` 数据类型，因为它是一个如下定义的接口：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, in order to satisfy the `error` interface, you just need to implement the
    `Error()` string type method. This does not change the way we use errors to find
    out whether the execution of a function or method was successful or not but shows
    how important interfaces are in Go as they are used transparently all the time.
    However, the crucial question is when you should implement the `error` interface
    on your own instead of using the default one. The answer to that question is when
    you want to give more context to an error condition.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了满足 `error` 接口，你只需要实现 `Error()` 字符串类型方法。这并不会改变我们使用错误来确定函数或方法执行是否成功的方式，但它显示了接口在
    Go 中的重要性，因为它们始终被透明地使用。然而，关键问题是当你应该自己实现 `error` 接口而不是使用默认接口时。这个问题的答案是当你想要给错误条件提供更多上下文时。
- en: Now, let us talk about the `error` interface in a more practical situation.
    When there is nothing more to read from a file, Go returns an `io.EOF` error,
    which, strictly speaking, is not an error condition but a logical part of reading
    a file. If a file is totally empty, you still get `io.EOF` when you try to read
    it for the first time. However, this might cause problems in some situations,
    and you might need to have a way of differentiating between a totally empty file
    and a file that has been read fully and there is nothing more to read. One way
    of dealing with that issue is with the help of the `error` interface.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在更实际的情况下讨论 `error` 接口。当没有更多内容可以读取文件时，Go 返回一个 `io.EOF` 错误，严格来说，这并不是一个错误条件，而是读取文件逻辑的一部分。如果文件完全为空，当你第一次尝试读取它时，你仍然会得到
    `io.EOF`。然而，这可能在某些情况下引起问题，你可能需要有一种方法来区分一个完全为空的文件和一个已经完全读取且没有更多内容可以读取的文件。处理这个问题的方法之一是借助
    `error` 接口。
- en: The code example that is presented here is connected to file I/O. Putting it
    here might generate some questions about reading files in Go—however, I feel that
    this is the appropriate place to put it because it is connected to errors and
    error handling more than it is connected to file reading in Go.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的代码示例与文件 I/O 相关。将其放在这里可能会产生一些关于 Go 中读取文件的问题——然而，我觉得这是放置它的合适位置，因为它与错误和错误处理比与
    Go 中的文件读取更相关。
- en: 'The code of `errorInt.go` without the package and `import` blocks is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`errorInt.go` 代码块中，没有包含包和 `import` 块的内容如下：'
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`emptyFile` is a new data type that is used in the program.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`emptyFile` 是程序中使用的新数据类型。'
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the implementation of the `error` interface for `emptyFile`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `emptyFile` 的 `error` 接口实现。
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is a type assertion for getting an `emptyFile` structure from the `error`
    variable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类型断言，用于从 `error` 变量获取 `emptyFile` 结构。
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is a method for checking whether a file is empty or not. The `if` condition
    translates as: If you have read zero bytes (`v.Read == 0`) and you have reached
    the end of the file (`v.Ended == true`), then the file is empty.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个检查文件是否为空的方法。`if` 条件翻译为：如果你已经读取了零字节（`v.Read == 0`）并且你已经到达了文件的末尾（`v.Ended
    == true`），那么文件是空的。
- en: If you want to deal with multiple `error` variables, you should add a type switch
    to the `isFileEmpty()` function after the type assertion.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要处理多个 `error` 变量，你应该在类型断言之后向 `isFileEmpty()` 函数添加一个类型选择。
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We read the input file line by line—you are going to learn more about file I/O
    in *Chapter 7*, *Telling a UNIX System What to Do*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们逐行读取输入文件——你将在 *第 7 章*，*告诉 UNIX 系统做什么* 中了解更多关于文件 I/O 的内容。
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If we have reached the end of a file (`io.EOF`) and we have read zero characters,
    then we are dealing with an empty file. This kind of context is added to the `emptyFile`
    structure and returned as an error value.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到达了文件末尾 (`io.EOF`) 并且我们读取了零个字符，那么我们正在处理一个空文件。这种上下文被添加到 `emptyFile` 结构中，并作为错误值返回。
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is where we check the error message of the `readFile()` function. The order
    we do the checking in is important because only the first match is executed. **This
    means that we must go from more specific cases to more generic ones**.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们检查 `readFile()` 函数的错误信息的地方。我们检查的顺序很重要，因为只有第一个匹配项会被执行。**这意味着我们必须从更具体的案例到更通用的案例**。
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Running `errorInt.go` produces the following output—your output might differ:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `errorInt.go` 产生以下输出——你的输出可能会有所不同：
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The first file (`/etc/hosts`) was read without any issues, whereas the second
    file (`/tmp/doesNotExist`) could not be found. The third file (`/tmp/empty`) was
    there but we did not have the required file permissions to read it, whereas the
    fourth file (`/tmp`) was, in reality, a directory. The last file (`/tmp/Empty.txt`)
    was there but was empty, which is the error situation that we wanted to catch
    in the first place.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个文件 (`/etc/hosts`) 读取时没有问题，而第二个文件 (`/tmp/doesNotExist`) 找不到。第三个文件 (`/tmp/empty`)
    存在，但我们没有读取所需的文件权限，而第四个文件 (`/tmp`) 实际上是一个目录。最后一个文件 (`/tmp/Empty.txt`) 存在，但为空，这是我们最初想要捕获的错误情况。
- en: Writing your own interfaces
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写你自己的接口
- en: In this section, we are going to learn how to write our own interfaces. Creating
    your own interfaces is easy. For reasons of simplicity, we include our own interface
    in the `main` package. However, this is rarely the case as we usually want to
    share our interfaces, which means that interfaces are usually included in Go packages
    other than `main`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写我们自己的接口。创建自己的接口很容易。出于简单起见，我们将我们的接口包含在 `main` 包中。然而，这种情况很少见，因为我们通常希望共享我们的接口，这意味着接口通常包含在
    Go 包的 `main` 之外。
- en: The following code excerpt defines a new interface.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段定义了一个新的接口。
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This interface has the following properties:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口具有以下属性：
- en: It is called `Shape2D`.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被称为 `Shape2D`。
- en: It requires the implementation of a single method named `Perimeter()` that returns
    a `float64` value.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要实现一个名为 `Perimeter()` 的单个方法，该方法返回一个 `float64` 值。
- en: Apart from being user-defined, there is nothing special about that interface
    compared to the built-in Go interfaces—you can use it as you do all other existing
    interfaces. So, in order for a data type to satisfy the `Shape2D` interface, it
    needs to implement a type method named `Perimeter()` that returns a `float64`
    value.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与内置的 Go 接口相比，该接口除了是用户定义之外，没有其他特殊之处——你可以像使用所有其他现有接口一样使用它。因此，为了使一个数据类型满足 `Shape2D`
    接口，它需要实现一个名为 `Perimeter()` 的类型方法，该方法返回一个 `float64` 值。
- en: Using a Go interface
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Go 接口
- en: The code that follows presents the simplest way of using an interface, which
    is by calling its method directly, as if it were a function, to get a result.
    Although this is allowed, it is rarely the case as we usually create functions
    that accept interface parameters in order for these functions to be able to work
    with multiple data types.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了使用接口的最简单方式，即直接调用其方法，就像调用函数一样，以获取结果。虽然这是允许的，但这种情况很少见，因为我们通常创建接受接口参数的函数，以便这些函数能够与多种数据类型一起工作。
- en: The code uses a handy technique for quickly finding out whether a given variable
    is of a given data type that was presented earlier in `assertions.go`. In this
    case, we examine whether a variable is of the `Shape2D` interface by using the
    `interface{}(a).(Shape2D)` notation, where `a` is the variable that is being examined
    and `Shape2D` is the data type against the variable being checked.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用了一种方便的技术，可以快速找出给定变量是否为之前在 `assertions.go` 中展示的给定数据类型。在这种情况下，我们通过使用 `interface{}(a).(Shape2D)`
    语法来检查变量是否为 `Shape2D` 接口，其中 `a` 是正在检查的变量，而 `Shape2D` 是正在检查的变量数据类型。
- en: 'The next program is called `Shape2D.go`—its most interesting parts are the
    following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个程序被称为 `Shape2D.go`——其最有趣的部分如下：
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is the definition of the `Shape2D` interface that requires the implementation
    of the `Perimeter()` type method.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Shape2D`接口的定义，它要求实现`Perimeter()`类型方法。
- en: '[PRE61]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is where the `circle` type implements the `Shape2D` interface with the
    implementation of the `Perimeter()` type method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`circle`类型通过实现`Perimeter()`类型方法来实现`Shape2D`接口的地方。
- en: '[PRE62]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As stated before, the `interface{}(a).(Shape2D)` notation checks whether the
    `a` variable satisfies the `Shape2D` interface without using its underlying value
    (`circle{R: 1.5}`).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '如前所述，`interface{}(a).(Shape2D)`表示法检查`a`变量是否满足`Shape2D`接口，而不使用其底层值（`circle{R:
    1.5}`）。'
- en: 'Running `Shape2D.go` creates the following output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`Shape2D.go`会生成以下输出：
- en: '[PRE63]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Object-oriented programming in Go
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go语言中的面向对象编程
- en: As Go does not support all object-oriented features, it cannot replace an object-oriented
    programming language fully. However, it can mimic some object-oriented concepts.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go不支持所有面向对象特性，它不能完全替代面向对象编程语言。然而，它可以模仿一些面向对象的概念。
- en: First, a Go structure with its type methods is like an object with its methods.
    Second, interfaces are like abstract data types that define behaviors and objects
    of the same class, which is similar to polymorphism. Third, Go supports encapsulation,
    which means it supports hiding data and functions from the user by making them
    private to the structure and the current Go package. Last, combining interfaces
    and structures is like composition in object-oriented terminology.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个具有其类型方法的Go结构体就像一个具有其方法的对象。其次，接口就像定义行为和同一类对象的抽象数据类型，这与多态类似。第三，Go支持封装，这意味着它通过将数据和方法设置为结构体和当前Go包的私有来隐藏数据和方法，从而支持隐藏数据和方法。最后，接口和结构的组合在面向对象术语中类似于组合。
- en: If you really want to develop applications using the object-oriented methodology,
    then choosing Go might not be your best option. As I am not really into Java,
    I would suggest looking at C++ or Python instead. The general rule here is to
    choose the best tool for your job.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想使用面向对象的方法开发应用程序，那么选择Go可能不是你的最佳选择。由于我对Java并不真正感兴趣，我建议你看看C++或Python。这里的通用规则是选择最适合你工作的工具。
- en: You have already seen some of these points earlier in this chapter—the next
    chapter discusses how to define private fields and functions. The example that
    follows, which is named `objO.go`, illustrates composition and polymorphism as
    well as embedding an anonymous structure into an existing one to get all its fields.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在本章前面看到了一些这些点——下一章将讨论如何定义私有字段和函数。接下来的例子，命名为`objO.go`，展示了组合和多态，以及将匿名结构体嵌入现有结构体以获取所有字段。
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `IntC` interface combines interfaces `IntA` and `IntB`. If you implement
    `IntA` and `IntB` for a data type, then this data type implicitly satisfies `IntC`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntC`接口结合了`IntA`和`IntB`接口。如果你为数据类型实现了`IntA`和`IntB`，那么这个数据类型就隐式地满足`IntC`。'
- en: '[PRE65]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This structure has two fields named `A` and `B` that are of the `a` and `b`
    data types, respectively.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构有两个字段，分别命名为`A`和`B`，它们的类型分别是`a`和`b`。
- en: '[PRE66]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This function works with data types that satisfy the `IntA` interface.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数与满足`IntA`接口的数据类型一起工作。
- en: '[PRE67]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Structure `c` satisfies `IntA` as it implements `foo()`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 结构`c`通过实现`foo()`满足`IntA`。
- en: '[PRE68]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now, structure `c` satisfies `IntB`. As structure `c` satisfies both `IntA`
    and `IntB`, it implicitly satisfies `IntC`, which is a composition of the `IntA`
    and `IntB` interfaces.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结构`c`满足`IntB`。由于结构`c`同时满足`IntA`和`IntB`，它隐式地满足`IntC`，这是`IntA`和`IntB`接口的组合。
- en: '[PRE69]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This new structure uses an anonymous structure (`a`), which means that it gets
    the fields of that anonymous structure.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的结构使用了一个匿名结构体（`a`），这意味着它获取了该匿名结构体的字段。
- en: '[PRE70]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we define a `c` variable that is composed of an `a` structure and a `b`
    structure.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个由`a`结构和`b`结构组成的`c`变量。
- en: '[PRE71]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, we access a method of the `a` structure (`A.A()`) and `a` method of the
    `b` structure (`B.A()`).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们访问了`a`结构体的一个方法（`A.A()`）和`b`结构体的`a`方法（`B.A()`）。
- en: '[PRE72]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When using an anonymous structure inside another structure, as we do with `a{456,
    789}`, you can access the fields of the anonymous structure, which is the `a{456,
    789}` structure, directly as `iComp.XX` and `iComp.YY`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当在另一个结构体内部使用匿名结构体时，就像我们用`a{456, 789}`做的那样，你可以直接访问匿名结构体的字段，即`a{456, 789}`结构体，作为`iComp.XX`和`iComp.YY`。
- en: '[PRE73]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Although `processA()` works with `IntA` variables, it can also work with `IntC`
    variables because the `IntC` interface satisfies `IntA`!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`processA()`与`IntA`变量一起工作，但它也可以与`IntC`变量一起工作，因为`IntC`接口满足`IntA`！
- en: All the code in `objO.go` is simplistic compared to the code of a real object-oriented
    programming language that supports abstract classes and inheritance. However,
    it is more than adequate for generating types and elements with an internal structure,
    as well as for having different data types with the same method names.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与支持抽象类和继承的真正面向对象编程语言的代码相比，`objO.go` 中的所有代码都很简单。然而，它对于生成具有内部结构的类型和元素以及具有相同方法名称的不同数据类型来说已经足够了。
- en: 'Running `objO.go` produces the following output:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `objO.go` 产生以下输出：
- en: '[PRE74]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The first two lines of the output show that two different structures can have
    methods with the same name. The third line proves that when using an anonymous
    structure inside one other structure, you can access the fields of the anonymous
    structure directly. The fourth line is the output of the `iC.bar()` call, where
    `iC` is a `c` variable accessing a method from the `IntB` interface. The last
    line is the output of `processA(iC)` that requires an `IntA` parameter and prints
    the real data type of its parameter, which, in this case, is `main.c`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前两行显示，两种不同的结构可以有相同名称的方法。第三行证明了当在一个结构内部使用匿名结构时，可以直接访问匿名结构的字段。第四行是 `iC.bar()`
    调用的输出，其中 `iC` 是一个 `c` 变量，它从 `IntB` 接口访问方法。最后一行是 `processA(iC)` 的输出，它需要一个 `IntA`
    参数并打印其参数的实际数据类型，在这种情况下是 `main.c`。
- en: Evidently, although Go is not an object-oriented programming language, it can
    mimic some of the characteristics of object-oriented languages.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，尽管 Go 不是面向对象的编程语言，但它可以模仿一些面向对象语言的特征。
- en: The next section discusses the differences between using interfaces and generics
    to support multiple data types.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节讨论了使用接口和泛型支持多种数据类型之间的差异。
- en: Interfaces versus generics
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口与泛型
- en: This section presents a program that increments a numeric value by one using
    interfaces and generics so that you can compare the implementation details.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了一个程序，它使用接口和泛型将数值增加一，以便您可以比较实现细节。
- en: The code of `genericsInterfaces.go` illustrates the two techniques and contains
    the next code.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`genericsInterfaces.go` 的代码展示了这两种技术，并包含了以下代码。'
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This is where we define a constraint named `Numeric` for limiting the permitted
    data types.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们定义一个名为 `Numeric` 的约束，以限制允许的数据类型。
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `Print()` function uses the empty interface for getting input and a type
    switch to work with that input parameter.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print()` 函数使用空接口来获取输入，并使用类型选择来处理该输入参数。'
- en: Put simply, we are using a type switch to differentiate between the supported
    data types—in this case, the supported data types are just `int` and `float64`,
    which have to do with the implementation of the *type switch*. However, adding
    more data types requires code changes, which is not the most efficient solution
    when a large number of data types needs to be supported.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们正在使用类型选择来区分受支持的数据类型——在这种情况下，受支持的数据类型只是 `int` 和 `float64`，这与 *类型选择* 的实现有关。然而，添加更多数据类型需要代码更改，当需要支持大量数据类型时，这不是最有效率的解决方案。
- en: '[PRE77]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This branch is how we handle the `in`t case.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分支是我们处理 `in`t 情况的方式。
- en: '[PRE78]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This branch is how we handle the `float64` case.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分支是我们处理 `float64` 情况的方式。
- en: '[PRE79]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `default` branch is how we handle all unsupported data types.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`default` 分支是我们处理所有不支持的数据类型的方式。'
- en: The biggest issue with `Print()` is that due to the use of the empty interface,
    it accepts all kinds of input. As a result, the function signature does not help
    us limit the allowed data types. The second issue with `Print()` is that we need
    to specifically handle each case—handling more cases means writing more code.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print()` 函数的最大问题是由于使用了空接口，它接受所有类型的输入。因此，函数签名无法帮助我们限制允许的数据类型。`Print()` 的第二个问题是我们需要特别处理每个情况——处理更多的情况意味着需要编写更多的代码。'
- en: On the other hand, the compiler and the developer do not have to guess many
    things with that code, which is not the case with generics, where the compiler
    and the runtime have more work to do. This kind of work introduces delays in the
    execution time.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，编译器和开发者不需要用那种代码猜测很多事情，而泛型则不同，编译器和运行时需要做更多的工作。这种工作引入了执行时间上的延迟。
- en: '[PRE80]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`PrintGenerics()` is a generic function that can handle all available data
    types simply and elegantly.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintGenerics()` 是一个泛型函数，可以简单优雅地处理所有可用的数据类型。'
- en: '[PRE81]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `PrintNumeric()` function supports all numeric data types with the use of
    the `Numeric` constraint. No need to specifically add code for supporting each
    distinct data type, as happens with `Print()`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintNumeric()` 函数通过使用 `Numeric` 约束支持所有数值数据类型。无需为支持每种不同的数据类型专门添加代码，正如 `Print()`
    函数所做的那样。'
- en: '[PRE82]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The first part of `main()` uses `Print()` with various types of input: an `int`
    value, a `float64` value, and a `string` value, respectively.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数的第一部分使用 `Print()` 函数处理各种类型的输入：一个 `int` 值、一个 `float64` 值和一个 `string`
    值，分别。'
- en: '[PRE83]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As stated before, `PrintGenerics()` works with all data types, including `string`
    values.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`PrintGenerics()` 与所有数据类型一起工作，包括 `string` 值。
- en: '[PRE84]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The last part of `main()` uses `PrintNumeric()` with numeric values only, due
    to the use of the `Numeric` constraint.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数的最后部分仅使用 `PrintNumeric()` 和数值一起使用，这是由于使用了 `Numeric` 约束。'
- en: 'Running `genericsInterfaces.go` produces the following output:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `genericsInterfaces.go` 产生以下输出：
- en: '[PRE85]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The preceding three lines of the output are from the `Print()` function, which
    uses the empty interface.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前三行来自 `Print()` 函数，该函数使用空接口。
- en: '[PRE86]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The previous three lines of the output are from the `PrintGenerics()` function,
    which uses generics and supports all available data types. As a result, it should
    not blindly increase the value of its input because we do not know for sure that
    we are dealing with a numeric value. Therefore, it just prints the given input.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前三行来自使用泛型的 `PrintGenerics()` 函数，它支持所有可用的数据类型。因此，它不应该盲目增加其输入的值，因为我们不能确定我们正在处理一个数值。因此，它只是打印给定的输入。
- en: '[PRE87]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The last two lines are generated by the two `PrintNumeric()` calls, which operate
    using the `Numeric` constraint.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行是由两个 `PrintNumeric()` 调用生成的，它们使用 `Numeric` 约束操作。
- en: So, in practice, when you have to support multiple data types, the use of generics
    might be a better choice than using interfaces. However, when we want to define
    and use a specific behavior, interfaces are better and more descriptive than generics.
    Such cases include reading data with the `Reader` interface or writing data with
    the `Writer` interface.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在实践中，当你必须支持多种数据类型时，使用泛型可能比使用接口是一个更好的选择。然而，当我们想要定义和使用特定的行为时，接口比泛型更好，也更具有描述性。这些情况包括使用
    `Reader` 接口读取数据或使用 `Writer` 接口写入数据。
- en: The next section discusses the use of reflection as a way of bypassing the use
    of generics.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节讨论了使用反射作为绕过泛型使用的方法。
- en: Reflection versus generics
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射与泛型
- en: 'In this section, we develop a utility that prints the elements of a slice in
    two ways: first, using reflection, and second, using generics.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们开发了一个实用程序，以两种方式打印切片的元素：首先，使用反射；其次，使用泛型。
- en: 'The code of `genericsReflection.go` is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`genericsReflection.go` 的代码如下：'
- en: '[PRE88]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Internally, the `PrintReflection()` function works with slices only. However,
    as we cannot express that in the function signature, we need to accept an empty
    interface parameter. Put simply, instead of specifying all kinds of slices, it
    makes much more sense to use the empty interface. Additionally, we have to write
    more code to get the desired output and prevent the function from crashing.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`PrintReflection()` 函数仅与切片一起工作。然而，由于我们无法在函数签名中表达这一点，我们需要接受一个空接口参数。简单地说，与其指定所有类型的切片，不如使用空接口更合理。此外，我们必须编写更多的代码来获得所需的输出并防止函数崩溃。
- en: In more detail, first, we need to make sure that we are processing a slice (`reflect.Slice`),
    and second, we have to print the slice elements using a `for` loop, which is pretty
    ugly.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，首先，我们需要确保我们正在处理一个切片（`reflect.Slice`），其次，我们必须使用 `for` 循环打印切片元素，这看起来相当丑陋。
- en: '[PRE89]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Once again, **the implementation of the generic function is simpler and therefore
    easier to understand**. Moreover, the function signature specifies that only slices
    are accepted as function parameters—we do not have to perform any additional checks
    for that as this is a job for the Go compiler. Last, we use a simple `for` loop
    with `range` to print the slice elements.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，**泛型函数的实现更简单，因此更容易理解**。此外，函数签名指定只接受切片作为函数参数——我们不需要为此执行任何额外的检查，因为这是 Go 编译器的工作。最后，我们使用简单的
    `for` 循环和 `range` 来打印切片元素。
- en: '[PRE90]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `main()` function calls `PrintSlice()` and `PrintReflection()` with various
    kinds of input to test their operation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数使用各种类型的输入调用 `PrintSlice()` 和 `PrintReflection()` 函数来测试它们的操作。'
- en: 'Running `genericsReflection.go` generates the following output:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `genericsReflection.go` 生成以下输出：
- en: '[PRE91]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The first six lines are produced by taking advantage of generics and print the
    elements of a slice of `int` values, a slice of `string` values, and a slice of
    `float64` values.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 前六行利用泛型打印了`int`值切片、`string`值切片和`float64`值切片的元素。
- en: '[PRE92]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The last six lines of the output produce the same output but, this time, using
    reflection. There is no difference in the output—all differences are in the code
    found in the implementations of `PrintReflection()` and `PrintSlice()` for printing
    the output. As expected, **generics code is simpler and shorter than Go code that
    uses reflection**, especially when you must support lots of different data types.
    While generics in Go offer a powerful and type-safe way to write reusable code,
    there are scenarios where using reflection might be more suitable, including dynamic
    type handling, working with uncommon types, serialization and deserialization,
    and when implementing custom marshaling and unmarshaling.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后六行产生相同的输出，但这次使用反射。输出没有差异——所有差异都在`PrintReflection()`和`PrintSlice()`的实现中，这两个函数用于打印输出。正如预期的那样，**泛型代码比使用反射的Go代码更简单、更短**，尤其是在必须支持许多不同数据类型的情况下。虽然Go中的泛型提供了一种强大且类型安全的编写可重用代码的方法，但在某些场景下使用反射可能更合适，包括动态类型处理、与不常见类型一起工作、序列化和反序列化，以及实现自定义序列化和反序列化。
- en: Moving on, the last section of this chapter is about updating the statistics
    application by reading multiple files and sorting its output by a given statistical
    property.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，本章的最后部分是关于通过读取多个文件并根据给定的统计属性对输出进行排序来更新统计应用程序。
- en: Updating the statistics application
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新统计应用程序
- en: What we are going to do in this section is sort different datasets based on
    their mean value. As a result, the application is going to be able to read multiple
    files, which are going to be given as command line arguments to the utility—we
    are going to learn more about file I/O in *Chapter 7*, *Telling a UNIX System
    What to Do*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将根据数据集的平均值对不同的数据集进行排序。结果，应用程序将能够读取多个文件，这些文件将作为命令行参数提供给实用工具——我们将在*第7章*，*告诉UNIX系统做什么*中了解更多关于文件I/O的内容。
- en: We are going to create a structure that holds the statistical properties of
    each datafile, use a slice to store all such structures, and sort them based on
    the mean value of each dataset. The last functionality is going to be implemented
    using the `sort.Interface`. Using a structure for keeping the important information
    organized is a common practice. Additionally, we are going to use the `slices.Min()`
    and `slices.Max()` functions for finding the minimum and the maximum value in
    a slice, respectively, which saves us from having to sort the slice.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个结构来保存每个数据文件的统计属性，使用切片来存储所有这样的结构，并根据每个数据集的平均值对它们进行排序。最后的功能将使用`sort.Interface`来实现。使用结构来保持重要信息组织有序是一种常见做法。此外，我们将使用`slices.Min()`和`slices.Max()`函数来分别找到切片中的最小值和最大值，这样可以避免对切片进行排序。
- en: Although such utilities look naïve at first, they can be the foundation of complex
    machine learning systems. In general, statistics is the foundation of machine
    learning.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些实用工具一开始看起来很天真，但它们可以是复杂机器学习系统的基础。一般来说，统计学是机器学习的基础。
- en: 'The definition of the `DataFile` structure is the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFile`结构的定义如下：'
- en: '[PRE93]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We also need to define a new data type for a slice of `DataFile` structures,
    which is the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为`DataFile`结构的一部分定义一个新的数据类型，如下所示：
- en: '[PRE94]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: It is for `DFslice` that we are going to implement the `sort.Interface`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`DFslice`实现`sort.Interface`。
- en: '[PRE95]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The previous three methods satisfy the `sort.Interface` for `DFslice`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个方法满足`DFslice`的`sort.Interface`。
- en: 'The implementation of the `main()` function is presented in four parts, the
    first part being the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数的实现分为四部分，第一部分如下：'
- en: '[PRE96]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In this first part of `main()`, we make sure that we have at least one command
    line argument to process and we define a slice of `DataFile` structures variable
    for keeping the data of each file.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数的这一部分，我们确保至少有一个命令行参数要处理，并为每个文件的`DataFile`结构定义一个切片变量来保存数据。
- en: 'The second part of `main()` is as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数的第二部分如下：'
- en: '[PRE97]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The presented `for` loop processes all input files unless there is an error.
    In case of error, the utility exits with a call to `os.Exit(0)`. A different approach
    would have been to skip the erroneous input file and continue with the next. Additionally,
    the `currentFile` variable keeps the data of the current file in a `DataFile`
    structure.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的 `for` 循环处理所有输入文件，除非出现错误。如果出现错误，实用程序将调用 `os.Exit(0)` 退出。另一种方法可能是跳过有误的输入文件并继续处理下一个。此外，`currentFile`
    变量将当前文件的数据保存在 `DataFile` 结构中。
- en: 'The third part of `main()` contains the following code:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 的第三部分包含以下代码：'
- en: '[PRE98]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In the previous code, we compute all the required statistical properties and
    save them in the `currentFile` variable. Last, the current version of the `currentFile`
    variable is stored in the `files` slice before continuing with the next file,
    if any.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们计算了所有所需的统计属性并将它们保存在 `currentFile` 变量中。最后，在继续处理下一个文件（如果有的话）之前，将当前版本的
    `currentFile` 变量存储在 `files` 切片中。
- en: 'The last part of `main()` comes with the following code:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 的最后一部分包含以下代码：'
- en: '[PRE99]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The last part of the utility sorts the `files` slice and prints information
    about each one of the input files. You can print any data you want from the `files`
    slice.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 工具的最后部分对 `files` 切片进行排序，并打印每个输入文件的信息。您可以从 `files` 切片中打印任何您想要的数据。
- en: 'Running `stats.go` using the simplistic data files found in the `ch05` directory
    produces the following output:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ch05` 目录中找到的简单数据文件运行 `stats.go` 产生以下输出：
- en: '[PRE100]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: As the mean value of `d3.txt` is `0.75`, `d3.txt` is presented before `d1.txt`,
    which has a mean value of `3`, and `d2.txt`, which has a mean value of `18.2`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `d3.txt` 的平均值是 `0.75`，因此 `d3.txt` 在具有平均值为 `3` 的 `d1.txt` 和具有平均值为 `18.2` 的
    `d2.txt` 之前显示。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about interfaces, which are like contracts, and
    also about type methods, type assertion, and reflection. Although reflection is
    a very powerful Go feature, it might slow down your Go programs because it adds
    a layer of complexity at runtime. Furthermore, your Go programs could crash if
    you use reflection carelessly. However, reflection is not usually needed unless
    you want to perform low-level tasks with Go variables.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了接口，它们就像合同一样，还学习了类型方法、类型断言和反射。尽管反射是 Go 的一个非常强大的功能，但它可能会减慢您的 Go 程序，因为它在运行时添加了一层复杂性。此外，如果您不小心使用反射，您的
    Go 程序可能会崩溃。然而，除非您想使用 Go 变量执行低级任务，否则通常不需要反射。
- en: Remember that interfaces specify behavior, specify what you can do, and not
    what a data type is. Code that uses interfaces successfully is more readable,
    more extensible, and simpler to understand. Last, **keep in mind that interfaces
    are implemented implicitly once the required type methods are implemented**.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，接口指定行为，指定您可以做什么，而不是数据类型是什么。成功使用接口的代码更易于阅读、更易于扩展，并且更容易理解。最后，**请记住，一旦实现了所需类型的方法，接口就隐式实现**。
- en: This chapter also discussed writing Go code that follows the principles of object-oriented
    programming. If you are going to remember just one thing from this chapter, it
    should be that Go is not an object-oriented programming language, but it can mimic
    some of the functionality offered by object-oriented programming languages, such
    as Java, Python, and C++. In the last section, we updated the statistics application
    to support the sorting of multiple datasets based on the mean value of a dataset.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还讨论了编写遵循面向对象编程原则的 Go 代码。如果您只想记住本章中的一件事，那就是 Go 不是一个面向对象编程语言，但它可以模仿一些面向对象编程语言（如
    Java、Python 和 C++）提供的一些功能。在最后一节中，我们更新了统计应用程序以支持根据数据集的平均值对多个数据集进行排序。
- en: The next chapter discusses semantic versioning, Go packages, functions, and
    workspaces.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章讨论语义版本控制、Go 包、函数和工作空间。
- en: Exercises
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try to do the following exercises:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习：
- en: Create a slice of structures using a structure that you created and sort the
    elements of the slice using a field from the structure.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您创建的结构创建一个结构体切片，并使用结构中的一个字段对切片的元素进行排序。
- en: Use the empty interface and a function that allows you to differentiate between
    two different structures that you have created.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空接口和一个允许您区分您创建的两个不同结构的函数。
- en: Additional resources
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The documentation of the `reflect` package: [https://pkg.go.dev/reflect](https://pkg.go.dev/reflect)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflect` 包的文档：[https://pkg.go.dev/reflect](https://pkg.go.dev/reflect)'
- en: 'The documentation of the `sort` package: [https://pkg.go.dev/sort](https://pkg.go.dev/sort)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort` 包的文档：[https://pkg.go.dev/sort](https://pkg.go.dev/sort)'
- en: 'Working with errors in Go 1.13: [https://blog.go.dev/go1.13-errors](https://blog.go.dev/go1.13-errors)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 1.13 中处理错误：[https://blog.go.dev/go1.13-errors](https://blog.go.dev/go1.13-errors)
- en: 'The implementation of the `sort` package: [https://go.dev/src/sort/](https://go.dev/src/sort/)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort` 包的实现：[https://go.dev/src/sort/](https://go.dev/src/sort/)'
- en: Join our community on Discord
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6)'
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6)'
