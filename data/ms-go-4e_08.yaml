- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Go Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go并发
- en: The key component of the Go concurrency model is the goroutine, which is the
    **minimum executable entity** in Go. To create a new goroutine, we must use the
    `go` keyword followed by a function call or an anonymous function—the two methods
    are equivalent. For a goroutine or a function to terminate the entire Go application,
    it should call `os.Exit()` instead of `return`. However, most of the time, we
    exit a goroutine or a function using `return` because what we really want is to
    exit that specific goroutine or function and not stop the entire application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go并发模型的关键组件是goroutine，它是Go中的**最小可执行实体**。要创建一个新的goroutine，我们必须使用`go`关键字后跟一个函数调用或匿名函数——这两种方法等效。对于一个goroutine或函数要终止整个Go应用程序，它应该调用`os.Exit()`而不是`return`。然而，大多数时候，我们使用`return`退出goroutine或函数，因为我们真正想要退出的是特定的goroutine或函数，而不是停止整个应用程序。
- en: Everything in Go is executed as a goroutine, either transparently or consciously.
    Each executable Go program has at least one goroutine, which is used for running
    the `main()` function of the `main` package. Each goroutine is executed on a single
    OS thread according to the instructions of the Go scheduler, which is responsible
    for the execution of goroutines—the developer has no control over the amount of
    memory allocated to a goroutine. The OS scheduler does not dictate how many threads
    the Go runtime is going to create because the Go runtime will spawn enough threads
    to ensure that `GOMAXPROCS` threads are available to run the Go code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的所有内容都以goroutine的形式执行，无论是透明地还是有意为之。每个可执行的Go程序至少有一个goroutine，用于运行`main`包的`main()`函数。每个goroutine根据Go调度器的指令在单个OS线程上执行，Go调度器负责goroutine的执行——开发者无法控制分配给goroutine的内存量。操作系统调度器不会指定Go运行时将要创建多少线程，因为Go运行时会生成足够的线程以确保有`GOMAXPROCS`个线程可用于运行Go代码。
- en: However, **goroutines cannot communicate with each other directly**. Data sharing
    in Go is implemented using either channels, local sockets, or shared memory. *Channels*
    act as the glue that connects multiple goroutines. On the other hand, channels
    cannot process data or execute code but they can send data to and receive data
    from goroutines and have a special purpose like acting as signals or specifying
    the order of execution for goroutines.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，**goroutines不能直接相互通信**。Go中的数据共享是通过通道、本地套接字或共享内存实现的。*通道*作为连接多个goroutines的粘合剂。另一方面，通道不能处理数据或执行代码，但它们可以向goroutines发送数据并从goroutines接收数据，具有特殊用途，如作为信号或指定goroutine的执行顺序。
- en: When I first learned about channels, I thought that they were a great idea,
    much better than shared memory, and I wanted to use channels everywhere! However,
    nowadays **I only use channels when I have no other alternative**. Look at the
    implementation of the concurrent statistical application at the end of the chapter
    to realize that there exist designs that do not require the use of channels.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我最初了解到通道时，我认为这是一个很好的主意，比共享内存好得多，我想要在所有地方都使用通道！然而，如今**我只在别无选择的情况下使用通道**。看看本章末尾的并发统计应用程序的实现，以了解存在不需要使用通道的设计。
- en: Although the use of channels to communicate and synchronize between goroutines
    is very typical and expected, channels might introduce deadlocks, overhead, and
    complexity to the design, as well as performance considerations, especially when
    low-latency communication is a priority.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在goroutine之间使用通道进行通信和同步是非常典型和预期的，但通道可能会引入死锁、开销和复杂性到设计中，以及性能考虑，尤其是在低延迟通信是优先级时。
- en: When you combine multiple channels and goroutines, you can create data flows,
    which, in Go terminology, are called pipelines. So, you might have a goroutine
    that reads data from a database and sends it to a channel and a second goroutine
    that reads from that channel, processes that data, and sends it to another channel
    to be read from another goroutine, before making modifications to the data and
    storing it in another database.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你结合多个通道和goroutines时，你可以创建数据流，在Go术语中，这些被称为管道。因此，你可能有一个goroutine从数据库读取数据并发送到通道，另一个goroutine从该通道读取数据，处理这些数据，然后将数据发送到另一个通道供另一个goroutine读取，在修改数据并将其存储在另一个数据库之前。
- en: 'This chapter covers:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖：
- en: Processes, threads, and goroutines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程、线程和goroutines
- en: The Go scheduler
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go调度器
- en: Goroutines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goroutines
- en: Channels
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道
- en: Race conditions are bad
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞态条件是坏事
- en: The `select` keyword
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select`关键字'
- en: Timing out a goroutine
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时goroutine
- en: Go channels revisited
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视Go通道
- en: Handling UNIX signals
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理UNIX信号
- en: Shared memory and shared variables
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存和共享变量
- en: Closured variables and the `go` statement
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包变量和`go`语句
- en: The `context` package
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`包'
- en: The `semaphore` package
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`semaphore`包'
- en: Making the statistics application concurrent
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使统计应用程序并发
- en: Processes, threads, and goroutines
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程、线程和goroutine
- en: A process is an OS representation of a running program, while a program is a
    binary file on a disk that contains all the information necessary for creating
    an OS process. The binary file is written in a specific format and contains all
    the instructions the CPU is going to run, as well as a plethora of other required
    sections. That program is loaded into memory and the instructions are executed,
    creating a running process. So, a process carries with it additional resources
    such as memory, opened file descriptions, and user data, as well as other types
    of resources that are obtained during runtime.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是操作系统对正在运行的程序的表示，而程序是磁盘上的一个二进制文件，其中包含创建操作系统进程所需的所有信息。该二进制文件以特定格式编写，包含CPU将要运行的指令以及大量其他所需部分。该程序被加载到内存中，并执行指令，创建一个正在运行的进程。因此，进程携带了额外的资源，如内存、打开的文件描述符和用户数据，以及运行时获取的其他类型资源。
- en: A thread is a smaller and lighter entity than a process. Processes consist of
    one or more threads that have their own flow of control and stack. A quick and
    simplistic way to differentiate a thread from a process is to consider a process
    as the running binary file and a thread as a subset of a process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是一个比进程更小、更轻的实体。进程由一个或多个具有自己控制流和堆栈的线程组成。区分线程和进程的一个简单方法是将进程视为正在运行的二进制文件，而线程则是进程的一个子集。
- en: A goroutine is the minimum Go entity that can be executed concurrently. The
    use of the word *minimum* is very important here, as goroutines are not autonomous
    entities like UNIX processes—**goroutines live in OS threads that live in OS processes**.
    The good thing is that goroutines are lighter than threads, which, in turn, are
    lighter than processes—running thousands or hundreds of thousands of goroutines
    on a single machine is not a problem. Among the reasons that goroutines are lighter
    than threads are that they have a smaller stack that can grow, they have a faster
    startup time, and they can communicate with each other through channels with low
    latency. In practice, this means that a process can have multiple threads and
    lots of goroutines, whereas a goroutine needs the environment of a process to
    exist. So, to create a goroutine, you need to have a process with at least one
    thread. The OS takes care of the process and thread scheduling, while Go creates
    the necessary threads and the developer creates the desired number of goroutines.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutine是Go语言中可以并发执行的最小实体。在这里使用“最小”这个词非常重要，因为goroutine不是像UNIX进程那样的自主实体——**goroutine生活在操作系统线程中，而操作系统线程又生活在操作系统进程中**。好事是goroutine比线程轻，而线程又比进程轻——在单台机器上运行数千或数百万个goroutine不是问题。goroutine比线程轻的原因包括它们有一个可以增长的更小的堆栈，它们有更快的启动时间，并且可以通过低延迟的通道相互通信。在实践中，这意味着一个进程可以有多个线程和大量goroutine，而goroutine需要进程的环境才能存在。因此，要创建goroutine，你需要有一个至少包含一个线程的进程。操作系统负责进程和线程的调度，而Go创建必要的线程，开发者创建所需的goroutine数量。
- en: Now that you know the basics of processes, programs, threads, and goroutines,
    let us talk a little bit about the Go scheduler.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了进程、程序、线程和goroutine的基础知识，让我们简单谈谈Go调度器。
- en: The Go scheduler
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go调度器
- en: The OS kernel scheduler is responsible for the execution of the threads of a
    program. Similarly, the Go runtime has its own scheduler, which is responsible
    for the execution of the goroutines using a technique known as *m:n scheduling*,
    where m goroutines are executed using n OS threads using multiplexing. The Go
    scheduler is the Go component responsible for the way and the order in which the
    goroutines of a Go program get executed. This makes the Go scheduler a really
    important part of the Go programming language. The Go scheduler is also executed
    as a goroutine.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统内核调度器负责程序的线程执行。同样，Go运行时也有自己的调度器，它负责使用称为*m:n调度*的技术来执行goroutine，其中m个goroutine使用n个操作系统线程通过多路复用来执行。Go调度器是Go组件，负责Go程序中goroutine的执行方式和顺序。这使得Go调度器成为Go编程语言的重要组成部分。Go调度器也作为一个goroutine来执行。
- en: Be aware that as the Go scheduler only deals with the goroutines of a single
    program, its operation is much simpler, cheaper, and faster than the operation
    of the OS kernel scheduler.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于 Go 调度器只处理单个程序中的 goroutine，其操作比操作系统内核调度器的操作要简单、便宜和快速得多。
- en: Go uses the fork-join concurrency model. The *fork part* of the model, which
    should not be confused with the `fork(2)` system call, states that a child branch
    can be created at any point of a program. Analogously, the *join part* of the
    Go concurrency model is where the child branch ends and joins with its parent.
    Keep in mind that both `sync.Wait()` statements and channels that collect the
    results of goroutines are join points, whereas each new goroutine creates a child
    branch.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Go 使用了分叉-连接并发模型。模型中的 *分叉部分*，不应与 `fork(2)` 系统调用混淆，表明可以在程序的任何位置创建子分支。类似地，Go 并发模型中的
    *连接部分* 是子分支结束并与父分支连接的地方。请注意，`sync.Wait()` 语句和收集 goroutine 结果的通道都是连接点，而每个新的 goroutine
    都会创建一个子分支。
- en: '**The fair scheduling strategy shares all load evenly among the available processors**.
    At first, this might look like the perfect strategy because it does not have to
    take many things into consideration while keeping all processors equally occupied.
    However, it turns out that this is not exactly the case because most distributed
    tasks usually depend on other tasks. Therefore, some processors are underutilized
    or, equivalently, some processors are utilized more than others.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**公平调度策略将所有负载均匀地分配到所有可用处理器上**。起初，这看起来像是一个完美的策略，因为它在保持所有处理器同等忙碌的同时，不需要考虑许多因素。然而，事实证明并非如此，因为大多数分布式任务通常依赖于其他任务。因此，一些处理器未被充分利用，或者说，一些处理器的利用率高于其他处理器。'
- en: A goroutine is a task, whereas everything after the calling statement of a goroutine
    is a continuation. **In the work-stealing strategy used by the Go scheduler, a
    (logical) processor that is underutilized looks for additional work from other
    processors.** When it finds such jobs, it steals them from the other processor
    or processors, hence the name. Additionally, the work-stealing algorithm of Go
    queues and steals continuations. A stalling join, as is suggested by its name,
    is a point where a thread of execution stalls at a join and starts looking for
    other work to do.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutine 是一个任务，而 goroutine 调用语句之后的代码则是一个延续。**在 Go 调度器使用的偷取工作策略中，一个（逻辑上的）未充分利用的处理器会从其他处理器那里寻找额外的工作。**
    当它找到这样的工作后，它会从其他处理器或处理器那里窃取这些工作，因此得名。此外，Go 的工作窃取算法还会对队列中的延续进行排队和窃取。正如其名所暗示的，停滞的连接点是指执行线程在连接点停滞并开始寻找其他工作去做的地方。
- en: Although both task stealing and continuation stealing have stalling joins, continuations
    happen more often than tasks; therefore, the Go scheduling algorithm works with
    continuations rather than tasks. The main disadvantage of continuation stealing
    is that it requires extra work from the compiler of the programming language.
    Fortunately, Go provides that extra help and, therefore, uses continuation stealing
    in its work-stealing algorithm. One of the benefits of continuation stealing is
    that you get the same results when using function calls instead of goroutines
    or a single thread with multiple goroutines. This makes perfect sense, as only
    one thing is executed at any given point in both cases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管任务窃取和延续窃取都有停滞的连接点，但延续的发生频率比任务更高；因此，Go 调度算法使用延续而不是任务。延续窃取的主要缺点是它需要编程语言编译器的额外工作。幸运的是，Go
    提供了这种额外帮助，因此在其工作窃取算法中使用了延续窃取。延续窃取的一个好处是，使用函数调用而不是 goroutine 或具有多个 goroutine 的单个线程时，你将得到相同的结果。这在两种情况下都只执行一个操作，因此这是完全合理的。
- en: 'The Go scheduler works using three main kinds of entities: OS threads (M),
    which are related to the OS in use, goroutines (G), and logical processors (P).
    The number of processors that can be used by a Go program is specified by the
    value of the `GOMAXPROCS` environment variable—at any given time, there are, at
    most, `GOMAXPROCS` processors. Now, let us return to the `m:n` scheduling algorithm
    used in Go. Strictly speaking, at any time, you have `m` goroutines that are executed
    and, therefore, scheduled to run, on `n` OS threads using, at most, `GOMAXPROCS`
    number of logical processors. You will learn more about `GOMAXPROCS` shortly.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Go 调度器通过三种主要实体工作：操作系统线程（M），它们与使用的操作系统相关联，goroutines（G），以及逻辑处理器（P）。Go 程序可以使用的处理器数量由
    `GOMAXPROCS` 环境变量的值指定——在任何给定时间，最多有 `GOMAXPROCS` 个处理器。现在，让我们回到 Go 中使用的 `m:n` 调度算法。严格来说，在任何时候，你都有
    `m` 个正在执行且因此被调度运行的 goroutines，它们在 `n` 个操作系统线程上运行，最多使用 `GOMAXPROCS` 个逻辑处理器。你很快就会了解更多关于
    `GOMAXPROCS` 的信息。
- en: 'Each goroutine can be in one of the following three stages: *executing*, *runnable*,
    or *waiting*. In the executing stage, the instructions of the goroutine are executed
    on an OS thread. In the runnable stage, the goroutine waits to be assigned to
    an OS thread for execution. Finally, in the waiting stage, the goroutine is blocked
    for some reason like waiting for a resource or a mutex to become available to
    go into one of the other two stages.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 goroutine 可以处于以下三个阶段之一：*执行中*、*可运行*或*等待中*。在执行阶段，goroutine 的指令在一个操作系统线程上执行。在可运行阶段，goroutine
    等待被分配到操作系统线程以进行执行。最后，在等待阶段，goroutine 由于某些原因（如等待资源或互斥锁变得可用）而被阻塞，以便进入其他两个阶段之一。
- en: The following figure shows that there are two different kinds of queues—a global
    run queue and a local run queue—attached to each logical processor. Goroutines
    from the global queue are assigned to the queue of a logical processor in order
    to get executed at some point in the future.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了每个逻辑处理器都附加了两种不同类型的队列——一个全局运行队列和一个本地运行队列。来自全局队列的 goroutines 被分配到逻辑处理器的队列中，以便在未来某个时刻执行。
- en: '![](img/B21003_08_01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21003_08_01.png)'
- en: 'Figure 8.1: The operation of the Go scheduler'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：Go 调度器的操作
- en: Each logical processor can have multiple threads, and the stealing occurs between
    the local queues of the available logical processors. Finally, keep in mind that
    the Go scheduler is allowed to create more OS threads when needed. OS threads
    are expensive in terms of resources and going from one status to another (*context
    switching*), which means that dealing too much with OS threads might slow down
    your Go applications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个逻辑处理器可以有多个线程，偷取发生在可用逻辑处理器的本地队列之间。最后，请记住，Go 调度器在需要时可以创建更多的操作系统线程。操作系统线程在资源方面很昂贵，并且从一个状态转换到另一个状态（*上下文切换*），这意味着过多地处理操作系统线程可能会减慢你的
    Go 应用程序。
- en: Next, we discuss the meaning and the use of `GOMAXPROCS`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论 `GOMAXPROCS` 的含义和使用。
- en: The GOMAXPROCS environment variable
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`GOMAXPROCS` 环境变量'
- en: The `GOMAXPROCS` environment variable allows you to set the number of OS threads
    that can execute user-level Go code simultaneously; this does not limit the number
    of threads created but it does limit the number of threads that are actively running.
    Starting with Go version 1.5, the default value of `GOMAXPROCS` should be the
    number of logical cores available in your machine. There is also the `runtime.GOMAXPROCS()`
    function, which allows you to set and get the value of `GOMAXPROCS` programmatically.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOMAXPROCS` 环境变量允许你设置可以同时执行用户级 Go 代码的操作系统线程数量；这不会限制创建的线程数量，但会限制正在积极运行的线程数量。从
    Go 版本 1.5 开始，`GOMAXPROCS` 的默认值应该是你的机器中可用的逻辑核心数。还有一个 `runtime.GOMAXPROCS()` 函数，它允许你以编程方式设置和获取
    `GOMAXPROCS` 的值。'
- en: If you decide to assign a value to `GOMAXPROCS` that is smaller than the number
    of cores in your machine, you might affect the performance of your program. However,
    using a `GOMAXPROCS` value that is larger than the number of available cores does
    not necessarily make your Go programs run faster due to the context switching
    of threads.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定将 `GOMAXPROCS` 的值设置为小于你机器中的核心数，可能会影响你程序的性能。然而，使用大于可用核心数的 `GOMAXPROCS` 值并不一定会使你的
    Go 程序运行得更快，因为线程的上下文切换可能会造成影响。
- en: 'As mentioned earlier in this subsection, you can programmatically set and get
    the value of the `GOMAXPROCS` environment variable—this is illustrated in `maxprocs.go`,
    which will also show additional capabilities of the runtime package. The `main()`
    function is implemented as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节之前所述，您可以程序化地设置和获取 `GOMAXPROCS` 环境变量的值——这在本节中的 `maxprocs.go` 中得到了说明，它还将展示运行时包的额外功能。`main()`
    函数的实现如下：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `runtime.Compiler` variable holds the compiler toolchain used for building
    the running binary. The two most well-known values are `gc` and `gccgo`. The `runtime.GOARCH`
    variable holds the current architecture and `runtime.Version()` returns the current
    version of the Go compiler. This information is not necessary for using `runtime.GOMAXPROCS()`
    but it is good to have a better knowledge of your system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime.Compiler` 变量保存用于构建运行二进制的编译器工具链。最著名的两个值是 `gc` 和 `gccgo`。`runtime.GOARCH`
    变量保存当前架构，而 `runtime.Version()` 返回 Go 编译器的当前版本。这些信息对于使用 `runtime.GOMAXPROCS()`
    不是必需的，但了解您的系统信息是好的。'
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What happens with the `runtime.GOMAXPROCS(0)` call? It always returns the previous
    value of the maximum number of CPUs that can be executed simultaneously. When
    the parameter of `runtime.GOMAXPROCS()` is equal to or bigger than `1`, then `runtime.GOMAXPROCS()`
    also changes the current setting. As we are using `0`, our call does not alter
    the current setting.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime.GOMAXPROCS(0)` 调用会发生什么？它总是返回可以同时执行的最大 CPU 数量的上一个值。当 `runtime.GOMAXPROCS()`
    的参数等于或大于 `1` 时，`runtime.GOMAXPROCS()` 也会更改当前设置。由于我们使用的是 `0`，我们的调用不会改变当前设置。'
- en: 'Running `maxprocs.go` produces the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `maxprocs.go` 产生以下输出：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can change the value of `GOMAXPROCS` on the fly using the following technique:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下技术实时更改 `GOMAXPROCS` 的值：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The previous command temporarily changes the value of `GOMAXPROCS` to `100`
    and runs `maxprocs.go`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令临时将 `GOMAXPROCS` 的值更改为 `100` 并运行 `maxprocs.go`。
- en: Apart from testing the performance of your code using fewer cores, you will
    most likely not need to change `GOMAXPROCS`. The next subsection will explain
    the similarities and differences between concurrency and parallelism.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用较少的核心测试代码的性能外，您很可能不需要更改 `GOMAXPROCS`。下一节将解释并发与并行之间的相似之处和不同之处。
- en: Concurrency and parallelism
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发与并行
- en: It is a common misconception that concurrency is the same thing as parallelism—this
    is not true! Parallelism is the simultaneous execution of multiple entities of
    some kind, whereas concurrency is a way of structuring your components so that
    they can be executed independently when possible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 人们普遍认为并发与并行是同一件事——这并不正确！并行性是同时执行多种类型的多个实体，而并发是一种结构化组件的方式，以便在可能的情况下独立执行。
- en: It is only when you build software components concurrently that you can safely
    execute them in parallel, when and if your OS and your hardware permit it. The
    Erlang programming language did this a long time ago—long before CPUs had multiple
    cores and computers had lots of RAM.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在您并发构建软件组件时，才能安全地在您的操作系统和硬件允许的情况下并行执行它们。Erlang 编程语言很久以前就这样做了——在 CPU 具有多个核心和计算机拥有大量
    RAM 之前很久。
- en: In a valid concurrent design, adding concurrent entities makes the whole system
    run faster because more things can be executed in parallel. So, the desired parallelism
    comes from a better concurrent expression and implementation of the problem. The
    developer is responsible for taking concurrency into account during the design
    phase of a system and will benefit from a potential parallel execution of the
    components of the system. So, the developer should not think about parallelism
    but about breaking things into independent components that solve the initial problem
    when combined.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个有效的并发设计中，添加并发实体可以使整个系统运行得更快，因为可以并行执行更多的事情。因此，所需的并行性来自于对问题更好的并发表达和实现。开发者负责在设计阶段考虑并发，并将从系统组件的潜在并行执行中受益。因此，开发者不应该考虑并行性，而应该考虑将问题分解为独立的组件，这些组件在组合时解决初始问题。
- en: '**Even if you cannot run your functions in parallel on your machine, a valid
    concurrent design still improves the design, data flow, and maintainability of
    your programs**. In other words, concurrency is better than parallelism! Let us
    now talk about goroutines before looking into channels, which are the main components
    of the Go concurrency model.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**即使您无法在您的机器上并行运行函数，有效的并发设计仍然可以改进程序的设计、数据流和可维护性**。换句话说，并发比并行更好！现在，在我们探讨通道之前，让我们先谈谈goroutines，通道是Go并发模型的主要组件。'
- en: Goroutines
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: You can define, create, and execute a new goroutine using the `go` keyword followed
    by a named function or an anonymous function call. The `go` keyword makes the
    function call return immediately, while the function starts running in the background
    as a goroutine and the rest of the program continues its execution. You cannot
    control or make any assumptions about the order in which your goroutines are going
    to be executed because that depends on the scheduler of the OS, the Go scheduler,
    and the load of the OS.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`go`关键字后跟一个命名函数或匿名函数调用来定义、创建和执行一个新的goroutine。`go`关键字使得函数调用立即返回，而函数则在后台作为goroutine开始运行，其余程序继续执行。您无法控制或对goroutines将要执行的顺序做出任何假设，因为这取决于操作系统的调度器、Go调度器和操作系统负载。
- en: Creating a goroutine
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建goroutine
- en: 'In this subsection, you will learn how to create goroutines. The program that
    illustrates the technique is called `create.go`. The implementation of the `main()`
    function is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，您将学习如何创建goroutines。演示该技术的程序被称为`create.go`。`main()`函数的实现如下：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is how you run an anonymous function as a goroutine. The `(10)` at the
    end is how you pass a parameter to an anonymous function. The previous anonymous
    function just prints a value. In general, it is more readable to pass parameters
    explicitly than to have the function close over the variables it uses.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何将匿名函数作为goroutine运行。最后的`(10)`是如何向匿名函数传递参数的。前面的匿名函数只是打印一个值。一般来说，显式传递参数比让函数关闭它所使用的变量更易于阅读。
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is how you execute a function as a goroutine. As a rule of thumb, the functions
    that you execute as goroutines should not return any values directly. **Exchanging
    data with goroutines happens via the use of shared memory or channels or some
    other mechanism**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何将一个函数作为goroutine执行。一般来说，您作为goroutine执行的函数不应直接返回任何值。**与goroutines交换数据是通过使用共享内存或通道或其他机制来实现的**。
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As a Go program does not wait for its goroutines to end before exiting, we need
    to delay it manually, which is the purpose of the `time.Sleep()` call. We correct
    that shortly in order to wait for all goroutines to finish before exiting.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go程序在退出前不会等待其goroutines结束，我们需要手动延迟它，这就是`time.Sleep()`调用的目的。我们将很快纠正这一点，以便在退出前等待所有goroutines完成。
- en: 'Running `create.go` produces the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`create.go`会产生以下输出：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `10` part in the output is from the anonymous function, whereas the `*
    15` part is from the `go printme(15)` statement. However, if you run `create.go`
    more than once, you might get a different output because the two goroutines are
    not always executed in the same order, as this depends on the Go scheduler:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的`10`部分来自匿名函数，而`* 15`部分来自`go printme(15)`语句。然而，如果您多次运行`create.go`，可能会得到不同的输出，因为这两个goroutines并不总是按相同的顺序执行，这取决于Go调度器：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The next subsection shows how to run a variable number of goroutines.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节将展示如何运行可变数量的goroutines。
- en: Creating multiple goroutines
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建多个goroutines
- en: 'In this subsection, you will learn how to create a variable number of goroutines.
    The program that illustrates the technique is called `multiple.go`. The number
    of goroutines is given as a command line argument to the program. The important
    code from the implementation of the `main()` function is the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，您将学习如何创建可变数量的goroutines。演示该技术的程序被称为`multiple.go`。goroutines的数量作为程序的一个命令行参数给出。`main()`函数实现中的重要代码如下：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is nothing prohibiting you from using a `for` loop to create multiple
    goroutines, especially when you want to create lots of them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何禁止您使用`for`循环来创建多个goroutines，尤其是在您想创建很多goroutines时。
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once again, `time.Sleep()` prevents the `main()` function from exiting immediately.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`time.Sleep()`防止`main()`函数立即退出。
- en: 'Running `multiple.go` generates the following kind of output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`multiple.go`会生成以下类型的输出：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you run `multiple.go` many times, you are going to get different outputs.
    So, there is still room for improvement. The next subsection shows how to remove
    the call to `time.Sleep()` and make your programs wait for the goroutines to finish.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次运行 `multiple.go`，你将得到不同的输出。因此，仍有改进的空间。下一小节将展示如何移除对 `time.Sleep()` 的调用，并使你的程序等待
    goroutines 完成。
- en: Waiting for all goroutines to finish
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待所有 goroutines 完成
- en: It is not enough to create multiple goroutines—you also need to wait for them
    to finish before the `main()` function ends. Therefore, this subsection shows
    a very popular technique that improves the code of `multiple.go`—the improved
    version is called `varGoroutines.go`. But first, we need to explain how this works.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 仅创建多个 goroutines 是不够的——你还需要在 `main()` 函数结束前等待它们完成。因此，本小节将展示一个非常流行的技术，它可以改进 `multiple.go`
    的代码——改进后的版本被称为 `varGoroutines.go`。但首先，我们需要解释它是如何工作的。
- en: 'The synchronization process begins by defining a `sync.WaitGroup` variable
    and using the `Add()`, `Done()`, and `Wait()` methods. If you look at the source
    code of the `sync` Go package, and more specifically at the `waitgroup.go` file,
    you see that the `sync.WaitGroup` type is nothing more than a structure with two
    fields:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 同步过程从定义一个 `sync.WaitGroup` 变量并使用 `Add()`、`Done()` 和 `Wait()` 方法开始。如果你查看 `sync`
    Go 包的源代码，特别是 `waitgroup.go` 文件，你会看到 `sync.WaitGroup` 类型不过是一个包含两个字段的结构的集合：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each call to `sync.Add()` increases a counter in the `state1` field, which is
    an array with three `uint32` elements. Notice that it is really important to call
    `sync.Add()` before the `go` statement in order to prevent any *race conditions*—we
    will learn about race conditions in the *Race conditions are bad* section. When
    each goroutine finishes its job, the `sync.Done()` function should be executed
    in order to decrease the same counter by one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `sync.Add()` 都会增加 `state1` 字段中的一个计数器，该字段是一个包含三个 `uint32` 元素的数组。请注意，在 `go`
    语句之前调用 `sync.Add()` 确实非常重要，以防止任何 *竞争条件*——我们将在 *竞争条件是坏事* 部分学习竞争条件。当每个 goroutine
    完成其工作后，应该执行 `sync.Done()` 函数以将相同的计数器减一。
- en: Behind the scenes, `sync.Done()` runs an `Add(-1)` call. The `Wait()` method
    waits until that counter becomes `0` in order to return. The return of `Wait()`
    inside the `main()` function means that `main()` is going to return and the program
    ends.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`sync.Done()` 执行一个 `Add(-1)` 调用。`Wait()` 方法等待该计数器变为 `0` 才返回。`main()` 函数内
    `Wait()` 的返回意味着 `main()` 将返回，程序结束。
- en: You can call `Add()` with a positive integer value other than 1 in order to
    avoid calling `Add(1)` multiple times. This can be handy when you know the number
    of goroutines you are going to create in advance. `Done()` does not support that
    functionality.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用除了 1 以外的正整数调用 `Add()`，以避免多次调用 `Add(1)`。当你事先知道将要创建的 goroutines 的数量时，这很有用。`Done()`
    不支持该功能。
- en: 'The important part of `varGoroutines.go` is the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`varGoroutines.go` 的重要部分如下：'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is where you create a `sync.WaitGroup` variable that you are going to use.
    The `fmt.Printf()` call prints the contents of the `sync.WaitGroup` structure—you
    do not usually do that but it is good for learning more about the `sync.WaitGroup`
    structure.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建你将要使用的 `sync.WaitGroup` 变量的地方。`fmt.Printf()` 调用打印出 `sync.WaitGroup` 结构的内容——你通常不会这样做，但这对学习
    `sync.WaitGroup` 结构很有帮助。
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We call `Add(1)` just before we create the goroutine in order to avoid race
    conditions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建 goroutine 之前调用 `Add(1)` 以避免竞争条件。
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Done()` call is going to be executed just before the anonymous function
    returns because of the `defer` keyword.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `defer` 关键字，`Done()` 调用将在匿名函数返回之前执行。
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Wait()` function waits for the counter in the `waitGroup` variable to become
    `0` before it returns, which is what we want to achieve.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wait()` 函数在返回之前等待 `waitGroup` 变量中的计数器变为 `0`，这正是我们想要达到的目标。'
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the `Wait()` function returns, the `fmt.Println()` statement is executed.
    No need to call `time.Sleep()` any more!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Wait()` 函数返回时，将执行 `fmt.Println()` 语句。不再需要调用 `time.Sleep()` 了！
- en: 'Running `varGoroutines.go` produces the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `varGoroutines.go` 产生以下输出：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Remember that using more goroutines in a program is not a panacea for performance,
    as more goroutines, in addition to the various calls to `sync.Add()`, `sync.Wait()`,
    and `sync.Done()`, might slow down your program due to the extra housekeeping
    that needs to be done by the Go scheduler and the Go garbage collector.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在程序中使用更多的goroutines并不是性能的万能药，因为更多的goroutines，除了对`sync.Add()`、`sync.Wait()`和`sync.Done()`的各种调用外，还可能因为Go调度器和Go垃圾收集器需要做的额外管理工作而减慢你的程序。
- en: What if the number of Add() and Done() calls differ?
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果Add()和Done()调用的次数不同怎么办？
- en: When the number of `sync.Add()` calls and `sync.Done()` calls are equal, everything
    is going to be fine in your programs. However, this subsection tells you what
    happens when these two numbers do not agree with each other.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当`sync.Add()`调用次数和`sync.Done()`调用次数相等时，你的程序将一切正常。然而，本小节将告诉你当这两个数字不一致时会发生什么。
- en: 'Without giving any command line parameters to `addDone.go`, the number of `Add()`
    calls is going to be smaller than the number of `Done()` calls. With at least
    one command line argument, the number of `Done()` calls is going to be smaller
    than the number of `Add()` calls. You can look at the Go code of `addDone.go`
    on your own. What is important is the output it generates. Running `addDone.go`
    without any command line arguments produces the following error message:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不给`addDone.go`提供任何命令行参数，`Add()`调用的次数将少于`Done()`调用的次数。如果有至少一个命令行参数，`Done()`调用的次数将少于`Add()`调用的次数。你可以自己查看`addDone.go`的Go代码。重要的是它生成的输出。不提供任何命令行参数运行`addDone.go`会产生以下错误信息：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The cause of the error message can be found in the output: `panic: sync: negative
    WaitGroup counter`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '错误信息的起因可以在输出中找到：`panic: sync: WaitGroup计数器为负`。'
- en: Sometimes, `addDone.go` does not produce any error messages and terminates just
    fine—**this mainly happens when the system is already busy**. This is an issue
    with concurrent programs in general—they do not always crash or misbehave as the
    order of execution can change, which might change the behavior of the program.
    This makes the debugging of concurrent software even more difficult.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`addDone.go`不会产生任何错误信息，并且可以正常终止——**这主要发生在系统已经非常繁忙的情况下**。这是并发程序的一般问题——它们并不总是崩溃或行为异常，因为执行顺序可能会改变，这可能会改变程序的行为。这使得并发软件的调试变得更加困难。
- en: 'Running `addDone.go` with one command line argument produces the following
    error message:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个命令行参数运行`addDone.go`会产生以下错误信息：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once again, the reason for the crash is printed on the screen: `fatal error:
    all goroutines are asleep - deadlock!`. This means that the program should wait
    indefinitely for a goroutine to finish—that is, for a `Done()` call that is never
    going to happen.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，崩溃的原因会打印在屏幕上：`致命错误：所有goroutines都处于休眠状态 - 死锁！`这意味着程序应该无限期地等待一个goroutine完成——也就是说，等待一个永远不会发生的`Done()`调用。
- en: Creating multiple files with goroutines
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用goroutines创建多个文件
- en: 'As a practical example of the use of goroutines, this subsection presents a
    command line utility that creates multiple files populated with randomly generated
    data—such files can be used for testing file systems or generating data for testing.
    The crucial code of `randomFiles.go` is the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为goroutines使用的一个实际例子，本小节介绍了一个命令行工具，该工具创建多个包含随机生成数据的文件——这些文件可用于测试文件系统或生成测试数据。`randomFiles.go`中的关键代码如下：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We first create a `sync.WaitGroup` variable in order to wait for all goroutines
    to finish in the right way. Each file is created by a single goroutine only. What
    is important here is that each file has a unique filename—this is implemented
    with the `filepath` variable that contains the value of the `for` loop counter.
    Multiple `createFile()` functions executed as goroutines create the files. This
    is a simple yet very efficient way of creating multiple files. Running `randomFiles.go`
    generates the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`sync.WaitGroup`变量，以便正确地等待所有goroutines完成。每个文件仅由一个goroutine创建。这里重要的是每个文件都有一个唯一的文件名——这是通过包含`for`循环计数器值的`filepath`变量实现的。多个`createFile()`函数作为goroutines执行来创建文件。这是一种简单但非常高效地创建多个文件的方法。运行`randomFiles.go`会生成以下输出：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, the utility requires four parameters, which are the first and last values
    of the `for` loop as well as the filename and the directory in which the files
    are going to be written. So, let us run the utility with the correct number of
    parameters:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个实用程序需要四个参数，分别是 `for` 循环的第一个和最后一个值，以及将要写入文件的文件名和目录。让我们使用正确的参数数量运行这个实用程序：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Everything looks fine, and four files have been created according to our instructions!
    Now that we know about goroutines, let us continue with channels.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很正常，根据我们的指示已经创建了四个文件！现在我们了解了goroutines，让我们继续学习通道。
- en: Channels
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道
- en: A channel is a communication mechanism that, among other things, allows goroutines
    to exchange data. Firstly, each channel allows the exchange of a particular data
    type, which is also called the element type of the channel, and secondly, for
    a channel to operate properly, you need someone to receive what is sent via the
    channel. You should declare a new channel using `make()` and the `chan` keyword
    (`make(chan int)`), and you can close a channel using the `close()` function.
    You can declare the size of a channel by writing something similar to `make(chan
    int, 1)`. This statement creates a **buffered channel** that has a different use—buffered
    channels are explained later in this chapter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是一种通信机制，它允许goroutines交换数据。首先，每个通道允许交换特定数据类型，这也被称为通道的元素类型；其次，为了使通道正常工作，需要有人接收通过通道发送的数据。您应该使用
    `make()` 函数和 `chan` 关键字（`make(chan int)`）来声明一个新的通道，并且可以使用 `close()` 函数关闭通道。您可以通过编写类似
    `make(chan int, 1)` 的代码来声明通道的大小。这个语句创建了一个**带缓冲的通道**，它有不同的用途——带缓冲的通道将在本章后面进行解释。
- en: Just because we can use channels, it does not mean that we should. If a simpler
    solution exists that allows goroutines to get executed and save the generated
    information, we should also consider that. The purpose of every developer should
    be to create a simple design, not to use all the features of a programming language.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就因为我们可以使用通道，并不意味着我们应该这样做。如果存在一个更简单的解决方案，允许goroutines执行并保存生成的信息，我们也应该考虑这一点。每个开发者的目的应该是创建一个简单的设计，而不是使用编程语言的所有功能。
- en: A pipeline is a virtual method for connecting goroutines and channels so that
    the output of one goroutine becomes the input of another goroutine using channels
    to transfer your data. One of the benefits that you get from using pipelines is
    that there is a constant data flow in your program, as no goroutine or channel
    has to wait for everything to be completed in order to start their execution.
    Additionally, you use fewer variables and, therefore, less memory space because
    you do not have to save everything as a variable. Finally, the use of pipelines
    simplifies the design of the program and improves its maintainability.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一种虚拟方法，用于连接goroutines和通道，使得一个goroutine的输出可以通过通道传输成为另一个goroutine的输入。使用管道的好处之一是，在您的程序中会有持续的数据流，因为没有goroutine或通道需要等待所有操作完成才能开始执行。此外，您使用的变量更少，因此内存空间也更少，因为您不需要将所有内容都保存为变量。最后，管道的使用简化了程序的设计并提高了其可维护性。
- en: Writing to and reading from a channel
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向通道写入和从通道读取
- en: Writing a value (`val`) to a channel (`ch`) is as easy as writing `ch <- val`.
    The arrow shows the direction of the value, and you will have no problem with
    this statement as long as both `var` and `ch` are of the same data type.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将值（`val`）写入通道（`ch`）就像写入 `ch <- val` 一样简单。箭头显示了值的方向，只要 `var` 和 `ch` 是相同的数据类型，您就不会对这个语句有任何问题。
- en: You can read a single value from a channel named `c` by executing `<-c`. In
    this case, the direction is from the channel to the outer world. You can save
    that value into a new variable using `aVar := <-c`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行 `<-c` 从名为 `c` 的通道中读取单个值。在这种情况下，方向是从通道到外部世界。您可以使用 `aVar := <-c` 将该值保存到一个新变量中。
- en: 'Both channel reading and writing are illustrated in `channels.go`, which comes
    with the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的读写操作在 `channels.go` 文件中有示例，以下代码展示了这一点：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function just writes a value to the channel and immediately closes it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只是将值写入通道，然后立即关闭它。
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This function just sends the `true` value to a `bool` channel.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只是将 `true` 值发送到一个 `bool` 通道。
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This channel is buffered with a size of 1\. This means that as soon as we fill
    that buffer, we can close the channel and the goroutine is going to continue its
    execution and return. A channel that is unbuffered has a different behavior: when
    you try to send a value to that channel, it blocks forever because it is waiting
    for someone to fetch that value. In this case, we definitely want a buffered channel
    in order to avoid any blocking.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此通道具有大小为 1 的缓冲区。这意味着一旦我们填满该缓冲区，我们就可以关闭通道，goroutine 将继续执行并返回。一个无缓冲的通道有不同的行为：当你尝试向该通道发送值时，它将永远阻塞，因为它正在等待有人取走该值。在这种情况下，我们确实需要一个缓冲通道，以避免任何阻塞。
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we read from the channel and print the value without storing it in a separate
    variable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从通道读取值并打印它，而不将其存储在单独的变量中。
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The previous code shows a technique for determining whether a channel is closed
    or not. In this case, we are ignoring the read value—if the channel was open,
    then the read value would be discarded.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码展示了确定通道是否关闭的技术。在这种情况下，我们正在忽略读取值——如果通道是打开的，那么读取值将被丢弃。
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we make an unbuffered channel and create five goroutines without any synchronization
    as we do not use any `Add()` calls.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个无缓冲的通道，并创建了五个goroutine，我们没有进行任何同步，因为我们没有使用任何 `Add()` 调用。
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `range` keyword works with channels! However, a `range` loop on a channel
    only exits when the channel is closed or uses the `break` keyword.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 关键字与通道一起工作！然而，在通道上的 `range` 循环只有在通道关闭或使用 `break` 关键字时才会退出。'
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We close the `ch` channel when a condition is met and exit the `for` loop using
    `break`. Note that it is never a good idea to close a channel on the receiving
    end—this is presented here for the sake of the example. You are going to see the
    consequences of this decision in a while.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足某个条件时，我们关闭 `ch` 通道并使用 `break` 退出 `for` 循环。请注意，在接收端关闭通道从来都不是一个好主意——这里展示是为了示例。你很快就会看到这个决定带来的后果。
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When trying to read from a closed channel, we get the zero value of its data
    type, so this `for` loop works just fine and does not cause any issues.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试从关闭的通道读取时，我们得到其数据类型的零值，因此这个 `for` 循环运行得很好，不会引起任何问题。
- en: 'Running `channels.go` generates the following output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `channels.go` 生成以下输出：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After writing the value `10` to the channel using `writeToChannel(c, 10)`, we
    read that value back.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `writeToChannel(c, 10)` 将值 `10` 写入通道后，我们读取该值。
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `for` loop with the `range` exits after three iterations—each iteration
    prints `true` on screen.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `range` 的 `for` 循环在三次迭代后退出——每次迭代在屏幕上打印 `true`。
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These five `false` values are printed by the last `for` loop of the program.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个 `false` 值是由程序的最后 `for` 循环打印的。
- en: Although everything looks fine with `channels.go`, there is a logical issue
    with it, which we will explain and resolve in the *Race conditions are bad* section.
    Additionally, if we run `channels.go` multiple times, it might crash. However,
    most of the time, it does not, which makes debugging even more challenging.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来 `channels.go` 没有问题，但它存在一个逻辑问题，我们将在 *竞争条件很糟糕* 部分进行解释和解决。此外，如果我们多次运行 `channels.go`，它可能会崩溃。然而，大多数时候它不会，这使得调试变得更加困难。
- en: Receiving from a closed channel
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从关闭的通道接收
- en: '**Reading from a closed channel returns the zero value of its data type**.
    However, if you try to write to a closed channel, your program is going to crash
    in a bad way (panic). These two situations are explored in `readCloseCh.go` and,
    more specifically, in the implementation of the `main()` function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**从关闭的通道读取返回其数据类型的零值**。然而，如果你尝试向关闭的通道写入，你的程序将以糟糕的方式崩溃（panic）。这两种情况在 `readCloseCh.go`
    中进行了探索，特别是在 `main()` 函数的实现中：'
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you make that an unbuffered channel, the program is going to crash.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其作为一个无缓冲的通道，程序将会崩溃。
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We write two values to the `willClose` channel.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `willClose` 通道写入两个值。
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then, we read and discard these two values and we close the channel.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们读取并丢弃这两个值，并关闭通道。
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The last value that we read from the channel is the zero value of a `complex64`
    data type. Running `readCloseCh.go` generates the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从通道读取的最后一个值是 `complex64` 数据类型的零值。运行 `readCloseCh.go` 生成以下输出：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So, we got back the zero value of the `complex64` data type. Now let us continue
    and discuss how to work with functions that accept channels as parameters.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了 `complex64` 数据类型的零值。现在让我们继续讨论如何处理接受通道作为参数的函数。
- en: Channels as function parameters
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将通道作为函数参数
- en: When using a channel as a function parameter, you can specify its direction—that
    is, whether it is going to be used for sending or receiving data only. In my opinion,
    if you know the purpose of a channel in advance, you should use this capability
    because it makes your programs more robust. You will not be able to send data
    accidentally to a channel from which you should only receive data, or receive
    data from a channel to which you should only be sending data.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用通道作为函数参数时，你可以指定其方向——也就是说，它是否仅用于发送或接收数据。在我看来，如果你事先知道通道的目的，你应该使用这个功能，因为它使你的程序更加健壮。你将无法意外地将数据发送到仅应接收数据的通道，或者从仅应发送数据的通道接收数据。
- en: If you declare that a channel function parameter is going to be used for reading
    only and you try to write to it, you are going to get a compile error message
    that will most likely save you from nasty bugs in the future. This is the major
    benefit of this approach!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明一个通道函数参数仅用于读取，而你尝试向其写入，你将得到一个编译错误信息，这很可能会让你在未来避免一些讨厌的bug。这是这种方法的重大好处！
- en: 'All these are illustrated in `channelFunc.go`—the implementation of the functions
    that accept channel parameters are the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在 `channelFunc.go` 中得到了说明——接受通道参数的函数的实现如下：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The above function accepts a channel parameter that is available for writing
    only.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的函数接受一个仅可用于写入的通道参数。
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The channel parameter of the above function is available for reading only.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的函数的通道参数仅可用于读取。
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The last function accepts two channel parameters. However, `out` is available
    for reading, whereas `in` is offered for writing. If you try to perform an operation
    on a channel parameter that is not allowed, the Go compiler is going to complain.
    This happens even if the function is not being used.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数接受两个通道参数。然而，`out` 仅可用于读取，而 `in` 则用于写入。如果你尝试对一个不允许的操作执行通道参数，Go编译器将会抱怨。即使函数没有被使用，这种情况也会发生。
- en: The subject of the next section is race conditions—read it carefully in order
    to avoid undefined behaviors and unpleasant situations when working with multiple
    goroutines.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节的主题是竞争条件——仔细阅读，以避免在处理多个goroutine时出现未定义的行为和令人不愉快的情况。
- en: Race conditions are bad
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞争条件是坏事
- en: A *data race condition* is a situation where two or more running elements, such
    as threads and goroutines, try to take control of or modify a shared resource
    or shared variable of a program. Strictly speaking, a data race occurs when two
    or more instructions access the same memory address, where at least one of them
    performs a write (change) operation. If all operations are read operations, then
    there is no race condition. In practice, this means that you might get different
    output if you run your program multiple times, and that is a bad thing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据竞争条件* 是一种情况，其中两个或多个正在运行的元素，例如线程和goroutine，试图控制或修改程序的一个共享资源或共享变量。严格来说，数据竞争发生在两个或多个指令访问相同的内存地址时，其中至少有一个执行了写（更改）操作。如果所有操作都是读取操作，则不存在竞争条件。在实践中，这意味着如果你多次运行程序，可能会得到不同的输出，这是不好的。'
- en: Using the `-race` flag when running or building Go source files executes the
    Go race detector, which makes the compiler create a modified version of a typical
    executable file. This modified version can record all accesses to shared variables
    as well as all synchronization events that take place, including calls to `sync.Mutex`
    and `sync.WaitGroup`, which are presented later on in this chapter. After analyzing
    the relevant events, the race detector prints a report that can help you identify
    potential problems so that you can correct them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行或构建Go源文件时使用 `-race` 标志将执行Go竞争检测器，这使得编译器创建一个典型的可执行文件的修改版本。这个修改版本可以记录所有对共享变量的访问以及所有发生的同步事件，包括对
    `sync.Mutex` 和 `sync.WaitGroup` 的调用，这些将在本章后面介绍。在分析相关事件后，竞争检测器会打印出一份报告，可以帮助你识别潜在的问题，以便你可以纠正它们。
- en: The Go race detector
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 竞争检测器
- en: 'You can run the race detector tool with `go run -race`. If we test `channels.go`
    using `go run -race`, we are going to get the following output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `go run -race` 运行竞争检测器工具。如果我们使用 `go run -race` 测试 `channels.go`，我们将得到以下输出：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Therefore, although `channels.go` looks fine at first, there is a race condition
    waiting to happen. Let us now discuss where the problem with `channels.go` lies
    based on the previous output. There is a closing of a channel at `channels.go`
    on line 54, and there is a write to the same channel on line 14 that looks to
    be the root of the race condition situation. Line 54 is `close(ch)`, whereas line
    14 is `ch <- true`. The issue is that we cannot be sure about what is going to
    happen and in which order—this is the race condition. If you execute `channels.go`
    without the race detector, it might work, but if you try it multiple times, you
    might get a `panic: send on closed channel` error message—this mainly has to do
    with the order in which the Go scheduler is going to run the goroutines of the
    program. So, if the closing of the channel happens first, then writing to that
    channel is going to fail—race condition!'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，尽管 `channels.go` 最初看起来没有问题，但其中存在一个等待发生的竞态条件。现在，让我们根据之前的输出讨论一下 `channels.go`
    中存在的问题。在 `channels.go` 的第 54 行有一个关闭通道的操作，而在第 14 行对同一个通道进行了写入操作，这看起来是竞态条件情况的根本原因。第
    54 行是 `close(ch)`，而第 14 行是 `ch <- true`。问题是，我们无法确定将要发生什么以及发生的顺序——这就是竞态条件。如果你在没有竞态检测器的情况下执行
    `channels.go`，它可能工作正常，但如果你多次尝试，你可能会得到 `panic: send on closed channel` 错误信息——这主要与
    Go 调度器将要运行的 goroutines 的顺序有关。因此，如果通道的关闭操作先发生，那么对该通道的写入操作将会失败——竞态条件！'
- en: 'Fixing `channels.go` requires changing the code and, more specifically, the
    implementation of the `printer()` function. The corrected version of `channels.go`
    is named `chRace.go` and comes with the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 修复 `channels.go` 需要更改代码，更具体地说，是更改 `printer()` 函数的实现。修正后的 `channels.go` 版本被命名为
    `chRace.go`，并包含以下代码：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first thing to notice is that instead of using multiple goroutines for writing
    to the desired channel, we use a single goroutine. **A single goroutine writing
    to a channel followed by the closing of that channel cannot create any race conditions
    because things happen sequentially**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们不是使用多个 goroutine 来写入所需的通道，而是使用单个 goroutine。**单个 goroutine 写入通道后关闭该通道不会创建任何竞态条件，因为事情是按顺序发生的**。
- en: 'Running `go run -race chRace.go` produces the following output, which means
    that there is no longer a race condition:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `go run -race chRace.go` 产生以下输出，这意味着不再存在竞态条件：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The next section is about the important and powerful `select` keyword.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是关于重要且强大的 `select` 关键字。
- en: The select keyword
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`select` 关键字'
- en: The `select` keyword is really important because it allows you to **listen to
    multiple channels at the same time**. A `select` block can have multiple cases
    and an optional `default` case, which mimics the `switch` statement. It is good
    for `select` blocks to have a timeout option just in case. Lastly, a `select`
    without any cases (`select{}`) waits forever.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 关键字非常重要，因为它允许你**同时监听多个通道**。一个 `select` 块可以有多个情况和一个可选的 `default` 情况，这类似于
    `switch` 语句。对于 `select` 块来说，有一个超时选项是很好的。最后，没有任何情况的 `select` (`select{}`) 将永远等待。'
- en: In practice, this means that `select` allows a goroutine to wait on multiple
    communication operations. So, `select` gives you the power to listen to multiple
    channels using a single select block. Consequently, you can have non-blocking
    operations on channels, provided that you have implemented your `select` blocks
    appropriately.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着 `select` 允许 goroutine 等待多个通信操作。因此，`select` 给你使用单个 `select` 块监听多个通道的能力。因此，只要你适当地实现了你的
    `select` 块，你就可以在通道上执行非阻塞操作。
- en: A `select` statement is **not evaluated sequentially**, as all of its channels
    are examined simultaneously. If none of the channels in a `select` statement are
    ready, the `select` statement blocks (waits) until one of the channels is ready.
    If multiple channels of a `select` statement are ready, then the Go runtime **makes
    a random selection** from the set of these ready channels.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `select` 语句**不是按顺序评估的**，因为它的所有通道都是同时检查的。如果一个 `select` 语句中的所有通道都没有准备好，那么 `select`
    语句将阻塞（等待），直到其中一个通道准备好。如果一个 `select` 语句中的多个通道都准备好了，那么 Go 运行时**从这些准备好通道的集合中随机选择**。
- en: 'The code in `select.go` presents a simple use of `select` running in a goroutine
    that has three cases. But first, let us see how the goroutine that contains `select`
    is executed:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`select.go` 中的代码展示了 `select` 在一个具有三个情况的 goroutine 中运行的简单用法。但首先，让我们看看包含 `select`
    的 goroutine 是如何执行的：'
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The previous code tells us that for `wg.Done()` to get executed, `gen()` should
    return first. So, let us see the implementation of `gen()`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码告诉我们，为了执行`wg.Done()`，`gen()`应该首先返回。那么，让我们看看`gen()`的实现：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The right thing to do here is to add the `return` statement for `gen()` to
    finish. Let us imagine that you have forgotten to add the `return` statement.
    This means that the function is not going to finish after the `select` branch
    associated with the end channel parameter is executed—`createNumber` is not going
    to end the function as it has no `return` statement. Therefore, the `select` block
    keeps waiting for more. The solution can be found in the code that follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里正确的事情是为`gen()`函数添加`return`语句以结束。让我们假设你忘记添加了`return`语句。这意味着在执行与结束通道参数相关的`select`分支之后，函数不会结束——`createNumber`不会结束函数，因为它没有`return`语句。因此，`select`块一直在等待更多。解决方案可以在下面的代码中找到：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, what is really happening in the code of the entire select block? This particular
    `select` statement has three cases. As stated earlier, `select` does not require
    a `default` branch. You can consider the third branch of the `select` statement
    as a clever `default` branch. This happens because `time.After()` waits for the
    specified duration (`4 * time.Second`) to elapse and then prints a message and
    properly ends `gen()` with `return`. This unblocks the `select` statement in case
    all of the other channels are blocked for some reason. Although omitting `return`
    from the second branch is a bug, this shows that having an exit strategy is always
    a good thing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，整个`select`块中的代码实际上在发生什么呢？这个特定的`select`语句有三个情况。如前所述，`select`不需要`default`分支。你可以将`select`语句的第三个分支视为一个巧妙的`default`分支。这是因为`time.After()`等待指定的持续时间（`4
    * time.Second`）过去，然后打印一条消息，并使用`return`正确地结束`gen()`。这在这种情况下解除了`select`语句的阻塞，即所有其他通道由于某种原因而阻塞。尽管省略第二个分支的`return`是一个错误，但这表明有一个退出策略始终是一件好事。
- en: 'Running `select.go` produces the following output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`select.go`产生以下输出：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We are going to see `select` in action in the remainder of the chapter, starting
    from the next section, which discusses how to time out goroutines. What you should
    remember is that `select` allows us to **listen to multiple channels from a single
    point**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的剩余部分看到`select`的实际应用，从下一节开始，该节讨论如何超时goroutines。你应该记住的是，`select`允许我们从单个点**监听多个通道**。
- en: Timing out a goroutine
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时goroutine
- en: There are times when goroutines take more time than expected to finish—in such
    situations, we want to time out the goroutines so that we can unblock the program.
    This section presents two such techniques.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候goroutines完成所需的时间比预期的要长——在这种情况下，我们希望goroutines超时，这样我们就可以解除程序的阻塞。本节介绍了两种这样的技术。
- en: Timing out a goroutine inside main()
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`main()`函数中超时goroutine
- en: 'This subsection presents a simple technique for timing out a goroutine. The
    relevant code can be found in the `main()` function of `timeOut1.go`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节介绍了一种超时goroutine的简单技术。相关代码可以在`timeOut1.go`的`main()`函数中找到：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `time.Sleep()` call is used for emulating the time it normally takes for
    a function to finish its operation. In this case, the anonymous function that
    is executed as a goroutine takes about three seconds before writing a message
    to the `c1` channel.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Sleep()`调用用于模拟函数完成其操作所需的时间。在这种情况下，作为goroutine执行的匿名函数在向`c1`通道发送消息之前大约需要三秒钟。'
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The purpose of the `time.After()` call is to wait for the desired time before
    being executed—if another branch is executed, the waiting time resets. In this
    case, we are not interested in the actual value returned by `time.After()` but
    in the fact that the `time.After()` branch was executed, which means that the
    waiting time has passed. In this case, as the value passed to the `time.After()`
    function is smaller than the value used in the `time.Sleep()` call that was executed
    previously, you will most likely get a timeout message. The reason for saying
    “most likely” is that Linux is not a real-time OS and, sometimes, the OS scheduler
    plays strange games, especially when it has to deal with a high load and has to
    schedule lots of tasks—this means that you should not make any assumptions about
    the operation of the OS scheduler.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.After()` 调用的目的是在执行前等待所需的时间——如果执行了另一个分支，等待时间将重置。在这种情况下，我们并不关心 `time.After()`
    返回的实际值，而是关心 `time.After()` 分支是否已执行，这意味着等待时间已经过去。在这种情况下，由于传递给 `time.After()` 函数的值小于之前执行
    `time.Sleep()` 调用所使用的值，你很可能会收到超时消息。说“很可能”的原因是 Linux 不是一个实时操作系统，有时操作系统调度器会玩一些奇怪的游戏，尤其是在它必须处理高负载并调度大量任务时——这意味着你不应该对操作系统调度器的操作有任何假设。'
- en: '[PRE53]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding code executes a goroutine that takes about three seconds to execute
    because of the `time.Sleep()` call and defines a timeout period of four seconds
    in select using `time.After(4 * time.Second)`. If the `time.After(4 * time.Second)`
    call returns after you get a value from the `c2` channel found in the first case
    of the `select` block, then there will be no timeout; otherwise, you will get
    a timeout. However, in this case, the value of the `time.After()` call provides
    enough time for the `time.Sleep()` call to return, so you will most likely not
    get a timeout message here.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码执行了一个需要大约三秒钟来执行 goroutine，因为 `time.Sleep()` 调用，并在 `select` 中使用 `time.After(4
    * time.Second)` 定义了四秒的超时期。如果在 `select` 块的第一个情况中从 `c2` 通道获取值之后 `time.After(4 *
    time.Second)` 调用返回，则不会有超时；否则，你会收到超时。然而，在这种情况下，`time.After()` 调用的值提供了足够的时间让 `time.Sleep()`
    调用返回，所以你很可能会在这里不会收到超时消息。
- en: 'Let us now verify our thoughts. Running `timeOut1.go` produces the following
    output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在验证我们的想法。运行 `timeOut1.go` 产生以下输出：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As expected, the first goroutine timed out, whereas the second one did not.
    The subsection that follows presents another timeout technique.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，第一个 goroutine 超时了，而第二个没有。接下来的一小节将介绍另一种超时技术。
- en: Timing out a goroutine outside main()
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 `main()` 外部超时 goroutine
- en: This subsection illustrates another technique for timing out goroutines. The
    `select` statement can be found in a separate function. Additionally, the timeout
    period is given as a command line argument.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小节说明了另一个用于超时 goroutine 的技术。`select` 语句可以在一个单独的函数中找到。此外，超时期作为命令行参数给出。
- en: 'The interesting part of `timeOut2.go` is the implementation of `timeout()`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeOut2.go` 的有趣之处在于 `timeout()` 的实现：'
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In `timeout()`, the time duration that is used in the `time.After()` call is
    a function parameter, which means that it can vary. Once again, the `select` block
    supports the logic of the timeout. Any timeout period longer than 5 seconds will
    most likely give the goroutine enough time to finish. If `timeout()` writes `false`
    to the `result` channel, then there is no timeout, whereas if it writes `true`,
    there is a timeout. Running `timeOut2.go` produces the following output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `timeout()` 中，`time.After()` 调用中使用的持续时间是一个函数参数，这意味着它可以变化。再次强调，`select` 块支持超时逻辑。任何超过
    5 秒的超时期都很可能给 goroutine 足够的时间完成。如果 `timeout()` 将 `false` 写入 `result` 通道，则没有超时；如果写入
    `true`，则有超时。运行 `timeOut2.go` 产生以下输出：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The timeout period is 100 milliseconds, which means that the goroutine did not
    have enough time to finish, hence the timeout message.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 超时期是 100 毫秒，这意味着 goroutine 没有足够的时间完成，因此收到超时消息。
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This time, the timeout is 5,500 milliseconds, which means that the goroutine
    had enough time to finish.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，超时时间是 5,500 毫秒，这意味着 goroutine 有足够的时间完成。
- en: The next section revisits and presents advanced concepts related to channels.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分回顾并介绍了与通道相关的高级概念。
- en: Go channels revisited
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次回顾 Go 通道
- en: So far, we have seen the basic usages of channels—this section presents the
    definition and the usage of `nil` channels, signal channels, and buffered channels.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了通道的基本用法——本节介绍了 `nil` 通道、信号通道和缓冲通道的定义和用法。
- en: Although channels seem like an interesting concept, they are not the answer
    to every concurrency problem as there exist times when they can be replaced by
    mutexes and shared memory. So, **do not force the use of channels**.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通道看起来像是一个有趣的概念，但它们并不是每个并发问题的答案，因为存在一些时候它们可以被互斥锁和共享内存所替代。所以，**不要强迫使用通道**。
- en: It helps to remember that the zero value of the channel type is `nil`, and if
    you send a message to a closed channel, the program panics. However, if you try
    to read from a closed channel, you get the zero value of the type of that channel.
    So, after closing a channel, you can no longer write to it but you can still read
    from it. To be able to close a channel, the channel must not be receive-only.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 记住通道类型的零值是`nil`，如果你向一个关闭的通道发送消息，程序会崩溃。然而，如果你尝试从关闭的通道读取，你会得到该通道类型的零值。因此，在关闭通道后，你不能再向其写入，但仍然可以从中读取。要能够关闭通道，该通道不能是只读的。
- en: 'Additionally, a `nil` channel always blocks, which means that both reading
    and writing from `nil` channels block. This property of channels can be very useful
    when you want to disable a branch of a `select` statement by assigning the `nil`
    value to a channel variable. Finally, if you try to close a `nil` channel, your
    program is going to panic. This is best illustrated in the `closeNil.go` program:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个`nil`通道总是阻塞的，这意味着从`nil`通道读取和写入都会阻塞。当你想通过将`nil`值分配给通道变量来禁用`select`语句的一个分支时，这个通道属性非常有用。最后，如果你尝试关闭一个`nil`通道，你的程序将会崩溃。这最好在`closeNil.go`程序中说明：
- en: '[PRE58]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The previous statement defines a `nil` channel named `c` of the type `string`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的声明定义了一个名为`c`的`nil`通道，其类型为`string`。
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Running `closeNil.go` generates the following output:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`closeNil.go`会生成以下输出：
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The previous output shows the message you are going to get if you try to close
    a `nil` channel. Let us now discuss buffered channels.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示了如果你尝试关闭一个`nil`通道时将收到的消息。现在让我们来讨论带缓冲的通道。
- en: Buffered channels
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带缓冲的通道
- en: Unlike unbuffered channels, which have a capacity of 0 and require a sender
    to have a corresponding receiver ready at the other end, buffered channels allow
    a certain number of values to be sent into the channel before a receiver is needed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与容量为0的无缓冲通道不同，无缓冲通道需要发送方在另一端有一个相应的接收方准备就绪，带缓冲的通道允许在需要接收方之前向通道发送一定数量的值。
- en: These channels allow us to put jobs in a queue quickly to be able to deal with
    more requests and process requests later on. Moreover, you can use buffered channels
    as semaphores to limit the throughput of your application.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通道允许我们快速将工作放入队列，以便能够处理更多请求并在稍后处理请求。此外，你可以使用带缓冲的通道作为信号量来限制应用程序的吞吐量。
- en: 'The presented technique works as follows: all incoming requests are forwarded
    to a channel, which processes them one by one. When the channel is done processing
    a request, it sends a message to the original caller saying that it is ready to
    process a new one. So, **the capacity of the buffer of the channel restricts the
    number of simultaneous requests that it can keep**. Bear in mind that it is not
    the channel that processes the requests or sends the messages.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的技术工作原理如下：所有传入的请求都被转发到一个通道，该通道逐个处理它们。当通道完成处理一个请求后，它会向原始调用者发送一条消息，表示它已准备好处理新的请求。因此，**通道缓冲区的容量限制了它可以同时保持的请求数量**。请记住，不是通道在处理请求或发送消息。
- en: 'Also, bear in mind that a buffered channel keeps accepting data until it blocks
    due to its limited capacity. However, in the presented example, the implementation
    is what cancels remaining requests after the channel buffer is full due to the
    `select` statement, not the channel itself. The source file that implements the
    technique is named `bufChannel.go` and contains the following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，带缓冲的通道会一直接受数据，直到由于容量限制而阻塞。然而，在所展示的例子中，实现是通过`select`语句取消剩余请求，而不是通道本身。实现该技术的源文件名为`bufChannel.go`，并包含以下代码：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `numbers` channel can store up to five integers because it is a buffer channel
    with a capacity of 5.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`numbers`通道可以存储最多五个整数，因为它是一个容量为5的缓冲通道。'
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We begin putting data into `numbers`—however, when the channel is full, it is
    not going to store more data and the `default` branch is going to be executed.
    This is not because of the way channels work but because of the specific implementation
    with `select`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '我们开始向`numbers`中放入数据——然而，当通道满时，它将不会存储更多数据，并将执行`default`分支。这并不是因为通道的工作方式，而是因为与`select`的具体实现有关。 '
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Similarly, we try to read data from numbers using a `for` loop. When all data
    from the channel is read, the `default` branch is going to be executed and will
    terminate the program with its `return` statement—when `main()` returns, the entire
    program will be terminated.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们尝试使用 `for` 循环从数字中读取数据。当从通道读取所有数据后，`default` 分支将被执行，并使用其 `return` 语句终止程序——当
    `main()` 返回时，整个程序将被终止。
- en: 'Running `bufChannel.go` produces the following output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `bufChannel.go` 产生以下输出：
- en: '[PRE64]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Let us now discuss `nil` channels.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在讨论 `nil` 通道。
- en: nil channels
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空通道
- en: '`nil` channels **always block**! Therefore, you should use them when you want
    that behavior on purpose! The code that follows illustrates `nil` channels:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`nil` 通道**总是阻塞**！因此，当你故意想要这种行为时，你应该使用它们！下面的代码演示了 `nil` 通道：'
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We are making `wg` a global variable in order to be available from anywhere
    in the code and avoid passing it to every function that needs it as a parameter.
    This is not idiomatic Go and some people might dislike that approach, despite
    its simpler implementation. An alternative would be to declare `wg` in `main()`
    and pass a pointer to each function that needs it—you can implement that as an
    exercise.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `wg` 声明为全局变量，以便在代码的任何地方都可以访问它，并避免将其作为参数传递给每个需要它的函数。这不是 Go 的惯用用法，尽管它的实现更简单，有些人可能不喜欢这种方法。一个替代方案是在
    `main()` 中声明 `wg` 并将指针传递给每个需要它的函数——你可以将其作为练习来实现。
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `send()` function keeps sending random numbers to channel `c`. Do not confuse
    channel `c`, which is a (channel) function parameter, with channel `t.C`, which
    is part of timer `t`—you can change the name of the `c` variable but not the name
    of the `C` field of a timer. When the time of timer `t` expires, the timer sends
    a value to the `t.C` channel.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()` 函数持续向通道 `c` 发送随机数字。不要混淆通道 `c`，它是一个（通道）函数参数，与定时器 `t` 的部分 `t.C` 相区别——你可以更改
    `c` 变量的名称，但不能更改定时器中 `C` 字段的名称。当定时器 `t` 的计时结束，定时器会向 `t.C` 通道发送一个值。'
- en: This triggers the execution of the relevant branch of the `select` statement,
    which assigns the value `nil` to channel `c` and prints the value of the `sum`
    variable, and `wg.Done()` is executed, which is going to unblock `wg.Wait()` found
    in the `main()` function. Additionally, as `c` becomes `nil`, it stops/blocks
    `send()` from sending more data to it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这触发了 `select` 语句相关分支的执行，将值 `nil` 赋予通道 `c` 并打印 `sum` 变量的值，然后执行 `wg.Done()`，这将解除
    `main()` 函数中找到的 `wg.Wait()` 的阻塞。此外，由于 `c` 变为 `nil`，它停止/阻塞 `send()` 向其发送更多数据。
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Running `nilChannel.go` produces the following output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `nilChannel.go` 产生以下输出：
- en: '[PRE68]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Since the number of times that the first branch of the `select` statement in
    `add()` is going to be executed is not fixed, you get different results each time
    you execute `nilChannel.go`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `add()` 函数中 `select` 语句的第一个分支将要执行的次数是不确定的，所以每次执行 `nilChannel.go` 时，你都会得到不同的结果。
- en: The next subsection discusses worker pools.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节讨论工作池。
- en: Worker pools
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作池
- en: 'A worker pool is a **set of threads that process jobs assigned to them**. The
    Apache web server and the `net/http` package of Go more or less work this way:
    the main process accepts all incoming requests, which are forwarded to worker
    processes to get served. Once a worker process has finished its job, it is ready
    to serve a new client.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 工作池是一组**处理分配给它们的任务的线程**。Apache 网络服务器和 Go 的 `net/http` 包大致以这种方式工作：主进程接受所有传入的请求，然后将它们转发给工作进程以提供服务。一旦工作进程完成其任务，它就准备好为新客户端提供服务。
- en: As Go does not have threads, the presented implementation is going to use goroutines
    instead of threads. Additionally, threads do not usually die after serving a request
    because the cost of ending a thread and creating a new one is too high, whereas
    goroutines do die after finishing their job. Worker pools in Go are implemented
    with the help of buffered channels, as they allow you to limit the number of goroutines
    running at the same time.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Go 没有线程，所提供的实现将使用 goroutine 而不是线程。此外，线程在服务请求后通常不会死亡，因为结束线程和创建新线程的成本太高，而 goroutine
    在完成任务后会死亡。Go 中的工作池通过使用带缓冲的通道来实现，因为它们允许你限制同时运行的 goroutine 的数量。
- en: 'The presented utility implements a simple task: it processes integers and prints
    their square values using a single goroutine for serving each request. The code
    of `wPools.go` is as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 所提供的实用程序实现了一个简单的任务：它使用单个goroutine为每个请求提供服务，处理整数并打印它们的平方值。`wPools.go` 的代码如下：
- en: '[PRE69]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `Client` structure is used for keeping track of the requests that the program
    is going to process.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client` 结构用于跟踪程序将要处理的请求。'
- en: '[PRE70]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `Result` structure is used for keeping the data of each `Client` as well
    as the results generated by the client. Put simply, the `Client` structure holds
    the input data of each request, whereas `Result` holds the results of a request—if
    you want to process more complex data, you should modify these structures.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result` 结构用于保存每个 `Client` 的数据以及客户端生成的结果。简单来说，`Client` 结构持有每个请求的输入数据，而 `Result`
    持有请求的结果——如果你想处理更复杂的数据，你应该修改这些结构。'
- en: '[PRE71]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `clients` and `data` buffered channels are used to get new client requests
    and write the results, respectively. If you want your program to run faster, you
    can increase the value of `size`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`clients` 和 `data` 缓冲通道分别用于获取新的客户端请求和写入结果。如果你想使程序运行得更快，可以增加 `size` 的值。'
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `worker()` function processes requests by reading the `clients` channel.
    Once the processing is complete, the result is written to the `data` channel.
    The delay that is introduced with `time.Sleep()` is not necessary but it gives
    you a better sense of the way that the generated output is printed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`worker()` 函数通过读取 `clients` 通道来处理请求。一旦处理完成，结果将被写入 `data` 通道。使用 `time.Sleep()`
    引入的延迟不是必需的，但它能更好地让你理解生成的输出是如何打印的。'
- en: '[PRE73]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The purpose of the `create()` function is to create all requests properly and
    then send them to the `clients` buffered channel for processing. Note that the
    `clients` channel is read by `worker()`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`create()` 函数的目的是正确创建所有请求，然后将它们发送到 `clients` 缓冲通道进行处理。请注意，`clients` 通道由 `worker()`
    读取。'
- en: '[PRE74]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the preceding code, you read the command line parameters that define the
    number of jobs and workers. If the number of jobs is greater than the number of
    workers, the jobs are served in smaller chunks.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你读取了定义作业和工作线程数量的命令行参数。如果作业数量大于工作线程数量，作业将以较小的块提供服务。
- en: '[PRE75]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `create()` call mimics the client requests that you are going to process.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`create()` 调用模拟了你将要处理的客户端请求。'
- en: '[PRE76]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `finished` channel is used for blocking the program and, therefore, needs
    no particular data type.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`finished` 通道用于阻塞程序，因此不需要特定的数据类型。'
- en: '[PRE77]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `finished <- true` statement is used for unblocking the program as soon
    as the `for` `range` loop ends. The `for range` loop ends when the `data` channel
    is closed, which happens after `wg.Wait()`, which means after all workers have
    finished.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`finished <- true` 语句用于在 `for range` 循环结束时立即解除程序阻塞。`for range` 循环在 `data` 通道关闭时结束，这发生在
    `wg.Wait()` 之后，意味着所有工作线程都已完成。'
- en: '[PRE78]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The purpose of the previous `for` loop is to generate the required number of
    `worker()` goroutines to process all requests.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个 `for` 循环的目的是生成所需的 `worker()` 协程数量以处理所有请求。
- en: '[PRE79]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `<-finished` statement in `fmt.Printf()` blocks until the `finished` channel
    is closed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Printf()` 中的 `<-finished` 语句会阻塞，直到 `finished` 通道关闭。'
- en: 'Running `wPools.go` creates the following kind of output:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `wPools.go` 会创建以下类型的输出：
- en: '[PRE80]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The previous output shows that all requests were processed. This technique allows
    you to serve a given number of requests, which saves you from server overload.
    The price you pay for that is having to write more code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示所有请求都已处理。这种技术允许你服务一定数量的请求，从而避免服务器过载。为此，你需要编写更多的代码。
- en: The next subsection introduces signal channels and shows a technique for using
    them to define the order of execution for a small number of goroutines.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将介绍信号通道，并展示一种使用它们为少量协程定义执行顺序的技术。
- en: Signal channels
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号通道
- en: A signal channel is one that is used just for signaling. Put simply, you can
    use a signal channel when you want to inform another goroutine about something.
    Signal channels should not be used for data transferring. You are going to see
    signal channels in action in the next subsection where we specify the order of
    execution of goroutines.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通道是仅用于信号的一种通道。简单来说，当你想通知另一个协程某事时，可以使用信号通道。信号通道不应用于数据传输。你将在下一小节中看到信号通道的实际应用，我们将指定协程的执行顺序。
- en: Specifying the order of execution for your goroutines
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为你的协程指定执行顺序
- en: This subsection presents a technique for specifying the order of execution of
    goroutines using signal channels. However, keep in mind that this technique works
    best when you are dealing with a small number of goroutines. The presented code
    example has four goroutines that we want to execute in the desired order—first,
    the goroutine for function `A()`, then function `B()`, then `C()`, and finally,
    `D()`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节介绍了一种使用信号通道指定goroutines执行顺序的技术。然而，请注意，当处理少量goroutines时，这种技术效果最佳。所提供的代码示例有四个goroutines，我们希望按以下顺序执行它们——首先，函数`A()`的goroutine，然后是函数`B()`，接着是`C()`，最后是`D()`。
- en: 'The code of `defineOrder.go` without the `package` statement and `import` block
    is the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`defineOrder.go`的代码（不包括`package`语句和`import`块）如下：'
- en: '[PRE81]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Function `A()` is going to be blocked until channel `a`, which is passed as
    a parameter, is closed. Just before it ends, it closes channel `b`, which is passed
    as a parameter. This is going to unblock the next goroutine, which is going to
    be function `B()`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`A()`将被阻塞，直到作为参数传递的通道`a`被关闭。在它结束之前，它会关闭作为参数传递的通道`b`。这将解除下一个goroutine的阻塞，该goroutine将是函数`B()`。
- en: '[PRE82]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Similarly, function `B()` is going to be blocked until channel `a`, which is
    passed as a parameter, is closed. Just before `B()` ends, it closes channel `b`,
    which is passed as a parameter. As before, this is going to unblock the following
    function:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，函数`B()`将被阻塞，直到作为参数传递的通道`a`被关闭。在`B()`结束之前，它会关闭作为参数传递的通道`b`。正如之前一样，这将解除后续函数的阻塞：
- en: '[PRE83]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As it happened with functions `A()` and `B()`, the execution of function `C()`
    is blocked by channel `a`. Just before it ends, it closes channel `b`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数`A()`和`B()`的情况一样，函数`C()`的执行被通道`a`阻塞。在它结束之前，它会关闭通道`b`。
- en: '[PRE84]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This is the last function that is going to be executed. Therefore, although
    it is blocked, it does not close any channels before exiting. Additionally, being
    the last function means that it can be executed more than once, which is not true
    for functions `A()`, `B()`, and `C()` because a channel can be closed only once.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将要执行的最后一个函数。因此，尽管它被阻塞了，但在退出之前不会关闭任何通道。此外，作为最后一个函数，它可能被执行多次，这与函数`A()`、`B()`和`C()`不同，因为通道只能关闭一次。
- en: '[PRE85]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We need to have as many channels as the number of functions we want to execute
    as goroutines.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要拥有与我们要作为goroutines执行的函数数量一样多的通道。
- en: '[PRE86]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This proves that the order of execution dictated by the Go code does not matter
    as `D()` is going to be executed last.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了由Go代码指定的执行顺序并不重要，因为`D()`将是最后一个被执行的。
- en: '[PRE87]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Although we run `C()` before `B()`, `C()` is going to finish after `B()` has
    finished.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在`B()`之前运行`C()`，但`C()`将在`B()`完成后完成。
- en: '[PRE88]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The closing of the first channel is what triggers the execution of the goroutines
    because this unblocks `A()`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 首个通道的关闭触发了goroutines的执行，因为这样可以解除`A()`的阻塞。
- en: '[PRE89]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Running `defineOrder.go` produces the following output:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`defineOrder.go`会产生以下输出：
- en: '[PRE90]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: So, the four functions, which are executed as goroutines, are executed in the
    desired order, and, in the case of the last function, the desired number of times.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为goroutines执行的四个函数将按所需顺序执行，并且在最后一个函数的情况下，执行所需的次数。
- en: Handling UNIX signals
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理UNIX信号
- en: UNIX signals offer a very handy way of interacting asynchronously with applications
    and server processes. UNIX signal handling in Go requires the use of channels
    that are used exclusively for this task. The presented program handles `SIGINT`
    (which is called `syscall.SIGINT` in Go) and `SIGINFO` separately and uses a `default`
    case in a `switch` block for handling the remaining signals. The implementation
    of that `switch` block allows you to differentiate between the various signals
    according to your needs.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX信号提供了一种非常方便的方式与异步交互应用程序和服务器进程。在Go中处理UNIX信号需要使用仅用于此任务的通道。所提供的程序分别处理`SIGINT`（在Go中称为`syscall.SIGINT`）和`SIGINFO`，并在`switch`块中使用`default`情况来处理剩余的信号。该`switch`块的实现允许您根据需要区分不同的信号。
- en: There exists a dedicated channel that receives all signals, as defined by the
    `signal.Notify()` function. Go channels can have a capacity—the capacity of this
    particular channel is 1 in order to be able to receive and keep **one signal at
    a time**. This makes perfect sense as a signal can terminate a program and there
    is no need to try to handle another signal at the same time. There is usually
    an anonymous function that is executed as a goroutine and performs the signal
    handling and nothing else. The main task of that goroutine is to listen to the
    channel for data. Once a signal is received, it is sent to that channel, read
    by the goroutine, and stored into a variable—at this point, the channel can receive
    more signals. That variable is processed by a `switch` statement.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个专门的通道，用于接收所有信号，如 `signal.Notify()` 函数定义。Go 通道可以有容量——这个特定通道的容量是 1，以便能够一次接收并保持
    **一个信号**。这完全合理，因为信号可以终止程序，而且没有必要同时尝试处理另一个信号。通常有一个匿名函数作为 goroutine 执行，并执行信号处理而无需做其他事情。该
    goroutine 的主要任务是监听通道中的数据。一旦接收到信号，它就会被发送到该通道，由 goroutine 读取，并存储到一个变量中——此时，通道可以接收更多信号。该变量通过
    `switch` 语句进行处理。
- en: Some signals cannot be caught, and the operating system cannot ignore them.
    So, the `SIGKILL` and `SIGSTOP` signals cannot be blocked, caught, or ignored;
    the reason for this is that they allow privileged users as well as the UNIX kernel
    to terminate any process they desire.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有些信号无法捕获，操作系统也不能忽略它们。因此，`SIGKILL` 和 `SIGSTOP` 信号不能被阻塞、捕获或忽略；这是因为它们允许特权用户以及 UNIX
    内核终止他们想要的任何进程。
- en: Create a text file by typing the following code—a good filename for it would
    be `signals.go`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下代码创建一个文本文件——一个好的文件名可以是 `signals.go`。
- en: '[PRE91]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`handleSignal()` is a separate function for handling signals. However, you
    can also handle signals inline, in the branches of a `switch` statement.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleSignal()` 是一个用于处理信号的独立函数。然而，你也可以在 `switch` 语句的分支中直接处理信号。'
- en: '[PRE92]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We create a channel with data of the type `os.Signal` because all channels must
    have a type.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个类型为 `os.Signal` 的通道，因为所有通道都必须有类型。
- en: '[PRE93]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The previous statement means handling all signals that can be handled.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句意味着处理所有可以处理的信号。
- en: '[PRE94]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Wait until you read data (<-) from the `sigs` channel and store it in the `sig`
    variable.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 等待从 `sigs` 通道读取数据（< -）并将其存储在 `sig` 变量中。
- en: '[PRE95]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Depending on the read value, act accordingly. This is how you differentiate
    between signals.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 根据读取的值，相应地采取行动。这就是如何区分不同的信号。
- en: '[PRE96]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: For the handling of `syscall.SIGINT`, we calculate the time that has passed
    since the beginning of the program execution and print it on the screen.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理 `syscall.SIGINT`，我们计算程序执行开始以来经过的时间，并将其打印在屏幕上。
- en: '[PRE97]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The code of the `syscall.SIGINFO` case calls the `handleSignal()` function—it
    is up to the developer to decide on the details of the implementation.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`syscall.SIGINFO` 情况的代码调用 `handleSignal()` 函数——开发者需要决定实现的细节。'
- en: On Linux machines, you should replace `syscall.SIGINFO` with another signal
    such as `syscall.SIGUSR1` or `syscall.SIGUSR2` because `syscall.SIGINFO` is not
    available on Linux ([https://github.com/golang/go/issues/1653](https://github.com/golang/go/issues/1653)).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 机器上，你应该将 `syscall.SIGINFO` 替换为另一个信号，例如 `syscall.SIGUSR1` 或 `syscall.SIGUSR2`，因为
    Linux 上没有 `syscall.SIGINFO` ([https://github.com/golang/go/issues/1653](https://github.com/golang/go/issues/1653))。
- en: '[PRE98]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: If there is no match, the `default` case handles the rest of the values and
    just prints a message.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配项，`default` 情况将处理剩余的值，并只打印一条消息。
- en: '[PRE99]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The endless for loop at the end of the `main()` function is for emulating the
    operation of a real program. Without an endless `for` loop, the program exits
    almost immediately.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数末尾的无穷循环是为了模拟真实程序的操作。如果没有无穷的 `for` 循环，程序几乎会立即退出。'
- en: 'Running `signals.go` and interacting with it creates the following kind of
    output:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `signals.go` 并与之交互会产生以下类型的输出：
- en: '[PRE100]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The second line of output was generated by pressing *Ctrl* + *C* on the keyboard,
    which, on UNIX machines, sends the `syscall.SIGINT` signal to the program. The
    third line of output was caused by executing `kill -USR1 74252` on a different
    terminal. The last line of the output was generated by the `kill -9 74252` command.
    As the `KILL` signal (which is also represented by the number 9) cannot be handled,
    it terminates the program, and the shell prints the `killed` message.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第二行是在键盘上按下 *Ctrl* + *C* 生成的，这在 UNIX 机器上会将 `syscall.SIGINT` 信号发送到程序。输出的第三行是由在另一个终端上执行
    `kill -USR1 74252` 造成的。输出的最后一行是由 `kill -9 74252` 命令生成的。由于 `KILL` 信号（也用数字 9 表示）无法处理，它终止了程序，并打印出
    `killed` 消息。
- en: Handling two signals
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理两个信号
- en: 'If you want to handle a limited number of signals instead of all of them, you
    should replace the `signal.Notify(sigs)` statement with a statement like the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想处理有限数量的信号而不是所有信号，您应该将 `signal.Notify(sigs)` 语句替换为以下类似语句：
- en: '[PRE101]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: After that, you need to make the appropriate changes to the code of the goroutine
    responsible for signal handling in order to identify and handle `syscall.SIGINT`
    and `syscall.SIGINFO`—the current version (`signals.go`) already handles both
    of them.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您需要相应地修改负责信号处理的 goroutine 的代码，以便识别和处理 `syscall.SIGINT` 和 `syscall.SIGINFO`——当前版本（`signals.go`）已经处理了这两个信号。
- en: The next section talks about shared memory and shared variables, which is a
    very handy way of making goroutines communicate with each other with the use of
    channels.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论共享内存和共享变量，这是一种非常方便的方法，通过使用通道使goroutines之间相互通信。
- en: Shared memory and shared variables
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享内存和共享变量
- en: Shared memory and shared variables are huge topics in concurrent programming
    and the most common ways for UNIX threads to communicate with each other. The
    same principles apply to Go and goroutines, which is what this section is about.
    **A mutex variable, which is the abbreviation for a mutual exclusion variable,
    is mainly used for thread synchronization and for protecting shared data when
    multiple writes or a write and a read can occur at the same time**. A mutex works
    like a buffered channel with a capacity of one, which allows, at most, one goroutine
    to access a shared variable at any given time. This means that there is no way
    for two or more goroutines to be able to update that variable simultaneously.
    Go offers the `sync.Mutex` and `sync.RWMutex` data types.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存和共享变量是并发编程中的巨大主题，也是 UNIX 线程之间相互通信的最常见方式。相同的原理也适用于 Go 和 goroutines，这正是本节要讨论的内容。**互斥锁变量，即互斥排他变量的缩写，主要用于线程同步和保护在同时可能发生多个写入或一个写入和一个读取时的共享数据**。互斥锁就像一个容量为
    1 的缓冲通道，允许最多一个 goroutine 在任何给定时间访问共享变量。这意味着两个或更多 goroutine 无法同时更新该变量。Go 提供了 `sync.Mutex`
    和 `sync.RWMutex` 数据类型。
- en: A *critical section* of a concurrent program is the code that cannot be executed
    simultaneously by all processes, threads, or, in this case, goroutines. It is
    the code that needs to be protected by mutexes. Therefore, identifying the critical
    sections of your code makes the whole programming process so much simpler that
    you should pay particular attention to this task. A critical section cannot be
    embedded into another critical section when both critical sections use the same
    `sync.Mutex` or `sync.RWMutex` variable. However, **avoid at almost any cost the
    spreading of mutexes across functions because that makes it really hard to see
    whether you are embedding or not**.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 并发程序的一个 *关键部分* 是不能由所有进程、线程或在这种情况下，goroutines 同时执行的代码。这是需要由互斥锁保护的代码。因此，识别代码中的关键部分可以使整个编程过程变得简单得多，您应该特别注意这项任务。当两个关键部分都使用相同的
    `sync.Mutex` 或 `sync.RWMutex` 变量时，关键部分不能嵌入到另一个关键部分中。然而，**几乎在任何情况下都要避免将互斥锁传播到函数中，因为这会使您很难判断是否嵌入了互斥锁**。
- en: The sync.Mutex type
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`sync.Mutex` 类型'
- en: 'The `sync.Mutex` type is the Go implementation of a mutex. Its definition,
    which can be found in the `mutex.go` file of the `sync` directory, is as follows
    (you do not need to know the definition of `sync.Mutex` in order to use it):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Mutex` 类型是 Go 对互斥锁的实现。其定义可以在 `sync` 目录下的 `mutex.go` 文件中找到（您不需要知道 `sync.Mutex`
    的定义就可以使用它）：'
- en: '[PRE102]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The definition of `sync.Mutex` is nothing special. All of the interesting work
    is done by the `sync.Lock()` and `sync.Unlock()` functions, which can lock and
    unlock a `sync.Mutex` variable, respectively. Locking a mutex means that nobody
    else can lock it until it has been released using the `sync.Unlock()` function.
    All these are illustrated in `mutex.go`, which contains the following code:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Mutex` 的定义并没有什么特别之处。所有有趣的工作都是由 `sync.Lock()` 和 `sync.Unlock()` 函数完成的，它们分别可以锁定和解锁一个
    `sync.Mutex` 变量。锁定互斥锁意味着在它被使用 `sync.Unlock()` 函数释放之前，没有人可以锁定它。所有这些都在 `mutex.go`
    文件中得到了说明，该文件包含以下代码：'
- en: '[PRE103]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This function makes changes to the value of `v1`. The critical section begins
    here.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会改变 `v1` 的值。关键部分从这里开始。
- en: '[PRE104]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This is the end of the critical section. Now, another goroutine can lock the
    mutex.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关键部分的结束。现在，另一个goroutine可以锁定互斥锁。
- en: '[PRE105]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This function is used for reading the value of `v1`—therefore, it should use
    a mutex to make the process concurrently safe. Most specifically, we want to make
    sure that nobody is going to change the value of `v1` while we are reading it.
    The rest of the program contains the implementation of the `main()` function—feel
    free to see the entire code of `mutex.go` in the GitHub repository of the book.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数用于读取 `v1` 的值——因此，它应该使用互斥锁来确保过程是并发安全的。最具体地说，我们想确保在我们读取它的时候没有人会改变 `v1` 的值。程序的其余部分包含了
    `main()` 函数的实现——你可以自由地查看书籍的 GitHub 仓库中的 `mutex.go` 的完整代码。
- en: 'Running `mutex.go` produces the following output:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `mutex.go` 产生以下输出：
- en: '[PRE106]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The previous output shows that due to the use of a mutex, goroutines cannot
    access shared data and, therefore, there are no hidden race conditions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示，由于使用了互斥锁，goroutines 无法访问共享数据，因此没有隐藏的竞态条件。
- en: The next subsection shows what could happen if we forget to unlock a mutex.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节展示了如果我们忘记解锁互斥锁可能会发生什么。
- en: What happens if you forget to unlock a mutex?
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果你忘记解锁互斥锁会发生什么？
- en: 'Forgetting to unlock a `sync.Mutex` mutex creates a panic situation, even in
    the simplest kind of a program. The same applies to the `sync.RWMutex` mutex,
    which is presented in the next section. Let us now see a code example to understand
    this unpleasant situation a lot better—this is part of `forgetMutex.go`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记解锁 `sync.Mutex` 互斥锁会创建一个恐慌情况，即使在最简单的程序中也是如此。同样的情况也适用于下一节中介绍的 `sync.RWMutex`
    互斥锁。现在让我们通过一个代码示例来更好地理解这种不愉快的情况——这是 `forgetMutex.go` 的一部分：
- en: '[PRE107]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Here, we lock a mutex without releasing it afterward. This means that if we
    run `function()` as a goroutine more than once, all instances after the first
    one are going to be blocked waiting to `Lock()` the shared mutex. In our case,
    we run two goroutines—feel free to see the entire code of `forgetMutex.go` for
    more details. Running `forgetMutex.go` generates the following output:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们锁定了一个互斥锁但没有释放它。这意味着如果我们多次以goroutine的形式运行 `function()`，那么第一次运行之后的所有实例都将被阻塞，等待
    `Lock()` 共享互斥锁。在我们的例子中，我们运行了两个goroutine——你可以自由地查看 `forgetMutex.go` 的完整代码以获取更多细节。运行
    `forgetMutex.go` 生成以下输出：
- en: '[PRE108]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: As expected, the program crashes because of the deadlock. To avoid such situations,
    always remember to unlock any mutexes created in your program as soon as possible.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，程序因为死锁而崩溃。为了避免这种情况，请务必尽快解锁程序中创建的任何互斥锁。
- en: Let us now discuss `sync.RWMutex`, which is an improved version of `sync.Mutex`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论 `sync.RWMutex`，它是 `sync.Mutex` 的改进版本。
- en: The sync.RWMutex type
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sync.RWMutex 类型
- en: 'The `sync.RWMutex` data type is an improved version of `sync.Mutex` and is
    defined in the `rwmutex.go` file of the `sync` directory of the Go Standard library
    as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.RWMutex` 数据类型是 `sync.Mutex` 的改进版本，并在 Go 标准库的 `sync` 目录下的 `rwmutex.go`
    文件中定义如下：'
- en: '[PRE109]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In other words, `sync.RWMutex` is based on `sync.Mutex` with the necessary
    additions and improvements. So, you might ask, how does `sync.RWMutex` improve
    `sync.Mutex`? Although a single function is allowed to perform write operations
    with a `sync.RWMutex` mutex, you can have multiple readers owning a `sync.RWMutex`
    mutex—this means that read operations are usually faster with `sync.RWMutex`.
    However, there is one important detail that you should be aware of: until all
    of the readers of a `sync.RWMutex` mutex unlock it, you cannot lock it for writing,
    which is the small price you have to pay for the performance improvement you get
    for allowing multiple readers.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`sync.RWMutex` 是基于 `sync.Mutex` 并添加了必要的改进。因此，你可能会问，`sync.RWMutex` 如何改进
    `sync.Mutex`？尽管单个函数可以使用 `sync.RWMutex` 互斥锁执行写操作，但你可以有多个读者拥有 `sync.RWMutex` 互斥锁——这意味着使用
    `sync.RWMutex` 的读操作通常更快。然而，有一个重要的细节你应该注意：直到一个 `sync.RWMutex` 互斥锁的所有读者都解锁它，你才能锁定它进行写操作，这是你为了允许多个读者而获得的性能改进所必须付出的微小代价。
- en: The functions that can help you work with `sync.RWMutex` are `RLock()` and `RUnlock()`,
    which are used for locking and unlocking the mutex for reading purposes, respectively.
    The `Lock()` and `Unlock()` functions used in `sync.Mutex` should still be used
    when you want to lock and unlock a `sync.RWMutex` mutex for writing purposes.
    Finally, it should be apparent that you should not make changes to any shared
    variables inside an `RLock()` and `RUnlock()` block of code.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 可以帮助你与 `sync.RWMutex` 一起工作的函数是 `RLock()` 和 `RUnlock()`，分别用于锁定和解锁互斥锁以进行读取操作。当你想锁定和解锁
    `sync.RWMutex` 互斥锁进行写操作时，仍然应该使用 `sync.Mutex` 中使用的 `Lock()` 和 `Unlock()` 函数。最后，很明显，你不应该在
    `RLock()` 和 `RUnlock()` 代码块内部对任何共享变量进行更改。
- en: 'All these are illustrated in `rwMutex.go`—the important code is the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在 `rwMutex.go` 中得到了说明——重要的代码如下：
- en: '[PRE110]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: This is the shared variable of the program—you can share any type of variable
    you want.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的共享变量——你可以分享任何类型的变量。
- en: '[PRE111]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This is the beginning of the critical section.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关键区的开始。
- en: '[PRE112]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This is the end of the critical section.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关键区的结束。
- en: '[PRE113]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The `Change()` function makes changes to the shared variable `Password` and,
    therefore, needs to use the `Lock()` function, which can be held by a single writer
    only.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`Change()` 函数对共享变量 `Password` 进行更改，因此需要使用 `Lock()` 函数，该函数只能被单个写者持有。'
- en: '[PRE114]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The `show()` function reads the shared variable `Password` and therefore it
    is allowed to use the `RLock()` function, which can be held by multiple readers.
    Inside `main()`, three `show()` functions are executed as goroutines before a
    call to the `Change()` function, which also runs as a goroutine. The key point
    here is that no race conditions are going to happen. Running `rwMutex.go` produces
    the following output:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`show()` 函数读取共享变量 `Password`，因此它允许使用 `RLock()` 函数，该函数可以被多个读者持有。在 `main()` 函数中，在调用
    `Change()` 函数之前，作为协程执行了三个 `show()` 函数。这里的关键点是不会有任何竞态条件发生。运行 `rwMutex.go` 产生以下输出：'
- en: '[PRE115]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The `Change()` function is executed but cannot acquire the mutex because it
    is already taken by one or more `show()` goroutines.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`Change()` 函数被执行，但不能获取互斥锁，因为它已经被一个或多个 `show()` 协程占用。'
- en: '[PRE116]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The previous output verifies that two `show()` goroutines have successfully
    taken the mutex for reading.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出验证了两个 `show()` 协程已经成功获取了互斥锁进行读取。
- en: '[PRE117]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Here, we can see a second `Change()` function running and waiting to get the
    mutex.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个第二个 `Change()` 函数正在运行并等待获取互斥锁。
- en: '[PRE118]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: This is the output from the two `show()` goroutines.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个 `show()` 协程的输出。
- en: '[PRE119]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Here we see that one `Change()` goroutine finishes its job.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个 `Change()` 协程完成了它的任务。
- en: '[PRE120]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: After that another `show()` goroutine finishes.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，另一个 `show()` 协程完成了。
- en: '[PRE121]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Lastly, the second `Change()` goroutine finishes. The last output line is for
    making sure that the password value has changed—please look at the full code of
    `rwMutex.go` for more details.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第二个 `Change()` 协程完成了。最后一行输出是为了确保密码值已经改变——请查看 `rwMutex.go` 的完整代码以获取更多细节。
- en: Bear in mind that the output you are going to get might be different due to
    the way the scheduler works. This is the nature of concurrent programming and
    these programs do not have any mechanism to ensure the `show()` function should
    be scheduled first.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你将获得的输出可能会因为调度器的工作方式而有所不同。这是并发编程的本质，这些程序没有任何机制来确保 `show()` 函数应该首先被调度。
- en: The next subsection discusses the use of the `atomic` package for avoiding race
    conditions.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节讨论了使用 `atomic` 包来避免竞态条件。
- en: The atomic package
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`atomic`包'
- en: An atomic operation is an operation that is completed in a single step relative
    to other threads or, in this case, to other goroutines. **This means that an atomic
    operation cannot be interrupted in the middle of it.** The Go Standard library
    offers the `atomic` package, which, in some simple cases, can help you avoid using
    a mutex. With the `atomic` package, you can have atomic counters accessed by multiple
    goroutines without synchronization issues and without worrying about race conditions.
    However, mutexes are more versatile than atomic operations.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作是相对于其他线程（在这种情况下，是其他goroutine）在单个步骤中完成的操作。**这意味着原子操作不能在中间被中断**。Go标准库提供了`atomic`包，在某些简单情况下，可以帮助你避免使用互斥锁。使用`atomic`包，你可以有多个goroutine访问原子计数器，而无需同步问题，也不必担心竞态条件。然而，互斥锁比原子操作更灵活。
- en: As illustrated in the code that follows, when using an atomic variable, all
    reading and writing operations of an atomic variable must be done using the functions
    provided by the `atomic` package in order to avoid race conditions.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，当使用原子变量时，原子变量的所有读取和写入操作都必须使用`atomic`包提供的函数来完成，以避免竞态条件。
- en: 'The code in `atomic.go` is as follows, which is made smaller by hardcoding
    some values:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`atomic.go`中的代码如下，通过硬编码一些值来减小其大小：'
- en: '[PRE122]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This is a structure for holding the desired `int64` atomic variable.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于存储所需`int64`原子变量的结构体。
- en: '[PRE123]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This is a helper function that returns the current value of an `int64` atomic
    variable using `atomic.LoadInt64()`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个辅助函数，它使用`atomic.LoadInt64()`返回一个`int64`原子变量的当前值。
- en: '[PRE124]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: We are creating lots of goroutines that change the shared variable—as stated
    before, the use of the `atomic` package for working with the shared variable offers
    a simple way of avoiding race conditions when changing the value of the shared
    variable.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了大量的goroutine来改变共享变量——正如之前所述，使用`atomic`包来处理共享变量提供了一个简单的方法来避免在改变共享变量值时发生竞态条件。
- en: '[PRE125]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The `atomic.AddInt64()` function changes the value of the `val` field of the
    `counter` structure variable in a safe way.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`atomic.AddInt64()`函数以安全的方式更改`counter`结构变量中`val`字段的值。'
- en: '[PRE126]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Running `atomic.go` while checking for race conditions produces the following
    kind of output:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查竞态条件的同时运行`atomic.go`会产生以下类型的输出：
- en: '[PRE127]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: So, the atomic variable is modified by multiple goroutines without any issues.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，原子变量由多个goroutine修改而不会出现任何问题。
- en: The next subsection shows how to share memory using goroutines.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示如何使用goroutine来共享内存。
- en: Sharing memory using goroutines
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用goroutine共享内存
- en: This subsection illustrates how to share data using a dedicated goroutine. Although
    shared memory is the traditional way that threads communicate with each other,
    Go comes with built-in synchronization features that allow a single goroutine
    to own a shared piece of data. This means that other goroutines must send messages
    to this single goroutine that owns the shared data, which prevents the corruption
    of the data. Such a goroutine is called a monitor goroutine. In Go terminology,
    **this is sharing by communicating instead of communicating by sharing**.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 本节子节说明了如何使用专用goroutine来共享数据。尽管共享内存是线程之间通信的传统方式，但Go内置了同步特性，允许单个goroutine拥有共享数据。这意味着其他goroutine必须向拥有共享数据的单个goroutine发送消息，这防止了数据的损坏。这样的goroutine被称为监控goroutine。在Go术语中，**这是通过通信来共享而不是通过共享来通信**。
- en: Personally, I prefer to use a monitor goroutine instead of traditional shared
    memory techniques because the implementation with the monitor goroutine is safer,
    closer to the Go philosophy, and easier to understand.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我更喜欢使用监控goroutine而不是传统的共享内存技术，因为使用监控goroutine的实现更安全，更接近Go的哲学，并且更容易理解。
- en: The logic of the program can be found in the implementation of the `monitor()`
    function. More specifically, the `select` statement orchestrates the operation
    of the entire program. When you have a read request, the `read()` function attempts
    to read from the `readValue` channel, which is controlled by the `monitor()` function.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的逻辑可以在`monitor()`函数的实现中找到。更具体地说，`select`语句协调整个程序的操作。当你有一个读取请求时，`read()`函数尝试从由`monitor()`函数控制的`readValue`通道中读取。
- en: This returns the current value of the value variable. On the other hand, when
    you want to change the stored value, you call `set()`. This writes to the `writeValue`
    channel, which is also handled by the same `select` statement. As a result, no
    one can deal with the shared variable without using the `monitor()` function,
    which is in charge.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回值变量的当前值。另一方面，当你想要更改存储的值时，你调用`set()`。这会将数据写入`writeValue`通道，该通道也由相同的`select`语句处理。因此，没有使用`monitor()`函数，没有人可以处理共享变量，该函数负责。
- en: 'The code of `monitor.go` is as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`monitor.go`的代码如下：'
- en: '[PRE128]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This function sends data to the `writeValue` channel.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将数据发送到`writeValue`通道。
- en: '[PRE129]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: When the `read()` function is called, it reads from the `readValue` channel—this
    reading happens inside the `monitor()` function.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`read()`函数时，它会从`readValue`通道读取——这种读取发生在`monitor()`函数内部。
- en: '[PRE130]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `monitor()` function contains the logic of the program with the endless
    `for` loop and the `select` statement. The first case receives data from the `writeValue`
    channel, sets the `value` variable accordingly, and prints that new value. The
    second case sends the value of the `value` variable to the `readValue` channel.
    As all traffic goes through `monitor()` and its `select` block, there is no way
    to have a race condition because there is a single instance of `monitor()` running.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`monitor()`函数包含程序的逻辑，包括无限`for`循环和`select`语句。第一个情况从`writeValue`通道接收数据，相应地设置`value`变量，并打印新值。第二个情况将`value`变量的值发送到`readValue`通道。由于所有流量都通过`monitor()`及其`select`块，因此不可能出现竞争条件，因为只有一个`monitor()`实例正在运行。'
- en: '[PRE131]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: It is important that the `monitor()` function is executed first because that
    is the goroutine that orchestrates the flow of the program.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，`monitor()`函数必须首先执行，因为这是协调程序流程的goroutine。
- en: '[PRE132]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: When the `for` loop ends, it means that we have created the desired number of
    random numbers.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当`for`循环结束时，这意味着我们已经创建了所需的随机数数量。
- en: '[PRE133]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Lastly, we wait for all `set()` goroutines to finish before printing the last
    random number.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在打印最后一个随机数之前等待所有`set()` goroutines完成。
- en: 'Running `monitor.go` produces the following output:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`monitor.go`产生以下输出：
- en: '[PRE134]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: So, 10 random numbers are created by 10 goroutines and all these goroutines
    send their output to the `monitor()` function, which is also executed as a goroutine.
    Apart from receiving the results, the `monitor()` function prints them on the
    screen, so all this output is generated by `monitor()`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过10个goroutines创建了10个随机数，所有这些goroutines都将它们的输出发送到`monitor()`函数，该函数也作为一个goroutine执行。除了接收结果外，`monitor()`函数还会将它们打印到屏幕上，因此所有这些输出都是由`monitor()`生成的。
- en: The next section discusses the `go` statement in more detail.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将更详细地讨论`go`语句。
- en: Closured variables and the go statement
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包变量和go语句
- en: 'In this section, we are going to talk about closured variables, which are variables
    inside closures, and the `go` statement. Notice that closured variables in goroutines
    are evaluated when the goroutine actually runs and when the `go` statement is
    executed in order to create a new goroutine. This means that closured variables
    are going to be replaced by their values when the Go scheduler decides to execute
    the relevant code. This is illustrated in the `main()` function of `goClosure.go`:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论闭包变量，即闭包内的变量，以及`go`语句。请注意，goroutines中的闭包变量在goroutine实际运行时以及执行`go`语句以创建新goroutine时被评估。这意味着闭包变量将在Go调度器决定执行相关代码时被其值替换。这可以在`goClosure.go`的`main()`函数中看到：
- en: '[PRE135]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Running `goClosure.go` produces the following output:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`goClosure.go`产生以下输出：
- en: '[PRE136]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The program mostly prints the number 21, which is the last value of the variable
    of the `for` loop, and not the other numbers. As `i` is a closured variable, it
    is evaluated at the time of execution. As the goroutines begin but wait for the
    Go scheduler to allow them to get executed, the `for` loop ends, so the value
    of `i` that is being used is 21\. Lastly, the same issue also applies to Go channels,
    so be careful.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 程序主要打印数字21，这是`for`循环变量的最后一个值，而不是其他数字。因为`i`是一个闭包变量，它在执行时被评估。由于goroutines开始但等待Go调度器允许它们执行，`for`循环结束，所以使用的`i`的值是21。最后，同样的问题也适用于Go通道，所以请小心。
- en: 'Running `goClosure.go` with the Go race detector reveals the issue:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go竞争检测器运行`goClosure.go`揭示问题：
- en: '[PRE137]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Now, let us correct `goClosure.go` and present it to you—the new name is `goClosureCorrect.go`
    and its `main()` function is as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们纠正`goClosure.go`并向您展示——新的名称是`goClosureCorrect.go`，其`main()`函数如下：
- en: '[PRE138]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This is one way of correcting the issue. The valid yet bizarre `i := i` statement
    creates a new instance of the variable for the goroutine that holds the correct
    value. Although this is a valid approach, this kind of variable shadowing is not
    considered a good practice.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这是纠正问题的方法之一。有效的但古怪的 `i := i` 语句为持有正确值的goroutine创建了一个新的变量实例。虽然这是一种有效的方法，但这种类型的变量遮蔽不被认为是良好的实践。
- en: Variable shadowing in Go occurs when a variable declared in a nested scope has
    the same name as a variable in an outer scope. While variable shadowing can be
    intentional and useful in certain situations, it can also lead to confusion and
    introduce subtle bugs. In practice, it is recommended to avoid unnecessary variable
    shadowing and choose meaningful variable names that minimize the likelihood of
    unintentional shadowing.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，当在嵌套作用域中声明的变量与外部作用域中的变量具有相同的名称时，会发生变量遮蔽。虽然变量遮蔽在某些情况下可能是故意的并且有用，但它也可能导致混淆并引入微妙的错误。在实践中，建议避免不必要的变量遮蔽，并选择有意义的变量名以最大限度地减少无意中遮蔽的可能性。
- en: '[PRE139]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'This is a totally different way of correcting the race condition: pass the
    current value of `i` to the anonymous function as a parameter and everything is
    OK. As explained in *Chapter 15*, *Changes in Recent Go Versions*, this issue
    does not exist in Go 1.22.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种纠正竞争条件（race condition）的完全不同的方法：将 `i` 的当前值作为参数传递给匿名函数，一切就绪。如 *第15章* 所述，*最近
    Go 版本的变化*，这个问题在 Go 1.22 中不存在。
- en: '[PRE140]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Testing `goClosureCorrect.go` with the race detector generates the expected
    output:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 使用竞争检测器测试 `goClosureCorrect.go` 生成预期的输出：
- en: '[PRE141]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The next section presents the functionality of the `context` package.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将介绍 `context` 包的功能。
- en: The context package
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`context` 包'
- en: The main purpose of the `context` package is to define the `Context` type and
    support cancellation. Yes, you heard that right; there are times when, for some
    reason, you want to abandon what you are doing. However, it would be very helpful
    to be able to include some extra information about your cancellation decisions.
    The `context` package allows you to do exactly that.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`context` 包的主要目的是定义 `Context` 类型并支持取消。是的，你没听错；有时，出于某种原因，你可能想放弃你正在做的事情。然而，能够包含一些关于你的取消决策的额外信息将非常有帮助。`context`
    包允许你做到这一点。'
- en: If you take a look at the source code of the `context` package, you will realize
    that its implementation is pretty simple—even the implementation of the `Context`
    type is pretty simple, yet the `context` package is very important.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `context` 包的源代码，你会意识到它的实现相当简单——甚至 `Context` 类型的实现也很简单，但 `context` 包非常重要。
- en: 'The `Context` type is an interface with four methods: `Deadline()`, `Done()`,
    `Err()`, and `Value()`. The good news is that you do not need to implement all
    of these functions of the `Context` interface—you just need to modify a `Context`
    variable using methods such as `context.WithCancel()`, `context.WithDeadline()`,
    and `context.WithTimeout()`.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context` 类型是一个具有四个方法的接口：`Deadline()`、`Done()`、`Err()` 和 `Value()`。好消息是，你不需要实现
    `Context` 接口的所有这些函数——你只需要使用 `context.WithCancel()`、`context.WithDeadline()` 和
    `context.WithTimeout()` 等方法修改 `Context` 变量。'
- en: All three of these methods return a derived `Context` (the child) and a `CancelFunc()`
    function. Calling the `CancelFunc()` function removes the parent’s reference to
    the child and stops any associated timers. As a side effect, this means that the
    Go garbage collector is free to garbage collect the child goroutines that no longer
    have associated parent goroutines. For garbage collection to work correctly, the
    parent goroutine needs to keep a reference to each child goroutine. If a child
    goroutine ends without the parent knowing about it, then a memory leak occurs
    until the parent is canceled as well.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法都返回一个派生出的 `Context`（子）和一个 `CancelFunc()` 函数。调用 `CancelFunc()` 函数会移除父对子的引用并停止任何相关的计时器。作为副作用，这意味着
    Go 垃圾收集器可以自由地回收不再有相关父goroutine的子goroutine。为了正确地进行垃圾收集，父goroutine需要保持对每个子goroutine的引用。如果一个子goroutine在没有父知道的情况下结束，那么就会发生内存泄漏，直到父goroutine也被取消。
- en: The example that follows showcases the use of the `context` package. The program
    contains four functions, including the `main()` function. Functions `f1()`, `f2()`,
    and `f3()` each require just one parameter (which is a time delay) because everything
    else they need is defined inside their function body. In this example, we use
    `context.Background()` to initialize an empty `Context`. The other function that
    can create an empty `Context` is `context.TODO()`, which is presented later on
    in this chapter.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了 `context` 包的使用。该程序包含四个函数，包括 `main()` 函数。函数 `f1()`、`f2()` 和 `f3()` 每个只需要一个参数（即时间延迟），因为它们需要的其他一切都在其函数体内定义。在这个例子中，我们使用
    `context.Background()` 来初始化一个空的 `Context`。另一个可以创建空 `Context` 的函数是 `context.TODO()`，它将在本章后面介绍。
- en: '[PRE142]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The `WithCancel()` method returns a copy of the parent context with a new `Done`
    channel. Notice that the `cancel` variable, which is a function, is one of the
    return values of `context.CancelFunc()`. The `context.WithCancel()` function uses
    an existing `Context` and creates a child with cancellation. The `context.WithCancel()`
    function also returns a `Done` channel that can be closed, either when the `cancel()`
    function is called, as shown in the preceding code, or when the `Done` channel
    of the parent context is closed.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithCancel()` 方法返回父上下文的副本，并带有新的 `Done` 通道。请注意，`cancel` 变量，它是一个函数，是 `context.CancelFunc()`
    的返回值之一。`context.WithCancel()` 函数使用现有的 `Context` 并创建一个带有取消的子上下文。`context.WithCancel()`
    函数还返回一个 `Done` 通道，该通道可以被关闭，无论是当调用 `cancel()` 函数时，如前述代码所示，还是当父上下文的 `Done` 通道被关闭时。'
- en: '[PRE143]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The `f1()` function creates and executes a goroutine. The `time.Sleep()` call
    simulates the time it would take a real goroutine to do its job. In this case,
    it is 4 seconds, but you can put any time period you want. If the `c1` context
    calls the `Done()` function in less than 4 seconds, the goroutine will not have
    enough time to finish.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`f1()` 函数创建并执行一个 goroutine。`time.Sleep()` 调用模拟了一个真实的 goroutine 完成工作所需的时间。在这种情况下，它是
    4 秒，但你可以设置任何你想要的时间段。如果 `c1` 上下文在 4 秒内调用 `Done()` 函数，goroutine 将没有足够的时间完成。'
- en: '[PRE144]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The cancel variable in `f2()` comes from `context.WithTimeout()`, which requires
    two parameters: a `Context` parameter and a `time.Duration` parameter. When the
    timeout period expires, the `cancel()` function is called automatically.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`f2()` 函数中的取消变量来自 `context.WithTimeout()`，它需要两个参数：一个 `Context` 参数和一个 `time.Duration`
    参数。当超时时间到期时，`cancel()` 函数会自动被调用。'
- en: '[PRE145]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The `cancel` variable in `f3()` comes from `context.WithDeadline()`, which
    requires two parameters: a `Context` variable and a time in the future that signifies
    the deadline of the operation. When the deadline passes, the `cancel()` function
    is called automatically.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`f3()` 函数的逻辑与 `f1()` 和 `f2()` 相同——`select` 块协调这个过程。'
- en: '[PRE146]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The logic of `f3()` is the same as in `f1()` and `f2()`—the `select` block orchestrates
    the process.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`f3()` 函数中的 `cancel` 变量来自 `context.WithDeadline()`，它需要两个参数：一个 `Context` 变量和表示操作截止日期的未来时间。当截止日期通过时，`cancel()`
    函数会自动被调用。'
- en: '[PRE147]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The three functions are executed in sequence by the `main()` function. Running
    `useContext.go` produces the following kind of output:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数由 `main()` 函数按顺序执行。运行 `useContext.go` 会产生以下类型的输出：
- en: '[PRE148]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: The long lines of the output are the return values of `time.After()` and show
    the times that `After()` sent the current time on the returned channel. All of
    them denote a normal operation of the program.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的长行是 `time.After()` 的返回值，显示了 `After()` 在返回的通道上发送当前时间的时间。所有这些都表示程序的正常操作。
- en: 'If you define a bigger delay, then the output is going to be similar to the
    following:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义一个更大的延迟，那么输出将类似于以下内容：
- en: '[PRE149]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The point here is that the operation of the program is canceled when there are
    delays in its execution.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是程序在执行过程中出现延迟时会被取消操作。
- en: About context.WithCancelCause
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 context.WithCancelCause
- en: The `context.WithCancelCause()` method was introduced in Go 1.21\. Its main
    advantage is that it gives you customization capabilities, which are not offered
    by the other methods of the `context` package. Apart from that, it behaves like
    `WithCancel()`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.WithCancelCause()` 方法是在 Go 1.21 中引入的。它的主要优点是提供了定制能力，这是 `context` 包的其他方法所不具备的。除此之外，它的行为类似于
    `WithCancel()`。'
- en: Similar to `context.WithCancelCause()`, there exists `context.WithTimeoutCause()`
    and `context.WithDeadlineCause()`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `context.WithCancelCause()` 类似，存在 `context.WithTimeoutCause()` 和 `context.WithDeadlineCause()`。
- en: The `withCancelCause.go` program illustrates the use of `context.WithCancelCause()`.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`withCancelCause.go` 程序展示了 `context.WithCancelCause()` 的使用方法。'
- en: '[PRE150]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The implementation of `main()` contains two important elements. First, we call
    `context.WithCancelCause()`, which returns a context, and a `CancelCauseFunc()`
    function, which behaves like `CancelFunc()` while allowing us to define and customize
    the cancellation cause giving clearer context to the error situation—in this case,
    the cancellation cause is defined as `errors.New("Canceled by timeout")`. After
    that, we call `takingTooLong()` with the context that we have just defined. If
    `takingTooLong()` returns an error that is not `nil`, we print that error.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`的实现包含两个重要元素。首先，我们调用`context.WithCancelCause()`，它返回一个上下文和一个`CancelCauseFunc()`函数，该函数的行为类似于`CancelFunc()`，同时允许我们定义和自定义取消原因，为错误情况提供更清晰的上下文——在这种情况下，取消原因被定义为`errors.New("Canceled
    by timeout")`。之后，我们使用我们刚刚定义的上下文调用`takingTooLong()`。如果`takingTooLong()`返回一个非`nil`的错误，我们打印该错误。'
- en: '[PRE151]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: The previous function returns either `nil` or `context.Cause(ctx)`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的函数返回`nil`或`context.Cause(ctx)`。
- en: 'Running `withCancelCause.go` produces the following output:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`withCancelCause.go`会产生以下输出：
- en: '[PRE152]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: So, as the second part of the `select` block is executed, `takingTooLong()`
    prints `Canceled!` and `main()` prints the cancellation reason according to the
    initialization of `context.WithCancelCause()`.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当`select`块的第二部分执行时，`takingTooLong()`打印`Canceled!`，而`main()`根据`context.WithCancelCause()`的初始化打印取消原因。
- en: We are not completely done with `context` as the next chapter is going to use
    it to timeout HTTP interactions on the client side of the connection. The next
    section discusses the `semaphore` package, which is not part of the standard library.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完全完成`context`，因为下一章将使用它来在连接的客户端超时HTTP交互。下一节讨论`semaphore`包，它不是标准库的一部分。
- en: The semaphore package
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量包
- en: This last section of this chapter presents the `semaphore` package, which is
    provided by the Go team. A semaphore is a construct that can limit or control
    the access to a shared resource. As we are talking about Go, **a semaphore can
    limit the access of goroutines to a shared resource** but, originally, semaphores
    were used for limiting access to threads. Semaphores can have weights that limit
    the number of threads or goroutines that can have access to a resource.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分介绍了由Go团队提供的`semaphore`包。信号量是一种可以限制或控制对共享资源访问的构造。由于我们谈论的是Go，**信号量可以限制goroutine对共享资源的访问**，但最初，信号量用于限制对线程的访问。信号量可以有权重，限制可以访问资源的线程或goroutine的数量。
- en: 'The process is supported via the `Acquire()` and `Release()` methods, which
    are defined as follows:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程通过`Acquire()`和`Release()`方法得到支持，这些方法定义如下：
- en: '[PRE153]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The second parameter of `Acquire()` defines the weight of the semaphore. As
    we are going to use an external package, we need to put the code inside `~/go/src`
    in order to use Go modules: `~/go/src/github.com/mactsouk/mGo4th/ch08/semaphore`.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`Acquire()`的第二个参数定义了信号量的权重。由于我们将使用外部包，我们需要将代码放在`~/go/src`中，以便使用Go模块：`~/go/src/github.com/mactsouk/mGo4th/ch08/semaphore`。'
- en: 'Now, let us present the code of `semaphore.go`, which shows an implementation
    of a worker pool using semaphores:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们展示`semaphore.go`的代码，它展示了使用信号量的工作池实现：
- en: '[PRE154]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The `Workers` variable specifies the maximum number of goroutines that can be
    executed by this program.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`Workers`变量指定了此程序可以执行的最多goroutine数量。'
- en: '[PRE155]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: This is where we define the semaphore with a weight identical to the maximum
    number of goroutines that can be executed concurrently. This means that no more
    than `Workers` goroutines can acquire the semaphore at the same time.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们定义具有与可以并发执行的最多goroutine数量相同的权重的信号量的地方。这意味着不能同时超过`Workers`个goroutine获取信号量。
- en: '[PRE156]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The `worker()` function is run as part of a goroutine. However, as we are using
    a semaphore, there is no need to return the results to a channel.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`worker()`函数作为goroutine的一部分运行。然而，由于我们使用信号量，没有必要将结果返回到通道。'
- en: '[PRE157]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The previous code reads the number of jobs that we want to run.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码读取我们想要运行的作业数量。
- en: '[PRE158]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: In this part, we try to acquire the semaphore as many times as the number of
    jobs defined by `nJobs`. If `nJobs` is bigger than `Workers`, then the `Acquire()`
    call is going to block and wait for `Release()` calls in order to unblock.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们尝试根据`nJobs`定义的作业数量多次获取信号量。如果`nJobs`大于`Workers`，那么`Acquire()`调用将会阻塞并等待`Release()`调用以解除阻塞。
- en: '[PRE159]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: This is where we run the goroutines that do the job and write the results to
    the `results` slice. As each goroutine writes to a different slice element, there
    are not any race conditions.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运行执行工作并将结果写入 `results` 切片的goroutines的地方。由于每个goroutine都写入不同的切片元素，因此不存在任何竞争条件。
- en: '[PRE160]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'This is a clever trick: we acquire all of the tokens so that the `sem.Acquire()`
    call blocks until all workers/goroutines have finished. This is similar in functionality
    to a `Wait()` call.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个巧妙的技巧：我们获取所有令牌，这样 `sem.Acquire()` 调用就会阻塞，直到所有工作者/goroutines完成。这在功能上类似于一个
    `Wait()` 调用。
- en: '[PRE161]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The last part of the program is about printing the results. After writing the
    code, we need to run the following commands to get the required Go modules:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分是关于打印结果。在编写代码后，我们需要运行以下命令来获取所需的Go模块：
- en: '[PRE162]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Apart from the first command, these commands were indicated by the output of
    `go mod init`, so you do not have to remember anything.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第一个命令之外，这些命令都由 `go mod init` 的输出指示，所以你不需要记住任何东西。
- en: 'Lastly, running `semaphore.go` produces the following output:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行 `semaphore.go` 产生以下输出：
- en: '[PRE163]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Each line in the output shows the input value and the output value separated
    by ->. The use of the semaphore keeps things in order.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的每一行都显示了输入值和输出值，它们由 -> 分隔。使用信号量保持了顺序。
- en: Making the statistics application concurrent
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使统计应用程序并发
- en: In this section of this chapter, we are going to convert the statistics application
    into a concurrent application that uses goroutines. However, instead of using
    channels, we are going to use a different approach that prevents deadlocks, while
    making the overall design of the program much simpler. Apart from that, there
    is also a version of `stats.go` named `statsNC.go` that does not create any goroutines
    and processes the input files sequentially.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一节中，我们将把统计应用程序转换成一个使用goroutines的并发应用程序。然而，我们不会使用通道，而将采用一种不同的方法来防止死锁，同时使程序的整体设计更加简单。此外，还有一个名为
    `statsNC.go` 的 `stats.go` 版本，它不会创建任何goroutines，并按顺序处理输入文件。
- en: We are only going to present the implementation of the `main()` function of
    `stats.go` because this is where the logic of the utility is found. However, minor
    additional changes exist for taking advantage of goroutines. The most time-consuming
    part of `stats.go` is the normalization of the time series.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只将展示 `stats.go` 的 `main()` 函数的实现，因为这是实用工具逻辑所在的地方。然而，为了利用goroutines，还存在一些小的额外更改。`stats.go`
    中最耗时的部分是时间序列的归一化。
- en: What is impressive is that we converted `stats.go` into a concurrent application
    using a minimal amount of changes that mainly have to do with goroutine synchronization—this
    is a good indication of great design.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 令人印象深刻的是，我们通过最小的更改将 `stats.go` 转换成了一个并发应用程序，这些更改主要与goroutine同步有关——这是一个优秀设计的良好迹象。
- en: 'The implementation of `main()` is the following:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数的实现如下：'
- en: '[PRE164]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: So far, we have a `sync.WaitGroup` variable for synchronizing the goroutines.
    Additionally, we have a slice variable named `files` that has as many elements
    as the length of the `os.Args` slice—`files[0]` is not going to be used.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个用于同步goroutines的 `sync.WaitGroup` 变量。此外，我们还有一个名为 `files` 的切片变量，其元素数量与
    `os.Args` 切片的长度相同——`files[0]` 将不会被使用。
- en: 'The remaining code of `main()` is the following:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 的剩余代码如下：'
- en: '[PRE165]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'What do we have here? There is an anonymous function that runs as a goroutine.
    That anonymous function requires a single parameter, which is **the index of the
    command line argument that is being processed**. There is a handy property that
    comes with that index: that index is unique, which means that we can use that
    unique index when we put data into the `files` slice—this process takes place
    inside `process()`. This resolves any potential race conditions as each goroutine
    uses a different place in `files`. Keep in mind that `files[0]` is not being used
    but we have decided to make `files` bigger than needed in order to put the data
    for the first command line argument in `files[1]`, and so on.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有什么？有一个作为goroutine运行的匿名函数。这个匿名函数需要一个参数，即**正在处理的命令行参数的索引**。这个索引有一个方便的特性：这个索引是唯一的，这意味着我们可以使用这个唯一的索引在将数据放入
    `files` 切片时使用——这个过程发生在 `process()` 中。这解决了任何潜在的竞争条件，因为每个goroutine都使用 `files` 中的不同位置。记住，`files[0]`
    不会被使用，但我们决定将 `files` 做得比需要的更大，以便将第一个命令行参数的数据放入 `files[1]`，依此类推。
- en: Apart from that, we use `sync` to wait for all goroutines to finish before exiting
    the program.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，我们使用 `sync` 等待所有goroutines完成后再退出程序。
- en: 'In order to compare `stats.go` with `statsNC.go`, we are going to use bigger
    datasets, which are all stored in the `./ch08/dataset` directory. The sizes of
    the three data files can be seen in the following output:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较`stats.go`与`statsNC.go`，我们将使用更大的数据集，这些数据集都存储在`./ch08/dataset`目录中。三个数据文件的大小可以在以下输出中看到：
- en: '[PRE166]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'A quick and dirty way to calculate the execution time of a program is using
    the `time(1)` UNIX utility. Using that utility, we are going to compare the execution
    time of `./ch05/stats.go` with `./ch05/stats.go` and see what happens:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 计算程序执行时间的一种快速且简单的方法是使用`time(1)` UNIX实用程序。使用该实用程序，我们将比较`./ch05/stats.go`与`./ch05/stats.go`的执行时间，看看会发生什么：
- en: '[PRE167]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: What is important in the output is the values in the lines that begin with `real`.
    The concurrent version is about **three times faster** than the non-concurrent
    version when processing nine files. Imagine using even bigger datasets and having
    to process 1,000 datasets instead of just nine!
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中重要的是以`real`开头的行中的值。当处理九个文件时，并发版本比非并发版本快**三倍**。想象一下使用更大的数据集，并且需要处理1,000个数据集而不是仅仅九个！
- en: Summary
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this important chapter, we talked about Go concurrency, goroutines, channels,
    the `select` keyword, shared memory, and mutexes, as well as timing out goroutines
    and the use of the `context` package. Bear in mind that although goroutines can
    process data and execute commands, they cannot communicate with each other directly
    but they can communicate in other ways, including channels, local sockets, and
    shared memory.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重要的章节中，我们讨论了Go并发、goroutines、channels、`select`关键字、共享内存和互斥锁，以及goroutines的超时和`context`包的使用。请记住，尽管goroutines可以处理数据和执行命令，但它们不能直接相互通信，但它们可以通过其他方式通信，包括channels、本地套接字和共享内存。
- en: Remember that OS threads are controlled by the OS scheduler, whereas goroutines
    executed in one or more OS threads are controlled by the Go runtime. The correct
    terminology for when a goroutine or an OS thread is executed and then paused is
    *context-switched on and off*, respectively. Keep in mind that the Go scheduler
    checks the global queue from time to time in order to find out whether there are
    any goroutines waiting to be assigned to a local queue. If both the global queue
    and a given local queue are empty, then *work-stealing* takes place.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，操作系统线程由操作系统调度器控制，而在一个或多个操作系统线程中执行的goroutines由Go运行时控制。当goroutine或操作系统线程被执行然后暂停时，正确的术语分别是*上下文切换开启和关闭*。请记住，Go调度器不时检查全局队列，以找出是否有goroutines等待分配到本地队列。如果全局队列和给定的本地队列都为空，则发生*工作窃取*。
- en: The main advantage of concurrency is that it allows the splitting of bigger
    tasks into smaller ones and the execution of each smaller task concurrently. Additionally,
    concurrency does a great job in distributing multiple HTTP requests among different
    goroutines. Lastly, concurrency makes better use of modern CPUs with multiple
    cores and virtual environments. However, concurrency adds complexity to the software
    design and the code, which affects readability and maintainability. For that reason,
    you might need to add concurrency last in your code, as we did with the statistics
    application. One other concern of concurrency is the risk of consuming all available
    resources making other services unreliable or even unavailable. Lastly, concurrent
    code is harder to benchmark—if you want to compare two concurrent implementations,
    it is better to compare their sequential versions that tell more about the actual
    algorithms and code efficiency.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 并发的主要优势在于它允许将更大的任务分解成更小的任务，并使每个较小的任务并发执行。此外，并发在将多个HTTP请求分配给不同的goroutines方面做得很好。最后，并发更好地利用了具有多个核心和虚拟环境的现代CPU。然而，并发增加了软件设计和代码的复杂性，这影响了可读性和可维护性。因此，你可能需要在代码中最后添加并发，就像我们在统计应用程序中所做的那样。并发的一个其他担忧是消耗所有可用资源，使其他服务不可靠或甚至不可用。最后，并发代码更难进行基准测试——如果你想比较两个并发实现，最好是比较它们的顺序版本，这更多地说明了实际的算法和代码效率。
- en: What is important to remember is that the rational use of concurrency and goroutines
    is going to allow you to write powerful Go applications. Feel free to experiment
    with the concepts and the examples of this chapter to better understand goroutines,
    channels, and shared memory.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，合理地使用并发和goroutines将允许你编写强大的Go应用程序。请随意实验本章的概念和示例，以更好地理解goroutines、channels和共享内存。
- en: The next chapter is all about web services and working with the HTTP protocol
    in Go. Among other things, we are going to convert the statistics application
    into a web service.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将全部关于网络服务和在 Go 中使用 HTTP 协议。其中，我们将把统计应用程序转换为网络服务。
- en: Exercises
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Try to implement a concurrent version of `wc(1)` that uses a buffered channel.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试实现一个使用带缓冲的通道的 `wc(1)` 并发版本。
- en: Try to implement a concurrent version of `wc(1)` that uses shared memory.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试实现一个使用共享内存的 `wc(1)` 并发版本。
- en: Try to implement a concurrent version of `wc(1)` that uses semaphores.
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试实现一个使用信号量的 `wc(1)` 并发版本。
- en: Try to implement a concurrent version of `wc(1)` that saves its output to a
    file.
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试实现一个将输出保存到文件的 `wc(1)` 并发版本。
- en: Additional resources
  id: totrans-556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The documentation page of `sync`: [https://pkg.go.dev/sync](https://pkg.go.dev/sync)'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync` 的文档页面：[https://pkg.go.dev/sync](https://pkg.go.dev/sync)'
- en: 'Learn about the `semaphore` package: [https://pkg.go.dev/golang.org/x/sync/semaphore](https://pkg.go.dev/golang.org/x/sync/semaphore)'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 `semaphore` 包：[https://pkg.go.dev/golang.org/x/sync/semaphore](https://pkg.go.dev/golang.org/x/sync/semaphore)
- en: 'Coroutines for Go: [https://research.swtch.com/coro](https://research.swtch.com/coro)'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 的协程：[https://research.swtch.com/coro](https://research.swtch.com/coro)
- en: 'Learn more about the Go scheduler by reading a series of posts: [https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html)'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过阅读一系列文章了解 Go 调度器：[https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html)
- en: 'The implementation of the Go scheduler: [https://go.dev/src/runtime/proc.go](https://go.dev/src/runtime/proc.go
    )'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 调度器的实现：[https://go.dev/src/runtime/proc.go](https://go.dev/src/runtime/proc.go
    )
- en: Join our community on Discord
  id: totrans-562
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
