- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Building Web Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建网络服务
- en: The core subject of this chapter is working with HTTP using the `net/http` package—keep
    in mind that all web services require a web server to operate. Additionally, in
    this chapter, we are going to convert the statistics application into a web application
    that accepts HTTP connections and create a command line client to work with it.
    In the last part of the chapter, we are going to learn how to time out HTTP connections.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的核心主题是使用 `net/http` 包处理 HTTP——请记住，所有网络服务都需要网络服务器才能运行。此外，在本章中，我们将把统计应用程序转换为接受
    HTTP 连接的网络应用程序，并创建一个命令行客户端来与之交互。在章节的最后部分，我们将学习如何超时 HTTP 连接。
- en: 'In more detail, this chapter covers:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，本章涵盖了：
- en: The `net/http` package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http` 包'
- en: Creating a web server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个网络服务器
- en: Updating the statistics application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新统计应用程序
- en: Developing web clients
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发网络客户端
- en: Creating a client for the statistics service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为统计服务创建客户端
- en: Timing out HTTP connections
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时 HTTP 连接
- en: The net/http package
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`net/http` 包'
- en: The `net/http` package offers functions that allow you to develop web servers
    and clients. For example, `http.Get()` and `http.NewRequest()` are used by clients
    to make HTTP requests, whereas `http.ListenAndServe()` is used to start web servers
    by specifying the IP address and the TCP port that the server listens to. Additionally,
    `http.HandleFunc()` defines supported URLs as well as the functions that are going
    to handle these URLs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http` 包提供了允许你开发网络服务器和客户端的函数。例如，客户端使用 `http.Get()` 和 `http.NewRequest()`
    来发送 HTTP 请求，而 `http.ListenAndServe()` 则用于通过指定服务器监听的 IP 地址和 TCP 端口来启动网络服务器。此外，`http.HandleFunc()`
    定义了支持的 URL 以及将要处理这些 URL 的函数。'
- en: The next three subsections describe three important data structures of the `net/http`
    package—you can use these descriptions as a reference while reading this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个小节描述了 `net/http` 包中的三个重要数据结构——在阅读本章时，你可以将这些描述作为参考。
- en: The http.Response type
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`http.Response` 类型'
- en: 'The `http.Response` struct embodies the response from an HTTP request—both
    `http.Client` and `http.Transport` return `http.Response` values once the response
    headers have been received. Its definition can be found at [https://go.dev/src/net/http/response.go](https://go.dev/src/net/http/response.go):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Response` 结构体体现了 HTTP 请求的响应——一旦收到响应头，`http.Client` 和 `http.Transport`
    都会返回 `http.Response` 值。其定义可以在 [https://go.dev/src/net/http/response.go](https://go.dev/src/net/http/response.go)
    找到：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You do not have to use all the structure fields, but it is good to know that
    they exist. However, some of them, such as `Status`, `StatusCode`, and `Body`,
    are more important than others. The Go source file, as well as the output of `go
    doc http.Response`, contains more information about the purpose of each field,
    which is also the case with most `struct` data types found in the standard Go
    library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必使用所有结构字段，但了解它们的存在是好的。然而，其中一些字段，如 `Status`、`StatusCode` 和 `Body`，比其他字段更重要。Go
    源文件以及 `go doc http.Response` 的输出都包含了关于每个字段目的的更多信息，这同样适用于标准 Go 库中找到的大多数 `struct`
    数据类型。
- en: The http.Request type
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`http.Request` 类型'
- en: 'The `http.Request` structure represents an HTTP request as constructed by a
    client in order to be sent or received by an HTTP server. The public fields of
    `http.Request` are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Request` 结构体代表了一个客户端构建的 HTTP 请求，以便发送或接收 HTTP 服务器。`http.Request` 的公共字段如下：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Body` field holds the body of the request. After reading the body of a
    request, you are allowed to call `GetBody()`, which returns a new copy of the
    body—this is optional.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Body` 字段包含请求的主体。在读取请求的主体之后，你可以调用 `GetBody()`，它返回主体的新副本——这是可选的。'
- en: Let us now present the `http.Transport` structure.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们介绍 `http.Transport` 结构体。
- en: The http.Transport type
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`http.Transport` 类型'
- en: 'The definition of `http.Transport`, which gives you more control over your
    HTTP connections, is fairly long and complex:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Transport` 的定义，它为你提供了更多对 HTTP 连接的控制，相当长且复杂：'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Keep in mind that `http.Transport` is **low-level** compared to `http.Client`.
    The latter implements a high-level HTTP client—each `http.Client` contains a `Transport`
    field. If its value is `nil`, then `DefaultTransport` is used. You do not need
    to use `http.Transport` in all of your programs, and you are not required to deal
    with all of its fields all the time. To learn more about `DefaultTransport`, type
    `go doc http.DefaultTransport`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，与`http.Client`相比，`http.Transport`是低级别的。后者实现了一个高级HTTP客户端——每个`http.Client`都包含一个`Transport`字段。你不需要在所有程序中使用`http.Transport`，也不需要始终处理它的所有字段。要了解更多关于`DefaultTransport`的信息，请输入`go
    doc http.DefaultTransport`。
- en: Let us now learn how to develop a web server.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在学习如何开发一个Web服务器。
- en: Creating a web server
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Web服务器
- en: This section presents a simple web server developed in Go to better understand
    the principles behind such applications. Although a web server programmed in Go
    can do many things efficiently and securely, if what you really need is a powerful
    web server that supports modules, multiple websites, and virtual hosts, then you
    would be better off using a web server such as Apache, Nginx, or Caddy that is
    written in Go. Those powerful web servers typically are in front of Go application
    servers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一个用Go开发的简单Web服务器，以更好地理解此类应用程序背后的原理。尽管用Go编写的Web服务器可以高效且安全地做很多事情，但如果你真正需要的是一个支持模块、多个网站和虚拟主机的强大Web服务器，那么你最好使用Apache、Nginx或Caddy这样的Web服务器，这些服务器是用Go编写的。这些强大的Web服务器通常位于Go应用服务器之前。
- en: 'You might ask why the presented web server uses HTTP instead of secure HTTP
    (HTTPS). The answer to this question is simple: most Go web servers are deployed
    as Docker images and are hidden behind web servers, such as Caddy and Nginx, that
    provide the secure HTTP operation part using the appropriate security credentials.
    It does not make any sense to use the secure HTTP protocol along with the required
    security credentials without knowing how, and under which domain name, an application
    is going to be deployed.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么所展示的Web服务器使用HTTP而不是安全的HTTP（HTTPS）。这个问题的答案很简单：大多数Go Web服务器都是以Docker镜像的形式部署的，并且隐藏在提供安全HTTP操作部分的Web服务器后面，例如Caddy和Nginx，它们使用适当的认证信息提供安全HTTP操作。在不了解如何以及将在哪个域名下部署应用程序的情况下，使用安全HTTP协议以及所需的认证信息是没有意义的。
- en: This is a common practice in microservices as well as regular web applications
    that are deployed as Docker images. So this is a design decision that is a common
    practice for such cases. However, your requirements might differ.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在微服务和作为Docker镜像部署的常规Web应用中的一种常见做法。因此，这是一个在这种情况下常见的做法的设计决策。然而，你的需求可能不同。
- en: The `net/http` package offers functions and data types that allow you to develop
    powerful web servers and clients. The `http.Set()` and `http.Get()` methods can
    be used to make HTTP and HTTPS requests, whereas `http.ListenAndServe()` is used
    for creating web servers given the user-specified handler function or functions
    that handle incoming requests. As most web services require support for multiple
    endpoints, you end up needing multiple discrete functions to handle incoming requests,
    which also leads to the better design of your services.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包提供了函数和数据类型，允许你开发强大的Web服务器和客户端。`http.Set()`和`http.Get()`方法可以用来发送HTTP和HTTPS请求，而`http.ListenAndServe()`用于创建Web服务器，给定用户指定的处理函数或处理传入请求的函数。由于大多数Web服务需要支持多个端点，你最终需要多个离散的函数来处理传入的请求，这也导致了你服务器的更好设计。'
- en: The simplest way to define the supported endpoints, as well as the handler function
    that responds to each client request, is with the use of `http.HandleFunc()`,
    which can be called multiple times.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 定义受支持的端点以及响应每个客户端请求的处理函数的最简单方法就是使用`http.HandleFunc()`，它可以被多次调用。
- en: 'After this quick and somewhat theoretical introduction, it is time to begin
    talking about more practical topics, beginning with the implementation of a simple
    web server, as illustrated in `wwwServer.go`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个快速且有些理论性的介绍之后，是时候开始讨论更实际的话题了，从实现一个简单的Web服务器开始，如`wwwServer.go`所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a handler function that sends a message back to the client using the
    `w http.ResponseWriter`, which is an interface that implements `io.Writer` and
    is used to send the server response.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个处理函数，它使用`w http.ResponseWriter`向客户端发送消息，`http.ResponseWriter`是一个实现`io.Writer`接口的接口，用于发送服务器响应。
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is another handler function called `timeHandler` that returns the current
    time in the HTML format. All `fmt.Fprintf()` calls send data back to the HTTP
    client, whereas the output of `fmt.Printf()` is printed on the terminal that the
    web server runs on. The first argument of `fmt.Fprintf()` is the `w http.ResponseWriter`,
    which implements `io.Writer` and, therefore, can accept data for writing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个名为`timeHandler`的另一个处理器函数，它以HTML格式返回当前时间。所有的`fmt.Fprintf()`调用都将数据发送回HTTP客户端，而`fmt.Printf()`的输出则打印在Web服务器运行的终端上。`fmt.Fprintf()`的第一个参数是`w
    http.ResponseWriter`，它实现了`io.Writer`接口，因此可以接受用于写入的数据。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is where you define the port number that your web server is going to listen
    to.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你定义你的Web服务器将要监听的端口号的地方。
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you use port number `0`, you are going to get a randomly selected free port,
    which is pretty handy for testing or when you do not want to specify the port
    yourself.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用端口号`0`，你将得到一个随机选择的可用端口号，这对于测试或当你不想自己指定端口号时非常方便。
- en: If you do not want to use the predefined port number (`8001`), then you should
    provide `wwwServer.go` with your own port number as a command line argument.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用预定义的端口号（`8001`），那么你应该将你自己的端口号作为命令行参数提供给`wwwServer.go`。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, the web server supports the `/time` URL as well as `/`. The `/` path matches
    every URL not matched by other handlers. The fact that we associate `myHandler()`
    with `/` makes `myHandler()` the default handler function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Web服务器支持`/time`和`/`这两个URL。`/`路径匹配所有其他处理器没有匹配的URL。我们将`myHandler()`与`/`关联的事实使得`myHandler()`成为默认的处理器函数。
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `http.ListenAndServe()` call begins the HTTP server using the predefined
    port number. As there is no hostname given in the `PORT` string, the web server
    is going to listen to all available network interfaces. The port number and the
    hostname should be separated with a colon (`:`), which should be there even if
    there is no hostname—in that case, the server listens to all available network
    interfaces and, therefore, all supported hostnames. This is the reason that the
    value of `PORT` is `:8001` instead of just `8001`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.ListenAndServe()`调用使用预定义的端口号开始HTTP服务器。由于`PORT`字符串中没有给出主机名，Web服务器将监听所有可用的网络接口。端口号和主机名应该用冒号（`:`）分隔，即使没有主机名，也应该有这个冒号——在这种情况下，服务器将监听所有可用的网络接口和所有支持的主机名。这就是为什么`PORT`的值是`:8001`而不是仅仅`8001`。'
- en: Part of the `net/http` package is the `ServeMux` struct (`go doc http.ServeMux`),
    which is an HTTP request multiplexer that provides a slightly different way of
    defining handler functions and endpoints than the default one, which is used in
    `wwwServer.go`. So if we do not create and configure our own `ServeMux` variable,
    then `http.HandleFunc()` uses `DefaultServeMux`, which is the default `ServeMux`.
    So in this case, we are going to implement the web service using the default Go
    router—this is the reason that the second parameter of `http.ListenAndServe()`
    is `nil`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包的一部分是`ServeMux`结构体（`go doc http.ServeMux`），它是一个HTTP请求多路复用器，它提供了一种与默认方式略有不同的定义处理器函数和端点的方法，默认方式在`wwwServer.go`中使用。所以如果我们不创建和配置我们自己的`ServeMux`变量，那么`http.HandleFunc()`将使用`DefaultServeMux`，即默认的`ServeMux`。因此，在这种情况下，我们将使用默认的Go路由器来实现Web服务——这就是为什么`http.ListenAndServe()`的第二个参数是`nil`。'
- en: 'Running `wwwServer.go` and interacting with it using `curl(1)` produces the
    following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`wwwServer.go`并使用`curl(1)`与之交互会产生以下输出：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that as `wwwServer.go` does not terminate automatically, you need to stop
    it on your own.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`wwwServer.go`不会自动终止，你需要自己停止它。
- en: 'On the `curl(1)` side, the interaction looks as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`curl(1)`这一侧，交互看起来如下：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this first case, we visit the `/` path of the web server, and we are served
    by `myHandler()`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们访问了Web服务器的`/`路径，并由`myHandler()`提供服务。
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, we visit `/time`, and we get HTML output back from `timeHandler()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们访问了`/time`，并从`timeHandler()`得到了HTML输出。
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this last case, we visit `/doesNotExist`, which does not exist. As this cannot
    be matched by any other path, it is served by the default handler, which is the
    `myHandler()` function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后这种情况中，我们访问了不存在的`/doesNotExist`路径。由于它不能与任何其他路径匹配，因此由默认处理器提供服务，即`myHandler()`函数。
- en: The next section is about making the statistics application a web application!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是关于将统计应用程序变成Web应用程序！
- en: Updating the statistics application
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新统计应用程序
- en: 'This time, the statistics application is going to work as a web service. The
    two main tasks that need to be performed are defining the API along with the endpoints
    and implementing the API. A third task that needs to be determined concerns data
    exchange between the application server and its clients. There exist many approaches
    regarding data exchange between the server and its clients. We are going to discuss
    the following four ways:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，统计应用程序将作为一个网络服务运行。需要执行的两个主要任务是定义 API 以及端点，并实现 API。还有一个需要确定的任务是关于应用程序服务器与其客户端之间的数据交换。关于服务器与其客户端之间的数据交换存在许多方法。我们将讨论以下四种方法：
- en: Using plain text
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纯文本
- en: Using HTML
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTML
- en: Using JSON
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON
- en: Using a hybrid approach that combines plain text and JSON data
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用结合纯文本和 JSON 数据的混合方法
- en: As JSON is explored in *Chapter 11*, *Working with REST APIs*, and HTML might
    not be the best option for a service because you need to separate the data from
    the HTML tags and parse the data, we are going to use the first approach. Therefore,
    the service is going to work with plain text data. We begin by defining the API
    that supports the operation of the statistics application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 *第 11 章*，*使用 REST API 工作中* 探讨了 JSON，而 HTML 可能不是服务的最佳选择，因为您需要将数据与 HTML 标签分开并解析数据，我们将使用第一种方法。因此，服务将使用纯文本数据。我们首先定义支持统计应用程序操作的
    API。
- en: Defining the API
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 API
- en: 'The API has support for the following URLs:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: API 支持以下 URL：
- en: '`/list`: This lists all available entries.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/list`: 这会列出所有可用的条目。'
- en: '`/insert/name/d1/d2/d3/.../`: This inserts a new dataset. Later in this chapter,
    we are going to see how to extract the desired information from a URL that contains
    user data and parameters. The key point here is that the number of elements in
    a dataset varies so the URL is going to contain a variable number of values.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/insert/name/d1/d2/d3/.../`: 这将插入一个新的数据集。在本章的后面部分，我们将看到如何从包含用户数据和参数的 URL 中提取所需信息。关键点是数据集中元素的数量是可变的，因此
    URL 将包含可变数量的值。'
- en: '`/delete/name/`: This deletes an entry based on the name of the dataset.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/delete/name/`: 这是在数据集名称的基础上删除条目的操作。'
- en: '`/search/name/`: This searches for an entry based on the dataset name.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/search/name/`: 这是在数据集名称的基础上搜索条目的操作。'
- en: '`/status`: This is an extra URL that returns the number of entries in the statistics
    application.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/status`: 这是一个额外的 URL，它返回统计应用程序中的条目数量。'
- en: The list of endpoints does not follow standard REST conventions—all these are
    going to be presented in *Chapter 11*, *Working with REST APIs*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 端点列表不遵循标准的 REST 规范——所有这些内容都将在 *第 11 章*，*使用 REST API 工作中* 进行介绍。
- en: 'This time, **we are not using the default Go router**, which means that we
    define and configure our own `http.NewServeMux()` variable. This changes the way
    we provide handler functions: a handler function with the `func(http.ResponseWriter,
    *http.Request)` signature has to be converted into an `http.HandlerFunc` type
    and used by the `ServeMux` type and its own `Handle()` method. Therefore, when
    using a different `ServeMux` than the default one, we should do that conversion
    explicitly by calling `http.HandlerFunc()`, which makes the `http.HandlerFunc`
    type act as an adapter that allows the use of ordinary functions as HTTP handlers,
    provided that they have the required signature. This is not a problem when using
    the default Go router (`DefaultServeMux`) because the `http.HandleFunc()` function
    does that conversion automatically and internally. However, you can also use the
    `HandleFunc()` method from the `ServeMux` type to do the same implicit conversion.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，**我们不使用默认的 Go 路由器**，这意味着我们定义并配置自己的 `http.NewServeMux()` 变量。这改变了我们提供处理函数的方式：具有
    `func(http.ResponseWriter, *http.Request)` 签名的处理函数必须转换为 `http.HandlerFunc` 类型，并由
    `ServeMux` 类型及其 `Handle()` 方法使用。因此，当使用不同于默认 Go 路由器（`DefaultServeMux`）的其他 `ServeMux`
    时，我们应该通过调用 `http.HandlerFunc()` 来显式进行此转换，这使得 `http.HandlerFunc` 类型充当一个适配器，允许使用具有所需签名的普通函数作为
    HTTP 处理器。当使用默认的 Go 路由器时，这不是问题，因为 `http.HandleFunc()` 函数会自动进行此转换。然而，您也可以使用 `ServeMux`
    类型的 `HandleFunc()` 方法来进行相同的隐式转换。
- en: To make things clearer, the `http.HandlerFunc` type has support for a method
    named `HandlerFunc()`—both the type and method are defined in the `http` package.
    The similarly named `http.HandleFunc()` function (without an `r`) is used with
    the default Go router.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更清晰，`http.HandlerFunc` 类型支持一个名为 `HandlerFunc()` 的方法——类型和方法都在 `http` 包中定义。同样命名的
    `http.HandleFunc()` 函数（不带 `r`）与默认的 Go 路由器一起使用。
- en: As an example, for the `/time` endpoint and the `timeHandler()` handler function,
    you should call `mux.Handle()` as `mux.Handle("/time", http.HandlerFunc(timeHandler))`.
    If you were using `http.HandleFunc()` and, as a consequence, `DefaultServeMux`,
    then you should have called `http.HandleFunc("/time", timeHandler)` instead.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 `/time` 端点和 `timeHandler()` 处理函数，你应该调用 `mux.Handle()` 如 `mux.Handle("/time",
    http.HandlerFunc(timeHandler))`。如果你使用 `http.HandleFunc()` 并且因此使用 `DefaultServeMux`，那么你应该调用
    `http.HandleFunc("/time", timeHandler)`。
- en: The subject of the next subsection is the implementation of the HTTP endpoints.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节的主题是 HTTP 端点的实现。
- en: Implementing the handlers
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现处理程序
- en: 'The new version of the statistics application is going to be created inside
    `~/go/src`: `~/go/src/github.com/mactsouk/mGo4th/ch09/server`. As expected, you
    also need to do the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 统计应用的新版本将在 `~/go/src` 目录下创建：`~/go/src/github.com/mactsouk/mGo4th/ch09/server`。正如预期的那样，你还需要执行以下操作：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you use the GitHub repository of the book, you are not going to need to create
    the server from scratch, as the Go code is already there.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用本书的 GitHub 仓库，你不需要从头创建服务器，因为 Go 代码已经在那里了。
- en: 'The `stats.go` file holds the code that defines the operation of the web server.
    Usually, handlers are put in a separate external package, but for reasons of simplicity,
    we have decided to put handlers in a separate file named `handlers.go` within
    the same package. The contents of the `handlers.go` file, which contains all functionality
    related to the serving of the clients, are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats.go` 文件包含定义 Web 服务器操作的代码。通常，处理程序被放在一个单独的外部包中，但为了简单起见，我们决定在同一包内创建一个名为
    `handlers.go` 的单独文件来放置处理程序。包含所有与客户端服务相关的功能的 `handlers.go` 文件内容如下：'
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All required packages for `handlers.go` are imported, even if some of them have
    already been imported by `stats.go`. Note that the name of the package is `main`,
    which is also the case for `stats.go`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `handlers.go` 所需的所有包都已导入，即使其中一些已经被 `stats.go` 导入。请注意，包的名称是 `main`，这与 `stats.go`
    的情况相同。
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the default port number that the HTTP server listens to.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 HTTP 服务器监听的自定义端口号。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is the default handler, which serves all requests that are not a match
    for any of the other handlers. Next is the handler for deleting entries:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认处理程序，它为所有不匹配其他处理程序请求提供服务。接下来是删除条目的处理程序：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is the handler function for the `/delete` path, which begins by splitting
    the URL in order to read the desired information. If we do not have enough parameters,
    we should send an error message back to the client with the appropriate HTTP code,
    which in this case is `http.StatusNotFound`. You can use any HTTP code you want
    as long as it makes sense. The `WriteHeader()` method sends back a header with
    the provided status code, before writing the body of the response.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `/delete` 路径的处理函数，它首先分割 URL 以读取所需信息。如果我们没有足够的参数，我们应该使用适当的 HTTP 状态码（在这种情况下是
    `http.StatusNotFound`）向客户端发送错误消息。只要它有意义，你可以使用任何你想要的 HTTP 状态码。`WriteHeader()` 方法在写入响应体之前发送带有提供状态码的头部。
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is where the HTTP server sends data to log files—this mainly happens for
    debugging reasons.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 HTTP 服务器向日志文件发送数据的地方——这主要发生在调试原因。
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As the delete process is based on the dataset name, all that is required is
    a valid dataset name. This is where the parameter is read after splitting the
    provided URL. If the `deleteEntry()` function returns an error, then we construct
    a fitting response and send it to the client.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于删除过程基于数据集名称，因此所需的所有内容只是一个有效的数据集名称。这是在分割提供的 URL 后读取参数的地方。如果 `deleteEntry()`
    函数返回错误，那么我们将构建一个合适的响应并发送给客户端。
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At this point, we know that the delete operation was successful, so we send
    a proper message to the client as well as the `http.StatusOK` status code. Type
    `go doc http.StatusOK` for the list of codes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们知道删除操作已成功，因此我们也向客户端发送了适当的消息以及 `http.StatusOK` 状态码。输入 `go doc http.StatusOK`
    查看代码列表。
- en: 'Next up is the implementation of `listHandler()`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `listHandler()` 的实现：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `list()` helper function that is used in the `/list` path cannot fail. Therefore,
    `http.StatusOK` is always returned when serving `/list`. However, sometimes the
    return value of `list()` can be the empty string.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/list` 路径中使用的 `list()` 辅助函数不能失败。因此，在服务 `/list` 时，总是返回 `http.StatusOK`。然而，有时
    `list()` 的返回值可以是空字符串。
- en: 'Next, we implement `statusHandler()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现 `statusHandler()`：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code defines the handler function for `/status`. It just returns
    information about the total number of entries found in the statistics application.
    It can be used to verify that the web service works fine.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码定义了 `/status` 的处理函数。它只是返回统计应用中找到的总条目数。它可以用来验证网络服务是否正常工作。
- en: 'Next, we present the implementation of the `insertHandler()` handler:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示 `insertHandler()` 处理器的实现：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As before, we need to split the given URL in order to extract the information.
    In this case, we need at least four elements, as we are trying to insert a new
    dataset into the statistics service.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们需要分割给定的 URL 以提取信息。在这种情况下，我们需要至少四个元素，因为我们正在尝试将一个新的数据集插入到统计服务中。
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the previous code, we initialize the `dataset` variable and read the data
    elements, which have a variable length. In this case, we also need to convert
    the data elements into `float64` values because they are read as text.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们初始化了 `dataset` 变量并读取了具有可变长度的数据元素。在这种情况下，我们还需要将数据元素转换为 `float64` 值，因为它们是以文本形式读取的。
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the end of the handler for `/insert`. The last part of the implementation
    of `insertHandler()` deals with the return value of `insert()`. If there was not
    an error, then `http.StatusOK` is sent to the client. In the opposite case, `http.StatusNotModified`
    is returned to signify that there was not a change in the statistics application.
    It is the job of the client to examine the status code of the interaction, but
    it is the job of the server to send an appropriate status code back to the client.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `/insert` 处理器的结束。`insertHandler()` 实现的最后一部分处理 `insert()` 的返回值。如果没有错误，则向客户端发送
    `http.StatusOK`。相反，如果返回 `http.StatusNotModified`，则表示统计应用中没有变化。检查交互的状态码是客户端的工作，但向客户端发送适当的响应状态码是服务器的工作。
- en: 'Next, we implement `searchHandler()`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现 `searchHandler()`：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At this point, we extract the dataset name from the URL, as we did with `/delete`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们从 URL 中提取数据集名称，就像我们在 `/delete` 中做的那样。
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The last function of `handlers.go` ends here and is about the `/search` endpoint.
    The `search()` helper function checks whether the given input exists in the data
    records or not and acts accordingly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlers.go` 的最后一个函数在这里结束，它关于 `/search` 端点。`search()` 辅助函数检查给定的输入是否存在于数据记录中，并相应地执行操作。'
- en: 'Additionally, the implementation of the `main()` function, which can be found
    in `stats.go`, is the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`main()` 函数的实现，可以在 `stats.go` 中找到，如下所示：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This first part of `main()` relates to the proper initialization of the statistics
    application. Internally, data is stored in the JSON format.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 的这部分与统计应用的正确初始化有关。内部，数据以 JSON 格式存储。'
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we store the parameters of the HTTP server in the `http.Server` structure
    and use our own `http.NewServeMux()` instead of the default one.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 HTTP 服务器的参数存储在 `http.Server` 结构中，并使用我们自己的 `http.NewServeMux()` 而不是默认的。
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is the list of the supported URLs. Note that `/search` and `/search/` are
    both handled by the same handler function even though `/search` is going to fail,
    as it does not include the required data. On the other hand, `/delete/` is handled
    differently—this will be apparent when testing the application. As we are using
    `http.NewServeMux()` and not the default Go router, we need to use `http.HandlerFunc()`
    when defining the handler functions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是支持的 URL 列表。请注意，尽管 `/search` 将会失败，因为它没有包含所需的数据，但 `/search` 和 `/search/` 都由同一个处理函数处理。另一方面，`/delete/`
    的处理方式不同——这将在测试应用时变得明显。由于我们使用 `http.NewServeMux()` 而不是默认的 Go 路由器，因此在定义处理函数时需要使用
    `http.HandlerFunc()`。
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As mentioned earlier in this chapter, each `mux.Handle()` call can be replaced
    by an equivalent `mux.HandleFunc()` call. So `mux.Handle("/list", http.HandlerFunc(listHandler))`
    is going to become `mux.HandleFunc("/list", listHandler)`. The same applies to
    all the other `mux.Handle()` calls.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，每个 `mux.Handle()` 调用都可以替换为等效的 `mux.HandleFunc()` 调用。因此，`mux.Handle("/list",
    http.HandlerFunc(listHandler))` 将变为 `mux.HandleFunc("/list", listHandler)`。这同样适用于所有其他的
    `mux.Handle()` 调用。
- en: The `ListenAndServe()` method starts the HTTP server using the parameters defined
    previously in the `http.Server` structure. The rest of `stats.go` contains helper
    functions related to the operation of the web service. Note that it is important
    to save and update the contents of the application as often as possible because
    this is a live application, and you might lose data if it crashes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListenAndServe()`方法使用在`http.Server`结构中先前定义的参数启动HTTP服务器。`stats.go`的其余部分包含与网络服务操作相关的辅助函数。请注意，尽可能频繁地保存和更新应用程序的内容非常重要，因为这是一个实时应用程序，如果它崩溃，你可能会丢失数据。'
- en: 'The next command allows you to execute the application—you need to provide
    both files in `go run`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令允许你执行应用程序——你需要在`go run`中提供两个文件：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'On the client side, which is `curl(1)`, we have the following interactions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，即`curl(1)`，我们有以下交互：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we get all entries from the statistics application by visiting `/list`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们通过访问`/list`获取统计应用程序的所有条目：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The previous command is going to work if `d1` is in the list of existing datasets.
    If your list is empty or `d1` does not exist, you should include it before deleting
    it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`d1`存在于现有数据集列表中，之前的命令将会工作。如果你的列表为空或`d1`不存在，你应该在删除它之前将其包含在内。
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the previous part, we tried to delete the `d1` and `d2` datasets. Trying
    to delete `d1` again fails.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分，我们尝试删除了`d1`和`d2`数据集。再次尝试删除`d1`会失败。
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we visit `/status` and get back the expected output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们访问`/status`并得到预期的输出：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'First, we search for `d3`, which does not exist, and then for `d4`, which exists.
    In the latter case, the web service returns the data of `d4`. Now, let us try
    and visit `/delete` instead of `/delete/`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们搜索不存在的`d3`，然后搜索存在的`d4`。在后一种情况下，网络服务返回`d4`的数据。现在，让我们尝试访问`/delete`而不是`/delete/`：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The presented message was generated by the Go router and tells us that we should
    try `/delete/` instead because `/delete` was moved permanently. This is the kind
    of message that we get by not specifically defining both `/delete` and `/delete/`
    in the routes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的消息是由Go路由器生成的，并告诉我们应该尝试`/delete/`而不是`/delete`，因为`/delete`已被永久移动。这是我们没有在路由中明确定义`/delete`和`/delete/`时可能会得到的消息类型。
- en: 'Now, let us insert two datasets:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们插入两个数据集：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The previous commands are going to work if both `v1` and `v2` do not already
    exist. If we try to insert a dataset with a name that already exists, we get no
    response back other than `304 – Not Modified`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`v1`和`v2`都不存在，之前的命令将会工作。如果我们尝试插入一个已存在的数据集，除了`304 – Not Modified`之外，我们不会收到任何响应。
- en: Everything looks like it is working OK. We can now put the statistics web service
    online and interact with it using multiple HTTP requests, as the `http` package
    uses multiple goroutines to interact with clients—in practice, this means that
    the statistics application runs concurrently! However, in its current version,
    there is no protection against data races, which might take place if we try to
    insert the same dataset more than once at the exact same time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的东西看起来都在正常工作。现在我们可以将统计网络服务上线，并通过多个HTTP请求与之交互，因为`http`包使用多个goroutine与客户端交互——在实践中，这意味着统计应用程序是并发运行的！然而，在其当前版本中，没有保护措施来防止数据竞争，如果我们尝试在完全相同的时间插入相同的数据集多次，可能会发生数据竞争。
- en: Later in this chapter, we are going to create a command line client for the
    statistics server. Additionally, *Chapter 12*, *Code Testing and Profiling*, shows
    how to test your code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将为统计服务器创建一个命令行客户端。此外，*第12章*，*代码测试和性能分析*展示了如何测试你的代码。
- en: The next section shows how to build Docker images for server applications.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将展示如何为服务器应用程序构建Docker镜像。
- en: Creating a Docker image
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Docker镜像
- en: This section shows how to convert a Go application into a Docker image—the kind
    of application we are going to use is an HTTP server that interacts with the outer
    world. In our case, it is going to be the statistical web service that we have
    just developed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何将Go应用程序转换为Docker镜像——我们将使用的是一种与外部世界交互的HTTP服务器。在我们的案例中，它将是刚刚开发的统计网络服务。
- en: 'The contents of `buildDocker`, which contains the steps to create a Docker
    image, are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildDocker`的内容，其中包含创建Docker镜像的步骤，如下所示：'
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After that, we can use the `buildDocker` file to build a Docker image, named
    `goapp`, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用`buildDocker`文件来构建一个名为`goapp`的Docker镜像，如下所示：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The contents of `docker-compose.yml`, which allows us to use a Docker image,
    are as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yml`的内容，它允许我们使用Docker镜像，如下所示：'
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What is important in the `docker-compose.yml` file is to use the `goapp` image
    name that was created in the previous step.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker-compose.yml`文件中重要的是使用在上一步骤中创建的`goapp`镜像名称。
- en: 'Having the `docker-compose.yml` at hand, we can use it as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有`docker-compose.yml`，我们可以这样使用它：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After that, we are free to interact with the web service using `curl(1)` or
    any other similar tool. When done, we can use *Ctrl* + *C* to stop the Docker
    image from running.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以自由地使用`curl(1)`或其他类似工具与网络服务进行交互。完成后，我们可以使用*Ctrl* + *C*来停止Docker镜像的运行。
- en: The main disadvantage of this particular web service is that once you disable
    the Docker image, all data is lost—the solution to this problem is simple. You
    can either store the data in an external database or link the internal Docker
    data file to a file in the local filesystem. Implementing either of these two
    solutions is beyond the scope of this chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定网络服务的主要缺点是，一旦你禁用Docker镜像，所有数据都会丢失——这个问题的解决方案很简单。你可以将数据存储在外部数据库中，或者将内部Docker数据文件链接到本地文件系统中的文件。实现这两种解决方案超出了本章的范围。
- en: After learning about HTTP servers, the next section shows how to develop HTTP
    clients.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解HTTP服务器之后，下一节将展示如何开发HTTP客户端。
- en: Developing web clients
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发网络客户端
- en: 'This section shows how to develop HTTP clients, starting with a simplistic
    version and continuing with a more advanced one. In this simplistic version, all
    of the work is done by the `http.Get()` call, which is pretty convenient when
    you do not want to deal with lots of options and parameters. However, this type
    of call gives you no flexibility over the process. Notice that `http.Get()` returns
    an `http.Response` value. All this is illustrated in `simpleClient.go`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何开发HTTP客户端，从简单版本开始，然后继续到更高级的版本。在这个简单版本中，所有工作都是由`http.Get()`调用完成的，当你不希望处理大量选项和参数时，这非常方便。然而，这种类型的调用给你在过程中的灵活性很小。请注意，`http.Get()`返回一个`http.Response`值。所有这些都在`simpleClient.go`中得到了说明：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `filepath.Base()` function returns the last element of a path. When given
    `os.Args[0]` as its parameter, it returns the name of the executable binary file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`filepath.Base()`函数返回路径的最后一个元素。当以`os.Args[0]`作为其参数时，它返回可执行二进制文件名。'
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the previous two statements, we get the URL and its data using `http.Get()`,
    which returns an `*http.Response` and an `error` variable. The `*http.Response`
    value contains all the information, so you do not need to make any additional
    calls to `http.Get()`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个语句中，我们使用`http.Get()`获取URL及其数据，它返回一个`*http.Response`和一个`error`变量。`*http.Response`值包含所有信息，因此你不需要对`http.Get()`进行任何额外的调用。
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `io.Copy()` function reads from the `data.Body` reader, which contains
    the body of the server response, and writes the data to `os.Stdout`. As `os.Stdout`
    is always open, you do not need to open it for writing. Therefore, all data is
    written to standard output, which is usually the terminal window:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Copy()`函数从`data.Body`读取器中读取，它包含服务器响应的主体，并将数据写入`os.Stdout`。由于`os.Stdout`始终是打开的，因此你不需要为写入而打开它。因此，所有数据都写入标准输出，这通常是终端窗口：'
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Last, we close the `data.Body` reader to make the work of garbage collection
    easier.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们关闭`data.Body`读取器，以便使垃圾收集工作更容易。
- en: 'Working with `simpleClient.go` produces the following kind of output, which
    in this case is abbreviated:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`simpleClient.go`生成以下类型的输出，在这种情况下是缩略的：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Although `simpleClient.go` does the job of verifying that the given URL exists
    and is reachable, it offers no control over the process. The next subsection develops
    an advanced HTTP client that processes the server response.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`simpleClient.go`负责验证给定的URL是否存在且可访问，但它对过程没有控制权。下一小节将介绍一个高级HTTP客户端，该客户端处理服务器响应。
- en: Using http.NewRequest() to improve the client
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用http.NewRequest()改进客户端
- en: As the web client of the previous section is relatively simplistic and does
    not give you any flexibility, in this subsection, you will learn how to read a
    URL without using the `http.Get()` function and by having more options. However,
    the extra flexibility comes at a cost, as you must write more code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节的网络客户端相对简单，并且没有提供任何灵活性，在本小节中，你将学习如何在不使用`http.Get()`函数的情况下读取URL，并且拥有更多选项。然而，额外的灵活性是有代价的，因为你必须编写更多的代码。
- en: 'The code of `wwwClient.go` is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`wwwClient.go`的代码如下：'
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Although using `filepath.Base()` is not necessary, it makes your output more
    professional.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`filepath.Base()`不是必需的，但它可以使你的输出更加专业。
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `url.Parse()` function parses a string into a URL structure. This means
    that if the given argument is not a valid URL, `url.Parse()` is going to notice.
    As usual, we need to check the `error` variable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`url.Parse()` 函数将字符串解析为 URL 结构。这意味着如果给定的参数不是一个有效的 URL，`url.Parse()` 会注意到。像往常一样，我们需要检查
    `error` 变量。'
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `http.NewRequest()` function returns an `http.Request` object when provided
    with a method, a URL, and an optional body. The `http.MethodGet` parameter defines
    that we want to retrieve the data using a `GET` HTTP method, whereas `URL.String()`
    returns the `string` value of an `http.URL` variable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.NewRequest()` 函数在提供方法、URL和可选主体时返回一个 `http.Request` 对象。`http.MethodGet`
    参数定义了我们想使用 `GET` HTTP 方法检索数据，而 `URL.String()` 返回 `http.URL` 变量的 `string` 值。'
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `http.Do()` function sends an HTTP request (`http.Request`) using an `http.Client`
    and gets an `http.Response` back. So `http.Do()` does the job of `http.Get()`
    in a more detailed way:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Do()` 函数使用 `http.Client` 发送 HTTP 请求（`http.Request`）并返回一个 `http.Response`。因此，`http.Do()`
    以更详细的方式完成了 `http.Get()` 的工作：'
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`httpData.Status` holds the HTTP status code of the response—this is important
    because it allows you to understand what really happened with the request.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpData.Status` 存储响应的 HTTP 状态码——这很重要，因为它允许你了解请求实际上发生了什么。'
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `httputil.DumpResponse()` function is used here to get the response from
    the server and is mainly used for debugging purposes. The second argument of `httputil.DumpResponse()`
    is a Boolean value that specifies whether the function is going to include the
    body or not in its output—in our case, it is set to `false`, which excludes the
    response body from the output and only prints the header. If you want to do the
    same on the server side, you should use `httputil.DumpRequest()`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`httputil.DumpResponse()` 函数在此处用于获取服务器的响应，主要用于调试目的。`httputil.DumpResponse()`
    的第二个参数是一个布尔值，用于指定函数是否在输出中包含主体——在我们的例子中，它被设置为 `false`，这意味着响应主体不会被包含在输出中，只会打印头部。如果你想在服务器端做同样的事情，你应该使用
    `httputil.DumpRequest()`。'
- en: '[PRE55]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here, we find out about the character set of the response by searching the
    value of `Content-Type`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过搜索 `Content-Type` 的值来了解响应的字符集：
- en: '[PRE56]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we try to get the content length from the response by reading `httpData.ContentLength`.
    However, if the value is not set, we print a relevant message:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试通过读取 `httpData.ContentLength` 来获取响应的内容长度。然而，如果该值未设置，我们会打印一条相关的消息：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the last part of the program, we use a technique for discovering the size
    of the server HTTP response on our own. If we wanted to display the HTML output
    on our screen, we could have printed the contents of the `r` buffer variable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的最后一部分，我们使用一种技术来自行发现服务器 HTTP 响应的大小。如果我们想在屏幕上显示 HTML 输出，我们可以打印 `r` 缓冲区变量的内容。
- en: 'Working with `wwwClient.go` and visiting [https://www.golang.org](https://www.golang.org)
    produces the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `wwwClient.go` 并访问 [https://www.golang.org](https://www.golang.org) 产生以下输出：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The previous is the output of `fmt.Println("Status code:", httpData.Status)`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出是 `fmt.Println("Status code:", httpData.Status)` 的输出。
- en: 'Next, we see the output of the `fmt.Print(string(header))` statement with the
    header data of the HTTP server response:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到 `fmt.Print(string(header))` 语句的输出，其中包含 HTTP 服务器响应的头部数据：
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The last part of the output is about the character set of the interaction (`utf-8`)
    and the content length of the response (`61870`), as calculated by the code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后一部分是关于交互的字符集（`utf-8`）和响应的内容长度（`61870`），这是通过以下代码计算得出的：
- en: '[PRE60]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Let us now see a technique to fetch multiple addresses concurrently.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个同时获取多个地址的技术。
- en: Using errGroup
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `errGroup`
- en: In this section, we are going to use the `errGroup` package to fetch multiple
    URLs concurrently, using the `golang.org/x/sync/errgroup` external package. For
    that reason, `eGroup.go` is located at `~/go/src/github.com/mactsouk/mGo4th/ch09/eGroup`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `errGroup` 包来通过 `golang.org/x/sync/errgroup` 外部包并发地获取多个 URL，因此 `eGroup.go`
    位于 `~/go/src/github.com/mactsouk/mGo4th/ch09/eGroup`。
- en: 'The code of `eGroup.go` is presented in two parts. The first part is the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`eGroup.go` 的代码分为两部分。第一部分如下：'
- en: '[PRE61]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We use the `errgroup.Group` variable, which is a collection of goroutines that
    work on parts of the same bigger task. In general, the `errgroup` package provides
    synchronization, error propagation, and `Context` cancelation for goroutines that
    work on subtasks of the same task that we want to treat as a group.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `errgroup.Group` 变量，它是一组工作在相同更大任务不同部分的 goroutines。一般来说，`errgroup` 包为工作在相同任务子任务的
    goroutines 提供同步、错误传播和 `Context` 取消。
- en: 'The second part of `eGroup.go` comes with the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`eGroup.go` 的第二部分包含以下代码：'
- en: '[PRE62]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this part, we use `g.Go()` to call the desired function as a goroutine. Additionally,
    we use a **closured variable** for the `url` variable so that each goroutine processes
    the desired URL correctly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们使用 `g.Go()` 以 goroutine 的形式调用所需的函数。此外，我们使用闭包变量为 `url` 变量，以确保每个 goroutine
    正确处理所需的 URL。
- en: 'As expected, we need to run the following two commands first:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们需要先运行以下两个命令：
- en: '[PRE63]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Running `eGroup.go` on my macOS machine generates the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 macOS 机器上运行 `eGroup.go` 生成以下输出：
- en: '[PRE64]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Running the same command on my Arch Linux machine produces a different output:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 Arch Linux 机器上运行相同的命令会产生不同的输出：
- en: '[PRE65]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The next section shows how to create a command line client for the statistics
    web service we developed earlier.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将展示如何为我们之前开发的统计网络服务创建一个命令行客户端。
- en: Creating a client for the statistics service
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建统计服务的客户端
- en: 'In this subsection, we create a command line utility that interacts with the
    statistics web service that was developed earlier in this chapter. This version
    of the statistics client is going to be created using the `cobra` package, and
    as expected, it is going to go under `~/go/src`: `~/go/src/github.com/mactsouk/mGo4th/ch09/client`.
    The previous directory contains the final version of the client. The initial steps
    for creating the client are the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个子节中，我们创建一个与本章早期开发的统计网络服务交互的命令行实用程序。这个统计客户端版本将使用 `cobra` 包创建，并且正如预期的那样，它将位于
    `~/go/src`：`~/go/src/github.com/mactsouk/mGo4th/ch09/client`。上一个目录包含客户端的最终版本。创建客户端的初始步骤如下：
- en: '[PRE66]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: So, we have a command line utility with five commands, named `search`, `insert`,
    `delete`, `status`, and `list`. After that, we need to implement the commands
    and define their local parameters in order to interact with the statistics server.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个包含五个命令的命令行实用程序，分别命名为 `search`、`insert`、`delete`、`status` 和 `list`。之后，我们需要实现这些命令并定义它们的本地参数，以便与统计服务器交互。
- en: 'Now, let us see the implementations of the commands, starting from the implementation
    of the `init()` function of the `root.go` file because this is where the global
    command line parameters are defined:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看命令的实现，从 `root.go` 文件的 `init()` 函数实现开始，因为这是定义全局命令行参数的地方：
- en: '[PRE67]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: So, we define two global parameters named `server` and `port`, which are the
    hostname and the port number of the server, respectively. Both parameters have
    an alias and are handled by `viper`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了两个全局参数，分别命名为 `server` 和 `port`，它们分别是服务器的主机名和端口号。这两个参数都有一个别名，并由 `viper`
    处理。
- en: 'Let us now examine the implementation of the `status` command as found in `status.go`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查 `status` 命令在 `status.go` 中的实现：
- en: '[PRE68]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'All commands read the values of the `server` and `port` command line parameters
    to get information about the server, and the `status` command is no exception:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命令都会读取 `server` 和 `port` 命令行参数的值以获取有关服务器的信息，`status` 命令也不例外：
- en: '[PRE69]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: After that, we construct the full URL of the request.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们构建请求的完整 URL。
- en: '[PRE70]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Then, we send a `GET` request to the server using `http.Get()`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `http.Get()` 向服务器发送一个 `GET` 请求。
- en: '[PRE71]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: After that, we check the HTTP status code of the request to make sure that everything
    is OK.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们检查请求的 HTTP 状态码以确保一切正常。
- en: '[PRE72]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If everything is OK, we read the entire body of the server response, which
    is a byte slice, and print it onscreen as a string. The implementation of `list`
    is almost identical to the implementation of `status`. The only differences are
    that the implementation is found in `list.go` and that the full URL is constructed
    as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们读取服务器响应的全部内容，它是一个字节切片，并将其作为字符串打印到屏幕上。`list` 的实现几乎与 `status` 的实现相同。唯一的区别是，实现位于
    `list.go` 中，并且完整的 URL 构建如下：
- en: '[PRE73]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'After that, let us see how the `delete` command is implemented in `delete.go`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们看看 `delete` 命令在 `delete.go` 中的实现：
- en: '[PRE74]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Apart from reading the values of the `server` and `port` global parameters,
    we read the value of the `dataset` parameter. If `dataset` has no value, the command
    returns this.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除了读取`server`和`port`全局参数的值之外，我们还读取`dataset`参数的值。如果`dataset`没有值，则命令将返回此信息。
- en: '[PRE75]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Once again, we construct the full URL of the request before connecting to the
    server.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们在连接到服务器之前构建了请求的完整URL。
- en: '[PRE76]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The previous code sends the client request to the server.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将客户端请求发送到服务器。
- en: '[PRE77]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If there is an error in the server response, the `delete` command prints the
    HTTP error and terminates.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器响应中存在错误，`delete`命令将打印HTTP错误并终止。
- en: '[PRE78]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If everything was fine, the server response text is printed on the screen.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，服务器响应文本将打印在屏幕上。
- en: The `init()` function of `delete.go` contains the definition of the local `dataset`
    command line parameter to get the dataset name to delete.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete.go`中的`init()`函数包含了定义本地`dataset`命令行参数以获取要删除的数据集名称的定义。'
- en: 'Next, let us learn more about the `search` command and how it is implemented
    in `search.go`. The implementation is the same as in `delete` except for the full
    request URL:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更深入地了解`search`命令及其在`search.go`中的实现方式。实现方式与`delete`相同，除了完整的请求URL：
- en: '[PRE79]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `search` command also supports the `dataset` command line parameter in getting
    the dataset name to search for—this is defined in the `init()` function of `search.go`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`命令也支持`dataset`命令行参数，用于获取要搜索的数据集名称——这是在`search.go`的`init()`函数中定义的。'
- en: 'The last command that is presented is the `insert` command, which supports
    two local command line parameters that are defined in the `init()` function in
    `insert.go`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个展示的命令是`insert`命令，它支持两个在`insert.go`中的`init()`函数中定义的本地命令行参数：
- en: '[PRE80]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: These two parameters are needed to get the required user input. However, the
    value of the `values` parameter is expected to be a comma-separated list of floating-point
    values—this is the way we define how to get all the elements of a dataset.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数是获取所需用户输入所必需的。然而，`values`参数的值预期是一个以逗号分隔的浮点数值列表——这是我们定义如何获取数据集所有元素的方式。
- en: 'The `insert` command is implemented using the following code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert`命令是通过以下代码实现的：'
- en: '[PRE81]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: First, we read the `server` and `port` global parameters.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们读取`server`和`port`全局参数。
- en: '[PRE82]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Then, we get the values of the two local command line parameters. If either
    one of them has an empty value, the command returns without sending the request
    to the server.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取两个本地命令行参数的值。如果其中任何一个参数值为空，则命令将返回而不向服务器发送请求。
- en: '[PRE83]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The previous code is very important, as it checks whether the given dataset
    elements are valid `float64` values, and then it creates a string of the `/value1/value2/.
    . ./valueN/` form. This `string` value is attached to the end of the URL that
    holds the server request.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码非常重要，因为它检查给定数据集元素是否为有效的`float64`值，然后创建一个形如`/value1/value2/.../valueN/`的字符串。这个字符串值附加到包含服务器请求的URL的末尾。
- en: '[PRE84]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here, we create the server request in two steps for readability.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为了可读性，分两步创建服务器请求。
- en: '[PRE85]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Then, we send the request to the server.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将请求发送到服务器。
- en: '[PRE86]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Checking the HTTP status code is always a good practice. Therefore, if everything
    is OK with the server response, we continue by reading the data. Otherwise, we
    print the status code, and we exit.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 检查HTTP状态码总是一个好的做法。因此，如果服务器响应一切正常，我们继续读取数据。否则，我们打印状态码，并退出。
- en: '[PRE87]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: After reading the body of the server response, which is stored in a byte slice,
    we print it onscreen as a string using `string(responseData)`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取存储在字节切片中的服务器响应体之后，我们使用`string(responseData)`将其作为字符串打印在屏幕上。
- en: 'The client application generates the following kind of output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序生成以下类型的输出：
- en: '[PRE88]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is the output of the `list` command.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`list`命令的输出。
- en: '[PRE89]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The output of the `status` command informs us about the number of entries in
    the application.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`status`命令的输出告诉我们应用程序中的条目数量。'
- en: '[PRE90]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The previous output shows the use of the `search` command when successfully
    finding a dataset.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示了在成功找到数据集时使用`search`命令的情况。
- en: '[PRE91]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The previous output shows the use of the `search` command when not finding a
    dataset.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示了在找不到数据集时使用`search`命令的情况。
- en: '[PRE92]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This is the output of the `delete` command.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`delete`命令的输出。
- en: '[PRE93]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This is the operation of the `insert` command. If you try to insert the same
    dataset name more than once, the server output is going to be `Status code: 304`.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`insert`命令的操作。如果你尝试多次插入相同的数据集名称，服务器输出将是`状态码：304`。
- en: The next section explains how to time out HTTP connections.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分解释了如何超时HTTP连接。
- en: Timing out HTTP connections
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时HTTP连接
- en: This section presents techniques for timing out HTTP connections that take too
    long to finish and work either on the server or the client side.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了处理耗时过长的HTTP连接超时的技术，这些技术可以在服务器端或客户端工作。
- en: Using SetDeadline()
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SetDeadline()
- en: The `SetDeadline()` function is used by `net` to set the read and write deadlines
    of network connections. Due to the way that `SetDeadline()` works, you need to
    call `SetDeadline()` before any read or write operation. Keep in mind that Go
    uses deadlines to implement timeouts, so you do not need to reset the timeout
    every time your application receives or sends any data.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetDeadline()`函数由`net`用于设置网络连接的读写截止时间。由于`SetDeadline()`的工作方式，你需要在任何读写操作之前调用`SetDeadline()`。请注意，Go使用截止时间来实现超时，因此你不需要在每次应用程序接收或发送数据时重置超时。'
- en: 'The use of `SetDeadline()` is illustrated in `withDeadline.go` and, more specifically,
    in the implementation of the `Timeout()` function:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetDeadline()`的使用在`withDeadline.go`中得到了说明，特别是在`Timeout()`函数的实现中：'
- en: '[PRE94]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `timeout` global variable defines the timeout period used in the `SetDeadline()`
    call. The previous function is used in the following code inside `main()`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeout`全局变量定义了在`SetDeadline()`调用中使用的超时时间。前面的函数在`main()`中的以下代码中使用：'
- en: '[PRE95]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: So, `http.Transport` uses `Timeout()` in the `Dial` field, and `http.Client`
    uses `http.Transport`. When you call the `client.Get()` method with the desired
    URL, which is not shown here, `Timeout` is automatically used because of the `http.Transport`
    definition. So, if the `Timeout` function returns before the server response is
    received, we have a timeout.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`http.Transport`在`Dial`字段中使用`Timeout()`，而`http.Client`使用`http.Transport`。当你调用`client.Get()`方法并传入所需的URL（此处未显示）时，由于`http.Transport`的定义，`Timeout`会被自动使用。所以，如果`Timeout`函数在收到服务器响应之前返回，我们就遇到了超时。
- en: 'Using `withDeadline.go` produces the following kind of output:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`withdeadline.go`会产生以下类型的输出：
- en: '[PRE96]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The call was successful and took less than 1 second to finish, so there was
    no timeout.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 调用成功，并在不到1秒内完成，所以没有超时。
- en: '[PRE97]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This time, we have a timeout, as the server took too long to answer.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们遇到了超时，因为服务器响应时间过长。
- en: Next, we show how to time out a connection using the `context` package.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示如何使用`context`包超时一个连接。
- en: Setting the timeout period on the client side
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在客户端设置超时时间
- en: This section presents a technique for timing out network connections that take
    too long to finish **on the client side**. So if the client does not receive a
    response from the server in the desired time, it closes the connection. The `timeoutClient.go`
    source file illustrates the technique.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一种在客户端超时耗时过长的网络连接的技术。因此，如果客户端在期望的时间内没有从服务器收到响应，它将关闭连接。`timeoutClient.go`源文件展示了这一技术。
- en: '[PRE98]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In the previous code, we define a global variable named `delay` that holds the
    delay value.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个名为`delay`的全局变量，用于存储延迟值。
- en: '[PRE99]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The URL is read directly because it is already a string value, whereas the delay
    period is converted into a numeric value using `strconv.Atoi()`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于URL已经是字符串值，因此直接读取，而延迟期则使用`strconv.Atoi()`转换为数值。
- en: 'The rest of the `main()` implementation is the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数的其余实现如下：'
- en: '[PRE100]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: First, we initialize the `ctx` context, and then we associate that context with
    the HTTP request using `http.NewRequestWithContext()`. If the timeout period is
    exceeded, the `context.Context` created with `WithTimeout()` is going to expire.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化`ctx`上下文，然后使用`http.NewRequestWithContext()`将此上下文与HTTP请求关联。如果超时时间超过，使用`WithTimeout()`创建的`context.Context`将会过期。
- en: 'Working with `timeoutClient.go` and having a timeout situation generates the
    following kind of output:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 与`timeoutClient.go`一起工作并产生超时情况时，会生成以下类型的输出：
- en: '[PRE101]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The next subsection shows how to time out an HTTP request on the server side.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子部分展示了如何在服务器端超时一个HTTP请求。
- en: Setting the timeout period on the server side
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器端设置超时时间
- en: This section presents a technique for timing out network connections that take
    too long to finish **on the server side**. This is much more important than the
    client side, as a server with too many open connections might not be able to process
    additional requests unless some of the already open connections close. This usually
    happens for two reasons. The first reason is software bugs, and the second reason
    is when a server experiences a **Denial of Service** (**DoS**) attack!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一种超时网络连接的技术，这些连接在服务器端完成时间过长。这比客户端更重要，因为拥有太多打开连接的服务器可能无法处理额外的请求，除非一些已经打开的连接关闭。这通常有两个原因。第一个原因是软件错误，第二个原因是当服务器遭受
    **拒绝服务**（**DoS**）攻击时！
- en: 'The `main()` function in `timeoutServer.go` shows the technique:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeoutServer.go` 中的 `main()` 函数展示了这项技术：'
- en: '[PRE102]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This is where the timeout periods are defined. Note that you can define timeout
    periods for both reading and writing processes. The value of the `ReadTimeout`
    field specifies the maximum duration allowed to read the entire client request,
    including the body, whereas the value of the `WriteTimeout` field specifies the
    maximum time duration before timing out the sending of the client response.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是定义超时时间的地方。请注意，您可以定义读取和写入过程的超时时间。`ReadTimeout` 字段的值指定了读取整个客户端请求（包括主体）允许的最大持续时间，而
    `WriteTimeout` 字段的值指定了在超时发送客户端响应之前允许的最大时间。
- en: '[PRE103]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Apart from the parameters in the definition of `http.Server`, the rest of the
    code is as usual: it contains the handler functions and calls `ListenAndServe()`
    to start the HTTP server.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `http.Server` 定义中的参数外，其余代码与往常一样：它包含处理函数并调用 `ListenAndServe()` 来启动 HTTP 服务器。
- en: Working with `timeoutServer.go` generates no output. However, if a client connects
    to it without sending any requests, the client connection will end after 3 seconds.
    The same will happen if it takes the client more than 3 seconds to receive the
    server response.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `timeoutServer.go` 不会生成任何输出。然而，如果客户端连接到它而没有发送任何请求，客户端连接将在 3 秒后结束。如果客户端接收服务器响应的时间超过
    3 秒，也会发生同样的事情。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to work with HTTP and how to create Docker images
    from Go code, as well as how to develop HTTP clients and servers. We have also
    converted the statistics application into a web application and programmed a command
    line client for it. Additionally, we learned how to time out HTTP connections.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 HTTP，如何从 Go 代码创建 Docker 镜像，以及如何开发 HTTP 客户端和服务器。我们还把统计应用程序转换成了
    Web 应用程序，并为它编写了一个命令行客户端。此外，我们还学习了如何超时 HTTP 连接。
- en: We are now ready to begin developing powerful and concurrent HTTP applications
    —however, we are not done yet with HTTP. *Chapter 11*, *Working with REST APIs*,
    is going to connect the dots and show how to develop powerful RESTful servers
    and clients.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好开始开发强大且并发的 HTTP 应用程序——然而，我们还没有完成 HTTP 的学习。*第 11 章*，*与 REST API 一起工作*，将连接这些点，并展示如何开发强大的
    RESTful 服务器和客户端。
- en: But first, we need to learn about working with TCP/IP, TCP, UDP, and WebSocket,
    which are the subjects of the next chapter.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要了解如何使用 TCP/IP、TCP、UDP 和 WebSocket，这些是下一章的主题。
- en: Exercises
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Modify `wwwClient.go` to save the HTML output to an external file.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `wwwClient.go` 以将 HTML 输出保存到外部文件。
- en: Use `sync.Mutex` in order to avoid race conditions in the statistics application.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在统计应用程序中使用 `sync.Mutex` 以避免竞争条件。
- en: Implement a simple version of `ab(1)` using goroutines and channels. `ab(1)`
    is an Apache HTTP server benchmarking tool.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 goroutines 和 channels 实现 `ab(1)` 的简单版本。`ab(1)` 是 Apache HTTP 服务器基准测试工具。
- en: Additional resources
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'Caddy server: [https://caddyserver.com/](https://caddyserver.com/)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Caddy 服务器：[https://caddyserver.com/](https://caddyserver.com/)
- en: 'Nginx server: [https://nginx.org/en/](https://nginx.org/en/)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nginx 服务器：[https://nginx.org/en/](https://nginx.org/en/)
- en: 'The `net/http` package: [https://pkg.go.dev/net/http](https://pkg.go.dev/net/http)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http` 包：[https://pkg.go.dev/net/http](https://pkg.go.dev/net/http)'
- en: 'Official Docker Go images: [https://hub.docker.com/_/golang/](https://hub.docker.com/_/golang/
    )'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 Docker Go 镜像：[https://hub.docker.com/_/golang/](https://hub.docker.com/_/golang/
    )
- en: Join our community on Discord
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
