- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Working with TCP/IP and WebSocket
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 TCP/IP 和 WebSocket 一起工作
- en: TCP/IP is the foundation of the Internet and, therefore, being able to create
    TCP/IP servers and clients is essential when developing network services. This
    chapter teaches you how to work with the lower-level protocols of TCP/IP, which
    are TCP and UDP, with the help of the `net` package, so that you can develop TCP/IP
    servers and clients and have more control over their functionality. The Go code
    of the TCP and UDP utilities included in this chapter allows us to create our
    own advanced TCP/IP services as the core principles and logic of TCP/IP remain
    the same.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 是互联网的基础，因此，在开发网络服务时能够创建 TCP/IP 服务器和客户端是至关重要的。本章教你如何使用 `net` 包来处理 TCP/IP
    的底层协议，即 TCP 和 UDP，这样你就可以开发 TCP/IP 服务器和客户端，并对其功能有更多控制。本章包含的 TCP 和 UDP 工具的 Go 代码使我们能够创建自己的高级
    TCP/IP 服务，因为 TCP/IP 的核心原则和逻辑保持不变。
- en: Additionally, this chapter illustrates the development of servers and clients
    for the WebSocket protocol, which is based on HTTP, and shows how to interact
    with RabbitMQ, which is an open-source *message broker*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章还介绍了 WebSocket 协议的服务器和客户端的开发，该协议基于 HTTP，并展示了如何与 RabbitMQ 交互，RabbitMQ 是一个开源的
    *消息代理*。
- en: The WebSocket protocol provides full-duplex communication channels over a single
    TCP connection. On the other hand, message brokers such as RabbitMQ and Apache
    Kafka are famous for their speed, which is the main reason for including them
    in a workflow that processes lots of data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 协议在单个 TCP 连接上提供全双工通信通道。另一方面，像 RabbitMQ 和 Apache Kafka 这样的消息代理因其速度而闻名，这也是它们被包含在处理大量数据的工作流程中的主要原因。
- en: 'In more detail, this chapter covers:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，本章涵盖了：
- en: TCP/IP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP/IP
- en: The `net` package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net` 包'
- en: Developing a TCP client
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 TCP 客户端
- en: Developing a TCP server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 TCP 服务器
- en: Developing a UDP client
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 UDP 客户端
- en: Developing a UDP server
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 UDP 服务器
- en: Developing concurrent TCP servers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发并发 TCP 服务器
- en: Creating a WebSocket server
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 WebSocket 服务器
- en: Creating a WebSocket client
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 WebSocket 客户端
- en: Working with RabbitMQ
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 RabbitMQ 一起工作
- en: TCP/IP
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP
- en: 'TCP/IP is a family of protocols that help the Internet operate. Its name comes
    from its two most well-known protocols: TCP and IP.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 是一组帮助互联网运行的协议。它的名字来源于其最著名的两个协议：TCP 和 IP。
- en: TCP stands for Transmission Control Protocol. TCP software transmits data between
    machines using segments, which are also called TCP packets. The main characteristic
    of TCP is that it is a **reliable protocol**, which means that it makes sure that
    every packet is delivered without requiring any extra code from the programmer.
    If there is no proof of packet delivery, TCP resends that packet. Among other
    things, TCP packets can be used to establish connections, transfer data, send
    acknowledgments, and close connections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 代表传输控制协议。TCP 软件使用段（也称为 TCP 数据包）在机器之间传输数据。TCP 的主要特点是它是一个 **可靠的协议**，这意味着它确保每个数据包都成功交付，而不需要程序员编写任何额外的代码。如果没有数据包交付的证明，TCP
    会重新发送该数据包。除此之外，TCP 数据包可以用来建立连接、传输数据、发送确认和关闭连接。
- en: When a TCP connection is established between two machines, a full-duplex virtual
    circuit, similar to a telephone call, is created between those two machines. The
    two machines constantly communicate to make sure that data is sent and received
    correctly. If the connection fails for some reason, the two machines try to find
    the problem and report it to the relevant application. The TCP header of each
    packet includes the source port and destination port fields. These two fields,
    plus the source and destination IP addresses, are combined to uniquely identify
    every single TCP connection. All these details are handled by TCP/IP, as long
    as you provide the required details without any extra effort.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当两台机器之间建立 TCP 连接时，会在这两台机器之间创建一个全双工虚拟电路，类似于电话通话。这两台机器持续通信以确保数据正确发送和接收。如果连接因某种原因失败，两台机器会尝试找出问题并向相关应用程序报告。每个数据包的
    TCP 报头包括源端口和目的端口字段。这两个字段，加上源和目的 IP 地址，组合起来可以唯一地标识每个 TCP 连接。所有这些细节都由 TCP/IP 处理，只要你提供所需细节，无需额外努力。
- en: When creating TCP/IP server processes, remember that port numbers 0-1024 have
    restricted access and can only be used by the root user, which means that you
    need administrative privileges to use any port in that range. Running a process
    with root privileges is a security risk and must be avoided.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建TCP/IP服务器进程时，请记住端口号0-1024有受限访问权限，只能由root用户使用，这意味着您需要管理员权限才能使用该范围内的任何端口。以root权限运行进程是一个安全风险，必须避免。
- en: IP stands for Internet Protocol. The main characteristic of IP is that it is
    not a reliable protocol by nature. IP encapsulates the data that travels over
    a TCP/IP network because it is responsible for delivering packets from the source
    host to the destination host according to the IP addresses. IP must find an addressing
    method for sending a packet to its destination effectively. Although there are
    dedicated devices, called routers, that perform IP routing, every TCP/IP device
    has to perform some basic routing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: IP代表互联网协议。IP的主要特征是它本质上不是一个可靠的协议。IP封装了在TCP/IP网络上传输的数据，因为它负责根据IP地址将数据包从源主机传输到目标主机。IP必须找到一种寻址方法，以便有效地将数据包发送到其目的地。尽管有专门的设备，称为路由器，执行IP路由，但每个TCP/IP设备都必须执行一些基本路由。
- en: The first version of the IP protocol is now called IPv4 to differentiate it
    from the latest version of the IP protocol, which is called IPv6\. The main problem
    with IPv4 is that it is about to run out of available IP addresses, which is the
    main reason for creating the IPv6 protocol. This happened because an IPv4 address
    is represented using 32 bits only, which allows a total number of 2^(32) (4,294,967,296)
    different IP addresses. On the other hand, IPv6 uses 128 bits to define each one
    of its addresses. The format of an IPv4 address is `10.20.32.245` (four parts
    with values from 0 to 255 separated by dots), while the format of an IPv6 address
    is `3fce:1706:4523:3:150:f8ff:fe21:56cf` (eight parts separated by colons).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: IP协议的第一个版本现在被称为IPv4，以区分最新的IP协议版本，称为IPv6。IPv4的主要问题是它即将耗尽可用的IP地址，这是创建IPv6协议的主要原因。这是因为IPv4地址仅使用32位表示，允许有2^(32)（4,294,967,296）个不同的IP地址。另一方面，IPv6使用128位来定义其地址中的每一个。IPv4地址的格式是`10.20.32.245`（由点分隔的四个部分，值从0到255），而IPv6地址的格式是`3fce:1706:4523:3:150:f8ff:fe21:56cf`（由冒号分隔的八个部分）。
- en: UDP (User Datagram Protocol) is based on IP, which means that it is also unreliable.
    UDP is simpler than TCP, mainly because UDP is not reliable by design. As a result,
    UDP messages can be lost, duplicated, or arrive out of order. Furthermore, packets
    can arrive faster than the recipient can process them. So, UDP is used when speed
    is more important than reliability.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: UDP（用户数据报协议）基于IP，这意味着它也是不可靠的。UDP比TCP简单，主要是因为UDP设计上不可靠。因此，UDP消息可能会丢失、重复或顺序错误地到达。此外，数据包可能会比接收者处理它们的速度更快地到达。因此，当速度比可靠性更重要时，使用UDP。
- en: This chapter implements both TCP and UDP software—TCP and UDP services are the
    basis of the Internet. But first, let us talk about the handy `nc(1)` utility.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章实现了TCP和UDP软件——TCP和UDP服务是互联网的基础。但首先，让我们谈谈方便的`nc(1)`实用程序。
- en: The nc(1) command line utility
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`nc(1)` 命令行实用程序'
- en: 'The `nc(1)` utility, which is also called `netcat(1)`, is very convenient when
    you want to test TCP/IP servers and clients: `nc(1)` is a utility for everything
    that involves TCP and UDP as well as IPv4 and IPv6, including but not limited
    to opening TCP connections, sending and receiving UDP messages, and acting as
    a TCP server.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要测试TCP/IP服务器和客户端时，`nc(1)`实用程序，也称为`netcat(1)`，非常方便：`nc(1)`是一个涉及TCP和UDP以及IPv4和IPv6的实用程序，包括但不限于打开TCP连接、发送和接收UDP消息以及充当TCP服务器。
- en: 'You can use `nc(1)` as a client for a TCP service that runs on a machine with
    the `10.10.1.123` IP address and listens to port number `1234`, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`nc(1)`作为运行在具有`10.10.1.123` IP地址并监听端口号`1234`的机器上的TCP服务的客户端，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `-l` option tells `netcat(1)` to act as a server, which means that when
    the `-l` option is given, `netcat(1)` starts listening for incoming connections
    at the given port number. By default, `nc(1)` uses the TCP protocol. However,
    if you execute `nc(1)` with the `-u` flag, it uses the UDP protocol, either as
    a client or as a server. Finally, the `-v` and `-vv` options tell `netcat(1)`
    to generate verbose output, which can be practical when you want to troubleshoot
    network connections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`-l` 选项告诉 `netcat(1)` 作为服务器运行，这意味着当提供 `-l` 选项时，`netcat(1)` 将在指定的端口号上监听传入的连接。默认情况下，`nc(1)`
    使用 TCP 协议。但是，如果您使用 `-u` 标志执行 `nc(1)`，它将使用 UDP 协议，无论是作为客户端还是服务器。最后，`-v` 和 `-vv`
    选项告诉 `netcat(1)` 生成详细输出，这在您想要调试网络连接时可能很有用。'
- en: The net package
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`net` 包'
- en: The `net` package of the Go Standard Library is all about TCP/IP, UDP, domain
    name resolution, and UNIX domain sockets. The `net.Dial()` function is used to
    connect to a network as a client, whereas the `net.Listen()` function is used
    to tell a Go program to accept incoming network connections and thus act as a
    server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库中的 `net` 包主要涉及 TCP/IP、UDP、域名解析和 UNIX 域套接字。`net.Dial()` 函数用于作为客户端连接到网络，而
    `net.Listen()` 函数用于指示 Go 程序接受传入的网络连接，从而充当服务器。
- en: The return value for both `net.Dial()` and `net.Listen()` is of the `net.Conn`
    data type, which implements the `io.Reader` and `io.Writer` interfaces—this means
    that you can both read and write to a `net.Conn` connection using code related
    to file I/O. The first parameter of both `net.Dial()` and `net.Listen()` is the
    network type, but this is where their similarities end.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Dial()` 和 `net.Listen()` 的返回值都是 `net.Conn` 数据类型，它实现了 `io.Reader` 和 `io.Writer`
    接口——这意味着您可以使用与文件 I/O 相关的代码来读取和写入 `net.Conn` 连接。`net.Dial()` 和 `net.Listen()` 的第一个参数是网络类型，但这是它们相似之处结束的地方。'
- en: The `net.Dial()` function is used to connect to a remote server. The first parameter
    of the `net.Dial()` function defines the network protocol that is going to be
    used, while the second parameter defines the server address, which must also include
    the port number. Valid values for the first parameter are `tcp`, `tcp4` (IPv4-only),
    `tcp6` (IPv6-only), `udp`, `udp4` (IPv4-only), `udp6` (IPv6-only), `ip`, `ip4`
    (IPv4-only), `ip6` (IPv6-only), `unix` (UNIX sockets), `unixgram`, and `unixpacket`.
    On the other hand, valid values for `net.Listen()` are `tcp`, `tcp4`, `tcp6`,
    `unix`, and `unixpacket`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Dial()` 函数用于连接到远程服务器。`net.Dial()` 函数的第一个参数定义了将要使用的网络协议，而第二个参数定义了服务器地址，其中必须包括端口号。第一个参数的有效值包括
    `tcp`、`tcp4`（仅 IPv4）、`tcp6`（仅 IPv6）、`udp`、`udp4`（仅 IPv4）、`udp6`（仅 IPv6）、`ip`、`ip4`（仅
    IPv4）、`ip6`（仅 IPv6）、`unix`（UNIX 套接字）、`unixgram` 和 `unixpacket`。另一方面，`net.Listen()`
    的有效值包括 `tcp`、`tcp4`、`tcp6`、`unix` 和 `unixpacket`。'
- en: Execute the `go doc net.Listen` and `go doc net.Dial` commands for detailed
    information regarding these two functions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `go doc net.Listen` 和 `go doc net.Dial` 命令以获取这两个函数的详细信息。
- en: Developing a TCP client
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 TCP 客户端
- en: This section is about developing TCP clients. The two subsections that follow
    present two equivalent ways of developing TCP clients.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是关于开发 TCP 客户端。接下来的两个小节展示了两种开发 TCP 客户端等效的方法。
- en: Developing a TCP client with net.Dial()
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `net.Dial()` 开发 TCP 客户端
- en: 'First, we are going to present the most widely used way, which is implemented
    in `tcpC.go`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍最广泛使用的方法，它在 `tcpC.go` 中实现：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `import` block contains packages such as `bufio` and `fmt` that also work
    with file I/O operations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 块包含 `bufio` 和 `fmt` 等也用于文件 I/O 操作的包。'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we read the details of the TCP server we want to connect to.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们读取我们想要连接的 TCP 服务器的详细信息。
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the connection details, we call `net.Dial()`—its first parameter is the
    protocol we want to use, which in this case is `tcp`, and its second parameter
    contains the connection details. A successful `net.Dial()` call returns an open
    connection (a `net.Conn` interface), which is a generic stream-oriented network
    connection.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接详细信息的基础上，我们调用 `net.Dial()`——它的第一个参数是我们想要使用的协议，在这个例子中是 `tcp`，而第二个参数包含连接详细信息。成功的
    `net.Dial()` 调用返回一个打开的连接（一个 `net.Conn` 接口），这是一个通用的面向流的网络连接。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last part of the TCP client keeps reading user input until the word `STOP`
    is given as input—in this case, the client waits for the server response before
    terminating after `STOP` because this is how the `for` loop is constructed. This
    mainly happens because the server might have a useful answer for us, and we do
    not want to miss that. All given user input is sent (written) to the open TCP
    connection using `fmt.Fprintf()`, whereas `bufio.NewReader()` is used to read
    data from the TCP connection, just like you would do with a regular file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: TCP客户端的最后部分会持续读取用户输入，直到输入`STOP`为止——在这种情况下，客户端在`STOP`后等待服务器响应才终止，因为这是`for`循环构建的方式。这主要是因为服务器可能对我们有一个有用的答案，我们不希望错过。所有用户输入都通过`fmt.Fprintf()`发送（写入）到打开的TCP连接，而`bufio.NewReader()`用于从TCP连接中读取数据，就像处理常规文件一样。
- en: Bear in mind that the reason for not checking the `error` value returned by
    `reader.ReadString('\n')` is simplicity. We should never ignore errors.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，不检查`reader.ReadString('\n')`返回的`error`值的原因是简单性。我们永远不应该忽略错误。
- en: 'Using `tcpC.go` to connect to a TCP server, which in this case is implemented
    with `nc(1)` as `nc -l 1234`, produces the next kind of output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tcpC.go`连接到TCP服务器，在这个例子中，服务器是用`nc(1)`实现的，命令为`nc -l 1234`，会产生以下类型的输出：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lines beginning with `>>` denote user input, whereas lines beginning with `->`
    signify server messages. After sending `STOP`, we wait for the server response
    and then the client ends the TCP connection. The previous code demonstrates how
    to create a proper TCP client in Go with some extra logic and functionality in
    it (the `STOP` keyword).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以`>>`开头的行表示用户输入，而以`->`开头的行表示服务器消息。在发送`STOP`后，我们等待服务器响应，然后客户端结束TCP连接。前面的代码演示了如何在Go中创建一个带有额外逻辑和功能的适当TCP客户端（`STOP`关键字）。
- en: The next subsection shows a different way of creating a TCP client.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节将展示创建TCP客户端的另一种方法。
- en: Developing a TCP client that uses net.DialTCP()
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`net.DialTCP()`开发TCP客户端
- en: This subsection presents an alternative way to develop a TCP client. The difference
    lies in the Go functions that are being used to establish the TCP connection,
    which are `net.DialTCP()` and `net.ResolveTCPAddr()`, and not in the functionality
    of the client.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节介绍了一种开发TCP客户端的替代方法。区别在于用于建立TCP连接的Go函数，即`net.DialTCP()`和`net.ResolveTCPAddr()`，而不是客户端的功能。
- en: 'The code of `otherTCPclient.go` is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`otherTCPclient.go`的代码如下：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although we are working with TCP/IP connections, we need packages such as `bufio`
    because UNIX treats network connections as files, so we are basically working
    with I/O operations over networks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们正在使用TCP/IP连接，但我们仍需要像`bufio`这样的包，因为UNIX将网络连接视为文件，所以我们基本上是在网络上进行I/O操作。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We need to read the details of the TCP server we want to connect to, including
    the desired port number. The utility cannot operate with default parameters when
    working with TCP/IP unless we are developing a very specialized TCP client.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要读取我们想要连接的TCP服务器的详细信息，包括所需的端口号。在处理TCP/IP时，除非我们正在开发一个非常专业的TCP客户端，否则实用程序不能使用默认参数操作。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `net.ResolveTCPAddr()` function is specific to TCP connections, hence its
    name, and resolves the given address to a `*net.TCPAddr` value, which is a structure
    that represents the address of a TCP endpoint—in this case, the endpoint is the
    TCP server we are going to connect to.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.ResolveTCPAddr()`函数是针对TCP连接的，因此得名，它将给定的地址解析为`*net.TCPAddr`值，这是一个表示TCP端点地址的结构——在这种情况下，端点是我们要连接的TCP服务器。'
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the TCP endpoint at hand, we call `net.DialTCP()` to connect to the server.
    Apart from the use of `net.ResolveTCPAddr()` and `net.DialTCP()`, the rest of
    the code that has to do with the TCP client and TCP server interaction is exactly
    the same.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在手头有TCP端点的情况下，我们调用`net.DialTCP()`来连接到服务器。除了使用`net.ResolveTCPAddr()`和`net.DialTCP()`之外，与TCP客户端和TCP服务器交互相关的其余代码完全相同。
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Lastly, an infinite `for` loop is used to interact with the TCP server. The
    TCP client reads user data, which is sent to the server. After that, it reads
    data from the TCP server. Once again, the `STOP` keyword terminates the TCP connection
    on the client side using the `Close()` method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用无限`for`循环与TCP服务器交互。TCP客户端读取用户数据，并将其发送到服务器。然后，它从TCP服务器读取数据。再次使用`STOP`关键字在客户端侧使用`Close()`方法终止TCP连接。
- en: 'Working with `otherTCPclient.go` and interacting with a TCP server process
    produces the next kind of output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`otherTCPclient.go`与TCP服务器进程交互会产生以下类型的输出：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The interaction is the same as with `tcpC.go`—we have just learned a different
    way of developing TCP clients. If you want my opinion, I prefer the implementation
    found in `tcpC.go` because it uses more generic functions. However, this is just
    personal taste.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 交互与`tcpC.go`相同——我们只是学会了开发TCP客户端的另一种方式。如果我的意见能被采纳，我更喜欢`tcpC.go`中的实现，因为它使用了更通用的函数。然而，这仅仅是个人喜好。
- en: The next section shows how to program TCP servers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将展示如何编程TCP服务器。
- en: Developing a TCP server
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发TCP服务器
- en: This section presents two ways of developing TCP servers that can interact with
    TCP clients, just as we did with the TCP client.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了两种开发TCP服务器的方法，这些服务器可以与TCP客户端交互，就像我们与TCP客户端交互一样。
- en: Developing a TCP server with net.Listen()
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`net.Listen()`开发TCP服务器
- en: 'The TCP server presented in this section, which uses `net.Listen()`, returns
    the current date and time to the client in a single network packet. In practice,
    this means that after accepting a client connection, the server gets the time
    and date from the operating system and sends that data back to the client. The
    `net.Listen()` function listens for connections, whereas the `net.Accept()` method
    waits for the next connection and returns a generic `net.Conn` variable with the
    client information. The code of `tcpS.go` is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中介绍的TCP服务器使用`net.Listen()`，将当前日期和时间作为一个网络数据包发送给客户端。在实践中，这意味着在接收客户端连接后，服务器从操作系统获取时间和日期，并将这些数据发送回客户端。`net.Listen()`函数监听连接，而`net.Accept()`方法等待下一个连接，并返回一个包含客户端信息的通用`net.Conn`变量。`tcpS.go`的代码如下：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The TCP server should know about the port number it is going to use—this is
    given as a command line argument.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TCP服务器应该知道它将要使用的端口号——这作为命令行参数给出。
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `net.Listen()` function listens for connections and is what makes that particular
    program a server process. If the second parameter of `net.Listen()` contains a
    port number without an IP address or a hostname, `net.Listen()` listens to all
    available IP addresses of the local system, which is the case here.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Listen()`函数监听连接，这使得该特定程序成为一个服务器进程。如果`net.Listen()`的第二个参数包含一个没有IP地址或主机名的端口号，`net.Listen()`将监听本地系统上所有可用的IP地址，这里就是这种情况。'
- en: This is a personal preference; although it is considered a bad practice to have
    variable names such as `PORT` and `SERVER`, this is my own way of signifying important
    or global variables.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个个人偏好；尽管被认为是不良实践，使用如`PORT`和`SERVER`这样的变量名，但这是我自己表示重要或全局变量的方式。
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We call `Accept()` and wait for a client connection—`Accept()` blocks until
    a new connection comes. There is something unusual with this particular TCP server:
    it can only serve the first TCP client that is going to connect to it because
    the `Accept()` call is outside of the `for` loop and therefore is **called only
    once**. Each individual client should be served by a different `Accept()` call,
    which is not happening here. Correcting that is left as an exercise for the reader.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`Accept()`并等待客户端连接——`Accept()`会阻塞，直到新的连接到来。这个特定的TCP服务器有一些不寻常的地方：它只能服务即将连接到它的第一个TCP客户端，因为`Accept()`调用在`for`循环之外，因此**只调用一次**。每个单独的客户端都应该由不同的`Accept()`调用服务，但这里并没有这样做。纠正这一点留给读者作为练习。
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This endless `for` loop keeps interacting with the same TCP client until the
    word `STOP` is sent from the client. As it happened with the TCP clients, `bufio.NewReader()`
    is used to read data from the network connection, whereas `Write()` is used to
    send data to the TCP client.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个无休止的`for`循环会一直与同一个TCP客户端交互，直到客户端发送`STOP`这个词。就像TCP客户端一样，`bufio.NewReader()`用于从网络连接中读取数据，而`Write()`用于向TCP客户端发送数据。
- en: 'Running `tcpS.go` and interacting with a TCP client produces the next kind
    of output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`tcpS.go`并与TCP客户端交互会产生以下类型的输出：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The server connection ended automatically with the client connection because
    the `for` loop concluded when `bufio.NewReader(c).ReadString(''\n'')` had nothing
    more to read. The client was `nc(1)`, which produced the next output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器连接因客户端连接自动结束，因为当`bufio.NewReader(c).ReadString('\n')`没有更多内容可读时，`for`循环结束了。客户端是`nc(1)`，它产生了以下输出：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have ended the connection using the `STOP` keyword.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`STOP`关键字结束了连接。
- en: So, we now know how to develop a TCP server in Go. As with the TCP client, there
    is an alternative way to develop a TCP server, which is presented in the next
    subsection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道如何在Go中开发TCP服务器。与TCP客户端一样，还有另一种开发TCP服务器的方法，将在下一小节中介绍。
- en: Developing a TCP server that uses net.ListenTCP()
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`net.ListenTCP()`开发TCP服务器
- en: This time, this alternative version of the TCP server implements the echo service.
    Put simply, the TCP server sends back to the client the data that was received
    by the client.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，这个TCP服务器的替代版本实现了回显服务。简单来说，TCP服务器将接收到的数据发送回客户端。
- en: 'The code of `otherTCPserver.go` is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`otherTCPserver.go`的代码如下：'
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous code gets the TCP port number value as a command line argument,
    which is used in `net.ResolveTCPAddr()`—this is required for defining the TCP
    port number the TCP server is going to listen to.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码通过命令行参数获取TCP端口号值，该值用于`net.ResolveTCPAddr()`——这是定义TCP服务器将要监听的端口号所必需的。
- en: That function only works with TCP, hence its name.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 那个函数只与TCP一起工作，因此得名。
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Similarly, `net.ListenTCP()` only works with TCP and is what makes that program
    a TCP server ready to accept incoming connections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`net.ListenTCP()`只与TCP一起工作，这使得该程序成为一个准备接受传入连接的TCP服务器。
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As before, due to the place where `Accept()` is called, this particular implementation
    can work with a single client only. This is used for reasons of simplicity. The
    concurrent TCP server that is developed later on in this chapter puts the `Accept()`
    call inside an endless `for` loop.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，由于`Accept()`被调用的位置，这个特定的实现只能与单个客户端一起工作。这是出于简单性的考虑。在本章后面开发的并发TCP服务器将`Accept()`调用放在了一个无休止的`for`循环中。
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You need to use `strings.TrimSpace()` in order to remove any space characters
    from your input and compare the result with `STOP`, which has a special meaning
    in this implementation. Once the `STOP` keyword is received from the client, the
    server closes the connection using the `Close()` method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用`strings.TrimSpace()`来删除输入中的任何空格字符，并将结果与具有特殊意义的`STOP`关键字进行比较。一旦从客户端接收到`STOP`关键字，服务器将使用`Close()`方法关闭连接。
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All previous code is for interacting with the TCP client until the client decides
    to close the connection. Running `otherTCPserver.go` and interacting with a TCP
    client produces the following kind of output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所有之前的代码都是与TCP客户端交互，直到客户端决定关闭连接。运行`otherTCPserver.go`并与TCP客户端交互会产生以下类型的输出：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first line that begins with `>` is the client message, whereas the second
    line is the server output when getting the `STOP` message from the client. Therefore,
    the TCP server processes client requests as programmed and exits when it gets
    the `STOP` message, which is the desired behavior.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以`>`开头的第一行是客户端消息，而第二行是服务器在接收到客户端的`STOP`消息时的输出。因此，TCP服务器按照程序处理客户端请求，并在接收到`STOP`消息时退出，这是期望的行为。
- en: The next section is about developing UDP clients.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是关于开发UDP客户端。
- en: Developing a UDP client
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发UDP客户端
- en: 'This section demonstrates how to develop a UDP client that can interact with
    UDP services. The code of `udpC.go` is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分演示了如何开发一个可以与UDP服务交互的UDP客户端。`udpC.go`的代码如下：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is how we get the UDP server details from the user.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从用户获取UDP服务器详情的方式。
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The previous two lines declare that we are using UDP and that we want to connect
    to the UDP server that is specified by the return value of `net.ResolveUDPAddr()`.
    The actual connection is initiated using `net.DialUDP()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行声明我们正在使用UDP，并且我们想要连接到由`net.ResolveUDPAddr()`返回值指定的UDP服务器。实际的连接是通过`net.DialUDP()`发起的。
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This part of the program finds the details of the UDP server by calling the
    `RemoteAddr()` method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分程序通过调用`RemoteAddr()`方法找到UDP服务器的详细信息。
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Data is read from the user using `bufio.NewReader(os.Stdin)` and is written
    to the UDP server using `Write()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bufio.NewReader(os.Stdin)`从用户读取数据，并使用`Write()`将数据写入UDP服务器。
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the input read from the user is the `STOP` keyword, then the connection is
    terminated.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从用户读取的输入是`STOP`关键字，那么连接将被终止。
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Data is read from the UDP connection using the `ReadFromUDP()` method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ReadFromUDP()`方法从UDP连接中读取数据。
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `for` loop is going to keep going forever until the `STOP` keyword is received
    as input or the program is terminated in some other way.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环将一直进行，直到接收到作为输入的`STOP`关键字或以其他方式终止程序。'
- en: 'Working with `udpC.go` is as simple as follows—the client side is implemented
    using `nc(1)`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`udpC.go`就像以下这样——客户端使用`nc(1)`实现：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`127.0.0.1:1234` is the value of `c.RemoteAddr().String()`, which shows the
    details of the UDP server we have connected to.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`127.0.0.1:1234`是`c.RemoteAddr().String()`的值，它显示了我们所连接的UDP服务器的详细信息。'
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Our client sent `Hello!` to the UDP server and received `Hi from the server.`
    back.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端向UDP服务器发送了`Hello!`，并收到了`Hi from the server.`的回复。
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Our client sent `Have to leave now :)` to the UDP server and received `OK -
    bye from nc -l -u 1234` back. The UDP server started using `nc -l -u 1234`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端向 UDP 服务器发送 `Have to leave now :)` 并收到 `OK - bye from nc -l -u 1234` 的回复。UDP
    服务器开始使用 `nc -l -u 1234`。
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, after sending the `STOP` keyword to the server, the client prints `Exiting
    UDP client!` and terminates—the message is defined in the Go code and can be anything
    you want.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在向服务器发送 `STOP` 关键字后，客户端打印 `Exiting UDP client!` 并终止——该消息在 Go 代码中定义，可以是任何你想要的内容。
- en: The next section is about programming a UDP server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节是关于编程 UDP 服务器的内容。
- en: Developing a UDP server
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 UDP 服务器
- en: 'This section shows how to develop a UDP server, which generates and returns
    random numbers to its clients. The code for the UDP server (`udpS.go`) is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何开发一个 UDP 服务器，该服务器为客户端生成并返回随机数。UDP 服务器（`udpS.go`）的代码如下：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The UDP port number the server is going to listen to is provided as a command
    line argument.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将要监听的 UDP 端口号作为命令行参数提供。
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `net.ResolveUDPAddr()` function creates a UDP endpoint that the UDP server
    is going to listen to.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.ResolveUDPAddr()` 函数创建一个 UDP 服务器将要监听的 UDP 端点。'
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `net.ListenUDP("udp4", s)` function call makes this process a server for
    the `udp4` protocol using the details specified by its second parameter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.ListenUDP("udp4", s)` 函数调用使此过程成为使用其第二个参数指定的详细信息的 `udp4` 协议的服务器。'
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `buffer` variable stores a byte slice with 1024 bytes and is used to read
    data from the connection with the UDP client.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer` 变量存储一个 1024 字节的字节切片，用于从 UDP 客户端读取数据。'
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `ReadFromUDP()` and `WriteToUDP()` methods are used to read data from a
    UDP connection and write data to a UDP connection, respectively. Additionally,
    due to the way UDP operates, the UDP server can serve multiple clients.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFromUDP()` 和 `WriteToUDP()` 方法分别用于从 UDP 连接读取数据并将数据写入 UDP 连接。此外，由于 UDP
    的操作方式，UDP 服务器可以服务多个客户端。'
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The UDP server terminates when any one of the clients sends the `STOP` message.
    Aside from this, the `for` loop is going to keep running forever.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何一个客户端发送 `STOP` 消息时，UDP 服务器将终止。除此之外，`for` 循环将永远运行。
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A byte slice is stored in the `data` variable and used to write the desired
    data to the client.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 字节切片存储在 `data` 变量中，并用于将所需数据写入客户端。
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Working with `udpS.go` is as simple as the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `udpS.go` 一起工作就像以下这样：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Lines beginning with `->` show data coming from a client. Lines beginning with
    `data:` show random numbers generated by the UDP server—in this case, `403`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `->` 开头的行显示来自客户端的数据。以 `data:` 开头的行显示 UDP 服务器生成的随机数——在本例中为 `403`。
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The previous two lines show another interaction with a UDP client.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行显示了与 UDP 客户端的另一个交互。
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Once the UDP server receives the `STOP` keyword from the client, it closes the
    connection and exits.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 UDP 服务器从客户端接收到 `STOP` 关键字，它将关闭连接并退出。
- en: 'On the client side, which uses `udpC.go`, we have the following interaction:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `udpC.go` 的客户端方面，我们有以下交互：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The client sends the `Hello from client!` message to the server and receives
    `403`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端向服务器发送 `Hello from client!` 消息并收到 `403`。
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The client sends `Going to terminate the connection now.` to the server and
    receives the random number `154`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端向服务器发送 `Going to terminate the connection now.` 并接收随机数 `154`。
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When the client gets `STOP` as user input, it terminates the UDP connection
    and exits.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端接收到 `STOP` 作为用户输入时，它将终止 UDP 连接并退出。
- en: The next section shows how to develop a concurrent TCP server that uses goroutines
    for serving its clients.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节展示了如何开发一个使用 goroutines 为其客户端提供服务的并发 TCP 服务器。
- en: Developing concurrent TCP servers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发并发 TCP 服务器
- en: This section teaches you a pattern for developing concurrent TCP servers, which
    are servers that use separate goroutines to serve their clients following a successful
    `Accept()` call. Therefore, such servers can serve multiple TCP clients at the
    same time. This is how real-world production servers and services are implemented.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本节教你一个开发并发 TCP 服务器的模式，这些服务器在成功调用 `Accept()` 后使用单独的 goroutines 为其客户端提供服务。因此，这样的服务器可以同时为多个
    TCP 客户端提供服务。这是现实世界生产服务器和服务实现的方式。
- en: 'The code of `concTCP.go` is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`concTCP.go` 的代码如下：'
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The previous statement is not required—it just informs us that a new client
    has been connected.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句不是必需的——它只是通知我们一个新的客户端已连接。
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `for` loop makes sure that `handleConnection()` is not going to exit automatically.
    Once again, the `STOP` keyword stops the goroutine of the current client connection—however,
    the server process, as well as all other active client connections, is going to
    keep running.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环确保 `handleConnection()` 不会自动退出。再次强调，`STOP` 关键字停止了当前客户端连接的 goroutine——然而，服务器进程以及所有其他活跃的客户端连接将继续运行。'
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the end of the function that is executed as a goroutine to serve clients.
    All you need in order to serve a client is a `net.Conn` parameter with the TCP
    client details. After reading the client data, the server sends back a message
    to the current TCP client indicating the total number of TCP clients that have
    been served so far.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行为服务客户端的 goroutine 的函数的结束。为了服务一个客户端，你需要一个带有 TCP 客户端详细信息的 `net.Conn` 参数。在读取客户端数据后，服务器会向当前的
    TCP 客户端发送一条消息，指示到目前为止已服务的 TCP 客户端总数。
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each time a new client connects to the server, the `count` variable is increased.
    Each TCP client is served by a separate goroutine that executes the `handleConnection()`
    function. This frees the server process and allows it to accept new connections.
    Put simply, while multiple TCP clients are being served, the TCP server is free
    to interact with more TCP clients. As before, new TCP clients are connected using
    the `Accept()` function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每次有新的客户端连接到服务器时，`count` 变量会增加。每个 TCP 客户端都由一个执行 `handleConnection()` 函数的单独的 goroutine
    服务。这释放了服务器进程，并允许它接受新的连接。简单来说，当多个 TCP 客户端正在被服务时，TCP 服务器可以自由地与更多的 TCP 客户端交互。和之前一样，新的
    TCP 客户端是通过使用 `Accept()` 函数连接的。
- en: 'Working with `concTCP.go` produces the next kind of output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `concTCP.go` 进行工作会产生以下类型的输出：
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first line of output is from the first TCP client, whereas the second line
    is from the second TCP client. This means that the concurrent TCP server works
    as expected. Therefore, when you want to be able to serve multiple TCP clients
    in your TCP services, you can use the presented technique and code as a template
    for developing your own concurrent TCP servers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行来自第一个 TCP 客户端，而第二行来自第二个 TCP 客户端。这意味着并发 TCP 服务器按预期工作。因此，当你想在 TCP 服务中服务多个
    TCP 客户端时，你可以使用提供的技巧和代码作为开发自己的并发 TCP 服务器的模板。
- en: The sections that follow concern the WebSocket protocol.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部分将涉及 WebSocket 协议。
- en: Creating a WebSocket server
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 WebSocket 服务器
- en: The WebSocket protocol is a computer communications protocol that provides full-duplex
    (transmission of data in two directions simultaneously) communication channels
    over a single TCP connection. The WebSocket protocol is defined in RFC 6455 ([https://tools.ietf.org/html/rfc6455](https://tools.ietf.org/html/rfc6455))
    and uses `ws://` and `wss://` instead of `http://` and `https://`, respectively.
    Therefore, the client should begin a WebSocket connection by using a URL that
    starts with `ws://`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 协议是一种计算机通信协议，它通过单个 TCP 连接提供全双工（同时双向传输数据）通信通道。WebSocket 协议在 RFC 6455
    ([https://tools.ietf.org/html/rfc6455](https://tools.ietf.org/html/rfc6455)) 中定义，并分别使用
    `ws://` 和 `wss://` 替代 `http://` 和 `https://`。因此，客户端应通过使用以 `ws://` 开头的 URL 来开始
    WebSocket 连接。
- en: In this section, we are going to develop a small yet fully functional WebSocket
    server using the `gorilla/websocket` ([https://github.com/gorilla/websocket](https://github.com/gorilla/websocket))
    module. The server implements the echo service, which means that it automatically
    returns the client input back to the client.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `gorilla/websocket` ([https://github.com/gorilla/websocket](https://github.com/gorilla/websocket))
    模块开发一个小型但功能齐全的 WebSocket 服务器。该服务器实现了回声服务，这意味着它会自动将客户端输入返回给客户端。
- en: The `https://pkg.go.dev/golang.org/x/net/websocket` package offers another way
    of developing WebSocket clients and servers. However, based on its documentation,
    `pkg.go.dev/golang.org/x/net/websocket` lacks some features and it is advised
    to use either [https://pkg.go.dev/github.com/gorilla/websocket](https://pkg.go.dev/github.com/gorilla/websocket),
    the one used here, or [https://pkg.go.dev/nhooyr.io/websocket](https://pkg.go.dev/nhooyr.io/websocket)
    instead.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://pkg.go.dev/golang.org/x/net/websocket` 包提供了另一种开发 WebSocket 客户端和服务器的方法。然而，根据其文档，`pkg.go.dev/golang.org/x/net/websocket`
    缺少一些功能，建议使用 [https://pkg.go.dev/github.com/gorilla/websocket](https://pkg.go.dev/github.com/gorilla/websocket)，即这里使用的，或者
    [https://pkg.go.dev/nhooyr.io/websocket](https://pkg.go.dev/nhooyr.io/websocket)。'
- en: 'You might ask why to use the WebSocket protocol instead of HTTP. The advantages
    of the WebSocket protocol include the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么使用 WebSocket 协议而不是 HTTP。WebSocket 协议的优点包括以下内容：
- en: A WebSocket connection is a full-duplex, bidirectional communications channel.
    This means that a server does not need to wait to read from a client to send data
    to the client and vice versa.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket连接是一个全双工、双向的通信通道。这意味着服务器不需要等待从客户端读取数据才能向客户端发送数据，反之亦然。
- en: WebSocket connections are raw TCP sockets, which means that they do not have
    the overhead required to establish an HTTP connection.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket连接是原始的TCP套接字，这意味着它们不需要建立HTTP连接所需的开销。
- en: WebSocket connections can also be used to send HTTP data. However, plain HTTP
    connections cannot work as WebSocket connections.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket连接也可以用来发送HTTP数据。然而，普通的HTTP连接不能作为WebSocket连接工作。
- en: WebSocket connections live until they are killed, so there is no need to reopen
    them all the time.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket连接在它们被终止之前一直存在，因此没有必要总是重新打开它们。
- en: WebSocket connections can be used for real-time web applications.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket连接可以用于实时Web应用程序。
- en: Data can be sent from the server to the client at any time, without the client
    even requesting it.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以在任何时候从服务器发送到客户端，即使客户端没有请求。
- en: WebSocket is part of the HTML5 specification, which means that it is supported
    by all modern web browsers.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket是HTML5规范的一部分，这意味着它被所有现代网络浏览器支持。
- en: Before showing the server implementation, it would be good for you to know that
    the `websocket.Upgrader` method of the `gorilla/websocket` package upgrades an
    HTTP server connection to the WebSocket protocol and allows you to define the
    parameters of the upgrade. After that, your HTTP connection is a WebSocket connection,
    which means that you will not be allowed to execute statements that work with
    the HTTP protocol.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示服务器实现之前，了解`gorilla/websocket`包中的`websocket.Upgrader`方法将HTTP服务器连接升级到WebSocket协议，并允许你定义升级参数会很好。之后，你的HTTP连接就变成了WebSocket连接，这意味着你将不允许执行与HTTP协议相关的语句。
- en: The next subsection shows the implementation of the server.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节将展示服务器的实现。
- en: The implementation of the server
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器实现
- en: This subsection presents the implementation of the WebSocket server that implements
    the echo service, which can be really handy when testing network connections.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节展示了实现echo服务的WebSocket服务器，这在测试网络连接时非常有用。
- en: The code is put inside `~/go/src/github.com/mactsouk/mGo4th/ch10/ws`. The `server`
    directory contains the implementation of the server whereas the `client` directory
    contains the implementation of the WebSocket client.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被放置在`~/go/src/github.com/mactsouk/mGo4th/ch10/ws`目录中。`server`目录包含服务器的实现，而`client`目录包含WebSocket客户端的实现。
- en: 'The implementation of the WebSocket server can be found in `server.go`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket服务器的实现可以在`server.go`中找到：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is the external package used for working with the WebSocket protocol.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于处理WebSocket协议的外部包。
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is where the parameters of `websocket.Upgrader` are defined. They are going
    to be used shortly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义了`websocket.Upgrader`的参数。它们将很快被使用。
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is a regular HTTP handler function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常规的HTTP处理函数。
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: A WebSocket server application calls the `Upgrader.Upgrade` method to get a
    WebSocket connection from an HTTP request handler. After a successful call to
    `Upgrader.Upgrade`, the server begins working with the WebSocket connection and
    the WebSocket client.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket服务器应用程序调用`Upgrader.Upgrade`方法从HTTP请求处理器获取WebSocket连接。在成功调用`Upgrader.Upgrade`之后，服务器开始与WebSocket连接和WebSocket客户端一起工作。
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `for` loop in `wsHandler()` handles all incoming messages for `/ws`—you
    can use any technique you want to serve incoming requests. Additionally, in the
    presented implementation, only the client is allowed to close an existing WebSocket
    connection unless there is a network issue, or the server process is killed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`wsHandler()`中的`for`循环处理所有针对`/ws`的传入消息——你可以使用任何你想要的技巧来处理传入请求。此外，在所展示的实现中，除非有网络问题或服务器进程被终止，否则只有客户端被允许关闭现有的WebSocket连接。'
- en: Last, remember that in a WebSocket connection, you cannot use `fmt.Fprintf()`
    statements to send data to the WebSocket client—if you use any of these, or any
    other call that can implement the same functionality, the WebSocket connection
    fails and you are not going to be able to send or receive any data. Therefore,
    the only way to send and receive data in a WebSocket connection implemented with
    `gorilla/websocket` is through `WriteMessage()` and `ReadMessage()` calls, respectively.
    Of course, you can always implement the desired functionality on your own by working
    with raw network data, but implementing this goes beyond the scope of this book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，在WebSocket连接中，您不能使用`fmt.Fprintf()`语句向WebSocket客户端发送数据——如果您使用这些中的任何一个，或者任何其他可以执行相同功能的调用，WebSocket连接将失败，您将无法发送或接收任何数据。因此，在用`gorilla/websocket`实现的WebSocket连接中发送和接收数据的唯一方法是分别通过`WriteMessage()`和`ReadMessage()`调用。当然，您总是可以通过处理原始网络数据来实现所需的功能，但这超出了本书的范围。
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If there is not a command line argument, the default port number stored in the
    `PORT` global variable is used. Otherwise, the given value is used.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有命令行参数，将使用存储在`PORT`全局变量中的默认端口号。否则，将使用给定的值。
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: These are the details of the HTTP server that also handles WebSocket connections.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是处理WebSocket连接的HTTP服务器的详细信息。
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The endpoint used for WebSocket can be anything you want—in this case, it is
    `/ws`. Additionally, you can have multiple endpoints that work with the WebSocket
    protocol.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 用于WebSocket的端点可以是您想要的任何内容——在这种情况下，它是`/ws`。此外，您可以有多个端点，它们使用WebSocket协议。
- en: '[PRE62]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The presented code uses `log.Println()` instead of `fmt.Println()` for printing
    messages—as this is a server process, using `log.Println()` is a much better choice
    than `fmt.Println()` because logging information is sent to files that can be
    examined at a later time. However, during development, you might prefer `fmt.Println()`
    calls and avoid writing to your log files because you can see your data on screen
    immediately without having to look elsewhere. Additionally, if you are going to
    run the server as a Docker image, using `fmt.Println()` makes more sense. However,
    you should bear in mind that the `log` package also prints to the screen by default.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的代码使用`log.Println()`而不是`fmt.Println()`来打印消息——因为这是一个服务器进程，使用`log.Println()`比`fmt.Println()`更好，因为日志信息被发送到可以在以后检查的文件。然而，在开发过程中，您可能更喜欢`fmt.Println()`调用，并避免写入日志文件，因为您可以在屏幕上立即看到数据，而无需在其他地方查找。此外，如果您打算以Docker镜像运行服务器，使用`fmt.Println()`更有意义。但是，您应该记住，`log`包默认也会打印到屏幕上。
- en: The server implementation is short, yet fully functional. The single most important
    call in the code is `Upgrader.Upgrade` because this is what upgrades an HTTP connection
    to a WebSocket connection.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器实现简短，但功能齐全。代码中最重要的单个调用是`Upgrader.Upgrade`，因为这会将HTTP连接升级为WebSocket连接。
- en: 'Getting and running the code from GitHub requires the following steps—most
    of the steps have to do with module initialization and downloading the required
    packages:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub获取并运行代码需要以下步骤——大多数步骤都与模块初始化和下载所需的包有关：
- en: '[PRE63]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To test that server, we need to have a client. As we have not developed our
    own client so far, we are going to test the WebSocket server using the `websocat`
    utility.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试该服务器，我们需要有一个客户端。由于我们迄今为止还没有开发自己的客户端，我们将使用`websocat`实用程序来测试WebSocket服务器。
- en: Using websocat
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用websocat
- en: '`websocat` is a command line utility that can help you test WebSocket connections.
    However, as `websocat` is not installed by default, you need to install it on
    your machine using your package manager of choice. You can use it as follows,
    provided that there is a WebSocket server at the desired address:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`websocat`是一个命令行实用程序，可以帮助您测试WebSocket连接。然而，由于`websocat`默认未安装，您需要使用您选择的包管理器在您的机器上安装它。如果目标地址有WebSocket服务器，您可以使用以下方式使用它：'
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is what we type and send to the server.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在服务器上键入并发送的内容。
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is what we get back from the WebSocket server, which implements the echo
    service—different WebSocket servers implement different functionality.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从WebSocket服务器返回的内容，该服务器实现了回显服务——不同的WebSocket服务器实现不同的功能。
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Again, the previous line is user input given to `websocat`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，上一行是用户输入给`websocat`的。
- en: '[PRE67]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: And the last line is the data sent back from the server. The connection was
    closed by pressing *Ctrl* + *D* on the `websocat` client.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条是服务器发送回的数据。连接是通过在`websocat`客户端上按*Ctrl* + *D*来关闭的。
- en: 'Should you wish for verbose output from `websocat`, you can execute it with
    the `-v` flag:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望从`websocat`获取详细输出，你可以使用`-v`标志执行它：
- en: '[PRE68]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In both cases, the output from our WebSocket server should be similar to the
    following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们的WebSocket服务器的输出应该类似于以下内容：
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The next subsection shows how to develop a WebSocket client in Go.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节展示了如何在Go中开发WebSocket客户端。
- en: Creating a WebSocket client
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建WebSocket客户端
- en: This subsection shows how to program a WebSocket client in Go. The client reads
    user data, sends it to the server, and reads the server response. The `client`
    directory contains the implementation of the WebSocket client. The `gorilla/websocket`
    package is going to help us develop the WebSocket client.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何在Go中编程WebSocket客户端。客户端读取用户数据，将其发送到服务器，并读取服务器响应。`client`目录包含WebSocket客户端的实现。`gorilla/websocket`包将帮助我们开发WebSocket客户端。
- en: 'The code of `./client/client.go` is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`./client/client.go`的代码如下：'
- en: '[PRE70]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `in` variable is just a shortcut for `bufio.NewReader(os.Stdin)`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`变量只是`bufio.NewReader(os.Stdin)`的一个快捷方式。'
- en: '[PRE71]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `getInput()` function, which is executed as a goroutine, gets user input
    that is transferred to the `main()` function via the `input` channel. Each time
    the program reads some user input, the old goroutine ends and a new `getInput()`
    goroutine begins in order to get new user input.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`getInput()`函数作为goroutine执行，获取用户输入并将其通过`input`通道传输到`main()`函数。每次程序读取一些用户输入时，旧的goroutine结束，并开始一个新的`getInput()`
    goroutine以获取新的用户输入。'
- en: '[PRE72]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The WebSocket client handles UNIX interrupts with the help of the `interrupt`
    channel. When the appropriate signal is caught (`syscall.SIGINT`), the WebSocket
    connection with the server is closed with the help of the `websocket.CloseMessage`
    message. This is how professional tools work!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket客户端借助`interrupt`通道处理UNIX中断。当捕获到适当的信号（`syscall.SIGINT`）时，使用`websocket.CloseMessage`消息关闭与服务器的WebSocket连接。这正是专业工具的工作方式！
- en: '[PRE73]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The WebSocket connection begins with a call to `websocket.DefaultDialer.Dial()`.
    Everything that goes to the `input` channel is transferred to the WebSocket server
    using the `WriteMessage()` method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket连接从调用`websocket.DefaultDialer.Dial()`开始。所有发送到`input`通道的内容都使用`WriteMessage()`方法传输到WebSocket服务器。
- en: '[PRE74]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Another goroutine, which this time is implemented using an anonymous Go function,
    is responsible for reading data from the WebSocket connection using the `ReadMessage()`
    method.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个goroutine，这次使用匿名Go函数实现，负责使用`ReadMessage()`方法从WebSocket连接中读取数据。
- en: '[PRE75]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `syscall.Kill(syscall.Getpid(), syscall.SIGINT)` statement sends the interrupt
    signal to the program using Go code. According to the logic of `client.go`, the
    interrupt signal makes the program close the WebSocket connection with the server
    and terminate its execution. This only happens if the current number of timeout
    periods is bigger than a predefined global value, which in this case is equal
    to `5`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`syscall.Kill(syscall.Getpid(), syscall.SIGINT)`语句使用Go代码向程序发送中断信号。根据`client.go`的逻辑，中断信号使得程序关闭与服务器的WebSocket连接并终止其执行。这仅在当前超时周期数大于预定义的全局值时发生，在这个例子中等于`5`。'
- en: '[PRE76]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If you get user input, the current number of the timeout periods (`TIMESWAIT`)
    is reset and the new input is read.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到用户输入，当前的超时周期数（`TIMESWAIT`）将被重置，并读取新的输入。
- en: '[PRE77]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Just before we close the client connection, we send `websocket.CloseMessage`
    to the server in order to end the connection the right way.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关闭客户端连接之前，我们向服务器发送`websocket.CloseMessage`以正确结束连接。
- en: '[PRE78]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As `./client/client.go` is in a separate directory, we need to run the next
    commands in order to collect the required dependencies and run it:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`./client/client.go`位于单独的目录中，我们需要运行以下命令来收集所需的依赖项并运行它：
- en: '[PRE79]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Interacting with the WebSocket server produces the next kind of output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与WebSocket服务器的交互产生以下类型的输出：
- en: '[PRE80]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The previous two lines show user input as well as the server response.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行显示了用户输入以及服务器响应。
- en: '[PRE81]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The last lines of output show how the automatic timeout process works.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行显示了自动超时过程的工作方式。
- en: 'The WebSocket server generated the following output for the previous interaction:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket服务器为之前的交互生成了以下输出：
- en: '[PRE82]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'However, if a WebSocket server cannot be found at the address provided, the
    WebSocket client produces the next output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果无法在提供的地址找到WebSocket服务器，WebSocket客户端将产生以下输出：
- en: '[PRE83]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `connection refused` message indicates that there is no process listening
    to port number `1234` on `localhost`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`connection refused`消息表明没有进程在`localhost`上监听端口号`1234`。'
- en: The next section of the chapter is about working with the RabbitMQ message broker.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的下一节是关于与RabbitMQ消息代理一起工作。
- en: Working with RabbitMQ
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与RabbitMQ一起工作
- en: In the last section of this chapter, we are going to learn how to work with
    RabbitMQ. RabbitMQ is an open-source message broker that is particularly handy
    when you want to exchange information asynchronously and need a place where messages
    can be stored safely until they are read. RabbitMQ enables you to exchange information,
    which is the main reason that you do not need to use it directly unless you want
    to perform administrative tasks.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将学习如何与RabbitMQ一起工作。RabbitMQ是一个开源的消息代理，当您想要异步交换信息并需要一个安全存储消息的地方时特别有用。RabbitMQ使您能够交换信息，这也是您不需要直接使用它除非您想执行管理任务的主要原因。
- en: RabbitMQ uses the AMQP protocol. AMQP, which stands for Advanced Message Queuing
    Protocol, is an open protocol for message-oriented middleware. The characteristic
    features of AMQP are message orientation, queuing, routing, reliability, and security.
    AMQP works with binary data and transmits data in frames. There exist nine types
    of frames (open connection, close connection, transfer data, etc.) depending on
    the task that you want to perform.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ使用AMQP协议。AMQP代表高级消息队列协议，是一种面向消息的中间件的开源协议。AMQP的特点是消息导向、排队、路由、可靠性和安全性。AMQP与二进制数据一起工作，并以帧的形式传输数据。根据您要执行的任务，存在九种类型的帧（打开连接、关闭连接、传输数据等）。
- en: If you must choose between RabbitMQ and Kafka, which both do a similar job,
    you should begin by considering their differences. First, Kafka is faster than
    RabbitMQ. Second, RabbitMQ works with the push model whereas Kafka works with
    a pull-based approach. Third, Kafka offers support for batching whereas RabbitMQ
    does not. Last, RabbitMQ does not have a limit on the payload size whereas Kafka
    has some restrictions on the payload size. The key thing to remember is that if
    speed is your main concern, then Kafka might be a better choice, whereas if payload
    size and simplicity are your main concerns, then RabbitMQ is a more rational choice.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须在RabbitMQ和Kafka之间做出选择，它们都执行类似的工作，您应该首先考虑它们之间的差异。首先，Kafka比RabbitMQ更快。其次，RabbitMQ使用推送模型，而Kafka使用基于拉取的方法。第三，Kafka支持批处理，而RabbitMQ不支持。最后，RabbitMQ没有对有效负载大小的限制，而Kafka对有效负载大小有一些限制。要记住的关键点是，如果速度是您的主要关注点，那么Kafka可能是一个更好的选择，而如果您主要关注有效负载大小和简单性，那么RabbitMQ是一个更合理的选择。
- en: 'Data is stored in queues. A queue in RabbitMQ is a FIFO (First In, First Out)
    structure that supports two operations: adding elements and getting elements.
    Queues have names, which means that you should know the name of the queue you
    want to interact with either as a message producer or a message consumer.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储在队列中。RabbitMQ中的队列是一个FIFO（先进先出）结构，支持两种操作：添加元素和获取元素。队列有名称，这意味着您应该知道您想要交互的队列的名称，无论是作为消息生产者还是消息消费者。
- en: The `github.com/rabbitmq/amqp091-go` Go module does the job of connecting to
    RabbitMQ using the AMQP protocol, provided that you supply the correct connection
    details.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/rabbitmq/amqp091-go` Go模块通过AMQP协议连接到RabbitMQ，前提是您提供了正确的连接细节。'
- en: All files for this section, including source files and a `docker-compose.yml`
    file for running RabbitMQ, are located in `~/go/src/github.com/mactsouk/mGo4th/ch10/MQ`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的所有文件，包括源文件和用于运行RabbitMQ的`docker-compose.yml`文件，都位于`~/go/src/github.com/mactsouk/mGo4th/ch10/MQ`。
- en: Running RabbitMQ
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行RabbitMQ
- en: 'In this first subsection, we are going to learn how to execute RabbitMQ using
    Docker—this is the cleanest solution for running RabbitMQ on your machine because
    it only requires the use of a single Docker image. The contents of the `docker-compose.yml`
    file, which can be found inside `~/go/src/github.com/mactsouk/mGo4th/ch10/MQ/`,
    are the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一小节中，我们将学习如何使用Docker来执行RabbitMQ——这是在您的机器上运行RabbitMQ的最干净解决方案，因为它只需要使用单个Docker镜像。位于`~/go/src/github.com/mactsouk/mGo4th/ch10/MQ/`目录下的`docker-compose.yml`文件的内容如下：
- en: '[PRE84]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Running `docker-compose.yml` is as simple as using `docker-compose up` from
    inside `~/go/src/github.com/mactsouk/mGo4th/ch10/MQ/`. If the relevant Docker
    image is not present on the active machine, it is going to be downloaded first.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker-compose.yml`就像在`~/go/src/github.com/mactsouk/mGo4th/ch10/MQ/`目录下使用`docker-compose
    up`一样简单。如果相关的Docker镜像不在活动机器上，它将首先被下载。
- en: Now that we have RabbitMQ up and running, let us learn how to send data to RabbitMQ
    (producer) and read data from a RabbitMQ queue (consumer).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了RabbitMQ，让我们学习如何向RabbitMQ（生产者）发送数据，并从RabbitMQ队列（消费者）读取数据。
- en: Writing to RabbitMQ
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向RabbitMQ写入
- en: 'The code of the RabbitMQ producer is named `sendMQ.go` and is located under
    the `producer` directory. The `sendMQ.go` source file is presented in two parts.
    The first part contains the following code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ生产者的代码命名为`sendMQ.go`，位于`producer`目录下。`sendMQ.go`源文件也分为两部分。第一部分包含以下代码：
- en: '[PRE85]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `amqp.Dial()` call initiates a connection to RabbitMQ, whereas the `Channel()`
    call opens a channel to that connection and makes it ready for use.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`amqp.Dial()`调用初始化与RabbitMQ的连接，而`Channel()`调用打开该连接的通道，使其准备好使用。'
- en: The connection string (`amqp://guest:guest@localhost:5672/`) can be split into
    three logical parts. The first part (`amqp://`) is the protocol that is used,
    the second part contains the user credentials, and the third part contains the
    name of the server and the port number (`localhost:5672/`).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串（`amqp://guest:guest@localhost:5672/`）可以分为三个逻辑部分。第一部分（`amqp://`）是使用的协议，第二部分包含用户凭据，第三部分包含服务器名称和端口号（`localhost:5672/`）。
- en: 'The second part comes with the following code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下代码：
- en: '[PRE86]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `QueueDeclare()` defines the queue that we are going to use. If the queue
    name specified by `QueueDeclare()` does not already exist, it is going to be created.
    This means that typos in queue names are not caught. In this case, the queue is
    named `Go`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueueDeclare()`定义了我们将要使用的队列。如果`QueueDeclare()`指定的队列名称不存在，它将被创建。这意味着队列名称中的错误不会被捕获。在这种情况下，队列被命名为`Go`。'
- en: The plain text data we want to send is kept in the `message` variable. After
    that, we specify the format of the data we are going to put in the `amqp.Publishing{}`
    structure, which in this case is plain text (the JSON format is also supported).
    The contents of the `message` variable are converted into a byte slice and put
    into the `Body` field of an anonymous `amqp.Publishing{}` structure.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要发送的纯文本数据保存在`message`变量中。之后，我们指定将要放入`amqp.Publishing{}`结构体中的数据格式，在这种情况下是纯文本（也支持JSON格式）。`message`变量的内容被转换为字节切片，并放入匿名`amqp.Publishing{}`结构体的`Body`字段中。
- en: That `amqp.Publishing{}` structure is one of the parameters of the `ch.PublishWithContext()`
    call, which sends the structure to RabbitMQ.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`amqp.Publishing{}`结构体是`ch.PublishWithContext()`调用的一个参数，它将结构体发送到RabbitMQ。
- en: The current version of `sendMQ.go` just writes a message to the predefined queue
    using `Publish()` and exits. This means that in order to send multiple messages
    to RabbitMQ, we have to execute `sendMQ.go` multiple times.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的`sendMQ.go`只是使用`Publish()`将消息写入预定义的队列并退出。这意味着为了向RabbitMQ发送多个消息，我们必须多次执行`sendMQ.go`。
- en: 'Running `sendMQ.go` generates the following kind of output:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`sendMQ.go`生成以下类型的输出：
- en: '[PRE87]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `{Go 1 0}` output means that we currently have two messages in the RabbitMQ
    queue.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`{Go 1 0}`输出意味着我们目前在RabbitMQ队列中有两条消息。'
- en: The next subsection shows how to consume messages from a RabbitMQ queue.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示如何从RabbitMQ队列中消费消息。
- en: Reading from RabbitMQ
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从RabbitMQ读取
- en: 'The code of the RabbitMQ consumer is named `readMQ.go` and is located under
    the `consumer` directory. The `readMQ.go` source file is also presented in two
    parts. The first part contains the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ消费者的代码命名为`readMQ.go`，位于`consumer`目录下。`readMQ.go`源文件也分为两部分。第一部分包含以下代码：
- en: '[PRE88]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: As in `sendMQ.go`, we define the connection details, and we open the connection.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 与`sendMQ.go`类似，我们定义连接细节，并打开连接。
- en: 'The second part is the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE89]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The `Consume()` method reads messages from the `Go` queue using a goroutine.
    The `forever` channel blocks the program and prevents it from exiting. The `Body`
    field of the received message, which is a structure, contains the data we want.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consume()`方法使用goroutine从`Go`队列读取消息。`forever`通道阻塞程序，防止其退出。接收到的消息的`Body`字段，它是一个结构体，包含我们想要的数据。'
- en: 'Running `readMQ.go`, after `sendMQ.go` has put some messages in RabbitMQ, generates
    the following kind of output:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`readMQ.go`，在`sendMQ.go`向RabbitMQ中放入一些消息后，生成以下类型的输出：
- en: '[PRE90]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `readMQ.go` utility keeps running and waits for new messages, which means
    that we need to end it on our own by pressing *Ctrl* + *C*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`readMQ.go`实用程序持续运行并等待新消息，这意味着我们需要自己通过按下*Ctrl* + *C*来结束它。'
- en: How to remove a module
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何删除模块
- en: 'This is not directly related to RabbitMQ, but it is a useful tip. The current
    version of `go.mod` in the `consumer` directory is the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这与RabbitMQ没有直接关系，但它是一个有用的提示。`consumer`目录中当前版本的`go.mod`如下所示：
- en: '[PRE91]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'You can remove a module from `go.mod` using `none` as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方式使用`none`从`go.mod`中删除模块：
- en: '[PRE92]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'After that, `go.mod` is going to look as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`go.mod`将如下所示：
- en: '[PRE93]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: If you want to bring `go.mod` back into its previous state, you can run `go
    mod tidy`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将`go.mod`恢复到之前的状态，可以运行`go mod tidy`。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was all about the `net` package, TCP/IP, TCP, and UDP, which implement
    low-level connections, as well as WebSocket and RabbitMQ.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍了`net`包、TCP/IP、TCP和UDP，它们实现了低级连接，以及WebSocket和RabbitMQ。
- en: WebSocket gives us an alternative way of creating services. As a rule of thumb,
    WebSocket is better when we want to exchange lots of data, and we want the connection
    to remain open all the time and exchange data in full duplex. However, if we are
    not sure about what to choose, it is recommended to begin with a TCP/IP service
    and see how it goes before upgrading it to the WebSocket protocol.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket为我们提供了创建服务的另一种方式。一般来说，当我们想要交换大量数据，并且希望连接始终保持开启状态，进行全双工数据交换时，WebSocket是更好的选择。然而，如果我们不确定该选择什么，建议从TCP/IP服务开始，看看效果如何，然后再升级到WebSocket协议。
- en: Lastly, RabbitMQ is a rational choice when we want to store and retrieve a large
    amount of data to an external data store.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们要将大量数据存储和检索到外部数据存储时，RabbitMQ是一个合理的选择。
- en: Go can help you create all kinds of concurrent servers and clients.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Go可以帮助您创建各种并发服务器和客户端。
- en: We are now ready to begin developing our own services! The next chapter is about
    REST APIs, exchanging JSON data over HTTP, and developing RESTful clients and
    servers—Go is widely used for developing RESTful clients and servers.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始开发自己的服务了！下一章将介绍REST API、通过HTTP交换JSON数据以及开发RESTful客户端和服务器——Go在开发RESTful客户端和服务器方面得到了广泛应用。
- en: Exercises
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Develop a concurrent TCP server that generates random numbers in a predefined
    range.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个并发TCP服务器，在预定义的范围内生成随机数。
- en: Develop a concurrent TCP server that generates random numbers in a range that
    is given by the TCP client. This can be used as a way of randomly picking values
    from a set.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个并发TCP服务器，在TCP客户端给出的范围内生成随机数。这可以用作从集合中随机选择值的方法。
- en: Add UNIX signal processing to the concurrent TCP server developed in this chapter
    to gracefully stop the server process when a given signal is received.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将UNIX信号处理添加到本章开发的并发TCP服务器中，以便在接收到指定信号时优雅地停止服务器进程。
- en: Write a client program that reads a message from a RabbitMQ server and posts
    it to a TCP server.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个客户端程序，从RabbitMQ服务器读取消息并将其发布到TCP服务器。
- en: Develop a WebSocket server that creates a variable number of random integers
    that are sent to the client. The number of random integers is specified by the
    client in the initial client message.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个WebSocket服务器，该服务器创建一个可变数量的随机整数并发送给客户端。随机整数的数量由客户端在初始客户端消息中指定。
- en: Additional resources
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The WebSocket protocol: [https://tools.ietf.org/rfc/rfc6455.txt](https://tools.ietf.org/rfc/rfc6455.txt)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket协议：[https://tools.ietf.org/rfc/rfc6455.txt](https://tools.ietf.org/rfc/rfc6455.txt)
- en: 'Wikipedia WebSocket: [https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科WebSocket：[https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket)
- en: 'Gorilla WebSocket package: [https://github.com/gorilla/websocket](https://github.com/gorilla/websocket)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gorilla WebSocket包：[https://github.com/gorilla/websocket](https://github.com/gorilla/websocket)
- en: 'Gorilla WebSocket docs: [https://www.gorillatoolkit.org/pkg/websocket](https://www.gorillatoolkit.org/pkg/websocket)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gorilla WebSocket文档：[https://www.gorillatoolkit.org/pkg/websocket](https://www.gorillatoolkit.org/pkg/websocket)
- en: 'RabbitMQ Go module: [https://github.com/rabbitmq/amqp091-go](https://github.com/rabbitmq/amqp091-go)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ Go模块：[https://github.com/rabbitmq/amqp091-go](https://github.com/rabbitmq/amqp091-go)
- en: Learn more about AMQP at [https://www.amqp.org/](https://www.amqp.org/) and
    [https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol
    )
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://www.amqp.org/](https://www.amqp.org/)和[https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)了解更多关于AMQP的信息。
- en: Leave a review!
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下您的评价！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书？通过留下亚马逊评价帮助像您这样的读者。扫描下面的二维码以获得您选择的免费电子书。
- en: '![](img/Review_QR_Code.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![评价二维码](img/Review_QR_Code.png)'
