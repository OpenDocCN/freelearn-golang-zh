- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: The Go Garbage Collector
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go垃圾回收器
- en: The subject of this appendix is the operation of the Go **Garbage Collector**
    (**GC**). It is important to note that the details and performance characteristics
    of the GC may evolve with each new Go release.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录的主题是Go **垃圾回收器**（**GC**）的操作。需要注意的是，GC的细节和性能特性可能会随着每个新的Go版本而演变。
- en: Developers generally do not need to interact directly with the GC, as **it operates
    automatically in the background in its own goroutine**. However, understanding
    its behavior can be beneficial for optimizing memory usage and avoiding common
    pitfalls related to memory management. For the most up-to-date and detailed information,
    it is recommended to refer to the official Go documentation and release notes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者通常不需要直接与GC交互，因为**它在其自己的goroutine中以自动方式在后台运行**。然而，了解其行为对于优化内存使用和避免与内存管理相关的常见陷阱是有益的。对于最新和最详细的信息，建议参考官方Go文档和发布说明。
- en: First, let us discuss garbage collection in general. Following that, we will
    dig deeper into the nuances of the Go GC.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下垃圾回收的一般情况。之后，我们将深入探讨Go垃圾回收的细微差别。
- en: Garbage collection
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: 'Garbage collection is the process of freeing up memory space that is not being
    used. In other words, the GC sees which objects are out of scope and cannot be
    referenced anymore and frees the memory space they consume. This process happens
    in a concurrent way while a Go program is running and not before or after the
    execution of the program. The documentation of the Go GC implementation states
    the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是释放未使用内存空间的过程。换句话说，GC看到哪些对象已超出作用域且无法再被引用，并释放它们所消耗的内存空间。这个过程在Go程序运行时以并发方式发生，而不是在程序执行之前或之后。Go
    GC实现的文档中说明了以下内容：
- en: ”The GC runs concurrently with mutator threads, is type accurate (also known
    as precise), allows multiple GC threads to run in parallel. It is a concurrent
    mark and sweep that uses a write barrier. It is non-generational and non-compacting.
    Allocation is done using size segregated per P allocation areas to minimize fragmentation
    while eliminating locks in the common case.”
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “垃圾回收器与mutator线程并发运行，类型准确（也称为精确），允许多个GC线程并行运行。它是一种使用写屏障的并发标记和清除。它既不是代式的也不是压缩式的。分配是通过每个P的分配区域按大小分离来进行的，以最小化碎片化并消除常见情况下的锁。”
- en: The key characteristics of the Go GC
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go垃圾回收器的关键特性
- en: 'The key characteristics of the Go garbage collector are the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Go垃圾收集器的关键特性如下：
- en: '**Concurrent and parallel**: The Go GC operates concurrently with the execution
    of Go programs. It runs concurrently with the application’s threads, meaning that
    the GC can perform its work without stopping the application that is being executed.
    Additionally, certain phases of the GC can be parallelized to take advantage of
    multiple CPU cores and modern CPUs.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发和并行**：Go垃圾回收器与Go程序的执行并发运行。它与应用程序的线程并发运行，这意味着GC可以在不停止正在执行的应用程序的情况下执行其工作。此外，GC的某些阶段可以并行化，以利用多个CPU核心和现代CPU。'
- en: '**Generational collector**: The Go GC uses a generational garbage collection
    strategy, dividing objects into two generations: young and old. Most objects are
    allocated to the young generation, and most garbage collection work is focused
    there. The old generation contains longer-lived objects, which are less likely
    to get garbage collected.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代收集器**：Go的垃圾回收器使用代垃圾回收策略，将对象分为两代：年轻代和老年代。大多数对象分配到年轻代，大部分垃圾回收工作都集中在那里。老年代包含寿命较长的对象，这些对象不太可能被垃圾回收。'
- en: '**Tri-color mark and sweep algorithm**: The Go GC uses a tri-color mark-and-sweep
    algorithm. This algorithm uses three colors (white, gray, and black) to track
    the state of objects during the marking phase. White objects are not yet visited,
    gray objects are in the process of being visited, and black objects have been
    visited.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三色标记和清除算法**：Go GC使用三色标记和清除算法。该算法在标记阶段使用三种颜色（白色、灰色和黑色）来跟踪对象的状态。白色对象尚未被访问，灰色对象正在被访问过程中，黑色对象已被访问。'
- en: '**Write barrier**: Go uses a write barrier to keep track of pointers that are
    updated in the heap in order to maintain consistency during garbage collection.
    The write barrier ensures that the GC is aware of changes to pointers, allowing
    it to trace object dependencies accurately.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写屏障**：Go使用写屏障来跟踪堆中更新的指针，以在垃圾回收期间保持一致性。写屏障确保GC了解指针的变化，允许它准确地跟踪对象依赖关系。'
- en: '**Garbage collection triggers**: The Go GC is triggered based on memory allocation
    and heap size. When the allocated memory reaches a certain threshold or the heap
    size grows beyond a specified limit, the GC is triggered to reclaim unused memory.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾回收触发器**：Go GC基于内存分配和堆大小触发。当分配的内存达到某个阈值或堆大小超过指定的限制时，GC被触发以回收未使用的内存。'
- en: '**Manual control**: While the GC is designed to be automatic and transparent
    to developers, there are ways to provide hints and control certain aspects of
    the garbage collection process. For example, the `runtime.GC()` function can be
    used to request an explicit garbage collection cycle.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动控制**：虽然GC被设计为自动且对开发者透明，但有一些方法可以提供提示并控制垃圾回收过程的某些方面。例如，可以使用`runtime.GC()`函数请求显式的垃圾回收周期。'
- en: We are going to revisit most of the characteristics of the GC in a while.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在不久的将来重新审视GC的大部分特性。
- en: Learning more about the Go GC
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Go GC的更多内容
- en: The Go standard library offers functions that allow you to study the operation
    of the GC and learn more about what the GC covertly does. These functions are
    illustrated in the `gColl.go` utility. The source code of `gColl.go` is presented
    here in chunks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库提供了允许你研究GC操作并了解更多关于GC秘密做什么的功能。这些函数在`gColl.go`实用程序中得到了说明。`gColl.go`的源代码在此以块的形式展示。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We need the `runtime` package because it allows us to get information about
    the Go runtime system, which among other things includes information about the
    operation of the GC.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`runtime`包，因为它允许我们获取有关Go运行时系统的信息，其中包括GC操作的信息。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The main purpose of `printStats()` is to avoid writing the same Go code multiple
    times. The `runtime.ReadMemStats()` call gets the latest garbage collection statistics
    for you.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`printStats()`的主要目的是避免多次编写相同的Go代码。`runtime.ReadMemStats()`调用为你获取最新的垃圾回收统计信息。'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this part, we have a for loop that creates 10 byte slices with 50,000,000
    bytes each. The reason for this is that by allocating large amounts of memory,
    we can trigger the GC.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们有一个for循环，创建了10个每个50,000,000字节的字节块。这样做的原因是，通过分配大量内存，我们可以触发GC。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The last part of the program makes even bigger memory allocations—this time,
    each byte slice has 100,000,000 bytes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分进行了更大的内存分配——这次，每个字节块有10亿字节。
- en: 'Running `gColl.go` on a macOS Sonoma machine with 32 GB of RAM produces the
    following kind of output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有32 GB RAM的macOS Sonoma机器上运行`gColl.go`会产生以下类型的输出：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The value of `mem.Alloc` is the bytes of allocated heap objects—all the objects
    that the GC has not yet freed. `mem.TotalAlloc` shows the cumulative bytes allocated
    for heap objects—this number does not decrease when objects are freed, which means
    that it keeps increasing. Therefore, it shows the total number of bytes allocated
    for heap objects during program execution. `mem.HeapAlloc` is the same as `mem.Alloc`.
    Last, `mem.NumGC` **shows the total number of completed garbage collection cycles**.
    The bigger that value is, the more you have to consider how you allocate memory
    in your code and if there is a way to optimize that.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`mem.Alloc`的值是已分配堆对象的字节数——所有GC尚未释放的对象。`mem.TotalAlloc`显示为堆对象分配的累积字节数——当对象被释放时，这个数字不会减少，这意味着它会持续增加。因此，它显示了程序执行期间为堆对象分配的总字节数。`mem.HeapAlloc`与`mem.Alloc`相同。最后，`mem.NumGC`**显示了完成的垃圾回收周期总数**。这个值越大，你就越需要考虑如何在代码中分配内存，以及是否有优化这一点的途径。'
- en: 'If you want even more verbose output about the operation of the GC, you can
    combine `go run` `gColl.go` with `GODEBUG=gctrace=1`. Apart from the regular program
    output, you get some extra metrics—this is illustrated in the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取更多关于GC操作的详细输出，可以将`go run gColl.go`与`GODEBUG=gctrace=1`结合使用。除了常规程序输出外，你还会得到一些额外的指标——这将在以下输出中说明：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As before, we have the same number of completed garbage collection cycles (20).
    However, we get extra information about the heap size of each cycle. So, for garbage
    collection cycle 20 (`gc 20`), we get the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们有相同数量的完成的垃圾回收周期（20）。然而，我们得到了关于每个周期堆大小的额外信息。因此，对于垃圾回收周期20（`gc 20`），我们得到以下信息：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let us explain the `95->95->0` `MB` triplet in the previous line of output.
    The first value (`95`) is the heap size when the GC is about to run. The second
    value (`95`) is the heap size when the GC ends its operation. The last value is
    the size of the live heap (`0`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来解释上一行输出中的 `95->95->0` `MB` 三联组。第一个值（`95`）是 GC 即将运行时的堆大小。第二个值（`95`）是 GC
    结束操作时的堆大小。最后一个值是活动堆的大小（`0`）。
- en: The tri-color algorithm
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三色算法
- en: As mentioned earlier, the operation of the Go GC is based on the tri-color algorithm.
    Note that the tri-color algorithm is not unique to Go and can be used in other
    programming languages as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Go GC 的操作基于三色算法。请注意，三色算法并非仅限于 Go，也可以用于其他编程语言。
- en: Strictly speaking, the official name for the algorithm used in Go is the **tri-color
    mark-and-sweep algorithm**. It works concurrently with the program and uses a
    write barrier. This means that while a Go program runs, the Go scheduler is responsible
    for the scheduling of the application as well as the GC, which also runs as a
    goroutine. This is as if the Go scheduler must deal with a regular application
    with multiple goroutines!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，Go 中使用的算法的官方名称是 **三色标记-清除算法**。它与程序并发工作并使用写屏障。这意味着当 Go 程序运行时，Go 调度器负责调度应用程序以及垃圾回收器（GC），后者也作为一个
    goroutine 运行。这就像 Go 调度器必须处理一个具有多个 goroutine 的常规应用程序一样！
- en: 'The core idea behind this algorithm came from Edsger W. Dijkstra, Leslie Lamport,
    A. J. Martin, C. S. Scholten, and E. F. M. Steffens and was first illustrated
    in a paper named *On-the-Fly Garbage Collection: An Exercise in Cooperation*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '该算法背后的核心思想来自 Edsger W. Dijkstra、Leslie Lamport、A. J. Martin、C. S. Scholten
    和 E. F. M. Steffens，并在一篇名为 *On-the-Fly Garbage Collection: An Exercise in Cooperation*
    的论文中首次阐述。'
- en: The primary principle behind the tri-color mark-and-sweep algorithm is that
    it divides the objects of the heap into three different sets according to their
    color, which is assigned by the algorithm and can be black, gray, or white. The
    objects in the black set are guaranteed to have no pointers to any object in the
    white set. On the other hand, an object in the white set can point to an object
    in the black set because this has no effect on the operation of the GC. The objects
    in the gray set might have pointers to some objects in the white set. Finally,
    the objects in the white set are the candidates for garbage collection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 三色标记-清除算法背后的主要原则是，根据算法分配的颜色将堆中的对象分为三个不同的集合，颜色可以是黑色、灰色或白色。黑色集合中的对象保证没有指向白色集合中任何对象的指针。另一方面，白色集合中的对象可以指向黑色集合中的对象，因为这不会对
    GC 的操作产生影响。灰色集合中的对象可能指向白色集合中的某些对象。最后，白色集合中的对象是垃圾回收的候选对象。
- en: So, when the garbage collection begins, all objects are white, and the GC visits
    all the root objects and colors them gray. The roots are the objects that can
    be directly accessed by the application, which includes global variables and other
    things on the stack. These objects mostly depend on the Go code of a particular
    program.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当垃圾回收开始时，所有对象都是白色的，GC 会访问所有根对象并将它们标记为灰色。根对象是可以被应用程序直接访问的对象，包括全局变量和堆栈上的其他东西。这些对象主要依赖于特定程序的
    Go 代码。
- en: After that, the GC picks a gray object, makes it black, and starts looking at
    whether that object has pointers to other objects in the white set or not. Therefore,
    when an object in the gray set is scanned for pointers to other objects, it is
    colored black. If that scan discovers that this particular object has one or more
    pointers to a white object, it puts that white object in the gray set. This process
    keeps going for as long as there exist objects in the gray set. After that, the
    objects in the white set are unreachable and their memory space can be reused.
    Therefore, at this point, the elements in the white set are said to be garbage
    collected. Please note that no object can go directly from the black set to the
    white set, which allows the algorithm to operate and be able to clear the objects
    in the white set. As mentioned before, no object in the black set can directly
    point to an object in the white set. Additionally, if an object in the gray set
    becomes unreachable at some point in a garbage collection cycle, it will not be
    collected in that garbage collection cycle but in the next one! Although this
    is not an optimal situation, it is not that bad.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，GC选择一个灰色对象，将其变为黑色，并开始检查该对象是否指向白色集合中的其他对象。因此，当灰色集合中的对象被扫描以查找指向其他对象的指针时，它会被染成黑色。如果这次扫描发现这个特定的对象有一个或多个指向白色对象的指针，它就会将那个白色对象放入灰色集合。这个过程会一直持续到灰色集合中存在对象为止。之后，白色集合中的对象是不可达的，它们的内存空间可以被重用。因此，在这个时候，白色集合中的元素被认为是垃圾回收的。请注意，没有任何对象可以直接从黑色集合转到白色集合，这允许算法运行并能够清除白色集合中的对象。如前所述，黑色集合中的对象不能直接指向白色集合中的对象。此外，如果在垃圾回收周期中的某个时刻，灰色集合中的对象变得不可达，它将不会在该垃圾回收周期中被回收，而是在下一个周期中回收！尽管这不是最佳情况，但也不是那么糟糕。
- en: During this process, the running application is called the mutator. The mutator
    runs a small function named **write barrier**, which is executed each time a pointer
    in the heap is modified. If the pointer of an object in the heap is modified,
    this means that this object is now reachable—the write barrier colors it gray
    and puts it in the gray set. The mutator is responsible for the invariant that
    no element of the black set has a pointer to an element of the white set. This
    is accomplished with the help of the write barrier function. Failing to accomplish
    this invariant will ruin the garbage collection process and will most likely crash
    your program in a pretty bad and undesirable way!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，运行中的应用程序被称为突变器。突变器运行一个名为**写屏障**的小函数，每次堆中的指针被修改时都会执行该函数。如果堆中对象的指针被修改，这意味着该对象现在是可以到达的——写屏障将其染成灰色并将其放入灰色集合。突变器负责确保黑色集合中没有元素指向白色集合中的元素。这是通过写屏障函数实现的。未能实现这一不变性将破坏垃圾回收过程，并且很可能会以非常糟糕和不受欢迎的方式使你的程序崩溃！
- en: 'So, to summarize, there are three different colors: black, white, and gray.
    When the algorithm begins, all objects are colored white. As the algorithm keeps
    going, white objects are moved into one of the other two sets. The objects that
    are left in the white set are the ones that are going to be cleared at some point.
    The next figure displays the three color sets with objects in them.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，有三种不同的颜色：黑色、白色和灰色。当算法开始时，所有对象都被染成白色。随着算法的进行，白色对象会被移动到另外两个集合中的一个。留在白色集合中的对象是那些将在某个时刻被清除的对象。下一图显示了包含对象的三个颜色集合。
- en: '![A group of circles with letters and numbers  Description automatically generated](img/B21003_appA_01.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![一组带有字母和数字的圆圈  自动生成的描述](img/B21003_appA_01.png)'
- en: 'Figure A.1: The Go garbage collector represents the heap of a program as a
    graph'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.1：Go垃圾回收器将程序的堆表示为图
- en: While object **E**, which is in the white set, can access object **F**, it cannot
    be accessed by any other object because no other object points to object **E**,
    which makes it a perfect candidate for garbage collection! Additionally, objects
    **A**, **B**, and **C** are root objects and are always reachable; therefore,
    they cannot be garbage collected.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象**E**（在白色集合中）可以访问对象**F**时，它不能被任何其他对象访问，因为没有任何其他对象指向对象**E**，这使得它成为垃圾回收的完美候选者！此外，对象**A**、**B**和**C**是根对象，总是可以到达的；因此，它们不能被垃圾回收。
- en: Can you guess what happens next? Well, the algorithm will have to process the
    remaining elements of the gray set, which means that both objects **A** and **F**
    will go to the black set. Object **A** goes to the black set because it is a root
    element and **F** goes to the black set because it does not point to any other
    object while it is in the gray set.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到接下来会发生什么吗？好吧，算法将不得不处理灰色集合的剩余元素，这意味着对象**A**和**F**都将进入黑色集合。对象**A**进入黑色集合，因为它是一个根元素，而**F**进入黑色集合，因为它在灰色集合中不指向任何其他对象。
- en: After object **E** is garbage collected, object **F** will become unreachable
    and will be garbage collected in the next cycle of the GC because an unreachable
    object cannot magically become reachable in the next iteration of the garbage
    collection cycle.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象**E**被垃圾回收后，对象**F**将变得不可达，并在GC的下一个周期中被垃圾回收，因为不可达的对象不能在垃圾回收周期的下一个迭代中神奇地变得可达。
- en: Go garbage collection can also be applied to variables such as channels. When
    the GC finds out that a channel is unreachable, which is when the channel variable
    cannot be accessed anymore, it will free its resources even if the channel has
    not been closed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Go的垃圾回收也可以应用于诸如通道之类的变量。当GC发现通道不可达时，即通道变量无法再被访问时，即使通道尚未关闭，它也会释放其资源。
- en: Go allows you to manually initiate garbage collection cycles by putting a `runtime.GC()`
    statement in your Go code. However, keep in mind that `runtime.GC()` blocks the
    caller and it might block the entire program, especially if you are running a
    very busy Go program with many objects. This mainly happens because you cannot
    perform garbage collections while everything else is rapidly changing, as this
    will not give the GC the opportunity to clearly identify the members of the white,
    black, and gray sets. This garbage collection status is also called a garbage
    collection safe point.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Go允许你通过在Go代码中放置`runtime.GC()`语句来手动启动垃圾回收周期。然而，请注意，`runtime.GC()`会阻塞调用者，它可能会阻塞整个程序，尤其是如果你正在运行一个非常繁忙的Go程序，并且有很多对象时。这主要是因为当其他一切都在快速变化时，你不能执行垃圾回收，因为这不会给GC提供清楚地识别白色、黑色和灰色集合成员的机会。这种垃圾回收状态也被称为垃圾回收安全点。
- en: You can find the long and relatively advanced Go code of the GC at [https://github.com/golang/go/blob/master/src/runtime/mgc.go](https://github.com/golang/go/blob/master/src/runtime/mgc.go),
    which you can study if you want to learn even more information about the garbage
    collection operation. You can even make changes to that code if you are brave
    enough!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/golang/go/blob/master/src/runtime/mgc.go](https://github.com/golang/go/blob/master/src/runtime/mgc.go)找到GC的较长且相对高级的Go代码，如果你想要了解更多关于垃圾回收操作的信息，你可以研究这段代码。如果你足够勇敢，甚至可以修改这段代码！
- en: More about the operation of the Go GC
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于Go GC的操作更多
- en: This section talks more about the Go GC and presents additional information
    about its activities. The main concern of the Go GC is low latency, which basically
    means short pauses in its operation in order to have real-time operation. On the
    other hand, what a program does is create new objects and manipulate existing
    objects with pointers all the time. This process can end up creating objects that
    cannot be accessed anymore because there are no pointers pointing to these objects.
    These objects are then garbage and wait for the GC to clean them up and free their
    memory space. After that, the memory space that has been freed is ready to be
    used again.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将更详细地讨论Go GC，并展示其活动的一些额外信息。Go GC的主要关注点是低延迟，这基本上意味着在操作中保持短暂的暂停，以便实现实时操作。另一方面，程序一直在创建新的对象，并通过指针操作现有的对象。这个过程可能会导致无法访问的对象，因为没有指针指向这些对象。这些对象随后成为垃圾，等待GC清理并释放其内存空间。之后，释放的内存空间就可以再次使用了。
- en: The mark-and-sweep algorithm is the simplest algorithm used. The algorithm stops
    the program execution (**stop-the-world GC**) in order to visit all the accessible
    objects of the heap of a program and marks them. After that, it sweeps the inaccessible
    objects. During the mark phase of the algorithm, each object is marked as white,
    gray, or black. The children of a gray object are colored gray, whereas the original
    gray object is then colored black. The sweep phase begins when there are no more
    gray objects to examine. This technique works because there are no pointers from
    the black set to the white set, which is a fundamental invariant of the algorithm.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 标记-清除算法是使用最简单的算法。该算法为了访问程序堆中所有可访问的对象并对其进行标记，会停止程序执行（**停止世界GC**）。之后，它清除不可访问的对象。在算法的标记阶段，每个对象被标记为白色、灰色或黑色。灰色对象的子对象被着色为灰色，而原始的灰色对象随后被着色为黑色。当没有更多灰色对象需要检查时，开始清除阶段。这种技术之所以有效，是因为黑色集合中没有指针指向白色集合，这是算法的一个基本不变量。
- en: Although the mark-and-sweep algorithm is simple, it suspends the execution of
    the program while it is running, which means that it adds latency to the actual
    process. Go tries to lower that latency by running the GC as a concurrent process
    and by using the tri-color algorithm described in the previous section. However,
    other processes can move pointers or create new objects while the GC runs concurrently.
    This fact can make things difficult for the GC.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管标记-清除算法很简单，但在运行时它暂停了程序的执行，这意味着它给实际过程增加了延迟。Go试图通过将GC作为并发进程运行以及使用上一节中描述的三色算法来降低这种延迟。然而，当GC并发运行时，其他进程可以移动指针或创建新对象。这个事实可能会给GC带来困难。
- en: As a result, the basic principle that will allow the tri-color algorithm to
    operate concurrently while maintaining the fundamental invariant of the mark-and-sweep
    algorithm is that no object in the black set can point to an object in the white
    set.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，允许三色算法在保持标记-清除算法的基本不变量的同时并发运行的基本原则是，黑色集合中的任何对象都不能指向白色集合中的对象。
- en: The solution to this problem is fixing all the cases that can cause a problem
    for the algorithm. Therefore, new objects must go to the gray set because, this
    way, the fundamental invariant of the mark-and-sweep algorithm cannot be altered.
    Additionally, when a pointer of the program is moved, you color the object that
    the pointer points to as gray. The gray set acts like a barrier between the white
    set and the black set. Finally, each time a pointer is moved, some Go code gets
    automatically executed, which is the write barrier mentioned earlier, which does
    some recoloring. The latency introduced by the execution of the write barrier
    code is the price we have to pay for being able to run the GC concurrently.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是修复所有可能对算法造成问题的案例。因此，新对象必须进入灰色集合，因为这样，标记-清除算法的基本不变量就不会被改变。此外，当程序中的指针移动时，您将指针指向的对象着色为灰色。灰色集合在白色集合和黑色集合之间充当屏障。最后，每次指针移动时，都会自动执行一些Go代码，这就是前面提到的写屏障，它进行一些重新着色。执行写屏障代码引入的延迟是我们为了能够并发运行GC而必须付出的代价。
- en: Note that the Java programming language has many garbage collectors that are
    highly configurable with the help of multiple parameters. One of these Java garbage
    collectors is called G1 and it is recommended for low-latency applications. Although
    Go does not have multiple garbage collectors, it does have knobs that you can
    use to tune the garbage collector for your applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Java编程语言有许多垃圾收集器，这些收集器可以通过多个参数进行高度配置。其中之一是G1，它适用于低延迟应用。尽管Go没有多个垃圾收集器，但它确实有一些旋钮，您可以使用这些旋钮来调整应用程序的垃圾收集器。
- en: The section that follows discusses maps and slices from a garbage collection
    perspective because sometimes the way we handle variables influences the operation
    of the GC.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将从一个垃圾收集的角度讨论映射和切片，因为有时我们处理变量的方式会影响GC的操作。
- en: Maps, slices, and the Go GC
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射、切片和Go GC
- en: In this section, we discuss the operation of the Go GC in relation to maps and
    slices. The purpose of this section is to let you write code that makes the work
    of the GC easier.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论Go GC与映射和切片的关系操作。本节的目的让您编写使GC工作更简单的代码。
- en: Using slices
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用切片
- en: 'The example in this section uses a slice to store a large number of structures
    in order to show how slice allocation is related to the operation of the GC. Each
    structure stores two integer values. This is implemented in `sliceGC.go` as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例使用切片来存储大量结构，以展示切片分配与GC操作的关系。每个结构存储两个整数值。这通过`sliceGC.go`实现如下：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The last statement, (`_ = structure[0]`), is used to prevent the GC from garbage
    collecting the structure variable too early, as it is not referenced or used outside
    of the `for` loop. The same technique will be used in the three Go programs that
    follow. Apart from this important detail, a `for` loop is used for putting all
    values into structures that are stored in the structure slice variable. An equivalent
    way of doing that is the use of `runtime.KeepAlive()`. The program generates no
    output—it just triggers the GC using a call to `runtime.GC()`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句（`_ = structure[0]`）用于防止垃圾回收器过早地回收结构变量，因为它在`for`循环外部没有被引用或使用。接下来的三个Go程序也将使用同样的技术。除了这个重要的细节外，`for`循环用于将所有值放入存储在结构切片变量中的结构体中。另一种实现方式是使用`runtime.KeepAlive()`。程序不生成任何输出——它只是通过调用`runtime.GC()`来触发垃圾回收。
- en: Using maps with pointers
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指针映射
- en: 'In this subsection, we use a map for storing pointers. This time, the map uses
    integer keys that reference the pointers. The name of the program is `mapStar.go`
    and contains the following Go code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们使用映射来存储指针。这次，映射使用整数键来引用指针。程序名为`mapStar.go`，包含以下Go代码：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The operation of the program is the same as in `sliceGC.go` from the previous
    section. What differs is the use of a map (`make(map[int]*int)`) for storing the
    pointers to `int`. As before, the program produces no output.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的操作与上一节中的`sliceGC.go`相同。不同的是，它使用映射（`make(map[int]*int)`）来存储`int`的指针。与之前一样，程序没有生成任何输出。
- en: Using maps without pointers
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不使用指针的映射
- en: 'In this subsection, we use a map that stores integer values directly instead
    of pointers to integers. The important code of `mapNoStar.go` is the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们使用一个直接存储整数值的映射，而不是存储整数值的指针。`mapNoStar.go`中的重要代码如下：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once again, the program produces no output.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，程序没有生成任何输出。
- en: Splitting a map
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割映射
- en: 'In this last program, we use a different technique called sharding where we
    split one long map into a map of maps. The implementation of the `main()` function
    of `mapSplit.go` is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个程序中，我们使用了一种称为分片的不同技术，其中将一个长映射分割成映射的映射。`mapSplit.go`的`main()`函数的实现如下：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code uses two `for` loops, one for creating the map of maps and the other
    one for storing the desired data values in the map of maps.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用了两个`for`循环，一个用于创建映射的映射，另一个用于将所需的数据值存储在映射的映射中。
- en: As all four programs are using huge data structures, they are consuming large
    amounts of memory. Programs that consume lots of memory space trigger the Go GC
    more often. The next subsection presents an evaluation of the presented techniques.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有四个程序都使用大量数据结构，它们消耗了大量的内存。消耗大量内存空间的程序会触发Go GC的频率更高。下一小节将介绍对所提出技术的评估。
- en: Comparing the performance of the presented techniques
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较所提出技术的性能
- en: In this subsection, we compare the performance of each one of these four implementations
    using the time command of `zsh(1)`, which is pretty similar to the `time(1)` UNIX
    command. The purpose of the comparison is to understand how the allocation technique
    and the data structure used affect the performance of a program.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们使用`zsh(1)`命令的时间命令（与UNIX命令`time(1)`非常相似）比较这四种实现的性能。比较的目的是了解分配技术和使用的数据结构如何影响程序的性能。
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It turns out that **all map versions are slower than the slice version**. Unfortunately
    for maps, the map version will always be slower than the slice version because
    of the execution of the hash function and the fact that the data is not contiguous.
    **In maps, data is stored in a bucket determined by the output of the hash function**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，**所有映射版本都比切片版本慢**。不幸的是，对于映射来说，由于哈希函数的执行和数据的不连续性，映射版本将始终比切片版本慢。**在映射中，数据存储在由哈希函数输出确定的桶中**。
- en: Additionally, the first map program (`mapStar.go`) may trigger some GC slowdown
    because taking the address of `&value` will cause it to escape to the heap. Every
    other program is just using the stack for those locals. **When variables escape
    to the heap, they cause more garbage collection pressure**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，第一个地图程序（`mapStar.go`）可能会触发一些垃圾回收（GC）的减慢，因为获取`&value`的地址会导致它逃逸到堆上。其他所有程序只是使用栈来存储那些局部变量。**当变量逃逸到堆上时，它们会导致更多的垃圾回收压力**。
- en: Accessing an element of a map or a slice has `O(1)` runtime, which means that
    the access time does not depend on the number of elements found in the map or
    the slice. However, the way these structures work affects the overall speed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 访问映射或切片的元素具有`O(1)`的运行时间，这意味着访问时间不依赖于映射或切片中找到的元素数量。然而，这些结构的工作方式会影响整体速度。
- en: Additional resources
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'Go FAQ: How do I know whether a variable is allocated on the heap or the stack?
    [https://go.dev/doc/faq#stack_or_heap](https://go.dev/doc/faq#stack_or_heap)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go FAQ：我如何知道一个变量是在堆上还是在栈上分配的？[https://go.dev/doc/faq#stack_or_heap](https://go.dev/doc/faq#stack_or_heap)
- en: 'The list of available `-gcflags` options: [https://pkg.go.dev/cmd/compile](https://pkg.go.dev/cmd/compile.dev/doc/faq#stack_or_heap)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的`-gcflags`选项列表：[https://pkg.go.dev/cmd/compile](https://pkg.go.dev/cmd/compile.dev/doc/faq#stack_or_heap)
- en: If you want to learn more about garbage collection, you should visit [http://gchandbook.org/](http://gchandbook.org/)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于垃圾回收的信息，你应该访问[http://gchandbook.org/](http://gchandbook.org/)
- en: Leave a review!
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoyed this book? Help readers like you by leaving an Amazon review. Scan the
    QR code below to get a free eBook of your choice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评论来帮助像你这样的读者。扫描下面的二维码，获取你选择的免费电子书。
- en: '![](img/Review_QR_Code.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Review_QR_Code.png)'
