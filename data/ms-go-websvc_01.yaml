- en: Chapter 1. Our First API in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。我们在Go中的第一个API
- en: If you spend any time developing applications on the Web (or off it, for that
    matter), it won't be long before you find yourself facing the prospect of interacting
    with a web service or an API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您花费了时间在Web上开发应用程序（或者说，不管在哪里），您很快就会发现自己面临与Web服务或API进行交互的前景。
- en: Whether it's a library that you need or another application's sandbox with which
    you have to interact, the world of development relies in no small part on the
    cooperation among dissonant applications, languages, and formats.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是您需要的库还是必须与之交互的另一个应用程序的沙盒，开发世界在很大程度上依赖于不同应用程序、语言和格式之间的合作。
- en: That, after all, is why we have APIs to begin with—to allow standardized communication
    between any two given platforms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 毕竟，这就是我们拥有API的原因——允许任何两个给定平台之间的标准化通信。
- en: If you spend a long amount of time working on the Web, you'll encounter bad
    APIs. By *bad* we mean APIs that are not all-inclusive, do not adhere to best
    practices and standards, are confusing semantically, or lack consistency. You'll
    encounter APIs that haphazardly use OAuth or simple HTTP authentication in some
    places and the opposite in others, or more commonly, APIs that ignore the stated
    purposes of HTTP verbs (we will discuss more on this later in the chapter).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Web上花费了很长时间，您会遇到糟糕的API。所谓的*糟糕*是指不全面、不遵循最佳实践和标准、在语义上令人困惑或缺乏一致性的API。您会遇到一些API在某些地方随意使用OAuth或简单的HTTP身份验证，而在其他地方则相反，或者更常见的是，API忽略了HTTP动词的规定用途（我们将在本章后面更多地讨论这一点）。
- en: Google's Go language is particularly well suited to servers. With its built-in
    HTTP serving, a simple method for XML and JSON encoding of data, high availability,
    and concurrency, it is the ideal platform for your API.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的Go语言特别适用于服务器。具有内置的HTTP服务、数据的简单XML和JSON编码方法、高可用性和并发性，它是您的API的理想平台。
- en: Throughout this book, we'll not only explore a robust and clean API development
    but also its interaction with other APIs and data sources, and best practices
    for such development. We'll build one large service and a bunch of smaller ones
    for individual, self-contained lessons.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不仅将探讨强大而干净的API开发，还将探讨其与其他API和数据源的交互，以及此类开发的最佳实践。我们将构建一个大型服务和一堆小型服务，用于个别、独立的课程。
- en: Most importantly, by the end, you should be able to interact with any networked
    API in Go and be able to design and execute a well-polished API suite yourself.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，到最后，您应该能够在Go中与任何网络API进行交互，并能够自己设计和执行一个完善的API套件。
- en: This book requires at least a casual familiarity with the web-based APIs and
    a beginner's level competency in Go, but we'll do some very brief introductions
    when we discuss new concepts and steer you to more information if it turns out
    that you're not entirely versed in this aspect of either Go or APIs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书至少需要对基于Web的API有一定的了解，并且需要具备初学者水平的Go能力，但是当我们讨论新概念时，我们会进行一些非常简要的介绍，并引导您获取更多信息，以便了解Go或API的这一方面。
- en: We will also touch a bit on concurrency in Go, but we won't get too detailed—if
    you wish to learn more about this, please check out for the book authored by me,
    *Mastering Concurrency in Go*, *Packt Publishing*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将稍微涉及Go中的并发性，但我们不会过于详细——如果您希望了解更多，请查看我撰写的书籍*Mastering Concurrency in Go*，*Packt
    Publishing*。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Understanding requirements and dependencies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解要求和依赖关系
- en: Introducing the HTTP package
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍HTTP包
- en: Building our first routes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们的第一个路由
- en: Setting data via HTTP
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP设置数据
- en: Serving data from the datastore to the client
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据存储器向客户端提供数据
- en: Understanding requirements and dependencies
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解要求和依赖关系
- en: Before we get too deep into the weeds in this book, it would be a good idea
    for us to examine the things that you will need to have installed in order to
    handle all our examples as we develop, test, and deploy our APIs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中深入研究之前，我们最好先检查一下您需要安装的东西，以便处理我们开发、测试和部署API的所有示例。
- en: Installing Go
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Go
- en: It should go without saying that we will need to have the Go language installed.
    However, there are a few associated items that you will also need to install in
    order to do everything we do in this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，我们需要安装Go语言。但是，为了完成本书中的所有操作，您还需要安装一些相关项目。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Go is available for Mac OS X, Windows, and most common Linux variants. You can
    download the binaries at [http://golang.org/doc/install](http://golang.org/doc/install).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Go适用于Mac OS X、Windows和大多数常见的Linux变体。您可以在[http://golang.org/doc/install](http://golang.org/doc/install)下载二进制文件。
- en: On Linux, you can generally grab Go through your distribution's package manager.
    For example, you can grab it on Ubuntu with a simple `apt-get install golang`
    command. Something similar exists for most distributions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，您通常可以通过发行版的软件包管理器获取Go。例如，您可以通过简单的`apt-get install golang`命令在Ubuntu上获取它。大多数发行版都有类似的方法。
- en: In addition to the core language, we'll also work a bit with the Google App
    Engine, and the best way to test with the App Engine is to install the **Software
    Development Kit** (**SDK**). This will allow us to test our applications locally
    prior to deploying them and simulate a lot of the functionality that is provided
    only on the App Engine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了核心语言外，我们还将与Google App Engine一起工作，并且测试App Engine的最佳方法是安装**软件开发工具包**（**SDK**）。这将允许我们在部署之前在本地测试我们的应用程序，并模拟App
    Engine上提供的许多功能。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The App Engine SDK can be downloaded from [https://developers.google.com/appengine/downloads](https://developers.google.com/appengine/downloads).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: App Engine SDK可以从[https://developers.google.com/appengine/downloads](https://developers.google.com/appengine/downloads)下载。
- en: While we're obviously most interested in the Go SDK, you should also grab the
    Python SDK as there are some minor dependencies that may not be available solely
    in the Go SDK.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们显然最感兴趣的是Go SDK，但您还应该获取Python SDK，因为有一些小的依赖关系可能仅在Go SDK中不可用。
- en: Installing and using MySQL
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和使用MySQL
- en: We'll be using quite a few different databases and datastores to manage our
    test and real data, and MySQL will be one of the primary ones.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用许多不同的数据库和数据存储来管理我们的测试和真实数据，而MySQL将是其中之一。
- en: We will use MySQL as a storage system for our users; their messages and their
    relationships will be stored in our larger application (we will discuss more about
    this in a bit).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MySQL作为我们用户的存储系统；他们的消息和他们的关系将存储在我们的较大的应用程序中（我们稍后会更多地讨论这一点）。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: MySQL can be downloaded from [http://dev.mysql.com/downloads/](http://dev.mysql.com/downloads/).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL可以从[http://dev.mysql.com/downloads/](http://dev.mysql.com/downloads/)下载。
- en: 'You can also grab it easily from a package manager on Linux/OS X as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以轻松地从Linux/OS X的软件包管理器中获取它，方法如下：
- en: 'Ubuntu: `sudo apt-get install mysql-server mysql-client`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu：`sudo apt-get install mysql-server mysql-client`
- en: 'OS X with Homebrew: `brew install mysql`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OS X与Homebrew：`brew install mysql`
- en: Redis
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redis
- en: Redis is the first of the two NoSQL datastores that we'll be using for a couple
    of different demonstrations, including caching data from our databases as well
    as the API output.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是我们将用于几种不同演示的两种NoSQL数据存储之一，包括从我们的数据库缓存数据以及API输出。
- en: If you're unfamiliar with NoSQL, we'll do some pretty simple introductions to
    results gathering using both Redis and Couchbase in our examples. If you know
    MySQL, Redis will at least feel similar, and you won't need the full knowledge
    base to be able to use the application in the fashion in which we'll use it for
    our purposes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对NoSQL不熟悉，我们将在示例中使用Redis和Couchbase进行一些非常简单的结果收集介绍。如果您了解MySQL，那么Redis至少会感觉相似，您不需要完整的知识库来使用我们为我们的目的使用应用程序。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Redis can be downloaded from [http://redis.io/download](http://redis.io/download).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Redis可以从[http://redis.io/download](http://redis.io/download)下载。
- en: 'Redis can be downloaded on Linux/OS X using the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Redis可以在Linux/OS X上使用以下方式下载：
- en: 'Ubuntu: `sudo apt-get install redis-server`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu：`sudo apt-get install redis-server`
- en: 'OS X with Homebrew: `brew install redis`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OS X与Homebrew：`brew install redis`
- en: Couchbase
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Couchbase
- en: As mentioned earlier, Couchbase will be our second NoSQL solution that we'll
    use in various products, primarily to set short-lived or ephemeral key store lookups
    to avoid bottlenecks and as an experiment with in-memory caching.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，Couchbase将是我们将在各种产品中使用的第二个NoSQL解决方案，主要用于设置短暂或瞬时的键存储查找，以避免瓶颈，并作为内存缓存的实验。
- en: Unlike Redis, Couchbase uses simple REST commands to set and receive data, and
    everything exists in the JSON format.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与Redis不同，Couchbase使用简单的REST命令来设置和接收数据，而且所有内容都以JSON格式存在。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Couchbase can be downloaded from [http://www.couchbase.com/download](http://www.couchbase.com/download).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Couchbase可以从[http://www.couchbase.com/download](http://www.couchbase.com/download)下载。
- en: 'For Ubuntu (`deb`), use the following command to download Couchbase:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Ubuntu（`deb`），请使用以下命令下载Couchbase：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For OS X with Homebrew use the following command to download Couchbase:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于使用Homebrew的OS X，请使用以下命令下载Couchbase：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nginx
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nginx
- en: Although Go comes with everything you need to run a highly concurrent, performant
    web server, we're going to experiment with wrapping a reverse proxy around our
    results. We'll do this primarily as a response to the real-world issues regarding
    availability and speed. *Nginx is not available natively for Windows*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go自带了运行高并发、高性能Web服务器所需的一切，但我们将尝试在我们的结果周围包装一个反向代理。我们主要这样做是为了应对关于可用性和速度的现实问题。*Nginx在Windows上不是原生可用的*。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For Ubuntu, use the following command to download Nginx:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Ubuntu，请使用以下命令下载Nginx：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For OS X with Homebrew, use the following command to download Nginx:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于使用Homebrew的OS X，请使用以下命令下载Nginx：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Apache JMeter
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apache JMeter
- en: We'll utilize JMeter for benchmarking and tuning our API for performance. You
    have a bit of a choice here, as there are several stress-testing applications
    for simulating traffic. The two we'll touch on are **JMeter** and Apache's built-in
    **Apache Benchmark** (**AB**) platform. The latter is a stalwart in benchmarking
    but is a bit limited in what you can throw at your API, so JMeter is preferred.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用JMeter来对我们的API进行基准测试和调优。在这里您有一些选择，因为有几个模拟流量的压力测试应用程序。我们将涉及的两个是**JMeter**和Apache内置的**Apache
    Benchmark**（**AB**）平台。后者在基准测试中是一个坚定不移的选择，但在您可以向API发送的内容方面有些受限，因此更倾向于使用JMeter。
- en: One of the things that we'll need to consider when building an API is its ability
    to stand up to heavy traffic (and introduce some mitigating actions when it cannot),
    so we'll need to know what our limits are.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建API时，我们需要考虑的一件事是其抵御高流量的能力（以及在无法抵御时引入一些缓解措施），因此我们需要知道我们的限制是什么。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Apache JMeter can be downloaded from [http://jmeter.apache.org/download_jmeter.cgi](http://jmeter.apache.org/download_jmeter.cgi).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Apache JMeter可以从[http://jmeter.apache.org/download_jmeter.cgi](http://jmeter.apache.org/download_jmeter.cgi)下载。
- en: Using predefined datasets
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预定义数据集
- en: While it's not entirely necessary to have our dummy dataset throughout the course
    of this book, you can save a lot of time as we build our social network by bringing
    it in because it is full of users, posts, and images.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，虽然没有必要一直使用我们的虚拟数据集，但是当我们构建社交网络时，将其引入可以节省大量时间，因为它充满了用户、帖子和图片。
- en: By using this dataset, you can skip creating this data to test certain aspects
    of the API and API creation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个数据集，您可以跳过创建这些数据来测试API和API创建的某些方面。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our dummy dataset can be downloaded at [https://github.com/nkozyra/masteringwebservices](https://github.com/nkozyra/masteringwebservices).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的虚拟数据集可以从[https://github.com/nkozyra/masteringwebservices](https://github.com/nkozyra/masteringwebservices)下载。
- en: Choosing an IDE
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择IDE
- en: A choice of **Integrated Development Environment** (**IDE**) is one of the most
    personal choices a developer can make, and it's rare to find a developer who is
    not steadfastly passionate about their favorite.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成开发环境**（**IDE**）的选择是开发人员可以做出的最个人化的选择之一，很少有开发人员对自己喜欢的IDE不充满激情。'
- en: Nothing in this book will require one IDE over another; indeed, most of Go's
    strength in terms of compiling, formatting, and testing lies at the command-line
    level. That said, we'd like to at least explore some of the more popular choices
    for editors and IDEs that exist for Go.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中没有任何内容需要特定的IDE；事实上，Go在编译、格式化和测试方面的大部分优势都在命令行级别。不过，我们至少想探索一些Go的更受欢迎的编辑器和IDE选择。
- en: Eclipse
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Eclipse
- en: As one of the most popular and expansive IDEs available for any language, Eclipse
    is an obvious first mention. Most languages get their support in the form of an
    Eclipse plugin and Go is no exception.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为任何语言可用的最受欢迎和最广泛的IDE之一，Eclipse是一个显而易见的首选。大多数语言都通过Eclipse插件获得支持，Go也不例外。
- en: There are some downsides to this monolithic piece of software; it is occasionally
    buggy on some languages, notoriously slow for some autocompletion functions, and
    is a bit heavier than most of the other available options.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这款庞大的软件也有一些缺点；它在某些语言上偶尔会出现错误，有些自动完成功能的速度明显较慢，并且比大多数其他可用选项更加沉重。
- en: However, the pluses are myriad. Eclipse is very mature and has a gigantic community
    from which you can seek support when issues arise. Also, it's free to use.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它的优点是多方面的。Eclipse非常成熟，并且有一个庞大的社区，您可以在出现问题时寻求支持。而且，它是免费的。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Eclipse can be downloaded from [http://eclipse.org/](http://eclipse.org/)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse可以从[http://eclipse.org/](http://eclipse.org/)下载
- en: Get the Goclipse plugin at [http://goclipse.github.io/](http://goclipse.github.io/)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[http://goclipse.github.io/](http://goclipse.github.io/)获取Goclipse插件
- en: Sublime Text
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sublime Text
- en: Sublime Text is our particular favorite, but it comes with a large caveat—it
    is the only one listed here that is not free.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Sublime Text是我们特别喜欢的，但它有一个很大的警告——它是这里列出的唯一一个不免费的。
- en: This one feels more like a complete code/text editor than a heavy IDE, but it
    includes code completion options and the ability to integrate the Go compilers
    (or other languages' compilers) directly into the interface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这款软件更像是一个完整的代码/文本编辑器，而不是一个沉重的IDE，但它包括代码完成选项，并且可以直接将Go编译器（或其他语言的编译器）集成到界面中。
- en: Although Sublime Text's license costs $70, many developers find its elegance
    and speed to be well worth it. You can try out the software indefinitely to see
    if it's right for you; it operates as nagware unless and until you purchase a
    license.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Sublime Text的许可证价格为70美元，但许多开发人员发现它的优雅和速度是非常值得的。您可以无限期地尝试该软件，以查看它是否适合您；除非您购买许可证，否则它将作为催告软件运行。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sublime Text can be downloaded from [http://www.sublimetext.com/2](http://www.sublimetext.com/2).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Sublime Text可以从[http://www.sublimetext.com/2](http://www.sublimetext.com/2)下载。
- en: LiteIDE
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LiteIDE
- en: LiteIDE is a much younger IDE than the others mentioned here, but it is noteworthy
    because it has a focus on the Go language.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: LiteIDE是比其他提到的IDE更年轻的一个，但它值得一提，因为它专注于Go语言。
- en: It's cross-platform and does a lot of Go's command-line magic in the background,
    making it truly integrated. LiteIDE also handles code autocompletion, `go fmt`,
    build, run, and test directly in the IDE and a robust package browser.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它是跨平台的，并且在后台执行了很多Go的命令行魔术，使其真正集成。LiteIDE还可以在IDE中直接处理代码自动完成、`go fmt`、构建、运行和测试，以及强大的包浏览器。
- en: It's free and totally worth a shot if you want something lean and targeted directly
    for the Go language.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它是免费的，如果您想要一个精简且专门针对Go语言的工具，那么它绝对值得一试。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: LiteIDE can be downloaded from [https://code.google.com/p/golangide/](https://code.google.com/p/golangide/).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: LiteIDE可以从[https://code.google.com/p/golangide/](https://code.google.com/p/golangide/)下载。
- en: IntelliJ IDEA
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IntelliJ IDEA
- en: Right up there with Eclipse is the JetBrains family of IDE, which has spanned
    approximately the same number of languages as Eclipse. Ultimately, both are primarily
    built with Java in mind, which means that sometimes other language support can
    feel secondary.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与Eclipse齐名的是JetBrains系列的IDE，它涵盖了大约与Eclipse相同数量的语言。最终，两者都主要是以Java为主要考虑因素，这意味着有时其他语言的支持可能会次要。
- en: The Go integration here, however, seems fairly robust and complete, so it's
    worth a shot if you have a license. If you do not have a license, you can try
    the Community Edition, which is free.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的Go集成似乎相当强大和完整，因此如果您有许可证，那么它是值得一试的。如果您没有许可证，您可以尝试免费的Community Edition。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can download IntelliJ IDEA at [http://www.jetbrains.com/idea/download/](http://www.jetbrains.com/idea/download/)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从[http://www.jetbrains.com/idea/download/](http://www.jetbrains.com/idea/download/)下载IntelliJ
    IDEA
- en: The Go language support plugin is available at [http://plugins.jetbrains.com/plugin/?idea&id=5047](http://plugins.jetbrains.com/plugin/?idea&id=5047)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go语言支持插件可在[http://plugins.jetbrains.com/plugin/?idea&id=5047](http://plugins.jetbrains.com/plugin/?idea&id=5047)上获得
- en: Some client-side tools
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些客户端工具
- en: Although the vast majority of what we'll be covering will focus on Go and API
    services, we will be doing some visualization of client-side interactions with
    our API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将主要关注Go和API服务，但我们将对客户端与API的交互进行一些可视化。
- en: In doing so, we'll primarily focus on straight HTML and JavaScript, but for
    our more interactive points, we'll also rope in jQuery and AngularJS.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将主要关注纯HTML和JavaScript，但对于更多的交互点，我们还将使用jQuery和AngularJS。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most of what we do for client-side demonstrations will be available at this
    book's GitHub repository at [https://github.com/nkozyra/goweb](https://github.com/nkozyra/goweb)
    under client.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为客户端演示所做的大部分内容都可以在本书的GitHub存储库[https://github.com/nkozyra/goweb](https://github.com/nkozyra/goweb)的client目录下找到。
- en: Both jQuery and AngularJS can be loaded dynamically from Google's CDN, which
    will prevent you from having to download and store them locally. The examples
    hosted on GitHub call these dynamically.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery和AngularJS都可以从Google的CDN动态加载，这样您就不必在本地下载和存储它们。托管在GitHub上的示例会动态调用它们。
- en: 'To load AngularJS dynamically, use the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要动态加载AngularJS，请使用以下代码：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To load jQuery dynamically, use the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要动态加载jQuery，请使用以下代码：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Looking at our application
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看我们的应用程序
- en: Throughout this book, we'll be building myriad small applications to demonstrate
    points, functions, libraries, and other techniques. However, we'll also focus
    on a larger project that mimics a social network wherein we create and return
    to users, statuses, and so on, via the API.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将构建许多小应用程序来演示要点、函数、库和其他技术。但是，我们也将专注于一个更大的项目，模拟一个社交网络，在其中我们通过API创建和返回用户、状态等。
- en: Though we'll be working towards the larger application as a way to demonstrate
    each piece of the puzzle, we'll also build and test self-contained applications,
    APIs, and interfaces.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将致力于构建一个更大的应用程序来演示每个部分的拼图，但我们也将构建和测试独立的应用程序、API和接口。
- en: The latter group will be prefaced with a quick hitter to let you know that it's
    not part of our larger application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 后一组将以快速入门为前缀，以让您知道它不是我们更大应用程序的一部分。
- en: Setting up our database
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的数据库
- en: As mentioned earlier, we'll be designing a social network that operates almost
    entirely at the API level (at least at first) as our *master* project in this
    book.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将设计一个几乎完全在API级别上运行的社交网络（至少起初是这样），作为本书中的*主要*项目。
- en: 'When we think of the major social networks (from the past and in the present),
    there are a few omnipresent concepts endemic among them, which are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想到主要的社交网络（过去和现在），它们中有一些无处不在的概念，如下所示：
- en: The ability to create a user and maintain a user profile
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户并维护用户资料的能力
- en: The ability to share messages or statuses and have conversations based on them
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分享消息或状态并基于它们进行对话的能力
- en: The ability to express pleasure or displeasure on the said statuses/messages
    to dictate the worthiness of any given message
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达对所述状态/消息的喜好或厌恶，以决定任何给定消息的价值
- en: 'There are a few other features that we''ll be building here, but let''s start
    with the basics. Let''s create our database in MySQL as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些其他功能，我们将从这里开始构建，但让我们从基础知识开始。让我们按以下方式在MySQL中创建我们的数据库：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will be the basis of our social network product in this book. For now,
    we''ll just need a `users` table to store our individual users and their most
    basic information. We''ll amend this to include more features as we go along:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是本书中我们社交网络产品的基础。目前，我们只需要一个`users`表来存储我们的个人用户及其最基本的信息。随着我们的进展，我们将对其进行修改以包括更多功能：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We won't need to do too much in this chapter, so this should suffice. We'll
    have a user's most basic information—name, nickname, and e-mail, and not much
    else.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不需要做太多事情，所以这就够了。我们将拥有用户的最基本信息——姓名、昵称和电子邮件，没有太多其他信息。
- en: Introducing the HTTP package
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍HTTP包
- en: The vast majority of our API work will be handled through REST, so you should
    become pretty familiar with Go's `http` package.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分API工作将通过REST处理，因此您应该对Go的`http`包非常熟悉。
- en: In addition to serving via HTTP, the `http` package comprises of a number of
    other very useful utilities that we'll look at in detail. These include cookie
    jars, setting up clients, reverse proxies, and more.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过HTTP提供服务外，`http`包还包括许多其他非常有用的实用程序，我们将详细了解这些实用程序。这些包括cookie jars、设置客户端、反向代理等。
- en: The primary entity about which we're interested right now, though, is the `http.Server`
    struct, which provides the very basis of all of our server's actions and parameters.
    Within the server, we can set our TCP address, HTTP multiplexing for routing specific
    requests, timeouts, and header information.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但目前我们感兴趣的主要实体是`http.Server`结构，它提供了我们服务器所有操作和参数的基础。在服务器内部，我们可以设置TCP地址、用于路由特定请求的HTTP多路复用、超时和标头信息。
- en: 'Go also provides some shortcuts for invoking a server without directly initializing
    the struct. For example, if you have a lot of default properties, you could use
    the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Go还提供了一些快捷方式来调用服务器，而不是直接初始化结构。例如，如果您有许多默认属性，您可以使用以下代码：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can simply execute using the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以简单地使用以下代码执行：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will invoke a server struct for you and set only the `Addr` and `Handler`
    properties within.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您调用一个服务器结构并仅设置`Addr`和`Handler`属性。
- en: There will be times, of course, when we'll want more granular control over our
    server, but for the time being, this will do just fine. Let's take this concept
    and output some JSON data via HTTP for the first time.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时我们会想要更精细地控制我们的服务器，但目前这样就够了。让我们首次将这个概念输出一些JSON数据通过HTTP。
- en: Quick hitter – saying Hello, World via API
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速入门-通过API说Hello, World
- en: As mentioned earlier in this chapter, we'll go off course and do some work that
    we'll preface with **quick hitter** to denote that it's unrelated to our larger
    project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，我们将偏离原题，做一些我们将以**快速入门**为前缀的工作，以示它与我们更大的项目无关。
- en: In this case, we just want to rev up our `http` package and deliver some JSON
    to the browser. Unsurprisingly, we'll be merely outputting the uninspiring `Hello,
    world` message to, well, the world.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只想激活我们的`http`包并向浏览器传递一些JSON。毫不奇怪，我们只会向世界输出令人沮丧的`Hello, world`消息。
- en: 'Let''s set this up with our required package and imports:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用所需的包和导入来设置这个：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the bare minimum that we need to output a simple string in JSON via
    HTTP. Marshalling JSON data can be a bit more complex than what we'll look at
    here, so if the struct for our message doesn't immediately make sense, don't worry.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要通过HTTP输出简单的JSON字符串的最低要求。编组JSON数据可能比我们在这里看到的要复杂一些，所以如果我们的消息结构不立即让人明白，不要担心。
- en: 'This is our response struct, which contains all of the data that we wish to
    send to the client after grabbing it from our API:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的响应结构，包含我们希望从API中获取并发送给客户端的所有数据：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There is not a lot here yet, obviously. All we're setting is a single message
    string in the obviously-named `Message` variable.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 显然这里还没有太多东西。我们只设置了一个消息字符串，显然命名为`Message`变量。
- en: 'Finally, we need to set up our main function (as follows) to respond to a route
    and deliver a marshaled JSON response:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要设置我们的主要函数（如下所示）来响应路由并提供一个经过编组的JSON响应：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Upon entering `main()`, we set a route handling function to respond to requests
    at `/api` that initializes an API struct with `Hello, world!` We then marshal
    this to a JSON byte array, `output`, and after sending this message to our `iowriter`
    class (in this case, an `http.ResponseWriter` value), we cast that to a string.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`main()`后，我们设置了一个路由处理函数，以响应在`/api`处初始化一个带有`Hello, world!`的API结构。然后我们将其编组为JSON字节数组`output`，并在将此消息发送到我们的`iowriter`类（在本例中为`http.ResponseWriter`值）后，将其转换为字符串。
- en: The last step is a kind of quick-and-dirty approach for sending our byte array
    through a function that expects a string, but there's not much that could go wrong
    in doing so.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是一种快速而粗糙的方法，通过一个期望字符串的函数发送我们的字节数组，但在这样做时几乎不会出现什么问题。
- en: Go handles typecasting pretty simply by applying the type as a function that
    flanks the target variable. In other words, we can cast an `int64` value to an
    integer by simply surrounding it with the `int(OurInt64)` function. There are
    some exceptions to this—types that cannot be directly cast and some other pitfalls,
    but that's the general idea. Among the possible exceptions, some types cannot
    be directly cast to others and some require a package like `strconv` to manage
    typecasting.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Go通过将类型作为环绕目标变量的函数来简单处理类型转换。换句话说，我们可以通过简单地用`int(OurInt64)`函数将`int64`值转换为整数来进行类型转换。当然，也有一些例外情况——一些类型不能直接转换，还有一些其他陷阱，但这是一般的想法。在可能的例外情况中，一些类型不能直接转换为其他类型，有些需要像`strconv`这样的包来管理类型转换。
- en: 'If we head over to our browser and call `localhost:8080/api` (as shown in the
    following screenshot), you should get exactly what we expect, assuming everything
    went correctly:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中输入`localhost:8080/api`（如下截图所示），您应该会得到我们期望的结果，假设一切都正确：
- en: '![Quick hitter – saying Hello, World via API](img/1304OS_01_01.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![快速命中-通过API说Hello, World](img/1304OS_01_01.jpg)'
- en: Building our first route
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个路由
- en: When we talk about routing in Go nomenclature, we're more accurately discussing
    a multiplexer or `mux`. In this case, the multiplexer refers to taking URLs or
    URL patterns and translating them into internal functions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论Go术语中的路由时，我们更准确地讨论的是多路复用器或`mux`。在这种情况下，多路复用器指的是将URL或URL模式转换为内部函数。
- en: 'You can think of this as a simple mapping from a request to a function (or
    a handler). You might draw up something like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这看作是从请求到函数（或处理程序）的简单映射。您可能会设计出类似以下的东西：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are some limitations with the built-in mux/router provided by the `net/http`
    package. You cannot, for example, supply a wildcard or a regular expression to
    a route.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包提供的内置mux/router存在一些限制。例如，您不能为路由提供通配符或正则表达式。'
- en: 'You might expect to be able to do something as discussed in the following code
    snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能期望能够像下面的代码片段中所讨论的那样做一些事情：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: However, this results in a parsing error.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会导致解析错误。
- en: If you've spent any serious time in any mature web API, you'll know that this
    won't do. We need to be able to react to dynamic and unpredictable requests. By
    this we mean that anticipating every numerical user is untenable as it relates
    to mapping to a function. We need to be able to accept and use patterns.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在任何成熟的Web API中花费了一些时间，您会知道这是行不通的。我们需要能够对动态和不可预测的请求做出反应。这意味着无法预料每个数字用户与函数的映射是不可行的。我们需要能够接受和使用模式。
- en: There are a few solutions for this problem. The first is to use a third-party
    platform that has this kind of robust routing built in. There are a few very good
    platforms to choose from, so we'll quickly look at these now.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题有一些解决方案。第一个是使用具有这种强大路由功能的第三方平台。有一些非常好的平台可供选择，所以我们现在快速看一下这些。
- en: Gorilla
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gorilla
- en: Gorilla is an all-inclusive web framework, and one that we'll use quite a bit
    in this book. It has precisely the kind of URL routing package that we need (in
    its `gorilla/mux` package), and it also supplies some other very useful tools,
    such as JSON-RPC, secure cookies, and global session data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla是一个全面的Web框架，我们在本书中会经常使用它。它具有我们需要的精确的URL路由包（在其`gorilla/mux`包中），并且还提供一些其他非常有用的工具，如JSON-RPC、安全cookie和全局会话数据。
- en: Gorilla's `mux` package lets us use regular expressions, but it also has some
    shorthand expressions that let us define the kind of request string we expect
    without having to write out full expressions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla的`mux`包让我们可以使用正则表达式，但它也有一些简写表达式，让我们定义我们期望的请求字符串类型，而不必写出完整的表达式。
- en: 'For example, if we have a request like `/api/users/309`, we can simple route
    it as follows in Gorilla:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个像`/api/users/309`这样的请求，我们可以在Gorilla中简单地路由它如下：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, there is a clear risk in doing so—by leaving this so open-ended, we
    have the potential to get some data validation issues. If this function accepts
    anything as a parameter and we expect digits or text only, this will cause problems
    in our underlying application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做存在明显的风险——通过让这一切如此开放，我们有可能遇到一些数据验证问题。如果这个函数接受任何参数，而我们只期望数字或文本，这将在我们的基础应用程序中造成问题。
- en: 'So, Gorilla allows us to clarify this with regular expressions, which are as
    follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Gorilla允许我们使用正则表达式来澄清这一点，如下所示：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And now, we will only get what we expect—digit-based request parameters. Let''s
    modify our previous example with this concept to demonstrate this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只会得到我们期望的——基于数字的请求参数。让我们修改我们之前的示例，以演示这个概念：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: 'With this code, we have some validation at the routing level. A valid request
    to `/api/44` will give us a proper response, as shown in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们在路由级别上进行了一些验证。对`/api/44`的有效请求将给我们一个正确的响应，如下面的屏幕截图所示：
- en: '![Gorilla](img/1304OS_01_02.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![大猩猩](img/1304OS_01_02.jpg)'
- en: An invalid request to something like `/api/nkozyra` will give us a 404 response.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对`/api/nkozyra`之类的无效请求将给我们一个404响应。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can download the Gorilla web toolkit from [http://www.gorillatoolkit.org/](http://www.gorillatoolkit.org/)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从[http://www.gorillatoolkit.org/](http://www.gorillatoolkit.org/)下载Gorilla
    web工具包
- en: The documentation on its URL multiplexer can be found at [http://www.gorillatoolkit.org/pkg/mux](http://www.gorillatoolkit.org/pkg/mux)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其URL多路复用器的文档可以在[http://www.gorillatoolkit.org/pkg/mux](http://www.gorillatoolkit.org/pkg/mux)找到
- en: Routes
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: Routes, from `drone.io`, is explicitly and solely a routing package for Go.
    This makes it much more focused than the Gorilla web toolkit.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`drone.io`的Routes，明确且专门用于Go的路由包。这使它比Gorilla web工具包更加专注。
- en: For the most part, URL routing will not be a bottleneck in a smaller application,
    but it's something that should be considered as your application scales. For our
    purpose, the differences in speed between, say, Gorilla and Routes is negligible.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在较小的应用程序中，URL路由大多数情况下不会成为瓶颈，但随着应用程序规模的扩大，这是需要考虑的事情。对于我们的目的，例如Gorilla和Routes之间的速度差异是可以忽略不计的。
- en: 'Defining your `mux` package in routes is very clean and simple. Here is a variation
    on our `Hello world` message that responds to URL parameters:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在routes中定义您的`mux`包非常干净简单。这是对我们的`Hello world`消息的一个变体，它响应URL参数：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The primary difference here (as with Gorilla) is that we''re passing our `routes`
    multiplexer to `http` instead of using the internal one. And as with Gorilla,
    we can now use variable URL patterns to change our output, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别（与Gorilla一样）是我们将我们的`routes`多路复用器传递给`http`，而不是使用内部的多路复用器。与Gorilla一样，我们现在可以使用可变的URL模式来更改我们的输出，如下所示：
- en: '![Routes](img/1304OS_01_03.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![路由](img/1304OS_01_03.jpg)'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about routes and how to install them at: [https://github.com/drone/routes](https://github.com/drone/routes).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/drone/routes](https://github.com/drone/routes)了解有关路由及其安装方法的更多信息。
- en: 'Run the following command to install routes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令安装路由：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Setting data via HTTP
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过HTTP设置数据
- en: Now that we've examined how we're going to handle routing, let's take a stab
    at injecting data into our database directly from a REST endpoint.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了如何处理路由，让我们尝试直接从REST端点向数据库中注入数据。
- en: In this case, we'll be looking exclusively at the `POST` request methods because
    in most cases when large amounts of data could be transferred, you want to avoid
    the length limitations that the `GET` requests impose.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将专门查看`POST`请求方法，因为在大多数情况下，当可能传输大量数据时，您希望避免`GET`请求所施加的长度限制。
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Technically, a `PUT` request is the semantically correct method to use for requests
    that are made to create data in the **create-read-update-delete** (**CRUD**) concept,
    but years of disuse have largely relegated `PUT` to a historical footnote. Recently,
    some support for restoring `PUT` (and `DELETE`) to their proper place has taken
    hold. Go (and Gorilla) will gladly allow you to relegate requests to either and
    as we go forward, we'll move towards more protocol-valid semantics.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`PUT`请求是在**创建-读取-更新-删除**（CRUD）概念中用于创建数据的语义上正确的方法，但多年来，`PUT`在很大程度上被边缘化为历史脚注。最近，一些支持将`PUT`（和`DELETE`）恢复到其适当位置的做法已经开始流行。Go（和Gorilla）将乐意允许您将请求委托给任何一个，并且在我们继续前进时，我们将朝着更符合协议的语义发展。
- en: Connecting to MySQL
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到MySQL
- en: Go has a largely built-in agnostic database connection facility, and most third-party
    database connectivity packages yield to it. Go's default SQL package is `database/sql`,
    and it allows more general database connectivity with some standardization.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Go具有一个内置的通用数据库连接设施，大多数第三方数据库连接包都会让步于它。Go的默认SQL包是`database/sql`，它允许更一般的数据库连接，并具有一些标准化。
- en: However, rather than rolling our own MySQL connection (for now, at least), we'll
    yield to a third-party add-on library. There are a couple of these libraries that
    are available, but we'll go with `Go-MySQL-Driver`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们暂时不会自己编写MySQL连接，而是使用第三方附加库。有几个可用的库，但我们将选择`Go-MySQL-Driver`。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can install `Go-MySQL-Driver` using the following command (it requires
    Git):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令安装`Go-MySQL-Driver`（需要Git）：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For the purpose of this example, we'll assume that you have MySQL running with
    a localhost on the `3306` standard port. If it is not running, then please make
    the necessary adjustments accordingly in the examples. The examples here will
    also use a passwordless root account for the sake of clarity.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将假设您的MySQL在标准端口`3306`上以localhost运行。如果它没有运行，请相应地进行必要的调整。这里的示例也将使用无密码的root帐户，以便清晰起见。
- en: 'Our imports will remain largely the same but with two obvious additions: the
    `sql` package (`database/sql`) and the aforementioned MySQL driver that is imported
    solely for side effects by prepending it with an underscore:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的导入基本上保持不变，但有两个明显的添加：`sql`包（`database/sql`）和前面提到的仅用于副作用的MySQL驱动，通过在其前面加下划线导入：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ll set a new endpoint using Gorilla. You may recall that when we intend
    to set or create data, we''ll generally push for a `PUT` or `POST` verb, but for
    the purposes of this demonstration, appending URL parameters is the easiest way
    to push data. Here is how we''d set up this new route:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Gorilla设置一个新的端点。您可能还记得，当我们打算设置或创建数据时，我们通常会推动`PUT`或`POST`动词，但出于演示目的，通过附加URL参数是推送数据的最简单方式。以下是我们设置这个新路由的方法：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we're specifying the verbs that we'll accept for this request. In
    real usage, this is recommended for the `GET` requests.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在指定我们将接受此请求的动词。在实际使用中，这是推荐的`GET`请求。
- en: 'Our `CreateUser` function will accept several parameters—`user`, `email`, `first`,
    and `last`. `User` represents a short user name and the rest should be self-explanatory.
    We''ll precede our code with the definition of a `User` struct as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CreateUser`函数将接受几个参数——`user`、`email`、`first`和`last`。`User`代表一个简短的用户名，其余的应该是不言自明的。我们将在代码之前定义一个`User`结构体，如下所示：
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And now let''s take a look at the `CreateUser` function itself:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`CreateUser`函数本身：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we run this, our routed API endpoint should be available at `localhost:8080/api/user/create`.
    Though if you look at the call itself, you''ll note that we need to pass URL parameters
    to create a user. We''re not yet doing any sanity checking on our input, nor are
    we making certain it''s clean/escaped, but we''ll hit the URL as follows: `http://localhost:8080/api/user/create?user=nkozyra&first=Nathan&last=Kozyra&email=nathan@nathankozyra.com`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，我们的路由API端点应该在`localhost:8080/api/user/create`可用。尽管如果你看一下调用本身，你会注意到我们需要传递URL参数来创建一个用户。我们还没有对我们的输入进行任何合理性检查，也没有确保它是干净的/转义的，但我们将按照以下方式访问URL：`http://localhost:8080/api/user/create?user=nkozyra&first=Nathan&last=Kozyra&email=nathan@nathankozyra.com`。
- en: 'And then, we''ll end up with a user created in our `users` table, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在我们的`users`表中创建一个用户，如下所示：
- en: '![Connecting to MySQL](img/1304OS_01_04.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![连接到MySQL](img/1304OS_01_04.jpg)'
- en: Serving data from the datastore to the client
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据存储中向客户端提供数据
- en: 'Obviously, if we start setting data via API endpoint—albeit crudely—we''ll
    also want to retrieve the data via another API endpoint. We can easily amend our
    current call using the following code to include a new route that provides the
    data back via a request:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们开始通过API端点设置数据，尽管很简单，我们也希望通过另一个API端点检索数据。我们可以轻松地修改我们当前的调用，使用以下代码包括一个提供数据返回的新路由：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''re doing a couple of new and noteworthy things here. First, we''re using
    a `QueryRow()` method instead of `Exec()`. Go''s default database interface offers
    a couple of different querying mechanisms that do slightly different things. These
    are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了一些新的和值得注意的事情。首先，我们使用了`QueryRow()`方法而不是`Exec()`。Go的默认数据库接口提供了一些稍有不同的查询机制。具体如下：
- en: '`Exec()`: This method is used for queries (`INSERT`, `UPDATE`, and `DELETE`
    primarily) that will not return rows.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exec()`: 该方法用于查询（主要是`INSERT`、`UPDATE`和`DELETE`），不会返回行。'
- en: '`Query()`: This method is used for queries that will return one or more rows.
    This is usually designated for the `SELECT` queries.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Query()`: 该方法用于返回一个或多个行的查询。这通常用于`SELECT`查询。'
- en: '`QueryRow()`: This method is like `Query()`, but it expects just one result.
    This is typically a row-based request similar to the one we had in our previous
    example. We can then run the `Scan()` method on that row to inject the returned
    values into our struct''s properties.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QueryRow()`: 该方法类似于`Query()`，但它只期望一个结果。这通常是一个基于行的请求，类似于我们在之前的例子中所做的。然后我们可以在该行上运行`Scan()`方法，将返回的值注入到我们结构体的属性中。'
- en: Since we're scanning the returned data into our struct, we don't get a return
    value. With the `err` value, we run a switch to determine how to convey a response
    to the user or the application that's using our API.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在将返回的数据扫描到我们的结构体中，我们不会得到返回值。通过`err`值，我们运行一个开关来确定如何向用户或使用我们的API的应用程序传达响应。
- en: If we have no rows, it is likely that there is an error in the request and we'll
    let the recipient know that an error exists.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有行，很可能是请求中存在错误，我们会让接收方知道存在错误。
- en: However, if there is a SQL error, then we'll stay quiet for now. It's a bad
    practice to expose internal errors to the public. However, we should respond that
    something went wrong without being too specific.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果有SQL错误，我们现在会保持安静。将内部错误暴露给公众是一种不好的做法。但是，我们应该回应出现了问题，而不要太具体。
- en: 'Finally, if the request is valid and we get a record, we will marshal that
    into a JSON response and cast it to a string before returning it. Our following
    result looks like what we''d expect for a valid request:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果请求有效并且我们得到一条记录，我们将将其编组为JSON响应，并在返回之前将其转换为字符串。我们的下一个结果看起来像我们对有效请求的期望：
- en: '![Serving data from the datastore to the client](img/1304OS_01_05.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![从数据存储中向客户端提供数据](img/1304OS_01_05.jpg)'
- en: 'And then, it appropriately returns an error (as shown in the following screenshot)
    if we request a particular record from our users'' table that does not actually
    exist:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们从我们的用户表中请求一个实际上不存在的特定记录，它将适当地返回错误（如下面的截图所示）：
- en: '![Serving data from the datastore to the client](img/1304OS_01_06.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![从数据存储中向客户端提供数据](img/1304OS_01_06.jpg)'
- en: Setting headers to add detail for clients
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置标题以为客户端添加细节
- en: Something that will come up a bit more as we go on is the idea of using HTTP
    headers to convey important information about the data that we're sending or accepting
    via the API.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，更多地使用HTTP头部来传达关于我们通过API发送或接受的数据的重要信息的想法将会更加突出。
- en: 'We can quickly look at the headers that are being sent through our API now
    by running a `curl` request against it. When we do, we''ll see something like
    this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对其运行`curl`请求来快速查看通过我们的API发送的标头。当我们这样做时，我们会看到类似于这样的东西：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is a pretty small set of headers that is sent by Go, by default. As we
    go forward, we may wish to append more informative headers that tell a recipient
    service how to handle or cache data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Go默认发送的一个相当小的头部集合。随着我们的前进，我们可能希望附加更多的信息头，告诉接收服务如何处理或缓存数据。
- en: Let's very briefly try to set some headers and apply them to our request using
    the `http` package. We'll start with one of the more basic response headers and
    set a Pragma. This is a `no-cache` Pragma on our result set to tell users or services
    that ingest our API to always request a fresh version from our database.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们非常简要地尝试设置一些头部，并将它们应用到我们的请求中，使用`http`包。我们将从更基本的响应头开始，并设置一个Pragma。这是一个`no-cache`
    Pragma，告诉使用我们的API的用户或服务始终从我们的数据库请求最新版本。
- en: Ultimately, given the data we're working with, this is unnecessary in this case,
    but is the simplest way to demonstrate this behavior. We may find going forward
    that endpoint caching helps with performance, but it may not provide us with the
    freshest data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，鉴于我们正在处理的数据，在这种情况下这是不必要的，但这是演示这种行为的最简单的方法。我们可能会发现，随着前进，端点缓存有助于性能，但它可能不会为我们提供最新的数据。
- en: 'The `http` package itself has a pretty simple method for both setting response
    headers and getting request headers. Let''s modify our `GetUser` function to tell
    other services that they should not cache this data:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`http`包本身有一个非常简单的方法，既可以设置响应头，也可以获取请求头。让我们修改我们的`GetUser`函数，告诉其他服务他们不应该缓存这些数据：'
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Header()` method returns the `Header` struct of `iowriter`, which we can
    then add directly using `Set()` or get by using values using `Get()`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Header()`方法返回`iowriter`的`Header`结构，我们可以直接使用`Set()`添加，或者使用`Get()`获取值。'
- en: 'Now that we''ve done that, let''s see how our output has changed:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经做到了，让我们看看我们的输出如何改变：
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we'd expect, we now see our value directly in CURL's header information and
    it properly returns that this result should not be cached.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的，我们现在直接在CURL的头信息中看到我们的值，并且它正确地返回这个结果不应该被缓存。
- en: There are, of course, far more valuable response headers that we can send with
    web services and APIs, but this is a good start. As we move forward, we'll utilize
    more of these, including `Content-Encoding`, `Access-Control-Allow-Origin`, and
    more headers that allow us to specify what our data is, who can access it, and
    what they should expect in terms of formatting and encoding.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以发送更有价值的响应头，与web服务和API一起发送，但这是一个很好的开始。随着我们的前进，我们将利用更多的这些，包括`Content-Encoding`、`Access-Control-Allow-Origin`和更多的头部，允许我们指定我们的数据是什么，谁可以访问它，以及他们应该期望的格式和编码。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've touched on the very basics of developing a simple web service interface
    in Go. Admittedly, this particular version is extremely limited and vulnerable
    to attack, but it shows the basic mechanisms that we can employ to produce usable,
    formalized output that can be ingested by other services.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涉及了在Go中开发简单web服务接口的基础知识。诚然，这个特定版本非常有限且容易受攻击，但它展示了我们可以采用的基本机制，以产生可用的、正式的输出，可以被其他服务接收。
- en: At this point, you should have the basic tools at your disposal that are necessary
    to start refining this process and our application as a whole. We'll move forward
    with applying a fuller design to our API as we push forward, as two randomly chosen
    API endpoints will obviously not do much for us.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该已经掌握了开始完善这个过程和我们整个应用所需的基本工具。随着我们的推进，我们将应用更完整的设计到我们的API中，因为随机选择的两个API端点显然对我们没有太大帮助。
- en: In our next chapter, we'll dive in deeper with API planning and design, the
    nitty-gritty of RESTful services, and look at how we can separate our logic from
    our output. We'll briefly touch on some logic/view separation concepts and move
    toward more robust endpoints and methods in [Chapter 3](ch03.html "Chapter 3. Routing
    and Bootstrapping"), *Routing and Bootstrapping*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究API规划和设计，RESTful服务的细节，以及如何将逻辑与输出分离。我们将简要涉及一些逻辑/视图分离的概念，并在[第3章](ch03.html
    "第3章。路由和引导")中向更健壮的端点和方法迈进，*路由和引导*。
