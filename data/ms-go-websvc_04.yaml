- en: Chapter 4. Designing APIs in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。在Go中设计API
- en: We've now barreled through the basics of REST, handling URL routing, and multiplexing
    in Go, either directly or through a framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了REST的基础知识，处理URL路由和在Go中进行多路复用，无论是直接还是通过框架。
- en: Hopefully, creating the skeleton of our API has been useful and informative,
    but we need to fill in some major blanks if we're going to design a functioning
    REST-compliant web service. Primarily, we need to handle versions, all endpoints,
    and the `OPTIONS` headers as well as multiple formats in an elegant, easy way
    that can be managed going forward.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 希望创建我们的API的框架已经有所帮助和启发，但是如果我们要设计一个功能齐全的符合REST标准的Web服务，我们需要填补一些重要的空白。主要是，我们需要处理版本、所有端点和`OPTIONS`头，以及以一种优雅且易于管理的方式处理多种格式。
- en: We're going to flesh out the endpoints we want to lay out for an API-based application
    that allows clients to get all of the information they need about our application
    as well as create and update users, with valuable error information relating to
    both the endpoints.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将完善我们想要为基于API的应用程序制定的端点，该应用程序允许客户端获取关于我们应用程序的所有信息，以及创建和更新用户，并提供与这些端点相关的有价值的错误信息。
- en: By the end of this chapter, you should also be able to switch between REST and
    WebSocket applications as we'll build a very simple WebSocket example with a built-in
    client-side testing interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您还应该能够在REST和WebSocket应用程序之间切换，因为我们将构建一个非常简单的WebSocket示例，并带有内置的客户端测试界面。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Outlining and designing our complete social network API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述和设计我们完整的社交网络API
- en: Handling code organization and the basics of API versioning
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理代码组织和API版本控制的基础知识
- en: Allowing multiple formats (XML and JSON) for our API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们的API使用多种格式（XML和JSON）
- en: A closer look at WebSockets and implementing them in Go
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细研究WebSockets并在Go中实现它们
- en: Creating more robust and descriptive error reporting
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建更健壮和描述性的错误报告
- en: Updating user records via the API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过API更新用户记录
- en: At the end of this chapter, you should be able to elegantly handle multiple
    formats and versions of your REST Web Services and have a better understanding
    of utilizing WebSockets within Go.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您应该能够优雅地处理REST Web服务的多种格式和版本，并更好地理解如何在Go中利用WebSockets。
- en: Designing our social network API
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的社交网络API
- en: Now that we've gotten our feet wet a bit by making Go output data in our web
    service, one important step to take now is to fully flesh out what we want our
    major project's API to do.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过让Go输出我们Web服务中的数据来初步了解了一些，现在要采取的一个重要步骤是充分完善我们希望我们的主要项目的API要做什么。
- en: Since our application is a social network, we need to focus not only on user
    information but also on connections and messaging. We'll need to make sure that
    new users can share information with certain groups, make and modify connections,
    and handle authentication.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序是一个社交网络，我们不仅需要关注用户信息，还需要关注连接和消息传递。我们需要确保新用户可以与某些群体共享信息，建立和修改连接，并处理身份验证。
- en: 'With this in mind, let''s scope out our following potential API endpoints,
    so that we can continue to build our application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们勾画出我们接下来可能的API端点，以便我们可以继续构建我们的应用程序：
- en: '| Endpoints | Method | Description |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 端点 | 方法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `/api/users` | `GET` | Return a list of users with optional parameters |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `/api/users` | `GET` | 返回带有可选参数的用户列表 |'
- en: '| `/api/users` | `POST` | Create a user |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `/api/users` | `POST` | 创建用户 |'
- en: '| `/api/users/XXX` | `PUT` | Update a user''s information |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `/api/users/XXX` | `PUT` | 更新用户信息 |'
- en: '| `/api/users/XXX` | `DELETE` | Delete a user |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `/api/users/XXX` | `DELETE` | 删除用户 |'
- en: '| `/api/connections` | `GET` | Return a list of connections based on users
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `/api/connections` | `GET` | 返回基于用户的连接列表 |'
- en: '| `/api/connections` | `POST` | Create a connection between users |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `/api/connections` | `POST` | 创建用户之间的连接 |'
- en: '| `/api/connections/XXX` | `PUT` | Modify a connection |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `/api/connections/XXX` | `PUT` | 修改连接 |'
- en: '| `/api/connections/XXX` | `DELETE` | Remove a connection between users |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `/api/connections/XXX` | `DELETE` | 删除用户之间的连接 |'
- en: '| `/api/statuses` | `GET` | Get a list of statuses |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `/api/statuses` | `GET` | 获取状态列表 |'
- en: '| `/api/statuses` | `POST` | Create a status |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `/api/statuses` | `POST` | 创建状态 |'
- en: '| `/api/statuses/XXX` | `PUT` | Update a status |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `/api/statuses/XXX` | `PUT` | 更新状态 |'
- en: '| `/api/statuses/XXX` | `DELETE` | Delete a status |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `/api/statuses/XXX` | `DELETE` | 删除状态 |'
- en: '| `/api/comments` | `GET` | Get list of comments |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `/api/comments` | `GET` | 获取评论列表 |'
- en: '| `/api/comments` | `POST` | Create a comment |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `/api/comments` | `POST` | 创建评论 |'
- en: '| `/api/comments/XXX` | `PUT` | Update a comment |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `/api/comments/XXX` | `PUT` | 更新评论 |'
- en: '| `/api/comments/XXX` | `DELETE` | Delete a comment |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `/api/comments/XXX` | `DELETE` | 删除评论 |'
- en: In this case, any place where `XXX` exists is where we'll supply a unique identifier
    as part of the URL endpoint.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`XXX` 存在的任何地方都是我们将作为URL端点的一部分提供唯一标识符的地方。
- en: You'll notice that we've moved to all plural endpoints. This is largely a matter
    of preference and a lot of APIs use both (or only singular endpoints). The advantages
    of pluralized endpoints relate to consistency in the naming structure, which allows
    developers to have predictable calls. Using singular endpoints work as a shorthand
    way to express that the API call will only address a single record.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们已经转移到了所有复数端点。这在很大程度上是一种偏好，许多API同时使用（或仅使用）单数端点。复数化端点的优势与命名结构的一致性有关，这使开发人员能够进行可预测的调用。使用单数端点可以作为一种简写方式来表达API调用只会处理单个记录。
- en: 'Each of these endpoints reflects a potential interaction with a data point.
    There is another set of endpoints that we''ll include as well that don''t reflect
    interaction with our data, but rather they allow our API clients to authenticate
    through OAuth:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端点中的每一个都反映了与数据点的潜在交互。还有一组我们将包括的端点，它们不反映与我们的数据的交互，而是允许我们的API客户端通过OAuth进行身份验证：
- en: '| Endpoint | Method | Description |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 端点 | 方法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `/api/oauth/authorize` | `GET` | Returns a list of users with optional parameters
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `/api/oauth/authorize` | `GET` | 返回带有可选参数的用户列表 |'
- en: '| `/api/oauth/token` | `POST` | Creates a user |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `/api/oauth/token` | `POST` | 创建用户 |'
- en: '| `/api/oauth/revoke` | `PUT` | Updates a user''s information |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `/api/oauth/revoke` | `PUT` | 更新用户信息 |'
- en: If you're unfamiliar with OAuth, don't worry about it for now as we'll dig in
    a bit deeper later on when we introduce authentication methods.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对OAuth不熟悉，现在不用担心，因为当我们介绍认证方法时，我们将会更深入地了解它。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**OAuth**, short for **Open Authentication**, was born from a need to create
    a system for authenticating users with OpenID, which is a decentralized identity
    system.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth**，即**开放认证**，诞生于需要创建一个用于验证OpenID用户的系统的需求，OpenID是一个分散的身份系统。'
- en: By the time OAuth2 came about, the system had been largely retooled to be more
    secure as well as focus less on specific integrations. Many APIs today rely on
    and require OAuth to access and make changes on behalf of users via a third party.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2出现时，系统已经大规模改进，更加安全，并且不再专注于特定的集成。如今，许多API依赖并要求OAuth来访问并代表用户通过第三方进行更改。
- en: The entire specification document (RFC6749) from the Internet Engineering Task
    Force can be found at [http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的规范文档（RFC6749）可以在互联网工程任务组的网站上找到：[http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749)。
- en: The endpoints mentioned earlier represent everything that we'll need to build
    a minimalistic social network that operates entirely on a web service. We will
    be building a basic interface for this too, but primarily, we're focusing on building,
    testing, and tuning our application at the web service level.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的端点代表了我们构建一个完全基于Web服务运行的极简社交网络所需的一切。我们也将为此构建一个基本的界面，但主要是专注于在Web服务层面构建、测试和调优我们的应用程序。
- en: One thing that we won't address here is the `PATCH` requests, which as we mentioned
    in the previous chapter, refer to partial updates of data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里讨论`PATCH`请求，正如我们在上一章中提到的，它指的是对数据的部分更新。
- en: In the next chapter, we will augment our web service to allow the `PATCH` updates,
    and we'll outline all our endpoints as part of our `OPTIONS` response.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将增强我们的Web服务，允许`PATCH`更新，并且我们将概述我们所有的端点作为我们`OPTIONS`响应的一部分。
- en: Handling our API versions
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理我们的API版本
- en: If you spend any amount of time dealing with web services and APIs across the
    Internet, you'll discover a great amount of variation as to how various services
    handle their API versions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花费了大量时间处理互联网上的Web服务和API，你会发现各种服务处理其API版本的方式存在很大的差异。
- en: Not all of these methods are particularly intuitive and often they break forward
    and backward compatibility. You should aim to avoid this in the simplest way possible.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有这些方法都特别直观，而且通常它们会破坏向前和向后的兼容性。你应该尽量以最简单的方式避免这种情况。
- en: 'Consider an API that, by default, uses versioning as part of the URI: `/api/v1.1/users`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个默认情况下在URI中使用版本控制的API：`/api/v1.1/users`。
- en: You will find this to be pretty common; for example, this is the way Twitter
    handles API requests.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现这是相当常见的；例如，这就是Twitter处理API请求的方式。
- en: There are some pluses and minuses to this approach, so you should consider the
    potential downsides for your URI methodology.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些优点和缺点，因此你应该考虑你的URI方法可能存在的缺点。
- en: With API versions being explicitly defined, there is no default version, which
    means that users always have the version they've asked for. The good part of this
    is that you won't necessarily break anyone's API by upgrading. The bad part is
    that users may not know which version is the latest without checking explicitly
    or validating descriptive API messages.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过明确定义API版本，就没有默认版本，这意味着用户总是拥有他们所请求的版本。好处是你不会通过升级来破坏任何人的API。坏处是用户可能不知道哪个版本是最新的，除非明确检查或验证描述性的API消息。
- en: As you may know, Go doesn't allow conditional imports. Although this is a design
    decision that enables tools such as `go fmt` and `go fix` to work quickly and
    elegantly, it can sometimes hamper application design.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能知道的，Go不允许有条件的导入。虽然这是一个设计决策，使得诸如`go fmt`和`go fix`等工具能够快速而优雅地工作，但有时会妨碍应用程序的设计。
- en: 'For example, something like this is not directly possible in Go:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Go中直接实现这样的功能是不可能的：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can improvise around this a bit though. Let''s assume that our application
    structure is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们可以在这方面做一些变通。让我们假设我们的应用程序结构如下：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can then import each as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以按如下方式导入每个版本：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This, of course, also means that we need to use these in our application, otherwise
    Go will trigger a compile error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也意味着我们需要在我们的应用程序中使用它们，否则Go将触发编译错误。
- en: 'An example of maintaining multiple versions can be seen as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 维护多个版本的示例如下所示：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The unfortunate reality of this design decision is that your application will
    break one of programming cardinal rules: *don''t duplicate code*.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计决定的不幸现实是，你的应用程序将违反编程的基本规则之一：*不要重复代码*。
- en: This isn't a hard and fast rule of course, but duplicating code leads to functionality
    creep, fragmentation, and other headaches. As long as we make primary methods
    to do the same things across versions, we can mitigate these problems to some
    degree.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是一个硬性规则，但重复代码会导致功能蔓延、碎片化和其他问题。只要我们在各个版本中做相同的事情，我们就可以在一定程度上缓解这些问题。
- en: 'In this example, each of our API versions will import our standard API serving-and-routing
    file, as shown in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的每个API版本都将导入我们的标准API服务和路由文件，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And, of course, our v2 version will look nearly identical to a different version.
    Essentially, we use these as wrappers that bring in our important shared data
    such as database connections, data marshaling, and so on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的v2版本将几乎与不同版本相同。基本上，我们使用这些作为包装器，引入我们的重要共享数据，如数据库连接、数据编组等等。
- en: 'To demonstrate this, we could put a couple of our essential variables and functions
    into our `api.go` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们可以将一些我们的基本变量和函数放入我们的`api.go`文件中：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If this looks familiar, this is because it's the core of what we had in our
    first attempt at the API from the last chapter, with a few of the routes stripped
    for space here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来很熟悉，那是因为它是我们在上一章中尝试API时所拥有的核心，这里为了节省空间而剥离了一些路由。
- en: Now is also a good time to mention an intriguing third-party package for handling
    JSON-based REST APIs—**JSON API Server** (**JAS**). JAS sits on top of HTTP (like
    our API) but automates a lot of the routing by directing requests to resources
    automatically.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在也是一个好时机提到一个有趣的第三方包，用于处理基于JSON的REST API——**JSON API Server**（**JAS**）。 JAS位于HTTP之上（就像我们的API一样），但通过自动将请求定向到资源来自动化了许多路由。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: JSON API Server or JAS allows a simple set of JSON-specific API tools on top
    of the HTTP package to augment your web service with minimal impact.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JSON API Server或JAS允许在HTTP包之上使用一组简单的特定于JSON的API工具，以最小的影响增强您的Web服务。
- en: You can read more about this at [https://github.com/coocood/jas](https://github.com/coocood/jas).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/coocood/jas](https://github.com/coocood/jas)上阅读更多信息。
- en: 'You can install it via Go by using this command: `go get github.com/coocood/jas`.
    Delivering our API in multiple formats'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用以下命令在Go中安装它：`go get github.com/coocood/jas`。以多种格式交付我们的API
- en: At this stage, it makes sense to formalize the way we approach multiple formats.
    In this case, we're dealing with JSON, RSS, and generic text.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，形式化我们处理多种格式的方式是有意义的。在这种情况下，我们处理JSON、RSS和通用文本。
- en: We'll get to generic text in the next chapter when we talk about templates,
    but for now, we need to be able to separate our JSON and RSS responses.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论模板时涉及通用文本，但现在我们需要能够分开我们的JSON和RSS响应。
- en: The easiest way to do this is to treat any of our resources as an interface
    and then negotiate marshaling of the data based on a request parameter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的最简单方法是将我们的任何资源都视为接口，然后根据请求参数协商数据的编组。
- en: 'Some APIs define the format directly in the URI. We can also do this fairly
    easily (as shown in the following example) within our mux routing:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一些API直接在URI中定义格式。我们也可以在我们的mux路由中相当容易地这样做（如下面的示例所示）：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code will allow us to extract the requested format directly from
    URL parameters. However, this is also a bit of a touchy point when it comes to
    REST and URIs. And though it's one with some debate on either side, for our purpose,
    we'll use the format simply as a query parameter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将允许我们直接从URL参数中提取请求的格式。然而，当涉及到REST和URI时，这也是一个敏感的问题。虽然双方都有一些争论，但出于我们的目的，我们将简单地将格式用作查询参数。
- en: 'In our `api.go` file, we''ll need to create a global variable called `Format`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`api.go`文件中，我们需要创建一个名为`Format`的全局变量：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And a function that we can use to ascertain the format for each respective
    request:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个我们可以用来确定每个请求的格式的函数：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We'll call this with each request. Although the preceding option automatically
    restricts to JSON, XML, or text, we can build it into the application logic as
    well and include a fallback to `Format` if it doesn't match the acceptable options.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每个请求中调用它。虽然前面的选项自动限制为JSON、XML或文本，但我们也可以将其构建到应用逻辑中，并包括对`Format`的回退，如果它不匹配可接受的选项。
- en: 'We can use a generic `SetFormat` function to marshal data based on the currently
    requested data format:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用通用的`SetFormat`函数来根据当前请求的数据格式进行数据编组：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Within any of our endpoint functions, we can return any data resource that
    is passed as an interface to `SetFormat()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任何端点函数中，我们可以返回作为接口传递给`SetFormat()`的任何数据资源：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This allows us to remove the marshaling from the response function(s). Now that
    we have a pretty firm grasp of marshaling our data into XML and JSON, let's revisit
    another protocol for serving a web service.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够从响应函数中删除编组。现在我们已经相当牢固地掌握了将数据编组为XML和JSON，让我们重新审视另一种用于提供Web服务的协议。
- en: Concurrent WebSockets
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发WebSockets
- en: As mentioned in the previous chapter, a WebSocket is a method to keep an open
    connection between the client and the server, which is typically meant to replace
    multiple HTTP calls from a browser to a client, but also between two servers that
    may need to stay in a semi-reliable constant connection.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，WebSocket是一种保持客户端和服务器之间开放连接的方法，通常用于替代浏览器到客户端的多个HTTP调用，也用于两个可能需要保持半可靠恒定连接的服务器之间。
- en: The advantages of using WebSockets for your API are reduced latency for the
    client and server and a generally less complex architecture for building a client-side
    solution for long-polling applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WebSockets的优势是减少客户端和服务器的延迟，并且对于构建长轮询应用程序的客户端解决方案来说，架构通常更少复杂。
- en: 'To outline the advantages, consider the following two representations; the
    first of the standard HTTP request:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了概述优势，请考虑以下两种表示形式；第一个是标准HTTP请求：
- en: '![Concurrent WebSockets](img/1304OS_04_03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![并发WebSockets](img/1304OS_04_03.jpg)'
- en: 'Now compare this with the more streamlined WebSocket request over TCP, which
    eliminates the overhead of multiple handshakes and state control:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这与更简化的WebSocket请求通过TCP进行比较，这消除了多次握手和状态控制的开销：
- en: '![Concurrent WebSockets](img/1304OS_04_04.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![并发WebSockets](img/1304OS_04_04.jpg)'
- en: You can see how traditional HTTP presents levels of redundancy and latency that
    can hamper a long-lived application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到传统HTTP呈现了可以妨碍长期应用的冗余和延迟级别。
- en: Granted, it's only HTTP 1 that has this problem in a strict sense. HTTP 1.1
    introduced keep-alives or persistence in a connection. And while that worked on
    the protocol side, most nonconcurrent web servers would struggle with resource
    allocation. Apache, for example, by default left keep-alive timeouts very low
    because long-lived connections would tie up threads and prevent future requests
    from completing in a reasonable manner of time.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定的是，严格意义上只有HTTP 1才有这个问题。HTTP 1.1引入了保持活动或持久性连接。虽然这在协议方面起作用，但大多数非并发的Web服务器在资源分配方面会遇到困难。例如，默认情况下，Apache会将保持活动超时设置得非常低，因为长时间的连接会占用线程并阻止未来的请求在合理的时间内完成。
- en: The present and future of HTTP offers some alternatives to WebSockets, namely
    some big options that have been brought to the table by the SPDY protocol, which
    was developed primarily by Google.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的现在和未来提供了一些WebSocket的替代方案，主要是由Google主要开发的SPDY协议提出的一些重要选项。
- en: While HTTP 2.0 and SPDY offer concepts of multiplexing connections without closing
    them, particularly in the HTTP pipelining methodology, there is no wide-ranging
    client-side support for them yet. For the time being, if we approach an API from
    a web client, WebSockets provide far more client-side predictability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTTP 2.0和SPDY提供了在不关闭连接的情况下复用连接的概念，特别是在HTTP管线化方法中，但目前还没有广泛的客户端支持。目前，如果我们从Web客户端访问API，WebSockets提供了更多的客户端可预测性。
- en: It should be noted that SPDY support across web servers and load balancers is
    still largely experimental. Caveat emptor.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，跨Web服务器和负载均衡器的SPDY支持仍然在很大程度上是实验性的。买方自负。
- en: 'While REST remains our primary target for our API and demonstrations, you''ll
    find a very simple WebSocket example in the following code that accepts a message
    and returns the length of that message along the wire:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然REST仍然是我们API和演示的主要目标，但在以下代码中，您会发现一个非常简单的WebSocket示例，它接受一条消息并返回该消息在传输过程中的长度：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the loop here; it's essential to keep this loop running within the `EchoLengthServer`
    function, otherwise your WebSocket connection will close immediately on the client
    side, preventing future messages.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里的循环；在`EchoLengthServer`函数中保持此循环运行非常重要，否则您的WebSocket连接将立即在客户端关闭，从而阻止未来的消息。
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is our primary socket router. We''re listening on port `12345` and evaluating
    the incoming message''s length and then returning it. Note that we essentially
    *cast* the `http` handler to a `websocket` handler. This is shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的主要套接字路由器。我们正在监听端口`12345`并评估传入消息的长度，然后返回它。请注意，我们实质上将`http`处理程序*转换*为`websocket`处理程序。这在这里显示：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This last piece, in addition to instantiating the WebSocket portion, also serves
    a flat file. Due to some cross-domain policy issues, it can be cumbersome to test
    client-side access and functionality of a WebSocket example unless the two are
    running on the same domain and port.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分，除了实例化WebSocket部分外，还提供了一个平面文件。由于一些跨域策略问题，测试WebSocket示例的客户端访问和功能可能会很麻烦，除非两者在同一域和端口上运行。
- en: To manage cross-domain requests, a protocol handshake must be initiated. This
    is beyond the scope of the demonstration, but if you choose to pursue it, know
    that this particularly package does provide the functionality with a `serverHandshaker`
    interface that references the `ReadHandshake` and `AcceptHandshake` methods.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理跨域请求，必须启动协议握手。这超出了演示的范围，但如果您选择追求它，请知道这个特定的包确实提供了一个`serverHandshaker`接口，引用了`ReadHandshake`和`AcceptHandshake`方法。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The source for handshake mechanisms of `websocket.go` can be found at [https://code.google.com/p/go/source/browse/websocket/websocket.go?repo=net](https://code.google.com/p/go/source/browse/websocket/websocket.go?repo=net).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`websocket.go`的握手机制源代码可以在[https://code.google.com/p/go/source/browse/websocket/websocket.go?repo=net](https://code.google.com/p/go/source/browse/websocket/websocket.go?repo=net)找到。'
- en: 'Since this is a wholly WebSocket-based presentation at the `/length` endpoint,
    if you attempt to reach it via HTTP, you''ll get a standard error, as shown in
    the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个完全基于WebSocket的演示，如果您尝试通过HTTP访问`/length`端点，您将收到标准错误，如下截图所示：
- en: '![Concurrent WebSockets](img/1304OS_04_01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![并发WebSockets](img/1304OS_04_01.jpg)'
- en: 'Hence, the flat file will be returned to the same domain and port. In the preceding
    code, we simply include jQuery and the built-in WebSocket support that exists
    in the following browsers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，平面文件将返回到相同的域和端口。在前面的代码中，我们只是包括了jQuery和以下浏览器中存在的内置WebSocket支持：
- en: '**Chrome**: Version 21 and higher versions'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chrome**：版本21及更高版本'
- en: '**Safari**: Version 6 and higher versions'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Safari**：版本6及更高版本'
- en: '**Firefox**: Version 21 and higher versions'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Firefox**：版本21及更高版本'
- en: '**IE**: Version 10 and higher versions'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IE**：版本10及更高版本'
- en: '**Opera**: Versions 22 and higher versions'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Opera**：版本22及更高版本'
- en: Modern Android and iOS browsers also handle WebSockets now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Android和iOS浏览器现在也处理WebSockets。
- en: 'The code for connecting to the WebSocket-side of the server and testing some
    messages is as follows. Note that we don''t test for WebSocket support here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到服务器的WebSocket端并测试一些消息的代码如下。请注意，我们在这里不测试WebSocket支持：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code returns the message that we get from the WebSocket server:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码返回我们从WebSocket服务器收到的消息：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we visit the `/websocket` URL in our browser, we''ll get the text area
    that allows us to send messages from the client side to the WebSocket server,
    as shown in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中访问`/websocket` URL时，我们将获得文本区域，允许我们从客户端发送消息到WebSocket服务器，如下截图所示：
- en: '![Concurrent WebSockets](img/1304OS_04_02.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![并发WebSockets](img/1304OS_04_02.jpg)'
- en: Separating our API logic
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离我们的API逻辑
- en: As we mentioned in the section on versioning earlier, the best way for us to
    achieve consistency across versions and formats is to keep our API logic separate
    from our overall version and delivery components.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在版本控制部分提到的，我们实现版本和格式的一致性的最佳方法是将API逻辑与整体版本和交付组件分开。
- en: We've seen a bit of this in our `GetFormat()` and `SetFormat()` functions, which
    span all the endpoints and versions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`GetFormat()`和`SetFormat()`函数中看到了一些这种情况，它们涵盖了所有的端点和版本。
- en: Expanding our error messages
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展我们的错误消息
- en: In the last chapter, we briefly touched on sending error messages via our HTTP
    status codes. In this case, we passed along a 409 status conflict when a client
    attempted to create a user with an e-mail address that already existed in the
    database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了通过HTTP状态码发送错误消息。在这种情况下，当客户端尝试创建一个已经存在于数据库中的电子邮件地址的用户时，我们传递了一个409状态冲突。
- en: 'The `http` package provides a noncomprehensive set of status codes that you
    can use for standard HTTP issues as well as REST-specific messages. The codes
    are noncomprehensive because there are some additional messages that go along
    with some of these codes, but the following list satisfies the RFC 2616 proposal:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`http`包提供了一组非全面的状态代码，您可以用它们来处理标准的HTTP问题以及特定于REST的消息。这些代码是非全面的，因为其中一些代码还有一些附加消息，但以下列表满足了RFC
    2616提案：'
- en: '| Error | Number |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| Error | Number |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `StatusContinue` | 100 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `StatusContinue` | 100 |'
- en: '| `StatusSwitchingProtocols` | 101 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `StatusSwitchingProtocols` | 101 |'
- en: '| `StatusOK` | 200 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `StatusOK` | 200 |'
- en: '| `StatusCreated` | 201 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `StatusCreated` | 201 |'
- en: '| `StatusAccepted` | 202 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `StatusAccepted` | 202 |'
- en: '| `StatusNonAuthoritativeInfo` | 203 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `StatusNonAuthoritativeInfo` | 203 |'
- en: '| `StatusNoContent` | 204 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `StatusNoContent` | 204 |'
- en: '| `StatusResetContent` | 205 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `StatusResetContent` | 205 |'
- en: '| `StatusPartialContent` | 206 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `StatusPartialContent` | 206 |'
- en: '| `StatusMultipleChoices` | 300 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `StatusMultipleChoices` | 300 |'
- en: '| `StatusMovedPermanently` | 301 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `StatusMovedPermanently` | 301 |'
- en: '| `StatusFound` | 302 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `StatusFound` | 302 |'
- en: '| `StatusSeeOther` | 303 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `StatusSeeOther` | 303 |'
- en: '| `StatusNotModified` | 304 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `StatusNotModified` | 304 |'
- en: '| `StatusUseProxy` | 305 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `StatusUseProxy` | 305 |'
- en: '| `StatusTemporaryRedirect` | 307 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `StatusTemporaryRedirect` | 307 |'
- en: '| `StatusBadRequest` | 400 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `StatusBadRequest` | 400 |'
- en: '| `StatusUnauthorized` | 401 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `StatusUnauthorized` | 401 |'
- en: '| `StatusPaymentRequired` | 402 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `StatusPaymentRequired` | 402 |'
- en: '| `StatusForbidden` | 403 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `StatusForbidden` | 403 |'
- en: '| `StatusNotFound` | 404 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `StatusNotFound` | 404 |'
- en: '| `StatusMethodNotAllowed` | 405 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `StatusMethodNotAllowed` | 405 |'
- en: '| `StatusNotAcceptable` | 406 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `StatusNotAcceptable` | 406 |'
- en: '| `StatusProxyAuthRequired` | 407 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `StatusProxyAuthRequired` | 407 |'
- en: '| `StatusRequestTimeout` | 408 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `StatusRequestTimeout` | 408 |'
- en: '| `StatusConflict` | 409 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `StatusConflict` | 409 |'
- en: '| `StatusGone` | 410 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `StatusGone` | 410 |'
- en: '| `StatusLengthRequired` | 411 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `StatusLengthRequired` | 411 |'
- en: '| `StatusPreconditionFailed` | 412 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `StatusPreconditionFailed` | 412 |'
- en: '| `StatusRequestEntityTooLarge` | 413 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `StatusRequestEntityTooLarge` | 413 |'
- en: '| `StatusRequestURITooLong` | 414 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `StatusRequestURITooLong` | 414 |'
- en: '| `StatusUnsupportedMediaType` | 415 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `StatusUnsupportedMediaType` | 415 |'
- en: '| `StatusRequestedRangeNotSatisfiable` | 416 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `StatusRequestedRangeNotSatisfiable` | 416 |'
- en: '| `StatusExpectationFailed` | 417 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `StatusExpectationFailed` | 417 |'
- en: '| `StatusTeapot` | 418 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `StatusTeapot` | 418 |'
- en: '| `StatusInternalServerError` | 500 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `StatusInternalServerError` | 500 |'
- en: '| `StatusNotImplemented` | 501 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `StatusNotImplemented` | 501 |'
- en: '| `StatusBadGateway` | 502 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `StatusBadGateway` | 502 |'
- en: '| `StatusServiceUnavailable` | 503 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `StatusServiceUnavailable` | 503 |'
- en: '| `StatusGatewayTimeout` | 504 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `StatusGatewayTimeout` | 504 |'
- en: '| `StatusHTTPVersionNotSupported` | 505 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `StatusHTTPVersionNotSupported` | 505 |'
- en: 'You may recall that we hard coded this error message before; our error-handling
    should still be kept above the context of API versions. For example, in our `api.go`
    file, we had a switch control in our `ErrorMessage` function that explicitly defined
    our 409 HTTP status code error. We can augment this with constants and global
    variables that are defined in the `http` package itself:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得我们之前硬编码了这个错误消息；我们的错误处理仍然应该保持在API版本的上下文之上。例如，在我们的`api.go`文件中，我们在`ErrorMessage`函数中有一个switch控制，明确定义了我们的409
    HTTP状态码错误。我们可以通过`http`包本身中定义的常量和全局变量来增强这一点：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You may recall that this does some translation of errors in other components
    of the application; in this case 1062 was a MySQL error. We can also directly
    and automatically implement the HTTP status codes here as a default in the switch:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得这在应用程序的其他组件中进行了一些错误的翻译；在这种情况下，1062是一个MySQL错误。我们还可以直接自动地在switch中实现HTTP状态码作为默认值：
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Updating our users via the web service
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过网络服务更新我们的用户
- en: We have an ability here to present another point of potential error when we
    allow users to be updated via the web service.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们允许用户通过网络服务进行更新时，我们在这里有能力呈现另一个潜在的错误点。
- en: 'To do this, we''ll add an endpoint to the /`api/users/XXX` endpoint by adding
    a route:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将通过添加路由将一个端点添加到/`api/users/XXX`端点：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And in our `UsersUpdate` function, we'll first check to see if the said user
    ID exists. If it does not exist, we'll return a 404 error (a document not found
    error), which is the closest approximation of a resource record not found.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`UsersUpdate`函数中，我们首先会检查所说的用户ID是否存在。如果不存在，我们将返回404错误（文档未找到错误），这是资源记录未找到的最接近的近似值。
- en: 'If the user does exist, we''ll attempt to update their e-mail ID through a
    query; if that fails, we''ll return the conflict message (or another error). If
    it does not fail, we''ll return 200 and a success message in JSON. Here''s the
    beginning of the `UserUpdates` function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户存在，我们将尝试通过查询更新他们的电子邮件ID；如果失败，我们将返回冲突消息（或其他错误）。如果没有失败，我们将返回200和JSON中的成功消息。这是`UserUpdates`函数的开头：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We'll expand on this a bit, but for now, we can create a user, return a list
    of users, and update users' e-mail addresses.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微扩展一下这个，但现在，我们可以创建一个用户，返回用户列表，并更新用户的电子邮件地址。
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'While working with APIs, now is a good time to mention two browser-based tools:
    **Postman** and **Poster**, that let you work directly with REST endpoints from
    within a browser.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用API时，现在是一个好时机提到两个基于浏览器的工具：**Postman**和**Poster**，它们让您直接在浏览器中使用REST端点。
- en: For more information on Postman in Chrome, go to [https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en](https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Chrome中Postman的更多信息，请访问[https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en](https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en)。
- en: For more information on Poster in Firefox, go to [https://addons.mozilla.org/en-US/firefox/addon/poster/](https://addons.mozilla.org/en-US/firefox/addon/poster/).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Firefox中的Poster的更多信息，请访问[https://addons.mozilla.org/en-US/firefox/addon/poster/](https://addons.mozilla.org/en-US/firefox/addon/poster/)。
- en: Both tools do essentially the same thing; they allow you to interface with an
    API directly without having to develop a specific HTML or script-based tool or
    using cURL directly from the command line.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种工具本质上是做同样的事情；它们允许您直接与API进行接口，而无需开发特定的基于HTML或脚本的工具，也无需直接从命令行使用cURL。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Through this chapter, we have the guts of our social networking web service
    scoped out and ready to fill in. We've shown you how to create and outlined how
    to update our users as well as return valuable error information when we cannot
    update our users.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们已经勾勒出了我们的社交网络网络服务的要点，并准备填写。我们已经向您展示了如何创建和概述如何更新我们的用户，以及在无法更新用户时返回有价值的错误信息。
- en: This chapter has dedicated a lot of time to the infrastructure—the formats and
    endpoints—of such an application. On the former, we looked at XML and JSON primarily,
    but in the next chapter, we'll explore templates so that you can return data in
    any arbitrary format in which you deem necessary.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在这样的应用程序基础设施——格式和端点——上投入了大量时间。在前者方面，我们主要关注了XML和JSON，但在下一章中，我们将探索模板，以便您可以以您认为必要的任何任意格式返回数据。
- en: We'll also delve into authentication, either via OAuth or a simple HTTP basic
    authentication, which will allow our clients to connect securely to our web service
    and make requests that protect sensitive data. To do this, we'll also lock our
    application down to HTTPS for some of our requests.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将深入探讨身份验证，无论是通过OAuth还是简单的HTTP基本身份验证，这将允许我们的客户端安全连接到我们的网络服务并发出保护敏感数据的请求。为此，我们还将锁定我们的应用程序以进行一些请求的HTTPS。
- en: In addition, we'll focus on a REST aspect that we've only touched on briefly—outlining
    our web service's behavior via the `OPTIONS HTTP` verb. Finally, we'll look more
    closely at the way headers can be used to approximate state on both the server
    and receiving end of a web service.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将专注于我们仅简要提及的REST方面——通过`OPTIONS HTTP`动词概述我们的网络服务的行为。最后，我们将更仔细地研究头部如何用于近似表示网络服务的服务器端和接收端的状态。
