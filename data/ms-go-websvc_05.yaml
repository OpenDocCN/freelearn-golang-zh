- en: Chapter 5. Templates and Options in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。Go中的模板和选项
- en: With the basics of our social networking web service fleshed out, it's time
    we take our project from a demo toy to something that can actually be used, and
    perhaps eventually in production as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的社交网络网络服务的基础上，是时候将我们的项目从演示玩具变成实际可用的东西了，也许最终还可以投入生产。
- en: To do this, we need to focus on a number of things, some of which we'll address
    in this chapter. In the last chapter, we looked at scoping out the primary functions
    of our social network application. Now, we need to make sure that each of those
    things is possible from a REST standpoint.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要关注许多事情，其中一些我们将在本章中解决。在上一章中，我们看了一下如何确定我们的社交网络应用程序的主要功能。现在，我们需要确保从REST的角度来看，每一件事都是可能的。
- en: 'In order to accomplish that, in this chapter, we''ll look at:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，在本章中，我们将看到：
- en: Using `OPTIONS` to provide built-in documentation and a REST-friendly explanation
    of our resources' endpoints purposes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`OPTIONS`提供内置文档和我们资源端点目的的REST友好解释
- en: Considering alternative output formats and an introduction on how to implement
    them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑替代输出格式以及如何实现它们的介绍
- en: Implementing and enforcing security for our API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的API实施和强制安全性
- en: Allowing user registration to utilize secure passwords
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户注册以使用安全密码
- en: Allowing users to authenticate from a web-based interface
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户从基于Web的界面进行身份验证
- en: Approximating an OAuth-like authentication system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近似于OAuth样式的身份验证系统
- en: Allowing external applications to make requests on behalf of other users
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许外部应用代表其他用户发出请求
- en: After the implementation of these things, we will have the foundation of a service
    that will allow users to interface with it, either directly via an API or through
    a third-party service.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施这些事情之后，我们将拥有一个允许用户与之进行接口的服务的基础，无论是通过API直接接口还是通过第三方服务。
- en: Sharing our OPTIONS
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享我们的选项
- en: We've hinted a bit at the value and purpose of the `OPTIONS` HTTP verb as it
    relates to the HTTP specification and the best practices of REST.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经略微提到了`OPTIONS` HTTP动词的价值和目的，因为它与HTTP规范和REST的最佳实践有关。
- en: As per RFC 2616, the HTTP/1.1 specification, responses to the `OPTIONS` requests
    should return information about what the client can do with the resource and/or
    requested endpoint.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC 2616，即HTTP/1.1规范，对`OPTIONS`请求的响应应返回有关客户端可以对资源和/或请求的端点进行的操作的信息。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the **HTTP/1.1** **Request for Comments** (**RFC**) at [https://www.ietf.org/rfc/rfc2616.txt](https://www.ietf.org/rfc/rfc2616.txt).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.ietf.org/rfc/rfc2616.txt](https://www.ietf.org/rfc/rfc2616.txt)找到**HTTP/1.1**
    **请求注释** (**RFC**)。
- en: In other words, in our early examples, calls to `/api/users` with `OPTIONS`
    should return an indication that `GET`, `POST`, `PUT`, and `DELETE` are presently
    available options at that REST resource request.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在我们早期的示例中，对`/api/users`的`OPTIONS`调用应返回一个指示，即`GET`、`POST`、`PUT`和`DELETE`目前是该REST资源请求的可用选项。
- en: At present, there's no predefined format for what the body content should resemble
    or contain although the specification indicates that this may be outlined in a
    future release. This gives us some leeway in how we present available actions;
    in most such cases we will want to be as robust and informative as possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，对于正文内容应该是什么样子或包含什么内容并没有预定义的格式，尽管规范表明这可能会在将来的版本中概述。这给了我们一些灵活性，可以在如何呈现可用操作方面有所作为；在大多数这样的情况下，我们都希望尽可能健壮和信息丰富。
- en: 'The following code is a simple modification of our present API that includes
    some basic information about the `OPTIONS` request that we outlined earlier. First,
    we''ll add the method-specific handler for the request in our exported `Init()`
    function of the `api.go` file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是我们目前API的简单修改，其中包含了我们之前概述的有关`OPTIONS`请求的一些基本信息。首先，我们将在`api.go`文件的导出`Init()`函数中添加请求的特定处理程序：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And then, we''ll add the handler:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加处理程序：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Calling this with cURL directly gives us what we''re looking for. In the following
    screenshot, you''ll notice the `Allow` header right at the top of the response:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用cURL调用这个命令会给我们我们所需要的东西。在下面的屏幕截图中，您会注意到响应顶部的`Allow`标头：
- en: '![Sharing our OPTIONS](img/1304OS_05_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![分享我们的选项](img/1304OS_05_01.jpg)'
- en: This alone would satisfy most generally accepted requirements for the `OPTIONS`
    verb in the REST-based world, but remember that there is no format for the body
    and we want to be as expressive as we can.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点单独就足以满足REST世界中`OPTIONS`动词的大多数普遍接受的要求，但请记住，正文没有格式，我们希望尽可能地表达。
- en: 'One way in which we can do this is by providing a documentation-specific package;
    in this example, it is called specification. Keep in mind that this is wholly
    optional, but it is a nice treat for any developers who happen to stumble across
    it. Let''s take a look at how we can set this up for self-documented APIs:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供一个特定于文档的包来做到这一点；在这个例子中，它被称为规范。请记住，这是完全可选的，但对于偶然发现它的任何开发人员来说，这是一个不错的礼物。让我们看看如何为自我记录的API设置这个：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can then reference this directly in our `api.go` file. First, we''ll create
    a generic slice of interfaces that will encompass all the available methods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以直接在我们的`api.go`文件中引用它。首先，我们将创建一个包含所有可用方法的通用接口切片：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we can compile our various methods within our `UsersInfo` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的`UsersInfo`方法中编译我们的各种方法：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Your screen should look similar to this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您的屏幕应该看起来类似于这样：
- en: '![Sharing our OPTIONS](img/1304OS_05_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![分享我们的选项](img/1304OS_05_02.jpg)'
- en: Implementing alternative formats
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施替代格式
- en: 'When looking at the world of API formats, you know by now that there are two
    big players: **XML** and **JSON**. As human-readable formats, these two have owned
    the format world for more than a decade.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看API格式的世界时，您现在知道有两个主要的参与者：**XML**和**JSON**。作为人类可读格式，这两种格式在过去十多年中一直占据着格式世界。
- en: As is often the case, developers and technologists rarely settle happily for
    something for long. XML was number one for a very long time before the computational
    complexity of encoding and decoding as well as the verbosity of schema pushed
    many developers towards JSON.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，开发人员和技术人员很少会满意地长期使用某种东西。在计算编码和解码的复杂性以及模式的冗长推动许多开发人员转向JSON之前，XML很长一段时间是第一位的。
- en: JSON is not without its faults either. It's not all that readable by humans
    without some explicit spacing, which then increases the size of the document excessively.
    It doesn't handle commenting by default either.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JSON也不是没有缺点。没有一些明确的间距，它对人类来说并不那么可读，这会使文档的大小过分增加。它也不能默认处理注释。
- en: 'There are a number of alternative formats that are sitting on the sideline.
    **YAML**, which stands for **YAML Ain''t Markup Language**, is a whitespace-delimited
    format that uses indentation to make it extremely readable for humans. An example
    document would look something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多替代格式在一旁。**YAML**，代表**YAML Ain't Markup Language**，是一种使用缩进使其对人类极易阅读的空白分隔格式。一个示例文档可能是这样的：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The indentation system as a method of simulating code blocks will look familiar
    to anyone with experience in Python.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进系统作为模拟代码块的方法，对于有Python经验的人来说会很熟悉。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are a number of YAML implementations for Go. The most noteworthy is `go-yaml`
    and this is available at [https://github.com/go-yaml/yaml](https://github.com/go-yaml/yaml).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Go有许多YAML实现。最值得注意的是`go-yaml`，可以在[https://github.com/go-yaml/yaml](https://github.com/go-yaml/yaml)找到。
- en: '**TOML**, or **Tom''s Obvious, Minimal Language**, takes an approach that will
    look very familiar to anyone who has worked with the `.ini` style config files.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**TOML**，或**Tom''s Obvious, Minimal Language**，采用了一种方法，对于任何使用`.ini`风格配置文件的人来说都会非常熟悉。'
- en: Rolling our own data representation format
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制定我们自己的数据表示格式
- en: TOML is a good format to look at with regard to building our own data format,
    primarily because its simplicity lends itself to multiple ways of accomplishing
    the output within this format.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TOML是一个很好的格式，可以用来构建我们自己的数据格式，主要是因为它的简单性使得在这种格式内部实现多种输出成为可能。
- en: 'You may be immediately tempted to look at Go''s text template format when devising
    something as simple as TOML because the control mechanisms to present it are largely
    there inherently. Take this structure and loop, for example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计像TOML这样简单的东西时，你可能会立即想到Go的文本模板格式，因为它本质上已经有了呈现它的控制机制。例如，考虑这个结构和循环：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And, when the structure is parsed against the text template, it will generate
    precisely what we want as follows:`{{.Name}}`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当结构被解析为文本模板时，它将精确地生成我们想要的内容:`{{.Name}}`。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One big problem with this method is that you have no inherent system for unmarshalling
    data. In other words, you can generate the data in this format, but you can't
    unravel it back into Go structures the other way.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个大问题是你没有固有的系统来解组数据。换句话说，你可以生成这种格式的数据，但你不能将其解开成Go结构的另一种方式。
- en: Another issue is that as the format increases in complexity, it becomes less
    reasonable to use the limited control structures in the Go template library to
    fulfill all of the intricacies and quirks of such a format.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，随着格式的复杂性增加，使用Go模板库中的有限控制结构来满足这种格式的所有复杂性和怪癖变得不太合理。
- en: If you choose to roll your own format, you should avoid text templates and look
    at the encoding package that allows you to both produce and consume structured
    data formats.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择自己的格式，你应该避免文本模板，而是查看编码包，它允许你生成和消费结构化数据格式。
- en: We'll look at the encoding package closely in the following chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中仔细研究编码包。
- en: Introducing security and authentication
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入安全和认证
- en: A critical aspect of any web service or API is the ability to keep information
    secure and only allow access to specific users to do specific things.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 任何网络服务或API的一个关键方面是能够保持信息安全，并且只允许特定用户访问特定的内容。
- en: Historically, there have been a number of ways to accomplish this and one of
    the earliest is HTTP digest authentication.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在历史上，有许多方法可以实现这一点，最早的一种是HTTP摘要认证。
- en: Another common one is inclusion of developer credentials, namely an API key.
    This isn't recommended much anymore, primarily because the security of the API
    relies exclusively on the security of these credentials. It is, however, largely
    a self-evident method for allowing authentication and as a service provider, it
    allows you to keep track of who is making specific requests and it also enables
    the throttling of requests.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的方法是包含开发人员凭据，即API密钥。这已经不再被推荐，主要是因为API的安全性完全依赖于这些凭据的安全性。然而，这在很大程度上是一种明显的允许认证的方法，作为服务提供商，它允许你跟踪谁在做特定的请求，还可以实现请求的限制。
- en: The big player today is OAuth and we'll look at this shortly. However, first
    things first, we need to ensure that our API is accessible only via HTTPS.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的大玩家是OAuth，我们很快会看一下。然而，首先，我们需要确保我们的API只能通过HTTPS访问。
- en: Forcing HTTPS
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制使用HTTPS
- en: At this point, our API is starting to enable clients and users to do some things,
    namely create users, update their data, and include image data for these users.
    We're beginning to dabble in things that we would not want to leave open in a
    real-world environment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的API开始使客户和用户能够做一些事情，比如创建用户，更新他们的数据，并为这些用户包含图像数据。我们开始涉足一些在现实环境中不希望公开的事情。
- en: The first security step we can look at is forcing HTTPS instead of HTTP on our
    API. Go implements HTTPS via TLS rather than SSL since TLS is considered as a
    more secure protocol from the server side. One of the driving factors was vulnerabilities
    in SSL 3.0, particularly the Poodlebleed Bug that was exposed in 2014.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看一下的第一个安全步骤是强制API上的HTTPS而不是HTTP。Go通过TLS实现HTTPS，而不是SSL，因为从服务器端来看，TLS被认为是更安全的协议。其中一个驱动因素是SSL
    3.0中的漏洞，特别是2014年暴露的Poodlebleed Bug。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can read more about Poodlebleed at [https://poodlebleed.com/](https://poodlebleed.com/).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://poodlebleed.com/](https://poodlebleed.com/)了解更多关于Poodlebleed的信息。
- en: 'Let''s look at how we can reroute any nonsecure request to its secure counterpoint
    in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在以下代码中将任何非安全请求重定向到其安全对应项：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is our (temporarily) correct endpoint. It's not yet TSL (or SSL), so we're
    not actually listening for HTTPS connections, hence the message.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们（暂时）正确的端点。它还不是TSL（或SSL），所以我们实际上并没有监听HTTPS连接，因此会显示此消息。
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is our redirection handler. You'll probably take note with the `http.StatusOK`
    status code—obviously we'd want to send a 301 Moved Permanently error (or an `http.StatusMovedPermanently`
    constant). However, if you're testing this, there's a chance that your browser
    will cache the status and automatically attempt to redirect you.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的重定向处理程序。您可能会注意到`http.StatusOK`状态码 - 显然我们希望发送301永久移动错误（或`http.StatusMovedPermanently`常量）。但是，如果您正在测试这个，您的浏览器可能会缓存状态并自动尝试重定向您。
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So, why have we wrapped these methods in anonymous goroutines? Well, take them
    out and you''ll see that because the `ListenAndServe` function is blocking, we''ll
    never run the two simultaneously by simply calling the following statements:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们将这些方法包装在匿名的goroutines中呢？好吧，把它们拿出来，您会发现因为`ListenAndServe`函数是阻塞的，我们不能通过简单调用以下语句同时运行这两个方法：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, you have options in this regard. You could simply set the first as
    a goroutine and this would allow the program to move on to the second server.
    This method provides some more granular control for demonstration purposes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您在这方面有多种选择。您可以简单地将第一个设置为goroutine，这将允许程序继续执行第二个服务器。这种方法提供了一些更细粒度的控制，用于演示目的。
- en: Adding TLS support
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加TLS支持
- en: In the preceding example, we were obviously not listening for HTTPS connections.
    Go makes this quite easy; however, like most SSL/TLS matters, the complication
    arises while handling your certificates.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，显然我们并没有监听HTTPS连接。Go使这变得非常容易；但是，像大多数SSL/TLS问题一样，处理您的证书时会出现复杂性。
- en: For these examples, we'll be using self-signed certificates, and Go makes this
    easy as well. Within the `crypto/tls` package, there is a file called `generate_cert.go`
    that you can use to generate your certificate keys.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些示例，我们将使用自签名证书，Go也很容易实现。在`crypto/tls`包中，有一个名为`generate_cert.go`的文件，您可以使用它来生成您的证书密钥。
- en: 'By navigating to your Go binary directory and then `src/pkg/crypto/tls`, you
    can generate a key pair that you can utilize for testing by running this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转到您的Go二进制目录，然后`src/pkg/crypto/tls`，您可以通过运行以下命令生成一个可以用于测试的密钥对：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can then take those files and move them wherever you want, ideally in the
    directory where our API is running.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将这些文件移动到任何您想要的位置，理想情况下是我们API运行的目录。
- en: 'Next, let''s remove our `http.ListenAndServe` function and change it to `http.ListenAndServeTLS`.
    This requires a couple of additional parameters that encompass the location of
    the keys:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们删除`http.ListenAndServe`函数，并将其更改为`http.ListenAndServeTLS`。这需要一些额外的参数，包括密钥的位置：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the sake of being more explicit, let''s also modify our `secureRequest`
    handler slightly:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更加明确，让我们稍微修改我们的`secureRequest`处理程序：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we run this now and go to our browser, we''ll hopefully see a warning, assuming
    that our browser would keep us safe:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行这个并转到我们的浏览器，希望会看到一个警告，假设我们的浏览器会保护我们：
- en: '![Adding TLS support](img/1304OS_05_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![添加TLS支持](img/1304OS_05_03.jpg)'
- en: 'Assuming we trust ourselves, which is not always advisable, click through and
    we''ll see our message from the secure handler:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们信任自己，这并不总是明智的，点击通过，我们将看到来自安全处理程序的消息：
- en: '![Adding TLS support](img/1304OS_05_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![添加TLS支持](img/1304OS_05_04.jpg)'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: And of course, if we again visit `http://localhost:8080`, we should now be automatically
    redirected with a 301 status code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们再次访问`http://localhost:8080`，我们现在应该会自动重定向，并显示301状态代码。
- en: Creating self-signed certificates is otherwise fairly easy when you have access
    to an OS that supports OpenSSL.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有访问支持OpenSSL的操作系统时，创建自签名证书通常是相当容易的。
- en: You can get a signed (but not verified) certificate for free through a number
    of services for a one-year period if you'd like to experiment with real certificates
    and not self-signed ones. One of the more popular ones is StartSSL ([https://www.startssl.com/](https://www.startssl.com/)),
    which makes getting free and paid certificates a painless process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要尝试使用真实证书而不是自签名证书，您可以通过多种服务免费获得一年期的签名（但未经验证）证书。其中比较流行的是StartSSL（[https://www.startssl.com/](https://www.startssl.com/)），它使得获取免费和付费证书变得简单。
- en: Letting users register and authenticate
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让用户注册和认证
- en: You may recall that as part of our API application we have a self-contained
    interface that allows us to serve a HTML interface for the API itself. Any discussion
    of security goes out the door if we don't lock down our users.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，作为我们API应用的一部分，我们有一个自包含的接口，允许我们为API本身提供HTML界面。如果我们不保护我们的用户，任何关于安全性的讨论都将毫无意义。
- en: Of course, the absolute simplest way of implementing user authentication security
    is through the storage and use of a password with a hashing mechanism. It's tragically
    common for servers to store passwords in clear text, so we won't do that; but,
    we want to implement at least one additional security parameter with our passwords.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，实现用户身份验证安全的绝对最简单的方法是通过存储和使用带有哈希机制的密码。服务器以明文存储密码是非常常见的，所以我们不会这样做；但是，我们希望至少使用一个额外的安全参数来实现我们的密码。
- en: We want to store not just the user's password, but at least a salt to go along
    with it. This is not a foolproof security measure, although it severely limits
    the threat of dictionary and rainbow attacks.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望不仅存储用户的密码，而且至少存储一个盐。这并不是一个绝对安全的措施，尽管它严重限制了字典和彩虹攻击的威胁。
- en: To do this, we'll create a new package called `password` as part of our suite,
    which allows us to generate random salts and then encrypt that value along with
    the password.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将创建一个名为`password`的新包，作为我们套件的一部分，它允许我们生成随机盐，然后加密该值以及密码。
- en: We can use `GenerateHash()` to both create and validate passwords.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`GenerateHash()`来创建和验证密码。
- en: A quick hit – generating a salt
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速入门-生成盐
- en: 'Getting a password is simple, and creating a secure hash is also fairly easy.
    What we''re missing to make our authentication process more secure is a salt.
    Let''s look at how we can do this. First, let''s add both a password and a salt
    field to our database:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 获取密码很简单，创建安全哈希也相当容易。为了使我们的身份验证过程更安全，我们缺少的是盐。让我们看看我们如何做到这一点。首先，让我们在我们的数据库中添加一个密码和一个盐字段：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With this in place, let''s take a look at our password package that will contain
    the salt and hash generation functions:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们来看看我们的密码包，其中包含盐和哈希生成函数：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our `GenerateSalt()` function produces a random string of characters within
    a certain set of characters. In this case, we want to start at 32 in the ASCII
    table and go up to 126.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`GenerateSalt()`函数生成一串特定字符集内的随机字符。在这种情况下，我们希望从ASCII表中的32开始，一直到126。
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we generate a hash based on a password and a salt. This is useful not
    just for the creation of a password but also for validating it. The following
    `ReturnPassword()` function primarily operates as a wrapper for other functions,
    allowing you to create a password and return its hashed value:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们基于密码和盐生成一个哈希。这不仅对于密码的创建有用，还对于验证密码也有用。以下的`ReturnPassword()`函数主要作为其他函数的包装器，允许您创建密码并返回其哈希值：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: On our client side, you may recall that we sent all of our data via AJAX in
    jQuery. We had a single method on a single Bootstrap tab that allowed us to create
    users. First, let's remind ourselves of the tab setup.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的客户端，您可能还记得我们通过jQuery通过AJAX发送了所有数据。我们在一个单独的Bootstrap标签上有一个单独的方法，允许我们创建用户。首先，让我们回顾一下标签设置。
- en: 'And now, the `userCreate()` function, wherein we''ve added a few things. First,
    there''s a password field that allows us to send that password along when we create
    a user. We may have been less comfortable about doing this before without a secure
    connection:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`userCreate()`函数中，我们添加了一些东西。首先，有一个密码字段，允许我们在创建用户时发送该密码。在没有安全连接的情况下，我们可能以前对此不太放心：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we can modify our `.ajax` response to react to different HTTP status
    codes. Remember that we are already setting up a conflict if a username or an
    e-mail ID already exists. So, let''s handle this as well:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以修改我们的`.ajax`响应以对不同的HTTP状态代码做出反应。请记住，如果用户名或电子邮件ID已经存在，我们已经设置了冲突。因此，让我们也处理这个问题：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, if we get a response of 200, we know our API-side has created the user.
    If we get 409, we report to the user that the e-mail address or username is taken
    in the alert area.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们得到一个200的响应，我们知道我们的API端已经创建了用户。如果我们得到409，我们会在警报区域向用户报告电子邮件地址或用户名已被使用。
- en: Examining OAuth in Go
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中检查OAuth
- en: As we briefly touched on in [Chapter 4](ch04.html "Chapter 4. Designing APIs
    in Go"), *Designing APIs in Go*, OAuth is one of the more common ways of allowing
    an application to interact with a third-party app using another application's
    user authentication.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第4章](ch04.html "第4章。在Go中设计API")中简要提到的，*在Go中设计API*，OAuth是允许应用使用另一个应用的用户身份验证与第三方应用进行交互的一种常见方式。
- en: It's extraordinarily popular in social media services; Facebook, Twitter, and
    GitHub all use OAuth 2.0 to allow applications to interface with their APIs on
    behalf of users.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它在社交媒体服务中非常受欢迎；Facebook、Twitter和GitHub都使用OAuth 2.0允许应用代表用户与其API进行交互。
- en: It's noteworthy here because while there are many API calls that we are comfortable
    leaving unrestricted, primarily the `GET` requests, there are others that are
    specific to users, and we need to make sure that our users authorize these requests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的是，虽然有许多API调用我们可以放心地不受限制，主要是`GET`请求，但还有一些是特定于用户的，我们需要确保我们的用户授权这些请求。
- en: 'Let''s quickly review the methods that we can implement to enable something
    akin to OAuth with our server:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下我们可以实现的方法，以使我们的服务器类似于OAuth：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Given that we have a small, largely demonstration-based service, our risk in
    keeping access tokens active for a long time is minimal. Long-lived access tokens
    obviously open up more opportunities for unwanted access by keeping the said access
    open to clients, who may not be observing the best security protocols.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们有一个小型的、主要基于演示的服务，我们长时间保持访问令牌活动的风险是很小的。长期有效的访问令牌显然会为客户端开放更多的不受欢迎的访问机会，因为它们可能没有遵守最佳的安全协议。
- en: In normal conditions, we'd want to set an expiry on a token, which we can do
    pretty simply by using a memcache system or a keystore with expiration times.
    This allows values to die naturally, without having to explicitly destroy them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，我们希望对令牌设置一个到期时间，我们可以通过使用一个带有过期时间的memcache系统或密钥库来简单地实现这一点。这样可以使值自然死亡，而无需显式销毁它们。
- en: 'The first thing we''ll need to do is add a table for client credentials, namely
    `consumer_key` and `consumer_token`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为客户端凭据添加一个表，即`consumer_key`和`consumer_token`：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We'll check the details against our newly created database to verify credentials,
    and if they are correct, we'll return an access token.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查详细信息以验证凭据是否正确，并且如果正确，我们将返回一个访问令牌。
- en: An access token can be of any format; given our low security restrictions for
    a demonstration, we'll return an MD5 hash of a randomly generated string. In the
    real world, this probably wouldn't be sufficient even for a short-lived token,
    but it will serve its purpose here.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌可以是任何格式；鉴于我们对演示的低安全限制，我们将返回一个随机生成的字符串的MD5哈希。在现实世界中，即使对于短期令牌，这可能也不够，但它在这里能够达到目的。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Remember, we implemented a random string generator as part of our `password`
    package. You can create a quick key and secret value in `api.go` by calling the
    following statements:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们在`password`包中实现了一个随机字符串生成器。您可以通过调用以下语句在`api.go`中创建一个快速的密钥和密钥值：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you feed this key and secret value into the previously created table and
    associate it with an existing user, you'll have an active API client. Note that
    this may generate invalid URL characters, so we'll restrict our access to the
    `/oauth/token` endpoint to `POST`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将此密钥和密钥值输入到先前创建的表中，并将其与现有用户关联，您将拥有一个活动的API客户端。请注意，这可能会生成无效的URL字符，因此我们将将我们对`/oauth/token`端点的访问限制为`POST`。
- en: Our pseudo OAuth mechanism will go into its own package, and it will strictly
    generate tokens that we'll keep in a slice of tokens within our API package.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的伪OAuth机制将进入自己的包中，并且它将严格生成我们将在API包中的令牌切片中保留的令牌。
- en: 'Within our core API package, we''ll add two new functions to validate credentials
    and the `pseudoauth` package:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的核心API包中，我们将添加两个新函数来验证凭据和`pseudoauth`包：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The functions that we'll add are `CheckCredentials()` and `CheckToken()`. The
    first will accept a key, a nonce, a timestamp, and an encryption method, which
    we'll then hash along with the `consumer_secret` value to see that the signature
    matches. In essence, all of these request parameters are combined with the mutually
    known but unbroadcasted secret to create a signature that is hashed in a mutually
    known way. If those signatures correspond, the application can issue either a
    request token or an access token (the latter is often issued in exchange for a
    request token and we'll discuss more on this shortly).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加的函数是`CheckCredentials()`和`CheckToken()`。第一个将接受一个密钥、一个一次性号码、一个时间戳和一个加密方法，然后我们将与`consumer_secret`值一起对其进行哈希处理，以查看签名是否匹配。实质上，所有这些请求参数都与双方知道但未广播的秘密结合在一起，以创建一个以双方知道的方式进行哈希处理的签名。如果这些签名对应，应用程序可以发出请求令牌或访问令牌（后者通常用于交换请求令牌，我们将很快讨论更多内容）。
- en: In our case, we'll accept a `consumer_key` value, a nonce, a timestamp, and
    a signature and for the time being assume that HMAC-SHA1 is being used as the
    signature method. SHA1 is losing some favor do to the increased feasibility of
    collisions, but for the purpose of a development application, it will do and can
    be simply replaced later on. Go also provides SHA224, SHA256, SHA384, and SHA512
    out of the box.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将接受`consumer_key`值、一次性号码、时间戳和签名，暂时假设HMAC-SHA1被用作签名方法。由于SHA1发生碰撞的可能性增加，它正在失去一些青睐，但是对于开发应用程序的目的，它将会并且可以在以后简单地替换。Go还提供了SHA224、SHA256、SHA384和SHA512。
- en: The purpose of the nonce and timestamp is exclusively added security. The nonce
    works almost assuredly as a unique identifying hash for the request, and the timestamp
    allows us to expire data periodically to preserve memory and/or storage. We're
    not going to do this here, although we will check to make sure that a nonce has
    not been used previously.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性号码和时间戳的目的是专门增加安全性。一次性号码几乎肯定作为请求的唯一标识哈希，时间戳允许我们定期过期数据以保留内存和/或存储。我们这里不会这样做，尽管我们将检查以确保一次性号码以前没有被使用。
- en: 'To begin authenticating the client, we look up the shared secret in our database:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始验证客户端，我们在数据库中查找共享密钥。
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we''re taking the `consumer_key` value and looking up our shared `consumer_secret`
    token, which we''ll pass along to our `ValidateSignature` function as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取`consumer_key`值并查找我们共享的`consumer_secret`令牌，然后将其传递给我们的`ValidateSignature`函数，如下所示：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we find our request to be invalid (either due to incorrect credentials or
    an existing nonce), we''ll return an unauthorized error and a 401 status code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现我们的请求无效（要么是因为凭据不正确，要么是因为存在的一次性号码），我们将返回未经授权的错误和401状态码：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Otherwise, we''ll return the access code in a JSON body response. Here''s the
    code for the `pseudoauth` package itself:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们将在JSON主体响应中返回访问代码。这是`pseudoauth`包本身的代码：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Nothing too surprising here! We''ll need some crypto packages and `math/rand`
    to allow us to seed:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多令人惊讶的地方！我们需要一些加密包和`math/rand`来允许我们进行种子生成：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There''s a bit more here than what we''ll use at the moment, but you can see
    that we can create tokens with specific access rights:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里比我们目前使用的要多一点，但你可以看到我们可以创建具有特定访问权限的令牌：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is a rough approximation of how services like OAuth attempt to validate
    signed requests; a nonce, a public key, a timestamp, and the shared private key
    are evaluated using the same encryption. If they match, the request is valid.
    If they don't match, an error should be returned.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类似于OAuth这样的服务尝试验证签名请求的粗略近似；一次性号码、公钥、时间戳和共享私钥使用相同的加密进行评估。如果它们匹配，请求是有效的。如果它们不匹配，应该返回错误。
- en: 'We can use the timestamp later to give a short window for any given request
    so that in case of an accidental signature leak, the damage can be minimized:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍后使用时间戳为任何给定的请求提供一个短暂的窗口，以便在意外签名泄漏的情况下，可以将损害最小化：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Making requests on behalf of users
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代表用户进行请求
- en: When it comes to making requests on behalf of users, there is a critical middle
    step that is involved in the OAuth2 process, and that's authentication on the
    part of the user. This cannot happen within a consumer application, obviously,
    because it would open a security risk wherein, maliciously or not, user credentials
    could be compromised.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在代表用户进行请求时，OAuth2过程中涉及一个关键的中间步骤，那就是用户的身份验证。显然，这不能在消费者应用程序中发生，因为这将打开一个安全风险，恶意或不恶意地，用户凭据可能会被泄露。
- en: Thus, this process requires a few redirects.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个过程需要一些重定向。
- en: First, the initial request that will redirect users to a login location is required.
    If they're already logged in, they'll have the ability to grant access to the
    application. Next, our service will take a callback URL and send the user back
    along with their request token. This will enable a third-party application to
    make requests on behalf of the user, unless and until the user restricts access
    to the third-party application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要一个初始请求，将用户重定向到登录位置。如果他们已经登录，他们将有能力授予应用程序访问权限。接下来，我们的服务将接受一个回调URL并将用户带回来，同时带上他们的请求令牌。这将使第三方应用程序能够代表用户进行请求，直到用户限制对第三方应用程序的访问为止。
- en: 'To store valid tokens, which are essentially permissive connections between
    a user and a third-party developer, we''ll create a database for this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储有效的令牌，这些令牌本质上是用户和第三方开发人员之间的许可连接，我们将为此创建一个数据库：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''ll need a few pieces to make this work, first, a login form for users who
    are not presently logged in, by relying on a `sessions` table. Let''s create a
    very simple implementation in MySQL now:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些部件来使其工作，首先是一个登录表单，用于当前未登录的用户，依赖于`sessions`表。让我们现在在MySQL中创建一个非常简单的实现：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, we'll need an authorization form for users who are logged in that allows
    us to create a valid API access token for the user and service and redirects the
    user to the callback.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个授权表单，用于已登录用户，允许我们为用户和服务创建有效的API访问令牌，并将用户重定向到回调地址。
- en: 'The template can be a very simple HTML template that can be placed at `/authorize`.
    So, we need to add that route to `api.go`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以是一个非常简单的HTML模板，可以放置在`/authorize`。因此，我们需要将该路由添加到`api.go`中：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Requests to `POST` will check confirmation and if all is well, pass this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对`POST`的请求将检查确认，如果一切正常，就会传递这个：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Go''s templating language is largely, but not completely, without logic. We
    can use an `if` control structure to keep both pages'' HTML code in a single template.
    For brevity, we''ll also create a very simple `Page` struct that allows us to
    construct very basic response pages:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Go的模板语言在很大程度上没有逻辑，但并非完全没有逻辑。我们可以使用`if`控制结构将两个页面的HTML代码放在一个模板中。为了简洁起见，我们还将创建一个非常简单的`Page`结构，使我们能够构建非常基本的响应页面：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We're not going to maintain login state for now, which means each user will
    need to log in anytime they wish to give a third party access to make API requests
    on their behalf. We'll fine-tune this as we go along, particularly in using secure
    session data and cookies that are available in the Gorilla toolkit.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们不会维护登录状态，这意味着每个用户都需要在希望授权第三方代表他们进行API请求时登录。随着我们的进展，我们将对此进行微调，特别是在使用Gorilla工具包中可用的安全会话数据和cookie方面。
- en: So, the first request will include a login attempt with a `consumer_key` value
    to identify the application. You can also include the full credentials (nonce,
    and so on) here, but since this will only allow your application access to a single
    user, it's probably not necessary.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个请求将包括一个带有`consumer_key`值的登录尝试，用于标识应用程序。您也可以在这里包括完整的凭据（nonce等），但由于这将只允许您的应用程序访问单个用户，这可能是不必要的。
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: All requests will be posted to the same address, which will then allow us to
    validate the login credentials (remember `GenerateHash()` from our `password`
    package), and if they are valid, we will create the connection in `api_connections`
    and then return the user to the callback URL associated with the API credentials.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有请求都将发布到同一个地址，然后我们将验证登录凭据（记住我们`password`包中的`GenerateHash()`），如果它们有效，我们将在`api_connections`中创建连接，然后将用户返回到与API凭据关联的回调URL。
- en: 'Here is the function that determines whether the login credentials are correct
    and if so, redirects to the callback URL with the `request_token` value that we
    created:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个确定登录凭据是否正确的函数，如果是的话，将使用我们创建的`request_token`值重定向到回调URL：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With the `user_password` value, the `user_salt` value, and a submitted password
    value, we can verify the validity of the password by using our `GenerateHash()`
    function and doing a direct comparison, as they are Base64 encoded.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`user_password`值，`user_salt`值和提交的密码值，我们可以通过使用我们的`GenerateHash()`函数并进行直接比较来验证密码的有效性，因为它们是Base64编码的。
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After checking `expectedPassword` against the password in the database, we can
    tell whether the user authenticated correctly. If they did, we create the token
    and redirect the user back to the callback URL. It is then the responsibility
    of the other application to store the token for future use.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`expectedPassword`与数据库中的密码进行对比后，我们可以判断用户是否成功进行了身份验证。如果是，我们会创建令牌并将用户重定向回回调URL。然后，其他应用程序有责任存储该令牌以备将来使用。
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now that we have the token on the third-party side, we can make API requests
    with that token and our `client_token` value to make requests on behalf of individual
    users, such as creating connections (friends and followers), sending automated
    messages, or setting status updates.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在第三方端有了令牌，我们可以使用该令牌和我们的`client_token`值进行API请求，代表个人用户进行请求，例如创建连接（好友和关注者），发送自动消息或设置状态更新。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We began this chapter by looking at ways to bring in more REST-style options
    and features, better security, and template-based presentation. Towards this goal,
    we examined a basic abstraction of the OAuth security model that allows us to
    enable external clients to work within a user's domain.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始本章时，看了一些带来更多REST风格选项和功能、更好的安全性以及基于模板的呈现的方法。为了实现这个目标，我们研究了OAuth安全模型的基本抽象，这使我们能够使外部客户端在用户的域内工作。
- en: With our application now accessible via OAuth-style authentication and secured
    by HTTPS, we can now expand the third-party integration of our social networking
    application, allowing other developers to utilize and augment our service.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序通过OAuth风格的身份验证并通过HTTPS进行了安全保护，我们现在可以扩展我们的社交网络应用程序的第三方集成，允许其他开发人员利用和增强我们的服务。
- en: In the next chapter, we'll look more at the client-side and consumer-side of
    our application, expanding our OAuth options and empowering more actions via the
    API that will include creating and deleting connections between users as well
    as creating status updates.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更多地关注我们应用程序的客户端和消费者端，扩展我们的OAuth选项，并通过API赋予更多的操作，包括创建和删除用户之间的连接，以及创建状态更新。
