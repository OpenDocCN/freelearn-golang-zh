- en: Chapter 7. Working with Other Web Technologies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。与其他Web技术合作
- en: In our last chapter, we looked at how our web service can play nicely and integrate
    with other web services through APIs or OAuth integrations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了我们的Web服务如何通过API或OAuth集成与其他Web服务良好地配合和集成。
- en: Continuing that train of thought, we'll take a pit stop as we develop the technology
    around our social network service to see how we can also integrate other technologies
    with it, independent of other services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这个思路，我们将在开发我们的社交网络服务周围的技术时停下来，看看我们如何还可以独立于其他服务集成其他技术。
- en: Very few applications run on a stack that's limited to just one language, one
    server type, or even one set of code. Often, there are multiple languages, operating
    systems, and designated purposes for multiple processes. You may have web servers
    running with Go on Ubuntu, which is a database server that runs PostgreSQL.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有应用程序仅在一个语言、一个服务器类型或甚至一个代码集上运行。通常有多种语言、操作系统和多个进程的指定目的。您可能在Ubuntu上使用Go运行Web服务器，这是运行PostgreSQL的数据库服务器。
- en: 'In this chapter, we''ll look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Serving our web traffic through a reverse proxy to leverage the more advanced
    features provided by mature HTTP products
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过反向代理来提供我们的Web流量，以利用成熟的HTTP产品提供的更高级功能
- en: Connecting to NoSQL or key/value datastores, which we can utilize as our core
    data provider or with which we can do ancillary work such as caching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到NoSQL或键/值数据存储，我们可以将其用作我们的核心数据提供程序，或者用它来进行辅助工作，如缓存
- en: Enabling sessions for our API and allowing clients and users to make requests
    without specifying credentials again
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的API启用会话，并允许客户和用户在不再指定凭据的情况下发出请求
- en: Allowing users to connect with each other by way of friending or adding other
    users to their network
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户通过添加其他用户到他们的网络来互相连接
- en: When we've finished all of this, you should have an idea about how to connect
    your web service with NoSQL and database solutions that are different to MySQL.
    We will utilize datastores later on to give us a performance boost in [Chapter
    10](ch10.html "Chapter 10. Maximizing Performance"), *Maximizing Performance*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成所有这些时，您应该对如何将您的Web服务与不同于MySQL的NoSQL和数据库解决方案连接有所了解。我们将在以后利用数据存储来在[第10章](ch10.html
    "第10章。最大化性能")*最大化性能*中提供性能提升。
- en: You will hopefully also be familiar enough with some out-of-the-box solutions
    for handling APIs, be able to bring middleware into your web service, and be able
    to utilize message passing to communicate between dissonant or segregated systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您还希望熟悉一些处理API的开箱即用解决方案，能够将中间件引入您的Web服务，并能够利用消息传递在不和谐或分离的系统之间进行通信。
- en: Let's get started by looking at ways in which we can connect with other web
    servers to impose some additional functionality and failure mitigation into our
    own service that is presently served solely by Go's `net/http` package.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始看看我们可以如何连接到其他Web服务器，以将一些额外的功能和故障处理引入我们目前仅由Go的`net/http`包提供服务的服务中。
- en: Serving Go through a reverse proxy
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过反向代理进行服务
- en: 'One of the most prominent features of Go''s internal HTTP server might have
    also triggered an immediate, skeptical response: if it''s so easy to start serving
    applications with Go, then is it fully featured as it relates to web serving?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Go内部HTTP服务器最突出的功能之一可能也引发了立即的怀疑回应：如果使用Go轻松启动应用程序服务，那么它是否与Web服务相关的功能齐全呢？
- en: This is an understandable question, particularly given Go's similarity to interpreted
    scripting languages. After all, Ruby on Rails, Python, NodeJS, and even PHP all
    come with out-of-the-box simple web servers. Rarely are these simple servers suggested
    as production-grade servers due to their limitations in feature set, security
    updates, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以理解的问题，特别是考虑到Go与解释脚本语言的相似性。毕竟，Ruby on Rails、Python、NodeJS，甚至PHP都带有开箱即用的简单Web服务器。由于它们在功能集、安全更新等方面的限制，很少有人建议将这些简单服务器用作生产级服务器。
- en: That being said, Go's `http` package is robust enough for many production-level
    projects; however, you may find not only some missing features but also some reliability
    by integrating Go with a reverse proxy that has a more mature web server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Go的`http`包对于许多生产级项目来说已经足够强大；然而，通过将Go与具有更成熟的Web服务器的反向代理集成，您可能不仅会发现一些缺失的功能，还会发现一些可靠性。
- en: A "reverse proxy" is a misnomer or at least a clunky way to illustrate an internal,
    incoming proxy that routes client requests opaquely through one system to another
    server, either within the same machine or network. In fact, it's often referred
    to simply as a gateway for this reason.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “反向代理”是一个错误的名称，或者至少是一种笨拙的方式来说明一个内部的、传入的代理，它将客户端请求不透明地通过一个系统路由到另一个服务器，无论是在同一台机器还是网络中。事实上，出于这个原因，它通常被简单地称为网关。
- en: The potential advantages are myriad. These include being able to employ a well-known,
    well-supported, fully featured web server (versus only having the building blocks
    to build your own in Go), having a large community for support, and having a lot
    of pre-built, available plugins and tools.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在的优势是多方面的。这些包括能够使用一个众所周知、得到充分支持、功能齐全的Web服务器（而不仅仅是在Go中构建自己的构建块）、拥有庞大的社区支持，以及拥有大量预构建的可用插件和工具。
- en: Whether it's necessary or advantageous or has a good return on investment is
    a matter of preference and the situation you're in, but it can often help in logging
    and debugging web apps.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有必要或有利，或者投资回报率如何，这取决于个人偏好和所处情况，但通常可以帮助记录和调试Web应用程序。
- en: Using Go with Apache
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go与Apache
- en: Apache's web server is the elder statesman in web serving. First released in
    1996, it quickly became a stalwart and as of 2009, it has served more than 100
    million websites. It has remained in the most popular web server in the world
    since shortly after its inception, although some estimates have placed Nginx as
    the new number 1 (we will talk a little more about this in some time).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Apache的Web服务器是Web服务器中的元老。自1996年首次发布以来，它迅速成为了一支坚实的力量，截至2009年，它已为超过1亿个网站提供服务。自诞生后不久，它一直是世界上最受欢迎的Web服务器，尽管一些估计将Nginx列为新的第一名（我们将在稍后谈一些关于这个的更多内容）。
- en: Putting Go behind Apache is super easy but there is one caveat; Apache, as it
    comes installed, is a blocking, nonconcurrent web server. This is different to
    Go, which delineates requests as goroutines or NodeJS or even Nginx. Some of these
    are bound to threads and some aren't. Go is obviously not bound, and this ultimately
    impacts how performant the servers can be.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将Go放在Apache后面非常容易，但有一个注意事项；Apache默认安装时是一个阻塞的、非并发的Web服务器。这与Go不同，Go将请求划分为goroutines或NodeJS甚至Nginx。其中一些绑定到线程，一些没有。Go显然没有绑定，这最终影响了服务器的性能。
- en: 'To start, let''s create a simple `hello world` web application in Go, which
    we''ll call `proxy-me.go`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在Go中创建一个简单的`hello world` Web应用程序，我们将其称为`proxy-me.go`：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There is nothing too complicated here. We listen on port 8080 and we have one
    very simple route, `/hello`, which just says `hello world`. To get Apache to serve
    this as a reverse proxy in pass-through, we edit our default server configuration
    as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太复杂的东西。我们在端口8080上监听，并且有一个非常简单的路由`/hello`，它只是说`hello world`。要让Apache作为透传的反向代理提供此服务，我们编辑我们的默认服务器配置如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The default server configuration is generally stored at `/etc/apache2/sites-enabled/`
    for Linux and `[Drive]:/[apache install directory]/conf/` in Windows.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 默认服务器配置通常存储在Linux的`/etc/apache2/sites-enabled/`和Windows的`[驱动器]:/[apache安装目录]/conf/`中。
- en: We can verify that we're seeing the page served by Apache rather than directly
    through Go by viewing the headers on a request to the `/hello` route.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看对`/hello`路由的请求的标头来验证我们看到的页面是由Apache提供而不是直接通过Go提供的。
- en: 'When we do this, we''ll see not only the Server as **Apache/2.4.7**, but also
    our custom header that was passed along. Typically, we''d use the **X-Forwarded-For**
    header for another purpose, but it''s analogous enough to use as a demonstration,
    as shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们不仅会看到服务器是**Apache/2.4.7**，还会看到我们传递的自定义标头。通常，我们会为其他目的使用**X-Forwarded-For**标头，但这足够类似，可以用作演示，如下面的屏幕截图所示：
- en: '![Using Go with Apache](img/1304OS_07_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![使用Go与Apache](img/1304OS_07_01.jpg)'
- en: Go and NGINX as reverse proxies
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go和NGINX作为反向代理
- en: While Apache is the old king of web serving, in recent years, it has been surpassed
    in popularity by Nginx at least by some measurements.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Apache是Web服务器的老大哥，但近年来，它在某些方面的受欢迎程度已被Nginx超越。
- en: Nginx was initially written as an approach to the C10K problem—serving 10,000
    concurrent connections. It's not an impossible task, but one that previously required
    expensive solutions to address it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx最初是作为解决C10K问题的方法编写的——提供1万个并发连接。这并不是一个不可能的任务，但以前需要昂贵的解决方案来解决它。
- en: Since Apache, by default, spawns new threads and/or processes to handle new
    requests, it often struggles under heavy load.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Apache默认会生成新的线程和/或进程来处理新请求，它经常在重负载下挣扎。
- en: On the other hand, Nginx was designed with an event model that is asynchronous
    and does not spawn new processes for each request. In many ways this makes it
    complementary to the way Go works with concurrency in the HTTP package.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Nginx设计为采用异步事件模型，不会为每个请求生成新进程。在许多方面，这使得它与Go在HTTP包中的并发工作方式互补。
- en: 'Like Apache, the benefits of putting Nginx instead of Go are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与Apache一样，将Nginx放在Go之后的好处如下：
- en: It has access and error logs. This is something that you'll need to build using
    the log package in Go. While it's easy enough to do, it's one fewer hassle.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有访问和错误日志。这是您需要使用Go中的日志包构建的内容。虽然这很容易做到，但这是一个更少的麻烦。
- en: It has extraordinarily fast static file serving. In fact, Apache users often
    use Nginx exclusively to serve static files.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有非常快的静态文件服务。事实上，Apache用户经常使用Nginx专门用于提供静态文件。
- en: It has SPDY support. SPDY is a new and somewhat experimental protocol that manipulates
    the HTTP protocol to introduce some speed and security features. There are some
    attempts to implement Go's HTTP and TLS at package libraries for SPDY, but nothing
    has been built natively into the net/HTTP package.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有SPDY支持。SPDY是一种新的、有些实验性的协议，它操纵HTTP协议引入了一些速度和安全功能。有一些尝试实现Go的HTTP和TLS包库用于SPDY，但还没有在net/HTTP包中构建出来。
- en: It has built-in caching options and hooks for popular caching engines.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有内置的缓存选项和流行缓存引擎的钩子。
- en: It has the flexibility to delegate some requests to other processes.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有将一些请求委托给其他进程的灵活性。
- en: We will discuss the usage of SPDY directly in both Nginx and within Go in [Chapter
    10,](ch10.html "Chapter 10. Maximizing Performance") *Maximizing Performance*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第10章](ch10.html "第10章。最大化性能")*最大化性能*中直接讨论在Nginx和Go中使用SPDY。
- en: It's worth noting that asynchronous, nonblocking, and concurrent HTTP serving
    will almost always be bound to the constraints of technical externalities such
    as network latency, file and database blocking, and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，异步、非阻塞和并发的HTTP服务几乎总是受到技术外部因素的限制，比如网络延迟、文件和数据库阻塞等。
- en: With that in mind, let's take a look at the setup for quickly putting Nginx
    instead of Go as a reverse proxy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们来看一下快速将Nginx作为反向代理而不是Go的设置。
- en: Nginx allows a pass through very simply by modifying the default configuration
    file. Nginx has no native support for Windows yet; so, in most *nix solutions,
    this file can be found by navigating to `/etc/nginx/sites-enabled`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx允许通过简单修改默认配置文件进行透传。Nginx目前还没有对Windows的原生支持；因此，在大多数*nix解决方案中，可以通过导航到`/etc/nginx/sites-enabled`找到该文件。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Alternately, you can do a proxy globally by making the change within the `.conf`
    file available at `/etc/nginx/nginx.conf`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过在`/etc/nginx/nginx.conf`中的`.conf`文件中进行更改来全局代理。
- en: Let's look at a sample Nginx configuration operation that will let us proxy
    our server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个样本Nginx配置操作，让我们代理我们的服务器。
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this modification in place, you can start Nginx by running `/etc/init.d/nginx`,
    and then start the Go server with `go run proxy-me.go`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个修改，您可以通过运行`/etc/init.d/nginx`来启动Nginx，然后通过`go run proxy-me.go`来启动Go服务器。
- en: 'If we hit our localhost implementation, we''ll see something that looks a lot
    like our last request''s headers but with Nginx instead of Apache as our proxy
    server:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问本地主机实现，我们将看到与上次请求的标头非常相似，但代理服务器是Nginx而不是Apache：
- en: '![Go and NGINX as reverse proxies](img/1304OS_07_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Go和NGINX作为反向代理](img/1304OS_07_02.jpg)'
- en: Enabling sessions for the API
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为API启用会话
- en: Mostly, we expose APIs for machines to use. In other words, we expect that some
    applications will be directly interfacing with our web service rather than the
    users.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们会为机器暴露API。换句话说，我们期望一些应用程序将直接与我们的网络服务进行交互，而不是用户。
- en: However, this is not always the case. Sometimes, users interact with APIs using
    the browser, either directly or through a conduit like JavaScript with JSONP and/or
    AJAX requests.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况并非总是如此。有时，用户直接或通过JavaScript与JSONP和/或AJAX请求等方式使用浏览器与API进行交互。
- en: In fact, the fundamentals of the aesthetics of Web 2.0 were rooted in providing
    users a seamless, desktop-like experience. This has come to fruition today and
    includes a lot of JavaScript MVC frameworks that handle presentation layers. We'll
    tackle this in our next chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Web 2.0美学的基本原则在于为用户提供无缝的、类似桌面的体验。这在今天已经实现，并包括许多处理表示层的JavaScript MVC框架。我们将在下一章中解决这个问题。
- en: The term Web 2.0 has largely been supplanted and it is now usually referred
    to as a **Single Page App** or **SPA**. What was once a mixture of server-generated
    (or served) HTML pages with some pieces built or updated through XML and JavaScript
    has ceded to JavaScript frameworks that build entire client-side applications.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Web 2.0这个术语已经基本被取代，现在通常被称为**单页应用**或**SPA**。曾经是一种混合了服务器生成（或提供）HTML页面和一些通过XML和JavaScript构建或更新的部分，现在已经让位给了构建整个客户端应用程序的JavaScript框架。
- en: Almost all of these rely on an underlying API, which is generally accessible
    through stateless requests over HTTP/HTTPS, although some newer models use web
    sockets to enable real-time communication between the server and the presentation
    model. This is something that we'll look at in the next chapter as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些几乎都依赖于底层API，通常通过HTTP/HTTPS进行无状态请求访问，尽管一些较新的模型使用Web套接字来实现服务器和表示模型之间的实时通信。这也是我们将在下一章中看到的内容。
- en: Irrespective of the model, you cannot simply expose this API to the world without
    some authentication. If, for example, an API is accessible from a `/admin` request
    without authentication, it's probably also accessible from outside. You cannot
    rely on a user's information such as an HTTP referer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 无论模型如何，您都不能简单地将此API暴露给世界而不进行一些身份验证。例如，如果API可以在没有身份验证的情况下从`/admin`请求访问，那么它很可能也可以从外部访问。您不能依赖用户的信息，比如HTTP引用者。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Grammarians may note the misspelling of referrer in the previous sentence. However,
    it's not a typo. In the initial HTTP request for comments proposal, the term was
    included without the double *r* in the spelling and it has largely stuck ever
    since.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 语法学家可能会注意到上一句中引用者的拼写错误。然而，这不是一个打字错误。在最初的HTTP请求评论提案中，该术语的拼写中没有双* r*，自那时以来它基本上一直保持不变。
- en: However, relying on every OAuth request is overkill when it's a user who is
    making many requests per page. You could cache tokens in local storage or cookies,
    but browser support for the former is still limited and the latter limits the
    revocability of a token.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当用户在每个页面上进行多次请求时，依赖每个OAuth请求就有些过度了。您可以在本地存储或cookie中缓存令牌，但前者的浏览器支持仍然有限，后者会限制令牌的撤销。
- en: A traditional and simple solution for this is to allow sessions for authentication
    that are based on cookies. You may still want to leave an API open for access
    from outside a main application so that it can be authenticated via an API key
    or OAuth, but it should also enable users to interface with it directly from client-side
    tools to provide a clean SPA experience.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这方面的一个传统而简单的解决方案是允许基于cookie的身份验证会话。您可能仍然希望为主应用程序之外的访问开放API，以便可以通过API密钥或OAuth进行身份验证，但它还应该允许用户直接使用客户端工具与其进行交互，以提供清晰的SPA体验。
- en: Sessions in a RESTful design
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RESTful设计中的会话
- en: It's worth noting that because sessions typically enforce some sense of state,
    they are not inherently considered as a part of a RESTful design. However, it
    can also be argued that sessions can be used solely for authentication and not
    state. In other words, an authentication and a session cookie can be used elusively
    as a method for verifying identity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，因为会话通常强制执行某种状态，它们并不被认为是RESTful设计的一部分。然而，也可以说会话仅用于身份验证而不是状态。换句话说，身份验证和会话cookie可以被单独用作验证身份的方法。
- en: Of course, you can also do this by passing a username and password along with
    every secure request. This is not an unsafe practice on its own, but it means
    that users will need to supply this information with every request, or the information
    will need to be stored locally. This is the problem that sessions that are stored
    in cookies attempt to solve.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以通过在每个安全请求中传递用户名和密码来实现这一点。这本身并不是一种不安全的做法，但这意味着用户需要在每个请求中提供这些信息，或者这些信息需要被本地存储。这就是存储在cookie中的会话试图解决的问题。
- en: As mentioned earlier, this will never apply to third-party applications, which
    for the most part need some sort of easily revokable key to work and rarely have
    a username and a password (although ours are tied to users, so they technically
    do).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，这永远不会适用于第三方应用程序，因为它们大部分需要某种易于撤销的密钥来工作，很少有用户名和密码（尽管我们的用户名和密码与用户绑定，所以从技术上讲也有）。
- en: The easiest way to do this is to allow a username and a password to go directly
    into the URL request, and you may see this sometimes. The risk here is that if
    a user shares the URL in full accidentally, the data will be compromised. In fact,
    this happens often with newer GitHub users, as it's possible to automatically
    push config files that contain GitHub passwords.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是允许用户名和密码直接进入URL请求，有时你可能会看到这种情况。这里的风险是，如果用户意外地分享了完整的URL，数据将会被泄露。事实上，这在新手GitHub用户中经常发生，因为可能会自动推送包含GitHub密码的配置文件。
- en: To reduce this risk, we should mandate that a username and a password be passed
    via a header field, although it should still be in cleartext. Assuming that a
    solid TSL (or SSL) option is in place, cleartext in the header of the request
    is not inherently a problem, but could be one if an application can at any point
    switch to (or be accessed by) unsecure protocols. This is a problem that time-restricted
    token systems attempt to address.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少这种风险，我们应该要求用户名和密码通过标头字段传递，尽管它仍然是明文的。假设一个可靠的TSL（或SSL）选项已经就位，请求标头中的明文并不是一个固有的问题，但如果应用程序随时可以切换到（或被访问到）不安全的协议，这可能会成为一个问题。这是一个有时间限制的令牌系统试图解决的问题。
- en: We can store session data anywhere. Our application presently uses MySQL, but
    session data will be read frequently. So, it's not ideal to encumber our database
    with information that has very little in terms of relational information.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将会话数据存储在任何地方。我们的应用目前使用的是MySQL，但会话数据将经常被读取。因此，在数据库中存储几乎没有关系信息的信息并不理想。
- en: Remember, we'll be storing an active user, their session's start time, the last
    update time (changed with every request), and perhaps where they are within the
    application. This last piece of information can be used in our application to
    tell users what their friends are currently doing within our social network.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们将存储一个活跃用户，他们会话的开始时间，最后更新时间（每次请求都会更改），以及他们在应用程序中的位置。我们的应用程序可以使用这些信息来告诉用户他们的朋友目前在我们的社交网络中做什么。
- en: With these conditions in mind, relying on our primary datastore is not an ideal
    solution. What we want is something more ephemeral, faster, and more concurrent
    that enables many successive requests without impacting our datastore.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些条件，依赖我们的主要数据存储并不是一个理想的解决方案。我们想要的是更加短暂、更快速、更具并发性的东西，可以在不影响我们的数据存储的情况下处理许多连续的请求。
- en: One of the most popular solutions today for handling sessions in this regard
    is to yield relational databases to NoSQL solutions that include document and
    column stores or key-value datastores.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如今处理会话的最流行解决方案之一是将关系数据库转移到包括文档和列存储或键值数据存储在内的NoSQL解决方案中。
- en: Using NoSQL in Go
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中使用NoSQL
- en: Long ago, the world of data storage and retrieval was relegated almost exclusively
    to the realm of relational databases. In our application, we are using MySQL,
    largely because it's been a lingua franca for quick applications and SQL translates
    fairly easily across similar databases (Microsoft's SQL Server, PostgreSQL, Oracle,
    and so on).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，数据存储和检索的世界几乎完全被限制在关系数据库的领域。在我们的应用程序中，我们使用的是MySQL，主要是因为它一直是快速应用程序的通用语言，而且SQL在类似的数据库（如微软的SQL
    Server、PostgreSQL、Oracle等）之间相对容易转换。
- en: In recent years, however, a big push has been made toward NoSQL. More accurately,
    the push has been towards data storage solutions that rely less on typical relational
    database structures and schemas and more on highly performant, key-value stores.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，近年来，对NoSQL进行了大力推动。更准确地说，推动的是依赖于典型关系数据库结构和模式较少的数据存储解决方案，而更多地依赖于高性能的键值存储。
- en: A key-value store is exactly what anyone who works with associative arrays,
    hashes, and maps (in Go) would expect, that is, some arbitrary data associated
    with a key. Many of these solutions are very fast because of the lack of indexed
    relationships, mitigation of locking, and a de-emphasis of consistency. In fact,
    many solutions guarantee no ACIDity out of the box (but some offer methods for
    employing it optionally).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 键值存储正是任何使用关联数组、哈希和映射（在Go中）的人所期望的，即与一个键相关联的一些任意数据。许多这些解决方案非常快，因为它们缺乏索引关系、减少了锁定，并且不太强调一致性。事实上，许多解决方案在开箱即用时不保证ACID性（但一些提供了可选的使用方法）。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**ACID** refers to the properties that developers expect in a database application.
    Some or all of these may be missing or may be optional parameters in any given
    NoSQL or key-value datastore solution. The term **ACID** can be elaborated as
    follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**ACID**指的是开发人员在数据库应用程序中期望的属性。在任何给定的NoSQL或键值数据存储解决方案中，这些属性可能有一些或全部缺失或是可选参数。**ACID**这个术语可以详细解释如下：'
- en: '**Atomicity**: This indicates that all parts of a transaction must succeed
    for any part to succeed'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：这表示事务的所有部分必须成功才能成功'
- en: '**Consistency**: This refers to the database''s state at the start of a transaction
    does not change before the completion of a transaction'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：这指的是事务完成之前，数据库在事务开始时的状态不会发生变化'
- en: '**Isolation**: This refers to the table or row locking mechanism that prevents
    access to data that is presently in the state of transaction'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：这指的是防止访问处于事务状态的数据的表或行锁定机制'
- en: '**Durability**: This ensures that a successful transaction can and will survive
    a system or application failure'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：这确保了成功的事务可以并且将在系统或应用程序故障时幸存'
- en: NoSQL solutions can be used for a lot of different things. They can be outright
    replacements for SQL servers. They can supplement data with some data that requires
    less consistency. They can work as quickly accessible, automatically expiring
    cache structures. We'll look at this in a moment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL解决方案可以用于许多不同的事情。它们可以直接替代SQL服务器。它们可以用一些需要较少一致性的数据来补充数据。它们可以作为快速可访问的、自动过期的缓存结构。我们稍后会看到这一点。
- en: If you choose to introduce a NoSQL solution into your application, be thoughtful
    about the potential impact this could bring to your application. For example,
    you can consider whether the potential tradeoff for ACID properties will be outweighed
    by performance boosts and horizontal scalability that a new solution provides.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择在应用程序中引入NoSQL解决方案，请考虑这可能给您的应用程序带来的潜在影响。例如，您可以考虑ACID属性的潜在权衡是否会被新解决方案提供的性能提升和水平可扩展性所抵消。
- en: While almost any SQL or traditional relational database solution out there has
    some integration with Go's `database/sql` package, this is not often the case
    with key-value stores that need some sort of package wrapper around them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然几乎所有的SQL或传统关系数据库解决方案都与Go的`database/sql`包有一些集成，但对于需要某种包装器的键值存储来说，情况并非总是如此。
- en: Now, we'll briefly look at a few of the most popular solutions for key-value
    stores and when we talk about caching in the next section, we'll come back and
    use NoSQL as a basic caching solution.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将简要介绍一些最受欢迎的键值存储解决方案，当我们在下一节讨论缓存时，我们将回来使用NoSQL作为基本缓存解决方案。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: NoSQL is, despite the recent resurgence, not a new concept. By definition, anything
    that eschews SQL or relational database concepts qualifies as NoSQL, and there
    have been dozens of such solutions since the 1960s. It probably bears to be mentioned
    that we're not spending any time on these solutions—like Ken Thompson's DBM or
    BerkeleyDB—but instead the more modern stories.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最近有所复苏，但NoSQL并不是一个新概念。根据定义，任何避开SQL或关系数据库概念的东西都可以称为NoSQL，自上世纪60年代以来就有数十种这样的解决方案。可能需要提到的是，我们不会花时间在这些解决方案上——比如Ken
    Thompson的DBM或BerkeleyDB——而是更现代的故事。
- en: Before we start exploring the various NoSQL solutions that we can use to handle
    sessions, let's enable them in our application by providing an alternative username/password
    authentication.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索各种NoSQL解决方案来处理会话之前，让我们通过提供替代的用户名/密码身份验证来在我们的应用程序中启用它们。
- en: 'You may recall that back when we enabled third-party authentication proxies,
    we enabled sessions and stored them in our MySQL database in the `CheckLogin()`
    function. This function was only called in response to a `POST` request to the
    `ApplicationAuthorize` function. We''ll open this up to more methods. First, let''s
    create a new function called `CheckSession()`, if it doesn''t exist, which will
    validate the cookie''s session ID, and then validate against our session store
    if it does:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得当我们启用了第三方身份验证代理时，我们在`CheckLogin()`函数中启用了会话并将它们存储在我们的MySQL数据库中。这个函数只会在对`ApplicationAuthorize`函数的`POST`请求的响应中调用。我们将扩展到更多的方法。首先，让我们创建一个新函数叫做`CheckSession()`，如果它不存在的话，它将验证cookie的会话ID，然后根据我们的会话存储进行验证：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You may recall that we also had a basic session struct and a method within
    `api.go`. We''ll move these to sessions as well:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得我们在`api.go`中有一个基本的会话结构和一个方法。我们也将把这些移到会话中：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command becomes the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令变成了以下内容：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To create our session store, we''ll make a new package called `sessions.go`
    within our API''s subdirectory/sessions. This is the skeleton without any NoSQL
    specific methods:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的会话存储，我们将在API的子目录/会话中创建一个名为`sessions.go`的新包。这是一个没有任何NoSQL特定方法的骨架：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's look at a few simple NoSQL models that have strong third-party integrations
    with Go to examine how we can keep these sessions segregated and enable client-side
    access to our APIs in a way that they remain secure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些与Go有强大第三方集成的简单NoSQL模型，以便检查我们如何保持这些会话分离，并以一种使客户端可以安全访问我们的API的方式启用它们。
- en: Memcached
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Memcached
- en: We'll start with Memcached, specifically because it's not really a datastore
    like our other options. While it is still a key-value store in a sense, it's a
    general purpose caching system that maintains data exclusively in memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Memcached开始，特别是因为它不像我们的其他选择那样真正是一个数据存储。虽然从某种意义上说它仍然是一个键值存储，但它是一个维护数据仅在内存中的通用缓存系统。
- en: Developed by Brad Fitzpatrick for the once massively popular LiveJournal site,
    it was designed and intended to reduce the amount of direct access to the database,
    which is one of the most common bottlenecks in web development.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由Brad Fitzpatrick为曾经非常流行的LiveJournal网站开发，旨在减少对数据库的直接访问量，这是Web开发中最常见的瓶颈之一。
- en: Memcached was originally written in Perl but has since been rewritten in C and
    it has reached a point of large-scale usage.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Memcached最初是用Perl编写的，但后来被重写为C，并且已经达到了大规模使用的程度。
- en: The pros and cons of this are already apparent—you get the speed of memory without
    the drag of disk access. This is obviously huge, but it precludes using data that
    should be consistent and fault tolerant without some redundancy process.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些的优缺点已经显而易见——您可以获得内存的速度，而不会受到磁盘访问的拖累。这显然是巨大的，但它排除了使用应该是一致和容错的数据而不经过一些冗余处理。
- en: For this reason, it's ideal for caching pieces of the presentation layer and
    sessions. Sessions are already ephemeral in nature, and Memcached's built-in expiration
    feature allows you to set a maximum age for any single piece of data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它非常适合缓存呈现层和会话的片段。会话本来就是短暂的，而Memcached的内置过期功能允许您为任何单个数据设置最大年龄。
- en: Perhaps Memcached's biggest advantage is its distributed nature. This allows
    multiple servers to share data in-memory values across a network.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 也许Memcached最大的优势是它的分布式特性。这允许多个服务器在网络中共享内存值的数据。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's worth noting here that Memcached operates as a first-in, first out system.
    Expiration is only necessary for programmatic purposes. In other words, there's
    no need to force a maximum age unless you need something to expire at a certain
    time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Memcached作为先进先出系统运行。过期只是为了编程目的而必要。换句话说，除非您需要在特定时间过期，否则没有必要强制设置最大年龄。
- en: 'In the `api.go` file, we''ll check a cookie against our Memcached session proxy,
    or we''ll create a session:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`api.go`文件中，我们将检查一个cookie是否与我们的Memcached会话代理匹配，或者我们将创建一个会话：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And then, here is our `sessions.go` file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这是我们的`sessions.go`文件：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`GetSession()` attempts to grab a session by key. If it exists in memory, it
    will pass its value to the referenced `UserSession` directly. Note that we make
    one minor change when we verify a session in the following code. We increase the
    cookie''s expiry time by one hour. This is optional, but it allows a session to
    remain active if a user leaves one hour after their last action (and not their
    first one):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetSession()`尝试通过键获取会话。如果它存在于内存中，它将直接将其值传递给引用的`UserSession`。请注意，在验证以下代码中的会话时，我们进行了一些微小的更改。我们将cookie的到期时间增加了一个小时。这是可选的，但如果用户在最后一次操作后一个小时离开，它允许会话保持活动状态：'
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Brad Fitzpatrick has joined the Go team at Google, so it should come as no surprise
    that he has written a Memcached implementation in Go. It should also come as no
    surprise that this is the implementation that we'll use for this example.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Brad Fitzpatrick已经加入了Google的Go团队，因此他在Go中编写了一个Memcached实现应该不足为奇。同样，这也不足为奇，这是我们在这个示例中将使用的实现。
- en: You can read more about this at [https://github.com/bradfitz/gomemcache](https://github.com/bradfitz/gomemcache)
    and install it using the `go get github.com/bradfitz/gomemcache/memcache` command.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/bradfitz/gomemcache](https://github.com/bradfitz/gomemcache)了解更多信息，并使用`go
    get github.com/bradfitz/gomemcache/memcache`命令进行安装。
- en: MongoDB
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB
- en: MongoDB is one of the earlier big names in the latter day NoSQL solutions; it
    is a document store that relies on JSON-esque documents with open-ended schemas.
    Mongo's format is called BSON, for Binary JSON. So, as you can imagine, this opens
    up some different data types, namely BSON object and BSON array, which are both
    stored as binary data rather than string data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是后来NoSQL解决方案中较早的大名鼎鼎的一个；它是一个依赖于具有开放式模式的类JSON文档的文档存储。Mongo的格式称为BSON，即二进制JSON。因此，可以想象，这打开了一些不同的数据类型，即BSON对象和BSON数组，它们都以二进制数据而不是字符串数据存储。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about the Binary JSON format at [http://bsonspec.org/](http://bsonspec.org/).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://bsonspec.org/](http://bsonspec.org/)了解有关二进制JSON格式的更多信息。
- en: As a superset, BSON wouldn't provide much in the way of a learning curve, and
    we won't be using binary data for session storage anyway, but there are places
    where storing data can be useful and thrifty. For example, BLOB data in SQL databases.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为超集，BSON不会提供太多的学习曲线，而且我们也不会使用二进制数据进行会话存储，但在某些情况下存储数据是有用且节省的。例如，在SQL数据库中的BLOB数据。
- en: MongoDB has earned some detractors in recent years as newer, more feature-rich
    NoSQL solutions have come to the forefront, but you can still appreciate and utilize
    the simplicity it provides.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，随着更新、功能更丰富的NoSQL解决方案的出现，MongoDB已经赢得了一些批评者，但您仍然可以欣赏和利用它提供的简单性。
- en: There are a couple of decent packages for MongoDB and Go out there, but the
    most mature is mgo.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些不错的MongoDB和Go包，但最成熟的是mgo。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information and download links for MongoDB are available at [http://www.mongodb.org/](http://www.mongodb.org/)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关MongoDB的更多信息和下载链接，请访问[http://www.mongodb.org/](http://www.mongodb.org/)
- en: mgo can be found at [https://labix.org/mgo](https://labix.org/mgo) and it can
    installed using the `go get gopkg.in/mgo.v2` command
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mgo可以在[https://labix.org/mgo](https://labix.org/mgo)找到，并且可以使用`go get gopkg.in/mgo.v2`命令进行安装
- en: Mongo does not come with a built-in GUI, but there are a number of third-party
    interfaces and quite a few of them are HTTP-based. Here, I'll recommend Genghis
    ([http://genghisapp.com/](http://genghisapp.com/)) that uses just a single file
    for either PHP or Ruby.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB没有内置的图形用户界面，但有许多第三方界面，其中很多是基于HTTP的。在这里，我会推荐Genghis ([http://genghisapp.com/](http://genghisapp.com/))，它只使用一个文件，可以用于PHP或Ruby。
- en: Let's look at how we can jump from authentication into session storage and retrieval
    using Mongo.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从身份验证跳转到使用Mongo进行会话存储和检索。
- en: We'll supplant our previous example with another. Create a second file and another
    package subdirectory called `sessions2.go`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用另一个示例取代我们之前的示例。创建第二个文件和另一个名为`sessions2.go`的包子目录。
- en: In our `api.go` file, change the import call from `Sessions "github.com/nkozyra/api/sessions"`
    to `Sessions "github.com/nkozyra/api/sessionsmongo"`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`api.go`文件中，将导入调用从`Sessions "github.com/nkozyra/api/sessions"`更改为`Sessions
    "github.com/nkozyra/api/sessionsmongo"`。
- en: 'We''ll also need to replace the `"github.com/bradfitz/gomemcache/memcache"`
    import with the mgo version, but since we''re just modifying the storage platform,
    much of the rest remains the same:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要用mgo版本替换`"github.com/bradfitz/gomemcache/memcache"`的导入，但由于我们只是修改存储平台，大部分内容仍然保持不变：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The big change to our struct in this case is that we're setting our data to
    BSON instead of JSON in the string literal attribute. This is not actually critical
    and it will still work with the `json` attribute type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们结构的重大变化是将我们的数据设置为BSON而不是字符串文字属性中的JSON。这实际上并不重要，它仍然可以与`json`属性类型一起使用。
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our method of connection obviously changes, but we also need to work within
    a collection (that is analogous to a table in database nomenclature), so we connect
    to our database and then the collection that are both named `session`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的连接方法显然会发生变化，但我们还需要在一个集合中工作（这类似于数据库术语中的表），因此我们连接到我们的数据库，然后连接到两者都命名为`session`的集合：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`GetSession()` works in almost exactly the same way, aside from the datastore
    method being switched to `Find()`. The `mgo.One()` function assigns the value
    of a single document (row) to an interface.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetSession()`的工作方式几乎完全相同，除了数据存储方法被切换为`Find()`。`mgo.One()`函数将单个文档（行）的值分配给一个接口。'
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Enabling connections using a username and password
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用用户名和密码启用连接
- en: To permit users to enter a username and password for their own connections instead
    of relying on a token or leaving the API endpoint open, we can create a piece
    of middleware that can be called directly into any specific function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户输入他们自己的连接的用户名和密码，而不是依赖令牌或者开放API端点，我们可以创建一个可以直接调用到任何特定函数中的中间件。
- en: 'In this case, we''ll do several authentication passes. Here''s an example in
    the `/api/users` GET function, which was previously open:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将进行几次身份验证。这是`/api/users` GET函数中的一个例子，它之前是开放的：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see the passes that we make here. First, we check for a token and then
    we check for an existing session. If this doesn't exist, we check for a login
    `username` and `password` and validate them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到我们所做的通行证。首先，我们检查令牌，然后检查现有会话。如果不存在，我们检查登录`用户名`和`密码`并验证它们。
- en: If all these three fail, then we return an unauthorized error.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这三个都失败了，那么我们返回一个未经授权的错误。
- en: 'Now, we already have the `MiddlewareAuth()` function in another part of the
    code in `ApplicationAuthorize()`, so let''s move it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在代码的另一个部分中已经有了`MiddlewareAuth()`函数，名为`ApplicationAuthorize()`，所以让我们把它移动一下：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If users access the `/api/users` endpoint via a `GET` method, they will now
    need a `username` and `password` combination, an `access_token`, or a valid session
    in cookie data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户通过`GET`方法访问`/api/users`端点，现在他们将需要一个`用户名`和`密码`组合，一个`access_token`，或者在cookie数据中有一个有效的会话。
- en: We also return the expected `user_id` on a valid authentication, which will
    otherwise return a value of 0.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在有效的身份验证时，我们还返回预期的`user_id`，否则将返回值为0。
- en: Allowing our users to connect to each other
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许我们的用户相互连接
- en: Let's take a step back into our application and add some functionality that's
    endemic to social networks—the ability to create connections such as friending.
    In most social networks, this grants read access to the data among those connected
    as friends.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，为我们的应用程序添加一些社交网络特有的功能——创建连接的能力，比如加好友。在大多数社交网络中，这将授予与好友相连的数据的读取权限。
- en: Since we already have a valid view to see users, we can create some new routes
    to allow users to initiate connections.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有一个有效的视图来查看用户，我们可以创建一些新的路由来允许用户发起连接。
- en: 'First, let''s add a few endpoints to our `Init()` function in the `api.go`
    file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`api.go`文件的`Init()`函数中添加一些端点：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we don't have a `PUT` request method here. Since our connections are
    friendships and binary, they won't be changed but they will be either created
    or deleted. For example, if we add a mechanism for blocking a user, we can create
    that as a separate connection type and allow changes to be made to it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们这里没有`PUT`请求方法。由于我们的连接是友谊和二进制的，它们不会被更改，但它们将被创建或删除。例如，如果我们添加一个阻止用户的机制，我们可以将其创建为一个单独的连接类型，并允许对其进行更改。
- en: 'Let''s set up a database table to handle these:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个数据库表来处理这些：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this in place, we can now duplicate the code that we used to ensure that
    the users are authenticated for our `/api/connections` `POST` method and allow
    them to initiate friend requests.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在可以复制我们用来确保用户对我们的`/api/connections` `POST`方法进行身份验证的代码，并允许他们发起好友请求。
- en: 'Let''s look at the `ConnectionsCreate()` method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`ConnectionsCreate()`方法：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the same code as our `/api/users` `GET` function. We'll come back to
    this after we look at the full example.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的`/api/users` `GET`函数的代码相同。在查看完整示例之后，我们将回到这里。
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we check for an existing user. If we are trying to connect to a user
    that doesn''t exist, we return a 410: Gone HTTP error.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查是否存在用户。如果我们试图连接到一个不存在的用户，我们返回一个410：Gone的HTTP错误。
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we check whether such a request has been initiated. If it has, then we
    also pass a Gone reference error. If neither of these error conditions is met,
    then we can create a relationship:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查是否已经发起了这样的请求。如果是，我们还会传递一个Gone引用错误。如果没有满足这些错误条件中的任何一个，那么我们可以创建一个关系：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With a successful call, we create a pending user relationship between the authenticated
    user and the intended one.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用后，我们在认证用户和目标用户之间创建一个待处理的用户关系。
- en: You may have noted the duplication of code in this function. This is something
    that's typically settled with middleware and Go has some options that are available
    to inject in the process. In the next chapter, we'll look at some frameworks and
    packages that can assist in this as well to build our own middleware.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了这个函数中的代码重复。这通常是通过中间件解决的，Go有一些可用的选项可以在这个过程中注入。在下一章中，我们将看一些框架和包，它们也可以帮助构建我们自己的中间件。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have a featured social network that is available through web services
    with forced TLS, authentication from users, and it has the ability to interact
    with other users.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个功能齐全的社交网络，可以通过强制TLS的Web服务进行访问，用户可以进行身份验证，并且可以与其他用户进行交互。
- en: In this chapter, we also looked at offloading our session management to NoSQL
    databases and putting other web servers instead of Go to provide additional features
    and failover protections.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还研究了将会话管理转移到NoSQL数据库，并使用其他Web服务器代替Go来提供额外的功能和故障转移保护。
- en: In the next chapter, we'll flesh out our social network even more as we try
    to interact with our API from the client side. With the foundation in place that
    allows this, we can then let users directly authenticate and interact with the
    API through a client-side interface without needing API tokens, while simultaneously
    retaining the ability to use third-party tokens.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步完善我们的社交网络，尝试从客户端与我们的API进行交互。有了这个基础，我们可以让用户直接通过客户端界面进行身份验证和与API进行交互，而不需要API令牌，同时保留使用第三方令牌的能力。
- en: We'll also peek at using Go with complementary frontend frameworks like Go and
    Meteor to provide a more responsive, app-like web interface.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究如何使用Go与补充的前端框架，比如Go和Meteor，以提供更具响应性、类似应用的网络界面。
