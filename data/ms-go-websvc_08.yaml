- en: Chapter 8. Responsive Go for the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。Web的响应式Go
- en: If you spend any time developing applications on the Web (or off it, for that
    matter) it won't be long before you find yourself facing the prospect of interacting
    with an API from within a website itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您花费了任何时间在Web上（或者无论如何），开发应用程序，您很快就会发现自己面临从网站内部与API进行交互的前景。
- en: In this chapter, we'll bridge the gap between the client and the server by allowing
    the browser to work as a conduit for our web service directly via a few technologies
    that includes Google's own AngularJS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过允许浏览器直接通过一些技术作为我们的Web服务的传导器来弥合客户端和服务器之间的差距，其中包括谷歌自己的AngularJS。
- en: Earlier in this book, we created a stopgap client-side interface for our API.
    This existed almost exclusively for the purpose of viewing the details and output
    of our web service through a simple interface.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前面，我们为我们的API创建了一个临时的客户端接口。这几乎完全是为了通过一个简单的界面查看我们的Web服务的细节和输出而存在的。
- en: However, it's important to keep in mind that it's not only machines that are
    processing APIs, but also client-side interfaces that are initiated directly by
    the users. For this reason, we're going to look at applying our own API in this
    format. We will keep it locked down by domain and enable RESTful and non-RESTful
    attributes that will allow a website to be responsive (not necessarily in the
    mobile sense) and operate exclusively via an API using HTML5 features.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要记住，处理API的不仅是机器，还有由用户直接发起的客户端接口。因此，我们将考虑以这种格式应用我们自己的API。我们将通过域名锁定并启用RESTful和非RESTful属性，使网站能够响应（不一定是移动意义上的响应），并且仅通过使用HTML5功能的API进行操作。
- en: 'In this chapter, we''ll look at:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究：
- en: Using client-side frameworks like jQuery and AngularJS to dovetail with our
    server-side endpoints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像jQuery和AngularJS这样的客户端框架与我们的服务器端端点相结合
- en: Using server-side frameworks to create web interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器端框架创建Web界面
- en: Allowing our users to log in, view other users, create connections, and post
    messages via a web interface to our API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们的用户通过Web界面登录，查看其他用户，创建连接并发布消息到我们的API
- en: Extending the functionality of our web service, and expanding it to allow direct
    access via an interface that we'll build in Go
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展我们的Web服务的功能，并将其扩展为允许通过我们将在Go中构建的接口直接访问
- en: Employing HTML5 and several JavaScript frameworks to complement our server-side
    frameworks for Go
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5和几个JavaScript框架来补充我们的Go服务器端框架
- en: Creating a frontend interface
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建前端界面
- en: Before we get started, we'll need to address a couple of issues with the way
    browsers restrict information flow from the client to the server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要解决浏览器限制客户端到服务器信息流的一些问题。
- en: We'll also need to create an example site that works with our API. This should
    ideally be done on localhost on a different port or another machine because you
    will run into additional problems simply by using the `file://` access.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个与我们的API一起工作的示例站点。最好在本地主机上的不同端口或另一台机器上进行，因为仅使用`file://`访问就会遇到额外的问题。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the sake of building an API, it's entirely unnecessary to bundle an interface
    with the API, as we did for a simple demonstration earlier.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建API，与之前的简单演示一样，将接口与API捆绑在一起是完全不必要的。
- en: In fact, this may introduce cruft and confusion as a web service grows. In this
    example, we'll build our interface application separately and run it on port 444\.
    You can choose any available port that you like, assuming that it doesn't interfere
    with our web service (443). Note that on many systems access to ports 1024 and
    below require `root/sudo`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这可能会在Web服务增长时引入混乱。在这个例子中，我们将单独构建我们的界面应用程序，并在端口444上运行它。您可以选择任何可用的端口，假设它不会干扰我们的Web服务（443）。请注意，在许多系统上，访问端口1024及以下需要`root/sudo`。
- en: As is, if we attempt to run the interface on a different port than our secure
    web service, we'll run into cross-origin resource sharing issues. Make sure that
    any endpoint method that we expose for client-side and/or JavaScript consumption
    includes a header for `Access-Control-Allow-Origin`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在与我们的安全Web服务不同的端口上运行接口，我们将遇到跨域资源共享问题。确保我们为客户端和/或JavaScript消耗公开的任何端点方法都包括一个`Access-Control-Allow-Origin`头。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about the nature and mechanism of **Access-Control-Allow-Origin**
    at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)上阅读有关**Access-Control-Allow-Origin**的性质和机制的更多信息。
- en: 'You may be tempted to just use the `*` wildcard for this, but this will cause
    a lot of browser issues, particularly with the frontend frameworks that we''ll
    be looking at. As an example, let''s see what happens if we attempt to access
    the `/api/users` endpoint via `GET`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会诱惑只是使用`*`通配符，但这将导致许多浏览器问题，特别是我们将要研究的前端框架。例如，让我们看看如果我们尝试通过`GET`访问`/api/users`端点会发生什么：
- en: '![Creating a frontend interface](img/1304OS_08_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![创建前端界面](img/1304OS_08_01.jpg)'
- en: The results can be unreliable and some frameworks reject the wildcard entirely.
    Using a wildcard also disables some key features that you may be interested in
    such as cookies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能不可靠，一些框架完全拒绝通配符。使用通配符还会禁用一些您可能感兴趣的关键功能，例如cookies。
- en: 'You can see the following code that we used to attempt to access the web service
    to induce this error. The code is built in Angular, which we''ll look at in more
    detail shortly:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们用来尝试访问Web服务以引发此错误的以下代码。该代码是用Angular构建的，我们将很快更详细地研究它：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we''re making a `GET` request to our API endpoint. If this succeeds,
    we''ll add users to our `$scope.users` array that is iterated though an AngularJS
    loop, which is shown in the following code. Without a domain origin allowance
    for our client, this will fail due to cross-origin policies in the browser:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在向我们的API端点发出`GET`请求。如果成功，我们将将用户添加到`$scope.users`数组中，该数组将通过AngularJS循环进行迭代，如下所示。如果我们的客户端没有域来源允许，由于浏览器中的跨域政策，这将失败：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the way AngularJS deals with loops by allowing you to specify a JavaScript
    array that is associated directly with a DOM-specific variable or a loop.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是AngularJS处理循环的方式，允许您指定一个与特定于DOM的变量或循环直接关联的JavaScript数组。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we will get zero users due to the permissions' issue.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于权限问题，我们将得到零个用户。
- en: 'Luckily, we have previously addressed this issue in our application by introducing
    a very high-level configuration setting inside our `v1.go` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们之前在应用程序中通过在`v1.go`文件中引入了一个非常高级的配置设置来解决了这个问题：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You may recall that the `Init()` function accepts an array of allowed domains
    to which we can then set the `Access-Control-Allow-Origin` header:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得`Init()`函数接受一个允许的域名数组，然后我们可以设置`Access-Control-Allow-Origin`头：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As mentioned earlier, if we set a `*` wildcard domain, some browsers and libraries
    will disagree and the wildcard origin precludes the ability to neither set cookies
    nor honor SSL credentials. We can instead specify the domains more explicitly:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果我们设置一个`*`通配符域，一些浏览器和库会产生分歧，通配符来源会导致无法设置cookie或遵守SSL凭证的能力。我们可以更明确地指定域：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This permits you to retain the settings of the cookie and SSL certificate that
    are honoring the aspects of a non-wildcard access control header. It does open
    up some security issues that are related to cookies, so you must use this with
    caution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您能够保留cookie和SSL证书的设置，这些设置遵守了非通配符访问控制头的方面。这确实会带来一些与cookie相关的安全问题，因此您必须谨慎使用。
- en: If this loop is called within any function that can be accessible via a web
    interface, it will prevent the cross-origin issue.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此循环在通过网络界面可访问的任何函数中被调用，它将防止跨域问题。
- en: Logging in
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: As before, we'll use Twitter's Bootstrap as a basic CSS framework, which allows
    us to quickly replicate a site structure that we might see anywhere online.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们将使用Twitter的Bootstrap作为基本的CSS框架，这使我们能够快速复制一个我们可能在任何地方在线看到的站点结构。
- en: Remember that our earlier examples opened a login interface that simply passed
    a token to a third party for short-term use to allow the said application to perform
    actions on behalf of our users.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们之前的例子打开了一个登录界面，只是将一个令牌传递给第三方，以便允许该应用程序代表我们的用户执行操作。
- en: Since we're now attempting to allow our users to interface directly with our
    API (through a browser conduit), we can change the way that operates and allow
    sessions to serve as the authentication method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在试图允许用户直接通过我们的API（通过浏览器通道）进行接口，我们可以改变操作方式，允许会话作为认证方法。
- en: 'Previously, we were posting login requests directly via JavaScript to the API
    itself, but since we''re now using a full web interface, there''s no reason to
    do that; we can post directly to the web interface itself. This primarily means
    eschewing the `onsubmit="return false"` or `onsubmit="userCreate();"` methods
    and just sending the form data to `/interface/login` instead:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们是直接通过JavaScript将登录请求发布到API本身，但现在我们使用完整的网络界面，没有理由这样做；我们可以直接发布到网络界面本身。这主要意味着放弃`onsubmit="return
    false"`或`onsubmit="userCreate();"`方法，只需将表单数据发送到`/interface/login`：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This gives us enough to allow a web interface to create and login to our accounts
    utilizing existing code and still through the API.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了足够的内容，允许网络界面利用现有代码创建和登录到我们的帐户，同时仍然通过API进行。
- en: Using client-side frameworks with Go
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go的客户端框架
- en: While we've spent the bulk of this book building a backend API, we've also been
    building a somewhat extensible, basic framework for the server-side.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本书的大部分时间里构建了一个后端API，但我们也一直在构建一个相对可扩展的基本服务器端框架。
- en: When we need to access an API from the client side, we're bound by the limitations
    of HTML, CSS, and JavaScript. Alternatively, we can render pages on the server
    side as a consumer and we'll show that in this chapter as well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要从客户端访问API时，我们受到HTML、CSS和JavaScript的限制。或者，我们可以作为消费者在服务器端呈现页面，并且我们也将在本章中展示这一点。
- en: However, most modern web applications operate on the client-side, frequently
    in the **single-page application** or **SPA**. This attempts to reduce the number
    of "hard" page requests that a user has to make, which makes a site appear less
    like an application and more like a collection of documents.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数现代网络应用程序在客户端上运行，通常是在**单页应用程序**或**SPA**中。这试图减少用户必须进行的“硬”页面请求的数量，使站点看起来不太像一个应用程序，而更像是一组文档。
- en: The primary way this is done is through asynchronous JavaScript data requests,
    which allow an SPA to *redraw* a page in response to user actions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是通过异步JavaScript数据请求完成的，它允许SPA在响应用户操作时*重新绘制*页面。
- en: 'At first, there were two big drawbacks to this approach:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这种方法有两个主要缺点：
- en: First, the application state was not preserved, so if a user took an action
    and attempted to reload the page, the application would reset.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，应用程序状态没有得到保留，因此如果用户采取行动并尝试重新加载页面，应用程序将重置。
- en: Secondly, JavaScript-based applications fared very poorly in search engine optimization
    because a traditional web scraper would not render the JavaScript applications.
    It will only render the raw HTML applications.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，基于JavaScript的应用在搜索引擎优化方面表现非常糟糕，因为传统的网络爬虫无法渲染JavaScript应用程序。它只会渲染原始的HTML应用程序。
- en: But recently, some standardization and hacks have helped to mitigate these issues.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但最近，一些标准化和技巧已经帮助减轻了这些问题。
- en: On state, SPAs have started utilizing a new feature in HTML5 that enables them
    to modify the address bar and/or history in browsers without requiring reloads,
    often by utilizing inline anchors. You can see this in an URL in Gmail or Twitter,
    which may look something like [https://mail.google.com/mail/u/0/#inbox/1494392317a0def6](https://mail.google.com/mail/u/0/#inbox/1494392317a0def6).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态上，SPAs已经开始利用HTML5中的一个新功能，使它们能够在浏览器中修改地址栏和/或历史记录，而无需重新加载，通常是通过使用内联锚点。您可以在Gmail或Twitter的URL中看到这一点，它可能看起来像[https://mail.google.com/mail/u/0/#inbox/1494392317a0def6](https://mail.google.com/mail/u/0/#inbox/1494392317a0def6)。
- en: This enables the user to share or bookmark a URL that is built through a JavaScript
    controller.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用户能够通过JavaScript控制器分享或收藏URL。
- en: On SEO, this largely relegated SPAs to admin-type interfaces or areas where
    search engine accessibility was not a key factor. However, as search engines have
    begun parsing JavaScript, the window is open for widespread usage without negatively
    impacting the effects on SEO.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在SEO方面，这在很大程度上将SPAs局限于管理类型的界面或搜索引擎可访问性不是关键因素的领域。然而，随着搜索引擎开始解析JavaScript，窗口已经打开，可以广泛使用而不会对SEO产生负面影响。
- en: jQuery
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery
- en: If you do any frontend work or have viewed the source of any of the most popular
    websites on the planet, then you've encountered jQuery.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做任何前端工作或查看过地球上最流行的网站之一的源代码，那么你一定遇到过jQuery。
- en: According to SimilarTech, jQuery is used by just about 67 million websites.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据SimilarTech的数据，jQuery被大约6700万个网站使用。
- en: jQuery evolved as a method of standardizing an API among browsers where consistency
    was once an almost impossible task. Between the brazen self-determination of Microsoft's
    Internet Explorer and browsers that stuck to standards at variable levels, writing
    cross-browser code was once a very complicated matter. In fact, it was not uncommon
    to see this website best viewed with tags because there was no guarantee of functionality
    even with the latest versions of any given browser.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery作为一种标准化API的方法发展起来，其中一致性曾经是一项几乎不可能的任务。在微软的Internet Explorer和各种程度上坚持标准的浏览器之间，编写跨浏览器代码曾经是一件非常复杂的事情。事实上，以前经常会看到这个网站最好使用标签来查看，因为即使使用了任何给定浏览器的最新版本，也无法保证功能。
- en: When jQuery took hold (following other similar frameworks such as Prototype,
    Moo Tools, and Dojo), the world of web development finally found a way to cover
    most of the available, modern web browsers with a single interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当jQuery开始流行（在Prototype、Moo Tools和Dojo等其他类似框架之后），Web开发领域终于找到了一种方法，可以使用单一接口覆盖大多数现有的现代Web浏览器。
- en: Consuming APIs with jQuery
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用jQuery消耗API
- en: Working with our API using jQuery couldn't be much simpler. When jQuery first
    started to come to fruition, the notion of AJAX was really taking hold. **AJAX**
    or **Asynchronous JavaScript** and **XML** were the first iteration towards a
    web technology that utilized the `XMLHttpRequest` object to get remote data and
    inject it into the DOM.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery处理我们的API非常简单。当jQuery开始出现时，AJAX的概念真的开始流行起来。**AJAX**或**异步JavaScript**和**XML**是朝着利用`XMLHttpRequest`对象获取远程数据并将其注入到DOM的Web技术的第一次迭代。
- en: It's with some degree of irony that Microsoft, which is often considered as
    the greatest offender of web standards, laid the groundwork for `XMLHttpRequest`
    in the Microsoft Exchange Server that lead to AJAX.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 具有一定讽刺意味的是，微软，通常被认为是最严重违反网络标准的公司，却在Microsoft Exchange Server中为`XMLHttpRequest`奠定了基础，从而导致了AJAX的出现。
- en: Today, of course, XML is rarely a part of the puzzle, as most of what is consumed
    in these types of libraries is JSON. You can still use XML as source data, but
    it's likely that your responses will be more verbose than necessary.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如今XML很少成为谜题的一部分，因为这些库中消耗的大部分内容都是JSON。您仍然可以使用XML作为源数据，但您的响应可能会比必要的更冗长。
- en: Doing a simple `GET` request couldn't be easier as jQuery provides a simple
    shorthand function called `getJSON`, which you can use to get data from our API.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 进行简单的`GET`请求非常简单，因为jQuery提供了一个简单的快捷函数，称为`getJSON`，您可以使用它从我们的API获取数据。
- en: 'We''ll now iterate through our users and create some HTML data to inject into
    an existing DOM element:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将遍历我们的用户，并创建一些HTML数据注入到现有的DOM元素中：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `GET` requests will only "get" us so far though. To be fully compliant with
    a RESTful web service, we need to be able to do the `GET`, `POST`, `PUT`, `DELETE`,
    and `OPTIONS` header requests. In fact, the last method will be important to allow
    requests across disparate domains.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`GET`请求只能让我们走得更远。为了完全符合RESTful网络服务，我们需要能够执行`GET`、`POST`、`PUT`、`DELETE`和`OPTIONS`头请求。实际上，最后一种方法将很重要，以允许跨不同域的请求。
- en: 'As we mentioned earlier, `getJSON` is a shorthand function for the built-in
    `ajax()` method, which allows more specificity in your requests. For example,
    `$.getJSON(''/api/users'')` translates into the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`getJSON`是内置的`ajax()`方法的简写函数，它允许您在请求中更具体。例如，`$.getJSON('/api/users')`转换为以下代码：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that we can technically handle all endpoints and methods in our API
    by setting the `HTTP` method directly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以通过直接设置`HTTP`方法来技术上处理API中的所有端点和方法。
- en: While `XMLHttpRequest` accepts all of these headers, HTML forms (at least through
    HTML 4) only accept the `GET` and `POST` requests. Despite this, it's always a
    good idea to do some cross-browser testing if you're going to be using `PUT`,
    `DELETE`, `OPTIONS`, or `TRACE` requests in client-side JavaScript.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`XMLHttpRequest`接受所有这些头部，但HTML表单（至少通过HTML 4）只接受`GET`和`POST`请求。尽管如此，如果您打算在客户端JavaScript中使用`PUT`、`DELETE`、`OPTIONS`或`TRACE`请求，进行一些跨浏览器测试总是一个好主意。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can download and read the very comprehensive documentation that jQuery
    provides at [http://jquery.com/](http://jquery.com/). There are a few common CDNs
    that allow you to include the library directly and the most noteworthy is Google
    Hosted Libraries, which is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://jquery.com/](http://jquery.com/)下载并阅读jQuery提供的非常全面的文档。有一些常见的CDN可以让您直接包含库，其中最值得注意的是Google
    Hosted Libraries，如下所示：
- en: '`<script src="img/jquery.min.js"></script>`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script src="img/jquery.min.js"></script>`'
- en: The latest version of the library is available at [https://developers.google.com/speed/libraries/devguide#jquery](https://developers.google.com/speed/libraries/devguide#jquery).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该库的最新版本可在[https://developers.google.com/speed/libraries/devguide#jquery](https://developers.google.com/speed/libraries/devguide#jquery)找到。
- en: AngularJS
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AngularJS
- en: If we go beyond the basic toolset that jQuery provides, we'll start delving
    into legitimate, fully formed frameworks. In the last five years these have popped
    up like weeds. Many of these are traditional **Model-View-Controller** (**MVC**)
    systems, some are pure templating systems, and some frameworks work on both the
    client- and server-side, providing a unique push-style interface through websockets.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们超越了jQuery提供的基本工具集，我们将开始深入研究合法的、完全成型的框架。在过去的五年里，这些框架如雨后春笋般涌现。其中许多是传统的**模型-视图-控制器**（**MVC**）系统，有些是纯模板系统，有些框架同时在客户端和服务器端工作，通过WebSockets提供了独特的推送式接口。
- en: Like Go, Angular (or AngularJS) is a project maintained by Google and it aims
    to provide full-featured MVC on the client side. Note that over time, Angular
    has moved somewhat away from MVC as a design pattern and it has moved more towards
    MVVM or Model View ViewModel, which is a related pattern.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与Go一样，Angular（或AngularJS）是由Google维护的项目，旨在在客户端提供全功能的MVC。请注意，随着时间的推移，Angular已经在设计模式上有所偏离，更多地朝向MVVM或Model
    View ViewModel，这是一种相关的模式。
- en: Angular goes far beyond the basic functionality that jQuery provides. In addition
    to general DOM manipulation, Angular provides true controllers as part of a larger
    app/application as well as for robust unit testing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Angular远远超出了jQuery提供的基本功能。除了一般的DOM操作外，Angular还提供了真正的控制器作为更大的应用程序的一部分，以及用于强大的单元测试。
- en: Among other things, Angular makes interfacing with APIs from the client side
    quick, easy, and pleasant. The framework provides a lot more MVC functionality
    that includes the ability to bring in separate templates from `.html`/`template`
    files.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除其他功能外，Angular使得从客户端快速、轻松、愉快地与API进行交互成为可能。该框架提供了更多的MVC功能，包括能够从`.html`/`template`文件中引入单独的模板的能力。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Actual push notifications are expected by many to become a standard feature
    in HTML5 as the specifications mature.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人预计实际的推送通知将成为HTML5的标准功能，随着规范的成熟。
- en: The W3C had a working draft for the Push API at the time of writing this book.
    You can read more about it at [http://www.w3.org/TR/2014/WD-push-api-20141007/](http://www.w3.org/TR/2014/WD-push-api-20141007/).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，W3C对推送API有一个工作草案。您可以在[http://www.w3.org/TR/2014/WD-push-api-20141007/](http://www.w3.org/TR/2014/WD-push-api-20141007/)了解更多信息。
- en: For now, workarounds include libraries such as Meteor (which will be discussed
    later) and others that utilize WebSockets in HTML5 to emulate real-time communication
    without being able to work within the confines of other browser-related restraints
    such as dormant processes in inactive tabs, and so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，解决方法包括诸如Meteor（稍后将讨论）等利用HTML5中的WebSockets来模拟实时通信，而不受其他浏览器相关限制的束缚，例如在非活动选项卡中的休眠进程等。
- en: Consuming APIs with Angular
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Angular消费API
- en: Enabling an Angular application to work with a REST API is, as with jQuery,
    built directly into the bones of the framework.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使Angular应用程序能够与REST API一起工作，就像jQuery一样，直接内置到框架的骨架中。
- en: 'Compare this call to the `/api/users` endpoint that we just looked at:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将此调用与我们刚刚查看的`/api/users`端点进行比较：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Except syntax, Angular isn't all that different from jQuery; it also has a method
    that accepts a callback function or a promise as a second parameter. However,
    instead of setting the property for the method similar to jQuery, Angular provides
    short methods for most of the HTTP verbs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语法外，Angular与jQuery并没有太大的不同；它也有一个接受回调函数或承诺作为第二参数的方法。但是，与jQuery设置方法的属性不同，Angular为大多数HTTP动词提供了简短的方法。
- en: 'This means that we can do our `PUT` or `DELETE` requests directly:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以直接进行`PUT`或`DELETE`请求：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that in the preceding example, we''re reading header values. To make this
    work across domains, you need to also set a header that enables these headers
    to be shared for other domains:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的示例中，我们正在读取标头值。为了使其跨域工作，您还需要设置一个标头，以便为其他域共享这些标头：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since domains are explicitly whitelisted with the `Access-Control-Allow-Origin`
    header, this controls the specific header keys that will be available to clients
    and not domains. In our case, we will set something for the `Last-Modified` and
    `Date` values.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于域名在`Access-Control-Allow-Origin`标头中被明确列入白名单，这控制了将可用于客户端而不是域的特定标头键。在我们的情况下，我们将为`Last-Modified`和`Date`值设置一些内容。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about Angular and download it from [https://angularjs.org/](https://angularjs.org/).
    You can also include the library directly from Google Hosted Libraries CDN, which
    is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://angularjs.org/](https://angularjs.org/)阅读更多关于Angular并从那里下载它。您还可以直接从Google
    Hosted Libraries CDN包含该库，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can find the most recent version of the library at [https://developers.google.com/speed/libraries/devguide#angularjs](https://developers.google.com/speed/libraries/devguide#angularjs).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://developers.google.com/speed/libraries/devguide#angularjs](https://developers.google.com/speed/libraries/devguide#angularjs)找到该库的最新版本。
- en: Setting up an API-consuming frontend
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个消费API的前端
- en: For the purpose of consuming an API, a frontend will be almost entirely free
    of internal logic. After all, the entirety of the application is called via HTML
    into a SPA, so we don't need much beyond a template or two.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用API，前端将几乎完全不包含内部逻辑。毕竟，整个应用程序都是通过HTML调用到SPA中的，所以我们除了一个或两个模板之外不需要太多东西。
- en: 'Here is our `header.html` file, which contains the basic HTML code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`header.html`文件，其中包含基本的HTML代码：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The line with `application.js` is noteworthy because that's where all the logic
    will exist and utilize one of the frontend frameworks below.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`application.js`的行很重要，因为那里将存在所有逻辑并利用下面的一个前端框架。
- en: The `ng-view` directive is no more than a placeholder that will be replaced
    with the values within a controller's routing. We'll look at that soon.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-view`指令只是一个占位符，将根据控制器的路由值替换。我们很快会看到。'
- en: Note that we're calling AngularJS, jQuery, and React all in this header. These
    are options and you shouldn't necessarily import all of them. In all likelihood,
    this will cause conflicts. Instead, we'll explore how to handle our API with each
    of them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在此处调用了AngularJS、jQuery和React。这些都是选项，您不一定需要全部导入。很可能会导致冲突。相反，我们将探讨如何使用它们处理我们的API。
- en: 'As you might expect, our footer will be primarily closing tags:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的，我们的页脚主要是闭合标签：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ll utilize Go''s `http` template system to generate our basic template.
    The example here shows this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用Go的`http`模板系统生成我们的基本模板。这里的示例显示了这一点：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The heart of this template will not be hardcoded, but instead, it will be built
    by the JavaScript framework of choice.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板的核心不会是硬编码的，而是由所选择的JavaScript框架构建的。
- en: Creating a client-side Angular application for a web service
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Web服务创建客户端Angular应用程序
- en: As mentioned earlier, the `ng-view` directive within an `ng-app` element refers
    to dynamic content that is brought in according to the router that pairs URLs
    with controllers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ng-app`元素中的`ng-view`指令是指根据将URL与控制器配对的路由动态引入的内容。
- en: More accurately, it joins the pseudo-URL fragments (which we mentioned earlier)
    that are built on top of the `#` anchor tag. Let's first set up the application
    itself by using the following code snippet.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，它连接了伪URL片段（我们之前提到的）构建在`#`锚标签之上。让我们首先通过以下代码片段设置应用程序本身。
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each one of these URLs, when they are accessed, tells Angular to pair a controller
    with a template and put them together within the `ng-view` element. This is what
    allows users to navigate across a site without doing hard page loads.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问这些URL时，Angular会告诉它将控制器与模板配对，并将它们放在`ng-view`元素中。这就是允许用户在站点之间导航而不进行硬页面加载的原因。
- en: 'Here is `auth.html`, which is held in our `/views/` directory and allows us
    to log in and perform a user registration:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`auth.html`，它位于我们的`/views/`目录中，允许我们登录并执行用户注册：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The JavaScript used to control this, as mentioned earlier, is merely a thin
    wrapper around our API. Here''s the `Login()` process:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，用于控制这一切的JavaScript只是我们API周围的一个薄包装。这是`Login()`过程：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And, here is the `Register()` process:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Register()`过程：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will like to make a note about the `OPTIONS` header here. This is an important
    part of how the CORS standard operates; essentially, requests are buffered with
    a preflight call using the `OPTIONS` verb that returns information on allowed
    domains, resources, and so on. In this case, we include a catchall called `APIDescribe`
    within `api.go`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在这里注意`OPTIONS`头。这是CORS标准运作的重要部分；基本上，请求通过使用`OPTIONS`动词进行预检调用进行缓冲，返回有关允许的域、资源等信息。在这种情况下，我们在`api.go`中包括一个名为`APIDescribe`的catchall：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Viewing other users
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看其他用户
- en: Once we are logged in, we should be able to surface other users to an authenticated
    user to allow them to initiate a connection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录，我们应该能够向经过身份验证的用户展示其他用户，以允许他们发起连接。
- en: 'Here''s how we can quickly view other users within our `users.html` Angular
    template:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何快速查看我们`users.html` Angular模板中的其他用户：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We make a call to our `/api/users` endpoint, which returns a list of users who
    are logged in. You may recall that we put this behind the authentication wall
    in the last chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用我们的`/api/users`端点，它返回一个已登录用户列表。您可能还记得我们在上一章中将其放在身份验证墙后面。
- en: '![Viewing other users](img/1304OS_08_02.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![查看其他用户](img/1304OS_08_02.jpg)'
- en: There's not a lot of flair with this view. This is just a way to see people
    who you may be interested in connecting with or friending in our social application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图没有太多的花哨。这只是一种方式，可以看到您可能有兴趣连接或在我们的社交应用中添加好友的人。
- en: Rendering frameworks on the server side in Go
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中服务器端呈现框架
- en: For the purposes of building pages, rendering frameworks is largely academic
    and it is similar to having prerendered pages from JavaScript and returning them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建页面，呈现框架在很大程度上是学术性的，它类似于使用JavaScript预渲染页面并返回它们。
- en: 'For this reason, our total code for an API consumer is extraordinarily simple:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的API消费者的总代码非常简单：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we designate a directory to use for template access, which is the idiomatic
    template in this case. We don't use `views` because we'll use that for our Angular
    templates, and those chunks of HTML are called by `templateUrl`. Let's first define
    our SSL port and add a handler.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定一个目录用于模板访问，这在这种情况下是惯用的模板。我们不使用`views`，因为我们将用它来放我们的Angular模板，那些HTML块被`templateUrl`调用。让我们首先定义我们的SSL端口并添加一个处理程序。
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That''s it for our endpoint. Now, we''re simply showing the HTML page. This
    can be done simply in any language and still interface with our web service easily:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的端点。现在，我们只是显示HTML页面。这可以简单地用任何语言完成，并且可以轻松地与我们的Web服务进行接口：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These last two lines allow serving files from a directory. Without these, we'll
    get error 404 when we attempt to call JavaScript or HTML include files. Let's
    add our SSLPort and certificates next.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行允许从目录中提供文件。如果没有这些，当我们尝试调用JavaScript或HTML包含文件时，我们将收到404错误。让我们接下来添加我们的SSL端口和证书。
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As mentioned earlier, the choice of the port and even HTTP or HTTPS is wholly
    optional, given that you allow the resulting domain to be in your list of permitted
    domains within `v1.go`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，端口的选择甚至是HTTP还是HTTPS都是完全可选的，只要您允许生成的域在`v1.go`中的允许域列表中。
- en: Creating a status update
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建状态更新
- en: Our last example allows a user to view their latest status updates and create
    another one. It's slightly different because it calls upon two different API endpoints
    in a single view—the loop for the latest statuses and the ability to post, that
    is, to create a new one.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个例子允许用户查看他们的最新状态更新并创建另一个。它略有不同，因为它在单个视图中调用了两个不同的API端点——用于最新状态的循环和发布的能力，也就是创建一个新的状态。
- en: 'The `statuses.html` file looks a little like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`statuses.html`文件看起来有点像这样：'
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we call on a `createStatus()` function within the controller to post
    to the `/api/statuses` endpoint. The rest of the code shown here shows a list
    of previous statuses through the ng-repeat directive:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在控制器中调用`createStatus()`函数来发布到`/api/statuses`端点。这里显示的其余代码通过ng-repeat指令显示了先前状态的列表：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code simply displays the text as it is returned.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码只是简单地显示返回的文本。
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Creating a status update](img/1304OS_08_03.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![创建状态更新](img/1304OS_08_03.jpg)'
- en: Here, we can see a simple demonstration where previous status messages are displayed
    below a form for adding new status messages.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个简单的演示，在添加新状态消息的表单下显示了先前的状态消息。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've touched on the very basics of developing a simple web service interface
    in Go. Admittedly, this particular version is extremely limited and vulnerable
    to attack, but it shows the basic mechanisms that we can employ to produce usable,
    formalized output that can be ingested by other services.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要介绍了在Go中开发简单Web服务接口的基础知识。诚然，这个特定版本非常有限且容易受攻击，但它展示了我们可以采用的基本机制，以产生可用的、正式的输出，可以被其他服务接收。
- en: Having superficially examined some of the big framework players for the Web
    as well as general purpose libraries such as jQuery, you have more than enough
    options to test your API against a web interface and create a single-page application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在对Web的一些主要框架以及诸如jQuery之类的通用库进行了初步检查后，您有足够多的选择来测试您的API与Web界面并创建单页面应用程序。
- en: At this point, you should have the basic tools at your disposal that are necessary
    to start refining this process and our application as a whole. We'll move forward
    and apply a fuller design to our API as we push forward, as two randomly chosen
    API endpoints will obviously not do much for us.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该已经掌握了开始完善这个过程和我们整个应用程序所需的基本工具。我们将继续前进，并在推进过程中对我们的API应用更全面的设计。显然，随机选择的两个API端点对我们来说并没有太多作用。
- en: In the next chapter we'll dive in deeper with API planning and design, the nitty-gritty
    of RESTful services, and look at how we can separate our logic from our output.
    We'll briefly touch on some logic/view separation concepts and move toward more
    robust endpoints and methods in [Chapter 3](ch03.html "Chapter 3. Routing and
    Bootstrapping"), *Routing and Bootstrapping*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨API规划和设计，RESTful服务的细节，以及如何将逻辑与输出分离。我们将简要涉及一些逻辑/视图分离的概念，并朝着更健壮的端点和方法迈进[第3章](ch03.html
    "第3章。路由和引导"), *路由和引导*。
