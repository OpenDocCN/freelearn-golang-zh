- en: Chapter 9. Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。部署
- en: When all is said and done, and you're ready to launch your web service or API,
    there are always considerations that need to be taken into account with regards
    to launching, from code repository, to staging, to live environments, to stop,
    start, and update policies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 说到底，当您准备启动您的Web服务或API时，总会有一些需要考虑的事项，从代码存储库到分段，到实时环境，到停止、启动和更新策略。
- en: Deploying compiled applications always carries a little more complexity than
    doing so with interpreted applications. Luckily, Go is designed to be a very modern,
    compiled language. By this, we mean that a great deal of thought has been devoted
    to the kinds of problems that traditionally plagued servers and services built
    in C or C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 部署编译应用程序总是比部署解释应用程序更加复杂。幸运的是，Go被设计为一种非常现代的编译语言。这意味着，人们已经付出了大量的思考，以解决传统上困扰C或C++构建的服务器和服务的问题。
- en: With this in mind, in this chapter, we're going to look at some tools and strategies
    that are available to us for painlessly deploying and updating our application
    with minimal downtime.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，在本章中，我们将探讨一些可用于轻松部署和更新应用程序的工具和策略，以最小化停机时间。
- en: We're also going to examine some things that we can do to reduce the internal
    load of our web service, such as offloading image storage and messaging as part
    of our deployment strategy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究一些可以减少我们的Web服务内部负载的方法，例如将图像存储和消息传递作为部署策略的一部分。
- en: By the end of this chapter, you should have some Go-specific and general tips
    that will minimize some of the heartache that is endemic to deploying APIs and
    web services, particularly those that are frequently updated and require the least
    amount of downtime.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您应该掌握一些特定于Go的和一般的技巧，可以最大限度地减少部署API和Web服务时常见的烦恼，特别是那些需要频繁更新并需要最少停机时间的服务。
- en: 'In this chapter, we''ll look at:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨：
- en: Application design and structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序设计和结构
- en: Deployment options and strategies for the cloud
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云端部署选项和策略
- en: Utilization of messaging systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用消息系统
- en: Decoupling image hosting from our API server and connecting it with a cloud-based
    CDN
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像托管与我们的API服务器分离，并将其连接到基于云的CDN
- en: Project structures
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: Though the design and infrastructure of your application is a matter of institutional
    and personal preference, the way you plan its architecture can have a very real
    impact on the approach that you use to deploy your application to the cloud or
    anywhere in production.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应用程序的设计和基础设施是机构和个人偏好的问题，但您计划其架构的方式可能会对您用于将应用程序部署到云端或任何生产环境中的方法产生真正的影响。
- en: 'Let''s quickly review the structure that we have for our application, keeping
    in mind that we won''t need package objects unless we intend to produce our application
    for mass cross-platform usage:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下我们应用程序的结构，记住除非我们打算为大规模跨平台使用而生产我们的应用程序，否则我们不需要包对象：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The structure of our application may be noteworthy depending on how we deploy
    it to the cloud.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序的结构可能会引人注目，具体取决于我们如何将其部署到云端。
- en: If there's a conduit process before deployment that handles the build, dependency
    management, and push to the live servers, then this structure is irrelevant as
    the source and Go package dependencies can be eschewed in lieu of the binary.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在部署之前有一个处理构建、依赖管理和推送到实时服务器的传输过程，那么这个结构就不相关了，因为源代码和Go包依赖可以被二进制文件所取代。
- en: However, in scenarios where the entire project is pushed to each application
    server or servers or NFS/file servers, the structure remains essential. In addition,
    as noted earlier, any place where cross-platform distribution is a consideration,
    the entire structure of the Go project should be preserved.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在整个项目被推送到每个应用服务器或服务器或NFS/文件服务器的情况下，结构仍然是必不可少的。此外，正如前面所指出的，任何需要考虑跨平台分发的地方，都应该保留Go项目的整个结构。
- en: Even when this is not critical, if the build machine (or machines) are not exactly
    like the target machines, this impacts your process for building the binary, although
    it does not preclude solely dealing with that binary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这并非至关重要，如果构建机器（或机器）与目标机器不完全相同，这会影响您构建二进制文件的过程，尽管这并不排除仅处理该二进制文件。
- en: In an example GitHub repository, it might also require to obfuscate the nonbinary
    code if there is any open directory access, similar to our `interface.go` application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个示例GitHub存储库中，如果存在任何开放目录访问，可能还需要对非二进制代码进行混淆，类似于我们的`interface.go`应用程序。
- en: Using process control to keep your API running
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用进程控制来保持您的API运行
- en: The methods for handling version control and development processes are beyond
    the scope of this book, but a fairly common issue with building and deploying
    compiled code for the Web is the process of installing and restarting the said
    processes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 处理版本控制和开发流程的方法超出了本书的范围，但在为Web构建和部署编译代码时，一个相当常见的问题是安装和重新启动这些进程的过程。
- en: Managing the way updates happen while minimizing or removing downtime is critical
    for live applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 管理更新的方式，同时最大限度地减少或消除停机时间对于实时应用程序至关重要。
- en: For scripting languages and languages that rely on an external web server to
    expose the application via the Web, this process is easy. The scripts either listen
    for changes and restart their internal web serving or they are interpreted when
    they are uncached and the changes work immediately.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于脚本语言和依赖外部Web服务器通过Web公开应用程序的语言来说，这个过程很容易。脚本要么监听更改并重新启动其内部Web服务，要么在未缓存时进行解释，并且更改立即生效。
- en: This process becomes more complicated with long-running binaries, not only for
    updating and deploying our application but also for ensuring that our application
    is alive and does not require manual intervention if the service stops.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长时间运行的二进制文件，这个过程变得更加复杂，不仅涉及更新和部署我们的应用程序，还涉及确保我们的应用程序处于活动状态，如果服务停止，不需要手动干预。
- en: Luckily, there are a couple of easy ways to handle this. The first is just strict
    process management for automatic maintenance. The second is a Go-specific tool.
    Let's look at process managers first and how they work with a Go web service.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有几种简单的方法来处理这个问题。第一种是自动维护的严格进程管理。第二种是一个特定于Go的工具。让我们首先看看进程管理器以及它们如何与Go Web服务一起工作。
- en: Using supervisor
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用监督者
- en: 'There are a few big solutions here for *nix servers, from the absurdly simple
    to the more complex and granular. There''s not a lot of difference in the way
    they operate, so we''ll just briefly examine how we can manage our web service
    with one: Supervisor. Supervisor is readily available on most Linux distributions
    as well as on OS X, so it is a good example for testing locally.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*nix服务器来说，这里有几个大的解决方案，从非常简单到更复杂和细粒度的解决方案。它们的操作方式没有太大的区别，因此我们将简要地介绍如何使用Supervisor来管理我们的Web服务。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some other process managers of note are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些值得注意的进程管理器如下：
- en: 'Upstart: [http://upstart.ubuntu.com/](http://upstart.ubuntu.com/)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Upstart: [http://upstart.ubuntu.com/](http://upstart.ubuntu.com/)'
- en: 'Monit: [http://mmonit.com/monit/](http://mmonit.com/monit/)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Monit: [http://mmonit.com/monit/](http://mmonit.com/monit/)'
- en: 'Runit: [http://smarden.org/runit/](http://smarden.org/runit/)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Runit: [http://smarden.org/runit/](http://smarden.org/runit/)'
- en: The basic premise of these direct supervision init daemon monitoring process
    managers is to listen for running applications if there are no live attempts to
    restart them based on a set of configured rules.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些直接监督初始化守护进程监控进程管理器的基本原则是监听运行的应用程序，如果没有根据一组配置的规则尝试重新启动它们。
- en: It's worth pointing out here that these systems have no real distributed methods
    that allow you to manage multiple servers' processes in aggregate, so you'll generally
    have to yield to a load balancer and network monitoring for that type of feedback.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，这些系统没有真正的分布式方法，允许您以聚合方式管理多个服务器的进程，因此通常需要依靠负载均衡器和网络监控来获取此类反馈。
- en: 'In the case of Supervisor, after installing it, all we need is a simple configuration
    file that can be typically located by navigating to `/etc/supervisor/conf.d/`
    on *nix distros. Here''s an example of such a file for our application:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Supervisor的情况下，安装完成后，我们只需要一个简单的配置文件，通常可以通过导航到*nix发行版上的`/etc/supervisor/conf.d/`来找到。以下是我们应用程序的一个示例文件：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While you can get more complex—for example, grouping multiple applications together
    to allow synchronous restarts that are useful for upgrades—that's all you should
    need to keep our long-running API going.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以变得更加复杂，例如，将多个应用程序组合在一起以允许同步重启，这对升级非常有用，但这就是您需要保持我们长时间运行的API的全部内容。
- en: 'When it''s time for updates, say from GIT to staging to live, a process that
    restarts the service can be triggered either manually or programmatically through
    a command such as the following one:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要更新时，比如从GIT到暂存再到线上，可以手动触发一个重新启动服务的进程，也可以通过命令以编程方式触发，比如以下命令：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This allows you to not only keep your application running, but it also imposes
    a full update process that pushes your code live and triggers a restart of the
    process. This ensures the least possible amount of downtime.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅可以使您的应用程序保持运行，还可以强制执行一个完整的更新过程，将您的代码推送到线上并触发进程的重新启动。这确保了最小的停机时间。
- en: Using Manners for more graceful servers
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Manners创建更加优雅的服务器
- en: While init replacement process managers work very well on their own, they do
    lack some control from within the application. For example, simply killing or
    restarting the web server would almost surely drop any active requests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然替代进程管理器在自己的工作中表现得很好，但它们在应用程序内部缺乏一些控制。例如，简单地杀死或重新启动Web服务器几乎肯定会中断任何活动的请求。
- en: On its own, Manners lacks some of the listening control of a process such as
    **goagain**, which is a library that corrals your TCP listeners in goroutines
    and allows outside control for restarts via SIGUSR1/SIGUSR2 interprocess custom
    signals.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用Manners时，缺少一些像**goagain**这样的进程的监听控制，它是一个将TCP监听器聚合到goroutines中，并允许通过SIGUSR1/SIGUSR2进程间自定义信号进行外部控制的库。
- en: However, you can use the two together to create such a process. Alternatively,
    you can write the internal listener directly, as goagain may end up being a slight
    overkill for the aim of gracefully restarting a web server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以将两者结合使用来创建这样的进程。或者，您可以直接编写内部监听器，因为对于优雅地重新启动Web服务器的目的，goagain可能会有点过度。
- en: 'An example of using Manners as a drop-in replacement/wrapper around `net/http`
    will look something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Manners作为`net/http`的替代/包装器的示例将如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After running within a goroutine and blocking with the channel that is listening
    for SIGUSR1 or SIGUSR2, we will pass our Boolean along the `Server.Shutdown` channel
    when such a signal is received.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在goroutine中运行并阻塞的通道监听SIGUSR1或SIGUSR2时，当接收到这样的信号时，我们将布尔值传递给`Server.Shutdown`通道。
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is just a rehash of our `Init()` function within `api.go`. This registers
    the Gorilla router that we'll need for our Manners wrapper.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们在`api.go`中`Init()`函数的重新处理。这注册了我们需要Manners包装的Gorilla路由器。
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `main()` function, instead of just starting our `http.ListenAndServe()`
    function, we use the Manners server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们不仅启动`http.ListenAndServe()`函数，还使用Manners服务器。
- en: This will prevent open connections from breaking when we send a shutdown signal.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将防止在发送关闭信号时断开开放的连接。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can install Manners with `go get github.com/braintree/manners`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`go get github.com/braintree/manners`来安装Manners。
- en: You can read more about Manners at [https://github.com/braintree/manners](https://github.com/braintree/manners).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/braintree/manners](https://github.com/braintree/manners)了解更多关于Manners的信息。
- en: You can install goagain with `go get github.com/rcrowley/goagain`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`go get github.com/rcrowley/goagain`来安装goagain。
- en: You can read more about goagain at [https://github.com/rcrowley/goagain](https://github.com/rcrowley/goagain).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/rcrowley/goagain](https://github.com/rcrowley/goagain)了解更多关于goagain的信息。
- en: Deploying with Docker
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker部署
- en: In the last few years, there have been very few server-side products that have
    made as big a wave as Docker in the tech world.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，几乎没有什么服务器端产品能像Docker在技术世界中引起如此大的轰动。
- en: Docker creates something akin to easily deployable, preconfigured virtual machines
    that have a much lower impact on the host machine than traditional VM software
    such as VirtualBox, VMWare, and the like.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Docker创建了类似于易于部署、预配置的虚拟机，与VirtualBox、VMWare等传统虚拟机软件相比，对主机的影响要小得多。
- en: It is able to do this with much less overall weight than VMs by utilizing Linux
    Containers, which allows the user space to be contained while retaining access
    to a lot of the operating system itself. This prevents each VM from needing to
    be a full image of the OS and the application for all practical purposes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它能够以比虚拟机更少的整体重量来实现这一点，通过利用Linux容器，这允许用户空间被包含，同时保留对操作系统本身的许多访问权限。这样一来，每个虚拟机就不需要成为操作系统和应用程序的完整镜像了。
- en: In order to be used in Go, this is generally a good fit, particularly if we
    create builds for multiple target processors and wish to easily deploy Docker
    containers for any or all of them. It is even better that the setup aspect is
    largely handled out of the box now, as Docker has created language stacks and
    included Go within them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Go中使用，这通常是一个很好的选择，特别是如果我们为多个目标处理器创建构建，并希望轻松部署Docker容器到任何一个或所有这些处理器。更好的是，现在设置方面基本上是开箱即用的，因为Docker已经创建了语言堆栈，并在其中包含了Go。
- en: While at its core Docker is essentially just an abstraction of a typical Linux
    distribution image, using it can make upgrading and quickly provisioning a breeze,
    and it may even provide additional security benefits. The last point depends a
    bit on your application and its dependencies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在其核心，Docker本质上只是一个典型Linux发行版镜像的抽象，但使用它可以使升级和快速配置变得轻而易举，甚至可能提供额外的安全性好处。最后一点取决于您的应用程序及其依赖关系。
- en: Docker operates with the use of very simple configuration files, and using a
    language stack, you can easily create a container that can be launched and has
    everything we need for our API.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用非常简单的配置文件，使用语言堆栈，您可以轻松创建一个容器，可以启动并具有我们API所需的一切。
- en: 'Take a look at this Docker file example to see how we''d get all the necessary
    packages for our social networking web service:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个Docker文件示例，看看我们如何为我们的社交网络网络服务获取所有必要的包：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The file can then be built and run using simple commands:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用简单的命令构建和运行该文件：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see how, at bare minimum, this would greatly speed up the Go update
    procedure across multiple instances (or containers in this case).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，至少在最低限度下，这将极大地加快Go更新过程，跨多个实例（或在这种情况下是容器）。
- en: Complete Docker the base images are also available for the Google Cloud Platform.
    These are useful for quickly deploying the most recent version of Go if you use
    or would like to test Google Cloud.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的Docker基础镜像也适用于Google云平台。如果您使用或希望测试Google Cloud，这对于快速部署最新版本的Go非常有用。
- en: Deploying in cloud environments
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云环境中部署
- en: For those who remember the days of rooms full of physical single-purpose servers,
    devastating hardware faults, and insanely slow rebuild and backup times, the emergence
    of cloud hosting has in all likelihood been a godsend.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些还记得满屋子都是物理单用途服务器、毁灭性的硬件故障和极其缓慢的重建和备份时间的人来说，云托管的出现很可能是一大福音。
- en: Nowadays, a full architecture can often be built from templates in short order,
    and autoscaling and monitoring are easier than ever. Now, there are a lot of players
    in the market too, from Google, Microsoft, and Amazon to smaller companies such
    as Linode and Digital Ocean that focus on simplicity, thrift, and ease of usage.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，一个完整的架构通常可以很快地从模板构建，自动扩展和监控也比以往更容易。现在，市场上也有很多参与者，从谷歌、微软和亚马逊到专注于简单、节俭和易用性的小公司，如Linode和Digital
    Ocean。
- en: Each web service comes with its own feature set as well as disadvantages, but
    most share a very common workflow. For the sake of exploring additional functionality
    that may be available via APIs within Golang itself, we'll look at Amazon Web
    Services.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络服务都有自己的功能集和缺点，但大多数都共享一个非常常见的工作流程。为了探索Golang本身可能通过API提供的其他功能，我们将看看亚马逊云服务。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that similar tools exist for other cloud platforms in Go. Even Microsoft's
    platform, Azure, has a client library that is written for Go.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，类似的工具也适用于Go的其他云平台。甚至微软的平台Azure也有一个专为Go编写的客户端库。
- en: Amazon Web Services
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 亚马逊云服务
- en: As with many of the aforementioned cloud services, deploying to Amazon Web Service
    or AWS is by and large no different than deploying it to any standard physical
    server's infrastructure.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与前述的许多云服务一样，部署到亚马逊云服务或AWS基本上与部署到任何标准物理服务器的基础设施没有太大区别。
- en: There are a few differences with AWS though. The first is the breadth of services
    provided by it. Amazon does not strictly deal with only static virtual servers.
    It also deals with an array of supportive services such as DNS, e-mail, and SMS
    services (via their SNS service), long-term storage, and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，AWS有一些区别。首先是它提供的服务范围。亚马逊不仅仅处理静态虚拟服务器。它还处理一系列支持服务，如DNS、电子邮件和短信服务（通过他们的SNS服务）、长期存储等等。
- en: Despite all that has been said so far, note that many of the alternate cloud
    services provide similar functionality that may prove analogous to that provided
    with the following examples.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管迄今为止已经说了很多，但请注意，许多备选云服务提供类似的功能，可能与以下示例提供的功能类似。
- en: Using Go to interface directly with AWS
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Go直接与AWS进行接口
- en: While some cloud services do offer some form of an API with their service, none
    are as robust as Amazon Web Services.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些云服务确实提供了某种形式的API与其服务配套，但没有一个像亚马逊云服务那样强大。
- en: The AWS API provides direct access to every possible action in its environment,
    from adding instances, to provisioning IP addresses, to adding DNS entries and
    much more.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: AWS API提供了对其环境中的每一个可能操作的直接访问，从添加实例、分配IP地址、添加DNS条目等等。
- en: As you might expect, interfacing directly with this API can open up a lot of
    possibilities since it relates to automating the health of your application as
    well as managing updates and bug fixes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的那样，直接与此API进行接口可以打开许多可能性，因为它涉及自动化应用程序的健康以及管理更新和错误修复。
- en: 'To interface with AWS directly, we''ll initiate our application with the `goamz`
    package:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接与AWS进行接口，我们将使用`goamz`包启动我们的应用程序：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To grab the two dependencies to run this example, run the `go get launchpad.net/goamz/aws`
    command and the `go get launchpad.net/goamz/ec2` command.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取运行此示例所需的两个依赖项，请运行`go get launchpad.net/goamz/aws`命令和`go get launchpad.net/goamz/ec2`命令。
- en: You can find additional documentation about this at [http://godoc.org/launchpad.net/goamz](http://godoc.org/launchpad.net/goamz).
    The `goamz` package also includes a package for the Amazon S3 storage service
    and some additional experimental packages for Amazon's SNS service and Simple
    Database Service.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://godoc.org/launchpad.net/goamz](http://godoc.org/launchpad.net/goamz)找到有关此的其他文档。`goamz`包还包括Amazon
    S3存储服务的包，以及Amazon的SNS服务和简单数据库服务的一些额外实验性包。
- en: Starting a new instance based on an image is simple. Perhaps it is too simple
    if you're used to deploying it manually or through a controlled, automated, or
    autoscaled process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 基于镜像启动一个新实例很简单。也许对于习惯于手动部署或通过受控、自动化或自动缩放过程部署的人来说，这太简单了。
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this instance `ami-9eaa1cf6` refers to Ubuntu Server 14.04.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`ami-9eaa1cf6`指的是Ubuntu Server 14.04。
- en: Having an interface to Amazon's API will be important in our next section where
    we'll take our image data and move it out of our relational database and into
    a CDN.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一节中，拥有与亚马逊API的接口将是重要的，我们将把图像数据从我们的关系数据库中移出，并放入CDN中。
- en: Handling binary data and CDNs
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理二进制数据和CDN
- en: You may recall that way back in [Chapter 3](ch03.html "Chapter 3. Routing and
    Bootstrapping"), *Routing and Bootstrapping*, we looked at how to store binary
    data, specifically image data, for our application in a database in the BLOB format.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得在[第3章](ch03.html "第3章。路由和引导")中，*路由和引导*，我们看了如何以BLOB格式将二进制数据，特别是图像数据，存储在我们应用程序的数据库中。
- en: At that time, we handled this in a very introductory way to simply get binary
    image data into some sort of a storage system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，我们以一种非常基础的方式处理这个问题，只是简单地将二进制图像数据放入某种存储系统中。
- en: Amazon S3 is part of the content distribution/delivery network aspect of AWS,
    and it operates on the notion of buckets as collections of data, with each bucket
    having its own set of access control rights. It should be noted that AWS also
    presents a true CDN called Cloudfront, but S3 can be used for this purpose as
    a storage service.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon S3是AWS内容分发/交付网络方面的一部分，它基于桶的概念来收集数据，每个桶都有自己的访问控制权限。需要注意的是，AWS还提供了一个名为Cloudfront的真正CDN，但S3可以用作存储服务。
- en: 'Let''s first look at using the `goamz` package to list up to 100 items in a
    given bucket:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下使用`goamz`包在给定存储桶中列出最多100个项目：
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Replace ----------- in the code with your credentials.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中用您的凭据替换-----------。
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our social network example, we're handling this as part of the `/api/user/:id:`
    endpoint.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的社交网络示例中，我们将其作为`/api/user/:id:`端点的一部分处理。
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Return uploaded, instead we either check for the error and continue attempting
    to process the image or we move on. We''ll show how to handle an empty value here
    in a bit:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 返回上传，而不是检查错误并继续尝试处理图像，或者我们继续前进。我们将在这里展示如何处理空值：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this point we've attempted to read the image and extract the data—if we cannot,
    we print the response through `fmt.Println` or `log.Println` and skip the remaining
    steps, but do not panic as we can continue editing in other ways.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经尝试读取图像并提取数据——如果我们不能，我们通过`fmt.Println`或`log.Println`打印响应并跳过剩余的步骤，但不要惊慌，因为我们可以以其他方式继续编辑。
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In [Chapter 3](ch03.html "Chapter 3. Routing and Bootstrapping"), *Routing and
    Bootstrapping*, we took the data as it was uploaded in our form, converted it
    into a Base64-encoded string, and saved it in our database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。路由和引导")中，*路由和引导*，我们接受了表单中上传的数据，将其转换为Base64编码的字符串，并保存在我们的数据库中。
- en: 'Since we''re now going to save the image data directly, we can skip this final
    step. We can instead read anything from the `FormFile` function in our request
    and take the entire data and send it to our S3 bucket, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在要直接保存图像数据，我们可以跳过这最后一步。我们可以从我们请求中的`FormFile`函数中读取任何内容，并将整个数据发送到我们的S3存储桶，如下所示：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It would make sense for us to ensure that we have a unique identifier for this
    image—one that avoids race conditions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个图像，我们需要确保有一个唯一的标识符，避免竞争条件。
- en: Checking for the existence of a file upload
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查文件上传的存在
- en: The `FormFile()`function actually calls `ParseMultipartForm()` under the hood
    and returns default values for the file, the file header, and a standard error
    if nothing exists.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormFile()`函数实际上在底层调用`ParseMultipartForm()`，并为文件、文件头和标准错误返回默认值（如果不存在）。'
- en: Sending e-mails with net/smtp
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用net/smtp发送电子邮件
- en: Decoupling our API and social network from ancillary tools is a good idea to
    create a sense of specificity in our system, reduce conflicts between these systems,
    and provide more appropriate system and maintenance rules for each.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的API和社交网络与辅助工具解耦是一个好主意，可以在我们的系统中创建特定性感，减少这些系统之间的冲突，并为每个系统提供更适当的系统和维护规则。
- en: 'It would be simple enough to equip our e-mail system with a socket client that
    allows the system to listen directly for messages from our API. In fact, this
    could be accomplished with just a few lines of code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地为我们的电子邮件系统配备一个套接字客户端，使系统能够直接监听来自我们API的消息。实际上，这只需要几行代码就可以实现：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s look at the actual send function that will deliver our message from
    the registration process in our API to the e-mail server:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下实际的发送函数，它将把我们API中注册过程中的消息发送到电子邮件服务器：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While this system will work well, as we can listen on TCP and receive messages
    that tell us what to send and to what address, it's not particularly fault tolerant
    on its own.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个系统可以很好地工作，因为我们可以监听TCP并接收告诉我们要发送什么和发送到什么地址的消息，但它本身并不特别容错。
- en: We can address this problem easily by employing a message queue system, which
    we'll look at next with RabbitMQ.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用消息队列系统轻松解决这个问题，接下来我们将使用RabbitMQ来看一下。
- en: RabbitMQ with Go
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RabbitMQ with Go
- en: An aspect of web design that's specially relevant to APIs, but is a part of
    almost any web stack, is the idea of a message passing between servers and other
    systems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Web设计的一个方面，特别与API相关，但几乎是任何Web堆栈的一部分，是服务器和其他系统之间的消息传递的概念。
- en: It is commonly referred to as **Advanced Message Queuing Protocol** or **AMQP**.
    It can be an essential piece to an API/web service since it allows services that
    are otherwise separated to communicate with each other without utilizing yet another
    API.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常被称为**高级消息队列协议**或**AMQP**。它可以成为API/web服务的重要组成部分，因为它允许否则分离的服务相互通信，而无需使用另一个API。
- en: By message passing, we're talking here about generic things that can or should
    be shared between dissonant systems getting moved to the relevant recipient whenever
    something important happens.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消息传递，我们在这里谈论的是可以或应该在发生重要事件时在不同的系统之间共享的通用事物被传递给相关的接收者。
- en: To draw another analogy, it's like a push notification on your phone. When a
    background application has something to announce to you, it generates the alert
    and passes it through a message passing system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再举个类比，就像手机上的推送通知。当后台应用程序有要通知您的事情时，它会生成警报并通过消息传递系统传递。
- en: 'The following diagram is a basic representation of this system. The sender
    (S), in our case the API, will add messages to the stack that will then be retrieved
    by the receiver (R) or the e-mail sending process:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是该系统的基本表示。发送者（S），在我们的情况下是API，将消息添加到堆栈，然后接收者（R）或电子邮件发送过程将检索这些消息：
- en: '![RabbitMQ with Go](img/1304OS_09_01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![RabbitMQ with Go](img/1304OS_09_01.jpg)'
- en: We believe that these processes are especially important to APIs because often,
    there's a institutional desire to segregate an API from the rest of the infrastructure.
    Although this is done to keep an API resource from impacting a live site or to
    allow two different applications to operate on the same data safely, it can also
    be used to allow one service to accept many requests while permitting a second
    service or system to process them as resources permit.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为这些过程对API特别重要，因为通常有机构希望将API与基础设施的其余部分隔离开来。尽管这样做是为了防止API资源影响现场站点或允许两个不同的应用程序安全地在相同的数据上运行，但也可以用于允许一个服务接受多个请求，同时允许第二个服务或系统根据资源的允许情况进行处理。
- en: This also provides a very basic data glue for applications written in different
    programming languages.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这还为用不同编程语言编写的应用程序提供了非常基本的数据粘合剂。
- en: In our web service, we can use an AMQP solution to tell our e-mail system to
    generate a welcome e-mail upon successful registration. This frees our core API
    from having to worry about doing that and it can instead focus on the core of
    our system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Web服务中，我们可以使用AMQP解决方案告诉我们的电子邮件系统在成功注册后生成欢迎电子邮件。这使我们的核心API不必担心这样做，而是可以专注于我们系统的核心。
- en: 'There are a number of ways in which we can formalize the requests between system
    A and system B, but the easiest way to demonstrate a simple e-mail message is
    by setting a standard message and title and passing it in JSON:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过制定标准消息和标题并将其传递为JSON来形式化系统A和系统B之间的请求的多种方式之一：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Receiving e-mails in this way instead of via an open TCP connection enables
    us to protect the integrity of the messages. In our previous example, any message
    that would be lost due to failure, crash, or shutdown would be lost forever.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式接收电子邮件，而不是通过开放的TCP连接，使我们能够保护消息的完整性。在我们之前的例子中，由于故障、崩溃或关闭而丢失的任何消息将永远丢失。
- en: Message queues, on the other hand, operate like mailboxes with levels of configurable
    durability that allow us to dictate how messages should be saved, when they expire,
    and what processes or users should have access to them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列，另一方面，就像具有可配置耐久性级别的邮箱一样运作，这使我们能够决定消息应该如何保存，何时过期，以及哪些进程或用户应该访问它们。
- en: In this case, we use a literal message that is delivered as part of a package
    that will be ingested by our mail service through the queue. In the case of a
    catastrophic failure, the message will still be there for our SMTP server to process.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用一个文字消息，作为一个包的一部分交付，将通过队列被我们的邮件服务摄取。在发生灾难性故障的情况下，消息仍将存在，供我们的SMTP服务器处理。
- en: Another important feature is its ability to send a "receipt" to the message
    initiator. In this case, an e-mail system would tell the API or web service that
    the e-mail message was successfully taken from the queue by the e-mail process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要特性是它能够向消息发起者发送“收据”。在这种情况下，电子邮件系统会告诉API或Web服务，电子邮件消息已成功从队列中被电子邮件进程取走。
- en: This is something that is not inconsequential to replicate within our simple
    TCP process. The number of fail-safes and contingencies that we'd have to build
    in would make it a very heavy, standalone product.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在我们简单的TCP过程中复制的一些东西。我们必须构建的故障保护和应急措施的数量将使其成为一个非常沉重的独立产品。
- en: 'Luckily, integrating a message queue is pretty simple within Go:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在Go中集成消息队列是相当简单的：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is just our connection to the RabbitMQ server. If any error with the connection
    is detected, we will stop the process.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们与RabbitMQ服务器的连接。如果检测到连接出现任何错误，我们将停止该过程。
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The name of the queue here is somewhat arbitrary like a memcache key or a database
    name. The key is to make sure that both the sending and receiving mechanisms search
    for the same queue name:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里队列的名称有点像memcache键或数据库名称一样任意。关键是确保发送和接收机制搜索相同的队列名称：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our loop here, we listen for messages and invoke the `Send()` method when
    we receive one. In this case, we''re passing JSON that is then unmarshalled into
    a `Message` struct, but this format is entirely up to you:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的循环中，我们监听消息并在接收到消息时调用`Send()`方法。在这种情况下，我们传递的是JSON，然后将其解组为`Message`结构，但这种格式完全取决于您：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And, in our `main()` function, we need to make sure that we replace our infinite
    TCP listener with the `Listen()` function that calls the AMQP listener:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，在我们的`main()`函数中，我们需要确保用调用AMQP监听器的`Listen()`函数替换我们的无限TCP监听器：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we have the ability to take messages (in the e-mail sense) from the queue
    of messages (in the message queue sense), which means that we'd simply need to
    include this functionality in our web service as well.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有能力从消息队列中接收消息（在电子邮件意义上），这意味着我们只需要在我们的Web服务中包含这个功能即可。
- en: In the example usage that we discussed, a newly registered user would receive
    an e-mail that prompts for the activation of the account. This is generally done
    to prevent sign ups with fake e-mail addresses. This is not an airtight security
    mechanism by any means, but it ensures that our application can communicate with
    a person who ostensibly has access to a real e-mail address.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的示例用法中，新注册的用户将收到一封电子邮件，提示激活账户。这通常是为了防止使用虚假电子邮件地址进行注册。这并不是一个完全可靠的安全机制，但它确保我们的应用程序可以与拥有真实电子邮件地址的人进行通信。
- en: Sending to the queue is also easy.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到队列也很容易。
- en: 'Given that we''re sharing credentials across two separate applications, it
    makes sense to formalize this into a separate package:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们在两个独立应用程序之间共享凭据，将这些内容正式化为一个单独的包是有意义的：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this way, both our API and our listener can import our `emailQueue` package
    and share these credentials. In our `api.go` file, add the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们的API和我们的监听器都可以导入我们的`emailQueue`包并共享这些凭据。在我们的`api.go`文件中，添加以下代码：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And in our `e-mail.go` process:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`e-mail.go`进程中：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: AMQP is a more generalized message passing interface with RabbitMQ extensions.
    You can read more about it at [https://github.com/streadway/amqp](https://github.com/streadway/amqp).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: AMQP是一个更通用的消息传递接口，具有RabbitMQ扩展。您可以在[https://github.com/streadway/amqp](https://github.com/streadway/amqp)上阅读更多信息。
- en: More information on Grab Rabbit Hole is available at [https://github.com/michaelklishin/rabbit-hole](https://github.com/michaelklishin/rabbit-hole)
    or can be downloaded using the `go get github.com/michaelklishin/rabbit-hole`
    command.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Grab Rabbit Hole的更多信息，请访问[https://github.com/michaelklishin/rabbit-hole](https://github.com/michaelklishin/rabbit-hole)，或者可以使用`go
    get github.com/michaelklishin/rabbit-hole`命令进行下载。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By separating the logic of our API from our hosted environment and ancillary,
    supportive services, we can reduce the opportunity for feature creep and crashes
    due to non-essential features.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将API的逻辑与我们托管的环境和辅助支持服务分开，我们可以减少功能蔓延和由于非必要功能而导致的崩溃的机会。
- en: In this chapter, we moved image hosting out of our database and into the cloud
    and stored raw image data and the resulting references to S3, a service that is
    often used as a CDN. We then used RabbitMQ to demonstrate how message passing
    can be utilized in deployment.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将图像托管从数据库中移到云端，并将原始图像数据和结果引用存储到S3，这是一个经常用作CDN的服务。然后，我们使用RabbitMQ演示了如何在部署中利用消息传递。
- en: At this point, you should have a grasp of offloading these services as well
    as a better understanding of the available strategies for deployment, updates,
    and graceful restarts.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该掌握了将这些服务卸载以及更好地了解部署、更新和优雅重启的可用策略。
- en: In our next chapter, we'll begin to round out the final, necessary requirements
    of our social network and in doing so, explore some ways to increase the speed,
    reliability, and overall performance of our web service.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始完成社交网络的最终必要要求，并通过这样做，探索增加我们的Web服务的速度、可靠性和整体性能的一些方法。
- en: We'll also introduce a secondary service that allows us to chat within our social
    network from the SPA interface as well as expand our image-to-CDN workflow to
    allow users to create galleries. We'll look at ways in which we can maximize image
    presentation and acquisition through both the interface and the API directly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将引入一个次要服务，允许我们在SPA界面内进行社交网络聊天，并扩展我们的图像到CDN工作流程，以允许用户创建图库。我们将研究如何通过界面和API直接最大化图像呈现和获取的方式。
