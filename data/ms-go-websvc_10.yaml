- en: Chapter 10. Maximizing Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。最大化性能
- en: With concepts relating to deploying and launching our application behind us,
    we'll lock in high-performance tactics within Go and related third-party packages
    in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论部署和启动应用程序的概念之后，我们将在本章中锁定Go和相关第三方包中的高性能策略。
- en: As your web service or API grows, performance issues may come to the fore. One
    sign of a successful web service is a need for more and more horsepower behind
    your stack; however, reducing this need through programmatic best practices is
    an even better approach than simply providing more processing power to your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的网络服务或API的增长，性能问题可能会凸显出来。成功的网络服务的一个标志是需要更多的硬件支持；然而，通过编程最佳实践来减少这种需求比简单地为应用程序提供更多处理能力更好。
- en: 'In this chapter, we''ll look at:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨：
- en: Introducing middleware to reduce redundancy in our code and pave the way for
    some performance features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入中间件来减少代码中的冗余，并为一些性能特性铺平道路
- en: Designing caching strategies to keep content fresh and provide it as quickly
    as possible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计缓存策略以保持内容新鲜并尽快提供
- en: Working with disk-based caching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于磁盘的缓存
- en: Working with memory caching
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内存缓存
- en: Rate-limiting our API through middleware
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过中间件对我们的API进行速率限制
- en: Google's SPDY protocol initiative
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌的SPDY协议倡议
- en: By the end of this chapter, you should know how to build your own middleware
    into your social network (or any other web service) to bring in additional features
    that introduce performance speedups.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您应该知道如何将自己的中间件构建到您的社交网络（或任何其他网络服务）中，以引入额外的功能，从而提高性能。
- en: Using middleware to reduce cruft
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中间件来减少冗余
- en: When working with the Web in Go, the built-in approaches to routing and using
    handlers don't always lend themselves to very clean methods for middleware out
    of the box.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中处理Web时，内置的路由和处理程序的方法并不总是很适合直接使用中间件的清晰方法。
- en: 'For example, although we have a very simple `UsersRetrieve()` method, if we
    want to prevent consumers from getting to that point or run something before it,
    we will need to include these calls or parameters multiple times in our code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尽管我们有一个非常简单的`UsersRetrieve()`方法，但如果我们想要阻止消费者到达那一点或在那之前运行一些东西，我们将需要在我们的代码中多次包含这些调用或参数：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And an other call is:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个调用是：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Middleware allows us to more cleanly direct the internal patterns of our application,
    as we can apply checks against rate limits and authentication as given in the
    preceding code. We can also bypass calls if we have some external signal that
    tells us that the application should be temporarily offline without stopping the
    application completely.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件允许我们更清晰地指导应用程序的内部模式，因为我们可以对速率限制和身份验证进行检查，就像前面的代码中所示的那样。如果有一些外部信号告诉我们应用程序应该暂时离线，而不是完全停止应用程序，我们也可以绕过调用。
- en: Considering the possibilities, let's think about useful ways in which we can
    utilize middleware in our application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到可能性，让我们想一想如何在应用程序中有效地利用中间件。
- en: 'The best way to approach this is to find places where we''ve inserted a lot
    of needless code through duplication. An easy place to start is our authentication
    steps that exist as a potential block in a lot of sections of code in our `api.go`
    file. Refer to the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是找到我们通过重复插入了大量不必要代码的地方。一个容易开始的地方是我们的身份验证步骤，它存在于我们的`api.go`文件的许多代码部分中。
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We call the `CheckLogin()` function multiple times throughout the application,
    so we can offload this to middleware to reduce the cruft and duplicate code throughout.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整个应用程序中多次调用`CheckLogin()`函数，因此我们可以将其卸载到中间件中，以减少冗余和重复的代码。
- en: 'Another method is the access control header setting that allows or denies requests
    based on the permitted domains. We use this for a few things, particularly for
    our server-side requests that are bound to CORS rules:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是访问控制头设置，允许或拒绝基于允许的域的请求。我们特别用于服务器端请求，这些请求受到CORS规则的约束：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This too can be handled by middleware as it doesn't require any customization
    that is based on request type. On any request in which we wish to set the permitted
    domains, we can move this code into middleware.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以由中间件处理，因为它不需要基于请求类型的任何自定义。在我们希望设置允许的域的任何请求中，我们可以将这段代码移到中间件中。
- en: Overall, this represents good code design, but it can sometimes be tricky without
    custom middleware handlers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这代表了良好的代码设计，但有时候没有自定义中间件处理程序可能会有些棘手。
- en: 'One popular approach to middleware is chaining, which works something like
    this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的一种流行方法是链接，工作原理如下：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is extremely common within the world of Node.js, where the `next()`, `then()`,
    and `use()` functions pepper the code liberally. And it's possible to do this
    within Go as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这在Node.js世界中非常常见，`next()`、`then()`和`use()`函数在代码中广泛使用。在Go中也可以做到这一点。
- en: There are two primary approaches to this. The first is by wrapping handlers
    within handlers. This is generally considered to be ugly and is not preferred.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要方法。第一种是在处理程序中包装处理程序。这通常被认为是丑陋的，不被推荐。
- en: Dealing with wrapped handler functions that return to their parent can be a
    nightmare to parse.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 处理返回到其父级的包装处理程序函数可能会很难解析。
- en: 'So, let''s instead look at the second approach: chaining. There are a number
    of frameworks that include middleware chaining, but introducing a heavy framework
    simply for the purpose of middleware chaining is unnecessary. Let''s look at how
    we can do this directly within a Go server:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们来看看第二种方法：链接。有许多框架包括中间件链接，但引入一个重型框架仅仅是为了中间件链接是不必要的。让我们看看如何在Go服务器中直接实现这一点：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As mentioned earlier, there are a couple of places in our code and most server-based
    applications where middleware would be very helpful. Later in this chapter, we'll
    look at moving our authentication model(s) into middleware to reduce the amount
    of repetitious calls that we make within our handlers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，在我们的代码和大多数基于服务器的应用程序中，中间件将非常有帮助。在本章后面，我们将看看如何将我们的认证模型移入中间件，以减少我们在处理程序中进行的重复调用。
- en: However, for performance's sake, another function for a middleware of this kind
    can be used as a blocking mechanism for cache lookups. If we want to bypass potential
    bottlenecks in our `GET` requests, we can put a caching layer between the request
    and the response.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，出于性能考虑，这种类型的中间件的另一个功能可以用作缓存查找的阻塞机制。如果我们想要避免`GET`请求中的潜在瓶颈，我们可以在请求和响应之间放置一个缓存层。
- en: We're using a relational database, which is one of the most common sources of
    web-based bottlenecks; so, in situations where stale or infrequently changing
    content is acceptable, placing the resulting queries behind such a barrier can
    drastically improve our API's overall performance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用关系数据库，这是网络瓶颈最常见的来源之一；因此，在接受过时或不经常更改的内容是可以接受的情况下，将查询结果放在这样的屏障后面可以大大提高我们API的整体性能。
- en: Given that we have two primary types of requests that can benefit from middleware
    in different ways, we should spec how we'll approach the middleware strategy for
    various requests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们有两种主要类型的请求可以以不同的方式从中间件中受益，我们应该规定我们将如何处理各种请求的中间件策略。
- en: 'The following diagram is a model of how we can architect middleware. It can
    serve as a basic guide for where to implement specific middleware handlers for
    certain types of API calls:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是我们如何设计中间件的模型。它可以作为一个基本指南，指导我们在哪里为特定类型的API调用实现特定的中间件处理程序：
- en: '![Using middleware to reduce cruft](img/1304OS_10_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: 使用中间件减少冗余
- en: All requests should be subject to some degree of rate-limiting, even if certain
    requests have much higher limits than others. So, the `GET`, `PUT`, `POST`, and
    `DELETE` requests will run through at least one piece of middleware on every request.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有请求都应该受到一定程度的速率限制，即使某些请求的限制比其他请求高得多。因此，`GET`、`PUT`、`POST`和`DELETE`请求将在每个请求上至少通过一个中间件。
- en: Any requests with other verbs (for example, `OPTIONS`) should bypass this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他动词的请求（例如`OPTIONS`）应该绕过这一点。
- en: The `GET` requests should be subject to caching, which we also described as
    making the data they return amenable to some degree of staleness.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`请求应该受到缓存的影响，我们也将其描述为使它们返回的数据在一定程度上可以过时。'
- en: On the other hand, PUT, POST, and DELETE requests obviously cannot be cached,
    as this will either force our responses to be inaccurate or it will lead to duplicate
    attempts to create or remove data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，显然不能对PUT、POST和DELETE请求进行缓存，因为这要么会导致我们的响应不准确，要么会导致重复尝试创建或删除数据。
- en: Let's start with the `GET` requests and look at two related ways in which we
    can bypass a bottleneck when it is possible to deliver server-cached results instead
    of hitting our relational database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`GET`请求开始，看看我们可以绕过瓶颈的两种相关方式，当可能提供服务器缓存的结果而不是访问我们的关系数据库时。
- en: Caching requests
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存请求
- en: There are, of course, more than one or two methods for inducing caching across
    the lifetime of any given request. We'll explore a few of them in this section
    to introduce the highest level of nonredundant caching.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有不止一种或两种方法可以在任何给定请求的生命周期内引入缓存。我们将在本节中探讨其中一些方法，以引入最高级别的非冗余缓存。
- en: There is client-side caching at a script or a browser level that is ostensibly
    bound to the rules that are sent to it from the server side. By this, we mean
    yielding to HTTP response headers such as `Cache-Control`, `Expires`, `If-None-Match`,
    `If-Modified-Since`, and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本或浏览器级别有客户端缓存，它明显受到从服务器端发送给它的规则的约束。我们指的是遵守HTTP响应头，比如`Cache-Control`、`Expires`、`If-None-Match`、`If-Modified-Since`等等。
- en: These are the simplest forms of cache control that you can enforce, and they
    are also pretty important as part of a RESTful design. However, they're also a
    bit brittle as they do not allow any enforcement of those directives and clients
    that can readily dismiss them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是您可以强制执行的最简单的缓存控制形式，它们也是作为RESTful设计的重要部分。然而，它们也有点脆弱，因为它们不允许对这些指令进行任何强制执行，并且客户端可以轻易地忽略它们。
- en: Next, there is proxy-based caching—typically third-party applications that either
    serve a cached version of any given request or pass-through to the originating
    server application. We looked at a precursor to this when we talked about using
    Apache or Nginx in front of our API.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是基于代理的缓存——通常是第三方应用程序，它们要么提供任何给定请求的缓存版本，要么通过到原始服务器应用程序。我们在谈论在API前面使用Apache或Nginx时，已经提到了这个的前身。
- en: Finally, there is server-level caching at the application level. This is typically
    done in lieu of proxy caching because the two tend to operate on the same rule
    sets. In most cases, appealing to a standalone proxy cache is the wisest option,
    but there are times when those solutions are unable to accommodate specific edge
    cases.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在应用程序级别有服务器级别的缓存。这通常是代理缓存的替代，因为两者往往遵循相同的规则集。在大多数情况下，诉诸于独立的代理缓存是最明智的选择，但有时这些解决方案无法适应特定的边缘情况。
- en: There's also some merit in designing these from scratch to better understand
    caching strategies for your proxy cache. Let's briefly look at building server-side
    application caching for our social network in both disk-based and memory-based
    ways, and see how we can utilize this experience to better define caching rules
    at the proxy level.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始设计这些也有一定的价值，以更好地理解代理缓存的缓存策略。让我们简要地看一下如何在基于磁盘和基于内存的方式上为我们的社交网络构建服务器端应用程序缓存，并看看我们如何利用这一经验来更好地定义代理级别的缓存规则。
- en: Simple disk-based caching
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的基于磁盘的缓存
- en: Not all that long ago, the way most developers handled caching requests was
    typically through disk-based caching at the application level.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不久以前，大多数开发人员处理缓存请求的方式通常是通过应用程序级别的磁盘缓存。
- en: In this approach, some parameters were set around the caching mechanisms and
    qualifiers of any given request. Then, the results of the request were saved to
    a string and then to a lock file. Finally, the lock file was renamed. The process
    was pretty steady although it was archaic and worked well enough to be reliable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，围绕任何给定请求的缓存机制和限定条件设置了一些参数。然后，请求的结果被保存到一个字符串，然后保存到一个锁文件中。最后，锁文件被重命名。这个过程相当稳定，尽管有些过时，但足够可靠。
- en: There were a number of downsides that were somewhat insurmountable at the time
    in the early days of the Web.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web早期，有一些不可逾越的缺点。
- en: Note that disks, particularly mechanical magnetic disks, have been notoriously
    and comparatively slow for storage and access, and they are bound to cause a lot
    of issues with filesystems and OS operations with regard to lookups, finds, and
    sorting.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，磁盘，特别是机械磁盘，一直以来都以存储和访问速度慢而著称，并且在查找、发现和排序方面很可能会导致文件系统和操作系统操作出现许多问题。
- en: Distributed systems also pose an obvious challenge where a shared cache is necessary
    to ensure consistency across balanced requests. If server A updates its local
    cache and the next request returns a cache hit from server B, you can see varying
    results depending on the server. Using a network file server may reduce this,
    but it introduces some issues with permissions and network latency.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统也带来了一个明显的挑战，即需要共享缓存以确保平衡请求的一致性。如果服务器A更新其本地缓存，并且下一个请求从服务器B返回了缓存命中，您会看到根据服务器的不同而产生不同的结果。使用网络文件服务器可能会减少这种情况，但它会引入一些权限和网络延迟的问题。
- en: On the other hand, nothing is simpler than saving a version of a request to
    a file. That, along with disk-based caching's long history in other sectors of
    programming, made it a natural early choice.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，没有什么比将请求的版本保存到文件更简单。这个特点，再加上磁盘缓存在编程的其他领域中有着悠久的历史，使它成为一个自然的早期选择。
- en: Moreover, it's not entirely fair to suggest that disk-based caching's days are
    over. Faster drives, often SSDs, have reopened the potential for using non-ephemeral
    storage for quick access.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，完全公平地说磁盘缓存的时代已经结束也并不合适。更快的驱动器，通常是固态硬盘，重新打开了使用非短暂存储进行快速访问的潜力。
- en: Let's take a quick look at how we can design a disk-based cache middleware solution
    for our API to reduce load and bottlenecks in heavy traffic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下如何为我们的API设计一个基于磁盘的缓存中间件解决方案，以减少高流量中的负载和瓶颈。
- en: The first consideration to take into account is what to cache. We would never
    want to allow the `PUT`, `POST`, and `DELETE` requests to cache for obvious reasons,
    as we don't want duplication of data nor erroneous responses to `DELETE` or `POST`
    requests that indicate that a resource has been created or deleted when in fact
    it hasn't.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的是要缓存什么。出于明显的原因，我们绝不希望允许`PUT`、`POST`和`DELETE`请求进行缓存，因为我们既不希望数据重复，也不希望`DELETE`或`POST`请求出现错误响应，表明资源已经被创建或删除，而实际上并没有。
- en: So, we know that we're only caching the `GET` requests or listings of data.
    This is the only data we have that can be "outdated" in the sense that we can
    accept some staleness without making major changes in the way the application
    operates.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道我们只缓存`GET`请求或数据列表。这是我们唯一的数据，可以在某种程度上过时，而不会对应用程序的运行方式产生重大变化。
- en: 'Let''s start with our most basic request, `/api/users`, which returns a list
    of users in our system, and introduce some middleware for caching to a disk. Let''s
    set it up as a skeleton to explain how we evaluate:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们最基本的请求`/api/users`开始，它返回我们系统中用户的列表，并引入一些用于将数据缓存到磁盘的中间件。让我们将其设置为一个框架，以解释我们如何评估：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our `CacheItem` struct is the only real element in the package. It consists
    of either a valid cache hit (and information about the cached element including
    the last modification time, contents, and so on) or a cache miss. A cache miss
    will return to our API that either the item does not exist or has surpassed the
    time-to-live (TTL). In this case, the `diskcache` package will then set the cache
    to file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CacheItem`结构是包中唯一真正的元素。它包括一个有效的缓存命中（以及关于缓存元素的最后修改时间、内容等信息）或一个缓存未命中。缓存未命中将返回给我们的API，要么该项不存在，要么已经超过了生存时间（TTL）。在这种情况下，`diskcache`包将把缓存设置为文件：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is where we''ll do this. If a request has no cached response or the cache
    is invalid, we''ll need to get the results back so that we can save it. This makes
    the middleware part a little trickier, but we''ll show you how to handle this
    shortly. The following `GetCache()` function looks into our cache directory and
    either finds and returns a cache item (whether valid or not) or produces a false
    value:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将要做的。如果一个请求没有缓存的响应，或者缓存无效，我们需要获取结果，以便保存它。这使得中间件部分有点棘手，但我们很快会向您展示如何处理这个问题。以下的`GetCache()`函数查找我们的缓存目录，找到并返回一个缓存项（无论是否有效），或者产生一个false值：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following `Evaluate()` function will be our primary point of entry, passing
    to `GetCache()` and possibly `SetCache()` later, if we need to create or recreate
    our cache entry:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的`Evaluate()`函数将是我们的主要入口点，传递给`GetCache()`，可能稍后还会传递给`SetCache()`，如果我们需要创建或重新创建缓存条目的话：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this structure, we'll utilize a context (so that we can delineate between
    request types), the resulting value (for saving), and an open-ended variadic of
    strings that we can use as qualifiers for our cache entry. By this, we mean the
    parameters that force a unique cache file to be produced. Let's say we designate
    `page` and `search` as two such qualifiers. Page 1 requests will be different
    than page 2 requests and they will be cached separately. Page 1 requests for a
    search for Nathan will be different from page 1 requests for a search for Bob,
    and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，我们将利用上下文（以便我们可以区分请求类型）、结果值（用于保存）和一个开放的字符串可变参数，我们可以用作缓存条目的限定符。我们指的是强制生成唯一缓存文件的参数。比如，我们指定`page`和`search`作为这样的限定符。第1页的请求将与第2页的请求不同，并且它们将被分别缓存。搜索Nathan的第1页请求将与搜索Bob的第1页请求不同，依此类推。
- en: This point is very strict for hard files because we need to name (and look up)
    our cache files in a reliable and consistent way, but it's also important when
    we save caches in a datastore.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点对硬文件来说非常严格，因为我们需要以一种可靠和一致的方式命名（和查找）我们的缓存文件，但当我们将缓存保存在数据存储中时，这也很重要。
- en: With all of this in mind, let's examine how we will discern a cacheable entry
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，让我们来看看我们如何区分可缓存的条目
- en: Enabling filtering
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用过滤
- en: Presently our API does not accept any specific parameters against any of our
    `GET` requests, which return lists of entities or specific details about an entity.
    Examples here include a list of users, a list of status updates, or a list of
    relationships.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们的API不接受任何特定参数来对我们的`GET`请求进行过滤，这些请求返回实体列表或实体的特定详细信息。例如，用户列表、状态更新列表或关系列表。
- en: You may note that our `UsersRetrieve()` handler presently returns the next page
    in response to a `start` value and a `limit` value. Right now this is hard-coded
    at a start value of `0` and a limit value of `10`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到我们的`UsersRetrieve()`处理程序目前根据`start`值和`limit`值返回下一页。目前这是在`start`值为`0`和`limit`值为`10`的情况下硬编码的。
- en: 'In addition, we have a `Pragma: no-cache` header that is being set. We obviously
    don''t want that. So, to prepare for caching, let''s add a couple of additional
    fields that clients can use to find particular users they''re looking for by attributes.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，我们设置了一个`Pragma: no-cache`头。显然我们不希望这样。因此，为了进行缓存准备，让我们添加一些额外的字段，客户端可以使用这些字段来查找他们想要的特定用户。'
- en: 'The first is a start and a limit, which dictates a pagination of sorts. What
    we now have is this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是起始值和限制值，它决定了一种分页。我们现在有的是这样的：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s make this responsive to the request first by accepting a start:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们通过接受一个起始值来使其对请求做出响应：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we can accept a start value as well as a limit value. Note that we also
    put a cap on the number of results that we'll return. Any results that are more
    than 50 will be ignored and a maximum of 50 results will be returned.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以接受一个起始值和一个限制值。请注意，我们还对我们将返回的结果数量进行了限制。任何超过50的结果都将被忽略，最多返回50个结果。
- en: Transforming a disk cache into middleware
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将磁盘缓存转换为中间件
- en: 'Now we''ll take the skeleton of `diskcache`, turn it into a middleware call,
    and begin to speed up our `GET` requests:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把`diskcache`的框架转换为中间件调用，并开始加速我们的`GET`请求：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This obviously represents a strict location for cache files, but it can also
    be branched into subdirectories that are based on a context, for example, our
    API endpoints in this case. So, `/api/users` in a `GET` request would map to `/var/www/cache/users/get/.`
    This reduces the volume of data in a single directory:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然代表了缓存文件的严格位置，但它也可以分成基于上下文的子目录，例如，在这种情况下，我们的API端点。因此，`/api/users`在`GET`请求中将映射到`/var/www/cache/users/get/.`这样可以减少单个目录中的数据量：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our generic `CacheItem` struct consists of the file''s name, its physical location,
    the age in seconds, and the contents, as mentioned in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通用的`CacheItem`结构由文件名、物理位置、以秒为单位的年龄和内容组成，如下面的代码中所述：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our `IsValid()` method first determines whether the file exists and is readable,
    if it's older than the `MaxAge` variable. If it cannot be read or if it's too
    old, then we return false, which tells our `Evaluate()` entry point to create
    the file. Otherwise, we return true, which directs the `Evaluate()` function to
    perform a read of the existing cache file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`IsValid()`方法首先确定文件是否存在且可读，如果它的年龄超过`MaxAge`变量。如果无法读取或者它太旧，那么我们返回false，这告诉我们的`Evaluate()`入口创建文件。否则，我们返回true，这将指示`Evaluate()`函数执行对现有缓存文件的读取。
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In our imports section, you may note that the `sync` package is called; `SetCache()`
    should, in production at least, utilize a mutex to induce locking on file operations.
    We use `Lock()` and `Unlock()` (in a defer) to handle this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的导入部分，您可能会注意到调用了`sync`包；`SetCache()`应该在生产中至少利用互斥锁来对文件操作进行加锁。我们使用`Lock()`和`Unlock()`（在延迟中）来处理这个问题。
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that our filename here is generated by joining the parameters in the `qu`
    variadic parameter. If we want to fine-tune this, we will need to sort the parameters
    alphabetically and this will prevent cache misses if the parameters are supplied
    in a different order.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的文件名是通过连接`qu`可变参数中的参数生成的。如果我们想要对此进行微调，我们需要按字母顺序对参数进行排序，这将防止缓存丢失，如果参数以不同的顺序提供。
- en: Since we control the originating call, that's low-risk. However, since this
    is built as a shared library, it's important that the behavior should be fairly
    consistent.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们控制了起始调用，所以风险较低。然而，由于这是作为一个共享库构建的，因此行为应该是相当一致的。
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can test this pretty simply using a tiny example that just writes files
    by value:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个简单的示例来测试这一点，该示例只是按值写文件：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we run this, then change the value of `Here is a value ...`, and run it again
    within 60 seconds, we'll get our cached value. This shows that our diskcache package
    saves and returns values without hitting what could otherwise be a backend bottleneck.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，然后改变`这里是一个值...`的值，并在60秒内再次运行它，我们将得到我们的缓存值。这表明我们的diskcache包保存并返回值，而不会触及可能成为后端瓶颈的内容。
- en: So, let's now put this in front of our `UsersRetrieve()` handler with some optional
    parameters. By setting our cache by `page` and `search` as cacheable parameters,
    we'll mitigate any load-based impact on our database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们在“UsersRetrieve()”处理程序前面加上一些可选参数。通过将我们的缓存设置为“page”和“search”作为可缓存的参数，我们将减轻对数据库的基于负载的影响。
- en: Caching in distributed memory
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式内存中的缓存
- en: Similar to disk-based caching, we're bound to a single entity key with simple
    in-memory caching although this is still a useful alternative to disk caching.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于磁盘的缓存类似，尽管这仍然是磁盘缓存的一个有用替代，但我们在简单的内存缓存中仍然受限于单个实体键。
- en: Replacing the disk with something like Memcache(d) will allow us to have very
    fast retrieval, but will provide us with no benefit in terms of keys. In addition,
    the potential for large amounts of duplication means that our memory storage that
    is generally smaller than physical storage might become an issue.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 用类似Memcache(d)的东西替换磁盘将使我们能够非常快速地检索，但在键方面不会给我们带来任何好处。此外，大量重复的潜力意味着我们的内存存储通常比物理存储小，可能会成为一个问题。
- en: However, there are a number of ways to sneak into in-memory or distributed memory
    caching. We won't be showing you that drop-in replacement, but through a segue
    with one NoSQL solution, you can easily translate two types of caching into a
    strict, memory-only caching option.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有许多方法可以潜入内存或分布式内存缓存。我们不会向您展示这种可替换的方法，但是通过与NoSQL解决方案的衔接，您可以轻松地将两种类型的缓存转换为严格的仅内存缓存选项。
- en: Using NoSQL as a cache store
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NoSQL作为缓存存储
- en: Unlike Memcache(d), with a datastore or a database we have the ability to do
    more complex lookups based on non-chained parameters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与Memcache(d)不同，使用数据存储或数据库，我们可以根据非链接参数进行更复杂的查找。
- en: For example, in our `diskcache` package, we chain together parameters such as
    `page` and `search` in such a way that our key (in this case a filename) is something
    like `getusers_1_nathan.cache`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的“diskcache”包中，我们将参数（如“page”和“search”）链接在一起，这样我们的键（在这种情况下是文件名）就变成了“getusers_1_nathan.cache”。
- en: It is essential that these keys are generated in a consistent and reliable way
    for lookup since any change results in a cache miss instead of an expected hit,
    and we will need to rebuild our cached request, which will completely eliminate
    the intended benefit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些键以一种一致可靠的方式生成以进行查找是至关重要的，因为任何更改都会导致缓存未命中而不是预期的命中，我们将需要重建我们的缓存请求，这将完全消除预期的好处。
- en: For databases, we can do very high-detail column lookups for cache requests,
    but, given the nature of relational databases, this is not a good solution. After
    all, we built the caching layer very specifically to avoid hitting common bottlenecks
    such as a RDBMS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库，我们可以对缓存请求进行非常详细的列查找，但是，考虑到关系数据库的性质，这并不是一个好的解决方案。毕竟，我们构建缓存层是非常具体的，以避免命中常见瓶颈，如关系数据库管理系统。
- en: For the sake of an example, we'll again utilize MongoDB as a way to compile
    and lookup our cache files with high throughput and availability and with the
    extra flexibility that is afforded to parameter-dependent queries.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例，我们将再次利用MongoDB来编译和查找我们的缓存文件，以实现高吞吐量和可用性，并具有参数相关查询所提供的额外灵活性。
- en: In this case, we'll add a basic document with just a page, search, contents,
    and a modified field. The last field will serve as our timestamp for analysis.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将添加一个基本文档，其中只有一个页面、搜索、内容和一个修改字段。最后一个字段将作为我们的时间戳进行分析。
- en: Despite `page` being a seemingly obvious integer field, we'll create it as a
    string in MongoDB to avoid type conversion when we do queries.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管“page”看起来是一个明显的整数字段，但我们将其在MongoDB中创建为字符串，以避免在进行查询时进行类型转换。
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For obvious reasons, we'll call this `memorycache` instead of memcache to avoid
    any potential confusion.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 出于明显的原因，我们将其称为“memorycache”，而不是memcache，以避免任何潜在的混淆。
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've supplanted any OS and disk-based packages with the MongoDB ones. The BSON
    package is also included as part of making specific `Find()` requests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用MongoDB的包替换了任何基于操作系统和磁盘的包。BSON包也包含在内，作为进行特定的“Find()”请求的一部分。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In a production environment, when looking for a key-value store or a memory
    store for such intents, one should be mindful of the locking mechanisms of the
    solution and their impact on your read/write operations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，当寻找一个键值存储或内存存储用于这样的意图时，应该注意解决方案的锁定机制及其对读/写操作的影响。
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It's worth noting here that MongoDB has a time-to-live concept for data expiration.
    This might remove the necessity to manually expire content but it may not be available
    in alternative store platforms.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，MongoDB具有数据过期的生存时间概念。这可能消除了手动过期内容的必要性，但在替代存储平台上可能无法使用。
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note the literal identifiers in the `CacheRecord` struct; these allow us to
    generate MongoDB IDs automatically. Without this, MongoDB will complain about
    duplicate indices on `_id_`. The following `IsValid()` function literally returns
    information about a file in our `diskcache` package. In a `memorycache` version,
    we will only return one piece of information, whether or not a record exists within
    the requested age.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意“CacheRecord”结构中的文字标识符；这些允许我们自动生成MongoDB ID。如果没有这个，MongoDB将抱怨“_id_”上的重复索引。以下的“IsValid()”函数实际上返回了有关我们的“diskcache”包中文件的信息。在“memorycache”版本中，我们只会返回一个信息，即请求的年龄内是否存在记录。
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note also that we're not deleting old records. This may be the logical next
    step to keep cache records snappy.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们没有删除旧记录。这可能是保持缓存记录敏捷的逻辑下一步。
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Whether or not we find a record, we insert a new one in the preceding code.
    This gives us the most recent record when we do a lookup and it also allows us
    to have some sense of revision control in a way. You can also update the record
    to eschew revision control.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是否找到记录，我们都会在前面的代码中插入一个新记录。这使我们在查找时获得最新的记录，也使我们在某种程度上具有修订控制的意识。您还可以更新记录以避免修订控制。
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This operates in much the same way as `diskcache` except that, instead of a
    list of unstructured parameter names, we provide key/value pairs in the `param`
    hash map.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`diskcache`的操作方式基本相同，只是我们在`param`哈希映射中提供键/值对，而不是无结构的参数名称列表。
- en: 'So, the usage changes a little bit. Here''s an example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用方法会有一些变化。这里有一个例子：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When we run this, we'll set our content in the datastore and this will last
    for 60 seconds before it becomes invalid and recreates the cache contents in a
    second row.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，我们将在数据存储中设置我们的内容，这将持续60秒，然后变为无效，并在第二行重新创建缓存内容。
- en: Implementing a cache as middleware
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施缓存作为中间件
- en: To place this cache in the middleware chain for all of our `GET` requests, we
    can implement the strategy that we outlined above and add a caching middleware
    element.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此缓存放置在我们所有`GET`请求的中间件链中，我们可以实现我们上面概述的策略并添加一个缓存中间件元素。
- en: 'Using our example from earlier, we can implement this at the front of the chain
    using our `middleware()` function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前的示例，我们可以使用我们的`middleware()`函数在链的前面实现这一点：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This allows us to execute a `DiskCache()` handler before the `UsersRetrieve()`
    function. However, we''ll also want to save our response if we don''t have a valid
    cache, so we''ll also call `DiskCacheSave()` at the end. The `DiskCache()` middleware
    handler will block the chain if it receives a valid cache. Here''s how that works:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在`UsersRetrieve()`函数之前执行`DiskCache()`处理程序。但是，如果我们没有有效的缓存，我们还希望保存我们的响应，因此我们还将在最后调用`DiskCacheSave()`。如果`DiskCache()`中间件处理程序接收到有效的缓存，它将阻止链。它的工作原理如下：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we get `check.Cached` as true, we simply serve the contents. Otherwise, we
    continue on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到`check.Cached`为true，我们只需提供内容。否则，我们继续。
- en: 'One minor modification to our primary function is necessary to transfer the
    contents to our next function right before writing the function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在将内容传输到下一个函数之前，我们的主要函数需要进行一些小的修改：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And then, `DiskCacheSave()` can essentially be a duplicate of `DiskCache`,
    except that it will set the actual contents from the `http.Request` function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`DiskCacheSave()`基本上可以是`DiskCache`的副本，只是它将从`http.Request`函数设置实际内容：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using a frontend caching proxy in front of Go
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Go前面使用前端缓存代理
- en: Another tool in our toolbox is utilizing front-end caching proxies (as we did
    in [Chapter 7](ch07.html "Chapter 7. Working with Other Web Technologies"), *Working
    with Other Web Technologies*) as our request-facing cache layer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们工具箱中的另一个工具是利用前端缓存代理（就像我们在[第7章](ch07.html "第7章。使用其他Web技术")中所做的那样，*使用其他Web技术*）作为我们面向请求的缓存层。
- en: In addition to traditional web servers such as Apache and Nginx, we can also
    employ services that are intended almost exclusively for caching, either in place
    of, in front of, or in parallel with the said servers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传统的Web服务器，如Apache和Nginx，我们还可以使用专门用于缓存的服务，这些服务可以替代、放在前面或与上述服务器并行使用。
- en: Without going too deeply into this approach, we can replicate some of this functionality
    with better performance from outside the application. We'd be remiss if we didn't
    at least broach this. Tools such as Nginx, Varnish, Squid, and Apache have built-in
    caching for reverse-proxy servers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在不深入研究这种方法的情况下，我们可以从应用程序外部复制一些功能，以获得更好的性能。如果我们至少不提及这一点，那就不够完整。像Nginx、Varnish、Squid和Apache这样的工具都具有反向代理服务器的内置缓存。
- en: For production-level deployments, these tools are probably more mature and better
    suited for handling this level of caching.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产级部署，这些工具可能更成熟，更适合处理这种级别的缓存。
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find more information on Nginx and reverse proxy caching at [http://nginx.com/resources/admin-guide/caching/](http://nginx.com/resources/admin-guide/caching/).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://nginx.com/resources/admin-guide/caching/](http://nginx.com/resources/admin-guide/caching/)找到有关Nginx和反向代理缓存的更多信息。
- en: Varnish and Squid are both built primarily for caching at this level as well.
    More detail on Varnish and Squid can be found at [https://www.varnish-cache.org/](https://www.varnish-cache.org/)
    and [http://www.squid-cache.org/](http://www.squid-cache.org/) respectively.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Varnish和Squid都主要用于在这个级别进行缓存。有关Varnish和Squid的更多详细信息，可以在[https://www.varnish-cache.org/](https://www.varnish-cache.org/)和[http://www.squid-cache.org/](http://www.squid-cache.org/)找到。
- en: Rate limiting in Go
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中进行速率限制
- en: Introducing caching to our API is probably the simplest way to demonstrate effective
    middleware strategy. We're able to now mitigate the risk of heavy traffic and
    move toward
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的API引入缓存可能是展示有效中间件策略的最简单方法。我们现在能够减轻重负流量的风险，并朝着
- en: One particularly useful place for this kind of middleware functionality in a
    web service is rate limiting.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web服务中，这种中间件功能特别有用的地方是速率限制。
- en: Rate limiting exists in APIS with high traffic to allow consumers to use the
    application without potentially abusing it. Abuse in this case can just mean excessive
    access that can impact performance, or it can mean creating a deterrent for large-scale
    data acquisition.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有高流量的API中存在速率限制，以允许消费者使用应用程序而不会滥用它。在这种情况下，滥用可能只是指可能影响性能的过度访问，或者可能意味着为大规模数据获取创建障碍。
- en: Often, people will utilize APIs to create local indices of entire data collections,
    effectively spidering a site through an API. With most applications, you'll want
    to prevent this kind of access.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们会利用API来创建整个数据集的本地索引，通过API有效地爬取网站。对于大多数应用程序，您将希望阻止这种访问。
- en: In either case, it makes sense to impose some rate limiting on certain requests
    within our application. And, importantly, we'll want this to be flexible enough
    so that we can do it with varying limits depending on the request time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何一种情况下，对我们应用程序中的某些请求施加一些速率限制是有意义的。并且，重要的是，我们希望这足够灵活，以便我们可以根据请求时间使用不同的限制。
- en: 'We can do this using a number of factors, but the two most common methods are
    as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用许多因素来实现这一点，但最常见的两种方法如下：
- en: Through the corresponding API user credentials
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过相应的API用户凭据
- en: Through the IP address of the request
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过请求的IP地址
- en: In theory, we can also introduce rate limits on the underlying user by making
    a request per proxy. In a real-world scenario, this would reduce the risk of a
    third-party application being penalized for its user's usage.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们也可以通过每个代理发出请求来对底层用户引入速率限制。在现实世界的情况下，这将减少第三方应用因其用户使用而受到惩罚的风险。
- en: The important factor is that we discover rate-limit-exceeded notations before
    delving into more complex calls, as we want to break the middleware chain at precisely
    that point if the rate limit has been exceeded.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的因素是，在深入研究更复杂的调用之前，我们发现速率限制已超出标记，因为我们希望在速率限制已超出的那一点精确地打破中间件链。
- en: For this rate-limiting middleware example, we'll again use MongoDB as a request
    store and a limit based on a calendar day from midnight to midnight. In other
    words, our limit per user resets every day at 12:01 a.m.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个速率限制中间件示例，我们将再次使用MongoDB作为请求存储，并基于从午夜到午夜的日历日进行限制。换句话说，我们每个用户的限制每天在凌晨12:01重置。
- en: Storing actual requests is just one approach. We can also read from web server
    logs or store them in memory. However, the most lightweight approach is keeping
    them in a datastore.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 存储实际请求只是一种方法。我们也可以从Web服务器日志中读取或将它们存储在内存中。然而，最轻量级的方法是将它们保存在数据存储中。
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is simply our MongoDB host or hosts. Here, we have a struct with boundaries
    for the beginning and end of a calendar day:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们的MongoDB主机或主机。在这里，我们有一个结构，用于定义日历日的开始和结束的边界：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The following `CreateDateBounds()` function calculates today's date and then
    adds `86400` seconds to the returned `Unix()` value (effectively 1 day).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的`CreateDateBounds()`函数计算今天的日期，然后将`86400`秒添加到返回的`Unix()`值（实际上是1天）。
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With the following `RegisterRequest()` function, we're simply logging another
    request to the API. Here again, we're only binding the request to the IP, adding
    an authentication key, user ID, or
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下的`RegisterRequest()`函数，我们只是简单地记录了对API的另一个请求。同样，我们只是将请求绑定到IP，添加认证密钥、用户ID或
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code is a simple, standard initialization setup, except for the
    `createDateBounds()` function, which simply sets the start and end of our lookup:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个简单的标准初始化设置，除了`createDateBounds()`函数，它只是设置了我们查找的开始和结束：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following `CheckRequest()` function acts as the coordinating function for
    the entire process; it determines whether any given request exceeds the daily
    limit and returns the `Valid` status property:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的`CheckRequest()`函数充当整个过程的协调函数；它确定任何给定请求是否超过了每日限制，并返回`Valid`状态属性：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Implementing rate limiting as middleware
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施速率限制作为中间件
- en: Unlike the cache system, turning the rate limiter into middleware is much easier.
    Either the IP address is rate-limited, or it's not and we move on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与缓存系统不同，将速率限制器转换为中间件要容易得多。要么IP地址受到速率限制，要么没有，我们继续进行。
- en: 'Here''s an example for updating users:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新用户的示例：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And then, we can introduce a `RateLimit()` middleware call:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以引入一个`RateLimit()`中间件调用：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This allows us to block the middleware chain if our `ratelimit.CheckRequest()`
    call fails and prevents any more processing-intensive parts of our API from being
    called.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在我们的`ratelimit.CheckRequest()`调用失败时阻止中间件链，并防止调用API的更多处理密集型部分。
- en: Implementing SPDY
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施SPDY
- en: If there's one thing you can say about Google's vast ecosystem of products,
    platforms, and languages, it's that there's a perpetual, consistent focus on one
    thing that spans all of them—a need for speed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一件事你可以说谷歌庞大的产品、平台和语言生态系统，那就是它们都有一个永恒的、一致的关注点——对速度的需求。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We briefly mentioned the SPDY pseudo-protocol in [Chapter 7](ch07.html "Chapter 7. Working
    with Other Web Technologies"), *Working with Other Web Technologies*. You can
    read more about SPDY from its whitepaper at [http://www.chromium.org/spdy/spdy-whitepaper](http://www.chromium.org/spdy/spdy-whitepaper).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](ch07.html "第7章。使用其他Web技术")中简要提到了SPDY伪协议，*使用其他Web技术*。您可以从其白皮书[http://www.chromium.org/spdy/spdy-whitepaper](http://www.chromium.org/spdy/spdy-whitepaper)中了解更多关于SPDY的信息。
- en: As Google (the search engine) quickly scaled from being a student project to
    the most popular site on Earth to the de facto way people find anything anywhere,
    scaling the product and its underlying infrastructure became key.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 随着谷歌（搜索引擎）从一个学生项目迅速发展成为地球上最受欢迎的网站，成为人们发现任何事物的事实方式，产品及其基础设施的扩展变得至关重要。
- en: And, if you think about it, this search engine is heavily dependent on sites
    being available; if the sites are fast, Google's spiders and indexers will be
    faster and the results will be more current.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，如果你仔细想想，这个搜索引擎非常依赖于网站的可用性；如果网站速度快，谷歌的蜘蛛和索引器将更快，结果也将更加及时。
- en: Much of this is behind Google's *Let's Make the Web Faster* campaign, which
    aims to help developers on both the backend and frontend by being cognizant of
    and pushing toward speed as the primary consideration.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 其中很多都是谷歌的*让网络更快*活动背后的原因，该活动旨在通过认识到速度是主要考虑因素并朝着速度推进，来帮助后端和前端开发人员。
- en: Google is also behind the SPDY pseudo-protocol that augments HTTP and operates
    as a stopgap set of improvements, many of which are finding their way into the
    standardization of HTTP/2.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌也是SPDY伪协议的背后推手，它增强了HTTP并作为一组改进的临时措施，其中许多改进正在被纳入HTTP/2的标准化。
- en: There are a lot of SPDY implementations that are written for Go, and SPDY seems
    to be a particularly popular project to embrace as it's not yet supported directly
    in Go. Most implementations are interchangeable drop-in replacements for `http`
    in `net/http`. In most practical cases, you can get these benefits by simply leaving
    SPDY to a reverse proxy such as HAProxy or Nginx.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多为Go编写的SPDY实现，SPDY似乎是一个特别受欢迎的项目，因为它尚未直接在Go中支持。大多数实现都可以替换`net/http`中的`http`，在大多数实际情况下，你可以通过简单地将SPDY留给HAProxy或Nginx等反向代理来获得这些好处。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here are a few SPDY implementations that implement both secure and nonsecure
    connections and that are worth checking out and comparing:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些实现了安全和非安全连接的SPDY实现，值得一看并进行比较：
- en: 'The `spdy.go` file from Solomon Hykes: [https://github.com/shykes/spdy-go](https://github.com/shykes/spdy-go)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Solomon Hykes的`spdy.go`文件：[https://github.com/shykes/spdy-go](https://github.com/shykes/spdy-go)
- en: 'The `spdy` file from Jamie Hall: [https://github.com/SlyMarbo](https://github.com/SlyMarbo)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Jamie Hall的`spdy`文件：[https://github.com/SlyMarbo](https://github.com/SlyMarbo)
- en: We'll first look at `spdy.go` from the preceding list. Switching our `ListenAndServe`
    function is the easiest first step, and this approach to implement SPDY is fairly
    common.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看一下前面列表中的`spdy.go`。切换我们的`ListenAndServe`函数是最简单的第一步，这种实现SPDY的方法是相当常见的。
- en: 'Here''s how to use `spdy.go` as a drop-in replacement in our `api.go` file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在我们的`api.go`文件中使用`spdy.go`作为一个可替换的方法：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Pretty simple, huh? Some SPDY implementations make serving pages through the
    SPDY protocol in lieu of `HTTP/HTTP` semantically indistinguishable.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 相当简单，是吧？一些SPDY实现通过SPDY协议提供页面，而不是`HTTP/HTTPS`，在语义上是无法区分的。
- en: For some Go developers, this counts as an idiomatic approach. For others, the
    protocols are different enough that having separate semantics is logical. The
    choice here depends on your preference.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些Go开发者来说，这被视为一种惯用的方法。对于其他人来说，这些协议的差异足够大，以至于有单独的语义是合乎逻辑的。在这里的选择取决于您的偏好。
- en: However, there are a few other considerations to take into account. First, SPDY
    introduces some additional features that we can utilize. Some of these are baked-in
    like header compression.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些其他考虑因素需要考虑。首先，SPDY引入了一些我们可以利用的附加功能。其中一些是内置的，比如头部压缩。
- en: Detecting SPDY support
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测SPDY支持
- en: For most clients, detecting SPDY is not something that you need to worry about
    too much, as SPDY support relies on TLS/SSL support.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数客户端来说，检测SPDY并不是需要过多担心的事情，因为SPDY支持依赖于TLS/SSL支持。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we worked at a few concepts that are important to highly-performant
    APIs. These primarily included rate limiting and disk and memory caching that
    were executed through the use of custom-written middleware.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些对高性能API非常重要的概念。这些主要包括通过自定义中间件执行的速率限制和磁盘和内存缓存。
- en: Utilizing the examples within this chapter, you can implement any number of
    middleware-reliant services to keep your code clean and introduce better security,
    faster response times, and more features.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 利用本章中的示例，您可以实现任意数量的依赖中间件的服务，以保持代码清晰，并引入更好的安全性、更快的响应时间和更多功能。
- en: In the next and final chapter, we'll focus on security-specific concepts that
    should lock in additional concerns with rate limits, denial-of-service detection,
    and mitigating and preventing attempts at code and SQL injections.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的最后一章中，我们将专注于安全特定的概念，这些概念应该锁定额外的关注点，包括速率限制、拒绝服务检测，以及减轻和预防代码和SQL注入的尝试。
