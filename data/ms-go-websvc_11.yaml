- en: Chapter 11. Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 安全
- en: Before we begin this chapter, it's absolutely essential to point out one thing—though
    security is the topic of the last chapter of this book, it should never be the
    final step in application development. As you develop any web service, security
    should be considered prominently at every step. By considering security as you
    design, you limit the impact of top-to-bottom security audits after an application's
    launch.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始本章之前，绝对必要指出一件事——尽管安全是本书最后一章的主题，但它不应该是应用程序开发的最终步骤。在开发任何Web服务时，安全性应该在每一步骤中得到重视。通过在设计时考虑安全性，您可以限制应用程序启动后进行自上而下的安全审计的影响。
- en: With that being said, the intent here is to point out some of the larger and
    more rampant security flaws and look at ways in which we can allay their impact
    on our web service using standard Go and general security practices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，这里的意图是指出一些更大更猖獗的安全漏洞，并探讨我们如何使用标准的Go和一般安全实践来减轻它们对我们的Web服务的影响。
- en: Of course, out of the box, Go provides some wonderful security features that
    are disguised as solely good programming practices. Using all the included packages
    and handling all the errors are not only useful for developing good habits, but
    they also help you to secure your application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Go提供了一些出色的安全功能，它们被伪装成纯粹的良好编程实践。使用所有包和处理所有错误不仅有助于养成良好的习惯，而且还有助于确保应用程序的安全。
- en: However, no language can offer perfect security nor can it stop you from shooting
    yourself in the foot. In fact, the most expressive and utilitarian languages often
    make that as easy as possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有一种语言可以提供完美的安全性，也无法阻止你自己给自己惹麻烦。事实上，最具表现力和实用性的语言往往使这变得尽可能容易。
- en: There's also a large trade-off when it comes to developing your own design as
    opposed to using an existing package (as we've done throughout this book), be
    it for authentication, database interfaces, or HTTP routing or middleware. The
    former can provide quick resolution and less exposure of errors and security flaws.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发自己的设计与使用现有包（就像我们在整本书中所做的那样）之间也存在很大的权衡，无论是用于身份验证、数据库接口还是HTTP路由或中间件。前者可以提供快速解决方案，并减少错误和安全漏洞的曝光。
- en: There is also some security through obscurity that is offered by building your
    own application, but swift responses to security updates and a whole community
    whose eyes are on your code beats a smaller, closed-source project.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建自己的应用程序，还可以提供一些安全性，但对安全更新的迅速响应以及整个社区的目光都胜过一个较小的闭源项目。
- en: 'In this chapter, we''ll look at:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到：
- en: Handling error logging for security purposes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理安全目的的错误日志记录
- en: Preventing brute-force attempts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止暴力尝试
- en: Logging authentication attempts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录身份验证尝试
- en: Input validation and injection mitigation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入验证和注入缓解
- en: Output validation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出验证
- en: Lastly, we'll look at a few production-ready frameworks to look at the way they
    handle API and web service integrations and associated security.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看一些生产就绪的框架，以了解它们处理API和Web服务集成以及相关安全性的方式。
- en: Handling error logging for security
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理安全目的的错误日志记录
- en: A critical step on the path to a secure application involves the use of comprehensive
    logging. The more data you have, the better you can analyze potential security
    flaws and look at the way your application is used.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在通往安全应用程序的道路上，关键的一步是使用全面的日志记录。您拥有的数据越多，就越能分析潜在的安全漏洞，并了解应用程序的使用方式。
- en: Even so, the "log it all" approach can be somewhat difficult to utilize. After
    all, finding the needles in the haystack can be particularly difficult if you
    have all the hay.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，“记录所有”方法可能有些难以利用。毕竟，如果你有所有的干草，找到其中的针可能会特别困难。
- en: Ideally, we'd want to log all errors to file and have the ability to segregate
    other types of general information such as SQL queries that are tied to users
    and/or IP addresses.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望将所有错误记录到文件，并具有将其他类型的一般信息（例如与用户和/或IP地址相关的SQL查询）分隔的能力。
- en: In the next section, we'll look at logging authentication attempts but only
    in memory/an application's lifetime to detect brute-force attempts. Using the
    log package more extensively allows us to maintain a more persistent record of
    such attempts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下记录身份验证尝试，但仅在内存/应用程序的生命周期中，以便检测暴力尝试。更广泛地使用日志包可以让我们保持对这些尝试的更持久的记录。
- en: 'The standard way to create log output is to simply set the output of the general
    log, `Logger`, like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建日志输出的标准方法是简单地设置一般日志`Logger`的输出，就像这样：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This allows us to specify a new file instead of our default `stdout` class for
    logging our database errors for analyzing later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够指定一个新文件，而不是我们默认的`stdout`类，用于记录我们的数据库错误，以便以后分析。
- en: 'However, if we want multiple log files for different errors (for example, database
    errors and authentication errors), we can break these into separate loggers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要为不同的错误（例如数据库错误和身份验证错误）创建多个日志文件，我们可以将它们分成单独的记录器：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we instantiate separate loggers with specific formats for our log files:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用特定格式为我们的日志文件实例化单独的记录器：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By building separate logs for elements of an application in this manner, we
    can divide and conquer the debugging process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式为应用程序的各个元素构建单独的日志，我们可以分而治之地进行调试过程。
- en: As for logging SQL, we can make use of the `sql.Prepare()` function instead
    of using `sql.Exec()` or `sql.Query()` to keep a reference to the query before
    executing it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于记录SQL，我们可以利用`sql.Prepare()`函数，而不是使用`sql.Exec()`或`sql.Query()`在执行之前保留对查询的引用。
- en: 'The `sql.Prepare()` function returns a `sql.Stmt` struct, and the query itself,
    which is represented by the variable query, is not exported. You can, however,
    use the struct''s value itself in your log file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`sql.Prepare()`函数返回一个`sql.Stmt`结构，而查询本身，由变量query表示，不会被导出。但是，您可以在日志文件中使用结构的值本身：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will leave a detailed account of the query in the log file. For more detail,
    IP addresses can be appended to the `Stmt` class for more information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在日志文件中留下查询的详细账户。为了获得更多细节，IP地址可以附加到`Stmt`类以获取更多信息。
- en: Storing every transactional query to a file may, however, end up becoming a
    drag on performance. Limiting this to data-modifying queries and/or for a short
    period of time will allow you to identify potential issues with security.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个交易查询存储到文件中可能会对性能产生影响。将其限制为修改数据的查询和/或短时间内将允许您识别安全性潜在问题。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are some third-party libraries for more robust and/or prettier logging.
    Our favorite is go-logging, which implements multiple output formats, partitioned
    debugging buckets, and expandable errors with attractive formatting. You can read
    more about these at [https://github.com/op/go-logging](https://github.com/op/go-logging)
    or download the documentation via the `go get github.com/op/go-logging` command.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些第三方库可以进行更强大和/或更漂亮的记录。我们最喜欢的是go-logging，它实现了多种输出格式、分区调试桶和具有吸引人的格式的可扩展错误。您可以在[https://github.com/op/go-logging](https://github.com/op/go-logging)上阅读更多信息，或通过`go
    get github.com/op/go-logging`命令下载文档。
- en: Preventing brute-force attempts
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止暴力破解尝试
- en: Perhaps the most common, lowest-level attempt at circumventing the security
    of any given system is the brute-force approach.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 也许是绕过任何给定系统安全性的最常见、最低级别的尝试是暴力破解方法。
- en: From the point of view of an attacker, this makes some sense. If an application
    designer allows an infinite amount of login attempts without penalty, then the
    odds of this application enforcing a good password-creation policy are low.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从攻击者的角度来看，这是有道理的。如果应用程序设计者允许无限次数的登录尝试而不受惩罚，那么这个应用程序执行良好的密码创建策略的可能性就很低。
- en: This makes it a particularly vulnerable application. And, even if the password
    rules are in place, there is still a likelihood to use dictionary attacks to get
    in.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得它成为一个特别容易受攻击的应用程序。即使密码规则已经制定，仍然有可能使用字典攻击来获取登录权限。
- en: Some attackers will look at rainbow tables in order to determine a hashing strategy,
    but this is at least in some way mitigated by the use of unique salts per account.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些攻击者会查看彩虹表以确定哈希策略，但这至少在某种程度上被每个帐户使用唯一的盐所缓解。
- en: Brute-force login attacks were actually often easier in the offline days because
    most applications did not have a process in place to automatically detect and
    lock account access attempts with invalid credentials. They could have, but then
    there would also need to be a retrieval authority process—something like "e-mail
    me my password".
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在线下时代，暴力登录攻击通常更容易，因为大多数应用程序没有流程来自动检测和锁定使用无效凭据的帐户访问尝试。他们本来可以这样做，但那么也需要有一个检索权限流程——类似于“给我发邮件我的密码”。
- en: With services such as our social network, it makes a great deal of sense to
    either lock accounts or temporarily disable logins after a certain point.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像我们的社交网络这样的服务，锁定帐户或在一定程度后暂时禁用登录是非常有意义的。
- en: The first is a more dramatic approach, requiring direct user action to restore
    an account; often, this also entails greater support systems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一种更激进的方法，需要直接用户操作来恢复帐户；通常，这也需要更大的支持系统。
- en: The latter is beneficial because it thwarts brute-force attempts by greatly
    slowing the rate of attempts, and rendering most attacks useless for all practical
    purposes without necessarily requiring user action or support to restore access.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 后者是有益的，因为它通过大大减慢尝试的速度来阻止暴力破解尝试，并使大多数攻击在实际目的上变得无用，而不一定需要用户操作或支持来恢复访问。
- en: Knowing what to log
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 知道要记录什么
- en: One of the hardest things to do when it comes to logging is deciding what it
    is that you need to know. There are several approaches to this, ranging from logging
    everything to logging only fatal errors. All the approaches come with their own
    potential issues, which are largely dependent on a trade-off between missing some
    data and wading through an impossible amount of data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录日志时最难的事情之一是决定你需要知道什么。有几种方法可以做到这一点，从记录所有内容到仅记录致命错误。所有这些方法都伴随着自己的潜在问题，这在很大程度上取决于错过一些数据和浏览不可能的数据之间的权衡。
- en: The first consideration that we'll need to make is what we should log in memory—only
    failed authentications or attempts against API keys and other credentials.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的第一个问题是我们应该在内存中记录什么——只有失败的身份验证或针对API密钥和其他凭据的尝试。
- en: It may also be prudent to note login attempts against nonexistent users. This
    will tell us that someone is likely doing something nefarious with our web service.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记录针对不存在用户的登录尝试也可能是明智的。这将告诉我们，有人很可能在对我们的网络服务进行不正当的操作。
- en: Next, we'll want to set a lower threshold or the maximum amount of login attempts
    before we act.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将希望设置一个较低的阈值或登录尝试的最大次数，然后再采取行动。
- en: 'Let''s start by introducing a `bruteforcedetect` package:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先介绍一个`bruteforcedetect`包：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can set this directly as a package variable and modify it from the calling
    application, if necessary. Three attempts are likely lower than what we''d like
    for a general invalid login threshold, particularly one that automatically bans
    the IP:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将其设置为一个包变量，并在必要时从调用应用程序中进行修改。三次尝试可能比我们希望的一般无效登录阈值要低，特别是自动禁止IP的情况：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our `Requester` struct will maintain all incremental values associated with
    any given IP or hostname, including general attempts at a login, failed attempts,
    and failed attempts wherein the requested user does not actually exist in our
    database:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Requester`结构将维护与任何给定IP或主机名相关的所有增量值，包括一般的登录尝试、失败的尝试以及请求的用户实际上并不存在于我们的数据库中的失败尝试：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We don't need this as middleware as it needs to react to just one thing—authentication
    attempts. As such, we have a choice as it relates to storage of authentication
    attempts. In a real-world environment, we may wish to grant this process more
    longevity than we will here. We could store these attempts directly into memory,
    a datastore, or even to disk.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将其作为中间件，因为它只需要对一件事情做出反应——认证尝试。因此，关于认证尝试的存储，我们有选择。在现实环境中，我们可能希望给这个过程更长的寿命。我们可以直接将这些尝试存储到内存中、数据存储中，甚至存储到磁盘中。
- en: However, in this case, we'll just let this data live in the memory space of
    this application by creating a map of the `bruteforce.Requester` struct. This
    means that if our server reboots, we lose these attempts. Similarly, it means
    that multiple server setups won't necessarily know about attempts on other servers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，我们将通过创建`bruteforce.Requester`结构的映射，让这些数据仅存在于应用程序的内存空间中。这意味着如果我们的服务器重新启动，我们将丢失这些尝试。同样，这意味着多个服务器设置不一定会知道其他服务器上的尝试。
- en: Both these problems can be easily solved by putting less ephemeral storage behind
    the logging of bad attempts, but we'll keep it simple for this demonstration.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题都可以通过在记录错误尝试的背后放置更少的短暂存储来轻松解决，但是为了演示的简单性，我们将保持简单。
- en: 'In our `api.go` file, we''ll bring in `bruteforce` and create our map of `Requesters`
    when we start the application:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`api.go`文件中，我们将引入`bruteforce`并在启动应用程序时创建我们的`Requesters`映射：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And then, of course, to take this from being a nil map, we''ll initialize it
    when our server starts:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们的服务器启动时，当然要将这个从空映射变成一个初始化的映射：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We're now ready to start logging our attempts.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始记录我们的尝试。
- en: If you've decided to implement middleware for login attempts, make the adjustment
    here by simply putting these changes into the middleware handler instead of the
    separate function named `CheckLogin()` that we originally called.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定为登录尝试实现中间件，在这里进行调整，只需将这些更改放入中间件处理程序中，而不是最初调用的名为`CheckLogin()`的单独函数。
- en: No matter what happens with our authentication—be it a valid user, valid authentication;
    a valid user, invalid authentication; or an invalid user—we want to add this to
    our `LoginAttempts` function of the respective `Requester` struct.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们的认证发生了什么——无论是有效的用户、有效的认证；有效的用户、无效的认证；还是无效的用户——我们都希望将其添加到相应的`Requester`结构的`LoginAttempts`函数中。
- en: We'll bind each `Requester` map to either our IP or hostname. In this case,
    we will use the IP address.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个`Requester`映射绑定到我们的IP或主机名。在这种情况下，我们将使用IP地址。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `net` package has a function called `SplitHostPort` that properly explodes
    our `RemoteAddr` value from the `http.Request` handler, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`net`包有一个名为`SplitHostPort`的函数，可以正确地从`http.Request`处理程序中的`RemoteAddr`值中分解出来，如下所示：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also just use the entire `r.RemoteAddr` value, which may be more comprehensive:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以只使用整个`r.RemoteAddr`值，这可能更全面：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This means that no matter what, we invoke another attempt to the tally.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无论如何，我们都会对总数进行另一次尝试。
- en: 'Since `CheckLogin()` will always create the map''s key if it doesn''t exist,
    we''re free to safely evaluate on this key further down the authentication pipeline.
    For example, in our `UserLogin()` handler, which processes an e-mail address and
    a password from a form and checks against our database, we first call `UserLogin()`
    before checking the submitted values:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CheckLogin()`总是会在不存在时创建映射的键，我们可以在认证流程的后面安全地对这个键进行评估。例如，在我们的`UserLogin()`处理程序中，首先调用`UserLogin()`，然后再检查提交的值：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we check against our maximum login attempts following the `CheckLogin()`
    call, we'll never allow database lookups after a certain point.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`CheckLogin()`调用之后检查最大的登录尝试次数，我们将永远不会在某一点之后允许数据库查找。
- en: 'In the following code of the `UserLogin()` function, we compare the hash from
    the submitted password to the one stored in the database and return an error on
    an unsuccessful match. Let''s use that to increment the `FailedAttempts` value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserLogin()`函数的以下代码中，我们将提交的密码的哈希与数据库中存储的密码哈希进行比较，并在不成功匹配时返回错误。让我们使用它来增加`FailedAttempts`值：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This simply increases our general `FailedAttempts` integer value with each invalid
    login per IP.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是增加了我们的一般`FailedAttempts`整数值，每个IP的无效登录都会增加这个值。
- en: 'However, we''re not yet doing anything with this. To inject it as a blocking
    element, we''ll need to evaluate it after the `CheckLogin()` call to initialize
    the map''s hash if it does not exist yet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有对此做任何处理。为了将其作为一个阻塞元素注入，我们需要在`CheckLogin()`调用之后对其进行评估，以初始化映射的哈希（如果尚不存在）：
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the preceding code, you may notice that the mutable `FailedAttempts` value
    that is bound by `RemoteAddr` could theoretically be susceptible to a race condition,
    causing unnatural increments and premature blocking. A mutex or similar locking
    mechanism may be used to prevent this behavior.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可能会注意到由`RemoteAddr`绑定的可变`FailedAttempts`值在理论上可能会受到竞争条件的影响，导致不自然的增加和过早的阻塞。可以使用互斥锁或类似的锁定机制来防止这种行为。
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This call to `Check()` prevents banned IPs from even accessing our database
    at the login endpoint, which can still cause additional strain, bottlenecks, and
    potential service disruptions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对`Check()`的调用可以防止被禁止的IP地址甚至在登录端点访问我们的数据库，这仍然可能导致额外的压力、瓶颈和潜在的服务中断：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And, to update our `Check()` method from a brute-force attack, we will use
    the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新我们的`Check()`方法，以防止暴力攻击，我们将使用以下代码：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This supplies us with an ephemeral way to store information about login attempts,
    but what if we want to find out whether someone is simply testing account names
    along with passwords, ala "guest" or "admin?"
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一种短暂的方式来存储有关登录尝试的信息，但是如果我们想找出某人是否只是在测试帐户名和密码，比如“guest”或“admin”，该怎么办呢？
- en: 'To do this, we''ll just add an additional check to `UserLogin()` to see whether
    the requested e-mail account exists. If it does, we''ll just continue. If it does
    not exist, we''ll increment `FailedInvalidUserAttempts`. We can then make a decision
    about whether we should block access to the login portion of `UserLogin()` at
    a lower threshold:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们只需在`UserLogin()`中添加额外的检查，以查看所请求的电子邮件帐户是否存在。如果存在，我们将继续。如果不存在，我们将增加`FailedInvalidUserAttempts`。然后我们可以决定是否应该在`UserLogin()`的登录部分下降到更低的阈值：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we decide that the traffic is represented by fully failed authenticated attempts
    (for example, invalid users), we can also pass that information to IP tables or
    our front-end proxy to block the traffic from even getting to our application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定流量由完全失败的身份验证尝试（例如，无效用户）表示，我们还可以将该信息传递给IP表或我们的前端代理，以阻止流量甚至到达我们的应用程序。
- en: Handling basic authentication in Go
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中处理基本身份验证
- en: One area at which we didn't look too deeply in the authentication section of
    [Chapter 7](ch07.html "Chapter 7. Working with Other Web Technologies"), *Working
    with Other Web Technologies*, was basic authentication. It's worth talking about
    as a matter of security, particularly as it can be a very simple way to allow
    authentication in lieu of OAuth, direct login (with sessions), or keys. Even in
    the latter, it's entirely possible to utilize API keys as part of basic authentication.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。与其他Web技术合作")中，我们没有深入研究身份验证部分，*与其他Web技术合作*，基本身份验证。这是值得讨论的安全问题，特别是它可以是一种非常简单的方式，允许身份验证代替OAuth、直接登录（带会话）或密钥。即使在后者中，完全可以利用API密钥作为基本身份验证的一部分。
- en: The most critical aspect of basic authentication is an obvious one—**TLS**.
    Unlike methods that involve passing keys, there's very little obfuscation involved
    in the basic authentication header method, as beyond Base64 encoding, everything
    is essentially cleartext.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证最关键的方面是一个显而易见的一点——**TLS**。与涉及传递密钥的方法不同，在基本身份验证标头方法中几乎没有混淆，除了Base64编码之外，一切基本上都是明文。
- en: This of course enables some very simple man-in-the-middle opportunities for
    nefarious parties.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这为恶意方提供了一些非常简单的中间人机会。
- en: In [Chapter 7](ch07.html "Chapter 7. Working with Other Web Technologies"),
    *Working with Other Web Technologies*, we explored the concept of creating transaction
    keys with shared secrets (similar to OAuth) and storing valid authentication via
    sessions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。与其他Web技术合作")中，*与其他Web技术合作*，我们探讨了使用共享密钥创建交易密钥并通过会话存储有效身份验证的概念。
- en: 'We can grab usernames and passwords or API keys directly from the `Authorization`
    header and measure attempts on the API by including a check for this header at
    the top of our `CheckLogin()` call:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从“授权”标头中获取用户名和密码或API密钥，并通过在我们的`CheckLogin()`调用顶部包含对该标头的检查来测量对API的尝试：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we can allow our `CheckLogin()` function to utilize either
    the data posted to our API to obtain username and password combinations, API keys,
    or authentication tokens, or we can also ingest that data directly from the header.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以允许我们的`CheckLogin()`函数利用要么从我们的API发布的数据来获取用户名和密码组合、API密钥或身份验证令牌，要么我们也可以直接从标头中摄取这些数据。
- en: Handling input validation and injection mitigation
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理输入验证和注入缓解
- en: If a brute-force attack is a rather inelegant exercise in persistence, one in
    which the attacker has no access, input or injection attacks are the opposite.
    At this point, the attacker has some level of trust from the application, even
    if it is minimal.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果暴力攻击是一种相当不雅的坚持练习，攻击者没有访问、输入或注入攻击则相反。在这一点上，攻击者对应用程序有一定程度的信任，即使它很小。
- en: SQL injection attacks can happen at any level in the application pipeline, but
    cross-site scripting and cross-site request forgeries are aimed less at the application
    and more at other users, targeting vulnerabilities to expose their data or bring
    other security threats directly to the application or browser.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入攻击可以发生在应用程序管道的任何级别，但跨站点脚本和跨站点请求伪造更多地针对其他用户，而不是应用程序，针对漏洞暴露其数据或直接将其他安全威胁带到应用程序或浏览器。
- en: In this next section, we'll examine how to keep our SQL queries safe through
    input validation, and then move onto other forms of input validation as well as
    output validation and sanitization.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将通过输入验证来检查如何保持我们的SQL查询安全，然后转向其他形式的输入验证以及输出验证和净化。
- en: Using best practices for SQL
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SQL的最佳实践
- en: There are a few very big security loopholes when it comes to using a relational
    database, and most of them apply to other methods of data storage. We've looked
    at a few of these loopholes such as properly and uniquely salting passwords and
    using secure sessions. Even in the latter, there is always some risk of session
    fixation attacks, which allow shared or persistent shared sessions to be hijacked.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用关系数据库时存在一些非常大的安全漏洞，其中大部分都适用于其他数据存储方法。我们已经看过一些这些漏洞，比如正确和唯一地加盐密码以及使用安全会话。即使在后者中，也总是存在一些会话固定攻击的风险，这允许共享或持久共享会话被劫持。
- en: One of the more pervasive attack vectors, which modern database adapters tend
    to eliminate, are injection attacks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个更普遍的攻击向量，现代数据库适配器 tend to 消除的是注入攻击。
- en: Injection attacks, particularly SQL injections, are among the most prevalent
    and yet most avoidable loopholes that can expose sensitive data, compromise accountability,
    and even make you lose control of entire servers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注入攻击，特别是SQL注入，是最常见的，但也是最可避免的漏洞之一，可以暴露敏感数据，损害问责制，甚至使您失去对整个服务器的控制。
- en: A keen eye may have caught it, but earlier in this book, we deliberately built
    an unsafe query into our `api.go` file that can allow SQL injection.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的眼睛可能已经注意到了，但在本书的前面，我们故意在我们的`api.go`文件中构建了一个不安全的查询，可以允许SQL注入。
- en: 'Here is the line in our original `CreateUser()` handler:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们原始的`CreateUser()`处理程序中的一行：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It goes without saying, but constructing queries as a straight, direct SQL command
    is frowned upon in almost all languages.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，但是在几乎所有语言中，直接构造查询作为直接的SQL命令是不受欢迎的。
- en: A good general rule of thumb is to treat all externally produced data, including
    user input, internal or administrator user input, and external APIs as malicious.
    By being as suspicious as possible of user-supplied data, we improve the odds
    of catching potentially harmful injections.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是将所有外部生成的数据，包括用户输入、内部或管理员用户输入和外部API视为恶意。通过尽可能怀疑用户提供的数据，我们提高了捕捉潜在有害注入的几率。
- en: Most of our other queries utilized the parameterized `Query()` function that
    allows you to add variadic parameters that correspond to the `?` tokens.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的其他大部分查询都使用了参数化的`Query()`函数，该函数允许您添加与`?`标记对应的可变参数。
- en: Remember that since we store the user's unique salt in the database (at least
    in our example), losing access to the MySQL database means that we also lose the
    security benefits of having a password salt in the first place.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于我们在数据库中存储用户的唯一盐（至少在我们的示例中），失去对MySQL数据库的访问权限意味着我们也失去了首次使用密码盐的安全好处。
- en: This doesn't mean that all accounts' passwords are exposed in this scenario,
    but at this point, having direct login credentials for users would only be useful
    for exploiting other services if the users maintain poor personal password standards,
    that is, sharing passwords across services.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着在这种情况下所有账户的密码都会被暴露，但在这一点上，如果用户保持个人密码标准低劣，那么直接获取用户的登录凭据只有在利用其他服务方面才有用，也就是说，在服务之间共享密码。
- en: Validating output
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证输出
- en: Normally, the idea of output validation seems foreign, particularly when the
    data is sanitized on the input side.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，输出验证的概念似乎很陌生，特别是当数据在输入端进行了消毒时。
- en: Preserving the values as they were sent and only sanitizing them when they are
    output may make some sense, but it increases the odds that said values might not
    be sanitized on the way out to the API consumer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 保留值的发送方式，并且仅在输出时对其进行消毒可能是有道理的，但这增加了这些值在传递给API消费者时可能未经消毒的几率。
- en: There are two main ways in which a payload can be delivered to the end user,
    either in a stored attack where we, as the application, keep the vector verbatim
    on our server, or in a reflected attack wherein some code is appended via another
    method such as an e-mail message that includes the payload.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要方式可以将有效负载传递给最终用户，一种是存储攻击，我们作为应用程序在服务器上保留向量，另一种是反射攻击，其中一些代码通过其他方法附加，例如包含有效负载的电子邮件消息。
- en: APIs and web services can sometimes be especially susceptible to not only **XSS**
    (short form for **Cross-Site Scripting**) but also **CSRF** (short form for **Cross-Site**
    **Request Forgery**).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: API和Web服务有时特别容易受到不仅**XSS**（**跨站脚本攻击**的缩写）的影响，还有**CSRF**（**跨站请求伪造**的缩写）。
- en: We'll briefly look at both of these and the ways in which we can limit their
    efficacy within our web service.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要讨论这两种情况以及我们可以在Web服务中限制它们的有效性的方法。
- en: Protection against XSS
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止XSS攻击
- en: Anytime we're dealing with user input that will later be translated into output
    for the consumption of other users, we need to be wary of Cross-Site Scripting
    or Cross-Site Request Forgery in the resulting data payload.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们处理用户输入，以便稍后将其转换为其他用户消费的输出时，我们都需要警惕跨站脚本攻击或跨站请求伪造在生成的数据有效负载中的问题。
- en: This isn't necessarily a matter solely for output validation. It can and should
    be addressed at the input stage as well. However, our output is our last line
    of defense between one user's arbitrary text and another user's consumption of
    that text.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是输出验证的问题。这也应该在输入阶段进行处理。然而，我们的输出是我们在一个用户的任意文本和另一个用户消费该文本之间的最后防线。
- en: 'Traditionally, this is best illustrated through something like the following
    nefarious piece of hypothetical code. A user hits our `/api/statuses` endpoint
    with a `POST` request, after authenticating it via whatever method is selected,
    and posts the following status:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，最好通过以下假设性的恶意代码片段来说明这一点。用户通过`POST`请求击中我们的`/api/statuses`端点，经过选择的任何方法进行身份验证，并发布以下状态：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If presented in a template, as in our interface example, then this is a problem
    that will be mitigated automatically by using Go's template engine.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果像我们的界面示例一样呈现在模板中，那么使用Go的模板引擎将自动减轻这个问题。
- en: 'Let''s take the preceding example data and see what it looks like on our interface''s
    user profile page:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的示例数据在我们界面的用户配置文件页面上是什么样子：
- en: '![Protection against XSS](img/1304OS_11_01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![防止XSS攻击](img/1304OS_11_01.jpg)'
- en: The `html/template` package automatically escapes the HTML output to prevent
    code injection, and it requires an override to allow any HTML tags to come through
    as originally entered.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`html/template`包会自动转义HTML输出，以防止代码注入，并且需要覆盖以允许任何HTML标签原样输入。'
- en: However, as an API provider, we are agnostic towards the type of consuming application
    language and support or care given to sanitation of input.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为API提供者，我们对消费应用程序语言的类型以及对输入的消毒的支持或关注是中立的。
- en: The onus on escaping data is a matter that needs some consideration, that is,
    should the data that your application provides to clients come pre-sanitized or
    should it come with a usage note about sanitizing data? The answer in almost all
    cases is the first option, but depending on your role and the type of data, it
    could go either way. On the other hand, unsanitizing the data in certain situations
    (for example, APIs) on the frontend means potentially having to reformat data
    in many different ways.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 转义数据的责任是需要考虑的问题，也就是说，您的应用程序提供给客户端的数据是否应该预先经过消毒，或者是否应该附带有关消毒数据的使用说明？在几乎所有情况下，答案都是第一种选择，但根据您的角色和数据类型，情况可能有所不同。另一方面，在某些情况下（例如API），在前端取消消毒数据意味着可能需要以多种方式重新格式化数据。
- en: Earlier in this chapter, we showed you some input validation techniques for
    allowing or disallowing certain types of data (such as characters, tags, and so
    on), and you can apply some of these techniques to an endpoint such as `/statuses`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面部分，我们向您展示了一些输入验证技术，用于允许或禁止某些类型的数据（如字符、标签等），您可以将这些技术应用到诸如`/statuses`之类的端点。
- en: It makes more sense, however, to allow this data; but, sanitize it either before
    saving it to a database/datastore or returning it via an API endpoint. Here are
    two ways in which we can use the `http/template` package to do either.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更合理的做法是允许这些数据；但是，在将其保存到数据库/数据存储或通过API端点返回之前对其进行清理。以下是我们可以使用`http/template`包来执行这两种操作的方法。
- en: 'First, when we accept data via the `/api/statuses` endpoint, we can utilize
    one or more of the functions in `html/template` to prevent certain types of data
    from being stored. The functions are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当我们通过`/api/statuses`端点接受数据时，我们可以利用`html/template`中的一个或多个函数来防止某些类型的数据被存储。这些函数如下：
- en: '`template.HTMLEscapeString`: This encodes HTML tags and renders the resulting
    string as non-HTML content'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template.HTMLEscapeString`: 这将对HTML标签进行编码，并将生成的字符串呈现为非HTML内容'
- en: '`template.JSEscapeString()`: This encodes JavaScript-specific pieces of a string
    to prevent proper rendering'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template.JSEscapeString()`: 这将对字符串的JavaScript特定部分进行编码，以防止正确呈现'
- en: 'For the purpose of keeping this simple for potential output through HTML, we
    can just apply `HTMLEscapeString()` to our data, which will disable any JavaScript
    calls from executing:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化通过HTML输出的目的，我们可以只需对我们的数据应用`HTMLEscapeString()`，这将禁用任何JavaScript调用的执行：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This makes the data escape on the input (`StatusCreate`) side. If we want to
    add JavaScript escaping (which, as noted earlier, may not be necessary), it should
    come before the HTML escaping, as noted here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得数据在输入（`StatusCreate`）端进行转义。如果我们想要添加JavaScript转义（正如前面所述，可能并不需要），它应该在HTML转义之前进行，如下所示：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If in lieu of escaping on the input side, we wish to do it on the output side,
    the same template escape calls can be made as part of the respective status request
    API calls, like `/api/statuses`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在输入端不进行转义，而是在输出端进行转义，那么可以在相应的状态请求API调用中进行相同的模板转义调用，比如`/api/statuses`：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we want to attempt to detect and log attempts to pass specific HTML elements
    into input elements, we can create a new logger for XSS attempts and capture any
    text that matches a `<script>` element, a `<iframe>` element, or any other element.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要尝试检测并记录尝试将特定HTML元素传递到输入元素中，我们可以为XSS尝试创建一个新的日志记录器，并捕获与`<script>`元素、`<iframe>`元素或其他任何元素匹配的任何文本。
- en: 'Doing this can be as complex as a tokenizer or a more advanced security package
    or as simple as a regular expression match, as we will see in the following examples.
    First, we will look at the code in our logging setup:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是一个像标记器或更高级的安全包一样复杂，也可以是一个像正则表达式匹配一样简单，我们将在接下来的示例中看到。首先，我们将查看我们日志设置中的代码：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And the changes in our initialization code are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化代码中的更改如下：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And then, make the following changes back in our application''s `StatusCreate`
    handler:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们应用程序的`StatusCreate`处理程序中进行以下更改：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Detecting tags this way, through regular expressions, is not airtight nor is
    it intended to be. Remember that we'll be sanitizing the data either on the input
    side or the output side, so if we can catch attempts through this method, it will
    give us some insight into potentially malicious attempts against our application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过正则表达式以这种方式检测标签既不是绝对可靠的，也不是本意。请记住，我们将在输入端或输出端对数据进行清理，因此如果我们可以通过这种方法捕捉到尝试，它将为我们提供一些关于对我们应用程序的潜在恶意尝试的见解。
- en: If we want to be more idiomatic and comprehensive, we can simply sanitize the
    text and compare it with the original. If the two values do not match, we can
    surmise that HTML was included.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更符合Go语言的习惯和更全面，我们可以简单地对文本进行清理并将其与原始文本进行比较。如果两个值不匹配，我们可以推断出HTML已被包含。
- en: This does mean that we'll get a positive for innocuous HTML tags such as bold
    tags or table tags.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将对无害的HTML标签（如粗体标签或表格标签）进行转义。
- en: Using server-side frameworks in Go
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中使用服务器端框架
- en: We would be remiss if, while detailing how to build a web service from scratch,
    we didn't at least touch upon integrating or exclusively using some existing frameworks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细介绍如何从头开始构建Web服务时，如果我们不至少触及集成或专门使用一些现有框架，那就不够周全了。
- en: Although you'll never get the same experience by plugging in such a framework
    as you would by designing one from scratch, for practical purposes, there's often
    no reason to reinvent the wheel when you want to start a project.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过插入这样一个框架来获得与从头开始设计一个框架相同的体验是不可能的，但出于实际目的，当您想要启动一个项目时，通常没有理由重新发明轮子。
- en: Go has quite a few readily available and mature web/HTML frameworks, but it
    also has a handful of noteworthy frameworks that are specifically designed for
    web services with some of the delivery methods and additional hooks that you might
    expect to see.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言有一些现成的、成熟的Web/HTML框架，但也有一些特别为Web服务设计的值得注意的框架，其中一些提供了你可能期望看到的一些交付方法和额外的钩子。
- en: By some measurements, it's fair to describe Gorilla as a framework; however,
    as the name implies, it's a little basic.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根据某些标准，可以将Gorilla描述为一个框架；然而，正如其名称所暗示的那样，它有点基础。
- en: Whether you use an existing framework or choose to build your own (either for
    the experience or to completely customize it due to business requirements), you
    should probably consider doing a bit
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用现有框架还是选择构建自己的框架（无论是出于经验还是出于完全定制业务需求），您都应该考虑做一些
- en: We'll briefly look at a few of these frameworks and how they can simplify the
    development of small web-based projects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要地看一下这些框架中的一些，以及它们如何简化小型基于Web的项目的开发。
- en: Tiger Tonic
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tiger Tonic
- en: Tiger Tonic is specifically an API-centric framework, so we'll mention it first
    in this section. This takes a very idiomatic Go approach to developing JSON web
    services.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Tiger Tonic是一个专门面向API的框架，因此我们将在本节中首先提到它。它采用了一种非常符合Go语言习惯的方式来开发JSON Web服务。
- en: Responses are primarily intended to be in JSON only and multiplexing should
    seem pretty familiar to the style introduced by Gorilla.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 响应主要是以JSON格式为主，多路复用应该与Gorilla引入的风格非常相似。
- en: Tiger Tonic also provides some quality logging features that allow you to funnel
    logs directly into the Apache format for more detailed analysis. Most importantly,
    it handles middleware in a way that allows some conditional operations based on
    the results of the middleware itself.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Tiger Tonic还提供了一些高质量的日志记录功能，允许您将日志直接导入Apache格式进行更详细的分析。最重要的是，它以一种方式处理中间件，允许根据中间件本身的结果进行一些条件操作。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about Tiger Tonic at [https://github.com/rcrowley/go-tigertonic](https://github.com/rcrowley/go-tigertonic)
    or download the documentation using the `go get github.com/rcrowley/go-tigertonic`
    command.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/rcrowley/go-tigertonic](https://github.com/rcrowley/go-tigertonic)了解更多关于Tiger
    Tonic的信息，或使用`go get github.com/rcrowley/go-tigertonic`命令下载文档。
- en: Martini
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Martini
- en: The web framework Martini is one of the more popular web frameworks for the
    relatively young Go language, largely due to its similarity in design to both
    the `Node.js` framework Express and the popular Ruby-on-Rails framework Sinatra.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Web框架Martini是相对年轻的Go语言中较受欢迎的Web框架之一，这在很大程度上是因为它在设计上与`Node.js`框架Express和流行的Ruby-on-Rails框架Sinatra相似。
- en: Martini also plays extraordinarily well with middleware, so much so that it's
    often brought in exclusively for this purpose. It also comes with a few standard
    middleware handlers like `Logger()` that takes care of logging in and out and
    `Recovery()` that recovers from panics and returns HTTP errors.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Martini还与中间件非常搭配，以至于它经常被专门用于这个目的。它还带有一些标准的中间件处理程序，比如`Logger()`用于处理登录和退出的日志记录，`Recovery()`用于从panic中恢复并返回HTTP错误。
- en: Martini is built for a large swath of web projects, and it may include more
    than what is necessary for a simple web service; however, it is an excellent all-inclusive
    framework that's worth checking out.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Martini是为大量网络项目构建的，可能包括比简单的网络服务更多的内容；然而，它是一个非常全面的框架，值得一试。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about Martini at [https://github.com/go-martini/martini](https://github.com/go-martini/martini)
    or download the documentation using the `go get github.com/go-martini/martini`
    command.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/go-martini/martini](https://github.com/go-martini/martini)了解更多关于Martini的信息，或使用`go
    get github.com/go-martini/martini`命令下载文档。
- en: Goji
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Goji
- en: Unlike Martini, which is quite comprehensive and far-reaching, the Goji framework
    is minimalistic and lean. The primary advantages of Goji are its incredibly quick
    routing system, a low overhead for additional garbage collection, and robust middleware
    integrations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与Martini相比，Goji框架是非常简约和精简的。Goji的主要优势在于其非常快速的路由系统，额外垃圾收集的开销低，以及强大的中间件集成。
- en: Goji uses Alice for middleware, which we briefly touched on in an earlier chapter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Goji使用Alice作为中间件，我们在前面的章节中简要提到过。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about the Goji micro framework at [https://goji.io/](https://goji.io/)
    and download it with the `go get github.com/zenazn/goji` and `go get github.com/zenazn/goji/web`
    commands.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://goji.io/](https://goji.io/)了解更多关于Goji微框架的信息，并使用`go get github.com/zenazn/goji`和`go
    get github.com/zenazn/goji/web`命令下载它。
- en: Beego
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Beego
- en: Beego is a more complex type of framework that has quickly become one of the
    more popular Go frameworks for web projects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Beego是一种更复杂的框架类型，已经迅速成为Go项目中较受欢迎的Web框架之一。
- en: Beego has a lot of features that can come in handy for a web service, despite
    the additional feature set that is largely intended for rendered web pages. The
    framework comes with its own sessions, routing, and cache modules, and also includes
    a live monitoring process that allows you to analyze your project dynamically.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Beego有许多功能，可以为网络服务提供便利，尽管其附加功能主要用于渲染网页。该框架配备了自己的会话、路由和缓存模块，并包括一个实时监控过程，允许您动态分析项目。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about Beego at [http://beego.me/](http://beego.me/) or download
    it using the `go get github.com/astaxie/beego` command.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://beego.me/](http://beego.me/)了解更多关于Beego的信息，或使用`go get github.com/astaxie/beego`命令下载它。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this final chapter, we looked at how to keep our web service as airtight
    as possible from common security issues and looked at solutions to mitigate issues
    if and when a breach happens.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们看了如何尽可能地使我们的网络服务免受常见的安全问题，并研究了如何在发生违规时减轻问题的解决方案。
- en: As APIs scale both in popularity and scope, it is paramount to ensure that users
    and their data are safe.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 随着API在受欢迎程度和范围上的扩展，确保用户及其数据的安全至关重要。
- en: We hope you have been (and will be) able to utilize these security best practices
    and tools to improve the overall reliability and speed of your application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您已经（并将能够）利用这些安全最佳实践和工具来提高应用程序的整体可靠性和速度。
- en: While our primary project—the social network—is by no means a complete or comprehensive
    project, we've broken down aspects of such a project to demonstrate routing, caching,
    authentication, display, performance, and security.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的主要项目——社交网络——绝不是一个完整或全面的项目，但我们已经分解了这样一个项目的各个方面，以演示路由、缓存、身份验证、显示、性能和安全性。
- en: If you wish to continue expanding the project, feel free to augment, fork, or
    clone the example at [https://github.com/nkozyra/masteringwebservices](https://github.com/nkozyra/masteringwebservices).
    We'd love to see the project continue to serve as a demonstration of features
    and best practices related to web services and APIs in Go.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望继续扩展项目，请随意增加、分叉或克隆[https://github.com/nkozyra/masteringwebservices](https://github.com/nkozyra/masteringwebservices)上的示例。我们很乐意看到该项目继续作为演示Go中与网络服务和API相关的功能和最佳实践。
