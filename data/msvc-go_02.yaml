- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Scaffolding a Go Microservice
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搭建 Go 微服务
- en: 'In this chapter, we will finally start scaffolding our microservice code. The
    goal of this chapter is to establish a solid foundation for writing Go microservices
    and setting the right structure for future changes. While Go makes it relatively
    easy to write small applications, there are multiple challenges that engineers
    may face along the way, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们最终将开始搭建我们的微服务代码。本章的目标是为编写 Go 微服务和为未来的变更设置正确的结构奠定坚实的基础。虽然 Go 使得编写小型应用程序相对容易，但工程师在过程中可能会遇到多个挑战，包括以下内容：
- en: How to set the right project structure to make it easier to evolve and maintain
    the code base
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置合适的项目结构，使其更容易演进和维护代码库
- en: How to write idiomatic Go code that is going to be consistent with the largest
    Go code bases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写符合最大 Go 代码库规范的惯用 Go 代码
- en: How to separate the components of a microservice and wire them together
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何分离微服务的组件并将它们连接起来
- en: In this chapter, we are going to address each of these challenges. First, you
    will be introduced to the key aspects of writing idiomatic and conventional Go
    code. You will learn important recommendations for writing and organizing your
    code base, as well as how to set up the proper code structure for your services.
    Then, we are going to introduce you to an example application, which will consist
    of three microservices that we are going to use throughout the book. In the following
    chapters, we will add additional features to these services, illustrating all
    the important areas of microservice development.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解决这些挑战中的每一个。首先，你将了解编写惯用和传统 Go 代码的关键方面。你将学习编写和组织代码库的重要建议，以及如何为你的服务设置适当的代码结构。然后，我们将向你介绍一个示例应用，它将包含三个微服务，我们将在整本书中使用这些微服务。在接下来的章节中，我们将向这些服务添加更多功能，展示微服务开发的所有重要领域。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Go basics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 基础
- en: Project structure
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目结构
- en: Scaffolding an example application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搭建示例应用
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you need to have Go 1.11 or above. If you don’t have
    Go installed, you can download it from the official website at [go.dev/dl](https://go.dev/dl).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，你需要安装 Go 1.11 或更高版本。如果你还没有安装 Go，你可以从官方网站 [go.dev/dl](https://go.dev/dl)
    下载。
- en: 'You can find the code examples for this chapter on GitHub: [https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter02](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter02).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码示例：[https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter02](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter02)。
- en: Go basics
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 基础
- en: Go is a great language for writing microservices. It is relatively easy to learn
    and has a pretty smooth learning curve, making onboarding new engineers easier.
    While you may have already had some experience with Go, one of the purposes of
    this book is to provide enough information to all types of developers—from beginners
    to highly experienced professionals.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是编写微服务的优秀语言。它相对容易学习，学习曲线平缓，使得新工程师的入职更加容易。虽然你可能已经对 Go 有了一些经验，但本书的一个目的就是为所有类型的开发者提供足够的信息——从初学者到经验丰富的专业人士。
- en: In this section, we are going to summarize important concepts of the language.
    If you already have experience with Go, you can still quickly scan through this
    part. It also includes some useful recommendations and best practices commonly
    missed even by experienced engineers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将总结语言的重要概念。如果你已经对 Go 有了一些经验，你仍然可以快速浏览这部分内容。它还包括一些有用的建议和最佳实践，即使是经验丰富的工程师也常常会忽略。
- en: Core principles
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心原则
- en: 'Before we proceed to look at the basics of Go, I’m going to share with you
    some fundamental principles that will help you make decisions when writing and
    organizing your code. These principles include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续探讨 Go 的基础知识之前，我将与你分享一些基本原理，这些原理将帮助你编写和组织代码时做出决策。这些原则包括以下内容：
- en: '*Always follow the official guidelines*. It is not uncommon for us engineers
    to have strong opinions about various styling and coding practices. However, in
    any developer community, consistency is more important than individual opinions.
    Make sure you get familiar with the most fundamental Go programming guidelines,
    written by the Go team:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*始终遵循官方指南*。我们工程师对各种风格和编码实践有强烈的意见并不罕见。然而，在任何开发者社区中，一致性比个人意见更重要。确保您熟悉Go团队编写的最基本Go编程指南：'
- en: '**Effective Go—an official set of guidelines for Go developers**: [https://go.dev/doc/effective_go](https://go.dev/doc/effective_go)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Effective Go——Go开发者的官方指南集**：[https://go.dev/doc/effective_go](https://go.dev/doc/effective_go)'
- en: '**Go code review comments**: Another useful source of information on Go development,
    covering various aspects, including code style, naming, and error handling: [https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Go代码审查评论**：Go开发的另一个有用信息来源，涵盖多个方面，包括代码风格、命名和错误处理：[https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)'
- en: '*Follow the style used in the standard library*. The standard Go library, which
    comes with any Go installation, is the best source of code examples and comments.
    Get familiar with some of the packages from the library, such as `context` and
    `net`. Following the coding style used in these packages will help you to write
    consistent, readable, and maintainable code, regardless of who will be using it
    later.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*遵循标准库中的风格*。任何Go安装都附带的标准Go库是代码示例和注释的最佳来源。熟悉一些库中的包，例如`context`和`net`。遵循这些包中使用的编码风格将帮助您编写一致、可读和可维护的代码，无论将来谁使用它。'
- en: '*Do not try to apply the ideas from other languages to Go*. Instead, understand
    the philosophy of Go and see the implementation of the most elegant Go packages—you
    can check the `net` package for some good examples: [https://pkg.go.dev/net](https://pkg.go.dev/net).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要试图将其他语言中的思想应用到Go中*。相反，理解Go的哲学，并查看最优雅的Go包的实现——您可以检查`net`包以获取一些好的示例：[https://pkg.go.dev/net](https://pkg.go.dev/net)。'
- en: Now, as we are aligned on the core principles, let’s move on to the key recommendations
    for writing conventional and idiomatic Go code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经明确了核心原则，让我们继续讨论编写传统和惯用Go代码的关键建议。
- en: Writing idiomatic Go code
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写惯用的Go代码
- en: This section summarizes the key topics described in the *Effective Go* document.
    Following the suggestions provided in this section will help you to keep your
    code consistent with the official guidelines.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本节总结了*Effective Go*文档中描述的关键主题。遵循本节中提供的建议将帮助您使代码与官方指南保持一致。
- en: Naming
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名
- en: 'Naming is one of the most important aspects of Go development. Writing Go code
    in an idiomatic way requires an understanding of its core naming principles:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 命名是Go开发最重要的方面之一。以惯用的方式编写Go代码需要理解其核心命名原则：
- en: Exported names start with an uppercase character.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出的名称以大写字母开头。
- en: When a variable, struct, or interface is imported from another package, its
    name includes a package name or alias, for example, `bytes.Buffer`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从另一个包导入变量、结构体或接口时，其名称包括包名或别名，例如`bytes.Buffer`。
- en: Since references include package names, you should not prefix your names with
    the package name. If the package name is `xml`, use the name `Reader`, not `XMLReader`—in
    the second case, the full name would be `xml.XMLReader`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于引用包括包名，因此您不应在您的名称前加上包名。如果包名是`xml`，则使用名称`Reader`，而不是`XMLReader`——在后一种情况下，完整名称将是`xml.XMLReader`。
- en: Packages are generally given lowercase, single-word names.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包通常使用小写、单词命名。
- en: It is not idiomatic to start the names of getters with the `Get` prefix. If
    your function returns the user’s age, call the function `Age()`, not `GetAge()`.
    Using the `Set` prefix, however, is fine; you can safely call your function `SetAge()`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`Get`前缀开始获取器的名称不是惯用的。如果您的函数返回用户的年龄，请将函数命名为`Age()`，而不是`GetAge()`。然而，使用`Set`前缀是可以的；您可以安全地调用您的函数`SetAge()`。
- en: Single-method interfaces are named using the method name plus an `er` suffix.
    For example, an interface with a `Write` function would be called `Writer`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单方法接口使用方法名加上`er`后缀命名。例如，具有`Write`函数的接口将被称为`Writer`。
- en: Initialisms and acronyms should have a consistent case. The correct versions
    would be `URL`, `url` and `ID`, include while `Url`, `Id` would be incorrect.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩写和首字母缩略词应保持一致的字母大小写。正确的版本将是`URL`、`url`和`ID`，而`Url`、`Id`将是错误的。
- en: Variable names should be short rather than long. In general, follow this simple
    rule—the closer to declaration a name is used, the shorter it should be. For iterating
    over an array, use *i* for the index variable.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名应该比长变量名更短。一般来说，遵循这个简单的规则——名称使用得越接近声明，它就越短。在遍历数组时，使用 *i* 作为索引变量。
- en: 'Additional naming recommendations include the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其他命名建议包括以下内容：
- en: The package name should be short, concise, and evocative and should provide
    context for its contents, for example, `json`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名应该简短、简洁、富有启发性，并且应该为其内容提供上下文，例如，`json`。
- en: Keep the contents of a package consistent with the name. If you start noticing
    that a package includes extra logic that has no relationship to the package name,
    consider exporting it to a separate one or using a more descriptive name.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持包的内容与名称一致。如果你开始注意到一个包包含与包名称无关的额外逻辑，考虑将其导出到单独的一个包或使用更具有描述性的名称。
- en: Use name abbreviations only if they are widely used (for example, `fmt` or `cmd`).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当它们被广泛使用时才使用名称缩写（例如，`fmt` 或 `cmd`）。
- en: Avoid name collisions, when possible. For example, if you introduce a set of
    string functions, avoid calling it `strings` package because a package with the
    same name exists in the Go standard library and is already widely used.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当可能时，避免名称冲突。例如，如果你引入了一组字符串函数，避免将其称为 `strings` 包，因为 Go 标准库中已经存在一个同名包并且已被广泛使用。
- en: Consider the client’s point of view when giving names to your code. Think about
    how the code is going to be used when giving a name to it, for example, the `Writer`
    interface for proving the write functionality.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给代码命名时，考虑客户端的视角。在给代码命名时，考虑代码将被如何使用，例如，用于提供写入功能的 `Writer` 接口。
- en: In addition to these rules, remember to keep the naming consistent across your
    code base. It will help make it easier to read and write new code—good names will
    act as examples for other engineers as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则之外，请记住在整个代码库中保持命名的一致性。这有助于使阅读和编写新代码变得更加容易——好的命名将作为其他工程师的示例。
- en: Comments
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'Comments are the next important aspect of Go development. Go comments can be
    used in two different ways:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是 Go 开发的下一个重要方面。Go 注释可以以两种不同的方式使用：
- en: Seeing the comments alongside the code
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码旁边查看注释
- en: Viewing the package documentation generated by the `godoc` tool
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 `godoc` 工具生成的包文档
- en: 'General principles for Go comments include the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Go 代码注释的一般原则包括以下内容：
- en: Every package should have a comment describing its contents.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个包都应该有一个描述其内容的注释。
- en: Every exported name in Go should have a comment.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 中每个导出的名称都应该有注释。
- en: Comments should be complete sentences and end with a period.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释应该是完整的句子，并以句号结尾。
- en: 'The first sentence of the comment should start with the name being exported
    and provide a summary of it, as in the following example:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释的第一句话应该以导出的名称开头，并提供其摘要，如下例所示：
- en: '[PRE0]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Go standard library provides many good examples of code comments, so I always
    suggest getting familiar with some examples from it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库提供了许多优秀的代码注释示例，所以我总是建议熟悉其中的一些示例。
- en: Errors
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误
- en: 'General recommendations for Go errors include the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Go 错误的一般建议包括以下内容：
- en: Only use panics in truly exceptional cases.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只在真正异常的情况下使用 panic。
- en: Always handle each error; don’t discard errors by using `_` assignment.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是处理每个错误；不要通过使用 `_` 赋值来丢弃错误。
- en: Error strings should start with a lowercase character, unless they begin with
    names requiring capitalization, such as acronyms.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误字符串应以小写字母开头，除非它们以需要大写的名称开头，例如首字母缩略词。
- en: 'Error strings, unlike comments, should not end with punctuation marks, as in
    the following example:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误字符串，与注释不同，不应以标点符号结尾，如下例所示：
- en: '[PRE2]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When calling a function returning an error, always handle the error first.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用返回错误的函数时，始终先处理错误。
- en: 'Wrap errors if you want to add additional information to the clause. The conventional
    way of wrapping errors in Go is to use `%w` at the end of the formatted error:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果想为条款添加附加信息，请包装错误。Go 中包装错误的传统方法是在格式化错误末尾使用 `%w`：
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While checking for errors, using the `==` operator may result in improper handling
    of the wrapped errors. There are two solutions to this. For a comparison to a
    sentinel error, such as `errors.New("some error")`, use `errors.Is`:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检查错误时，使用 `==` 操作符可能会导致对包装错误的处理不当。有两个解决方案。对于与哨兵错误（例如 `errors.New("some error")`）的比较，使用
    `errors.Is`：
- en: '[PRE7]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For error types, use `errors.As`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误类型，使用 `errors.As`：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Additionally, keep errors descriptive yet compact. It should be always easy
    to understand what exactly went wrong by reading the error message.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，保持错误描述性且简洁。应该总是通过阅读错误消息就能轻松理解到底出了什么问题。
- en: Interfaces
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'Key principles of Go **interfaces** include the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Go **接口**的关键原则包括以下内容：
- en: Do not define interfaces before they are used without a realistic example of
    usage.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有实际使用示例的情况下，不要在它们被使用之前定义接口。
- en: Return concrete (using a pointer or struct) types instead of an interface in
    your functions.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的函数中，返回具体的（使用指针或结构体）类型而不是接口。
- en: Single-method interfaces should be called by the method name and include the
    `er` suffix, for example, the `Writer` interface with a `Write` function.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单方法接口应该通过方法名调用，并包含`er`后缀，例如，具有`Write`函数的`Writer`接口。
- en: See some built-in interfaces, such as `Writer` and `Reader`, to get a good example
    of defining and using interfaces in Go.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 看一些内置接口，例如`Writer`和`Reader`，以获取在Go中定义和使用接口的好例子。
- en: Tests
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'We are going to cover testing in detail in [*Chapter 8*](B18865_08.xhtml#_idTextAnchor109)
    of this book. Let’s provide here some key suggestions for writing Go tests in
    an idiomatic way:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的[*第8章*](B18865_08.xhtml#_idTextAnchor109)中详细讨论测试。让我们在这里提供一些关于以惯用方式编写Go测试的关键建议：
- en: Tests should always provide information to the user on what exactly went wrong
    in case of a failure.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应该在失败的情况下向用户提供有关到底出了什么问题的信息。
- en: 'Consider writing table-driven tests whenever possible. See this example: [https://github.com/golang/go/blob/master/src/fmt/errors_test.go](https://github.com/golang/go/blob/master/src/fmt/errors_test.go).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，考虑编写表驱动测试。参见这个例子：[https://github.com/golang/go/blob/master/src/fmt/errors_test.go](https://github.com/golang/go/blob/master/src/fmt/errors_test.go)。
- en: Generally, we should only test public functions. Your private function should
    be indirectly tested through them.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，我们只应该测试公共函数。你的私有函数应该通过它们间接测试。
- en: Make sure you always write tests for your code. Not only does this help with
    finding bugs earlier but it also helps to see how your code can be used. I personally
    find the latter especially useful.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你总是为你的代码编写测试。这不仅有助于尽早发现错误，还有助于了解你的代码如何被使用。我个人发现后者特别有用。
- en: Context
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: One of the key differences between the Go language and other popular languages
    is explicit context propagation. **Context propagation** is a mechanism of propagating
    an additional call argument, called **context**, into function calls, passing
    additional metadata.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言与其他流行语言之间的一个关键区别是显式上下文传播。**上下文传播**是一种将额外的调用参数，称为**上下文**，传播到函数调用中的机制，传递额外的元数据。
- en: 'Go context has a type called `context.Context`. There are multiple ways of
    using it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Go上下文有一个名为`context.Context`的类型。有多种使用它的方法：
- en: '**Cancelation logic**: You can pass a special instance of a context that can
    get *canceled*. In that case, all functions you were to call with it would be
    able to detect this. Such logic can be useful for handling application shutdown
    or stopping any processing.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消逻辑**：你可以传递一个特殊的上下文实例，它可以被*取消*。在这种情况下，所有你打算用这个上下文调用的函数都能够检测到这一点。这种逻辑对于处理应用程序关闭或停止任何处理非常有用。'
- en: '**Timeouts**: You can set the timeouts for your execution by using the corresponding
    context functions.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**：你可以通过使用相应的上下文函数来设置你的执行超时。'
- en: '**Propagating extra metadata**: You can propagate additional key-value metadata
    inside the context. This way, any downstream functions called would receive that
    metadata inside the context object. There are some useful applications of this
    approach, one of which is distributed tracing, which we are going to cover in
    the following chapters.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传播额外元数据**：你可以在上下文中传播额外的键值元数据。这样，任何后续调用的函数都会在上下文对象中接收到这些元数据。这种方法有一些有用的应用，其中之一是分布式跟踪，我们将在接下来的章节中介绍。'
- en: 'We will get back to context propagation in the following chapters. Now, we
    can define some important aspects of using context in Go:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中回到上下文传播。现在，我们可以定义一些使用Go上下文的重要方面：
- en: Context is immutable but can be cloned with extra metadata.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文是不可变的，但可以通过额外的元数据进行克隆。
- en: Functions using context should accept it as their first argument.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文的函数应该将其作为第一个参数接受。
- en: 'Additionally, some context best practices are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是一些上下文最佳实践：
- en: Always pass context to functions performing I/O calls.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是传递上下文给执行I/O调用的函数。
- en: Limit the usage of context for passing any metadata. You should use metadata
    propagation for truly exceptional cases, such as distributed tracing, mentioned
    earlier.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制上下文的使用，以传递任何元数据。你应该仅在真正特殊的情况下使用元数据传播，例如前面提到的分布式跟踪。
- en: Do not attach context to structures.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将上下文附加到结构中。
- en: Now, as we have discussed the key recommendations for writing idiomatic Go code,
    we can move on to the next section, which is going to cover the project structure
    recommendations and standards for Go applications.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经讨论了编写惯用 Go 代码的关键建议，我们可以继续到下一节，该节将涵盖项目结构建议和 Go 应用的标准。
- en: Project structure
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: The project structure is the foundation of and plays a major role in the readability
    and maintainability of your code. As we discussed in the previous sections, in
    Go projects, the structure may play a more important role than in other languages,
    because each exported name generally includes the name of its package. This requires
    you to have good and descriptive naming for your packages and directories, as
    well as the right hierarchy of your code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构是代码可读性和可维护性的基础，并在其中发挥着重要作用。正如我们在前面的章节中讨论的，在 Go 项目中，结构可能比其他语言更重要，因为每个导出的名称通常包括其包的名称。这要求你为你的包和目录提供良好且描述性的命名，以及正确的代码层次结构。
- en: While the official guidelines define some strong recommendations for naming
    and coding styles there aren’t that many rules constraining the Go project structure.
    Each project is unique by its nature, and developers are generally free to choose
    the way they organize the code. However, there are some common practices and specifics
    of Go package organization that we are going to cover in this section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然官方指南定义了一些关于命名和编码风格的强烈建议，但约束 Go 项目结构的规则并不多。每个项目在本质上都是独特的，开发者通常可以自由选择他们组织代码的方式。然而，在本节中，我们将介绍一些常见的
    Go 包组织实践和具体细节。
- en: Private packages
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有包
- en: 'In Go, all code stored inside a directory called `internal` can be imported
    and used only by packages stored within the same directory or one of the directories
    it includes. Putting code into an internal directory can ensure your code is not
    exported and used by external packages. This can be useful for the following different
    cases:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，存储在名为 `internal` 的目录中的所有代码只能由存储在同一目录或其包含的目录中的包导入和使用。将代码放入内部目录可以确保你的代码不会被导出并由外部包使用。这可以在以下不同情况下很有用：
- en: Hide the details of the implementation from the user if some of the types of
    functions need to be exported.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果某些类型或函数需要导出，则隐藏实现细节以供用户查看。
- en: Ensure no external package relies on your types and functions, which you don’t
    want to expose widely.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保没有外部包依赖于你不想广泛暴露的类型和函数。
- en: Remove possible unnecessary dependencies between the packages.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除包之间可能的不必要依赖。
- en: Avoid extra refactoring and maintenance difficulties if your code is unexpectedly
    used by other developers/teams.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的代码意外地被其他开发者/团队使用，避免额外的重构和维护困难。
- en: I have found it useful to use internal packages as a protection against unwanted
    dependencies. This plays a big role in large repositories and applications, where
    there is a high possibility of unexpected dependencies between the packages. Large
    code bases that don’t have a separation between private and public packages often
    suffer from an effect called *spaghettification*—when packages depend on each
    other in an uncontrolled and chaotic way.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现使用内部包作为防止不受欢迎的依赖很有用。这在大型存储库和应用中起着重要作用，在这些应用中，包之间意外依赖的可能性很高。没有在私有和公共包之间进行分离的大型代码库通常会受到一种称为
    *spaghettification* 的影响——当包以不受控制和混乱的方式相互依赖时。
- en: Public packages
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共包
- en: There is another type of directory name with a semantic meaning in Go—a directory
    called `pkg`. It implies that it is OK to use the code from this package externally.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，还有一种具有语义意义的目录名称——名为 `pkg` 的目录。它意味着可以使用此包中的代码。
- en: The `pkg` directory isn’t recommended officially, but it is widely used. Ironically,
    the Go team used this in the library code and then got rid of this pattern, while
    the rest of the Go community adopted it so widely that it became a common practice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 官方并不推荐使用 `pkg` 目录，但它被广泛使用。具有讽刺意味的是，Go 团队在库代码中使用了这个模式，然后又放弃了它，而 Go 社区的其他部分广泛采用了它，以至于它成为了一种常见做法。
- en: It is up to you whether you use a `pkg` directory in your applications. But
    in tandem with the internal directory, it can help to organize your code so that
    what is private and what is public is clear, easing the code navigation for the
    developers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 是否在你的应用程序中使用`pkg`目录取决于你。但与内部目录结合使用，可以帮助你组织代码，使私有和公共部分清晰，便于开发者进行代码导航。
- en: Executable packages
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可执行包
- en: 'The `cmd` package is commonly used in the Go community to store the code of
    one or multiple executable packages with a `main` function. This may include the
    code starting your application or any code for your executable tools. For a single-app
    directory, you can store your Go code directly in the `cmd` package:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd`包在Go社区中常用，用于存储一个或多个具有`main`函数的可执行包的代码。这可能包括启动应用程序的代码或任何可执行工具的代码。对于单应用程序目录，你可以直接在`cmd`包中存储你的Go代码：'
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For a multi-app directory, you can include subpackages in `cmd` packages:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多应用程序目录，你可以在`cmd`包中包含子包：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Other commonly used directories
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他常用目录
- en: 'The following list includes some other commonly used directory or package names
    in the Go community:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包括Go社区中一些其他常用的目录或包名称：
- en: '`api`: JSON schema files and definitions in various protocols, including gRPC.
    We are going to cover these topics in [*Chapter 4*](B18865_04.xhtml#_idTextAnchor067).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`: 包含JSON模式文件和各种协议（包括gRPC）的定义。我们将在[*第4章*](B18865_04.xhtml#_idTextAnchor067)中介绍这些主题。'
- en: '`testdata`: Files containing the data used in tests.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testdata`: 包含测试中使用的数据的文件。'
- en: '`web`: Web application components and assets.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web`: 网络应用程序组件和资产。'
- en: Common files
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见文件
- en: 'Here is a list of common filenames, which will keep your packages consistent
    with the official library and lots of third-party libraries:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一份常见文件名的列表，这将使你的包与官方库和许多第三方库保持一致：
- en: '`main.go`: A file containing the `main()` function'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.go`: 包含`main()`函数的文件'
- en: '`doc.go`: Package documentation (a separate file is not necessary for small
    packages)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc.go`: 包文档（对于小型包，不需要单独的文件）'
- en: '`*_test.go`: Test files'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*_test.go`: 测试文件'
- en: '`README.md`: A read-me file written in the Markdown language'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`: 用Markdown语言编写的自述文件'
- en: '`LICENSE`: A license file, if there is one'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LICENSE`: 如果有的话，许可证文件'
- en: '`CONTRIBUTING.md`/CONTRIBUTORS/AUTHORS: List of contributors and/or authors'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONTRIBUTING.md`/`CONTRIBUTORS/AUTHORS`: 贡献者列表和/或作者列表'
- en: Now, let’s cover the best practices for organizing the code base for Go applications.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨组织Go应用程序代码库的最佳实践。
- en: Best practices
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'In this section, you can find a list of best practices for organizing the Go
    application project structure. It is going to help you to keep your code aligned
    with thousands of other Go packages and keep it conventional and idiomatic. The
    best practices of Go project organization include the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你可以找到组织Go应用程序项目结构的最佳实践列表。这将帮助你使你的代码与成千上万的Go包保持一致，并使其符合传统和习惯用法。Go项目组织的最佳实践包括以下内容：
- en: Separate private code using an internal directory.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内部目录分离私有代码。
- en: Get familiar with the way popular open source Go projects, such as [https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes),
    are organized. This can provide you with great examples of how to structure your
    repository.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉流行的开源Go项目（如[https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes)）的组织方式。这可以为你提供如何结构化你的存储库的绝佳示例。
- en: Split in a sufficiently granular way. Don’t split the packages too early but
    also avoid having a lot of logic in a single package. Generally, you will find
    that the easier it is to give a short and specific self-descriptive name to a
    package, the better your code composition is.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以足够细粒度的方式进行拆分。不要过早地拆分包，但也避免在单个包中有太多逻辑。通常，你会发现，给包起一个简短且具体的自我描述性名称越容易，你的代码结构就越好。
- en: Avoid long package names.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用过长的包名。
- en: Always be ready to change the structure if requirements are changed or if the
    structure no longer reflects the package name/original intent.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需求发生变化或结构不再反映包名/原始意图，请随时准备更改结构。
- en: This sums up the part of the chapter describing the core principles and best
    practices of Go application development and code organization. Now, we are ready
    to get to the practical side of this chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了本章描述Go应用程序开发和代码组织的核心原则和最佳实践的章节。现在，我们准备进入本章的实际部分。
- en: Scaffolding an example application
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搭建示例应用程序
- en: We have covered the general recommendations for writing and organizing Go applications
    and we are finally ready to start writing the code! In this section, we are going
    to introduce an application, consisting of multiple microservices that are going
    to be used throughout the book. In each chapter, we are going to add to or improve
    them, converting them from small examples into production-grade services that
    are ready to be used.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了编写和组织 Go 应用程序的一般建议，我们终于准备好开始编写代码了！在本节中，我们将介绍一个应用程序，它由多个将在整本书中使用的微服务组成。在每一章中，我们将对其进行添加或改进，将它们从小型示例转换为可用于生产的级别服务。
- en: You will learn how to scaffold microservice code and split the code into separate
    logical parts, each having its own role. We are going to apply the project structure
    and Go knowledge you gained in this chapter to illustrate how to set the right
    structure for each service and write its code in a conventional and idiomatic
    way.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何构建微服务代码并将代码拆分为独立的逻辑部分，每个部分都有自己的角色。我们将应用在本章中获得的项目的结构和 Go 知识，以说明如何为每个服务设置正确的结构并以传统和惯用的方式编写其代码。
- en: Movie application
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电影应用程序
- en: 'Let’s imagine we are building an application for movie lovers. The application
    would provide the following features:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们正在为电影爱好者构建一个应用程序。该应用程序将提供以下功能：
- en: Get the movie metadata (such as title, year, description, and director) and
    the aggregated movie rating
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取电影元数据（如标题、年份、描述和导演）以及聚合的电影评分
- en: Rate a movie
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分电影
- en: All the listed features seem to be closely related. However, let’s take a closer
    look at them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所列出的功能似乎都密切相关。然而，让我们更仔细地看看它们。
- en: Movie metadata
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电影元数据
- en: 'Let’s assume we have the metadata for a collection of movies, which includes
    the following fields:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一组电影的元数据，包括以下字段：
- en: ID
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID
- en: Title
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题
- en: Year
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年份
- en: Description
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述
- en: Director
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导演
- en: List of actors
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员名单
- en: Such information about movies doesn’t generally change unless somebody wants
    to update the description, but for simplicity, we may assume that we are dealing
    with a static dataset. We would retrieve the records based on their IDs, so we
    could use any key-value or document database to store and access the metadata.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于电影的信息通常不会改变，除非有人想要更新描述，但为了简单起见，我们可以假设我们正在处理一个静态数据集。我们将根据它们的 ID 检索记录，因此我们可以使用任何键值或文档数据库来存储和访问元数据。
- en: Ratings
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评分
- en: Let’s now review the functionality required for storing and retrieving movie
    ratings.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾存储和检索电影评分所需的功能。
- en: 'Generally, we would need to perform the following rating operations:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要执行以下评分操作：
- en: Store a movie rating
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储电影评分
- en: Get the aggregated movie rating
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取聚合的电影评分
- en: Later, we would also need to support rating deletion, but for now, we can just
    keep this logic in mind while designing the application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们还需要支持评分删除，但就目前而言，我们可以在设计应用程序时记住这个逻辑。
- en: The ratings data is quite different from the movie metadata—we can both append
    and delete the records. In addition to this, we need to return the aggregated
    rating, so we should either be able to return all stored ratings for an item and
    perform the aggregation on the go or have separate logic for performing and storing
    the aggregations. You will notice that the ways we access ratings and movie metadata
    are different. This hints that the ratings data can, and probably should, be stored
    separately from the movie metadata.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 评分数据与电影元数据相当不同——我们都可以添加和删除记录。除此之外，我们还需要返回聚合评分，因此我们或者能够返回一个项目的所有存储评分并在运行时进行聚合，或者有单独的逻辑来执行和存储聚合。你会注意到我们访问评分和电影元数据的方式不同。这暗示着评分数据可以，并且可能应该，与电影元数据分开存储。
- en: While designing the application, it is beneficial to think one step ahead and
    imagine how the application may evolve in the future. This does not mean that
    you should necessarily build the application trying to predict future use cases,
    because it can lead to unnecessary abstractions that may not be needed later if
    your plans change. However, thinking one step ahead may save you time later if
    you find more efficient ways of modeling and storing your data, which would help
    you to adapt to changing requirements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序时，提前思考并想象应用程序可能如何发展是有益的。这并不意味着你应该试图预测未来的用例来构建应用程序，因为这可能导致不必要的抽象，如果计划改变，可能后来不再需要。然而，提前思考可能会在找到更有效的方式建模和存储数据时节省你时间，这有助于你适应不断变化的需求。
- en: 'Let’s see how the rating service can possibly evolve. At some point, we may
    want to extend the rating functionality to other types of movie-related records.
    A user may be able to do the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看评分服务可能如何演变。在某个时候，我们可能希望将评分功能扩展到其他类型的电影相关记录。用户可能能够执行以下操作：
- en: Rate the actor’s performance in some movies
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分某些电影中的演员表现
- en: Rate the movie soundtrack
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分电影原声带
- en: Rate the movie’s costume design
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分电影的服装设计
- en: When making decisions on supporting future use cases, you should ask yourself,
    how likely it is that I will need to implement that logic in the observable future
    (6 to 12 months)? You should generally avoid thinking much further ahead because
    the requirements and goals may change. However, if you are quite certain you have
    plans to support particular features, you should make sure your data model can
    support those features without major changes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出支持未来用例的决定时，你应该问自己，在可观察的未来（6到12个月）内，我需要实现该逻辑的可能性有多大？你应该通常避免过多地展望未来，因为需求和目标可能会改变。然而，如果你非常确定你有计划支持特定的功能，你应该确保你的数据模型可以在不进行重大更改的情况下支持这些功能。
- en: Let’s assume we definitely want to implement the additional ratings mentioned
    earlier. In this case, we want to make sure we can design our application in a
    way that would support the ratings for different types of objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们确实想实现之前提到的附加评分。在这种情况下，我们想确保我们可以以支持不同类型对象评分的方式设计我们的应用程序。
- en: 'Let’s define the API for such a rating component:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义这样一个评分组件的API：
- en: 'Store the rating record, including the following:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储评分记录，包括以下内容：
- en: ID of the user who gave the rating
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给出评分的用户ID
- en: Type of record
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录类型
- en: ID of the record
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录ID
- en: Rating value
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分值
- en: Get the aggregated rating for a record by its ID and type.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过记录ID和类型获取聚合评分。
- en: This API supports record types, so we can easily add more types of ratings without
    changing the system. The trade-off we made here is quite reasonable—the API is
    different on the basis of just one field (record type) from the API of a rating
    system designed just for movies. However, this gives us complete freedom in introducing
    new rating types in the future! Such a trade-off seems very reasonable given that
    we have decided we will certainly need those ratings in the future.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此API支持记录类型，因此我们可以轻松地添加更多类型的评分，而无需更改系统。我们在这里做出的权衡是相当合理的——基于仅一个字段（记录类型）的API与仅针对电影设计的评分系统的API不同。然而，这给了我们在未来引入新的评分类型时完全的自由！鉴于我们决定我们肯定需要在未来需要那些评分，这种权衡似乎是合理的。
- en: Should we split the application?
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们应该拆分应用程序吗？
- en: 'Let’s provide a summary of the two parts of the application we have just described:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们刚刚描述的应用程序的两个部分：
- en: 'Movie metadata:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影元数据：
- en: Retrieve the metadata for a movie by its ID.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过电影ID检索电影元数据。
- en: 'Ratings:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分：
- en: Store a rating for a record.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为记录存储一个评分。
- en: Retrieve an aggregated rating for a record.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过记录ID检索聚合评分。
- en: After we abstracted the rating component by letting it support various record
    types, it stopped being a movie rating component and became a more generic record
    rating system. The movie metadata component is now loosely coupled to the rating
    system—the rating system can store the ratings for movies as well as for any other
    possible types of records.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过使其支持各种记录类型来抽象评分组件之后，它就不再是电影评分组件，而变成了一个更通用的记录评分系统。电影元数据组件现在与评分系统松散耦合——评分系统可以存储电影的评分，以及任何其他可能的记录类型。
- en: As we discussed previously, the data models for both components are also quite
    different. The movie metadata component stores static data, which is going to
    be retrieved by ID, while the rating component stores dynamic data, which requires
    aggregation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，这两个组件的数据模型也相当不同。电影元数据组件存储静态数据，这些数据将通过ID检索，而评分组件存储动态数据，需要聚合。
- en: 'Both components seem to be relatively independent of each other. This is a
    perfect example of a situation where we may benefit from splitting the application
    into separate services:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件似乎相对独立。这是一个我们可能从将应用程序拆分为独立服务中受益的完美例子：
- en: Logic is loosely coupled
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑是松散耦合的
- en: Data models are different
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据模型不同
- en: Data is generally independent
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据通常是独立的
- en: This list is not complete, and you need to consider all the aspects described
    in [*Chapter 1*](B18865_01.xhtml#_idTextAnchor015), to make a decision on splitting
    the application. However, since this book covers microservice development, let’s
    make our decision here and decide to split the system into separate services.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表并不完整，您需要考虑在[*第一章*](B18865_01.xhtml#_idTextAnchor015)中描述的所有方面，以做出关于拆分应用程序的决定。然而，由于本书涵盖了微服务开发，让我们在这里做出决定，并决定将系统拆分为单独的服务。
- en: 'Let’s list the services we would split the application into:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出我们将拆分应用程序的服务：
- en: '**Movie metadata service**: Store and retrieve the movie metadata records by
    movie IDs.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电影元数据服务**：通过电影ID存储和检索电影元数据记录。'
- en: '**Rating service**: Store ratings for different types of records and retrieve
    aggregated ratings for records.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评分服务**：存储不同类型记录的评分并检索记录的聚合评分。'
- en: '**Movie service**: Provide complete information to the callers about a movie
    or a set of movies, including the movie metadata and its rating.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电影服务**：向调用者提供关于电影或一组电影的完整信息，包括电影元数据和其评分。'
- en: 'Why did we end up with three services here? We did this for the following reasons:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们最终有了三个服务？我们这样做有以下原因：
- en: The movie metadata service would be solely responsible for accessing the movie
    metadata records.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影元数据服务将仅负责访问电影元数据记录。
- en: The movie service would provide the client-facing API, aggregating two separate
    types of records—movie metadata and ratings. The records would be stored in two
    separate systems, so this component would join them together and return to the
    caller.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影服务将提供面向客户端的API，聚合两种不同的记录类型——电影元数据和评分。这些记录将存储在两个不同的系统中，因此该组件将它们连接起来并返回给调用者。
- en: If we introduce any other types of records in the system, such as likes, reviews,
    and recommendations, we will plug them into the movie service, not the movie metadata
    service. The movie metadata service would be used solely for accessing the static
    movie metadata, not any other types of records.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在系统中引入任何其他类型的记录，例如点赞、评论和推荐，我们将把它们连接到电影服务，而不是电影元数据服务。电影元数据服务将仅用于访问静态电影元数据，而不是任何其他类型的记录。
- en: Movie metadata services can potentially evolve in the future by getting more
    metadata-related functionality, such as editing or adding descriptions in different
    languages. This also hints that it is better to keep this component solely for
    the metadata-related features.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影元数据服务可能在未来通过获取更多与元数据相关的功能而演变，例如编辑或添加不同语言的描述。这也暗示了最好将此组件仅用于与元数据相关的功能。
- en: 'Let’s illustrate these services in a diagram:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用图表来展示这些服务：
- en: '![Figure 2.1 – Movie application services'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.1 – Movie application services](img/Figure_2.1_B18865.jpg)'
- en: '](img/Figure_2.1_B18865.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.1 – Movie application services](img/Figure_2.1_B18865.jpg)'
- en: Figure 2.1 – Movie application services
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 电影应用程序服务
- en: Now, as we have definitions of the three microservices, let’s finally proceed
    to the coding part.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经定义了三个微服务，让我们最终进入编码部分。
- en: Application code structure
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序代码结构
- en: 'Let’s align on how are we going to structure the code of all microservices
    in relation to each other. I would suggest storing them inside a single directory,
    which would be our application root. Create a new directory (you may call it `movieapp`),
    and inside it, create the following directories for our microservices:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确定我们将如何结构化所有微服务的代码，以便相互关联。我建议将它们存储在单个目录中，这将是我们应用程序的根目录。创建一个新的目录（您可以称其为`movieapp`），并在其中为我们的微服务创建以下目录：
- en: '`rating`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rating`'
- en: '`metadata`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`'
- en: '`movie`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movie`'
- en: Throughout the book, I will use the directory paths relative to the application
    directory you’ve created, so when you see a directory or filename, assume it is
    stored in the app directory you chose for this.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将使用相对于您创建的应用程序目录的目录路径，因此当您看到目录或文件名时，请假设它存储在您为此次选择的应用目录中。
- en: From the *Project structure* section, we know that the logic containing the
    `main` function generally resides in the `cmd` directory. We will use this approach
    in our microservices—for example, the main file for the rating service would be
    called `rating/cmd/main.go`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从*项目结构*部分，我们知道包含`main`函数的逻辑通常位于`cmd`目录中。我们将在我们的微服务中使用这种方法——例如，评分服务的主文件将被称为`rating/cmd/main.go`。
- en: 'Each service may contain one or multiple packages related to the following
    logical roles:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务可能包含一个或多个与以下逻辑角色相关的包：
- en: API handlers
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API处理器
- en: Business/application logic
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务/应用程序逻辑
- en: Database logic
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库逻辑
- en: Interaction with other services
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他服务的交互
- en: Note that handler and business/application logic are separate, even though the
    primary purpose of the application may be to handle the API requests. This is
    not absolutely necessary, but it’s a relatively good practice to separate the
    business logic from the API handling layer. This way, if you migrate from one
    type of API to another (for example, from HTTP to gRPC), or support both, you
    don’t need to implement the same logic twice or rewrite it. Instead, you would
    just call the business logic from your handler, keeping the handler as simple
    as possible and making its primary purpose to pass the requests to the relevant
    interfaces.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管应用程序的主要目的是处理 API 请求，但处理器和业务/应用程序逻辑是分开的。这并不是绝对必要的，但将业务逻辑与 API 处理层分开是一种相对良好的实践。这样，如果你从一种类型的
    API 迁移到另一种类型（例如，从 HTTP 到 gRPC），或者同时支持两种类型，你不需要两次实现相同的逻辑或重写它。相反，你只需从你的处理器调用业务逻辑，使处理器尽可能简单，并使其主要目的是将请求传递到相关的接口。
- en: 'We can illustrate this relationship with the help of a diagram:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一张图来展示这种关系：
- en: '![Figure 2.2 – Layers of a service'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.2 – 服务层](img/Figure_2.2_B18865.jpg)'
- en: '](img/Figure_2.2_B18865.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.2 – 服务层](img/Figure_2.2_B18865.jpg)'
- en: Figure 2.2 – Layers of a service
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.2 – 服务层
- en: As you can see in the diagram, the API handler does not access the database
    directly. Instead, the database access is performed on a business logic layer.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图中看到的，API 处理器不直接访问数据库。相反，数据库访问是在业务逻辑层完成的。
- en: There is no convention in the Go community on how to call packages serving these
    purposes, so we are free to choose the names for our packages providing such logic.
    It is, however, important that you keep these names consistent across all your
    microservices, so let’s align on a common naming convention for these types of
    packages.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 社区中，关于如何命名服务于这些目的的包没有约定，因此我们可以自由选择我们包的名称。然而，保持这些名称在所有微服务中的一致性是很重要的，所以让我们为这些类型的包达成一个共同的命名约定。
- en: 'In this book, we are going to use the following names for our application components:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用以下名称来命名我们的应用程序组件：
- en: '**controller**: Business logic'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**controller**：业务逻辑'
- en: '**gateway**: Logic for interacting with other services'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gateway**：与其他服务交互的逻辑'
- en: '**handler**: API handlers'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**handler**：API 处理器'
- en: '**repository**: Database logic'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**repository**：数据库逻辑'
- en: 'Now, since we are aligned on the naming, let’s proceed to the last step of
    setting up our project. Execute this command in the application root directory:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们已经达成了命名上的共识，让我们继续进行设置项目的最后一步。在应用程序根目录中执行以下命令：
- en: '[PRE13]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command creates a Go module called `movieexample.com`. A Go module is a
    collection of related packages stored in a file tree. They help manage dependencies
    for your project, and we are going to use this feature in all the chapters.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建了一个名为 `movieexample.com` 的 Go 模块。Go 模块是一组相关包的集合，存储在文件树中。它们帮助管理项目的依赖关系，我们将在所有章节中使用这个特性。
- en: Now, we can proceed to code scaffolding for our first microservice.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续为我们的第一个微服务进行代码脚手架搭建。
- en: Movie metadata service
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电影元数据服务
- en: 'Let’s summarize the logic of the movie metadata service:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下电影元数据服务的逻辑：
- en: '**API**: Get metadata for a movie'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API**：获取电影的元数据'
- en: '**Database**: Movie metadata database'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：电影元数据数据库'
- en: '**Interacts with services**: None'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与服务交互**：无'
- en: '**Data model type**: Movie metadata'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据模型类型**：电影元数据'
- en: 'This logic would translate into the following packages:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑可以转化为以下包：
- en: '`cmd`: Contains the main function for starting the service'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd`：包含启动服务的 main 函数'
- en: '`controller`: Our service logic (read the movie metadata)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller`：我们的服务逻辑（读取电影元数据）'
- en: '`handler`: API handler for a service'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler`：服务的 API 处理器'
- en: '`repository`: Logic for accessing the movie metadata database'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repository`：访问电影元数据数据库的逻辑'
- en: Let’s store the logic of our service in a directory called `metadata`. Following
    the conventions we described earlier in the chapter, the executable code containing
    the main file is going to be stored in the `cmd` package. All code that we are
    not going to export will be stored in the `internal` directory and this will include
    most of our applications. The exported structures will reside in the `pkg` directory.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们服务的逻辑存储在一个名为 `metadata` 的目录中。根据我们在本章中之前描述的约定，包含主文件的可执行代码将存储在 `cmd` 包中。我们不会导出的所有代码将存储在
    `internal` 目录中，这包括我们的大部分应用程序。导出的结构将位于 `pkg` 目录中。
- en: 'Applying the rules that we just described, we are going to structure our packages
    in the following way:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们刚才描述的规则，我们将以以下方式组织我们的包：
- en: '`metadata/cmd`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata/cmd`'
- en: '`metadata/internal/controller`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata/internal/controller`'
- en: '`metadata/internal/handler`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata/internal/handler`'
- en: '`metadata/internal/repository`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata/internal/repository`'
- en: '`metadata/pkg`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata/pkg`'
- en: Once you have created the directories listed here, let’s proceed to implement
    the code for our microservice.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了这里列出的目录，让我们继续为我们的微服务实现代码。
- en: Model
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: 'First, we are going to implement the structure for the movie metadata. Inside
    the `metadata/pkg` directory, create a `metadata.go` file using the following
    code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现电影元数据的结构。在`metadata/pkg`目录内，创建一个`metadata.go`文件，使用以下代码：
- en: '[PRE14]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This structure is going to be used by the callers of our service. It includes
    JSON annotations, which we are going to use later in this chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构将被我们的服务调用者使用。它包括JSON注解，我们将在本章后面使用。
- en: Repository
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仓库
- en: 'Now, let’s create the stub logic for handling the database logic. Inside the
    `metadata/internal/repository` directory, add an `error.go` file using the following
    code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为处理数据库逻辑创建一个存根逻辑。在`metadata/internal/repository`目录内，添加一个`error.go`文件，使用以下代码：
- en: '[PRE15]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This file defines an error for the case when the record is not found. We are
    going to use this error in our implementation.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件定义了当记录未找到时的错误。我们将在我们的实现中使用这个错误。
- en: In the next step, we are going to add the repository implementation. Even if
    you have some specific technology to work with for storing the data, it is often
    useful to provide more than one implementation of the database logic. I always
    find it useful to include an in-memory implementation of the database logic that
    can be used for testing and local development, reducing the need for any additional
    databases or extra libraries. I am going to illustrate how to do this.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将添加仓库实现。即使你有特定的技术来存储数据，通常提供多个数据库逻辑实现也是有用的。我发现包括一个内存中的数据库逻辑实现非常有用，它可以用于测试和本地开发，减少对任何额外数据库或额外库的需求。我将展示如何做到这一点。
- en: 'Inside the `metadata/internal/repository` directory, create a directory called
    `memory` that will contain the in-memory implementation or our movie metadata
    database. Add a `memory.go` file to it, using the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在`metadata/internal/repository`目录内，创建一个名为`memory`的目录，它将包含内存中的实现或我们的电影元数据库。向其中添加一个`memory.go`文件，使用以下代码：
- en: '[PRE16]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s highlight some aspects of the code we’ve just added:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们强调一下我们刚刚添加的代码的一些方面：
- en: First, we called the `Repository` structure because it provides a good name
    to the users when combined with the name of its package— `memory.Repository`.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们调用`Repository`结构，因为它与它的包名结合提供了一个对用户来说很好的名字——`memory.Repository`。
- en: Second, we used the exported `ErrNotFound` that we previously defined, so callers
    can check their code. It is usually good practice to do so because it allows the
    developers to check for a specific error in their code. We will illustrate how
    to write tests for it in [*Chapter 8*](B18865_08.xhtml#_idTextAnchor109).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，我们使用了之前定义的导出`ErrNotFound`，这样调用者就可以检查他们的代码。通常这是一个好的实践，因为它允许开发者检查他们代码中的特定错误。我们将在[*第8章*](B18865_08.xhtml#_idTextAnchor109)中展示如何为它编写测试。
- en: Additionally, the function creating the repository is called `New`. This is
    often a good name for short packages when there is just one type being created.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，创建仓库的函数被命名为`New`。当只有一个类型被创建时，这通常是短包的一个好名字。
- en: Our `Get` and `Put` functions accept context as the first argument. We mentioned
    this approach in the *Writing idiomatic Go code* section—all functions performing
    I/O operations must accept context.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`Get`和`Put`函数接受上下文作为第一个参数。我们在*编写惯用Go代码*部分提到了这种方法——所有执行I/O操作的功能都必须接受上下文。
- en: Our implementation is using a `sync.RWMutex` structure to protect against concurrent
    writes and reads
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的实现使用`sync.RWMutex`结构来保护并发读写
- en: Now, let’s move on to the business logic layer.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到业务逻辑层。
- en: Controller
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器
- en: The next step is to add a controller to encapsulate our business logic. Even
    if your logic is trivial, it is still a good practice to keep it separate from
    the handler from the beginning. This will help you avoid further changes and,
    more importantly, keep the structure of your applications consistent.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为封装我们的业务逻辑添加一个控制器。即使你的逻辑很简单，从一开始就将它与处理器分开也是一个好的实践。这将帮助你避免进一步的更改，更重要的是，保持你应用程序的结构一致。
- en: 'Inside the `metadata/internal/controller` package, add a directory called `metadata`.
    Inside it, add a `controller.go` file with the following logic:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `metadata/internal/controller` 包内，添加一个名为 `metadata` 的目录。在其内部，添加一个 `controller.go`
    文件，并包含以下逻辑：
- en: '[PRE17]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The controller we created is currently just a wrapper around the repository.
    However, the controller will generally have more logic, so it is preferable to
    keep it separate.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的控制器目前只是仓库的一个包装器。然而，控制器通常会有更多的逻辑，因此最好将其保持独立。
- en: Handler
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理器
- en: 'Now, we are going to create the API handler. Inside the `metadata/internal/handler`
    directory, create a directory called `http`. Inside it, create a file called `http.go`
    with the following logic:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建 API 处理器。在 `metadata/internal/handler` 目录内，创建一个名为 `http` 的目录。在其内部，创建一个名为
    `http.go` 的文件，并包含以下逻辑：
- en: '[PRE18]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let’s implement the logic for retrieving movie metadata:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现检索电影元数据的逻辑：
- en: '[PRE19]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The handler we just created uses our repository to retrieve the information
    and return it in JSON format. We chose JSON here just for simplicity. In [*Chapter
    4*](B18865_04.xhtml#_idTextAnchor067), we are going to cover more data formats
    and illustrate how they can benefit your applications.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的处理程序使用我们的仓库来检索信息并以 JSON 格式返回。我们在这里选择 JSON 只是为了简单起见。在 [*第 4 章*](B18865_04.xhtml#_idTextAnchor067)
    中，我们将介绍更多的数据格式，并展示它们如何为您的应用程序带来益处。
- en: You may notice that we have called the package for our HTTP handler `http`.
    There is a trade-off here—while we are certainly colliding with its namesake standard
    library package, we get a pretty descriptive `http.Handler` exported name. Since
    our package is going to be used internally, this trade-off is reasonable.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，我们为我们的 HTTP 处理器命名了 `http` 包。这里有一个权衡——虽然我们确实与同名的标准库包发生了冲突，但我们得到了一个相当描述性的
    `http.Handler` 导出名称。由于我们的包将用于内部使用，这种权衡是合理的。
- en: Main file
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主文件
- en: 'Now, since we have created both a database and an API handler, let’s create
    the executable for the metadata service. Inside the `metadata/cmd` directory,
    create the `main.go` file and add the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们已经创建了一个数据库和一个 API 处理器，让我们创建元数据服务的可执行文件。在 `metadata/cmd` 目录内，创建 `main.go`
    文件并添加以下代码：
- en: '[PRE20]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The function we just created initializes all structures of our service and starts
    the `http` API handler we implemented earlier. The service is ready to process
    user requests, so let’s move on to the other services.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的函数初始化了我们服务的所有结构，并启动了我们之前实现的 `http` API 处理器。服务已准备好处理用户请求，因此让我们继续其他服务。
- en: Rating service
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评分服务
- en: 'Let’s summarize the logic of the rating service:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下评分服务的逻辑：
- en: '**API**: Get the aggregated rating for a record and write a rating.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API**：获取记录的聚合评分并写入评分。'
- en: '**Database**: Rating database.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：评分数据库。'
- en: '**Interacts with services**: None.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互服务**：无。'
- en: '**Data model type**: Rating.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据模型类型**：评分。'
- en: 'This logic would translate into the following packages:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这逻辑将转化为以下包：
- en: '`cmd`: Contains the main function for starting the service'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd`：包含启动服务的 main 函数'
- en: '`controller`: Our service logic (read and write ratings)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller`：我们的服务逻辑（读取和写入评分）'
- en: '`handler`: API handler for a service'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler`：服务的 API 处理器'
- en: '`repository`: Logic for accessing the movie metadata database'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repository`：访问电影元数据数据库的逻辑'
- en: 'We are going to use exactly the same directory structure as we used for the
    metadata service:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与元数据服务相同的目录结构：
- en: '`rating/cmd`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rating/cmd`'
- en: '`rating/internal/controller`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rating/internal/controller`'
- en: '`rating/internal/handler`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rating/internal/handler`'
- en: '`rating/internal/repository`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rating/internal/repository`'
- en: '`rating/pkg`'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rating/pkg`'
- en: Once you have created these directories, let’s move on to the implementation
    of the service.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了这些目录，让我们继续服务实现的实现。
- en: Model
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: 'Create a model directory inside `rating/pkg` and create a `rating.go` file,
    using the following code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `rating/pkg` 内创建一个模型目录，并创建一个 `rating.go` 文件，使用以下代码：
- en: '[PRE21]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The file contains the model for our rating service, which is also going to be
    used by other services interacting with it. Note that we created separate types,
    `RecordID`, `RecordType`, and `UserID`. This will help us with readability and
    add extra type protection, as you will see in the implementation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含我们评分服务的模型，它也将被其他与之交互的服务使用。请注意，我们创建了单独的类型，`RecordID`、`RecordType` 和 `UserID`。这将有助于提高可读性，并增加额外的类型保护，正如您将在实现中看到的。
- en: Repository
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仓库
- en: 'Create the in-memory implementation for our rating repository inside the `rating/internal/repository/memory/memory.go`
    file:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `rating/internal/repository/memory/memory.go` 文件内为我们的评分仓库创建内存实现：
- en: '[PRE22]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, add an implementation of the `Get` function to it, as shown in the following
    code block:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加`Get`函数的实现，如下所示：
- en: '[PRE23]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, let’s implement a `Put` function inside it, as shown:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在它内部实现一个`Put`函数，如下所示：
- en: '[PRE24]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding implementation is using a nested map to store all records inside
    it. If we didn’t define separate types, `RatingID`, `RatingType`, and `UserID`,
    it would be harder to understand the types of the keys in the map because we would
    be using primitives such as `string` and `int`, which are less self-descriptive.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现使用嵌套映射来存储所有记录。如果我们没有定义单独的类型，如`RatingID`、`RatingType`和`UserID`，那么在映射中理解键的类型会更困难，因为我们可能会使用如`string`和`int`这样的原始类型，这些类型描述性较差。
- en: Controller
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器
- en: 'Let’s add a controller for our rating service. In the `rating/internal/controller/rating`
    package, create a `controller.go` file:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`rating/internal/controller/rating`包中添加一个控制器。创建一个`controller.go`文件：
- en: '[PRE25]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s add functions for writing and getting an aggregated rating:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加写入和获取聚合评分的功能：
- en: '[PRE26]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, it is easy to see how the controller logic is different from
    the repository one. The repository provides an interface to get all ratings for
    a record and the controller implements the aggregation logic for them.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，很容易看出控制器逻辑与存储库逻辑的不同。存储库提供了一个接口来获取记录的所有评分，而控制器实现了对这些评分的聚合逻辑。
- en: Handler
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理器
- en: 'Let’s implement the service handler in the `rating/internal/handler/http/http.go`
    file, using the following code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`rating/internal/handler/http/http.go`文件中实现服务处理器，使用以下代码：
- en: '[PRE27]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let’s add a function for handling HTTP requests to our service:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的服务添加一个处理HTTP请求的功能：
- en: '[PRE28]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The handler we implemented handles both `GET` and `PUT` requests. Note the way
    we handle some special cases such as an empty `id` value from the request—in that
    case, we return a special error code, `http.StatusBadRequest`, indicating that
    the API request was invalid. If the record is not found, we return `http.StatusNotFound`,
    and if we encounter any unexpected errors when accessing our database, we return
    `http.StatusInternalServerError`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的处理器处理`GET`和`PUT`请求。注意我们处理一些特殊情况的办法，例如请求中的空`id`值——在这种情况下，我们返回一个特殊的错误代码`http.StatusBadRequest`，表示API请求无效。如果记录未找到，我们返回`http.StatusNotFound`，如果在访问我们的数据库时遇到任何意外错误，我们返回`http.StatusInternalServerError`。
- en: Using such standard HTTP error codes helps the clients to differentiate between
    the types of errors and implement the logic for detecting and correctly handling
    such issues.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的标准HTTP错误代码有助于客户端区分错误类型并实现检测和正确处理这些问题的逻辑。
- en: Main
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主
- en: 'Let’s write the main file for our service. In `rating/cmd/main.go`, write the
    following logic:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们服务的主体文件。在`rating/cmd/main.go`中，编写以下逻辑：
- en: '[PRE29]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `main` function we created is similar to the main function of the metadata
    service; it initializes all components of a service and starts an HTTP handler.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`main`函数类似于元数据服务的`main`函数；它初始化服务的所有组件并启动一个HTTP处理器。
- en: Now, we are ready to implement our last service.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好实现我们的最后一个服务。
- en: Movie service
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电影服务
- en: 'Let’s summarize the logic of the movie service:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下电影服务的逻辑：
- en: '**API**: Get the details for a movie, including the aggregated movie rating
    and movie metadata.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API**：获取电影的详细信息，包括聚合的电影评分和电影元数据。'
- en: '**Database**: None.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：无。'
- en: '**Interacts with services**: Movie metadata and rating.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与服务交互**：电影元数据和评分。'
- en: '**Data model type**: Movie details.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据模型类型**：电影详情。'
- en: 'This logic would translate into the following packages:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑将转换为以下包：
- en: '`cmd`: Contains the main function for starting the service'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd`：包含启动服务的主体函数'
- en: '`controller`: Our service logic (read rating and metadata)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller`：我们的服务逻辑（读取评分和元数据）'
- en: '`gateway`: Logic for calling the other services'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gateway`：调用其他服务的逻辑'
- en: '`handler`: API handler for a service'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler`：服务的API处理器'
- en: 'The directory structure is as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 目录结构如下：
- en: '`movie/cmd`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movie/cmd`'
- en: '`movie/internal/controller`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movie/internal/controller`'
- en: '`movie/internal/gateway`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movie/internal/gateway`'
- en: '`movie/internal/handler`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movie/internal/handler`'
- en: '`movie/pkg`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movie/pkg`'
- en: Once you have created these directories, let’s move on to the implementation
    of the service.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了这些目录，让我们继续实现服务的逻辑。
- en: Model
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: 'Create a `model.go` file in the `movie/pkg/model` directory and write the following
    logic:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在`movie/pkg/model`目录中创建一个`model.go`文件，并编写以下逻辑：
- en: '[PRE30]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that the file imports the model package of a metadata service containing
    the `Metadata` structure that we can reuse in our service.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该文件导入了包含`Metadata`结构的元数据服务的模型包，我们可以在我们的服务中重用它。
- en: Gateways
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网关
- en: In the previous examples, the services did not interact with each other and
    just provided an API for this. The movie service won’t access any database by
    itself but instead is going to interact with both the movie metadata and the rating
    service.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，服务之间没有交互，只是提供了一个API。电影服务本身不会访问任何数据库，而是将与电影元数据和评分服务进行交互。
- en: Let’s create the logic for interacting with both services.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建与两个服务交互的逻辑。
- en: 'First, let’s create an error that we are going to use in our gateways. In the
    `movie/internal/gateway` package, create an `error.go` file, using the following
    code block:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个我们将在网关中使用的错误。在`movie/internal/gateway`包中，创建一个`error.go`文件，使用以下代码块：
- en: '[PRE31]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let’s write an HTTP gateway for the movie metadata service. In the `movie/gateway/metadata/http`
    directory, create a `metadata.go` file:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为电影元数据服务编写一个HTTP网关。在`movie/gateway/metadata/http`目录下，创建一个`metadata.go`文件：
- en: '[PRE32]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s implement a `Get` function in it:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在其中实现一个`Get`函数：
- en: '[PRE33]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let’s write an HTTP gateway for the rating service. In the `movie/gateway/rating/http`
    directory, create a `rating.go` file:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为评分服务编写一个HTTP网关。在`movie/gateway/rating/http`目录下，创建一个`rating.go`文件：
- en: '[PRE34]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s add logic for getting the aggregated rating:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加获取聚合评分的逻辑：
- en: '[PRE35]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, let’s add a function for handling a rating creation request:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一个处理评分创建请求的函数：
- en: '[PRE36]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At this point, we have both gateways and can implement the controller aggregating
    the data from them.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了两个网关，可以实施聚合从它们获取数据的控制器。
- en: Controller
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器
- en: 'In the `movie/internal/controller/movie` directory, create a `controller.go`
    file:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在`movie/internal/controller/movie`目录下，创建一个`controller.go`文件：
- en: '[PRE37]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s define the interfaces for the services we will be calling:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们将要调用的服务的接口：
- en: '[PRE38]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we can define our service controller:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义我们的服务控制器：
- en: '[PRE39]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, let’s implement the function for getting the movie details, including
    both its rating and metadata:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们实现获取电影详情的函数，包括其评分和元数据：
- en: '[PRE40]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that we redefine `ErrNotFound` in different components. While we could
    have just exported it to some shared package, sometimes it is better to keep it
    independent. Otherwise, we may confuse one error for another (for example, rating
    not found or metadata not found).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在不同的组件中重新定义了`ErrNotFound`。虽然我们可以将其导出到某个共享包中，但有时保持其独立性更好。否则，我们可能会混淆一个错误与另一个错误（例如，评分未找到或元数据未找到）。
- en: Handler
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理器
- en: 'In the `movie/internal/handler/http` package, add the `http.go` file, using
    the following logic:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在`movie/internal/handler/http`包中，添加`http.go`文件，使用以下逻辑：
- en: '[PRE41]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, we are finally ready to write a main file for the movie service.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于准备好为电影服务编写主文件了。
- en: Main file
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主文件
- en: 'In the `movie/cmd` package, create a `main.go` file, using the following code
    block:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在`movie/cmd`包中，创建一个`main.go`文件，使用以下代码块：
- en: '[PRE42]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At this point, we have the logic for all three services. Note that we used
    static service addresses, `localhost:8081`, `localhost:8082`, and `localhost:8083`,
    in this example. This allows you to run the services locally; however, this would
    not work if we deployed our services to the cloud or any other deployment platform.
    In the next chapter, we are going to cover this aspect and continue improving
    our microservices. You can run the services we just created by executing this
    command inside the `cmd` directory of each service:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了所有三个服务的逻辑。注意，在这个例子中，我们使用了静态服务地址，`localhost:8081`、`localhost:8082`和`localhost:8083`。这允许你在本地运行服务；然而，如果我们把服务部署到云端或其他部署平台，这就不起作用了。在下一章中，我们将讨论这个方面，并继续改进我们的微服务。你可以在每个服务的`cmd`目录中执行以下命令来运行我们刚刚创建的服务：
- en: '[PRE43]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, you can call the metadata service API using the following command:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下命令调用元数据服务API：
- en: '[PRE44]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can call the rating service API using a similar command:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类似的命令调用评分服务API：
- en: '[PRE45]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, you can call the movie service using the following command:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用以下命令调用电影服务：
- en: '[PRE46]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: All of the preceding requests should return an HTTP 404 error, indicating that
    records are not found—we do not have any data yet, so this is expected.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个请求都应该返回HTTP 404错误，表示未找到记录——我们还没有任何数据，这是预期的。
- en: At this point, we have illustrated how to bootstrap and manually test our example
    microservices and are ready to move on to the next chapter.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经说明了如何启动和手动测试我们的示例微服务，并准备好进入下一章。
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this section, we have covered lots of topics, including the most important
    recommendations for writing Go applications and the standards for the project
    layout of Go applications. The knowledge we gained helped us during the code scaffolding
    of our microservices—we have tried to implement our microservice code in an idiomatic
    way as much as possible.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们涵盖了众多主题，包括编写Go应用程序最重要的建议以及Go应用程序项目布局的标准。我们获得的知识在微服务的代码脚手架搭建过程中给予了我们帮助——我们尽可能地以惯用的方式实现我们的微服务代码。
- en: You have also learned how to split each of your microservices into multiple
    layers, each responsible for its own logic. We have illustrated how to separate
    the business logic from the code accessing the database, and how to separate the
    API handler logic from both, as well as from the logic performing remote calls
    between the services.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了如何将每个微服务分割成多个层次，每个层次负责其自身的逻辑。我们说明了如何将业务逻辑从访问数据库的代码中分离出来，以及如何将API处理逻辑从两者以及服务之间执行远程调用的逻辑中分离出来。
- en: While the amount of information in this chapter is quite overwhelming, we have
    made a solid start and are ready to move on to more advanced topics. In the next
    chapter, we are going to see how the microservices we created can explore each
    other, so we can finally test them.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章的信息量相当庞大，但我们已经取得了坚实的基础，并准备好进入更高级的主题。在下一章中，我们将看到我们创建的微服务如何相互探索，这样我们就可以最终测试它们。
- en: Further reading
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Effective Go*: [https://go.dev/doc/effective_go](https://go.dev/doc/effective_go)'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Effective Go》*：[https://go.dev/doc/effective_go](https://go.dev/doc/effective_go)'
- en: '*Go Code Review Comments*: [https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Go代码审查评论*：[https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)'
- en: '*Project layout*: [https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout)'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目布局*：[https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout)'
- en: '*Package names*: [https://go.dev/blog/package-names](https://go.dev/blog/package-names)'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*包名*：[https://go.dev/blog/package-names](https://go.dev/blog/package-names)'
