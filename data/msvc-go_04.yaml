- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Serialization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化
- en: In previous chapters, we have learned how to scaffold Go microservices, create
    HTTP API endpoints, and set up service discovery to let our microservices commsunicate
    with each other. This knowledge already provides a solid foundation for building
    microservices; however, we are going to continue our journey with more advanced
    topics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何构建 Go 微服务、创建 HTTP API 端点，以及设置服务发现以使我们的微服务能够相互通信。这些知识已经为我们构建微服务提供了一个坚实的基础；然而，我们将继续我们的旅程，探讨更多高级主题。
- en: In this chapter, we will explore **serialization**, a process that allows the
    encoding and decoding of data for storing or sending between services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨**序列化**，这是一个允许数据编码和解码以在服务之间存储或发送的过程。
- en: To illustrate how to use serialization, we are going to define data structures
    transferred between the services using the **Protocol Buffers** format, which
    is widely used across the industry and has a simple syntax, as well as very size-efficient
    encoding.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用序列化，我们将使用**Protocol Buffers**格式定义服务之间传输的数据结构，该格式在业界广泛使用，具有简单的语法，以及非常高效的编码。
- en: Finally, we are going to illustrate how you can generate code for the Protocol
    Buffers structures and demonstrate how efficient Protocol Buffers encoding is
    compared to some other formats, such as XML and JSON.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将说明如何为 Protocol Buffers 结构生成代码，并展示与 XML 和 JSON 等其他格式相比，Protocol Buffers
    编码是多么高效。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basics of serialization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化的基础知识
- en: Using Protocol Buffers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Protocol Buffers
- en: Best practices with serialization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化的最佳实践
- en: Now, let’s continue to the basics of serialization.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续探讨序列化的基础知识。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need to have Go 1.11 or above and the Protocol
    Buffers compiler. We will be using the official Protocol Buffers compiler; you
    can install it by running the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，您需要拥有 Go 1.11 或更高版本以及 Protocol Buffers 编译器。我们将使用官方的 Protocol Buffers
    编译器；您可以通过运行以下命令来安装它：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can find the code examples for this chapter on GitHub at the following
    link:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接在 GitHub 上找到本章的代码示例：
- en: https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter04
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter04
- en: The basics of serialization
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化的基础知识
- en: '**Serialization** is the process of converting data into a format that allows
    you to transfer it, store it, and later deconstruct it back.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列化**是将数据转换为一种格式的过程，允许您传输、存储它，并在以后将其重构回原始形式。'
- en: 'This process is illustrated in the following diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程在以下图中进行了说明：
- en: '![Figure 4.1 – The serialization and deserialization process'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 序列化和反序列化过程'
- en: '](img/Figure_4.1_B18865.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.1_B18865.jpg)'
- en: Figure 4.1 – The serialization and deserialization process
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 序列化和反序列化过程
- en: As illustrated in the diagram, the process of transforming the original data
    is called **serialization**, and the reverse process of transforming it back is
    called **deserialization**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，将原始数据转换的过程称为**序列化**，而将其转换回原始形式的过程称为**反序列化**。
- en: 'Serialization has two primary use cases:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化有两个主要用途：
- en: Transferring the data between services, acting as a common *language* between
    them
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务之间传输数据，充当它们之间的通用**语言**
- en: Encoding and decoding arbitrary data for storage, allowing you to store complex
    data structures as byte arrays or regular strings
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码和解码任意数据以进行存储，允许您将复杂的数据结构作为字节数组或常规字符串存储
- en: In [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027), while scaffolding our applications,
    we created our HTTP API endpoints and set them to return JSON responses to the
    callers. In that case, JSON played the role of a **serialization format**, allowing
    us to transform our data structures into it and then decode them back.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 2 章*](B18865_02.xhtml#_idTextAnchor027)中，当我们构建应用程序时，我们创建了我们的 HTTP API 端点，并将它们设置为向调用者返回
    JSON 响应。在这种情况下，JSON 扮演了**序列化格式**的角色，使我们能够将我们的数据结构转换为它，然后再将其解码回来。
- en: 'Let’s take our `Metadata` structure defined in the `metadata/pkg/model/metadata.go`
    file as an example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以在 `metadata/pkg/model/metadata.go` 文件中定义的 `Metadata` 结构为例：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our structure includes the records called **annotations** that help the JSON
    encoder transform our record into an output. For example, we create an instance
    of our structure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结构包括称为**注释**的记录，这些记录帮助 JSON 编码器将我们的记录转换为输出。例如，我们创建了一个我们的结构实例：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we then encode it with JSON, the result would be the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用JSON对其进行编码时，结果将是以下内容：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the data is serialized, it can be used in many different ways. In our
    examples in[*Chapter 2*](B18865_02.xhtml#_idTextAnchor027), we used JSON format
    for sending and receiving the data between our microservices. Some additional
    use cases of serialization include the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被序列化，它就可以以多种不同的方式使用。在我们的例子中[*第2章*](B18865_02.xhtml#_idTextAnchor027)，我们使用了JSON格式来在我们的微服务之间发送和接收数据。序列化的其他一些用例包括以下内容：
- en: '**Store configuration**: Serialization formats are commonly used for storing
    configuration. For example, you can define your service settings using these kinds
    of formats and then read them in your service code.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储配置**: 序列化格式常用于存储配置。例如，您可以使用这些格式定义您的服务设置，然后在服务代码中读取它们。'
- en: '**Store records in a database**: Formats such as JSON are frequently used for
    storing arbitrary data in databases. For example, key-value databases require
    encoding entire record values into byte arrays, and developers often use formats
    such as JSON to encode and decode these record values.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在数据库中存储记录**: 例如，JSON这样的格式常用于在数据库中存储任意数据。例如，键值数据库需要将整个记录值编码到字节数组中，开发者通常使用JSON这样的格式来编码和解码这些记录值。'
- en: '**Logging**: Application logs are often stored in JSON format, making them
    easy to read for both humans and various applications, such as data visualization
    software.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录**: 应用程序日志通常以JSON格式存储，这使得它们对人类和诸如数据可视化软件等各种应用程序都易于阅读。'
- en: 'JSON is one of the most popular serialization formats at the moment and it
    has been essential to web development. It has the following benefits:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是目前最受欢迎的序列化格式之一，对Web开发至关重要。它具有以下优点：
- en: '**Language support**: Most programming languages include tools for encoding
    and decoding JSON.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言支持**: 大多数编程语言都包括用于编码和解码JSON的工具。'
- en: '**Browser support**: JSON has been an integral part of web applications and
    all modern browsers include developer tools to work with it in the browser itself.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器支持**: JSON是Web应用程序的一个基本组成部分，所有现代浏览器都包括在浏览器本身中与之交互的开发者工具。'
- en: '**Readability**: JSON records are easily readable and are often easy to use
    during both the development and debugging of web applications.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**: JSON记录易于阅读，在Web应用程序的开发和调试过程中通常也容易使用。'
- en: 'However, it has certain limitations as well:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也有一定的局限性：
- en: '**Size**: JSON is not a size-efficient format. In this chapter, we are going
    to see which formats and protocols provide output records that are smaller in
    size.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**: JSON不是一种大小高效的格式。在本章中，我们将探讨哪些格式和协议提供了更小的输出记录。'
- en: '**Speed**: As with its output size, the encoding and decoding speed with JSON
    is not the fastest when set against other popular serialization protocols.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**: 与其他流行的序列化协议相比，JSON的编码和解码速度并不是最快的。'
- en: Let’s explore the other popular serialization formats.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索其他流行的序列化格式。
- en: Popular serialization formats
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**流行的序列化格式**'
- en: 'There are many popular serialization formats and protocols used in the industry.
    Let’s cover some of the most popular formats:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 行业中使用了许多流行的序列化格式和协议。让我们了解一下一些最流行的格式：
- en: '**XML**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML**'
- en: '**YAML**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YAML**'
- en: '**Apache Thrift**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Thrift**'
- en: '**Apache Avro**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Avro**'
- en: '**Protocol Buffers**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议缓冲区**'
- en: This section will provide a high-level overview of each one, as well as some
    key differences between these protocols.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将提供每个格式的高级概述，以及这些协议之间的一些关键差异。
- en: XML
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML
- en: XML is one of the earliest serialization formats for web service development.
    It was created in 1998 and is still widely used in the industry, especially in
    enterprise applications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: XML是用于Web服务开发的最早序列化格式之一。它于1998年创建，目前在行业中仍然被广泛使用，尤其是在企业应用中。
- en: 'XML represents data as a tree of nodes called elements. An element example
    would be `<example>Some value</example>`. If we serialized our metadata structure
    mentioned above, the result would be the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: XML将数据表示为称为元素的节点树。一个元素示例是`<example>Some value</example>`。如果我们序列化上面提到的元数据结构，结果将是以下内容：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may notice that the serialized XML representation of our data is slightly
    longer than the JSON one. It is one of the downsides of XML format – the output
    is often the largest among all popular serialization protocols, making it harder
    to read and transfer the data. On the other hand, XML’s advantages include its
    wide adoption and popularity, readability, as well as its wide library support.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，我们数据的序列化 XML 表示形式比 JSON 长一些。这是 XML 格式的一个缺点——输出通常是所有流行序列化协议中最大的，这使得阅读和传输数据更困难。另一方面，XML
    的优点包括其广泛的采用和受欢迎程度、可读性以及其广泛的库支持。
- en: YAML
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: YAML
- en: 'YAML is a serialization format that was first released in 2001\. It gained
    popularity over the years, becoming one of the most popular serialization formats
    in the industry. Designers of the language took a strong focus on its readability
    and compactness, making it a perfect tool for defining arbitrary human-readable
    data. We can illustrate this on our Metadata structure: in the YAML format, it
    would look as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 是一种序列化格式，它最初于 2001 年发布。多年来，它越来越受欢迎，成为行业中最受欢迎的序列化格式之一。该语言的开发者非常注重其可读性和紧凑性，使其成为定义任意可读数据的完美工具。我们可以在我们的元数据结构上说明这一点：在
    YAML 格式中，它看起来如下所示：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The YAML format is widely used for storing configuration data. One of the reasons
    for this is the ability to include comments, which is lacking in other formats,
    such as JSON. The use of YAML for service-to-service communication is less common,
    primarily due to the greater size of the serialized data. Let’s get to some more
    size-efficient serialization formats.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 格式广泛用于存储配置数据。其中一个原因是它能够包含注释，这是其他格式，如 JSON 所缺乏的。YAML 用于服务间通信的使用较少，主要是因为序列化数据的大小较大。让我们来看看一些更高效的序列化格式。
- en: Apache Thrift
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apache Thrift
- en: 'So far, we have reviewed JSON, XML, and YAML, and all are primarily used for
    defining and serializing arbitrary types of data. There are other solutions to
    a broader class of problems, when we want not only to serialize and deserialize
    the data but also to transfer it between multiple services. These solutions combine
    two roles: they act as both serialization formats and **communication protocols**
    — mechanisms for sending and receiving arbitrary data over the network. HTTP is
    an example of such a protocol but developers are not limited to using it in their
    applications.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经审查了 JSON、XML 和 YAML，它们主要用于定义和序列化任意类型的数据。当我们不仅想要序列化和反序列化数据，还要在多个服务之间传输数据时，还有其他更广泛的解决方案。这些解决方案结合了两个角色：它们既作为序列化格式，也作为**通信协议**——在网络中发送和接收任意数据的机制。HTTP
    是此类协议的一个例子，但开发者并不局限于在他们的应用程序中使用它。
- en: Apache Thrift is a combination of serialization and a communication protocol
    that can be used for both defining your data types and allowing your services
    to communicate with each other by passing them. It was initially created at Facebook
    but later became a community-supported open source project under the Apache Software
    Foundation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Thrift 是一种结合了序列化和通信协议的工具，可用于定义您的数据类型，并允许您的服务通过传递数据相互通信。它最初是在 Facebook
    上创建的，但后来成为 Apache 软件基金会下的社区支持的开源项目。
- en: 'Thrift, unlike JSON and XML, requires you to define your structures in their
    own format first. In our example, for the Metadata structure, we would need to
    create a file with the `.thrift` extension, including the definition in Thrift
    language:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JSON 和 XML 不同，Thrift 要求您首先以自己的格式定义您的结构。在我们的示例中，对于元数据结构，我们需要创建一个以 `.thrift`
    扩展名结尾的文件，包括 Thrift 语言中的定义：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once you have a Thrift file, you can use it with an automatic Thrift code generator
    to generate the code for most programming languages that would contain the defined
    structures and logic to encode and decode it. In addition to data structures,
    Thrift allows you to define **Thrift services** — sets of functions that can be
    called remotely. Here’s an example of a Thrift service definition:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了 Thrift 文件，您可以使用自动 Thrift 代码生成器来生成大多数编程语言的代码，这些代码将包含定义的结构和逻辑，用于编码和解码它。除了数据结构之外，Thrift
    允许您定义**Thrift 服务**——可以远程调用的函数集。以下是一个 Thrift 服务定义的示例：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The example here defines a service called `MetadataService`, which provides
    a `get` function, returning a `Metadata` Thrift object. A Thrift-compatible server
    can act as such a Thrift service, processing incoming requests from the client
    applications — we are going to learn how to write such servers in [*Chapter 5*](B18865_05.xhtml#_idTextAnchor076).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此处定义了一个名为 `MetadataService` 的服务，它提供了一个 `get` 函数，返回一个 `Metadata` Thrift 对象。一个兼容
    Thrift 的服务器可以充当这样的 Thrift 服务，处理来自客户端应用程序的传入请求——我们将在 [*第 5 章*](B18865_05.xhtml#_idTextAnchor076)
    中学习如何编写这样的服务器。
- en: 'Let’s explore the benefits and limitations of Apache Thrift. The benefits include
    the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨 Apache Thrift 的优势和局限性。优势包括以下内容：
- en: A smaller output size and higher encoding and decoding speed compared to XML
    and JSON. Thrift-serialized data can be 30 to 50% smaller in size than XML and
    JSON.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 XML 和 JSON 相比，输出数据更小，编码和解码速度更快。Thrift 序列化数据的大小可以比 XML 和 JSON 小 30% 到 50%。
- en: The ability to define not only structures but entire services and generate code
    for them, allowing communication between the servers and their clients.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅能够定义结构，还能定义整个服务并为它们生成代码，从而允许服务器与其客户端之间进行通信。
- en: 'The limitations include the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 局限性包括以下内容：
- en: Relatively low popularity and adoption in recent years due to moving to more
    popular and efficient formats.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近年来相对较低的人气和采用率，因为转向了更流行和高效的格式。
- en: It lacks official documentation. Thrift is a relatively complex technology,
    and most documentation is unofficial.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它缺乏官方文档。Thrift 是一种相对复杂的技术，大多数文档都是非官方的。
- en: Unlike JSON and XML, Thrift-serialized data is not readable, so it’s trickier
    to use it for debugging.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 JSON 和 XML 不同，Thrift 序列化数据不可读，因此更难以用于调试。
- en: Nearly no support in recent years – Facebook keeps maintaining a separate branch
    of it called Facebook Thrift, but it is much less popular than its Apache counterpart.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近年来几乎没有任何支持——Facebook 一直在维护一个名为 Facebook Thrift 的独立分支，但它的受欢迎程度远低于 Apache 版本。
- en: Let’s see the other popular serialization formats that are widely used across
    the industry.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他在业界广泛使用的流行序列化格式。
- en: Apache Avro
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apache Avro
- en: 'Apache Avro is a combination of a serialization format and a communication
    protocol that is somewhat similar to Apache Thrift. Apache Avro also requires
    a developer to define a schema (written either in JSON or in its own language
    called Avro IDL) for their data. In our case, the Metadata structure would have
    the following schema:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Avro 是一种序列化格式和通信协议的组合，与 Apache Thrift 有一定的相似性。Apache Avro 也要求开发者为他们数据定义一个架构（可以是
    JSON 或其自己的语言 Avro IDL 编写），在我们的案例中，Metadata 结构将具有以下架构：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, the schema would be used for translating the structures into a serialized
    state and back.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该架构将用于将结构转换为序列化状态，并再次转换回来。
- en: It is not uncommon for types and structures to change over time, and microservice
    API and structure definitions need to evolve. With Avro, developers can create
    a new version of a schema (represented as a separate file, often suffixed with
    an incremental version number), and keep both the old and new versions in the
    code base. This way, the application can encode and decode data in either format,
    even if they have some incompatible changes, such as changes in field names. This
    is one of the key benefits of using Apache Avro over many other serialization
    protocols. Additionally, Apache Avro allows you to generate code for existing
    schemas, making it easier to translate between serialized data and corresponding
    data structures in different programming languages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类型和结构随时间变化并不罕见，微服务 API 和结构定义需要进化。使用 Avro，开发者可以创建一个新版本的架构（通常表示为单独的文件，后缀为增量版本号），并在代码库中保留新旧版本。这样，应用程序可以以任一格式编码和解码数据，即使它们有一些不兼容的更改，例如字段名称的更改。这是使用
    Apache Avro 而不是许多其他序列化协议的关键优势之一。此外，Apache Avro 允许你为现有架构生成代码，这使得在不同编程语言之间翻译序列化数据及其对应的数据结构变得更加容易。
- en: Protocol Buffers
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Protocol Buffers
- en: 'Protocol Buffers is a serialization format that was created at Google more
    than 20 years ago. In 2008, the format became public and immediately gained popularity
    among developers. The benefits of the format include the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Protocol Buffers 是一种在 20 多年前由 Google 创建的序列化格式。2008 年，该格式公开，并立即在开发者中获得了流行。该格式的优势包括以下内容：
- en: The simplicity of the definition language
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义语言的简洁性
- en: A small data output size
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较小的数据输出大小
- en: High performance of serialization and deserialization
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化和反序列化的高性能
- en: The ability to define services in addition to data structures and compile client
    and server code in multiple languages
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了数据结构外，还能够定义服务，并且能够在多种语言中编译客户端和服务器代码
- en: Protocol evolution and official support by Google
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Google提供的协议演变和官方支持
- en: The popularity of Protocol Buffers and its simplicity, as well as the efficiency
    of its data encoding, makes it a great fit for using it in microservice development.
    We are going to use Protocol Buffers for serializing and deserializing the data
    transferred between our services, as well as defining our service APIs. In the
    next section, you will learn how to start using Protocol Buffers and move our
    microservice logic to Protocol Buffers from JSON.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Protocol Buffers的流行度、其简单性以及其数据编码的效率，使其非常适合用于微服务开发。我们将使用Protocol Buffers来序列化和反序列化服务之间传输的数据，以及定义我们的服务API。在下一节中，您将学习如何开始使用Protocol
    Buffers，并将我们的微服务逻辑从JSON迁移到Protocol Buffers。
- en: Using Protocol Buffers
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Protocol Buffers
- en: In this section, we are going to illustrate how you can use Protocol Buffers
    for your applications. We will use the microservice examples from the previous
    chapters and define our data model in the Protocol Buffers format. Then, we will
    be using the code generation tools with Protocol Buffers to generate our data
    structures. Finally, we will illustrate how to use our generated code for serializing
    and deserializing our data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将说明如何将Protocol Buffers用于您的应用程序。我们将使用前几章中的微服务示例，并以Protocol Buffers格式定义我们的数据模型。然后，我们将使用Protocol
    Buffers的代码生成工具来生成我们的数据结构。最后，我们将说明如何使用我们生成的代码来序列化和反序列化我们的数据。
- en: 'First, let’s prepare our application. Create the directory called `api` under
    our application’s `src` directory. Inside this directory, create a `movie.proto`
    file and add the following to it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们准备我们的应用程序。在我们的应用程序的`src`目录下创建一个名为`api`的目录。在这个目录内，创建一个`movie.proto`文件，并将其以下内容添加到其中：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s describe the code we just added. In the first line, we set the syntax
    to `proto3`, the latest version of the Protocol Buffers protocol. The second line
    defines the output path for the code generated. The rest of the file includes
    two structures that we need for our microservices, similar to the Go structures
    we created in [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下我们刚刚添加的代码。在第一行，我们将语法设置为`proto3`，这是Protocol Buffers协议的最新版本。第二行定义了代码生成的输出路径。文件的其他部分包括两个结构，这些结构是我们微服务所需的，类似于我们在[*第二章*](B18865_02.xhtml#_idTextAnchor027)中创建的Go结构。
- en: 'Now, let’s generate the code for our structures. In the `src` directory of
    our application, run the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的结构生成代码。在我们的应用程序的`src`目录中，运行以下命令：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the command executes successfully, you should find a new directory called
    `src/gen`. The directory should include a file called `movie.pb.go` with the generated
    code that includes our structures and the code to serialize and deserialize them.
    For example, the generated `MovieDetails` structure code would be the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令执行成功，您应该会找到一个名为`src/gen`的新目录。该目录应包含一个名为`movie.pb.go`的文件，其中包含我们的结构和序列化/反序列化它们的代码。例如，生成的`MovieDetails`结构代码如下：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s now describe what exactly we have just achieved. We have created a `movie.proto`
    file that defines our **data schema** — the definition of our data structures.
    The schema is now defined independently from our Go code, providing the following
    benefits to us:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们描述一下我们刚刚实现了什么。我们创建了一个`movie.proto`文件，它定义了我们的**数据模式**——我们数据结构的定义。现在，该模式独立于我们的Go代码定义，为我们提供了以下好处：
- en: '**Explicit schema definition**: Our data schema is now decoupled from the code
    and explicitly defines the application data types. This makes it easier to see
    the data types provided by application APIs.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式模式定义**：我们的数据模式现在与代码解耦，并显式定义了应用程序数据类型。这使得查看应用程序API提供的数据类型变得更容易。'
- en: '**Code generation**: Our schema can be converted to code via code generation.
    We are going to use it later in [*Chapter 5*](B18865_05.xhtml#_idTextAnchor076)
    for sending the data between the services.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码生成**：我们的模式可以通过代码生成转换为代码。我们将在[*第五章*](B18865_05.xhtml#_idTextAnchor076)中使用它来在服务之间发送数据。'
- en: '**Cross-language support**: We can generate our code not only for Go but also
    for other programming languages. If our model changes, we would not need to rewrite
    our structures for all languages. Instead, we can just re-generate the code for
    all languages by running a single command.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨语言支持**：我们不仅可以为 Go 生成代码，还可以为其他编程语言生成代码。如果我们的模型发生变化，我们就不需要为所有语言重写结构。相反，我们只需运行单个命令即可为所有语言重新生成代码。'
- en: Let’s do a quick benchmark and compare the size of serialized data for three
    serialization protocols – XML, JSON, and Protocol Buffers. For this, let’s write
    a small tool to do so.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速进行基准测试，比较三种序列化协议（XML、JSON 和 Protocol Buffers）序列化数据的尺寸。为此，让我们编写一个小工具来完成这个任务。
- en: 'Inside the `src` directory, create a directory called `cmd/sizecompare` and
    add a `main.go` file to it with the following contents:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 目录中，创建一个名为 `cmd/sizecompare` 的目录，并向其中添加一个 `main.go` 文件，内容如下：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s implement the `main` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现 `main` 函数：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Additionally, add the following functions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加以下函数：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we encode our `Metadata` structure using JSON, XML, and
    Protocol Buffers formats, and print the output sizes in bytes for each encoded
    result.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 JSON、XML 和 Protocol Buffers 格式对 `Metadata` 结构进行编码，并打印每个编码结果的输出大小（以字节为单位）。
- en: 'You may need to fetch the `github.com/golang/protobuf/proto` package required
    for our benchmark by running the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要通过运行以下命令来获取我们基准测试所需的 `github.com/golang/protobuf/proto` 包：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, you can run our benchmark by executing `go run *.go` inside its directory
    and will see following the output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在其目录中执行 `go run *.go` 来运行我们的基准测试，并将看到以下输出：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result is quite interesting. The XML output is almost 40% bigger than the
    JSON one. At the same time, Protocol Buffers’s output is more than 40% smaller
    than the JSON data and more than twice as small as the XML result. This illustrates
    quite well how efficient the Protocol Buffers format is compared to the other
    two in terms of output size. By switching from JSON to Protocol Buffers, we reduce
    the amount of data that we need to send over the network and make our communication
    faster.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 结果非常有趣。XML 输出几乎比 JSON 大 40%。同时，Protocol Buffers 的输出比 JSON 数据小 40% 以上，并且比 XML
    结果小两倍以上。这很好地说明了与另外两种格式相比，Protocol Buffers 格式在输出大小方面的效率。通过从 JSON 切换到 Protocol Buffers，我们减少了需要通过网络发送的数据量，并使我们的通信更快。
- en: Let’s now do an additional experiment and test serialization speed for all three
    formats. For this, we are going to do a **benchmark** — an automated performance
    check that is going to measure how fast a target operation is.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进行一个额外的实验，测试三种格式的序列化速度。为此，我们将进行一个 **基准测试** — 一个自动的性能检查，将测量目标操作的速度。
- en: 'Create a file called `main_test.go` in the same directory and add the following
    to it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录下创建一个名为 `main_test.go` 的文件，并向其中添加以下内容：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have just created a Go benchmark, that is going to tell us how fast is JSON,
    XML, and Protocol Buffers encoding. We are going to cover the details of benchmarking
    in [*Chapter 8*](B18865_08.xhtml#_idTextAnchor109), let’s now run the code to
    see the output by executing the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个 Go 基准测试，它将告诉我们 JSON、XML 和 Protocol Buffers 编码的速度有多快。我们将在 [*第 8 章*](B18865_08.xhtml#_idTextAnchor109)
    中详细介绍基准测试的细节，现在让我们执行以下命令来查看输出：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The result of the command should look as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的结果应该如下所示：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can see the names of three functions that we just implemented and two numbers
    next to them:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们刚刚实现的三个函数的名称以及它们旁边的两个数字：
- en: The first one is the number of times the function got executed
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是函数执行的次数
- en: The second is the average processing speed, measured in nanoseconds per operation
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是平均处理速度，以每操作纳秒来衡量
- en: From the output, we can see that Protocol Buffers serialization on average took
    185.7 nanoseconds, while JSON serialization was almost two times slower at 342.2
    nanoseconds. XML serialization on average took 2519 nanoseconds, being more than
    13 times slower than Protocol Buffers, and more than 7 times slower than JSON
    serialization.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到 Protocol Buffers 序列化平均耗时 185.7 纳秒，而 JSON 序列化几乎慢两倍，达到 342.2 纳秒。XML
    序列化平均耗时 2519 纳秒，比 Protocol Buffers 慢 13 倍以上，比 JSON 序列化慢 7 倍以上。
- en: The benchmark is indeed interesting – it illustrates how different the average
    encoding speeds for various serialization formats are. If performance is important
    for your services, you should consider faster serialization formats to achieve
    a higher encoding and decoding speed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基准测试确实很有趣——它说明了不同序列化格式的平均编码速度差异有多大。如果你的服务对性能很重要，你应该考虑使用更快的序列化格式以实现更高的编码和解码速度。
- en: For now, we are going to leave the generated structures in our repository. We
    will be using them in the next chapter, [*Chapter 5*](B18865_05.xhtml#_idTextAnchor076),
    to replace our JSON API handlers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将把生成的结构保存在我们的仓库中。我们将在下一章，[*第五章*](B18865_05.xhtml#_idTextAnchor076)，中使用它们来替换我们的
    JSON API 处理程序。
- en: Now, let’s learn some best practices for using serialization.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习一些使用序列化的最佳实践。
- en: Best practices for serialization
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化的最佳实践
- en: 'This section summarizes the best practices for serializing and deserializing
    the data. These practices will help you make efficient decisions for using serialization
    in your applications and writing your schema definitions in Protocol Buffers and
    other formats:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本节总结了序列化和反序列化数据的最佳实践。这些实践将帮助你做出高效的决定，在应用程序中使用序列化，并在 Protocol Buffers 和其他格式中编写你的模式定义：
- en: '**Keeping your schema backward compatible**: Avoid any changes in your data
    schema that would break any existing callers. Such changes include modifications
    (renaming or removal) of field names and types.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持模式向后兼容**: 避免任何会破坏现有调用者的数据模式的变化。这些变化包括字段名称和类型的修改（重命名或删除）。'
- en: '**Ensuring that data schemas are kept in sync between clients and servers**:
    For serialization formats with explicit schema definitions, such as Apache Thrift,
    Protocol Buffers, and Apache Avro, you should keep clients and servers in sync
    with the latest schema versions.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保客户端和服务器之间的数据模式保持同步**: 对于具有显式模式定义的序列化格式，如 Apache Thrift、Protocol Buffers
    和 Apache Avro，你应该保持客户端和服务器与最新的模式版本同步。'
- en: '**Documenting implicit details**: Let the callers know any implicit details
    related to your data schema. For example, if your API does not allow an empty
    value of a certain field of a structure, include this in the comments in the schema
    file.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录隐含细节**: 让调用者了解与你的数据模式相关的任何隐含细节。例如，如果你的 API 不允许结构中某个字段的空值，请将其包括在模式文件的注释中。'
- en: '`int timestamp` filed would be considered a bad practice. The right approach
    would be to use `google.protobuf.Timestamp`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int timestamp` 字段会被视为一种不良实践。正确的方法是使用 `google.protobuf.Timestamp`。'
- en: '**Using consistent naming**: Opt for using consistent naming in your schema
    files, similarly to your code.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用一致的命名**: 在你的模式文件中，选择使用与你的代码类似的**一致的命名**。'
- en: '**Following the official style guide**: Get familiar with the official style
    guide if you are using a schema definition language, such as Thrift or Protocol
    Buffers. You can find the link to the official style guide for Protocol Buffers
    in the *Further reading* section below.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遵循官方风格指南**: 如果你使用的是 Thrift 或 Protocol Buffers 等模式定义语言，请熟悉官方风格指南。你可以在下面的*进一步阅读*部分找到
    Protocol Buffers 的官方风格指南链接。'
- en: This list provides some high-level recommendations applicable to all serialization
    protocols. For protocol-specific recommendations, follow the official documentation
    and check the popular open source projects to get some real-world code examples.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表提供了一些适用于所有序列化协议的高级建议。对于特定协议的建议，请遵循官方文档，并检查流行的开源项目以获取一些实际的代码示例。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of serialization and illustrated how
    our data structures could be encoded using various serialization protocols, including
    XML, JSON, and Protocol Buffers. You learned about the differences between the
    most popular serialization protocols and their main advantages and disadvantages.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了序列化的基础知识，并说明了我们的数据结构可以使用各种序列化协议进行编码，包括 XML、JSON 和 Protocol Buffers。你了解了最流行的序列化协议之间的差异以及它们的主要优缺点。
- en: We covered the basics of Protocol Buffers and showed how to define custom data
    structures in its schema definition language. Then, we used the example code to
    illustrate how to generate the schema files for the Go language. Finally, we covered
    the differences in compression efficiency between XML, JSON, and Protocol Buffers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了 Protocol Buffers 的基础知识，并展示了如何在其模式定义语言中定义自定义数据结构。然后，我们使用示例代码来说明如何为 Go 语言生成模式文件。最后，我们讨论了
    XML、JSON 和 Protocol Buffers 之间的压缩效率差异。
- en: In the next chapter, we are going to continue using Protocol Buffers and will
    show how to use it for communication between services.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续使用 Protocol Buffers，并展示如何将其用于服务之间的通信。
- en: Further reading
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The Protocol Buffers documentation*: [https://developers.google.com/protocol-buffers](https://developers.google.com/protocol-buffers
    )'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Protocol Buffers文档》*：[https://developers.google.com/protocol-buffers](https://developers.google.com/protocol-buffers)'
- en: '*Comparison of serialization formats*: [https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats](https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats
    )'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*序列化格式的比较*：[https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats](https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats)'
- en: '*The Protocol Buffers official style guide*: [https://developers.google.com/protocol-buffers/docs/style](https://developers.google.com/protocol-buffers/docs/style)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Protocol Buffers官方风格指南》*：[https://developers.google.com/protocol-buffers/docs/style](https://developers.google.com/protocol-buffers/docs/style)'
