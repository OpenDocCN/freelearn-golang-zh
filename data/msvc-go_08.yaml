- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Deployment with Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 进行部署
- en: As you have reached this chapter, you already know how to bootstrap microservices,
    set up the logic for accessing the database, implement service APIs, use serialization,
    and enable asynchronous communication between your microservices. Now, we are
    ready to cover a topic that is very important in practice—microservice deployment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经到达了本章，你已经知道如何引导微服务，设置访问数据库的逻辑，实现服务 API，使用序列化，并启用微服务之间的异步通信。现在，我们准备介绍一个在实践中非常重要的主题——微服务部署。
- en: '`localhost` for **Kafka**. At some point, you will need to run your services
    remotely—for example, on a remote server or in a cloud, such as **Amazon Web Services**
    (**AWS**) or Microsoft Azure.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`localhost` 用于 **Kafka**。在某个时候，你将需要在远程运行你的服务——例如，在远程服务器或云中，如 **Amazon Web Services**（**AWS**）或
    Microsoft Azure。'
- en: This chapter will help you to learn how to build and set up your applications
    for deployments to such remote infrastructure. Additionally, we are going to illustrate
    how to use one of the most popular deployment and orchestration systems, Kubernetes.
    You will learn about the benefits it provides, as well as how to set it up for
    the microservices that we created in the previous chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你学习如何构建和设置你的应用程序，以便部署到这样的远程基础设施。此外，我们将展示如何使用最受欢迎的部署和编排系统之一，Kubernetes。你将了解它提供的优势，以及如何为我们在前几章中创建的微服务设置它。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Preparing application code for deployments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备应用程序代码以进行部署
- en: Deploying via Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Kubernetes 部署
- en: Deployment best practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署最佳实践
- en: Now, let’s proceed to the first part of the chapter, which is going to help
    you to better understand the core ideas behind the deployment process, and prepare
    your microservices for deployments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续本章的第一部分，这将帮助你更好地理解部署过程背后的核心思想，并为你的微服务准备部署。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you need Go `1.11+` or above, similar to the previous
    chapters. Additionally, you will need Docker, which you can download at [https://www.docker.com](https://www.docker.com).
    You will need to register on the Docker website in order to test service deployments
    in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，你需要 Go `1.11+` 或更高版本，类似于前几章。此外，你还需要 Docker，你可以在 [https://www.docker.com](https://www.docker.com)
    下载它。你需要在 Docker 网站上注册，以便在本章测试服务部署。
- en: In addition to Docker, to complete this chapter, you will need Kubernetes, which
    you can download at [https://kubernetes.io](https://kubernetes.io) (you will need
    the `kubectl` and `minikube` tools from it).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Docker 之外，为了完成本章，你还需要 Kubernetes，你可以在 [https://kubernetes.io](https://kubernetes.io)
    下载它（你需要其中的 `kubectl` 和 `minikube` 工具）。
- en: 'You can find the GitHub code for this chapter here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到本章的 GitHub 代码：
- en: '[https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter08](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter08)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter08](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter08)'
- en: Preparing application code for deployments
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备应用程序代码以进行部署
- en: In this section, we are going to provide a high-level overview of a service
    deployment process and describe the actions required to prepare your microservices
    for deployments. You will learn how to configure Go microservices for running
    in different environments, how to build them for different operating systems,
    and some other tips for preparing your microservices for remote execution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供一个服务部署过程的高级概述，并描述准备你的微服务进行部署所需的操作。你将学习如何配置 Go 微服务以在不同的环境中运行，如何为不同的操作系统构建它们，以及一些准备你的微服务进行远程执行的其他技巧。
- en: Let’s proceed to the basics of the deployment process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续了解部署过程的基本知识。
- en: Deployment basics
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署基础知识
- en: As we mentioned in the introduction to this chapter, deployments allow you to
    run and update your applications on one or multiple servers. Such servers are
    usually located remotely (clouds or dedicated web hosting) and are running all
    the time to allow your applications to serve the request or process data 24/7.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言中所述，部署允许你在单个或多个服务器上运行和更新你的应用程序。这样的服务器通常位于远程位置（云或专用网络托管），并且全天候运行，以便你的应用程序能够24/7处理请求或处理数据。
- en: 'The deployment process for each environment usually consists of multiple steps.
    The steps include the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个环境的部署过程通常包括多个步骤。这些步骤包括以下内容：
- en: '**Build**: Build a service by compiling it (for compiled languages, such as
    Go) and including additional required files.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建**：通过编译（对于编译语言，如Go）并包含其他必需文件来构建服务。'
- en: '**Rollout**: Copy the newly created build to servers of the target environment
    and replace the existing running code, if any, with the newly built one.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署**：将新创建的构建复制到目标环境的服务器上，并用新构建的代码替换任何现有的运行代码。'
- en: 'The rollout process is usually sequential: instead of replacing the build on
    all hosts parallelly, it performs one replacement at a time. For example, if you
    have ten service instances, the rollout process would first update one instance,
    then verify that the instance is healthy and move to the second one, and continue
    until it updates the last service instance. This is done to increase service reliability
    because if a new version consists of a bug or entirely fails to start on some
    server, the rollout would not affect all servers at once.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 部署过程通常是顺序的：不是并行替换所有主机上的构建，而是每次只替换一个。例如，如果你有十个服务实例，部署过程将首先更新一个实例，然后验证该实例是否健康，然后移动到第二个实例，一直更新到最后一个服务实例。这样做是为了提高服务可靠性，因为如果新版本包含错误或完全无法在某些服务器上启动，部署就不会一次性影响所有服务器。
- en: 'In order to enable the testing of microservices, servers can be classified
    into multiple categories, called environments:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够测试微服务，服务器可以被分类到多个类别，称为环境：
- en: '**Local/development**: Servers that are used for running and testing code while
    working on the code. This environment should never handle any requests from users,
    and it often consists just of a developer’s computer. It can be also configured
    to use simplified versions of a database and other components, such as single-server
    and in-memory implementations.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地/开发环境**：在编写代码时用于运行和测试代码的服务器。这个环境永远不会处理来自用户的任何请求，通常只由开发者的计算机组成。它也可以配置为使用数据库和其他组件的简化版本，例如单服务器和内存实现。'
- en: '**Production**: Servers that are intended to handle user requests.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产环境**：用于处理用户请求的服务器。'
- en: '**Staging**: A mirror of a production environment, but is used for testing.
    Staging differs from the local/production environment due to configuration and
    separate data storages, which help to avoid any interference with production data
    during testing.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预发布环境**：生产环境的镜像，但用于测试。预发布环境与本地/生产环境的不同之处在于配置和独立的数据存储，这有助于在测试期间避免与生产数据的任何干扰。'
- en: Production deployments can be done in **canary** mode—a deployment mode that
    performs the changes only on a small fraction (such as 1%) of production hosts.
    Canary deployments are useful for the final testing of new code before updating
    all production instances of a service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 生产部署可以通过**金丝雀模式**进行——这种部署模式只对生产主机的一小部分（例如1%）进行更改。金丝雀部署在更新服务所有生产实例之前对新代码进行最终测试非常有用。
- en: Let’s now see how developers can configure their microservices for deployments
    to multiple environments.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看开发者如何配置他们的微服务以部署到多个环境。
- en: Application configuration
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用配置
- en: In the previous section, we described the differences between various environments,
    such as local/development and production. Each environment is usually configured
    differently—if your services have access to databases, each environment will generally
    have a separate database with different credentials. To enable your services to
    run in such environments, you would need to have multiple configurations of your
    services, one per environment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们描述了不同环境之间的差异，例如本地/开发和生产。每个环境通常配置不同——如果你的服务可以访问数据库，每个环境通常会有一个不同的数据库，具有不同的凭证。为了使你的服务能够在这样的环境中运行，你需要有多个服务配置，每个环境一个。
- en: 'There are two ways of configuring your services:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 配置你的服务有两种方式：
- en: '**In-place/hardcode**: All required settings are stored in the service code
    (Go code, in our case).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**就地/硬编码**：所有必需的设置都存储在服务代码中（在我们的例子中是Go代码）。'
- en: '**Separate code and configuration**: Configuration is stored in separate files
    so that it can be modified independently.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离代码和配置**：配置存储在单独的文件中，以便可以独立修改。'
- en: 'Separating service code and configuration often results in better readability,
    which makes configuration changes easier. Each environment can have a separate
    configuration file or a set of files, allowing you to read, review, and update
    environment-specific configurations easily. Additionally, various data formats,
    such as YAML, can help to keep configuration files compact. Here’s a YAML configuration
    example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务代码和配置分离通常会使代码更易于阅读，这使得配置更改更加容易。每个环境都可以有一个单独的配置文件或一组文件，这样您可以轻松地读取、审查和更新特定环境的配置。此外，各种数据格式，如YAML，可以帮助保持配置文件的紧凑性。以下是一个YAML配置示例：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this book, we are going to use an approach that separates application code
    and configuration files and stores the configuration in YAML format. This approach
    is common to many Go applications and can be seen in many popular open source
    Go projects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用一种将应用程序代码和配置文件分离的方法，并将配置存储在YAML格式中。这种方法在许多Go应用程序中很常见，并且可以在许多流行的开源Go项目中看到。
- en: Important note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Note that invalid configuration changes are among the top causes of service
    outages in most production systems. I suggest you explore various ways of automatically
    validating configuration files as a part of the code commit flow. An example of
    Git-based YAML configuration validation is provided in the following article:
    [https://ruleoftech.com/2017/git-pre-commit-and-pre-receive-hooks-validating-yaml](https://ruleoftech.com/2017/git-pre-commit-and-pre-receive-hooks-validating-yaml).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无效的配置更改是大多数生产系统中服务中断的主要原因之一。我建议您探索各种方法来自动验证配置文件，作为代码提交流程的一部分。以下文章提供了一个基于Git的YAML配置验证示例：[https://ruleoftech.com/2017/git-pre-commit-and-pre-receive-hooks-validating-yaml](https://ruleoftech.com/2017/git-pre-commit-and-pre-receive-hooks-validating-yaml)。
- en: 'Let’s review our microservice code and see which settings can be extracted
    from the application configuration:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们的微服务代码，看看哪些设置可以从应用程序配置中提取出来：
- en: 'Our `metadata service` does not have any settings other than its gRPC handler
    address, `localhost:8081`, which you can find in its `main.go` file:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`metadata服务`除了其gRPC处理器的地址`localhost:8081`外，没有其他设置，您可以在其`main.go`文件中找到这个地址：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can extract this setting to the service configuration. A YAML configuration
    file with this setting would look like this:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将此设置提取到服务配置中。具有此设置的YAML配置文件看起来如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s make the changes for reading the configuration from a file. Inside the
    `metadata/cmd` directory, create a `config.go` file and add the following code
    to it:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进行更改，以便从文件中读取配置。在`metadata/cmd`目录内，创建一个`config.go`文件，并将以下代码添加到其中：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In addition to this, create a `configs` directory inside the `metadata` service
    directory and add a `base.yaml` file to it with the following contents:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在`metadata`服务目录内创建一个`configs`目录，并向其中添加一个包含以下内容的`base.yaml`文件：
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The file we just created contains the YAML configuration for our service. Now,
    let’s add code to our `main.go` file to read the configuration. Replace the first
    line of the `main` function that prints a log message with this:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚创建的文件包含我们服务的YAML配置。现在，让我们向我们的`main.go`文件添加代码以读取配置。用以下内容替换`main`函数中打印日志消息的第一行：
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Additionally, replace the line with the `net.Listen` call with this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将包含`net.Listen`调用的行替换为以下内容：
- en: '[PRE23]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The code we have just added is using a `gopkg.in/yaml.v3` package to read a
    YAML file. Import it into our module by running the following command:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码正在使用`gopkg.in/yaml.v3`包来读取YAML文件。通过运行以下命令将其导入到我们的模块中：
- en: '[PRE24]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Make the same changes that we just made for the other two services we created
    earlier. Use port number `8082` for the `rating` service and `8083` for the `movie`
    service in your YAML files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们之前创建的两个其他服务执行相同的更改。在您的YAML文件中使用端口号`8082`为`rating`服务，`8083`为`movie`服务。
- en: The changes we just made helped us introduce the application configuration that
    is separate from the service logic. This can help us when we want to introduce
    additional configurable options—to make any configuration changes, we would just
    need to update the YAML files without touching our service Go code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚所做的更改帮助我们引入了与应用程序逻辑分离的应用程序配置。这有助于我们在想要引入额外的可配置选项时——要做出任何配置更改，我们只需更新YAML文件，而无需修改我们的服务Go代码。
- en: Now that we have finished configuring our microservices for deployment, we are
    ready to move to the next section, which is going to cover the deployment process
    of our microservices.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对微服务的配置，以便部署，我们准备进入下一节，该节将介绍微服务的部署过程。
- en: Deploying via Kubernetes
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Kubernetes 部署
- en: In this section, we are going to illustrate how to set up deployments for our
    microservices using a popular open source deployment and orchestration platform,
    Kubernetes. You will learn the basics of Kubernetes, how to set up our microservices
    for using it, and how to test our microservice deployments in Kubernetes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何使用一个流行的开源部署和编排平台 Kubernetes 来设置我们的微服务部署。您将学习 Kubernetes 的基础知识，如何设置我们的微服务以使用它，以及如何在
    Kubernetes 中测试我们的微服务部署。
- en: Introduction to Kubernetes
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 简介
- en: '**Kubernetes** is an open source deployment and orchestration platform that
    was initially created at Google and later maintained by a large developer community
    backed by the Linux Foundation. Kubernetes provides a powerful, scalable, and
    flexible solution for running and deploying applications of any size, from small
    single-instance applications to ones having tens of thousands of instances. Kubernetes
    helps to orchestrate multiple operations, such as deployments, rollbacks, up-
    and down-scaling of applications (changing the application instance count upward
    and downward), and many more.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes** 是一个开源的部署和编排平台，最初由 Google 创建，后来由 Linux 基金会支持的一个大型开发者社区维护。Kubernetes
    为运行和部署任何规模的应用程序提供了一种强大、可扩展和灵活的解决方案，从小型单实例应用程序到拥有数万个实例的应用程序。Kubernetes 有助于编排多个操作，如部署、回滚、应用程序的向上和向下扩展（更改应用程序实例数量向上和向下），以及更多。'
- en: 'In Kubernetes, each application consists of one or multiple **pods**—the smallest
    deployable units. Each pod contains one or multiple **containers**—lightweight
    software blocks containing the application code. The deployment of a single container
    to multiple pods is illustrated in the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，每个应用程序由一个或多个**Pod**组成——最小的可部署单元。每个 Pod 包含一个或多个**容器**——包含应用程序代码的轻量级软件块。以下图中展示了单个容器部署到多个
    Pod 的示例：
- en: '![Figure 8.1 – Kubernetes deployment model'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.1 – Kubernetes 部署模型](img/Figure_8.1_B188651.jpg)'
- en: '](img/Figure_7.1_B188651.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.1 – Kubernetes 部署模型](img/Figure_7.1_B188651.jpg)'
- en: Figure 8.1 – Kubernetes deployment model
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.1 – Kubernetes 部署模型](img/Figure_8.1_B188651.jpg)'
- en: 'Kubernetes pods can be run on one or multiple hosts, called **nodes**. A group
    of nodes is called a **cluster**, and the relationship between the cluster, nodes,
    and its pods is illustrated in the following diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Pod 可以在单个或多个主机上运行，这些主机被称为**节点**。一组节点被称为**集群**，集群、节点及其 Pod 之间的关系在以下图中展示：
- en: '![Figure 8.2 – Kubernetes cluster model'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.2 – Kubernetes 集群模型'
- en: '](img/Figure_7.2_B188651.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.2 – Kubernetes 部署模型](img/Figure_7.2_B188651.jpg)'
- en: Figure 8.2 – Kubernetes cluster model
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.2 – Kubernetes 集群模型](img/Figure_8.2_B188651.jpg)'
- en: 'For deploying a service in Kubernetes, developers generally need to perform
    the following steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中部署服务时，开发者通常需要执行以下步骤：
- en: '**Prepare a container image**: A **container image** contains either the application
    code or its compiled binary (both options can be used, as long as the container
    image contains the instructions and any tools to run the code), as well as any
    additional files required for running it. A container image is essentially a program
    ready for deployment.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**准备容器镜像**：**容器镜像**包含应用程序代码或其编译的二进制文件（两种选项都可以使用，只要容器镜像包含运行代码的指令和任何工具），以及运行它所需的任何附加文件。容器镜像本质上是一个准备就绪的、可用于部署的程序。'
- en: '**Create a deployment configuration**: A Kubernetes deployment configuration
    tells it how to run the application. It includes settings such as the number of
    replicas (number of pods to run), names of containers, and many more.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建部署配置**：Kubernetes 部署配置告诉它如何运行应用程序。它包括设置，如副本数量（要运行的 Pod 数量）、容器名称以及更多。'
- en: '**Run a deployment command**: Kubernetes will apply the provided configuration
    by running the desired number of pods with the target application(s).'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行部署命令**：Kubernetes 将通过运行所需数量的 Pod 并针对目标应用程序（程序）应用提供的配置。'
- en: 'One of the benefits of Kubernetes is abstracting away all the low-level details
    of deployments, such as selecting target servers to deploy (if you have many,
    you need to balance their load otherwise), copying and extracting your files,
    and running health checks. In addition to this, there are some other useful benefits:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的一个好处是抽象出所有部署的低级细节，例如选择目标服务器进行部署（如果您有很多，您需要平衡它们的负载否则），复制和提取您的文件，以及运行健康检查。除此之外，还有一些其他有用的好处：
- en: '**Service discovery**: Kubernetes offers a built-in service discovery API for
    use in applications.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：Kubernetes 为应用程序提供内置的服务发现 API。'
- en: '**Rollbacks**: In case there are any issues with the deployment, Kubernetes
    allows you to roll back the changes to the previous state.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚**：如果在部署中遇到任何问题，Kubernetes 允许您将更改回滚到之前的状态。'
- en: '**Automated restarts**: If any pod experiences any issue, such as an application
    crash, Kubernetes will perform a restart of that pod.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动重启**：如果任何 pod 遇到任何问题，例如应用程序崩溃，Kubernetes 将重启该 pod。'
- en: Now, let’s describe how we can set up deployments of our microservices using
    Kubernetes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们描述如何使用 Kubernetes 设置我们的微服务的部署。
- en: Setting up our microservices for Kubernetes deployments
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Kubernetes 部署设置我们的微服务
- en: 'All the necessary steps for setting up deployments in Kubernetes for our three
    microservices are set out here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们三个微服务在 Kubernetes 中设置部署的所有必要步骤都列在这里：
- en: The first step is to create a container image for each service. Kubernetes supports
    multiple types of containers, and Docker is currently the most popular container
    type. We already used Docker in [*Chapter 3*](B18865_03.xhtml#_idTextAnchor051)
    and will illustrate now how to use it for creating containers for our services.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是为每个服务创建一个容器镜像。Kubernetes 支持多种类型的容器，而 Docker 目前是最流行的容器类型。我们已经在 [*第 3 章*](B18865_03.xhtml#_idTextAnchor051)
    中使用了 Docker，现在我们将展示如何使用它为我们的服务创建容器。
- en: 'Inside the `metadata` service directory, create a file called `Dockerfile`
    and add the following code to it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `metadata` 服务目录内部，创建一个名为 `Dockerfile` 的文件，并将以下代码添加到其中：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the file that we just added, we specified that to prepare the image for our
    container for the `metadata` service, Docker should use the `alpine:latest` base
    image. `main` to a container, copy the `configs` directory of the service, and
    expose an `8081` port so that we can accept incoming requests on it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的文件中，我们指定了为 `metadata` 服务的容器准备镜像时，Docker 应该使用 `alpine:latest` 作为基础镜像。将
    `main` 添加到容器中，复制服务的 `configs` 目录，并暴露 `8081` 端口，以便我们可以接受其上的入站请求。
- en: As the next step, add a file with the same contents inside the `rating` and
    the `movie` service directories. Make sure you use the right ports in the files
    (`8082` and `8083`, correspondingly).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为下一步，在 `rating` 和 `movie` 服务目录中添加一个具有相同内容的文件。确保在文件中使用正确的端口（分别为 `8082` 和 `8083`）。
- en: 'Once you have created the Docker configuration files, run the `build` command
    inside each service directory:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 Docker 配置文件，请在每个服务目录中运行 `build` 命令：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The results of the previous command should be the executable file called `main`,
    stored in each service directory. Note that we used a `GOOS=linux` variable—this
    tells the `go` tool to build our code for the Linux operating system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的结果应该是名为 `main` 的可执行文件，存储在每个服务目录中。请注意，我们使用了 `GOOS=linux` 变量——这告诉 `go` 工具为
    Linux 操作系统构建我们的代码。
- en: 'The next step is to build service images. Run this command from the `metadata`
    service directory:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是构建服务镜像。从 `metadata` 服务目录运行此命令：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, run this command from the `rating` service directory:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，从 `rating` 服务目录运行此命令：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, run this command from the `movie` service directory:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从 `movie` 服务目录运行此命令：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If each command is executed successfully, we are ready to run out containers
    using the following commands:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个命令都成功执行，我们就准备好使用以下命令运行我们的容器：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The result of each execution should be a successful execution of each service.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行的成果应该是每个服务的成功执行。
- en: The next step is to create Docker Hub repositories in your account so that you
    can publish your service images to them. Log in to [https://hub.docker.com](https://hub.docker.com),
    go to the `metadata`, `rating`, and `movie`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在您的账户中创建 Docker Hub 仓库，以便您可以将服务镜像发布到它们。登录到 [https://hub.docker.com](https://hub.docker.com)，转到
    `metadata`、`rating` 和 `movie`。
- en: 'Execute the following commands to publish the images:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以发布镜像：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These commands should upload the images we just created to your Docker Hub repositories
    so that Kubernetes can download them during the deployment.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令应将我们刚刚创建的镜像上传到您的 Docker Hub 仓库，以便 Kubernetes 在部署期间下载它们。
- en: At this point, we are ready to create a Kubernetes deployment configuration
    that is going to tell Kubernetes how to deploy our services.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好创建一个 Kubernetes 部署配置，这将告诉 Kubernetes 如何部署我们的服务。
- en: 'Inside the `metadata` service directory, create a file called `kubernetes-deployment.yml`
    with the following contents:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `metadata` 服务目录内部，创建一个名为 `kubernetes-deployment.yml` 的文件，内容如下：
- en: '[PRE32]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The file that we just created provides instructions to Kubernetes on how to
    deploy our service. Here are some important settings:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的文件提供了 Kubernetes 如何部署我们的服务的说明。以下是一些重要的设置：
- en: '**Replicas**: The number of pods to run'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**副本数**: 运行的 pod 数量'
- en: '**Image**: The name of the container image to deploy'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像**: 部署要使用的容器镜像名称'
- en: '**Ports**: Container port to expose'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**: 需要暴露的容器端口'
- en: Note that the container port is different from the application port (the one
    that we configured in our `APIConfig` structure). The mapping between these settings
    is done by Docker as a part of the `docker run` settings.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，容器端口与应用端口（我们在 `APIConfig` 结构中配置的那个端口）是不同的。这些设置的映射是由 Docker 在 `docker run`
    设置中完成的。
- en: 'Now, create a file with the same name in the `rating` service directory with
    the following contents:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `rating` 服务目录中创建一个具有相同名称的文件，内容如下：
- en: '[PRE52]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Remember to replace the `image` property with the Docker image name that you
    created in *step 4*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 记得用你在 *步骤 4* 中创建的 Docker 镜像名称替换 `image` 属性。
- en: 'Finally, create a `kubernetes-deployment.yml` file in the `movie` service directory
    with the following contents:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `movie` 服务目录中创建一个名为 `kubernetes-deployment.yml` 的文件，内容如下：
- en: '[PRE72]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The next step is to start the local Kubernetes cluster using the `minikube`
    tool, which you should have installed as a part of Kubernetes. Run the following
    command to start the cluster:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用 `minikube` 工具启动本地 Kubernetes 集群，你应该已经将其作为 Kubernetes 的一部分安装了。运行以下命令以启动集群：
- en: '[PRE92]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Then, apply our `metadata` deployment configuration by running the following
    command from the `metadata` service directory:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从 `metadata` 服务目录运行以下命令来应用我们的 `metadata` 部署配置：
- en: '[PRE93]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'If the previous command is executed successfully, you should see the new deployment
    by running this command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前一个命令执行成功，你可以通过运行以下命令来查看新的部署：
- en: '[PRE94]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output of the command should be this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出应该是这样的：
- en: '[PRE95]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Also, check the state of the service pods by running the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过运行以下命令来检查服务 pod 的状态：
- en: '[PRE96]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The output should show the `Running` status for our `metadata` service pods,
    as shown here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该显示 `metadata` 服务 pod 的 `Running` 状态，如下所示：
- en: '[PRE97]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: As you may notice, Kubernetes created two pods for our service, the same number
    as we specified in the deployment configuration. Each pod has a `metadata` service.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，Kubernetes 为我们的服务创建了两个 pod，这与我们在部署配置中指定的数量相同。每个 pod 都有一个 `metadata`
    服务。
- en: 'You can check the logs of each pod by running the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来检查每个 pod 的日志：
- en: '[PRE98]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Now, perform the same changes that we did for the `metadata` service for the
    other two services, and verify that the pods are running.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对其他两个服务执行与 `metadata` 服务相同的更改，并验证 pod 是否正在运行。
- en: 'If you want to make some manual API requests to the services, you need to set
    up port forwarding by running the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要向服务发送一些手动 API 请求，你需要通过运行以下命令来设置端口转发：
- en: '[PRE99]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This command would work for the `metadata`, `rating`, and `movie` services;
    however, you would need to replace the `8081` port value with `8082` and `8083`,
    correspondingly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令适用于 `metadata`、`rating` 和 `movie` 服务；但是，你需要将 `8081` 端口值分别替换为 `8082` 和 `8083`。
- en: 'If you did everything well, congratulations! We have finished setting up basic
    Kubernetes deployments of our microservices. Let’s summarize what we did in this
    section:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切做得很好，恭喜！我们已经完成了微服务的基本 Kubernetes 部署设置。让我们总结一下本节中我们做了什么：
- en: First, we created container images for each of our services so that we could
    deploy them.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们为每个服务创建了容器镜像，以便我们可以部署它们。
- en: Then, we published our container images to Docker Hub so that Kubernetes could
    pull the images during the deployment.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将容器镜像发布到 Docker Hub，以便 Kubernetes 在部署过程中可以拉取这些镜像。
- en: We created a Kubernetes deployment configuration to tell it how to deploy our
    microservices.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个 Kubernetes 部署配置，以告诉它如何部署我们的微服务。
- en: Finally, we tested our Kubernetes deployments using a combination of `minikube`
    and `kubectl` commands.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `minikube` 和 `kubectl` 命令的组合测试了我们的 Kubernetes 部署。
- en: At this point, you should have some understanding of Kubernetes deployments
    and know how to deploy your microservices using them. This knowledge will help
    you to run your services on many platforms, including all popular cloud platforms,
    such as AWS, Azure, and **Google Cloud Platform** (**GCP**).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对 Kubernetes 部署有一些了解，并知道如何使用它们来部署你的微服务。这些知识将帮助你将服务运行在许多平台上，包括所有流行的云平台，如
    AWS、Azure 和 **Google Cloud Platform**（**GCP**）。
- en: Deployment best practices
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署最佳实践
- en: 'In this section, we are going to describe some best practices related to the
    deployment process. These practices, listed here, will help you to set up a reliable
    deployment process for your microservices:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述一些与部署过程相关的最佳实践。以下列出的这些实践将帮助你为你的微服务设置一个可靠的部署过程：
- en: Automated rollbacks
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动回滚
- en: Canary deployments
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金丝雀部署
- en: Continuous deployment (CD)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署（CD）
- en: Automated rollbacks
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动回滚
- en: '**Automated rollbacks** are the mechanism of automatically reverting a deployment
    in case there was a failure during it. Imagine you are making deployment of a
    new version of your service and that version has some application bug that is
    preventing it from starting successfully. In that case, the deployment process
    will replace your active instances of a service (if the service is already running)
    with the failing ones, making your services unavailable. Automated rollbacks are
    a way to detect and revert such bad deployments, helping you to avoid an outage
    in situations when your services become unavailable due to such issues.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动回滚**是在部署过程中出现失败时自动回滚部署的机制。想象一下，你正在部署你服务的新版本，而这个版本有一些应用程序错误，阻止它成功启动。在这种情况下，部署过程将用失败的实例替换你的服务活动实例（如果服务已经运行），从而使你的服务不可用。自动回滚是一种检测和回滚此类不良部署的方法，帮助你避免在服务因此类问题而不可用时出现中断。'
- en: 'Automated rollbacks are not offered by default in Kubernetes, at the time of
    writing this book, similar to many popular deployment platforms. However, this
    should not stop you from using this technique, especially if you aim to achieve
    high reliability of your services. The high-level idea of implementing automated
    rollbacks with Kubernetes is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 自动回滚在撰写本书时不是 Kubernetes 的默认功能，类似于许多流行的部署平台。然而，这不应该阻止你使用这项技术，尤其是如果你旨在实现服务的高可靠性。使用
    Kubernetes 实现自动回滚的高级思路如下：
- en: Perform continuous health checks of your service (we are going to cover such
    logic in [*Chapter 12*](B18865_12.xhtml#_idTextAnchor171) of this book).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的服务进行持续的健康检查（我们将在本书的[*第 12 章*](B18865_12.xhtml#_idTextAnchor171)中介绍此类逻辑）。
- en: When you detect a health issue with your service, check whether there was a
    recent deployment of your service. For example, you can do so by running the `kubectl
    describe deployment` command.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你发现你的服务存在健康问题时，检查是否有最近的服务部署。例如，你可以通过运行 `kubectl describe deployment` 命令来做到这一点。
- en: 'In case there was a recent deployment and the time of it closely matches the
    time when the health check issues were detected, you can roll it back by executing
    this rollback command: `kubectl rollout undo deployment <DEPLOYMENT_NAME>`.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最近有部署，并且其时间与检测到健康检查问题的时刻非常接近，你可以通过执行以下回滚命令来回滚它：`kubectl rollout undo deployment
    <DEPLOYMENT_NAME>`。
- en: Canary deployments
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金丝雀部署
- en: As we mentioned at the beginning of the chapter, canary is a special type of
    deployment, where you update only a small fraction (1 to 3%) of instances. The
    idea of canary deployments is to test a new version of your code on a subset of
    production instances and validate its correctness before doing a regular production
    deployment.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，金丝雀是一种特殊的部署类型，其中你只更新一小部分（1% 到 3%）的实例。金丝雀部署的想法是在生产实例的子集上测试你代码的新版本，并在进行常规生产部署之前验证其正确性。
- en: 'We won’t cover the details of setting up canary deployments in Kubernetes,
    but can cover the basic ideas that would help you to do this once you want to
    enable canary deployments for your microservices, as set out here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖在 Kubernetes 中设置金丝雀部署的细节，但可以介绍一些基本理念，这些理念将帮助你在想要为你的微服务启用金丝雀部署时进行操作，如下所述：
- en: Create two separate Kubernetes deployment configurations, one for canary and
    one for production.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个独立的 Kubernetes 部署配置，一个用于金丝雀，一个用于生产。
- en: Specify the desired number of replicas in each configuration—if you want to
    run a service on 50 pods and let canary handle 2% of traffic, set 1 replica for
    canary and 49 replicas for production.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定每个配置中所需的副本数——如果你想在一个服务上运行 50 个 pod，并让金丝雀处理 2% 的流量，则为金丝雀设置 1 个副本，为生产环境设置 49
    个副本。
- en: You may also add environment-specific suffixes to deployment names. For example,
    you can call a canary deployment of a rating service, `rating-canary,` and `rating-production`
    for the production environment.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以为部署名称添加环境特定的后缀。例如，你可以将一个评分服务的金丝雀部署命名为 `rating-canary`，而将生产环境的部署命名为 `rating-production`。
- en: When you perform a deployment of your service, deploy it using a canary configuration
    first.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你进行服务的部署时，首先使用金丝雀配置进行部署。
- en: Once you verify that the deployment was successful, make a deployment using
    a production configuration.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你验证了部署成功，就使用生产配置进行部署。
- en: Canary deployments are strongly recommended for increasing the reliability of
    your deployments. Testing new changes on a small fraction of traffic helps to
    reduce the impact of various application bugs and other types of issues that your
    services can encounter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀部署强烈推荐用于提高部署的可靠性。在少量流量上测试新更改有助于减少各种应用程序错误和其他类型的问题的影响，这些问题可能是你的服务可能遇到的。
- en: Replace with Continuous Deployment (CD)
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用持续部署（CD）替换
- en: '**Continuous Deployment** (**CD**) is a technique of making frequent recurring
    deployments. With CD, services get deployed automatically—for example, on each
    code change. The main benefit of CD is early deployment failure detection—if any
    change (such as a Git commit of a new service code) is causing a deployment failure,
    the failure would often get detected much sooner than in the case of manual deployments.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续部署**（**CD**）是一种频繁重复部署的技术。使用 CD，服务会自动部署——例如，在每次代码更改时。CD 的主要好处是早期部署失败检测——如果任何更改（如新服务代码的
    Git 提交）导致部署失败，失败通常会比手动部署更快地被发现。'
- en: You can automate deployments by programmatically monitoring a change log (such
    as Git commit history), or by using `kubectl apply` command.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过程序化监控变更日志（如 Git 提交历史）或使用 `kubectl apply` 命令来自动化部署。
- en: Due to the high cadence of version updates, CD requires some tooling for automated
    checks of service health. We are going to cover such tooling later in [*Chapter
    11*](B18865_11.xhtml#_idTextAnchor152) and [*Chapter 12*](B18865_12.xhtml#_idTextAnchor171)
    of this book.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于版本更新的高频率，CD 需要一些工具来自动检查服务健康。我们将在本书的第 [*第 11 章*](B18865_11.xhtml#_idTextAnchor152)
    和 [*第 12 章*](B18865_12.xhtml#_idTextAnchor171) 中介绍此类工具。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered a very important topic—service deployments.
    You have learned about the basics of the service deployment process, as well as
    the necessary steps for preparing our microservices for deployment. Then, we introduced
    Kubernetes, a popular deployment and orchestration platform that is now provided
    by many companies and cloud providers. We have illustrated how to set up a local
    Kubernetes cluster and deploy our microservices to it, running multiple instances
    of each service to illustrate how easy is to run any arbitrary number of instances
    within the Kubernetes platform.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一个非常重要的主题——服务部署。你已经了解了服务部署过程的基础，以及为部署我们的微服务所需的必要步骤。然后，我们介绍了 Kubernetes，这是一个由许多公司和云服务提供商提供的流行部署和编排平台。我们展示了如何设置本地
    Kubernetes 集群并将我们的微服务部署到其中，运行每个服务的多个实例，以说明在 Kubernetes 平台中运行任意数量的实例是多么容易。
- en: The knowledge you gained should help you to set up more complex deployment processes,
    as well as to work with the services that are already deployed via Kubernetes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你所获得的知识应该能帮助你设置更复杂的部署流程，以及与通过 Kubernetes 已部署的服务一起工作。
- en: 'This chapter summarizes our material on service deployments. In the next chapter,
    we are going to describe another important topic: unit and integration.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了我们在服务部署方面的材料。在下一章，我们将描述另一个重要主题：单元和集成。
- en: Further reading
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you’d like to learn more, refer to the following links:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多信息，请参考以下链接：
- en: 'Kubernetes documentation: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/
    )'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 文档：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/
    )
- en: 'Service deployment best practices: [https://codefresh.io/learn/software-deployment/](https://codefresh.io/learn/software-deployment/
    )'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务部署最佳实践：[https://codefresh.io/learn/software-deployment/](https://codefresh.io/learn/software-deployment/
    )
- en: 'Setting up Kubernetes services: [https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/
    )'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Kubernetes 服务：[https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/
    )
- en: 'Blue-green deployments: [https://www.redhat.com/en/topics/devops/what-is-blue-green-deployment](https://www.redhat.com/en/topics/devops/what-is-blue-green-deployment)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝绿部署：[https://www.redhat.com/en/topics/devops/what-is-blue-green-deployment](https://www.redhat.com/en/topics/devops/what-is-blue-green-deployment)
