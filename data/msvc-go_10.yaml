- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Reliability Overview
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠性概述
- en: We have made a long journey through all previous chapters of this book and completed
    the part of the book dedicated to microservice development basics. So far, you
    have learned how to bootstrap microservices, write tests, set up service discovery,
    use synchronous and asynchronous communication between your microservices, and
    serialize the data between them using different formats, as well as how to deploy
    the services and verify that their APIs work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走过了本书所有前面的章节，完成了关于微服务开发基础的章节。到目前为止，您已经学习了如何启动微服务、编写测试、设置服务发现、在微服务之间使用同步和异步通信，以及使用不同的格式在它们之间序列化数据，以及如何部署服务并验证它们的API是否正常工作。
- en: This chapter begins the third part of the book, dedicated to more advanced concepts
    of microservice development, including reliability, observability, maintainability,
    and scalability. In this chapter, we will cover some practical aspects of microservice
    development that are important for ensuring your services can operate well under
    many conditions, including failure scenarios, changes in network traffic, and
    unexpected service shutdowns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始本书的第三部分，这部分内容专注于微服务开发的更高级概念，包括可靠性、可观察性、可维护性和可伸缩性。在本章中，我们将探讨微服务开发的一些实用方面，这些方面对于确保您的服务能够在多种条件下良好运行至关重要，包括故障场景、网络流量变化和意外服务关闭。
- en: 'In this chapter, we will cover various techniques and processes that can help
    you increase the reliability of your services. We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍各种技术和流程，可以帮助您提高服务的可靠性。我们将涵盖以下主题：
- en: Reliability basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性基础
- en: Achieving reliability through automation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自动化实现可靠性
- en: Achieving reliability through development processes and culture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过开发流程和文化实现可靠性
- en: Let’s proceed to the first section of the chapter, which will help you to understand
    service reliability concepts better.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续本章的第一部分，这将帮助您更好地理解服务可靠性概念。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you need Go 1.11+ or above.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您需要Go 1.11或更高版本。
- en: 'You can find the GitHub code for this chapter here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的GitHub代码：
- en: '[https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter10)10'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter10)10'
- en: Reliability basics
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠性基础
- en: While implementing new applications, services, or features, engineers often
    focus first on meeting various system requirements, such as implementing specific
    application features. The initial result of such work is usually some working
    code that correctly performs its job, such as handling some data processing task
    or serving network requests as an API endpoint. We can say that such code initially
    performs well in isolation—the implemented code produces expected outputs for
    the inputs we provide.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现新应用程序、服务或功能时，工程师通常会首先关注满足各种系统要求，例如实现特定的应用程序功能。这种工作的初步结果通常是某些可以正确执行其任务的代码，例如处理某些数据处理任务或作为API端点处理网络请求。我们可以这样说，这样的代码最初在独立运行时表现良好——实现的代码为我们提供的输入产生预期的输出。
- en: Things usually get more complex when we add more components to the system. Let’s
    take our movie service from [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027) and
    assume that its API gets used by some external service that has millions of users.
    Our service can be implemented perfectly fine and produce the right results for
    various test inputs. Still, once we get requests from an external service, we
    may notice various issues. One of them is called **denial of service** (**DoS**)—an
    external service can overload our service by asking to process too many requests,
    to the extent that our service stops serving new requests. The outcome of such
    an issue can vary from minor system performance degradation to service crashes
    due to reaching CPU, file, or memory limits.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向系统中添加更多组件时，事情通常会变得更加复杂。让我们以[*第二章*](B18865_02.xhtml#_idTextAnchor027)中的电影服务为例，并假设其API被某个拥有数百万用户的第三方服务使用。我们的服务可以完美实现并针对各种测试输入产生正确的结果。然而，一旦我们从外部服务收到请求，我们可能会注意到各种问题。其中之一被称为**拒绝服务**（**DoS**）——外部服务可以通过请求处理过多的请求来超载我们的服务，以至于我们的服务停止处理新的请求。这种问题的后果可能从轻微的系统性能下降到由于达到CPU、文件或内存限制而导致的服务崩溃。
- en: DoS is just one of the examples of things that can go wrong in a microservice
    environment. Assume that you performed a fix that limits the number of incoming
    requests to your service, but the fix broke the services calling your API because
    they did not expect a sudden DoS on their requests. An alternative scenario is
    a change in a service API that introduces a **backward-incompatible change**.
    This change is incompatible with one or multiple previously released versions
    of callers of your service API. As a result, services calling your API could experience
    various negative effects, up to the point that they would be unable to process
    any requests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: DoS只是微服务环境中可能出现问题的例子之一。假设您实施了一个限制传入服务请求数量的修复，但这个修复破坏了调用您的API的服务，因为它们没有预料到请求会突然遭受DoS攻击。另一种情况是服务API的变化引入了**向后不兼容的更改**。这种更改与您的服务API的一个或多个先前发布的版本不兼容。结果，调用您的API的服务可能会经历各种负面效果，甚至无法处理任何请求。
- en: Let’s define the quality of a service that can be resilient in the face of unexpected
    failures as **reliability**—the quality of operating expectedly and having explicitly
    defined limitations. The last clause in our definition of reliability makes a
    big difference to its meaning—it’s not enough to perform a certain function well.
    It is equally important to be explicit about the service’s limitations and what
    happens when these limitations are breached.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一种服务在面对意外故障时仍能保持弹性的质量为**可靠性**——即按照预期运行并具有明确定义的限制。在我们对可靠性的定义中，最后一句话对它的含义产生了重大影响——仅仅做好某个功能是不够的。同样重要的是要明确服务的限制以及当这些限制被违反时会发生什么。
- en: 'In our movie service example, we would need to be explicit about multiple things,
    such as the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电影服务示例中，我们需要明确多个方面，如下所示：
- en: '**System throughput**: How many requests the service can process (for example,
    maximal requests per second)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统吞吐量**：服务可以处理多少请求（例如，每秒最大请求量）'
- en: '**Congestion policy**: How we would handle scenarios when our service is overloaded'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥堵策略**：当我们的服务过载时我们将如何处理场景'
- en: For example, if our service can’t process more than 100 simultaneous requests
    per service instance, we could explicitly state this in the documentation to our
    API and reject all extra incoming requests by returning a special error code,
    such as `HTTP 429 Too Many Requests`. Such indication of system limits and explicit
    communication of congestion issues would be a great step toward improving overall
    system reliability by making its behavior more deterministic and, hence, reliable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的服务每个实例无法处理超过100个并发请求，我们可以在API文档中明确指出这一点，并通过返回特殊错误代码（如`HTTP 429 Too Many
    Requests`）来拒绝所有额外的传入请求。这种对系统限制的指示和明确沟通拥堵问题将是一个巨大的步骤，有助于通过使行为更加确定性和可靠性来提高整体系统可靠性。
- en: 'In general, achieving a high degree of reliability is a continuous process
    and requires constant improvements in the following three categories:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，实现高度的可靠性是一个持续的过程，需要不断在以下三个类别中持续改进：
- en: '**Prevention**: An ability to prevent possible issues whenever possible'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预防**：在可能的情况下防止可能出现的问题'
- en: '**Detection**: An ability to detect possible issues as early as possible'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测**：尽可能早地发现可能出现的问题'
- en: '**Mitigation**: An ability to mitigate any issues as early as possible'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓解**：尽可能早地减轻任何问题'
- en: 'Prevention, detection, and mitigation improvements can be made by performing
    two types of actions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行两种类型的操作可以改进预防、检测和缓解：
- en: Automating service responses to various types of failures
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化服务对各种类型故障的响应
- en: Changing and improving service development processes
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变和改进服务开发流程
- en: We will divide the rest of the chapter into two sections, describing these two
    types of actions. Let’s proceed to the first section, covering the automation-related
    reliability work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把本章的其余部分分为两个部分，描述这两种类型的操作。让我们先进行第一部分，涵盖与自动化相关的可靠性工作。
- en: Achieving reliability through automation
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过自动化实现可靠性
- en: In this section, we will talk about various automation techniques that can help
    you improve the reliability of your services.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论各种自动化技术，这些技术可以帮助您提高服务的可靠性。
- en: First, let’s get back to communication error handling, which we briefly covered
    earlier in [*Chapter 5*](B18865_05.xhtml#_idTextAnchor076). Having the right communication
    error-handling logic in place is the first step toward achieving higher reliability
    of your services, so we will focus on multiple aspects of error handling that
    are equally important in microservice development.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回到通信错误处理，这是我们之前在[*第五章*](B18865_05.xhtml#_idTextAnchor076)中简要介绍过的。拥有正确的通信错误处理逻辑是实现服务更高可靠性的第一步，因此我们将关注在微服务开发中同样重要的错误处理的多个方面。
- en: Communication error handling
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信错误处理
- en: 'As we discussed in [*Chapter 5*](B18865_05.xhtml#_idTextAnchor076) of this
    book, when two components—such as a client and a server—communicate with each
    other, there are three possible resulting scenarios:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书[*第五章*](B18865_05.xhtml#_idTextAnchor076)中讨论的那样，当两个组件（例如客户端和服务器）相互通信时，有三种可能的结果场景：
- en: '**Successful response**: The server receives and successfully processes a request.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功响应**：服务器接收并成功处理了一个请求。'
- en: '**Client error**: An error occurs, and it is not caused by the server (for
    example, the client sends an invalid request).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端错误**：发生错误，并非由服务器引起（例如，客户端发送无效请求）。'
- en: '**Server error**: An error occurs, and it is caused by the server (for example,
    due to an application crash or an unexpected error on the server side).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器错误**：发生错误，是由服务器引起的（例如，由于应用程序崩溃或服务器端意外错误）。'
- en: 'From the perspective of a client, there are two different classes of errors:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度来看，存在两类不同的错误：
- en: '**Retriable errors**: A client may retry the original request (for example,
    when a server is temporarily unavailable).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重试错误**：客户端可以重试原始请求（例如，当服务器暂时不可用）。'
- en: '**Non-retriable errors**: A client should not retry the request (for example,
    when the request itself is incorrect due to failing validation).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非可重试错误**：客户端不应重试请求（例如，当请求本身由于验证失败而不正确）。'
- en: Differentiating between retriable and non-retriable errors is the responsibility
    of the client. However, it is a good practice to indicate this explicitly whenever
    possible. For example, a server can return specific codes, indicating the types
    of errors (such as `HTTP 404 Not Found`) so that a client can recognize retriable
    errors and perform retries. Differentiation between client and server errors also
    helps to ensure that requests are not retried for non-retriable errors. It is
    important from the server’s perspective because handling duplicate, invalid requests
    increases its load.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 区分可重试和非可重试错误是客户端的责任。然而，在可能的情况下明确指出这一点是一个好习惯。例如，服务器可以返回特定的代码，指示错误类型（例如`HTTP 404
    Not Found`），以便客户端可以识别可重试错误并执行重试。区分客户端和服务器错误还有助于确保不会对非可重试错误进行重试。从服务器的角度来看，这很重要，因为处理重复的、无效的请求会增加其负载。
- en: Let’s illustrate how to handle retriable communication errors by implementing
    client request retries. Setting up automated responses to potential issues, such
    as communication errors, helps to make the system more resilient to transient
    failures, resulting in a better experience for all components in the system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现客户端请求重试来展示如何处理可重试的通信错误。设置对潜在问题的自动响应，例如通信错误，有助于使系统对瞬时故障更具弹性，从而为系统中的所有组件提供更好的体验。
- en: Implementing request retries
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现请求重试
- en: 'Let’s illustrate how to implement request retries in microservice code. For
    this, let’s review the metadata gRPC gateway code we implemented earlier in [*Chapter
    5*](B18865_05.xhtml#_idTextAnchor076). The `Get` function includes the actual
    call to the `metadata` service:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在微服务代码中实现请求重试来展示如何操作。为此，让我们回顾一下我们在[*第五章*](B18865_05.xhtml#_idTextAnchor076)中实现的元数据gRPC网关代码。`Get`函数包括对`metadata`服务的实际调用：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s now look at the implementation of the `GetMetadata` endpoint in the metadata
    service gRPC handler. The `GetMetadata` function includes the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在元数据服务gRPC处理器中实现`GetMetadata`端点的实现。`GetMetadata`函数包括以下代码：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can see, the implementation of the `GetMetadata` endpoint includes three
    error cases, each having its own gRPC error code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`GetMetadata`端点的实现包括三个错误情况，每个都有自己的gRPC错误代码：
- en: '`InvalidArgument`: The incoming request fails the validation.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvalidArgument`：传入的请求未通过验证。'
- en: '`NotFound`: The record with the provided identifier is not found.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotFound`：未找到带有提供标识符的记录。'
- en: '`Internal`: Internal server error.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Internal`：内部服务器错误。'
- en: The `InvalidArgument` and `NotFound` errors are non-retriable—there is no point
    in retrying requests failing validation or trying to retrieve records that are
    not found. `Internal` errors may indicate a wide range of issues, such as bugs
    in the service code, so we can’t certainly state that you should perform retries
    on them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvalidArgument`和`NotFound`错误是不可重试的——重试验证失败的请求或尝试检索未找到的记录是没有意义的。"Internal"错误可能表明一系列问题，例如服务代码中的错误，因此我们无法肯定地说你应该对它们进行重试。'
- en: 'There are, however, some other types of gRPC error codes that indicate potentially
    retriable errors. Let’s list some of them:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些其他类型的gRPC错误代码表示可能可重试的错误。让我们列出其中一些：
- en: '`DeadlineExceeded`: Indicates a problem with processing a request within the
    configured interval of time.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeadlineExceeded`：表示在配置的时间间隔内处理请求存在问题。'
- en: '`ResourceExhausted`: The service processing the request is exhausted. This
    can indicate a problem with a lack of available resources (for example, the CPU,
    memory, or disk reaching its limit) or the client reaching its quota for accessing
    the service (for example, when a service does not allow more than a certain number
    of parallel requests).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceExhausted`：处理请求的服务已耗尽。这可能表明可用资源不足的问题（例如，CPU、内存或磁盘达到其限制）或客户端达到访问服务的配额（例如，当服务不允许超过一定数量的并行请求时）。'
- en: '`Unavailable`: The service is currently unavailable.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unavailable`：服务当前不可用。'
- en: 'Let’s first implement some simple retry logic inside the metadata gRPC gateway
    by replacing the `Get` function with the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在元数据gRPC网关内部实现一些简单的重试逻辑，通过替换`Get`函数为以下代码：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a function that should help us to check whether a communication error is
    retriable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个函数，帮助我们检查通信错误是否可重试：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we also need to import two extra packages for checking for specific
    gRPC error codes—`google.golang.org/grpc/codes` for accessing a list of error
    codes and `google.golang.org/grpc/status` for checking whether the communication
    error is a valid gRPC error.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还需要导入两个额外的包来检查特定的gRPC错误代码——`google.golang.org/grpc/codes`用于访问错误代码列表，`google.golang.org/grpc/status`用于检查通信错误是否为有效的gRPC错误。
- en: 'Now, our metadata gRPC gateway can perform up to five retries of requests to
    the metadata service. The retry logic that we just added should help us minimize
    the impact of occasional errors, such as temporary server unavailability (for
    example, during an unexpected outage or temporary network issues). However, it
    introduces some additional challenges:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的元数据gRPC网关可以对元数据服务的请求进行最多五次的重试。我们刚刚添加的重试逻辑应该有助于我们最小化偶尔的错误影响，例如临时服务器不可用（例如，在意外中断或临时网络问题期间）。然而，这也引入了一些额外的挑战：
- en: '`Get` function, the metadata service gRPC gateway now performs up to five calls
    instead of one for retriable errors.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get`函数，元数据服务gRPC网关现在对于可重试的错误进行最多五次调用，而不是一次。'
- en: '**Request bursts**: The metadata gRPC gateway performs immediate retries on
    errors, which will generate bursts of requests to the server.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求突发**：元数据gRPC网关在出现错误时立即重试，这将生成对服务器的请求突发。'
- en: The latter scenario may be especially challenging to the server due to uneven
    load distribution. Imagine that you are doing some work and getting some phone
    calls with extra tasks. If you responded to such calls and said that you were
    busy, you wouldn’t want to get called again immediately and asked to perform the
    same tasks again—instead, you would want the caller to call back after some time.
    Similarly, immediate retries would be suboptimal to servers experiencing congestion
    issues, so we would need to perform additional modifications to our retry logic
    to introduce extra delays between the retries so that our server does not get
    overloaded with immediate retries.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 后者场景可能对服务器特别具有挑战性，因为负载分布不均。想象一下，你正在做一些工作，同时接到一些带有额外任务的电话。如果你回应这样的电话并说你在忙，你不想立即再次被叫去执行同样的任务——相反，你希望呼叫者在一段时间后再回电。同样，立即重试对于经历拥塞问题的服务器来说也是不理想的，因此我们需要对我们的重试逻辑进行额外的修改，在重试之间引入额外的延迟，以便我们的服务器不会因为立即重试而超载。
- en: 'The technique of adding extra delays between client request retries is called
    **backoff**. Different types of backoff are implemented by using different delay
    intervals between the retry requests:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端请求重试之间添加额外延迟的技术称为**退避**。通过在重试请求之间使用不同的延迟间隔来实现不同的退避类型：
- en: '**Constant backoff**: Each retry is performed after a constant delay.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恒定退避**：每次重试都在一个恒定的延迟之后执行。'
- en: '**Exponential backoff**: Each retry is performed after a delay that is exponentially
    higher than the previous one.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指数退避**：每次重试都是在比前一次指数级更高的延迟后进行的。'
- en: An example of exponential backoff would be a sequence of calls where the first
    retry would be done after a 100 ms delay, the second one would take a 400 ms wait,
    and the third retry delay would be 900 ms. Exponential backoff is usually a better
    solution than constant, because it performs the next retry much slower than the
    previous ones, allowing the server to recover in case of overloading. A popular
    Go library at [https://github.com/cenkalti/backoff](https://github.com/cenkalti/backoff)
    provides an implementation of exponential and other types of backoff algorithms.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 指数退避的一个例子是一系列调用，其中第一次重试会在100毫秒的延迟后进行，第二次将需要400毫秒的等待，第三次重试延迟将是900毫秒。指数退避通常比恒定退避更好，因为它使下一次重试比前一次慢得多，允许服务器在过载的情况下恢复。一个流行的Go库[https://github.com/cenkalti/backoff](https://github.com/cenkalti/backoff)提供了指数退避和其他类型退避算法的实现。
- en: Backoff delay can also be modified by introducing small random changes to its
    duration. For example, the retry delay value on each step could be increased or
    decreased by up to 10% to better spread the load on the server. This optimization
    is called **jittering**. To illustrate the usefulness of jittering, assume multiple
    clients start calling the server simultaneously. If retries are performed with
    the same delays for each client, they will keep calling the server simultaneously,
    generating bursts of server requests. Adding pseudo-random offsets to retry delay
    intervals helps to distribute the load on a server more evenly, preventing possible
    traffic bursts from request retries.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入对持续时间的小随机变化，退避延迟也可以被修改。例如，每一步的重试延迟值可以增加或减少多达10%，以更好地分散服务器上的负载。这种优化称为**抖动**。为了说明抖动的有用性，假设多个客户端同时开始调用服务器。如果每个客户端的重试都使用相同的延迟，它们将同时不断调用服务器，生成服务器请求的突发。向重试延迟间隔添加伪随机偏移有助于更均匀地分配服务器上的负载，防止请求重试可能产生的流量突发。
- en: Deadlines and timeouts
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 截止日期和超时
- en: 'Let’s now talk about another class of communication issues related to time.
    When a client performs a request to a server, multiple possible failures may result
    in either a client or a server not receiving enough data to consider the request
    successful. Possible failure scenarios include the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈与时间相关的另一类通信问题。当客户端向服务器发起请求时，多种可能的失败可能导致客户端或服务器接收到的数据不足以认为请求成功。可能的失败场景包括以下几种：
- en: The client request does not reach the server due to network issues.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端请求因网络问题未能到达服务器。
- en: The server gets overloaded and takes longer to respond to the client.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器过载，响应客户端需要更长的时间。
- en: The server processes the request, but the response does not reach the client
    due to network issues.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器处理了请求，但由于网络问题，响应未能到达客户端。
- en: These failures can result in longer waiting times for a client. Imagine you
    are sending a letter to your relative and not getting a response back. Without
    additional information, you would continue waiting without knowing whether the
    letter got lost at any step or the relative simply hasn’t responded.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些失败可能导致客户端的等待时间更长。想象一下，你正在给你的亲戚写信，但没有收到回复。没有额外的信息，你会继续等待，不知道信是否在某个步骤中丢失，或者亲戚只是还没有回复。
- en: 'For synchronous requests, there is a way to improve the client experience by
    setting a **request timeout**—an interval after which the request is considered
    as failed in case of not receiving a successful response. Setting request timeouts
    is a good practice due to multiple reasons:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同步请求，有一种方法可以通过设置**请求超时**来提高客户端体验——即在未收到成功响应的情况下，经过一定时间间隔后，请求被视为失败。由于多个原因，设置请求超时是一种良好的实践：
- en: '**Elimination of unexpected waits**: If a request takes an unexpectedly long
    time, the client can stop it earlier and perform an optional retry.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除意外等待**：如果请求花费了意外长的时间，客户端可以提前停止它并执行可选的重试。'
- en: '**Ability to estimate maximum request processing time**: When requests are
    performed with explicit timeouts, it is easier to calculate how long it will take
    until the operation returns a response or an error to the caller.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**估计最大请求处理时间的能力**：当使用显式超时执行请求时，更容易计算操作返回响应或错误给调用者需要多长时间。'
- en: '**Ability to set longer timeouts for long-running operations**: Libraries used
    for performing network calls often set default request timeouts (for example,
    30 seconds). Sometimes the clients want to set a higher value, knowing that the
    request may take longer to complete (for example, when uploading a large file
    to a server). Explicitly setting a higher timeout helps to prevent the situation
    of a request getting canceled due to exceeding the default timeout.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**能够为长时间运行的操作设置更长的超时时间**：用于执行网络调用的库通常设置默认请求超时时间（例如，30秒）。有时客户端希望设置一个更高的值，因为他们知道请求可能需要更长的时间才能完成（例如，当将大文件上传到服务器时）。显式地设置一个更高的超时时间有助于防止请求因超过默认超时而被取消的情况。'
- en: 'In Go, timeouts are usually propagated via the `context.Context` object. As
    we mentioned in [*Chapter 1*](B18865_01.xhtml#_idTextAnchor015), each I/O operation,
    such as a network call, accepts the `context` object as an argument, and we can
    set a timeout by calling the `context.WithTimeout` function, as shown in the following
    code snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，超时通常通过`context.Context`对象传播。正如我们在[*第一章*](B18865_01.xhtml#_idTextAnchor015)中提到的，每个I/O操作，如网络调用，都接受`context`对象作为参数，我们可以通过调用`context.WithTimeout`函数来设置超时，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we set the timeout for the `SomeOperation` function
    to `10` seconds, so it should not take more than 10 seconds to complete the operation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将`SomeOperation`函数的超时时间设置为`10`秒，因此完成操作不应超过10秒。
- en: 'Setting a timeout is not the only way to limit request processing time. An
    alternative solution to this is setting a `time.Duration` structure (for example,
    having the value of 10 seconds), a deadline indicates the exact instance of time
    (for example, January 1, 2074, 00:00:00). Here’s an example of using a deadline
    for the same operation as in the previous code example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 设置超时并不是限制请求处理时间的唯一方法。对此的另一种解决方案是设置一个`time.Duration`结构（例如，值为10秒），一个截止时间表示确切的时间点（例如，2074年1月1日，00:00:00）。以下是一个使用截止时间的代码示例，与之前的代码示例中的相同操作：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Technically, both a timeout and a deadline help us achieve the same goal—set
    a time limit for a target operation. You are free to use either format, depending
    on your preferences.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，超时和截止时间都帮助我们实现相同的目标——为特定操作设置时间限制。你可以根据自己的喜好选择使用任一格式。
- en: Fallbacks
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回退
- en: 'Let’s now talk about another client-server communication failure scenario—when
    a client tries to operate and doesn’t get a successful response even after a set
    of retries. In such a case, there are three possible options for the client:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论另一个客户端-服务器通信失败场景——当客户端尝试操作，即使在多次重试后也没有收到成功的响应。在这种情况下，客户端有三个可能的选择：
- en: Return an error to the caller, if any
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有调用者，向其返回错误
- en: Panic, in case an error is fatal to the system
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果错误对系统是致命的，则引发恐慌
- en: Perform an alternative backup operation, if it is possible
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，执行替代的备份操作
- en: The last option is called a **fallback**—an alternative logic that can get executed
    if some operation can’t be performed as expected.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项被称为**回退**——一种在某些操作无法按预期执行时可以执行的替代逻辑。
- en: Let’s take our rating service as an example. In our service, we implemented
    the `GetAggregatedRating` endpoint by reading all ratings for a provided record
    from the rating repository. Now, let’s consider a failure scenario when we can’t
    retrieve the ratings due to some problem, such as MySQL database unavailability.
    Without a fallback logic, we would not be able to process an incoming request
    and would need to return an error to our caller.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的评分服务为例。在我们的服务中，我们通过从评分存储库中读取提供的记录的所有评分来实现`GetAggregatedRating`端点。现在，让我们考虑一个由于某些问题（例如MySQL数据库不可用）而无法检索评分的失败场景。如果没有回退逻辑，我们就无法处理传入的请求，并需要向我们的调用者返回错误。
- en: 'An example of a fallback would be to use a `map` structure) and return them
    on database-read errors. The following code snippet provides an example of such
    a fallback logic:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 回退的一个例子是使用`map`结构，并在数据库读取错误时返回它们。以下代码片段提供了一个这样的回退逻辑示例：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using fallbacks is an example of **graceful degradation**—a practice of handling
    application failures in a way that an application still performs its operations
    in a limited mode. In our example, the movie service would continue processing
    requests for getting movie details even if the recommendation feature is unavailable,
    providing a limited but working functionality to its users.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回退是**优雅降级**的一个例子——这是一种处理应用程序故障的方式，即使应用程序仍然以有限模式执行其操作。在我们的例子中，即使推荐功能不可用，电影服务也会继续处理获取电影详情的请求，为用户提供有限但正常的功能。
- en: When designing new services or features, ask yourself which operations could
    be replaced with fallbacks in case of failures. Additionally, check which features
    and operations are absolutely necessary and which ones can be turned off in case
    of any failure, such as system overload or losing a part of a system due to an
    outage. Also, a good practice is to emit additional useful information related
    to failures, such as logs and metrics, and make it explicit in the code that the
    fallback is intentional, as in the preceding example.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计新的服务或功能时，请自问哪些操作在出现故障时可以被回退操作所替代。此外，检查哪些特性和操作是绝对必要的，哪些可以在任何故障发生时关闭，例如系统过载或由于故障而丢失系统的一部分。另外，一个好的做法是发出与故障相关的额外有用信息，例如日志和指标，并在代码中明确指出回退是故意的，就像前面的例子一样。
- en: Rate limiting and throttling
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速率限制和节流
- en: As we discussed at the beginning of this chapter, there may be a situation when
    a microservice is overloaded and can’t handle incoming requests anymore. How can
    we prevent or mitigate such issues?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头讨论的那样，可能存在一种情况，即微服务过载并且无法再处理传入的请求。我们如何防止或减轻此类问题？
- en: 'A popular way of preventing such issues is setting a hard limit on the number
    of requests to be processed in parallel. Such a technique is called **rate limiting**
    and can be applied on multiple levels:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 防止此类问题的流行方法是在并行处理请求数量上设置一个硬限制。这种技术被称为**速率限制**，可以在多个级别上应用：
- en: '**Client level**: A client limits the number of simultaneous outgoing requests.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端级别**：客户端限制同时发出的请求数量。'
- en: '**Server level**: A server limits the number of simultaneous incoming requests.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器级别**：服务器限制同时传入的请求数量。'
- en: '**Network/intermediate level**: The number of requests between a server and
    its clients is controlled by some logic or an intermediate component between them
    (for example, by a load balancer).'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络/中间级别**：服务器和其客户端之间的请求数量由它们之间的某些逻辑或中间组件（例如，由负载均衡器）控制。'
- en: When a client or a server exceeds the configured number of requests, the result
    of a request would be an error that should include a special code or message,
    indicating that a request has been rate limited.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端或服务器超过配置的请求数量时，请求的结果将是一个错误，该错误应包括一个特殊代码或消息，指示请求已被速率限制。
- en: An example of a rate-limiting indication in the HTTP protocol is a built-in
    status code, `429 Too Many Requests`. When a client receives a response with such
    a code, it should take this into account by either reducing the call rate or waiting
    some time until the server can process requests again.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议中速率限制的一个例子是内置的状态码，`429 Too Many Requests`。当客户端收到带有此代码的响应时，它应该通过减少调用速率或等待一段时间直到服务器可以再次处理请求来考虑这一点。
- en: 'Client- and server-level rate limiting are often done by each service instance
    separately: each instance keeps track of the current number of outgoing or incoming
    requests. The downside of these models is the inability to configure the limits
    on a global-service level. If you configure each service client instance to send
    no more than 100 requests per second, you may still receive 100,000 simultaneous
    requests if there are 1,000 client instances. Such a high number of simultaneous
    requests could easily overload your service.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器级别的速率限制通常由每个服务实例单独执行：每个实例跟踪当前发出的或传入的请求数量。这些模型的缺点是无法在全局服务级别配置限制。如果你将每个服务客户端实例配置为每秒不超过100个请求，那么如果有1000个客户端实例，你仍然可能会接收到10万个同时请求。如此高的同时请求数量很容易使你的服务过载。
- en: 'Network-level rate limiting can potentially solve this problem: if rate limiting
    is performed in a centralized way (for example, by a load balancer that handles
    requests between the services), the component performing rate limiting can keep
    track of the total number of requests across all service instances.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 网络级别的速率限制可能解决此问题：如果以集中方式（例如，通过处理服务之间请求的负载均衡器）执行速率限制，执行速率限制的组件可以跟踪所有服务实例的总请求数量。
- en: While network-level rate limiters provide more flexibility to configure the
    settings, they often require additional centralized components (such as load balancers).
    Because of this, we are going to demonstrate how to use a simpler approach, based
    on the client level.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然网络级别的速率限制器提供了更多的配置灵活性，但它们通常需要额外的集中式组件（例如负载均衡器）。因此，我们将演示如何使用基于客户端的更简单的方法。
- en: There is a popular package implementing rate limiting in Go, called `golang.org/x/time/rate`.
    The package implements the `b`, decrements its value by 1 on each request, and
    refills it at a configured rate of `r` elements per second. For example, for b
    = 100 and r = 50, the token bucket algorithm creates a bucket of size 100 and
    refills it at a rate of 50 per second. At any moment in time, it doesn’t allow
    more than 100 simultaneous requests (the maximal number is controlled by the current
    bucket size).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个流行的Go语言包实现了速率限制，称为`golang.org/x/time/rate`。该包实现了`b`，每次请求时减1，并以每秒配置的速率`r`个元素进行补充。例如，对于b
    = 100和r = 50，令牌桶算法创建一个容量为100的桶，并以每秒50的速率补充。在任何时刻，它不允许超过100个并发请求（最大数量由当前桶的大小控制）。
- en: 'Here is an example of using a token bucket-based rate limiter in Go:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在Go中使用基于令牌桶的速率限制器的示例：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code prints `allowed` 3 times and then keeps printing `not allowed` 97
    times unless it takes more than 1 second to run.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码会打印`allowed`三次，然后持续打印`not allowed` 97次，除非执行时间超过1秒。
- en: 'Let’s illustrate how to use such a rate limiter in combination with a gRPC
    API handler, which we implemented in [*Chapter 5*](B18865_05.xhtml#_idTextAnchor076).
    The gRPC protocol allows us to define **interceptors**—operations that are performed
    on each request and can modify the gRPC server’s response to it. To add a gRPC
    rate limiter to the movie service gRPC handler, perform the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过[*第五章*](B18865_05.xhtml#_idTextAnchor076)中实现的gRPC API处理器来展示如何使用这种速率限制器。gRPC协议允许我们定义**拦截器**——在每个请求上执行的操作，可以修改gRPC服务器对该请求的响应。要将gRPC速率限制器添加到电影服务的gRPC处理器中，执行以下步骤：
- en: 'Open the `movie/cmd/main.go` file and add the following code to its imports:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`movie/cmd/main.go`文件，并在其导入中添加以下代码：
- en: '[PRE8]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Replace the line with a `grpc.NewServer` call with the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将带有`grpc.NewServer`调用的行替换为以下代码：
- en: '[PRE9]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, add the following structure definition to the file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下结构定义添加到文件中：
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our rate limiter is using a rate-limiting gRPC server interceptor from the `github.com/grpc-ecosystem/go-grpc-middleware/ratelimit`
    package. Its interface is slightly different from our limiter from `golang.org/x/time/rate`,
    so we added a structure that links them together. Now, our gRPC server allows
    up to 100 requests per second and returns an error with a `codes.ResourceExhausted`
    special code in case the limit is exceeded. This allows us to make sure the service
    does not get overloaded with a sudden spike of a large number of requests—if somebody
    requests 1 million movie details at once from it, we are not going to make 1 million
    calls to our metadata service and overload its database.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的速率限制器使用来自`github.com/grpc-ecosystem/go-grpc-middleware/ratelimit`包的速率限制gRPC服务器拦截器。其接口与我们来自`golang.org/x/time/rate`的限制器略有不同，因此我们添加了一个结构来将它们连接起来。现在，我们的gRPC服务器允许每秒最多100个请求，并在超过限制时返回一个带有`codes.ResourceExhausted`特殊代码的错误。这确保了服务不会因为大量请求的突然增加而超载——如果有人一次性请求100万部电影详情，我们不会对元数据服务进行100万次调用并超载其数据库。
- en: Keep in mind that rate limiting is a powerful technique; however, it needs to
    be used with caution because setting the limit too low would make your system
    unnecessarily too restrictive for users by rejecting too many requests. To calculate
    fair rate-limiting settings for your services, you need to periodically perform
    benchmarking, understanding the maximum throughput of their logic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，速率限制是一种强大的技术；然而，它需要谨慎使用，因为设置限制过低会使系统对用户过于限制，拒绝过多的请求。为了计算服务的公平速率限制设置，您需要定期进行基准测试，了解其逻辑的最大吞吐量。
- en: Let’s move to the next topic of automation-based reliability techniques, describing
    how to gracefully terminate the execution of your services.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到基于自动化的可靠性技术的下一个主题，描述如何优雅地终止服务的执行。
- en: Graceful shutdown
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优雅关闭
- en: 'In this section, we are going to talk about the graceful handling of service
    shutdown events. Service shutdowns can be triggered by multiple events:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论服务关闭事件的优雅处理。服务关闭可以由多个事件触发：
- en: Manual interruption of execution (for example, when a user types *Ctrl* + *C*/*Cmd*
    + *C* in a terminal that runs the service process, and the process receives a
    `SIGINT` signal from the operating system)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动中断执行（例如，当用户在运行服务进程的终端中输入*Ctrl* + *C*/*Cmd* + *C*时，进程从操作系统接收`SIGINT`信号）
- en: Termination of execution by the operating system (for example, by `SIGTERM`
    or `SIGKILL` signals)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统通过（例如，通过`SIGTERM`或`SIGKILL`信号）终止执行
- en: Panic in service code
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务代码中的panic
- en: 'Generally, sudden termination of the execution of a service may result in the
    following negative consequences:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，服务的执行突然终止可能会导致以下负面后果：
- en: '**Dropped requests**: Incoming API requests may be dropped before they get
    fully processed, resulting in errors for the callers of the service.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**丢弃请求**：入站API请求可能在完全处理之前被丢弃，从而导致服务调用者的错误。'
- en: '**Connection issues**: Service network connections may not be properly closed
    during a shutdown, resulting in multiple negative effects. For example, not closing
    a database connection may result in a situation called a **connection leak**,
    when the database keeps the connection allocated to the service instead of allowing
    it to be reused by another instance.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接问题**：在关闭过程中，服务网络连接可能无法正确关闭，从而导致多种负面影响。例如，未关闭数据库连接可能导致所谓的**连接泄漏**情况，此时数据库会保留连接以供服务使用，而不是允许其他实例重用该连接。'
- en: 'To prevent these issues, you need to ensure that your service shuts down gracefully
    by performing a set of operations that minimize any negative consequences for
    the service and its components. Performing a **graceful shutdown**, the service
    would run some extra logic before the termination, such as the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这些问题，您需要确保您的服务通过执行一系列操作来优雅地关闭，以最大限度地减少对服务和其组件的负面影响。执行**优雅关闭**时，服务在终止前会运行一些额外的逻辑，例如以下内容：
- en: Completing as many unfinished operations, such as unprocessed requests, as possible
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能完成尽可能多的未完成操作，例如未处理请求
- en: Closing all open network connections and yielding any shared resources, such
    as network sockets
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭所有打开的网络连接并释放任何共享资源，例如网络套接字
- en: 'Graceful shutdown logic for Go services is usually implemented in the following
    way:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Go服务的优雅关闭逻辑通常按以下方式实现：
- en: The service subscribes to shutdown events by calling a `Notify` function of
    an `os/signal` package.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务通过调用`os/signal`包的`Notify`函数订阅关闭事件。
- en: When a service receives a `SIGINT` or `SIGTERM` event from the operating system,
    indicating that the service is about to be terminated, it performs a set of required
    operations for closing all open connections and completing all pending tasks.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当服务从操作系统接收到`SIGINT`或`SIGTERM`事件，表明服务即将被终止时，它执行一系列必要的操作来关闭所有打开的连接并完成所有挂起的任务。
- en: Once all operations are completed, the service finishes the execution.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有操作完成，服务将结束执行。
- en: 'Here is a code example that you can add to the `main` function of any Go service,
    such as the ones that we implemented in [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个您可以添加到任何Go服务`main`函数中的代码示例，例如我们在[*第2章*](B18865_02.xhtml#_idTextAnchor027)中实现的服务：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There is also a way to gracefully handle panics in Go code by using the built-in
    `recover` function. The following code snippet demonstrates how to handle a panic
    inside the `main` function and execute any custom logic, such as closing any open
    connections:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用内置的`recover`函数，也有一种优雅地处理Go代码中panic的方法。以下代码片段演示了如何在`main`函数内部处理panic并执行任何自定义逻辑，例如关闭任何打开的连接：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In our code, we check whether there is a service panic by calling the `recover`
    function and checking whether it returns a non-nil error. In case of a panic,
    we can perform any additional operations, such as saving any unsaved data or terminating
    any open connections.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们通过调用`recover`函数并检查它是否返回非空错误来检查是否存在服务panic。在panic的情况下，我们可以执行任何额外的操作，例如保存任何未保存的数据或终止任何打开的连接。
- en: To gracefully terminate the execution of a Go gRPC server, you need to call
    the `GracefulStop` function instead of `Stop`. Unlike the `Stop` function, `GracefulStop`
    would wait until all requests are processed, helping to reduce the negative impact
    of the shutdown on the clients.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要优雅地终止 Go gRPC 服务器的执行，你需要调用 `GracefulStop` 函数而不是 `Stop`。与 `Stop` 函数不同，`GracefulStop`
    会等待所有请求处理完毕，从而帮助减少关闭对客户端的负面影响。
- en: If you have some long-running components, such as Kafka consumers or any background
    goroutines executing long-running tasks, you can communicate the service termination
    signal using the built-in `context.Context` structure. The `context.Context` structure
    provides a feature called **context cancellation**—an ability to notify different
    components about the cancellation of an execution by sending a specific event
    through the channel associated with the context.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些长时间运行的组件，例如 Kafka 消费者或执行长时间运行任务的任何后台 goroutine，你可以使用内置的 `context.Context`
    结构来传达服务终止信号。`context.Context` 结构提供了一种名为 **上下文取消** 的功能——通过发送与上下文关联的通道中的特定事件来通知不同组件关于执行取消的能力。
- en: 'Let’s update our rating service code to illustrate how to implement context
    cancellation and a graceful shutdown of a gRPC server:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的评分服务代码，以说明如何实现上下文取消和 gRPC 服务的优雅关闭：
- en: 'Open the `main.go` file of the rating service and find the line that performs
    a call to the `context.Background()` function. Replace it with the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开评分服务的 `main.go` 文件，找到执行 `context.Background()` 函数调用的行。将其替换为以下代码：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our code creates an instance of a context and the `cancel` function, which we
    will be calling on service shutdown to notify our components, such as the service
    registry, about upcoming termination.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个上下文实例和 `cancel` 函数，我们将在服务关闭时调用它来通知我们的组件，例如服务注册表，关于即将到来的终止。
- en: 'Immediately before the call to the `srv.Serve` function, add the following
    code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `srv.Serve` 函数之前立即添加以下代码：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In our code, we let the rating service listen for process interruption and termination
    signals and start the background goroutine, which keeps listening for the relevant
    notifications. Once it receives either signal, it calls the `cancel` function
    that we obtained in the previous step. The result of calling this function would
    be a notification that would be sent to the components initialized with our context,
    such as the service registry.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们让评分服务监听进程中断和终止信号，并启动后台 goroutine，持续监听相关通知。一旦它收到任一信号，它就会调用我们在上一步获得的
    `cancel` 函数。调用此函数的结果将是一个通知，该通知将被发送到使用我们的上下文初始化的组件，例如服务注册表。
- en: 'Let’s add the final touch by adding the following line to the end of our `main`
    function:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `main` 函数的末尾添加以下行来完成最后的润色：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s now test the code that we just implemented. Run the rating service and
    then terminate it by pressing *Ctrl + C*/*Cmd + C* (depending on your OS). You
    should see the following messages:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来测试我们刚刚实现的代码。运行评分服务，然后通过按 *Ctrl + C*/*Cmd + C*（取决于你的操作系统）来终止它。你应该会看到以下消息：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Communication of termination and interruption events is a common practice in
    Go microservice development and is an elegant way of implementing graceful shutdown
    logic. When designing and implementing your services, think in advance about possible
    resources that need to be closed or de-initialized upon the service termination,
    such as any network clients and connections. A graceful shutdown logic can prevent
    the negative effects of sudden service termination. It can also reduce the number
    of possible errors in your services and improve your operating experience.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 微服务开发中，传达终止和中断事件是一种常见做法，并且是实现优雅关闭逻辑的一种优雅方式。在设计和服务实现时，提前考虑在服务终止时需要关闭或反初始化的可能资源，例如任何网络客户端和连接。优雅关闭逻辑可以防止服务突然终止的负面影响。它还可以减少服务中可能出现的错误数量，并提高你的操作体验。
- en: At this point, we have reviewed some automation techniques to improve the reliability
    of our services and reduce the symptoms of various failure scenarios. Now, we
    can proceed to the next section of the chapter, covering another aspect of reliability
    work related to development processes and culture. Improvements to your development
    processes are essential to achieving high reliability in the long term, and the
    section should be useful to you by providing some valuable tips and ideas that
    you can utilize in microservice development.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经审查了一些自动化技术，以提高我们服务的可靠性并减少各种故障场景的症状。现在，我们可以继续本章的下一节，涵盖与开发流程和文化相关的另一个可靠性工作方面。改进你的开发流程对于长期实现高可靠性至关重要，本节将为你提供一些有价值的技巧和想法，你可以在微服务开发中利用它们。
- en: Achieving reliability through development processes and culture
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过开发流程和文化实现可靠性
- en: In this section, we are going to describe some techniques for achieving higher
    service reliability based on changes in the development processes and culture.
    You will learn how to establish the processes for improving and reviewing your
    service reliability, how to learn from any service-related issues and incidents
    efficiently, and how to measure your service reliability. We will cover the processes
    and practices that are widely used across the industry, outlining the most important
    ideas from each one. The section is going to be more theoretical than the previous
    one; however, it should be equally useful.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述一些基于开发流程和文化变革提高服务可靠性的技术。你将学习如何建立改进和审查服务可靠性的流程，如何高效地从任何服务相关的问题和事件中学习，以及如何衡量你的服务可靠性。我们将涵盖整个行业广泛使用的流程和实践，概述每个流程最重要的思想。本节将比前一节更具理论性；然而，它应该同样有用。
- en: First, we are going to provide an overview of the on-call process essential
    for setting up a mechanism for monitoring issues with your services.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将提供一个概述，介绍设置监控服务问题的机制所必需的值班流程。
- en: On-call process
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值班流程
- en: When your services start handling production traffic or start serving user requests,
    one of your first reliability goals should be to detect any issues, or incidents,
    as early as possible. Efficient detection should be automatic—a program will always
    be much more efficient than a human in detecting most issues. Each automatic detection
    should notify one or more engineers about the incident so that the engineers can
    perform work in order to mitigate an incident.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的服务开始处理生产流量或开始响应用户请求时，你的第一个可靠性目标应该是尽早发现任何问题或事件。高效的检测应该是自动的——程序在检测大多数问题时总是比人类更有效率。每个自动检测都应该通知一个或多个工程师关于事件的信息，以便工程师可以采取措施减轻事件的影响。
- en: The process for establishing such a mechanism for notifying engineers about
    service incidents is called **on-call**. This process helps ensure that at any
    moment in time, service incidents are acknowledged and addressed by the engineers
    responsible for the service.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 建立这种通知工程师关于服务事件机制的流程被称为**值班**。此流程有助于确保在任何时刻，服务事件都由负责该服务的工程师承认和解决。
- en: 'The main ideas behind the on-call process are the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 值班流程背后的主要思想如下：
- en: Engineers can get grouped into **on-call rotations**. Each engineer participating
    in the on-call process repeatedly gets assigned a continuous *shift* (often taking
    1 week), during which they take responsibility for periodically handling notifications
    regarding service-level incidents.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程师可以被分组到**值班轮换**中。每个参与值班流程的工程师都会反复被分配一个连续的**班次**（通常持续1周），在此期间，他们负责定期处理有关服务级别事件的通知。
- en: On-call rotation can have an *escalation policy*—a process of escalating incidents
    in case they remain unresolved. First, an incident gets reported to the *primary*
    on-call engineer of the rotation. If the primary engineer is unavailable, the
    incident gets reported to the *secondary* engineer, and so on.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值班轮换可以有一个**升级策略**——在事件未解决的情况下升级事件的过程。首先，事件报告给轮换的**主要**值班工程师。如果主要工程师不可用，事件报告给**次要**工程师，依此类推。
- en: There can be a *shadow* role, commonly assigned to new engineers. This role
    does not require any response to the incident, but it can be used for getting
    familiar with the on-call process and subscribing to real-time incident notifications.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以有一个*影子*角色，通常分配给新工程师。这个角色不需要对事件做出任何响应，但可以用来熟悉值班流程并订阅实时事件通知。
- en: Each incident triggers one or multiple notifications, notifying the on-call
    engineers about the issue. Each notification must be acknowledged by the responsible
    on-call engineer unless the incident self-resolves (for example, if a service
    stops receiving too many requests and starts operating normally).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个事件都会触发一个或多个通知，通知值班工程师关于问题。除非事件自行解决（例如，如果服务停止接收过多请求并开始正常运作），否则每个通知都必须由负责的值班工程师确认。
- en: You can also set up an *escalation policy* for a rotation—a mechanism for escalating
    the incident notifications if the responsible on-call engineers don’t acknowledge
    them within the configured time. Usually, escalation policy follows the reporting
    chain of the engineering hierarchy—if no engineer acknowledges the incident, the
    incident first triggers a notification to the closest engineering manager, then
    to the person the manager is reporting to, and so on until it reaches the highest
    level (this can even be a CTO at some companies).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以为轮换设置一个*升级策略*——如果负责的值班工程师在配置的时间内未确认事件通知，则触发事件升级的机制。通常，升级策略遵循工程层级报告链——如果没有任何工程师确认事件，事件首先触发通知给最近的工程经理，然后是经理报告的人，依此类推，直到达到最高级别（这甚至可能是某些公司的CTO）。
- en: Having an on-call process is common to most technology companies and teams,
    and the on-call process is pretty similar in most companies across the industry.
    Some popular solutions provide mechanisms for triggering various types of notifications,
    such as SMS, emails, and even phone calls. You can also configure on-call rotations
    and assign them to different services. One of the most popular solutions to on-call
    management is **PagerDuty**—a platform providing a set of tools for automating
    on-call operations, as well as integrations with hundreds of services, including
    Slack, Zoom, and many more. PagerDuty provides all the features we listed earlier,
    allowing engineers to configure on-call rotations for their services and notifying
    them about incidents in different ways. Additionally, it provides an API that
    can be used for both accessing the incident data and triggering new incidents
    from the code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 值班流程对于大多数科技公司和团队来说是常见的，而且大多数公司之间的值班流程都很相似。一些流行的解决方案提供了触发各种类型通知的机制，例如短信、电子邮件，甚至电话。您还可以配置值班轮换并将它们分配给不同的服务。最流行的值班管理解决方案之一是**PagerDuty**——一个提供一系列自动化值班操作工具的平台，以及与数百个服务的集成，包括Slack、Zoom等。PagerDuty提供了我们之前列出的所有功能，允许工程师为他们的服务配置值班轮换，并以不同的方式通知他们关于事件的信息。此外，它提供了一个API，可以用于访问事件数据和从代码中触发新事件。
- en: We are not going to dive into the details of PagerDuty's features and integrations
    in this chapter—I suggest you check the official PagerDuty documentation on their
    website, [https://developer.pagerduty.com/docs](https://developer.pagerduty.com/docs).
    I also suggest you read [*Chapter 12*](B18865_12.xhtml#_idTextAnchor171) before
    establishing an on-call process for your services. It will help you to learn more
    about possible incident detection mechanisms and tools you can utilize in your
    projects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨本章中PagerDuty的功能和集成细节——我建议您查看他们网站上的官方PagerDuty文档，[https://developer.pagerduty.com/docs](https://developer.pagerduty.com/docs)。我还建议您在为您的服务建立值班流程之前阅读[*第12章*](B18865_12.xhtml#_idTextAnchor171)。这将帮助您了解可能的故障检测机制以及您可以在项目中利用的工具。
- en: 'Let’s discuss the common challenges of establishing an on-call process in a
    microservice environment:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论在微服务环境中建立值班流程的常见挑战：
- en: '**Rotation ownership**: Different services may be maintained by different teams,
    so there may be multiple on-call rotations inside a single company. A good practice
    is to have an explicit mapping between each production service and the associated
    on-call rotation so that it is clear which rotation each incident should be reported
    to. In [*Chapter 13*](B18865_13.xhtml#_idTextAnchor181), we will cover the ownership
    aspect of this.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮换所有权**：不同的服务可能由不同的团队维护，因此一个公司内部可能有多个值班轮换。一个好的做法是在每个生产服务和相关的值班轮换之间建立明确的映射，以便清楚地知道每个事件应该报告给哪个轮换。在[*第13章*](B18865_13.xhtml#_idTextAnchor181)中，我们将介绍这个方面的所有权问题。'
- en: '**Cross-service issues**: Some issues, such as database or network failures,
    can span multiple services, so it becomes important to have some centralized team(s)
    that will be able to help with any issues crossing the boundaries of individual
    services.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨服务问题**：一些问题，如数据库或网络故障，可能跨越多个服务，因此拥有一些能够帮助解决跨越单个服务边界的任何问题的集中式团队变得很重要。'
- en: Some companies may have thousands of microservices, so centralized incident
    response teams become crucial. For example, Uber has a dedicated team of engineers
    called *Ring0* that is able to address any widespread incidents and coordinate
    the mitigation of issues that span multiple teams. Having such a team helps to
    dramatically reduce incident mitigation time.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公司可能有数千个微服务，因此集中式的事件响应团队变得至关重要。例如，Uber有一个名为*Ring0*的专用工程师团队，能够处理任何广泛的事件，并协调跨多个团队的问题缓解。拥有这样的团队有助于显著减少事件缓解时间。
- en: 'To better understand what happens next after incidents are detected and acknowledged
    by the engineers, we are going to move now to the next topic: incident management.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解在工程师检测和确认事件后会发生什么，我们现在将转到下一个主题：事件管理。
- en: Incident management
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件管理
- en: Once incidents are detected and acknowledged by the engineers, there are two
    other types of work necessary for improving the service or system reliability—mitigation
    and prevention. Mitigation is required for resolving an open issue unless it gets
    resolved by itself or due to some external changes (for example, an external API
    getting fixed by the owning team). Prevention work is useful for ensuring the
    issue does not happen again. Without a proper prevention response to the incident,
    you may keep fixing the same issue over and over again, spending your time and
    affecting the experience of your system’s users.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦事件被工程师检测和确认，还有两种其他类型的工作对于提高服务或系统可靠性是必要的——缓解和预防。除非问题自行解决或由于某些外部变化（例如，外部API由拥有团队修复），否则需要缓解来解决开放问题。预防工作对于确保问题不再发生是有用的。如果没有适当的预防响应来应对事件，你可能会反复修复相同的问题，浪费时间和影响系统用户的使用体验。
- en: To make the incident mitigation process quick and efficient, especially in a
    large team where engineers may have different levels of understanding of the system,
    there should be enough documentation describing which actions to perform in case
    of an incident. Such documentation is called a **runbook** and should be prepared
    for as many types of detectable incidents as possible. Whenever an on-call engineer
    gets an incident notification, it should be clear from the runbook which steps
    to take to mitigate it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事件缓解过程快速高效，尤其是在一个大型团队中，工程师可能对系统的理解程度不同，应该有足够的文档描述在发生事件时应采取哪些行动。这种文档称为**运行手册**，应该为尽可能多的可检测事件类型准备。每当值班工程师收到事件通知时，运行手册应该清楚地说明缓解事件的步骤。
- en: 'A good runbook should be short and concise and provide clear actionable steps
    that are easy to understand for any engineer. Let’s take this example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的运行手册应该简短、简洁，并提供任何工程师都容易理解的明确可执行步骤。让我们以这个例子为例：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the incident mitigation requires further investigation, include any useful
    links, such as links to the relevant application logs and dashboards. You should
    aim for the lowest possible incident mitigation time—also called **time to repair**
    (**TTR**)—to increase the availability of your service and improve its overall
    health.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件缓解需要进一步调查，请包括任何有用的链接，例如指向相关应用程序日志和仪表板的链接。你应该争取尽可能低的缓解时间——也称为**修复时间**（**TTR**）——以提高服务的可用性并改善其整体健康状况。
- en: 'Once the incident is mitigated, focus on prevention work to ensure you take
    all actions to eliminate its causes, as well as to improve detection and mitigation
    mechanisms, if needed. Multiple companies across the industry use the process
    of writing documents called **incident postmortems** to organize the learnings
    around incidents and make sure each incident involves enough work related to its
    future prevention. An incident postmortem generally consists of the following
    data:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦事件得到缓解，关注预防工作以确保您采取所有行动消除其原因，以及必要时改进检测和缓解机制。跨行业中的多家公司使用编写文档的过程称为 **事件后分析**
    来组织围绕事件的学习，并确保每个事件都涉及足够的相关未来预防工作。事件后分析通常包括以下数据：
- en: Incident title and summary
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件标题和摘要
- en: Authors
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者
- en: When and how the incident was detected and mitigated
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及如何检测和缓解事件
- en: Incident context, in the form of a text or a set of diagrams that can help to
    understand it
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件背景，以文本或一组图表的形式呈现，有助于理解
- en: Root cause
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根本原因
- en: Incident impact
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件影响
- en: Incident timeline
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件时间线
- en: Lessons learned
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经验教训
- en: Action items
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动项
- en: 'A great example of a postmortem document is provided in the famous Google *Site
    Reliability Engineering (SRE)* book, and you can get familiar with it at the following
    link: [https://sre.google/sre-book/example-postmortem/](https://sre.google/sre-book/example-postmortem/).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在著名的谷歌 *《站点可靠性工程（SRE）》* 书籍中提供了一个优秀的故障分析文档示例，您可以在以下链接中熟悉它：[https://sre.google/sre-book/example-postmortem/](https://sre.google/sre-book/example-postmortem/).
- en: 'To get to the root cause of the incident, you can use a technique called **Five
    whys**. The idea of the technique is to keep asking what caused the previously
    mentioned problem until the root cause is found. Let’s take the following **root
    cause analysis** (**RCA**) as an example to understand the technique:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到事件的根本原因，您可以使用称为 **五问法** 的技术。该技术的理念是持续询问导致先前问题的原因，直到找到根本原因。让我们以下面的 **根本原因分析**
    （**RCA**）为例来理解这个技术：
- en: '**Incident**: Rating service returns internal errors to its API callers'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**：评级服务向其API调用者返回内部错误'
- en: '**Root cause analysis**:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**根本原因分析**：'
- en: The rating service started returning internal errors to its API callers due
    to the rating database’s unavailability.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评级服务开始向其API调用者返回内部错误，因为评级数据库不可用。
- en: The rating database became unavailable because of an unexpectedly high request
    load to it.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评级数据库因意外的高请求负载而变得不可用。
- en: The unexpectedly high request load to the rating service was caused by an application
    bug in the movie service.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评级服务意外的高请求负载是由电影服务中的应用程序错误引起的。
- en: In this example, we kept finding the underlying cause of each previous issue
    by using the Five whys technique, until we got to the root cause of the incident
    in just three steps. The technique is very powerful and easy to use, and it can
    help you get to the root cause of even complex issues quite quickly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过使用五问法，逐步找到每个先前问题的根本原因，直到在仅仅三步中找到事件的根本原因。这个技术非常强大且易于使用，并且可以帮助您快速找到复杂问题的根本原因。
- en: Make sure you include and track action items for your incidents. Capturing the
    incident details and identifying the causes isn’t enough for making sure incidents
    are prevented. Prioritizing the action items helps ensure that the most critical
    ones get addressed as early as possible.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您包括并跟踪您事件中的行动项。仅捕获事件细节和识别原因不足以确保防止事件发生。优先处理行动项有助于确保最关键的行动项尽早得到解决。
- en: Now, let’s move to the next reliability process based on periodic testing of
    your possible service failure scenarios.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向基于定期测试您可能的服务故障场景的下一个可靠性流程。
- en: Reliability drills
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可靠性演练
- en: As many system administrators know, it is not enough to have backups of your
    data to guarantee its durability. You also need to ensure that you can restore
    the data from the backups in case of any failure. The same principle applies to
    any part of your service infrastructure—to know that your services are resilient
    to particular failures, you need to perform periodic exercises, called **drills**.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如许多系统管理员所知，仅对数据进行备份以保证其持久性是不够的。您还需要确保在发生任何故障的情况下能够从备份中恢复数据。同样的原则适用于您服务的任何部分——为了知道您的服务对特定故障具有弹性，您需要定期进行练习，称为
    **演练**。
- en: You can perform many possible types of drills. As in the example with the database
    backups, if you have any persistent data stored in a database, you can periodically
    test the ability to back up and restore the data, verifying that your services
    are tolerable to database availability issues. Another example would be network
    drills. You can simulate network issues, such as connectivity loss, by updating
    service routing configuration or any other network settings to check how your
    services behave in case of network unavailability.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以执行许多可能类型的演练。例如，在数据库备份的例子中，如果你在数据库中存储了任何持久数据，你可以定期测试备份和恢复数据的能力，以验证你的服务是否能够容忍数据库可用性问题。另一个例子是网络演练。你可以通过更新服务路由配置或任何其他网络设置来模拟网络问题，例如连接丢失，以检查你的服务在网络不可用的情况下会如何表现。
- en: 'There are multiple benefits of performing reliability drills:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 执行可靠性演练有多个好处：
- en: '**Detect unexpected service failures**: By performing failure drills, you can
    detect some unexpected service errors and panics, that don’t happen in the regular
    mode. Such issues will present themselves in a controlled environment, where engineers
    are ready to stop the drill at any moment and address the detected errors as early
    as possible.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测意外的服务故障**：通过执行故障演练，你可以检测到一些在常规模式下不会发生的意外服务错误和恐慌。这些问题将在一个受控环境中呈现，工程师可以随时停止演练，并尽早解决检测到的错误。'
- en: '**Detect unexpected service dependencies**: Reliability drills often uncover
    unexpected dependencies between the services, such as **transitive dependencies**
    (service A depends on service B, which depends on service C) or even **circular
    dependencies** (two services require each other in order to operate).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测意外的服务依赖性**：可靠性演练经常揭示服务之间意外的依赖关系，例如**传递依赖**（服务A依赖于服务B，而服务B依赖于服务C）或甚至**循环依赖**（两个服务需要彼此才能运行）。'
- en: '**Ability to mitigate future incidents quicker**: By knowing how the services
    operate in case of a failure and how they resolve related issues, you invest in
    improving future incident mitigation.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快地减轻未来事件的能力**：通过了解服务在故障情况下的运行方式和如何解决相关问题，你投资于提高未来事件缓解的能力。'
- en: Drills are often performed as **planned incidents**—incidents that get announced
    in advance and follow the regular incident management process, including the work
    on the postmortem document. The drill postmortem document should include the same
    items as a regular incident, with a focus on improving the mitigation and prevention
    experience. Additionally, engineers should focus on reviewing and updating the
    service runbooks, making sure that the incident mitigation instructions are accurate
    and up to date.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 演练通常作为**计划中的事件**进行——这些事件提前宣布，并遵循常规事件管理流程，包括编写事后报告。演练的事后报告应包括与常规事件相同的条目，重点在于改进缓解和预防体验。此外，工程师应专注于审查和更新服务操作手册，确保事件缓解说明准确且最新。
- en: 'At this point, we have discussed the most important service reliability techniques.
    There are many more interesting topics to cover that are related to service reliability—some
    of them, related to incident detection, we are going to cover in [*Chapter 12*](B18865_12.xhtml#_idTextAnchor171)
    of the book. If you are interested in the topic, I strongly encourage you to read
    the Google *Site Reliability Engineering (SRE)* book, which provides a comprehensive
    guide to various reliability-related techniques. You can find the online version
    of the book by going to the following link: [https://sre.google/sre-book/table-of-contents](https://sre.google/sre-book/table-of-contents).
    The practices that are described in the book are applicable to any microservice,
    so you can always use it as a reference while working on building any type of
    system.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了最重要的服务可靠性技术。还有许多与服务可靠性相关的话题值得探讨——其中一些与事件检测相关的内容，我们将在本书的[*第12章*](B18865_12.xhtml#_idTextAnchor171)中进行介绍。如果你对这个话题感兴趣，我强烈建议你阅读谷歌的*《站点可靠性工程（SRE）*》一书，它提供了各种可靠性相关技术的全面指南。你可以通过以下链接找到这本书的在线版本：[https://sre.google/sre-book/table-of-contents](https://sre.google/sre-book/table-of-contents)。书中描述的实践适用于任何微服务，因此你可以在构建任何类型的系统时始终将其作为参考。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the topic of reliability, describing a set of techniques
    and practices that can help you to make your microservices more resilient to various
    types of failures. You have learned some useful techniques for automating error
    responses of your services and reducing the negative impact of various types of
    issues, such as service overloading and unexpected service shutdowns.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了可靠性的主题，描述了一系列可以帮助你使你的微服务对各种类型的故障更具弹性的技术和实践。你学习了一些有用的技术来自动化服务的错误响应，并减少各种类型问题（如服务过载和意外的服务关闭）的负面影响。
- en: In the final part of the chapter, we discussed various reliability techniques
    based on changes in engineering processes and culture, such as introducing the
    on-call and incident management processes, as well as performing periodic reliability
    drills. The knowledge that you gained from reading this chapter should help you
    to establish a solid foundation for writing reliable microservices.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们讨论了基于工程流程和文化变化的可靠性技术，例如引入值班和事件管理流程，以及进行定期的可靠性演练。从阅读本章中你获得的知识应该有助于你为编写可靠的微服务建立一个坚实的基础。
- en: In the next chapter, we are going to continue our journey into the reliability
    topic and focus on collecting service telemetry data, such as logs, metrics, and
    traces. Service telemetry data is the primary instrument for setting up service
    incident detection, and we will illustrate how to work with each type of telemetry
    data in your microservice code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的可靠性主题之旅，重点关注收集服务遥测数据，如日志、指标和跟踪。服务遥测数据是设置服务事件检测的主要工具，我们将说明如何在你的微服务代码中处理每种类型的遥测数据。
- en: Further reading
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you’d like to learn more, refer to the following resources:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多，请参考以下资源：
- en: '*Timeouts, retries, and backoff with jitter*: https://aws.amazon.com/builders-library/timeouts-retries-and-backoff-with-jitter'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*带有抖动的超时、重试和退避*: https://aws.amazon.com/builders-library/timeouts-retries-and-backoff-with-jitter'
- en: '*Token bucket rate-limiting algorithm*: [https://en.wikipedia.org/wiki/Token_bucket](https://en.wikipedia.org/wiki/Token_bucket)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*令牌桶速率限制算法*: [https://zh.wikipedia.org/wiki/Token_bucket](https://zh.wikipedia.org/wiki/Token_bucket)'
- en: '*PagerDuty documentation*: [https://developer.pagerduty.com/docs](https://developer.pagerduty.com/docs)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PagerDuty 文档*: [https://developer.pagerduty.com/docs](https://developer.pagerduty.com/docs)'
- en: '*Incident postmortems*: [https://www.pagerduty.com/resources/learn/incident-postmortem/](https://www.pagerduty.com/resources/learn/incident-postmortem/)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事件事后分析*: [https://www.pagerduty.com/resources/learn/incident-postmortem/](https://www.pagerduty.com/resources/learn/incident-postmortem/)'
- en: '*Google Site Reliability Engineering (SRE)* website: [https://sre.google/](https://sre.google/)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google 网站可靠性工程 (SRE)* 网站: [https://sre.google/](https://sre.google/)'
- en: '*Google Site Reliability Engineering (SRE)*  book: [https://sre.google/sre-book/table-of-contents](https://sre.google/sre-book/table-of-contents)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google 网站可靠性工程 (SRE)* 书籍: [https://sre.google/sre-book/table-of-contents](https://sre.google/sre-book/table-of-contents)'
