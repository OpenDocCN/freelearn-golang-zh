- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Advanced Topics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级主题
- en: 'If you are reading this chapter – congratulations, you have reached the very
    final part of this book! We have discussed many topics related to microservice
    development, but some remain that are important to cover. The topics in this chapter
    span many areas, from observability and debugging to service ownership and security.
    You may find these topics useful at various points in time: some of them will
    be helpful once you have working services serving production traffic, while others
    will be useful while your services are still in active development.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这一章——恭喜你，你已经到达了这本书的最后一部分！我们已经讨论了许多与微服务开发相关的话题，但还有一些重要的话题需要覆盖。本章涵盖的主题范围很广，从可观察性和调试到服务所有权和安全。你可能会在各个时间点发现这些主题很有用：其中一些在你有正在运行的服务处理生产流量时会有所帮助，而其他一些则在你服务仍在积极开发时会有所帮助。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Profiling Go services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析Go服务
- en: Creating microservice dashboards
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建微服务仪表板
- en: Frameworks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架
- en: Storing microservice ownership data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储微服务所有权数据
- en: Securing microservice communication with JWT
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JWT保护微服务通信
- en: Let’s proceed to the first section of this chapter, which covers service profiling.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入本章的第一部分，它涵盖了服务分析。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need Go 1.11+ or above. Additionally, you
    will need the following tools:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，你需要Go 1.11或更高版本。此外，你还需要以下工具：
- en: '**Graphviz**: [https://graphviz.org](https://graphviz.org)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Graphviz**：[https://graphviz.org](https://graphviz.org)'
- en: '**Docker**: [https://www.docker.com](https://www.docker.com)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：[https://www.docker.com](https://www.docker.com)'
- en: 'You can find the code examples for this chapter on GitHub: https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter13.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码示例：https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter13。
- en: Profiling Go services
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析Go服务
- en: 'In this section, we are going to review a technique called **profiling**, which
    involves collecting real-time performance data of a running process, such as a
    Go service. Profiling is a powerful technique that can help you analyze various
    types of service performance data:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一种称为**分析**的技术，它涉及收集运行进程的实时性能数据，例如Go服务。分析是一种强大的技术，可以帮助你分析各种类型的服务性能数据：
- en: '**CPU usage**: Which operations used the most CPU power and what was the distribution
    of CPU usage among them?'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU使用率**：哪些操作使用了最多的CPU功率，它们之间的CPU使用率分布是怎样的？'
- en: '**Heap allocation**: Which operations used heap (dynamic memory allocated in
    Go applications) and what amount of memory was used?'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆分配**：哪些操作使用了堆（Go应用程序中分配的动态内存）以及使用了多少内存？'
- en: '**Call graph**: In which order were service functions executed?'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用图**：服务函数的执行顺序是怎样的？'
- en: 'Profiling may help you in different situations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 分析可以在不同的情况下帮助你：
- en: '**Identifying CPU-intensive logic**: At some point, you may notice that your
    service is consuming most of your CPU power. To understand this problem, you can
    collect the CPU profile – a graph showing the CPU usage of various service components,
    such as individual functions. Components that consume too much CPU power may indicate
    various issues, such as inefficient implementations or code bugs.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别CPU密集型逻辑**：在某个时刻，你可能会注意到你的服务消耗了大部分的CPU功率。为了理解这个问题，你可以收集CPU分析——一个显示各种服务组件（如单个函数）CPU使用的图表。消耗过多CPU功率的组件可能表明各种问题，如实现效率低下或代码错误。'
- en: '**Capturing the service memory footprint**: Similar to high CPU consumption,
    your service may be using too much memory (for example, to allocate too much data
    to the heap), resulting in occasional service crashes due to out-of-memory panics.
    Performing memory profiling may help you analyze the memory usage of various parts
    of your service and find components that have unexpectedly high memory usage.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕获服务的内存占用**：类似于高CPU消耗，你的服务可能使用了过多的内存（例如，为堆分配过多的数据），这可能导致服务偶尔因内存不足而崩溃。进行内存分析可以帮助你分析服务各个部分的内存使用情况，并找到意外占用内存过多的组件。'
- en: 'Let’s illustrate how to profile Go services using the pprof tool, which is
    a part of the Go SDK. To visualize the results of the tool, you will need to install
    the Graphviz library: [https://graphviz.org/](https://graphviz.org/).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用Go SDK的一部分pprof工具来展示如何分析Go服务，为了可视化工具的结果，你需要安装Graphviz库：[https://graphviz.org/](https://graphviz.org/)。
- en: 'We will use the metadata service that we implemented in [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027)
    as an example. Open the `metadata/cmd/main.go` file and add the `flag` package
    to the `imports` block. Then, add the following code to the beginning of the main
    function, immediately after the logger initialization:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以我们在[*第 2 章*](B18865_02.xhtml#_idTextAnchor027)中实现的元数据服务为例。打开 `metadata/cmd/main.go`
    文件，并将 `flag` 包添加到 `imports` 块中。然后，在主函数的开始处，紧接在日志初始化之后，添加以下代码：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the code we just added, we introduced an additional flag called `simulatecpuload`
    that will let us simulate a CPU-intensive operation for our profiling. We also
    started an HTTP handler that we will use to access the profiler data from the
    command line.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的代码中，我们引入了一个额外的标志 `simulatecpuload`，它将允许我们模拟一个 CPU 密集型操作以进行分析。我们还启动了一个
    HTTP 处理器，我们将使用它从命令行访问分析器数据。
- en: 'Now, let’s add another function to the same file that will run a continuous
    loop and execute some CPU-intensive operations. We will generate random 1,024-byte
    arrays and calculate their md5 hashes (you can read about the md5 operation in
    the comments of its Go package at https://pkg.go.dev/crypto/md5). Our selection
    of such logic is fully arbitrary: we could easily choose any other operation that
    would consume some visible part of the CPU load.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向同一文件添加另一个函数，该函数将运行一个连续循环并执行一些 CPU 密集型操作。我们将生成随机的 1,024 字节数组并计算它们的 md5
    哈希（你可以在其 Go 包的注释中阅读有关 md5 操作的内容，网址为 https://pkg.go.dev/crypto/md5）。我们选择这种逻辑是完全随机的：我们很容易选择任何其他会消耗
    CPU 负载可见部分的操作。
- en: 'Add the following code to the `main.go` file that we just updated:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到我们刚刚更新的 `main.go` 文件中：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we are ready to test our profiling logic. Run the service with the `--``simulatecpuload`
    argument:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好测试我们的分析逻辑。使用 `--simulatecpuload` 参数运行服务：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, execute the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下命令：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The command should take 5 seconds to complete. If it executes successfully,
    the pprof tool will be running, as shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 命令应该需要 5 秒才能完成。如果执行成功，pprof 工具将运行，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Type `web` in the command prompt of the tool and press *Enter*. If everything
    worked well, you will be redirected to a browser window containing a CPU profile
    graph:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具的命令提示符中键入 `web` 并按 *Enter*。如果一切正常，你将被重定向到一个包含 CPU 配置文件图的浏览器窗口：
- en: '![Figure 13.1 – Go CPU profile example'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1 – Go CPU 配置文件示例'
- en: '](img/Figure_13.1_B18865.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.1_B18865.jpg)'
- en: Figure 13.1 – Go CPU profile example
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – Go CPU 配置文件示例
- en: 'Let’s walk through the data from the graph to understand how to interpret it.
    Each node on the graph includes the following data:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遍历图中的数据，了解如何解释它。图中的每个节点都包含以下数据：
- en: Package name
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名称
- en: Function name
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名称
- en: Elapsed time and the total time of the execution
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时间和执行总时间
- en: For example, the `heavyOperation` function took just 0.01 seconds, but all the
    operations that were executed in it (including all function calls inside it) took
    4.39 seconds, taking most of the elapsed time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`heavyOperation` 函数仅花费了 0.01 秒，但其中执行的所有操作（包括其内部的所有函数调用）共花费了 4.39 秒，占去大部分的运行时间。
- en: 'If you walk through the graph, you will see the distribution of the elapsed
    time by sub-operations. In our case, `heavyOperation` executed two functions that
    got recorded by the CPU profiler: `md5.Write` and `rand.Read`. The `md5.Write`
    function took 2.78 seconds in total, while `rand.Read` took 1.59 seconds of the
    execution time. Level by level, you can analyze the calls and find the CPU-intensive
    functions.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遍历这个图，你会看到子操作的时间分布。在我们的例子中，`heavyOperation` 执行了两个被 CPU 分析器记录的函数：`md5.Write`
    和 `rand.Read`。`md5.Write` 函数总共花费了 2.78 秒，而 `rand.Read` 花费了 1.59 秒的执行时间。逐层分析，你可以找到
    CPU 密集型函数。
- en: When working with the CPU profiler data, notice the functions that take the
    most processing time. Such functions are illustrated as larger rectangles to help
    you find them. If you notice that some functions have unexpectedly high processing
    time, spend some time analyzing their code to see whether there is any opportunity
    to optimize them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理 CPU 分析器数据时，注意那些花费最多处理时间的函数。这些函数被表示为更大的矩形，以帮助你找到它们。如果你注意到某些函数的处理时间异常高，花些时间分析它们的代码，看看是否有任何机会进行优化。
- en: 'Now, let’s illustrate another example of profiler data. This time, we will
    be capturing a **heap profile** – a profile showing dynamic memory allocation
    by a Go process. Run the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过另一个分析器数据的示例。这次，我们将捕获一个**堆分析** – 一个显示 Go 进程动态内存分配的分析。运行以下命令：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Similar to the previous example, successfully executing this command should
    run the pprof tool, where we can execute a web command. The result will contain
    the following graph:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子类似，成功执行此命令应运行pprof工具，在那里我们可以执行web命令。结果将包含以下图表：
- en: '![Figure 13.2 – Go heap profile example'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2 – Go堆配置文件示例'
- en: '](img/Figure_13.2_B18865.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.2_B18865.jpg)'
- en: Figure 13.2 – Go heap profile example
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – Go堆配置文件示例
- en: This diagram is similar to the CPU profile. The last line inside each node shows
    the ratio between the memory used by the function and the total heap memory allocated
    by the process.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此图与CPU配置文件类似。每个节点内的最后一行显示了函数使用的内存与进程分配的总堆内存之间的比率。
- en: 'In our example, three high-level operations are consuming the heap memory:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，有三个高级操作正在消耗堆内存：
- en: '**api.serviceRegister**: A function that registers a service via the Consul
    API'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**api.serviceRegister**：一个通过Consul API注册服务的函数'
- en: '`zap` library'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zap`库'
- en: '**trace.init**: Initializes the tracing logic'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**trace.init**：初始化跟踪逻辑'
- en: Looking at the heap profiler data, it’s easy to find functions allocating an
    unexpectedly high amount of heap memory. Similar to CPU profiler graphs, heap
    profilers display the functions that have the highest heap allocation as larger
    rectangles, making it easier to visualize the most memory-consuming functions.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察堆配置文件数据，很容易找到分配意外大量堆内存的函数。与CPU配置文件图类似，堆配置文件显示具有最高堆分配的函数以更大的矩形显示，这使得可视化最消耗内存的函数更容易。
- en: 'I suggest that you practice with the pprof tool and try the other operations
    it provides. Being able to profile Go applications is a highly valuable skill
    in production debugging that should help you optimize your services and solve
    different performance-related issues. The following are some other useful tips
    for profiling Go services:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我建议您使用pprof工具进行练习，并尝试它提供的其他操作。能够对Go应用程序进行性能分析是生产调试中非常宝贵的技能，这有助于您优化服务并解决不同的性能相关问题。以下是一些其他有用的Go服务性能分析技巧：
- en: You can profile Go tests without adding any extra logic to your code. Running
    the `go test` command with the `-cpuprofile` and `-memprofile` flags will capture
    the CPU and memory profiles of your logic, respectively.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在不向代码添加任何额外逻辑的情况下对Go测试进行性能分析。使用带有`-cpuprofile`和`-memprofile`标志的`go test`命令将分别捕获您的逻辑的CPU和内存配置文件。
- en: The `top` command of the pprof tool is a convenient way of showing the top memory
    consumers. There is also the `top10` command, which shows the top 10 memory consumers.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pprof工具的`top`命令是一种方便显示顶级内存消费者的方式。还有一个`top10`命令，它显示了前10个内存消费者。
- en: Using the `roroutine` mode of the pprof tool, you can get a profile of all used
    goroutines, as well as their stack traces.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pprof工具的`goroutine`模式，您可以获取所有使用goroutine的配置文件，以及它们的堆栈跟踪。
- en: 'Now that we have covered the basics of Go profiling, let’s move on to the next
    topic of this chapter: service dashboarding.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了Go性能分析的基础知识，让我们继续本章的下一个主题：服务仪表板化。
- en: Creating microservice dashboards
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建微服务仪表板
- en: In the previous two chapters, we reviewed various ways of working with service
    metrics. In [*Chapter 11*](B18865_11.xhtml#_idTextAnchor152), we demonstrated
    how to collect the service metrics, while in [*Chapter 12*](B18865_12.xhtml#_idTextAnchor171),
    we showed you how to aggregate and query them using the Prometheus tool. In this
    section, we will describe one more way of accessing the metrics data that can
    help you explore your metrics and plot them as charts. The technique that we will
    cover is called **dashboarding** and is useful for visualizing various service
    metrics.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们回顾了与服务指标一起工作的各种方法。在[*第11章*](B18865_11.xhtml#_idTextAnchor152)中，我们演示了如何收集服务指标，而在[*第12章*](B18865_12.xhtml#_idTextAnchor171)中，我们展示了如何使用Prometheus工具聚合和查询它们。在本节中，我们将描述另一种访问指标数据的方法，这可以帮助您探索指标并将它们作为图表绘制。我们将介绍的技术称为**仪表板化**，它对于可视化各种服务指标非常有用。
- en: 'Let’s provide an example of a dashboard – a set of charts representing different
    metrics. The following figure shows the dashboard of a Go service containing some
    system-level metrics, such as the goroutine count, the number of Go threads, and
    allocated memory size:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提供一个仪表板的例子——一组代表不同指标的图表。以下图显示了包含一些系统级指标（如goroutine数量、Go线程数量和分配的内存大小）的Go服务仪表板：
- en: '![Figure 13.3 – Go process dashboard example from the Grafana tool'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 – 使用Grafana工具的Go进程仪表板示例'
- en: '](img/Figure_13.3_B18865.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 – Go进程仪表板示例](img/Figure_13.3_B18865.jpg)'
- en: Figure 13.3 – Go process dashboard example from the Grafana tool
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – Grafana 工具的 Go 进程仪表板示例
- en: 'Dashboards help visualize various types of data, such as time series datasets,
    allowing us to analyze service performance. The following are some other use cases
    for using dashboards:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板有助于可视化各种类型的数据，例如时间序列数据集，使我们能够分析服务性能。以下是一些使用仪表板的其它用例：
- en: '**Debugging**: Being able to visualize various service performance metrics
    helps us identify service issues and notice any anomalies in system activity'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**：能够可视化各种服务性能指标有助于我们识别服务问题并注意系统活动中的任何异常'
- en: '**Data correlation**: Having a side-by-side representation of multiple service
    performance charts helps us find related events, such as an increase in server
    errors or a sudden drop in available memory'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据相关性**：多个服务性能图表并排显示有助于我们找到相关事件，例如服务器错误增加或可用内存突然下降'
- en: It’s a great practice to have a dashboard for each of your services, as well
    as some dashboards that span all services, to get some high-level system performance
    data, such as the number of active service instances, network throughput, and
    much more.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个服务设置一个仪表板，以及一些跨越所有服务的仪表板，以获取一些高级系统性能数据，例如活动服务实例的数量、网络吞吐量等等，这是一个很好的实践。
- en: 'Let’s demonstrate how to set up an example dashboard for the Prometheus data
    that we collected in [*Chapter 12*](B18865_12.xhtml#_idTextAnchor171). For this,
    we will use the open source tool called Grafana, which has built-in support for
    various types of time series data and provides a convenient user interface for
    setting up different dashboards. Follow these instructions to set up a Grafana
    dashboard:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示如何为我们在 [*第 12 章*](B18865_12.xhtml#_idTextAnchor171) 中收集的 Prometheus 数据设置一个示例仪表板。为此，我们将使用名为
    Grafana 的开源工具，它内置了对各种类型的时间序列数据的支持，并提供了一个方便的用户界面来设置不同的仪表板。按照以下说明设置 Grafana 仪表板：
- en: 'Execute the following command to run the Grafana Docker image:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以运行 Grafana Docker 镜像：
- en: '[PRE6]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command should fetch and run the open source version of Grafana (Grafana
    also comes in an enterprise version, which we won’t cover in this chapter) and
    expose port `3000` so that we can access it via HTTP.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应获取并运行 Grafana 的开源版本（Grafana 还有一个企业版本，我们将在本章中不涉及）并暴露端口 `3000`，以便我们可以通过 HTTP
    访问。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Similar to Prometheus, Grafana is also written in Go and is another example
    of a popular open source Go project widely used across the software development
    industry.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Prometheus 类似，Grafana 也是用 Go 编写的，它是广泛用于软件开发行业的流行开源 Go 项目的另一个例子。
- en: Once you’ve run the preceding command, open [http://localhost:3000](http://localhost:3000)
    in your browser. This will lead you to the Grafana login page. By default, the
    Docker-based version of Grafana includes a user with `admin` as both its username
    and password, so you can use these credentials to log in.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行上述命令后，在您的浏览器中打开 [http://localhost:3000](http://localhost:3000)。这将带您到 Grafana
    登录页面。默认情况下，基于 Docker 的 Grafana 版本包括一个用户，其用户名和密码都是 `admin`，因此您可以使用这些凭据登录。
- en: 'From the side menu, select **Configuration**:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从侧边菜单中选择 **配置**：
- en: '![Figure 13.4 – Grafana data source configuration menu'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4 – Grafana 数据源配置菜单'
- en: '](img/Figure_13.4_B18865.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.4_B18865.jpg)'
- en: Figure 13.4 – Grafana data source configuration menu
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – Grafana 数据源配置菜单
- en: 'On the **Configuration** page, click on the **Data sources** menu item, then
    click **Add data source** and choose **Prometheus** from the list of available
    data sources. Doing so will open a new page that displays Prometheus settings.
    In the **HTTP** section, set **URL** to [http://host.docker.internal:9090](http://host.docker.internal:9090),
    as shown in the following screenshot:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **配置** 页面上，点击 **数据源** 菜单项，然后点击 **添加数据源** 并从可用数据源列表中选择 **Prometheus**。这样做将打开一个新页面，显示
    Prometheus 设置。在 **HTTP** 部分，将 **URL** 设置为 [http://host.docker.internal:9090](http://host.docker.internal:9090)，如下截图所示：
- en: '![Figure 13.5 – Grafana configuration for a Prometheus data source'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.5 – Grafana Prometheus 数据源配置'
- en: '](img/Figure_13.5_B18865.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.5_B18865.jpg)'
- en: Figure 13.5 – Grafana configuration for a Prometheus data source
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – Grafana Prometheus 数据源配置
- en: Now, you can click the **Save and test** button at the bottom of the page, which
    should let you know whether the operation was successful. If you did everything
    well, Grafana should be ready to display your metrics from Prometheus.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以在页面底部点击 **保存并测试** 按钮，这将通知您操作是否成功。如果您一切都做得很好，Grafana 应该准备好显示来自 Prometheus
    的指标。
- en: 'From the side menu, click on **New dashboard**:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从侧边菜单中，点击**新建仪表板**：
- en: '![Figure 13.6 – Grafana’s New dashboard menu item for dashboard creation'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6 – Grafana的“新建仪表板”菜单项用于创建仪表板'
- en: '](img/Figure_13.6_B18865.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.6_B18865.jpg]'
- en: Figure 13.6 – Grafana’s New dashboard menu item for dashboard creation
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – Grafana新建仪表板菜单项用于创建仪表板
- en: This should open an empty dashboard page.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该打开一个空白的仪表板页面。
- en: Click on the **Add a new panel** button on this dashboard page; you will be
    redirected to the panel creation page.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此仪表板页面上点击**添加新面板**按钮；您将被重定向到面板创建页面。
- en: 'A panel is a core element of a Grafana dashboard and its purpose is to visualize
    the provided dataset. To illustrate how to use it, let’s select our Prometheus
    data source and some of the metrics that it already has. On the panel view, choose
    `process_open_fds` element and select it. Now, click on the **Run queries** button;
    you should see the following view:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 面板是Grafana仪表板的核心元素，其目的是可视化提供的数据集。为了说明如何使用它，让我们选择我们的Prometheus数据源以及它已经拥有的某些指标。在面板视图中，选择`process_open_fds`元素并选择它。现在，点击**运行查询**按钮；您应该看到以下视图：
- en: '![Figure 13.7 – Grafana panel view'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7 – Grafana面板视图'
- en: '](img/Figure_13.7_B18865.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.7_B18865.jpg]'
- en: Figure 13.7 – Grafana panel view
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – Grafana面板视图
- en: We just configured the dashboard panel to display the `process_open_fds` time
    series stored in Prometheus. Each data point on the chart shows the value of the
    time series at a different time, displayed below the chart. On the right-hand
    panel, you can set the panel title to **Open fd count**. Now, save the dashboard
    by clicking the **Apply** button provided in the top menu. You will be redirected
    to the dashboard page.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚配置了仪表板面板以显示存储在Prometheus中的`process_open_fds`时间序列。图表上的每个数据点都显示了时间序列在不同时间点的值，显示在图表下方。在右侧面板中，您可以设置面板标题为**打开文件描述符计数**。现在，通过点击顶部菜单中提供的**应用**按钮保存仪表板。您将被重定向到仪表板页面。
- en: In the top menu, you will find the `go_gc_duration_seconds` metric, you will
    add a new panel to the dashboard that will visualize the `go_gc_duration_seconds`
    time series from Prometheus.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部菜单中，您将找到`go_gc_duration_seconds`指标，您将添加一个新的面板到仪表板，用于可视化Prometheus中的`go_gc_duration_seconds`时间序列。
- en: 'The resulting dashboard should look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的仪表板应该看起来像这样：
- en: '![Figure 13.8 – Example Grafana dashboard'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8 – 示例Grafana仪表板'
- en: '](img/Figure_13.8_B18865.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.8_B18865.jpg]'
- en: Figure 13.8 – Example Grafana dashboard
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 – 示例Grafana仪表板
- en: We just created an example dashboard that has two panels that display some existing
    Prometheus metrics. You can use the same approach to create any dashboards for
    your services, as well as high-level dashboards showing the system-global metrics,
    such as the total number of API requests, network throughput, or the total number
    of all service instances.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个示例仪表板，它包含两个面板，用于显示一些现有的Prometheus指标。您可以使用相同的方法为您的服务创建任何仪表板，以及显示系统全局指标的高级仪表板，例如API请求总数、网络吞吐量或所有服务实例的总数。
- en: 'Let’s provide some examples of metrics that can be useful for setting up a
    dashboard for an individual service. This includes *The Four Golden Signals*,
    which we mentioned in [*Chapter 12*](B18865_12.xhtml#_idTextAnchor171):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提供一些有用的指标示例，这些指标可以用于为单个服务设置仪表板。这包括我们提到的[*第12章*](B18865_12.xhtml#_idTextAnchor171)中的*四个黄金信号*：
- en: '**Client error rate**: The ratio between client errors (such as invalid or
    unauthenticated requests) and all requests to the service'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端错误率**：客户端错误（如无效或未经认证的请求）与对服务的所有请求之间的比率'
- en: '**Server error rate**: The ratio between server errors (such as database write
    errors) and all requests to the service'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器错误率**：服务器错误（如数据库写入错误）与对服务的所有请求之间的比率'
- en: '**API throughput**: Number of API requests per second/minute'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API吞吐量**：每秒/每分钟的API请求数量'
- en: '**API latency**: API request processing latency, usually measured in percentiles,
    such as p90/p95/p99 (you can learn about percentiles by reading this blog post:
    https://www.elastic.co/blog/averages-can-dangerous-use-percentile)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API延迟**：API请求处理延迟，通常以百分位数衡量，如p90/p95/p99（您可以通过阅读这篇博客了解百分位数：https://www.elastic.co/blog/averages-can-dangerous-use-percentile）'
- en: '**CPU utilization**: Current usage of CPUs (100% means all CPUs are fully loaded)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU利用率**：CPU当前的使用情况（100%表示所有CPU都处于完全负载状态）'
- en: '**Memory utilization**: Ratio between used and total memory across all service
    instances'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存利用率**：所有服务实例中已用内存与总内存之间的比率'
- en: '**Network throughput**: Total amount of network write/read traffic per second/minute'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络吞吐量**：每秒/每分钟的网络读写流量总量'
- en: Depending on the operations performed by your service (for example, database
    writes or reads, cache usage, Kafka consumption, or production), you may wish
    to include additional panels that will help you visualize your service performance.
    Make sure that you cover all the high-level functionality of the service so that
    you can visually notice any service malfunctions on your dashboards.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的服务执行的操作（例如，数据库写入或读取、缓存使用、Kafka消费或生产），您可能希望包含额外的面板，以帮助您可视化服务性能。确保您涵盖了服务的高级所有功能，这样您就可以在仪表板上直观地注意到任何服务故障。
- en: 'The Grafana tool, which we used in our example, also supports lots of different
    visualization options, such as displaying tables, heatmaps, numerical values,
    and much more. We will not cover these features in this chapter, but you can get
    familiar with them by reading the official documentation: https://grafana.com/docs/.
    Using the full power of Grafana will help you set up excellent dashboards for
    your services, simplifying your debugging and performance analysis.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中使用的Grafana工具也支持许多不同的可视化选项，例如显示表格、热图、数值等。我们不会在本章中介绍这些功能，但您可以通过阅读官方文档来熟悉它们：https://grafana.com/docs/。利用Grafana的全部功能将帮助您为您的服务设置出色的仪表板，简化您的调试和性能分析。
- en: Now, let’s move on to the next section, where we will describe Go frameworks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入下一节，我们将描述Go框架。
- en: Frameworks
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架
- en: In [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027), we covered the topic of
    the Go project structure, as well as some common patterns of organizing your Go
    code. The code organization principles that we described are generally based on
    conventions – written agreements or statements that define specific rules for
    naming and placing Go files. Some of the conventions that we followed were proposed
    by the authors of the Go language, while others are commonly used and proposed
    by authors of various Go libraries.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B18865_02.xhtml#_idTextAnchor027)中，我们讨论了Go项目结构的话题，以及一些组织Go代码的常见模式。我们描述的代码组织原则通常基于约定——书面协议或声明，用于定义命名和放置Go文件的特定规则。我们遵循的一些约定是由Go语言的作者提出的，而其他则是被各种Go库的作者广泛使用并提出的。
- en: While conventions play an important role in establishing the common principles
    of organizing Go code, there are other ways of enforcing specific code structures.
    One such way is using frameworks, which we are going to cover in this section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然约定在建立组织Go代码的共同原则方面发挥着重要作用，但还有其他方法可以强制执行特定的代码结构。其中一种方法就是使用框架，我们将在本节中介绍。
- en: 'Generally speaking, **frameworks** are tools that establish a structure for
    various components of your code. Let’s take the following code snippet as an example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，**框架**是用于建立代码各种组件结构的工具。以下代码片段作为例子：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are registering an HTTP handler function and letting it handle HTTP
    requests on the `localhost:8080/echo` endpoint. The code for our example is extremely
    simple, yet it does a lot of background work (you can check the source of the
    `net/http` package to see how complex the internal part of the HTTP handling logic
    is) to start an HTTP server, accept all incoming requests, and respond to them
    by executing the function provided by us. Most importantly, our code allows us
    to add additional HTTP handlers by following the same format of calling the `http.HandleFunc`
    function and passing handler functions to it. The `net/http` library that we used
    in our example established a structure for handling HTTP calls to various endpoints,
    acting as a framework for our Go application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在注册一个HTTP处理函数，并让它处理`localhost:8080/echo`端点的HTTP请求。我们示例中的代码非常简单，但它做了大量的后台工作（您可以检查`net/http`包的源代码，以了解HTTP处理逻辑的内部部分是多么复杂），以启动HTTP服务器、接受所有传入的请求并通过执行我们提供的函数来响应它们。最重要的是，我们的代码允许我们通过遵循调用`http.HandleFunc`函数和向其传递处理函数的相同格式来添加额外的HTTP处理程序。我们示例中使用的`net/http`库为处理各种端点的HTTP调用建立了结构，充当了我们Go应用程序的框架。
- en: 'The authors of the `net/http` package were able to add additional HTTP endpoint
    handlers (provided by the `http.HandleFunc` function) by following a pattern called
    `net/http` package) takes control of the execution flow by calling the other components
    of it (in our case, the function provided as an argument to `http.HandleFunc`).
    In our example, the moment we call the `http.ListenAndServe` function, the `net/http`
    package takes control of executing the HTTP handler functions: each time the HTTP
    server receives an incoming request, our function is called automatically.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包的作者能够通过遵循名为`net/http`包的模式添加额外的HTTP端点处理器（由`http.HandleFunc`函数提供），该模式通过调用其其他组件（在我们的情况下，是作为`http.HandleFunc`参数提供的函数）来控制执行流程。在我们的例子中，当我们调用`http.ListenAndServe`函数时，`net/http`包就控制了HTTP处理器函数的执行：每当HTTP服务器收到传入的请求时，我们的函数会自动被调用。'
- en: IaC is a primary mechanism of most frameworks that allows them to establish
    a foundation for various parts of application code. In general, most frameworks
    work by taking control of an application, or a part of it, and handling some routing
    operations, such as resource management (opening and closing incoming connections,
    writing and reading files, and so on), serialization and deserialization, and
    many more.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: IaC（基础设施即代码）是大多数框架的主要机制，它使它们能够为应用程序代码的各个部分建立基础。一般来说，大多数框架通过控制应用程序或其一部分，并处理一些路由操作来工作，例如资源管理（打开和关闭传入连接、读写文件等）、序列化和反序列化，以及更多。
- en: 'What are the primary use cases for using Go frameworks? We can list some of
    the most common ones:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go框架的主要用例有哪些？我们可以列出一些最常见的用例：
- en: '**Writing web servers**: Similar to our example of an HTTP server, there can
    be other types of web servers handling requests to different endpoints using different
    protocols, such as Apache Thrift or gRPC.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写网络服务器**：类似于我们关于HTTP服务器的例子，可以有其他类型的网络服务器，它们使用不同的协议处理对不同端点的请求，例如Apache Thrift或gRPC。'
- en: '**Async event processing**: There are libraries for various asynchronous communication
    tools, such as Apache Kafka, that help organize code in an IoC way by passing
    handler functions for various types of events (such as Kafka messages belonging
    to different topics), which get called automatically each time there is a new
    unprocessed message.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步事件处理**：有各种异步通信工具的库，如Apache Kafka，它们通过传递各种类型事件（例如属于不同主题的Kafka消息）的处理函数来以IoC（控制反转）方式组织代码，这些处理函数会在每次有新的未处理消息时自动调用。'
- en: 'It is important to note that frameworks have some significant downsides:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，框架有一些显著的缺点：
- en: '**Harder to debug and understand the execution flow**: In addition to taking
    control of the execution flow, frameworks also perform lots of background work
    that is hidden from developers. Because of this, it is usually much harder to
    understand how your code is being executed, as well as to debug various issues,
    such as initialization errors (you may find more information on this in the following
    article: [https://www.baeldung.com/cs/framework-vs-library](https://www.baeldung.com/cs/framework-vs-library)).'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更难调试和理解执行流程**：除了控制执行流程外，框架还执行大量对开发者隐藏的背景工作。正因为如此，通常很难理解代码是如何执行的，以及调试各种问题，例如初始化错误（你可以在以下文章中找到更多关于此的信息：[https://www.baeldung.com/cs/framework-vs-library](https://www.baeldung.com/cs/framework-vs-library))。'
- en: '**Steeper learning curve**: Frameworks generally require a good understanding
    of the logic and abstractions they provide. This requires developers to spend
    more time reading the related documentation or learning some key lessons in practice.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习曲线更陡峭**：框架通常需要开发者对它们提供的逻辑和抽象有很好的理解。这要求开发者花费更多时间阅读相关文档或在实践中学习一些关键经验。'
- en: '`reflect` (https://pkg.go.dev/reflect). Such operations are performed when
    executing a program, making it hard to catch various types of issues, such as
    the incorrect implementation of interfaces or invalid naming.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflect`（https://pkg.go.dev/reflect）。这些操作在程序执行时进行，使得捕捉各种类型的问题变得困难，例如接口实现不正确或无效的命名。'
- en: 'When deciding on using a specific framework, you should do some analysis and
    compare the advantages it provides to you with the downsides it brings, especially
    in the long term. Many developers underestimate the complexity that frameworks
    bring to them or the other developers in their organizations: most frameworks
    perform a fair amount of *magic* to provide a convenient code structure to application
    developers. In general, you should always start from a simpler option (in our
    case, not using a particular framework) and only decide to use a framework if
    its benefits outweigh its downsides.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用特定的框架时，您应该做一些分析，比较它为您提供的优势与它带来的劣势，尤其是在长期内。许多开发者低估了框架给他们或他们组织中的其他开发者带来的复杂性：大多数框架都进行了一定程度的“魔法”操作，为应用开发者提供方便的代码结构。一般来说，您应该始终从一个更简单的选项（在我们的案例中，即不使用特定的框架）开始，并且只有在框架的好处超过其劣势时才决定使用框架。
- en: Now that we have discussed the topic of frameworks, let’s move on to the next
    section, where we will describe the different aspects of microservice ownership.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了框架的话题，接下来让我们进入下一节，我们将描述微服务所有权的不同方面。
- en: Storing microservice ownership data
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储微服务所有权数据
- en: 'One of the key benefits of using microservice architectures is the ability
    to distribute their development: each service can be developed and maintained
    by a separate team, and teams can be distributed across the globe. While the distributed
    development model helps different teams build various parts of their systems independently,
    it brings some new challenges, such as service ownership.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构的一个关键好处是能够分散其开发：每个服务可以由一个独立的团队开发和维护，并且团队可以分布在全球各地。虽然分布式开发模型有助于不同团队独立构建其系统的各个部分，但它也带来了一些新的挑战，例如服务所有权。
- en: To illustrate the problem of service ownership, imagine that you are working
    in a company with thousands of microservices. One day, the security engineers
    of your company find out that there is a critical security vulnerability in a
    popular Go library that is used in most of the company’s services. How can you
    communicate with the right teams and find out who would be responsible for making
    the changes in each service?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明服务所有权的问题，想象一下您正在一家拥有数千个微服务的公司工作。有一天，您的公司的安全工程师发现，在大多数公司服务中使用的流行Go库中存在一个关键的安全漏洞。您如何与正确的团队沟通，找出谁将负责对每个服务进行更改？
- en: There are numerous companies with thousands of microservices. In such companies,
    it becomes impossible to remember which team and which developers are responsible
    for each of them. In such companies, it becomes crucial to find a solution to
    the service ownership problem.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多公司拥有数千个微服务。在这样的公司中，记住哪个团队和哪些开发者负责每个服务变得不可能。在这样的公司中，找到解决服务所有权问题的解决方案变得至关重要。
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While we are discussing the ownership problem for microservices, the same principles
    apply to many other types of technological assets, such as Kafka topics and database
    tables.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在讨论微服务的所有权问题时，同样的原则也适用于许多其他类型的科技资产，例如Kafka主题和数据库表。
- en: How can we define service ownership?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何定义服务所有权？
- en: 'There are many different ways of doing this, each of which is equally important
    for some specific use cases:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法来做这件事，每种方法对于某些特定的用例来说都同等重要：
- en: '**Accountability**: Which person/entity is accountable for the service and
    who can act as the primary point of contact or the main authority for it?'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问责制**：哪个人/实体对服务负责，谁可以充当其主要联系点或主要权威？'
- en: '**Support**: Who is going to provide support for the service, such as a service
    bug, feature request, or user question?'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持**：谁将提供对服务的支持，例如服务中的bug、功能请求或用户问题？'
- en: '**On-call**: Who is currently on-call for the service? Who can we contact in
    case of an emergency issue?'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值班**：目前谁负责该服务的值班？在紧急情况下我们可以联系谁？'
- en: 'As you can see, there are many ways of interpreting the word ownership, depending
    on the use case. Let’s look at some ways to define each role, starting with accountability:
    who should be accountable, or liable, for a service?'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，根据使用场景的不同，对“所有权”一词的解释有很多种。让我们看看定义每个角色的几种方法，从问责制开始：谁应该对服务负责，或者说谁应该对服务承担责任？
- en: 'In most organizations, liability is attributed to engineering managers: every
    engineering manager acts as an accountable individual for some unique domain.
    If you define a mapping between your services and the engineering managers that
    are responsible for them, you can solve the service accountability problem by
    allowing them to easily find the relevant point of contact, such as an engineering
    manager that is liable for it.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数组织中，责任归咎于工程经理：每位工程经理都作为某个独特领域的责任个人。如果您在您的服务和负责它们的工程经理之间定义一个映射，您可以通过让他们轻松找到相关联系人点来解决服务责任问题，例如负责该服务的工程经理。
- en: 'An alternative way of defining service accountability is to associate services
    with teams. However, there can be multiple issues with this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 定义服务责任的另一种方法是将其与团队关联。然而，这可能会出现多个问题：
- en: '**Shared accountability does not always work**: If you have multiple people
    that are responsible for a service, it becomes unclear who the final authority
    among them is.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享责任并不总是有效**：如果您有多个对服务负责的人，那么在他们中间谁是最终权威就变得不清楚了。'
- en: '**A team is a loosely defined concept in many organizations**: Unless you have
    a single, well-defined registry of teams in your company, it’s better to avoid
    referencing team names in your systems.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在许多组织中，团队是一个松散定义的概念**：除非您在公司中有一个单一、明确定义的团队注册，否则最好避免在您的系统中引用团队名称。'
- en: 'Now, let’s discuss the support aspect of ownership. Ideally, each service should
    have a mechanism for reporting any issues or bugs. Such a mechanism can take one
    of the following forms:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来讨论所有权的支持方面。理想情况下，每个服务都应该有一个机制来报告任何问题或错误。这样的机制可以采取以下形式之一：
- en: '**Support channel**: The identifier or URL of a messaging channel for leaving
    support requests, such as a link to the relevant Google group, Slack channel,
    or any other similar tool.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持渠道**：用于留下支持请求的消息渠道的标识符或URL，例如相关Google群组、Slack频道或任何其他类似工具的链接。'
- en: '**Ticketing system URL**: The URL to a system/page that allows you to create
    a support request ticket. Developers often use Atlassian Jira for this purpose.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**票据系统URL**：允许您创建支持请求票据的系统/页面的URL。开发者通常使用Atlassian Jira来完成这项任务。'
- en: 'If you provide such metadata for all your services, you will significantly
    simplify user support: all service users, such as other developers, will always
    know how to request support for them or report any bugs or other issues.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为所有服务提供此类元数据，您将显著简化用户支持：所有服务用户，如其他开发者，都将始终知道如何为他们请求支持或报告任何错误或其他问题。
- en: Let’s move on to the on-call ownership metadata. An easy solution to this is
    to link each service to its on-call rotation. If you use PagerDuty, you can store
    the relationships between service names and their corresponding PagerDuty rotation
    identifiers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论待命的所有权元数据。解决这个问题的简单方法是将每个服务与其待命轮换关联起来。如果您使用PagerDuty，您可以存储服务名称与其对应的PagerDuty轮换标识符之间的关系。
- en: 'An example of the ownership metadata that we just described is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的所有权元数据的示例如下：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our example is defined in YAML format, though it may be preferable to store
    this data in some system that would allow us to query or modify it via an API.
    This way, you can automatically submit new ownership changes (for example, when
    people leave the company and you want to reassign the ownership automatically).
    I would also suggest making the ownership data mandatory for all services. To
    enforce this, you can establish a service creation process that will request the
    ownership data before developers provision new services.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例定义在YAML格式中，尽管将此数据存储在允许我们通过API查询或修改它的系统中可能更可取。这样，您可以自动提交新的所有权更改（例如，当人们离开公司并且您希望自动重新分配所有权时）。我还建议将所有权数据对所有服务强制为必填项。为了强制执行此操作，您可以建立一个服务创建流程，在开发者在提供新服务之前要求提供所有权数据。
- en: Now that we’ve discussed service ownership, let’s move on to the next section,
    where we will describe the basics of Go microservice security.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了服务所有权，接下来让我们进入下一节，我们将描述Go微服务安全的基础知识。
- en: Securing microservice communication with JWT
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JWT保护微服务通信
- en: In this section, we are going to review some basic concepts of microservice
    security, such as authentication and authorization. You will learn how to implement
    such logic in Go using a popular **JSON Web Token** (**JWT**) protocol.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一些微服务安全的基本概念，例如身份验证和授权。您将学习如何使用流行的**JSON Web Token**（JWT）协议在Go中实现此类逻辑。
- en: 'Let’s start with one of the primary aspects of security: **authentication**.
    Authentication is the process of verifying someone’s identity, such as via user
    credentials. When you log into some system, such as Gmail, you generally go through
    the authentication process by providing your login details (username and password).
    The system that performs authentication performs verification by comparing the
    provided data with the existing records it stores. Verification can take one or
    multiple steps: some types of authentication, such as two-factor authentication,
    require some additional actions, such as verifying access to a phone number via
    SMS.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安全的一个主要方面开始：**认证**。认证是验证某人身份的过程，例如通过用户凭证。当你登录到某个系统，如Gmail时，你通常通过提供登录详细信息（用户名和密码）来完成认证过程。执行认证的系统通过将提供的数据与它存储的现有记录进行比较来进行验证。验证可以是一步或多步：某些类型的认证，如双因素认证，需要一些额外的操作，例如通过短信验证对电话号码的访问。
- en: A successful authentication often results in granting the caller access to some
    resources, such as user data (for example, user emails in Gmail). Additionally,
    the server performing this authentication may provide a security token to the
    caller that can be used on subsequent calls to skip the verification process.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的认证通常会导致授予调用者访问某些资源的权限，例如用户数据（例如，Gmail中的用户电子邮件）。此外，执行此认证的服务器可能还会向调用者提供一个安全令牌，该令牌可以在后续调用中使用以跳过验证过程。
- en: 'Another form of access control, known as **authorization**, involves specifying
    access rights to various resources. Authorization is often performed to check
    whether a user has permission to perform a certain action, such as viewing a specific
    admin page. Authorization is often performed by using a security token that was
    obtained during authentication, as illustrated in the following diagram:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种形式的访问控制，称为**授权**，涉及指定对各种资源的访问权限。授权通常是为了检查用户是否有权执行某些操作，例如查看特定的管理员页面。授权通常是通过使用在认证期间获得的安全令牌来执行的，如下面的图所示：
- en: '![Figure 13.9 – Authorization request providing a token'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9 – 提供令牌的授权请求'
- en: '](img/Figure_13.9_B18865.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.9_B18865.jpg)'
- en: Figure 13.9 – Authorization request providing a token
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 – 提供令牌的授权请求
- en: There are many different ways to implement authentication and authorization
    in microservices. Among the most popular protocols is JWT, a proposed internet
    standard for creating security tokens that can contain any number of facts about
    the caller’s identity, such as them being an administrator. Let’s review the basics
    of the protocol to help you understand how to use it in your services.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中实现认证和授权有许多不同的方法。其中最受欢迎的协议之一是JWT，这是一个提议的互联网标准，用于创建可以包含关于调用者身份的任何数量事实的安全令牌，例如他们是否是管理员。让我们回顾一下该协议的基本知识，以帮助您了解如何在您的服务中使用它。
- en: JWT basics
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT 基础
- en: 'JWTs are generated by components that perform authentication or authorization.
    Each token consists of three parts: a header, a payload, and a signature. The
    payload is the main part of the token and it contains a set of **claims** – statements
    about the caller’s identity, such as a user identifier or a role in the system.
    The following code shows an example of a token payload:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: JWT由执行认证或授权的组件生成。每个令牌由三部分组成：一个头部、一个有效载荷和一个签名。有效载荷是令牌的主要部分，它包含一组**声明**——关于调用者身份的陈述，例如用户标识符或系统中的角色。以下代码显示了一个令牌有效载荷的示例：
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our example payload contains three claims: the user’s name, role (`admin` in
    our example), and token issuance time (`iat` is a standard field name that is
    a part of the JWT protocol). Such claims could be used in various flows – for
    example, when checking whether a user has the `admin` role to access a system
    dashboard.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例有效载荷包含三个声明：用户的姓名、角色（在我们的示例中为`admin`）和令牌发行时间（`iat`是一个标准字段名，它是JWT协议的一部分）。这些声明可以在各种流程中使用——例如，当检查用户是否有`admin`角色以访问系统仪表板时。
- en: 'As a protection mechanism against modifications, each token contains a **signature**
    – a cryptographic function of its payload - a header, and a special value, called
    a **secret**, that is known only to the authentication server. The following pseudocode
    provides an example of token signature calculation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 作为防止修改的保护机制，每个令牌都包含一个**签名**——其有效载荷的加密函数、一个头部和一个称为**密钥**的特殊值，这个密钥只有认证服务器才知道。以下伪代码提供了一个令牌签名计算的示例：
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The algorithm that is used for creating a token signature is defined in a **token
    header**. The following JSON record provides an example of a header:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建令牌签名的算法在**令牌头**中定义。以下JSON记录提供了一个头部的示例：
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In our example, the token is using `HMAC-SHA256`, a cryptographic algorithm
    that is commonly used for signing JWTs. Our selection of `HMAC-SHA256` is primarily
    due to its popularity; if you wish to learn about other signing algorithms, you
    can find a link to an overview of them in the *Further reading* section of the
    chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，令牌使用`HMAC-SHA256`，这是一种常用的JWT签名加密算法。我们选择`HMAC-SHA256`主要是由于其流行度；如果您想了解其他签名算法，可以在本章的*进一步阅读*部分找到它们的概述。
- en: 'The resulting JWT is a concatenation of the token’s header, payload, and signature,
    encoded with the *Base64uri* protocol. For example, the following value is a JWT
    that’s been created by combining the header and the payload from our code snippets,
    signed with a secret string called `our-secret`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的JWT是令牌的头、有效载荷和签名的串联，使用*Base64uri*协议编码。例如，以下值是一个JWT，它通过结合我们的代码片段中的头部和有效载荷，并使用名为`our-secret`的密钥字符串签名而创建：
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To practice JWT creation, I suggest using the JWT tool available at [https://jwt.io](https://jwt.io)
    to try encoding arbitrary JWTs and see the resulting token values.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习JWT的创建，我建议使用位于[https://jwt.io](https://jwt.io)的JWT工具尝试编码任意的JWT并查看生成的令牌值。
- en: Now that we have discussed the high-level details of JWT, let’s move on to the
    practical part of this section – implementing basic authentication and authorization
    in Go microservices using JWTs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了JWT的高级细节，让我们继续本节的实际部分——使用JWT在Go微服务中实现基本的身份验证和授权。
- en: Implementing authentication and authorization with JWTs
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JWT实现身份验证和授权
- en: In this section, we will provide some examples of implementing basic access
    control via authentication and authorization using Go.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供一些使用Go实现基本访问控制（通过身份验证和授权）的示例。
- en: 'Let’s start with the authentication process. A simple credential-based authentication
    flow can be summarized as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从认证过程开始。一个基于凭证的简单认证流程可以总结如下：
- en: The client initiating authentication would call a specified endpoint (for example,
    HTTPS POST `/auth`) while providing the user credentials, such as username and
    password.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化认证的客户端会调用一个指定的端点（例如，HTTPS POST `/auth`），同时提供用户凭证，如用户名和密码。
- en: 'The server handling authentication would verify the credentials and perform
    one of two actions:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理认证的服务器会验证凭证并执行以下两个动作之一：
- en: Return an error if the credentials are invalid (for example, an HTTP error with
    a `401` code).
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果凭证无效，则返回错误（例如，带有`401`代码的HTTP错误）。
- en: Return a successful response with a `200` code, containing a JWT, that is signed
    with the server’s secret.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个包含JWT的成功响应，该JWT由服务器的密钥签名。
- en: If authentication is successful, the client can store the received token so
    that it can be used in the following requests.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果认证成功，客户端可以存储收到的令牌，以便在后续请求中使用。
- en: Let’s illustrate how to implement the server logic for the authentication flow
    that we just described. To generate JWTs in our Go code, we will use the `https://github.com/golang-jwt/jwt`
    library.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们说明如何实现我们刚才描述的认证流程的服务器逻辑。在我们的Go代码中生成JWT，我们将使用`https://github.com/golang-jwt/jwt`库。
- en: 'The following code provides an example of handling an HTTP authentication request.
    It performs credential validation and returns a successful response with a signed
    JWT if the validation passes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了一个处理HTTP认证请求的示例。它执行凭证验证，如果验证通过，则返回一个包含已签名JWT的成功响应：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we created a token using the `jwt.NewWithClaims` function.
    The token includes two fields:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`jwt.NewWithClaims`函数创建了一个令牌。该令牌包括两个字段：
- en: '`username`: Name of the authenticated user'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`：已认证用户的名称'
- en: '`iat`: Time of token creation'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iat`：令牌创建时间'
- en: 'The server code that we just created is using the secret value to sign the
    token. Any attempts to modify the token would be impossible without knowing the
    secret: the token signature allows us to check whether the token is correct.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才创建的服务器代码正在使用密钥值来签名令牌。不知道密钥的情况下，任何修改令牌的尝试都是不可能的：令牌签名允许我们检查令牌是否正确。
- en: 'Now, let’s illustrate how the client can perform requests using the token that
    it receives after successfully authenticating:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们说明客户端如何使用在成功认证后收到的令牌进行请求：
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In our example of an authorized operation, we added an `Authorization` header
    to the request while using the token value with the `Bearer` prefix. The `Bearer`
    prefix defines a **bearer token** – a token that intends to give access to its
    bearer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的授权操作示例中，我们在使用带有 `Bearer` 前缀的令牌值的同时，向请求中添加了 `Authorization` 头。`Bearer` 前缀定义了一个
    **携带令牌** – 一个意图赋予其携带者访问权限的令牌。
- en: 'Let’s also provide the logic of a server handler that would handle such an
    authorized request and verify whether the provided token is correct:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们也提供处理此类授权请求并验证提供的令牌是否正确的服务器处理器的逻辑：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s describe some highlights of the provided example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下提供的示例的一些亮点：
- en: We use the `jwt.Parse` function to parse the token and validate it. We return
    an error if the signature algorithm does not match `HMAC-SHA256`, which we used
    previously.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `jwt.Parse` 函数来解析令牌并验证它。如果签名算法与我们之前使用的 `HMAC-SHA256` 不匹配，我们返回一个错误。
- en: The parsed token contains the `Claims` field, which contains the claims from
    the token payload
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析后的令牌包含 `Claims` 字段，它包含令牌有效载荷中的声明。
- en: We use the `username` claim from the token payload in our function. Once we
    successfully parse the token and verify that it is valid, we can assume that the
    information in its payload has been securely passed to us and can trust it.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在我们的函数中使用令牌有效载荷中的 `username` 声明。一旦我们成功解析令牌并验证它是有效的，我们可以假设其有效载荷中的信息已经安全地传递给我们，并且可以信任它。
- en: 'Now that we have provided examples of Go authentication and authorization using
    JWTs, let’s list some best practices for using JWTs to secure microservice communication:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经提供了使用 JWTs 进行 Go 认证和授权的示例，让我们列出一些使用 JWTs 保护微服务通信的最佳实践：
- en: '`exp` JWT claim field) to avoid situations where users use old authorization
    records. By having an expiration time set in each token payload, you can verify
    it against authorization requests. For example, when a user authenticates as a
    system administrator, you can set a short token expiration time (for example,
    a few hours) to avoid situations where a former administrator can still perform
    critical actions in the system.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`exp` JWT 声明字段) 以避免用户使用旧的授权记录的情况。通过在令牌有效载荷中设置过期时间，你可以将其与授权请求进行验证。例如，当用户以系统管理员身份进行认证时，你可以设置一个短的令牌过期时间（例如，几个小时），以避免前管理员仍然可以在系统中执行关键操作的情况。
- en: '`ist` JWT claim field), can be useful in many practical situations. For example,
    if you identify a security breach that happened at a certain point in time, you
    can invalidate all access tokens that were issued before that moment by using
    the token issuance time metadata.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`ist` JWT 声明字段)，在许多实际情况下可能很有用。例如，如果你确定在某个时间点发生的安全漏洞，你可以通过使用令牌发行时间元数据来使在该时刻之前发行的所有的访问令牌失效。
- en: '**Use JWTs with HTTPS instead of HTTP**: The HTTPS protocol encrypts request
    metadata, such as authorization request headers, preventing various types of security
    attacks. An example of such a security attack is a *man-in-the-middle* attack,
    which is when some third party (such as a hacker trying to obtain a user’s access
    token) captures network traffic to extract JWTs from request headers.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 HTTPS 而不是 HTTP 来使用 JWTs**：HTTPS 协议加密请求元数据，例如授权请求头，防止各种类型的网络安全攻击。这类安全攻击的一个例子是
    *中间人攻击*，即某个第三方（例如试图获取用户访问令牌的黑客）捕获网络流量以从请求头中提取 JWTs。'
- en: '**Prefer standard JWT claim fields to custom ones**: When including metadata
    in the JWT payload, make sure that there is no standard field for the same purpose.
    You can find a list of standard JWT claim fields at https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先使用标准 JWT 声明字段而不是自定义字段**：当在 JWT 有效载荷中包含元数据时，请确保没有相同目的的标准字段。你可以在 https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields
    找到标准 JWT 声明字段列表。'
- en: The [https://jwt.io/](https://jwt.io/) website contains some additional tips
    on using JWTs, as well as an online tool for encoding and decoding JWTs, that
    you can use to debug your service communication.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://jwt.io/](https://jwt.io/) 网站包含一些关于使用 JWTs 的额外提示，以及一个用于编码和解码 JWTs 的在线工具，你可以使用它来调试你的服务通信。'
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, we have finished the last chapter of this book by reviewing lots
    of microservice development topics that were not included in the previous chapters.
    You learned how to profile Go services, create microservice dashboards so that
    you can monitor their performance, define and store microservice ownership data,
    and secure microservice communication with JWTs. I hope that you have found lots
    of interesting tips in this chapter that will help you build scalable, highly
    performant, and secure microservices.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回顾许多未在前几章中包含的微服务开发主题，我们完成了这本书的最后一章。你学习了如何分析 Go 服务，创建微服务仪表板以便监控其性能，定义和存储微服务所有权数据，以及使用
    JWT 保护微服务通信。我希望你在这一章中找到了许多有用的提示，这将帮助你构建可扩展、高性能和安全的微服务。
- en: The Go language keeps evolving, as well as the tooling for it. Each day, developers
    release new libraries and tools for it that can solve various microservice development
    problems that we described in this book. While this book provided you with lots
    of tips on Go microservice development, you should keep improving your skills
    and make your services simpler and easier to maintain.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言及其工具集不断进化。每天，开发者都会发布新的库和工具来解决我们在本书中描述的各种微服务开发问题。虽然本书为您提供了许多关于 Go 微服务开发的提示，但您应该不断改进您的技能，并使您的服务更简单、更易于维护。
- en: I also want to thank you for reading this book. I hope you enjoyed reading it
    and gained lots of useful experience that will help you in mastering the art of
    Go microservice development. Let your Go microservices be highly performant, secure,
    and easy to maintain!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想感谢您阅读这本书。希望您喜欢阅读它，并从中获得了许多有用的经验，这将帮助您掌握 Go 微服务开发的技艺。让您的 Go 微服务具有高性能、安全且易于维护！
- en: Further reading
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: '*Profiling Go* *Programs*: [https://go.dev/blog/pprof](https://go.dev/blog/pprof)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Go 程序分析*: [https://go.dev/blog/pprof](https://go.dev/blog/pprof)'
- en: 'Grafana documentation: [https://grafana.com/docs/](https://grafana.com/docs/)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Grafana 文档: [https://grafana.com/docs/](https://grafana.com/docs/)'
- en: '*Grafana support for* *Prometheus*: [https://prometheus.io/docs/visualization/grafana/](https://prometheus.io/docs/visualization/grafana/)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Grafana 对 Prometheus 的支持*: [https://prometheus.io/docs/visualization/grafana/](https://prometheus.io/docs/visualization/grafana/)'
- en: 'Top Go frameworks: [https://github.com/mingrammer/go-web-framework-stars](https://github.com/mingrammer/go-web-framework-stars)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Top Go 框架: [https://github.com/mingrammer/go-web-framework-stars](https://github.com/mingrammer/go-web-framework-stars)'
- en: 'JSON web token: [https://jwt.io/](https://jwt.io/)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'JSON web token: [https://jwt.io/](https://jwt.io/)'
- en: '*JSON Web Token (JWT) Signing Algorithms* *Overview*: https://auth0.com/blog/json-web-token-signing-algorithms-overview/'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JSON Web Token (JWT) 签名算法* 概述: https://auth0.com/blog/json-web-token-signing-algorithms-overview/'
- en: 'We suggest that you use these resources to stay up to date with the latest
    news related to Go microservice development:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您使用以下资源来了解与 Go 微服务开发相关的最新新闻：
- en: '**The Go** **blog**: [https://go.dev/blog/](https://go.dev/blog/)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Go 博客**: [https://go.dev/blog/](https://go.dev/blog/)'
- en: '**Microservice** **architecture**: https://microservices.io'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务架构**: https://microservices.io'
- en: '**A curated list of awesome Go** **software**: [https://github.com/avelino/awesome-go](https://github.com/avelino/awesome-go)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精选的 Go 软件列表**: [https://github.com/avelino/awesome-go](https://github.com/avelino/awesome-go)'
