- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Go Basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 基础
- en: With so many programming languages out there, it’s fair to wonder why anyone
    would have to invent yet another one. What the background is of the people behind
    Go and what the problems are they are trying to solve with this new language are
    some of the items we will address in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在如此多的编程语言中，公平地怀疑为什么有人必须发明另一种语言是有道理的。Go 背后的人的背景以及他们试图用这种新语言解决的问题是我们将在本章中讨论的一些事项。
- en: These topics give us some perspective on the challenges large-scale software
    development presents to software developers today and why modern technologies
    such as programming languages are constantly evolving.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题为我们提供了对大型软件开发对软件开发者今天所面临的挑战的某些看法，以及为什么现代技术，如编程语言，始终在不断发展。
- en: 'By the end of this chapter, you should have a better understanding of where
    Go comes from and its role in developing distributed systems running on multi-core
    processors, as well as be familiar with Go’s source code structure as we go through
    the following areas:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对 Go 的来源及其在多核处理器上运行的分布式系统开发中的作用有更好的理解，并且在我们通过以下区域时，应该熟悉 Go 的源代码结构：
- en: What is Go?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Go？
- en: Go’s guiding principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 的指导原则
- en: Go source code file structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 源代码文件结构
- en: Go packages and modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 包和模块
- en: Compiling Go programs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译 Go 程序
- en: Running Go programs online
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线运行 Go 程序
- en: Exploring the Go tool to manage Go source code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Go 工具以管理 Go 源代码
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We assume that you have basic familiarity with the command line, Git, and GitHub.
    You can find the code examples for this chapter in the book’s GitHub repository,
    [https://github.com/PacktPublishing/Network-Automation-with-Go](B16971_02.xhtml),
    in the `ch02` folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您对命令行、Git 和 GitHub 有基本的了解。您可以在本书的 GitHub 仓库中找到本章的代码示例，[https://github.com/PacktPublishing/Network-Automation-with-Go](B16971_02.xhtml)，在
    `ch02` 文件夹中。
- en: 'To run the examples, follow these steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，请按照以下步骤操作：
- en: Install Go 1.17 or later for your operating system. You can follow the instructions
    in [*Chapter 1*](B16971_01.xhtml#_idTextAnchor015), *Introduction*, in the *Installing
    Go* on your computer section, or go to [https://go.dev/doc/install](https://packages.cloud.google.com/apt/doc/apt-key.gpg).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的操作系统安装 Go 1.17 或更高版本。您可以在计算机上的 *安装 Go* 部分的 *第 1 章*（[B16971_01.xhtml#_idTextAnchor015](B16971_01.xhtml#_idTextAnchor015)）*简介*中的说明中找到，或者访问
    [https://go.dev/doc/install](https://packages.cloud.google.com/apt/doc/apt-key.gpg)。
- en: Clone the book’s GitHub repository with `git clone` at [https://github.com/PacktPublishing/Network-Automation-with-Go.git](https://kubernetes.io/docs/reference/ports-and-protocols/).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `git clone` 在 [https://github.com/PacktPublishing/Network-Automation-with-Go.git](https://kubernetes.io/docs/reference/ports-and-protocols/)
    上克隆本书的 GitHub 仓库。
- en: Change the directory to an example’s folder – `cd Network-Automation-with-Go/ch02/pong`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录更改为示例文件夹 – `cd Network-Automation-with-Go/ch02/pong`。
- en: Execute `go` `run main.go`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `go run main.go`。
- en: What is Go?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Go？
- en: During the second half of 2007, *Robert Griesemer*, *Rob Pike*, and *Ken Thompson*
    started discussing the design of a new programming language that would solve some
    problems they were experiencing when writing software at Google, such as the increased
    complexity to use some languages, long code compilation times, and not being able
    to program efficiently on multiprocessor computers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2007 年下半年，*罗伯特·格里泽默*、*罗布·派克* 和 *肯·汤普森* 开始讨论设计一种新的编程语言，这种语言将解决他们在 Google 编写软件时遇到的一些问题，例如使用某些语言的复杂性增加、长的代码编译时间以及无法在多处理器计算机上高效编程。
- en: '*Rob Pike* was trying to take some concurrency and communicating channels ideas
    into C++, based on his earlier work on the Newsqueak language in 1988, as he describes
    in *Go: Ten years and climbing* (*Further reading*) and *Less is exponentially
    more* (*Further reading*). This turned out to be too hard to implement. He would
    work out of the same office with *Robert Griesemer* and *Ken Thompson*. Ken had
    worked together with Rob Pike in the past to create the character-encoding UTF-8,
    while *Ken Thompson* had designed and implemented the Unix operating system and
    invented the B programming language (the predecessor to the C programming language).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*罗布·派克* 正在尝试将一些并发和通信通道的想法带入 C++，这是基于他在 1988 年对 Newsqueak 语言早期工作的成果，正如他在 *Go:
    十年攀登*（*进一步阅读*）和 *少即是多*（*进一步阅读*）中所描述的。这证明太难实现了。他将与 *罗伯特·格里泽默* 和 *肯·汤普森* 在同一个办公室工作。肯曾与罗布·派克合作创建字符编码
    UTF-8，而 *肯·汤普森* 设计并实现了 Unix 操作系统，并发明了 B 编程语言（C 编程语言的前身）。'
- en: 'They chose the name **Go** for this new programming language because it’s short,
    but the DNS entry for [go.com](https://cloud.google.com/architecture/reduce-carbon-footprint)
    wasn’t available, so Go’s website ended up at [golang.org](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/what-is-ccft.html).
    And so, **golang** became a nickname for Go. While golang is convenient for search
    queries, it’s not the name of the language (which is Go):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 他们选择**Go**这个名字给这种新的编程语言，因为它简短，但[go.com](https://cloud.google.com/architecture/reduce-carbon-footprint)的DNS条目不可用，所以Go的网站最终在[golang.org](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/what-is-ccft.html)。因此，“**golang**”成为了Go的昵称。虽然golang对搜索查询来说很方便，但它并不是语言的名字（语言的名字是Go）：
- en: '![Figure 2.1 – The initial Go discussion email thread ](img/B16971_02_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 初始Go讨论邮件线程](img/B16971_02_01.jpg)'
- en: Figure 2.1 – The initial Go discussion email thread
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 初始Go讨论邮件线程
- en: 'Though they initially thought of C/C++ to be the starting point, they ended
    up starting from scratch to define a more expressive language, despite a large
    number of simplifications when compared to its predecessors. Go inherits some
    things from C, such as, but not limited to, basic data types, expression syntax,
    pointers, and compilation to machine code, but it doesn’t have things such as
    the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管他们最初认为C/C++是起点，但他们最终从头开始定义了一种更具有表现力的语言，尽管与前辈相比有很多简化。Go从C继承了一些东西，例如，但不仅限于基本数据类型、表达式语法、指针和编译成机器代码，但它没有以下这些：
- en: Header files
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头文件
- en: Exceptions
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常
- en: Pointer arithmetic
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针算术
- en: Subtype inheritance (no subclasses)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类型继承（没有子类）
- en: '`this` in methods'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法中的`this`
- en: Promotion to a superclass (it uses embedding instead)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向超类提升（它使用嵌入代替）
- en: Circular dependencies
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环依赖
- en: 'Pascal, Oberon, and Newsqueak are among the programming languages that have
    influenced Go. In particular, its concurrency model comes from *Tony Hoare*’s
    **Communicating Sequential Processes** (**CSPs**) (*Further reading*) white paper,
    and CSP’s implementations in *Rob Pike*’s interpreted language Newsqueak and,
    later, Phil Winterbottom’s C-like compiled version, Alef. The next figure shows
    Go’s family tree:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal、Oberon和Newsqueak是影响Go的编程语言之一。特别是，它的并发模型来自*托尼·霍尔*的**通信顺序过程**（**CSPs**）(*进一步阅读*)白皮书，以及CSP在*罗布·派克*的解析语言Newsqueak中的实现，以及后来的Phil
    Winterbottom的类似C的编译版本，Alef。下一张图显示了Go的家族树：
- en: '![Figure 2.2 – The Go ancestors ](img/B16971_02_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – Go的祖先](img/B16971_02_02.jpg)'
- en: Figure 2.2 – The Go ancestors
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – Go的祖先
- en: The number of C++ programmers that come to Go is just a few compared to what
    the Go founders expected. Most Go programmers actually come from languages such
    as Python and Ruby.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与Go的创始人预期的相比，来到Go的C++程序员数量只是寥寥无几。大多数Go程序员实际上来自Python和Ruby等语言。
- en: Go became an open source project on November 10, 2009\. They host Go’s source
    code at [https://go.googlesource.com/go](https://www.microsoft.com/en-us/sustainability/emissions-impact-dashboard?activetab=pivot_2%3aprimaryr12)
    and keep a mirror of the code at [https://github.com/golang/go](https://cloud.google.com/carbon-footprint)
    where you can submit pull requests. While Go is an open source programming language,
    it’s actually supported by Google.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Go于2009年11月10日成为开源项目。他们把Go的源代码托管在[https://go.googlesource.com/go](https://www.microsoft.com/en-us/sustainability/emissions-impact-dashboard?activetab=pivot_2%3aprimaryr12)，并在[https://github.com/golang/go](https://cloud.google.com/carbon-footprint)上保留代码镜像，你可以在这里提交pull请求。虽然Go是一种开源编程语言，但它实际上由Google支持。
- en: They wrote the first Go compiler in C, but they later converted it to Go. Russ
    Cox describes this in detail in Go 1.3+ Compiler Overhaul (*Further reading*).
    As mind-blowing as it may sound, the Go source code of today is written in Go.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 他们最初用C编写了第一个Go编译器，但后来将其转换为Go。Russ Cox在Go 1.3+编译器重整（*进一步阅读*）中详细描述了这一点。虽然听起来可能令人难以置信，但今天的Go源代码是用Go编写的。
- en: 'They released Go 1 on March 28, 2012\. We highlight some notable changes to
    the language since then in the summarized version of Go’s timeline in the next
    figure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 他们于2012年3月28日发布了Go 1。在下一张图中的Go时间线总结版本中，我们强调了自那时以来语言的一些显著变化：
- en: '![Figure 2.3 – Go''s brief timeline ](img/B16971_02_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – Go的简要时间线](img/B16971_02_03.jpg)'
- en: Figure 2.3 – Go’s brief timeline
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – Go的简要时间线
- en: Go is a stable language, and the semantics should not change unless Go 2 happens.
    The only change that the Go team has confirmed at this point is the addition of
    generic programming using type parameters in early 2022 (Go 1.18), as described
    in the Type Parameters Proposal (*Further reading*).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种稳定的语言，其语义不应该改变，除非发生Go 2。截至目前，Go团队唯一确认的改变是在2022年初（Go 1.18）添加了泛型编程，使用类型参数，如类型参数提案（*进一步阅读*）所述。
- en: Go is a programming language that attempts to combine the ease of programming
    of a dynamically typed language with the efficiency and safety of a statically
    typed language. It builds executable files in seconds, and with Go’s first-class
    support for concurrency, we can take full advantage of multi-core CPUs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种编程语言，它试图将动态类型语言的编程便捷性与静态类型语言的效率和安全性结合起来。它可以在几秒钟内构建可执行文件，并且由于Go对并发的一流支持，我们可以充分利用多核CPU。
- en: Before we dive into Go code, we cover some guiding principles that make Go unique
    through the Go proverbs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入Go代码之前，我们通过Go谚语来介绍一些指导原则，这些原则使Go独具特色。
- en: Go Proverbs
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go谚语
- en: '*Rob Pike* introduced the Go language proverbs at *Gopherfest* in *2015* to
    explain or teach Go philosophically. These are general guidelines that Go developers
    tend to adhere to. Most of these proverbs are good practices – but optional –
    that convey the spirit of the language.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rob Pike* 在 *2015年* 的 *Gopherfest* 上介绍了Go语言谚语，以哲学的角度解释或教授Go。这些是Go开发者倾向于遵循的一般性指导原则。这些谚语中的大多数都是良好的实践——但并非强制——传达了语言的精神。'
- en: 'We only include our favorite proverbs here. You can check out the full list
    at *Go Proverbs* (*Further reading*):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只包括我们最喜欢的谚语。你可以查看完整的列表，在 *Go谚语* (*进一步阅读*)：
- en: 'Gofmt’s style is no one’s favorite, yet gofmt is everyone’s favorite. When
    you write code in Go, you don’t have to worry about the debate of white spaces
    versus tabs, or where you put braces or curly brackets. Gofmt (`gofmt`) formats
    your code with a prescriptive style guide, so all Go code looks the same. This
    way, you don’t have to think about it when you write or read Go code:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gofmt的风格并不是每个人都喜欢的，但gofmt是每个人的最爱。当你用Go编写代码时，你不必担心空格与制表符的争论，或者在哪里放置括号或花括号。Gofmt（`gofmt`）使用规定性的风格指南格式化你的代码，所以所有的Go代码看起来都一样。这样，当你编写或阅读Go代码时，你不必去考虑它：
- en: '**Clear is better than clever**: Go favors clear code over clever code that
    is difficult to analyze or describe. Write code other people can read and with
    behavior they can understand.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰胜于巧妙**：Go倾向于清晰易懂的代码，而不是难以分析或描述的巧妙代码。编写其他人可以阅读且能理解的代码。'
- en: '**Errors are values**: An error in Go is not an exception. It’s a value you
    can use in your program logic – as a variable, for example.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误是值**：在Go中，错误不是一个异常。它是在你的程序逻辑中可以使用的值——例如，作为一个变量。'
- en: '**Don’t just check errors; handle them gracefully**: Go encourages you to think
    about whether you should do something with an error, instead of just returning
    it and forgetting about it. Depending on the error, maybe you can trigger a different
    execution path, add more info to it, or save it for later.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不仅要检查错误，还要优雅地处理它们**：Go鼓励你思考是否应该对错误进行处理，而不仅仅是返回它并忘记它。根据错误，你可能可以触发不同的执行路径，添加更多信息，或者为以后保存它。'
- en: '**A little copying is better than a little dependency**: If you only need a
    few lines from a library, maybe you can just copy those lines instead of importing
    the entire library to keep your dependency tree under control and make your code
    more compact. This way, your program not only compiles faster but is also more
    manageable and simpler to understand.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**少量复制胜于少量依赖**：如果你只需要从库中获取几行代码，也许你可以直接复制这些行，而不是导入整个库来控制你的依赖树，并使你的代码更加紧凑。这样，你的程序不仅编译得更快，而且更易于管理，也更易于理解。'
- en: '**Don’t communicate by sharing memory; share memory by communicating**: This
    describes how concurrent processes in Go can coordinate between each other. In
    other languages, concurrent processes communicate by sharing memory, which you
    have to protect with locks to prevent a data race condition when these processes
    try to access a memory location concurrently. Go, in contrast, uses channels instead
    to pass references to data between processes, so only one process has access to
    the data at a time.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要通过共享内存来通信；通过通信来共享内存**：这描述了Go中并发进程之间如何相互协调。在其他语言中，并发进程通过共享内存来通信，你必须使用锁来保护它，以防止当这些进程尝试并发访问内存位置时发生数据竞争条件。相比之下，Go使用通道在进程之间传递数据的引用，因此一次只有一个进程可以访问数据。'
- en: '**Concurrency is not parallelism**: Concurrency is structuring the execution
    of independent processes, whose instructions are not necessarily executed in sequence.
    Whether these instructions run in parallel depends on the availability of different
    CPU cores or hardware threads. *Rob Pike*’s *Concurrency is not Parallelism* (*Further
    reading*) talk is a must for Go developers.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发不是并行**：并发是对独立进程执行的架构，其指令不一定按顺序执行。这些指令是否并行运行取决于不同 CPU 核心或硬件线程的可用性。*Rob Pike*
    的 *并发不是并行*（*进一步阅读*）演讲是 Go 开发者的必读。'
- en: The Go proverbs cover different aspects of Go, from formatting your Go code
    to how Go achieves concurrency.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Go 谚语涵盖了 Go 的不同方面，从格式化 Go 代码到 Go 如何实现并发。
- en: Now, it’s time to roll up our sleeves as we start looking into Go source code
    files.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们卷起袖子，开始查看 Go 源代码文件。
- en: Go source code files
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 源代码文件
- en: While there isn’t a filename convention for Go source code files, their filenames
    are typically one-word, all lowercase, and include an underscore if it has more
    than one word. It ends with the `.``go` suffix.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Go 源代码文件没有文件名约定，但它们的文件名通常是单词，全部小写，如果包含多个单词，则包含一个下划线。它以 `.go` 后缀结尾。
- en: 'Each file has three parts:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件有三个部分：
- en: '**Package clause**: This defines the name of the package a file belongs to.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包声明**：这定义了文件所属的包名。'
- en: '**Import declaration**: This is a list of packages that you need to import.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进口声明**：这是一个需要导入的包列表。'
- en: '`const`, `var`, `type`, or `func`):'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`、`var`、`type` 或 `func`）：'
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code example shows the package declaration for the `main` package at the
    top. It follows the import declaration, where we specify that we use the `fmt`
    package in this file. Then, we include all declarations in the code – in this
    case, an `s` constant and the `main` function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例显示了 `main` 包的包声明在顶部。它遵循导入声明，其中我们指定在这个文件中使用 `fmt` 包。然后，我们包括代码中的所有声明——在这种情况下，一个
    `s` 常量和 `main` 函数。
- en: Packages
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: A package is one or more `.go` files in the same folder that declares the related
    constants, types, variables, and functions. These declarations are accessible
    to every file in the same package, so breaking down the code into different files
    is optional. It’s more of a personal preference on how to better organize code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 包是同一文件夹中的一个或多个 `.go` 文件，它声明了相关的常量、类型、变量和函数。这些声明对同一包中的每个文件都是可访问的，因此将代码分解到不同的文件是可选的。这更多的是个人偏好，如何更好地组织代码。
- en: 'In the standard library, they divide the code into separate files for larger
    packages. The `encoding/base64` package has one `.go` file (other than the test
    and example files), such as the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中，他们将代码分成单独的文件，用于更大的包。`encoding/base64` 包有一个 `.go` 文件（除了测试和示例文件），例如以下内容：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By contrast, the `encoding/json` package has nine `.go` source code files:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`encoding/json` 包有九个 `.go` 源代码文件：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Package names are short and meaningful (no underscore). Users of a package refer
    to the package name when importing something from it – for example, the `Decode`
    method exists in the `json` and `xml` packages. Users can call these methods with
    `json.Decode` and `xml.Decode`, respectively.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 包名简短且具有意义（没有下划线）。包的用户在从它导入内容时引用包名——例如，`Decode` 方法存在于 `json` 和 `xml` 包中。用户可以使用
    `json.Decode` 和 `xml.Decode` 分别调用这些方法。
- en: One special package is `main`. This is the entry point for any program that
    imports other packages. This package must have a `main` function that takes no
    arguments and returns no value, such as the code example at the beginning of this
    section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的包是 `main`。这是任何导入其他包的程序入口点。此包必须有一个不带参数且不返回任何值的 `main` 函数，例如本节开头的代码示例。
- en: Go modules
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 模块
- en: Go modules became the default way to release packages in Go 1.16\. They were
    first introduced in Go 1.11, back in 2018, to improve dependency management in
    Go. It allows you to define an import path and the dependencies for a package
    or collection of packages.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Go 模块在 Go 1.16 中成为发布包的默认方式。它们最初在 2018 年的 Go 1.11 中引入，目的是改善 Go 的依赖管理。它允许你定义包或包集合的导入路径和依赖项。
- en: 'Let’s define a small package called `ping`, with a `Send` function that returns
    a string with the word `pong`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个名为 `ping` 的小包，它有一个返回包含单词 `pong` 的字符串的 `Send` 函数：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch02/ping/code.go](http://www.sustainableitplaybook.com)
    file in the book’s GitHub repository. You can create a module for this package
    with the `go mod init` command at the root folder of this example (`ch02/ping`).
    The argument for this command should be the module location, where users can get
    access to it. The result is a `go.mod` file with the import path and a list of
    external package dependencies in it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是书中 GitHub 仓库中的 [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch02/ping/code.go](http://www.sustainableitplaybook.com)
    文件。您可以使用 `go mod init` 命令在此示例的根目录（`ch02/ping`）中为该包创建一个模块。此命令的参数应该是模块位置，用户可以通过此位置访问它。结果是包含导入路径和外部包依赖列表的
    `go.mod` 文件：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this, anyone can now import this package. The following program imports
    this package to the `pong` output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，任何人现在都可以导入这个包。以下程序将其导入到 `pong` 输出中：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can run this program from the Go Playground (*Further reading*), which imports
    the module we just created. This is also a great segue into the next section on
    packet importing and a sneak peek into the Go Playground section that we will
    cover in just a few more pages.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 Go Playground（*进一步阅读*）运行此程序，它导入了我们刚刚创建的模块。这也是过渡到下一节关于包导入的绝佳方式，也是对我们将在接下来的几页中涵盖的
    Go Playground 部分的预览。
- en: Importing packages
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入包
- en: The `import` keyword lists the packages to import in a source file. The import
    path is the module path, followed by the folder where the package is within the
    module, unless the package is in the standard library, in which case you only
    need to reference the directory. Let’s examine an example of each scenario.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 关键字列出了源文件中要导入的包。导入路径是模块路径，后跟包在模块中的文件夹位置，除非包位于标准库中，在这种情况下，你只需要引用目录。让我们检查每种情况的一个示例。'
- en: To give an example, the `google.golang.org/grpc` module has a package in the
    `credentials` folder. You would import it with `google.golang.org/grpc/credentials`.
    The last part of the path is how you prefix the package types and functions, `credentials.TransportCredentials`
    and `credentials.NewClientTLSFromFile`, respectively, in the next code sample.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以为例，`google.golang.org/grpc` 模块在 `credentials` 文件夹中有一个包。你会用 `google.golang.org/grpc/credentials`
    来导入它。路径的最后一部分是你如何为包类型和函数添加前缀，在下一个代码示例中分别是 `credentials.TransportCredentials` 和
    `credentials.NewClientTLSFromFile`。
- en: 'Go’s standard library (*Further reading*) at `go/src` is a collection of packages
    of the `std` module. The `fmt` folder hosts the package that implements functions
    to format input and output. The path to import this package is just `fmt`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的标准库（*进一步阅读*）位于 `go/src`，是 `std` 模块的一系列包集合。`fmt` 文件夹包含实现输入输出格式化功能的包。导入此包的路径仅为
    `fmt`：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Packages do not live in a central repository such as `maven`, `pip`, or `npm`.
    You can share your code by upstreaming it to a version control system and distribute
    it by sharing its location. Users can download it with the `go` command (`go install`
    or `go get`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 包并不存储在像 `maven`、`pip` 或 `npm` 这样的中央仓库中。你可以通过将其上传到版本控制系统来共享你的代码，并通过共享其位置来分发它。用户可以使用
    `go` 命令（`go install` 或 `go get`）下载它。
- en: 'For developing and testing purposes, you can reference local packages by pointing
    to their local path in the `go.mod` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发和测试目的，你可以在 `go.mod` 文件中通过指向它们的本地路径来引用本地包：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `ch02/pong` example, the Go tool automatically created the first three
    lines of the `go.mod` file for us, referencing the ping module from the book’s
    GitHub repository (*Further reading*). We later added a fourth line to replace
    that module, with the contents of the local version of it (`../ping`).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ch02/pong` 示例中，Go 工具为我们自动创建了 `go.mod` 文件的前三行，引用了来自书中 GitHub 仓库的 ping 模块（*进一步阅读*）。我们后来添加了第四行来替换该模块，用其本地版本的内容（`../ping`）。
- en: Comments
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: Code comments in Go play a key role, as they become your package documentation.
    The `go doc` tool takes the comments preceding a type, constant, function, or
    method that you export in a package as a document string for that declaration,
    producing an HTML file that the tool presents as a web page.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的代码注释扮演着关键角色，因为它们成为了你的包文档。`go doc` 工具将你在一个包中导出的类型、常量、函数或方法之前的注释作为该声明的文档字符串，生成一个工具以网页形式展示的
    HTML 文件。
- en: To give an example, all public Go packages (*Further reading*) display this
    autogenerated documentation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以为例，所有公共 Go 包（*进一步阅读*）都显示此自动生成的文档。
- en: 'Go offers two ways to create comments:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了两种创建注释的方法：
- en: 'C++-style `//` line comments, which is the most common form:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 风格的 `//` 行注释，这是最常见的形式：
- en: '[PRE8]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'C-style `/* */` block comments, which are primarily for package descriptions
    or large blocks of formatted/indented code:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 风格的 `/* */` 块注释，主要用于包描述或大块格式化/缩进的代码：
- en: '[PRE18]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Dave Cheney in *Practical Go: Real-world advice for writing maintainable Go
    programs* (*Further reading*) suggests that a code comment should explain one
    – and only one – of these three things:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '在 *Practical Go: Real-world advice for writing maintainable Go programs* (*进一步阅读*)
    一书中，Dave Cheney 建议，代码注释应该解释这三者之一 - 并且仅解释一个：'
- en: What it does
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它做了什么
- en: How something does what it does
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事物是如何做到它的
- en: Why something is why it is
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么是为什么
- en: A good practice is to make comments on variables that describe their contents,
    rather than their purpose. You could use the name of the variable to describe
    its purpose. This brings us to the naming style.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的做法是对描述其内容的变量进行注释，而不是其目的。您可以使用变量的名称来描述其目的。这让我们想到了命名风格。
- en: Names
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称
- en: 'The convention for declaring names in Go is to use camel case (MixedCaps or
    mixedCaps) instead of, for example, dashes or underscores when you use more than
    one word for the name of a function or variable. The exception to the rule are
    acronyms that have a consistent case, such as `ServeHTTP` and not `ServeHttp`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中声明名称的约定是使用驼峰式命名法（MixedCaps 或 mixedCaps），而不是使用破折号或下划线，例如，当您使用多个单词作为函数或变量的名称时。规则的一个例外是具有一致大写的缩写，例如
    `ServeHTTP` 而不是 `ServeHttp`：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first letter of the name determines whether the package exports this top-level
    declaration. Packages export names that start with a capital letter. These names
    are the only ones an external user of the package can reference when importing
    the package – for example, you can reference `IsMulticast` in the preceding code
    sample from another package as `net.IsMulticast`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 名称的第一个字母决定了包是否导出这个顶级声明。包导出以大写字母开头的名称。这些名称是外部用户在导入包时可以引用的唯一名称 - 例如，您可以在另一个包中引用前面的代码示例中的
    `IsMulticast`，作为 `net.IsMulticast`：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the first letter is lowercase, no other package has access to this resource.
    Packages can have declarations that are only for internal consumption. The `allFF`
    function in the last code example comes from the `net` package. This means only
    functions in the `net` package can call the `allFF` function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个字母是小写的，则没有其他包可以访问此资源。包可以有仅用于内部消费的声明。最后代码示例中的 `allFF` 函数来自 `net` 包。这意味着只有
    `net` 包中的函数可以调用 `allFF` 函数。
- en: Languages such as Java and C++ have explicit keywords such as `public` and `private`
    to control access to types and methods. Python follows the convention of naming
    variables or methods for internal use with a single underscore prefix. In Go,
    you can access any variable or method that starts with a lowercase letter from
    any source code file within the package, but not from another package.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Java 和 C++ 等语言有 `public` 和 `private` 等显式关键字来控制对类型和方法的访问。Python 遵循使用单个下划线前缀为内部使用变量或方法命名的约定。在
    Go 中，您可以从包内的任何源代码文件访问以小写字母开头的任何变量或方法，但不能从另一个包访问。
- en: Executing your Go code
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行您的 Go 代码
- en: The Go compiler translates Go programs into machine code, producing a binary
    file. Aside from your program, the binary includes the Go runtime, which offers
    services such as garbage collection and concurrency. Having access to binary files
    that work for different platforms makes Go programs very portable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Go 编译器将 Go 程序转换为机器代码，生成二进制文件。除了您的程序外，二进制文件还包括 Go 运行时，它提供垃圾回收和并发等服务。能够访问适用于不同平台的二进制文件使得
    Go 程序非常便携。
- en: 'Let’s compile the [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch02/pong/code.go](https://www.cio.gov/assets/files/Application-Rationalization-Playbook.pdf)
    file of the book’s GitHub repository with the `go build` command. You can also
    time this operation with the `time` command to see how fast Go builds really are:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `go build` 命令编译书籍 GitHub 仓库中的 [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch02/pong/code.go](https://www.cio.gov/assets/files/Application-Rationalization-Playbook.pdf)
    文件。您也可以使用 `time` 命令来计时此操作，看看 Go 编译器实际上有多快：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, you can execute the binary file. The default filename is the package name,
    `pong`. You can change the filename with the `-o` option of the `go build` command.
    There will be more on this in the *Go* *tool* section:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以执行二进制文件。默认文件名是包名，`pong`。您可以使用 `go build` 命令的 `-o` 选项更改文件名。关于这一点，将在 *Go*
    *工具* 部分进行更多介绍：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you don’t want to generate a binary or executable file and only run the
    code, you can use the `go run` command instead:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想生成二进制或可执行文件，只想运行代码，您可以使用 `go run` 命令：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Either option is fine, and it probably comes down to a matter of personal preference
    or whether you intend to share the compiled artifact with others or deploy it
    to servers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一种选择都行，这可能取决于个人偏好或者您是否打算与他人共享编译后的工件或将它部署到服务器上。
- en: Go files have three main parts and they are organized into packages and modules.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Go 文件有三个主要部分，并且被组织成包和模块。
- en: You can run all the examples on your computer after installing Go, or you can
    run them online, as we discuss in the next section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Go 后，您可以在您的电脑上运行所有示例，或者像我们在下一节讨论的那样在线运行它们。
- en: Running Go programs online
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线运行 Go 程序
- en: 'Sometimes, you need to test some code quickly or just want to share a code
    example with someone who might not have Go installed on their computer. In those
    situations, there are at least three websites where you can run and share Go code
    for free:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您需要快速测试一些代码或者只是想与可能没有在电脑上安装 Go 的人分享一个代码示例。在这些情况下，至少有三个网站您可以免费运行和分享 Go 代码：
- en: The Go Playground
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 操场
- en: The Go Play Space
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 操场
- en: The Gotip Playground
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gotip 操场
- en: They all share the backend infrastructure, but with subtle differences.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它们共享后端基础设施，但有一些细微的差别。
- en: The Go Playground
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 操场
- en: The Go team runs the Go Playground ([https://play.golang.org/](https://github.com/Green-Software-Foundation/awesome-green-software))
    on golang.org’s servers. They shared some insights and its architecture in the
    article *Inside the Go Playground* (*Further reading*), but more recently, *Brad
    Fitzpatrick* shared the history and the implementation details of the latest incarnation
    of the Go Playground (*Further reading*).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Go 团队运行 Go 操场 ([https://play.golang.org/](https://github.com/Green-Software-Foundation/awesome-green-software))
    在 golang.org 的服务器上。他们在文章 *Go 操场的内部* (*进一步阅读*) 中分享了一些见解和其架构，但最近，*布拉德·菲茨帕特里克* 分享了最新版本的
    Go 操场的历史和实现细节 (*进一步阅读*)。
- en: This service receives your program, runs it on a sandbox, and returns its output.
    This is very convenient if you are on your mobile phone, for example, and you
    want to verify the syntax of a function or something else.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务接收您的程序，在沙盒中运行它，并返回其输出。如果您在手机上，例如，并想验证函数或其它内容的语法，这非常方便。
- en: '![Figure 2.4 – The Go Playground ](img/B16971_02_04.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – Go 操场](img/B16971_02_04.jpg)'
- en: Figure 2.4 – The Go Playground
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – Go 操场
- en: If you are curious about how they built this service or you want to run it locally
    in your environment, make sure you check out the Playground source code (*Further
    reading*).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对如何构建此服务感兴趣或者想在您的环境中本地运行它，请确保查看 Playground 源代码 (*进一步阅读*)。
- en: The Go Play Space
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 操场空间
- en: 'If you can’t live without syntax highlighting, go to the Go Play Space (*Further
    reading*). This is an experimental alternative Go Playground frontend. They proxy
    the code execution to the official Go Playground so that programs work the same.
    They also store shared snippets on the [golang.org](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/what-is-ccft.html)
    servers:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不能没有语法高亮，请访问 Go 操场 (*进一步阅读*)。这是一个实验性的替代 Go 操场前端。它们将代码执行代理到官方的 Go 操场，以便程序工作相同。它们还存储共享片段在
    [golang.org](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/what-is-ccft.html)
    服务器上：
- en: '![Figure 2.5 – The Go Play Space ](img/B16971_02_05.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – Go 操场](img/B16971_02_05.jpg)'
- en: Figure 2.5 – The Go Play Space
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – Go 操场
- en: '*Figure 2**.5* shows some extra features that the Go Play Space includes besides
    syntax highlighting, such as auto-closing braces, access to documentation, and
    different UI themes.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.5* 展示了 Go 操场除了语法高亮之外的一些额外功能，例如自动关闭括号、访问文档和不同的 UI 主题。'
- en: '![Figure 2.6 – Building a house in the Go Play Space ](img/B16971_02_06.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 在 Go 操场中建造房屋](img/B16971_02_06.jpg)'
- en: Figure 2.6 – Building a house in the Go Play Space
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 在 Go 操场中建造房屋
- en: We could not pass over the fact that it also has a Turtle graphics mode to help
    you visualize algorithms for fun, such as having a gopher build a house, as shown
    in *Figure 2**.6*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能忽略它还有一个海龟图形模式来帮助您以娱乐的方式可视化算法，例如展示在 *图 2.6* 中，一只 gopher 建造房屋。
- en: A look into the Future
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展望未来
- en: The Gotip Playground runs on golang.org’s servers as well. This instance of
    the Go playground runs the latest development branch of Go. You can use it to
    test upcoming features that are in active development, such as the syntax described
    in the Type Parameters Proposal (*Further reading*) or the new `net/netip` package,
    without having to install more than one Go version on your system if you don’t
    want to.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Gotip 操场也在 golang.org 的服务器上运行。这个 Go 操场的实例运行 Go 的最新开发分支。您可以使用它来测试正在积极开发中的即将推出的功能，例如在类型参数提案（*进一步阅读*）中描述的语法或新的
    `net/netip` 包，而无需在您的系统上安装多个 Go 版本。
- en: '![Figure 2.7 – The Gotip Playground ](img/Figure_2.7.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – Gotip 操场](img/Figure_2.7.jpg)'
- en: Figure 2.7 – The Gotip Playground
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – Gotip 操场
- en: You can access the Gotip Playground via [https://gotipplay.golang.org/](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/what-is-ccft.html)
    or by selecting the **Go dev branch** dropdown at [https://go.dev/play/](https://www.microsoft.com/en-us/sustainability/emissions-impact-dashboard?activetab=pivot_2:primaryr12).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 [https://gotipplay.golang.org/](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/what-is-ccft.html)
    或通过在 [https://go.dev/play/](https://www.microsoft.com/en-us/sustainability/emissions-impact-dashboard?activetab=pivot_2:primaryr12)
    选择 **Go 开发分支** 下拉菜单来访问 Gotip 操场。
- en: These are all great options to run Go programs online that are available to
    you at no cost. In the next section, we go back to working on the command line
    as we explore the Go tool to manage Go source code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是您可以在不花费任何费用的情况下在线运行 Go 程序的绝佳选择。在下一节中，我们将回到命令行工作，探索用于管理 Go 源代码的 Go 工具。
- en: The Go tool
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 工具
- en: One of the convenient things about Go – as a programming language – is that
    a single tool handles all interactions with, and operations on, the source code.
    When installing Go, make sure that the `go` tool is in the searchable OS path
    so that you can invoke it from any command-line terminal. The user experience,
    regardless of the OS or platform architecture, is uniform and doesn’t require
    any customization when moving from one machine to another.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Go 作为一种编程语言的一个便利之处是，有一个单独的工具可以处理与源代码的所有交互和操作。当安装 Go 时，请确保 `go` 工具位于可搜索的操作系统路径中，这样您就可以从任何命令行终端调用它。用户体验，无论操作系统或平台架构如何，都是统一的，并且在不同机器之间移动时不需要任何定制。
- en: 'IDEs also use the `go` tool to build and run code, report errors, and automatically
    format Go source code. The `go` executable accepts a *verb* as the first argument
    that determines what `go` tool function to apply to Go source files:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 集成开发环境（IDEs）也使用 `go` 工具来构建和运行代码，报告错误，并自动格式化 Go 源代码。`go` 可执行文件接受一个作为第一个参数的 *动词*，该动词确定将应用哪个
    `go` 工具功能到 Go 源文件：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We’re only exploring a subset of the functions of the Go tool in this section.
    You can find the full list and every detail of each one in the Go `cmd` documentation
    (*Further reading*). The commands we’re covering are as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只探索了 Go 工具功能的一个子集。您可以在 Go `cmd` 文档（*进一步阅读*）中找到完整的列表以及每个功能的详细信息。我们涵盖的命令如下：
- en: '`build`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`'
- en: '`run`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`'
- en: '`mod`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod`'
- en: '`get`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`'
- en: '`install`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install`'
- en: '`fmt`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt`'
- en: '`test`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`'
- en: '`env`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`'
- en: These help you build and run your Go programs, manage their dependencies, and
    format and test your code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令帮助您构建和运行 Go 程序，管理它们的依赖项，以及格式化和测试您的代码。
- en: Build
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建
- en: We use the `go build` command to compile a Go program and generate an executable
    binary. If you are not using Go modules yet, the command expects a list of Go
    source files to compile as an argument. It generates a binary file as a result,
    with the same name as the first source file (without the `.go` suffix). In the
    `ch02/hello` folder of the book’s GitHub repository (*Further reading*), we have
    the `main.go` and `vars.go` files.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `go build` 命令来编译 Go 程序并生成可执行二进制文件。如果您尚未使用 Go 模块，该命令期望一个作为参数的 Go 源文件列表以进行编译。它生成一个与第一个源文件同名的二进制文件（不带
    `.go` 后缀）。在本书 GitHub 仓库的 `ch02/hello` 文件夹（*进一步阅读*）中，我们有 `main.go` 和 `vars.go`
    文件。
- en: 'You can build an executable file for the program in these files with the `go`
    `build` command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `go build` 命令为这些文件中的程序构建可执行文件：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Packaging compiled binaries is a common way of distributing Go programs, since
    it allows users of a program to skip the compilation stage and reduce the installation
    procedure to just a few commands (`download` and `unzip`). But you can only run
    this binary file on a machine with the same architecture and OS. To produce binary
    files for other systems, you can cross-compile to a wide range of OSs and CPU
    architectures. For example, the following table shows some target CPU instruction
    sets that are supported:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 打包编译后的二进制文件是分发Go程序的常见方式，因为它允许程序的用户跳过编译阶段，将安装过程简化为仅几个命令（`download`和`unzip`）。但是，你只能在具有相同架构和操作系统的机器上运行此二进制文件。要为其他系统生成二进制文件，你可以交叉编译到广泛的操作系统和CPU架构。例如，以下表格显示了一些受支持的CPU指令集：
- en: '![Table 2.1 – Some supported CPU architectures ](img/B16971_02_Table_2.1.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![表 2.1 – 一些支持的 CPU 架构](img/B16971_02_Table_2.1.jpg)'
- en: Table 2.1 – Some supported CPU architectures
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 – 一些支持的 CPU 架构
- en: 'Out of a long list of supported operating systems, the next table shows the
    most popular options:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在长长的支持操作系统列表中，下一张表格显示了最受欢迎的选项：
- en: '![Table 2.2 – Some supported OSs ](img/B16971_02_Table_2.2.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![表 2.2 – 一些支持的 OSs](img/B16971_02_Table_2.2.jpg)'
- en: Table 2.2 – Some supported OSs
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2 – 一些支持的 OSs
- en: 'The `GOOS` and `GOARCH` environment variables allow you to generate cross-compiled
    binaries for any other supported system. If you are on a Windows machine, you
    can generate a binary for macOS running on a 64-bit Intel processor with the following
    command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOOS`和`GOARCH`环境变量允许你为任何其他支持的系统生成交叉编译的二进制文件。如果你在Windows机器上，你可以使用以下命令生成在64位Intel处理器上运行的macOS的二进制文件：'
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `go tool dist list` command shows a complete set of unique combinations
    of OSs and architectures that the Go compiler supports:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`go tool dist list`命令显示了Go编译器支持的操作系统和架构的唯一组合的完整集合：'
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `go build` command supports different flags to change its default behavior.
    Two of the most popular flags are `-o` and `-ldflags`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`go build`命令支持不同的标志来改变其默认行为。两个最受欢迎的标志是`-o`和`-ldflags`。'
- en: 'You can use `-o` to override the default binary name with a name of your preference.
    In the example, we’ve selected `another_name`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`-o`来用你偏好的名称覆盖默认的二进制文件名。在示例中，我们选择了`another_name`：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To inject environment data at compile time into your program, use `-ldflags`
    with a reference to a variable and its value. This way, you can have access to
    build information during the program execution, such as the date you compiled
    the program or the version of the source code (`git commit`) you compiled it from:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要在编译时将环境数据注入到你的程序中，使用`-ldflags`并引用变量及其值。这样，你可以在程序执行期间访问构建信息，例如编译程序的日期或你编译它所用的源代码版本（`git
    commit`）：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The last example is a very common way of version-tagging a Go binary. The benefit
    of this approach is that it doesn’t require any changes to the source code, and
    you can automate the entire process in a continuous delivery pipeline.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例是版本标记Go二进制文件的一种非常常见的方式。这种方法的优点是不需要修改源代码，并且你可以在持续交付管道中自动化整个流程。
- en: Run
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Run
- en: 'Another way to run a Go program is by using the `go run` command. It accepts
    the same flags as `go build` with two differences:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Go程序的另一种方式是使用`go run`命令。它接受与`go build`相同的标志，但有两个区别：
- en: It doesn’t produce a binary.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会产生二进制文件。
- en: It runs the program right after compilation.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在编译后立即运行程序。
- en: 'The most common use case for `go run` is local debugging and troubleshooting,
    where a single command combines the processes of compilation and execution:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`go run`命令最常见的使用场景是本地调试和故障排除，其中单个命令结合了编译和执行的过程：'
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the example, we run the program in the `main.go` and `vars.go` files, which
    produces the `Hello` `World` output.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们在`main.go`和`vars.go`文件中运行程序，这会产生`Hello World`输出。
- en: Mod
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mod
- en: 'With the introduction of Go modules, the `go` tool got an extra command to
    work with them – `go mod`. To describe its functionally, let’s review a typical
    Go program development workflow:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Go模块的引入，`go`工具获得了一个额外的命令来与之交互 – `go mod`。为了描述其功能，让我们回顾一个典型的Go程序开发工作流程：
- en: You create a new project in a folder and initialize Go modules with the `go
    mod init` command, with a reference to the module name – `go mod init example.com/my-project`.
    This creates a pair of files, `go.mod` and `go.sum`, that keep track of your project’s
    dependencies.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在文件夹中创建一个新的项目，并使用`go mod init`命令初始化Go模块，引用模块名称 – `go mod init example.com/my-project`。这会创建一对文件，`go.mod`和`go.sum`，它们跟踪你的项目依赖项。
- en: 'The next output shows the size of these two files of a real-life project. `go.mod`
    lists all the dependencies and is relatively small in size compared to `go.sum`,
    which has the checksum for all the dependencies:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个输出显示了真实项目中这两个文件的大小。`go.mod` 列出了所有依赖项，与包含所有依赖项校验和的 `go.sum` 相比，它的大小相对较小：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you plan to share this project with others, the name of the module should
    be a path that is reachable on the internet. It normally points to your source
    code repository – for example, `github.com/username/my-project`. A real-life example
    is `github.com/gohugoio/hugo/`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划与他人共享此项目，模块的名称应该是互联网上可访问的路径。它通常指向您的源代码仓库，例如 `github.com/username/my-project`。一个现实生活中的例子是
    `github.com/gohugoio/hugo/`。
- en: As you develop your code and add more and more dependencies, the `go` tool updates
    the `go.mod` and `go.sum` files automatically whenever you run the `go build`
    or `go` `run` commands.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着您开发代码并添加越来越多的依赖项，每当您运行 `go build` 或 `go run` 命令时，`go` 工具会自动更新 `go.mod` 和 `go.sum`
    文件。
- en: When you add a dependency, the `go` tool locks its version in the `go.mod` file
    to prevent accidental code breakages. If you decide you want to update to a newer
    minor version, you can use the `go get -u` `package@version` command.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您添加一个依赖项时，`go` 工具会在 `go.mod` 文件中锁定其版本，以防止意外破坏代码。如果您决定要更新到较新的次要版本，您可以使用 `go
    get -u` `package@version` 命令。
- en: If you remove a dependency, you can run `go mod tidy` to clean up the `go.mod`
    file.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您移除了一个依赖项，您可以通过运行 `go mod tidy` 来清理 `go.mod` 文件。
- en: 'The two `go.*` files contain a full list of dependencies, including the ones
    that are not directly referenced in your code, that are indirect or chained/transitive
    dependencies. If you want to find out why a particular dependency is present in
    your `go.mod` file, you can use the `go mod why package` or `go mod graph` commands
    to print the dependency tree on the screen:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个 `go.*` 文件包含了一个完整的依赖项列表，包括那些在您的代码中没有直接引用的依赖项，即间接或链式/传递依赖项。如果您想知道为什么某个特定的依赖项出现在您的
    `go.mod` 文件中，您可以使用 `go mod why package` 或 `go mod graph` 命令在屏幕上打印依赖树：
- en: '[PRE39]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `go list` command can also be of help. It lists all the module dependencies:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`go list` 命令也可以提供帮助。它会列出所有模块依赖项：'
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It also lists the actual package dependencies:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 它还列出了实际的包依赖项：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you prefer a visual representation, there are projects such as Spaghetti
    (*Further reading*), a dependency analysis tool for Go packages, that can present
    this information with a user-friendly interface, as shown in *Figure 2**.8*:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢视觉表示，有一些项目，如 Spaghetti（*进一步阅读*），是一个用于 Go 包的依赖项分析工具，它可以以用户友好的界面展示这些信息，如图
    *图 2**.8* 所示：
- en: '![Figure 2.8 – Hugo dependency analysis ](img/B16971_02_08.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – Hugo 依赖分析](img/B16971_02_08.jpg)'
- en: Figure 2.8 – Hugo dependency analysis
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – Hugo 依赖分析
- en: One thing that is important to mention is that Go modules use semantic versioning.
    If you need to import a package that is part of a module at major version 2 or
    higher, you need to include that major version suffix in their import path (`github.com/username/my-project/v2
    v2.0.0`, for example).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事情需要提及，那就是 Go 模块使用语义版本控制。如果您需要导入一个属于主要版本 2 或更高版本的模块中的包，您需要在它们的导入路径中包含该主要版本后缀（例如，`github.com/username/my-project/v2
    v2.0.0`）。
- en: 'Before we move to the next command, let’s create a `go.mod` file for the example
    in the `ch02/hello` folder of the book’s GitHub repository (*Further reading*):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转到下一个命令之前，让我们为书籍 GitHub 仓库中 `ch02/hello` 文件夹中的示例创建一个 `go.mod` 文件（*进一步阅读*）：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, you can build a binary file for the program with `go build` without having
    to reference all the Go files in the folder (`*.go`).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用 `go build` 命令构建程序的二进制文件，而无需引用文件夹中所有的 Go 文件（`*.go`）。
- en: Get
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取
- en: Before the Go 1.11 release, you could use the `go get` command to download and
    install Go programs. This legacy behavior is being completely deprecated, starting
    from Go 1.17, so we won’t cover it here. From now on, the sole role of this command
    is the management of dependencies in the `go.mod` file to update them to a newer
    minor version.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 1.11 版本发布之前，您可以使用 `go get` 命令下载和安装 Go 程序。这种遗留行为从 Go 1.17 开始已被完全弃用，因此我们在这里不会涉及它。从现在起，此命令的唯一作用是管理
    `go.mod` 文件中的依赖项，以将它们更新到较新的次要版本。
- en: Install
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'The easiest way to compile and install a Go binary without explicitly downloading
    the source code is to use the `go install [packages]` command. In the background,
    the `go` tool still downloads the code if necessary, runs `go build`, and copies
    the binary into the `GOBIN` directory, but the `go` tool hides all this from the
    end user:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和安装Go二进制文件的最简单方法是不显式下载源代码，使用`go install [packages]`命令。在后台，如果需要，`go`工具仍然会下载代码，运行`go
    build`，并将二进制文件复制到`GOBIN`目录，但`go`工具会隐藏所有这些对最终用户来说：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `go install` command accepts an optional version suffix – for example, `@latest`
    – and falls back to the local `go.mod` file if the version is missing. Thus, when
    running `go install`, it’s recommended to always specify a version tag to avoid
    errors if the `go` tool cannot find a local `go.mod` file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`go install`命令接受一个可选的版本后缀 – 例如，`@latest` – 如果版本缺失，则回退到本地的`go.mod`文件。因此，当运行`go
    install`时，建议始终指定一个版本标签，以避免如果`go`工具找不到本地的`go.mod`文件时出现错误。'
- en: Fmt
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化
- en: Go takes much of the code formatting out of developers’ hands by shipping an
    opinionated formatting tool that you can invoke with the `go fmt` command pointing
    to your Go source code – for example, `go fmt source.go`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Go通过提供可以调用`go fmt`命令的格式化工具，将大部分代码格式化工作从开发者手中拿走，该命令指向你的Go源代码 – 例如，`go fmt source.go`。
- en: '[*Chapter 1*](B16971_01.xhtml#_idTextAnchor015), *Introduction*, covers how
    this improves code readability by making all Go code look similar. Most IDEs with
    plugins for Go automatically format your code every time you save it, making it
    one less problem to worry about for developers.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第一章*](B16971_01.xhtml#_idTextAnchor015)，*引言*，介绍了如何通过使所有Go代码看起来相似来提高代码的可读性。大多数带有Go插件的IDE在每次保存时都会自动格式化你的代码，这使得开发者少了一个需要担心的问题。'
- en: Test
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'Go is also opinionated when it comes to testing. It makes a few decisions on
    behalf of developers about the best way to organize code testing to unify the
    user experience and discourage the use of third-party frameworks:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试方面，Go也有自己的观点。它代表开发者做出一些关于最佳代码测试组织的决定，以统一用户体验并阻止使用第三方框架：
- en: It automatically executes all files with the `_test.go` suffix in their filenames
    when you run the `go test` command. This command accepts an optional argument
    that specifies which package, path, or source file to test.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行`go test`命令时，它会自动执行所有文件名带有`_test.go`后缀的文件。此命令接受一个可选的参数，用于指定要测试的包、路径或源文件。
- en: The Go standard library includes a special `testing` package that works with
    the `go test` command. Aside from unit test support, this package offers comprehensive
    coverage reports and benchmarks.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go标准库包括一个特殊的`testing`包，它与`go test`命令一起工作。除了单元测试支持外，此包还提供全面的覆盖率报告和基准测试。
- en: 'To put this into practice, we include a test program for the `ping` package
    that we described in the Go modules section. The `ping` package has a `Send` function,
    which returns the `pong` string when called. The test we perform should verify
    this. In the test program, we start by defining a string with the value we expect
    (`pong`) and then compare it to the result of the `ping` function. The `code_test.go`
    file ([https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch02/ping/code_test.go](https://sdg-tracker.org/))
    in the same folder as `ping` represents this in Go code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此方法付诸实践，我们在Go模块部分描述的`ping`包中包含了一个测试程序。`ping`包有一个`Send`函数，当被调用时返回`pong`字符串。我们进行的测试应该验证这一点。在测试程序中，我们首先定义一个包含我们期望的值（`pong`）的字符串，然后将其与`ping`函数的结果进行比较。与`ping`包在同一文件夹中的`code_test.go`文件（[https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch02/ping/code_test.go](https://sdg-tracker.org/））展示了如何用Go代码实现这一点：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'All test functions have a `TestXxx`(`t *testing.T`) signature, and whether
    they have access to any other functions and variables defined in the same package
    depends on how you name the package:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试函数都具有`TestXxx`(`t *testing.T`)签名，并且它们是否可以访问同一包中定义的任何其他函数和变量取决于你如何命名该包：
- en: '**ping**: This gives you access to everything in the package.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ping**：这让你可以访问包中的所有内容。'
- en: '`_test` suffix) that can live in the same folder as the package you are testing,
    but it does not have access to the original package variables and methods, so
    you must import it as any other user would do it. It’s an effective way to document
    how to use the package while testing it. In the example, we use the `ping.Send`
    function instead of `Send` directly, as we are importing the package.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_test` 后缀) 可以与你要测试的包位于同一文件夹中，但它无法访问原始包的变量和方法，因此你必须像其他用户一样导入它。这是在测试包的同时记录如何使用包的有效方法。在示例中，我们使用
    `ping.Send` 函数而不是直接使用 `Send`，因为我们正在导入包。'
- en: 'This is an assurance that the `Send` function always does the same even if
    they must optimize the code later. Now, every time you change the code, you can
    run the `go test` command to verify that the code still behaves the way you expect.
    By default, when you run `go test`, it prints the results of every test function
    it finds along with the time to execute them:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了 `Send` 函数始终以相同的方式执行，即使他们以后必须优化代码。现在，每次你更改代码时，你都可以运行 `go test` 命令来验证代码是否仍然以你期望的方式运行。默认情况下，当你运行
    `go test` 时，它会打印出它找到的每个测试函数的结果以及执行它们的时间：
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If someone makes a change in the code that modifies the behavior of the program
    so that it can no longer pass the test cases, we are in the presence of a potential
    bug. You can proactively identify software issues with the `go test` command.
    Let’s say they change the return value of the `Send` function to `p1ong`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人对代码进行了修改，改变了程序的行为，以至于它无法通过测试用例，那么我们面前就存在一个潜在的bug。你可以使用 `go test` 命令主动识别软件问题。假设他们把
    `Send` 函数的返回值更改为 `p1ong`：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `go test` command then generates an error the next time your continuous
    integration pipeline runs the test cases:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在下一次持续集成管道运行测试用例时，`go test` 命令会生成一个错误：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, you know you can’t promote this code to production. The benefit of testing
    is that you reduce the number of software bugs your users might run into, as you
    can catch them beforehand.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道你不能将这段代码提升到生产环境。测试的好处是你可以减少用户可能遇到的软件bug的数量，因为你可以提前捕捉到它们。
- en: Env
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Env
- en: 'The `go env` command displays the environment variables that the `go` command
    uses for configuration. The `go` tool can print these variables as flat text or
    in the JSON format with the `-``json` flag:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`go env` 命令显示 `go` 命令用于配置的环境变量。`go` 工具可以以纯文本或使用 `-json` 标志以 JSON 格式打印这些变量：'
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can change the value of a variable with `go env -w <NAME>=<VALUE>`. The
    next table describes some of these configuration environment variables:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `go env -w <NAME>=<VALUE>` 来更改变量的值。下表描述了一些这些配置环境变量：
- en: '![Table 2.3 – Some configuration environment variables ](img/B16971_02_Table_2.3.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![表 2.3 – 一些配置环境变量](img/B16971_02_Table_2.3.jpg)'
- en: Table 2.3 – Some configuration environment variables
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3 – 一些配置环境变量
- en: 'When you change a variable, the `go` tool stores its new value in the path
    specified by the `GOENV` variable, which defaults to `~/.config/go`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更改一个变量时，`go` 工具将其新值存储在由 `GOENV` 变量指定的路径中，默认为 `~/.config/go`：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding output example shows how to set the `GOBIN` directory explicitly
    and how to verify it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出示例展示了如何显式设置 `GOBIN` 目录以及如何验证它。
- en: Go offers a command-line utility that helps you manage your source code, from
    formatting your code to performing dependency management.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一个命令行工具，可以帮助你管理你的源代码，从格式化代码到执行依赖项管理。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed Go’s origins and its guiding principles, and how
    you should structure Go source code files and work with dependencies to run your
    Go programs.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了 Go 的起源和其指导原则，以及你应该如何结构化 Go 源代码文件以及如何与依赖项一起工作以运行你的 Go 程序。
- en: In the next chapter, we will drill down into the semantics of the Go language,
    the variable types, math logic, control flow, functions, and, of course, concurrency.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 Go 语言的语义、变量类型、数学逻辑、控制流、函数，当然还有并发。
- en: Further reading
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Less is exponentially* *more*: [https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html?m=1](https://docs.aws.amazon.com/wellarchitected/latest/sustainability-pillar/sustainability-pillar.html)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*少即是多*：[https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html?m=1](https://docs.aws.amazon.com/wellarchitected/latest/sustainability-pillar/sustainability-pillar.html)'
- en: '*Go: Ten years and* *climbing*: [https://commandcenter.blogspot.com/2017/09/go-ten-years-and-climbing.html](https://github.com/kubernetes/kubernetes/releases)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Go：十年成长*：[https://commandcenter.blogspot.com/2017/09/go-ten-years-and-climbing.html](https://github.com/kubernetes/kubernetes/releases)'
- en: '*Communicating Sequential* *Processes*: [https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf](https://kubernetes.io/docs/concepts/cluster-administration/addons/)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通信顺序* *进程*: [https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf](https://kubernetes.io/docs/concepts/cluster-administration/addons/)'
- en: '*Go 1.3+ Compiler* *Overhaul*: [https://golang.org/s/go13compiler](https://docs.projectcalico.org/manifests/tigera-operator.yaml)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Go 1.3+ 编译器* *重整*: [https://golang.org/s/go13compiler](https://docs.projectcalico.org/manifests/tigera-operator.yaml)'
- en: '*Type Parameters* *Proposal*: [https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md](B16971_02.xhtml)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类型参数* *提案*: [https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md](B16971_02.xhtml)'
- en: '*Go* *Proverbs*: [https://go-proverbs.github.io/](https://multipass.run/)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Go* *谚语*: [https://go-proverbs.github.io/](https://multipass.run/)'
- en: '*Concurrency is not* *Parallelism*: [https://www.youtube.com/watch?v=oV9rvDllKEg](https://multipass.run/)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并发不是* *并行性*: [https://www.youtube.com/watch?v=oV9rvDllKEg](https://multipass.run/)'
- en: 'The book’s GitHub repository: [https://github.com/PacktPublishing/Network-Automation-with-Go](B16971_02.xhtml)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该书的GitHub仓库：[https://github.com/PacktPublishing/Network-Automation-with-Go](B16971_02.xhtml)
- en: 'Go Playground: [https://go.dev/play/p/ndfJcayqaGV](B16971_02.xhtml)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Go Playground: [https://go.dev/play/p/ndfJcayqaGV](B16971_02.xhtml)'
- en: 'Playground source code: [https://go.googlesource.com/playground](https://docs.aws.amazon.com/wellarchitected/latest/framework/sustainability.html)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playground源代码：[https://go.googlesource.com/playground](https://docs.aws.amazon.com/wellarchitected/latest/framework/sustainability.html)
- en: 'Go Play Space: [https://goplay.space/](https://cloud.google.com/carbon-footprint)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Go Play Space: [https://goplay.space/](https://cloud.google.com/carbon-footprint)'
- en: 'Go’s standard library: [https://github.com/golang/go/tree/master/src](B16971_02.xhtml)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go的标准库：[https://github.com/golang/go/tree/master/src](B16971_02.xhtml)
- en: '*Practical Go: Real-world advice for writing maintainable Go* *programs*: [https://dave.cheney.net/practical-go/presentations/qcon-china.html#_comments](https://github.com/PacktPublishing/Network-Automation-with-Go)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用Go：编写可维护Go* *程序*的实际建议：[https://dave.cheney.net/practical-go/presentations/qcon-china.html#_comments](https://github.com/PacktPublishing/Network-Automation-with-Go)'
- en: 'The latest incarnation of the Go Playground: [https://talks.golang.org/2019/playground-v3/playground-v3.slide#1](https://go.dev/doc/install)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go Playground的最新版本：[https://talks.golang.org/2019/playground-v3/playground-v3.slide#1](https://go.dev/doc/install)
- en: '*Inside the Go* *Playground*: [https://go.dev/blog/playground](https://cloud.google.com/blog/topics/sustainability/pick-the-google-cloud-region-with-the-lowest-co2)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Go* *Playground*内部：[https://go.dev/blog/playground](https://cloud.google.com/blog/topics/sustainability/pick-the-google-cloud-region-with-the-lowest-co2)'
- en: 'Cmd documentation: [https://pkg.go.dev/cmd/go#pkg-overview](https://pkg.go.dev/syscall
    )'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cmd文档：[https://pkg.go.dev/cmd/go#pkg-overview](https://pkg.go.dev/syscall )
- en: 'Spaghetti: [https://github.com/adonovan/spaghetti](http://www.blender.org)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意面：[https://github.com/adonovan/spaghetti](http://www.blender.org)
- en: '*Deprecation of ’go get’ for installing* *executables*: [https://golang.org/doc/go-get-install-deprecation](https://cloud.google.com/recommender/docs/unattended-project-recommender)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对于安装* *可执行文件* *的‘go get’的弃用：[https://golang.org/doc/go-get-install-deprecation](https://cloud.google.com/recommender/docs/unattended-project-recommender)'
