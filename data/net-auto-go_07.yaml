- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Automation Frameworks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化框架
- en: Most engineers start their automation journey by writing small ad hoc scripts.
    Over time, as these scripts grow in size and number, we need to think about the
    operating model for the solutions we create and how strong the foundations we
    are building upon are. Ultimately, we have to coordinate automation practices
    across different teams to generate business outcomes at scale.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数工程师通过编写小型临时脚本开始他们的自动化之旅。随着时间的推移，随着这些脚本的大小和数量增加，我们需要考虑我们创建的解决方案的运营模式以及我们建立的基础有多牢固。最终，我们必须协调不同团队之间的自动化实践，以实现规模化的业务成果。
- en: To reduce the time and effort spent automating their use cases, some organizations
    try to standardize their tools and reuse generic components in their solutions,
    which often leads them to automation frameworks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少自动化用例所花费的时间和精力，一些组织试图标准化他们的工具并在解决方案中重用通用组件，这通常会导致他们转向自动化框架。
- en: Automation frameworks allow different teams to come together under the same
    umbrella, break silos that may lead to inefficiencies, embrace common practices
    and code reusability, and enforce policies across domains to make the developed
    solutions more secure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化框架允许不同的团队在同一伞下合作，打破可能导致低效的隔阂，采用共同实践和代码重用性，并在各个领域强制执行政策，以使开发出的解决方案更加安全。
- en: 'When choosing what best fits your environment and use cases, make sure you
    evaluate different automation frameworks. In this chapter, we will review some
    of them and focus specifically on how they can integrate with Go. In particular,
    we will look at the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择最适合您环境和用例的框架时，请确保评估不同的自动化框架。在本章中，我们将回顾其中一些，并特别关注它们如何与 Go 集成。特别是，我们将查看以下内容：
- en: How Go programs can become Ansible modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 程序如何成为 Ansible 模块
- en: The development of a custom Terraform provider
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 Terraform 提供器的开发
- en: An overview of the rest of the well-known Go-based frameworks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他知名基于 Go 的框架概述
- en: We close this chapter by looking at the current trends in the industry and how
    the new generation of automation frameworks may develop in the future.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过审视行业中的当前趋势以及新一代自动化框架未来的可能发展来结束本章。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code examples for this chapter in the book’s GitHub repository
    (see the *Further reading* section), in the `ch07` folder.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的 GitHub 仓库（见“进一步阅读”部分）的 `ch07` 文件夹中找到本章的代码示例。
- en: Important Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We recommend you execute the Go programs in this chapter in a virtual lab environment.
    Refer to the appendix for the prerequisites and instructions on how to build it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在虚拟实验室环境中执行本章中的 Go 程序。有关先决条件和构建它的说明，请参阅附录。
- en: Ansible
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible
- en: Ansible is an open source project, framework, and automation platform. Its descriptive
    automation language has captured the attention of many network engineers who see
    it as an introduction with minimal friction into the world of network automation
    and something that can help them become productive relatively quickly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一个开源项目、框架和自动化平台。其描述性自动化语言吸引了众多网络工程师的注意，他们认为它是进入网络自动化世界的入门途径，并且可以帮助他们相对快速地变得高效。
- en: Ansible has an agentless push-based architecture. It connects to the hosts it
    manages via SSH and runs a series of tasks. These tasks are small programs that
    we call Ansible modules, which are the units of code that Ansible abstracts away
    from the user. A user only has to give the input arguments and can rely on Ansible
    modules to do all the heavy work for them. Although the level of abstraction may
    vary, Ansible modules allow users to focus more on the desired state of their
    infrastructure and less on the individual commands required to achieve that state.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 采用无代理的推送式架构。它通过 SSH 连接到它管理的宿主机，并运行一系列任务。这些任务是我们称之为 Ansible 模块的小型程序，它们是
    Ansible 从用户抽象出来的代码单元。用户只需提供输入参数，就可以依赖 Ansible 模块为他们完成所有繁重的工作。尽管抽象级别可能有所不同，但 Ansible
    模块允许用户更多地关注其基础设施的期望状态，而不是实现该状态所需的单个命令。
- en: Overview of Ansible components
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 组件概述
- en: 'Playbooks are at the core of Ansible. These text-based declarative YAML files
    define a set of automation tasks that you can group in different plays. Each task
    runs a module that comes from either the Ansible code base or a third-party content
    collection:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks 是 Ansible 的核心。这些基于文本的声明性 YAML 文件定义了一组自动化任务，您可以将这些任务分组在不同的 Play 中。每个任务运行一个模块，该模块来自
    Ansible 代码库或第三方内容集合：
- en: '![Figure 7.1 – Ansible high-level diagram](img/B16971_07_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – Ansible 高级图](img/B16971_07_01.jpg)'
- en: Figure 7.1 – Ansible high-level diagram
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – Ansible 高级图
- en: We use an Ansible inventory to describe the hosts or network devices we want
    to manage with Ansible. *Figure 7**.1* provides a high-level overview of these
    elements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Ansible 清单来描述我们想要使用 Ansible 管理的主机或网络设备。*图 7*.1 提供了这些元素的高级概述。
- en: Inventory
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清单
- en: 'An inventory is a list of managed hosts you can define statically in a text
    file or pull dynamically from an external system. You can manage hosts individually
    or collectively using groups. The following code snippet shows an Ansible inventory
    file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 清单是一份您可以定义在文本文件中的静态托管主机列表，或者从外部系统动态提取。您可以使用组单独或集体管理主机。以下代码片段显示了 Ansible 清单文件：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can also use inventory to define group- and host-level variables that become
    available to Ansible playbooks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用清单来定义组和主机级别的变量，这些变量将可用于 Ansible 演练。
- en: Playbooks, plays, and tasks
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 演练、演练和任务
- en: 'Ansible playbooks are files that you write using a YAML-based **Domain-Specific
    Language** (**DSL**). A playbook can have one or more plays on it. Each Ansible
    play targets a host or a group of hosts from an inventory to perform a series
    of tasks in a specific order. The following code output shows an example of a
    playbook with a single play and two tasks:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 演练是您使用基于 YAML 的 **领域特定语言（DSL**）编写的文件。一个演练可以有一个或多个演练。每个 Ansible 演练针对清单中的一个或多个主机执行一系列任务。以下代码输出显示了一个包含单个演练和两个任务的演练示例：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last example is a snippet from a larger playbook (see *Further reading*)
    included in the `ch07/ansible` folder of this book’s GitHub repository. That playbook
    has four tasks spread across two different plays. We use that playbook to review
    different concepts throughout this section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例是从本书 GitHub 存储库中 `ch07/ansible` 文件夹包含的更大演练（见 *进一步阅读*）的一个片段。该演练在两个不同的演练中分散了四个任务。我们使用该演练在本节中回顾不同的概念。
- en: Modules
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: Each task executes an Ansible module. Although implementations may vary, the
    goal of an Ansible module is to be idempotent, so no matter how many times you
    run it against the same set of hosts, you always get the same outcome.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务执行一个 Ansible 模块。尽管实现可能不同，但 Ansible 模块的目标是幂等的，所以无论您多少次对同一组主机运行它，您总是得到相同的结果。
- en: Ansible ships with several modules written mostly in Python, but it doesn’t
    stop you from using another programming language, which is what we explore in
    this section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 随带提供了一些主要用 Python 编写的模块，但它不会阻止您使用其他编程语言，这正是我们在本节中要探讨的。
- en: Working with Ansible modules
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Ansible 模块一起工作
- en: The code of an Ansible module can execute either on a remote node, for hosts
    such as Linux servers, or locally, on the node running the playbook. The latter
    is what we typically do when the managed node is an API service or a network device
    because they both lack an execution environment with dependencies such as Linux
    shell and Python. Luckily, modern network operating systems meet those requirements,
    which give us both options of running the code locally or remotely.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 模块的代码可以在远程节点上执行，例如 Linux 服务器，或者在本地上执行，在运行演练的节点上。后者是我们通常在托管节点是 API 服务或网络设备时所做的，因为它们两者都缺乏具有依赖项（如
    Linux shell 和 Python）的执行环境。幸运的是，现代网络操作系统满足这些要求，这为我们提供了在本地或远程运行代码的两种选择。
- en: If you look at the preceding playbook snippet, you can see how we implemented
    these two options. The first task invokes the `go_srl` module that gets delegated
    to the localhost. This means it runs from the machine running Ansible and targets
    a remote host provided in the host argument. The second task executes the `go_cvx`
    module, which is not delegated and thus runs on a remote node, targeting its API
    calls at the localhost.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看前面的演练片段，您可以看到我们如何实现这两个选项。第一个任务调用 `go_srl` 模块，该模块被委派到本地主机。这意味着它从运行 Ansible
    的机器上运行，并针对在主机参数中提供的远程主机。第二个任务执行 `go_cvx` 模块，该模块没有被委派，因此它在远程节点上运行，将其 API 调用针对本地主机。
- en: 'The rest of the playbook uses a combination of local and remote execution environments,
    as denoted by the gear symbols in the following diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 演练的其余部分使用本地和远程执行环境的组合，如下图中齿轮符号所示：
- en: '![Figure 7.2 – Playbook example](img/B16971_07_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 演练示例](img/B16971_07_02.jpg)'
- en: Figure 7.2 – Playbook example
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 演练示例
- en: 'The Ansible playbook first runs an Ansible play to configure each node of the
    topology with these high-level objectives:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible剧本首先运行一个Ansible剧本来配置拓扑中的每个节点，并具有以下高级目标：
- en: Configure the SR Linux node (`srl`) using a compiled Go code we execute locally
    on the machine running Ansible
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们在运行Ansible的机器上本地执行的编译后的Go代码配置SR Linux节点（`srl`）
- en: Configure the NVIDIA Cumulus node (`cvx`) using a compiled Go code we execute
    on the remote node
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们在远程节点上执行的编译后的Go代码配置NVIDIA Cumulus节点（`cvx`）
- en: Configure the Arista EOS node (`ceos`) using a compiled Go code we execute locally
    on the machine running Ansible
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在运行Ansible的机器上本地执行的编译后的Go代码配置Arista EOS节点（`ceos`）
- en: The choice of local or remote execution environments in the preceding playbook
    is random and only serves to show the two different approaches. Since all our
    lab devices are Linux-based, we can change this behavior without reworking the
    Ansible modules we use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的剧本中，选择本地或远程执行环境是随机的，只是为了展示两种不同的方法。由于我们所有的实验室设备都是基于Linux的，我们可以改变这种行为，而无需重写我们使用的Ansible模块。
- en: The second play has a single task that verifies the configured state on all
    three devices using a non-compiled code we execute using the `go run` command.
    We use this last task to show an alternative approach to concurrency that uses
    Go native primitives instead of Ansible forks to execute tasks on several nodes
    at the same time. We discuss this later in this section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个剧本有一个单一的任务，使用我们通过`go run`命令执行的未编译代码来验证所有三个设备上的配置状态。我们使用这个最后任务来展示一种使用Go原生原语而不是Ansible分叉来同时执行多个节点任务的并发替代方法。我们将在本节后面讨论这个问题。
- en: Developing an Ansible module
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发Ansible模块
- en: 'While Ansible developers write most Ansible modules in Python, there are different
    reasons to write a module in another programming language:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Ansible开发者大多数使用Python编写Ansible模块，但编写模块为另一种编程语言有不同的原因：
- en: Your company might use another programming language already.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的公司可能已经使用另一种编程语言。
- en: Maybe you know or feel more comfortable writing in a different language.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能你知道或更习惯用另一种语言写作。
- en: The code is already available and there is no business justification to rewrite
    it in another programming language.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码已经可用，并且没有商业理由将其重写为另一种编程语言。
- en: You want to take advantage of a feature that is not available in Python.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想利用Python中不可用的功能。
- en: Ansible’s role is not to rip and replace everything that you have, especially
    if it’s working for you already. To illustrate this, we will take a set of Go
    programs from other chapters and turn them into Ansible modules we can execute
    in a playbook to configure our lab topology.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的角色不是要替换你拥有的所有东西，尤其是如果它已经为你工作的话。为了说明这一点，我们将从其他章节中取出一组Go程序，并将它们转换为可以在剧本中执行的Ansible模块，以配置我们的实验室拓扑。
- en: Ansible module interface
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ansible模块接口
- en: 'You can extend Ansible by adding custom modules. Their implementation code
    should go into the `library` folder. When Ansible runs into a task with a module
    that is not installed in the system, it looks for a file with the module’s name
    in the `library` folder and tries to run it as a module, going through the following
    sequence of steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加自定义模块来扩展Ansible。它们的实现代码应该放入`library`文件夹。当Ansible遇到一个未在系统中安装的模块的任务时，它会寻找一个与模块名称相同的文件在`library`文件夹中，并尝试将其作为模块运行，经过以下步骤：
- en: It saves all module arguments in a temporary file, for example, `/tmp/foo`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将所有模块参数保存到一个临时文件中，例如，`/tmp/foo`。
- en: It executes that module as a child process, passing it the filename as the first
    and only argument, for example, `./``library/my_module /tmp/foo`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将那个模块作为一个子进程执行，传递文件名作为第一个也是唯一的参数，例如，`./library/my_module /tmp/foo`。
- en: It waits for the process to complete and expects to receive a structured response
    in its standard output.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它等待进程完成，并期望从其标准输出接收结构化响应。
- en: While Ansible always expects a response in a JSON format, the input file format
    Ansible passes to the module depends on whether the module is a script or a binary.
    All binary modules get their input arguments as a JSON file, while script modules
    receive their input arguments as Bash files or just a list of key-value pairs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Ansible始终期望以JSON格式收到响应，但Ansible传递给模块的输入文件格式取决于模块是脚本还是二进制文件。所有二进制模块都从JSON文件获取输入参数，而脚本模块则接收Bash文件或只是一系列的键值对作为输入参数。
- en: From Go’s code perspective, to make this input behavior uniform, we normalize
    the input format to JSON before running any non-compiled Go programs. We do this
    using a wrapper Bash script that transforms the Bash input into JSON before calling
    the `go run` command, as you can see in the `ch07/ansible/library/go_state` file
    of this book’s GitHub repository (see *Further reading*).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从Go代码的角度来看，为了使这种输入行为统一，我们在运行任何非编译的Go程序之前，将输入格式标准化为JSON。我们使用一个包装Bash脚本来实现这一点，该脚本在调用`go
    run`命令之前将Bash输入转换为JSON，正如您在本书GitHub仓库的`ch07/ansible/library/go_state`文件中所见（见*进一步阅读*）。
- en: Adapting your Go code to interact with Ansible
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将您的Go代码适配以与Ansible交互
- en: Ultimately, a custom Ansible module can do anything as long as it understands
    how to parse the input arguments and knows how to return the expected output.
    We would need to change the Go programs from other chapters to make them an Ansible
    module. But the amount of changes necessary is minimal. Let’s examine this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，一个自定义Ansible模块可以执行任何操作，只要它知道如何解析输入参数，并且知道如何返回预期的输出。我们需要将其他章节的Go程序修改为Ansible模块。但所需更改的数量是微不足道的。让我们来检查一下。
- en: 'First, for this example, we need to create a struct to parse the module arguments
    we receive in the input JSON file. These arguments include login credentials and
    the input data model:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了这个例子，我们需要创建一个结构体来解析我们在输入JSON文件中接收到的模块参数。这些参数包括登录凭证和输入数据模型：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The input data model we use for Ansible remains the same as the one that we
    used in other chapters. This data is in the `ch07/ansible/host_vars` directory
    for this example. With Ansible, this data model becomes just a subset of all variables
    defined for each host. We pass it, along with the rest of the host variables,
    as a base64-encoded string. Inside our module, we decode the input string and
    decode it into the same `Model` struct we used before:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为Ansible使用的输入数据模型与其他章节中使用的相同。在这个例子中，这些数据位于`ch07/ansible/host_vars`目录。在Ansible中，这个数据模型变成了为每个主机定义的所有变量的一部分。我们将它，连同其他主机变量一起，作为base64编码的字符串传递。在我们的模块内部，我们解码输入字符串，并将其解码成我们之前使用的相同的`Model`结构体：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point, we’ve parsed enough information for our Go program to configure
    a network device. This part of the Go code does not require any modifications.
    The only thing you need to be mindful of is that instead of logging to the console,
    you now need to send any log messages as a response to Ansible.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经解析了足够的信息，让我们的Go程序能够配置网络设备。这部分Go代码不需要任何修改。您需要注意的唯一一点是，您现在需要将任何日志消息作为响应发送给Ansible。
- en: 'When all the work is complete, we need to prepare and print the response object
    for Ansible. The following code snippet shows the *happy path* when all changes
    have gone through:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有工作完成后，我们需要为Ansible准备和打印响应对象。以下代码片段显示了所有更改都已通过时的*正常路径*：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using a similar pattern to what we just described, we have created a custom
    module for each one of the three lab devices and one module to verify the state
    of the lab topology as we did in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144),
    *Configuration Management*. You can find these modules in the `ch07/ansible/`{`srl`|`cvx`|`ceos`|`state`}
    directories of this book’s GitHub repository (see *Further reading*).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与我们刚才描述的类似模式，我们为三个实验室设备中的每一个创建了一个自定义模块，以及一个用于验证实验室拓扑状态的模块，就像我们在[*第6章*](B16971_06.xhtml#_idTextAnchor144)“配置管理”中所做的那样。您可以在本书GitHub仓库的`ch07/ansible/`{`srl`|`cvx`|`ceos`|`state`}目录中找到这些模块（见*进一步阅读*）。
- en: Before we move on to the execution, we want to show one way we can make use
    of Go’s built-in features to speed up and optimize concurrent task execution in
    Ansible.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续执行之前，我们想展示一种我们可以利用Go的内置功能来加快和优化Ansible中并发任务执行的方法。
- en: Taking advantage of Go’s concurrency
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用Go的并发性
- en: Ansible’s default behavior is to run each task on all hosts before moving on
    to the next one (linear strategy). Of course, it doesn’t just run one task on
    one host at a time; instead, it uses several independent processes attempting
    to run simultaneously on as many hosts as the number of forks you define in the
    Ansible configuration. Whether these processes run in parallel depends on the
    hardware resources available to them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的默认行为是在继续执行下一个任务之前，先在所有主机上运行每个任务（线性策略）。当然，它并不是一次只在一个主机上运行一个任务；相反，它使用多个独立进程，尝试在您在Ansible配置中定义的fork数量所允许的主机数量上同时运行。这些进程是否并行运行取决于它们可用的硬件资源。
- en: A less expensive approach from a resource utilization perspective is to leverage
    Go concurrency. This is what we do in the `go_state` Ansible module, where we
    target a single node from the inventory, the implicit localhost, and leave the
    concurrent communication with the remote nodes to Go.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从资源利用的角度来看，一种更经济的方法是利用 Go 并发。这就是我们在 `go_state` Ansible 模块中所做的，我们针对清单中的单个节点，即隐含的本地主机，并将与远程节点的并发通信留给
    Go。
- en: 'For the following module, we reuse the code example from the *State validation*
    section of [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration Management*
    that has the access details embedded in the code already, but you could also pass
    these access details as arguments to the module to achieve the same result:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下模块，我们重用了来自 [*第 6 章*](B16971_06.xhtml#_idTextAnchor144) *配置管理* 部分的 *状态验证*
    部分的代码示例，其中已经将访问细节嵌入到代码中，但你也可以将这些访问细节作为参数传递给模块以实现相同的结果：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The trade - off of this approach is that we gain speed and get more efficient
    use of resources, but we lose the inventory management side of Ansible. Be mindful
    of this when trying to decide whether this is the right fit for your use case.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的权衡是，我们获得了速度并更有效地利用资源，但失去了 Ansible 的清单管理方面。在尝试决定这是否适合你的用例时，请注意这一点。
- en: Running the playbook
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行剧本
- en: 'You can find the complete example involving four Go Ansible modules in the
    `ch07/ansible` directory. To run it, first make sure the lab topology is running
    from the root folder of the repository with `make lab-up`, then run the playbook
    with the `ansible-playbook` command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `ch07/ansible` 目录中找到涉及四个 Go Ansible 模块的完整示例。要运行它，首先确保从存储库的根目录运行 `make lab-up`
    以启动实验室拓扑，然后使用 `ansible-playbook` 命令运行剧本：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we’ve covered how Go programs can integrate with Ansible, we will
    move on to another popular automation framework: Terraform.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 Go 程序如何与 Ansible 集成，我们将继续介绍另一个流行的自动化框架：Terraform。
- en: Terraform
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform
- en: Terraform is an open source software solution for declarative infrastructure
    management. It allows you to express and manage the desired state of your infrastructure
    with code. It has gained initial popularity as a framework to automate public
    cloud infrastructure but now supports a variety of on-premises and public cloud
    resources, platforms, services—almost anything that has an API.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一个用于声明性基础设施管理的开源软件解决方案。它允许你使用代码表达和管理你基础设施的期望状态。它最初作为自动化公共云基础设施的框架而受到欢迎，但现在支持各种本地和公共云资源、平台、服务——几乎任何有
    API 的东西。
- en: One of the key distinctions of Terraform is the way it manages state. Once it
    creates a remote resource initially, it saves the resulting state in a file and
    relies on that state to be there for its next runs. As you update and develop
    your infrastructure code, the state file enables Terraform to manage the entire
    life cycle of a remote resource, calculating the precise sequence of API calls
    to transition between states. This ability to manage state and the declarative
    configuration language and the agentless, API-first architecture allowed Terraform
    to become deeply entrenched in the cloud infrastructure space and become a critical
    part of DevOps and Infrastructure-as-Code toolchains.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 的一个关键区别在于它管理状态的方式。一旦它最初创建了一个远程资源，它就会将产生的状态保存到一个文件中，并依赖于这个状态在后续运行中存在。随着你更新和开发你的基础设施代码，状态文件使
    Terraform 能够管理远程资源的整个生命周期，计算在状态之间转换的确切 API 调用序列。这种管理状态的能力、声明性配置语言以及无代理、API 首选的架构使得
    Terraform 在云基础设施领域深深扎根，并成为 DevOps 和基础设施即代码工具链的关键部分。
- en: If we look at the Terraform registry (see *Further reading*), we can see over
    a hundred providers in the networking category ranging from SDN appliances and
    firewalls to various cloud services. This number is on a rising trend, as more
    people adopt a declarative approach to manage their infrastructure as code. This
    is why we believe it’s important for network automation engineers to know Terraform
    and be able to extend its capabilities using Go.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 Terraform 注册表（见 *进一步阅读*），我们可以看到网络类别中有超过一百个提供者，从 SDN 设备和防火墙到各种云服务。这个数字正在上升的趋势中，因为越来越多的人采用声明性方法来管理他们的基础设施代码。这就是为什么我们认为对于网络自动化工程师来说，了解
    Terraform 并能够使用 Go 扩展其功能非常重要。
- en: Overview of Terraform components
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform 组件概述
- en: The entire Terraform ecosystem is a collection of Go packages. They distribute
    the main CLI tool, often referred to as *Terraform Core*, as a statically compiled
    binary. This binary implements the command-line interface and can parse and evaluate
    instructions written in **Hashicorp Configuration Language** (**HCL**). On every
    invocation, it builds a resource graph and generates an execution plan to reach
    the desired state described in the configuration file. The main binary only includes
    a few plugins but can discover and download the required dependencies.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 Terraform 生态系统是一系列 Go 包的集合。它们分发主要的 CLI 工具，通常称为 *Terraform 核心工具*，作为一个静态编译的二进制文件。这个二进制文件实现了命令行界面，并可以解析和评估用
    **Hashicorp 配置语言**（**HCL**）编写的指令。在每次调用时，它构建一个资源图并生成一个执行计划，以实现配置文件中描述的期望状态。主要二进制文件只包含少数插件，但可以发现和下载所需的依赖。
- en: 'Terraform plugins are also distributed as standalone binaries. Terraform Core
    starts and terminates the required plugins as child processes and interacts with
    them using an internal gRPC-based protocol. Terraform defines two types of plugins:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 插件也作为独立的二进制文件分发。Terraform 核心工具作为子进程启动和终止所需的插件，并使用基于 gRPC 的内部协议与它们交互。Terraform
    定义了两种类型的插件：
- en: '**Providers**: Interact with a remote infrastructure provider and implement
    the required changes'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供者**：与远程基础设施提供者交互并实施所需更改'
- en: '**Provisioners**: Implement a set of imperative actions, declared as a set
    of terminal commands, to bootstrap a resource that a provider created before'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置器**：实现一组命令式操作，作为一组终端命令声明，以引导提供者创建的资源'
- en: 'The following diagram demonstrates what we have described and shows how different
    Terraform components communicate internally and externally:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了我们所描述的内容，并显示了不同的 Terraform 组件如何在内部和外部进行通信：
- en: '![Figure 7.3 – Terraform high-level diagram](img/B16971_07_03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – Terraform 高级图](img/B16971_07_03.jpg)'
- en: Figure 7.3 – Terraform high-level diagram
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – Terraform 高级图
- en: 'The vast majority of Terraform plugins are providers as they implement the
    declarative resource actuation and communicate with an upstream API. A provider
    defines two types of objects that you can use to interact with a remote API:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Terraform 插件都是提供者，因为它们实现了声明式资源激活并与上游 API 通信。提供者定义了两种类型的对象，您可以使用它们与远程 API
    交互：
- en: '**Resources**: Represent the actual managed infrastructure objects, such as
    virtual machines, firewall policies, and DNS records'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：表示实际管理的基础设施对象，例如虚拟机、防火墙策略和 DNS 记录'
- en: '**Data Sources**: Offer a way to query information that is not managed by Terraform,
    such as a list of supported cloud regions, VM images, or **Identity and Access
    Management** (**IAM**) roles'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据源**：提供一种查询不由 Terraform 管理的信息的方式，例如支持的云区域列表、虚拟机镜像或**身份和访问管理**（**IAM**）角色'
- en: It’s up to the Terraform provider maintainers to decide what resources and data
    sources to implement, so the coverage may vary, especially between official and
    community-supported providers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 提供者维护者决定要实现哪些资源和数据源，因此覆盖范围可能有所不同，尤其是在官方和社区支持的提供者之间。
- en: Working with Terraform
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Terraform
- en: A typical Terraform workflow involves several stages that need to happen in
    sequence. We first need to define a provider that determines what infrastructure
    we would manage, and then describe the state of our infrastructure using a combination
    of resources and data sources. We will walk through these stages by following
    a configuration file, `ch07/terraform/main.tf`, we’ve created in this book’s GitHub
    repository (see *Further reading*).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 Terraform 工作流程涉及几个需要按顺序发生的阶段。我们首先需要定义一个提供者，以确定我们将要管理的基础设施，然后使用资源和数据源的组合来描述我们的基础设施状态。我们将通过遵循本书
    GitHub 仓库中创建的配置文件 `ch07/terraform/main.tf` 来逐步介绍这些阶段（见 *进一步阅读*）。
- en: Defining a provider
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义提供者
- en: Providers define connection details for the upstream API. They can point at
    the public AWS API URL or an address of a private vCenter instance. In the next
    example, we show how to manage the demo instance of Nautobot running at [https://demo.nautobot.com/](https://demo.nautobot.com/).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者定义了上游 API 的连接细节。它们可以指向公共 AWS API URL 或私有 vCenter 实例的地址。在下一个示例中，我们将展示如何管理运行在
    [https://demo.nautobot.com/](https://demo.nautobot.com/) 的 Nautobot 示例实例。
- en: 'Terraform expects to find a list of required providers, along with their definition,
    in one file in the current working directory. For the sake of simplicity, we include
    those details at the top of the `main.tf` file and define credentials in the same
    file. In production environments, these details may live in a separate file, and
    you should source credentials externally, for example, from environment variables:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 期望在当前工作目录中的一个文件中找到所需提供者的列表及其定义。为了简化，我们将这些详细信息包含在 `main.tf` 文件的顶部，并在同一文件中定义凭证。在生产环境中，这些详细信息可能位于单独的文件中，您应该从外部源获取凭证，例如，从环境变量中：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this information defined, we can initialize Terraform. The following command
    instructs Terraform to perform plugin discovery and download any dependencies
    into a local `./``terraform` directory:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些信息后，我们可以初始化 Terraform。以下命令指示 Terraform 执行插件发现并将任何依赖项下载到本地的 `./terraform`
    目录中：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At the end of this step, Terraform creates a lock file, `.terraform.lock.hcl`,
    to record the provider selections it just made. Include this file in your version
    control repository so that Terraform can guarantee to make the same selections
    by default when you run `terraform init` on a different machine.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤结束时，Terraform 创建一个锁文件，`.terraform.lock.hcl`，以记录它刚刚做出的提供者选择。将此文件包含在版本控制存储库中，以便
    Terraform 可以在您在不同机器上运行 `terraform init` 时默认做出相同的选择。
- en: Creating a resource
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建资源
- en: 'To create a resource, we define it in a configuration block with zero or more
    arguments that assign values to resource fields. The following resource creates
    a new `Manufacturer` object in Nautobot with the specified name and description:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建资源，我们在配置块中定义它，并使用零个或多个参数将值分配给资源字段。以下资源在 Nautobot 中创建了一个新的 `Manufacturer`
    对象，具有指定的名称和描述：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we can run `terraform plan` to check whether the current configuration
    matches the existing state. If they don’t match, Terraform creates an execution
    plan with the proposed changes to make the remote objects match the current configuration.
    We could skip the `terraform plan` command and move straight to `terraform apply`,
    which generates the plan and also executes it in a single step:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 `terraform plan` 来检查当前配置是否与现有状态匹配。如果不匹配，Terraform 将创建一个执行计划，其中包含使远程对象匹配当前配置的提议更改。我们可以跳过
    `terraform plan` 命令，直接转到 `terraform apply`，它将生成计划并在一个步骤中执行：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see the result of running this plan in Nautobot’s web UI at [https://demo.nautobot.com/dcim/manufacturers/new-vendor/](https://demo.nautobot.com/dcim/manufacturers/new-vendor/),
    or you can check the resulting state using the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Nautobot 的 Web UI 中查看此计划的运行结果，网址为 [https://demo.nautobot.com/dcim/manufacturers/new-vendor/](https://demo.nautobot.com/dcim/manufacturers/new-vendor/)，或者您可以使用以下命令检查生成的状态：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At the time of writing, there was no Terraform provider available for Nautobot,
    so the last example used a custom provider we created specifically for this book.
    Creating a new provider can enable many new use cases and it involves writing
    Go code, so this is what we cover next.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，没有可用的 Terraform 提供者适用于 Nautobot，所以最后一个示例使用了我们为这本书专门创建的自定义提供者。创建新的提供者可以启用许多新的用例，并且它涉及编写
    Go 代码，所以这就是我们接下来要讨论的内容。
- en: Developing a Terraform provider
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发 Terraform 提供者
- en: Eventually, you may come across a provider with limited or missing capabilities,
    or a provider may not even exist for a platform that is part of your infrastructure.
    This is when knowing how to build a provider can make a difference, to either
    extend or fix a provider or build a brand new one. The only prerequisite to get
    started is the availability of a Go SDK for the target platform. For example,
    Nautobot has a Go client package that gets automatically generated from its OpenAPI
    model, which we used already in the *Getting config inputs from other systems
    via HTTP* section of [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration
    Management*, so we have all we need to develop its Terraform provider.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你可能会遇到功能有限或缺失的提供者，或者对于你的基础设施中的一部分平台，可能根本不存在提供者。这时，了解如何构建提供者可以起到关键作用，无论是扩展或修复提供者，还是构建全新的提供者。开始前的唯一先决条件是目标平台有可用的
    Go SDK。例如，Nautobot 有一个 Go 客户端包，它可以从其 OpenAPI 模型自动生成，我们在 [*第 6 章*](B16971_06.xhtml#_idTextAnchor144)
    的 *通过 HTTP 从其他系统获取配置输入* 部分已经使用过，*配置管理*，因此我们已经有了一切所需来开发其 Terraform 提供者。
- en: The recommended way to create a new Terraform provider is to start with the
    terraform-provider-scaffolding project (see *Further reading*). This repository
    provides enough boilerplate to allow you to focus on the internal logic while
    it provides function stubs and implements **Remote Procedure Call** (**RPC**)
    integration. We used this template to create the Nautobot provider, so you can
    compare our final result with the template to see what changes we made.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新Terraform提供者的推荐方法是先从terraform-provider-scaffolding项目开始（见*进一步阅读*）。这个仓库提供了足够的样板代码，让你可以专注于内部逻辑，同时它提供了功能占位符并实现了**远程过程调用**（**RPC**）集成。我们使用这个模板创建了Nautobot提供者，所以你可以将我们的最终结果与模板进行比较，看看我们做了哪些修改。
- en: As a by-product of developing a Terraform provider using the scaffolding project,
    you can register your Git repository in the Terraform registry and get the benefit
    of automatically rendered provider documentation (see *Further reading*).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用脚手架项目开发Terraform提供者的副产品，你可以在Terraform注册表中注册你的Git仓库，并享受自动渲染的提供者文档的好处（见*进一步阅读*）。
- en: Defining a provider
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义提供者
- en: 'The provider’s internal code (`internal/provider/provider.go` (see *Further
    reading*)) starts with a schema definition for the provider itself as well as
    its managed resources and data sources. Inside the provider’s schema, we define
    two input arguments—`url` and `token`. You can extend each schema struct with
    more constraints, default values, and validation functions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者内部代码（`internal/provider/provider.go`（见*进一步阅读*））从为提供者本身以及其管理的资源和数据源定义架构开始。在提供者的架构内部，我们定义了两个输入参数——`url`和`token`。你可以通过添加更多的约束、默认值和验证函数来扩展每个架构结构：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With login information defined, the provider can initialize an API client for
    the target platform. This happens inside a local function where `url` and `token`
    get passed to the Nautobot’s Go SDK, which creates a fully authenticated HTTP
    client. We save this client in a special `apiClient` struct, which gets passed
    as an argument to all provider resources, as we show later on:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了登录信息后，提供者可以为目标平台初始化一个API客户端。这发生在本地函数内部，其中`url`和`token`被传递给Nautobot的Go SDK，它创建了一个完全认证的HTTP客户端。我们将这个客户端保存在一个特殊的`apiClient`结构体中，它随后被传递给所有提供者资源，正如我们稍后所展示的：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have prepared a remote API client, we can start writing code for
    our managed resources.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备了一个远程API客户端，我们可以开始编写我们管理资源的代码。
- en: Defining resources
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义资源
- en: Just like how we defined a schema for our provider, we now need to define a
    schema for each managed resource and data source. For educational purposes, we
    only implement a single resource type, `Manufacturer`, and a corresponding data
    source you can use to retrieve the list of all existing manufacturers in Nautobot.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们为我们的提供者定义架构一样，我们现在需要为每个管理的资源和数据源定义一个架构。出于教育目的，我们只实现了一个资源类型，`Manufacturer`，以及一个相应的数据源，你可以用它来检索Nautobot中所有现有制造商的列表。
- en: 'When we define a schema, our goal is to match the upstream API as closely as
    possible. This should reduce the number of required data transformations and make
    the implementation work much easier. Let’s look at Nautobot’s Go SDK code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义架构时，我们的目标是尽可能接近上游API。这应该会减少所需的数据转换数量，并使实现工作更加容易。让我们看看Nautobot的Go SDK代码：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The schema that we define for the `Manufacturer` resource in `resource_manufacturer.go`
    closely follows the fields and types defined in the preceding output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`resource_manufacturer.go`中为`Manufacturer`资源定义的架构紧密遵循前面输出中定义的字段和类型：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once we have defined all schemas with their constraints, types, and descriptions,
    we can start implementing resource operations. The scaffolding project provides
    stubs for each one of the CRUD functions, so we only need to fill them out with
    code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了所有具有约束、类型和描述的架构，我们就可以开始实现资源操作。脚手架项目为每个CRUD函数提供了占位符，所以我们只需要用代码填充它们。
- en: The create operation
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建操作
- en: 'We first look at the `resourceManufacturerCreate` function, which gets invoked
    when Terraform determines that it must create a new object. This function has
    two very important arguments:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看看`resourceManufacturerCreate`函数，当Terraform确定必须创建一个新对象时，该函数会被调用。这个函数有两个非常重要的参数：
- en: '`meta`: Stores the API client we created earlier'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta`：存储我们之前创建的API客户端'
- en: '`d`: Stores all resource arguments defined in the HCL configuration file'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：存储在HCL配置文件中定义的所有资源参数'
- en: 'We extract the user-defined configuration from `d` and use it to build a new
    `nb.Manufacturer` object from the Nautobot’s SDK. We can then use the API client
    to send that object to Nautobot and save the returned object ID:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `d` 中提取用户定义的配置，并使用它从 Nautobot 的 SDK 中构建一个新的 `nb.Manufacturer` 对象。然后我们可以使用
    API 客户端将此对象发送到 Nautobot 并保存返回的对象 ID：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Typically, we don’t define all optional fields when we create a new object.
    A remote provider assigns the unique ID and initializes default values as it creates
    a new object. Some platforms return the newly created object back, but there is
    no guarantee of that. Hence, it’s a common pattern in Terraform provider implementations
    to call a read function at the end of the create function to synchronize and update
    a local state.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在创建新对象时不会定义所有可选字段。远程提供者在创建新对象时分配唯一的 ID 并初始化默认值。一些平台会返回新创建的对象，但没有任何保证。因此，在
    Terraform 提供器实现中，在创建函数的末尾调用 read 函数以同步和更新本地状态是一种常见的模式。
- en: The read operation
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取操作
- en: The read function updates the local state to reflect the latest state of an
    upstream resource. We’ve seen in the preceding example how the create function
    calls the read at the end of its execution to update the state of a newly created
    object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 读取函数更新本地状态以反映上游资源的最新状态。我们在先前的示例中看到，创建函数在其执行结束时调用 read 函数以更新新创建对象的州。
- en: But the most important use of read is to detect configuration drift. When you
    do `terraform plan` or `terraform apply`, read is the first thing that Terraform
    executes and its goal is to retrieve the current upstream state and compare it
    with the state file. This allows Terraform to understand whether users have manually
    changed a remote object, so it needs to reconcile its state, or whether it’s up
    to date and no updates are necessary.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但 read 的最重要用途是检测配置漂移。当你执行 `terraform plan` 或 `terraform apply` 时，read 是 Terraform
    首先执行的操作，其目标是检索当前的上游状态并与状态文件进行比较。这使得 Terraform 能够理解用户是否手动更改了远程对象，因此它需要协调其状态，或者是否是最新的且不需要更新。
- en: 'Read has the same signature as the rest of the CRUD functions, which means
    it gets the latest version of a managed resource as `*schema.ResourceData` and
    an API client stored in `meta`. The first thing we need to do in this function
    is fetch the upstream object:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Read 函数与 CRUD 函数的签名相同，这意味着它以 `*schema.ResourceData*` 的形式获取托管资源的最新版本，并在 `meta`
    中存储 API 客户端。在这个函数中，我们首先需要做的事情是获取上游对象：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We use the data we get back to update the local Terraform state:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用返回的数据来更新本地 Terraform 状态：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this stage, our local state should be in sync with the upstream and Terraform
    can decide whether any changes are necessary as a result.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的本地状态应该与上游同步，Terraform 可以决定是否需要任何更改。
- en: Remaining implementations
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 剩余实现
- en: 'In this chapter, we only cover a subset of the Nautobot provider code. The
    remaining sections we need to implement include the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只涵盖了 Nautobot 提供器代码的一部分。我们需要实现的剩余部分包括以下内容：
- en: The resource **update** and **delete** functions
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源 **更新** 和 **删除** 函数
- en: '**Data** **source** implementation'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据** **源** 实现'
- en: For the sake of brevity, we don’t include this code in the book, but the full
    implementation for the `Manufacturer` resource and data source is available in
    our demo Nautobot provider repository (see *Further reading*).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们没有在书中包含此代码，但 `Manufacturer` 资源和数据源的完整实现可以在我们的演示 Nautobot 提供器存储库中找到（见
    *进一步阅读*）。
- en: Networking providers
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络提供器
- en: Writing a provider and keeping it up to date is a major undertaking. At the
    beginning of this section, we mentioned that Terraform has several providers in
    the networking category of the Terraform registry (see *Further reading*). We
    invite you to explore them and always check whether there’s an existing provider
    before implementing your own.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 编写提供器并保持其更新是一项重大任务。在本节的开头，我们提到 Terraform 在 Terraform 注册表的网络类别中有几个提供器（见 *进一步阅读*）。我们邀请您探索它们，并在实现自己的提供器之前始终检查是否存在现有的提供器。
- en: 'Terraform’s guarantees of declarative configuration and state management are
    very appealing to network engineers trying to adopt DevOps and GitOps practices.
    As the interest grows, so does the number of new network-related providers, with
    the following notable recent additions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 对声明性配置和状态管理的保证对试图采用 DevOps 和 GitOps 实践的网络工程师非常有吸引力。随着兴趣的增长，新的网络相关提供器的数量也在增加，以下是一些值得注意的最近新增的提供器：
- en: '**JUNOS Terraform Automation Framework** (see *Further reading*): Allows you
    to create a custom JunOS Terraform provider from YANG files'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JUNOS Terraform Automation Framework**（参见 *进一步阅读*）：允许您从 YANG 文件创建自定义的 JunOS
    Terraform 提供程序'
- en: '**Terraform Provider for Cisco IOS XE** (see *Further reading*): Manages the
    configuration of Cisco Catalyst IOS XE devices including switches, routers, and
    wireless LAN controllers'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Terraform Provider for Cisco IOS XE**（参见 *进一步阅读*）：管理 Cisco Catalyst IOS XE
    设备的配置，包括交换机、路由器和无线局域网控制器'
- en: '**terraform-provider-junos** (see *Further reading*): An unofficial Terraform
    provider for Junos OS devices with the NETCONF protocol'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**terraform-provider-junos**（参见 *进一步阅读*）：一个非官方的 Terraform 提供程序，用于支持 NETCONF
    协议的 Junos OS 设备'
- en: '**terraform-provider-ciscoasa** (see *Further reading*): DevNet provider to
    configure Cisco ASA firewall rules'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**terraform-provider-ciscoasa**（参见 *进一步阅读*）：DevNet 提供程序，用于配置 Cisco ASA 防火墙规则'
- en: This completes the overview of Terraform and its network-related use cases.
    We hope that its adoption continues to increase and the number of networking providers
    grows. In the next section, we wrap up with a brief overview of a few other automation
    frameworks.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对 Terraform 及其网络相关用例的概述。我们希望其采用率继续增加，网络提供商的数量也不断增加。在下一节中，我们将简要概述几个其他自动化框架。
- en: Other automation frameworks
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他自动化框架
- en: Our industry has many more automation frameworks and solutions that we would
    have liked to cover in this chapter. The best we can do is just scratch the surface,
    leaving much of the exploration up to you. At the same time, we don’t want to
    leave you thinking there’s nothing out there besides Ansible and Terraform. This
    section gives you an overview of other automation frameworks and solutions that
    you can use or adapt to use within a networking context.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们行业还有许多其他自动化框架和解决方案，我们本希望在这一章中涵盖。我们所能做的最好的事情就是触及表面，将大部分探索留给您。同时，我们也不想让您认为除了
    Ansible 和 Terraform 之外没有其他东西。本节为您概述了其他可以用于或适应在网络安全环境中使用的自动化框架和解决方案。
- en: Gornir
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gornir
- en: Nornir (see *Further reading*) is a popular network automation framework for
    Python that offers a pure programming experience by ditching DSL in favor of the
    Python API. It has a pluggable architecture where you can replace or extend almost
    any element of the framework, from inventory to device connections. It also has
    a flexible way to parallelize groups of tasks without having to deal with Python’s
    concurrency primitives directly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Nornir（参见 *进一步阅读*）是一个流行的 Python 网络自动化框架，通过放弃 DSL 而选择 Python API 提供了纯编程体验。它具有可插拔的架构，您可以从库存到设备连接几乎替换或扩展框架的任何元素。它还提供了一种灵活的方式来并行化任务组，而无需直接处理
    Python 的并发原语。
- en: Gornir (see *Further reading*) is a Nornir implementation in Go. Keeping with
    the same principles, it offers things such as inventory management, concurrent
    execution of tasks, and pluggable connection drivers. Gornir ships with a minimal
    set of drivers, but its core provides Go interfaces to improve upon and extend
    this feature. If you’re coming to Go from Python and are familiar with Nornir,
    Gornir may offer a very smooth transition through a familiar API and workflows.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Gornir（参见 *进一步阅读*）是 Nornir 的 Go 语言实现。遵循相同的原理，它提供了诸如库存管理、任务并发执行和可插拔连接驱动程序等功能。Gornir
    随附的最小驱动程序集，但其核心提供了 Go 接口，以改进和扩展此功能。如果您从 Python 转向 Go 并且熟悉 Nornir，Gornir 可能会通过熟悉的
    API 和工作流程提供一个非常平滑的过渡。
- en: Consul-Terraform-Sync
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Consul-Terraform-Sync
- en: In the preceding section, we examined how you can use Terraform to manage resources
    declaratively on a remote target, using Nautobot as an example. Hashicorp, the
    same company behind Terraform, has developed another automation solution that
    builds on top of it. It’s called Consul-Terraform-Sync (see *Further reading*)
    and it enables automatic infrastructure management by combining Terraform with
    Consul and linking them together with a synchronization agent.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了如何使用 Terraform 在远程目标上声明式地管理资源，并以 Nautobot 为例。与 Terraform 同属 Hashicorp
    公司开发的另一项自动化解决方案在此基础上构建。它被称为 Consul-Terraform-Sync（参见 *进一步阅读*），通过结合 Terraform 和
    Consul 并使用同步代理将它们链接在一起，实现了自动基础设施管理。
- en: Consul is a distributed key/value store used for service discovery, load balancing,
    and access control. It works by setting up a cluster of nodes that use the Raft
    consensus protocol to have a consistent view of their internal state. Server nodes
    communicate with their clients and broadcast relevant updates to make sure clients
    have an up-to-date version of the relevant part of the internal state. All this
    happens behind the scenes, with minimal configuration, which makes Consul a very
    popular choice for service discovery and data storage.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Consul 是一个分布式键/值存储，用于服务发现、负载均衡和访问控制。它通过设置一个使用 Raft 一致性协议的节点集群来工作，以保持对其内部状态的一致视图。服务器节点与其客户端通信并广播相关更新，以确保客户端拥有相关内部状态的相关部分的最新版本。所有这些都在幕后进行，配置最小化，这使得
    Consul 成为服务发现和数据存储的一个非常受欢迎的选择。
- en: The main idea of the Consul-Terraform-Sync solution is to use Consul as a backend
    for Terraform configuration and state. The synchronization agent connects to Consul,
    waits for updates, and automatically triggers Terraform reconciliation as it detects
    any changes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Consul-Terraform-Sync 解决方案的主要思想是将 Consul 用作 Terraform 配置和状态的底层。同步代理连接到 Consul，等待更新，并在检测到任何更改时自动触发
    Terraform 协调。
- en: Consul-Terraform-Sync allows you to automate Terraform deployments for any of
    these providers and ensures that your state always matches your intent thanks
    to the automated reconciliation process.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Consul-Terraform-Sync 允许您自动化任何这些提供程序的 Terraform 部署，并通过自动协调过程确保您的状态始终与您的意图相匹配。
- en: mgmt
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mgmt
- en: '`mgmt` (see *Further reading*) is another infrastructure automation and management
    framework written completely in Go. It has its own DSL and synchronizes its state
    using a baked-in etcd cluster. It uses a few interesting ideas, such as a declarative
    and functional DSL, resource graphs, and dynamic state transitions triggered by
    closed-loop feedback. Just like Gornir, `mgmt` ships with a set of plugins that
    users can extend, but none of these plugins is specifically for network devices
    since the main use case for mgmt is Linux server management.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`mgmt`（见*进一步阅读*）是另一个完全用 Go 编写的基础设施自动化和管理框架。它有自己的 DSL，并使用内置的 etcd 集群同步其状态。它使用了一些有趣的想法，例如声明性和函数式
    DSL、资源图和由闭环反馈触发的动态状态转换。就像 Gornir 一样，`mgmt` 随附一套插件，用户可以扩展，但没有任何插件是专门针对网络设备的，因为
    mgmt 的主要用例是 Linux 服务器管理。'
- en: Looking into the future
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展望未来
- en: In this chapter, we have covered popular network automation frameworks in use
    today. All these frameworks are at a different stage of development—some have
    already reached their peak while others are still crossing the chasm (see *Further
    reading*). But it’s important to remember that automation frameworks are not a
    solved problem with well-established projects and well-understood workflows. This
    field is constantly developing, and new automation approaches are emerging on
    the horizon.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了目前使用的流行网络自动化框架。所有这些框架都处于不同的开发阶段——一些已经达到顶峰，而另一些仍在跨越鸿沟（见*进一步阅读*）。但重要的是要记住，自动化框架不是一个已经解决的问题，有成熟的项目和已理解的流程。这个领域正在不断发展，新的自动化方法正在地平线上出现。
- en: 'These alternative approaches do not resemble what we had seen before. One big
    trend that we’re seeing lately is the departure from an imperative automation
    paradigm, where a human operator manually triggers actions and tasks. We briefly
    discussed this trend in [*Chapter 5*](B16971_05.xhtml#_idTextAnchor128), *Network
    Automation*, and we want to revisit it here to show how the *closed-loop* automation
    approach changes the landscape of infrastructure management systems. Most modern
    automation frameworks develop into systems that exhibit some or all the following
    characteristics:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些替代方法与我们之前所见的不同。最近我们看到的一个大趋势是离开命令式自动化范式，在这种范式中，人类操作员手动触发动作和任务。我们在[*第五章*](B16971_05.xhtml#_idTextAnchor128)“网络自动化”中简要讨论了这一趋势，并希望在这里重新探讨，以展示闭环自动化方法如何改变基础设施管理系统格局。大多数现代自动化框架发展成具有以下一些或所有以下特征的系统：
- en: Focus on the complete life cycle management of a system as opposed to individual
    stages, such as bootstrapping, provisioning, or decommissioning.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于系统的完整生命周期管理，而不是像引导、配置或退役这样的单个阶段。
- en: Exclusive use of declarative state definition and automatic reconciliation,
    or self-healing implemented internally.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用声明性状态定义和自动协调，或内部实现的自我修复。
- en: Separation of state definitions from the platform managing this state through
    practices such as GitOps.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过GitOps等实践将状态定义与平台管理分离。
- en: Offer a cloud-native self-service experience via APIs, reducing the friction
    in consuming of these services both manually and programmatically.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过API提供云原生自助服务体验，减少手动和程序化消费这些服务的摩擦。
- en: We’re currently at a point when these systems and their building blocks are
    becoming a reality, with some notable examples including Crossplane, Nokia Edge
    Network Controller, and Anthos Config Sync. They build these systems as Kubernetes
    controllers, leveraging the Operator model, allowing them to expose their APIs
    in a standard way, so other systems can talk to them with the same set of tools.
    We still don’t know whether these systems could become mainstream and displace
    the incumbent frameworks, since they increase the level of complexity and they
    introduce a steep learning curve. Regardless of that, it’s an area to explore,
    like other potential new trends that might develop, since infrastructure management
    is far from being a solved problem.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前正处于这些系统和它们的构建块成为现实的时候，一些值得注意的例子包括Crossplane、Nokia Edge Network Controller和Anthos
    Config Sync。它们将这些系统作为Kubernetes控制器构建，利用Operator模型，允许它们以标准方式公开它们的API，这样其他系统就可以使用相同的工具与之通信。我们仍然不知道这些系统是否会成为主流并取代现有的框架，因为它们增加了复杂性，并引入了陡峭的学习曲线。无论如何，这是一个值得探索的领域，就像其他可能发展的潜在新趋势一样，因为基础设施管理远未得到解决。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Whether to choose Ansible, Terraform, or a programming language to solve a particular
    use case depends on many variables. But don’t fall into the trap of looking at
    this as a binary decision. Most times, different technologies complement each
    other to offer solutions, as we showed in this chapter. In the next chapter, we
    will explore newer and more advanced techniques to interact with networking devices
    and Go.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Ansible、Terraform或编程语言来解决特定用例取决于许多变量。但不要陷入将其视为二元选择的陷阱。大多数时候，不同的技术相互补充，提供解决方案，正如我们在本章中展示的那样。在下一章中，我们将探索与网络设备和Go交互的新技术和更高级的技术。
- en: Further reading
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'This book’s GitHub repository: https://github.com/PacktPublishing/Network-Automation-with-Go'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书GitHub仓库：https://github.com/PacktPublishing/Network-Automation-with-Go
- en: 'Playbook: https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch07/ansible/playbook.yml'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playbook：https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch07/ansible/playbook.yml
- en: 'Terraform registry: [https://registry.terraform.io/browse/providers?category=networking](https://registry.terraform.io/browse/providers?category=networking
    )'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform注册表：[https://registry.terraform.io/browse/providers?category=networking](https://registry.terraform.io/browse/providers?category=networking
    )
- en: 'terraform-provider-scaffolding project: [https://github.com/hashicorp/terraform-provider-scaffolding](https://github.com/hashicorp/terraform-provider-scaffolding
    )'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: terraform-provider-scaffolding项目：[https://github.com/hashicorp/terraform-provider-scaffolding](https://github.com/hashicorp/terraform-provider-scaffolding
    )
- en: 'Provider documentation: [https://registry.terraform.io/providers/nleiva/nautobot/latest/docs?pollNotifications=true](https://registry.terraform.io/providers/nleiva/nautobot/latest/docs?pollNotifications=true
    )'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者文档：[https://registry.terraform.io/providers/nleiva/nautobot/latest/docs?pollNotifications=true](https://registry.terraform.io/providers/nleiva/nautobot/latest/docs?pollNotifications=true
    )
- en: 'Provider’s internal code: [https://github.com/nleiva/terraform-provider-nautobot/blob/main/internal/provider/provider.go](https://github.com/nleiva/terraform-provider-nautobot/blob/main/internal/provider/provider.go
    )'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者内部代码：[https://github.com/nleiva/terraform-provider-nautobot/blob/main/internal/provider/provider.go](https://github.com/nleiva/terraform-provider-nautobot/blob/main/internal/provider/provider.go
    )
- en: '`resource_manufacturer.go`: [https://github.com/nleiva/terraform-provider-nautobot/blob/main/internal/provider/resource_manufacturer.go](https://github.com/nleiva/terraform-provider-nautobot/blob/main/internal/provider/resource_manufacturer.go
    )'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource_manufacturer.go`：[https://github.com/nleiva/terraform-provider-nautobot/blob/main/internal/provider/resource_manufacturer.go](https://github.com/nleiva/terraform-provider-nautobot/blob/main/internal/provider/resource_manufacturer.go
    )'
- en: 'Nautobot provider repository: [https://github.com/nleiva/terraform-provider-nautobot](https://github.com/nleiva/terraform-provider-nautobot
    )'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nautobot提供者仓库：[https://github.com/nleiva/terraform-provider-nautobot](https://github.com/nleiva/terraform-provider-nautobot
    )
- en: 'JUNOS Terraform Automation Framework: [https://github.com/Juniper/junos-terraform](https://github.com/Juniper/junos-terraform
    )'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUNOS Terraform自动化框架：[https://github.com/Juniper/junos-terraform](https://github.com/Juniper/junos-terraform
    )
- en: 'Terraform Provider for Cisco IOS XE: [https://github.com/CiscoDevNet/terraform-provider-iosxe](https://github.com/CiscoDevNet/terraform-provider-iosxe
    )'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Cisco IOS XE的Terraform提供程序: [https://github.com/CiscoDevNet/terraform-provider-iosxe](https://github.com/CiscoDevNet/terraform-provider-iosxe
    )'
- en: 'terraform-provider-junos: [https://github.com/jeremmfr/terraform-provider-junos](https://github.com/jeremmfr/terraform-provider-junos
    )'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'terraform-provider-junos: [https://github.com/jeremmfr/terraform-provider-junos](https://github.com/jeremmfr/terraform-provider-junos
    )'
- en: 'terraform-provider-ciscoasa: https://github.com/CiscoDevNet/terraform-provider-ciscoasa'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'terraform-provider-ciscoasa: https://github.com/CiscoDevNet/terraform-provider-ciscoasa'
- en: 'Nornir: [https://github.com/nornir-automation/nornir/](https://github.com/nornir-automation/nornir/
    )'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Nornir: [https://github.com/nornir-automation/nornir/](https://github.com/nornir-automation/nornir/)'
- en: 'Gornir: [https://github.com/nornir-automation/gornir](https://github.com/nornir-automation/gornir
    )'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Gornir: [https://github.com/nornir-automation/gornir](https://github.com/nornir-automation/gornir
    )'
- en: 'Consul-Terraform-Sync: [https://learn.hashicorp.com/tutorials/consul/consul-terraform-sync-intro?in=consul/network-infrastructure-automation](https://learn.hashicorp.com/tutorials/consul/consul-terraform-sync-intro?in=consul/network-infrastructure-automation
    )'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Consul-Terraform-Sync: [https://learn.hashicorp.com/tutorials/consul/consul-terraform-sync-intro?in=consul/network-infrastructure-automation](https://learn.hashicorp.com/tutorials/consul/consul-terraform-sync-intro?in=consul/network-infrastructure-automation
    )'
- en: '`mgmt`: [https://github.com/purpleidea/mgmt](https://github.com/purpleidea/mgmt)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mgmt`: [https://github.com/purpleidea/mgmt](https://github.com/purpleidea/mgmt)'
- en: '[https://en.wikipedia.org/wiki/Diffusion_of_innovations](https://en.wikipedia.org/wiki/Diffusion_of_innovations)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Diffusion_of_innovations](https://en.wikipedia.org/wiki/Diffusion_of_innovations)'
- en: 'Part 3: Interacting with APIs'
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：与API交互
- en: As the way that networks are built, deployed, and operated has evolved, new
    protocols and interfaces have emerged to facilitate machine-to-machine communication
    as an enabler of network automation. In these chapters, we will navigate through
    some of these new capabilities and how to take advantage of them with Go.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 随着网络构建、部署和运营方式的演变，新的协议和接口已经出现，以促进机器与机器之间的通信，作为网络自动化的推动力。在这些章节中，我们将探讨一些这些新功能以及如何使用Go来利用它们。
- en: 'This part of the book comprises the following chapters:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的书包括以下章节：
- en: '[*Chapter 8*](B16971_08.xhtml#_idTextAnchor182), *Network APIs*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B16971_08.xhtml#_idTextAnchor182), *网络API*'
- en: '[*Chapter 9*](B16971_09.xhtml#_idTextAnchor209), *OpenConfig*'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B16971_09.xhtml#_idTextAnchor209), *OpenConfig*'
- en: '[*Chapter 10*](B16971_10.xhtml#_idTextAnchor225), *Network Monitoring*'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B16971_10.xhtml#_idTextAnchor225), *网络监控*'
- en: '[*Chapter 11*](B16971_11.xhtml#_idTextAnchor247), *Expert Insights*'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B16971_11.xhtml#_idTextAnchor247), *专家见解*'
- en: '[*Chapter 12*](B16971_12.xhtml#_idTextAnchor279), *Appendix: Building a Testing
    Environment*'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B16971_12.xhtml#_idTextAnchor279), *附录：构建测试环境*'
