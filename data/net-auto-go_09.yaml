- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: OpenConfig
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenConfig
- en: OpenConfig is a group of network operators (see the *Further reading* section)
    with the common goal of streamlining the way we manage and operate networks. They
    welcome anyone operating a production network as a member and, more recently,
    have started to accept contributions from vendors when more than one of them implements
    the same feature (that they want to include in a YANG model).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: OpenConfig是由一群网络运营商组成的团体（参见*进一步阅读*部分），他们有一个共同的目标，即简化我们管理和操作网络的方式。他们欢迎任何运营生产网络的成员加入，并且最近开始接受来自多个厂商的贡献，当这些厂商实现相同的功能（他们希望将其包含在YANG模型中）时。
- en: Their initial focus was to create a set of vendor-neutral YANG data models based
    on common operational use cases and requirements from the field. This later expanded
    to include vendor-neutral **Remote Procedure Calls** (**RPCs**) for configuring,
    streaming telemetry, performing operational commands, and manipulating forwarding
    entries (see *Further reading*) on network devices. In this chapter, we will focus
    primarily on the OpenConfig RPCs, as we already covered YANG data models in [*Chapter
    8*](B16971_08.xhtml#_idTextAnchor182), *Network APIs*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的初始重点是创建一套基于现场常见操作用例和要求的厂商中立YANG数据模型。这后来扩展到包括用于在网络上配置、流式遥测、执行操作命令和操作转发条目的厂商中立**远程过程调用**（**RPCs**）（参见*进一步阅读*）。在本章中，我们将主要关注OpenConfig
    RPCs，因为我们已经在[*第8章*](B16971_08.xhtml#_idTextAnchor182)，*网络API*中介绍了YANG数据模型。
- en: One thing that sets OpenConfig apart from other similar initiatives is that
    they not only work publicly on the specifications but also write open source code
    that implements these specifications, helping you to interact with OpenConfig-compliant
    devices. They write most of these projects in Go, including but not limited to
    ygot, gNxI Tools, the gNMI collector, the gNMI CLI utility, the gNMI test framework,
    gRPC tunnels, and IS-IS LSDB parsing (see *Further reading*). We encourage you
    to explore those projects, especially the ones we do not cover in this book, as
    they target a wide range of network-related applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类似倡议相比，OpenConfig的一个独特之处在于，它们不仅公开工作在规范上，还编写了实现这些规范的开放源代码，帮助您与符合OpenConfig的设备交互。他们大多数项目都是用Go编写的，包括但不限于ygot、gNxI工具、gNMI收集器、gNMI
    CLI实用程序、gNMI测试框架、gRPC隧道和IS-IS LSDB解析（参见*进一步阅读*）。我们鼓励您探索这些项目，特别是我们在这本书中没有涵盖的项目，因为它们针对广泛的网络相关应用。
- en: 'At the time of writing, OpenConfig includes four gRPC services:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，OpenConfig包括四个gRPC服务：
- en: '**gRPC Network Management Interface** (**gNMI**): For streaming telemetry and
    configuration management'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gRPC网络管理接口**（**gNMI**）：用于流式遥测和配置管理'
- en: '**gRPC Network Operations Interface** (**gNOI**): For executing operational
    commands on network devices'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gRPC网络操作接口**（**gNOI**）：用于在网络上执行操作命令'
- en: '**gRPC Routing Information Base Interface** (**gRIBI**): To let an external
    client inject routing entries on a network element'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gRPC路由信息库接口**（**gRIBI**）：允许外部客户端在网络元素上注入路由条目'
- en: '**gRPC Network Security Interface** (**gNSI**): Infrastructure services for
    securing access to a compliant network device'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gRPC网络安全接口**（**gNSI**）：用于保护访问符合网络设备的底层基础设施服务'
- en: 'In the following sections, we will examine the following common operational
    tasks:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将检查以下常见的操作任务：
- en: Device provisioning, with the gNMI `Set` RPC, to label correctly the primary
    and backup interfaces between two nodes in the lab topology
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备配置，使用gNMI的`Set` RPC，在实验室拓扑结构中的两个节点之间正确标记主备接口
- en: Streaming telemetry, with the `Subscribe` RPC, where a Go program reacts to
    a gNMI telemetry stream to make changes to the network
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Subscribe` RPC进行流式遥测，其中Go程序对gNMI遥测流做出反应，以对网络进行更改
- en: Network operations, with a `traceroute` example with the gNOI `Traceroute` RPC,
    to check that all the forwarding paths in the network are working as expected
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络操作，使用gNOI的`Traceroute` RPC的`traceroute`示例，以检查网络中的所有转发路径是否按预期工作
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code examples for this chapter in the book’s GitHub repository
    (see *Further reading*), in the `ch09` folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中找到本章的代码示例（参见*进一步阅读*），在`ch09`文件夹中。
- en: Important Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We recommend you execute the Go programs in this chapter in a virtual lab environment.
    Refer to the appendix for prerequisites and instructions on how to build the fully
    configured network topology.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在虚拟实验室环境中执行本章中的Go程序。请参阅附录以获取先决条件和构建完全配置的网络拓扑结构的说明。
- en: The first example we discuss in the following section explores gNMI to configure
    network devices with Go.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论的第一个示例是使用Go来配置网络设备gNMI。
- en: Device provisioning
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备配置
- en: In [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration Management*,
    we discussed applying the desired configuration state on a network device. Network
    engineers routinely have to log in to network devices to provision new services,
    bring up new connections, or remove outdated configurations. We covered the different
    transport options available to configure network devices such as SSH or HTTP in
    the same chapter, and in [*Chapter 8*](B16971_08.xhtml#_idTextAnchor182), *Network
    APIs*, we added gRPC as another option.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B16971_06.xhtml#_idTextAnchor144) *配置管理*中，我们讨论了在网络上应用所需的配置状态。网络工程师通常需要登录到网络设备以提供新服务、建立新连接或删除过时的配置。我们在同一章节中介绍了配置网络设备（如SSH或HTTP）的不同传输选项，并在[*第8章*](B16971_08.xhtml#_idTextAnchor182)
    *网络API*中添加了gRPC作为另一个选项。
- en: We briefly touched on modeling network device configurations with a data modeling
    language such as YANG, so we could move from configuring networks with semi-structured
    vendor-specific CLI syntax to a model where we exchange structured data with the
    network to change its configuration state.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要介绍了使用数据建模语言（如YANG）来建模网络设备配置，这样我们就可以从使用半结构化供应商特定CLI语法配置网络，转变为与网络交换结构化数据以改变其配置状态的模式。
- en: OpenConfig defines a gRPC service specifically for configuration management
    called gNMI. It aims to provide a common gRPC protobuf definition that any vendor
    can implement, alongside their existing proprietary gRPC services.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: OpenConfig定义了一个专门用于配置管理的gRPC服务，称为gNMI。它的目标是提供一个任何供应商都可以实现的通用gRPC protobuf定义，同时保留他们现有的专有gRPC服务。
- en: 'The protobuf definition for gNMI is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: gNMI的protobuf定义如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: gNMI particularly offers configuration management capabilities via the `Set`
    RPC that you can use to make changes on a target node. The gNMI specification
    (see *Further reading*) has extensive documentation on all available gNMI RPCs.
    In this section, we will focus on `Set`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: gNMI特别通过`Set` RPC提供配置管理功能，您可以使用它来对目标节点进行更改。gNMI规范（见*进一步阅读*）对所有可用的gNMI RPCs有详细的文档。在本节中，我们将重点关注`Set`。
- en: Set RPC
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Set RPC
- en: The `Set` RPC lets you change the state of a target network device. You do this
    by sending a `SetRequest` message that encodes all changes you want to make.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set` RPC允许您更改目标网络设备的状态。您通过发送一个编码了您想要进行的所有更改的`SetRequest`消息来实现这一点。'
- en: 'You can update, replace, or delete values in the data tree of the target device
    in a single transaction, using dedicated fields of the `SetRequest` message. This
    means that unless the target can apply every specified change, it must roll all
    of them back and return to its previous state. The following protobuf definition
    shows the options you have in a `SetRequest` message:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`SetRequest`消息的专用字段在目标设备的单个事务中更新、替换或删除数据树中的值。这意味着除非目标可以应用所有指定的更改，否则它必须全部回滚并返回到其先前状态。以下protobuf定义显示了您在`SetRequest`消息中可用的选项：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The field called `Path` in `SetRequest` encodes a YANG data tree path. It’s
    worth noting that gNMI is not limited to using OpenConfig YANG models; it works
    equally well with vendor-defined YANG models. gNMI describes the data tree path
    as a series of `PathElem` (path elements). Each one of these is a data tree node
    that has a name, and it may have one or more attributes (keys) associated with
    it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SetRequest`中称为`Path`的字段编码了一个YANG数据树路径。值得注意的是，gNMI不仅限于使用OpenConfig YANG模型；它同样适用于供应商定义的YANG模型。gNMI将数据树路径描述为一系列`PathElem`（路径元素）。每一个都是具有名称的数据树节点，并且可能与之关联一个或多个属性（键）：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For instance, the `/interfaces/interface[name=Ethernet2]/config/description`
    path lets you set the description on the `Ethernet2` interface on a target device.
    The only data node in this case that has an attribute is `interface`, which needs
    a `name`. To configure an IPv4 address on the native VLAN in that same interface,
    you can use a path that looks like this: `/interfaces/interface[name=Ethernet2]/subinterfaces/subinterface[index=0]/ipv4/addresses/address[ip=192.0.2.2]`.
    In this case, you need to add the `subinterface` index, as the interface could
    have IP addresses on different sub-interfaces.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`/interfaces/interface[name=Ethernet2]/config/description` 路径允许您在目标设备上的 `Ethernet2`
    接口上设置描述。在这种情况下，唯一具有属性的节点是 `interface`，它需要一个 `name`。要配置该接口中本地 VLAN 的 IPv4 地址，您可以使用如下路径：`/interfaces/interface[name=Ethernet2]/subinterfaces/subinterface[index=0]/ipv4/addresses/address[ip=192.0.2.2]`。在这种情况下，您需要添加
    `subinterface` 索引，因为接口可能在不同子接口上有 IP 地址。
- en: Once you have identified the data path, you need to build the content that has
    the new values you want to set on the target device, which is a data instance
    of a YANG schema. You only need this for `replace` and `update`. For `delete`,
    the path is enough to tell the target device what to remove from the configuration.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已识别数据路径，您需要构建包含您要在目标设备上设置的新值的内容，这是一个 YANG 模式的数据实例。您只需要 `replace` 和 `update`。对于
    `delete`，路径就足够告诉目标设备从配置中删除什么。
- en: 'An `Update` message that you would use to send the values for either `replace`
    or `update` has a `Path` and `TypedValue` pair. The latter lets you encode the
    content in different formats:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用于发送 `replace` 或 `update` 的值的 `Update` 消息包含一个 `Path` 和 `TypedValue` 对。后者允许您以不同的格式编码内容：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A value could be a string for an interface description, such as `PRIMARY: TO
    -> CVX:swp1` or a JSON value to describe the IPv4 address of an interface such
    as `{"config":{"ip":"192.0.2.2","prefix-length":31}}`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '值可以是字符串，例如接口描述 `PRIMARY: TO -> CVX:swp1`，或者 JSON 值，用于描述接口的 IPv4 地址，例如 `{"config":{"ip":"192.0.2.2","prefix-length":31}}`。'
- en: Using gNMI to configure network interfaces
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 gNMI 配置网络接口
- en: 'The virtual lab topology for this chapter, which you can bring up by running
    `make lab-full` from the root of this book’s GitHub repository, has two connections
    between `ceos` and `cvx`. They have IPv4 addresses configured already, but they
    don’t have a description that lets you identify the roles of these interfaces,
    whether they are the primary or the backup link:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的虚拟实验室拓扑，您可以通过从本书 GitHub 仓库的根目录运行 `make lab-full` 来启动它，其中 `ceos` 和 `cvx` 之间有两个连接。它们已经配置了
    IPv4 地址，但没有描述来让您识别这些接口的角色，即它们是主链路还是备份链路：
- en: '![Figure 9.1 – A dual link between ceos and cvx](img/B16971_09_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – ceos 和 cvx 之间的双链路](img/B16971_09_01.jpg)'
- en: Figure 9.1 – A dual link between ceos and cvx
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – ceos 和 cvx 之间的双链路
- en: In the next example, we add a description to those interfaces on the `ceos`
    side via gNMI. To do this, we use the gNMIc package (`karimra/gnmic/api`). We
    chose gNMIc over the official gNMI package (`openconfig/gnmi`) because it’s more
    developer-friendly and higher-level. It lets us conveniently encode the gNMI paths
    as strings, instead of Go data structures, as the gNMIc docs (see *Further reading*)
    describe. You can find the code for this example in the `ch09/gnmi` directory
    of this book’s GitHub repository (see *Further reading*).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们通过 gNMI 在 `ceos` 端的这些接口上添加描述。为此，我们使用 gNMIc 包（`karimra/gnmic/api`）。我们选择
    gNMIc 而不是官方的 gNMI 包（`openconfig/gnmi`），因为它对开发者更友好，并且是更高层次的。它允许我们方便地将 gNMI 路径编码为字符串，而不是
    Go 数据结构，正如 gNMIc 文档（见 *进一步阅读*）所述。您可以在本书 GitHub 仓库的 `ch09/gnmi` 目录中找到此示例的代码（见 *进一步阅读*）。
- en: 'The gNMIc package has a `NewTarget` function that creates a new gNMI target
    device. In the following example, we wrap this function in the `createTarget`
    method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: gNMIc 包含一个 `NewTarget` 函数，用于创建新的 gNMI 目标设备。在下面的示例中，我们将此函数封装在 `createTarget`
    方法中：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first step in the code is to read the connection details from a YAML file
    (`input.yml`) to create this target device:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一步是从 YAML 文件（`input.yml`）中读取连接详情以创建此目标设备：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We store all target devices in the `Routers` data structure. In our case, we
    only have one device (`clab-netgo-ceos`) but the connection details are a list,
    so we could’ve added more devices if we wanted to. Now, with the target data,
    we use the `CreateGNMIClient` method to set up the underlying gRPC connection
    to the target device (`clab-netgo-ceos:6030`):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有目标设备存储在`Routers`数据结构中。在我们的案例中，我们只有一个设备（`clab-netgo-ceos`），但连接细节是一个列表，所以如果我们想的话，可以添加更多设备。现在，有了目标数据，我们使用`CreateGNMIClient`方法设置到目标设备（`clab-netgo-ceos:6030`）的底层gRPC连接：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the connection established, we now can send the `Set` requests. Another
    YAML file (`api-ceos.yml`) has a list of parameters for each request: `prefix`,
    `encoding`, `path`, and `value`. You can add `prefix` when you want to reduce
    the length of a path. In our Go program, we save this list of parameters in the
    `info` slice:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 连接建立后，我们现在可以发送`Set`请求。另一个YAML文件（`api-ceos.yml`）包含每个请求的参数列表：`prefix`、`encoding`、`path`和`value`。当你想要缩短路径长度时，可以添加`prefix`。在我们的Go程序中，我们将这个参数列表保存到`info`切片中：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last step is to iterate over the `info` slice, build a `Set` request with
    the `NewSetRequest` function, and send it to the target device using the `Set`
    method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是遍历`info`切片，使用`NewSetRequest`函数构建一个`Set`请求，并使用`Set`方法将其发送到目标设备：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `NewSetRequest` has only one `Update` message, but you could include several
    messages in a single request.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`NewSetRequest`只有一个`Update`消息，但你可以在单个请求中包含多个消息。
- en: 'You get the following output when running this example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例时，你会得到以下输出：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What you see on the terminal screen are the `SetResponse` messages, containing
    the `path`, `response`, and `timestamp` values of the operation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你在终端屏幕上看到的是`SetResponse`消息，包含操作的`path`、`response`和`timestamp`值：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you connect to the `ceos` device now, you will see the following in its
    running configuration:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在连接到`ceos`设备，你将看到其运行配置中的以下内容：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Configuring network devices is one of those repetitive tasks that most network
    engineers spend a good amount of time on, so automating this process has the potential
    to have a good return on investment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 配置网络设备是大多数网络工程师花费大量时间进行的一些重复性任务之一，因此自动化此过程具有很好的投资回报潜力。
- en: The years of work of the OpenConfig working group, which released the official
    gNMI package (`openconfig/gnmi`), set the path for the emergence of other open
    source packages and libraries such as gNMIc (`karimra/gnmic`) and pyGNMI (`akarneliuk/pygnmi`),
    creating a community around these vendor-neutral gRPC services to drive consistent
    automation practices in our networks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: OpenConfig工作组多年的工作，该工作组发布了官方的gNMI包（`openconfig/gnmi`），为其他开源包和库（如gNMIc (`karimra/gnmic`)
    和 pyGNMI (`akarneliuk/pygnmi`））的出现设定了路径，围绕这些供应商中立的gRPC服务建立社区，以推动我们网络中一致的自动化实践。
- en: In the following section, we will cover another OpenConfig gRPC service that
    enhances your network visibility capabilities.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍另一个增强网络可见性能力的OpenConfig gRPC服务。
- en: Streaming telemetry
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式遥测
- en: Traditionally, network engineers have relied on the **Simple Network Management
    Protocol** (**SNMP**) to gather state information from network devices. Devices
    encode this information in a binary format using the **Abstract Syntax Notation
    One** (**ASN.1**) and send it to a receiver, typically a collector or a **Network
    Management System** (**NMS**). The latter would use one of the **Management Information
    Bases** (**MIBs**) to decode the received information and store it locally for
    further processing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，网络工程师依赖于**简单网络管理协议**（**SNMP**）从网络设备收集状态信息。设备使用**抽象语法表示法一**（**ASN.1**）的二进制格式编码此信息，并将其发送到接收器，通常是收集器或**网络管理系统**（**NMS**）。后者会使用**管理信息库**（**MIBs**）之一来解码接收到的信息并将其存储在本地以供进一步处理。
- en: 'This has been the way we’ve done network monitoring for decades, but this approach
    has room for improvement:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们几十年来进行网络监控的方式，但这种方法仍有改进的空间：
- en: The limited number of vendor-neutral data models means that even the basic things
    require unique MIBs that you may need to update every time you do a major network
    OS upgrade.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限数量的供应商中立数据模型意味着即使是基本的东西也需要独特的MIBs，你可能需要每次进行主要网络操作系统升级时都更新它们。
- en: MIBs use a notation defined by a subset of ASN.1, which isn’t the best way to
    structure values. It has no concept of lists or key-value pairs. Instead, you
    must implement these with indexed values and extra lookup tables.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIBs使用ASN.1子集定义的符号，这不是结构值的最佳方式。它没有列表或键值对的概念。相反，您必须使用索引值和额外的查找表来实现这些。
- en: SNMP uses UDP as its transport protocol to avoid putting an extra burden on
    the collector. This means that you could miss some events completely, leaving
    blind spots in the stream of telemetry data.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SNMP使用UDP作为其传输协议，以避免给收集器带来额外负担。这意味着您可能会完全错过一些事件，在遥测数据流中留下盲点。
- en: Since SNMP primarily relies on polling, we can only see aggregated values and
    may miss important state transitions.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于SNMP主要依赖于轮询，我们只能看到聚合值，可能会错过重要的状态转换。
- en: SNMP does not generally timestamp when a value changes. Collectors can only
    infer timing based on the time of collection.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SNMP通常不记录值变化的时间戳。收集者只能根据收集时间推断时间。
- en: 'gNMI offers a new approach to network monitoring via a dedicated `Subscribe`
    RPC. At the very least, it offers the same capabilities as SNMP but takes it further,
    making the protocol more feature-rich and versatile:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: gNMI通过一个专门的`Subscribe` RPC提供了一种新的网络监控方法。至少，它提供了与SNMP相同的性能，但更进一步，使协议更加功能丰富和灵活：
- en: One of the greatest improvements is telemetry streaming. Now, you can continuously
    receive any value of the operational YANG tree from a network device, which gives
    you better visibility into all state transitions along with their timestamps.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大的改进之一是遥测流。现在，您可以连续接收来自网络设备的操作YANG树中的任何值，这使您能够更好地了解所有状态转换及其时间戳。
- en: You have a choice to receive telemetry data only when there is a change as opposed
    to a periodic transmission.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以选择只在有变化时接收遥测数据，而不是周期性传输。
- en: Thanks to the underlying gRPC transport, gNMI supports both dial-in and dial-out
    connection methods and delivers messages using a reliable HTTP/2 protocol.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多亏了底层的gRPC传输，gNMI支持拨入和拨出连接方法，并使用可靠的HTTP/2协议传递消息。
- en: OpenConfig defines vendor-neutral YANG models to describe the operational state
    of a network device, which enables clients to parse and process the received data
    from different vendors in a standard pipeline.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenConfig定义了描述网络设备操作状态的供应商中立YANG模型，这使得客户端能够以标准管道解析和处理来自不同供应商的接收数据。
- en: Important Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Even with streaming telemetry, you are not necessarily getting an update for
    every counter increment. Network devices have local processes that periodically
    poll internal data stores to get the latest metrics or stats, such as interface
    packet counters, which they feed to their gNMI process. Hence, how real-time the
    data you receive is depends not only on how often you get streaming messages but
    also on the internal polling cadence. Still, you will probably see the most relevant
    system events, such as BGP state transitions, which you would otherwise miss with
    SNMP.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有流式遥测，也不一定为每个计数器增量提供更新。网络设备有本地进程，它们定期轮询内部数据存储以获取最新的指标或统计信息，例如接口数据包计数器，然后将这些信息提供给它们的gNMI进程。因此，您接收到的数据的实时性不仅取决于您获取流消息的频率，还取决于内部轮询的频率。尽管如此，您仍然可能会看到最相关的系统事件，例如BGP状态转换，否则您可能会错过这些事件。
- en: These features are just a subset of the gNMI capabilities. The gNMI specification
    (see *Further reading*) can serve as a good reference for all gNMI protocol features.
    Next, we examine the gNMI protobuf message for the telemetry service to help you
    understand how it works.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能只是gNMI能力的一部分。gNMI规范（见*进一步阅读*）可以作为所有gNMI协议功能的良好参考。接下来，我们将检查遥测服务的gNMI protobuf消息，以帮助您了解它是如何工作的。
- en: Subscribe RPC
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅RPC
- en: 'gNMI defines a single RPC to subscribe to a telemetry stream. Network devices
    receive one or more `SubscribeRequest` messages and respond with a stream of `SubscribeResponse`
    messages:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: gNMI定义了一个单独的RPC来订阅遥测流。网络设备接收一个或多个`SubscribeRequest`消息，并以一系列`SubscribeResponse`消息进行响应：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'gNMI clients have different options to control their telemetry subscriptions.
    The following figure shows the composition of the `SubscribeRequest` message,
    highlighting some of these options:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: gNMI客户端有多种选项来控制他们的遥测订阅。以下图显示了`SubscribeRequest`消息的组成，突出了这些选项之一：
- en: '![Figure 9.2 – gNMI subscribe protobuf messages](img/B16971_09_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – gNMI订阅protobuf消息](img/B16971_09_02.jpg)'
- en: Figure 9.2 – gNMI subscribe protobuf messages
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – gNMI订阅protobuf消息
- en: 'The most basic way to control the telemetry subscription is by specifying `Path`
    and `SubscriptionMode`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 控制遥测订阅的最基本方法是指定 `Path` 和 `SubscriptionMode`：
- en: '**Path**: References the part of the YANG tree you want to monitor. You can
    subscribe to anything, from the entire device state to just a single leaf value.
    It follows the gNMI path convention (see *Further reading*).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Path**：引用您想要监控的 YANG 树的部分。您可以订阅任何内容，从整个设备状态到单个叶值。它遵循 gNMI 路径约定（见 *进一步阅读*）。'
- en: '**SubscriptionMode**: Determines whether to send the telemetry on-change or
    periodically:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SubscriptionMode**：确定是否在更改时发送遥测或定期发送：'
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In return, a network device sends you a stream of response messages with the
    following information:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回报，网络设备会向您发送包含以下信息的响应消息流：
- en: '**TypedValue**: The most critical field, containing the actual telemetry value'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypedValue**：最重要的字段，包含实际的遥测值'
- en: '**Path**: The full gNMI path of the value, which identifies the unique YANG
    leaf node'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Path**：值的完整 gNMI 路径，用于标识唯一的 YANG 叶节点'
- en: '**timestamp**: To help you arrange and process received data in the right order
    or find out when a value last changed for those that do not change frequently:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**timestamp**：帮助您按正确顺序安排和处理接收到的数据，或找出值最后一次更改的时间，对于那些不经常更改的值：'
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We are just scratching the surface of the `Subscribe` RPC. You can check the
    `gnmi.proto` file to see the complete set of protobuf messages and read the telemetry
    section of the gNMI specification (see *Further reading*) to get a better idea
    of the capabilities and features offered by the protocol. Here are some features
    you can learn about that we don’t cover in this book:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了 `Subscribe` RPC 的表面。您可以通过查看 `gnmi.proto` 文件来查看完整的 protobuf 消息集，并阅读 gNMI
    规范的遥测部分（见 *进一步阅读*）以更好地了解协议提供的功能和特性。以下是一些您可以了解的功能，我们在这本书中没有涉及：
- en: gNMI lets you poll or take an instant one-off (`ONCE`) snapshot of telemetry
    values.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gNMI 允许您轮询或获取遥测值的即时一次性（`ONCE`）快照。
- en: Some network devices can send several `Update` messages bundled in a single
    `SubscribeResponse`. This comes at the expense of reduced timestamp accuracy,
    since there’s only a single timestamp for all transported values.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些网络设备可以在单个 `SubscribeResponse` 中发送多个 `Update` 消息。这以降低时间戳准确性为代价，因为所有传输的值只有一个时间戳。
- en: If you are not interested in seeing every single value, you can let a network
    device aggregate those values.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您不希望看到每个单独的值，您可以允许网络设备聚合这些值。
- en: For values that different YANG models define, you can specify the definition
    you prefer to use.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不同 YANG 模型定义的值，您可以指定您希望使用的定义。
- en: Important Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As with OpenConfig YANG models, the exact set of implemented features varies
    from vendor to vendor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OpenConfig YANG 模型一样，具体实现的功能集因供应商而异。
- en: Streaming telemetry processing pipelines with gNMI
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 gNMI 的流式遥测处理管道
- en: To receive or collect the data from a gNMI-compliant network device, you could
    use the Go gNMI client implementation from the official gNMI repository (see *Further
    reading*). Another alternative is gNMIc (see *Further reading*), which builds
    on top of the official gNMI client and provides more capabilities, such as data
    transformation and wide support of northbound interfaces.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要从符合 gNMI 的网络设备接收或收集数据，您可以使用来自官方 gNMI 仓库的 Go gNMI 客户端实现（见 *进一步阅读*）。另一种选择是 gNMIc（见
    *进一步阅读*），它建立在官方 gNMI 客户端之上，并提供了更多功能，例如数据转换和对北向接口的广泛支持。
- en: gNMIc can serve as a link between a network device and a **T****ime-Series Database**
    (**TSDB**) or a message queue, as it can transform the received telemetry data
    into a format popular open source projects, such as Prometheus, InfluxDB, NATS,
    and Kafka, can understand. You can run gNMIc as a command-line tool to interact
    with network devices or as a daemon, subscribing to telemetry data and publishing
    it into a message queue or a database.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: gNMIc 可以作为网络设备和 **时间序列数据库**（**TSDB**）或消息队列之间的链接，因为它可以将接收到的遥测数据转换为流行的开源项目（如 Prometheus、InfluxDB、NATS
    和 Kafka）可以理解的格式。您可以将 gNMIc 作为命令行工具与网络设备交互，或作为守护进程，订阅遥测数据并将其发布到消息队列或数据库。
- en: Event-manager sample program
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件管理器示例程序
- en: 'Let’s examine one example of a telemetry processing pipeline via an implementation
    of a primitive event-manager application. The goal of this program is to react
    to an increased packet rate by temporarily enabling a backup interface to redistribute
    incoming traffic. The following diagram depicts the high-level architecture of
    the telemetry processing pipeline and includes the following main components:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个原始事件管理器应用程序的实现来检查遥测处理管道的一个示例。该程序的目标是通过临时启用备份接口来重新分配传入流量，以应对增加的包速率。以下图显示了遥测处理管道的高级架构，并包括以下主要组件：
- en: A gNMIC process running as a daemon, collecting and processing network telemetry
    data
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为守护进程运行的 gNMIC 进程，收集和处理网络遥测数据
- en: A TSDB (Prometheus) storing the collected telemetry data
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储收集的遥测数据的 TSDB（Prometheus）
- en: AlertManager (see *Further reading*) processing alerts received from Prometheus
    and triggering external events
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AlertManager（见 *进一步阅读*）处理从 Prometheus 收到的警报并触发外部事件
- en: 'A Go program that implements the event-manager business logic:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实现事件管理器业务逻辑的 Go 程序：
- en: '![Figure 9.3 – The event-manager application](img/B16971_09_03.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 事件管理器应用程序](img/B16971_09_03.jpg)'
- en: Figure 9.3 – The event-manager application
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 事件管理器应用程序
- en: 'You can spin up these components with `make gnmic-start` from the root of this
    book’s GitHub repository (see *Further reading*). This command starts the gNMIc
    daemon and brings up Prometheus, Grafana, and AlertManager using `docker-compose`.
    These applications now run alongside our test lab topology and interact with it
    over standard network interfaces:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从本书GitHub仓库的根目录使用 `make gnmic-start` 启动这些组件（见 *进一步阅读*）。此命令启动 gNMIc 守护进程，并使用
    `docker-compose` 启动 Prometheus、Grafana 和 AlertManager。这些应用程序现在与我们的测试实验室拓扑一起运行，并通过标准网络接口与之交互：
- en: '![Figure 9.4 – The event-manager topology](img/B16971_09_04.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 事件管理器拓扑](img/B16971_09_04.jpg)'
- en: Figure 9.4 – The event-manager topology
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 事件管理器拓扑
- en: 'We configured these applications using a series of files located in the `topo`-`full/workdir/`
    (see *Further reading*) directory of this book’s GitHub repository (see *Further
    reading*). These files get mounted into their respective containers, as we define
    in the configuration files of either Containerlab (`topo.yml` – see *Further reading*)
    or Docker Compose (`docker-compose.yml` – see *Further reading*). Here’s a brief
    description of the role these applications play in our setup:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用本书GitHub仓库（见 *进一步阅读*）中 `topo`-`full/workdir/` 目录的一系列文件配置了这些应用程序（见 *进一步阅读*）。这些文件被挂载到各自的容器中，正如我们在
    Containerlab 的配置文件（`topo.yml` – 见 *进一步阅读*）或 Docker Compose 的配置文件（`docker-compose.yml`
    – 见 *进一步阅读*）中定义的那样。以下是这些应用程序在我们设置中扮演的角色简要描述：
- en: 'The gNMIc daemon process runs in `Host-3` of the test topology. It subscribes
    to telemetry data from the `cvx` device and exposes it as Prometheus-style metrics.
    We manage these settings in the `gnmic.yaml` file that looks like this:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gNMIc 守护进程在测试拓扑的 `Host-3` 上运行。它订阅来自 `cvx` 设备的遥测数据，并将其作为 Prometheus 风格的指标暴露出来。我们在
    `gnmic.yaml` 文件中管理这些设置，该文件看起来像这样：
- en: '[PRE31]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can find the Prometheus configuration values in the `prometheus.yml` file.
    We configure it to scrape the gNMIc endpoint every 2 seconds and store the collected
    data in its TSDB:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 `prometheus.yml` 文件中找到 Prometheus 配置值。我们将其配置为每2秒抓取 gNMIc 端点，并将收集的数据存储在其
    TSDB 中：
- en: '[PRE45]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The same configuration file includes a reference to the alert definition file,
    called `alert.rules`, and the connection details of the AlertManager:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一个配置文件还包括对警报定义文件（称为 `alert.rules`）和 AlertManager 连接细节的引用：
- en: '[PRE50]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Inside of the `alert.rules` file, we define a single alert we call `HighLinkUtilization`.
    Every 10 seconds, Prometheus checks whether the incoming packet rate has exceeded
    a predefined threshold of 50 packets per 30-second interval, in which case it
    fires an alert and sends it to the AlertManager:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `alert.rules` 文件中，我们定义了一个名为 `HighLinkUtilization` 的单个警报。每10秒，Prometheus 检查传入的包速率是否超过了每30秒间隔50个包的预定义阈值，如果是，则触发警报并将其发送到
    AlertManager：
- en: '[PRE58]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'AlertManager has its own configuration file, called `alertmanager.yml`, that
    controls how to aggregate and route incoming alerts from Prometheus. In our case,
    we have a single alert type, so we only need one route. We decrease the default
    aggregation timers to enable faster reaction time and specify the webhook URL
    where to send these alerts:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AlertManager 有自己的配置文件，称为 `alertmanager.yml`，它控制如何从 Prometheus 聚合和路由传入的警报。在我们的案例中，我们只有一个警报类型，所以我们只需要一个路由。我们将默认的聚合计时器降低以实现更快的反应时间，并指定发送这些警报的
    webhook URL：
- en: '[PRE71]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: event-manager parses the alert and toggles a backup interface to re-balance
    the traffic coming into the `cvx` device. Its behavior is fairly static, so we
    don’t need a configuration file for it.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件管理程序解析警报并切换备份接口以重新平衡进入`cvx`设备的流量。其行为相当静态，因此我们不需要为其配置配置文件。
- en: 'The event-manager program implements a standard web server that listens to
    incoming requests and dispatches them to a handler function. Here, we decode the
    received Prometheus alert and invoke the `toggleBackup` function based on its
    status:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 事件管理程序实现了一个标准的网络服务器，它监听传入的请求并将它们调度到处理函数。在这里，我们解码接收到的Prometheus警报并根据其状态调用`toggleBackup`函数：
- en: '[PRE79]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We have two *uplinks* between the `cvx` and `ceos` devices, and we only use
    one of them by default. The backup uplink does BGP ASN prepending and only receives
    traffic when we announce more specific or disaggregated prefixes. The `toggleBackup`
    function does this by toggling a permit/deny statement on an IP prefix list (on
    `cvx`), thereby enabling or disabling the BGP disaggregation behavior:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`cvx`和`ceos`设备之间有两个*上行链路*，我们默认只使用其中一个。备份上行链路执行BGP ASN预置位，并且只有当我们宣布更具体或分解的前缀时才接收流量。`toggleBackup`函数通过在IP前缀列表（在`cvx`上）切换允许/拒绝语句来实现这一点，从而启用或禁用BGP分解行为：
- en: '[PRE80]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The final `sendBytes` function applies the constructed configuration using the
    three-stage commit process we discussed in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144),
    *Configuration Management*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的`sendBytes`函数使用我们在[*第6章*](B16971_06.xhtml#_idTextAnchor144)“配置管理”中讨论的三阶段提交过程应用构建的配置。
- en: Visualizing the data
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化数据
- en: You can connect to the local instance of Grafana running at `:3000` using `admin`
    as the username/password to test the complete telemetry-driven pipeline in action.
    This Grafana instance comes up pre-integrated with Prometheus as its data source,
    and it includes a pre-built `event-manager` dashboard that plots the incoming
    packet rate for both `cvx` links to `ceos`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`admin`作为用户名/密码连接到运行在`:3000`的本地Grafana实例，以测试完整的由遥测驱动的管道。这个Grafana实例预先集成了Prometheus作为其数据源，并包含一个预构建的`event-manager`仪表板，该仪表板绘制了进入`cvx`链接到`ceos`的入包速率。
- en: Run `make traffic-start` from the root of this book’s GitHub repository (see
    *Further reading*) to generate traffic in the lab topology. All traffic should
    initially flow over the primary connection between `cvx` and `ceos` (`swp1`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书GitHub仓库的根目录运行`make traffic-start`（见*进一步阅读*）以在实验室拓扑中生成流量。所有流量最初都应通过`cvx`和`ceos`之间的主连接（`swp1`）流动。
- en: 'Next, we want to start the event-manager application so that we can load-balance
    traffic across both connections. To do this, run the event-manager Go application
    inside the `host-2` container. This translates to the command that we execute
    in the following snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要启动事件管理器应用程序，以便我们可以在两个连接之间进行流量负载均衡。为此，请在`host-2`容器内运行事件管理器Go应用程序。这相当于以下代码片段中我们执行的命令：
- en: '[PRE81]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Open a new terminal window or tab and run `make traffic-start` again, but increase
    the traffic generation period from the default `60s` using the `DURATION` variable.
    For example, the following command would generate traffic for 2 minutes:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口或标签页，再次运行`make traffic-start`，但使用`DURATION`变量增加流量生成周期，从默认的`60s`。例如，以下命令将生成2分钟的流量：
- en: '[PRE82]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This can help you see the longer-term effect of traffic re-balancing. Logs
    should show that the traffic rate has triggered an alert and the application implemented
    corrective actions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以帮助您看到流量重新平衡的长期影响。日志应显示流量速率已触发警报，并且应用程序已实施纠正措施：
- en: '[PRE83]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'All three of the tests we performed should get you a similar-looking graph:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行的所有三个测试都应该得到一个看起来相似的图表：
- en: '![Figure 9.5 – Event-manager visualization](img/B16971_09_05.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 事件管理器可视化](img/B16971_09_05.jpg)'
- en: Figure 9.5 – Event-manager visualization
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 事件管理器可视化
- en: Streaming telemetry is a powerful capability that you can adapt to a wide variety
    of business use cases. However, most of these use cases are specific to the operating
    network environment, so it’s hard to come up with a set of *killer applications*
    that would apply to every network. Hence, it’s important to know how to implement
    the required business logic in code, which is what we have tried to show you in
    this chapter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 流式遥测是一种强大的功能，您可以将其适应各种商业用例。然而，这些用例中的大多数都是特定于操作网络环境的，因此很难提出一套适用于每个网络的*杀手级应用*。因此，了解如何在代码中实现所需业务逻辑非常重要，这正是我们在本章中试图向您展示的。
- en: In the following section, we cover another OpenConfig gRPC service you can use
    to automate operational tasks.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍另一个可以用于自动化操作任务的OpenConfig gRPC服务。
- en: Network operations
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络操作
- en: 'In the preceding sections, we explored how the OpenConfig management interface
    approaches two common network automation use cases: configuration management and
    operational state collection. These two tasks alone can get you a long way in
    your network automation journey, but there is a set of common operational tasks
    that don’t fall into either of these categories.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了OpenConfig管理接口如何处理两个常见的网络自动化用例：配置管理和操作状态收集。这两个任务本身就可以让您在网络自动化之旅中走得很远，但还有一些常见的操作任务不属于这两个类别。
- en: To automate all aspects of network operations, we need to perform tasks such
    as network device reloads, software life cycle management, and counter and adjacency
    resets. You normally execute these activities as part of interactive CLI workflows,
    with prompts and warnings that assume a human operator is involved in the process.
    This makes the automation of these tasks a major undertaking, as we have to resort
    to screen-scraping, which increases the already high risk of these tasks.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要自动化网络操作的各个方面，我们需要执行诸如网络设备重启、软件生命周期管理和计数器及邻接重置等任务。通常，您会将这些活动作为交互式CLI工作流程的一部分来执行，其中包含假设有人工操作员参与过程的提示和警告。这使得这些任务的自动化成为一项重大任务，因为我们不得不求助于屏幕抓取，这增加了这些任务已经很高的风险。
- en: To address these challenges, OpenConfig proposed a new gRPC API, designed to
    abstract away the interactive commands and surface these network operations capabilities
    in a standard, vendor-neutral way.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些挑战，OpenConfig提出了一种新的gRPC API，旨在抽象出交互式命令，并以标准、供应商中立的方式公开这些网络操作能力。
- en: gNOI
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: gNOI
- en: 'gNOI defines a list of gRPC services that address a wide range of network operations
    use cases. Each service represents one operational process with a set of actions,
    and the following table includes a few examples to give you an idea of the challenges
    gNOI attempts to solve:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: gNOI定义了一系列gRPC服务，这些服务涵盖了广泛的网络操作用例。每个服务代表一组操作和一系列动作，下表包含了一些示例，以帮助您了解gNOI试图解决的问题：
- en: '| **Service** | **Description** | **RPC examples** |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **服务** | **描述** | **RPC示例** |'
- en: '| OS | NOS package management | Install, Activate, and Verify |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| OS | NOS包管理 | 安装、激活和验证 |'
- en: '| File | File operations | Get, Transfer, Put, and Remove |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | 文件操作 | 获取、传输、放置和删除 |'
- en: '| L2 | L2 protocols operations | ClearNeighborDiscovery and ClearLLDPInterface
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| L2 | L2协议操作 | 清除邻居发现和清除LLDP接口 |'
- en: '| Cert | Certificate management | Rotate, Install, GenerateCSR, and RevokeCertificates
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 证书 | 证书管理 | 轮换、安装、生成CSR和撤销证书 |'
- en: '| System | System operations | Ping, Traceroute, Reboot, and Time |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 系统 | 系统操作 | Ping、Traceroute、重启和时间 |'
- en: Table 9.1 – gNOI use case examples
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 – gNOI用例示例
- en: Some RPCs are a one-shot with immediate response, some stream responses synchronously
    until complete or canceled, and some work asynchronously.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一些RPC是一次性的，有即时响应，一些同步响应直到完成或取消，还有一些是异步工作的。
- en: 'The gNOI GitHub repository (see *Further reading*) protobuf files have the
    most recent list of actions for each service. At the time of writing, this is
    the top-level definition of the `system.proto` file (see *Further reading*):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: gNOI GitHub仓库（见*进一步阅读*）protobuf文件包含每个服务的最新动作列表。在撰写本文时，这是`system.proto`文件的顶级定义（见*进一步阅读*）：
- en: '[PRE84]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We don’t cover all gNOI RPCs in this book. Instead, we focus on just one and
    include an example program built around it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涵盖所有gNOI RPC。相反，我们只关注其中一个，并包括围绕它构建的一个示例程序。
- en: Traceroute RPC
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Traceroute RPC
- en: 'Most, if not all, network engineers are familiar with the `traceroute` command.
    This is a common way to explore the forwarding path between a pair of network
    endpoints. When you run `traceroute` from a network device’s interactive shell,
    the terminal prints the result on your screen. With gNOI, `traceroute` is an action
    we request via an RPC with a `TracerouteRequest` message in the payload, and the
    result is a stream (one or many) of `TracerouteResponse` messages:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数，如果不是所有，网络工程师都熟悉`traceroute`命令。这是探索一对网络端点之间转发路径的常用方法。当您从网络设备的交互式shell中运行`traceroute`时，终端会在您的屏幕上打印结果。在gNOI中，`traceroute`是通过带有负载中的`TracerouteRequest`消息的RPC请求执行的操作，结果是`TracerouteResponse`消息的流（一个或多个）：
- en: '[PRE85]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'As with the `traceroute` command-line arguments and flags, the request message
    lets you specify options such as source address, the maximum number of hops, and
    whether to perform reverse DNS lookups:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与`traceroute`命令行参数和标志一样，请求消息允许您指定选项，例如源地址、最大跳数以及是否执行反向DNS查找：
- en: '[PRE86]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Each response message includes the results of a single measurement cycle, including
    the hop count, the round-trip time, and the responding address extracted from
    a probe reply:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每个响应消息包括单个测量周期的结果，包括跳数、往返时间和从探测回复中提取的响应地址：
- en: '[PRE87]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Now, let’s see an example of how to use the gNOI interface with Go.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用Go语言使用gNOI接口的示例。
- en: Path verifier application
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径验证应用程序
- en: In the streaming telemetry section of this chapter, we explored the implementation
    of an event-manager application that enables or disables a backup link as the
    traffic through the primary interface crosses a pre-defined threshold. We used
    Grafana to plot the traffic rate for both interfaces to confirm that the application
    works as intended.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的流式遥测部分，我们探讨了实现一个事件管理应用程序，该应用程序可以根据通过主接口的流量是否超过预定义阈值来启用或禁用备份链路。我们使用Grafana绘制了两个接口的流量速率，以确认应用程序按预期工作。
- en: In real-world automation use cases involving complex workflows, relying on visual
    clues is not always the right approach. Ideally, we need a programmatic way to
    verify that the backup link is actually working. We use the gNOI `Traceroute`
    RPC to check this in the next code example. The goal is to explore diverse network
    paths and confirm that we are forwarding some traffic flows over the backup interface.
    You can find the code example for this section in the `ch09/gnoi-trace` directory
    of this book’s GitHub repository (see *Further reading*).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及复杂工作流的实际自动化用例中，依赖于视觉线索并不总是正确的做法。理想情况下，我们需要一种程序化的方式来验证备份链路是否真正工作。我们在下一个代码示例中使用gNOI
    `Traceroute` RPC来检查这一点。目标是探索不同的网络路径，并确认我们正在通过备份接口转发一些流量流。您可以在本书GitHub仓库的`ch09/gnoi-trace`目录中找到本节的代码示例（见*进一步阅读*）。
- en: 'We start by setting up a gRPC session to the `ceos` virtual network device
    and creating a new API client for the gNOI `System` service:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一个与`ceos`虚拟网络设备的gRPC会话，并为gNOI `System`服务创建一个新的API客户端：
- en: '[PRE88]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Next, we create a `sync.WaitGroup` to coordinate all goroutines running traceroutes
    to different destinations. These goroutines send the collected results back to
    the `main` goroutine over the `traceCh` channel. For each traceroute destination
    encoded as `string`, the traceroute result includes a list of responded IP addresses
    per network hop.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`sync.WaitGroup`来协调运行到不同目的地的traceroute的所有goroutine。这些goroutine通过`traceCh`通道将收集到的结果发送回`main`
    goroutine。对于编码为`string`的每个traceroute目的地，traceroute结果包括每个网络跳的响应IP地址列表。
- en: 'To make it easier to compare lists of IP addresses in the following steps,
    we store them as a set using the `deckarep/golang-set` (`mapset`) third-party
    package, because Go doesn’t implement sets natively in the standard library. We
    encode the hop count implicitly as the index of the `[]``mapset.Set` array:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使以下步骤中比较IP地址列表更容易，我们使用`deckarep/golang-set`（`mapset`）第三方包将它们存储为集合，因为Go语言在标准库中没有原生实现集合。我们将跳数隐式地编码为`[]mapset.Set`数组中的索引：
- en: '[PRE89]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Each goroutine runs a single traceroute, and we only specify the source and
    destination fields of the `TracerouteRequest` message, leaving the rest options
    as default. As we receive responses, we store the results in the `route` slice.
    When the traceroute stops, which is when the error type is `io.EOF`, we send the
    accumulated response over the `traceCh` channel and call `wg.Done`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每个goroutine运行一个traceroute，我们只指定`TracerouteRequest`消息的源和目的字段，其余选项保留为默认值。当我们收到响应时，我们将结果存储在`route`切片中。当traceroute停止时，即当错误类型为`io.EOF`时，我们通过`traceCh`通道发送累积的响应并调用`wg.Done`：
- en: '[PRE90]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Since network devices have default control plane security settings that may
    restrict them from processing every incoming `goto` statements in the code to
    retry a traceroute in case we don’t get any information for any one hop. `START`
    and `FINISH` are the two labels we used to implement this retry logic, with the
    latter serving as a fall-through case when we don’t get a result after several
    attempts.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络设备具有默认的控制平面安全设置，这些设置可能会限制它们处理代码中的每个`goto`语句以重试traceroute，以防我们对于任何一跳没有获取到任何信息。`START`和`FINISH`是我们用来实现这种重试逻辑的两个标签，后者在我们尝试多次后没有获取到结果时作为回退情况。
- en: 'Once we have completed all traceroute requests, we can process and analyze
    the results. To simplify the code logic, we first transform the data to store
    a map between a hop count and a set of IP addresses per traceroute destination:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了所有traceroute请求，我们就可以处理和分析结果。为了简化代码逻辑，我们首先将数据转换为存储一个跳数与每个traceroute目标的一组IP地址之间的映射：
- en: '[PRE91]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Finally, we can traverse over each hop and check whether there is a discrepancy
    between a set of responding IP addresses for different traceroute destinations,
    which would mean that the packets went over different paths. If we detect this,
    we print it on the screen:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以遍历每个跳数并检查不同traceroute目标的一组响应IP地址之间是否存在差异，这意味着数据包走过了不同的路径。如果我们检测到这种情况，我们将在屏幕上打印出来：
- en: '[PRE92]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'You can run this program from the `ch09/gnoi-trace` folder. Make sure `lab-full`
    is up and running first. You should see output like the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`ch09/gnoi-trace`文件夹运行此程序。请确保`lab-full`首先启动并运行。您应该看到以下输出：
- en: '[PRE93]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Generate traffic with `make traffic-start` and run this program again. In another
    tab, run simultaneously the event-manager application from the `clab-netgo-host-2`
    host to activate the backup link:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make traffic-start`生成流量，然后再次运行此程序。在另一个标签页中，同时从`clab-netgo-host-2`主机运行事件管理器应用程序以激活备份链路：
- en: '[PRE94]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output of the program would look like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出将如下所示：
- en: '[PRE95]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The last output shows that the path that `203.0.113.252/32` and `203.0.113.251/32`
    follow is different from the path that `203.0.113.253/32` follows (primary link).
    This is because the event-manager disaggregated `.252` and `.251` from the main
    `203.0.113.250/30` prefix. Now, we know that the backup link is working as expected,
    as it is carrying traffic for these two IP addresses.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的输出显示，`203.0.113.252/32`和`203.0.113.251/32`遵循的路径与`203.0.113.253/32`遵循的路径不同（主链路）。这是因为事件管理器将`.252`和`.251`从主要的`203.0.113.250/30`前缀中分离出来。现在，我们知道备份链路正在按预期工作，因为它正在为这两个IP地址传输流量。
- en: Historically, networking vendors were not incentivized to create vendor-neutral
    APIs and data models, as it doesn’t allow them to differentiate themselves from
    the competition. And while standards bodies such as the Internet Engineering Task
    Force (IETF) produce standards for the networking industry, they can’t always
    influence what vendors actually implement. Also, some vendors might still perceive
    technological lock-ins as an effective way to keep their existing customer base.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，网络供应商没有动力创建供应商中立的API和数据模型，因为这不允许他们与竞争对手区分开来。虽然像互联网工程任务组（IETF）这样的标准机构为网络行业制定标准，但他们不能总是影响供应商实际实施的内容。此外，一些供应商可能仍然认为技术锁定是一种有效的保持现有客户群的方法。
- en: By contrast, the OpenConfig community of network operators has more leverage
    to influence networking vendors to adopt vendor-independent data models and APIs.
    OpenConfig adoption is still relatively low, in both model and feature coverage,
    but, as long as the OC participants continue to push for more, the coverage will
    increase, which, in turn, will drive the adoption in the wider networking community.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，网络运营商的OpenConfig社区更有能力影响网络供应商采用供应商独立的数据模型和API。OpenConfig的采用率在模型和功能覆盖方面仍然相对较低，但是，只要OC参与者继续推动更多，覆盖范围将会增加，这将反过来推动更广泛的网络社区采用。
- en: Even today, OpenConfig provides a vendor-neutral way of doing a lot of common
    networking tasks, including configuration management, monitoring, and operations.
    In this chapter, we’ve shown the two most popular interfaces, gNMI and gNOI, ignoring
    the less common gRIBI, which is outside of the scope of this book. We hope this
    chapter provides enough examples of tools and workflows that you can use with
    Go to consume and interact with OpenConfig-compliant devices.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在今天，OpenConfig也提供了一种供应商中立的网络任务执行方式，包括配置管理、监控和操作。在本章中，我们展示了两个最流行的接口，gNMI和gNOI，忽略了较少使用的gRIBI，它超出了本书的范围。我们希望本章提供了足够的工具和工作流程示例，您可以使用Go来消费和与OpenConfig兼容的设备交互。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, by introducing streaming telemetry, we have started exploring
    the world of network monitoring, a critical task for a business. The ability to
    observe network-wide state and collect and process data plane information are
    all important in determining the health of your network. In the next chapter,
    we will examine a few concrete examples of network monitoring tasks and use cases
    and learn how Go can help us automate them.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，通过介绍流式遥测，我们开始探索网络监控的世界，这对于企业来说是一项关键任务。观察网络整体状态以及收集和处理数据平面信息的能力，对于确定网络的健康状况都至关重要。在下一章中，我们将探讨一些具体的网络监控任务和用例，并学习Go语言如何帮助我们自动化这些任务。
- en: Further reading
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Network operators: [https://www.openconfig.net/about/participants/](https://www.openconfig.net/about/participants/)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络运营商：[https://www.openconfig.net/about/participants/](https://www.openconfig.net/about/participants/)
- en: 'Manipulating forwarding entries: https://github.com/openconfig/gribi/blob/master/doc/motivation.md#grpc-service-for-rib-injection'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作转发条目：[https://github.com/openconfig/gribi/blob/master/doc/motivation.md#grpc-service-for-rib-injection](https://github.com/openconfig/gribi/blob/master/doc/motivation.md#grpc-service-for-rib-injection)
- en: 'gNMI collector: https://github.com/openconfig/gnmi/tree/master/cmd/gnmi_collector'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gNMI 收集器：[https://github.com/openconfig/gnmi/tree/master/cmd/gnmi_collector](https://github.com/openconfig/gnmi/tree/master/cmd/gnmi_collector)
- en: 'gNMI CLI utility: [https://github.com/openconfig/gnmi/tree/master/cmd/gnmi_cli](https://github.com/openconfig/gnmi/tree/master/cmd/gnmi_cli
    )'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gNMI CLI 工具：[https://github.com/openconfig/gnmi/tree/master/cmd/gnmi_cli](https://github.com/openconfig/gnmi/tree/master/cmd/gnmi_cli
    )
- en: 'gNMI Test framework: [https://github.com/openconfig/gnmitest](https://github.com/openconfig/gnmitest
    )'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gNMI 测试框架：[https://github.com/openconfig/gnmitest](https://github.com/openconfig/gnmitest
    )
- en: 'gRPC tunnel: [https://github.com/openconfig/grpctunnel](https://github.com/openconfig/grpctunnel
    )'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC 隧道：[https://github.com/openconfig/grpctunnel](https://github.com/openconfig/grpctunnel
    )
- en: IS-IS LSDB parsing: [https://github.com/openconfig/lsdbparse](https://github.com/openconfig/lsdbparse
    )
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IS-IS LSDB 解析：[https://github.com/openconfig/lsdbparse](https://github.com/openconfig/lsdbparse
    )
- en: 'Ygot: [https://github.com/openconfig/ygot](https://github.com/openconfig/ygot
    )'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ygot：[https://github.com/openconfig/ygot](https://github.com/openconfig/ygot
    )
- en: 'gNxI Tools: https://github.com/google/gnxi'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gNxI 工具：[https://github.com/google/gnxi](https://github.com/google/gnxi )
- en: 'Book’s GitHub repository: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go
    )'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍的 GitHub 仓库：[https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go
    )
- en: 'gNMI specification: [https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md](https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gNMI 规范：[https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md](https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md)
- en: 'gNMIc docs: https://gnmic.kmrd.dev/user_guide/golang_package/intro/#set-request'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gNMIc 文档：[https://gnmic.kmrd.dev/user_guide/golang_package/intro/#set-request](https://gnmic.kmrd.dev/user_guide/golang_package/intro/#set-request)
- en: 'gNMI path convention: [https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-path-conventions.md](https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-path-conventions.md
    )'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gNMI 路径约定：[https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-path-conventions.md](https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-path-conventions.md
    )
- en: 'gNMI repository: [https://github.com/openconfig/gnmi](https://github.com/openconfig/gnmi
    )'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gNMI 仓库：[https://github.com/openconfig/gnmi](https://github.com/openconfig/gnmi
    )
- en: 'gNMIc: [https://gnmic.kmrd.dev/](https://gnmic.kmrd.dev/ )'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gNMIc：[https://gnmic.kmrd.dev/](https://gnmic.kmrd.dev/ )
- en: 'AlertManager: [https://prometheus.io/docs/alerting/latest/alertmanager/](https://prometheus.io/docs/alerting/latest/alertmanager/
    )'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AlertManager：[https://prometheus.io/docs/alerting/latest/alertmanager/](https://prometheus.io/docs/alerting/latest/alertmanager/
    )
- en: '`full/workdir/`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/topo-full/workdir](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/topo-full/workdir
    )'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`full/workdir/`：[https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/topo-full/workdir](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/topo-full/workdir
    )'
- en: '`topo.yml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/topo-full/topo.yml](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/topo-full/topo.yml
    )'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`topo.yml`：[https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/topo-full/topo.yml](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/topo-full/topo.yml
    )'
- en: '`docker-compose.yml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch09/docker-compose.yml](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch09/docker-compose.yml
    )'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose.yml`：[https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch09/docker-compose.yml](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch09/docker-compose.yml
    )'
- en: 'gNOI GitHub repository: [https://github.com/openconfig/gnoi](https://github.com/openconfig/gnoi
    )'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gNOI GitHub 仓库：[https://github.com/openconfig/gnoi](https://github.com/openconfig/gnoi
    )
- en: '`system.proto` file: [https://github.com/openconfig/gnoi/blob/master/system/system.proto](https://github.com/openconfig/gnoi/blob/master/system/system.proto)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system.proto` 文件：[https://github.com/openconfig/gnoi/blob/master/system/system.proto](https://github.com/openconfig/gnoi/blob/master/system/system.proto)'
