- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Network Monitoring
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络监控
- en: Despite the popularity of configuration management, we actually spend more time
    monitoring networks than configuring them. As networks become more and more complex,
    with new layers of encapsulation and IP address translations, our ability to understand
    whether a network functions correctly to let us meet customer **service-level
    agreements** (**SLAs**) is becoming increasingly difficult.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管配置管理很受欢迎，但我们实际上花在监控网络上的时间比配置它们的时间更多。随着网络变得越来越复杂，新的封装层和 IP 地址转换，我们理解网络是否正确运行以使我们能够满足客户**服务级别协议**（**SLAs**）的能力变得越来越困难。
- en: Engineers working in the cloud infrastructure space have come up with the term
    *observability*, referring to the ability to reason about the internal state of
    a system by observing its external outputs. Translated into networking terms,
    this may include passive monitoring through logs and state telemetry collection
    or active monitoring using distributed probing, data processing, and visualization.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在云基础设施领域工作的工程师提出了“可观察性”这个术语，指的是通过观察系统的外部输出来推理系统内部状态的能力。用网络术语来说，这可能包括通过日志和状态遥测收集的被动监控或使用分布式探测、数据处理和可视化的主动监控。
- en: 'The ultimate goal of all this is to reduce the **mean time to repair** (**MTTR**),
    adhere to customer SLAs, and shift to proactive problem resolution. Go is a very
    popular language of choice for these kinds of tasks, and in this chapter we will
    examine a few of the tools, packages, and platforms that can help you with network
    monitoring. Here are the highlights of this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的最终目标是减少**平均修复时间**（**MTTR**），遵守客户服务级别协议（**SLAs**），并转向主动问题解决。Go 语言是这类任务中非常受欢迎的选择语言，在本章中，我们将探讨一些可以帮助您进行网络监控的工具、包和平台。以下是本章的要点：
- en: We will explore traffic monitoring by looking at how to capture and parse network
    packets with Go.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将通过查看如何使用 Go 语言捕获和解析网络数据包来探索流量监控。
- en: Next, we will look at how to process and aggregate data plane telemetry to get
    meaningful insights into the current network behavior.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何处理和汇总数据平面遥测数据，以获取对当前网络行为的有意义见解。
- en: We show how you can use active probing to measure network performance, and how
    to produce, collect, and visualize performance metrics.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了如何使用主动探测来衡量网络性能，以及如何生成、收集和可视化性能指标。
- en: We will deliberately avoid talking about YANG-based telemetry, as we covered
    this already in [*Chapter 8*](B16971_08.xhtml#_idTextAnchor182), *Network APIs*,
    and [*Chapter 9*](B16971_09.xhtml#_idTextAnchor209), *OpenConfig*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将故意避免讨论基于 YANG 的遥测，因为我们已经在[*第 8 章*](B16971_08.xhtml#_idTextAnchor182)“网络 API”和[*第
    9 章*](B16971_09.xhtml#_idTextAnchor209)“OpenConfig”中介绍过了。
- en: Another area that we haven’t touched on so far and that we want to discuss briefly
    in this chapter is the developer experience. As we write more code, maintaining
    existing software becomes an important part of our day-to-day operations. We introduce
    one tool per section of this chapter, acknowledging that we are just scratching
    the surface and that this topic could be the subject of an entire book. In the
    end, we don’t strive to give a comprehensive overview of all tools there are out
    there but just want to give you an idea of what developing Go code in production
    may feel like.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还没有涉及的一个领域，我们希望在本章中简要讨论的是开发者体验。随着我们编写更多的代码，维护现有软件成为我们日常运营的重要部分。我们将在本章的每个部分介绍一个工具，承认我们只是触及了表面，这个主题可能是一整本书的主题。最后，我们并不力求提供一个全面概述所有工具的概述，只是想给您一个在生产环境中开发
    Go 代码可能感觉如何的印象。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code examples for this chapter in the book’s GitHub repository
    (see the *Further reading* section), under the `ch10` folder.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的 GitHub 仓库中找到本章的代码示例（见*进一步阅读*部分），在`ch10`文件夹下。
- en: Important Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We recommend you execute the Go programs in this chapter in a virtual lab environment.
    Refer to the *Appendix* for prerequisites and instructions on how to build the
    fully configured network topology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在虚拟实验室环境中执行本章中的 Go 程序。有关先决条件和如何构建完全配置的网络拓扑结构的说明，请参阅*附录*。
- en: The first example we will discuss in the following section explores packet capturing
    and parsing capabilities in Go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论的第一个示例将探讨 Go 中的数据包捕获和解析功能。
- en: Data plane telemetry processing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据平面遥测处理
- en: Network activities such as capacity planning, billing, or **distributed denial-of-service**
    (**DDoS**) attack monitoring require insights into the traffic flowing through
    a network. One way we can offer such visibility is by deploying a packet sampling
    technology. The premise is that at a high-enough rate, it’s possible to capture
    only a randomly sampled subset of packets to build a good understanding of the
    overall network traffic patterns.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 网络活动，如容量规划、计费或**分布式拒绝服务**（**DDoS**）攻击监控，需要了解通过网络流过的流量。我们可以提供此类可见性的方法之一是部署数据包采样技术。前提是，以足够高的速率，只捕获随机采样的数据包子集，以建立一个对整体网络流量模式的良好理解。
- en: While it’s the hardware that samples the packets, it’s the software that aggregates
    them into flows and exports them. NetFlow, sFlow, and **IP Flow Information Export**
    (**IPFIX**) are the three main protocols we use for this, and they define the
    structure of the payload and what metadata to include with each sampled packet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然是硬件对数据包进行采样，但软件将它们聚合为流并导出。NetFlow、sFlow和**IP流信息导出**（**IPFIX**）是我们用于此目的的三个主要协议，它们定义了有效负载的结构以及每个采样数据包应包含哪些元数据。
- en: One of the first steps in any telemetry processing pipeline is information ingestion.
    In our context, this means receiving and parsing data plane telemetry packets
    to extract and process flow records. In this section, we will look at how you
    can capture and process packets with the help of the `google/gopacket` package
    (see *Further reading*).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 任何遥测处理流程的第一步是信息摄取。在我们的上下文中，这意味着接收和解析数据平面遥测数据包以提取和处理流记录。在本节中，我们将探讨如何借助`google/gopacket`包（见*进一步阅读*）捕获和处理数据包。
- en: Packet capturing
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据包捕获
- en: In [*Chapter 4*](B16971_04.xhtml#_idTextAnchor109), *Networking (TCP/IP) with
    Go*, we discussed how to build a UDP ping application using the `net` package
    from Go’s standard library. And while we should probably take a similar approach
    when building an sFlow collector, we will do something different for the next
    example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B16971_04.xhtml#_idTextAnchor109)“使用Go的TCP/IP网络”，我们讨论了如何使用Go标准库中的`net`包构建UDP
    ping应用程序。虽然我们可能应该采取类似的方法来构建sFlow收集器，但我们将为下一个示例做些不同的事情。
- en: Instead of building a data plane telemetry collector, we designed our application
    to tap into an existing flow of telemetry packets, assuming the network devices
    in the topology are sending them to an existing collector somewhere in the network.
    This allows you to avoid changing the existing telemetry service configuration
    while still being able to capture and process telemetry traffic. You can use a
    program like this when you want a transparent tool that can run directly on a
    network device, on demand, and for a short period of time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有设计一个数据平面遥测收集器，而是将我们的应用程序设计为接入现有的遥测数据包流，假设拓扑中的网络设备正在将它们发送到网络中某个位置的现有收集器。这允许你在不改变现有遥测服务配置的情况下，仍然能够捕获和处理遥测流量。当你需要一个可以直接在网络上运行、按需使用且持续时间短的透明工具时，你可以使用这样的程序。
- en: 'In the test lab topology, the `cvx` node runs an agent that exports sampled
    metrics using the sFlow protocol. The sFlow traffic flows toward `host-2`, where
    it gets intercepted by the example application using a tap:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试实验室拓扑中，`cvx`节点运行一个代理，使用sFlow协议导出采样指标。sFlow流量流向`host-2`，在那里它被示例应用程序使用tap拦截：
- en: '![Figure 10.1 – sFlow application](img/B16971_10_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – sFlow应用程序](img/B16971_10_01.jpg)'
- en: Figure 10.1 – sFlow application
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – sFlow应用程序
- en: To show you the packet-capturing capabilities of the `google/gopacket` package,
    we intercept all sFlow packets using `pcapgo` – a native Go implementation of
    the traffic-capturing API in Linux. Although it’s less feature-rich than its counterpart
    `pcap` and `pfring` packages, the benefit of `pcapgo` is that it doesn’t rely
    on any external C libraries and can work natively on any Linux distribution.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您展示`google/gopacket`包的数据包捕获功能，我们使用`pcapgo`拦截所有sFlow数据包——这是Linux中流量捕获API的本地Go实现。尽管它比其对应的`pcap`和`pfring`包功能较少，但`pcapgo`的好处是它不依赖于任何外部C库，并且可以在任何Linux发行版上本地运行。
- en: 'In the first part of the `packet-capture` program, which you can find in the
    `ch10/packet-capture` folder of this book’s GitHub repository, we set up a new
    `af_packet` socket handler with the `pcapgo.NewEthernetHandle` function, passing
    it the name of the interface to monitor:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书GitHub仓库的`ch10/packet-capture`文件夹中，您可以在`packet-capture`程序的第一部分中设置一个新的`af_packet`套接字处理程序，使用`pcapgo.NewEthernetHandle`函数，并传递要监控的接口名称：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At this point, `handle` gives us access to all packets on the `eth0` interface.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`handle`为我们提供了对`eth0`接口上所有数据包的访问权限。
- en: Packet filtering
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据包过滤
- en: While we could just capture all packets through the interface, for the sake
    of experimenting, we will include an example of how to filter the traffic we capture
    with a **Berkeley Packet Filter** (**BPF**) program in Go.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以通过接口捕获所有数据包，但为了实验的目的，我们将包括一个如何在Go中使用**伯克利数据包过滤器（BPF**）程序过滤我们捕获的流量的示例。
- en: 'First, we generate a compiled packet-matching code in a human-readable format,
    using the `-d` option of the `tcpdump` command to filter IP and UDP packets:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`tcpdump`命令的`-d`选项以可读格式生成一个编译后的包匹配代码，用于过滤IP和UDP数据包：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we convert each of the preceding instructions into a corresponding `bpf.Instruction`
    from the `golang.org/x/net/bpf` package. We assemble these instructions into a
    set of `[]bpf.RawInstruction` that are ready to load into a BPF virtual machine:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将前面的每个指令转换为来自`golang.org/x/net/bpf`包的相应`bpf.Instruction`。我们将这些指令组装成一组`[]bpf.RawInstruction`，它们可以加载到BPF虚拟机中：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can attach the result to the `EthernetHandle` function we created earlier,
    to act as a packet filter and reduce the number of packets received by the application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将结果附加到我们之前创建的`EthernetHandle`函数上，作为数据包过滤器，以减少应用程序接收到的数据包数量。
- en: In summary, we copy all packets that match the `0x800` EtherType and the `0x11`
    IP protocol to the user space process, where our Go program runs, while all the
    other packets, including the ones we match, continue through the network stack.
    This makes this program completely transparent to any existing traffic flows,
    and you can use it without having to change the configuration of the sFlow agent.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们将匹配`0x800`以太网类型和`0x11`IP协议的所有数据包复制到用户空间进程，其中我们的Go程序运行，而所有其他数据包，包括我们匹配的数据包，将继续通过网络堆栈。这使得这个程序对任何现有的流量流都是完全透明的，并且你可以使用它而无需更改sFlow代理的配置。
- en: Packet processing
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据包处理
- en: 'All packets that the kernel sends to the user space become available in the
    Go application through the `PacketSource` type, which we build by combining the
    `EthernetHandle` function we created with an Ethernet packet decoder:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 内核发送到用户空间的所有数据包都通过`PacketSource`类型在Go应用程序中变得可用，我们通过将我们创建的`EthernetHandle`函数与一个以太网数据包解码器相结合来构建这个类型：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This `PacketSource` structure sends each received and decoded packet over a
    Go channel, which means we can use a `for` loop to iterate over them one by one.
    Inside this loop, we use `gopacket` to match packet layers and extract information
    about L2, L3, and L4 networking headers, including protocol-specific details such
    as the sFlow payload:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`PacketSource`结构通过Go通道发送每个接收和解码的数据包，这意味着我们可以使用`for`循环逐个迭代它们。在这个循环内部，我们使用`gopacket`来匹配数据包层并提取关于L2、L3和L4网络头部的信息，包括特定于协议的细节，如sFlow有效负载：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The benefit of using `gopacket` specifically for sFlow decoding is that it can
    parse and create another `gopacket.Packet` based on the sampled packet’s headers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gopacket`专门进行sFlow解码的好处是它可以基于采样数据包的头部解析并创建另一个`gopacket.Packet`。
- en: Generating traffic
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成流量
- en: To test this Go application, we need to generate some traffic in the lab topology,
    so the `cvx` device can generate sFlow records about it. Here, we use `microsoft/ethr`
    – a Go-based traffic generator that offers a user experience and features comparable
    to `iperf`. It can generate and receive a fixed volume of network traffic and
    measure bandwidth, latency, loss, and jitter. In our case, we only need it to
    generate a few low-volume traffic flows over the lab network to trigger the data
    plane flow sampling.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个Go应用程序，我们需要在实验室拓扑中生成一些流量，以便`cvx`设备可以生成关于它的sFlow记录。在这里，我们使用`microsoft/ethr`
    – 一个基于Go的流量生成器，它提供与`iperf`相当的用户体验和功能。它可以生成和接收固定量的网络流量并测量带宽、延迟、丢失和抖动。在我们的情况下，我们只需要它生成一些低流量的流量流，通过实验室网络触发数据平面流量采样。
- en: 'The `packet-capture` application taps into the existing sFlow traffic, parses
    and extracts flow records, and prints that information on the screen. To test
    the program, run `make capture-start` from the root of this book’s GitHub repository
    (see *Further reading*):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`packet-capture`应用程序从现有的sFlow流量中提取，解析和提取流记录，并在屏幕上打印这些信息。要测试程序，从本书GitHub存储库的根目录运行`make
    capture-start`（参见*进一步阅读*）：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As promised, before we move on to the next section, let’s review the first *developer
    experience* tool of the chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，在我们进入下一节之前，让我们回顾本章的第一个*开发者体验*工具。
- en: Debugging Go programs
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go程序调试
- en: Reading and reasoning about an existing code base is a laborious task, and it
    gets even harder as programs mature and evolve. This is why, when learning a new
    language, it’s very important to have at least a basic understanding of the debugging
    process. Debugging allows us to halt the execution of a program at a pre-defined
    place and step through the code line by line while examining in-memory variables
    and data structures.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读和推理现有代码库是一项费力的任务，随着程序的成熟和演变，这变得更加困难。这就是为什么在学习新语言时，至少对调试过程有一个基本理解非常重要。调试允许我们在预定义的位置停止程序的执行，并逐行通过代码，同时检查内存中的变量和数据结构。
- en: 'In the following example, we use Delve to debug the `packet-capture` program
    we just ran. Before you can start, you need to generate some traffic through the
    lab topology with `make traffic-start`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用 Delve 调试我们刚刚运行的 `packet-capture` 程序。在您开始之前，您需要通过 `make traffic-start`
    在实验室拓扑中生成一些流量：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Delve binary file is already pre-installed in the `host` lab containers,
    so you can connect to the `host-2` container with the `docker exec -it` command
    and start the Delve shell with the `dlv` `debug` command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Delve 二进制文件已在 `host` 实验室容器中预先安装，因此您可以使用 `docker exec -it` 命令连接到 `host-2` 容器，并使用
    `dlv debug` 命令启动 Delve shell：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once in the `dlv` interactive shell, you can use different built-in commands
    to control the execution of the program (you can use `help` to view the full list
    of commands). Set a breakpoint at line 49 of `main.go` and run the program until
    the point where we receive the first packet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入 `dlv` 交互式 shell，您可以使用不同的内置命令来控制程序的执行（您可以使用 `help` 查看命令列表的完整列表）。在 `main.go`
    的第 49 行设置断点，并运行程序直到我们收到第一个数据包：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When execution stops at a breakpoint, you can examine the local variables using
    the `locals` command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行在断点处停止时，您可以使用 `locals` 命令检查局部变量：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can print the variable contents on a screen, as in the following example
    for the `packet` variable:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在屏幕上打印变量内容，如下面的 `packet` 变量示例所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The text-based navigation and verbosity of the output may be intimidating for
    beginners, but luckily, we have alternative visualization options.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 文本导航和输出的详细程度可能对初学者来说有些吓人，但幸运的是，我们有其他可视化选项。
- en: Debugging from an IDE
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 IDE 进行调试
- en: If debugging in a console is not your preferred option, most of the popular
    **Integrated Development Environments** (**IDEs**) come with some form of support
    for Go debugging. For example, Delve integrates with **Visual Studio Code** (**VSCode**)
    and you can also configure it for remote debugging.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在控制台中调试不是您的首选选项，那么大多数流行的 **集成开发环境**（**IDE**）都提供某种形式的 Go 调试支持。例如，Delve 与 **Visual
    Studio Code**（**VSCode**）集成，您也可以为其配置远程调试。
- en: 'Although you can set up VSCode for remote debugging in different ways, in this
    example, we run Delve manually inside a container in the `headless` mode while
    specifying the port at which to listen for incoming connections:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以通过不同的方式设置 VSCode 的远程调试，但在本例中，我们在 `headless` 模式下手动在容器中运行 Delve，同时指定监听传入连接的端口：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we need to tell VSCode how to connect to the remote Delve process. You
    can do this by including a JSON config file in the `.vscode` folder next to the
    `main.go` file. Here’s an example file you can find in `ch10/packet-capture/.vscode/launch.json`
    in this book’s GitHub repository:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉 VSCode 如何连接到远程 Delve 进程。您可以通过在 `main.go` 文件旁边的 `.vscode` 文件夹中包含一个
    JSON 配置文件来实现这一点。以下是一个示例文件，您可以在本书 GitHub 仓库的 `ch10/packet-capture/.vscode/launch.json`
    中找到：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You need to replace the `host` value with the one where the lab is running
    and then start an instance of VSCode from the root of the Go program (`code ch10/packet-capture`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将 `host` 值替换为实验室运行的位置，然后从 Go 程序的根目录启动 VSCode 实例（`code ch10/packet-capture`）：
- en: '![Figure 10.2 – VSCode development environment ](img/B16971_10_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – VSCode 开发环境](img/B16971_10_02.jpg)'
- en: Figure 10.2 – VSCode development environment
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – VSCode 开发环境
- en: In VSCode, now you can go to the debug icon in the left menu to get to **RUN
    AND DEBUG**, where you should see the **Connect to server** option that reads
    the preceding JSON config file. Click on the green arrow to connect to the remote
    debugging process.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VSCode 中，现在您可以点击左侧菜单中的调试图标，进入 **运行和调试**，在那里您应该看到读取前面 JSON 配置文件的 **连接到服务器**
    选项。点击绿色箭头以连接到远程调试进程。
- en: 'At this point, you can navigate through the code and examine local variables
    inside the VSCode **user interface** (**UI**), while the debugging process is
    running inside a container:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，您可以在调试过程在容器内运行的同时，在VSCode **用户界面**（**UI**）中导航并检查局部变量：
- en: '![Figure 10.3 – VSCode debugging](img/B16971_10_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – VSCode调试](img/B16971_10_03.jpg)'
- en: Figure 10.3 – VSCode debugging
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – VSCode调试
- en: In the next section, we will look at how to add value to the data plane telemetry
    we collect and process by aggregating it to generate a report of the highest bandwidth
    consumers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何通过聚合收集和处理的网络平面遥测数据来增加其价值，并生成最高带宽消费者的报告。
- en: Data plane telemetry aggregation
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络平面遥测聚合
- en: After collecting and parsing data plane telemetry, we need to think about what
    to do with it next. Looking at raw data is not always helpful because of the sheer
    number of flows and lack of any meaningful context. Hence, the next logical step
    in a telemetry processing pipeline is data enrichment and aggregation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集和解析数据平面遥测数据后，我们需要考虑接下来如何处理这些数据。由于数据流数量庞大且缺乏任何有意义的上下文，直接查看原始数据并不总是有帮助。因此，遥测处理管道中的下一个逻辑步骤是数据增强和聚合。
- en: Telemetry enrichment refers to the process of adding extra metadata to each
    flow based on some external source of information. For example, these external
    sources can provide a correlation between a public IP and its country of origin
    or BGP ASN, or between a private IP and its aggregate subnets or device identity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 遥测增强是指根据某些外部信息源，为每个数据流添加额外元数据的过程。例如，这些外部源可以提供公共IP与其来源国家或BGP ASN之间的关联，或者私有IP与其聚合子网或设备标识之间的关联。
- en: Another technique that can help us interpret and reason about the telemetry
    we collect is aggregation. We can combine different flow records either based
    on the IP prefix boundary or flow metadata, such as a BGP ASN, to help network
    operators draw meaningful insights and create high-level views of the data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以帮助我们解释和推理所收集遥测数据的技巧是聚合。我们可以根据IP前缀边界或流元数据（如BGP ASN）将不同的流记录组合起来，以帮助网络操作员得出有意义的见解并创建数据的高级视图。
- en: You could build the entire telemetry processing pipeline out of open source
    components with ready-to-use examples (see *Further reading*) available on the
    internet, but sooner or later, you might need to write some code to meet your
    specific business requirements. In the following section, we will work on a scenario
    where we need to aggregate data plane telemetry to better understand the traffic
    patterns in our network.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用开源组件构建整个遥测处理管道，并使用互联网上可用的现成示例（见*进一步阅读*），但迟早您可能需要编写一些代码以满足特定的业务需求。在下一节中，我们将处理一个需要聚合网络平面遥测数据以更好地了解网络流量模式的场景。
- en: Top talkers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要通信者
- en: In the absence of long-term telemetry storage, getting a just-in-time snapshot
    of the highest bandwidth consumers can be quite helpful. We refer to this application
    as *top talkers*, and it works by displaying a list of network flows that are
    sorted based on their relative interface bandwidth utilization.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有长期遥测存储的情况下，获取最高带宽消费者的即时快照可能非常有帮助。我们将此应用程序称为*主要通信者*，它通过显示基于相对接口带宽利用率排序的网络流列表来工作。
- en: Let’s walk through an example Go application that implements this feature.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实现此功能的Go应用程序示例来了解一下。
- en: Exploring telemetry data
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索遥测数据
- en: In our `top-talkers` application, we collect sFlow records with `netsampler/goflow2`,
    a package designed specifically to collect, enrich, and save sFlow, IPFIX, or
    NetFlow telemetry. This package ingests raw protocol data and produces normalized
    (protocol-independent) flow records. By default, you can save these normalized
    records in a file or send them to a Kafka queue. In our case, we store them in
    memory for further processing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`top-talkers`应用程序中，我们使用`netsampler/goflow2`收集sFlow记录，这是一个专门设计用于收集、增强和保存sFlow、IPFIX或NetFlow遥测数据的包。该包摄取原始协议数据并生成标准化（协议无关）的流记录。默认情况下，您可以将这些标准化记录保存到文件或发送到Kafka队列。在我们的案例中，我们将它们存储在内存中以便进一步处理。
- en: 'To store the flow records in memory, we save the most relevant fields of each
    flow record we receive in a user-defined data structure we call `MyFlow`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在内存中存储流记录，我们将接收到的每个流记录的最相关字段保存到用户定义的数据结构中，我们称之为`MyFlow`：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Additionally, we create a flow key as a concatenation of the ports and IP addresses
    of the source and destination to uniquely identify each flow:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们创建一个流键，作为源和目标端口及IP地址的连接，以唯一标识每个流：
- en: '![Figure 10.4 – A flow key](img/B16971_10_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 流量键](img/B16971_10_04.jpg)'
- en: Figure 10.4 – A flow key
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 流量键
- en: 'To help us calculate the final result, we create another data structure we
    call `topTalker`, which has two fields:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们计算最终结果，我们创建了一个我们称之为`topTalker`的另一个数据结构，它有两个字段：
- en: '`flowMap`: A map to store a collection of `MyFlow`-type flows. We use the key
    we created to index them.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flowMap`：一个用于存储`MyFlow`类型流集合的映射。我们使用我们创建的键来索引它们。'
- en: '`Heap`: A helper data structure that keeps track of the most frequently seen
    flows:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Heap`：一个辅助数据结构，用于跟踪最频繁出现的流量：'
- en: '[PRE14]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since we use a high-level sFlow package (`goflow2`), we don’t need to worry
    about setting up a UDP listener or receiving and decoding packets, but we need
    to tell `goflow2` the format to report flow records (`json`) and point to a custom
    transport driver (`tt`) that determines what to do with the data after the sFlow
    package normalizes the received flow records:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用高级sFlow包（`goflow2`），我们不需要担心设置UDP监听器或接收和解码数据包，但我们需要告诉`goflow2`报告流量记录的格式（`json`）并指向一个自定义传输驱动程序（`tt`），该驱动程序确定在sFlow包标准化接收到的流量记录之后如何处理数据：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Transport` field in the `utils.StateSFlow` type of the preceding code
    snippet accepts any type that implements `TransportInterface`. This interface
    expects a single method (`Send()`) where all the enrichment and aggregation may
    take place:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码片段中的`utils.StateSFlow`类型的`Transport`字段接受任何实现了`TransportInterface`接口的类型。该接口期望一个方法（`Send()`），其中可以发生所有丰富和聚合操作：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Send` method accepts two arguments, one representing the source IP of an
    sFlow datagram and the second one containing the actual flow record.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Send`方法接受两个参数，一个表示sFlow数据报的源IP，另一个包含实际的流量记录。'
- en: Telemetry processing
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遥测处理
- en: 'In our implementation of the `Send` method (to satisfy the `TransportInterface`
    interface), we first parse the input binary data and deserialize it into a `MyFlow`
    data structure:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Send`方法实现（以满足`TransportInterface`接口）中，我们首先解析输入的二进制数据，并将其反序列化为`MyFlow`数据结构：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Bearing in mind that sFlow can capture packets going in either direction, we
    need to ensure that both flows count toward the same in-memory flow record. This
    means creating a special flow key that satisfies the following two conditions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到sFlow可以捕获双向的数据包，我们需要确保两个流都计入内存中的同一流量记录。这意味着创建一个特殊的流量键，满足以下两个条件：
- en: It must be the same for both ingress and egress packets of the same flow.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须与同一流的所有入站和出站数据包相同。
- en: It must be unique for all bidirectional flows.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须对所有双向流量是唯一的。
- en: 'We do this by sorting the source and destination IPs when constructing the
    bidirectional flow key, as the next code snippet shows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在构建双向流量键时对源和目标IP进行排序来完成这项工作，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With a unique key that represents both directions of a flow, we can save it
    in the map (`flowMap`) to store in memory. For each received flow record, the
    `Send` method performs the following checks:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个唯一键表示流的双向，我们可以在映射（`flowMap`）中保存它以存储在内存中。对于每个接收到的流量记录，`Send`方法执行以下检查：
- en: If this is the first time we’ve seen this flow, then we save it on the map and
    set the count number to `1`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这是我们第一次看到这个流量，那么我们就把它保存在地图上，并将计数器设置为`1`。
- en: 'Otherwise, we update the flow by incrementing its count by one:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，我们通过将计数器增加一个来更新流量：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, to display the top talkers in order, we need to sort the flow records we
    have saved. Here, we use the `container/heap` package from the Go standard library.
    It implements a sorting algorithm, offering O(log n) (logarithmic) upper-bound
    guarantees, which means it can do additions and deletions of data very efficiently.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了按顺序显示顶级对话者，我们需要对保存的流量记录进行排序。在这里，我们使用Go标准库中的`container/heap`包。它实现了一个排序算法，提供O(log
    n)（对数）上界保证，这意味着它可以非常高效地进行数据添加和删除操作。
- en: 'To use this package, you only need to teach it how to compare your items. As
    you add, remove, or update elements, it will sort them automatically. In our example,
    we want to sort flow records saved as the `MyFlow` data type. We define `Heap`
    as a list of pointers to `MyFlow` records. The `Less()` method instructs the `container/heap`
    package to compare two `MyFlow` elements, based on the `Count` field that stores
    the number of times we have *seen* a flow record:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此包，你只需要教它如何比较你的项目。当你添加、删除或更新元素时，它会自动对它们进行排序。在我们的例子中，我们想要对保存为`MyFlow`数据类型的流量记录进行排序。我们定义`Heap`为指向`MyFlow`记录的指针列表。`Less()`方法指示`container/heap`包根据存储我们已看到流量记录次数的`Count`字段比较两个`MyFlow`元素：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this, we now have an in-memory flow record store with elements sorted
    according to their `Count`. We can now iterate over the `Heap` slice and print
    its elements on the screen. As in the earlier example with `gopacket`, we use
    `ethr` to generate three UDP flows with different throughputs to get a consistently
    sorted output. You can trigger the flows in the topology with `make top-talkers-start`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个内存中的流记录存储，其元素根据它们的`Count`进行排序。我们现在可以遍历`Heap`切片，并在屏幕上打印其元素。与之前的`gopacket`示例一样，我们使用`ethr`生成具有不同吞吐量的三个UDP流，以获得一致的排序输出。您可以使用`make
    top-talkers-start`在拓扑中触发这些流：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, run the Top-talkers Go application with `go run main.go` from within
    the `host-2` container (`clab-netgo-host-2`) to get a real-time Top-talkers table:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`host-2`容器（`clab-netgo-host-2`）内部使用`go run main.go`运行Top-talkers Go应用程序，以获取实时Top-talkers表：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that due to low traffic volume, random packet sampling, and limited test
    duration, your results may be slightly different but should converge to a similar
    distribution after several test iterations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于流量量低、随机数据包采样和测试持续时间有限，你的结果可能会有所不同，但在多次测试迭代后应该收敛到类似的分布。
- en: Testing Go programs
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试Go程序
- en: Code testing is an integral part of any production software development process.
    Good test coverage improves application reliability and increases tolerance to
    bugs introduced at later stages of software development. Go has native support
    for testing with its `testing` package from the standard library and built-in
    command-line tool, `go test`. With test coverage built into the Go tool, it’s
    uncommon to see third-party packages used for testing Go code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码测试是任何生产软件开发过程中的一个重要部分。良好的测试覆盖率可以提高应用程序的可靠性，并增加对软件开发后期阶段引入的错误的容忍度。Go通过其标准库中的`testing`包和内置的命令行工具`go
    test`提供了对测试的原生支持。由于Go工具中内置了测试覆盖率，因此很少看到用于测试Go代码的第三方包。
- en: Table-driven testing is one of the most popular testing methodologies in Go.
    The idea is to describe test cases as a slice of custom data structures, with
    each one providing both inputs and expected results for each test case. Writing
    test cases as a table makes it easier to create new scenarios, consider corner
    cases, and interpret existing code behaviors.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表格驱动测试是Go中最受欢迎的测试方法之一。其思想是将测试用例描述为自定义数据结构的切片，每个提供每个测试用例的输入和预期结果。将测试用例编写为表格使得创建新场景、考虑边界情况以及解释现有代码行为变得更加容易。
- en: We can test part of the code of the `top-talkers` example we just reviewed by
    building a set of table tests for the heap implementation we used to sort the
    flow records.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过构建一组针对我们用于排序流记录的堆实现表格测试，来测试我们刚刚审查的`top-talkers`示例代码的一部分。
- en: 'Let’s create a test file, `main_test.go`, with a single test function in it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含单个测试函数的测试文件，`main_test.go`：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Both the `_test.go` filename suffix and the `Test<Name>` function prefix are
    naming conventions that allow Go to detect testing code and exclude it during
    binary compilation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`_test.go`文件名后缀和`Test<Name>`函数前缀都是命名约定，允许Go检测测试代码并在二进制编译期间排除它。'
- en: 'We design each test case to have all the relevant information, including the
    following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计每个测试用例都包含所有相关信息，包括以下内容：
- en: A name to use in error messages
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于错误消息的名称：
- en: 'A set of unique flows described by their starting counters and resulting positions:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组由它们的起始计数和结果位置描述的唯一流：
- en: '[PRE28]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Given the preceding definitions, we create a test suite for a different combination
    of input and output values to cover as many non-repeating scenarios as possible:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的定义，我们创建一个针对不同输入和输出值组合的测试套件，以尽可能覆盖尽可能多的非重复场景：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We tie all this together in the body of the `TestHeap` function, where we iterate
    over all test cases. For each test case, we set up its preconditions, push all
    flows on the heap, and update their count `timeSeen` number of times:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`TestHeap`函数的主体中将所有这些内容结合起来，在这个函数中，我们遍历所有测试用例。对于每个测试用例，我们设置其前提条件，将所有流推入堆中，并更新它们的`timeSeen`计数次数：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once we have updated all flows, we remove them off the heap, one by one, based
    on the highest count, and check whether the resulting position and count match
    what we had described in the test case. In case of a mismatch, we generate an
    error message using the `*testing.T` type injected by the testing package:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更新了所有流，我们就根据最高的计数，逐个从堆中移除它们，并检查结果位置和计数是否与我们描述的测试用例中的相符。如果出现不匹配，我们将使用测试包注入的`*testing.T`类型生成错误消息：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Thus far, we’ve only discussed data plane telemetry, which is crucial, but not
    the only element of network monitoring. In the following section, we will explore
    network control plane telemetry by building a complete end-to-end telemetry processing
    pipeline.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了数据平面遥测，这是至关重要的，但不是网络监控的唯一元素。在下一节中，我们将通过构建一个完整的端到端遥测处理管道来探索网络控制平面遥测。
- en: Measuring control plane performance
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量控制平面性能
- en: Most network engineers are familiar with tools such as `ping`, `traceroute`,
    and `iperf` to verify network data plane connectivity, reachability, and throughput.
    At the same time, control plane performance often remains a black box, and we
    can only assume how long it takes for our network to re-converge. In this section,
    we aim to address this problem by building a control plane telemetry solution.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络工程师熟悉`ping`、`traceroute`和`iperf`等工具，用于验证网络数据平面的连通性、可达性和吞吐量。同时，控制平面性能通常是一个黑盒，我们只能假设我们的网络重新收敛需要多长时间。在本节中，我们旨在通过构建控制平面遥测解决方案来解决这个问题。
- en: Modern control plane protocols, such as BGP, distribute large volumes of information
    from IP routes to MAC addresses and flow definitions. As the size of our networks
    grows, so does the churn rate of the control plane state, with users, VMs, and
    applications constantly moving between different locations and network segments.
    Hence, it’s critical to have visibility of how well our control plane performs
    to troubleshoot network issues and take any preemptive actions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现代控制平面协议，如BGP，从IP路由到MAC地址和流定义分发大量信息。随着我们网络规模的扩大，控制平面状态的变化率也在增加，用户、虚拟机和应用程序不断在不同位置和网络段之间移动。因此，了解我们的控制平面性能如何对于解决网络问题和采取任何预防措施至关重要。
- en: 'The next code example covers the telemetry processing pipeline we built to
    monitor the control plane performance of the lab network. At the heart of it,
    there is a special `bgp-ping` application that allows us to measure the round-trip
    time of a BGP update. In this solution, we take advantage of the features of the
    following Go packages and applications:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码示例涵盖了我们所构建的遥测处理管道，用于监控实验室网络的控制平面性能。其核心是一个特殊的`bgp-ping`应用程序，允许我们测量BGP更新的往返时间。在这个解决方案中，我们利用以下Go包和应用程序的功能：
- en: '`jwhited/corebgp`: A pluggable implementation of a BGP finite state machine
    that allows you to run arbitrary actions for different BGP states.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jwhited/corebgp`：一个可插入的BGP有限状态机实现，允许您为不同的BGP状态运行任意操作。'
- en: '`osrg/gobgp`: One of the most popular BGP implementations in Go; we use it
    to encode and decode BGP messages.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`osrg/gobgp`：Go中最受欢迎的BGP实现之一；我们用它来编码和解码BGP消息。'
- en: '`cloudprober/cloudprober`: A flexible distributed probing and monitoring framework.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cloudprober/cloudprober`：一个灵活的分布式探测和监控框架。'
- en: '`Prometheus` and `Grafana`: A popular monitoring and visualization software
    stack.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Prometheus`和`Grafana`：一个流行的监控和可视化软件栈。'
- en: '![Figure 10.5 – Telemetry pipeline architecture](img/B16971_10_05.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 遥测管道架构](img/B16971_10_05.jpg)'
- en: Figure 10.5 – Telemetry pipeline architecture
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 遥测管道架构
- en: 'To bring up this entire setup, you can run `make bgp-ping-start` from the root
    of this book’s GitHub repository (see *Further reading*):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动整个设置，您可以从本书GitHub仓库的根目录运行`make bgp-ping-start`（参见*进一步阅读*）：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The final line of the preceding output shows the URL that you can use to access
    the deployed instance of Grafana, using `admin` as both `username` and `password`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个输出的最后一行显示了您可以使用它来访问部署的Grafana实例的URL，其中`username`和`password`都使用`admin`：
- en: '![Figure 10.6 – BGP ping dashboard](img/B16971_10_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – BGP ping仪表板](img/B16971_10_06.jpg)'
- en: Figure 10.6 – BGP ping dashboard
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – BGP ping仪表板
- en: This instance has a pre-created dashboard called `BGP-Ping` that plots the graph
    of BGP round-trip times in milliseconds.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此实例有一个预先创建的名为`BGP-Ping`的仪表板，该仪表板绘制了BGP往返时间的图表（以毫秒为单位）。
- en: It’s important to note that there’s a lot more to routing protocol convergence
    and performance than the update propagation time. Other important factors may
    include update churn due to transient events or **Forwarding Information Base**
    (**FIB)** programming time. We focus on a single-dimension metric in this example,
    but in reality, you may want to consider other performance metrics as well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，路由协议收敛和性能的问题远不止更新传播时间。其他重要因素可能包括由于暂时性事件引起的更新 churn 或 **转发信息库**（**FIB**）编程时间。在这个例子中，我们关注单一维度的指标，但在现实中，您可能还想考虑其他性能指标。
- en: Measuring BGP Update propagation time
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量BGP更新传播时间
- en: As the standard `ping`, the `bgp-ping` application works by sending and receiving
    probe messages. A sender embeds a probe in a BGP Update message and sends it to
    its BGP neighbor. We encode the probe as a custom BGP optional transitive attribute,
    which allows it to propagate transparently throughout the network until it reaches
    one of the `bgp-ping` responders.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准的`ping`类似，`bgp-ping`应用程序通过发送和接收探测消息工作。发送者将探测嵌入BGP更新消息并发送给其BGP邻居。我们将探测编码为自定义的BGP可选传递属性，这使得它可以在整个网络中透明地传播，直到它到达`bgp-ping`响应者之一。
- en: A `bgp-ping` responder recognizes this custom transitive attribute and reflects
    it back to the sender. This gives the sender a measure of BGP Update propagation
    delay within the network, which is then reported to an external metric consumer
    or printed on a screen.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`bgp-ping`响应者识别这个自定义传递属性并将其反射回发送者。这给发送者提供了一个度量网络中BGP更新传播延迟的量，然后将其报告给外部度量消费者或打印在屏幕上。'
- en: 'Since the `bgp-ping` application needs to inter-operate with real BGP stacks,
    at the very least it has to implement the initial exchange of `Open` messages
    to negotiate the BGP session capabilities, followed by the periodic exchange of
    `Keepalive` messages. We also need to do the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`bgp-ping`应用程序需要与真实的BGP堆栈进行互操作，至少它必须实现`Open`消息的初始交换来协商BGP会话功能，然后是周期性的`Keepalive`消息交换。我们还需要做以下事情：
- en: Send BGP Update messages triggered by different events.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由不同事件触发的发送BGP更新消息。
- en: Encode and decode custom BGP attributes.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码和解码自定义BGP属性。
- en: Let’s see how we can implement these requirements using open source Go packages
    and applications.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用开源Go包和应用程序来实现这些要求。
- en: Event-driven BGP state machine
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件驱动的BGP状态机
- en: We use CoreBGP (`jwhited/corebgp`) to establish a BGP session with a peer and
    keep it alive until it’s shut down. This gets us the `Open` and `Keepalive` messages
    we just discussed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用CoreBGP (`jwhited/corebgp`) 与对等体建立BGP会话，并保持其活跃状态直到关闭。这为我们提供了刚刚讨论的`Open`和`Keepalive`消息。
- en: Inspired by the popular DNS server CoreDNS, CoreBGP is a minimalistic BGP server
    that you can extend through event-driven plugins.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 受到流行的DNS服务器CoreDNS的启发，CoreBGP是一个可以通过事件驱动插件扩展的最小化BGP服务器。
- en: 'In practice, you extend the initial capabilities by building a custom implementation
    of the `Plugin` interface. This interface defines different methods that can implement
    user-defined behavior at certain points of the BGP **finite state** **machine**
    (**FSM**):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你通过构建自定义的`Plugin`接口实现来扩展初始功能。该接口定义了可以在BGP **有限状态机**（**FSM**）的某些点上实现用户定义行为的不同方法：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the `bpg-ping` application, we only need to send and receive BGP Update
    messages, so we focus on implementing the following two methods:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`bpg-ping`应用程序，我们只需要发送和接收BGP更新消息，因此我们专注于实现以下两种方法：
- en: '`OnEstablished`: To send BGP Update messages.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnEstablished`：发送BGP更新消息。'
- en: '`handleUpdate`: We use this to process received updates, identify ping requests,
    and send a response message.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleUpdate`：我们使用这个函数来处理接收到的更新，识别ping请求，并发送响应消息。'
- en: 'The following diagram shows the main functional blocks of this application:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了该应用程序的主要功能模块：
- en: '![Figure 10.7 – BGP Ping Design](img/B16971_10_07.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – BGP Ping设计](img/B16971_10_07.jpg)'
- en: Figure 10.7 – BGP Ping Design
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – BGP Ping设计
- en: 'Let’s start the code overview by examining the BGP Update handling logic (`handleUpdate`).
    Since our goal is to parse and process BGP ping probes, we can make sure we discard
    any other BGP updates early in the code. For every BGP Update message we receive,
    we check whether any of the BGP attributes have the custom `bgpPingType` transitive
    attribute we created to signal the probe or ping. We silently ignore BGP updates
    that don’t have this attribute with a `continue` statement:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查BGP更新处理逻辑（`handleUpdate`）开始代码概述。由于我们的目标是解析和处理BGP ping探测，我们可以确保在代码早期就丢弃任何其他BGP更新。对于接收到的每个BGP更新消息，我们检查是否有任何BGP属性具有我们创建的用于表示探测或ping的自定义`bgpPingType`传递属性。我们使用`continue`语句静默忽略没有此属性的BGP更新：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once we have determined that it’s a BGP ping message, we deal with two possible
    scenarios:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定这是一条BGP ping消息，我们处理两种可能的情况：
- en: If it’s a `bgpPingType` path attribute.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是一个`bgpPingType`路径属性。
- en: 'If it’s a `OnEstablished` function:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是`OnEstablished`函数：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The event-driven logic to send BGP updates lives in the `OnEstablished()` method
    that has a three-way select statement to listen for triggers over Go channels,
    representing three different states of the `bgp-ping` application:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 发送 BGP 更新的事件驱动逻辑位于 `OnEstablished()` 方法中，该方法包含一个三路选择语句，用于监听 Go 通道上的触发器，代表 `bgp-ping`
    应用程序的三个不同状态：
- en: Responding to a received ping request, triggered by a request coming from the
    `handleUpdate` function
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应由来自 `handleUpdate` 函数的请求触发的 ping 请求
- en: Firing a new ping request, triggered by an external signal
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由外部信号触发的新的 ping 请求
- en: 'Sending a scheduled withdraw message at the end of the probing cycle:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在探测周期结束时发送计划中的撤回消息：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: One caveat of CoreBGP is that it doesn’t include its own BGP message parser
    or builder. It sends any raw bytes that may confuse or even crash a standard BGP
    stack, so always use it with caution.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: CoreBGP 的一个缺点是它不包含自己的 BGP 消息解析器或构建器。它发送任何可能混淆或甚至导致标准 BGP 堆栈崩溃的原始字节，因此始终要小心使用。
- en: Now, we need a way to parse and craft a BGP message, and here is where we can
    use another Go library called `GoBGP`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一种解析和构建 BGP 消息的方法，这正是我们可以使用另一个名为 `GoBGP` 的 Go 库的地方。
- en: Encoding and decoding BGP messages
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码和解码 BGP 消息
- en: GoBGP is a full-blown BGP stack and supports most of the BGP address families
    and features. However, since we already use CoreBGP for BGP state management,
    we limit the use of GoBGP to message encoding and decoding.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: GoBGP 是一个完整的 BGP 堆栈，支持大多数 BGP 地址族和功能。然而，由于我们已经在使用 CoreBGP 进行 BGP 状态管理，所以我们限制
    GoBGP 的使用仅限于消息编码和解码。
- en: 'For example, whenever we need to build a BGP withdraw update message, we call
    a helper function (`buildWithdraw`) that uses GoBGP to build the message. GoBGP
    allows us to include only the relevant information, such as a list of **Network
    Layer Reachability Information** (**NLRI**), while it takes care of populating
    the rest of the fields, such as type, length, and building a syntactically correct
    BGP message:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每当我们需要构建一个 BGP 撤回更新消息时，我们调用一个辅助函数（`buildWithdraw`），该函数使用 GoBGP 构建消息。GoBGP
    允许我们只包含相关信息，例如 **网络层可达性信息**（**NLRI**）列表，同时它负责填充其余字段，如类型、长度，并构建一个语法正确的 BGP 消息：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here’s another example of how to use GoBGP to parse a message received by CoreBGP.
    We take a slice of bytes and use the `ParseBGPBody` function to deserialize it
    into GoBGP’s `BGPMessage` type:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 GoBGP 解析 CoreBGP 收到的消息的另一个示例。我们取一个字节数组，并使用 `ParseBGPBody` 函数将其反序列化为 GoBGP
    的 `BGPMessage` 类型：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can now further parse this BGP message to extract various path attributes
    and NLRIs, as we’ve seen in the earlier overview of the `handleUpdate` function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以进一步解析此 BGP 消息以提取各种路径属性和 NLRIs，正如我们在 `handleUpdate` 函数的早期概述中所看到的。
- en: Collecting and exposing metrics
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集和公开指标
- en: The `bgp-ping` application can run as a standalone process and print the results
    on a screen. We also want to be able to integrate our application into more general-purpose
    system monitoring solutions. To do that, it needs to expose its measurement results
    in a standard format that an external monitoring system can understand.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`bgp-ping` 应用程序可以作为独立进程运行，并在屏幕上打印结果。我们还想能够将我们的应用程序集成到更通用的系统监控解决方案中。为此，它需要以标准格式公开其测量结果，以便外部监控系统可以理解。'
- en: You can implement this capability natively by adding a web server and publishing
    your metrics for external consumers, or you can use an existing tool that collects
    and exposes metrics on behalf of your application. One tool that does this is
    Cloudprober, which enables automated and distributed probing and monitoring, and
    offers native Go integration with several external probes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加一个网络服务器并发布您的指标以供外部消费者使用来实现此功能，或者您可以使用现有的工具来代表您的应用程序收集和公开指标。一个执行此操作的工具有
    Cloudprober，它支持自动化和分布式探测和监控，并提供与多个外部探测的原生 Go 集成。
- en: 'We integrate the `bgp-ping` application with the Cloudprober via its `serverutils`
    package, which allows you to exchange probe requests and replies over the `bgp-ping`
    with a `-c` flag, it expects all probe triggers to come from Cloudprober and sends
    its results back in a `ProbeReply` message:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `serverutils` 包将 `bgp-ping` 应用程序与 Cloudprober 集成，该包允许您通过 `-c` 标志在 `bgp-ping`
    上交换探测请求和回复，它期望所有探测触发器都来自 Cloudprober，并在 `ProbeReply` 消息中发送其结果：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The Cloudprober application itself runs as a pre-compiled binary and requires
    minimal configuration to tell it about the `bgp-ping` application and its runtime
    options:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Cloudprober 应用程序本身作为一个预编译的二进制文件运行，并且需要最少的配置来告诉它关于 `bgp-ping` 应用程序及其运行时选项的信息：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: All measurement results are automatically published by Cloudprober in a format
    that most popular cloud monitoring systems can understand.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测量结果都由 Cloudprober 自动以大多数流行的云监控系统可以理解的形式发布。
- en: Storing and visualizing metrics
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储和可视化指标
- en: The final stage in this control plane telemetry processing pipeline is metrics
    storage and visualization. Go is a very popular choice for these systems, with
    examples including Telegraf, InfluxDB, Prometheus, and Grafana.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制平面遥测处理管道的最后一个阶段是指标存储和可视化。Go 是这些系统的非常流行的选择，包括 Telegraf、InfluxDB、Prometheus
    和 Grafana。
- en: 'The current telemetry processing example includes Prometheus and Grafana with
    their respective configuration files and pre-built dashboards. The following configuration
    snippet points Prometheus at the local Cloudprober instance and tells it to scrape
    all available metrics every 10 seconds:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当前遥测处理示例包括 Prometheus 和 Grafana 及其相应的配置文件和预构建仪表板。以下配置片段将 Prometheus 指向本地 Cloudprober
    实例，并告诉它每 10 秒抓取所有可用的指标：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Although we discuss little of it here, building meaningful dashboards and alerts
    is as important as doing the measurements. Distributed systems observability is
    a big topic that is extensively covered in existing books and online resources.
    For now, we will stop at the point where we see a visual representation of the
    data in a Grafana dashboard but don’t want to imply that a continuous linear graph
    of absolute values is enough. Most likely, to make any reasonable assumptions,
    you’d want to present your data as an aggregated distribution and monitor its
    outlying values over time, as this would give a better sign of increasing system
    stress and may serve as a trigger for any further actions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里讨论的并不多，但构建有意义的仪表板和警报与进行测量一样重要。分布式系统可观察性是一个大话题，在现有的书籍和在线资源中得到了广泛覆盖。现在，我们将停止在
    Grafana 仪表板上看到数据可视化，但不想暗示绝对值的连续线性图就足够了。很可能会想，为了做出任何合理的假设，你希望以聚合分布的形式呈现你的数据，并随着时间的推移监控其异常值，因为这会更好地表明系统压力的增加，并可能作为采取任何进一步行动的触发器。
- en: Developing distributed applications
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发分布式应用程序
- en: Building a distributed application, such as `bgp-ping`, can be a major undertaking.
    Unit testing and debugging can help spot and fix a lot of bugs, but these processes
    can be time-consuming. In certain cases, when an application has different components,
    developing your code iteratively may require some manual orchestration. Steps
    such as building binary files and container images, starting the software process,
    enabling logging, and triggering events are now something you need to synchronize
    and repeat for all the components that include your application.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个分布式应用程序，例如 `bgp-ping`，可能是一项重大任务。单元测试和调试可以帮助发现和修复许多错误，但这些过程可能很耗时。在某些情况下，当应用程序有不同的组件时，迭代开发你的代码可能需要一些手动编排。例如，构建二进制文件和容器镜像、启动软件过程、启用日志记录和触发事件，现在是你需要同步和重复对所有包含你的应用程序的组件进行操作的事情。
- en: The final developer experience tool that we will cover in this chapter was specifically
    designed to address the preceding issues. Tilt helps developers automate manual
    steps, and it has native integration with container and orchestration platforms,
    such as Kubernetes or Docker Compose. You let it know which files to monitor,
    and it will automatically rebuild your binaries, swap out container images, and
    restart existing processes, all while showing you the output logs of all applications
    on a single screen.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍的最后一种开发者体验工具是专门为解决上述问题而设计的。Tilt 帮助开发者自动化手动步骤，并且它与容器和编排平台（如 Kubernetes
    或 Docker Compose）具有原生集成。你只需告诉它要监控哪些文件，它就会自动重建你的二进制文件，替换容器镜像，并重启现有进程，同时在一个屏幕上显示所有应用程序的输出日志。
- en: 'It works by reading a special `Tiltfile` containing a set of instructions on
    what to build and how to do it. Here’s a snippet from a Tiltfile that automatically
    launches a `bgp-ping` process inside one of the host containers and restarts it
    every time it detects a change to `main.go`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过读取一个包含有关构建内容和如何构建的指令的特殊 `Tiltfile` 来工作。以下是一个 `Tiltfile` 的片段，它自动在一个宿主容器内启动一个
    `bgp-ping` 进程，并在检测到 `main.go` 的更改时重启它：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The full `Tiltfile` has two more resources for the other two hosts in our lab
    network. You can bring up all three parts of the application with `sudo` `tilt
    up`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `Tiltfile` 为我们实验室网络中的另外两个主机提供了两个更多资源。你可以使用 `sudo tilt up` 启动应用程序的所有三个部分：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Tilt has both a console (text) and a web UI that you can use to view the logs
    of all resources:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Tilt 具有控制台（文本）和 Web UI，您可以使用它来查看所有资源的日志：
- en: '![Figure 10.8 – Tilt](img/B16971_10_08.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – Tilt](img/B16971_10_08.jpg)'
- en: Figure 10.8 – Tilt
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – Tilt
- en: Any change to the source code of the `bgp-ping` application would trigger a
    restart of all affected resources. By automating a lot of manual steps and aggregating
    the logs, this tool can simplify the development process of any distributed application.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `bgp-ping` 应用程序的源代码的任何更改都会触发所有受影响资源的重启。通过自动化大量手动步骤和汇总日志，这个工具可以简化任何分布式应用程序的开发过程。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This concludes the chapter about network monitoring. We have only touched upon
    a few selected subjects and admit that the topic of this chapter is too vast to
    cover in this book. However, we hope we have provided enough resources, pointers,
    and ideas for you to continue the exploration of network monitoring, as it’s one
    of the most vibrant and actively growing areas of the network engineering discipline.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关于网络监控的章节。我们只触及了几个选定的主题，并承认本章的主题过于广泛，无法在这本书中涵盖。然而，我们希望我们已经提供了足够多的资源、指南和想法，以便您继续探索网络监控，因为它是网络工程学科中最活跃和积极增长的一个领域。
- en: Further reading
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Book’s GitHub repository: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍的 GitHub 仓库：[https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go)
- en: '`google/gopacket` package: [https://github.com/google/gopacket](https://github.com/google/gopacket)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google/gopacket` 包：[https://github.com/google/gopacket](https://github.com/google/gopacket)'
- en: '`gdb` documentation: [https://go.dev/doc/gdb](https://go.dev/doc/gdb)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gdb` 文档：[https://go.dev/doc/gdb](https://go.dev/doc/gdb)'
- en: '`vscode-go`: [https://code.visualstudio.com/docs/languages/go](https://code.visualstudio.com/docs/languages/go)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vscode-go`: [https://code.visualstudio.com/docs/languages/go](https://code.visualstudio.com/docs/languages/go)'
- en: '`ch10/packet-capture/.vscode/launch.json`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch10/packet-capture/.vscode/launch.json](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch10/packet-capture/.vscode/launch.json)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch10/packet-capture/.vscode/launch.json`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch10/packet-capture/.vscode/launch.json](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch10/packet-capture/.vscode/launch.json)'
- en: 'Open source components with ready-to-use examples: [https://github.com/netsampler/goflow2/tree/main/compose/kcg](https://github.com/netsampler/goflow2/tree/main/compose/kcg)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有可使用示例的开源组件：[https://github.com/netsampler/goflow2/tree/main/compose/kcg](https://github.com/netsampler/goflow2/tree/main/compose/kcg)
- en: 'CoreBGP documentation: [https://pkg.go.dev/github.com/jwhited/corebgp#section-readme](https://pkg.go.dev/github.com/jwhited/corebgp#section-readme)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoreBGP 文档：[https://pkg.go.dev/github.com/jwhited/corebgp#section-readme](https://pkg.go.dev/github.com/jwhited/corebgp#section-readme)
