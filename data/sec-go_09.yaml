- en: Web Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序
- en: Go has a powerful HTTP package in the standard library. The `net/http` package
    is documented at [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/)
    and contains the HTTP and HTTPS utilities. At first, I advise that you stay away
    from the community HTTP frameworks and stick to the Go standard library. The standard
    HTTP package includes functions for listening, routing, and templating. The built-in
    HTTP server is of production quality, and it binds directly to a port, eliminating
    the need for a separate httpd, such as Apache, IIS, or nginx. However, it is common
    to see nginx listening on the public port `80` and reverse proxying all requests
    to Go servers listening on local ports other than `80`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go在标准库中有一个强大的HTTP包。`net/http`包的文档位于[https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/)，包含了HTTP和HTTPS的实用工具。起初，我建议你远离社区的HTTP框架，坚持使用Go标准库。标准的HTTP包包括了用于监听、路由和模板的函数。内置的HTTP服务器具有生产质量，并直接绑定到端口，消除了需要单独的httpd，如Apache、IIS或nginx。然而，通常会看到nginx监听公共端口`80`，并将所有请求反向代理到监听本地端口而不是`80`的Go服务器。
- en: In this chapter, we cover the basics of running an HTTP server, using HTTPS,
    setting secure cookies, and escaping output. We also cover how to use the Negroni
    middleware package and implement custom middleware for logging, adding secure
    HTTP headers, and serving static files. Negroni takes an idiomatic Go approach
    and encourages the use of the standard library `net/http` handlers. It is very
    lightweight and builds on top of the existing Go structures. Additionally, other
    best practices related to running a web application are mentioned.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了运行HTTP服务器的基础知识，使用HTTPS，设置安全的cookies，以及转义输出。我们还介绍了如何使用Negroni中间件包，并实现用于记录、添加安全的HTTP头和提供静态文件的自定义中间件。Negroni采用了Go的成熟方法，并鼓励使用标准库`net/http`处理程序。它非常轻量级，并建立在现有的Go结构之上。此外，还提到了与运行Web应用程序相关的其他最佳实践。
- en: HTTP client examples are also provided. Starting with making a basic HTTP request,
    we move on to making HTTPS requests and using client certificates for authentication
    and proxies for route traffic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了HTTP客户端的示例。从进行基本的HTTP请求开始，我们继续进行HTTPS请求，并使用客户端证书进行身份验证和代理路由流量。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: HTTP servers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP服务器
- en: Simple HTTP servers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的HTTP服务器
- en: TLS encrypted HTTP (HTTPS)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS加密的HTTP（HTTPS）
- en: Using secure cookies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全的cookies
- en: HTML escaping output
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML转义输出
- en: Middleware with Negroni
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Negroni中间件
- en: Logging requests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录请求
- en: Adding secure HTTP headers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加安全的HTTP头
- en: Serving static files
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: Other best practices
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他最佳实践
- en: Cross-site request forgery (CSRF) tokens
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站请求伪造（CSRF）令牌
- en: Preventing user enumeration and abuse
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止用户枚举和滥用
- en: Avoiding local and remote file inclusion vulnerabilities
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免本地和远程文件包含漏洞
- en: HTTP clients
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP客户端
- en: Making basic HTTP requests
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行基本的HTTP请求
- en: Using a client SSL certificate
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用客户端SSL证书
- en: Using proxies
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代理
- en: Using System proxy
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用系统代理
- en: Using an HTTP proxy
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP代理
- en: Using a SOCKS5 proxy (Tor)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SOCKS5代理（Tor）
- en: HTTP server
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP服务器
- en: 'HTTP is an application protocol built on top of the TCP layer. The concept
    is relatively simple; you can craft a request using plain text. In the first line,
    you will provide the method, such as `GET` or `POST`, along with the path and
    the HTTP version you are conforming to. After that, you will provide a series
    of key and value pairs to describe your request. Generally, you need to provide
    a `Host` value so that the server knows which website you are requesting. A simple
    HTTP request might look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是建立在TCP层之上的应用程序协议。概念相对简单；你可以使用纯文本来构造一个请求。在第一行，你将提供方法，比如`GET`或`POST`，以及路径和你遵循的HTTP版本。之后，你将提供一系列键值对来描述你的请求。通常，你需要提供一个`Host`值，以便服务器知道你正在请求哪个网站。一个简单的HTTP请求可能是这样的：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You don't need to worry about all of the details in the HTTP specification though.
    Go provides a `net/http` package that comes with several tools for easily creating
    production-ready web servers, including support for HTTP/2.0 with Go 1.6 and newer.
    This section covers topics related to running and securing HTTP servers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，你不需要担心HTTP规范中的所有细节。Go提供了一个`net/http`包，其中包含了几个工具，可以轻松地创建生产就绪的Web服务器，包括对HTTP/2.0的支持，Go
    1.6及更新版本。本节涵盖了与运行和保护HTTP服务器相关的主题。
- en: Simple HTTP servers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的HTTP服务器
- en: 'In this example, an HTTP server demonstrates how simple it is to create a listening
    server with the standard library. There is no routing or multiplexing yet. In
    this case, a specific directory is served through the server. `http.FileServer()`
    has directory listing built in, so if you make an HTTP request to `/`, then it
    will list the files available in the directory being served:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个HTTP服务器演示了使用标准库创建一个监听服务器是多么简单。目前还没有路由或多路复用。在这种情况下，通过服务器提供了一个特定的目录。`http.FileServer()`内置了目录列表，所以如果你对`/`发出HTTP请求，它将列出目录中可用的文件：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This next example shows how to route a path and create a function to handle
    incoming requests. This one won''t accept any command-line arguments, because
    it''s not quite a useful program on its own, but you can use this as a basic template:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例显示了如何路由路径并创建一个处理传入请求的函数。这个示例不接受任何命令行参数，因为它本身并不是一个很有用的程序，但你可以将其用作基本模板：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: HTTP basic auth
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP基本认证
- en: 'HTTP basic auth works by taking the username and password, combining them with
    a colon separator, and encoding them using base64\. The username and password
    can commonly be passed as part of the URL, for example: `http://<username>:<password>@www.example.com`.
    Under the hood, what happens though is that the username and password are combined,
    encoded, and passed as an HTTP header.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP基本认证通过取用户名和密码，用冒号分隔符组合它们，并使用base64进行编码来实现。用户名和密码通常可以作为URL的一部分传递，例如：`http://<username>:<password>@www.example.com`。在底层，实际发生的是用户名和密码被组合、编码，并作为HTTP头传递。
- en: If you use this method of authentication, keep in mind that it is not encrypted.
    There is no protection for the username and password in transit. You always want
    to use encryption on the transport layer, which means adding TLS/SSL.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用这种身份验证方法，请记住它是不加密的。在传输过程中，用户名和密码没有任何保护。您始终希望在传输层上使用加密，这意味着添加TLS/SSL。
- en: HTTP basic auth is not widely used these days, but it is easy to implement.
    A more common approach is to build or use your own authentication layer in your
    application, such as comparing a username and a password to a user database full
    of salted and hashed passwords.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，HTTP基本身份验证并不常用，但它很容易实现。更常见的方法是在应用程序中构建或使用自己的身份验证层，例如将用户名和密码与一个充满了盐和哈希密码的用户数据库进行比较。
- en: Refer to [Chapter 8](7b009a9c-c906-4919-ae73-07b807521f0c.xhtml), *Brute Force*,
    for an example of creating a client and connecting to an HTTP server that requires
    HTTP basic authentication. The Go standard library provides only a method for
    HTTP basic auth as a client. It does not provide a method for checking basic auth
    on the server side.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有关创建需要HTTP基本身份验证的HTTP服务器的客户端示例，请参阅[第8章](7b009a9c-c906-4919-ae73-07b807521f0c.xhtml)
    *暴力破解*。Go标准库仅提供了HTTP基本身份验证的客户端方法。它不提供服务器端检查基本身份验证的方法。
- en: I would not recommend that you implement HTTP basic auth on a server any more.
    If you need to authenticate a client, use TLS certificates.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议您在服务器上实现HTTP基本身份验证。如果需要对客户端进行身份验证，请使用TLS证书。
- en: Using HTTPS
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTPS
- en: In [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml), *Cryptography*,
    we walked you through the steps necessary to generate keys and then create your
    own self-signed certificate. We also gave you an example of how to run a TCP socket-level
    TLS server. This section will demonstrate how to create a TLS-encrypted HTTP server
    or an HTTPS server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml) *密码学*中，我们向您介绍了生成密钥并创建自签名证书所需的步骤。我们还为您提供了如何运行TCP套接字级别的TLS服务器的示例。本节将演示如何创建一个TLS加密的HTTP服务器或HTTPS服务器。
- en: TLS is the newer version of SSL, and Go has a standard package that supports
    it well. You need a private key and the signed certificate generated with that
    key. You can use a self-signed certificate or one signed by a recognized certificate
    authority. Historically, SSL certs signed by a trusted authority always cost money,
    but [https://letsencrypt.org/](https://letsencrypt.org/) changed the game when
    they began offering free and automated certificates signed by a widely trusted
    authority.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: TLS是SSL的更新版本，Go有一个很好地支持它的标准包。您需要一个使用该密钥生成的私钥和签名证书。您可以使用自签名证书或由公认的证书颁发机构签名的证书。从历史上看，由受信任的机构签名的SSL证书总是需要花钱的，但[https://letsencrypt.org/](https://letsencrypt.org/)改变了这一局面，他们开始提供由广泛信任的机构签名的免费和自动化证书。
- en: If you need a certificate (`cert.pem`) for this example, refer to [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*, for an example of creating your own self-signed certificate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一个证书（`cert.pem`）的示例，请参考[第6章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml)
    *密码学*中的创建自签名证书的示例。
- en: 'The following code demonstrates the most basic example of how to run an HTTPS
    server that serves a single web page. Refer to the examples in [Chapter 10](1b5ddb7b-00f9-47df-947c-e4d0ebeb94e5.xhtml), *Web
    Scraping* for various HTTP honeypot examples and more HTTP server reference code.
    After initializing the HTTPS server in the source code, you can work with it the
    same way you work with the HTTP server object. Notice that the only difference
    between this and the HTTP server is that you call `http.ListenAndServeTLS()` instead
    of `http.ListenAndServe()`. Additionally, you must provide the certificate and
    key for the server:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何运行一个提供单个网页的HTTPS服务器的最基本示例。有关各种HTTP蜜罐示例和更多HTTP服务器参考代码，请参考[第10章](1b5ddb7b-00f9-47df-947c-e4d0ebeb94e5.xhtml)
    *网络爬虫*中的示例。在源代码中初始化HTTPS服务器后，您可以像处理HTTP服务器对象一样处理它。请注意，这与HTTP服务器之间的唯一区别是您需要调用`http.ListenAndServeTLS()`而不是`http.ListenAndServe()`。此外，您必须为服务器提供证书和密钥：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating secure cookies
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建安全cookie
- en: Cookies themselves shouldn't ever contain sensitive information that the user
    should not be able to see. Attackers can target cookies to try and gather private
    information. The most common target is the session cookie. If the session cookie
    is compromised, an attacker can use the cookie to impersonate the user, and the
    server would allow it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies本身不应包含用户无法查看的敏感信息。攻击者可以针对cookie进行攻击，试图收集私人信息。最常见的目标是会话cookie。如果会话cookie受到损害，攻击者可以使用该cookie冒充用户，服务器将允许这种行为。
- en: The `HttpOnly` flag asks the browser to prevent JavaScript from accessing the
    cookie, protecting against cross-site scripting attacks. The cookie will only
    get sent when making HTTP requests. If you do need a cookie to be accessed via
    JavaScript, just create a different cookie from the session cookie.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpOnly`标志要求浏览器阻止JavaScript访问cookie，以防止跨站脚本攻击。只有在进行HTTP请求时才会发送cookie。如果确实需要通过JavaScript访问cookie，只需创建一个与会话cookie不同的cookie。'
- en: The `Secure` flag asks the browser to only transport the cookie with TLS/SSL
    encryption. This protects against session **sidejacking** attempts commonly done
    by sniffing a public unencrypted Wi-Fi network or a man-in-the-middle connection.
    Some websites will only put SSL on the login page to protect your password, but
    every connection after that is done in plain HTTP, and the session cookie can
    be stolen off the wire or, potentially, with JavaScript if the `HttpOnly` flag
    is missing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Secure`标志要求浏览器仅在TLS/SSL加密下传输cookie。这可以防止通过嗅探公共未加密的Wi-Fi网络或中间人连接进行的会话劫持尝试。一些网站只会在登录页面上使用SSL来保护您的密码，但之后的每次连接都是通过普通HTTP进行的，会话cookie可以在传输过程中被窃取，或者在缺少`HttpOnly`标志的情况下，可能会被JavaScript窃取。'
- en: When creating a session token, make sure that it is generated using a cryptographically
    secure pseudo-random number generator. Session tokens should be at a minimum of
    128 bits. Refer to [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml), *Cryptography*,
    for examples of generating secure random bytes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建会话令牌时，请确保使用加密安全的伪随机数生成器生成它。会话令牌的长度应至少为128位。请参阅[第6章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml)，*密码学*，了解生成安全随机字节的示例。
- en: 'The following example creates a simple HTTP server that has only one function,
    the `indexHandler()`. The function creates a cookie with the recommended security
    settings, and then calls `http.SetCookie()` before printing the body of the response
    and returning:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个简单的HTTP服务器，只有一个函数`indexHandler()`。该函数使用推荐的安全设置创建一个cookie，然后在打印响应正文并返回之前调用`http.SetCookie()`：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: HTML escaping output
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML转义输出
- en: Go has a standard function to escape a string and prevent HTML characters from
    getting rendered.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言有一个标准函数用于转义字符串，防止HTML字符被渲染。
- en: 'When outputting any data received by the user to the response output, always
    escape it to prevent cross-site scripting attacks. This applies equally whether
    the user-supplied data comes from a URL query, a POST value, the user-agent header,
    a form, a cookie, or the database. The following snippet gives an example of escaping
    a string:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出用户接收到的任何数据到响应输出时，始终对其进行转义，以防止跨站脚本攻击。无论用户提供的数据来自URL查询、POST值、用户代理标头、表单、cookie还是数据库，都适用这一规则。以下代码片段给出了转义字符串的示例：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Middleware with Negroni
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Negroni中间件
- en: Middleware is the term for functions that can be tied to the request/response
    flow and take action or make modification before passing it on to the next middleware
    and ultimately back to the client.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是指可以绑定到请求/响应流程并在传递给下一个中间件并最终返回给客户端之前采取行动或进行修改的函数。
- en: Middleware is a series of functions run in order on each request. You can add
    more functions to this chain. We will take a look at some practical examples,
    such as blacklisting IP addresses, adding logging, and adding authorization checks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是按顺序在每个请求上运行的一系列函数。您可以向此链中添加更多函数。我们将看一些实际的例子，比如列入黑名单的IP地址、添加日志记录和添加授权检查。
- en: The order of middleware is important. For example, we may want to put the logging
    middleware first, and then the IP blacklisting middleware. We would want the IP
    blacklist module to run first, or at least near the beginning, so that other middlewares
    don't waste resources processing a request that will just be rejected anyway.
    You can manipulate the request and response before passing it on to the next middleware
    handler.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的顺序很重要。例如，我们可能希望先放日志记录中间件，然后是IP黑名单中间件。我们希望IP黑名单模块首先运行，或者至少在开始附近运行，这样其他中间件不会浪费资源处理一个将被拒绝的请求。您可以在将请求和响应传递给下一个中间件处理程序之前操纵它们。
- en: You may want to also build custom middleware for analytics, logging, blacklisting
    IP addresses, injecting headers, or rejecting certain user agents, such as `curl`,
    `python`, or `go`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想构建自定义中间件来进行分析、日志记录、列入黑名单的IP地址、注入标头，或拒绝某些用户代理，比如`curl`、`python`或`go`。
- en: 'These examples use the Negroni package. Before compiling and running these
    examples, you need to `go get` the package. The examples call `http.ListenAndServe()`,
    but you can just as easily modify them to use TLS with `http.ListenAndServeTLS()`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例使用了Negroni包。在编译和运行这些示例之前，您需要`go get`该包。这些示例调用了`http.ListenAndServe()`，但您也可以很容易地修改它们以使用`http.ListenAndServeTLS()`来使用TLS：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following example creates a `customMiddlewareHandler()` function, which
    we will tell the `negroniHandler` interface to use. The custom middleware simply
    logs the incoming request URL and user agent, but you can do whatever you like,
    including modifying the request before it goes back to the client:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个`customMiddlewareHandler()`函数，我们将告诉`negroniHandler`接口使用它。自定义中间件只是简单地记录传入的请求URL和用户代理，但您可以做任何您喜欢的事情，包括修改请求再返回给客户端：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Logging requests
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录请求
- en: 'Because logging is such a common task, Negroni comes with a logger middleware
    that you can use, as demonstrated in the following example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志记录是如此常见的任务，Negroni附带了一个日志记录中间件，您可以使用，如下例所示：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding secure HTTP headers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加安全的HTTP标头
- en: Taking advantage of the Negroni package, we can easily create our own middleware
    to inject a set of HTTP headers to help improve security. You will need to evaluate
    each header to see whether it makes sense for your application. In addition, not
    every browser supports every one of these headers. This is a good baseline to
    begin with and modify to suit your needs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Negroni包，我们可以轻松地创建自己的中间件来注入一组HTTP标头，以帮助提高安全性。您需要评估每个标头，看看它是否适合您的应用程序。此外，并非每个浏览器都支持这些标头中的每一个。这是一个很好的基线，可以根据需要进行修改。
- en: 'The following headers are used in this example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中使用了以下标头：
- en: '| **Header** | **Description** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **标头** | **描述** |'
- en: '| `Content-Security-Policy` | This defines what scripts or remote hosts are
    trusted and able to provide executable JavaScript |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `Content-Security-Policy` | 这定义了哪些脚本或远程主机是受信任的，并能够提供可执行的JavaScript |'
- en: '| `X-Frame-Options` | This defines whether or not frames and iframes can be
    used and which domains are allowed to appear in frames |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `X-Frame-Options` | 这定义了是否可以使用框架和iframe，以及允许出现在框架中的域 |'
- en: '| `X-XSS-Protection` | This tells the browser to stop loading if a cross-site
    scripting attack is detected; it is largely unnecessary if a good `Content-Security-Policy`
    header is defined |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `X-XSS-Protection` | 这告诉浏览器在检测到跨站脚本攻击时停止加载；如果定义了良好的`Content-Security-Policy`标头，则基本上是不必要的
    |'
- en: '| `Strict-Transport-Security` | This tells the browser to use only HTTPS and
    not HTTP |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `Strict-Transport-Security` | 这告诉浏览器只使用HTTPS，而不是HTTP |'
- en: '| `X-Content-Type-Options` | This tells the browser to use the MIME type provided
    by the server, and not to modify based upon guesses by MIME sniffing |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `X-Content-Type-Options` | 这告诉浏览器使用服务器提供的MIME类型，而不是基于MIME嗅探的猜测进行修改 |'
- en: It is ultimately up to the client's web browser whether or not these headers
    are used or ignored. They do not guarantee any security without a browser that
    knows how to apply the header values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的网络浏览器最终决定是否使用或忽略这些标头。如果浏览器不知道如何应用标头值，它们就无法保证任何安全性。
- en: 'This example creates a function named `addSecureHeaders()`, which is used as
    an additional middleware handler to modify the response before it goes back to
    the client. Tweak the headers as needed for your application:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子创建了一个名为`addSecureHeaders()`的函数，它被用作额外的中间件处理程序，以在返回给客户端之前修改响应。根据你的应用程序需要调整标头：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Serving static files
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: 'Another common web server task is to serve static files. It is worth mentioning
    the Negroni middleware handler for serving static files. Just add an additional
    `Use()` call and pass `negroni.NewStatic()` to it. Make sure that your static
    files directory contains only files that clients should access. In most cases,
    the static files directory contains CSS and JavaScript files for the client. Do
    not put database backups, configuration files, SSH keys, Git repositories, development
    files, or anything a client shouldn''t have access to. Add the static-file middleware
    like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的Web服务器任务是提供静态文件。值得一提的是Negroni中间件处理程序用于提供静态文件。只需添加一个额外的`Use()`调用，并将`negroni.NewStatic()`传递给它。确保你的静态文件目录只包含客户端应该访问的文件。在大多数情况下，静态文件目录包含客户端的CSS和JavaScript文件。不要放置数据库备份、配置文件、SSH密钥、Git存储库、开发文件或任何客户端不应该访问的内容。像这样添加静态文件中间件：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Other best practices
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他最佳实践
- en: There are a few other things worth considering when creating a web application.
    Although they are not Go specific, it is worth taking these best practices into
    account when developing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Web应用程序时，还有一些其他值得考虑的事项。虽然它们不是Go特有的，但在开发时考虑这些最佳实践是值得的。
- en: CSRF tokens
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRF令牌
- en: '**Cross-Site Request Forgery**, or **CSRF**, tokens are a way of trying to
    prevent one website from taking action on your behalf against a different website.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**，或**CSRF**，令牌是一种试图阻止一个网站代表你对另一个网站采取行动的方式。'
- en: CSRF is a common attack where a victim will visit a website with malicious code
    embedded that tries to make a request to a different site. For example, a malicious
    actor embeds JavaScript that makes a POST request to every bank website attempting
    to transfer $1,000 to the attacker's bank account. If the victim has an active
    session with one of those banks, and the bank does not implement CSRF tokens,
    the bank's website may accept the request and process it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF是一种常见的攻击方式，受害者会访问一个嵌入了恶意代码的网站，试图向不同的网站发出请求。例如，一个恶意的行为者嵌入了JavaScript，试图向每个银行网站发出POST请求，尝试将1000美元转账到攻击者的银行账户。如果受害者在其中一个银行有活动会话，并且该银行没有实施CSRF令牌，那么银行的网站可能会接受并处理该请求。
- en: It is possible to be the victim of a CSRF attack even on a trusted site, if
    the trusted site is vulnerable to either reflective or stored cross-site scripting.
    CSRF has been on the *OWASP Top 10* since 2007 and remains there in 2017.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在受信任的网站上，也有可能成为CSRF攻击的受害者，如果受信任的网站容易受到反射或存储型跨站脚本攻击。自2007年以来，CSRF一直是*OWASP十大*中的一部分，并且在2017年仍然如此。
- en: Go provides a `xsrftoken` package that you can read more about at [https://godoc.org/golang.org/x/net/xsrftoken](https://godoc.org/golang.org/x/net/xsrftoken).
    It provides a `Generate()` function to create tokens and a `Valid()` function
    to validate tokens. You can use their implementation of choose to develop your
    own to suit your needs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个`xsrftoken`包，你可以在[https://godoc.org/golang.org/x/net/xsrftoken](https://godoc.org/golang.org/x/net/xsrftoken)上了解更多信息。它提供了一个`Generate()`函数来创建令牌，以及一个`Valid()`函数来验证令牌。你可以使用他们的实现，也可以选择开发适合自己需求的实现。
- en: To implement CSRF tokens, create a 16-byte random token and store it on the
    server associated to the user's session. You can use whatever backend you like
    to store the token, whether that is in memory, in a database, or in a file. Embed
    the CSRF token in the form as a hidden field. When processing the form on the
    server side, verify that the CSRF token is present and matches the user. Destroy
    the token after it is used. Do not reuse the same token.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现CSRF令牌，创建一个16字节的随机令牌，并将其存储在与用户会话关联的服务器上。你可以使用任何你喜欢的后端来存储令牌，无论是在内存中、数据库中还是在文件中。将CSRF令牌嵌入表单作为隐藏字段。在服务器端处理表单时，验证CSRF令牌是否存在并与用户匹配。在使用后销毁令牌。不要重复使用相同的令牌。
- en: 'The various requirements for implementing CSRF tokens have been covered in
    the previous sections:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中已经介绍了实现CSRF令牌的各种要求：
- en: 'Generating a token: In [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*, a section titled *Cryptographically secure pseudo-random number
    generator (CSPRNG)* provides an example of generating random numbers, strings,
    and bytes.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成令牌：在[第6章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml)中，*密码学*，名为*密码学安全伪随机数生成器（CSPRNG）*的部分提供了生成随机数、字符串和字节的示例。
- en: 'Creating, serving, and processing an HTML form: In [Chapter 9](f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml),
    *Web Applications*, the section titled *HTTP server* provides information on creating
    a secure web server, and [Chapter 12](ae593b94-6855-4154-be69-5e21d78daced.xhtml),
    *Social Engineering*, has a section titled *HTTP POST form login honeypot* has
    an example of processing a POST request.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、提供和处理HTML表单：在[第9章](f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml)中，*Web应用程序*，名为*HTTP服务器*的部分提供了创建安全Web服务器的信息，而[第12章](ae593b94-6855-4154-be69-5e21d78daced.xhtml)，*社会工程*，有一个名为*HTTP
    POST表单登录蜜罐*的部分，其中有一个处理POST请求的示例。
- en: 'Storing a token in a file: In [Chapter 3](88c1b677-61eb-4955-9fb9-7650ab33e7c8.xhtml),
    *Working with Files*, the section titled *Write bytes to a file* provides an example
    of storing data in a file.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将令牌存储在文件中：在[第3章](88c1b677-61eb-4955-9fb9-7650ab33e7c8.xhtml)中，*文件操作*，名为*将字节写入文件*的部分提供了将数据存储在文件中的示例。
- en: 'Storing a token in a database: In [Chapter 8](7b009a9c-c906-4919-ae73-07b807521f0c.xhtml),
    *Brute Force*, the section titled *Brute force database login* provides a blueprint
    for connecting to various database types.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库中存储令牌：在[第8章](7b009a9c-c906-4919-ae73-07b807521f0c.xhtml)中，*暴力破解*，标题为*暴力破解数据库登录*的部分提供了连接到各种数据库类型的蓝图。
- en: Preventing user enumeration and abuse
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止用户枚举和滥用
- en: 'The important things to remember here are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要记住的重要事项如下：
- en: Don't let people figure out who has an account
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要让人们弄清楚谁有帐户
- en: Don't let someone spam your users with your email server
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要让某人通过您的电子邮件服务器向用户发送垃圾邮件
- en: Don't allow people to figure out who is registered by brute force attempts
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要让人们通过暴力尝试弄清楚谁已注册
- en: Let's elaborate on the practical examples.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细说明一下实际例子。
- en: Registration
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册
- en: When someone attempts to register an email address, do not give the web client
    user any feedback about whether or not the account is registered. Instead, send
    an email to the address and simply give the web user a message saying, "An email
    has been sent to the address provided."
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人尝试注册电子邮件地址时，不要向Web客户端用户提供有关帐户是否已注册的任何反馈。相反，向该地址发送一封电子邮件，并简单地向Web用户显示一条消息，内容是“已向提供的地址发送了一封电子邮件”。
- en: If they have never registered, everything is normal. If they are already registered,
    the web user does not get informed that the email is already registered. Instead,
    an email is sent to the user's address informing them that the email is already
    registered. This will remind them they have an account already and they can use
    the password reset tool, or let them know something is suspicious and someone
    may be doing something malicious.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们从未注册过，一切都是正常的。如果他们已经注册，网页用户不会收到电子邮件已注册的通知。相反，将向用户的地址发送一封电子邮件，通知他们该电子邮件已经注册。这将提醒他们已经有一个帐户，他们可以使用密码重置工具，或者让他们知道有可疑的情况，可能有人在做一些恶意的事情。
- en: Be careful that you do not allow an attacker to repeatedly attempt the login
    process and generate mass amounts of email to your real user.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心，不要让攻击者反复尝试登录过程并向真实用户的电子邮件发送大量邮件。
- en: Login
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: Do not give the web user feedback about whether or not an email exists. You
    do not want someone to be able to try logging in with an email address and learn
    whether or not that address has an account just by the error message returned.
    For example, an attack could attempt to log in using a list of email addresses,
    and if the web server returns, "That password does not match," for some emails
    and "That email is not registered," for other emails, they can determine which
    emails are registered with your service.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不要向网页用户提供关于电子邮件是否存在的反馈。您不希望某人能够尝试使用电子邮件地址登录并通过返回的错误消息了解该地址是否有帐户。例如，攻击者可以尝试使用一系列电子邮件地址登录，如果Web服务器对某些电子邮件返回“密码不匹配”，对其他电子邮件返回“该电子邮件未注册”，他们可以确定哪些电子邮件已在您的服务中注册。
- en: Resetting the password
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置密码
- en: Avoid allowing email spam. Rate limit the emails sent so that an attacker cannot
    spam your users by submitting the forgot password form multiple times.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 避免允许电子邮件垃圾邮件。限制发送的电子邮件数量，以便攻击者无法通过多次提交忘记密码表单来向用户发送垃圾邮件。
- en: When creating a reset token, ensure that it has good entropy so that it can't
    be guessed. Don't just create a token based on the time and the user ID because
    that can be guessed and brute forced too easily, as it lacks enough entropy. You
    should use at least 16-32 random bytes for a token to have decent entropy. Refer
    to [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml), *Cryptography*, for
    examples of generating cryptographically secure random bytes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建重置令牌时，请确保它具有良好的熵，以便无法猜测。不要仅基于时间和用户ID创建令牌，因为这样太容易被猜测和暴力破解，熵不足。对于令牌，您应该使用至少16-32个随机字节以获得足够的熵。参考[第6章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml)，*密码学*，了解生成密码学安全随机字节的示例。
- en: Also, set the token to expire after a short period. Anywhere from one hour to
    one day are good options depending on your application. Only allow one reset token
    at a time, and destroy a token after it is used so that it cannot be replayed
    and used again.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将令牌设置为在短时间后过期。从一小时到一天不等的时间段都是不错的选择，这取决于您的应用程序。一次只允许一个重置令牌，并在使用后销毁令牌，以防止重放和再次使用。
- en: User profiles
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户配置文件
- en: Similar to the login page, if you have user profile pages, be careful about
    allowing username enumeration. For example, if someone visits `/users/JohnDoe`
    and then `/users/JaneDoe`, and one returns a `404 Not Found` error, while the
    other returns an `401 Access Denied` error, the attacker can infer that one account
    actually exists and the other does not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与登录页面类似，如果您有用户配置文件页面，请小心允许用户名枚举。例如，如果有人访问`/users/JohnDoe`，然后访问`/users/JaneDoe`，一个返回`404
    Not Found`错误，另一个返回`401 Access Denied`错误，攻击者可以推断一个帐户实际上存在，而另一个不存在。
- en: Preventing LFI and RFI abuse
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止LFI和RFI滥用
- en: '**Local File Inclusion** (**LFI**) and **Remote File Inclusion** (**RFI**)
    are other *OWASP Top 10* vulnerabilities. They refer to the danger of loading
    files from the local file system or a remote host that were not intended to be
    loaded, or loading the intended files but with contaminated data. Remote file
    includes are dangerous because a user may supply a remote file from a malicious
    server if precaution is not taken.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地文件包含**（**LFI**）和**远程文件包含**（**RFI**）是*OWASP十大*漏洞之一。它们指的是从本地文件系统或远程主机加载未经意的文件的危险，或者加载预期的文件但带有污染数据。远程文件包含是危险的，因为如果不采取预防措施，用户可能会从恶意服务器提供远程文件。'
- en: 'Do not open a file from the local file system if the filename is specified
    by the user without any sanitization. Consider an example where a file is returned
    by a web server upon request. The user may be able to request a file with sensitive
    system information, such as `/etc/passwd`, with a URL like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户未经任何消毒就指定了文件名，则不要从本地文件系统打开文件。考虑一个示例，Web服务器在请求时返回一个文件。用户可能能够使用这样的URL请求包含敏感系统信息的文件，例如`/etc/passwd`。
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This could be big trouble if the web server handled it like this (pseudocode):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Web服务器处理方式如下（伪代码）：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can''t simply fix it by prepending a specific directory like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能简单地通过在特定目录前面添加来修复它，就像这样：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This isn''t enough because attackers can use directory traversal to get back
    to the root of the filesystem, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不够，因为攻击者可以使用目录遍历返回到文件系统的根目录，就像这样：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Be sure to check for directory traversal attacks with any file inclusion.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 务必检查任何文件包含中的目录遍历攻击。
- en: Contaminated files
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受污染的文件
- en: If an attacker finds an LFI, or you provide a web interface to log files, you
    need to make sure that, even if the logs are contaminated, no code will execute.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者发现了LFI，或者您提供了一个用于查看日志文件的Web界面，您需要确保即使日志被污染，也不会执行任何代码。
- en: An attacker can potentially contaminate your logs and insert malicious code
    by taking some action on your service that creates a log entry. Any service that
    generates a log that is loaded or displayed must be considered.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能会通过对服务采取某些操作来污染您的日志并插入恶意代码。任何生成的日志都必须被视为已加载或显示的服务。
- en: For example, web server logs can be contaminated by making an HTTP request to
    a URL that is actually code. Your logs will have a `404 Not Found` error and log
    the URL that was requested, which is actually code. If it were a PHP server or
    another scripted language, this opens up potential code execution, but, with Go,
    the worst case would be JavaScript injection, which could still be dangerous to
    the user. Imagine a scenario where a web application has an HTTP log viewer that
    loads a log file from disk. If an attacker makes a request to `yourwebsite.com/<script>alert("test");</script>`,
    then your HTML log viewer may actually end up rendering that code, if it is not
    escaped or sanitized properly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Web服务器日志可能会通过向实际上是代码的URL发出HTTP请求而被污染。您的日志将显示`404 Not Found`错误并记录所请求的URL，实际上是代码。如果它是PHP服务器或另一种脚本语言，这将打开潜在的代码执行，但是，对于Go来说，最坏的情况将是JavaScript注入，这对用户仍然可能是危险的。想象一种情况，一个Web应用程序有一个HTTP日志查看器，它从磁盘加载日志文件。如果攻击者向`yourwebsite.com/<script>alert("test");</script>`发出请求，那么您的HTML日志查看器可能实际上会渲染该代码，如果没有适当地转义或清理。
- en: HTTP client
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP客户端
- en: Making HTTP requests is a core part of many applications these days. Go, being
    a web-friendly language, contains several tools for making HTTP requests in the
    `net/http` package.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，发出HTTP请求是许多应用程序的核心部分。作为一个友好的网络语言，Go包含了`net/http`包中用于发出HTTP请求的几个工具。
- en: The basic HTTP request
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的HTTP请求
- en: 'This example uses the `http.Get()` function from the `net/http` standard library
    package. It will read the entire response body to a variable named `body` and
    then print it to standard output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了`net/http`标准库包中的`http.Get()`函数。它将把整个响应主体读取到一个名为`body`的变量中，然后将其打印到标准输出：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the client SSL certificate
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用客户端SSL证书
- en: If a remote HTTPS server has strict authentication and requires a trusted client
    certificate, you can specify the certificate file by setting the `TLSClientConfig`
    variable in the `http.Transport` object that is used by `http.Client` to make
    the GET request.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果远程HTTPS服务器具有严格的身份验证并需要受信任的客户端证书，您可以通过在`http.Transport`对象中设置`TLSClientConfig`变量来指定证书文件，该对象由`http.Client`用于发出GET请求。
- en: 'This example makes a HTTP GET request similar to the previous example, but
    it does not use the default HTTP client provided by the `net/http` package. It
    creates a custom `http.Client` and configures it to use TLS with the client certificate.
    If you need a certificate or private key, refer to [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*, for examples of generating keys and self-signed certificates:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子发出了一个类似于上一个例子的HTTP GET请求，但它没有使用`net/http`包提供的默认HTTP客户端。它创建了一个自定义的`http.Client`并配置它以使用客户端证书的TLS。如果您需要证书或私钥，请参考[第6章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml)，“密码学”，以获取生成密钥和自签名证书的示例：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using a proxy
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理
- en: A forward proxy can be useful for many things, including viewing the HTTP traffic,
    debugging an application, reverse engineering an API, and manipulating headers,
    and it can potentially be used to increase your anonymity to the target server.
    However, be aware that many proxy servers still forward your original IP using
    an `X-Forwarded-For` header.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正向代理可以用于许多用途，包括查看HTTP流量、调试应用程序、逆向工程API、操纵标头，还可以潜在地用于增加您对目标服务器的匿名性。但是，请注意，许多代理服务器仍然使用`X-Forwarded-For`头来转发您的原始IP。
- en: You can use your environment variables to set a proxy or explicitly set a proxy
    with your request. The Go HTTP client supports HTTP, HTTPS, and SOCKS5 proxies,
    such as Tor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用环境变量设置代理，也可以在请求中明确设置代理。Go HTTP客户端支持HTTP、HTTPS和SOCKS5代理，比如Tor。
- en: Using system proxy
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用系统代理
- en: 'Go''s default HTTP client will respect the system''s HTTP(S) proxy if set through
    environment variables. Go uses the `HTTP_PROXY`, `HTTPS_PROXY` and `NO_PROXY` environment
    variables. The lowercase versions are also valid. You can set the environment
    variable before running the process or set the environment variable in Go with
    this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过环境变量设置了系统的HTTP(S)代理，Go的默认HTTP客户端将会遵守。Go使用`HTTP_PROXY`、`HTTPS_PROXY`和`NO_PROXY`环境变量。小写版本也是有效的。您可以在运行进程之前设置环境变量，或者在Go中设置环境变量：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After configuring the environment variable(s), any HTTP request made using the
    default Go HTTP client will respect the proxy settings. Read more about the default
    proxy settings at [https://golang.org/pkg/net/http/#ProxyFromEnvironment](https://golang.org/pkg/net/http/#ProxyFromEnvironment).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 配置环境变量后，使用默认的Go HTTP客户端进行的任何HTTP请求都将遵守代理设置。在[https://golang.org/pkg/net/http/#ProxyFromEnvironment](https://golang.org/pkg/net/http/#ProxyFromEnvironment)上阅读更多关于默认代理设置的信息。
- en: Using a specific HTTP proxy
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特定的HTTP代理
- en: 'To explicitly set the proxy URL, ignoring environment variables, set the `ProxyURL`
    variable in a custom `http.Transport` object that is used by `http.Client`. The
    following example creates custom `http.Transport` and specifies `proxyUrlString`.
    The example only has a placeholder value for the proxy and must be replaced with
    a valid proxy. `http.Client` is then created and configured to use the custom
    transport with the proxy:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要显式设置代理URL，忽略环境变量，请在由`http.Client`使用的自定义`http.Transport`对象中设置`ProxyURL`变量。以下示例创建了自定义`http.Transport`并指定了`proxyUrlString`。该示例仅具有代理的占位符值，必须替换为有效的代理。然后创建并配置了`http.Client`以使用带有代理的自定义传输：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using a SOCKS5 proxy (Tor)
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SOCKS5代理（Tor）
- en: Tor is an anonymity service that attempts to protect your privacy. Do not use
    Tor unless you fully understand all of the implications. Read more about Tor at
    [https://www.torproject.org](https://www.torproject.org). This example demonstrates
    how to use Tor when making a request, but this applies equally to other SOCKS5
    proxies.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Tor是一项旨在保护您隐私的匿名服务。除非您充分了解所有影响，否则不要使用Tor。在[https://www.torproject.org](https://www.torproject.org)上阅读有关Tor的更多信息。此示例演示了在进行请求时如何使用Tor，但这同样适用于其他SOCKS5代理。
- en: To use a SOCKS5 proxy, the only modification needed is with the URL string of
    the proxy. Instead of using the HTTP protocol, use the `socks5://` protocol prefix.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用SOCKS5代理，唯一需要修改的是代理的URL字符串。不要使用HTTP协议，而是使用`socks5://`协议前缀。
- en: 'The default Tor port is `9050`, or `9150` when using the Tor Browser bundle.
    The following example will perform a GET request for `check.torproject.org`, which
    will let you know if you are properly routing through the Tor network:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的Tor端口是`9050`，或者在使用Tor浏览器捆绑包时是`9150`。以下示例将执行对`check.torproject.org`的GET请求，这将让您知道是否正确地通过Tor网络进行路由：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of running a web server written in Go.
    You should now feel comfortable creating a basic HTTP and HTTPS server. Furthermore,
    you should understand the concept of middleware and know how to implement prebuilt
    and custom middleware using the Negroni package.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用Go编写Web服务器的基础知识。您现在应该可以轻松创建基本的HTTP和HTTPS服务器。此外，您应该了解中间件的概念，并知道如何使用Negroni包来实现预构建和自定义中间件。
- en: We also covered some best practices when trying to secure a web server. You
    should understand what a CSRF attack is, and how to prevent it. You should be
    able to explain local and remote file inclusion and what the risks are.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了在尝试保护Web服务器时的一些最佳实践。您应该了解CSRF攻击是什么，以及如何防止它。您应该能够解释本地和远程文件包含以及风险是什么。
- en: The web server in the standard library is of production quality, and it has
    everything you need to create a production-ready web application. There are a
    number of other frameworks for web applications, such as Gorilla, Revel, and Martini,
    but, ultimately, you will have to evaluate the features provided by each framework
    and see if they align with your project needs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的Web服务器具有生产质量，并且具有创建生产就绪Web应用程序所需的一切。还有许多其他用于Web应用程序的框架，例如Gorilla、Revel和Martini，但是，最终，您将不得不评估每个框架提供的功能，并查看它们是否符合您的项目需求。
- en: We also covered the HTTP client functions provided by the standard library.
    You should know how to make basic HTTP requests and authenticated requests using
    a client certificate. You should understand how to use an HTTP proxy when making
    requests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了标准库提供的HTTP客户端功能。您应该知道如何进行基本的HTTP请求和使用客户端证书进行身份验证的请求。您应该了解在进行请求时如何使用HTTP代理。
- en: In the next chapter, we will explore web scraping to extract information from
    HTML-formatted websites. We will start with basic techniques, such as string matching
    and regular expressions, and also explore the `goquery` package for working with
    the HTML DOM. We will also cover how to use cookies to crawl with a logged-in
    session. Fingerprinting web applications to identify frameworks is also discussed.
    We will also cover crawling the web with both the breadth-first and depth-first
    approaches.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨网络爬虫，以从HTML格式的网站中提取信息。我们将从基本技术开始，例如字符串匹配和正则表达式，并探讨用于处理HTML DOM的`goquery`包。我们还将介绍如何使用cookie在登录会话中爬取。还讨论了指纹识别Web应用程序以识别框架。我们还将介绍使用广度优先和深度优先方法爬取网络。
