- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Understanding Pipes in Inter-Process Communication
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解进程间通信中的管道
- en: Pipes are fundamental tools in **inter-process communication** (**IPC**), allowing
    for efficient data transfer between system processes. This chapter provides a
    comprehensive understanding of pipes, their functionality, and their application
    in various programming scenarios, particularly focusing on their use in Go.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是进程间通信（IPC）的基本工具，它允许系统进程之间进行高效的数据传输。本章提供了对管道的全面理解，包括其功能以及在各种编程场景中的应用，特别是它们在Go中的使用。
- en: By the end of this chapter, you will have a clear understanding of how pipes
    function in IPC, their significance in system programming, and how to effectively
    implement them in Go. The chapter aims to equip readers with the knowledge to
    utilize pipes for efficient process communication in their programming projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将清楚地了解管道在IPC中的功能，它们在系统编程中的重要性，以及如何在Go中有效地实现它们。本章旨在使读者具备利用管道在编程项目中实现高效进程通信的知识。
- en: 'In this chapter, we’re going to cover these main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What are pipes in IPC?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPC中的管道是什么？
- en: The mechanics of anonymous pipes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名管道的机制
- en: Navigating named pipes (`Mkfifo()`)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航命名管道（`Mkfifo()`）
- en: Best practices – guidelines for using pipes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践 - 使用管道的指南
- en: Developing a log processing tool
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发日志处理工具
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will use some system dependencies to execute this chapter’s examples. So,
    make sure you have these programs available:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些系统依赖来执行本章的示例。因此，请确保你有这些程序可用：
- en: '`grep`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep`'
- en: '`echo`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`echo`'
- en: What are pipes in IPC?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPC中的管道是什么？
- en: 'In system programming, we can envision a pipe as a conduit within memory designed
    for transporting data between two or more processes. This conduit adheres to the
    producer-consumer model: one process, the producer, funnels data into the pipe,
    while another, the consumer, taps into this stream to read the data. As a pivotal
    element of IPC, pipes establish a unidirectional flow of information. This setup
    ensures that data consistently moves in one direction – from the “write end” to
    the “read end” of the pipe. This mechanism allows processes to communicate in
    a streamlined and efficient manner, much like water flowing through a pipe, with
    one process smoothly passing information down the line to the next.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程中，我们可以将管道想象为内存中的管道，用于在两个或多个进程之间传输数据。这个管道遵循生产者-消费者模型：一个进程，即生产者，将数据注入管道，而另一个进程，即消费者，从这个流中读取数据。作为IPC的关键元素，管道建立了一个单向的信息流。这种设置确保数据始终朝一个方向移动
    - 从管道的“写入端”到“读取端”。这种机制允许进程以流畅和高效的方式进行通信，就像水通过管道流动一样，一个进程将信息顺利传递给下一个进程。
- en: 'Pipes are used in a variety of system-level programming tasks. The most common
    applications include the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 管道被用于各种系统级编程任务。最常见的应用包括以下：
- en: '**Command-line utilities**: Pipes are often used to connect the output of one
    command-line utility to the input of another, enabling the creation of powerful
    command chains'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行实用程序**：管道通常用于将一个命令行实用程序的输出连接到另一个实用程序的输入，从而创建强大的命令链'
- en: '**Data streaming**: When data needs to be streamed from one process to another,
    pipes offer a simple and effective solution'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据流**：当数据需要从一个进程流到另一个进程时，管道提供了一个简单而有效的解决方案'
- en: '**Inter-process data exchange**: Pipes facilitate data exchange between processes,
    essential in many multi-process applications'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程间数据交换**：管道促进了进程间的数据交换，这在许多多进程应用中是必不可少的'
- en: Why are pipes important?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道为什么重要？
- en: Pipes allow modular software creation where different processes specialize in
    specific tasks and communicate efficiently. They facilitate efficient use of system
    resources by enabling direct communication between processes without needing intermediate
    storage. Also, they provide a simple yet powerful interface for data exchange,
    making complex operations more manageable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 管道允许模块化软件创建，其中不同的进程专门从事特定任务并高效地通信。它们通过允许进程之间直接通信而不需要中间存储，从而促进了系统资源的有效利用。此外，它们提供了一个简单而强大的数据交换接口，使得复杂操作更容易管理。
- en: Since pipes are designed to allow data to move in a single direction, two pipes
    are often used for two-way communication. They operate buffering data until another
    process reads the data. This mechanism is especially useful for handling cases
    where the reader and the writer operate at different speeds.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于管道设计为允许数据单向移动，因此通常使用两个管道进行双向通信。它们在另一个进程读取数据之前对数据进行缓冲。这种机制在处理读者和作者操作速度不同的情况时特别有用。
- en: At this point, you should have been scratching your head and asking yourself
    *Are they Go’s channel-like structures?* And the answer is *Yes, in* *some sort*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经在挠头并问自己*它们是Go的类似通道的结构吗？*答案是*是的，在* *某种程度上*。
- en: 'There are similarities between them:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间有相似之处：
- en: '**Communication mechanisms**: Both pipes and channels are primarily used for
    communication. Pipes facilitate IPC, while channels are used for communication
    between goroutines within a Go program.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信机制**：管道和通道主要用于通信。管道促进进程间通信（IPC），而通道用于Go程序中goroutines之间的通信。'
- en: '**Data transfer**: At a basic level, both pipes and channels transfer data.
    In pipes, data flows from one process to another, while data is passed between
    goroutines in channels.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据传输**：在基本层面上，管道和通道都用于传输数据。在管道中，数据从一个进程流向另一个进程，而在通道中，数据在goroutines之间传递。'
- en: '**Synchronization**: Both provide a level of synchronization. Writing to a
    full pipe or reading from an empty pipe will block the process until the pipe
    is read from or written to, respectively. Similarly, sending to a full channel
    or receiving from an empty channel in Go will block the goroutine until the channel
    is ready for more data.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步**：两者都提供了一定程度的同步。向满管道写入或从空管道读取将阻塞进程，直到管道被读取或写入。同样，在Go中将数据发送到满通道或从空通道接收数据将阻塞goroutine，直到通道准备好更多数据。'
- en: '**Buffering**: Pipes and channels can be buffered. A buffered pipe has a defined
    capacity before it blocks or overflows, and similarly, Go channels can be created
    with a capacity, allowing a certain number of values to be held without immediate
    receiver readiness.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲**：管道和通道都可以进行缓冲。缓冲管道在阻塞或溢出之前有一个定义的容量，同样，Go通道可以创建带有容量，允许在不立即接收者准备好的情况下保持一定数量的值。'
- en: 'But more importantly, there are differences:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但更重要的是，它们之间也有不同之处：
- en: '**Direction of communication**: Standard pipes are unidirectional, meaning
    they only allow data flow in one direction. Channels in Go are bidirectional by
    default, allowing data to be sent and received on the same channel.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信方向**：标准管道是单向的，这意味着它们只允许单向数据流。Go中的通道默认是双向的，允许在同一个通道上发送和接收数据。'
- en: '**Ease of use in context**: Channels are a native feature of Go, offering integration
    and ease of use within Go programs that pipes cannot match. As a system-level
    feature, pipes require more setup and handling when used in Go.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在上下文中的易用性**：通道是Go的本地特性，在Go程序中提供集成和易用性，这是管道无法比拟的。作为一个系统级特性，管道在Go中使用时需要更多的设置和处理。'
- en: So, before we create our first Go programs using pipes, keep the following guidelines
    in mind.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们创建第一个使用管道的Go程序之前，请记住以下指南。
- en: 'Use pipes in the following scenarios:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下场景中使用管道：
- en: You must facilitate communication between different processes, possibly across
    different programming languages
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须促进不同进程之间的通信，可能涉及不同的编程语言
- en: Your application involves separate executables that need to communicate with
    each other
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序涉及需要相互通信的独立可执行文件
- en: You work in a Unix-like environment and can leverage robust IPC mechanisms
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在一个类Unix环境中工作，可以利用强大的IPC机制
- en: 'Use Go channels when the following applies:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下情况适用时，使用Go通道：
- en: You are developing concurrent applications in Go and need to synchronize and
    communicate between goroutines
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在开发Go的并发应用程序，需要在goroutines之间进行同步和通信
- en: You require a straightforward and safe way to handle concurrency within a single
    Go program
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个简单且安全的方法来处理单个Go程序中的并发
- en: You must implement complex concurrency patterns, such as fan-in, fan-out, or
    worker pools, which Go’s channel and goroutine model elegantly handle
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须实现复杂的并发模式，例如扇入、扇出或工作池，Go的通道和goroutine模型可以优雅地处理这些模式
- en: In our development routine, we are used to using pipes every time on the terminal.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的开发流程中，我们习惯在终端上每次都使用管道。
- en: 'As mentioned before, pipes pass the output of one command as the input to another.
    Here’s a simple example in `bash`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，管道将一个命令的输出作为另一个命令的输入。以下是一个简单的`bash`示例：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this command, `cat file.txt` reads the content of `file.txt`, and then the
    pipe (`|`) passes this content as input to `grep "flower"`, which searches for
    lines containing `"flower"`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，`cat file.txt` 读取 `file.txt` 的内容，然后管道（`|`）将此内容作为输入传递给 `grep "flower"`，它搜索包含
    `"flower"` 的行。
- en: To replicate this whole sequence of steps in Go, we need to read the contents
    of a file and then process these contents to find the desired string.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Go 中复制整个步骤序列，我们需要读取文件内容然后处理这些内容以找到所需的字符串。
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We don’t need to use pipes to achieve the same result since Go doesn’t use Unix-like
    pipes similarly; we typically read and process the data using Go’s file handling
    and string processing capabilities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要使用管道来实现相同的结果，因为 Go 不像 Unix-like 系统那样使用管道；我们通常使用 Go 的文件处理和字符串处理能力来读取和处理数据。
- en: Pipes in Golang
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Golang 中的管道
- en: Go’s standard library provides the necessary functions to create and manage
    pipes. The `io.Pipe()` function is commonly used to create a synchronous, in-memory
    pipe. This function is relevant to keep in mind when you only need to achieve
    this flow of control over the data but not execute any system call.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的标准库提供了创建和管理管道所需的函数。`io.Pipe()` 函数通常用于创建同步的内存管道。当你只需要控制数据的这种流程控制，而不需要执行任何系统调用时，这个函数需要记住。
- en: Also, for using OS pipes, we can call the `os.Pipe()` function This function
    internally uses the `SYS_PIPE2` syscall, and the Go `stdlib` package handles all
    the complexity for us, returning a connected pair of files.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了使用操作系统管道，我们可以调用 `os.Pipe()` 函数。这个函数内部使用 `SYS_PIPE2` 系统调用，Go 的 `stdlib`
    包为我们处理所有复杂性，返回一个连接的文件对。
- en: In both cases, data is written to the write end of the pipe using standard write
    operations and read from the read end using standard read operations. It’s crucial
    to ensure that any issues during data transfer, such as broken pipes or data integrity
    problems, are effectively managed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，数据都是通过标准写入操作写入管道的写入端，并通过标准读取操作从读取端读取。确保在数据传输过程中，如管道损坏或数据完整性问题，能够有效地管理。
- en: The mechanics of anonymous pipes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名管道的机制
- en: 'Anonymous pipes are the most basic form of pipes. They are used for communication
    between parent and child processes. Let’s explore how we can replicate the simple
    script beforementioned:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名管道是最基本的管道形式。它们用于在父进程和子进程之间进行通信。让我们看看我们如何复制前面提到的简单脚本：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This program manually creates pipes for IPC. Here’s how it works:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序手动创建了管道以进行进程间通信（IPC）。这是它的工作方式：
- en: 'Create an `echo` command and a pipe for its output:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `echo` 命令及其输出管道：
- en: '[PRE2]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: echoCmd := exec.Command("echo", "Hello, world!")
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: echoCmd := exec.Command("echo", "Hello, world!")
- en: pipe, err := echoCmd.StdoutPipe()
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pipe, err := echoCmd.StdoutPipe()
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This sets up an `echo` command for`"Hello, world!"` and creates a pipe for its
    standard output.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这设置了一个用于 `"Hello, world!"` 的 `echo` 命令并为其标准输出创建了一个管道。
- en: 'Create a `grep` command and set its standard input:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `grep` 命令并设置其标准输入：
- en: '[PRE4]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: grepCmd := exec.Command("grep", "-i", "HELLO")
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: grepCmd := exec.Command("grep", "-i", "HELLO")
- en: grepCmd.Stdin = pipe
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: grepCmd.Stdin = pipe
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `grep` command is set up to read from the output pipe of `echoCmd`.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`grep` 命令被设置为从 `echoCmd` 的输出管道读取。'
- en: 'Create a pipe for the `grepCmd` output:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `grepCmd` 输出创建一个管道：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: grepOut, err := grepCmd.StdoutPipe()
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: grepOut, err := grepCmd.StdoutPipe()
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This creates a pipe to capture the standard output of `grepCmd`.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了一个管道来捕获 `grepCmd` 的标准输出。
- en: 'Start `grepCmd`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `grepCmd`：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: if err := grepCmd.Start(); err != nil {
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if err := grepCmd.Start(); err != nil {
- en: // handle error
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 处理错误
- en: '}'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This starts `grepCmd` but doesn’t wait for it to finish. It’s ready to read
    from its standard input (connected to the `echoCmd` output).
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这启动了 `grepCmd` 但不等待它完成。它准备好从其标准输入读取（连接到 `echoCmd` 的输出）。
- en: 'Run `echoCmd`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `echoCmd`：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: if err := echoCmd.Run(); err != nil {
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if err := echoCmd.Run(); err != nil {
- en: // handle error
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 处理错误
- en: '}'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Running `echoCmd` sends its output to `grepCmd`.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行 `echoCmd` 将其输出发送到 `grepCmd`。
- en: 'Read and print the `grepCmd` output:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取并打印 `grepCmd` 的输出：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: scanner := bufio.NewScanner(grepOut)
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: scanner := bufio.NewScanner(grepOut)
- en: for scanner.Scan() {
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: for scanner.Scan() {
- en: fmt.Println(scanner.Text())
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fmt.Println(scanner.Text())
- en: '}'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code reads the output of `grepCmd` line by line and prints it.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码逐行读取 `grepCmd` 的输出并打印出来。
- en: 'Wait for `grepCmd` to finish:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 `grepCmd` 完成：
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: if err := grepCmd.Wait(); err != nil {
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if err := grepCmd.Wait(); err != nil {
- en: // handle error
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 处理错误
- en: '}'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Lastly, it waits for `grepCmd` to finish processing.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，它等待 `grepCmd` 完成处理。
- en: 'We have a simpler way to achieve the same result, as per the following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有更简单的方法达到相同的结果，如下例所示：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This program uses the `Output()` method to execute commands and capture their
    output directly. Here’s a step-by-step explanation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序使用 `Output()` 方法直接执行命令并捕获其输出。以下是逐步解释：
- en: 'Create an `echo` command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `echo` 命令：
- en: '[PRE17]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: echoCmd := exec.Command("echo", "Hello, world!")
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: echoCmd := exec.Command("echo", "Hello, world!")
- en: '[PRE18]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This line creates an `exec.Cmd` struct to represent the `"Hello, world!"` `echo`
    command.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码创建了一个 `exec.Cmd` 结构体来表示 `"Hello, world!"` 的 `echo` 命令。
- en: 'Run `echoCmd` and capture its output:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `echoCmd` 并捕获其输出：
- en: '[PRE19]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: echoOutput, err := echoCmd.Output()
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: echoOutput, err := echoCmd.Output()
- en: '[PRE20]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Output()` method runs `echoCmd`, waits for it to finish, and captures its
    standard output. If there’s an error (such as if the command doesn’t exist), it’s
    captured in `err`.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Output()` 方法运行 `echoCmd`，等待其完成，并捕获其标准输出。如果有错误（例如，如果命令不存在），它将被捕获在 `err` 中。'
- en: 'Create a `grep` command:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `grep` 命令：
- en: '[PRE21]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: grepCmd := exec.Command("grep", "Hello")
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: grepCmd := exec.Command("grep", "Hello")
- en: '[PRE22]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This creates another `exec.Cmd` struct for the `"HELLO"` `grep -i` command.
    The `-i` flag makes the search case-insensitive.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这为 `"HELLO"` 的 `grep -i` 命令创建另一个 `exec.Cmd` 结构体。`-i` 标志使搜索不区分大小写。
- en: 'Set the standard input for `grepCmd`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `grepCmd` 设置标准输入：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: grepCmd.Stdin = strings.NewReader(string(echoOutput))
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: grepCmd.Stdin = strings.NewReader(string(echoOutput))
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The output of `echoCmd` is used as the standard input for `grepCmd`. This mimics
    the piping behavior in a shell.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`echoCmd` 的输出被用作 `grepCmd` 的标准输入。这模仿了在shell中的管道行为。'
- en: 'Run `grepCmd` and capture its output:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `grepCmd` 并捕获其输出：
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: grepOutput, err := grepCmd.Output()
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: grepOutput, err := grepCmd.Output()
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This executes `grepCmd` and captures its output. If `grepCmd` encounters an
    error (such as no match found), it will be captured in `err`.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这执行 `grepCmd` 并捕获其输出。如果 `grepCmd` 遇到错误（例如没有找到匹配项），它将被捕获在 `err` 中。
- en: 'Print the output of `grepCmd`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 `grepCmd` 的输出：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'fmt.Printf("Output of grep: %s", grepOutput)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'fmt.Printf("Output of grep: %s", grepOutput)'
- en: '[PRE28]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As the last step, the output of `grepCmd` is printed to the console.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，`grepCmd` 的输出被打印到控制台。
- en: This approach using the `Output()` method is convenient. It works well in many
    scenarios, especially when dealing with straightforward command execution where
    you just need to capture the output of a command.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Output()` 方法的这种做法很方便。它在许多场景中都适用，尤其是在处理简单的命令执行时，只需要捕获命令的输出。
- en: There are limitations to anonymous pipes since they are only useful for communication
    if the creating process or its descendants are alive. Also, we have a unidirectional
    data flow. To address these issues, we can use named pipes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名管道有其局限性，因为只有在创建进程或其子进程仍然存活时，它们才对通信有用。此外，我们有一个单向的数据流。为了解决这些问题，我们可以使用命名管道。
- en: Navigating named pipes (Mkfifo())
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航命名管道（Mkfifo()）
- en: Named pipes are not limited to live processes, unlike anonymous pipes. They
    can be used between any processes and persist in the filesystem.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与匿名管道不同，命名管道不仅限于活着的进程。它们可以在任何进程之间使用，并持久存在于文件系统中。
- en: 'IPC can sometimes be an abstract concept, challenging to grasp for those new
    to system programming. Let’s use a simple, relatable analogy to make this easier:
    the “task mailbox” in an office setting.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 进程间通信（IPC）有时可能是一个抽象的概念，对于系统编程新手来说可能难以理解。让我们用一个简单、相关的类比来使这更容易理解：办公室环境中的“任务邮箱”。
- en: Imagine you’re in an office where every team member has a specific set of tasks.
    Communication and task delegation are key to the smooth operation of this office.
    How do team members efficiently exchange tasks and information? This is where
    the idea of a “task mailbox” comes into play.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你在一个办公室里，每个团队成员都有一组特定的任务。沟通和任务委派是这个办公室顺利运行的关键。团队成员如何高效地交换任务和信息？这就是“任务邮箱”概念发挥作用的地方。
- en: In our analogy, a task mailbox is a special mailbox in the office where team
    members drop off tasks for others. Once a task is in the mailbox, the designated
    team member can pick it up, process it, and move on to the next one. This system
    ensures that tasks are communicated and handled efficiently, without direct interaction
    between team members, every time a task needs to be passed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类比中，任务邮箱是办公室中的一个特殊邮箱，团队成员会将任务放入其中供他人处理。一旦任务进入邮箱，指定的团队成员就可以取走、处理并继续处理下一个任务。这个系统确保了每次需要传递任务时，任务都能得到有效沟通和处理，团队成员之间无需直接互动。
- en: Now, let’s translate this analogy into our program. Since processes often need
    to communicate with each other, just like team members in an office, this is where
    named pipes come into play. It acts like our task mailbox, serving as a conduit
    through which different processes can exchange information. One process can drop
    information into the pipe, and another can pick it up for processing. It’s a simple
    yet effective way to facilitate communication between processes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个类比转换到我们的程序中。由于进程通常需要相互通信，就像办公室里的团队成员一样，这就是命名管道发挥作用的地方。它就像我们的任务邮箱，作为一个不同进程可以交换信息的渠道。一个进程可以将信息放入管道，另一个进程可以取出来进行处理。这是一种简单而有效的方法，可以促进进程间的通信。
- en: To bring this analogy to life, let’s create this program. We’ll create a virtual
    “task mailbox” (a named pipe) and demonstrate how one can use it to pass messages
    (tasks) between different parts of a program. This example will illustrate the
    concept of named pipes and make the abstract idea of IPC more tangible and easier
    to understand.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个类比生动起来，让我们创建这个程序。我们将创建一个虚拟的“任务邮箱”（一个命名管道）并演示如何使用它在不同程序的部分之间传递消息（任务）。这个例子将说明命名管道的概念，并使抽象的IPC概念更加具体和易于理解。
- en: 'First, let’s handle the creation of our named pipe. We need to verify whether
    the named pipe exists:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们处理创建我们的命名管道。我们需要验证命名管道是否存在：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In our `main()` function, we make sure we are creating a named pipe when it
    does not exist. The `Mkfifo()` function creates a named pipe in the filesystem:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，我们确保在不存在时创建一个命名管道。`Mkfifo()`函数在文件系统中创建一个命名管道：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once created, `os.OpenFile` with `os.O_RDWR` is used to open the pipe for reading.
    This way, the data sent is read from the pipe:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，使用`os.OpenFile`和`os.O_RDWR`打开管道进行读取。这样，发送的数据就是从管道中读取的：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, our main logic resides in one goroutine sending tasks over the pipe while
    another reads them. Once we’re using a scanner, we stop reading for new tasks
    when the sender sends an `"EOD"` (end of day) string instance. To synchronize
    these goroutines, we’re using `sync.WaitGroup`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的主要逻辑驻留在发送任务通过管道的一个goroutine中，而另一个goroutine读取它们。一旦我们使用扫描器，当发送者发送一个`"EOD"`（日终）字符串实例时，我们就停止读取新任务。为了同步这些goroutine，我们使用`sync.WaitGroup`：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The sending logic in the `writer.go` file is simply pushing data over the pipe:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`writer.go`文件中的发送逻辑只是将数据推送到管道：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Receiving tasks is the responsibility of the `ReadTask()` function in the `reader.go`
    file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`reader.go`文件中的`ReadTask()`函数负责接收任务：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running our program, we should see an output like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的程序，我们应该看到以下输出：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There are a few important characteristics of using named pipes. For example,
    they can be used between any processes. They exist independently of the process
    and can be found in the filesystem. Also, although a single named pipe is unidirectional,
    two named pipes can be used for bidirectional communication.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名管道有几个重要的特性。例如，它们可以在任何进程之间使用。它们独立于进程存在，可以在文件系统中找到。此外，尽管单个命名管道是单向的，但两个命名管道可以用于双向通信。
- en: Best practices – guidelines for using pipes
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践 - 使用管道的指南
- en: Having explored practical aspects of using pipes in IPC, discussing best practices
    and guidelines is crucial. Adhering to these principles ensures that your implementation
    is efficient but also secure and maintainable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了使用管道进行进程间通信（IPC）的实际方面之后，讨论最佳实践和指南至关重要。遵循这些原则确保您的实现既高效又安全且易于维护。
- en: Efficient data handling
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效数据处理
- en: 'In the context of efficient data handling, especially when minimizing data
    in transit, two key strategies are employed: chunking and compression.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在高效数据处理的环境中，尤其是在最小化传输中的数据时，采用了两种关键策略：分块和压缩。
- en: Chunking involves breaking down large datasets into smaller, more manageable
    pieces. The primary advantage of chunking is that it prevents the overfilling
    of pipe buffers, which can lead to bottlenecks in data transmission. By segmenting
    the data, each chunk can be processed and transmitted sequentially, ensuring a
    smoother and more efficient flow of data. This technique is particularly useful
    in scenarios where data is streamed or processed in real time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 分块涉及将大型数据集分解成更小、更易于管理的部分。分块的主要优势是防止管道缓冲区溢出，这可能导致数据传输中的瓶颈。通过分段数据，每个块可以依次处理和传输，确保数据流更加顺畅和高效。这种技术在数据流或实时处理数据的情况下特别有用。
- en: Example – Chunking data
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 - 分块数据
- en: In this snippet, the idea is the writer sends data by chunk size and the reader
    receives the same.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，思想是写端按块大小发送数据，而读端接收相同的数据。
- en: 'The code on the writer’s side looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 写端代码如下所示：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And on the reader’s side, it looks like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在读端，代码如下所示：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Compression is the process of reducing the size of data before it is sent. This
    is especially beneficial when the data is highly compressible, such as text files
    or certain types of image and video files. By compressing data, the volume of
    information that needs to be transmitted is significantly reduced, leading to
    faster transmission times and potentially lower bandwidth usage. However, it’s
    important to consider the computational overhead of compressing and decompressing
    data, as well as the nature of the data itself (some data may not compress well).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩是在发送数据之前减小数据大小的过程。当数据高度可压缩时，例如文本文件或某些类型的图像和视频文件，这尤其有益。通过压缩数据，需要传输的信息量显著减少，从而加快传输速度，并可能降低带宽使用。然而，考虑压缩和解压缩数据的计算开销以及数据本身的性质（某些数据可能不易压缩）是很重要的。
- en: Example – Compressing data
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 – 压缩数据
- en: For compression, you can use a library such as `compress/gzip` to compress and
    decompress data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于压缩，您可以使用`compress/gzip`之类的库来压缩和解压缩数据。
- en: In these snippets, the writer compresses the data while the reader decompresses
    it to read it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些代码片段中，写端压缩数据，而读端解压缩数据以读取。
- en: 'In the following snippet, we’re compressing and sending the data:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们正在压缩并发送数据：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, for reading, we’ll decompress the data, as well:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于阅读，我们还需要解压缩数据：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Error handling and resource management
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理和资源管理
- en: We must handle errors and properly save resources to create maintainable and
    robust software. Let’s explore how we can approach these two dimensions of robustness.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须处理错误并妥善保存资源，以创建可维护和健壮的软件。让我们探讨如何接近这两个维度的健壮性。
- en: Robust error handling
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强健的错误处理
- en: Always check for errors after pipe operations. This includes read, write, and
    close operations. Also, implement timeouts for read/write operations to avoid
    deadlocks.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道操作后始终检查错误。这包括读取、写入和关闭操作。此外，为读取/写入操作实现超时以避免死锁。
- en: Example – Reading pipes with timeout
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 – 使用超时读取管道
- en: 'In this snippet, we have a boilerplate to read pipes leveraging in-context
    timeouts:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们有用于利用上下文超时读取管道的样板代码：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Proper resource management
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确的资源管理
- en: Ensure pipes are properly closed after use. Use `defer` for closing file descriptors
    in Go.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在使用后正确关闭管道。在Go中使用`defer`关闭文件描述符。
- en: 'In the following snippet, we can observe that we can avoid resource leakage:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们可以观察到我们可以避免资源泄漏：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Handling leaks
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 处理泄漏
- en: Monitor for any resource leaks. Left open, pipes can lead to file descriptor
    exhaustion.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 监控任何资源泄漏。如果管道保持打开状态，可能会导致文件描述符耗尽。
- en: Security considerations
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全考虑
- en: When we’re transmitting sensitive data, we should consider encrypting it before
    sending it through a pipe. After receiving data through pipes, we need to ensure
    the validation of this data, especially if used in critical parts of our programs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传输敏感数据时，我们应该在通过管道发送之前对其进行加密。在通过管道接收数据后，我们需要确保数据的验证，尤其是在程序的关键部分使用时。
- en: We also need to be cautious with permissions when creating named pipes. Restrict
    access to trusted users. Also, use randomized or unpredictable names to prevent
    name squatting attacks for named pipes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建命名管道时，我们还需要谨慎处理权限。仅限制对受信任用户的访问。此外，使用随机或不可预测的名称来防止针对命名管道的域名抢注攻击。
- en: Example – Securing named pipe creation
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 – 保护命名管道创建
- en: 'In the following snippet, the pipe name receives a random factor and restricts
    access to the pipe owner:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，管道名称接收一个随机因子并限制对管道所有者的访问：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Name squatting attack
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 域名抢注攻击
- en: In a name squatting attack, an attacker creates a named pipe with a name that
    is expected to be used by a legitimate application or service. This attack typically
    targets applications or services that dynamically create named pipes for IPC but
    do not adequately verify the identity of the pipe’s creator.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在域名抢注攻击中，攻击者创建一个预期将被合法应用程序或服务使用的命名管道。这种攻击通常针对动态创建命名管道进行IPC的应用程序或服务，但它们没有充分验证管道创建者的身份。
- en: Performance optimization
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能优化
- en: Adjust buffer sizes by tuning them based on your application’s needs. Smaller
    buffers can reduce memory usage, while larger ones can improve throughput.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的需求调整缓冲区大小。较小的缓冲区可以减少内存使用，而较大的缓冲区可以提高吞吐量。
- en: 'This next practice is crucial for achieving good performance: use non-blocking
    I/O operations to improve performance, especially in applications that require
    high responsiveness.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实践对于实现良好的性能至关重要：使用非阻塞I/O操作来提高性能，尤其是在需要高响应性的应用程序中。
- en: By following these best practices, you can ensure that your use of named pipes
    in Go is not only effective but also secure and maintainable. Named pipes are
    a powerful tool in system programming, and with careful consideration of these
    guidelines, you can harness their full potential to build robust and efficient
    applications. As you continue to develop your skills in Go and system programming,
    keep these practices in mind to enhance the quality of your code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践，您可以确保在Go中使用命名管道不仅有效，而且安全且易于维护。命名管道是系统编程中的强大工具，通过仔细考虑这些指南，您可以充分利用它们的潜力来构建健壮且高效的应用程序。随着您在Go和系统编程技能的提升，请记住这些实践以提升代码质量。
- en: Developing a log processing tool
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发日志处理工具
- en: Having covered the fundamentals of pipes in IPC and best practices for their
    use in Go, let’s explore more advanced topics. We will explore a scenario where
    pipes can be effectively utilized and see how Go’s concurrency model complements
    these use cases. This section aims to give you practical insights into leveraging
    pipes for sophisticated system programming tasks.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了IPC中管道的基础知识和在Go中使用它们的最佳实践之后，让我们探索更多高级主题。我们将探讨一个管道可以有效地利用的场景，并看看Go的并发模型如何补充这些用例。本节旨在为您提供利用管道进行复杂系统编程任务的实用见解。
- en: In the next example, we’ll develop a simple real-time log processing tool. This
    tool will read log data from a file (simulating a log file being written by another
    process), process the log entries (for example, filtering based on severity),
    and then output the results to the console.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将开发一个简单的实时日志处理工具。这个工具将从文件中读取日志数据（模拟另一个进程写入的日志文件），处理日志条目（例如，基于严重性进行过滤），然后将结果输出到控制台。
- en: 'First, we create a `filterLogs()` function that reads logs from the reader,
    filters them, and writes to the writer:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个`filterLogs()`函数，它从读取器读取日志，过滤它们，并将它们写入写入器：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note that the function reads from a reader (our named pipe), filters the log
    entries only to include those containing `"ERROR"`, and writes them to a writer
    (we’re sending to standard output):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该函数从读取器（我们的命名管道）读取，仅过滤包含`"ERROR"`的日志条目，并将它们写入写入器（我们发送到标准输出）：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the `main()` function, a named pipe is created to simulate a log file. This
    pipe acts as the source of log data. The pipe is opened for reading. Concurrently,
    a goroutine is started to simulate writing log entries to this pipe, including
    both `"INFO"` and `"ERROR"` messages. The `filterLogs()` function is called to
    process incoming log data. It filters and outputs error messages.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，创建了一个命名管道来模拟日志文件。这个管道作为日志数据的来源。管道被打开用于读取。同时，启动了一个goroutine来模拟将日志条目写入这个管道，包括`"INFO"`和`"ERROR"`消息。调用`filterLogs()`函数来处理传入的日志数据。它过滤并输出错误消息。
- en: Although simple, this code demonstrates a practical application of pipes in
    Go for real-time log processing. It shows how to set up a pipeline for continuous
    data processing, simulating a common scenario in system monitoring and log analysis
    tools.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单，但这段代码展示了在Go中使用管道进行实时日志处理的实际应用。它展示了如何设置一个用于连续数据处理的管道，模拟了系统监控和日志分析工具中的常见场景。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we conclude this chapter, let’s reflect on the key insights and knowledge
    we’ve gained about IPC in system programming, especially in the context of Go.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，让我们回顾一下我们在系统编程中关于IPC获得的关键见解和知识，特别是在Go的上下文中。
- en: We explored their fundamental role in facilitating data exchange between processes,
    emphasizing their importance in system-level programming. These pipes have versatile
    applications, including command-line utilities, data streaming, and inter-process
    data exchange. We also compared pipes to channels, highlighting differences in
    usage.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了它们在促进进程间数据交换中的基本作用，强调了它们在系统级编程中的重要性。这些管道有广泛的应用，包括命令行工具、数据流和进程间数据交换。我们还比较了管道和通道，突出了它们在用法上的差异。
- en: In the following chapter, we’re going to apply the knowledge gained to create
    automation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将应用所获得的知识来创建自动化。
