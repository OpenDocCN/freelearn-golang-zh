- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Memory Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: In this chapter, we’ll dive into the world of memory management in Go, focusing
    on the mechanisms and strategies underpinning garbage collection. As we navigate
    the garbage collection concepts, including its evolution within Go, the distinctions
    between stack and heap memory allocations, and the advanced techniques employed
    to manage memory efficiently, you will understand the inner workings of Go’s memory
    management system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入Go的内存管理世界，重点关注支撑垃圾回收的机制和策略。在我们导航垃圾回收概念的同时，包括其在Go中的演变，以及堆栈和堆内存分配之间的区别，以及用于有效管理内存的高级技术，你将了解Go内存管理系统的内部工作原理。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Garbage collection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Memory arenas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存区域
- en: By the end of the chapter, you should be able to optimize your code to reduce
    memory usage, minimize garbage collection overhead, and ultimately improve the
    scalability and responsiveness of your applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够优化你的代码以减少内存使用，最小化垃圾回收开销，并最终提高应用程序的可扩展性和响应性。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code shown in this chapter can be found in the `ch8` directory of our
    GitHub repository.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的所有代码都可以在我们的GitHub仓库的`ch8`目录中找到。
- en: Garbage collection
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Before garbage-collected languages, we needed to handle memory management ourselves.
    Despite the focused attention that this discipline craves, the main problems we
    ran in circles to avoid were memory leaks, dangling pointers, and double frees.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在垃圾回收语言之前，我们需要自己处理内存管理。尽管这个学科需要集中的关注，但我们努力避免的主要问题是内存泄漏、悬垂指针和重复释放。
- en: 'The garbage collector in Go has some jobs to avoid common mistakes and accidents:
    it tracks allocations on the heap, frees unneeded allocations, and keeps the allocations
    in use. These jobs are commonly referred to in academia as memory inference, or
    “What memory should I free?”. The two main strategies for dealing with memory
    inference are tracing and reference counting..'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的垃圾回收器有一些任务来避免常见的错误和事故：它跟踪堆上的分配，释放不再需要的分配，并保持正在使用的分配。这些任务在学术界通常被称为内存推断，或“我应该释放哪些内存？”。处理内存推断的两种主要策略是跟踪和引用计数。
- en: 'Go uses a tracing garbage collector (GC for short), which means the GC will
    trace objects reachable by a chain of references from “root” objects, consider
    the rest as “garbage,” and collect them. Go’s garbage collector has a long journey
    of optimization and learning. You can find the whole path to today’s state of
    the art in this blog post from Go’s dev team: [https://go.dev/blog/ismmkeynote](https://go.dev/blog/ismmkeynote).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go 使用跟踪垃圾回收器（简称GC），这意味着GC将跟踪从“根”对象通过一系列引用可达的对象，将其余的视为“垃圾”，并回收它们。Go的垃圾回收器经历了一段漫长的优化和学习过程。你可以在Go开发团队的这篇博客文章中找到通往今天这一先进状态的完整路径：[https://go.dev/blog/ismmkeynote](https://go.dev/blog/ismmkeynote)。
- en: In this very blog post, the Go team reports enormous gains. For instance, one
    garbage collection cycle dropped from 300 ms (Go 1.0) to, shockingly, 0.5 ms in
    the latest version.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇博客文章中，Go 团队报告了巨大的进步。例如，一个垃圾回收周期从 300 毫秒（Go 1.0）降至令人震惊的 0.5 毫秒的最新版本。
- en: 'You must have heard this at least once in the tech community: “Garbage collection
    in Go is automatic, so you can forget about memory management.” Yeah, and I’ve
    got some prime real estate on the moon to sell you. Believing this is like thinking
    your house cleans itself because you’ve got a Roomba. In Go, understanding garbage
    collection is not just a nice-to-have; it’s your ticket to writing efficient,
    high-performance code. So, buckle up, we’re diving into a world where “automatic”
    doesn’t mean “magical.”'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你至少在技术社区中听说过一次：“Go 中的垃圾回收是自动的，所以你可以忘记内存管理。”是的，我还有一些月球上的优质地产要卖给你。相信这一点就像认为你的房子会自己打扫，因为你有一个Roomba。在Go中，理解垃圾回收不仅仅是一个好主意；它是你编写高效、高性能代码的入场券。所以，系好安全带，我们将深入一个“自动”并不意味着“神奇”的世界。
- en: Imagine, if you will, a software development team that never reviews code because,
    hey, they have a linter. That’s similar to how some approach Go’s garbage collector.
    It’s like entrusting your entire code base quality to a program that checks for
    extra whitespaces. Sure, the GC in Go is a neat little janitor, tirelessly tidying
    up your memory mess. But misunderstanding its *modus operandi* is like thinking
    your linter will refactor your spaghetti code into a Michelin-star-worthy dish.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，一个软件开发团队从不审查代码，因为他们有一个代码检查器。这就像有些人对待 Go 的垃圾收集器一样。它就像把整个代码库的质量托付给一个检查额外空格的程序。当然，Go
    中的垃圾收集器是一个整洁的小清洁工，不知疲倦地清理你的内存混乱。但误解其*操作模式*就像认为你的代码检查器会把你的意大利面代码重构成一个米其林星级的美味佳肴。
- en: 'To pave the terrain to more advanced knowledge regarding GC, first, we need
    to understand two areas of memory: stack and heap.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要为更高级的 GC 知识铺路，首先，我们需要了解两个内存区域：栈和堆。
- en: Stack and heap allocation
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈和堆分配
- en: Stack allocation in Go is used for variables whose lifetimes are predictable
    and tied to the function calls that create them. These are your local variables,
    function parameters, and return values. The stack is remarkably efficient because
    of its **Last In, First Out** (**LIFO**) nature. Allocating and deallocating memory
    here is just a matter of moving the stack pointer up or down. This simplicity
    makes stack allocation fast, but it’s not without its limitations. The size of
    the stack is relatively small, and trying to put too much stuff on the stack can
    lead to the dreaded stack overflow.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的栈分配用于那些生命周期可预测且与创建它们的函数调用相关的变量。这些是你的局部变量、函数参数和返回值。由于栈的**后进先出**（**LIFO**）特性，栈非常高效。在这里分配和释放内存只是移动栈指针上下的事情。这种简单性使得栈分配快速，但并非没有限制。栈的大小相对较小，试图在栈上放置太多东西可能会导致可怕的栈溢出。
- en: Contrastingly, heap allocation is for variables whose lifetimes are less predictable
    and not strictly tied to where they were created. These are typically variables
    that must live beyond the scope of the function they were created in. The heap
    is a more flexible, dynamic space, and variables here can be accessed globally.
    However, this flexibility comes at a cost. Allocating memory on the heap is slower
    due to the need for more complex bookkeeping, and the responsibility of managing
    this memory falls to the garbage collector, which adds overhead.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，堆分配用于那些生命周期不太可预测且与它们创建的位置没有严格关联的变量。这些通常是必须超出它们创建的函数作用域的变量。堆是一个更灵活、动态的空间，这里的变量可以全局访问。然而，这种灵活性是有代价的。由于需要更复杂的账目记录，堆上的内存分配较慢，并且管理这种内存的责任落在垃圾收集器上，这增加了开销。
- en: Go’s compiler performs a neat trick called “escape analysis” (more on this topic
    in [*Chapter 9*](B21662_09.xhtml#_idTextAnchor193), *Analyzing Performance*) to
    decide whether a variable should live on the stack or the heap. If the compiler
    determines that the lifetime of a variable doesn’t escape the function it’s in,
    to the stack it goes. But if the variable’s reference is passed around or returned
    from the function, then it “escapes” to the heap.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的编译器执行一个叫做“逃逸分析”的巧妙技巧（关于这个话题的更多内容请参考[*第9章*](B21662_09.xhtml#_idTextAnchor193)，*分析性能*)，以决定一个变量应该存在于栈上还是堆上。如果编译器确定变量的生命周期不会超出其所在函数，那么它就会进入栈。但如果变量的引用在函数间传递或从函数返回，那么它就会“逃逸”到堆上。
- en: This automatic decision-making process is a boon for developers, as it optimizes
    memory usage and performance without manual intervention. The distinction between
    stack and heap allocation has significant performance implications. Stack-allocated
    memory tends to lead to better performance due to its straightforward allocation
    and deallocation mechanism.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自动决策过程对开发者来说是一个福音，因为它优化了内存使用和性能，而不需要手动干预。栈和堆分配之间的区别对性能有重大影响。由于其直接的分配和释放机制，栈分配通常会导致更好的性能。
- en: Heap-allocated memory, while necessary for more complex and dynamic data, incurs
    a performance cost due to the overhead of garbage collection. As a Go developer,
    being mindful of how your variables are allocated can help in writing more efficient
    code. While Go abstracts much of the memory management complexity, having a good
    understanding of how heap and stack allocations work can greatly impact the performance
    of your applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 堆分配的内存，虽然对于更复杂和动态的数据是必要的，但由于垃圾回收的开销，它会产生性能成本。作为一名 Go 开发者，注意你的变量如何分配可以帮助你编写更高效的代码。虽然
    Go 抽象了大部分内存管理复杂性，但了解堆和栈分配的工作原理可以极大地影响你应用程序的性能。
- en: As a rule of thumb, keep your variables in the scope as narrow as possible,
    and be cautious with pointers and references that might cause unnecessary heap
    allocations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，尽可能缩小变量的作用域，并且对可能引起不必要的堆分配的指针和引用保持谨慎。
- en: OK, let’s get technical. Go’s garbage collection is based on a concurrent, tri-color
    mark-and-sweep algorithm. Now, before your eyes glaze over like a donut, let’s
    break that down.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来深入探讨技术细节。Go 的垃圾回收基于并发、三色标记-清除算法。现在，在你眼前像甜甜圈一样失去光泽之前，让我们来分解一下。
- en: The GC algorithm
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GC 算法
- en: '*Concurrent* means it runs alongside your program, not halting everything to
    clean up. This is crucial for performance, especially in real-time systems where
    pausing for housekeeping is as welcome as a screen freeze on launch day.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发*意味着它与你的程序并行运行，而不是停止一切来清理。这对于性能至关重要，尤其是在实时系统中，暂停进行维护就像在发布日冻结屏幕一样不受欢迎。'
- en: 'The *tri-color* bit is about how the GC views objects. Think of it as a traffic
    light for memory: green for “in use,” red for “ready to delete,” and yellow for
    “maybe, maybe not.”'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*三色*的概念是关于 GC 如何看待对象。把它想象成内存的交通灯：绿色代表“正在使用中”，红色代表“准备删除”，黄色代表“可能，也可能不”。'
- en: 'The last part, *mark and sweep*, is the definition of the two main phases of
    the process. The quick version of the story is: during the “mark” phase, the GC
    scans your objects, flipping their colors based on accessibility. In the “sweep”
    phase, it takes out the trash – the red objects. This two-step process helps in
    managing memory efficiently without stepping on the toes of your running program.
    Once we have the big picture, we can explore the details of these two phases with
    ease.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分，*标记和清除*，是这个过程两个主要阶段的定义。简单来说：在“标记”阶段，GC 扫描你的对象，根据可访问性翻转它们的颜色。在“清除”阶段，它移除垃圾——红色对象。这个两步过程有助于高效地管理内存，同时不会干扰正在运行的程序。一旦我们有了整体概念，我们就可以轻松地探讨这两个阶段的细节。
- en: Marking phase
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记阶段
- en: The “mark” phase is split into two parts. In the initial part, the GC pauses
    the program briefly (less than 0.3 milliseconds) – think of it as a quick inhale
    before diving underwater. During this pause, known as the **stop-the-world** (**STW**)
    phase, the GC identifies the root set. These roots are essentially variables directly
    accessible from the stack, globals, and other special locations. In other words,
    it is the moment when the GC will start its search to identify what’s in use and
    what’s not.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “标记”阶段分为两部分。在初始部分，GC 短暂地暂停程序（小于 0.3 毫秒）——想象成潜水前的快速吸气。在这个被称为**停止世界**（**STW**）的阶段，GC
    识别根集。这些根实际上是直接从栈、全局变量和其他特殊位置可访问的变量。换句话说，这是 GC 开始搜索识别使用情况和未使用情况的时刻。
- en: After identifying the root set, the GC proceeds to the actual marking, *which
    happens concurrently with the program’s execution*. This is where the “tri-color”
    metaphor shines. Objects are initially marked “white,” meaning their fate is undecided.
    As the GC encounters these objects from the roots, it marks them “gray,” indicating
    they need to be explored further, and eventually turns them “black” once fully
    processed, signifying they are in use. This color-coded system ensures that the
    GC comprehensively assesses each object’s accessibility.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 识别根集后，GC 继续进行实际的标记，*这发生在程序执行的同时进行*。这就是“三色”隐喻大放异彩的地方。对象最初被标记为“白色”，意味着它们的命运尚未确定。随着
    GC 从根遇到这些对象，它将它们标记为“灰色”，表示需要进一步探索，一旦完全处理，最终将它们标记为“黑色”，表示它们正在使用中。这种颜色编码系统确保 GC
    全面评估每个对象的可访问性。
- en: There are more crucial details to expand on in this process. Since we want to
    create highly performant systems, we need to master our GC knowledge instead of
    keeping things theoretical.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中还有更多关键细节需要展开。由于我们希望创建高性能的系统，我们需要掌握我们的垃圾回收（GC）知识，而不是仅仅停留在理论层面。
- en: During the marking phase, the Go runtime deliberately allocates about **25%**
    of the available CPU resources. This allocation is a calculated decision, ensuring
    that the GC is efficient enough to keep memory usage in check while not overwhelming
    the system. It’s a balancing act, similar to a juggler who ensures each ball gets
    enough airtime but doesn’t hog the spotlight. This 25% allocation is crucial for
    keeping the GC’s work steady and unobtrusive.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记阶段，Go 运行时故意分配大约 **25%** 的可用 CPU 资源。这种分配是一个经过计算的决策，确保垃圾回收器足够高效，以控制内存使用，同时不会压倒系统。这是一个平衡行为，类似于一个确保每个球都能得到足够时间的杂技演员，但不会独占聚光灯。这个
    25% 的分配对于保持垃圾回收器的工作稳定和隐蔽至关重要。
- en: In addition to the standard CPU allocation, there’s a provision for an extra
    **5%** of CPU to be used via mark assists. These mark assists are triggered when
    the program makes memory allocations during the GC cycle. If the GC is lagging
    behind, allocating goroutines lends a hand (or in this case, some CPU cycles)
    to assist in the marking process. This additional 5% can be viewed as a reserve
    force, called into action when the situation demands it, ensuring that the GC
    keeps pace with the memory allocation rate.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的 CPU 分配外，还预留了额外的 **5%** CPU 用于标记辅助。这些标记辅助在程序在垃圾回收周期中进行内存分配时触发。如果垃圾回收落后了，分配
    goroutines 就会伸出援手（在这种情况下，是一些 CPU 循环）以协助标记过程。这额外的 5% 可以被视为一支预备队，在需要时被调用，确保垃圾回收器与内存分配率保持同步。
- en: Sweep
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扫描
- en: Moving to the sweep phase, this is where deallocations come into play. After
    the marking phase has identified which objects are no longer needed (those still
    marked as “white”), the sweep phase begins the process of deallocating this memory.
    This phase is crucial because it’s where the actual memory reclamation occurs,
    freeing up space for future allocations. The efficiency of this phase directly
    impacts the application’s memory footprint and overall performance. But it’s not
    all rainbows and butterflies. The GC can still lead to performance issues, such
    as latency spikes, especially when dealing with large heaps or memory-hungry applications.
    Understanding how to optimize your code to play nice with the GC is an art. It
    involves deep dives into pointer management, avoiding memory leaks, and sometimes
    just knowing when to say, “Hey, GC, you can take a break; I’ve got this.”
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 进入扫描阶段，这是释放操作开始发挥作用的地方。在标记阶段确定了哪些对象不再需要（那些仍然标记为“白色”）之后，扫描阶段开始释放这些内存的过程。这一阶段至关重要，因为这是实际内存回收发生的地方，为未来的分配腾出空间。这一阶段的效率直接影响应用程序的内存占用和整体性能。但并非全是彩虹和蝴蝶。垃圾回收器仍然可能导致性能问题，如延迟峰值，尤其是在处理大型堆或内存密集型应用程序时。了解如何优化你的代码以与垃圾回收器良好协作是一门艺术。它涉及到深入指针管理、避免内存泄漏，有时只是知道何时对垃圾回收器说，“嘿，GC，你可以休息一下；我自己能行。”
- en: GOGC
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GOGC
- en: The `GOGC` environment variable in Go is the tuning knob of the garbage collector.
    It’s like the thermostat of your home’s heating system, controlling how hot or
    cold you want in the room. In Go’s context, `GOGC` dictates the aggressiveness
    of the garbage collection process. It determines how much newly allocated memory
    is allowed before the garbage collector triggers another cycle. Understanding
    and adjusting this variable can significantly impact your Go application’s memory
    usage and performance. The default value is `100`, which means that the GC tries
    to leave at least 100% of the initial heap memory available after a new GC cycle.
    Adjusting the `GOGC` value allows you to tailor the garbage collection to the
    specific needs of your application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的 `GOGC` 环境变量是垃圾回收器的调节旋钮。它就像你家中供暖系统的恒温器，控制你想要房间有多热或多冷。在 Go 的上下文中，`GOGC`
    决定了垃圾回收过程的积极性。它决定了在垃圾回收器触发另一个周期之前，允许分配多少新内存。理解和调整这个变量可以显著影响你的 Go 应用程序的内存使用和性能。默认值是
    `100`，这意味着垃圾回收器试图在新的垃圾回收周期后至少留下 100% 的初始堆内存可用。调整 `GOGC` 的值允许你根据应用程序的具体需求定制垃圾回收。
- en: Go env
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go 环境
- en: '`GOGC` is an environment variable that affects the GC, but it is not a configuration
    option specific to the Go toolchain or compiler.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOGC` 是一个影响垃圾回收的环境变量，但它不是特定于 Go 工具链或编译器的配置选项。'
- en: Setting `GOGC` to a lower value, say `50`, means the GC will run more frequently,
    keeping the heap size smaller but using more CPU time. On the flip side, setting
    it higher, such as `200`, means the GC will run less frequently, allowing more
    memory allocation but potentially leading to an undesired increased memory usage.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将`GOGC`设置为较低的值，比如`50`，意味着GC将更频繁地运行，保持堆的大小更小，但使用更多的CPU时间。另一方面，将其设置得更高，例如`200`，意味着GC将运行得更少，允许更多的内存分配，但可能导致不希望的内存使用增加。
- en: The `GOGC` variable can take *any integer value greater than 0*. Setting it
    to a very low value can lead to a performance hit due to the GC running too often,
    like a cleaner who’s constantly tidying up to the point of being a nuisance. Conversely,
    setting it too high can cause your application to use more memory than necessary,
    which might not be ideal in memory-constrained environments. It’s important to
    find the sweet spot specific to your application’s memory and performance characteristics.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOGC`变量可以取*任何大于0的整数值*。将其设置为非常低的值可能导致性能下降，因为GC运行过于频繁，就像一个清洁工不断地整理到令人烦恼的程度。相反，设置得太高可能导致应用程序使用比必要的更多内存，这在内存受限的环境中可能不是理想的。找到适合你应用程序内存和性能特性的最佳点很重要。'
- en: There are also special values for `GOGC`. Setting it to `off` disables automatic
    garbage collection entirely. This might be useful in scenarios where the short-lived
    nature of the program doesn’t warrant the overhead of GC. However, with great
    power comes great responsibility; disabling GC can lead to unchecked memory growth.
    It’s a bit like turning off your house’s automatic thermostat – it can be beneficial
    in the right circumstances but requires much more attention to prevent problems.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOGC`也有特殊的值。将其设置为`off`将完全禁用自动垃圾回收。这可能在程序生命周期短暂，不需要GC开销的场景中很有用。然而，权力越大，责任越大；禁用GC可能导致内存增长不受控制。这有点像关闭你家的自动恒温器——在适当的条件下可能会有好处，但需要更多的关注来防止问题发生。'
- en: In practice, tuning `GOGC` is a matter of understanding your application’s memory
    profile and performance requirements. It requires careful experimentation and
    monitoring. Adjusting this variable can yield significant performance improvements,
    especially in systems with large heaps or real-time constraints.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，调整`GOGC`是一个理解你的应用程序内存配置文件和性能需求的问题。这需要仔细的实验和监控。调整这个变量可以带来显著的性能提升，尤其是在具有大堆或实时约束的系统上。
- en: GC pacer
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GC调节器
- en: The GC pacer in Go can be likened to a conductor of an orchestra, ensuring every
    section comes in at the right time to create a harmonious symphony. Its job is
    to regulate the timing of garbage collection cycles, balancing the need to reclaim
    memory with the need to keep the program running efficiently. The pacer’s decisions
    are based on the current heap size, the allocation rate, and the goal of maintaining
    program performance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的GC调节器可以比作一个乐队的指挥，确保每个部分都能在正确的时间进入，以创造和谐的交响乐。它的任务是调节垃圾回收周期的时机，平衡回收内存的需要与保持程序高效运行的需要。调节器的决策基于当前的堆大小、分配率和维持程序性能的目标。
- en: The primary role of the pacer is to determine when to start a new garbage collection
    cycle. It does this by monitoring the rate of memory allocation and the size of
    the live heap (hinted by GOGC) – the memory in use that can’t be reclaimed. The
    pacer’s strategy is to trigger a GC cycle before the program allocates too much
    memory, which could lead to increased latency or memory pressure. It’s a preventive
    measure, similar to changing the oil in your car before it turns into a bigger
    problem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 调节器的主要作用是确定何时开始一个新的垃圾回收周期。它通过监控内存分配率和活动堆的大小（由GOGC暗示）——无法回收的正在使用的内存来实现这一点。调节器的策略是在程序分配太多内存之前触发GC周期，这可能导致延迟增加或内存压力。这是一个预防措施，类似于在你车变成大问题之前更换机油。
- en: One of the key features of the GC pacer is its adaptive nature. It continuously
    adjusts its thresholds based on the application’s behavior. If an application
    allocates memory rapidly, the pacer responds by triggering GC cycles more frequently
    to keep up. Conversely, if the application’s allocation rate slows down, the pacer
    will allow more memory to be allocated before initiating a GC cycle. This adaptiveness
    ensures that the pacer’s behavior aligns with the application’s current needs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收节拍器的一个关键特性是其适应性。它根据应用程序的行为持续调整其阈值。如果一个应用程序快速分配内存，节拍器会通过更频繁地触发垃圾回收周期来做出响应，以保持同步。相反，如果应用程序的分配速率减慢，节拍器将允许在启动垃圾回收周期之前分配更多的内存。这种适应性确保了节拍器的行为与应用程序当前的需求保持一致。
- en: The pacer works in tandem with the `GOGC` environment variable. `GOGC` sets
    the percentage growth of the heap allowed before a GC cycle is triggered. The
    pacer uses this value as a guideline to determine its thresholds.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 节拍器与`GOGC`环境变量协同工作。`GOGC`设置在触发垃圾回收周期之前堆增长的百分比。节拍器使用这个值作为指导，以确定其阈值。
- en: The effectiveness of the GC pacer has a direct impact on application performance.
    A well-tuned pacer ensures that garbage collection happens smoothly, without causing
    significant pauses or latency spikes. However, if the pacer’s thresholds are not
    well aligned with the application’s behavior, it could lead to either excessive
    GC cycles, which can degrade performance, or delayed collections, which can increase
    memory usage. It’s like finding the right speed for cruise control – too fast
    or too slow can lead to an uncomfortable ride.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收节拍器的有效性直接影响应用程序的性能。一个调优良好的节拍器确保垃圾回收过程平稳进行，不会导致显著的暂停或延迟峰值。然而，如果节拍器的阈值没有与应用程序的行为良好对齐，可能会导致过多的垃圾回收周期，从而降低性能，或者延迟收集，从而增加内存使用。这就像找到巡航控制正确的速度一样——太快或太慢都可能造成不舒适的驾驶体验。
- en: The GC pacer in Go is a critical component that ensures the efficiency of the
    garbage collection process. It’s not just about writing code; it’s about understanding
    the environment in which your code runs, and the GC pacer is a significant part
    of that environment.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的垃圾回收节拍器是确保垃圾回收过程效率的关键组件。这不仅仅是编写代码；这是理解代码运行的环境，而垃圾回收节拍器是那个环境的重要组成部分。
- en: GODEBUG
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GODEBUG
- en: The `GODEBUG` environment variable in Go is a powerful tool for developers,
    offering insights into the inner workings of the Go runtime. Specifically, the
    `GODEBUG=gctrace=1` setting is often used to gain detailed information about garbage
    collection processes. Let’s explore this in depth.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的`GODEBUG`环境变量是开发者的一项强大工具，它能够提供关于Go运行时内部运作的洞察。具体来说，`GODEBUG=gctrace=1`设置通常用于获取关于垃圾回收过程的详细信息。让我们深入探讨这一点。
- en: '`GODEBUG` in Go is like a diagnostic toolkit for your car. Just as you might
    plug in a diagnostic tool to understand what’s happening under the hood of your
    car, `GODEBUG` provides insights into the Go runtime. Among its various capabilities,
    one of the most used is `gctrace`. When set to `1` (`GODEBUG=gctrace=1`), it enables
    the tracing of GC activities, offering a window into how and when garbage collection
    occurs in your Go application.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的`GODEBUG`就像是你汽车的诊断工具包。就像你可能插入一个诊断工具来了解你汽车引擎盖下发生了什么一样，`GODEBUG`提供了关于Go运行时的洞察。在其各种功能中，最常用的是`gctrace`。当设置为`1`（`GODEBUG=gctrace=1`）时，它启用了垃圾回收活动的跟踪，为你提供了一个窗口，可以看到在你的Go应用程序中垃圾回收是如何以及何时发生的。
- en: Enabling `gctrace` to `1` outputs detailed information for each GC cycle, including
    the time it starts, its duration, the heap size before and after collection, and
    the amount of memory reclaimed. This data is invaluable for understanding the
    GC’s impact on your application’s performance. It’s like getting a play-by-play
    commentary on how the GC is managing memory, which can be critical for performance
    tuning.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将`gctrace`设置为`1`会输出每个垃圾回收周期的详细信息，包括其开始时间、持续时间、回收前后的堆大小以及回收的内存量。这些数据对于理解垃圾回收对应用程序性能的影响至关重要。这就像获得关于垃圾回收如何管理内存的逐点评论，这对于性能调整可能是至关重要的。
- en: 'The output from `gctrace=1` can be quite dense and may seem intimidating at
    first. It includes several metrics, such as STW times, which indicate how long
    your application pauses during GC. Other details include the number of goroutines
    running, heap sizes, and the number of GC cycles. Reading this output is like
    decoding a treasure map; once you understand the symbols and numbers, it reveals
    valuable information about where your application’s performance can be improved.
    Take this output as an example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`gctrace=1`的输出可能相当密集，一开始可能看起来令人畏惧。它包括多个指标，例如STW时间，这些指标表明您的应用程序在GC期间暂停了多长时间。其他细节包括正在运行的goroutine数量、堆大小和GC周期数。阅读这个输出就像解读一张藏宝图；一旦您理解了符号和数字，它就会揭示有关如何提高应用程序性能的有价值信息。以下是一个示例输出：'
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down this output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个输出：
- en: '`gc 1`: This indicates the sequence number of the garbage collection cycle'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc 1`: 这表示垃圾收集周期的序列号'
- en: '`@0.019s`: The time (in seconds) since the program started when this GC cycle
    began'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@0.019s`: 从程序开始到此次GC周期开始的时间（以秒为单位）'
- en: '`2%`: Percentage of the total program runtime spent on GC'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2%`: 在GC上花费的总程序运行时间的百分比'
- en: '`0.015+2.5+0.003 ms clock`: Breakdown of the GC cycle time'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.015+2.5+0.003 ms clock`: GC周期时间的分解'
- en: '`0.015 ms`: STW sweep termination phase time'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.015 ms`: STW清除终止阶段时间'
- en: '`2.5 ms`: Concurrent mark and scan phase time'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2.5 ms`: 并发标记和扫描阶段时间'
- en: '`0.003 ms`: STW mark termination phase time'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.003 ms`: STW标记终止阶段时间'
- en: '`0.061+0.5/2.0/3.0+0.012 ms cpu`: CPU time for the GC cycle'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.061+0.5/2.0/3.0+0.012 ms cpu`: GC周期的CPU时间'
- en: '`0.061 ms`: CPU time for STW sweep termination'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.061 ms`: STW清除终止的CPU时间'
- en: '`0.5/2.0/3.0`: CPU time for concurrent phases (mark/scan, assist, background)'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.5/2.0/3.0`: 并发阶段（标记/扫描、辅助、后台）的CPU时间'
- en: '`0.012 ms`: CPU time for STW mark termination'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.012 ms`: STW标记终止的CPU时间'
- en: '`4->4->1 MB`: Heap size at the start, midpoint, and end of the GC'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4->4->1 MB`: GC开始、中点和结束时的堆大小'
- en: '`5 MB goal`: Next GC cycle’s target heap size'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5 MB goal`: 下一个GC周期的目标堆大小'
- en: '`4 P`: Number of processors used'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4 P`: 使用的处理器数量'
- en: 'We can observe the following with this data:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下数据观察到：
- en: '**Frequent high percentage**: If the percentage of time spent on GC is high
    and frequent, it could signal performance issues'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频繁的高百分比**：如果GC花费的时间百分比高且频繁，这可能表明存在性能问题'
- en: '**STW times**: Longer STW times can indicate that optimizations are needed
    to reduce GC pauses'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**STW时间**：较长的STW时间可能表明需要优化以减少GC暂停'
- en: '**Heap size trends**: Growing heap size without similar decreases after GC
    cycles might point to memory leaks'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆大小趋势**：GC周期后没有类似减少的堆大小增长可能表明存在内存泄漏'
- en: '**CPU time**: Higher CPU times might suggest that the GC is working harder
    than expected, potentially due to inefficient memory usage'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU时间**：更高的CPU时间可能表明GC比预期工作得更努力，这可能是由于内存使用效率低下'
- en: Setting `GODEBUG=gctrace=1` is particularly useful in scenarios where you suspect
    memory leaks, or when you’re trying to optimize memory usage and GC overhead.
    For instance, if you observe longer STW times, it might indicate that your application
    is spending too much time on garbage collection, leading to performance bottlenecks.
    Similarly, if the heap size grows continuously, it might be a sign of a memory
    leak. This level of insight is crucial for making informed decisions about code
    optimizations and memory management. However, like any powerful tool, it should
    be used with understanding and care. By leveraging `gctrace`, developers can significantly
    enhance the efficiency and performance of their Go applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在怀疑内存泄漏或尝试优化内存使用和GC开销的情况下，设置`GODEBUG=gctrace=1`特别有用。例如，如果您观察到较长的STW时间，这可能表明您的应用程序在垃圾收集上花费了太多时间，导致性能瓶颈。同样，如果堆大小持续增长，这可能是一个内存泄漏的迹象。这种程度的洞察力对于做出关于代码优化和内存管理的明智决策至关重要。然而，像任何强大的工具一样，它应该被理解和谨慎地使用。通过利用`gctrace`，开发者可以显著提高Go应用程序的效率和性能。
- en: Memory ballast
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存压舱物
- en: Memory ballast in Go, at its core, is like putting a heavy suitcase in the trunk
    of a car to prevent it from being too light and skidding on ice. In Go’s context,
    a memory ballast is a large allocation of memory that is never used but serves
    to influence the behavior of the garbage collector.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，内存压舱物，从本质上讲，就像在汽车的行李箱中放一个重的行李箱，以防止它太轻并在冰上打滑。在Go的上下文中，内存压舱物是指大量分配的内存，这些内存从未使用过，但用于影响垃圾收集器的行为。
- en: Traditionally, Go’s GC would trigger based on the heap size doubling from the
    size at the end of the last collection (`GOGC=100`). In applications with large
    heap sizes, this could lead to long periods between GC cycles, followed by large,
    disruptive collections.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Go 的垃圾回收（GC）会在上一次收集结束时的堆大小加倍时触发（`GOGC=100`）。在堆大小较大的应用程序中，这可能导致 GC 周期之间出现长时间的间隔，随后是大型且破坏性的收集。
- en: Developers used memory ballast as a buffer, artificially increasing the heap
    size to prompt more frequent, but smaller and less disruptive, GC cycles. It was
    a manual tuning method to optimize performance, particularly in high-throughput,
    low-latency systems. This technique was developed by the streaming company Twitch
    in 2019 in their post *How I learnt to stop worrying and love the* *heap* ([https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/](https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者使用内存压舱作为缓冲区，人为地增加堆大小以提示更频繁、但更小且更不破坏性的 GC 周期。这是一种手动调优方法，用于优化性能，尤其是在高吞吐量、低延迟系统中。这项技术是由流媒体公司
    Twitch 在 2019 年在其后 *How I learnt to stop worrying and love the* *heap* ([https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/](https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/))
    文章中开发的。
- en: Twitch has a service called Visage that acts as the API frontend and is the
    central gateway for all externally originating API traffic. It’s built with Go
    and runs on AWS EC2\. They faced challenges with handling large traffic spikes,
    notably during “refresh storms” when a popular broadcaster’s stream drops and
    restarts, causing viewers to refresh their pages repeatedly. The Visage application
    was triggering a high number of garbage collection cycles per second, which was
    consuming a significant portion of CPU cycles and increasing API latency during
    peak loads. The heap size of the application was relatively small, and during
    traffic spikes, the number of GC cycles would increase, further degrading performance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Twitch 有一个名为 Visage 的服务，充当 API 前端，是所有外部发起的 API 流量的中心网关。它是用 Go 编写的，并在 AWS EC2
    上运行。他们面临着处理大量流量波动的挑战，尤其是在“刷新风暴”期间，当一位受欢迎的广播者的直播掉线并重新启动时，观众会反复刷新他们的页面。Visage 应用程序每秒会触发大量垃圾回收周期，这消耗了大量的
    CPU 周期，并在高峰负载期间增加了 API 延迟。该应用程序的堆大小相对较小，在流量波动期间，GC 周期的数量会增加，从而进一步降低性能。
- en: 'When they introduced a memory ballast, it increased the base size of the heap,
    delaying GC triggers and reducing the number of GC cycles over time. This was
    achieved by allocating a very large byte array, which doesn’t get swept as garbage
    since it’s still referenced by the application. This array was created as the
    following snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们引入内存压舱时，它增加了堆的基数大小，延迟了 GC 触发，并随着时间的推移减少了 GC 周期的数量。这是通过分配一个非常大的字节数组来实现的，由于它仍然被应用程序引用，因此不会被回收。这个数组创建如下代码片段：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Very simple yet powerful, right? The results for them were as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单但强大，对吧？他们的结果如下：
- en: The introduction of the memory ballast led to a ~99% reduction in GC cycles
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入内存压舱导致 GC 周期减少了约 99%。
- en: CPU utilization of the API frontend servers reduced by ~30%, and the overall
    99th-percentile API latency during peak load reduced by ~45%
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 前端服务器的 CPU 利用率降低了约 30%，并且在高峰负载期间，API 的 99% 分位延迟降低了约 45%
- en: The ballast effectively allowed the heap to grow larger before triggering GC,
    which improved per-host throughput and provided more reliable per-request handling
    under load
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压舱石有效地允许堆在触发 GC 之前增长更大，这提高了每台主机的吞吐量，并在负载下提供了更可靠的每请求处理。
- en: The ballast allocation resides mostly in virtual memory, making it a cost-effective
    solution
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压舱石分配主要位于虚拟内存中，使其成为一种成本效益高的解决方案
- en: 'The memory ballast technique, while powerful in certain contexts like Twitch’s,
    is not universally applicable and should be avoided or used with caution in several
    scenarios:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 Twitch 等某些场景中非常强大，但内存压舱技术并不适用于所有情况，应避免或谨慎使用：
- en: '**Memory-sensitive applications**: In environments where memory is a scarce
    resource, allocating a large chunk of memory as a ballast might not be feasible.
    This is especially true for applications running on hardware with limited memory
    or in dense containerized environments where memory overhead is a critical factor.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存敏感型应用程序**：在内存资源稀缺的环境中，分配一大块内存作为压舱石可能不可行。这对于在内存有限的硬件上运行或在高密度容器化环境中运行的应用程序尤其如此，在这些环境中，内存开销是一个关键因素。'
- en: '**Applications with dynamic memory usage**: If an application’s memory usage
    is highly dynamic and unpredictable, setting a fixed-size memory ballast could
    lead to inefficient memory utilization.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有动态内存使用的应用程序**：如果应用程序的内存使用高度动态且不可预测，设置固定大小的内存平衡器可能会导致内存利用效率低下。'
- en: '**Low-latency systems**: While the memory ballast can reduce the frequency
    of garbage collection and thus improve throughput, it might not always benefit
    low-latency systems where the predictability of GC pauses is more critical. The
    ballast technique primarily optimizes throughput at the potential cost of increased
    latency due to larger heap sizes before GC triggers.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低延迟系统**：虽然内存平衡器可以减少垃圾回收的频率，从而提高吞吐量，但它并不总是有利于低延迟系统，在这些系统中，垃圾回收暂停的可预测性更为关键。平衡技术主要优化吞吐量，可能会以增加垃圾回收触发前的堆大小为代价，从而增加延迟。'
- en: '**Small heap footprint applications**: Applications that naturally maintain
    a small heap footprint might not benefit from a memory ballast. In such cases,
    the overhead of managing a large, unused memory allocation might outweigh the
    benefits of reduced GC frequency.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小堆内存占用应用程序**：自然保持小堆内存占用的应用程序可能不会从内存平衡器中受益。在这种情况下，管理大量未使用的内存分配的开销可能超过了减少垃圾回收频率的好处。'
- en: '`GOGC` environment variable) can achieve the desired performance improvements
    without the need for a memory ballast. This approach should be considered first,
    as it’s a less invasive way to optimize GC behavior.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`GOGC` 环境变量) 可以在不使用内存平衡器的情况下实现所需的性能改进。这种方法应该首先考虑，因为它是一种侵入性较小的优化 GC 行为的方法。
- en: '**When it masks underlying performance issues**: Using a memory ballast to
    improve performance might mask underlying inefficiencies in the application code
    or architecture. It’s important to address these fundamental issues directly rather
    than relying on a memory ballast as a workaround.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当它掩盖了潜在的性能问题时**：使用内存平衡器来提高性能可能会掩盖应用程序代码或架构中潜在的低效。直接解决这些基本问题比依赖内存平衡器作为权宜之计更为重要。'
- en: The memory ballast is an excellent choice for managing these critical scenarios,
    but it’s only relevant up to Go version 1.19\. Starting from version 1.20 and
    onward, there’s a standardized method to set the application’s “soft” memory limits
    using the `GOMEMLIMIT` environment variable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 内存平衡器是管理这些关键场景的绝佳选择，但它仅适用于 Go 版本 1.19 及之前。从版本 1.20 开始，有一个标准化的方法可以通过 `GOMEMLIMIT`
    环境变量设置应用程序的“软”内存限制。
- en: GOMEMLIMIT
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GOMEMLIMIT
- en: With `GOMEMLIMIT`, you set a soft cap on the memory usage of the Go runtime,
    encompassing the heap and other runtime-managed memory. This cap is like telling
    your application, “Here’s your memory budget; spend it wisely.”
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GOMEMLIMIT`，您为 Go 运行时的内存使用设置了一个软上限，包括堆和其他运行时管理的内存。这个上限就像告诉您的应用程序：“这是您的内存预算；明智地使用它。”
- en: Since Go 1.20, the strategic focus has shifted from manual tweaks such as memory
    ballast to leveraging built-in runtime features for memory management. `GOMEMLIMIT`
    offers a more straightforward and manageable approach to limiting memory usage.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Go 1.20 以来，战略重点已经从手动调整，如内存平衡器，转向利用内置的运行时功能进行内存管理。`GOMEMLIMIT` 提供了一种更直接、更易于管理的限制内存使用的方法。
- en: The `GOMEMLIMIT` variable is used to set a soft memory limit for the runtime.
    This limit encompasses the Go heap and all other memory managed by the runtime,
    but it doesn’t include external memory sources such as mappings of the binary,
    memory managed in other languages, or memory held by the operating system on behalf
    of the Go program. `GOMEMLIMIT` is a numeric value measured in bytes, with the
    option to add a unit suffix for clarity. The supported suffixes include B, KiB,
    MiB, GiB, and TiB, following the IEC 80000-13 standard. These suffixes denote
    quantities of bytes based on powers of 2; for instance, KiB means 2^10 bytes,
    MiB means 2^20 bytes, and so on. By default, GOMEMLIMIT is set to `math.MaxInt64`,
    effectively disabling the memory limit. However, you can change this limit during
    runtime using `runtime/debug.SetMemoryLimit`.The key aspect to understand about
    `GOMEMLIMIT` is its “soft cap” nature. Unlike a hard limit, which would act as
    a strict ceiling on memory usage, a soft cap is more flexible. `GOMEMLIMIT` influences
    the garbage collector’s behavior, prompting it to run more aggressively as memory
    usage approaches the set limit. However, this doesn’t equate to an absolute prevention
    of going over the limit. It’s like a speed warning sign on a road; it suggests
    a safe speed but can’t physically slow down your car.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOMEMLIMIT` 变量用于为运行时设置一个软内存限制。这个限制包括 Go 堆以及运行时管理的所有其他内存，但不包括外部内存源，例如二进制的映射、其他语言中管理的内存，或操作系统代表
    Go 程序持有的内存。`GOMEMLIMIT` 是一个以字节为单位的数值，可以选择添加单位后缀以增加清晰度。支持的单位后缀包括 B、KiB、MiB、GiB
    和 TiB，遵循 IEC 80000-13 标准。这些后缀表示基于 2 的幂的字节数量；例如，KiB 表示 2^10 字节，MiB 表示 2^20 字节，依此类推。默认情况下，GOMEMLIMIT
    设置为 `math.MaxInt64`，实际上禁用了内存限制。然而，您可以在运行时使用 `runtime/debug.SetMemoryLimit` 来更改此限制。关于
    `GOMEMLIMIT` 的关键方面是它的“软上限”性质。与作为内存使用严格上限的硬限制不同，软上限更加灵活。`GOMEMLIMIT` 影响垃圾收集器的行为，当内存使用接近设定的限制时，会促使垃圾收集器更加积极地运行。然而，这并不意味着绝对防止超过限制。它就像道路上的速度警告标志；它建议一个安全速度，但不能实际上减慢你的车。'
- en: Why not both?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不两者都要呢？
- en: Using memory ballast alongside `GOMEMLIMIT` can be redundant, like wearing two
    watches to tell the same time. Ballast is used to artificially inflate the heap
    size to alter GC behavior, but with `GOMEMLIMIT`, you’re already defining the
    heap’s upper limit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `GOMEMLIMIT` 一起使用内存压舱物可能是多余的，就像戴两只手表来告诉相同的时间一样。压舱物用于人为地增加堆的大小以改变垃圾收集器的行为，但有了
    `GOMEMLIMIT`，您已经定义了堆的上限。
- en: Memory arenas
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存区域
- en: The Go 1.20 release introduced an experimental arena package that offers memory
    arenas. These arenas can enhance performance by decreasing the number of allocations
    and deallocations that need to be done during runtime.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.20 版本引入了一个实验性的区域包，它提供了内存区域。这些区域可以通过减少运行时需要进行的分配和释放次数来提高性能。
- en: Memory arenas are a useful tool for allocating objects from a contiguous region
    of memory and freeing them all at once with minimal memory management or garbage
    collection overhead. They are especially helpful in functions that require the
    allocation of many objects, processing them for a significant amount of time,
    and then freeing all the objects at the end. It’s important to note that memory
    arenas are an experimental feature, available in Go 1.20 only when the `GOEXPERIMENT=arenas`
    environment variable is set.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 内存区域是分配对象并一次性释放它们（具有最小的内存管理或垃圾收集开销）的有用工具。它们在需要分配许多对象、处理一段时间后并在最后释放所有对象的函数中特别有用。重要的是要注意，内存区域是一个实验性功能，仅在
    Go 1.20 中可用，前提是设置了 `GOEXPERIMENT=arenas` 环境变量。
- en: Warning
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The Go team does not provide support or guarantee compatibility for the API
    and implementation of memory arenas, and it may not exist in future releases.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Go 团队不提供对内存区域 API 和实现的官方支持或兼容性保证，并且它可能不会出现在未来的版本中。
- en: Using memory arenas
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内存区域
- en: 'Once we’ve set the `GOEXPERIMENT=arenas` environment variable, we can import
    the `arena` package:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了 `GOEXPERIMENT=arenas` 环境变量，我们就可以导入 `arena` 包：
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create a new arena, we can use the `NewArena()` function, which returns
    the new arena reference:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的区域，我们可以使用 `NewArena()` 函数，它返回新的区域引用：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have an arena to use, we can ask for new references for our types.
    In the next snippet, we are creating a new reference in our arena for a `Person`
    struct type:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了要使用的区域，我们就可以为我们的类型请求新的引用。在下一个片段中，我们正在为 `Person` 结构体类型在我们的区域中创建一个新的引用：
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is an important distinction from the normal flow of allocation. We aren’t
    creating new references and putting them in the arena. We ask the arena for new
    references.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这与正常分配流程中的常规流程有一个重要的区别。我们不是创建新的引用并将它们放入区域。我们向区域请求新的引用。
- en: 'There are some new APIs introduced in the arena package, such as `MakeSlice`,
    that ask for a predetermined capacity slice for an arena. If we want to ask for
    a new arena-bounded slice, we can use code as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 区域包中引入了一些新的 API，例如 `MakeSlice`，它要求为区域请求一个预定的容量切片。如果我们想请求一个新的区域限制切片，我们可以使用以下代码：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can repeat this process and manipulate the objects normally, but when we’re
    done with our arena, we can call `Free()`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重复这个过程并正常操作对象，但当我们完成我们的区域时，我们可以调用 `Free()`：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember, freeing the arena will deallocate all objects at once instead of scattered
    deallocations made during the sweep phase in the normal flow of Go’s GC.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，释放区域将一次性释放所有对象，而不是在正常 Go 的 GC 流程中的扫描阶段进行分散释放。
- en: 'Sometimes we want to send some objects created in the arena to heap (garbage
    collected) before freeing all objects in the arena. This can be achieved by using
    the `Clone` function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想在释放区域中的所有对象之前，将一些在区域中创建的对象发送到堆（垃圾回收）。这可以通过使用 `Clone` 函数来实现：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this snippet, `p1` is arena-allocated while `p2` is heap-allocated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`p1` 是区域分配的，而 `p2` 是堆分配的。
- en: New solutions, old problems
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的解决方案，老问题
- en: Since we need to actively free our arena. This new step in our development can
    be error-prone. The most common problem is using arena objects after the arena
    is freed. To make things easier, the Go toolchain has a flag during the program
    execution to activate the **address** **sanitizer** (**asan**).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要积极释放我们的区域。这个新的开发步骤可能会出错。最常见的问题是释放区域后继续使用区域对象。为了使事情更容易，Go 工具链在程序执行期间有一个标志来激活
    **地址** **检查器**（**asan**）。
- en: 'Consider this program:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个程序：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, we can execute the program using the address sanitizer:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用地址检查器执行程序：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output will show the problem as intended:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将按预期显示问题：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Opportunities
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 机会
- en: There are several areas of Go development that could be positively affected
    by memory arenas. The most prevalent example is gRPC. Every time the program handles
    an RPC request, many objects are allocated during the process of encoding and
    decoding the messages. As we saw before, it tends to put more pressure on the
    GC. This strategy is somewhat the proof of how it affects the performance since
    the C++ implementation of gRPC already uses the concept of memory arenas ([https://protobuf.dev/reference/cpp/arenas/](https://protobuf.dev/reference/cpp/arenas/)).
    Another example of arenas (as a concept) being used for performance gains is in
    the JSON serialization process. The fastjson project ([https://github.com/valyala/fastjson](https://github.com/valyala/fastjson))
    uses memory arenas to deal with marshaling and is allegedly 15x faster than the
    Go standard library.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Go 开发中有几个领域可能会因内存区域而受益。最典型的例子是 gRPC。每当程序处理 RPC 请求时，在编码和解码消息的过程中会分配许多对象。正如我们之前看到的，这往往会对
    GC 增加更多压力。这种策略某种程度上证明了它对性能的影响，因为 gRPC 的 C++ 实现已经使用了内存区域的概念（[https://protobuf.dev/reference/cpp/arenas/](https://protobuf.dev/reference/cpp/arenas/））。另一个使用内存区域（作为一个概念）以获得性能提升的例子是在
    JSON 序列化过程中。fastjson 项目（[https://github.com/valyala/fastjson](https://github.com/valyala/fastjson)）使用内存区域来处理序列化，据说比
    Go 标准库快 15 倍。
- en: Guidelines
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指南
- en: There are some questions that you can ask yourself before introducing arenas
    in your project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在将区域引入你的项目之前，你可以问自己一些问题。
- en: '*Do I have the data about the issue* *I suspect?*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*我有关于我怀疑的问题的数据吗？*'
- en: 'If you don’t have the data, you’re guessing:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有数据，你就是在猜测：
- en: '*Do I have several allocations or just* *a few?*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*我有多处分配还是只有几处？*'
- en: If you don’t have many allocations, your program will use more memory by introducing
    arenas. You can use the rule of thumb that an arena is 8 MB in size.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有很多分配，你的程序通过引入区域会使用更多内存。你可以使用这样一个经验法则：一个区域的大小是 8 MB。
- en: '*Does it have the same* *small structure?*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*它有相同的小结构吗？*'
- en: Maybe you’re looking for the wrong tool. Consider using `sync.Pool`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你正在寻找错误的工具。考虑使用 `sync.Pool`。
- en: '*Is it the hot path of* *my program?*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是我的程序的“热点路径”吗？*'
- en: It is probably a premature optimization. Experiment with several combinations
    of GC and `GOMEMLIMIT` before considering memory arenas.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一种过早的优化。在考虑内存区域之前，先尝试几种 GC 和 `GOMEMLIMIT` 的组合。
- en: It’s time to wrap up our knowledge of memory management.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候总结我们对内存管理的知识了。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve explored GC, the difference between stack and heap allocation, and ways
    to optimize memory usage for better performance. Also, we’ve uncovered the evolution
    of Go’s garbage collector and its methods, including advanced topics such as its
    algorithm (tri-color/concurrent/mark and sweep).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了垃圾回收（GC）、栈和堆分配之间的区别，以及优化内存使用以提高性能的方法。此外，我们还揭示了Go的垃圾回收器和其方法的发展，包括高级主题，如其算法（三色/并发/标记和清除）。
- en: We’ve also discussed practical approaches including using environmental variables
    such as `GOGC` to fine-tune garbage collection and employing techniques such as
    memory ballast and `GOMEMLIMIT` to help the GC manage the program memory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了实际的方法，包括使用环境变量如`GOGC`来微调垃圾回收，以及采用内存压舱和`GOMEMLIMIT`等技术来帮助GC管理程序内存。
- en: 'During this chapter, you probably ask yourself: How much performance are we
    gaining, tinkering, and tweaking the GC and runtime parameters, and combining
    these techniques?'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你可能自己问自己：通过调整GC和运行时参数，以及结合这些技术，我们获得了多少性能提升？
- en: 'The answer is simple: *Performance is not a guessing game. We should* *measure
    it.*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：*性能不是一场猜测游戏。我们应该* *对其进行测量*。
- en: In the next chapter (on analyzing performance), we’ll explore how to profile
    our application in terms of memory, CPU, allocations, and much more.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（关于性能分析）中，我们将探讨如何从内存、CPU、分配等方面对应用程序进行性能分析。
