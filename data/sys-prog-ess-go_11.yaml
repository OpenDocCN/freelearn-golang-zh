- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Telemetry
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遥测
- en: In this chapter, we explore the practical world of **telemetry**, where the
    elegance of Go’s programming model meets the crucial need for application observability.
    We are equipping you with the tools of logging, tracing, and metrics to shed light
    on the inner workings of your Go applications, empowering you to ensure they run
    efficiently and reliably.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨实际世界的**遥测**领域，在这里，Go 的编程模型的优雅性与应用程序可观察性的关键需求相得益彰。我们正在为您提供日志记录、跟踪和度量的工具，以揭示您的
    Go 应用程序的内部运作，让您能够确保它们高效且可靠地运行。
- en: This chapter is your guide to enhancing the art and science of application telemetry.
    From the comprehensive practice of structured logging, which brings order and
    clarity to application logs, to the detailed insights offered by tracing and the
    thorough analysis enabled by metrics, this chapter covers it all.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是您提升应用程序遥测艺术和科学指南。从结构化日志的全面实践，它为应用程序日志带来秩序和清晰，到跟踪提供的详细洞察，以及度量实现的彻底分析，本章涵盖了所有内容。
- en: 'The chapter will cover the following key topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Logs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志
- en: Traces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪
- en: Metrics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 度量
- en: The **OpenTelemetry** (**OTel**) project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenTelemetry**（**OTel**）项目'
- en: By the end of this chapter, you will have acquired the skills to observe, understand,
    and actively improve the performance and reliability of your apps, fostering a
    sense of engagement and motivation in your work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将掌握观察、理解和积极改进应用程序性能和可靠性的技能，这将激发您在工作中的参与感和动力。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Make sure you have Docker installed on your machine. You can download it from
    the official Docker website ([https://www.docker.com/get-started](https://www.docker.com/get-started)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的机器上已安装 Docker。您可以从官方 Docker 网站下载它（[https://www.docker.com/get-started](https://www.docker.com/get-started)）。
- en: All the code shown in this chapter can be found in the `ch11` directory of our
    Git repository.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的所有代码都可以在我们的 Git 仓库的 `ch11` 目录中找到。
- en: Logs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: 'Logging, the unsung hero of system programming, is often as overlooked as the
    “terms and conditions” checkbox on software updates. Most developers treat logging
    the same way teenagers treat a clean room: a nice idea in theory but somehow never
    a priority until things start to smell funny. The common misconception here? That
    logging is just an afterthought, a mere diary for your code to occasionally scribble
    in. Spoiler alert: it’s not!'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录，系统编程中的不为人知的英雄，常常像软件更新中的“条款和条件”复选框一样被忽视。大多数开发者对待日志记录的方式就像青少年对待干净房间一样：理论上是个好主意，但不知为何，直到事情开始变得奇怪，才成为优先事项。这里的常见误解是什么？那就是日志记录只是事后想到的，只是代码偶尔记录的日记。剧透一下：事实并非如此！
- en: Imagine, if you will, a software development version of an archeological dig.
    Each log entry is a carefully unearthed artifact, offering clues to the civilization
    (code base) that once thrived. Now, picture some developers at this dig, using
    a bulldozer (poor logging practices) to uncover these delicate treasures. The
    result? A lot of broken pottery and bewildered faces. This, my friends, is what
    happens when logging into Go is not given the respect and precision it demands.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你愿意，一个软件开发版的考古挖掘。每一条日志条目都是精心挖掘出的文物，为曾经繁荣的文明（代码库）提供了线索。现在，想象一些开发者在这个挖掘现场，使用推土机（糟糕的日志记录实践）来挖掘这些脆弱的宝藏。结果呢？大量的破碎陶器和困惑的面孔。朋友们，这就是当将日志记录应用于
    Go 语言时没有得到应有的尊重和精确度时会发生的事情。
- en: Logging in Go, especially in the context of system programming, is an essential
    tool for understanding the behavior of applications. It provides visibility into
    the system, enabling developers to track down bugs, monitor performance, and understand
    traffic patterns. Go, being the pragmatic language it is, offers built-in support
    for logging via the standard library’s log package, but the plot thickens when
    system-level programming comes into play.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，尤其是在系统编程的背景下，日志记录是理解应用程序行为的一个基本工具。它提供了对系统的可见性，使开发者能够追踪错误、监控性能和理解流量模式。Go
    语言作为一门务实的语言，通过标准库中的日志包提供了内置的日志记录支持，但当系统级编程介入时，情况变得更加复杂。
- en: For system programming, where performance and resource optimization are paramount,
    the standard `log` package might not always cut it. This is where structured logging
    comes into the spotlight. Structured logging, as opposed to plain text logging,
    organizes log entries into a structured format, typically JSON. This format makes
    logs easier to query, analyze, and understand, especially when you’re sifting
    through mountains of data trying to find the proverbial needle in a haystack.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于系统编程，性能和资源优化至关重要，标准的`log`包可能并不总是能满足需求。这就是结构化日志受到关注的地方。与纯文本日志相比，结构化日志将日志条目组织成结构化格式，通常是JSON。这种格式使得日志更容易查询、分析和理解，尤其是在你试图在大量数据中找到传说中的“海中针”时。
- en: 'Let’s not just talk the talk; let’s walk the walk with a code snippet illustrating
    structured logging in Go:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅要有言辞，还要有行动，用一段Go语言代码片段来展示结构化日志：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code utilizes the experimental `slog` package introduced in Go 1.21\. It
    resides within the `log` sub-package (`log/slog`). It offers the convenience of
    no external dependencies being required, simplifying project management.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用了Go 1.21中引入的实验性`slog`包。它位于`log`子包中（`log/slog`）。它提供了无需外部依赖的便利，简化了项目管理。
- en: 'Let’s explore the snippet’s key points:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这个片段的关键点：
- en: '`handler := slog.NewJSONHandler(os.Stdout)`: This line creates a `slog.Handler`
    responsible for formatting and potentially routing log entries. Here, `slog.NewJSONHandler`
    generates a JSON formatter and `os.Stdout` specifies the standard output as the
    destination.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler := slog.NewJSONHandler(os.Stdout`)：这一行创建了一个`slog.Handler`，负责格式化和可能路由日志条目。在这里，`slog.NewJSONHandler`生成一个JSON格式化器，而`os.Stdout`指定标准输出作为目的地。'
- en: '`logger := slog.New(handler)`: This line creates a `slog.Logger` instance.
    The newly created JSON handler is used to configure the logger’s output format
    and destination.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logger := slog.New(handler`)：这一行创建了一个`slog.Logger`实例。新创建的JSON处理器用于配置日志的输出格式和目的地。'
- en: '`logger.Info("A group of walrus emerges from the ocean", slog.Attr("animal",
    "walrus"), slog.Attr("size", 10))`: This logs an informational message using the
    `Info` method'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logger.Info("A group of walrus emerges from the ocean", slog.Attr("animal",
    "walrus"), slog.Attr("size", 10))`：这是使用`Info`方法记录一条信息性消息'
- en: '`slog.Attr("animal", "walrus"), slog.Attr("size", 10)`: These leverage `slog.Attr`
    to create key-value pairs (attributes) that enhance the log message with structured
    data. This makes logs easier to parse and analyze by tools or downstream applications.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slog.Attr("animal", "walrus"), slog.Attr("size", 10`)：这些通过使用`slog.Attr`创建键值对（属性），以结构化数据增强日志消息。这使得日志更容易被工具或下游应用程序解析和分析。'
- en: Logging in Go is not just about keeping a record; it’s about making sense of
    your application’s story, one log entry at a time. Remember – like any good story,
    the devil is in the details (or in this case, the data).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，日志不仅仅是记录；它是逐条理解应用程序故事的过程。记住——就像任何好的故事一样，魔鬼在于细节（或者在这个案例中，是数据）。
- en: Logging, in the realm of software development, serves as the cornerstone for
    understanding, diagnosing, and tracking the behavior of applications. It is akin
    to the breadcrumb trail left by Hansel and Gretel in the famous fairy tale, offering
    guidance back through the complex woods of your code base to understand what happened,
    when, and why.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发领域，日志是理解、诊断和跟踪应用程序行为的基础。它类似于著名童话故事《汉塞尔与格蕾特》中留下的面包屑路径，为你提供指导，穿越代码库的复杂森林，了解发生了什么，何时发生，以及为什么发生。
- en: At its core, logging involves recording events and data during the execution
    of a program. These events could range from general information about the application’s
    operation to errors and system-specific messages that provide insight into its
    health and performance. The significance of logging can be likened to the role
    of a flight recorder or “black box” in aviation; it captures crucial information
    that can be analyzed post-factum to understand events leading up to an incident
    or to optimize future performance.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，日志涉及在程序执行过程中记录事件和数据。这些事件可能包括关于应用程序操作的一般信息，到错误和系统特定的消息，这些消息可以提供对其健康和性能的洞察。日志的重要性可以与航空中的飞行记录器或“黑匣子”的作用相提并论；它捕捉了事后分析事件发生前的事件或优化未来性能的关键信息。
- en: 'Effective logging practices empower developers through the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的日志实践通过以下方式赋予开发者力量：
- en: '**Debugging and troubleshooting**: Logs are one of the main places to look
    when something goes wrong. They can help pinpoint where an error occurred and
    under what circumstances, reducing the time it takes to resolve issues.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试和故障排除**：当出现问题的时候，日志是主要查看的地方。它们可以帮助确定错误发生的位置和情况，从而减少解决问题所需的时间。'
- en: '**Security auditing**: Logging access and transaction data can help detect
    unauthorized access attempts, data breaches, and other security threats, facilitating
    swift action.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全审计**：记录访问和交易数据可以帮助检测未授权的访问尝试、数据泄露和其他安全威胁，从而促进快速采取行动。'
- en: '**Compliance and record keeping**: In many industries, keeping detailed logs
    is a regulatory requirement for compliance purposes, serving as proof of proper
    data handling and other practices.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合规性和记录保存**：在许多行业中，为了合规目的，详细记录是监管要求，作为正确处理数据和其它实践的证明。'
- en: '**Understanding user behavior**: Logging can provide insights into how users
    interact with your application, which features are most popular, and where users
    may encounter difficulties.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解用户行为**：日志可以提供关于用户如何与你的应用程序交互、哪些功能最受欢迎以及用户可能遇到困难的见解。'
- en: Despite its critical role, logging is not without challenges. It requires a
    careful balance to ensure that the right amount of information is captured – too
    little and you may miss important clues; too much, and you’re sifting through
    a haystack looking for needles. The art and science of logging lie in determining
    what to log, how to log it, and how to make sense of the data collected, all while
    minimizing performance impacts on the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管日志记录在关键作用中，但它并非没有挑战。它需要仔细平衡，以确保捕获到正确数量的信息——太少可能会错过重要线索；太多，你就像在寻找针一样在干草堆中翻找。日志记录的艺术和科学在于确定记录什么、如何记录以及如何理解收集到的数据，同时最大限度地减少对应用程序性能的影响。
- en: When we look for performance today, uber/zap is one of the fastest logging libraries
    out there. Let’s explore the main differences between using slog versus zap.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们今天寻找性能时，uber/zap 是最快的日志库之一。让我们探讨使用 slog 与 zap 之间的主要区别。
- en: Zap versus slog
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Zap 与 slog
- en: When deciding between slog and zap, consider your application’s specific needs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 slog 和 zap 之间做出选择时，考虑你应用程序的具体需求。
- en: For applications where performance is paramount, and you need fine-grained control
    over logging, zap offers proven speed and configurability.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于性能至关重要的应用程序，并且你需要对日志进行精细控制，zap 提供了经过验证的速度和可配置性。
- en: If you’re looking for a modern, efficient logging solution that integrates well
    with Go’s context package and emphasizes simplicity and flexibility, slog may
    be the right choice.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个与现代、高效的日志解决方案集成良好，且强调简洁和灵活的 Go 的上下文包，slog 可能是正确的选择。
- en: 'Here is the zap version of the same example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同示例的 zap 版本：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This example is intentionally more exaggerated to depict how configurable the
    zap library is. Let me explain what is going on here, step by step:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子故意夸张，以描绘 zap 库的可配置性。让我一步一步地解释这里发生了什么：
- en: '`go.uber.org/zap` for core zap functionality and `go.uber.org/zap/zapcore`
    for low-level configuration.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `go.uber.org/zap` 进行核心 zap 功能和 `go.uber.org/zap/zapcore` 进行低级配置。
- en: '`encoderConfig` configuration for JSON output with human-readable keys.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`encoderConfig` 配置用于具有可读键的 JSON 输出。'
- en: '`consoleEncoder`) and an output destination (`consoleSink`) that writes to
    the standard output.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`consoleEncoder`）和一个输出目的地（`consoleSink`），它将写入标准输出。'
- en: '`zapcore.NewCore` function constructs the core of our logger, which combines
    the encoder, the sink, and the configured log level (`zap.InfoLevel`).'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zapcore.NewCore` 函数构建了我们日志的核心，它结合了编码器、接收器和配置的日志级别（`zap.InfoLevel`）。'
- en: '`zap.New`, we build a zap logger based on `core`.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `zap.New`，我们基于 `core` 构建了一个 zap 日志记录器。
- en: '`Infow` for logging. It makes it easier to add structured data to log messages
    (and runs slower than the non-sugared version).'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Infow` 进行日志记录。它使得向日志消息中添加结构化数据变得更容易（并且比非糖化的版本运行得更慢）。
- en: However, both slog and zap enhance Go’s logging capabilities, extending beyond
    the standard library to offer structured, efficient, and flexible logging solutions.
    The choice between them depends on your application’s specific requirements, including
    performance considerations, the need for structured logging, and the level of
    customization required.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，slog 和 zap 都增强了 Go 的日志功能，超越了标准库，提供了结构化、高效和灵活的日志解决方案。选择它们取决于你应用程序的具体需求，包括性能考虑、对结构化日志的需求以及所需的定制程度。
- en: Logging for debugging or monitoring?
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于调试或监控的日志？
- en: Debugging logs are primarily used during the development phase or when diagnosing
    issues in a system. Their main aim is to provide developers with detailed, contextual
    information about the application’s behavior at a specific moment in time, particularly
    when errors or unexpected behaviors occur.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 调试日志主要用于开发阶段或诊断系统中的问题时。它们的主要目的是为开发者提供关于应用程序在特定时间点行为的详细、上下文信息，尤其是在出现错误或意外行为时。
- en: 'Here are the characteristics of debugging logs:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是调试日志的特点：
- en: '**Granularity**: Debugging logs are often highly detailed, including verbose
    information about the state of the application, variable values, execution paths,
    and error messages.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒度**：调试日志通常非常详细，包括关于应用程序状态、变量值、执行路径和错误消息的冗长信息。'
- en: '**Temporary**: These logs may be generated in a development environment or
    temporarily enabled in production to track down specific issues. They are not
    typically kept running permanently in a living environment due to their verbose
    nature.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**临时性**：这些日志可能在开发环境中生成或在生产环境中临时启用以追踪特定问题。由于它们的冗长性质，它们通常不会在运行环境中永久运行。'
- en: '**Developer focused**: The audience for debugging logs is usually the developers
    who are familiar with the application’s code base. The information is technical
    and requires a deep understanding of the application’s internals.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向开发者**：调试日志的受众通常是熟悉应用程序代码库的开发者。信息是技术性的，需要深入了解应用程序的内部结构。'
- en: The most common examples of these logs are stack traces and key variables at
    certain checkpoints.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志最常见的例子是堆栈跟踪和某些检查点的关键变量。
- en: When we’re logging for monitoring, logs are designed for the ongoing observation
    of an application in production. They help in understanding the application’s
    health and usage patterns over time, facilitating proactive maintenance and optimization.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为监控进行日志记录时，日志被设计用于对生产环境中应用程序的持续观察。它们有助于理解应用程序的健康状况和随时间变化的用法模式，从而促进主动维护和优化。
- en: 'Here are the characteristics of monitoring logs:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是监控日志的特点：
- en: '**Aggregation friendly**: Monitoring logs are structured to be easily aggregated
    and analyzed by monitoring tools. They often follow a consistent format, making
    it simpler to extract metrics and trends.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于聚合**：监控日志被设计成易于监控工具进行聚合和分析。它们通常遵循一致的格式，这使得提取指标和趋势变得更加简单。'
- en: '**Persistent**: These logs are continuously generated and collected as part
    of the application’s normal operation in production environments. They are less
    detailed than debugging logs to balance informativeness with performance overhead.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：这些日志在生产环境中的应用程序正常操作过程中持续生成和收集。与调试日志相比，它们的信息量较少，以平衡信息量和性能开销。'
- en: '**Operational insight**: The focus is on information relevant to the operation
    of the application, user activity, and error rates. The audience includes not
    only developers but also system administrators and operations teams.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运营洞察**：重点在于与应用程序的运营、用户活动和错误率相关的信息。受众不仅包括开发者，还包括系统管理员和运维团队。'
- en: For instance, we can see this kind of logging strategy on HTTP request logs
    including method, URL, and status code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在包括方法、URL和状态码的HTTP请求日志中看到这种日志策略。
- en: The main difference between these two methods is the objective, detail level,
    audience, and life span.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法之间的主要区别在于目标、详细程度、受众和生命周期。
- en: In essence, logging for debugging and monitoring serve complementary but distinct
    roles in the life cycle of an application. Effective logging strategies recognize
    these differences, implementing tailored approaches to meet the unique needs of
    debugging and monitoring.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，调试和监控的日志在应用程序的生命周期中扮演着互补但不同的角色。有效的日志策略认识到这些差异，实施定制的方法以满足调试和监控的独特需求。
- en: When it comes to logging, the format you choose can significantly impact the
    readability, processing speed, and overall usefulness of your log data. Two popular
    formats are JSON logs and structured text logs. Choosing between them requires
    understanding their differences, advantages, and the specific needs of your application
    or environment. Let’s outline a framework to help us to make an informed decision.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志记录方面，你选择的格式可以显著影响日志数据的可读性、处理速度和整体实用性。两种流行的格式是JSON日志和结构化文本日志。在它们之间进行选择需要了解它们的不同之处、优点以及您应用程序或环境的特定需求。让我们概述一个框架，以帮助我们做出明智的决定。
- en: 'First, we should consider the log consumption tools:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该考虑日志消费工具：
- en: '**JSON logs**: If you’re using modern log management systems or tools designed
    to ingest and query JSON data (such as **Elasticsearch, Logstash, Kibana** (**ELK**),
    or Splunk), JSON logs can be highly advantageous. These tools can natively parse
    JSON, allowing for more efficient querying, filtering, and analysis.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON日志**：如果你使用的是现代日志管理系统或旨在摄取和查询JSON数据的工具（如**Elasticsearch, Logstash, Kibana**（**ELK**）或Splunk），JSON日志可以非常有优势。这些工具可以原生解析JSON，从而实现更高效的查询、过滤和分析。'
- en: '**Structured text logs**: If your log consumption mainly involves reading logs
    directly for debugging purposes or using tools that don’t natively parse JSON,
    structured text logs might be preferable. Structured text logs can be easier to
    read for humans, especially when tailing logs in a console.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化文本日志**：如果你的日志消费主要涉及直接读取日志进行调试或使用不原生解析JSON的工具，结构化文本日志可能更受欢迎。结构化文本日志对于人类来说可能更容易阅读，尤其是在控制台跟踪日志时。'
- en: 'Also, we evaluate log data complexity:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们评估日志数据复杂性：
- en: '**JSON logs**: JSON is well suited for logging complex and nested data structures.
    If your application logs contain a wide variety of data types or structured data
    that benefits from hierarchical organization, JSON logs can encapsulate this complexity
    more effectively.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON日志**：JSON非常适合记录复杂和嵌套的数据结构。如果你的应用程序日志包含多种数据类型或需要分层组织的结构化数据，JSON日志可以更有效地封装这种复杂性。'
- en: '**Structured text logs**: For simpler logging requirements where logs are primarily
    flat messages with a few key-value pairs, structured text logs can be sufficient
    and more straightforward to work with.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化文本日志**：对于主要需要简单日志记录，日志内容主要是平面消息和一些键值对的情况，结构化文本日志可以满足需求，并且更易于处理。'
- en: 'After this evaluation, we can assess performance and overhead:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在此评估之后，我们可以评估性能和开销：
- en: '**JSON logs**: Writing logs in JSON format can introduce additional computational
    overhead due to serialization costs. For high-throughput applications where performance
    is critical, assess whether your system can handle this overhead without significant
    impact.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON日志**：以JSON格式编写日志可能会因为序列化成本而引入额外的计算开销。对于性能至关重要的高吞吐量应用程序，评估你的系统是否能够在不造成重大影响的情况下处理这种开销。'
- en: '**Structured text logs**: Generally, generating structured text logs is less
    CPU-intensive than JSON serialization. If performance is a paramount concern and
    your log data is relatively simple, structured text logging may be the more efficient
    choice.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化文本日志**：通常，生成结构化文本日志比JSON序列化消耗的CPU资源更少。如果性能是首要关注点，并且你的日志数据相对简单，结构化文本日志可能是更有效的选择。'
- en: Then, we can create a plan for log analysis and troubleshooting.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以制定日志分析和故障排除的计划。
- en: '**JSON logs**: For scenarios where logs are extensively analyzed to gain insights
    into application behavior, and user actions, or for troubleshooting complex issues,
    JSON logs provide a more structured and “queryable” format. They facilitate deeper
    analysis and can be automatically processed by many tools.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON日志**：在需要广泛分析日志以深入了解应用程序行为、用户操作或故障排除复杂问题的场景中，JSON日志提供了更结构化和“可查询”的格式。它们促进了更深入的分析，并且可以被许多工具自动处理。'
- en: '**Structured text logs**: If your log analysis needs are straightforward or
    you primarily use logs for real-time troubleshooting without complex querying,
    structured text logs might suffice.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化文本日志**：如果你的日志分析需求简单，或者你主要使用日志进行实时故障排除而不进行复杂的查询，结构化文本日志可能就足够了。'
- en: 'Lastly, we can assess the development and maintenance context:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以评估开发和维护环境：
- en: '**JSON logs**: Consider whether your development team is comfortable with JSON
    format and parsing, as well as whether your logging framework and infrastructure
    support JSON logging effectively'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON日志**：考虑你的开发团队是否熟悉JSON格式和解析，以及你的日志框架和基础设施是否有效地支持JSON日志。'
- en: '**Structured text logs**: Structured text logs might be preferred for teams
    looking for simplicity and ease of use, especially if they are not using advanced
    log processing tools'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化文本日志**：对于寻求简单性和易用性的团队，特别是如果他们不使用高级日志处理工具，结构化文本日志可能更受欢迎。'
- en: 'The general guideline is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一般性指南如下：
- en: '**Log consumption tools**: Choose JSON for advanced processing tools; choose
    structured text for simplicity or direct consumption.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志消费工具**：选择JSON用于高级处理工具；选择结构化文本用于简单性或直接消费。'
- en: '**Data complexity**: Use JSON for complex, nested data; structured text for
    simpler data.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复杂性**：对于复杂、嵌套的数据使用JSON；对于简单的数据使用结构化文本。'
- en: '**Performance considerations**: Opt for structured text when performance is
    critical; use JSON with performance impact in mind.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能考虑**：当性能至关重要时选择结构化文本；考虑到性能影响使用JSON。'
- en: '**Analysis and troubleshooting**: Select JSON for in-depth analysis needs;
    structured text for basic troubleshooting.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析和故障排除**：对于深入分析需求选择JSON；对于基本故障排除使用结构化文本。'
- en: '**Team and infrastructure**: Consider team familiarity and infrastructure capabilities.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队和基础设施**：考虑团队熟悉度和基础设施能力。'
- en: Ultimately, the choice between JSON and structured text logs depends on balancing
    the specific needs of your application, the capabilities of your log processing
    infrastructure, and your team’s preferences and skills. It’s not uncommon for
    systems to employ both types in different contexts or layers of the application
    to optimize for both human readability and machine processing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在JSON和结构化文本日志之间的选择取决于平衡您应用的具体需求、日志处理基础设施的能力以及您团队的偏好和技能。系统在不同上下文或应用的不同层使用这两种类型以优化人类可读性和机器处理的情况并不少见。
- en: Understanding what to log and what not to log is crucial for maintaining efficient,
    secure, and useful logging practices.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 理解应该记录什么和不应该记录什么对于维护高效、安全和有用的日志实践至关重要。
- en: What to log?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应该记录什么？
- en: Proper logging can help you debug issues, monitor system performance, and understand
    user behavior. However, excessive, or inappropriate, logging can lead to performance
    degradation, storage issues, and security vulnerabilities.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的日志记录可以帮助您调试问题、监控系统性能和理解用户行为。然而，过多的或不适当的日志记录可能导致性能下降、存储问题和安全漏洞。
- en: 'Here’s a guide to help navigate these decisions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份指南来帮助您做出这些决定：
- en: '**Errors**: Capture any errors that occur. Include stack traces to facilitate
    debugging.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：捕获发生的任何错误。包括堆栈跟踪以方便调试。'
- en: '**System state changes**: Log significant state changes within your application,
    such as system startup or shutdown, configuration changes, and status changes
    of critical components.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统状态变化**：记录应用中的重大状态变化，例如系统启动或关闭、配置更改以及关键组件的状态变化。'
- en: '**User actions**: Log key user actions, especially those that modify data or
    trigger significant processes in your application. This helps in understanding
    user behavior and diagnosing issues.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户行为**：记录关键用户行为，特别是那些修改数据或触发应用中重大流程的行为。这有助于理解用户行为和诊断问题。'
- en: '**When you don’t have a metrics server** **in place**:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当您没有设置** **指标服务器**：'
- en: '**Performance metrics**: Log performance-related metrics such as response times,
    throughput, and resource utilization. This information is crucial for monitoring
    the health and performance of your system.'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能指标**：记录与性能相关的指标，如响应时间、吞吐量和资源利用率。这些信息对于监控系统的健康和性能至关重要。'
- en: '**Security events**: Log security-related events, such as login attempts, access
    control violations, and other suspicious activities. These logs are vital for
    security monitoring and incident response.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全事件**：记录与安全相关的事件，例如登录尝试、访问控制违规和其他可疑活动。这些日志对于安全监控和事件响应至关重要。'
- en: '**API calls**: When your application interacts with external services through
    APIs, logging these calls can be helpful for tracking dependencies and troubleshooting
    issues.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API调用**：当您的应用通过API与外部服务交互时，记录这些调用有助于跟踪依赖关系和故障排除问题。'
- en: '**When you don’t have an audit system to send the** **system events**:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当您没有审计系统来发送** **系统事件**：'
- en: '**Critical business transactions**: Log important business transactions to
    provide an audit trail that can be used for compliance, reporting, and business
    intelligence purposes.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键业务交易**：记录重要的业务交易，以提供可用于合规、报告和商业智能目的的审计跟踪。'
- en: What not to log?
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不应该记录什么？
- en: 'There is a series of information that’s not suitable for logging, such as the
    following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些信息不适合记录，例如以下内容：
- en: '**Sensitive information**: Avoid logging sensitive information such as passwords,
    **personal identification information** (**PII**), credit card numbers, and security
    tokens. Exposure to such information can lead to security breaches and compliance
    violations.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敏感信息**：避免记录敏感信息，如密码、**个人身份信息**（**PII**）、信用卡号码和安全令牌。此类信息的泄露可能导致安全漏洞和合规违规。'
- en: '**Verbose or debug information in production**: While verbose or debug-level
    logs can be incredibly useful during development, they can overwhelm production
    systems. Use appropriate log levels and consider dynamic log level adjustment.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产环境中的详细或调试信息**：虽然详细或调试级别的日志在开发期间非常有用，但它们可能会使生产系统不堪重负。使用适当的日志级别并考虑动态调整日志级别。'
- en: '**Redundant or irrelevant information**: Logging the same information multiple
    times or capturing irrelevant details can clutter your logs and consume unnecessary
    storage.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冗余或不相关信息**：多次记录相同的信息或捕获不相关信息可能会使日志杂乱无章，并消耗不必要的存储空间。'
- en: '**Large binary data**: Avoid logging large binary objects, such as files or
    images. These can significantly increase the size of your log files and degrade
    performance.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大量二进制数据**：避免记录大量二进制对象，例如文件或图像。这些可能会显著增加日志文件的大小并降低性能。'
- en: '**User input without sanitization**: Logging raw user input can introduce security
    risks, such as injection attacks. Always sanitize input before logging it.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未经净化的用户输入**：记录原始用户输入可能会引入安全风险，如注入攻击。在记录之前始终对输入进行净化。'
- en: 'The best practices can be summarized here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践可以总结如下：
- en: '**Use structured logging**: Structured logs make it easier to search and analyze
    data. Use a consistent format such as JSON across your logs'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用结构化日志**：结构化日志使搜索和分析数据更加容易。在日志中使用一致的格式，如JSON'
- en: '**Implement log rotation and retention policies**: Automatically rotate logs
    and define retention policies to manage disk space and comply with data retention
    requirements'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施日志轮转和保留策略**：自动轮转日志并定义保留策略以管理磁盘空间并符合数据保留要求'
- en: '**Secure log data**: Ensure that logs are stored securely, access is controlled,
    and transmission of log data is encrypted'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护日志数据**：确保日志安全存储，控制访问，并加密日志数据的传输'
- en: '**Monitor log files for anomalies**: Regularly review log files for unusual
    activity or errors that could indicate operational or security issues'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控日志文件中的异常**：定期审查日志文件，寻找可能表明操作或安全问题的异常活动或错误'
- en: By following these guidelines, you can ensure that your logging practices contribute
    positively to the maintenance, performance, and security of your applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些指南，你可以确保你的日志实践对应用程序的维护、性能和安全产生积极贡献。
- en: Remember, the goal is to capture enough information to be useful without compromising
    system performance or security.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，目标是捕获足够的信息以供使用，同时不损害系统性能或安全。
- en: Often, we need more information regarding the program execution and our series
    of records (logs) are not enough. This is where we rely on traces.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要有关程序执行和记录系列（日志）的更多信息。这就是我们依赖跟踪的地方。
- en: Traces
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪
- en: So, you’ve heard that tracing in Golang is as straightforward as pie, have you?
    Let’s not kid ourselves; in the realm of system programming, tracing is more like
    baking a soufflé in a microwave – sure, you might end up with something edible,
    but it’s hardly going to win you any Michelin stars.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你听说在Golang中进行跟踪就像吃派一样简单，是吗？让我们别自欺欺人；在系统编程领域，跟踪更像是用微波炉烘焙松饼——当然，你可能会得到一些可以食用的东西，但几乎不可能赢得任何米其林星级。
- en: 'Here’s an analogy that might tickle your fancy: Imagine you’re a detective
    in a software development murder mystery. The victim? System performance. The
    suspects? A motley crew of goroutines, each more suspicious than the last. Your
    only hope of cracking the case lies in the intricate art of trace analysis. But
    beware, this is no child’s play. You’ll need all your wit, wisdom, and a hefty
    dose of sarcasm to navigate through the quagmire of stack traces and execution
    threads.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个可能让你感兴趣的类比：想象你是一名软件开发的谋杀案侦探。受害者？系统性能。嫌疑人？一群可疑的goroutines，一个比一个可疑。你破解这个案件唯一的希望在于复杂的跟踪分析艺术。但小心，这可不是儿戏。你需要所有的智慧、智慧和大量的讽刺来穿越堆栈跟踪和执行线程的泥潭。
- en: Tracing in Golang, for those unacquainted with the finer points of system programming,
    is the Sherlock Holmes debugging tool. It allows developers to observe the behavior
    of their programs during execution, offering invaluable insights into performance
    bottlenecks and sneaky bugs that would otherwise remain as elusive as a well-behaved
    cat in a room full of rocking chairs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉系统编程细节的人来说，Golang中的跟踪是福尔摩斯调试工具。它允许开发者在程序执行期间观察程序的行为，为性能瓶颈和难以捉摸的虫子提供宝贵的见解，否则它们就像房间里摇椅上的好猫一样难以捉摸。
- en: At its core, Golang’s tracing framework leverages the `runtime/trace` package
    to let you peer into the running soul of your application. By collecting a wide
    range of events related to goroutines, heap allocation, garbage collection, and
    more, it sets the stage for a deep dive into the inner workings of your code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Go 的跟踪框架利用 `runtime/trace` 包让您深入了解应用程序的运行灵魂。通过收集与 goroutines、堆分配、垃圾回收等相关的大量事件，它为深入挖掘代码的内部工作原理奠定了基础。
- en: The power of trace analysis comes alive with tools such as `go tool trace`,
    which parses trace files generated by your Go application and serves them up in
    a web interface that’s as revealing as it is mesmerizing. Here, you can visualize
    the execution of goroutines, track down latency issues, and get to the bottom
    of those performance mysteries that keep you up at night.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪分析的力量在像 `go tool trace` 这样的工具的帮助下变得生动起来，这些工具可以解析由您的 Go 应用程序生成的跟踪文件，并以一个既揭示又迷人的网页界面提供它们。在这里，您可以可视化
    goroutines 的执行，追踪延迟问题，并揭开那些让您夜不能寐的性能之谜。
- en: 'Let’s take a practical look with a simple code example. Imagine you’ve wrapped
    your critical section with trace calls like so:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的代码示例来实际看看。假设您已经用跟踪调用包装了您的关键部分，如下所示：
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run this program, it outputs a kind of ugly output, right?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行这个程序时，它输出的是一种丑陋的输出，对吧？
- en: This snippet kick-starts the tracing process, directing the output to stderr,
    where you can later analyze it to your heart’s content. Remember, this is just
    the tip of the iceberg.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段启动跟踪过程，将输出定向到 stderr，您可以在那里尽情分析。记住，这只是冰山一角。
- en: Let’s step back and learn how to add the trace in our programs and check the
    output properly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退后一步，学习如何在我们的程序中添加跟踪并正确检查输出。
- en: 'As you can see, to start tracing, you need to import the `runtime/trace` package.
    This package provides the functionality to start and stop tracing:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，要开始跟踪，您需要导入 `runtime/trace` 包。此包提供了开始和停止跟踪的功能：
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to call `trace.Start` at the point in your code where you want to begin
    tracing. Similarly, you should call `trace.Stop` when you want to end the tracing,
    usually after a specific operation you’re interested in measuring:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在您代码中想要开始跟踪的点调用 `trace.Start`。同样，当您想要结束跟踪时，通常是在您感兴趣测量的特定操作之后，应该调用 `trace.Stop`：
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run your Go program as usual. The program will execute and generate a trace
    file named `trace.out` (or whatever you named your file) in the current directory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规运行您的 Go 程序。程序将执行并在当前目录下生成一个名为 `trace.out` 的跟踪文件（或您命名的任何文件）：
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After your program has run, you can analyze the trace file using `go tool trace`.
    This command will start a web server that hosts a web-based user interface for
    analyzing the trace:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的程序运行后，您可以使用 `go tool trace` 分析跟踪文件。此命令将启动一个提供基于网页的用户界面的 Web 服务器，用于分析跟踪：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you run this command, it will print a URL to your console. Open this URL
    in your web browser to view the trace viewer. The viewer provides various views
    to analyze different aspects of your program’s execution, such as the goroutine
    analysis, heap analysis, and other aspects we explored in [*Chapter 9*](B21662_09.xhtml#_idTextAnchor193),
    *Analyzing Performance*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此命令时，它将在控制台打印一个 URL。在您的网页浏览器中打开此 URL 以查看跟踪查看器。查看器提供了各种视图来分析程序执行的各个方面，例如
    goroutine 分析、堆分析以及我们在 [*第 9 章*](B21662_09.xhtml#_idTextAnchor193) 中探索的其他方面，*分析性能*。
- en: 'For programs with HTTP servers, the approach is slightly different. Let’s add
    tracing capabilities to this simple program:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于带有 HTTP 服务器的程序，方法略有不同。让我们给这个简单的程序添加跟踪功能：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To trace the HTTP endpoint, we’ll need to wrap your handler with a function
    that starts and stops tracing around the handler’s execution. You can use the
    `runtime/trace` package for tracing and `net/http/httptrace` for more detailed
    HTTP tracing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟踪 HTTP 端点，我们需要用开始和停止跟踪的函数包装您的处理器执行。您可以使用 `runtime/trace` 包进行跟踪，以及 `net/http/httptrace`
    进行更详细的 HTTP 跟踪。
- en: 'First, let’s modify our main package to include the `runtime/trace` package,
    as shown in the previous snippet. Then, create a trace wrapper for your HTTP handler:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改我们的主包以包含 `runtime/trace` 包，如前一个代码片段所示。然后，为您的 HTTP 处理器创建一个跟踪包装器：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, wrap your HTTP handlers with `TraceHandler`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用 `TraceHandler` 包装您的 HTTP 处理器：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Follow the same steps as in the previous program to start and stop tracing,
    and then run your application. Make some requests to your server to ensure there’s
    activity to trace.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上一个程序中的相同步骤开始和停止跟踪，然后运行您的应用程序。向您的服务器发送一些请求以确保有活动可以跟踪。
- en: After stopping the trace and generating the trace file, use the `go tool trace`
    command to analyze the trace data. Pay special attention to the sections related
    to network I/O and HTTP requests to understand the performance of your endpoint.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在停止跟踪并生成跟踪文件后，使用`go tool trace`命令来分析跟踪数据。特别关注与网络I/O和HTTP请求相关的部分，以了解您端点的性能。
- en: Effective tracing
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效的跟踪
- en: Instead of tracing your entire program, focus on the parts where performance
    is critical. This approach reduces the size of the trace file and makes analysis
    easier.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 不要跟踪整个程序，而要关注性能关键的部分。这种方法可以减小跟踪文件的大小，并使分析更容易。
- en: Spend some time exploring the different views available in the trace viewer.
    Each view provides insights into specific aspects of your program’s execution.
    Also, when analyzing the trace, look for unusual patterns or anomalies, such as
    goroutines that are blocked for a long time or excessive garbage collection pauses.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟踪查看器中花些时间探索不同的视图。每个视图都能为您提供对程序执行特定方面的洞察。在分析跟踪时，寻找不寻常的模式或异常，例如长时间阻塞的goroutines或过度的垃圾回收暂停。
- en: Ensure that the context containing the trace is passed to any downstream calls
    made during the request handling. This allows for a more comprehensive trace that
    includes the entire request life cycle.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在请求处理期间，将包含跟踪的上下文传递给任何下游调用。这允许进行更全面的跟踪，包括整个请求生命周期。
- en: When possible, use middleware for tracing. For more complex applications, consider
    implementing tracing as middleware in your HTTP server. This approach allows for
    more flexibility and reusability across different parts of your application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，使用中间件进行跟踪。对于更复杂的应用程序，考虑在您的HTTP服务器中实现跟踪作为中间件。这种方法可以在应用程序的不同部分提供更大的灵活性和可重用性。
- en: Reflecting on my own trials and tribulations with Golang’s tracing, I recall
    a project that was as bogged down as a luxury sedan in a mud wrestling pit. After
    hours of poring over trace outputs, I stumbled upon a revelation that was as profound
    as discovering your car keys in the refrigerator. It dawned on me that tracing,
    much like a skilled sommelier, could discern the subtle nuances between a fine
    performance and a disastrous bottleneck. In the end, the solution was as simple
    as rearranging some database calls, yet it underscored the nuanced sophistication
    of Golang’s tracing capabilities.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我使用Golang跟踪的种种尝试和挑战，我想起了一个项目，就像一辆豪华轿车陷入泥潭一样。经过数小时的仔细研究跟踪输出，我偶然发现了一个深刻的启示，就像在冰箱里找到你的车钥匙一样。我意识到，跟踪，就像一位技艺高超的品酒师一样，能够辨别出色表现和灾难性瓶颈之间的细微差别。最终，解决方案就像重新排列一些数据库调用那样简单，但它突显了Golang跟踪功能的微妙复杂性。
- en: Tracing is primarily used for performance analysis and debugging. It’s particularly
    useful for identifying concurrency issues, understanding system behavior under
    load, and pinpointing sources of latency in distributed systems. It offers a more
    granular view of program execution compared to logging. While logging records
    discrete events or states, tracing in Go can provide a continuous, detailed account
    of program execution, including system-level events.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪主要用于性能分析和调试。它特别有助于识别并发问题，了解系统在负载下的行为，以及确定分布式系统中的延迟来源。与记录相比，跟踪提供了更细粒度的程序执行视图。虽然记录记录离散的事件或状态，但Go中的跟踪可以提供连续、详细的程序执行记录，包括系统级事件。
- en: Logging versus tracing
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 记录与跟踪
- en: Also, there are performance considerations in both cases. Logging and tracing
    can impact the performance of a Go application, but the impact is generally more
    significant with tracing, especially when using execution tracing in a production
    environment. Developers need to balance the level of detail captured against the
    performance overhead.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，两种情况下都有性能考虑。记录和跟踪都可能影响Go应用程序的性能，但跟踪的影响通常更为显著，尤其是在生产环境中使用执行跟踪时。开发者需要在捕获的详细程度和性能开销之间进行权衡。
- en: To wrap it up, think of tracing in Golang like dissecting a complex piece of
    machinery. Without the right tools and knowledge, you’re just a monkey with a
    wrench. But arm yourself with Golang’s tracing package, and you transform into
    a master mechanic, tuning your application to purr like a kitten on a warm lap.
    Remember, the devil is in the details, and sometimes, those details are hidden
    deep within the traces of your code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，将Golang中的追踪想象成解剖一个复杂的机械装置。没有合适的工具和知识，你只是一个拿着扳手的猴子。但如果你配备了Golang的追踪包，你就能变成一个大师级机械师，将你的应用程序调整得像一只蜷缩在温暖的膝盖上打呼噜的小猫一样。记住，魔鬼藏在细节中，有时，这些细节隐藏在你的代码的深处。
- en: Distributed tracing
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式追踪
- en: Distributed tracing involves monitoring the complete journey of a request as
    it travels across various interconnected services in a distributed system. Imagine
    a complex e-commerce application with separate services for product search, shopping
    cart, payment processing, and order fulfillment. A single user request might trigger
    interactions with all these services.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式追踪涉及监控请求在分布式系统中穿越各种相互连接的服务时的完整旅程。想象一个复杂的电子商务应用程序，它有独立的产品搜索、购物车、支付处理和订单履行的服务。单个用户请求可能会触发与所有这些服务的交互。
- en: 'How does it work? You might ask yourself. There are four key concepts: unique
    identifier, propagation, spans, and collection and analysis.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，它是如何工作的？这里有四个关键概念：唯一标识符、传播、跨度以及收集和分析。
- en: A unique identifier (trace ID) is assigned to the initial request. This ID becomes
    the thread that ties together all subsequent logs and events related to that specific
    request.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为初始请求分配一个唯一标识符（追踪ID）。这个ID成为连接所有后续日志和事件的线索，这些日志和事件与该特定请求相关。
- en: The trace ID is then propagated across all services involved in handling the
    request. This can be done through headers in HTTP requests, messages in queues,
    or any mechanism suitable for the communication protocol between services.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪ID随后传播到处理请求的所有服务中。这可以通过HTTP请求中的头信息、队列中的消息或任何适合服务之间通信协议的机制来完成。
- en: Each service creates a “span” that captures information about its role in handling
    the request. This span might include details such as timestamps, service names,
    function calls, and any errors encountered.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务创建一个“跨度”，它捕获关于其在处理请求中角色的信息。这个跨度可能包括时间戳、服务名称、函数调用以及遇到的任何错误。
- en: The spans are collected by a central tracing system, which then stitches them
    together based on the trace ID. This provides a holistic view of the entire request
    flow, encompassing all the services involved.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 跨度是由一个中心追踪系统收集的，然后根据追踪ID将它们拼接在一起。这提供了一个对整个请求流的整体视图，包括所有涉及的服务。
- en: 'The main benefits of distributed tracing are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式追踪的主要好处如下：
- en: '**Enhanced observability**: Distributed tracing sheds light on how requests
    move through your system, revealing potential bottlenecks and inefficiencies'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的可观察性**：分布式追踪揭示了请求如何在您的系统中移动，揭示了潜在的瓶颈和低效。'
- en: '**Root cause analysis**: When errors occur, tracing helps pinpoint the exact
    service or component responsible, even if the error manifests itself much later
    in the request flow'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根本原因分析**：当发生错误时，追踪有助于确定负责该错误的确切服务或组件，即使错误在请求流中较晚出现。'
- en: '**Performance optimization**: By analyzing trace data, you can identify slow
    services or communication issues between services, enabling performance optimization
    efforts'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能优化**：通过分析追踪数据，您可以识别缓慢的服务或服务之间的通信问题，从而实现性能优化努力。'
- en: '**Debugging microservices**: Debugging complex interactions between microservices
    becomes significantly easier with the context provided by distributed tracing'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试微服务**：有了分布式追踪提供的上下文，调试微服务之间的复杂交互变得显著更容易。'
- en: Several open-source and commercial tools are available for implementing distributed
    tracing. Some popular options include Zipkin, Jaeger, Honeycomb, and Datadog.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种开源和商业工具可用于实现分布式追踪。一些流行的选项包括Zipkin、Jaeger、Honeycomb和Datadog。
- en: But what about the freedom to switch between observability tools and backend
    providers without requiring large changes to your application’s code? Later in
    this chapter, we’ll see there is a gap the OTel project is trying to fill.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在没有对应用程序代码进行大量更改的情况下，在可观察性工具和后端提供商之间切换的自由在哪里呢？在本章的后面，我们将看到OTel项目正在试图填补的差距。
- en: 'Let’s continue to expand our knowledge with the next pillar of telemetry: metrics.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过遥测的下一个支柱——指标——来扩展我们的知识。
- en: Metrics
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指标
- en: Nothing screams “I’ve made it as a programmer” quite like obsessing over performance
    data in a language that was designed to be as exciting as watching paint dry on
    a rainy day. But here we are, poised to dive into the thrilling world of Go metrics,
    armed with the enthusiasm of a sloth on tranquilizers. It’s a delightful journey
    through a labyrinth of numbers and charts, where the Minotaur you’re facing is
    your own code, mysteriously gobbling up resources in ways that make quantum physics
    seem straightforward by comparison.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么能像在一种被设计成像在雨天看油漆干涸一样令人兴奋的语言中痴迷于性能数据那样，大声宣告“我已经成为了一名程序员”。但在这里，我们正准备进入Go度量标准的激动人心的世界，带着一种被镇静剂麻痹的树懒的热情。这是一次愉快的旅程，穿越了一个数字和图表的迷宫，你面对的弥诺陶洛斯是你的代码，以一种使量子物理学看起来简单的方式神秘地消耗资源。
- en: Now, for those brave souls still with me and not deterred by the ominous shadows
    of impending doom, let’s get serious for a moment. Metrics in the context of Go
    are essential tools for understanding the behavior and performance of your applications.
    They provide insights into various aspects of your system, such as memory usage,
    CPU load, and goroutine counts. Go, with its minimalist charm and concurrency
    model, offers a plethora of opportunities for system programmers to shoot themselves
    in the foot, performance wise. Thankfully, it also provides band-aids in the form
    of built-in and third-party libraries designed to collect, report, and analyze
    these metrics. The Go runtime, for example, exposes a wealth of performance data
    through the `runtime` and `net/http/pprof` packages, allowing programmers to monitor
    their applications in real time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于那些仍然与我同行、没有被即将到来的厄运的阴影所吓倒的勇敢者，让我们暂时认真一下。在Go的语境中，度量标准是理解您应用程序行为和性能的必要工具。它们提供了对系统各个方面的洞察，例如内存使用、CPU负载和goroutine计数。Go以其简约的魅力和并发模型，为系统程序员提供了大量机会在性能上“自食其果”。幸运的是，它还提供了内置和第三方库的“绷带”，旨在收集、报告和分析这些度量标准。例如，Go运行时通过`runtime`和`net/http/pprof`包暴露了大量性能数据，允许程序员实时监控他们的应用程序。
- en: One of the more popular third-party libraries is Prometheus, with its Go client
    library offering a rich set of tools to define and collect metrics. It integrates
    seamlessly into Go applications, providing a robust solution for monitoring not
    just system-level metrics but also application-specific metrics that can help
    in diagnosing performance bottlenecks and understanding user behavior.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 更受欢迎的第三方库之一是Prometheus，其Go客户端库提供了一套丰富的工具来定义和收集度量标准。它无缝集成到Go应用程序中，为监控不仅限于系统级度量标准，还包括有助于诊断性能瓶颈和理解用户行为的特定于应用程序的度量标准提供了强大的解决方案。
- en: 'To give you a taste, let’s consider a simple example using Prometheus to collect
    HTTP request count in a Go web service:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给您一个味觉，让我们考虑一个简单的示例，使用Prometheus在Go网络服务中收集HTTP请求计数：
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This snippet uses the `prometheus/client_golang` library to interact with Prometheus.
    A counter metric `http_requests_processed` is used to track the number of HTTP
    requests, labeled by status code. The `/metrics` endpoint exposes metrics for
    Prometheus to scrape. Inside the HTTP handler, the counter metric is incremented
    with appropriate status code labels.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段使用`prometheus/client_golang`库与Prometheus交互。一个计数度量标准`http_requests_processed`用于跟踪HTTP请求的数量，按状态码标记。`/metrics`端点暴露了Prometheus抓取的度量标准。在HTTP处理程序内部，计数度量标准使用适当的状态码标记递增。
- en: Simplicity
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 简单性
- en: This is a basic example. Real-world applications would involve richer metrics
    and instrumentation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本示例。现实世界中的应用程序将涉及更丰富的度量标准和仪表。
- en: Let’s run our Prometheus server by following these steps.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤运行我们的Prometheus服务器。
- en: 'Create a Prometheus configuration file:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Prometheus配置文件：
- en: Create a new file and name it `prometheus.yml`
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新文件并命名为`prometheus.yml`
- en: 'Paste the following basic configuration into the file:'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下基本配置粘贴到文件中：
- en: '[PRE11]'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Pull the Prometheus Docker image:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取Prometheus Docker镜像：
- en: 'Open your terminal and run the following command to download the latest Prometheus
    Docker image:'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开您的终端并运行以下命令以下载最新的Prometheus Docker镜像：
- en: '[PRE12]'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the Prometheus container:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Prometheus容器：
- en: 'Use the following command to run Prometheus, mapping `prometheus.yml` to the
    container:'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令运行Prometheus，将`prometheus.yml`映射到容器：
- en: '[PRE13]'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Replace `<path_to_your_prometheus.yml>` with the actual path to your configuration
    file.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`<path_to_your_prometheus.yml>`替换为您配置文件的实际路径。
- en: 'Access the Prometheus web interface:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问Prometheus网络界面：
- en: Open your web browser and go to `http://localhost:9090`.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开您的网络浏览器并转到`http://localhost:9090`。
- en: You should now see the Prometheus user interface.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您现在应该看到 Prometheus 用户界面。
- en: 'Explore Prometheus:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索 Prometheus：
- en: In the expression browser (the `up` and click **Execute**. This should show
    you whether Prometheus itself is running.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表达式浏览器（点击“up”并点击**执行**。这应该会显示 Prometheus 本身是否正在运行。
- en: Explore other built-in metrics, experiment with the query language, and get
    a feel for Prometheus.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索其他内置指标，尝试查询语言，并感受 Prometheus 的使用。
- en: 'Now, we can execute our code and see the metrics. First, we need to save the
    code and build it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以执行我们的代码并查看指标。首先，我们需要保存代码并构建它：
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Explore the metrics:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 探索指标：
- en: '`http://localhost:8080/metrics`. You should see the raw Prometheus metrics
    output.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/metrics`. 您应该看到原始的 Prometheus 指标输出。'
- en: '`http://localhost:9090`), try queries such as the following:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:9090`），尝试以下查询：'
- en: '`http_requests_processed`: See the total number of requests, broken down by
    status codes'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http_requests_processed`: 查看按状态码分组的总请求数量'
- en: '`rate(http_requests_processed[1m])`: View the request rate over the last minute'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rate(http_requests_processed[1m])`: 查看过去一分钟的请求数量'
- en: We now can see our metrics, but what metrics can we use, and what metric should
    we use? Let’s explore this!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到我们的指标了，但我们能使用哪些指标，应该使用哪个指标呢？让我们来探讨这个问题！
- en: What metric should we use?
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们应该使用哪个指标？
- en: Choosing the right type of metric to monitor in your application is akin to
    selecting the appropriate tool for a job—use a hammer for nails, not for screws.
    In the world of monitoring and observability, the primary metric types—**Counter**,
    **Gauge**, **Histogram**, and **Summary**—each serve distinct purposes. Understanding
    these purposes is crucial to effectively measure and analyze your application’s
    behavior and performance.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中选择合适的指标类型进行监控，就像选择合适的工具来完成工作一样——用锤子敲钉子，而不是拧螺丝。在监控和可观察性的世界中，主要的指标类型——**计数器（Counter**）、**仪表（Gauge**）、**直方图（Histogram**）和**摘要（Summary**）——各自有不同的用途。理解这些用途对于有效地衡量和分析应用程序的行为和性能至关重要。
- en: Counters
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数器
- en: A Counter is a simple metric that only goes up (increments) over time and resets
    to zero on restarts. It’s perfect for tracking occurrences of events. Use a Counter
    when you want to count things, such as requests served, tasks completed, or errors
    that occurred. For example, counting the number of times a user performs a specific
    action on your site.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器是一种简单的指标，随着时间的推移只会增加（递增），并在重启时重置为零。它非常适合跟踪事件的发生。当您想计数事物时使用计数器，例如已服务的请求数、完成的任务数或发生的错误数。例如，统计用户在您的网站上执行特定动作的次数。
- en: 'Here are some use cases:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些用例：
- en: '**Event counting**: Perfect for counting occurrences of specific events. For
    instance, you could use a counter to track the number of user signups, tasks completed,
    or errors encountered.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件计数**：非常适合计数特定事件的次数。例如，您可以使用计数器来跟踪用户注册次数、完成任务数或遇到的错误数。'
- en: '**Rate measurement**: Although the counter itself only goes up, you can measure
    the rate of increase over time, making it suitable for understanding how frequently
    an event is happening, such as requests per second.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率测量**：尽管计数器本身只会增加，但您可以测量随时间增加的速率，这使得它适合了解事件发生的频率，例如每秒请求数。'
- en: Gauges
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仪表
- en: A Gauge is a metric that represents a single numerical value that can arbitrarily
    go up and down. It’s like a thermometer that measures the current temperature.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表是一种表示单个数值的指标，该数值可以任意上下波动。它就像一个测量当前温度的温度计。
- en: Use a Gauge for values that fluctuate over time, such as current memory usage,
    number of concurrent sessions, or the temperature of a machine. Gauges are great
    for monitoring resources where the current state at a specific point in time is
    more relevant than the rate of change.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仪表（Gauge）来表示随时间波动的数据，例如当前内存使用量、并发会话数量或机器的温度。仪表非常适合监控那些在特定时间点的当前状态比变化速率更相关的资源。
- en: 'Here are some use cases:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些用例：
- en: '**Resource levels**: Gauges are well suited for measuring quantities that can
    increase and decrease, such as the current memory usage, disk space remaining,
    or the number of active users'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源水平**：仪表非常适合测量可以增加和减少的数量，例如当前内存使用量、剩余磁盘空间或活跃用户数量'
- en: '**Sensor readings**: Any real-time measurement that fluctuates over time, such
    as temperature sensors, CPU load, or queue lengths'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传感器读数**：任何随时间波动的实时测量值，例如温度传感器、CPU负载或队列长度'
- en: Histograms
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直方图
- en: A Histogram samples observations (typically things such as request durations
    or response sizes) and counts them in configurable buckets. It also provides a
    sum of all observed values.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图采样观察值（通常是请求持续时间或响应大小等），并在可配置的桶中进行计数。它还提供了所有观察值的总和。
- en: Use a Histogram when you need to understand the distribution of a metric, not
    just its average. Histograms are ideal for tracking the latency of requests or
    the size of responses in your application because they allow you to see not just
    the average but also how the values are spread out, such as the 95th percentile
    latency.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要了解一个指标的分布，而不仅仅是平均值时，请使用直方图。直方图非常适合跟踪应用程序中请求的延迟或响应的大小，因为它们不仅允许你看到平均值，还可以看到值的分布情况，例如第95个百分位数的延迟。
- en: 'Here are some use cases:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些用例：
- en: '**Distribution measurement**: Histograms excel when you need to capture the
    distribution of metric values over time. This is crucial for understanding not
    just averages but the variability and outliers in your data.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布测量**：当需要捕捉指标值随时间变化的分布时，直方图表现卓越。这对于理解平均值、数据变异性和异常值至关重要。'
- en: '**Performance analysis**: Ideal for measuring request latencies or response
    sizes. Histograms help identify long-tail delays that might not affect the average
    much but significantly impact user experience.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能分析**：非常适合测量请求延迟或响应大小。直方图有助于识别可能不会对平均值产生太大影响但会显著影响用户体验的长尾延迟。'
- en: Summaries
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Like Histograms, Summaries also sample observations. However, they calculate
    sliding window quantiles (e.g., the 50th, 90th, and 99th percentiles) instead
    of providing buckets. Summaries can be more computation intensive than Histograms
    because they compute these quantiles on the fly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与直方图类似，摘要也会采样观察值。然而，它们计算滑动窗口的分位数（例如，第50、90和99个百分位数），而不是提供桶。由于它们在实时计算这些分位数，摘要可能比直方图计算量更大。
- en: Use a Summary when you need precise quantiles over a sliding time window, especially
    for metrics where long-term accuracy is less critical than recent trends. They’re
    particularly useful for tracking request durations and response sizes when you
    need to know the exact distribution dynamically.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在一个滑动时间窗口中获取精确的分位数，尤其是对于长期准确性不如近期趋势重要的指标时，请使用摘要。它们在跟踪请求持续时间和响应大小时特别有用，因为它们可以动态地显示确切的分布。
- en: 'Here are some use cases:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些用例：
- en: '**Dynamic quantiles**: When you need accurate quantiles in a sliding time window,
    summaries are the best choice. They provide a more detailed view of metric distributions,
    adjusting as new data comes in.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态分位数**：当你需要在滑动时间窗口中获取精确的分位数时，摘要是最优选择。它们提供了更详细的指标分布视图，并随着新数据的到来进行调整。'
- en: '**Recent trends analysis**: Suitable for scenarios where recent performance
    is more relevant than long-term averages, allowing you to respond to changes in
    patterns quickly.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**近期趋势分析**：适用于近期性能比长期平均值更相关的场景，允许你快速响应模式的变化。'
- en: Choosing the right metric
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择合适的指标
- en: 'The decision boils down to the nature of what you’re measuring and how you
    intend to use the data:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个决策取决于你测量的是什么以及你打算如何使用这些数据：
- en: Counting occurrences? Go with a Counter
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算发生次数？选择计数器（Counter）
- en: Measuring values that increase and decrease? A Gauge is your friend
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量增加和减少的值？仪表（Gauge）是你的朋友
- en: Need to understand distributions? Histograms shine here
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要理解分布？直方图在这里大放异彩
- en: Require dynamic quantiles over recent data? Summaries are the answer
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要最近数据的动态分位数？摘要就是答案
- en: Remember, the goal is not just to collect metrics but to derive actionable insights
    from them. Therefore, choosing the right type of metric is crucial for effective
    monitoring and analysis. It ensures you’re not just collecting data for the sake
    of it but are gathering information that can genuinely inform decisions about
    your application’s performance and design.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，目标不仅仅是收集指标，而是从中提取可操作的见解。因此，选择正确的指标类型对于有效的监控和分析至关重要。这确保了你不仅仅是为了收集数据而收集数据，而是在收集可以真正提供关于应用程序性能和设计决策信息的信息。
- en: To learn more about metrics and how to query them, please look at the Prometheus
    documentation ([https://prometheus.io/docs/concepts/metric_types/](https://prometheus.io/docs/concepts/metric_types/)).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于指标及其查询方法的信息，请参阅Prometheus文档（[https://prometheus.io/docs/concepts/metric_types/](https://prometheus.io/docs/concepts/metric_types/)）。
- en: In conclusion, metrics in Golang is like embarking on a grand adventure in a
    submarine. You’re under the surface, in the deep dark sea of code, navigating
    through the murky waters of performance. Your metrics are your sonar, pinging
    against potential issues and guiding you through the abyss to the promised land
    of efficient, scalable software. Remember, in the vast ocean of system programming,
    it’s not the size of the ship that matters, but the power of your metrics that
    charts the course to success.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Golang 中的指标就像是在潜艇上开始一场伟大的冒险。你身处水下，在代码的深暗海中，穿梭于性能的浑浊水域。你的指标就像声纳，对潜在问题进行探测，引导你穿越深渊，到达高效、可扩展软件的应许之地。记住，在系统编程的浩瀚海洋中，重要的是你的指标的力量，它为你规划成功的航线。
- en: The OTel project
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OTel 项目
- en: OTel is an open-source, vendor-neutral project under the **Cloud Native Computing
    Foundation** (**CNCF**). It provides a set of standards, APIs, and SDKs for instrumenting,
    generating, collecting, and exporting telemetry data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: OTel 是一个开源的、供应商中立的 Cloud Native Computing Foundation（**CNCF**）下的项目。它提供了一套标准、API
    和 SDK，用于仪器化、生成、收集和导出遥测数据。
- en: This data includes traces (the flow of requests through systems), metrics (measurements
    about system behavior), and logs (structured event records). Also, it aims to
    standardize how applications are instrumented, making it easier to adopt observability
    tools without vendor lock-in.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据包括跟踪（请求通过系统的流程）、指标（关于系统行为的测量）和日志（结构化事件记录）。此外，它旨在标准化应用程序的仪器化方式，使采用可观察性工具而无需供应商锁定变得更容易。
- en: 'When we look from the maturity perspective, Golang is one of the primary supported
    languages within OTel. Basically, it provides a comprehensive SDK with libraries
    for the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从成熟度的角度来看，Golang 是 OTel 内部主要支持的语言之一。基本上，它提供了一套全面的 SDK，包括以下库：
- en: '`go.opentelemetry.io/otel/trace`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go.opentelemetry.io/otel/trace`'
- en: '`go.opentelemetry.io/otel/metric`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go.opentelemetry.io/otel/metric`'
- en: '`go.opentelemetry.io/otel/propagation`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go.opentelemetry.io/otel/propagation`'
- en: OTel’s Go SDK integrates seamlessly with popular libraries and frameworks, making
    adding instrumentation to your existing Golang applications easy.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: OTel 的 Go SDK 与流行的库和框架无缝集成，使您能够轻松地将仪器化添加到现有的 Golang 应用程序中。
- en: Also, the SDK supports various exporters, enabling you to send your telemetry
    data to different analysis backends. An exhaustive list of vendors can be found
    on the OTel website ([https://opentelemetry.io/ecosystem/vendors/](https://opentelemetry.io/ecosystem/vendors/)).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，SDK 支持各种导出器，使您能够将您的遥测数据发送到不同的分析后端。可以在 OTel 网站上找到详尽的供应商列表（[https://opentelemetry.io/ecosystem/vendors/](https://opentelemetry.io/ecosystem/vendors/))。
- en: 'The major benefits of adopting OTel for Go projects are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 采用 OTel 为 Go 项目带来的主要好处如下：
- en: '**Vendor neutrality**: You have the freedom to switch between observability
    tools and backend providers without requiring large changes to your application’s
    code'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商中立性**：你可以自由地在可观察性工具和后端提供商之间切换，而无需对应用程序的代码进行大量更改'
- en: '**Streamlined instrumentation**: OTel makes instrumenting your Golang services
    easier and less tedious'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化了仪器化**：OTel 使您更容易且不那么繁琐地对 Golang 服务进行仪器化'
- en: '**Unified data format**: It provides standardized data formats, ensuring your
    trace and metric data can be understood by multiple platforms and tools'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一的数据格式**：它提供了标准化的数据格式，确保您的跟踪和指标数据可以被多个平台和工具理解'
- en: '**Strong community**: The Golang SDK is backed by an active community, offering
    support, and contributing to continuous improvement'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强大的社区**：Golang SDK 由一个活跃的社区支持，提供支持和持续改进'
- en: As OTel gains even wider adoption, it’s likely to become the de facto standard
    for observability in Golang applications. This standardization benefits the entire
    ecosystem by promoting vendor neutrality, portability, and easier adoption of
    best practices.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 OTel 获得更广泛的采用，它很可能会成为 Golang 应用程序中可观察性的事实标准。这种标准化通过促进供应商中立性、可移植性和更容易采用最佳实践，为整个生态系统带来好处。
- en: OTel
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OTel
- en: So, you think adding OTel to your program is like snapping some fancy Lego bricks
    together, huh? A bit of configuration magic, a sprinkle of auto-instrumentation,
    and voila – instant observability! Well, let’s just say you’re in for a surprise,
    my friend.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你认为将 OTel 添加到你的程序就像拼接一些花哨的乐高积木一样，对吧？一点配置魔法，一点自动仪器化， voila – 瞬间可观察！好吧，让我们这么说，你朋友，你将大吃一惊。
- en: Now, before you toss your keyboard in frustration, let’s break down what OTel
    is. Think of it as a universal toolbox for collecting telemetry data from your
    application. OTel, in turn, is like your application’s internal monologue – traces
    of its execution, performance metrics, logs, and other whispers of its inner workings.
    OTel lets you shine that light into the darkest corners of your code base, revealing
    where things slow down, where errors sprout, and how your users interact with
    your creation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您因挫败而扔掉键盘之前，让我们分析一下OTel是什么。把它想象成收集应用程序遥测数据的通用工具箱。OTel反过来就像您应用程序的内心独白——其执行的跟踪、性能指标、日志以及其他内部工作的低语。OTel让您能够将光线照进代码库最黑暗的角落，揭示事物变慢的地方、错误滋生的地方以及用户如何与您的创作互动。
- en: Logs are not ready yet
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 日志尚未准备好
- en: 'The Logs SDK for Go is in development and we can follow the status on the official
    status page for the SDK: [https://opentelemetry.io/status/](https://opentelemetry.io/status/).
    Therefore, the following examples will use the uber/zap library for logging.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的Logs SDK正在开发中，我们可以通过官方状态页面跟踪SDK的状态：[https://opentelemetry.io/status/](https://opentelemetry.io/status/)。因此，以下示例将使用uber/zap库进行日志记录。
- en: OTel itself is a set of specifications, APIs, and SDKs. It doesn’t magically
    make your app observable. You’ll need to strategically place sensors (think of
    them as fancy probes) throughout your code. This is where the “fun” of manual
    instrumentation comes in, along with deciding what data to collect in the first
    place.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: OTel本身是一套规范、API和SDK。它不会神奇地使您的应用程序可观察。您需要在代码中战略性地放置传感器（想想看它们就像高级探测器），这便是手动仪器化的“乐趣”所在，同时还需要决定最初要收集哪些数据。
- en: 'Let’s create a program that uses Otel from scratch. The following are the steps:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头开始创建一个使用Otel的程序。以下步骤如下：
- en: '**Create your Go project**: Create a new directory for your project and initialize
    a Go module:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建您的Go项目**：为您的项目创建一个新的目录并初始化一个Go模块：'
- en: '[PRE15]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Install dependencies**: Install the necessary packages for OTel and zap logging:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装依赖项**：安装OTel和zap日志记录所需的必要包：'
- en: '[PRE16]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`main.go` file in your project directory. First, let’s set up zap for advanced
    logging:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目目录中的`main.go`文件。首先，让我们为高级日志记录设置zap：
- en: '[PRE17]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code snippet initializes a production-grade logger with zap, which provides
    structured logging capabilities.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码片段使用zap初始化了一个生产级别的日志记录器，它提供了结构化日志记录功能。
- en: '**Configure OTel tracing**: Next, add OTel tracing to your application, sending
    data to the OTel Collector:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置OTel跟踪**：接下来，将OTel跟踪添加到您的应用程序中，并将数据发送到OTel收集器：'
- en: '[PRE18]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This section adds tracing, configured to export trace data via the **OTel**
    **Protocol** (**OTLP**).
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节添加了配置为通过**OTel** **协议**（**OTLP**）导出跟踪数据的跟踪。
- en: '**Add a sample HTTP handler**: For demonstration, add a simple HTTP handler
    that emits traces and logs for each request:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个示例HTTP处理器**：为了演示，添加一个简单的HTTP处理器，它会为每个请求发出跟踪和日志：'
- en: '[PRE19]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`docker-compose` with the file located in the `ch11/otel/` directory in your
    terminal:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，使用`docker-compose`与位于`ch11/otel/`目录中的文件：
- en: '[PRE20]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The collector should be set up to receive traces on the default OTLP port and
    route them to your tracing backend.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 收集器应设置为在默认的OTLP端口接收跟踪，并将它们路由到您的跟踪后端。
- en: 'Run your application:'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行您的应用程序：
- en: '[PRE21]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`http://localhost:8080/`) from your browser or using `curl`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器或`curl`从`http://localhost:8080/`)访问：
- en: '[PRE22]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Voilà*! We made an application leveraging OTel’s lock-in-free characteristics!'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*Voilà*！我们创建了一个利用OTel无锁定特性的应用程序！'
- en: Back in my day, we used to debug systems with print statements and the occasional
    panicked curse. OTel is a far more civilized approach. Think of it like building
    your own intricate network of informants within your code. They’ll report back
    every detail, letting you pinpoint problems not just faster, but sometimes even
    before they wreak havoc.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我那个时代，我们使用打印语句和偶尔的恐慌咒骂来调试系统。OTel是一种更为文明的方法。把它想象成在您的代码中建立自己的复杂情报网络。他们将会报告每一个细节，让您能够更快地定位问题，有时甚至可以在它们造成破坏之前。
- en: Isn’t that better than a good ol’ debugging brawl? Now, it’s time to wrap up.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这难道不是比传统的调试战斗更好吗？现在，是时候总结一下了。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we conclude this chapter on telemetry in Go, we’ve journeyed through the
    essential practices and tools that illuminate the inner mechanics of Go applications,
    enhancing their observability. This exploration began with an in-depth look at
    logging, where we learned to transcend essential log messages, adopting structured
    logging for its clarity and ease of analysis. We then navigated the complex yet
    crucial world of tracing, uncovering the intricate execution paths of our applications
    to identify and resolve performance bottlenecks. Also, we ventured into metrics,
    where quantitative data measurement enabled us to monitor and tune our applications
    for optimal performance. Lastly, we combined all the knowledge in a vendor-free
    solution backed by OTel.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章关于 Go 中遥测的结束，我们已探索了照亮 Go 应用内部机制的基本实践和工具，增强了它们的可观察性。这次探索从对日志的深入分析开始，我们学会了超越基本的日志消息，采用结构化日志以提高其清晰度和易于分析性。然后，我们进入了复杂但至关重要的跟踪领域，揭示了应用程序的复杂执行路径，以识别和解决性能瓶颈。此外，我们还涉足了度量领域，定量数据测量使我们能够监控和调整应用程序以实现最佳性能。最后，我们结合了所有知识，在一个无供应商解决方案中，由
    OTel 支持这些知识。
- en: In the next chapter, we’ll start to look at how to distribute our apps.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探讨如何分发我们的应用程序。
