- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting to Grips with Test-Driven Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握测试驱动开发
- en: Programs and software have never been more complex than they are today. From
    my experience, the typical tech startup setup involves deployment to the cloud,
    distributed databases, and a variety of software integrations from the very beginning
    of the project. As we use software and consume data at unprecedented rates, the
    expectation of high availability and scalability has become standard for all the
    services we interact with.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 程序和软件从未像今天这样复杂。根据我的经验，典型的科技初创企业设置从项目一开始就涉及云部署、分布式数据库以及各种软件集成。随着我们以前所未有的速度使用软件和消耗数据，对高可用性和可扩展性的期望已成为我们与之互动的所有服务的标准。
- en: So, why should we care about testing when we are so busy delivering complex
    functionality in fast-paced, high-growth environments? Simply put, to verify and
    prove that the code you write behaves and performs to the expectations and requirements
    of your project. This is important to you as the software professional, as well
    as to your team and product manager.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么在我们忙于在快节奏、高增长的环境中交付复杂功能时，我们还应该关心测试呢？简单来说，是为了验证和证明您编写的代码符合项目的期望和要求。这对您作为软件专业人士来说很重要，对您的团队和产品经理也是如此。
- en: In this chapter, we’ll look at the **Agile** technique of **Test-Driven Development**
    (**TDD**) and how we can use it to verify production code. TDD puts test writing
    before implementation, ensuring that test scripts cover and change with requirements.
    Its techniques allow us to deliver quality, well-tested, and maintainable code.
    The task of software testing is a necessity for all programmers, and TDD seamlessly
    incorporates test writing into the code delivery process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨敏捷技术中的**测试驱动开发**（**TDD**）以及我们如何使用它来验证生产代码。TDD 将编写测试放在实现之前，确保测试脚本覆盖并随着需求的变化而变化。其技术使我们能够交付质量高、经过良好测试且易于维护的代码。软件测试的任务对所有程序员来说都是必要的，TDD
    无缝地将测试编写纳入代码交付过程。
- en: This chapter begins our exploration into the world of testing. It will give
    you the required understanding of TDD and its main techniques. Defining and setting
    these fundamentals firmly in our minds will set the stage for the later implementation
    of automated testing in Go.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将开启我们对测试世界的探索。它将为您提供对 TDD 及其主要技术的必要理解。在脑海中牢固定义和设置这些基础将为我们后来在 Go 中实施自动化测试奠定基础。
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: The world and fundamentals of TDD
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD 的世界和基础
- en: The benefits and use of TDD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD 的益处和用途
- en: Alternatives to TDD
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD 的替代方案
- en: Test metrics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试指标
- en: Exploring the world of TDD
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 TDD 的世界
- en: In a nutshell, TDD is a technique that allows us to write automated tests with
    short feedback loops. It is an iterative process that incorporates testing into
    the software development process, allowing developers to use the same techniques
    for writing their tests as they use for writing production code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，TDD 是一种允许我们通过短反馈循环编写自动化测试的技术。它是一个将测试纳入软件开发过程的迭代过程，使开发者能够使用与编写生产代码相同的技巧来编写他们的测试。
- en: TDD was created as an Agile working practice, as it allows teams to deliver
    code in an iterative process, consisting of writing functional code, verifying
    new code with tests, and iteratively refactoring new code, if required.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 是作为一种敏捷工作实践被创建的，因为它允许团队以迭代过程交付代码，这个过程包括编写功能代码、通过测试验证新代码，并在需要时迭代重构新代码。
- en: Introduction to the Agile methodology
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瀑布方法的介绍
- en: 'This precursor to the Agile movement was the **waterfall methodology**, which
    was the most popular project management technique. This process involves delivering
    software projects in stages, with work starting on each stage once the stage before
    it is completed, just like water flows downstream. *Figure 1**.1* shows the five
    stages of the waterfall methodology:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为敏捷运动的先导，是**瀑布方法**，这是最受欢迎的项目管理技术。这个过程涉及分阶段交付软件项目，每个阶段的工作在上一阶段完成后才开始，就像水流顺流而下。*图
    1.1* 展示了瀑布方法的五个阶段：
- en: '![Figure 1.1 – The five stages of the waterfall methodology ](img/Figure_1.1_B18371.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 瀑布方法的五个阶段](img/Figure_1.1_B18371.jpg)'
- en: Figure 1.1 – The five stages of the waterfall methodology
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 瀑布方法的五个阶段
- en: 'Intuition from manufacturing and construction projects might suggest that it
    is natural to divide the software delivery process into sequential phases, gathering
    and formulating all requirements at the start of the project. However, this way
    of working poses three difficulties when used to deliver large software projects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从制造和建设项目中获得的直觉可能表明，将软件交付过程分为顺序阶段，在项目开始时收集和制定所有需求是自然的。然而，当用于交付大型软件项目时，这种方式存在三个困难：
- en: Changing the course of the project or requirements is difficult. A working solution
    is only available at the end of the process, requiring verification of a large
    deliverable. Testing an entire project is much more difficult than testing small
    deliverables.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变项目的方向或需求是困难的。只有在过程结束时才能获得一个可行的解决方案，需要验证大量的交付成果。测试整个项目比测试小交付成果要困难得多。
- en: Customers need to decide all of their requirements in detail at the beginning
    of the project. The waterfall allows for minimal customer involvement, as they
    are only consulted in the requirements and verification phases.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户需要在项目开始时详细决定所有需求。水晶模型允许客户参与度最低，因为他们只在需求和验证阶段被咨询。
- en: The process requires detailed documentation, which specifies both requirements
    and the software design approach. Crucially, the project documentation includes
    timelines and estimates that the clients need to approve prior to project initiation.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该过程需要详细的文档，其中指定了需求和软件开发方法。关键的是，项目文档包括客户在项目启动前需要批准的时间表和估计。
- en: The waterfall model is all about planning work
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 水晶模型主要关注工作计划
- en: Project management with the waterfall methodology allows you to plan your project
    in well-defined, linear phases. This approach is intuitive and suitable for projects
    with clearly defined goals and boundaries. In practice, however, the waterfall
    model lacks the flexibility and iterative approach required for delivering complex
    software projects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用瀑布式项目管理方法可以使您在定义良好、线性的阶段中规划项目。这种方法直观，适用于目标明确、边界清晰的项目。然而，在实践中，水晶模型缺乏交付复杂软件项目所需的灵活性和迭代方法。
- en: A better way of working named **Agile** emerged, which could address the challenges
    of the waterfall methodology. TDD relies on the principles of the Agile methodology.
    The literature on Agile working practices is extensive, so we won’t be looking
    at Agile in detail, but a brief understanding of the origins of TDD will allow
    us to understand its approach and get into its mindset.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一种名为**敏捷**的更好的工作方式出现，可以解决水晶模型的挑战。TDD依赖于敏捷方法的原则。关于敏捷工作实践的文献非常丰富，所以我们不会详细探讨敏捷，但简要了解TDD的起源将使我们能够理解其方法和进入其心态。
- en: '*Agile software development* is an umbrella term for multiple code delivery
    and project planning practices such as **SCRUM**, **Kanban**, **Extreme Programming**
    (**XP**), and TDD.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**敏捷软件开发**是一个涵盖多个代码交付和项目规划实践的总称，例如**Scrum**、**看板**、**极限编程**（**XP**）和TDD。'
- en: As implied by its name, it is all about the ability to respond and adapt to
    change. One of the main disadvantages of the waterfall way of working was its
    inflexibility, and Agile was designed to address this issue.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所暗示的，它主要关于应对和适应变化的能力。瀑布式工作方式的主要缺点是其缺乏灵活性，而敏捷正是为了解决这一问题而设计的。
- en: The **Agile manifesto** was written and signed by 17 software engineering leaders
    and pioneers in 2001\. It outlines the 4 core values and 12 central principles
    of Agile. The manifesto is available freely at agilemanifesto.org.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**敏捷宣言**于2001年由17位软件工程领导者和先驱撰写并签署。它概述了敏捷的4个核心价值和12个基本原则。宣言可在agilemanifesto.org免费获取。'
- en: 'The four core Agile values highlight the spirit of the movement:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 四个核心敏捷价值观突出了运动的精髓：
- en: '**Individuals and interactions over processes and tools**: This means that
    the team involved in the delivery of the project is more important than their
    technical tools and processes.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个人和交互胜过流程和工具**：这意味着参与项目交付的团队比他们的技术工具和流程更重要。'
- en: '**Working software over comprehensive documentation**: This means that delivering
    working functionality to customers is the number one priority. While documentation
    is important, teams should always focus on consistently delivering value.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作软件胜过全面文档**：这意味着向客户提供工作功能是首要任务。虽然文档很重要，但团队应始终专注于持续交付价值。'
- en: '**Customer collaboration over contract negotiation**: This means that customers
    should be involved in a feedback loop over the lifetime of the project, ensuring
    that the project and work continue to deliver value and satisfy their needs and
    requirements.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户协作而非合同谈判**：这意味着客户应该在项目整个生命周期中参与反馈循环，确保项目和工作的持续交付价值，并满足他们的需求和期望。'
- en: '**Responding to change over following a plan**: This means that teams should
    be responsive to change over following a predefined plan or roadmap. The team
    should be able to pivot and change direction whenever required.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应变化而非遵循计划**：这意味着团队应该对预定义的计划或路线图的变化做出响应。团队应该能够在需要时随时调整方向。'
- en: Agile is all about people
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷一切都是关于人
- en: The Agile methodology is not a prescriptive list of practices. It is all about
    teams working together to overcome uncertainty and change during the life cycle
    of a project. Agile teams are interdisciplinary, consisting of engineers, software
    testing professionals, product managers, and more. This ensures that the team
    members with a variety of skills collaborate to deliver the software project as
    a whole.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷方法不是一系列规定性的实践清单。它更多的是关于团队在项目生命周期中共同克服不确定性和变化。敏捷团队是跨学科的，包括工程师、软件测试专业人士、产品经理等等。这确保了具有各种技能的团队成员能够协作，共同交付整个软件项目。
- en: Unlike the waterfall model, the stages of the Agile software delivery methodology
    repeat, focusing on delivering software in small increments or iterations, as
    opposed to the big deliverables of waterfall. In Agile nomenclature, these iterations
    are called **sprints**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与瀑布模型不同，敏捷软件交付方法的各个阶段是重复的，专注于以小批量或迭代的方式交付软件，而不是瀑布模型的大规模交付。在敏捷术语中，这些迭代被称为**冲刺**。
- en: '*Figure 1**.2* depicts the stages of Agile project delivery:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1**.2* 展示了敏捷项目交付的各个阶段：'
- en: '![Figure 1.2 – The stages of Agile software delivery ](img/Figure_1.2_B18371.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 敏捷软件交付的各个阶段](img/Figure_1.2_B18371.jpg)'
- en: Figure 1.2 – The stages of Agile software delivery
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 敏捷软件交付的各个阶段
- en: 'Let’s look at the cyclical stages of Agile software delivery:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看敏捷软件交付的循环阶段：
- en: We begin with the **Plan** phase. The product owner discusses project requirements
    that will be delivered in the current sprint with key stakeholders. The outcome
    of this phase is the prioritized list of client requirements that will be implemented
    in this sprint.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从**计划**阶段开始。产品负责人与关键利益相关者讨论将在当前冲刺中交付的项目需求。本阶段的结果是优先级排序的客户需求列表，这些需求将在本冲刺中实施。
- en: Once the requirements and scope of the project are settled, the **Design** phase
    begins. This phase involves both technical architecture design, as well as UI/UX
    design. This phase builds on the requirements from the **Plan** phase.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦确定项目的需求和范围，**设计**阶段就开始了。这个阶段涉及技术架构设计和 UI/UX 设计。这个阶段建立在**计划**阶段的要求之上。
- en: Next, the **Implement** phase begins. The designs are used as the guide from
    which we implement the scoped functionality. Since the sprint is short, if any
    discrepancies are found during implementation, then the team can easily move to
    earlier phases.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入**实施**阶段。设计被用作指导，根据它实施范围功能。由于冲刺时间短，如果在实施过程中发现任何差异，团队可以轻松地回到早期阶段。
- en: As soon as a deliverable is complete, the **Test** phase begins. The **Test**
    phase runs almost concurrently with the **Implement** phase, as test specifications
    can be written as soon as the **Design** phase is completed. A deliverable cannot
    be considered finished until its tests have passed. Work can move back and forth
    between the **Implement** and **Test** phases, as the engineers fix any identified
    defects.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦可交付成果完成，**测试**阶段就开始了。**测试**阶段几乎与**实施**阶段并行进行，因为测试规范可以在**设计**阶段完成后立即编写。只有当测试通过后，才能认为可交付成果已完成。工作可以在**实施**和**测试**阶段之间来回移动，工程师修复任何已识别的缺陷。
- en: Finally, once all testing and implementation are completed successfully, the
    **Release** phase begins. This phase completes any client-facing documentation
    or release notes. At the end of this phase, the sprint is considered closed. A
    new sprint can begin, following the same cycle.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一旦所有测试和实施都成功完成，**发布**阶段就开始了。这个阶段完成任何面向客户的文档或发布说明。本阶段结束时，冲刺被认为是关闭的。可以开始一个新的冲刺，遵循相同的周期。
- en: The customer gets a new deliverable at the end of each sprint, enabling them
    to see whether the product still suits their requirements and inform changes for
    future sprints. The deliverable of each sprint is tested before it is released,
    ensuring that later sprints do not break existing functionality and deliver new
    functionality. The scope and effort of the testing performed are limited to exercising
    the functionality developed during the sprint.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 客户在每个冲刺结束时获得一个新的可交付成果，使他们能够看到产品是否仍然符合他们的要求，并为未来的冲刺提供变更信息。每个冲刺的可交付成果在发布之前都会进行测试，以确保后续的冲刺不会破坏现有功能并交付新功能。测试的范围和努力仅限于在冲刺期间开发的功能。
- en: One of the signatories of the Agile manifesto was software engineer Kent Beck.
    He is credited with having rediscovered and formalized the methodology of TDD.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷宣言的签署者之一是软件工程师肯特·贝克。他被认为重新发现并正式化了TDD（测试驱动开发）的方法论。
- en: Since then, Agile has been highly successful for many teams, becoming an industry
    standard because it enables them to verify functionality as it is being delivered.
    It combines testing with software delivery and refactoring, removing the separation
    between the code writing and testing process, and shortening the feedback loop
    between the engineering team and the customer requirements. This shorter loop
    is the principle that gives flexibility to Agile.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，敏捷对许多团队来说都取得了高度成功，成为行业标准，因为它使团队能够在功能交付时验证功能。它将测试与软件交付和重构相结合，消除了代码编写和测试过程之间的分离，缩短了工程团队和客户需求之间的反馈循环。这个更短的循环是赋予敏捷灵活性的原则。
- en: We will focus on learning how to leverage its process and techniques in our
    own **Go** projects throughout the chapters of this book.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的章节中学习如何利用其流程和技术在我们的**Go**项目中。
- en: Types of automated tests
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试的类型
- en: '**Automated testing** suites are tests that involve tools and frameworks to
    verify the behavior of software systems. They provide a repeatable way of performing
    the verification of system requirements. They are the norm for Agile teams, who
    must test their systems after each sprint and release to ensure that new functionality
    is shipped without disrupting old/existing functionality.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动化测试**套件是涉及工具和框架以验证软件系统行为的测试。它们提供了一种可重复的验证系统需求的方法。它们是敏捷团队的标准，因为敏捷团队必须在每个冲刺和发布后测试他们的系统，以确保新功能在没有干扰旧/现有功能的情况下交付。'
- en: 'All automated tests define their inputs and expected outputs according to the
    requirements of the system under test. We will divide them into several types
    of tests according to three criteria:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有自动化测试都根据被测试系统的需求定义它们的输入和预期输出。我们将根据三个标准将它们分为几种测试类型：
- en: The amount of knowledge they have of the system
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们对系统的知识量
- en: The type of requirement they verify
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们验证的要求类型
- en: The scope of the functionality they cover
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们覆盖的功能范围
- en: Each test we will study will be described according to these three traits.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要研究的每个测试都将根据这三个特征进行描述。
- en: System knowledge
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统知识
- en: 'As you can see in *Figure 1**.3*, automated tests can be divided into three
    categories according to how much internal knowledge they have of the system they
    test:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*图1**.3*中可以看到，根据它们对所测试系统的内部知识量，自动化测试可以分为三类：
- en: '![Figure 1.3 – Types of tests according to system knowledge ](img/Figure_1.3_B18371.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 根据系统知识类型的测试](img/Figure_1.3_B18371.png)'
- en: Figure 1.3 – Types of tests according to system knowledge
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 根据系统知识类型的测试
- en: 'Let’s explore the three categories of tests further:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨测试的三个类别：
- en: '**Black box tests** are run from the perspective of the user. The internals
    of the system are treated as unknown by the test writer, as they would be to a
    user. Tests and expected outputs are formulated according to the requirement they
    verify. Black box tests tend not to be brittle if the internals of the system
    change.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑盒测试**是从用户的角度运行的。测试编写者将系统的内部视为未知，就像用户一样。测试和预期输出是根据它们验证的要求制定的。如果系统的内部发生变化，黑盒测试通常不会很脆弱。'
- en: '**White box tests** are run from the perspective of the developer. The internals
    of the system are fully known to the test writer, most likely a developer. These
    tests can be more detailed and potentially uncover hidden errors that black box
    testing cannot discover. White box tests are often brittle if the internals of
    the system change.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**白盒测试**是从开发者的角度进行的。测试编写者，很可能是开发者，对系统的内部结构完全了解。这些测试可以更加详细，并且有可能发现黑盒测试无法发现的隐藏错误。如果系统的内部结构发生变化，白盒测试通常会变得脆弱。'
- en: '**Gray box tests** are a mixture of black box and white box tests. The internals
    of the system are partially known to the test writer, as they would be to a specialist
    or privileged user. These tests can verify more advanced use cases and requirements
    than black box tests (for example security or certain non-functional requirements)
    and are usually more time-consuming to write and run as well.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灰盒测试**是黑盒测试和白盒测试的混合体。测试编写者对系统的内部结构部分了解，就像专家或特权用户一样。这些测试可以验证比黑盒测试更高级的使用案例和要求（例如安全或某些非功能要求），并且通常编写和运行的时间更长。'
- en: Requirement types
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需求类型
- en: In general, we should provide tests that verify both the functionality and usability
    of a system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们应该提供验证系统功能和可用性的测试。
- en: For example, we could have all the correct functionality on a page, but if it
    takes 5+ seconds to load, users will abandon it. In this case, the system is functional,
    but it does not satisfy your customers’ needs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在页面上拥有所有正确的功能，但如果它需要5+秒才能加载，用户将会放弃它。在这种情况下，系统是功能性的，但它并不满足客户的需求。
- en: 'We can further divide our automated tests into two categories, based on the
    type of requirement that they verify:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据它们验证的要求类型进一步将我们的自动化测试分为两类：
- en: '**Functional tests**: These tests cover the functionality of the system under
    test added during the sprint, with functional tests from prior sprints ensuring
    that there are no regressions in functionality in later sprints. These kinds of
    tests are usually black box tests, as these tests should be written and run according
    to the functionality that a typical user has access to.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：这些测试覆盖了在冲刺期间添加到待测系统中的功能，之前冲刺的功能测试确保后续冲刺中没有功能回归。这类测试通常是黑盒测试，因为这些测试应该根据典型用户能够访问的功能来编写和运行。'
- en: '**Non-functional tests**: These tests cover all the aspects of the system that
    are not covered by functional requirements but affect the user experience and
    functioning of the system. These tests cover aspects such as performance, usability,
    and security aspects. These kinds of tests are usually white-box tests, as they
    usually need to be formulated according to implementation details.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能测试**：这些测试覆盖了系统所有非功能要求但影响用户体验和系统功能的方面。这些测试包括性能、可用性和安全性等方面。这类测试通常是白盒测试，因为它们通常需要根据实现细节来制定。'
- en: Correctness and usability testing
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正确性和可用性测试
- en: Tests that verify the correctness of the system are known as **functional tests**,
    while tests that verify the usability and performance of the system are known
    as **non-functional tests**. Common non-functional tests are performance tests,
    load tests, and security tests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 验证系统正确性的测试被称为**功能测试**，而验证系统可用性和性能的测试被称为**非功能测试**。常见的非功能测试包括性能测试、负载测试和安全测试。
- en: The testing pyramid
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: An important concept of testing in Agile is **the testing pyramid**. It lays
    out the types of automated tests that should be included in the **automated testing
    suites** of software systems. It provides guidance on the sequence and priority
    of each type of test to perform in order to ensure that new functionality is shipped
    with a proportionate amount of testing effort and without disrupting old/existing
    functionality.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷测试中，一个重要的概念是**测试金字塔**。它概述了应该包含在软件系统**自动化测试套件**中的自动化测试类型。它提供了关于执行每种类型测试的顺序和优先级的指导，以确保新功能以适当的测试努力交付，并且不会破坏旧/现有功能。
- en: '*Figure 1**.4* presents the testing pyramid with its three types of tests:
    unit tests, integration tests, and end-to-end tests:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1*.4展示了包含其三种测试类型的测试金字塔：单元测试、集成测试和端到端测试：'
- en: '![Figure 1.4 – The testing pyramid and its components ](img/Figure_1.4_B18371.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 测试金字塔及其组件](img/Figure_1.4_B18371.jpg)'
- en: Figure 1.4 – The testing pyramid and its components
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 测试金字塔及其组件
- en: Each type of test can then be further described according to the three established
    traits of system knowledge, requirement type, and testing scope.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每种测试类型都可以根据系统知识、需求类型和测试范围这三个已确立的特性进一步描述。
- en: Unit tests
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试
- en: At the bottom of the testing pyramid, we have **unit tests**. They are presented
    at the bottom because they are the most numerous. They have a small testing scope,
    covering the functionality of individual components under a variety of conditions.
    Good unit tests should be tested in isolation from other components so that we
    can fully control the test environment and setup.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试金字塔的底部，我们有**单元测试**。它们位于底部是因为它们的数量最多。它们的测试范围较小，覆盖了在多种条件下单个组件的功能。好的单元测试应该与其他组件隔离测试，这样我们就可以完全控制测试环境和设置。
- en: Since the number of unit tests increases as new features are added to the code,
    they need to be robust and fast to execute. Typically, test suites are run with
    each code change, so they need to provide feedback to engineers quickly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 随着代码中新功能的增加，单元测试的数量也在增加，因此它们需要健壮且执行速度快。通常，每次代码更改都会运行测试套件，因此它们需要快速为工程师提供反馈。
- en: '**Unit tests** have been traditionally thought of as **white-box tests** since
    they are typically written by developers who know all the implementation details
    of the component. However, Go unit tests usually only test the exported/public
    functionality of the package. This brings them closer to **gray-box tests**.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**传统上被认为是**白盒测试**，因为它们通常由了解组件所有实现细节的开发者编写。然而，Go语言的单元测试通常只测试包的导出/公开功能，这使得它们更接近**灰盒测试**。'
- en: We will explore unit tests further in [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035),
    *Unit* *Testing Essentials*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第2章*](B18371_02.xhtml#_idTextAnchor035)中进一步探讨单元测试，*单元测试基础*。
- en: Integration tests
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集成测试
- en: In the middle of the testing pyramid, we have **integration tests**. They are
    an essential part of the pyramid, but they should not be as numerous and should
    not be run as often as **unit tests**, which are at the bottom of the pyramid.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试金字塔的中间，我们有**集成测试**。它们是金字塔的必要组成部分，但它们的数量不应过多，也不应像金字塔底部的**单元测试**那样频繁运行。
- en: Unit tests verify that a single piece of functionality is working correctly,
    while integration tests extend the scope and test the communication between multiple
    components. These components can be external or internal to the system – a database,
    an external API, or another microservice in the system. Often, integration tests
    run in dedicated environments, which allows us to separate production and test
    data as well as reduce costs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试验证单个功能模块是否正确运行，而集成测试则扩展了测试范围，测试多个组件之间的通信。这些组件可以是系统外部的，也可以是系统内部的——比如数据库、外部API或系统中的另一个微服务。通常，集成测试在专用环境中运行，这使我们能够将生产数据和测试数据分开，同时降低成本。
- en: '**Integration tests** could be **black-box tests** or **gray-box tests**. If
    the tests cover external APIs and customer-facing functionality, they can be categorized
    as **black-box tests**, while more specialized security or performance tests would
    be considered **gray-box tests**.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**可以是**黑盒测试**或**灰盒测试**。如果测试覆盖外部API和面向客户的函数，它们可以归类为**黑盒测试**，而更专业的安全或性能测试则被视为**灰盒测试**。'
- en: We will explore integration tests further in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085),
    *Building Efficient* *Test Suites*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第4章*](B18371_04.xhtml#_idTextAnchor085)中进一步探讨集成测试，*构建高效的测试套件*。
- en: End-to-end tests
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 端到端测试
- en: At the top of the testing pyramid, we have **end-to-end tests**. They are the
    least numerous of all the tests we have seen so far. They test the entire functionality
    of the application (as added during each sprint), ensuring that the project deliverables
    are working according to requirements and can potentially be shipped at the conclusion
    of a given sprint.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试金字塔的顶部，我们有**端到端测试**。在我们迄今为止看到的测试中，它们的数量最少。它们测试应用程序的整个功能（在每个冲刺期间添加），确保项目交付成果符合要求，并在给定冲刺结束时可能发货。
- en: These tests can be the most time-consuming to write, maintain, and run since
    they can involve a large variety of scenarios. Just like integration tests, they
    are also typically run in dedicated environments that mimic production environments.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试可能编写、维护和运行所需的时间最长，因为它们可能涉及大量不同的场景。就像集成测试一样，它们通常也在模拟生产环境的专用环境中运行。
- en: There are a lot of similarities between integration tests and end-to-end tests,
    especially in microservice architectures where one service’s end-to-end functionality
    involves integration with another service’s end-to-end functionality.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试和端到端测试之间有很多相似之处，尤其是在微服务架构中，一个服务的端到端功能涉及到与其他服务的端到端功能的集成。
- en: We will explore end-to-end tests further in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124),
    *Performing Integration Testing*, and [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179),
    *Testing* *Microservice Architectures*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第5章*](B18371_05.xhtml#_idTextAnchor124) *执行集成测试*和[*第8章*](B18371_08.xhtml#_idTextAnchor179)
    *测试微服务架构*中进一步探讨端到端测试。
- en: Now that we understand the different types of automated tests, it’s time to
    look at how we can leverage the Agile practice of TDD to implement them alongside
    our code. TDD will help us write well-tested code that delivers all the components
    of the testing pyramid.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了不同类型的自动化测试，是时候看看我们如何利用敏捷实践TDD来在我们代码旁边实现它们了。TDD将帮助我们编写经过良好测试的代码，提供测试金字塔的所有组件。
- en: The iterative approach of TDD
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD的迭代方法
- en: 'As we’ve mentioned before, TDD is an Agile practice that will be the focus
    of our exploration. The principle of TDD is simple: write the unit tests for a
    piece of functionality before implementing it.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，TDD是一种敏捷实践，将是我们要探索的重点。TDD的原则很简单：在实现功能之前先编写单元测试。
- en: TDD brings the testing process together with the implementation process, ensuring
    that every piece of functionality is tested as soon as it is written, making the
    software development process iterative, and giving developers quick feedback.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: TDD将测试过程与实现过程结合起来，确保每一段功能在编写后立即得到测试，使软件开发过程迭代，并为开发者提供快速反馈。
- en: '*Figure 1**.5* demonstrates the steps of the TDD process, known as the **red**,
    **green**, and **refactor** process:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.5* 展示了TDD过程的步骤，被称为**红色**、**绿色**和**重构**过程：'
- en: '![Figure 1.5 – The steps of TDD ](img/Figure_1.5_B18371.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – TDD的步骤](img/Figure_1.5_B18371.jpg)'
- en: Figure 1.5 – The steps of TDD
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – TDD的步骤
- en: 'Let’s have a look at the cyclical phases of the TDD working process:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看TDD工作流程的循环阶段：
- en: 'We start at the **red phase**. We begin by considering what we want to test
    and translating this requirement into a test. Some requirements may be made up
    of several smaller requirements: at this point, we test only the first small requirement.
    This test will fail until the new functionality is implemented, giving a name
    to the red phase. The failing test is key because we want to ensure that the test
    will fail reliably regardless of what code we write.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从**红色阶段**开始。我们首先考虑我们想要测试的内容，并将这个需求转换为一个测试。有些需求可能由几个较小的需求组成：在这个阶段，我们只测试第一个小需求。这个测试将失败，直到新的功能实现，这就是红色阶段的名字。失败的测试是关键的，因为我们想要确保无论我们编写什么代码，测试都会可靠地失败。
- en: Next, we move to the **green phase**. We swap from test code to implementation,
    writing just enough code as required to make the failing test pass. The code does
    not need to be perfect or optimal, but it should be correct enough for the test
    to pass. It should focus on the requirement tested by the previously written failing
    test.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们进入**绿色阶段**。我们从测试代码切换到实现代码，只编写足够的代码以满足使失败的测试通过的要求。代码不需要完美或最优，但应该足够正确，以便测试可以通过。它应该专注于之前编写的失败的测试所测试的需求。
- en: Finally, we move to the **refactor phase**. This phase is all about cleaning
    up both the implementation and the test code, removing duplication, and optimizing
    our solution.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们进入**重构阶段**。这个阶段主要是清理实现代码和测试代码，去除重复，并优化我们的解决方案。
- en: We repeat this process until all the requirements are tested and implemented
    and all tests pass. The developer frequently swaps between testing and implementing
    code, extending functionality and tests accordingly.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重复这个过程，直到所有需求都经过测试和实现，所有测试都通过。开发者经常在测试和实现代码之间切换，相应地扩展功能和测试。
- en: That’s all there is to doing TDD!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是做TDD的全部内容！
- en: TDD is all about developers
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: TDD完全是关于开发者的
- en: TDD is a developer-centric process where unit tests are written before implementation.
    Developers first write a failing test. Then, they write the simplest implementation
    to make the test pass. Finally, once the functionality is implemented and working
    as expected, they can refactor the code and test as needed. The process is repeated
    as many times as necessary. No piece of code or functionality is written without
    corresponding tests.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 是一种以开发者为中心的过程，其中单元测试是在实现之前编写的。开发者首先编写一个失败的测试。然后，他们编写最简单的实现来使测试通过。一旦功能实现并按预期工作，他们就可以根据需要重构代码并进行测试。这个过程需要重复多少次就重复多少次。没有任何代码或功能是未编写相应测试的。
- en: TDD best practices
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD 最佳实践
- en: The **red**, **green**, and **refactor** approach to TDD is simple, yet very
    powerful. While the process is simple, we can make some recommendations and best
    practices for how to write components and tests that can more easily be delivered
    with TDD.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 的 **红色**、**绿色** 和 **重构** 方法简单，但非常强大。虽然过程简单，但我们仍可以提出一些建议和最佳实践，以指导如何编写组件和测试，以便更轻松地通过
    TDD 来交付。
- en: Structure your tests
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构化您的测试
- en: 'We can formulate a shared, repeatable, test structure to make tests more readable
    and maintainable. *Figure 1**.6* depicts the **Arrange-Act-Assert** (**AAA**)
    pattern that is often used with TDD:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以制定一个共享的、可重复的测试结构，使测试更易于阅读和维护。*图 1.6* 描述了在 TDD 中经常使用的 **安排-执行-断言** （**AAA**）
    模式：
- en: '![Figure 1.6 – The steps of the Arrange-Act-Assert pattern ](img/Figure_1.6_B18371.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 安排-执行-断言模式的步骤](img/Figure_1.6_B18371.jpg)'
- en: Figure 1.6 – The steps of the Arrange-Act-Assert pattern
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 安排-执行-断言模式的步骤
- en: 'The AAA pattern describes how to structure tests in a uniform manner:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: AAA 模式描述了如何以统一的方式构建测试：
- en: We begin with the **Arrange** step, which is the setup part of the test. This
    is when we set up the **Unit Under Test** (**UUT**) and all of the dependencies
    that it requires during setup. We also set up the inputs and the preconditions
    used by the test scenario in this section.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 **安排** 步骤开始，这是测试的设置部分。这是我们设置 **被测单元** （**UUT**） 和它在设置过程中所需的全部依赖项的时候。我们还在本节中设置了测试场景使用的输入和先决条件。
- en: Next, the **Act** step is where we perform the actions specified by the test
    scenario. Depending on the type of test that we are implementing, this could simply
    be invoking a function, an external API, or even a database function. This step
    uses the preconditions and inputs defined in the **Arrange** step.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，**执行** 步骤是我们执行测试场景中指定的操作的地方。根据我们正在实现的测试类型，这可能是简单地调用一个函数、一个外部 API，甚至是数据库函数。这一步骤使用在
    **安排** 步骤中定义的先决条件和输入。
- en: Finally, the **Assert** step is where we confirm that the UUT behaves according
    to requirements. This step compares the output from the UUT with the expected
    output, as defined by the requirements.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，**断言** 步骤是我们确认 UUT 是否符合要求的地方。这一步骤将 UUT 的输出与根据要求定义的预期输出进行比较。
- en: If the **Assert** step shows that the actual output from the UUT is not as expected,
    then the test is considered failed and the test is finished.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 **断言** 步骤显示被测单元（UUT）的实际输出与预期不符，则测试被认为是失败的，测试结束。
- en: 'If the **Assert** step shows that the actual output from the UUT is as expected,
    then we have two options: one option is that if there are no more test steps,
    the test is considered passed and the test is finished. The other option is that
    if there are more test steps, then we go back to the **Act** step and continue.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 **断言** 步骤显示被测单元（UUT）的实际输出与预期相符，那么我们有两种选择：一种选择是如果没有更多的测试步骤，则测试被认为是通过的，测试结束。另一种选择是如果有更多的测试步骤，那么我们就回到
    **执行** 步骤并继续。
- en: The **Act** and **Assert** steps can be repeated as many times as necessary
    for your test scenario. However, you should avoid writing lengthy, complicated
    tests. This is described further in the best practices throughout this section.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行** 和 **断言** 步骤可以根据您的测试场景需要重复执行多次。然而，您应该避免编写冗长、复杂的测试。这一点在本节的最佳实践中将进一步说明。'
- en: Your team can leverage test helpers and frameworks to minimize setup and assertion
    code duplication. Using the AAA pattern will help to set the standard for how
    tests should be written and read, minimizing the cognitive load of new and existing
    team members and improving the maintainability of the code base.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您的团队能够利用测试辅助工具和框架来最小化设置和断言代码的重复。使用 AAA 模式将有助于设定测试编写和阅读的标准，最小化新成员和现有团队成员的认知负荷，并提高代码库的可维护性。
- en: Control scope
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制范围
- en: As we have seen, the scope of your test depends on the type of test you are
    writing. Regardless of the type of test, you should strive to restrict the functionality
    of your components and the assertions of your tests as much as possible. This
    is possible with TDD, which allows us to test and implement code at the same time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，测试的范围取决于你正在编写的测试类型。无论测试类型如何，你都应该尽可能限制组件的功能和测试的断言。TDD可以实现这一点，它允许我们同时测试和实现代码。
- en: 'Keeping things as simple as possible immediately brings some advantages:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能保持简单立即带来一些优势：
- en: Easier debugging in the case of failures
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败情况下更容易调试
- en: Easier to maintain and adjust tests when the Arrange and Assert steps are simple
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当安排和断言步骤简单时，更容易维护和调整测试
- en: Faster execution time of tests, especially with the ability to run tests in
    parallel
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试执行时间更快，尤其是在能够并行运行测试的情况下
- en: Test outputs, not implementation
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试输出，而非实现
- en: As we have seen from the previous definitions of tests, they are all about defining
    inputs and expected outputs. As developers who know implementation details, it
    can be tempting to add assertions that verify the inner workings of the UUT.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从之前的测试定义中看到的，它们都是关于定义输入和预期输出的。作为了解实现细节的开发者，添加验证UUT内部工作的断言可能会很有诱惑力。
- en: However, this is an anti-pattern that results in a tight coupling between the
    test and the implementation. Once tests are aware of implementation details, they
    need to be changed together with code changes. Therefore, when structuring tests,
    it is important to focus on testing externally visible outputs, not implementation
    details.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个导致测试和实现之间紧密耦合的反模式。一旦测试了解实现细节，它们就需要与代码更改一起更改。因此，在构建测试时，重要的是要关注测试外部可见的输出，而不是实现细节。
- en: Keep tests independent
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持测试独立
- en: Tests are typically organized in test suites, which cover a variety of scenarios
    and requirements. While these test suites allow developers to leverage shared
    functionality, tests should run independently of each other.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常组织在测试套件中，涵盖各种场景和需求。虽然这些测试套件允许开发者利用共享功能，但测试应独立于彼此运行。
- en: Tests should start from a pre-defined and repeatable starting state that does
    not change with the number of runs and order of execution. Setup and clean-up
    code ensures that the starting point and end state of each test is as expected.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应从一个预定义且可重复的起始状态开始，该状态不会随着运行次数和执行顺序的改变而改变。设置和清理代码确保每个测试的起始点和结束状态符合预期。
- en: It is, therefore, best that tests create their own UUT against which to run
    modifications and verifications, as opposed to sharing one with other tests. Overall,
    this will ensure that your test suites are robust and can be run in parallel.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好是测试创建自己的UUT（单元测试对象）来运行修改和验证，而不是与其他测试共享一个。总体而言，这将确保你的测试套件是健壮的，并且可以并行运行。
- en: Adopting TDD and its best practices allows Agile teams to deliver well-tested
    code that is easy to maintain and modify. This is one of many benefits of TDD,
    which we will continue to explore in the next section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 采用TDD及其最佳实践允许敏捷团队交付经过良好测试的代码，易于维护和修改。这是TDD的许多好处之一，我们将在下一节继续探讨。
- en: Understanding the benefits and use of TDD
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解TDD的好处和使用方法
- en: With the fundamentals and best practices of TDD in mind, let us have a more
    in-depth look at the benefits of adopting it as practice in your teams. As Agile
    working practices are industry standard, we will discuss TDD usage in Agile teams
    going forward. Incorporating TDD in the development process immediately allows
    developers to write and maintain their tests more easily, enabling them to detect
    and fix bugs more easily too.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑TDD的基本原理和最佳实践的情况下，让我们更深入地探讨将TDD作为团队实践的好处。由于敏捷工作实践是行业标准，我们将从现在开始讨论敏捷团队中TDD的使用。将TDD纳入开发流程立即允许开发者更容易地编写和维护测试，同时也更容易检测和修复错误。
- en: Pros and cons of using TDD
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TDD的优缺点
- en: '*Figure 1**.7* depicts some of the pros and cons of using TDD:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.7**。7* 展示了使用TDD的一些优缺点：'
- en: '![Figure 1.7 – Pros and cons of using TDD ](img/Figure_1.7_B18371.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 使用TDD的优缺点](img/Figure_1.7_B18371.jpg)'
- en: Figure 1.7 – Pros and cons of using TDD
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 使用TDD的优缺点
- en: 'We can expand on these pros and cons highlights:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步探讨这些优缺点的亮点：
- en: TDD allows the development and testing process to happen at the same time, ensuring
    that all code is tested from the beginning. While TDD does require writing more
    code upfront, the written code is immediately covered by tests, and bugs are fixed
    while relevant code is fresh in developers’ minds. Testing should not be an afterthought
    and should not be rushed or cut if the implementation is delayed.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD允许开发和测试过程同时进行，确保所有代码从一开始就被测试。虽然TDD确实需要提前编写更多代码，但编写的代码会立即被测试覆盖，并且错误会在相关代码仍然新鲜时被修复。测试不应该是事后考虑的事情，也不应该在实现延迟时仓促或削减。
- en: TDD allows developers to analyze project requirements in detail at the beginning
    of the sprint. While it does require product managers to establish the details
    of what needs to be built as part of sprint planning, it also allows developers
    to give early feedback on what can and cannot be implemented during each sprint.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD允许开发者在冲刺开始时详细分析项目需求。虽然这确实要求产品经理在冲刺计划中确定需要构建的细节，但它也允许开发者对每个冲刺期间可以和不能实现的内容给出早期反馈。
- en: Well-tested code that has been built with TDD can be confidently shipped and
    changed. Once a code base has an established test suite, developers can confidently
    change code, knowing that existing functionality will not be broken because test
    failures would flag any issues before changes are shipped.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过良好测试且使用TDD构建的代码可以自信地发布和更改。一旦代码库建立了测试套件，开发者可以自信地更改代码，因为他们知道现有的功能不会因为测试失败而破坏，因为测试失败会在代码发布之前标记出任何问题。
- en: Finally, the most important pro is that it gives developers ownership of their
    code quality by making them responsible for both implementation and testing. Writing
    tests at the same time as code gives developers a short feedback loop on where
    their code might be faulty, as opposed to shipping a full feature and hearing
    about where they missed the mark much later.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，最重要的优点是它通过让他们对实现和测试都负责，使开发者拥有代码质量。与代码同时编写测试，使开发者能够快速了解代码可能存在的错误，而不是在发布完整功能后很久才听到他们哪里做得不够好。
- en: In my opinion, the most important advantage of using TDD is the increased ownership
    by developers. The immediate feedback loop allows them to do their best work,
    while also giving them peace of mind that they have not broken any existing code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，使用TDD（测试驱动开发）最重要的优势是开发者拥有感的增加。即时的反馈循环使他们能够做到最好，同时也让他们安心，因为他们没有破坏任何现有的代码。
- en: Now that we understand what TDD and its benefits are, let us explore the basic
    application of TDD to a simple calculator example.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了TDD及其好处，让我们探索TDD在简单计算器示例中的基本应用。
- en: Use case – the simple terminal calculator
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例 – 简单终端计算器
- en: This use case will give you a good understanding of the general process we will
    undertake when testing more advanced examples.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用例将使你对我们在测试更高级示例时将采取的一般过程有一个良好的理解。
- en: 'The use case we will look at is the simple terminal calculator. The calculator
    will run in the terminal and use the standard input to read its parameters. The
    calculator will only handle two operators and the simple mathematical operations
    you see in *Figure 1**.8*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要研究的用例是简单的终端计算器。计算器将在终端运行，并使用标准输入读取其参数。计算器将只处理两个运算符和你在*图1.8*中看到的简单数学运算：
- en: '![Figure 1.8 – The simple calculator runs in the terminal ](img/Figure_1.8_B18371.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – 简单计算器在终端运行](img/Figure_1.8_B18371.jpg)'
- en: Figure 1.8 – The simple calculator runs in the terminal
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 简单计算器在终端运行
- en: This functionality is simple, but the calculator should also be able to handle
    edge cases and other input errors.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能很简单，但计算器也应该能够处理边缘情况和其他输入错误。
- en: Requirements
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需求
- en: Agile teams typically write their requirements from the user’s perspective.
    The requirements of the project are written first in order to capture customer
    needs and to guide the test cases and implementation of the entire simple calculator
    project. In Agile teams, requirements go through multiple iterations, with engineering
    leadership weighing in early to ensure that the required functionality can be
    delivered.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷团队通常从用户的角度编写他们的需求。项目需求首先被编写，以捕捉客户需求并指导整个简单计算器项目的测试用例和实现。在敏捷团队中，需求会经历多次迭代，工程领导在早期就参与进来，以确保所需的功能可以被交付。
- en: 'Users should be able to do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该能够执行以下操作：
- en: Input positive, negative, and zero values using the terminal input. These values
    should be correctly transformed into numbers.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用终端输入输入正数、负数和零值。这些值应正确转换为数字。
- en: Access the mathematical operations of addition, subtraction, multiplication,
    and division. These operations should return the correct results for the entire
    range of inputs.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问加、减、乘、除等数学运算。这些运算应返回整个输入范围的正确结果。
- en: View fractional results rounded up to two decimal places.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看四舍五入到两位小数的分数结果。
- en: View user-friendly error messages, guiding them on how to fix their input.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看用户友好的错误信息，指导他们如何修复输入。
- en: Agile requirements from the perspective of the user
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户角度出发的敏捷需求
- en: Requirements are used to capture the needs and perspectives of the end user.
    The requirements set out the precondition, the user actions, and the acceptance
    criteria. They specify what we should build as well as how to verify the implementation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 需求用于捕捉最终用户的需求和观点。需求规定了先决条件、用户操作和验收标准。它们指定了我们应该构建什么，以及如何验证实现。
- en: Remember that we only specify requirements on a sprint-by-sprint basis. It is
    an anti-pattern to specify requirements of the entire product upfront, as well
    as work in the mindset that they cannot change. Software building in Agile is
    an iterative process.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们只按冲刺周期指定需求。一开始就指定整个产品的需求，以及认为它们不会改变的心态，是一种反模式。敏捷软件开发是一个迭代的过程。
- en: Architecture
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 架构
- en: Our simple terminal calculator is small enough to implement in one sprint. We
    will take our four requirements and translate them into a simple system architecture.
    The calculator will be downloaded and run by users locally, so we do not need
    to consider any networking or cloud deployment aspects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的终端计算器足够小，可以在一个冲刺周期内实现。我们将把我们的四个需求转换为简单的系统架构。计算器将由用户在本地下载并运行，因此我们不需要考虑任何网络或云部署方面。
- en: '*Figure 1**.9* shows what the design of the calculator module could look like:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.9* 展示了计算器模块的设计可能看起来是什么样子：'
- en: '![Figure 1.9 – Architecture of the simple terminal calculator ](img/Figure_1.9_B18371.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – 简单终端计算器的架构](img/Figure_1.9_B18371.jpg)'
- en: Figure 1.9 – Architecture of the simple terminal calculator
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 简单终端计算器的架构
- en: 'Each of the components of the calculator module has its own, well-defined responsibilities
    and functionality:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器模块的每个组件都有其自身明确的责任和功能：
- en: The **Input parser** is in charge of integrating with the terminal input and
    reading the user input correctly and passing it to the calculator module.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入解析器**负责与终端输入集成，正确读取用户输入并将其传递给计算器模块。'
- en: The **Input validator** is in charge of validating the input sent from the **Input
    parser**, such as whether the input contains valid numbers and the operators are
    valid.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入验证器**负责验证从**输入解析器**发送的输入，例如输入是否包含有效的数字和运算符是否有效。'
- en: Once the input is parsed and validated, the **Calculator engine** takes in the
    numbers and attempts to find the result of the operation.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦输入被解析和验证，**计算器引擎**将接收数字并尝试找到运算的结果。
- en: The **Calculator engine** then relies on the **Result formatter** to format
    the result correctly and print it to the terminal output. In the case of an error,
    it relies on the **Error formatter** to produce and print user-friendly errors.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算器引擎**随后依赖于**结果格式化器**来正确格式化结果并将其打印到终端输出。在出现错误的情况下，它依赖于**错误格式化器**来生成并打印用户友好的错误信息。'
- en: Applying TDD
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用 TDD
- en: As described, we will use the **red**, **green**, and **refactor** process to
    apply TDD to deliver the required user functionality in an iterative manner. Tests
    are written first, based on the requirements and design of the simple terminal
    calculator.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如描述，我们将使用**红色**、**绿色**和**重构**流程以迭代方式应用 TDD，以交付所需用户功能。测试是基于简单终端计算器的要求和设计先编写的。
- en: 'An overview of how the process might work for the implementation of the `Divide(x,y)`
    function in **the calculator engine** is demonstrated in *Figure 1**.10*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 1.10* 中展示了在 **计算器引擎** 中实现 `Divide(x,y)` 函数的过程概述：
- en: '![Figure 1.10 – The TDD process applied to the calculator engine ](img/Figure_1.10_B18371.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – 将 TDD 流程应用于计算器引擎](img/Figure_1.10_B18371.jpg)'
- en: Figure 1.10 – The TDD process applied to the calculator engine
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 将 TDD 流程应用于计算器引擎
- en: 'This is a small snapshot that demonstrates the steps involved when using TDD:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个展示使用 TDD 所涉及步骤的小快照：
- en: We begin by writing a simple `TestDivide()` that arranges two non-zero inputs
    and writes assertions for dividing them. This is the simplest case that we can
    implement. Then, we run the test suite to ensure that the newly written `TestDivide()`
    is failing.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先编写一个简单的 `TestDivide()` 测试，安排两个非零输入并编写断言来除以它们。这是我们能够实现的最简单情况。然后，我们运行测试套件以确保新编写的
    `TestDivide()` 测试正在失败。
- en: Now that the test has established the expected behavior, we can begin our implementation
    of the `Divide(x,y)` function. We write just enough code to handle the simple
    case of two non-zero inputs. Then, we run the test suite to verify that the code
    we have written satisfies the assertions of `TestDivide()`. All tests should now
    be passing.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在测试已经建立了预期的行为，我们可以开始实现 `Divide(x,y)` 函数。我们只编写足够的代码来处理两个非零输入的简单情况。然后，我们运行测试套件以验证我们编写的代码是否满足
    `TestDivide()` 的断言。现在所有测试都应该通过。
- en: We can now take some time to refactor the existing code that we have written.
    The newly written code can be cleaned up according to the clean code practices,
    as well as the TDD best practices that we have discussed. The test suite is run
    once more to validate that the refactor step has not broken any new or existing
    tests.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以花些时间重构我们编写的现有代码。新编写的代码可以根据清洁代码实践以及我们讨论过的 TDD 最佳实践进行清理。再次运行测试套件以验证重构步骤没有破坏任何新的或现有的测试。
- en: The simplest functionality for the new `Divide(x,y)` function is now implemented
    and validated. We can turn to looking at more advanced functionality or edge cases.
    One such edge case could be handling a zero divisor gracefully. We now add a new
    test, `TestDivide_Zero()`, which sets up and asserts the case of a zero divisor.
    As usual, we run the test suite to ensure that the new `TestDivide_Zero()` test
    is failing.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的 `Divide(x,y)` 函数的最简单功能现在已实现并经过验证。我们可以转向查看更高级的功能或边缘情况。一个这样的边缘情况可能是优雅地处理零除数。我们现在添加一个新的测试
    `TestDivide_Zero()`，它设置并断言零除数的情况。像往常一样，我们运行测试套件以确保新的 `TestDivide_Zero()` 测试正在失败。
- en: We modify the implementation of `Divide(x,y)` to handle a zero divisor gracefully
    and correctly, as established in the calculator requirements (talking to product
    owners and perhaps even users if necessary). We run the tests again to ensure
    that all tests are now passing.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们修改 `Divide(x,y)` 的实现，以优雅且正确地处理零除数，正如计算器要求中所述（可能需要与产品负责人甚至用户交谈）。我们再次运行测试以确保所有测试现在都通过。
- en: Finally, we begin a new round of refactoring, ensuring that code and tests are
    well written. All tests are run once more to ensure that refactoring has not caused
    any errors.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们开始新一轮的重构，确保代码和测试都写得很好。再次运行所有测试以确保重构没有引起任何错误。
- en: TDD is second nature
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 是第二天性
- en: The development process swaps between writing test code and writing implementation
    code as many times as required. While it might seem cumbersome at first, swapping
    between writing test code and implementation code quickly becomes second nature
    to TDD practitioners.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 开发过程在编写测试代码和编写实现代码之间切换，所需次数不限。虽然一开始可能感觉有些繁琐，但编写测试代码和实现代码之间的切换很快就会成为 TDD 实践者的第二天性。
- en: Always remember to start with a failing test and then write as little code as
    possible to make the test pass. Optimize your code only in the refactor phase,
    once you have all functionality working as verified.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记得先从一个失败的测试开始，然后尽可能少地编写代码来使测试通过。仅在所有功能都经过验证并正常工作后，在重构阶段优化代码。
- en: We are now familiar with the process of TDD and have looked at how to write
    and structure our tests accordingly. However, it’s important to consider alternative
    processes as well.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在熟悉了 TDD 的过程，并了解了如何相应地编写和构建我们的测试。然而，考虑替代流程也很重要。
- en: Alternatives to TDD
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD 的替代方案
- en: As we’ve seen, TDD is simply a way to deliver well-tested code in an iterative
    way. Putting tests first ensures that no functionality is ever delivered without
    being tested and refactored. In this section, we will have a look at some other
    common processes for testing code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，TDD 只是一种以迭代方式交付经过良好测试的代码的方法。将测试放在首位确保永远不会交付未经测试和重构的功能。在本节中，我们将探讨一些其他常见的代码测试流程。
- en: Waterfall testing
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 水瀑布测试
- en: As we remember from our introduction to the waterfall methodology, the testing
    or verification phase of waterfall projects happens after the implementation phase
    is fully completed. The entire project is delivered, and all requirements are
    implemented by this point.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从瀑布方法论的介绍中记得的那样，瀑布项目的测试或验证阶段是在实施阶段完全完成后发生的。整个项目已经交付，所有需求都已在此时实现。
- en: 'Here are the advantages:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是优点：
- en: Waterfall projects are typically well structured and well documented. Testing
    plans are informed by this extensive documentation and testers can ensure that
    all of the end-to-end tests that they implement cover the identified user needs.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瀑布项目通常结构良好，文档齐全。测试计划由这些广泛的文档提供信息，测试人员可以确保他们实施的端到端测试覆盖了已识别的用户需求。
- en: Developers and testers can rely on the project documentation to work independently,
    without the need to communicate. This division allows teams to work in shifts
    – testers verify functionality and developers fix any bugs that may arise.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员和测试人员可以依赖项目文档独立工作，无需沟通。这种分工使得团队可以轮班工作——测试人员验证功能，开发人员修复可能出现的任何错误。
- en: 'These are the disadvantages:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是缺点：
- en: As the entire project is already implemented, it is easier for bugs to become
    complex. Furthermore, since the entire project is already implemented, it might
    take considerably more engineering effort to fix a bug, in the case that large
    changes need to be undertaken.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于整个项目已经实施，错误可能会变得更加复杂。此外，由于整个项目已经实施，如果需要进行大量更改，修复错误可能需要相当多的工程努力。
- en: In the case that client requirements are not well known or clear from the beginning,
    a lot of implementation and testing effort might be wasted if the requirements
    change once the client sees the delivered product at the end of the process.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户需求在项目开始时并不清楚或明确，一旦客户在过程结束时看到交付的产品，需求发生变化，可能会浪费大量的实施和测试工作。
- en: The testing process can often be seen as a time-wasting, negative exercise that
    should be finished as soon as possible. Furthermore, if there are delays in the
    development process, it can be easy to cut corners in the verification process,
    delivering an unstable product.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试过程通常被视为一种浪费时间、消极的练习，应该尽快完成。此外，如果在开发过程中出现延误，验证过程中可能会很容易地削减成本，从而交付一个不稳定的产品。
- en: Acceptance Test-Driven Development
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受测试驱动开发
- en: '**Acceptance Test-Driven Development** (**ATDD**) is an Agile development process
    related to TDD. ATDD involves people from multiple disciplines from product, engineering,
    and testing to ensure that **the right product is being developed in the right
    way**. The customer requirements are translated into a list of requirements that
    can be understood by a wide variety of stakeholders. These requirements are then
    converted to automated acceptance tests, which are used to verify what the engineering
    department is delivering.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**接受测试驱动开发**（**ATDD**）是一种与TDD相关的敏捷开发过程。ATDD涉及来自产品、工程和测试等多个学科的人员，以确保**正确的产品以正确的方式被开发**。客户需求被转化为一个可以由各种利益相关者理解的列表。然后，这些需求被转换为自动接受测试，用于验证工程部门交付的内容。'
- en: 'The advantages of ATDD are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ATDD的优点如下：
- en: Just like with TDD, tests are written first when you use ATDD. A complete suite
    of automated acceptance tests can be run after each commit or incremental code
    delivery, ensuring that all end-to-end functionality works as expected.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像使用TDD一样，当使用ATDD时，首先编写测试。在每次提交或增量代码交付后，可以运行一个完整的自动化接受测试套件，确保所有端到端功能按预期工作。
- en: If done right, using ATDD on a project will be widely supported by a wide variety
    of stakeholders inside the business, as they will have a good understanding of
    the direction and customer value it will provide.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作得当，在项目中使用ATDD将得到业务内部各种利益相关者的广泛支持，因为他们将很好地理解它将提供的方向和客户价值。
- en: 'The disadvantages are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点如下：
- en: Significant communication and synchronization effort is required for the inter-disciplinary
    effort of writing requirements. It can be time-consuming to get a variety of stakeholders
    to give the time and effort needed.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写需求时，需要大量的沟通和同步工作，涉及跨学科的努力。让各种利益相关者提供所需的时间和精力可能会很耗时。
- en: This approach might not be best suited for greenfield projects, where there
    are a lot of unknowns upfront. It can be particularly challenging to write acceptance
    tests for a project that does not even have an API or database model yet.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法可能不适合绿色项目，因为一开始就有很多未知因素。为甚至没有API或数据库模型的项目编写验收测试尤其具有挑战性。
- en: It can be challenging to get sample payloads or datasets from the outset of
    a project, especially if these are provided by the client or a third party.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目初期获取样本有效载荷或数据集可能具有挑战性，尤其是如果这些由客户或第三方提供。
- en: Further related to ATDD, we have **Behavior-Driven Development** (**BDD**).
    It provides precise guidance on how to structure the conversation between stakeholders
    using business domain language. We will explore BDD further in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124),
    *Performing* *Integration Testing*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步与ATDD相关的是，我们有**行为驱动开发**（**BDD**）。它提供了关于如何使用业务领域语言结构化利益相关者之间对话的精确指导。我们将在[*第五章*](B18371_05.xhtml#_idTextAnchor124)
    *执行* *集成测试* 中进一步探讨BDD。
- en: As we begin to write and think of test code together with functional code, it’s
    important to set success criteria for our test code. Test metrics can help us
    achieve just that.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始与功能代码一起编写和思考测试代码时，为我们的测试代码设定成功标准是很重要的。测试指标可以帮助我们实现这一点。
- en: Understanding test metrics
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试指标
- en: Now that we understand how to deliver projects with tests first, it’s time to
    look at some metrics that can quantify how well-tested a project is. It’s important
    to deliver tests across the entire test pyramid, as it’s important to be able
    to ensure the application is working correctly end-to-end as well as working well
    with its external dependencies.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何首先通过测试来交付项目，是时候看看一些可以量化项目测试程度的指标了。在整个测试金字塔中交付测试非常重要，因为这可以确保应用程序能够正确地端到端工作，并且与外部依赖良好地协作。
- en: Important test metrics
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重要的测试指标
- en: 'There is a wide range of metrics that we can measure when quantifying the quality
    of software:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在量化软件质量时，我们可以测量一系列的指标：
- en: '**Requirement coverage**: This indicates the percentage of your project requirements
    that are covered by tests. A test could cover multiple requirements, but no customer
    requirement should be left untested.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需求覆盖率**：这表示测试覆盖了您项目需求的百分比。一个测试可以覆盖多个需求，但不应有任何客户需求未经过测试。'
- en: '**Defect count and distribution**: This indicates how many defects or bugs
    are discovered in each module/part of the application. The distribution will also
    signal whether there are any particular problem areas in the system that could
    be refactored.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺陷计数和分布**：这表示在应用的每个模块/部分中发现了多少缺陷或错误。分布也将表明系统中是否存在任何特定的问题区域，这些区域可能需要重构。'
- en: '**Defect resolution time**: This indicates how quickly the development team
    is able to fix bugs once they are detected. A long **Mean Time To Resolution**
    (**MTTR**) can indicate that the development team is short-staffed, while a long
    max resolution time in a particular area of the system can indicate that the code
    in that particular part is difficult to change.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺陷解决时间**：这表示一旦发现错误，开发团队能够多快地修复它们。长的**平均解决时间**（**MTTR**）可能表明开发团队人手不足，而在系统特定区域的长最大解决时间可能表明该部分的代码难以更改。'
- en: '**Code coverage**: This indicates the percentage of your code base that is
    exercised by unit tests. Since tests should be written first, coverage also shows
    whether the development team is using TDD. Low test coverage can also indicate
    issues with the system design.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码覆盖率**：这表示单元测试执行了您的代码库的百分比。由于测试应该首先编写，覆盖率也显示了开发团队是否在使用TDD。低测试覆盖率也可能表明系统设计存在问题。'
- en: '**Burndown rates and charts**: These indicate the rate at which the team is
    able to deliver functionality. As development and testing are a unified task,
    a user story or requirement cannot be considered complete unless it is tested,
    so the burndown rate will include only stories that are ready for delivery. Burndown
    charts can indicate delays in project timelines.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**燃尽率和图表**：这些指标表示团队交付功能的能力。由于开发和测试是一个统一的任务，除非经过测试，否则用户故事或需求不能被视为完成，因此燃尽率将仅包括准备交付的故事。燃尽图表可以表明项目时间表中的延迟。'
- en: Code coverage
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: 'Since the code coverage metric is such an important TDD indicator, let’s explore
    it further. In order to achieve a high coverage percentage, tests should cover
    the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码覆盖率指标是如此重要的TDD（测试驱动开发）指标，让我们进一步探讨它。为了实现高覆盖率百分比，测试应该覆盖以下内容：
- en: The **functions** you implemented
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您实现的**函数**
- en: The **statements** that your functions are composed of
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您函数由**语句**组成
- en: The different **execution paths** of your functions
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您函数的不同**执行路径**
- en: The different **conditions** of your Boolean variables
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您布尔变量的不同**条件**
- en: The different **parameter values** that can be passed to your functions
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以传递给您的函数的不同**参数值**
- en: The Go test runner provides the coverage percentage for Go applications. We
    will have a look at how to do this in [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035),
    *Unit* *Testing Essentials.*
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Go测试运行器为Go应用程序提供覆盖率百分比。我们将在[*第2章*](B18371_02.xhtml#_idTextAnchor035)，“单元测试基础”中查看如何做到这一点。
- en: '*Figure 1**.11* shows a flow chart of the implementation of the `Divide(x,y)`
    function from the simple terminal calculator:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1**.11*显示了简单终端计算器中`Divide(x,y)`函数实现的流程图：'
- en: '![Figure 1.11 – Execution flow of the Divide function in the simple calculator
    ](img/Figure_1.11_B18371.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图1.11 – 简单计算器中`Divide(x,y)`函数的执行流程](img/Figure_1.11_B18371.jpg)'
- en: Figure 1.11 – Execution flow of the Divide function in the simple calculator
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 – 简单计算器中`Divide(x,y)`函数的执行流程
- en: 'Tests should be written to cover and verify the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 应编写测试来覆盖和验证以下内容：
- en: The execution path for `y != 0`
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y != 0`的执行路径'
- en: The execution path for `y == 0`
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y == 0`的执行路径'
- en: The error message of the `DivideZero` error
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DivideZero`错误的错误信息'
- en: The output from the result calculation statements
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果计算语句的输出
- en: The output from the print result statements
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印结果语句的输出
- en: Code coverage percentage
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码覆盖率百分比
- en: In large projects, it will be unfeasible to reach 100% test coverage for the
    code base. There have been many discussions in the tech community about what a
    *good* test coverage percentage is. It is generally accepted that a good coverage
    amount is around the 80% mark. After that point, experience shows there can be
    diminishing returns.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型项目中，达到代码库的100%测试覆盖率将是不切实际的。技术社区中已经有很多关于什么是**好的**测试覆盖率百分比的讨论。普遍认为，良好的覆盖率大约在80%左右。在此之后，经验表明可能会有递减的回报。
- en: The code coverage percentage will also depend on the kind of project you are
    running. A legacy code base with a low code coverage percentage will require considerable
    effort to bring up to the 80% mark. Similarly, a greenfield project will also
    be difficult to test if there are many unknowns.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率百分比也将取决于您正在运行的项目类型。具有低代码覆盖率百分比的遗留代码库需要相当大的努力才能提高到80%的标记。同样，如果有很多未知因素，绿色项目也很难进行测试。
- en: Just like any code you write, test code needs to be maintained and refactored.
    Keeping a high coverage percentage requires maintaining and updating a lot of
    test code. This can increase the development cost of refactoring or other code
    changes, as it potentially requires updating many test cases. The business value
    of maintaining tests that do not cover requirements is very low, so you should
    ensure that your tests are providing value to your test suites.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您编写的任何代码一样，测试代码也需要维护和重构。保持高覆盖率百分比需要维护和更新大量的测试代码。这可能会增加重构或其他代码更改的开发成本，因为它可能需要更新许多测试用例。维护不覆盖需求的测试的商业价值非常低，因此您应该确保您的测试为您的测试套件提供价值。
- en: Well-tested code is not necessarily bug-free code
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 经过良好测试的代码不一定是无错误的代码
- en: Your tests should aim to provide verification for important code behavior, as
    opposed to simply writing code to get a certain code coverage percentage. The
    team should embrace a testing culture using TDD and a good coverage percentage
    will follow.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您的测试应该旨在验证重要代码行为，而不是仅仅为了达到一定的代码覆盖率百分比而编写代码。团队应该采用TDD（测试驱动开发）的文化，并且良好的覆盖率百分比将会随之而来。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered all the testing fundamentals that you will need
    to get started with TDD. We began with an explanation of what Agile is and how
    TDD fits into the Agile development process. You learned about the different types
    of automated tests and the testing pyramid. Then, we looked at the iterative process
    of delivering code with TDD using the red, green, and refactor process, and explored
    some TDD best practices on how to structure and write tests.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了您开始TDD所需的所有测试基础。我们从解释什么是敏捷以及TDD如何适应敏捷开发过程开始。您了解了不同类型的自动化测试和测试金字塔。然后，我们通过使用红色、绿色和重构流程来查看使用TDD交付代码的迭代过程，并探讨了如何构建和编写测试的一些TDD最佳实践。
- en: In [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035), *Unit Testing Essentials*,
    we will learn how to write tests in Go and begin to get some hands-on experience
    with TDD. We will begin to use the red, green, and refactor process and write
    tests according to the TDD best practices that we have learned.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B18371_02.xhtml#_idTextAnchor035)的*单元测试基础*中，我们将学习如何在Go中编写测试，并开始获得一些TDD（测试驱动开发）的实践经验。我们将开始使用红色、绿色和重构流程，并按照我们学到的TDD最佳实践编写测试。
- en: Questions
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the testing pyramid? What are its components?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试金字塔是什么？它的组成部分有哪些？
- en: What is the difference between functional and non-functional tests?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能测试和非功能测试之间有什么区别？
- en: Explain what the red, green, and refactor TDD approach is.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释红色、绿色和重构的TDD方法是什么。
- en: What is ATDD?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ATDD（接受测试驱动开发）是什么？
- en: What is code coverage?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码覆盖率是什么？
- en: Further reading
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Learning Agile: Understanding Scrum, XP, Lean, and Kanban* – Andrew Stellman
    and Jennifer Greene, published by O’Reilly Media'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《学习敏捷：理解Scrum、XP、精益和看板》：安德鲁·斯特尔曼和詹妮弗·格林，由O’Reilly Media出版*'
- en: '*Test Driven Development: By Example* – Kent Beck, published by Addison-Wesley
    Signature Series'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《通过示例学习测试驱动开发》：肯特·贝克，由Addison-Wesley Signature Series出版*'
- en: '*Clean Code: A Handbook of Agile Software Craftsmanship* – Robert C. Martin,
    published by Prentice Hall'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《代码整洁之道：敏捷软件开发工艺手册》：罗伯特·C·马丁，由Prentice Hall出版*'
- en: Answers
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The testing pyramid specifies how automated test suites should be structured.
    At the bottom of the pyramid are unit tests, which test a single isolated component.
    Next up in the middle of the pyramid are integration tests, which test that multiple
    components are able to work together as specified. Finally, at the top of the
    test pyramid are end-to-end tests that test the behavior of the entire application.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试金字塔规定了自动化测试套件的构建方式。金字塔的底部是单元测试，它测试单个隔离的组件。接下来在金字塔的中间是集成测试，它测试多个组件能否按照指定的方式协同工作。最后，在测试金字塔的顶部是端到端测试，它测试整个应用程序的行为。
- en: Functional tests cover the correctness of a system, while non-functional tests
    cover the usability and performance of a system. Both types of tests are required
    to ensure that the system satisfies the customers’ needs.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能测试覆盖系统的正确性，而非功能测试覆盖系统的可用性和性能。这两种类型的测试都是必需的，以确保系统能满足客户的需求。
- en: The red, green, and refactor TDD approach refers to the three phases of the
    process. The red phase involves writing a new failing test for the functionality
    we intend to implement. The green phase involves writing enough implementation
    code to make all tests pass. Finally, the refactor phase involves optimizing both
    implementation and testing code to remove duplication and come up with better
    solutions.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 红色、绿色和重构的TDD方法指的是过程的三个阶段。红色阶段涉及为我们要实现的功能编写一个新的失败的测试。绿色阶段涉及编写足够的实现代码，使所有测试通过。最后，重构阶段涉及优化实现和测试代码，以消除重复并提出更好的解决方案。
- en: Acceptance test-driven development. Just like TDD, ATDD puts tests first. ATDD
    is related to TDD, but it involves writing a suite of acceptance tests before
    the implementation begins. It involves multiple stakeholders to ensure that the
    acceptance test captures the customer’s requirements.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受测试驱动开发。就像TDD一样，ATDD（接受测试驱动开发）也将测试放在首位。ATDD与TDD相关，但在实施开始之前，它涉及编写一系列接受测试。它涉及多个利益相关者，以确保接受测试能够捕捉到客户的需求。
- en: Code coverage is the percentage of your lines of code that are exercised by
    your unit test. This is calculated by considering the function statements, parameter
    values, and execution paths of your code. The Go test runner outputs the calculated
    code coverage. We should aim for a good value, but optimizing for 100% is normally
    not appropriate.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码覆盖率是指你的代码行中有多少被单元测试所执行。这是通过考虑你的代码的功能语句、参数值和执行路径来计算的。Go 测试运行器会输出计算出的代码覆盖率。我们应该追求一个良好的值，但优化到100%通常是不合适的。
