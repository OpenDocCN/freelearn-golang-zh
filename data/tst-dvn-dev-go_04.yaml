- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building Efficient Test Suites
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建高效的测试套件
- en: In the previous chapter, we learned how to supplement the functionality of Go’s
    `testing` package with third-party libraries. These libraries make it easier to
    mock the dependencies of the **Unit Under Test** (**UUT**) and create assertions
    in these tests. Mocks are essential building blocks to being able to easily write
    test code for well-designed implementation code, according to the **SOLID** design
    principles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用第三方库来补充Go的`testing`包的功能。这些库使得模拟**被测试单元**（**UUT**）的依赖项和在测试中创建断言变得更加容易。根据**SOLID**设计原则，模拟是构建能够轻松编写测试代码的优质实现代码的基本构建块。
- en: In practice, developers identify edge cases of their requirements and implementations,
    ensuring a good **code coverage** percentage, which we discussed in [*Chapter
    2*](B18371_02.xhtml#_idTextAnchor035), *Unit Testing Essentials*. In this chapter,
    we will learn how to create test suites.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，开发者会识别其需求和实现中的边缘情况，确保良好的**代码覆盖率**百分比，这一点我们在[*第2章*](B18371_02.xhtml#_idTextAnchor035)，“单元测试基础”中讨论过。在本章中，我们将学习如何创建测试套件。
- en: One popular technique for constructing test suites in Go is **table-driven testing**.
    We will learn how to build tables that cover edge cases and exercise the UUT with
    a variety of inputs, ensuring that the UUT has a stable implementation. We will
    also leverage some of the techniques we’ve explored so far, such as test setup,
    subtests, and mocks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中进行测试套件构建的一种流行技术是**表格驱动测试**。我们将学习如何构建覆盖边缘情况并使用各种输入对UUT进行测试的表格，确保UUT有稳定的实现。我们还将利用我们之前探索的一些技术，例如测试设置、子测试和模拟。
- en: 'One of the most popular usages of Go is to build web applications, and in this
    chapter, we will explore how to build and test just that. We will move on from
    the simple calculator example that we have looked at so far and look at a new
    use case: the `BookSwap` application. This service will allow users to create
    book listings they wish to swap, allowing others to borrow them.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言最流行的用途之一是构建Web应用程序，在本章中，我们将探讨如何构建和测试这类应用程序。我们将从迄今为止我们所看到的简单计算器示例过渡到一个新的用例：`BookSwap`应用程序。这项服务将允许用户创建他们想要交换的书籍列表，让其他人可以借阅。
- en: This example will involve building a REST API with Go’s `net/http` package and
    learning how to test it. It is particularly important to cover edge cases when
    dealing with user input, so we will test the `BookSwap` API using the techniques
    covered so far.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将涉及使用Go的`net/http`包构建REST API，并学习如何测试它。在处理用户输入时，覆盖边缘情况尤为重要，因此我们将使用迄今为止所介绍的技术来测试`BookSwap`
    API。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: What edge cases are and how to identify them
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘情况是什么以及如何识别它们
- en: How to test web applications and APIs, which may rely on external services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何测试依赖外部服务的Web应用程序和API
- en: The popular Go testing technique of table-driven testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行的Go测试技术——表格驱动测试
- en: The `BookSwap` use case application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookSwap`用例应用程序'
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described in the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装**Go版本1.19**或更高版本才能运行本章中的代码示例。安装过程在官方Go文档[https://go.dev/doc/install](https://go.dev/doc/install)中有描述。
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter04](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter04).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含的代码示例在[https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter04](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter04)公开可用。
- en: Testing multiple conditions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试多个条件
- en: So far, we have covered how to structure and write tests. However, developers
    need to know *what* aspects of their code to test, as well as *how* to test them.
    Remember that the lower we go on the **testing pyramid**, the cheaper and faster
    the tests are to run. Therefore, it is important for developers to know how to
    exercise their code as low in their stack as possible. In this chapter, we’ll
    focus on covering edge cases as part of our developer **testing strategy**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何构建和编写测试。然而，开发者需要知道他们代码的哪些方面需要测试，以及如何测试它们。记住，我们在**测试金字塔**中越往底层，测试就越便宜、越快。因此，对于开发者来说，了解如何尽可能低地在他们的堆栈中执行代码是很重要的。在本章中，我们将重点关注将边缘情况作为我们开发者**测试策略**的一部分。
- en: As discussed in [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015), *Getting to
    Grips with Test-Driven Development*, automated tests should be based on the system
    requirements we implement. In general, system requirements will focus on the specification
    of the success scenarios and system functionality additions. Designing your testing
    strategy around these requirements serves the primary purpose of ensuring that
    your system satisfies its functional requirements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[*第一章*](B18371_01.xhtml#_idTextAnchor015)《掌握测试驱动开发》中所述，自动化测试应基于我们实施的系统要求。一般来说，系统要求将侧重于成功场景和系统功能扩展的规范。围绕这些要求设计您的测试策略，主要目的是确保您的系统满足其功能需求。
- en: A secondary purpose of your testing strategy should be to verify the behavior
    and robustness of your system-under-failure cases, such as incorrect/unexpected
    input, transient errors, or slow responses. Developers need to ensure that their
    systems are able to gracefully handle all sorts of operating conditions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您的测试策略的次要目的应该是验证系统在故障情况下的行为和鲁棒性，例如错误/意外的输入、瞬态错误或缓慢的响应。开发者需要确保他们的系统能够优雅地处理各种运行条件。
- en: We will learn how to identify these conditions and apply the testing techniques
    we’ve learned so far to devise testing strategies that give us confidence in our
    solutions, regardless of the inputs and the conditions our system operates in.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何识别这些条件，并应用我们迄今为止学到的测试技术，以制定使我们对我们解决方案有信心的测试策略，无论输入和系统运行的条件如何。
- en: '*Figure 4**.1* shows the dual nature of testing, comprising positive and negative
    tests, to ensure that both functionality and error handling is correctly implemented
    in our systems:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.1*展示了测试的双重性质，包括正向和负向测试，以确保我们的系统中功能实现和错误处理都正确：'
- en: '![Figure 4.1 – The two types of tests ](img/Figure_4.01_B18371.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 两种测试类型](img/Figure_4.01_B18371.jpg)'
- en: Figure 4.1 – The two types of tests
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 两种测试类型
- en: 'The two types of tests are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两种测试类型：
- en: '**Positive tests**, which use valid input for the UUT and verify that the expected
    result is returned from the UUT. This type of test ensures that the application
    behaves correctly according to the functional requirements. Positive tests cover
    the following:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正向测试**，使用有效的输入对UUT进行测试，并验证UUT返回预期的结果。此类测试确保应用程序根据功能需求正确运行。正向测试包括以下内容：'
- en: How the UUT handles valid input
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UUT处理有效输入的方式
- en: How the UUT behaves in expected scenarios
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UUT在预期场景中的行为
- en: How the UUT satisfies system requirements
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UUT满足系统要求的方式
- en: '**Negative tests**, which use invalid input for the UUT and verify that an
    error is returned from the UUT. This type of test ensures that the application
    can gracefully handle invalid input, with meaningful errors and avoiding crashes.
    Negative tests cover the following:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负向测试**，使用无效输入对UUT进行测试，并验证UUT返回错误。此类测试确保应用程序能够优雅地处理无效输入，提供有意义的错误信息，并避免崩溃。负向测试包括以下内容：'
- en: How the UUT handles invalid input
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UUT处理无效输入的方式
- en: How the UUT behaves in unexpected scenarios
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UUT在意外场景中的行为
- en: How the UUT behaves outside of system requirements
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UUT在系统要求之外的运行行为
- en: Each of these tests is comprised of different types of test scenarios of varying
    complexity, based on the values of input variables and their combinations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些测试都由不同类型的测试场景组成，这些场景的复杂度根据输入变量的值及其组合而变化。
- en: The importance of negative tests
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 负向测试的重要性
- en: Both positive and negative tests are equally important for production systems.
    Error handling is an important part of the user journey. We want users to receive
    meaningful messages in the case of errors, as well as recover successfully in
    the case of slowdowns or outages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产系统，正向测试和负向测试同等重要。错误处理是用户体验的重要组成部分。我们希望用户在出现错误时能够收到有意义的消息，以及在出现减速或故障时能够成功恢复。
- en: '**Happy path testing** or **happy flow testing** is the verification of the
    default success scenario without any errors or exceptions. Covering the default
    and requirement-specific scenarios ensures that the system behaves well in ideal
    scenarios. However, as developers, we need to know more than the ideal behavior
    of our systems.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**快乐路径测试**或**快乐流程测试**是对默认成功场景的验证，没有任何错误或异常。覆盖默认和要求特定的场景确保系统在理想情况下表现良好。然而，作为开发者，我们需要了解的不仅仅是系统的理想行为。'
- en: '*Figure 4**.2* depicts the different types of test cases for a given input
    parameter of our system. The different types of test cases cover the entire range
    of possible input parameter values:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.2* 描述了我们系统给定输入参数的不同类型的测试用例。不同类型的测试用例涵盖了所有可能的输入参数值范围：'
- en: '![Figure 4.2 – The types of test cases of a given input variable ](img/Figure_4.02_B18371.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 给定输入变量的测试用例类型](img/Figure_4.02_B18371.jpg)'
- en: Figure 4.2 – The types of test cases of a given input variable
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 给定输入变量的测试用例类型
- en: 'A good testing strategy should cover the following four major types of test
    cases of a given input variable:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的测试策略应该涵盖给定输入变量的以下四种主要类型的测试用例：
- en: '**Base cases** occur at the expected values of an operating parameter. For
    example, given an input parameter representing a name, a base case for it would
    be a short valid string value. These cases are often defined in the system requirements
    and make up the scenarios of the happy path testing strategy.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本案例**出现在操作参数的预期值。例如，给定一个表示名称的输入参数，它的基本案例将是一个短的有效字符串值。这些情况通常在系统需求中定义，并构成了快乐路径测试策略的场景。'
- en: '**Edge cases** occur at the extreme of an operating parameter. For example,
    given a string input parameter, some edge cases for it would be an empty string
    value, a multiline string, or a string with special characters.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边缘情况**出现在操作参数的极端。例如，给定一个字符串输入参数，它的某些边缘情况可能是一个空字符串值、多行字符串或包含特殊字符的字符串。'
- en: '**Boundary cases** occur on either side of an edge case, approaching the extreme
    values of an operating parameter. These cases are particularly important for asserting
    values that must have a particular value. For example, given a numeric input parameter
    representing temperature for a water temperature measurement application, we could
    boundary-test its values around the water freezing point and water boiling point.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界情况**出现在边缘情况的两侧，接近操作参数的极端值。这些情况对于断言必须具有特定值的值尤为重要。例如，给定一个表示水温测量应用中水温的数值输入参数，我们可以在水的冰点和沸点周围对其进行边界测试。'
- en: As demonstrated by these examples, edge cases are often based on the data type
    of the input/user parameter, as well as their purpose. We will explore other types
    of parameters and how to identify their extreme/edge-case values in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如这些示例所示，边缘情况通常基于输入/用户参数的数据类型以及它们的目的。我们将在下一节中探讨其他类型的参数以及如何识别它们的极端/边缘值。
- en: Systems will often operate on multiple input variables. The combinations of
    input variables and their edge cases can result in different system behavior.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 系统通常会操作多个输入变量。输入变量及其边缘情况的组合会导致不同的系统行为。
- en: '*Figure 4**.3* demonstrates the final type of test case, which tests the particular
    scenario of multiple edge cases of input variables:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.3* 展示了最终类型的测试用例，它测试了输入变量的多个边缘情况的特定场景：'
- en: '![Figure 4.3 – Corner cases ](img/Figure_4.03_B18371.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 边界情况](img/Figure_4.03_B18371.jpg)'
- en: Figure 4.3 – Corner cases
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 边界情况
- en: '**Corner cases** occur at extremes or edge cases of multiple operating parameters.
    Any combination of edge cases between the two types of input variables would result
    in a corner case. For example, given multiple string input parameters, we would
    achieve a corner case by a combination of any of the edge cases of these parameters.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**边界情况**出现在多个操作参数的极端或边缘情况。两种输入变量之间的任何边缘情况的组合都会导致边界情况。例如，给定多个字符串输入参数，我们可以通过这些参数的任何边缘情况的组合来达到边界情况。'
- en: '*Figure 4**.4* demonstrates the test case combinations of two input variables:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.4* 展示了两个输入变量的测试用例组合：'
- en: '![Figure 4.4 – Combining two input variables in a testing strategy ](img/Figure_4.04_B18371.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 测试策略中结合两个输入变量](img/Figure_4.04_B18371.jpg)'
- en: Figure 4.4 – Combining two input variables in a testing strategy
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 测试策略中结合两个输入变量
- en: As the number of input parameters of our system increases, the number of combinations
    of edge cases increases, resulting in a large number of corner cases that must
    be tested. In order to minimize test writing and maintenance efforts, it’s important
    to identify the subset of user-accessible scenarios from the entirety of possible
    test scenarios. These should be prioritized in the testing strategy, and testing
    can then be extended as the project becomes more mature.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们系统输入参数数量的增加，边缘情况的组合数量也会增加，导致必须测试的大量边缘情况。为了最小化测试编写和维护的工作量，识别从所有可能的测试场景中用户可访问的场景子集非常重要。这些应该在测试策略中优先考虑，并且随着项目的成熟，测试可以进一步扩展。
- en: The difference between edge and corner cases
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘情况和角落情况之间的区别
- en: The terms *edge case* and *corner case* are often used interchangeably. One
    easy way to remember the difference is that an edge case pushes the extremes of
    a parameter, while a corner case combines these extremes by pushing the user to
    a corner configuration.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*边缘情况* 和 *角落情况* 这两个术语经常可以互换使用。一个记住差异的简单方法是，边缘情况推动参数的极端，而角落情况通过将用户推到角落配置来组合这些极端。'
- en: Identifying edge cases
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别边缘情况
- en: There is no particular well-defined procedure for identifying edge cases for
    variables and algorithms. This is where the experience of software testers and
    engineers makes a big difference, as they can intuitively identify edge cases
    of code and requirements upon inspection. We can, however, make some recommendations
    of what to watch out for.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于变量和算法的边缘情况，没有特定的明确程序来识别。这就是软件测试人员和工程师的经验发挥重要作用的地方，因为他们可以通过检查直观地识别代码和需求中的边缘情况。然而，我们可以提出一些需要注意的建议。
- en: '*Figure 4**.5* demonstrates special cases based on the variable type:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4**.5* 展示了基于变量类型的特殊情况：'
- en: '![Figure 4.5 – Special cases of different variable types ](img/Figure_4.05_B18371.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 不同变量类型的特殊情况](img/Figure_4.05_B18371.jpg)'
- en: Figure 4.5 – Special cases of different variable types
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 不同变量类型的特殊情况
- en: 'The special cases of variable types are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 变量类型的特殊情况如下：
- en: 'String-type variables have the following special cases:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串类型变量有以下特殊情况：
- en: An empty or zero character string—`""`.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串或零字符字符串——“`""`”。
- en: A long string, which exceeds the expected length of the base-case valid string—`"a
    very very very very` `long string"`.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个长字符串，超过了基线有效字符串预期的长度——“`a very very very very` `long string`”。
- en: A string containing special characters, including Unicode characters and special
    accent characters—`"a $``p€¢iał string!"`.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含特殊字符的字符串，包括Unicode字符和特殊重音字符——“`a $``p€¢iał string!`”。
- en: A multiline string containing new line delimiters—`"a multi \n line string"`.
    Remember that Go allows the definition of raw string literals by the use of backticks,
    which can also contain other special characters.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含换行分隔符的多行字符串——“`a multi \n line string`”。记住，Go 允许使用反引号定义原始字符串字面量，这也可以包含其他特殊字符。
- en: 'Numeric-type variables have the following special cases:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字类型变量有以下特殊情况：
- en: A zero value—`0`.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零值——“`0`”。
- en: The minimum and maximum values are according to the numeric type. For example,
    the `int8` type has a minimum value of `–128` and a maximum value of `127`, while
    the `uint8` type has a minimum value of `0` and a maximum value of `255`. These
    values increase according to the memory allocation of the given type.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小值和最大值根据数值类型。例如，`int8` 类型有最小值 `-128` 和最大值 `127`，而 `uint8` 类型有最小值 `0` 和最大值 `255`。这些值根据给定类型的内存分配增加。
- en: Positive and negative numeric values may also require special handling, according
    to the logic of the UUT.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正负数值可能也需要根据UUT的逻辑进行特殊处理。
- en: 'Custom `struct` types have the following special cases:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 `struct` 类型有以下特殊情况：
- en: The zero value of the custom struct, with no initialization—`a :=` `MyType{}`.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义结构体的零值，没有初始化——“`a :=` `MyType{}`”。
- en: The nil value of the type, if passed by a pointer—`var` `a *MyType`.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通过指针传递，该类型的空值——“`var` `a *MyType`”。
- en: 'Combinations of initialized and uninitialized fields of the given type—`a :=
    MyType{ field1: "Value"}`. Testing these combinations can reveal whether any fields
    should be added to initialization/constructor functions. While Go does not provide
    default implementations of constructors, it is common to declare package - scoped
    functions that initialize an instance and return it—`func NewMyType(v` `string)
    *MyType`.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '给定类型的初始化和非初始化字段的组合—`a := MyType{ field1: "Value"}`。测试这些组合可以揭示是否应该将任何字段添加到初始化/构造函数中。虽然Go不提供构造函数的默认实现，但通常声明包作用域的函数来初始化实例并返回它—`func
    NewMyType(v string) *MyType`。'
- en: 'Collection types wrap around Go’s in-built collection types—arrays, slices,
    and maps:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合类型封装了Go的内置集合类型—数组、切片和映射：
- en: Zero-element or empty collection—`c := []``int{}`.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零元素或空集合—`c := []int{}`。
- en: One-element or single-element collection—`c := []``int{0}`.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元素或单个元素的集合—`c := []int{0}`。
- en: Nil value or collection with no allocated memory—`var` `c []int`.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值或未分配内存的集合—`var c []int`。
- en: Duplicate elements—`c := []``int{0, 0}`.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复元素—`c := []int{0, 0}`。
- en: Collection with a large number of elements—`var` `c [999]int`.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含大量元素的集合—`var c [999]int`。
- en: The special cases of each variable type should inform your decision as to which
    edge cases you should attempt to cover, but you should extend your edge cases
    to cover the boundaries of any system requirements and edge cases.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每种变量类型的特殊情况应该指导你决定哪些边缘情况你应该尝试覆盖，但你应该扩展你的边缘情况以覆盖任何系统要求的边界和边缘情况。
- en: When formulating your test cases, you should break down the UUT into small logical
    blocks, identify their inputs and their edge cases, then construct your test suites
    to verify these cases accordingly. We will learn how to easily write test suites
    using table-driven testing later on in this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当制定测试用例时，你应该将UUT分解成小的逻辑块，识别它们的输入和边缘情况，然后构建测试套件以相应地验证这些情况。我们将在本章后面学习如何使用表驱动测试轻松编写测试套件。
- en: External services
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部服务
- en: Now that we understand how to identify the edge cases of input parameters based
    on their type and system requirements, we can now turn our attention to testing
    with external services. As discussed in [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061),
    *Mocking and Assertion Frameworks*, any direct dependencies of the UUT should
    be mocked, allowing us to test the UUT in isolation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何根据类型和系统要求识别输入参数的边缘情况，我们现在可以将注意力转向使用外部服务进行测试。如[第3章](B18371_03.xhtml#_idTextAnchor061)中所述，“模拟和断言框架”，UUT的任何直接依赖都应该被模拟，这样我们就可以在隔离的情况下测试UUT。
- en: 'As the Go package provides us with an easy way to build small, self-contained
    APIs, we can treat all dependencies as external services. These dependencies can
    be divided into two categories:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go包为我们提供了一个简单的方式来构建小型、自包含的API，我们可以将所有依赖视为外部服务。这些依赖可以分为两类：
- en: '**Internal system dependencies** are located inside the system we are testing,
    whether inside the same service or not. We have full control of these dependencies.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部系统依赖**位于我们正在测试的系统内部，无论是否在同一服务内部。我们对这些依赖有完全的控制权。'
- en: '**External system dependencies** are located outside the system we are testing,
    providing extra functionality such as a database or third-party functionality.
    We do not have full control of these dependencies.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部系统依赖**位于我们正在测试的系统外部，提供额外的功能，如数据库或第三方功能。我们无法完全控制这些依赖。'
- en: Always mock external system dependencies
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 总是模拟外部系统依赖
- en: As we do not control system dependencies, testing against their live/real versions
    could introduce brittleness and extra costs to our test suites. With the exception
    of databases, you should always mock your external system dependencies. We will
    explore database testing further in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124),
    *Performing* *Integration Testing*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法控制系统依赖，针对它们的实时/真实版本进行测试可能会给我们的测试套件引入脆弱性和额外成本。除了数据库之外，你应该始终模拟你的外部系统依赖。我们将在[第5章](B18371_05.xhtml#_idTextAnchor124)中进一步探讨数据库测试，“执行集成测试”。
- en: When it comes to edge cases of external system dependencies, these APIs will
    most often connect with our system using some kind of network connection. Their
    edge cases are heavily influenced by this connection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到外部系统依赖的边缘情况时，这些API通常会通过某种网络连接与我们系统连接。它们的边缘情况受到这种连接的严重影响。
- en: '*Figure 4**.6* depicts the possible errors that can happen in the integration
    between the UUT and the external service:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4**.6* 展示了 UUT 和外部服务之间集成中可能出现的错误：'
- en: '![Figure 4.6 – Possible errors in communication between the UUT and external
    service ](img/Figure_4.06_B18371.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – UUT 和外部服务之间通信中可能出现的错误](img/Figure_4.06_B18371.jpg)'
- en: Figure 4.6 – Possible errors in communication between the UUT and external service
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – UUT 和外部服务之间通信中可能出现的错误
- en: 'When each part of the exchange is happening over a network, both the request
    and response need to be tolerant of delays and retries:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当交换的每一部分都在网络上进行时，请求和响应都需要能够容忍延迟和重试：
- en: The external service may error out and respond with an internal service error.
    In this case, the UUT will need to handle a full outage and serve a default response.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部服务可能会出错并响应内部服务错误。在这种情况下，UUT 需要处理完全中断并返回默认响应。
- en: The request may take a long time to be delivered to the external service. In
    this case, the UUT will need to wait for the response for a pre-defined amount
    of time and then consider the request failed. The UUT may then decide to retry
    this request to fetch any resources.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求可能需要很长时间才能被传递到外部服务。在这种情况下，UUT 需要等待预定义的时间内的响应，然后认为请求失败。然后，UUT 可能会决定重试此请求以获取任何资源。
- en: The response from the external service may not arrive at all. In this case,
    the UUT will need to retry the whole request cycle and handle this duplicate flow
    in the application logic.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自外部服务的响应可能根本不会到达。在这种情况下，UUT（被测单元）需要重试整个请求周期，并在应用程序逻辑中处理这种重复的流程。
- en: Errors are an inevitable part of writing code and running applications, especially
    those relying on external services for their functionality.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是编写代码和运行应用程序的必然部分，尤其是那些依赖于外部服务功能的应用程序。
- en: Modern systems will rely on many types of external APIs, which can communicate
    over REST APIs, RPC calls, or even asynchronously through event buses. The testing
    concerns of these integrations are similar, as the communication between the UUT
    and the external service will be the most error-prone part of the integration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统将依赖于许多类型的外部 API，这些 API 可以通过 REST API、RPC 调用，甚至通过事件总线异步通信。这些集成的测试关注点是相似的，因为
    UUT 和外部服务之间的通信将是集成中最容易出现错误的部分。
- en: Idempotence as design
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性作为设计原则
- en: In API design, idempotent operations can be called repeatedly without changing
    the initial result. It is considered good practice to design all operations as
    idempotent to ensure that operations can be retried in the case of error recovery.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 设计中，幂等操作可以在不改变初始结果的情况下重复调用。将所有操作设计为幂等是一种良好的实践，以确保在错误恢复的情况下可以重试操作。
- en: Error-handling refresher
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理复习
- en: Up until now, we’ve discussed how to identify possible edge cases and write
    tests for them, but resilience and error handling begins with the implementation
    of the UUT. This is especially true for Go developers, where the language design
    requires the explicit handling of error cases. Let us supplement our discussion
    of edge case identification and error case testing with a brief summary of error
    handling in Go.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何识别可能的边缘情况并为它们编写测试，但弹性和错误处理始于 UUT 的实现。这对于 Go 开发者来说尤其如此，因为语言设计要求显式处理错误情况。让我们通过简要总结
    Go 中的错误处理来补充我们对边缘情况识别和错误情况测试的讨论。
- en: Error handling plays a vital role in writing Go code. The Go team has opted
    for explicit error handling with the built-in `error` type, in order to avoid
    exceptions and `try-catch-finally` style blocks, which can cause brittle and error-prone
    code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理在编写 Go 代码中起着至关重要的作用。Go 团队选择了使用内置的 `error` 类型进行显式错误处理，以避免异常和 `try-catch-finally`
    风格的代码块，这些代码块可能导致脆弱且易于出错的代码。
- en: 'The `error` type is a simple interface:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`error` 类型是一个简单的接口：'
- en: '[PRE0]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This interface also makes it easy for us to create our own custom error types,
    which just need to implement the `Error() string` method. Errors are returned
    just as any other value, most commonly using **multiple return values**, and they
    are handled just like any other return value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口还使我们能够轻松创建自己的自定义错误类型，只需实现 `Error() string` 方法即可。错误就像任何其他值一样返回，最常见的是使用 **多重返回值**，并且它们被处理得就像任何其他返回值一样。
- en: 'For example, we’ve already seen the `Parser` calculator return an error, in
    the case of an invalid mathematical expression:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们已经看到在无效数学表达式中，`Parser` 计算器返回了一个错误：
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The zero value of the error type is `nil`. Most commonly, a `nil` error value
    will signal that no issues have occurred during execution.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 错误类型的零值是`nil`。最常见的情况是，`nil`错误值表示在执行过程中没有发生问题。
- en: 'It is common practice to handle errors first in the code by calling the possibly
    failing expression:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中首先通过调用可能失败的表达式来处理错误是一种常见的做法：
- en: '[PRE2]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we initialize the `err` variable at the same time as the call
    to the erroring function, limiting the scope of the variable to the `if` statement
    block.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们初始化`err`变量与调用错误函数同时进行，将变量的作用域限制在`if`语句块中。
- en: Note that we check for the presence of an error, not its absence. In the case
    of `err != nil`, we simply kill the application with a call to the `log.Fatal`
    function. This is the typical way we handle errors in Go.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们检查的是错误的存在，而不是其不存在。在`err != nil`的情况下，我们简单地通过调用`log.Fatal`函数来终止应用程序。这是我们在Go中处理错误的典型方式。
- en: 'Handling errors explicitly with the `error` type has the following advantages:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`error`类型显式处理错误有以下优点：
- en: '**Guarantees that error cases are handled, avoiding any later panics or nil
    pointers**: Handling errors first, at the top of the function code, reduces checks
    for valid data later on in the function code. This can help simplify code execution
    flow.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保错误情况得到处理，避免任何后续的恐慌或空指针**：在函数代码顶部首先处理错误，可以减少在函数代码后续部分对有效数据的检查。这有助于简化代码执行流程。'
- en: '**Makes it easy to see which error scenarios we need to cover in our testing
    strategy**: The function signature will show which methods and functions can produce
    errors, forcing calling code to handle them explicitly.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使我们可以轻松地看到在测试策略中需要覆盖哪些错误场景**：函数签名将显示哪些方法和函数可以产生错误，迫使调用代码显式地处理它们。'
- en: '`error` type gives all Go codebases a unified way of representing error states,
    which makes it easy to construct and return user-facing errors.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`类型为所有Go代码库提供了一个统一的方式来表示错误状态，这使得构建和返回面向用户的错误变得容易。'
- en: However, some developers find the error-checking code blocks repetitive and
    verbose. A common criticism is that they need to handle all errors, even those
    that are relatively unlikely to happen. Error return values may be disregarded
    by using the `_` operator) or not assigning the return value to any variable,
    but this is commonly discouraged.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些开发者发现错误检查代码块重复且冗长。常见的批评是，他们需要处理所有错误，即使这些错误相对不太可能发生。可以通过使用`_`运算符忽略错误返回值，或者不将返回值分配给任何变量，但这种做法通常是不被鼓励的。
- en: You can make your own opinions on Go’s explicit error handling, but we will
    use it throughout this book as it is a convention and standard practice for how
    we write Go.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己形成对Go的显式错误处理的看法，但在这本书中，我们将使用它，因为它是我们编写Go的约定和标准实践。
- en: Handling errors first but returning them as the last parameter
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先处理错误但将其作为最后一个参数返回
- en: In a function with multiple return values, remember that the error type is typically
    the last return value. You should then handle the error case first, returning
    in the case of abnormal scenarios, and keeping your code minimally indented.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有多个返回值的函数中，请记住错误类型通常是最后一个返回值。然后你应该首先处理错误情况，在异常情况下返回，并保持你的代码最小化缩进。
- en: Table-driven testing in action
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格驱动测试的实际应用
- en: Now that we have discussed the fundamentals of identifying edge cases and handling
    errors, we can begin to look at how to build test suites that cover a variety
    of scenarios. A popular technique in Go is to use **table-driven testing**. This
    technique uses the fundamentals we’ve learned so far to structure test suites
    that cover a variety of scenarios.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了识别边缘情况和处理错误的基础，我们可以开始探讨如何构建覆盖各种场景的测试套件。在Go中，一种流行的技术是使用**表格驱动测试**。这种技术使用我们迄今为止学到的基本原理来构建覆盖各种场景的测试套件。
- en: 'Let us begin with a simple example to demonstrate the test-writing process.
    We will implement a new `Divide` mathematical operation that does the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始，演示测试编写过程。我们将实现一个新的`Divide`数学运算，该运算执行以下操作：
- en: Returns the result formatted as a string to two decimal points
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果格式化为两位小数的字符串返回
- en: Returns an error in the case that the divisor is 0
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当除数为0时返回错误
- en: 'From the preceding requirement, we can formulate the following signature for
    this new operation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的要求中，我们可以为这个新操作制定以下签名：
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We remember that the minimum value of `int8` is `–128` and the maximum value
    is `127`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记得`int8`的最小值是`-128`，最大值是`127`。
- en: 'As previously discussed, we make use of multiple return values to encourage
    explicit error handling in the calling code. Based on the functionality requirements
    and the lessons learned from the previous *Identifying edge cases* section, we
    can identify the following test cases:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们利用多个返回值来鼓励在调用代码中显式处理错误。根据功能需求和从前面的*识别边缘情况*部分学到的经验，我们可以确定以下测试用例：
- en: '`x` and `y`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`和`y`'
- en: Two negative values for `x` and `y`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`和`y`的两种负值'
- en: '`x` and `y`*   Maximum value for `x` and positive value for `y`*   Minimum
    value for `x` and positive value for `y`*   A zero value of `x` and a nonzero
    value for `y`*   A positive value of `x` and a zero value for `y`*   `x` and `y`*   Maximum
    values for `x` and `y`*   Minimum values for `x` and `y`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`和`y`的最大值和`y`的正值、`x`的最小值和`y`的正值、`x`的零值和`y`的非零值、`x`的正值和`y`的零值、`x`和`y`、`x`和`y`的最大值、`x`和`y`的最小值'
- en: 'In [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035), *Unit Testing Essentials*,
    we saw how to write tests and implement different scenarios with subtests. This
    involves declaring a shared test setup and declaring a subtest for each case.
    For example, the implementation of the first test case could look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B18371_02.xhtml#_idTextAnchor035) *单元测试基础*中，我们学习了如何编写测试和通过子测试实现不同的场景。这涉及到声明共享的测试设置并为每个情况声明一个子测试。例如，第一个测试用例的实现可能如下所示：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we can see from the highlighted lines in this code snippet, the following
    components are the ones that change according to the test case we are running:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从代码片段中高亮显示的行中可以看出，以下组件是会根据我们正在运行的测试用例而变化的：
- en: The name of the test case, which will make our test output easy to read
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用例的名称，这将使我们的测试输出易于阅读
- en: The inputs that will change values according to the test case we are running
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据我们正在运行的测试用例，将改变值的输入
- en: The expected result value and error value according to the test case we are
    running
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据我们正在运行的测试用例，预期的结果值和错误值
- en: 'As can be seen from the previous snippet, there is quite a bit of boilerplate
    code that can be reused across test cases:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码片段所示，有相当多的样板代码可以在测试用例之间重用：
- en: The declaration of the test function and any required UUT setup
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试函数的声明以及任何所需的UUT（单元待测项）设置
- en: The declaration of the subtest and its nested testing function
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子测试的声明及其嵌套的测试函数
- en: The invocation of the `Divide` function with its input values
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`Divide`函数及其输入值
- en: As the interaction with the `*testing.T` object is the most verbose part of
    the test implementation, a shorter and simpler alternative to test cases is to
    use table-driven tests, which we will learn all about in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与`*testing.T`对象的交互是测试实现中最冗长的一部分，因此使用表格驱动测试作为测试用例的更简短、更简单的替代方案。我们将在下一节中详细了解这一点。
- en: Implementing table-driven tests has a very simple recipe. We will use the example
    of the `Divide` function from the previous section to demonstrate each step.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实现表格驱动测试有一个非常简单的配方。我们将使用前一个章节中的`Divide`函数示例来演示每个步骤。
- en: Step 1 – declaring the function signature
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步 - 声明函数签名
- en: 'We begin by declaring the function signature that we have presented previously
    and writing only enough code to make the code compile:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明之前提出的函数签名，并编写足够的代码以使代码编译：
- en: '[PRE5]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The signature of the function returns a pointer to a string and an error. In
    practice, we expect only one of the two values to ever be `nil`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的签名返回一个字符串指针和一个错误。在实际应用中，我们期望这两个值中只有一个会是`nil`：
- en: In the normal flow, the result string will be non-nil, and the error value will
    be nil
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在正常流程中，结果字符串将非`nil`，错误值将`nil`
- en: In the abnormal flow, the result string will be nil, and the error value will
    be non-nil
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在异常流程中，结果字符串将`nil`，错误值将非`nil`
- en: Therefore, by setting both values to nil, we will guarantee that there will
    be no accidentally passing test cases. This helps us begin the red phase of the
    **red-green-refactor** **test-driven development** (**TDD**) process.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过将两个值都设置为`nil`，我们可以保证不会有意外通过测试用例。这有助于我们开始**红-绿-重构**（**TDD**）过程的红色阶段。
- en: Step 2 – declaring a structure for our test case
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步 - 声明我们的测试用例的结构
- en: The first step of writing test code is to declare a custom type to wrap around
    our test case. The purpose of this structure is to hold the inputs and expected
    outputs of the test case. Generally, this type is declared inside the scope of
    the function test, but it can also be shared across tests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试代码的第一步是声明一个自定义类型来包装我们的测试用例。这种结构的目的在于保存测试用例的输入和预期输出。通常，这种类型是在函数测试的作用域内声明的，但它也可以在测试之间共享。
- en: 'The test case of our `Divide` function looks like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`Divide`函数的测试用例看起来是这样的：
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This custom type is a simple `struct` type that wraps around `x` and `y`—the
    two inputs of the function and the two expected results of the function—the formatted
    result and the possible returned error. Note that in Go it is customary to name
    the expected result as `want` or with the `want` prefix. This is different from
    other languages, where the naming convention begins with the word `expected`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自定义类型是一个简单的`struct`类型，它围绕`x`和`y`（函数的两个输入和两个预期结果——格式化的结果和可能的返回错误）包装。请注意，在Go中，习惯于将预期结果命名为`want`或带有`want`前缀。这与其他语言不同，其他语言的命名约定以单词`expected`开头。
- en: Step 3 – creating our test-case collection
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步 – 创建我们的测试用例集合
- en: 'Now that we have a way to express our test cases, we can begin to create a
    collection of all the cases we want to test for our function. Based on the two
    base cases that we identified for the `Divide` function in the previous section,
    we can create the following `tests` collection:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了表达测试用例的方法，我们可以开始创建一个包含我们想要测试的所有函数测试用例的集合。基于我们在上一节中为`Divide`函数确定的两个基本用例，我们可以创建以下`tests`集合：
- en: '[PRE7]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We prefer to use `map` to add a corresponding name to the test case, which allows
    us to add the name as a key and the test case as a value. An alternative solution
    is to use a slice and save the name of the test case as a field in the `testCase`
    type.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢使用`map`为测试用例添加相应的名称，这允许我们将名称作为键，将测试用例作为值。另一种解决方案是使用切片并将测试用例的名称作为`testCase`类型的字段保存。
- en: Note that we don’t provide a value to the `wantErr` field in the previous test
    case, as the base cases do not require the verification of errors. The zero value
    of the error type is `nil`, so not setting a value for it will be equivalent to
    declaring a happy path test case.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在之前的测试用例中没有为`wantErr`字段提供值，因为基本用例不需要验证错误。错误类型的零值是`nil`，因此不设置值将等同于声明一个快乐路径测试用例。
- en: 'We can further optimize our implementation of the `tests` map by using anonymous
    `struct` types for our `testCase` type to reduce boilerplate and keep the scope
    of the `testCase` type small:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用匿名`struct`类型来进一步优化我们的`tests`映射实现，以减少样板代码并保持`testCase`类型的范围小：
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This can further shorten the test declaration but will not allow us to share
    the `testCase` type between tests.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以进一步缩短测试声明，但不会允许我们在测试之间共享`testCase`类型。
- en: Step 4 – executing each test
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4步 – 执行每个测试
- en: 'With our table of tests in place, we will execute each test case as a subtest.
    We will use the `range` statement to loop through the map of tests, which will
    return the name of the test case and the test case instance itself. Then, we pass
    the test name as the subtest name and use the test case during the test setup
    and execution:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试表就绪后，我们将执行每个测试用例作为一个子测试。我们将使用`range`语句遍历测试映射，这将返回测试用例的名称和测试用例实例本身。然后，我们将测试名称作为子测试名称传递，并在测试设置和执行期间使用测试用例：
- en: '[PRE9]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This step allows us to set up the interaction with the test runner in one single
    block for the entire test suite. Remember that each subtest is its own function,
    so we can individually fail tests or stop the execution of the entire test suite
    using the `testing.T` helpers that we have explored in [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035),
    *Unit* *Testing Essentials*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步允许我们在整个测试套件中用一个单独的块设置与测试运行器的交互。记住，每个子测试都是一个自己的函数，因此我们可以单独失败测试或使用我们在[*第2章*](B18371_02.xhtml#_idTextAnchor035)，“单元测试基础”中探索的`testing.T`辅助程序停止整个测试套件的执行。
- en: Step 5 – implementing the test assertions
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5步 – 实现测试断言
- en: 'Once we have set up the `tests` map and its interaction with the test runner,
    we can begin to implement the testing logic based on the inputs and outputs defined
    in the `testCase` type:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了`tests`映射及其与测试运行器的交互，我们就可以根据在`testCase`类型中定义的输入和输出开始实现测试逻辑：
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Based on the `tc` test case value retrieved from the `tests` map, we use its
    values of `x` and `y` to invoke the `Divide` function. Then, we verify the error
    value and the result value from the `tc` test case as well. Note that, just as
    we do with error handling, we verify the error value first and return from the
    test in the case of the error case.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据从`tests`映射中检索到的`tc`测试用例值，我们使用其`x`和`y`的值来调用`Divide`函数。然后，我们验证`tc`测试用例中的错误值和结果值。注意，正如我们在错误处理中所做的那样，我们首先验证错误值，并在错误情况下从测试中返回。
- en: Step 6 – running the failing test
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6步 – 运行失败的测试
- en: 'Our table-driven test suite has successfully been implemented in five easy
    steps! The basics of running tests and assertions are in place, so we can now
    run the tests and see them fail. We can now run the test with the `go test` command,
    as we have done so far:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地在五个简单步骤中实现了表驱动测试套件！测试运行和断言的基本知识已经到位，因此我们现在可以运行测试并看到它们失败。我们现在可以使用`go test`命令运行测试，就像我们迄今为止所做的那样：
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see from the output, all the tests are run in their own subtest with
    the given scenario name passed to the test runner. The `–v` flag is the `verbose`
    flag, which will show the full output of all the tests that are run.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从输出中可以看到，所有测试都在自己的子测试中运行，并将给定的场景名称传递给测试运行器。`-v`标志是`verbose`标志，它将显示所有运行的测试的完整输出。
- en: Step 7 – implementing the base cases
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7步 – 实现基础情况
- en: 'We now begin to implement the `Divide` function happy path cases. We will write
    two simple lines of code that will allow the tests of the base cases to pass:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始实现`Divide`函数的happy path测试用例。我们将编写两行简单的代码，这将允许测试用例的基础测试通过：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These two lines of code will handle the normal program flow. We then rerun
    the base case tests that we have written so far and see them pass:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码将处理正常的程序流程。然后我们重新运行我们迄今为止编写的所有基础情况测试，并看到它们通过：
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once these tests pass, we enter the green phase of the red-green-refactor TDD
    process.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些测试通过，我们就进入了红-绿-重构TDD过程的绿色阶段。
- en: Step 8 – expanding the test case collection
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8步 – 扩展测试用例集合
- en: 'With the base case tests passing, it’s time to expand our test case collection
    to include error cases. Based on the 10 test cases that we identified for the
    `Divide` function in the previous section, we can add the following cases to the
    `tests` collection:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基础测试用例通过，现在是时候扩展我们的测试用例集合以包括错误情况。根据我们在上一节中为`Divide`函数确定的10个测试用例，我们可以将以下情况添加到`tests`集合中：
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In practice, we would expand each of the edge and corner cases one at a time,
    ensuring that each of them passes. However, we will add them all in one step,
    for the purpose of brevity.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们会逐个扩展每个边缘和角落情况，确保每个都通过。然而，为了简洁起见，我们将一次性添加它们所有。
- en: Step 9 – expanding functional code
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9步 – 扩展功能代码
- en: 'As expected, the new error edge cases will fail when run with the typical `go
    test` command, prompting us to implement functional code. We expand our `Divide`
    function to handle the error case described in the user requirements:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，当使用典型的`go test`命令运行时，新的错误边缘情况将失败，这促使我们实现功能代码。我们将`Divide`函数扩展以处理用户要求中描述的错误情况：
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As usual, the error case is handled at the top of the function, keeping the
    code minimally indented. Note that we initialize an error using the `errors.New`
    function, which takes in a message. We can initialize errors in other ways as
    well.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常一样，错误情况在函数顶部处理，保持代码的最小缩进。注意，我们使用`errors.New`函数初始化错误，该函数接受一个消息。我们也可以用其他方式初始化错误。
- en: 'The final step is to run our fully implemented table-driven test suite using
    the `go` `test` command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用`go test`命令运行我们完全实现的表驱动测试套件：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see from the output, all the tests are run successfully in their own
    subtest, with the given scenario name passed to the test runner. Our first table-driven
    test suite has been successfully implemented. This is a common testing technique
    that you will often use when you write Go code, so it’s important to master its
    methods.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从输出中可以看到，所有测试都在自己的子测试中成功运行，并将给定的场景名称传递给测试运行器。我们的第一个表驱动测试套件已经成功实现。这是你在编写Go代码时经常会使用的一种常见测试技术，因此掌握其方法是重要的。
- en: Parallelization
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行化
- en: By default, all the tests in each package will be run sequentially, but tests
    from multiple packages will run in parallel. As the number of tests increases,
    the sequential test execution time of a given package can increase as well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个包中的所有测试都将按顺序运行，但来自多个包的测试将并行运行。随着测试数量的增加，给定包的顺序测试执行时间也会增加。
- en: '*Figure 4**.7* demonstrates the behavior of sequential and parallel test runs:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4**.7* 展示了顺序和并行测试运行的行为：'
- en: '![Figure 4.7 – Sequential versus parallel test runs ](img/Figure_4.07_B18371.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 顺序与并行测试运行](img/Figure_4.07_B18371.jpg)'
- en: Figure 4.7 – Sequential versus parallel test runs
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 顺序与并行测试运行
- en: 'The test run life cycle is set out here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行的生命周期如下：
- en: The tests begin running. Tests in different packages run in parallel—tests in
    `package A` can run at the same time as tests in `package B`. This allows us to
    reduce running time.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试开始运行。不同包中的测试并行运行——`包 A`中的测试可以与`包 B`中的测试同时运行。这使我们能够减少运行时间。
- en: By default, test cases in the same package run sequentially. This is demonstrated
    by the tests in `package A`—`TestCase 1` needs to complete before `TestCase 2`
    can run.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，同一包中的测试用例按顺序运行。这可以通过`包 A`中的测试用例来演示——`TestCase 1`需要完成，`TestCase 2`才能运行。
- en: The test cases in the same package can be configured to run in parallel. This
    is demonstrated by the tests in `package B`—`TestCase 1` can run concurrently
    with `TestCase 2`.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一包中的测试用例可以被配置为并行运行。这可以通过`包 B`中的测试用例来演示——`TestCase 1`可以与`TestCase 2`同时运行。
- en: The number of tests that we can run in parallel is limited by the resources
    available to the test runner, but parallelizing test runs is a great way to reduce
    the test run time, which can further reduce the feedback cycle of CI/CD pipelines.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以并行运行的测试数量受测试运行器可用资源的限制，但并行化测试运行是减少测试运行时间的好方法，这可以进一步减少 CI/CD 管道中的反馈周期。
- en: The `*testing.T` type provides the `t.Parallel()` method, which allows us to
    specify which tests can be run in parallel with other parallel marked tests from
    the same package. As the subtests of our table-driven test run independently,
    we need to mark each as parallel and not just the top-level test.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`*testing.T` 类型提供了 `t.Parallel()` 方法，允许我们指定哪些测试可以与同一包中其他标记为并行的测试并行运行。由于我们的表驱动测试的子测试是独立运行的，我们需要将每个子测试标记为并行，而不仅仅是顶层测试。'
- en: 'The ability to mark certain tests for parallelization is particularly useful
    together with table-driven tests, which contain independently running test cases.
    We can easily adjust our table-driven tests to run in parallel with two short
    lines of code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 标记某些测试以进行并行化特别有用，尤其是与包含独立运行测试用例的表驱动测试一起使用。我们可以通过两行简短的代码轻松调整我们的表驱动测试以并行运行：
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We assign the current test case to a local `tc` variable to capture the test
    case range variable. This is required as the subtest will now run in a goroutine
    under the hood. We need to create a copy of the current value of the test case
    to the subtest closure, as opposed to the changing range return value.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将当前测试用例分配给本地 `tc` 变量以捕获测试用例范围变量。这是必需的，因为子测试现在将在底层的 goroutine 中运行。我们需要将当前测试用例的当前值复制到子测试闭包中，而不是变化的范围返回值。
- en: The second change we have made is to add the call to `t.Parallel()` in the subtest,
    marking each of the subtests as allowed to be run in parallel.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的第二个更改是在子测试中添加了对 `t.Parallel()` 的调用，将每个子测试标记为允许并行运行。
- en: By default, the number of binaries that can run in parallel is equal to the
    number of CPUs. This variable can be overridden by the `–parallel` flag, available
    on the `go` `test` command.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，可以并行运行的二进制文件数量等于 CPU 的数量。这个变量可以通过`go test`命令上的`–parallel`标志来覆盖。
- en: 'With our table-driven tests marked as parallel, we can run our tests again
    using `go test`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的表驱动测试标记为并行后，我们可以再次使用 `go test` 运行我们的测试：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the test run has been shortened. As we can see from the interleaving
    output, the tests are now running in parallel, in an interleaving manner: run,
    pause, and continue.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行的输出已被缩短。正如我们从交错输出中可以看到的，测试现在以交错方式并行运行：运行、暂停和继续。
- en: Advantages and disadvantages of table-driven testing
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表驱动测试的优缺点
- en: This brings us to the end of our exploration of table-driven testing. Let us
    conclude with a short discussion of its advantages and disadvantages. Table-driven
    tests are best suited to scenarios that cover a variety of test cases with different
    inputs and outputs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到了对表驱动测试探索的结尾。让我们通过对其优缺点的简要讨论来结束。表驱动测试最适合涵盖具有不同输入和输出的各种测试用例的场景。
- en: Advantages
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优势
- en: 'Table-driven tests have the following advantages:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 表驱动测试有以下优点：
- en: Provide a concise way to define and run multiple test cases, which reduces boilerplate
    code
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一种简洁的方式来定义和运行多个测试用例，从而减少了样板代码
- en: Easy to add and remove new tests by simply modifying the collection of test
    cases
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过简单地修改测试用例集合，可以轻松地添加和删除新的测试。
- en: As all of the test cases are run using the same surrounding code, we can easily
    refactor the test setup and assertion code
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于所有测试用例都使用相同的周围代码运行，我们可以轻松地重构测试设置和断言代码。
- en: Disadvantages
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缺点
- en: 'Here are some disadvantages of table-driven tests:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是表格驱动测试的一些缺点：
- en: As all the test cases are run identically, it may be difficult to create even
    small variations of the test setup and assertion code.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于所有测试用例都是相同地运行的，可能很难创建甚至小的测试设置和断言代码的变体。
- en: Table-driven tests are not suitable for test cases that require different test
    setup and teardown logic. They also make it difficult to use mocks, which must
    behave differently.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格驱动测试不适用于需要不同测试设置和拆卸逻辑的测试用例。它们还使得使用必须表现不同的模拟变得困难。
- en: Some developers argue that table-driven tests are difficult to read. While the
    name of the test case allows us to name each test, the code is not readable, especially
    when compared to the **behavior-driven development** (**BDD**) style of writing
    tests.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些开发者认为表格驱动测试难以阅读。虽然测试用例的名称允许我们为每个测试命名，但代码本身并不易读，尤其是与编写测试的**行为驱动开发**（**BDD**）风格相比。
- en: When implemented correctly, table-driven tests are a great way to test your
    code across a variety of scenarios and edge cases. They help us create a uniform
    way of running tests, which also makes it easy to maintain and refactor test code.
    Many developers advocate implementing your tests as table-driven tests from the
    very beginning, even if you don’t have many test cases when you get started. As
    your code matures, you will have an easy way to add new test cases.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确实施时，表格驱动测试是测试您代码在各种场景和边缘情况下的绝佳方式。它们帮助我们创建一种统一的测试运行方式，这也使得维护和重构测试代码变得容易。许多开发者提倡从一开始就实施表格驱动测试，即使您在开始时没有很多测试用例。随着您的代码成熟，您将有一个简单的方法来添加新的测试用例。
- en: If you have large variations in test setup, you can use different tests and
    dedicated subtests to group your tests.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试设置有较大的变化，您可以使用不同的测试和专门的子测试来分组您的测试。
- en: Use case – the BookSwap application
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - `BookSwap`应用程序
- en: 'One of the most popular use cases of Go is for building web applications. Therefore,
    it is important to know how to build and test web applications. We will learn
    how to build our first use case web application: the `BookSwap` application. We
    will explore and test the `BookSwap` application in this and the following chapters.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言最流行的用例之一是构建Web应用程序。因此，了解如何构建和测试Web应用程序非常重要。我们将学习如何构建我们的第一个用例Web应用程序：`BookSwap`应用程序。我们将在本章和下一章中探索和测试`BookSwap`应用程序。
- en: This simple application allows users to sign up and register which books they
    have available. Other users can sign up for the application and view other users’
    available books. They can then request to borrow a book from another user. The
    `BookSwap` application then generates an order and sends it to the posting service
    for wrapping and shipping.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的应用程序允许用户注册并登记他们可用的书籍。其他用户可以注册应用程序并查看其他用户的可用书籍。然后他们可以请求从其他用户那里借阅一本书。`BookSwap`应用程序随后生成一个订单并将其发送到发布服务进行包装和运输。
- en: '*Figure 4**.8* depicts an overview of the `BookSwap` application:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.8*展示了`BookSwap`应用程序的概述：'
- en: '![Figure 4.8 – Overview of the book swap web application ](img/Figure_4.08_B18371.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – 书籍交换Web应用程序概述](img/Figure_4.08_B18371.jpg)'
- en: Figure 4.8 – Overview of the book swap web application
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 书籍交换Web应用程序概述
- en: 'The `BookSwap` web application has some simple components:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookSwap` Web应用程序有一些简单的组件：'
- en: 'The user interacts with the `UserService` service endpoints. It exposes a few
    simple endpoints that provide all the functionality the application requires:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户与`UserService`服务端点进行交互。它公开了一些简单的端点，提供了应用程序所需的所有功能：
- en: '`GET /` returns a welcome message and all the book listings available in the
    application. This endpoint will serve as the application home page, which will
    show all the available books that users can swap. For completion, the `GET /books`
    endpoint will also return a list of available books.'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /`返回一个欢迎信息和应用程序中所有可用的书籍列表。此端点将作为应用程序的主页，将显示所有可交换的可用书籍。为了完整性，`GET /books`端点也将返回可用书籍列表。'
- en: '`POST /users` creates a new user. The user will receive a unique `userID` value,
    which they will need to remember for further interactions. For the sake of simplicity,
    we will not handle user authentication or any security concerns.'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /users` 创建一个新的用户。用户将收到一个唯一的 `userID` 值，他们需要记住这个值以进行后续交互。为了简化，我们不会处理用户认证或任何安全问题。'
- en: '`GET /users/{id}` returns the book listings of the given user. This endpoint
    will serve as the profile page of a given user.'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /users/{id}` 返回给定用户的书籍列表。此端点将作为给定用户的个人资料页面。'
- en: 'The `UserService` service relies on the `BookService`. It manages the details
    and statuses of all the books available in the `BookSwap` web application. It
    exposes the following endpoints:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserService` 服务依赖于 `BookService`。它管理 `BookSwap` 网络应用程序中所有可用的书籍的详细信息和服务状态。它公开以下端点：'
- en: '`POST /books` creates a new book listing on the `BookSwap` service. This request
    will take the details of the book to create a JSON request body.'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /books` 在 `BookSwap` 服务上创建一个新的书籍列表。此请求将包含书籍的详细信息以创建 JSON 请求体。'
- en: '`POST /books/{id}?user={userId}` creates a new request for a particular book
    and given user. This will create a request to send the given book to a new user.'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /books/{id}?user={userId}` 为特定书籍和给定用户创建一个新的请求。这将创建一个请求将给定的书籍发送给新用户。'
- en: '`BookService` has a dependency on the external posting service, which handles
    the creation of mail stamps and issues a request for packaging. Once `PostingService`
    has handled the order request, we can mark the book as swapped and update its
    `ownerID` value.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookService` 依赖于外部发布服务，该服务处理邮件标签的创建并发出包装请求。一旦 `PostingService` 处理了订单请求，我们就可以标记书籍为已交换并更新其
    `ownerID` 值。'
- en: You can explore the full implementation of the `BookSwap` application on our
    GitHub repository. The application is implemented using the `net/http` package
    in the standard library. We will explore some relevant parts of the `BookSwap`
    web application in this chapter, which showcase what we have learned in this chapter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的 GitHub 仓库中探索 `BookSwap` 应用程序的完整实现。该应用程序使用标准库中的 `net/http` 包实现。在本章中，我们将探索
    `BookSwap` 网络应用程序的一些相关部分，这些部分展示了我们在本章中学到的内容。
- en: Testing BookService
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 BookService
- en: 'We will represent books as a very simple data type that uses JSON tags to format
    its contents for display on REST APIs, which serve JSON data:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个非常简单的数据类型来表示书籍，该类型使用 JSON 标签来格式化其内容，以便在 REST API 上显示，这些 API 提供 JSON 数据：
- en: '[PRE19]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While REST APIs don’t have to operate on JSON data, the `application/json` data
    format is the most used. The book has `OwnerID` and `Status`, which shows whether
    the book is available for swaps.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 REST API 不必操作 JSON 数据，但 `application/json` 数据格式是最常用的。书籍有 `OwnerID` 和 `Status`，这显示了书籍是否可用于交换。
- en: '`BookService` is a very simple service that manages books. It will need to
    be able to retrieve and manage books with six simple methods:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookService` 是一个非常简单的服务，用于管理书籍。它需要能够使用六个简单的方法检索和管理书籍：'
- en: '[PRE20]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `NewBookService` method initializes `BookService` with a given list of books
    and a `PostingService` service. The `Get` method attempts to find a book for a
    given ID, returning an error if not found. The `Upsert` method creates a new book
    entry or updates the entry if the given ID is already found. The `List` operation
    returns all the books that are available for loan. `ListByUser` filters all books
    for a given owner, allowing us to power the home page of a given user. `SwapBook`
    is a function that wraps around availability, checking and updating the owner
    ID of a given book in case of a swap request.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewBookService` 方法使用给定的书籍列表和一个 `PostingService` 服务初始化 `BookService`。`Get`
    方法尝试根据给定的 ID 查找书籍，如果没有找到则返回错误。`Upsert` 方法创建一个新的书籍条目或如果已找到给定 ID 则更新条目。`List` 操作返回所有可借阅的书籍。`ListByUser`
    过滤给定所有者的所有书籍，使我们能够为给定用户的首页提供动力。`SwapBook` 是一个函数，它围绕可用性进行包装，检查并更新给定书籍在交换请求中的所有者
    ID。'
- en: '`BookService` will save the book entries on a map with their ID as the key:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookService` 将使用其 ID 作为键在映射中保存书籍条目：'
- en: '[PRE21]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The map will facilitate lookup operations, which will be required for the `BookSwap`
    application. The `Get` and `List` operations are expected to be the most popular,
    as they will appear on the homepage and profile pages.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 映射将简化查找操作，这对于 `BookSwap` 应用程序是必需的。`Get` 和 `List` 操作预计将是最受欢迎的，因为它们将出现在首页和个人资料页面上。
- en: 'Let us have a look at how we can formulate the table-driven tests for the `Get`
    operation of the `BookService`. We declare a test with two corresponding subtests—one
    for an initial amount of books and one for an empty book map:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何为`BookService`的`Get`操作制定表格驱动测试。我们声明了一个测试，其中包含两个相应的子测试——一个用于初始书籍数量，一个用于空书籍映射：
- en: '[PRE22]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We use two different subtests for the two cases, as they require two different
    test setups. As we have discussed, table-driven tests are not suitable for scenarios
    that require different setup conditions. We begin by creating a sample book and
    creating a new `BookService` instance:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种情况，我们使用两个不同的子测试，因为它们需要不同的测试设置。正如我们讨论的那样，表格驱动测试不适用于需要不同设置条件的场景。我们首先创建一个示例书籍并创建一个新的`BookService`实例：
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This starting point will be shared by all test cases in this subtest. Note
    that we pass a `nil` value as the `PostingService` service, as it will not be
    tested by these tests. Then, we implement a table-driven test with three scenarios
    in the first subtest:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个起点将在这个子测试中的所有测试用例中共享。请注意，我们传递一个`nil`值作为`PostingService`服务，因为这些测试将不会对其进行测试。然后，我们在第一个子测试中实现一个包含三个场景的表格驱动测试：
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The three cases consist of finding an existing book, looking for a book that
    is not found in `BookService`, and looking for an empty ID. Then, we loop through
    the test cases and run the assertions according to the inputs and expectations
    of the test case:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 三种情况包括寻找现有书籍、寻找在`BookService`中找不到的书籍，以及寻找空ID。然后，我们遍历测试用例并按照测试用例的输入和预期运行断言：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Just as we did in the *Table-driven testing in action* section, we loop through
    the map of test cases and handle the error cases first. Remember to verify all
    the wanted return values.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*表格驱动测试实战*部分所做的那样，我们遍历测试用例的映射，并首先处理错误情况。请记住验证所有期望的返回值。
- en: 'In the second subtest, named `"empty books"`, we have run a single test and
    performed the required verifications on a different UUT instance:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为`"empty books"`的第二个子测试中，我们运行了一个单独的测试并在不同的UUT实例上执行了所需的验证：
- en: '[PRE26]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We could have potentially implemented table-driven tests for the second subtest
    as well, but we have opted to include a single test here to keep the code snippets
    concise.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以也为第二个子测试实现表格驱动测试，但我们选择在这里只包含一个测试，以保持代码片段简洁。
- en: 'Finally, we run our tests using the `go test` command to ensure that they are
    passing:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`go test`命令运行我们的测试，以确保它们通过：
- en: '[PRE27]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that the output shows the nesting of the two different subtests. This allows
    us to build detailed test hierarchies. We will continue to explore and test other
    parts of the `BookSwap` application in the next few chapters, so there will be
    plenty of time to explore it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出显示了两个不同子测试的嵌套。这使我们能够构建详细的测试层次结构。我们将在接下来的几章中继续探索和测试`BookSwap`应用程序的其他部分，因此将有足够的时间去探索它。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored how to identify edge cases and write test suites
    that cover multiple conditions. We began with how to identify edge cases for systems
    with input parameters and external services, revising Go’s approach to explicit
    error handling. Then, we learned how to implement table-driven testing. This popular
    technique allows us to test multiple scenarios with a minimal amount of boilerplate
    code. It also allows running test cases in parallel, enabling us to make optimizations
    for the running of test cases as well. Finally, we introduced our new use case—the
    BookSwap web application. This example application will be the focus of the next
    few chapters, where we will learn how to test one of Go’s most popular use cases:
    building web applications.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何识别边缘情况并编写覆盖多个条件的测试套件。我们从如何识别具有输入参数和外部服务的系统的边缘情况开始，回顾了Go的显式错误处理方法。然后，我们学习了如何实现表格驱动测试。这种流行的技术允许我们用最少的样板代码测试多个场景。它还允许并行运行测试用例，使我们能够对测试用例的运行进行优化。最后，我们介绍了我们的新用例——BookSwap网络应用程序。这个示例应用程序将是下一章的重点，我们将学习如何测试Go最受欢迎的用例之一：构建网络应用程序。
- en: In [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124), *Performing Integration
    Testing*, we will begin to consider how to use TDD for testing **end-to-end**
    (**E2E**) applications, including database testing. We will also learn how to
    use Docker for identical application setup and easy teardown.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B18371_05.xhtml#_idTextAnchor124)《执行集成测试》中，我们将开始考虑如何使用TDD测试**端到端**（**E2E**）应用程序，包括数据库测试。我们还将学习如何使用Docker进行相同的应用程序设置和简单的拆卸。
- en: In [*Chapter 10*](B18371_10.xhtml#_idTextAnchor218), *Testing Edge Cases*, we
    will explore other testing techniques, such as fuzz testing and property-driven
    testing, which can make edge case verification even easier.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B18371_10.xhtml#_idTextAnchor218)，*测试边缘情况*中，我们将探讨其他测试技术，例如模糊测试和属性驱动测试，这些技术可以使边缘情况验证更加容易。
- en: Questions
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is an edge case? What is a corner case?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 边缘情况是什么？角落情况是什么？
- en: What is an idempotent operation?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是幂等操作？
- en: Explain Go’s explicit error handling.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释 Go 的显式错误处理。
- en: What is table-driven testing? What are some of its advantages?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是表驱动测试？它有哪些优点？
- en: How does Go parallelize test runs?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go 如何并行化测试运行？
- en: Further reading
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Building Microservices Second edition: Designing Fine-Grained Systems*, *Sam
    Newman*, published by *O’Reilly*.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《构建微服务 第二版：设计细粒度系统》*，*山姆·纽曼* 著，由 *O’Reilly* 出版。'
- en: '*Error handling and Go on the Go blog*. Available at [https://go.dev/blog/error-handling-and-go](https://go.dev/blog/error-handling-and-go).'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误处理和 Go 在 Go 博客上*。可在 [https://go.dev/blog/error-handling-and-go](https://go.dev/blog/error-handling-and-go)
    查阅。'
- en: 'Part 2: Integration and End-to-End Testing with TDD'
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：使用 TDD 进行集成和端到端测试
- en: With the fundamentals of TDD and Go testing in place, this part moves our focus
    beyond testing components in isolation. We explore the importance of integration
    testing and learn how to write tests using `httptest` and `ginkgo` to test the
    `BookSwap` web application. Then, we extend the functionality of the application
    by adding a database and containerizing it using Docker, which allows us to create
    identical test setups. Once the application is extended into a monolithic application,
    we use `GoDog` to implement end-to-end testing using BDD-style features. However,
    refactoring is an integral part of the development process, often applied to splitting
    monolithic applications to microservice architectures. We examine testing microservice
    integrations using contract testing, implemented using the Pact open-source testing
    tool.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TDD 和 Go 测试的基础知识已经建立之后，这部分内容将我们的关注点从单独测试组件扩展到更广泛的内容。我们探讨了集成测试的重要性，并学习了如何使用
    `httptest` 和 `ginkgo` 编写测试来测试 `BookSwap` 网络应用程序。然后，我们通过添加数据库并使用 Docker 容器化应用程序来扩展其功能，这使我们能够创建相同的测试设置。一旦应用程序扩展为一个单体应用程序，我们就使用
    `GoDog` 通过 BDD 风格的特性来实现端到端测试。然而，重构是开发过程中的一个重要部分，通常应用于将单体应用程序拆分为微服务架构。我们通过使用 Pact
    开源测试工具实现的合同测试来检查微服务集成。
- en: 'This part has the following chapters:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B18371_05.xhtml#_idTextAnchor124)*, Performing Integration Testing*'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18371_05.xhtml#_idTextAnchor124)*，执行集成测试*'
- en: '[*Chapter 6*](B18371_06.xhtml#_idTextAnchor142)*, End-to-End Testing the BookSwap
    Web Application*'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18371_06.xhtml#_idTextAnchor142)*，BookSwap 网络应用程序的端到端测试*'
- en: '[*Chapter 7*](B18371_07.xhtml#_idTextAnchor162)*, Refactoring in Go*'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18371_07.xhtml#_idTextAnchor162)*，Go 中的重构*'
- en: '[*Chapter 8*](B18371_08.xhtml#_idTextAnchor179)*, Testing Microservice Architectures*'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18371_08.xhtml#_idTextAnchor179)*，测试微服务架构*'
