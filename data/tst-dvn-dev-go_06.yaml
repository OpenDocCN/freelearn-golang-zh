- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: End-to-End Testing the BookSwap Web Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对`BookSwap`网络应用程序进行端到端测试
- en: We have made a lot of progress toward our goal of learning how to use TDD for
    implementing and testing Go code. So far, we have covered a wide variety of techniques
    for implementing unit and integration tests. Unit tests verify that each component
    works as intended, while integration tests extend their scope to cover the seams
    and interactions between different units. Moreover, we have learned how to apply
    these techniques to a wide variety of examples, including the `BookSwap` web application
    introduced in previous chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在如何使用TDD（测试驱动开发）来实现和测试Go代码的目标上取得了很大的进展。到目前为止，我们已经涵盖了实现单元测试和集成测试的广泛技术。单元测试验证每个组件按预期工作，而集成测试则扩展其范围，涵盖不同单元之间的接口和交互。此外，我们还学习了如何将这些技术应用到各种示例中，包括在前几章中介绍的`BookSwap`网络应用程序。
- en: These tests give us a fast feedback loop for code changes, as they don’t require
    the entirety of the application to be started up and made available before the
    test suite is run. As discussed in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124),
    *Performing Integration Testing*, we learned how to make use of the `httptest`
    and `ginkgo` libraries to easily write and run integration tests for web applications.
    We also learned how to make use of **behavior-driven development** (**BDD**) for
    writing tests, which is a popular technique for writing integration and **end-to-end**
    (**E2E**) tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试为我们提供了代码更改的快速反馈循环，因为它们不需要在运行测试套件之前启动整个应用程序并使其可用。如[*第5章*](B18371_05.xhtml#_idTextAnchor124)中所述，*执行集成测试*，我们学习了如何利用`httptest`和`ginkgo`库轻松编写和运行网络应用程序的集成测试。我们还学习了如何利用**行为驱动开发**（**BDD**）来编写测试，这是一种编写集成和**端到端**（**E2E**）测试的流行技术。
- en: However, while we can rely on unit and integration testing to ensure that the
    application is functioning correctly in a wide variety of scenarios, we should
    not neglect the benefits that E2E tests bring to our testing strategy. Only E2E
    tests allow us to verify the behavior of the entire application and replicate
    the user flows and experience. Simply put, these tests give us an insight into
    the user experience in production, which is the final verification that we should
    be making to our application before it is released.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然我们可以依赖单元和集成测试来确保应用程序在各种场景下正确运行，但我们不应忽视端到端测试为我们的测试策略带来的好处。只有端到端测试才能让我们验证整个应用程序的行为并复制用户流程和体验。简单来说，这些测试让我们了解了生产环境中的用户体验，这是我们发布应用程序之前应该进行的最终验证。
- en: This chapter is dedicated to discussing the implementation of E2E testing suites
    for the `BookSwap` web application introduced in previous chapters. We will make
    use of Docker to streamline the creation and teardown of identical applications,
    as well as discuss the changes we need to make to the application in order to
    make use of a database. Then, we will learn how to make use of Godog to write
    and run E2E tests. Finally, we will discuss which database assertions we should
    include in our tests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于讨论之前章节中介绍的`BookSwap`网络应用程序的端到端测试套件的实现。我们将利用Docker来简化创建和销毁相同应用程序的过程，并讨论我们需要对应用程序进行的更改以使用数据库。然后，我们将学习如何使用Godog编写和运行端到端测试。最后，我们将讨论我们应该在测试中包含哪些数据库断言。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The requirements of the `BookSwap` application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookSwap`应用程序的要求'
- en: The implementation of database storage in web applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络应用程序中数据库存储的实现
- en: Getting started with Cucumber and Godog
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Cucumber和Godog
- en: The implementation of E2E tests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试的实现
- en: Database start positions and assertions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库起始位置和断言
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described in the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装**Go版本1.19**或更高版本才能运行本章中的代码示例。安装过程在官方Go文档中描述，网址为[https://go.dev/doc/install](https://go.dev/doc/install)。
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter06](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter06).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中包含的代码示例可在[https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter06](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter06)公开获取。
- en: Use case – extending the BookSwap application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 扩展`BookSwap`应用程序
- en: The `BookSwap` web application was introduced in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085),
    *Building Efficient Test Suites*. Its main functionality allows users to list
    their books and swap them with other users. We learned what its main components
    and endpoints are, as well as how to apply table testing to its `BookService`.
    Then, in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124), *Performing Integration
    Testing*, we learned how to write integration tests for its `Index` request handler.
    We will continue to build out the functionality of this application in this chapter,
    taking a closer look at the user flows and intended functionality for each endpoint.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookSwap`网络应用程序在第[*第4章*](B18371_04.xhtml#_idTextAnchor085)中介绍，*构建高效的测试套件*。其主要功能允许用户列出他们的书籍并与其他用户交换。我们学习了其主要组件和端点，以及如何将表测试应用于其`BookService`。然后，在第[*第5章*](B18371_05.xhtml#_idTextAnchor124)中，*执行集成测试*，我们学习了如何为其`Index`请求处理器编写集成测试。在本章中，我们将继续构建此应用程序的功能，更详细地查看每个端点的用户流程和预期功能。'
- en: '*Figure 6**.1* depicts a summary of the responsibilities of the three main
    services of the `BookSwap` application—`BookService`, `UserService`, and `PostingService`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.1*展示了`BookSwap`应用程序三个主要服务（`BookService`、`UserService`和`PostingService`）的责任概要：'
- en: '![Figure 6.1 – The responsibilities of the main components of the BookSwap
    application  ](img/Figure_6.1_B18371.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – BookSwap应用程序主要组件的责任](img/Figure_6.1_B18371.jpg)'
- en: Figure 6.1 – The responsibilities of the main components of the BookSwap application
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – BookSwap应用程序主要组件的责任
- en: 'Each of the services has its own specialization and separate responsibilities:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都有自己的专业化和独立责任：
- en: '`BookService` is in charge of all book management aspects. This service implements
    the functionality of creating, updating, listing, and filtering books. As this
    application is quite limited in functionality, books are only filtered by the
    owner’s user ID, and we will not implement any searching for the `books` inventory.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookService`负责所有书籍管理方面。此服务实现了创建、更新、列出和过滤书籍的功能。由于此应用程序在功能上相当有限，书籍仅按所有者的用户ID进行过滤，我们不会实现任何对`books`库存的搜索。'
- en: '`UserService` is in charge of all user management aspects. This service implements
    functionality for creating and updating user profiles. It can also fetch a given
    user by ID and relies on `BookService` to receive a list of all books whose owner
    ID corresponds to the supplied user ID.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserService`负责所有用户管理方面。此服务实现了创建和更新用户配置文件的功能。它还可以通过ID获取特定用户，并依赖于`BookService`以接收所有书籍的列表，其所有者的ID与提供的用户ID相对应。'
- en: '`PostingService` is an external service to the `BookSwap` application, which
    is in charge of the details of posting and swapping books. For implementation
    purposes, we will use a `BookSwap` application. `PostingService` is not a service
    that actually exists, but we will use an internal stub to simulate calling out
    to an external service.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostingService`是`BookSwap`应用程序的外部服务，负责发布和交换书籍的细节。为了实现目的，我们将使用`BookSwap`应用程序。`PostingService`不是一个实际存在的服务，但我们将使用内部存根来模拟调用外部服务。'
- en: What is a stub?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是存根？
- en: A **stub** is a concrete implementation of another component. Stubs don’t make
    use of mocking frameworks, as they are used by implementation code. They make
    testing easier and allow us to build code as if the external component were built
    and implemented. Due to the flexibility of interfaces in Go, stubbed implementations
    can be easily swapped out for real implementations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**存根**是另一个组件的具体实现。存根不使用模拟框架，因为它们由实现代码使用。它们使测试更容易，并允许我们构建代码，就像外部组件已经构建并实现一样。由于Go接口的灵活性，存根实现可以轻松替换为真实实现。'
- en: As mentioned in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085), *Building Efficient
    Test Suites*, `BookSwap` saves its data in maps and does not currently have any
    database or persistent storage. We will change its implementation to use a **PostgreSQL**
    database in this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第4章*](B18371_04.xhtml#_idTextAnchor085)中所述，*构建高效的测试套件*，`BookSwap`将其数据保存在映射中，目前没有数据库或持久化存储。在本章中，我们将更改其实施方式，以使用**PostgreSQL**数据库。
- en: User journeys
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户旅程
- en: In this chapter, we will focus on the implementation of E2E tests. The focus
    of these tests is to verify the behavior of the application under typical **user
    journeys**. Therefore, it is important to establish typical user journeys or request
    flows before writing any E2E test cases.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于端到端测试的实现。这些测试的焦点是验证应用程序在典型**用户旅程**下的行为。因此，在编写任何端到端测试用例之前，建立典型用户旅程或请求流程是很重要的。
- en: What is a user journey?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是用户旅程？
- en: A user journey is the path or sequence of requests that the user of an application
    will take in order to achieve their goal. Often, these journeys are tracked in
    production environments to get insights into how users are using services.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 用户旅程是指应用程序用户为了实现目标而采取的路径或请求序列。通常，这些旅程在生产环境中被跟踪，以了解用户如何使用服务。
- en: '*Figure 6**.2* depicts the expected request flow for a new user for the `BookSwap`
    application:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.2*描述了`BookSwap`应用程序新用户的预期请求流程：'
- en: '![Figure 6.2 – The request flow of a new BookSwap application user ](img/Figure_6.2_B18371.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 新BookSwap应用程序用户的请求流程](img/Figure_6.2_B18371.jpg)'
- en: Figure 6.2 – The request flow of a new BookSwap application user
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 新BookSwap应用程序用户的请求流程
- en: 'The request flow diagram gives us an insight into which parts of the application
    are required for the user journey to be successfully completed. The expected usage
    of the application for a new user is outlined here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请求流程图让我们了解到哪些应用程序部分对于用户旅程的成功完成是必需的。对于新用户，应用程序的预期使用情况如下概述：
- en: '`POST /users` endpoint, passing the details of the user profile as a JSON request
    body. The `UserService` service will then create the user and return it to the
    client.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST /users`端点，将用户配置文件详情作为JSON请求体传递。`UserService`服务将创建用户并将其返回给客户端。'
- en: '`BookSwap` application and viewing which books are available for swapping.
    The client issues a `GET /books` request. `BookService` will fetch a list of books,
    filtering them by available status.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BookSwap`应用程序和查看哪些书籍可供交换。客户端发出`GET /books`请求。`BookService`将获取书籍列表，并通过可用状态进行过滤。'
- en: '`POST /books/{id}` request, passing the ID of the book that they want to book.
    Then, they pass their own user ID as a URL parameter, completing the URL of the
    request as `POST /books/id?user={userId}`. This could also have been implemented
    with a request body.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST /books/{id}`请求，传递他们想要预订的书的ID。然后，他们将他们自己的用户ID作为URL参数传递，完成请求的URL为`POST
    /books/id?user={userId}`。这也可以通过请求体来实现。'
- en: 'Looking at the main components in *Figure 6**.2*, we notice that there is an
    extra component named `HTTP Server`. The implementation of `HTTP Server` in the
    `BookSwap` application consists of a few different parts:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图6.2中的主要组件，我们注意到有一个名为`HTTP Server`的额外组件。`BookSwap`应用程序中`HTTP Server`的实现包括几个不同的部分：
- en: A handler custom type with `Index` example in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124),
    *Performing Integration Testing*. Typically, the handler custom type has access
    to all the dependencies it requires to fulfill its exposed operations.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有使用`Index`示例的处理器自定义类型在[*第5章*](B18371_05.xhtml#_idTextAnchor124)中介绍，*执行集成测试*。通常，处理器自定义类型可以访问其执行公开操作所需的所有依赖项。
- en: Each handler function is `gorilla/mux` library to take care of the configuration
    and routing of requests to their respective handler functions. You can read more
    about the `gorilla/mux` library at [https://github.com/gorilla/mux](https://github.com/gorilla/mux).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个处理函数都使用`gorilla/mux`库来处理配置和将请求路由到相应的处理函数。您可以在[https://github.com/gorilla/mux](https://github.com/gorilla/mux)上了解更多关于`gorilla/mux`库的信息。
- en: Finally, once routes and handlers are set up, we start the server and configure
    it to listen on a given port. This is done using the `net/http` library in the
    Go standard library.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一旦设置了路由和处理程序，我们就启动服务器并配置它监听指定的端口。这是使用Go标准库中的`net/http`库完成的。
- en: What is a mux?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是多路复用器？
- en: '`gorilla/mux` is a popular solution among Go developers.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`gorilla/mux`是Go开发者中流行的解决方案。'
- en: '*Figure 6**.2* covers a successful journey for a new user. E2E tests should
    cover a variety of scenarios, so we map out multiple request flows. However, due
    to their higher cost and running time, they typically only cover **base cases**
    or **happy paths**.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.2*展示了新用户的成功旅程。端到端测试应该覆盖各种场景，因此我们规划了多个请求流程。然而，由于它们的成本和运行时间较高，它们通常只覆盖**基本案例**或**成功路径**。'
- en: Using Docker
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker
- en: Up until now, we have run applications using the `go run` command and tested
    them using the `go test` command. The downside of this approach is that we must
    set up the Go environment and any dependencies locally before we can build and
    run the code locally. In [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124), *Performing
    Integration Testing*, we introduced Docker as a solution that addresses these
    issues.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用 `go run` 命令运行应用程序，并使用 `go test` 命令进行测试。这种方法的缺点是我们必须在本地设置 Go 环境和任何依赖项之后才能本地构建和运行代码。在[*第五章*](B18371_05.xhtml#_idTextAnchor124)中，*执行集成测试*，我们介绍了
    Docker 作为解决这些问题的解决方案。
- en: What is a Dockerfile?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 Dockerfile？
- en: A Dockerfile is a file that contains all the commands required for assembling
    an image. It is then used by Docker Engine to automatically create and start a
    container. We can view it as the specification of the setup for a Docker container.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是一个包含构建镜像所需所有命令的文件。然后，Docker 引擎使用它自动创建和启动容器。我们可以将其视为 Docker 容器设置的规范。
- en: 'We need to create a custom Dockerfile for our `BookSwap` application, as it
    does not have a pre-defined image in the Docker Hub image library. The `Dockerfile.book-swap.chapter06`
    file contains the `BookSwap` specification:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的 `BookSwap` 应用程序创建一个自定义的 Dockerfile，因为它在 Docker Hub 镜像库中没有预定义的镜像。`Dockerfile.book-swap.chapter06`
    文件包含 `BookSwap` 的规范：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This relatively simple file demonstrates all the essential knowledge that we
    need to effectively use Docker with our Go applications:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相对简单的文件展示了我们需要有效使用 Docker 与我们的 Go 应用程序相关的所有基本知识：
- en: The `FROM` statement indicates the base image of this build stage. We choose
    an image from Docker Hub that has the `alpine` images are lightweight and run
    on the **Linux** **BusyBox distribution**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FROM` 命令指示此构建阶段的基镜像。我们从 Docker Hub 选择了一个具有 `alpine` 镜像的图像，这些镜像轻量级且运行在 **Linux**
    **BusyBox** 发行版上。'
- en: The `WORKDIR` statement creates and sets the working directory of the Docker
    container. All further commands in our file execute in this directory.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WORKDIR` 命令创建并设置 Docker 容器的当前工作目录。我们文件中的所有后续命令都在这个目录中执行。'
- en: Next, the `COPY` statement copies all the source files from our local directory
    to the container’s working directory. Remember that containers are isolated from
    the underlying local directories, so these files must be copied to the container.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`COPY` 命令将所有源文件从我们的本地目录复制到容器的当前工作目录。请记住，容器与底层本地目录是隔离的，因此这些文件必须复制到容器中。
- en: The `RUN` statement executes the commands needed to build our Go executable
    by first downloading its dependencies and then specifying the directory that contains
    our application entry point. The Dockerfile is placed alongside the `go.mod` file
    in the root directory, so we need to explicitly state which of our chapter entry
    points to build from.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RUN` 命令通过首先下载其依赖项，然后指定包含我们的应用程序入口点的目录，来执行构建我们的 Go 可执行文件所需的命令。Dockerfile 文件放置在根目录中的
    `go.mod` 文件旁边，因此我们需要明确指出我们的章节入口点是从哪个构建的。'
- en: The `EXPOSE` statement instructs the Docker container to listen to network requests
    on the given port, as indicated by the `BOOKSWAP_PORT` environment variable. This
    variable is needed for the `BookSwap` application, so ensure that it is set in
    your terminal session before you run the application. The instructions of how
    to set environment variables will be different according to your operating system.
    If you want to run with the default setup, set the `BOOKSWAP_PORT` environment
    variable to `3000`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EXPOSE` 命令指示 Docker 容器在指定的端口上监听网络请求，如 `BOOKSWAP_PORT` 环境变量所示。这个变量对于 `BookSwap`
    应用程序是必需的，所以确保在运行应用程序之前在您的终端会话中设置它。设置环境变量的说明将根据您的操作系统而有所不同。如果您想使用默认设置运行，请将 `BOOKSWAP_PORT`
    环境变量设置为 `3000`。'
- en: Finally, the `CMD` statement specifies the command that should be run once the
    container starts. We run the executable from the `go` `build` step.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`CMD` 命令指定容器启动后应运行的命令。我们从 `go` 的 `build` 步骤运行可执行文件。
- en: That’s all we need to specify to run our application on any environment that
    is running Docker and has an internet connection! Most Docker specifications will
    be using this simple recipe for writing and running their custom images. We will
    see this specification in action later in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要在任何运行 Docker 并具有互联网连接的环境中运行我们的应用程序所需指定的全部内容！大多数 Docker 规范都将使用这个简单的配方来编写和运行他们的自定义镜像。我们将在本章后面看到这个规范的实际应用。
- en: Persistent storage
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化存储
- en: The next change we will make is to add `BookSwap` application, allowing us to
    save the state once the application shuts down. As SQL databases are still the
    most popular persistent storage solutions, we will use a SQL database in the demo
    application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要进行的下一个更改是添加 `BookSwap` 应用程序，允许我们在应用程序关闭后保存状态。由于 SQL 数据库仍然是最受欢迎的持久化存储解决方案，我们将在演示应用程序中使用
    SQL 数据库。
- en: SQL database management solutions
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 数据库管理解决方案
- en: There are a few popular SQL database solutions that you may already be familiar
    with. Some of these are **Oracle MySQL**, **Microsoft SQL Server**, and **PostgreSQL**.
    They all allow us to manage and interact with underlying SQL databases but may
    have differences in terms of the way we interact with them. Therefore, it’s important
    to use the same SQL solution in test environments as we have in production.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种流行的 SQL 数据库解决方案，您可能已经熟悉。其中一些是 **Oracle MySQL**、**Microsoft SQL Server** 和
    **PostgreSQL**。它们都允许我们管理和与底层的 SQL 数据库交互，但在我们与之交互的方式上可能存在差异。因此，在测试环境中使用与生产环境中相同的
    SQL 解决方案是很重要的。
- en: We will use a **PostgreSQL database**, an open source relational database widely
    used in production. It also has excellent cloud support across the public cloud
    providers, so it is a natural choice for our technology stack.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **PostgreSQL 数据库**，这是一个开源的关系型数据库，在生产环境中被广泛使用。它还拥有跨公共云提供商的优秀云支持，因此它是我们技术栈的自然选择。
- en: You can easily download and install it locally using the steps in the official
    documentation, available at [https://www.postgresql.org/download/](https://www.postgresql.org/download/),
    following the instructions for your operating system. Once you install it locally,
    make a note of your host, port, username, and password. You will need these to
    connect to your database and run instructions on it later.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照官方文档中的步骤轻松下载并本地安装，官方文档可在 [https://www.postgresql.org/download/](https://www.postgresql.org/download/)
    找到，遵循您操作系统的说明。一旦您本地安装了它，请记下您的宿主、端口、用户名和密码。您将需要这些信息来连接到您的数据库并在其上运行指令。
- en: '*Figure 6**.3* depicts the two main tables required for our application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.3* 展示了我们应用程序所需的两个主要表：'
- en: '![Figure 6.3 – The SQL tables of the BookSwap application ](img/Figure_6.3_B18371.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – BookSwap 应用程序的 SQL 表](img/Figure_6.3_B18371.jpg)'
- en: Figure 6.3 – The SQL tables of the BookSwap application
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – BookSwap 应用程序的 SQL 表
- en: 'There are two tables: `books` and `users`. Each table has a column for the
    data fields of each type. As the `owner_id` value of `books` should belong to
    an existing user, there is a `id` field. All the columns are of type `varchar`,
    which corresponds to a `string` type.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个表：`books` 和 `users`。每个表都有一个用于每种类型数据字段的列。由于 `books` 的 `owner_id` 值应该属于一个现有用户，因此有一个
    `id` 字段。所有列的类型都是 `varchar`，对应于 `string` 类型。
- en: Before we start up the application, we need to create the tables required for
    the application to function. However, we don’t want to execute SQL instructions
    outside of our source code, instead allowing us to version and review it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们启动应用程序之前，我们需要创建应用程序运行所需的所有表。然而，我们不想在源代码之外执行 SQL 指令，而是允许我们对其进行版本控制和审查。
- en: The `golang-migrate` project ([https://github.com/golang-migrate/migrate](https://github.com/golang-migrate/migrate))
    allows us to write migrations and run them as part of our application startup.
    The `migrate` CLI tool can easily be installed on your environment by following
    the installation steps in the *Getting started* tutorials available in the project
    documentation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`golang-migrate` 项目 ([https://github.com/golang-migrate/migrate](https://github.com/golang-migrate/migrate))
    允许我们编写迁移并在应用程序启动时运行它们。您可以通过遵循项目文档中 *入门* 教程中的安装步骤，轻松地在您的环境中安装 `migrate` CLI 工具。'
- en: 'Once installed, we can generate migrations for our two required tables:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以为我们所需的两个表生成迁移：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `migrate` CLI tool creates two files for each table, named `*.up.sql` and
    `*.down.sql`. The intended usage of these files is that the up migration creates
    the table at startup, and the down migration deletes the table once the application
    shuts down. This ensures that tables are removed after each run of the application
    and that they are always created at startup. Then, we add the columns required
    for each table. The configuration of the `users` table is shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`migrate` CLI 工具为每个表创建两个文件，分别命名为 `*.up.sql` 和 `*.down.sql`。这些文件预期的用法是，up 迁移在启动时创建表，down
    迁移在应用程序关闭时删除表。这确保了每次应用程序运行后都会删除表，并且它们总是在启动时创建。然后，我们添加每个表所需的列。这里展示了 `users` 表的配置：'
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The migration creates a table if one does not exist and marks the `id` column
    as the primary key. The specification matches the columns defined in *Figure 6**.3*.
    The down migration is one single line, which drops the table:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移在不存在表的情况下创建一个表，并将 `id` 列标记为主键。指定与 *图 6**.3* 中定义的列相匹配。向下迁移是一行，它删除了表：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The configuration of the `books` table is done in the same way. Finally, we
    add the migrations to the entry point of the `BookSwap` application:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`books` 表的配置也是以同样的方式进行。最后，我们将迁移添加到 `BookSwap` 应用程序的入口点：'
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Interacting with the `migrate` library requires three extra steps to be added
    to the startup of the application:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `migrate` 库交互需要在应用程序启动时添加三个额外的步骤：
- en: Creating a `postgres://user:password@host:port/database`. The `BookSwap` application
    requires an environment variable named `BOOKSWAP_DB_URL`, which contains this
    value. Make sure that this environment variable is set before starting the application.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `postgres://user:password@host:port/database`。`BookSwap` 应用程序需要一个名为 `BOOKSWAP_DB_URL`
    的环境变量，其中包含此值。确保在启动应用程序之前设置此环境变量。
- en: Once the migrate instance is created, we invoke the `Up()` method. This method
    looks at the current migration version and applies all the migrations defined
    in our `*.``up.sql` files.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建迁移实例，我们就调用 `Up()` 方法。此方法查看当前的迁移版本，并应用我们在 `*.up.sql` 文件中定义的所有迁移。
- en: If we want to clean up after the application shuts down or in the case of an
    error, we defer a call to the migration `Down()` method. This method uses the
    same version management and runs the contents of the `*.down.sql` files.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想在应用程序关闭后或发生错误的情况下进行清理，我们将延迟调用迁移 `Down()` 方法。此方法使用相同的版本管理并运行 `*.down.sql`
    文件的内容。
- en: The `golang-migrate` library and CLI have made it easy for us to save database
    configuration alongside source code, allowing for easy versioning as well as version
    management.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`golang-migrate` 库和 CLI 使我们能够将数据库配置与源代码一起保存，从而实现易于版本控制和版本管理。'
- en: Once our database and tables are created, we need to refactor our `UserService`
    and `BookService` implementations to make use of SQL tables and not the built-in
    maps we have been using so far. Typically, engineers make use of an **object-relational
    mapping** (**ORM**) library, which allows us to create a bridge between our Go
    custom types and our PostgreSQL database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的数据库和表创建完成，我们需要重构我们的 `UserService` 和 `BookService` 实现以使用 SQL 表，而不是我们迄今为止使用的内置映射。通常，工程师会使用一个
    **对象关系映射** (**ORM**) 库，它允许我们在 Go 自定义类型和 PostgreSQL 数据库之间创建桥梁。
- en: There are a few ORM solutions in the Go ecosystem. One of the most popular ones
    is **GORM** ([https://github.com/go-gorm/gorm](https://github.com/go-gorm/gorm)),
    which is an open source easy-to-use Go library. This library will make it easy
    for us to interact with our database solution, removing the need to manage SQL
    as raw strings in our source code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Go 生态系统中有几个 ORM 解决方案。其中最受欢迎的一个是 **GORM** ([https://github.com/go-gorm/gorm](https://github.com/go-gorm/gorm))，这是一个开源的易于使用的
    Go 库。这个库将使我们能够轻松地与我们的数据库解决方案交互，从而无需在源代码中以原始字符串的形式管理 SQL。
- en: 'The setup for using GORM is very similar to what we have done using `golang-migrate`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GORM 的设置与使用 `golang-migrate` 所做的非常相似：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we connect to the database using the database URL that we used previously
    to connect with `golang-migrate`. Once successfully connected, it returns the
    GORM database wrapper of type `*gorm.DB`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用之前与 `golang-migrate` 连接时使用的数据库 URL 连接到数据库。一旦成功连接，它将返回 GORM 数据库包装器类型 `*gorm.DB`。
- en: If we cannot connect to the database, then we will kill the application. We
    have also changed the signatures of the `NewBookService` and `NewUserService`
    initialization functions to take in the initialized database session.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法连接到数据库，我们将终止应用程序。我们还更改了 `NewBookService` 和 `NewUserService` 初始化函数的签名，以接受初始化的数据库会话。
- en: 'All of the operations of `BookService` and `UserService` that previously saved
    models to the built-in map type will now have to leverage the operations of the
    GORM database wrapper. One example is the `BookService` `ListByUser` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookService` 和 `UserService` 的所有之前将模型保存到内置映射类型的操作现在都必须利用 GORM 数据库包装器的操作。一个例子是
    `BookService` 的 `ListByUser` 方法：'
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method lists all books whose owner ID matches the given user ID. The usage
    of an ORM solution allows us to invoke operations on the database using a service
    that is able to use the invocations of methods to construct the correct SQL query.
    This allows us to reduce errors and remove the need to manage and interact with
    raw SQL strings.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法列出所有所有者ID与给定用户ID匹配的书籍。使用ORM解决方案的使用允许我们通过一个能够使用方法调用构造正确SQL查询的服务来在数据库上执行操作。这使我们能够减少错误并消除管理原始SQL字符串的需要。
- en: Running the BookSwap application
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行BookSwap应用程序
- en: The final piece of the puzzle for extensions we need to make to the `BookSwap`
    application is how to run it together with its database. As mentioned in [*Chapter
    5*](B18371_05.xhtml#_idTextAnchor124), *Performing Integration Testing*, the `docker-compose`
    tool is what we use to manage multiple Docker containers together. We now have
    two services, or parts, to the `BookSwap` application—the server-side application
    and its database. The database setup needs to be run in a Docker container as
    well, to avoid having to set up databases in every single environment.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们需要对`BookSwap`应用程序进行的扩展，最后一部分是如何与数据库一起运行它。如[*第5章*](B18371_05.xhtml#_idTextAnchor124)中所述，*执行集成测试*，我们使用的`docker-compose`工具是用来管理多个Docker容器的。现在我们有两个`BookSwap`应用程序的服务，或部分——服务器端应用程序及其数据库。数据库设置也需要在Docker容器中运行，以避免在每个环境中设置数据库。
- en: 'The `docker-compose` command takes its input from a `.yml` file, which makes
    it easy to specify the different services and their requirements. This simple
    specification in our `docker-compose.book-swap.chapter06.yml` file defines our
    `BookSwap` application and a PostgreSQL database that it can use:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`命令从`.yml`文件中获取输入，这使得指定不同的服务和它们的需求变得容易。我们`docker-compose.book-swap.chapter06.yml`文件中的简单指定定义了我们的`BookSwap`应用程序和它可以使用的一个PostgreSQL数据库：'
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The configuration in this relatively simple file specifies everything we need:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相对简单的文件中的配置指定了我们所需的一切：
- en: We define a services block for all the services that we start up. In our case,
    we will define the `books` service and the `db` service, each configured in its
    own sub-block.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为启动的所有服务定义一个服务块。在我们的情况下，我们将定义`books`服务和`db`服务，每个服务都在其自己的子块中配置。
- en: 'The configuration of the `books` service specifies the following:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`books`服务的配置指定以下内容：'
- en: The service is built from its own Dockerfile located in the current directory.
    This is the Dockerfile that we previously discussed in the *Using Docker* section
    of this chapter.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该服务是从当前目录中的自己的Dockerfile构建的。这是我们之前在本章的*使用Docker*部分讨论过的Dockerfile。
- en: The service exposes the port specified by the `BOOKSWAP_PORT` environment variable
    on its network. This will allow us to run tests that need access to the port locally.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该服务在其网络上公开由`BOOKSWAP_PORT`环境变量指定的端口。这将允许我们运行需要本地访问端口的测试。
- en: The service depends on the `db` service being started successfully. Docker Engine
    will take this into account when starting our service and instruct that the `db`
    service be started first.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该服务依赖于`db`服务成功启动。Docker引擎在启动我们的服务时将考虑这一点，并指示首先启动`db`服务。
- en: The service uses the `docker.env` file for its environment variable configuration.
    This will specify other environment variables that we require, like `BOOKSWAP_DB_URL`
    that we have previously seen.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该服务使用`docker.env`文件进行环境变量配置。这将指定我们需要的其他环境变量，例如之前提到的`BOOKSWAP_DB_URL`。
- en: 'The configuration of the `db` service specifies the following:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`db`服务的配置指定以下内容：'
- en: The container should use an existing image from the Docker repository. At the
    time of writing, this was the latest image of the `5432`, as is customary for
    PostgreSQL.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器应使用Docker仓库中的现有镜像。在撰写本文时，这是`5432`的最新镜像，这是PostgreSQL的常规做法。
- en: As can be seen from the documentation for this image, it requires the specification
    of a number of environment variables for the database username, password, and
    name. All of these variables will be defined in the `docker.env` file that we
    supply to this service.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如该镜像的文档所示，它需要指定数据库用户名、密码和名称的多个环境变量。所有这些变量都将定义在我们提供给该服务的`docker.env`文件中。
- en: Both services have a restart policy defined as well. This means that Docker
    will automatically restart containers if they fail.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个服务都有定义的重启策略。这意味着如果容器失败，Docker将自动重启容器。
- en: 'We can provide the following sample configuration for `docker.env`, but you
    can easily change it according to your own preferences by editing the file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为`docker.env`提供以下示例配置，但你可以通过编辑文件轻松根据你自己的偏好进行更改：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That’s all the configuration required for running two services together with
    the `docker compose -f docker-compose.book-swap.chapter06.yml up --build` command
    from the project root directory. This file contains a typical configuration that
    you will be able to reuse in your own projects. Furthermore, it allows us to identically
    start and run the `BookSwap` application across different environments. This provides
    us with the key advantage of being able to easily spin up test environments for
    the application as a whole. With these building blocks in place, let us have a
    look at how we can make use of this key advantage to increase the test coverage
    of our application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行两个服务所需的全部配置就是从项目根目录使用`docker compose -f docker-compose.book-swap.chapter06.yml
    up --build`命令。这个文件包含了一个典型的配置，你可以在自己的项目中重用。此外，它允许我们在不同的环境中一致地启动和运行`BookSwap`应用程序。这为我们提供了能够轻松启动整个应用程序的测试环境的关键优势。有了这些构建块，让我们看看如何利用这个关键优势来提高我们应用程序的测试覆盖率。
- en: Exploring Godog
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Godog
- en: In this chapter, we have made quite a few changes that have extended the scope
    and complexity of the `BookSwap` application. Now that we can easily start and
    tear down the application using Docker containers, it is time to turn our attention
    to writing E2E tests for our application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对`BookSwap`应用程序进行了相当多的更改，扩展了其范围和复杂性。现在我们可以轻松地使用Docker容器启动和关闭应用程序，是时候将我们的注意力转向编写应用程序的端到端测试了。
- en: In [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124), *Performing Integration
    Testing*, we looked at how to write BDD-style tests. This style of testing allows
    us to write human-readable test scenarios and use a **Given-When-Then** structure.
    These readable tests can serve as documentation for our projects, allowing us
    to involve multiple stakeholders and write tests that truly cover the functionality
    of our applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B18371_05.xhtml#_idTextAnchor124)中，*执行集成测试*，我们探讨了如何编写BDD风格的测试。这种测试风格允许我们编写人类可读的测试场景，并使用**给定-当-然后**结构。这些可读的测试可以作为我们项目的文档，使我们能够涉及多个利益相关者，并编写真正覆盖我们应用程序功能的测试。
- en: We also explored the `ginkgo` testing library, which allowed us to write tests
    using this style. Godog ([https://github.com/cucumber/godog](https://github.com/cucumber/godog))
    is another testing library that we will be exploring to write BDD-style tests.
    `ginkgo` allows us to add BDD-style assertions to our unit tests, but Godog provides
    extra code generation capabilities that make it a great fit for writing functional
    tests. We will learn how to use this great library for integration and E2E testing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了`ginkgo`测试库，它允许我们使用这种风格编写测试。Godog（[https://github.com/cucumber/godog](https://github.com/cucumber/godog)）是另一个我们将要探索的测试库，用于编写BDD风格的测试。`ginkgo`允许我们在单元测试中添加BDD风格的断言，但Godog提供了额外的代码生成功能，使其非常适合编写功能测试。我们将学习如何使用这个优秀的库进行集成和端到端测试。
- en: 'Here are some of the highlights of Godog:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Godog的一些亮点：
- en: Unlike the libraries we have used so far, Godog does not run its tests using
    the `go test` command, but with the `godog run` command. This command serves the
    dual purpose of generating test files as well as running the test that has been
    implemented.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与我们迄今为止使用的库不同，Godog不是使用`go test`命令运行测试，而是使用`godog run`命令。这个命令具有双重功能，既可以生成测试文件，也可以运行已经实现的测试。
- en: Tests are organized in **feature files**, which describe the expected behavior
    of a particular piece of functionality in a particular scenario. Godog uses a
    domain-specific language called **Gherkin** ([https://cucumber.io/docs/gherkin/reference/](https://cucumber.io/docs/gherkin/reference/)).
    We will explore how to write tests in this format for the remainder of this chapter.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试被组织在**功能文件**中，这些文件描述了特定场景下特定功能部分的预期行为。Godog使用一种称为**Gherkin**（[https://cucumber.io/docs/gherkin/reference/](https://cucumber.io/docs/gherkin/reference/)）的领域特定语言。在本章的剩余部分，我们将探讨如何以这种格式编写测试。
- en: Godog is an open source library, maintained by the community and the Cucumber
    organization. You can freely explore the source code and even contribute.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Godog是一个开源库，由社区和Cucumber组织维护。你可以自由地探索源代码，甚至可以贡献。
- en: 'Just as with the other dependencies we have used so far, Godog is installed
    by running the `go install` command in the terminal:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们迄今为止使用的其他依赖项一样，Godog通过在终端中运行`go install`命令进行安装：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we understand the basic usage of Godog and have installed it successfully,
    we start by writing our first `BookSwap` application:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Godog的基本用法并成功安装了它，我们开始编写我们的第一个`BookSwap`应用程序：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The feature file describes a part of the functionality required for new users
    of the `BookSwap` application:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 功能文件描述了`BookSwap`应用程序新用户所需的功能的一部分：
- en: The feature describes the scenario of signing up as a new user of an application.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该功能描述了作为应用程序新用户的注册场景。
- en: As a background step, the `BookSwap` application should be up and running. This
    allows us to write an E2E test as we run the entire application and run the test
    on the side.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为背景步骤，`BookSwap`应用程序应该处于运行状态。这允许我们在运行整个应用程序的同时编写端到端测试，并在旁边运行测试。
- en: 'When the feature is completed, the following functionality will be available:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当功能完成时，以下功能将可用：
- en: New customers will be able to create user profiles.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新客户将能够创建用户个人资料。
- en: When their profile is created, the user will see their user summary and receive
    their user ID, which will allow them to further interact with the application.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户创建其个人资料时，他们将看到他们的用户摘要并收到他们的用户ID，这将使他们能够进一步与应用程序交互。
- en: Once signed up, customers will be able to view their profile by using their
    user ID.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册后，客户将能够通过使用他们的用户ID查看他们的个人资料。
- en: Any further interactions with the application are outside the scope of this
    feature.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与应用程序的任何进一步交互都不在本功能的范围内。
- en: As discussed, the feature file is based on the expected user journeys and request
    flows of the application. Feature files should be easy to read and understand,
    so we should create separate files for covering other features and scenarios and
    use non-technical language.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所讨论的，功能文件基于应用程序预期的用户旅程和请求流程。功能文件应该易于阅读和理解，因此我们应该为覆盖其他功能和场景创建单独的文件，并使用非技术性语言。
- en: In the next section, we will learn how to implement and run this feature file
    with Godog.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用Godog实现和运行此功能文件。
- en: Implementing tests with Godog
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Godog实现测试
- en: With Godog installed and our first feature outlined, let us turn our attention
    to the implementation of this test.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Godog并概述了我们的第一个功能之后，让我们将注意力转向此测试的实现。
- en: 'The main steps we will be taking for implementing our outlined feature are
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取的主要步骤来实现概述的功能如下：
- en: Creating feature and test files.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建功能和测试文件。
- en: Implementing the test steps for the functionality of our `BookSwap` application.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现我们`BookSwap`应用程序的功能测试步骤。
- en: Running the application as well as the test.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序以及测试。
- en: As we previously mentioned, we will use Godog to implement BDD-style E2E tests,
    so we require the application to be up and running before we run our tests. However,
    this is not a Godog requirement, so we can write tests at any level with this
    easy-to-use library.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用Godog来实现BDD风格的端到端测试，因此在我们运行测试之前，我们需要确保应用程序正在运行。然而，这并不是Godog的要求，因此我们可以使用这个易于使用的库在任何级别编写测试。
- en: Creating test files
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试文件
- en: As previously mentioned, Godog relies on code generation to make developers’
    lives easier. The process consists of copying code from the terminal and creating
    files ourselves. Let us look at the steps involved.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Godog依赖于代码生成来简化开发者的工作。该过程包括从终端复制代码并自行创建文件。让我们看看涉及到的步骤。
- en: Step 1 – creating a feature file
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 创建功能文件
- en: 'Feature files are stored in the `/features` directory located at the root of
    the Go project. As we use project folders in our repository, we need to create
    a file under `/chapter06/features`. We will create a file in this directory and
    add the feature text inside it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 功能文件存储在Go项目根目录下的`/features`目录中。由于我们在仓库中使用项目文件夹，我们需要在`/chapter06/features`下创建一个文件。我们将在该目录下创建一个文件，并将功能文本添加到其中：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the file is named according to the feature name, making it easy to
    understand which functionality the file relates to.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文件命名是根据功能名称进行的，这使得理解文件关联的功能变得容易。
- en: Step 2 – generating step definitions
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 生成步骤定义
- en: 'Once the feature file contains our text, we can use Godog to generate the steps
    required for our feature. The `godog run` command prints the following generated
    code to the terminal:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦功能文件包含我们的文本，我们就可以使用Godog生成实现该功能所需的步骤。`godog run`命令将以下生成的代码打印到终端：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Figure 6**.4* presents the sequence of steps in our scenario, along with any
    HTTP requests that they make:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6**.4* 展示了我们场景中的步骤序列，以及它们所发出的任何 HTTP 请求：'
- en: '![Figure 6.4 – Steps and HTTP requests made in our scenario ](img/Figure_6.4_B18371.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 我们场景中执行的步骤和 HTTP 请求](img/Figure_6.4_B18371.jpg)'
- en: Figure 6.4 – Steps and HTTP requests made in our scenario
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 我们场景中执行的步骤和 HTTP 请求
- en: 'The generated code contains a function for each step of our scenario:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码包含我们场景每个步骤的函数：
- en: The `aNewUserProfileIsCreated` function sends a request to the `GET /users/{id}`
    endpoint and verifies that the user profile is successfully created. It will also
    verify that the user profile can be successfully retrieved by using the assigned
    user ID.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`aNewUserProfileIsCreated` 函数向 `GET /users/{id}` 端点发送请求，并验证用户资料是否成功创建。它还将验证可以通过指定的用户
    ID 成功检索用户资料。'
- en: The `sentToTheUsersEndpoint` function sends a JSON payload to the `POST /users`
    endpoint and verifies that the endpoint responds with the correct user details.
    It will also get access to the user ID that the application generates for the
    new user profile.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sentToTheUsersEndpoint` 函数向 `POST /users` 端点发送 JSON 负载，并验证端点以正确的用户详情响应。它还将获取应用程序为新用户资料生成的用户
    ID。'
- en: The `theBookSwapAppIsUp` function sends a request to the `GET /` endpoint and
    verifies that the application responds with a `200 OK` status code. In production,
    we often expose a separate `/health` endpoint, but we will make use of the root
    endpoint for the purposes of our `BookSwap` demo application.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`theBookSwapAppIsUp` 函数向 `GET /` 端点发送请求，并验证应用程序以 `200 OK` 状态码响应。在生产环境中，我们通常公开一个单独的
    `/health` 端点，但我们将为了 `BookSwap` 演示应用程序的目的使用根端点。'
- en: The `userDetails` function will create a `db.User` instance that we will marshal
    to the JSON payload and send to the `sentToTheUsersEndpoint` step. It will also
    serve as the expected value, or `want` variable, in our test assertions.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`userDetails` 函数将创建一个 `db.User` 实例，我们将将其序列化为 JSON 负载并发送到 `sentToTheUsersEndpoint`
    步骤。它还将作为我们测试断言中的预期值，或 `want` 变量。'
- en: We will need to implement these functions to invoke the functionality of our
    application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现这些函数以调用我们应用程序的功能。
- en: Finally, the `InitializeScenario` function ties together all these functions
    into steps and orders them alphabetically. We will have to correctly order them
    according to our feature definition when we implement our test file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`InitializeScenario` 函数将这些函数组合成步骤，并按字母顺序排序。当我们实现测试文件时，我们必须根据我们的功能定义正确排序它们。
- en: While the generated code is simple, it provides a scaffold for our test code
    and takes care of the interaction required with the Godog test runner.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然生成的代码很简单，但它为我们提供了测试代码的脚手架，并处理了与 Godog 测试运行器的交互。
- en: Step 3 – creating a test file
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3 – 创建测试文件
- en: 'Just as with regular unit tests, Godog tests also live in the `*_test.go` files
    and live alongside the packages that they test. As we will test the entire application,
    we create a test file in the `root` directory, at the same level as the `/features`
    directory. We create a test file matching the name of the feature and paste the
    generated file inside it:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如常规单元测试一样，Godog 测试也位于 `*_test.go` 文件中，并与它们所测试的包位于同一位置。由于我们将测试整个应用程序，我们在 `root`
    目录中创建一个测试文件，与 `/features` 目录处于同一级别。我们创建一个与功能名称匹配的测试文件，并将生成的文件粘贴到其中：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While the name of the test does not need to match, using a matching test will
    allow Godog to match the test with the feature.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试名称不需要匹配，但使用匹配的测试将允许 Godog 将测试与功能匹配。
- en: 'With the test file and code created, we execute `godog run` again. The test
    runner will mark the scenario as `pending`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建测试文件和代码后，我们再次执行 `godog run`。测试运行器将场景标记为 `pending`：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Conveniently, the output prints out the line numbers for each step as well,
    showing us where we are missing the implementation required for our tests.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，输出还会打印出每个步骤的行号，显示我们遗漏了哪些实现测试所需的步骤。
- en: Implementing test steps
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现测试步骤
- en: Now that Godog has conveniently generated a scaffold for our test steps, we
    begin writing test code according to the functionality of the `BookSwap` application.
    However, as described in the previous section, we will need to pass information
    between test steps.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Godog 已经方便地为我们生成了测试步骤的脚手架，我们开始根据 `BookSwap` 应用程序的功能编写测试代码。然而，如前所述，我们需要在测试步骤之间传递信息。
- en: 'The way to do this in Godog is by passing information through chained contexts.
    Godog will pass the contexts between the test steps, allowing us to pass information
    between steps in a safe way. In order to do this, we will need to change the signature
    of the test steps to take in a context and return a context and an error:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Godog中实现这一点的办法是通过链式上下文传递信息。Godog将在测试步骤之间传递上下文，允许我们以安全的方式在步骤之间传递信息。为了做到这一点，我们需要更改测试步骤的签名，使其接受一个上下文并返回一个上下文和一个错误：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The test steps take in a context and return a context and error. Under the
    hood, Godog will handle each of these return values correctly: chaining the returned
    context to subsequent test steps and failing the test in the case of a non-nil
    error.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 测试步骤接受一个上下文并返回一个上下文和错误。在底层，Godog将正确处理这些返回值：将返回的上下文链接到后续的测试步骤，并在出现非空错误时失败测试。
- en: Context refresher
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文复习
- en: The `context` type is part of Go’s standard library and its purpose is to carry
    deadlines, cancellations, and request-scoped variables. Contexts should be propagated
    across functions, allowing us to tie together function calls to requests across
    the layers of our application. Creating a new context requires a parent context.
    Cancellations then propagate across the chain of children contexts.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`context`类型是Go的标准库的一部分，其目的是携带截止日期、取消和请求范围内的变量。上下文应在函数之间传播，使我们能够将函数调用与我们的应用程序各层中的请求联系起来。创建一个新的上下文需要一个父上下文。取消随后将在子上下文链中传播。'
- en: 'For our purposes, we will use contexts to carry request-scoped variables. We
    will create a new `contextKey` custom type that will carry all the variables that
    we need to pass between test steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，我们将使用上下文来携带请求范围内的变量。我们将创建一个新的`contextKey`自定义类型，它将携带我们在测试步骤之间需要传递的所有变量：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In our case, we will propagate the `BookSwap` application’s `UsersURL` and
    the wanted value of the created user. In our background step, `theBookSwapAppIsUp`,
    we see a demonstration of the usage of the context to pass information to subsequent
    steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将传播`BookSwap`应用的`UsersURL`和创建用户的所需值。在我们的后台步骤`theBookSwapAppIsUp`中，我们可以看到如何使用上下文将信息传递给后续步骤：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code snippet demonstrates the implementation of a step that interacts
    with a REST endpoint:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段演示了与REST端点交互的步骤实现：
- en: We set the URL value for the environment that we will be testing by calling
    the `getTestURL` helper function. This function constructs the URL based on the
    environment variables specified for the application. This makes it easy for us
    to configure our test to run in different test environments, local or remote.
    If you want to run with the default values, set the `BOOKSWAP_BASE_URL` environment
    variable to `http://localhost` and the `BOOKSWAP_PORT` environment variable to
    `3000` to your terminal session.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过调用`getTestURL`辅助函数来设置我们将要测试的环境的URL值。此函数根据为应用程序指定的环境变量构建URL。这使得我们能够轻松地配置我们的测试以在不同的测试环境中运行，无论是本地还是远程。如果您想使用默认值运行，请将`BOOKSWAP_BASE_URL`环境变量设置为`http://localhost`，并将`BOOKSWAP_PORT`环境变量设置为`3000`到您的终端会话中。
- en: We use the `http.Get` method to interact with the defined URL, saving the error
    and the response. We are familiar with the `net/http` library from previous chapters.
    Its usage is no different in this test.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`http.Get`方法与定义的URL进行交互，保存错误和响应。我们从之前的章节中熟悉了`net/http`库。在这个测试中，其用法没有不同。
- en: In the case of an error or a status code other than `200 OK`, we return an error.
    This will fail this step and end the test.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现错误或状态码不是`200 OK`，我们将返回一个错误。这将使此步骤失败并结束测试。
- en: Finally, in the case of success, we use the `context.WithValue` function to
    create a child context from the `ctx` parameter value, passing a `contextKey`
    value with the populated `UsersURL`. In later steps, we will be able to use this
    URL for our requests.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在成功的情况下，我们使用`context.WithValue`函数从`ctx`参数值创建一个子上下文，传递一个带有填充的`UsersURL`的`contextKey`值。在后续步骤中，我们将能够使用此URL进行我们的请求。
- en: One other change we need to make to the generated test steps is to reorder them
    according to the order in which they should run. This step is not intuitive if
    you have never used Godog, but will be easy to track down if forgotten as your
    test will fail.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对生成的测试步骤进行的一个其他更改是按照它们应该运行的顺序重新排序它们。如果您从未使用过Godog，这个步骤可能不太直观，但如果忘记了，它将很容易追踪，因为您的测试将失败。
- en: Running the test suite
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试套件
- en: 'With everything implemented, it’s time to take our test out for a spin. First,
    we remember to run the `BookSwap` application, either using `docker compose -f
    docker-compose.book-swap.chapter06.yml up --build` command. Unless you have changed
    your configuration, this will expose the application at the `http://localhost:3000`
    URL. You can easily verify that the application is running by performing a `curl`
    command against this endpoint:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都实现之后，是时候对我们的测试进行测试了。首先，我们记得运行`BookSwap`应用程序，可以使用`docker compose -f docker-compose.book-swap.chapter06.yml
    up --build`命令。除非你已更改配置，否则这将通过`http://localhost:3000` URL公开应用程序。你可以通过对这个端点执行`curl`命令来轻松验证应用程序是否正在运行：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you see a welcome response, then the application is up and correctly connected
    to its database.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到欢迎响应，那么应用程序正在运行并且正确连接到其数据库。
- en: 'With the application running, we execute our test using the `godog` `run` command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，我们使用`godog`的`run`命令执行我们的测试：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see from the terminal output, Godog runs one scenario and all four
    steps passed. Alternatively, you can run the tests using the `go test` command
    if you don’t want to install the Godog CLI, but that will not format the test
    results, as you see in the preceding output.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从终端输出中可以看到，Godog运行了一个场景，所有四个步骤都通过了。或者，如果你不想安装Godog CLI，可以使用`go test`命令运行测试，但这样不会格式化测试结果，就像你看到的前面的输出一样。
- en: We have successfully written and run our first E2E test for the `BookSwap` application,
    which has been extended with persistent storage. The test was written using the
    Godog open source testing library, which allowed us to write easy-to-read BDD-style
    tests. We are well on our way to becoming Go testing experts.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功编写并运行了`BookSwap`应用程序的第一个端到端测试，该应用程序已扩展为具有持久化存储。该测试使用Godog开源测试库编写，这使得我们可以编写易于阅读的BDD风格测试。我们正在朝着成为Go测试专家的方向前进。
- en: Using database assertions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库断言
- en: 'We have learned how to start up our application in a test environment, as well
    as how to write and run E2E tests for our application. This has taken us far toward
    verifying the behavior of our application, but how can we be sure that the stored
    data and database components are correct? The final aspect of E2E testing that
    will help us answer this question is database testing. Looking at the tests we
    have written so far, we notice two things:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何在测试环境中启动我们的应用程序，以及如何为我们的应用程序编写和运行端到端测试。这使我们大大接近验证应用程序的行为，但如何确保存储的数据和数据库组件是正确的呢？帮助我们回答这个问题的端到端测试的最后一个方面是数据库测试。查看我们迄今为止编写的测试，我们注意到两件事：
- en: The database is typically initialized as empty, then the tables are torn down
    once the application shuts down. This has the advantage that we know there will
    be no persistent data that interferes with our tests, but it has the disadvantage
    of having to set up any required data as part of the test. For example, in our
    case, registering an available book requires a user ID, so we will have to create
    a user first before we do any book-related tasks. This can make our test suite
    running time longer.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库通常初始化为空，然后在应用程序关闭后拆毁表。这有一个优点，即我们知道测试中不会有持久数据干扰，但缺点是必须将所需数据作为测试的一部分设置。例如，在我们的案例中，注册可用的书需要用户ID，因此在我们进行任何与书籍相关的任务之前，我们必须首先创建一个用户。这可能会使我们的测试套件运行时间更长。
- en: The items from the database are asserted through the `BookSwap` endpoints. For
    example, we check that a user was correctly stored in the database by making a
    request to `GET /users/{id}` with its corresponding user ID. However, as requests
    travel down the entire application stack, it can become difficult to pinpoint
    the source of the error.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库中的条目通过`BookSwap`端点进行断言。例如，我们通过向`GET /users/{id}`发送带有相应用户ID的请求来检查用户是否被正确存储在数据库中。然而，随着请求在整个应用程序堆栈中传递，确定错误来源可能变得困难。
- en: Let us explore these two pain points further to get a better understanding of
    how to address them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨这两个痛点，以更好地了解如何解决它们。
- en: Seed data
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化数据
- en: As discussed in the previous *Persistent storage* section, we use `golang-migrate`
    to write database migrations, which allows us to create and set up our database
    for usage before the application starts up. Then, we use the **GORM** library
    as our ORM, which allows us to easily interact with our database using custom
    types.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文在*持久化存储*部分所述，我们使用`golang-migrate`编写数据库迁移，这允许我们在应用程序启动之前创建和设置我们的数据库以供使用。然后，我们使用**GORM**库作为我们的ORM，这使得我们可以使用自定义类型轻松地与数据库交互。
- en: 'The next step would be to insert some data into our newly created tables. This
    type of initial data is known as `INSERT` command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将一些数据插入到我们新创建的表中。这种初始数据被称为`INSERT`命令：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, none of the tools we have explored have the capability of creating
    and adding random seeds for our application. We could add another library dependency
    for generating random data, but instead, we can make use of GORM’s `DB` type to
    insert random data into our database before our tests run:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们探索的所有工具都没有创建和添加随机种子为我们应用程序的能力。我们可以添加另一个库依赖来生成随机数据，但相反，我们可以在测试运行之前使用GORM的`DB`类型将随机数据插入到我们的数据库中：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous code snippet demonstrates how to insert data into the database
    alongside running our Godog test steps, as detailed here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段展示了如何在运行Godog测试步骤的同时将数据插入数据库，具体细节如下：
- en: Just as at the application start, we open a new connection to our PostgreSQL
    database. Database connections should be shared between tests as much as possible,
    and you should not open them for many test iterations. However, as database start
    positions are usually required for E2E tests, it’s feasible to set up our database
    in this way.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在应用程序启动时一样，我们打开一个新的连接到我们的PostgreSQL数据库。数据库连接应尽可能在测试之间共享，并且不应为许多测试迭代打开。然而，由于数据库起始位置通常需要用于端到端测试，以这种方式设置我们的数据库是可行的。
- en: Once the database connection is opened successfully, we save a generated user
    using the `Save` method of the GORM database. After this, the database will contain
    the generated data and can be used across our tests.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦数据库连接成功打开，我们使用GORM数据库的`Save`方法保存一个生成的用户。之后，数据库将包含生成数据，并可以在我们的测试中使用。
- en: Test cases and assertions
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用例和断言
- en: 'When it comes to assertions on the contents of our database, we can take the
    same approach as we’ve seen with adding generated data:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到对数据库内容的断言时，我们可以采取与添加生成数据时相同的方法：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Looking at the verification code, we see the same approach:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 观察验证代码，我们看到同样的方法：
- en: We connect to the database using the connection string. GORM will optimize the
    use of your database connection when being used by multiple goroutines.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用连接字符串连接到数据库。当被多个goroutine使用时，GORM会优化数据库连接的使用。
- en: Then, we use the database methods to query the database for the user ID that
    is supplied to the method. Note that we rely on the GORM database directly, and
    not our own methods of `UserService`, removing any possible bugs that we may have
    introduced.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用数据库方法查询数据库以获取传递给方法的用户ID。请注意，我们直接依赖于GORM数据库，而不是我们自己的`UserService`方法，从而消除了我们可能引入的任何可能的错误。
- en: While GORM is easy to use, it might feel quite verbose to write full database
    queries to assert on returned values. The `dbassert` open source library ([https://github.com/hashicorp/dbassert](https://github.com/hashicorp/dbassert))
    provides wrappers and helper functions that can make this easier for you. You
    can explore this library by yourself and see how it can help streamline your test
    code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 GORM 使用起来很简单，但编写完整的数据库查询以断言返回值可能会感觉相当冗长。`dbassert`开源库([https://github.com/hashicorp/dbassert](https://github.com/hashicorp/dbassert))提供了包装和辅助函数，可以使这个过程更容易。您可以自行探索这个库，看看它如何帮助简化您的测试代码。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we spent our efforts extending the `BookSwap` application.
    We began by discussing what a typical user journey for a user will be, added a
    PostgreSQL database to it, and configured it to run with Docker. Then, we explored
    the Godog testing library, which makes it easy to write BDD-style tests, as well
    as E2E tests. We made use of Godog to verify that users are able to sign up on
    the `BookSwap` application, making use of the code generation abilities of Godog.
    Finally, we briefly discussed the challenges of creating database start positions
    and assertions directly at the database level.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们致力于扩展`BookSwap`应用程序。我们首先讨论了用户典型的用户旅程，向其中添加了PostgreSQL数据库，并将其配置为使用Docker运行。然后，我们探讨了Godog测试库，它使得编写BDD风格的测试以及端到端测试变得容易。我们利用Godog验证用户能否在`BookSwap`应用程序上注册，利用Godog的代码生成能力。最后，我们简要讨论了在数据库级别直接创建数据库起始位置和断言的挑战。
- en: In [*Chapter 7*](B18371_07.xhtml#_idTextAnchor162), *Refactoring in Go*, we
    will discuss tools and techniques for code refactoring and how to break up monoliths
    into multiple services. This will give us a realistic understanding of how to
    rely on our tests to verify that refactoring does not cause errors or break existing
    functionality.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第七章*](B18371_07.xhtml#_idTextAnchor162)中，我们将讨论Go语言的代码重构工具和技术，以及如何将单体应用拆分成多个服务。这将让我们对如何依靠测试来验证重构不会导致错误或破坏现有功能有一个现实的理解。
- en: Questions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the purpose of a user journey?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户旅程的目的是什么？
- en: What is ORM?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ORM是什么？
- en: What is the advantage of using Docker Compose?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Docker Compose的优势是什么？
- en: What is database seeding?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库初始化是什么？
- en: Further reading
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*User Story Mapping: Discover the Whole Story, Build the Right Product*, *Jeff
    Patton*, *Peter Economy*. Published by *O’Reilly*.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《用户故事映射：发现整个故事，构建正确的产品》*，作者 *杰夫·帕顿*，*彼得·艾康尼*。由 *O’Reilly* 出版。'
- en: '*The Book Of Kubernetes: A Hands-on Deep Dive into Container Technology*, *Alan
    Hohn*. Published by *No* *Starch Press*.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Kubernetes宝典：容器技术的实战深入探究》*，作者 *艾伦·霍恩*。由 *No Starch Press* 出版。'
- en: '*SQL & NoSQL Databases: Models, Languages, Consistency Options and Architectures
    for Big Data Management*, *Andreas Meier*, *Michael Kaufmann*. Published by *Springer
    Vieweg*.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《SQL与NoSQL数据库：大数据管理模型、语言、一致性选项和架构》*，作者 *安德烈亚斯·迈尔*，*迈克尔·考夫曼*。由 *Springer Vieweg*
    出版。'
