- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Testing Microservice Architectures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试微服务架构
- en: The topics we have covered so far have gone beyond the scope of how to write
    tests. We have looked at a wide range of software design and development concerns,
    including containerization with Docker and database integration with PostgreSQL.
    This highlights the fact that writing good tests requires a thorough understanding
    of the architecture and technical dependencies of the application under test.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止涵盖的主题已经超出了如何编写测试的范围。我们探讨了广泛的软件设计和开发问题，包括使用Docker的容器化和与PostgreSQL的数据库集成。这突出了编写良好测试需要彻底了解待测试应用程序的架构和技术依赖性的事实。
- en: Alongside these software development concepts, we discussed the evolution of
    code in [*Chapter 7*](B18371_07.xhtml#_idTextAnchor162), *Refactoring in Go*.
    We learned some common refactoring techniques, and we compared monolithic applications
    with microservice architectures, which is a common evolution of Go web applications
    as they grow and become more mature.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些软件开发概念之外，我们在[*第7章*](B18371_07.xhtml#_idTextAnchor162)“Go中的重构”中讨论了代码的演变。我们学习了一些常见的重构技术，并将单体应用程序与微服务架构进行了比较，这是Go
    Web应用程序随着成长和成熟而常见的演变。
- en: We will continue our exploration of microservice architectures and refactoring
    from the previous chapter. As microservices are often owned and developed by different
    software teams, they are often changed without any central oversight. In this
    fast-paced world of changing requirements and implementations, ensuring that the
    API integration points in our system are still functioning correctly is one of
    the biggest challenges to overcome. Another key concern to consider is error detection
    in the system – when something goes wrong, how do you isolate the malfunctioning
    service in a large map of dependencies?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续探索微服务架构和从上一章开始的重构。由于微服务通常由不同的软件团队拥有和开发，它们经常在没有中央监管的情况下进行更改。在这个快速变化的需求和实现的世界中，确保我们系统中的API集成点仍然正确运行是克服的最大挑战之一。另一个需要考虑的关键问题是系统中的错误检测——当出现问题的时候，如何在庞大的依赖图中隔离出故障的服务？
- en: This chapter is dedicated to discussing the testing of microservice architectures,
    demonstrated on the monolithic `BookSwap` web application introduced in previous
    chapters. We will have a closer look at the implementation of non-functional tests,
    which was briefly discussed in previous chapters. Then, we will learn the new
    concepts of contract testing and how we can leverage Pact for the implementation
    of contracts on microservice architectures. Finally, we will discuss how we can
    split up the monolithic `BookSwap` web application that we have built so far.
    Using the concepts and challenges we will have learned, we will discuss some best
    practices for running microservices in production.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于讨论微服务架构的测试，以之前章节中介绍的单体`BookSwap` Web应用程序为例。我们将更深入地了解非功能性测试的实施，这在之前的章节中已有简要讨论。然后，我们将学习合同测试的新概念以及如何利用Pact在微服务架构上实施合同。最后，我们将讨论如何将迄今为止构建的单体`BookSwap`
    Web应用程序拆分。使用我们学到的概念和挑战，我们将讨论在生产环境中运行微服务的最佳实践。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The implementation of non-functional testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非功能性测试的实施
- en: Challenges of testing microservice architectures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试微服务架构的挑战
- en: Getting started with contract testing with Pact
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pact开始合同测试
- en: Splitting up the `BookSwap` monolith we have built so far
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分我们迄今为止构建的`BookSwap`单体
- en: Best practices for running microservice architectures in production
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境中运行微服务架构的最佳实践
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described in the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装**Go版本1.19**或更高版本才能运行本章中的代码示例。安装过程在官方Go文档[https://go.dev/doc/install](https://go.dev/doc/install)中有描述。
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter08](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter08).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含的代码示例在[https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter08](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter08)公开可用。
- en: Functional and non-functional testing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性和非功能性测试
- en: We briefly touched upon the topic of non-functional testing in [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015),
    *Getting to Grips with Test-Driven Development*. Up until now, we have tabled
    this important type of testing and focused on verifying the various functional
    aspects, while exploring the popular testing libraries of `testify`, `ginkgo`,
    and `GoDog`. Let’s now explore how to implement a few of the most important non-functional
    tests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第一章*](B18371_01.xhtml#_idTextAnchor015)“掌握测试驱动开发”中简要介绍了非功能性测试的主题。到目前为止，我们推迟了这种重要类型的测试，并专注于验证各种功能方面，同时探索流行的测试库`testify`、`ginkgo`和`GoDog`。现在让我们探讨如何实现一些最重要的非功能性测试。
- en: '*Figure 8**.1* depicts the main types of non-functional tests:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8**.1*展示了主要的非功能性测试类型：'
- en: '![Figure 8.1 – Types of performance and correctness non-functional testing
    ](img/Figure_8.01_B18371.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 性能和正确性非功能性测试类型](img/Figure_8.01_B18371.jpg)'
- en: Figure 8.1 – Types of performance and correctness non-functional testing
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 性能和正确性非功能性测试类型
- en: 'The types of tests are divided between **performance tests** and **usability
    tests**. They verify the following aspects of our systems:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类型分为**性能测试**和**可用性测试**。它们验证我们系统以下方面的内容：
- en: '**Load testing** simulates user demand on our system. These tests simulate
    expected demand and overload conditions to identify bottlenecks or performance
    issues.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**负载测试**模拟对我们系统的用户需求。这些测试模拟预期需求和过载条件，以确定瓶颈或性能问题。'
- en: '**Stress testing** simulates user demand under extreme conditions on our system.
    These tests are used to identify the scalability limit of our system and verify
    that it handles errors gracefully when components become overloaded.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**压力测试**模拟在极端条件下对我们系统的用户需求。这些测试用于确定我们系统的可扩展性限制，并验证当组件过载时，系统可以优雅地处理错误。'
- en: '**Volume testing** simulates large volumes of data coming into our system.
    This is similar to stress testing but with a few tests, each involving relatively
    large amounts of data, instead of many tests involving smaller amounts of data
    simulating user demand. These tests are used to identify the data limits that
    our system can process, which is particularly useful for services with a database/persistent
    storage solution.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**体积测试**模拟大量数据进入我们的系统。这与压力测试类似，但涉及相对大量数据的几个测试，而不是许多涉及较小数据量的测试来模拟用户需求。这些测试用于确定我们的系统可以处理的数据限制，这对于具有数据库/持久存储解决方案的服务特别有用。'
- en: '**Scalability testing** verifies our system’s ability to scale its components
    when subjected to sudden load. The load can be applied gradually, or it can be
    applied suddenly, which is known as a **spike test**.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可扩展性测试**验证我们的系统在突然负载下扩展其组件的能力。负载可以逐渐应用，也可以突然应用，这被称为**峰值测试**。'
- en: '**Failover testing** verifies our system’s ability to recover after a failure.
    This type of negative testing is a useful simulation for how quickly the system
    can recover following incidents.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**故障转移测试**验证我们的系统在故障后的恢复能力。这种类型的负面测试是对系统在事件发生后恢复速度的有用模拟。'
- en: '**Configuration testing** verifies our system’s behavior with different types
    of settings. They can be user-controlled settings or system settings. The system
    setup can change the expected behavior of the system, as well as its performance.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置测试**验证我们的系统在不同类型设置下的行为。它们可以是用户控制的设置或系统设置。系统设置可以改变系统的预期行为，以及其性能。'
- en: '**Usability testing** verifies how intuitive the user-facing functionality
    is to use. The focus of this type of testing varies according to the functionality
    that the system exposes, but it typically covers the following:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可用性测试**验证用户界面功能的使用直观性。这种测试的重点根据系统公开的功能而变化，但通常包括以下内容：'
- en: How intuitive the system is to use for new users
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于新用户来说，系统使用起来有多直观
- en: How easily users can perform their tasks
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户完成任务有多容易
- en: Whether error messages are well formulated and guide the user
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误信息是否表述良好并能引导用户
- en: '**Security testing** verifies whether security practices have been followed
    during the development process. The system under test should have correct authentication,
    authorization, and data integrity features.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安全测试**验证在开发过程中是否遵循了安全实践。被测试的系统应具有正确的身份验证、授权和数据完整性功能。'
- en: As we have seen, non-functional tests are extremely important for ensuring that
    our systems are functioning correctly under a wide variety of conditions. No testing
    strategy is complete without covering some of these important types of tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，非功能性测试对于确保我们的系统在各种条件下正确运行至关重要。没有涵盖这些重要测试类型的测试策略是不完整的。
- en: Non-functional tests verify crucial aspects of our system
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 非功能性测试验证了我们系统的关键方面
- en: These tests verify the performance and usability of the system under test, including
    how well the system scales and recovers from outages. These types of tests might
    be performed by different development teams, as they might require skills from
    outside the engineering team to implement them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试验证了被测试系统的性能和可用性，包括系统扩展和从故障中恢复的能力。这些类型的测试可能由不同的开发团队执行，因为它们可能需要来自工程团队之外的技术来实现。
- en: Performance testing in Go
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go语言中的性能测试
- en: While we have already established that non-functional testing covers important
    aspects, performance testing becomes even more important when moving from monolithic
    applications to microservice architectures. In the microservice world, the user
    journey varies and is processed by independent system components, which can lead
    to a less cohesive view of system behavior.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经确定非功能性测试涵盖了重要方面，但在从单体应用迁移到微服务架构时，性能测试变得更加重要。在微服务世界中，用户旅程各不相同，并由独立的系统组件处理，这可能导致对系统行为的整体视图不够一致。
- en: '*Figure 8**.2* depicts the key questions that performance testing answers:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.2*2描述了性能测试回答的关键问题：'
- en: '![Figure 8.2 – Key questions that performance testing answers ](img/Figure_8.02_B18371.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 性能测试回答的关键问题](img/Figure_8.02_B18371.jpg)'
- en: Figure 8.2 – Key questions that performance testing answers
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 性能测试回答的关键问题
- en: The two important questions that performance testing answers relate to system
    usability and scalability. Let’s look at what each question means.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试回答的两个重要问题与系统可用性和可扩展性相关。让我们看看每个问题意味着什么。
- en: Is the system usable?
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统是否可用？
- en: 'Usability is more than achieving correct functionality, as a slow-functioning
    system will eventually impact user satisfaction negatively. Performance testing
    is useful for assessing the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 用户体验不仅仅是实现正确的功能，因为一个运行缓慢的系统最终会对用户满意度产生负面影响。性能测试有助于评估以下方面：
- en: '**Stability**: No intermittent failures should occur, causing retries and negative
    user experiences.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定性**：不应发生间歇性故障，导致重试和负面用户体验。'
- en: '**Speed**: User requests should be kept within acceptable levels set according
    to business requirements, or the system is scaled appropriately.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：用户请求应保持在根据业务要求设定的可接受水平内，或者系统应适当扩展。'
- en: '**Error handling**: Errors should be handled gracefully, without sudden crashes,
    and well-formulated messages should be returned across a variety of scenarios.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：错误应该优雅地处理，没有突然崩溃，并且在各种场景中应返回精心设计的消息。'
- en: '**User load**: The system should be able to handle the expected user loads
    without causing unexpected CPU or user memory spikes.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户负载**：系统应该能够处理预期的用户负载，而不会导致意外的CPU或用户内存峰值。'
- en: Is the system scalable?
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统是否可扩展？
- en: 'Business and system requirements evolve with time. A scalable system should
    be able to grow according to the expected future needs of the business. Performance
    testing is useful for assessing the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 商业和系统需求会随着时间而演变。一个可扩展的系统应该能够根据预期的未来业务需求进行增长。性能测试有助于评估以下方面：
- en: '**Bottlenecks**: Monitoring a variety of metrics allows us to identify which
    services in our system are not scalable, and should be refactored.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瓶颈**：监控各种指标使我们能够识别出我们系统中哪些服务不可扩展，并且应该进行重构。'
- en: '**Individual parts**: It is important to understand the expected response time
    for each microservice, as well as an estimate for the entire system. This can
    help us map costs for each user operation on our system.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单个部分**：了解每个微服务的预期响应时间以及整个系统的估计响应时间很重要。这可以帮助我们为系统中的每个用户操作映射成本。'
- en: '**Growth runway**: Performance testing allows us to establish how much more
    user and volume growth the system can sustain in its current form.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增长空间**：性能测试使我们能够确定系统在其当前形式下还能承受多少用户和流量的增长。'
- en: When used correctly, performance testing will ensure that each microservice
    is able to handle the current load of the system and that they are able to work
    together to serve user journeys correctly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确使用时，性能测试将确保每个微服务能够处理系统的当前负载，并且它们能够协同工作以正确地服务用户旅程。
- en: The “little and often” approach
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “小规模且频繁”的方法
- en: Performance testing is often added as part of the code build pipelines so that
    development teams get immediate feedback on performance with each commit. Similarly
    to refactoring, performance improvements are best done little and often. Monitoring
    performance with each commit will make it easier to see any trends and quickly
    fix new issues.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试通常作为代码构建管道的一部分添加，以便开发团队在每次提交时都能立即获得性能反馈。与重构类似，性能改进最好是小规模且频繁进行。每次提交时监控性能将更容易看到任何趋势并快速修复新问题。
- en: 'Performance testing is all about quantifying and comparing the behavior of
    our system and its microservices. How do we go about achieving this quantification?
    This is commonly achieved by gathering a few important metrics:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试的全部内容都是量化比较我们的系统和其微服务的行为。我们如何实现这种量化？这通常是通过收集一些重要的指标来实现的：
- en: '**Response time**: The time it takes between a user’s request and the response
    from the system to arrive back to the user. Often, the **average** and **peak**
    values of the response time are measured, giving an indication of the worst case
    alongside the average case.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应时间**：从用户请求到系统响应返回给用户所需的时间。通常，会测量**平均**和**峰值**响应时间，以提供对最坏情况和平均情况的指示。'
- en: '**Error rate**: The percentage of error cases in the total number of requests
    processed by the system. In RESTful APIs, the error responses are easily identified
    by HTTP status codes.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误率**：系统处理的总请求数中错误案例的百分比。在RESTful API中，错误响应可以通过HTTP状态码轻松识别。'
- en: '**CPU and memory usage**: The percentage of CPU and memory that the microservice
    is using on its host. These indicators will show whether the system is correctly
    scaled.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU和内存使用率**：微服务在其主机上使用的CPU和内存百分比。这些指标将显示系统是否正确扩展。'
- en: '**Concurrent users**: The number of users that are requesting a given resource
    at the same time. This can make it easy to identify any spikes for a particular
    endpoint of the user path.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发用户**：同时请求特定资源的用户数量。这可以很容易地识别用户路径特定端点的任何峰值。'
- en: '**Data throughput**: The amount of data processed by the system. This can indicate
    whether user requests are increasing over time or whether any large files are
    flowing into the system and affecting performance.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据吞吐量**：系统处理的数据量。这可以表明用户请求是否随时间增加，或者是否有大文件流入系统并影响性能。'
- en: The system under test should have monitoring and alerting for these metrics
    in place before we write any performance tests. Furthermore, we should establish
    what the failure criteria for our performance tests will be according to the needs
    of our system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写任何性能测试之前，测试系统应具备对这些指标的监控和警报功能。此外，我们应该根据系统的需求确定性能测试的失败标准。
- en: 'While you should always establish your threshold values together with key stakeholders,
    we can make some general recommendations based on experience and industry practice:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你应该始终与关键利益相关者一起确定阈值值，但我们可以根据经验和行业实践提出一些一般性建议：
- en: The average response time should generally be under 500 milliseconds, while
    the peak response time should be under 1 second
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均响应时间通常应低于500毫秒，而峰值响应时间应低于1秒
- en: Error rates should generally be under 5%
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误率通常应低于5%
- en: CPU and memory usage should generally stay under 70%, allowing the system to
    handle any spikes that may come up
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU和内存使用率通常应保持在70%以下，以便系统可以处理可能出现的任何峰值
- en: Concurrent users and data throughput do not have any failure thresholds, but
    should be monitored for spikes and anomalies
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发用户和数据吞吐量没有任何失败阈值，但应监控峰值和异常
- en: Now that we understand the importance of performance tests and how to quantify
    and compare their results, we can turn our attention to their implementation.
    We can implement them with Go’s standard `testing` framework or with popular third-party
    libraries.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了性能测试的重要性以及如何量化比较其结果，我们可以将注意力转向它们的实施。我们可以使用Go的`testing`标准框架或流行的第三方库来实现它们。
- en: Implementing performance tests
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施性能测试
- en: In [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035), *Unit Testing Essentials*,
    we learned how to write and execute benchmarks with Go’s standard testing library,
    which are special tests used to verify the performance of our code. We also learned
    how to export test coverage metrics from Go’s test runner.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B18371_02.xhtml#_idTextAnchor035)，*单元测试基础* 中，我们学习了如何使用 Go 的标准测试库编写和执行基准测试，这些是用于验证我们代码性能的特殊测试。我们还学习了如何从
    Go 的测试运行器导出测试覆盖率指标。
- en: 'We can use benchmarks to write performance tests for our endpoints. For example,
    we can easily write a benchmark for the `GET /` root endpoint of our `BookSwap`
    application:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用基准测试为我们的端点编写性能测试。例如，我们可以轻松地为 `BookSwap` 应用的 `GET /` 根端点编写基准测试：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We create a new benchmark according to the expected signature, taking in a single
    `*testing.B` parameter and named with the `Benchmark` prefix. Then, we make use
    of the standard `http` library to invoke the `GET` operation on the defined endpoint,
    which is returned by the `getTestEndpoint` helper function. Just as in previous
    chapters, this function constructs the endpoint based on the provided environment
    variables. If you want to run with the default values, set the `BOOKSWAP_BASE_URL`
    environment variable to `http://localhost` and the `BOOKSWAP_PORT` environment
    variable to `3000` to your terminal session.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据预期的签名创建一个新的基准测试，接受一个单个的 `*testing.B` 参数，并以 `Benchmark` 前缀命名。然后，我们利用标准的 `http`
    库在定义的端点上调用 `GET` 操作，该操作由 `getTestEndpoint` 辅助函数返回。正如前几章所提到的，这个函数根据提供的环境变量构建端点。如果您想使用默认值运行，请将
    `BOOKSWAP_BASE_URL` 环境变量设置为 `http://localhost`，并将 `BOOKSWAP_PORT` 环境变量设置为 `3000`
    到您的终端会话中。
- en: We save this test in the `chapter08/performance/books_index_test.go` file. With
    our simple test written, we need to make sure that the `BookSwap` application
    is up and running. We can easily run it using the `docker compose -f docker-compose.book-swap.chapter08.yml
    up --build` command. As mentioned in previous chapters, remember to set the `BOOKSWAP_PORT`
    environment variable before running. If you are running with default configuration,
    then you can use `3000` for its value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个测试保存在 `chapter08/performance/books_index_test.go` 文件中。在编写了简单的测试之后，我们需要确保
    `BookSwap` 应用程序正在运行。我们可以轻松地使用 `docker compose -f docker-compose.book-swap.chapter08.yml
    up --build` 命令来运行它。正如前几章所提到的，记得在运行之前设置 `BOOKSWAP_PORT` 环境变量。如果您使用默认配置运行，则可以使用
    `3000` 作为其值。
- en: 'Next, we need to run the benchmark. The `go test` command provides support
    for profiling benchmarks in a similar way to how we extracted code coverage details,
    in [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035), *Unit Testing Essentials*.
    The `runtime/pprof` package provides the following predefined profiling options:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行基准测试。`go test` 命令提供了与我们在 [*第 2 章*](B18371_02.xhtml#_idTextAnchor035)，*单元测试基础*
    中提取代码覆盖率详情类似的方式来支持基准测试。`runtime/pprof` 包提供了以下预定义的配置文件选项：
- en: '`cpu` shows us where our program is using CPU cycles'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpu` 展示了我们的程序在哪里使用 CPU 循环'
- en: '`heap` shows us where our program is making memory allocations'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heap` 展示了我们的程序在哪里进行内存分配'
- en: '`threadcreate` shows us where the program is requiring new threads'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threadcreate` 展示了程序在哪里需要新的线程'
- en: '`goroutine` shows us stack traces of all the program’s goroutines'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goroutine` 展示了程序中所有 goroutines 的堆栈跟踪'
- en: '`block` shows us where goroutines are waiting on locking primitives'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block` 展示了 goroutines 在等待锁定原语的地方'
- en: '`mutex` reports lock contention'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mutex` 报告锁定竞争'
- en: We will explore the concurrency aspects of threads, goroutines, and mutexes
    in [*Chapter 9*](B18371_09.xhtml#_idTextAnchor197), *Challenges of Testing Concurrent
    Code*. For now, we will focus on CPU profiling.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 9 章*](B18371_09.xhtml#_idTextAnchor197)，*测试并发代码的挑战* 中探讨线程、goroutines
    和互斥锁的并发方面。现在，我们将专注于 CPU 分析。
- en: 'We run our newly written benchmark with two profiling options, which will allow
    us to extract the CPU profile:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个配置文件选项运行我们新编写的基准测试，这将允许我们提取 CPU 配置文件：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The benchmark runner outputs the same results we saw in our introductory chapter:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试运行器输出了我们在介绍章节中看到的结果：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As our index endpoint is quite simple, the benchmark is executed 1,556 times
    and the total running time is 2.6 seconds. This command runs the benchmark and
    instructs the test runner to save the CPU profile to the `cpu-books.out` file,
    saved in the current running directory. The details of the test run are saved
    in the `performance.test` file, which is named after the package that the test
    is declared in.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的索引端点相当简单，基准测试执行了1,556次，总运行时间为2.6秒。此命令运行基准测试并指示测试运行器将CPU配置文件保存到当前运行目录下的`cpu-books.out`文件。测试运行的详细信息保存在名为测试声明的包的`performance.test`文件中。
- en: 'We can view the file using the `pprof` command tool, which comes installed
    with the Go toolchain:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与Go工具链一起安装的`pprof`命令行工具查看该文件：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This opens up an interactive command that will allow us to get some insights
    into the measured CPU time. The command will give a text output of the top profile
    results, while `web` will create a visual representation of the same results.
    Running `top5` on the CPU profile of our benchmark presents the following five
    results:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个交互式命令，使我们能够对测量的CPU时间有所了解。该命令将给出顶部配置文件结果的文本输出，而`web`将创建相同结果的视觉表示。在我们的基准测试的CPU配置文件上运行`top5`将展示以下五个结果：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These top results count for more than 80% of the running time, but they seem
    to be related only to the running and scheduling of the benchmark test itself.
    As the benchmark is scheduled and runs thousands of times, we can expect that
    the test runner will need to make use of quite a few goroutines and threads to
    execute the test. However, this is not very useful output for gaining an understanding
    of the operation of our `BookSwap` web application. We cannot profile our web
    application from the benchmark test since the web application is running in a
    whole other process, separate from the benchmark.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些顶级结果占运行时间的80%以上，但它们似乎仅与基准测试的运行和调度本身有关。由于基准测试被调度并运行数千次，我们可以预期测试运行器将需要使用相当多的goroutines和threads来执行测试。然而，这对于了解我们的`BookSwap`Web应用程序的操作并不是非常有用的输出。由于Web应用程序在完全不同的进程中运行，与基准测试分离，我们无法从基准测试中分析我们的Web应用程序。
- en: 'In order to gain insights into the CPU usage of our `BookSwap` application,
    we will need to integrate the `pprof` tool into our web application. This is easy
    to do by allowing `pprof` to register itself alongside our other handlers in `handlers/config.go`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入了解我们的`BookSwap`应用程序的CPU使用情况，我们需要将`pprof`工具集成到我们的Web应用程序中。通过允许`pprof`在我们的`handlers/config.go`中的其他处理器旁边注册自己，这样做很容易：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`pprof` will now be able to serve all the paths configured with the `debug/pprof`
    prefix if the `DEBUG` environment variable is set when the application is started.
    We can easily set it by adding the line `DEBUG=true` to the `docker.env`. We can
    then rerun the application in debug mode using the `docker compose -f docker-compose.book-swap.chapter08.yml
    up --build` command. This allows us to selectively expose this endpoint in particular
    environments. We are now ready to profile our web application. We rerun our benchmark,
    which will take around 3 seconds to run. We can then download the results to a
    local file in the same way that we exported the results of the benchmark profile:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在启动应用程序时设置了`DEBUG`环境变量，`pprof`现在将能够服务所有配置了`debug/pprof`前缀的路径。我们可以通过在`docker.env`中添加`DEBUG=true`行轻松设置它。然后我们可以使用`docker
    compose -f docker-compose.book-swap.chapter08.yml up --build`命令以调试模式重新运行应用程序。这允许我们在特定环境中选择性地公开此端点。我们现在已准备好分析我们的Web应用程序。我们重新运行基准测试，它将花费大约3秒钟的时间运行。然后我们可以以与导出基准测试配置文件结果相同的方式将结果下载到本地文件：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As the application is running locally in this example, the URL is `localhost:$BOOKSWAP_PORT`,
    but we would change it for other environments and configurations. This command
    downloads the profiling data from the past 10 seconds and saves it to a local
    file. We can then view the exported results in the same way as before:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，由于应用程序在本地运行，URL是`localhost:$BOOKSWAP_PORT`，但我们会根据其他环境和配置更改它。此命令从过去10秒下载分析数据并将其保存到本地文件。然后我们可以像以前一样查看导出的结果：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command opens up the same interactive screen as before, but we will now
    opt to see the visual representation of the CPU using the `web` command. This
    will launch a window in your default browser with a graph of the method calls
    that have been profiled.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将打开与之前相同的交互式屏幕，但我们将现在选择使用`web`命令查看CPU的视觉表示。这将在一个默认浏览器窗口中启动一个图表，显示已配置文件分析的函数调用。
- en: Graph visualization
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图形可视化
- en: Go’s profiling tool, `pprof`, relies on an external dependency for graph visualization.
    This dependency, named `graphviz`, is not written in Go and is therefore not automatically
    installed with the Go toolchain. You should follow the official documentation
    ([https://graphviz.org/download/](https://graphviz.org/download/)) to install
    it for your operating system.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Go的性能分析工具`pprof`依赖于外部依赖项进行图形可视化。这个依赖项名为`graphviz`，它不是用Go编写的，因此不会自动与Go工具链一起安装。您应该遵循官方文档([https://graphviz.org/download/](https://graphviz.org/download/))来为您的操作系统安装它。
- en: '*Figure 8**.3* presents the CPU profile usage in a visual representation, as
    was measured during the benchmarking of the index endpoint:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8**.3*展示了在基准测试索引端点时测量的CPU性能使用情况的视觉表示：'
- en: '![Figure 8.3 – A visual representation of the BookSwap CPU profile ](img/Figure_8.03_B18371.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – BookSwap CPU性能分析的视觉表示](img/Figure_8.03_B18371.jpg)'
- en: Figure 8.3 – A visual representation of the BookSwap CPU profile
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – BookSwap CPU性能分析的视觉表示
- en: As we can from the CPU profile, the `BookSwap` application spends most resources
    serving HTTP connections with `net/http` and interacting with the database layer
    using the `GORM` library. This is indicated by the percentages and size of the
    boxes corresponding to each operation. The visual representation of the call stack
    gives us a good indication of where we are spending our resources. We explored
    the database aspects of the BookSwap application in [*Chapter 6*](B18371_06.xhtml#_idTextAnchor142),
    *End-to-End Testing the BookSwap Web Application*. If we want to improve the performance
    of the application, we can use the information presented in the profile to identify
    areas of the call stack that need to be improved.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从CPU性能分析中我们可以看出，`BookSwap`应用程序在服务HTTP连接和通过`GORM`库与数据库层交互时消耗了大部分资源。这可以通过对应每个操作的百分比和框的大小来表示。调用栈的视觉表示为我们提供了资源消耗情况的良好指示。我们在[*第6章*](B18371_06.xhtml#_idTextAnchor142)中探讨了`BookSwap`应用程序的数据库方面，*《BookSwap
    Web应用程序的端到端测试》*。如果我们想提高应用程序的性能，我们可以使用配置文件中提供的信息来识别需要改进的调用栈区域。
- en: 'While benchmarking allows us to create simple tests and simulate a variety
    of load-testing scenarios, it can be quite verbose to define testing scenarios
    across many different microservices. There are two popular open source libraries
    that are often used for performance testing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基准测试允许我们创建简单的测试并模拟各种负载测试场景，但在许多不同的微服务中定义测试场景可能会相当冗长。有两个流行的开源库经常用于性能测试：
- en: '`testing` package. Different types of load can be configured. JMeter also has
    the capability of generating result graphs and dashboards once the tests are run.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testing`包。可以配置不同类型的负载。JMeter在测试运行后也有生成结果图表和仪表板的能力。'
- en: '**K6** ([https://k6.io/](https://k6.io/)) is an open source Go project maintained
    by Grafana. Test plans are written in a scripting language similar to JavaScript,
    reducing a lot of the code needed to write test scenarios. K6 offers different
    types of load configurations and also has the capability of outputting test results
    to dashboards.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**K6** ([https://k6.io/](https://k6.io/))是由Grafana维护的开源Go项目。测试计划是用类似于JavaScript的脚本语言编写的，这减少了编写测试场景所需的代码量。K6提供了不同类型的负载配置，并且也有将测试结果输出到仪表板的能力。'
- en: '**Gatling** ([https://gatling.io/open-source/](https://gatling.io/open-source/))
    is an open source Scala load testing tool maintained by Gatling Corp. Similarly
    to K6, tests are written in a Domain-Specific Language, but it is based on Scala.
    This library provides load testing and insights on dashboards.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gatling** ([https://gatling.io/open-source/](https://gatling.io/open-source/))是由Gatling
    Corp维护的开源Scala负载测试工具。与K6类似，测试是用领域特定语言编写的，但它基于Scala。这个库提供了负载测试和在仪表板上的洞察力。'
- en: Regardless of which performance testing implementation option you choose, you
    can profile your application and supplement the data and graphs that it supplies.
    We will not be exploring these third-party tools in this book, as we have used
    Go’s in-built benchmarking capabilities to write our performance tests.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪种性能测试实现选项，您都可以对应用程序进行性能分析，并补充它提供的数据和图表。我们在这本书中不会探讨这些第三方工具，因为我们已经使用了Go内置的基准测试功能来编写我们的性能测试。
- en: Go profiling is a very powerful tool with many more capabilities than what we
    have explored here. You can read more about Go’s diagnostics capabilities in the
    official documentation ([https://go.dev/doc/diagnostics](https://go.dev/doc/diagnostics)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Go配置文件是一个功能非常强大的工具，比我们在这里探索的具有更多功能。您可以在官方文档中了解更多关于Go的诊断功能（[https://go.dev/doc/diagnostics](https://go.dev/doc/diagnostics)）。
- en: Profiling tests and applications
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件测试和应用
- en: While we did not directly use the profiling information of the benchmark we
    ran, profiling tests can be a useful way to investigate costly or slow-running
    tests. Therefore, knowing how to export and read profiling information is useful
    for both development and test writing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有直接使用我们运行的基准测试的配置文件信息，但配置文件测试可以是一种有用的方式来调查成本高昂或运行缓慢的测试。因此，了解如何导出和读取配置文件信息对于开发和测试编写都很有用。
- en: Contract testing
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合同测试
- en: 'As discussed in [*Chapter 7*](B18371_07.xhtml#_idTextAnchor162), *Refactoring
    in Go*, microservice architectures have many advantages over monolithic applications:
    the ability to scale system components independently, smaller code bases that
    are easier to maintain, and a system that is less prone to outages. However, the
    development and testing of working processes change when organizations adopt microservice
    architectures. This also brings challenges, alongside the vast benefits of microservice
    architectures.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第7章*](B18371_07.xhtml#_idTextAnchor162)中所述，*Go语言的重构*，微服务架构相对于单体应用具有许多优势：能够独立扩展系统组件，更小的代码库，易于维护，以及一个不太容易发生故障的系统。然而，当组织采用微服务架构时，工作流程的开发和测试会发生变化。这也带来了挑战，以及微服务架构的巨大好处。
- en: '*Figure 8**.4* depicts the three types of complexity that microservice architectures
    bring:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8**.4* 展示了微服务架构带来的三种复杂性类型：'
- en: '![Figure 8.4 – The complexities of microservice architectures ](img/Figure_8.04_B18371.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 微服务架构的复杂性](img/Figure_8.04_B18371.jpg)'
- en: Figure 8.4 – The complexities of microservice architectures
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 微服务架构的复杂性
- en: 'Microservice architectures add complexity to every part of the development
    process:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构增加了开发过程中的每个部分的复杂性：
- en: '**Development complexity**: The source code of each microservice is often contained
    in its own separate code base or repository. This leads to complexity in the development
    process due to the following components:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开发复杂性**：每个微服务的源代码通常包含在其自己的独立代码库或仓库中。这导致由于以下组件而使开发过程变得复杂：'
- en: '**Service design** must be consistent across multiple services. Each engineering
    team must design multiple services, as opposed to creating one monolithic application
    and then changing it.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务设计**必须在多个服务之间保持一致。每个工程团队必须设计多个服务，而不是创建一个单体应用然后对其进行修改。'
- en: Related to service design, the **data separation and structure** must be designed
    as well. Each microservice is in charge of saving its own data to persistent storage
    and sending the information to other services when they require it. If this is
    done without any design, services will need to pass data back and forth, increasing
    response times.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与服务设计相关，**数据分离和结构**也必须进行设计。每个微服务负责将其自己的数据保存到持久存储，并在需要时将信息发送到其他服务。如果没有进行任何设计，服务将需要来回传递数据，从而增加响应时间。
- en: Finally, the team will need to implement **tests for each service**. If the
    service exposes user-facing functionality, it will need to be tested at every
    level of the testing pyramid. This will increase the number of tests required
    for the system, even though they may be faster and test a smaller functionality
    scope.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，团队将需要为每个服务实施**测试**。如果服务公开面向用户的功能，它将需要在测试金字塔的每个级别进行测试。这将增加系统所需的测试数量，尽管它们可能更快且测试的功能范围更小。
- en: '**Deployment complexity**: Each microservice is its own self-contained running
    application. This leads to complexity in the deployment pipelines due to the following
    components:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署复杂性**：每个微服务都是其自己的独立运行应用程序。这导致由于以下组件而使部署管道变得复杂：'
- en: The development teams have a higher burden of **infrastructure maintenance**
    due to the separation of each microservice and its dependencies. This can become
    even more complex when services require different kinds of dependencies or versions,
    as the system matures and the microservices are not updated at the same time.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于每个微服务及其依赖项的分离，开发团队在**基础设施维护**方面承担更高的负担。当服务需要不同类型的依赖项或版本时，这可能会变得更加复杂，因为随着系统的成熟和微服务没有同时更新。
- en: '**Release strategies** become more complex when it comes to making changes,
    as dependencies inside the system become more complex. All updates to the data
    structure or API changes, including the services, are not directly user-facing,
    as they could cause outages elsewhere in the system.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当涉及到进行更改时，**发布策略**变得更加复杂，因为系统内部的依赖关系变得更加复杂。所有对数据结构或API更改的更新，包括服务，都不是直接面向用户的，因为它们可能会在系统其他地方造成故障。
- en: '**Deployment automation** becomes a necessity in order to make it feasible
    for teams to easily build and release services. Testing must also be added to
    the release pipelines to minimize the risk of outages.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署自动化**成为必要条件，以便使团队能够轻松构建和发布服务。测试还必须添加到发布管道中，以最大限度地减少故障风险。'
- en: '**Organizational complexity**: Teams are unblocked to develop and release multiple
    services at the same time. This leads to an increase in productivity, but also
    organizational challenges due to the following components:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**组织复杂性**：团队可以同时开发和发布多个服务，这导致生产力提高，但也由于以下组件而带来组织挑战：'
- en: Often, the number of microservices far outnumbers the number of engineering
    teams, and in some cases even engineers! Therefore, **service ownership** is extended
    to multiple services per team. This adds maintenance complexity to the teams,
    which they must manage alongside delivering new features.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，微服务的数量远远超过工程团队的数量，在某些情况下甚至超过工程师！因此，**服务所有权**扩展到每个团队多个服务。这给团队增加了维护复杂性，他们必须在与交付新功能的同时管理这些复杂性。
- en: Teams must agree on a common way to structure and implement their services so
    that engineers can work across teams, as well as investigate services across the
    entire system. As such, the engineering organization will have to undertake some
    kind of design and implementation standardization process. This can be quite a
    difficult undertaking, as teams will have different requirements and/or preferences.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 团队必须就结构化和实现其服务的方式达成共识，以便工程师可以在团队之间工作，以及在整个系统中调查服务。因此，工程组织将不得不进行某种设计实施标准化过程。这可能是一项相当艰巨的任务，因为团队将有不同的需求或偏好。
- en: Finally, **communication between teams** will need to effectively handle larger
    systemic changes in order to avoid outages. This can be difficult for teams that
    are growing rapidly.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，**团队之间的沟通**将需要有效地处理更大的系统级变更，以避免故障。这对快速增长的团队来说可能很困难。
- en: The complexities introduced by microservice architectures can be mitigated with
    a solid testing strategy, which will flag any errors or breakages before they
    cause outages across the entire system. As discussed, the integration points between
    microservices must be tested, as teams will release changes to the services they
    own without any central oversight.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个坚实的测试策略，可以减轻微服务架构引入的复杂性，该策略会在它们在整个系统中造成故障之前标记出任何错误或损坏。如前所述，必须测试微服务之间的集成点，因为团队将在没有中央监督的情况下发布他们拥有的服务的更改。
- en: '*Figure 8**.5* depicts how we might go about testing the integration between
    two microservices using the knowledge we have gained so far:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8**.5* 展示了我们可以如何利用我们迄今为止获得的知识来测试两个微服务之间的集成：'
- en: '![Figure 8.5 – Testing the integration between two microservices ](img/Figure_8.05_B18371.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 测试两个微服务之间的集成](img/Figure_8.05_B18371.jpg)'
- en: Figure 8.5 – Testing the integration between two microservices
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 测试两个微服务之间的集成
- en: 'There are two options when it comes to testing the integration between two
    services:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试两个服务之间的集成时，有两种选择：
- en: '**Option A: Integration test with real services** involves writing an integration
    test between the real services in a testing environment. This approach allows
    us to verify that both services are functioning as expected and that their integration
    is successful. However, as the system grows, setting up each service and its dependencies
    becomes more complicated. Individual test runs will also slow down, as data and
    requests need to travel across multiple microservices or data stores.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项A：使用真实服务的集成测试**涉及在测试环境中编写真实服务之间的集成测试。这种方法使我们能够验证两个服务是否按预期运行，以及它们的集成是否成功。然而，随着系统的发展，设置每个服务和其依赖关系变得更加复杂。由于数据和请求需要跨越多个微服务或数据存储，单个测试运行也会变慢。'
- en: '**Option B: Integration test with mocks** involves writing separate integration
    tests against mocks for the dependency. This approach allows us to reduce the
    scope of the test and ensure that each service is working as expected. However,
    as it tests each service in isolation, it does not actually verify that the services
    are working together as expected. If either service does not conform to its defined
    mock, then the test would pass even though we could be creating an outage. This
    is the same issue we identified with our mocks in [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061),
    *Mocking and* *Assertion Frameworks*.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项B：使用模拟器的集成测试**涉及为依赖项编写针对模拟器的单独集成测试。这种方法允许我们缩小测试范围并确保每个服务按预期工作。然而，由于它独立测试每个服务，实际上并没有验证服务是否按预期协同工作。如果任一服务不符合其定义的模拟器，则测试将通过，尽管我们可能正在创建中断。这与我们在[*第3章*](B18371_03.xhtml#_idTextAnchor061)中识别的问题相同，*模拟和*
    *断言框架*。'
- en: Neither of these two options is ideal because we would need to write robust
    tests that verify that our microservices are integrated well together to have
    the confidence to change microservices without central oversight. We will explore
    a third way of testing that can alleviate some of the downsides of each approach.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选择都不是理想的，因为我们需要编写健壮的测试来验证我们的微服务是否良好集成，以便在没有中央监督的情况下对微服务进行更改。我们将探讨一种可以减轻每种方法缺点的方法。
- en: Fundamentals of contract testing
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合同测试基础
- en: Due to the downsides of the existing solutions and the difficulties that come
    with testing microservice architectures, developers began using another type of
    testing practice. **Contract testing** offers a simpler way to ensure that microservices
    continue to integrate well. It is not a new concept, but it has gained traction
    because it is well suited for distributed architectures.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现有解决方案的缺点以及测试微服务架构的困难，开发者开始使用另一种测试实践。**合同测试**提供了一种更简单的方式来确保微服务能够良好集成。这并不是一个新概念，但它因为非常适合分布式架构而获得了认可。
- en: 'Developers write virtual contracts that define how two microservices should
    interact. This contract provides the source of truth and represents the expected
    values for test assertions. There are two sides to every contract:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者编写虚拟合同，定义两个微服务应该如何交互。此合同提供了事实依据，并代表测试断言的预期值。每个合同都有两面：
- en: The `BookService` is the consumer as it sends the request.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookService` 是消费者，因为它发送请求。'
- en: The `PostingService` is the provider as it sends the response.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostingService` 是提供者，因为它发送响应。'
- en: 'Based on this terminology, *Figure 8**.6* demonstrates the procedure for writing
    and running contract tests:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个术语，*图8.6* 展示了编写和运行合同测试的流程：
- en: '![Figure 8.6 – Writing and running contract tests ](img/Figure_8.06_B18371.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 编写和运行合同测试](img/Figure_8.06_B18371.jpg)'
- en: Figure 8.6 – Writing and running contract tests
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 编写和运行合同测试
- en: 'The simple procedure consists of the following steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 简单程序包括以下步骤：
- en: '**Establish the consumer and provider**: We begin by identifying which services
    we want to test. In a microservice architecture, this isn’t always straightforward.
    After all, there is no code coverage metric for distributed systems that we can
    rely on to see which microservice integrations haven’t been tested.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**建立消费者和提供者**：我们首先确定我们想要测试哪些服务。在微服务架构中，这并不总是直接的。毕竟，我们没有可以依赖的代码覆盖率指标来查看哪些微服务集成尚未经过测试。'
- en: '**Identify the interaction(s) under test**: This step is equivalent to identifying
    which user journey we’d like to test or writing our feature test. This should
    include the HTTP method, the HTTP request body, and any URL parameters we might
    require. At this point, we should also establish what the expected response of
    the provider should be.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**识别受测试的交互**：这一步骤相当于确定我们想要测试的用户旅程或编写我们的功能测试。这应包括HTTP方法、HTTP请求体以及我们可能需要的任何URL参数。在此阶段，我们还应确定提供者预期的响应。'
- en: '**Consumer unit tests**: As part of the development process, the team will
    write unit tests for the consumer service. This will be done against a provider
    mock that is under the **consumer team’s ownership**.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**消费者单元测试**：作为开发过程的一部分，团队将为消费者服务编写单元测试。这将针对一个由**消费者团队拥有**的提供者模拟器进行。'
- en: '**Provider unit tests**: In the same way as on the consumer service side, the
    team will write unit tests for the provider during the development process, we
    use a consumer mock that is under the **provider** **team’s ownership**.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提供者单元测试**：与消费者服务端相同，团队将在开发过程中为提供者编写单元测试，我们使用一个位于**提供者** **团队所有者**之下的消费者模拟。'
- en: '**Record consumer interaction**: Based on the identified parameters and interactions
    of the unit test, we can begin to formulate the contract between the consumer
    and provider. The consumer team captures the required interaction between services,
    which is made up of the consumer request(s) and the expected provider response.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**记录消费者交互**：基于单元测试中确定的参数和交互，我们可以开始制定消费者和提供者之间的合约。消费者团队捕获服务之间所需交互，由消费者请求和预期的提供者响应组成。'
- en: '**Contract**: The consumer request and provider response are recorded together
    in one file, known as the contract. It crosses team boundaries and is the source
    of truth for the two teams, allowing them to easily collaborate using a common
    language. As we mentioned previously, microservice architectures add organizational
    complexity so the contract can help teams communicate more effectively.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合约**：消费者请求和提供者响应被记录在同一文件中，称为合约。它跨越团队界限，是两个团队的真实来源，使他们能够使用共同语言轻松协作。正如我们之前提到的，微服务架构增加了组织复杂性，因此合约可以帮助团队更有效地沟通。'
- en: '**Verify contract against provider**: The consumer requests recorded in the
    contract are run against the provider microservice. The expected provider response
    is verified against the response received from the real provider microservice.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验证合约与提供者**：合约中记录的消费者请求与提供者微服务运行。预期的提供者响应与从真实提供者微服务收到的响应进行验证。'
- en: A contract test is considered passed only when the contract is verified by interacting
    with the real services on both sides of the contract. However, unlike integration
    tests, which require one single team to have both the consumer and provider running
    for the test, contract testing allows this verification to be done in two steps,
    allowing the team ownership for each service to be maintained.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当合约通过与合约两边的真实服务交互进行验证时，合约测试才被认为是通过的。然而，与需要单一团队同时运行消费者和提供者进行测试的集成测试不同，合约测试允许这种验证分两步进行，从而保持每个服务的团队所有权。
- en: The consumer viewpoint
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者视角
- en: Contract testing is written starting with the consumer, which dictates the request
    and expectations. This helps us to ensure that the API is stable for the services
    that are using its functionality, encouraging stable APIs that do not promote
    breaking changes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 合约测试是从消费者开始的，这决定了请求和期望。这有助于我们确保API对使用其功能的服务是稳定的，鼓励不促进破坏性变更的稳定API。
- en: The contents of the contract file are the most important part of the process,
    and it is important that they does not contain any errors. The safest way to ensure
    that this does not happen is to use tools that help us generate them, as opposed
    to writing them manually. We will not attempt to implement contract testing manually,
    but instead, look at the process using one of the most popular tools.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 合约文件的内容是整个流程中最重要的一部分，确保它们不包含任何错误非常重要。确保这一点最安全的方法是使用帮助我们生成它们的工具，而不是手动编写。我们不会尝试手动实现合约测试，而是查看使用最受欢迎的工具的过程。
- en: Using Pact
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Pact
- en: Now that we understand the basic process of contract testing, we can have a
    look at some tools that facilitate the process by helping us generate contracts
    and run tests. Pact ([https://github.com/pact-foundation](https://github.com/pact-foundation))
    is a popular open source contract testing tool that allows us to easily write
    contract tests. It has been running since 2013, and it has quickly become the
    number-one choice for implementing contract tests.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了合约测试的基本流程，我们可以看看一些工具，这些工具通过帮助我们生成合约和运行测试来简化流程。Pact ([https://github.com/pact-foundation](https://github.com/pact-foundation))
    是一个流行的开源合约测试工具，它允许我们轻松编写合约测试。它自2013年以来一直在运行，并迅速成为实施合约测试的首选。
- en: 'Some of the main features of Pact are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Pact的一些主要功能如下：
- en: '**Synchronous and asynchronous support**: Pact allows contract testing for
    HTTP endpoints, as well as asynchronous non-HTTP messaging systems. It supports
    a variety of technologies, such as Kafka, GraphQL, and publish-subscribe messaging
    patterns.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步和异步支持**：Pact允许对HTTP端点以及异步非HTTP消息系统进行合同测试。它支持多种技术，如Kafka、GraphQL和发布/订阅消息模式。'
- en: '**Libraries in over ten languages**: Pact offers support for a wide variety
    of languages for both frontend and backend technologies. The Pact Go library ([https://github.com/pact-foundation/pact-go](https://github.com/pact-foundation/pact-go))
    provides us with the functionality required for testing our Go microservices.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超过十种语言的库**：Pact为前端和后端技术提供广泛的语言支持。Pact Go库([https://github.com/pact-foundation/pact-go](https://github.com/pact-foundation/pact-go))为我们提供了测试Go微服务所需的功能。'
- en: '**Unit testing integration**: The consumer code base imports the Pact Go library
    and uses it to write unit tests. This allows developers to use the same workflow
    and techniques for contract tests as was used for writing unit tests.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试集成**：消费者代码库导入Pact Go库并使用它来编写单元测试。这允许开发者使用与编写单元测试相同的流程和技术进行合同测试。'
- en: '**Contract testing Domain-Specific Language (DSL)**: The Pact library gives
    projects a common DSL for writing contract tests. This allows developers to define
    interactions and expected responses in a uniform way.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合同测试领域特定语言（DSL）**：Pact库为项目提供了一个编写合同测试的通用DSL。这允许开发者以统一的方式定义交互和预期响应。'
- en: '**Test playback and verification**: Based on the test specifications, Pact
    generates and records the test runs. Contract tests are called pacts, and they
    are replayed and verified against the provider service.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试回放和验证**：基于测试规范，Pact生成并记录测试运行。合同测试被称为pacts，它们将与提供者服务进行回放和验证。'
- en: '**Broker service**: Pact provides a self-hosted broker solution that allows
    the easy sharing and verification of contracts and test results. This solution
    is suitable for production systems and integrating contract testing into the release
    pipelines.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理服务**：Pact提供了一个自托管的代理解决方案，允许轻松共享和验证合同和测试结果。此解决方案适用于生产系统并将合同测试集成到发布管道中。'
- en: This list of features is the reason why Pact has quickly become the contract
    testing tool of choice. We can easily implement the contract testing steps using
    the Pact Go library.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能列表是Pact迅速成为合同测试工具首选的原因。我们可以轻松使用Pact Go库实现合同测试步骤。
- en: 'Pact provides a variety of command-line tools in an easy-to-install native
    binary that provides functionality for testing both synchronous and asynchronous
    message-based interactions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Pact提供了一种易于安装的本地二进制文件，其中包含各种命令行工具，这些工具提供了测试同步和异步基于消息交互的功能：
- en: Find the newest version of the tools on the project release page ([https://github.com/pact-foundation/pact-ruby-standalone/releases](https://github.com/pact-foundation/pact-ruby-standalone/releases)).
    This page will also contain installation instructions for your operating system.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目发布页面上找到工具的最新版本([https://github.com/pact-foundation/pact-ruby-standalone/releases](https://github.com/pact-foundation/pact-ruby-standalone/releases))。此页面还将包含适用于您操作系统的安装说明。
- en: 'The Pact Go library supports Go modules and can be easily added to your projects
    with the usual command: `go` `get github.com/pact-foundation/pact-go`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pact Go库支持Go模块，可以使用以下常用命令轻松添加到项目中：`go` `get github.com/pact-foundation/pact-go`。
- en: Adding the Pact tools to your system path
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 将Pact工具添加到系统路径
- en: As detailed in the Pact setup instructions, remember to add the path to the
    `pact/bin` directory to your system path. The Go test runner will need to be able
    to call the Pact tools during the test running and verification.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如Pact设置说明中详细说明，请记住将`pact/bin`目录的路径添加到您的系统路径中。Go测试运行器需要在测试运行和验证期间调用Pact工具。
- en: 'The installation will install a few different tools that we can use during
    contract testing. You can explore them all on your own. Some of the most commonly
    used tools are as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 安装将安装一些不同的工具，我们可以在合同测试期间使用它们。您可以自行探索它们。以下是一些最常用的工具：
- en: '`pact-mock-service` provides mocking and stubbing functionality. It can help
    us easily create mocks for our providers during contract testing.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pact-mock-service`提供了模拟和存根功能。它可以帮助我们在合同测试期间轻松地为我们的提供者创建模拟。'
- en: '`pact-broker` provides functionality for starting up the previously mentioned
    broker service, which makes it easy to share contracts and verification results.
    It also allows you to deploy it independently, including using Docker.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pact-broker` 提供启动之前提到的代理服务的功能，这使得共享合约和验证结果变得容易。它还允许您独立部署，包括使用 Docker。'
- en: '`pact-provider-verifier` provides verification of two versions of pacts, regardless
    of whether the values are coming from the Pact Broker or another source. The verifier
    is often added to the release pipelines, saving the development effort of implementing
    their own.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pact-provider-verifier` 提供对 pacts 两个版本的验证，无论值是否来自 Pact Broker 或其他来源。验证器通常添加到发布管道中，节省了实现自己的开发工作量。'
- en: 'Once the tools are installed, we can have a look at a simple test example for
    a possible client of the `GET /` root endpoint:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 工具安装完成后，我们可以查看一个针对 `GET /` 根端点的可能客户端的简单测试示例：
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Looking at the client test more closely, we can see that writing a contract
    test with Pact is not all that different from writing a unit test with Go’s standard
    testing library:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察客户端测试，我们可以看到使用 Pact 编写合同测试与使用 Go 的标准测试库编写单元测试并没有太大区别：
- en: The signature of the test is the same as a unit test, conforming to the test
    name convention and taking in the single `*testing.T` parameter.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试的签名与单元测试相同，遵循测试命名约定，并接受单个 `*testing.T` 参数。
- en: The Pact DSL is initialized, and we start up the Pact Mock Server using the
    `Setup()` function. Pact will find a free port on the local machine and then start
    up the server.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pact DSL 被初始化，我们使用 `Setup()` 函数启动 Pact Mock Server。Pact 将在本地机器上找到一个空闲端口，然后启动服务器。
- en: 'We create a test case function that takes in no parameters and returns a single
    error: `func() error`. This function wraps around the consumer code that calls
    out to the provider, including setting up any requests required. As we don’t have
    a dedicated client service on the `BookSwap` application, we simply call out to
    it using the `http` library.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个不接受任何参数并返回单个错误的测试用例函数：`func() error`。此函数包装了调用提供者的消费者代码，包括设置所需的任何请求。由于我们在
    `BookSwap` 应用程序上没有专门的客户端服务，我们只需使用 `http` 库调用它。
- en: With everything set up, we can run test cases in subtests. This allows us to
    use the same test techniques that we’ve seen so far, including the table-driven
    testing we explored in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085), *Building
    Efficient* *Test Suites*.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切设置完成后，我们可以在子测试中运行测试用例。这允许我们使用迄今为止看到的相同测试技术，包括我们在 [*第 4 章*](B18371_04.xhtml#_idTextAnchor085)
    中探索的表驱动测试，*构建高效的测试套件*。
- en: Inside each subtest, we define a new Pact interaction using the `AddInteraction()`
    function, which sets up all the prerequisites for contract testing, including
    starting a Mock Server, if one is running.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个子测试中，我们使用 `AddInteraction()` 函数定义一个新的 Pact 交互，该函数设置合同测试的所有先决条件，包括启动 Mock
    Server（如果正在运行）。
- en: 'The `dsl.Interaction` type returned allows us to configure all of the attributes
    required to describe the contract between the consumer and provider: the request
    and response body, headers, query parameters, status code, and so on.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回的 `dsl.Interaction` 类型允许我们配置描述消费者和提供者之间合同所需的所有属性：请求和响应体、头部、查询参数、状态码等。
- en: Once everything has been set up for the test case and expected behavior, we
    verify that the behavior is as written using the `Verify` function, which takes
    in the test case that has defined the consumer configuration.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切测试用例和预期行为设置完成后，我们使用 `Verify` 函数验证行为是否如预期，该函数接受已定义消费者配置的测试用例。
- en: Finally, we record the interaction in a file and invoke the `Teardown` function,
    which stops the Pact Mock Server. By default, Pact will save the contract inside
    the `pacts` folder in the project.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在文件中记录交互并调用 `Teardown` 函数，该函数停止 Pact Mock Server。默认情况下，Pact 将合约保存在项目中的
    `pacts` 文件夹内。
- en: 'We can run this test in the same way as we might run any integration test.
    The output of this test run will be as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像运行任何集成测试一样运行这个测试。这次测试运行的结果如下：
- en: '[PRE9]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output of the command indicates that the `TestConsumerIndex_Local` test
    was run against the Pact Mock Server and that it passed. The pact is also written
    to the `pacts/consumer-bookswap.json` file. This file contains the specified interactions
    between the consumer and provider, as described by the test.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出表明，`TestConsumerIndex_Local`测试是在Pact Mock Server上运行的，并且通过了。pact也被写入到`pacts/consumer-bookswap.json`文件中。该文件包含消费者和提供方之间由测试描述的指定交互。
- en: 'The consumer has specified the behavior they expect from the provider in the
    contract specification. Therefore, the provider verification is much simpler:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者在合同规范中指定了他们期望从提供方获得的行为。因此，提供方验证要简单得多：
- en: '[PRE10]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This simple snippet contains everything required for verification on the provider
    side:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的片段包含了在提供方进行验证所需的一切：
- en: We define the provider verification as a unit test, in the same way as we did
    on the consumer side.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将提供方验证定义为单元测试，就像我们在消费者端所做的那样。
- en: As we run the provider verification against the real service, we do not start
    the Pact Mock Server, but initialize the Pact DSL.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们针对实际服务运行提供方验证时，我们不需要启动Pact Mock Server，而是初始化Pact DSL。
- en: We call the `VerifyRequest` function, passing in the URL to the provider and
    the path to the consumer-defined contract. This was generated by running the consumer
    test, as described earlier on.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`VerifyRequest`函数，传入提供方的URL和消费者定义的合同路径。这通过运行消费者测试生成，如前所述。
- en: 'The URL to the provider and the path to the contract definition have been defined
    outside the scope of this test, allowing us to run this test in different environments.
    Once the `BookSwap` application is up and running with the Docker command we saw
    earlier, we can run the provider verification:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 提供方的URL和合同定义的路径是在此测试范围之外定义的，这使得我们可以在不同的环境中运行此测试。一旦使用我们之前看到的Docker命令启动了`BookSwap`应用程序，我们就可以运行提供方验证：
- en: '[PRE11]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The provider verification passes because the returned response from the `BookSwap`
    application is as we have specified on the consumer side. We have now successfully
    written and run our first contract test with Pact! All of the interaction with
    the contract testing library has been through a simple Go library, which has also
    allowed us to write contract tests in the same way as unit tests.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 提供方验证通过，因为从`BookSwap`应用程序返回的响应与我们已在消费者端指定的相符。我们现在已经成功编写并运行了我们的第一个Pact测试！所有与合同测试库的交互都是通过一个简单的Go库进行的，这也使我们能够以与单元测试相同的方式编写合同测试。
- en: As we have seen, the power of Pact is that it allows developers to easily implement
    code-first contract tests, so it is definitely a framework that you should consider
    adding to your projects alongside the practice of contract testing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Pact的力量在于它允许开发者轻松实现代码优先的合同测试，因此它绝对是一个你应该考虑添加到你的项目中的框架，与合同测试实践一起。
- en: The role of the Pact Broker
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Pact Broker的作用
- en: In the example we have explored, the contract tests were running locally, so
    they had shared access to the same contract file. However, this is not possible
    in microservice architectures or consumer-facing services. Teams run a dedicated
    Pact Broker service that can serve as the URL to the contracts that they wish
    to write and verify. The Pact Broker can be easily run with Docker using its image
    available on Docker hub ([https://hub.docker.com/r/pactfoundation/pact-broker/](https://hub.docker.com/r/pactfoundation/pact-broker/)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨的例子中，合同测试是在本地运行的，因此它们可以共享访问相同的合同文件。然而，在微服务架构或面向消费者的服务中这是不可能的。团队运行一个专用的Pact
    Broker服务，该服务可以作为他们希望编写和验证的合同的URL。Pact Broker可以很容易地通过Docker使用其在Docker Hub上的镜像来运行（[https://hub.docker.com/r/pactfoundation/pact-broker/](https://hub.docker.com/r/pactfoundation/pact-broker/))）。
- en: Breaking up the BookSwap monolith
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解BookSwap单体应用
- en: The discussion in this chapter has been centered around discussing microservice
    architectures, as distributed systems have become the standard and you will most
    likely have to work on this kind of system in the near future. However, the BookSwap
    application is still a monolithic application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的讨论主要集中在讨论微服务架构上，因为分布式系统已成为标准，你很可能在不久的将来必须处理这类系统。然而，BookSwap应用程序仍然是一个单体应用。
- en: 'Based on some of the practices we discussed in [*Chapter 7*](B18371_07.xhtml#_idTextAnchor162),
    *Refactoring in Go*, we can discuss how we might go splitting up the BookSwap
    monolith. *Figure 8**.7* depicts some of the microservices that we could create:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们在 [*第 7 章*](B18371_07.xhtml#_idTextAnchor162) 中讨论的一些实践，“Go 中的重构”，我们可以讨论如何拆分
    BookSwap 单体。*图 8**.7* 展示了我们可能创建的一些微服务：
- en: '![Figure 8.7 – The distributed BookSwap system ](img/Figure_8.07_B18371.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 分布式的 BookSwap 系统](img/Figure_8.07_B18371.jpg)'
- en: Figure 8.7 – The distributed BookSwap system
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 分布式的 BookSwap 系统
- en: 'The distributed `BookSwap` system has microservices with well-defined responsibilities:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式的 `BookSwap` 系统具有具有明确定义职责的微服务：
- en: '`SwapService` is the entry point to the system and is responsible for handling
    and routing all the incoming user requests of the system. It has direct dependencies
    on `BookService` and `UserService`, which own the data that `SwapService` relies
    on.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SwapService` 是系统的入口点，负责处理和路由系统所有传入的用户请求。它直接依赖于 `BookService` 和 `UserService`，它们拥有
    `SwapService` 所依赖的数据。'
- en: '`UserService` is responsible for all the operations pertaining to user management.
    The service has persistent storage, `UsersDB`, which it has full control of inside
    the system. This storage can take any form, but the service must be able to support
    the access patterns required by `SwapService`. This service has a direct dependency
    on `BookService`.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserService` 负责所有与用户管理相关的操作。该服务拥有持久存储 `UsersDB`，在系统中对它有完全的控制权。这种存储可以采取任何形式，但该服务必须能够支持
    `SwapService` 所需的访问模式。该服务直接依赖于 `BookService`。'
- en: '`BookService` is responsible for all the operations pertaining to book management.
    This service has its own dedicated persistent storage, `BooksDB`, which it has
    full control of inside the system. This service has a direct dependency on `PostingService`,
    which is an external service to the `BookSwap` system.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookService` 负责所有与书籍管理相关的操作。该服务拥有自己的专用持久存储 `BooksDB`，在系统中对它有完全的控制权。该服务直接依赖于
    `PostingService`，这是一个对 `BookSwap` 系统外部的服务。'
- en: Avoiding a shared database
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 避免共享数据库
- en: '`BookService` and `UserService` have been designed to have their own dedicated
    databases, instead of sharing one single persistent storage. This allows us to
    enforce data separation between the two microservices, as well as ensure that
    a database outage does not cause an outage on both of the services.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookService` 和 `UserService` 被设计为拥有自己的专用数据库，而不是共享一个单一的持久存储。这使我们能够在两个微服务之间强制执行数据分离，并确保数据库故障不会导致两个服务都出现故障。'
- en: This simple `BookSwap` system from *Figure 8**.7* is the starting point of how
    we might go about splitting up the `BookSwap` monolith. As we can see, the services
    have dependencies, so they must support the access patterns required by their
    consumers. The next step in the monolith splitting process is to design the APIs
    of the different services.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的 `BookSwap` 系统来自 *图 8**.7*，是我们如何拆分 `BookSwap` 单体的起点。正如我们所见，服务之间存在依赖关系，因此它们必须支持消费者所需的访问模式。单体拆分过程的下一步是设计不同服务的
    API。
- en: '*Figure 8**.8* depicts which API calls the services might expose:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8**.8* 展示了服务可能公开的 API 调用：'
- en: '![Figure 8.8 – The endpoints of the BookSwap microservices ](img/Figure_8.08_B18371.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – BookSwap 微服务的端点](img/Figure_8.08_B18371.jpg)'
- en: Figure 8.8 – The endpoints of the BookSwap microservices
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – BookSwap 微服务的端点
- en: 'As previously discussed, `SwapService` is the only user-facing service, with
    the other services being direct dependencies to it. We can see the following access
    patterns for the different domains in the `BookSwap` services:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`SwapService` 是唯一面向用户的服务，其他服务都是直接依赖于它的。我们可以看到 `BookSwap` 服务中不同域的以下访问模式：
- en: Books are accessed by their primary ID and by their owner user ID. This access
    pattern by two indices must be implemented to satisfy the requirements of `SwapService`.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍可以通过其主 ID 和所有者用户 ID 访问。这种通过两个索引的访问模式必须实现，以满足 `SwapService` 的要求。
- en: There is a **one-to-many relationship** between users and books. If we use a
    SQL database, then the user ID is a foreign key on the books table. This type
    of dependency can also be implemented in NoSQL tables, even though it feels like
    a natural fit for SQL databases.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和书籍之间存在 **一对多关系**。如果我们使用 SQL 数据库，那么用户 ID 就是书籍表的外键。这种依赖关系也可以在 NoSQL 表中实现，尽管它感觉更适合
    SQL 数据库。
- en: Users are created and updated using the same `POST` request on the corresponding
    endpoint. This conforms to RESTful design practices, but this merged operation
    should be handled lower down on the service level.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在相应的端点上使用相同的 `POST` 请求创建和更新。这符合 RESTful 设计实践，但这种合并操作应该在服务级别以下处理。
- en: Books are created using a `POST` request but are updated using their ID as the
    URL parameter. The second update is the implementation of the swap endpoint.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍通过 `POST` 请求创建，但使用其 ID 作为 URL 参数进行更新。第二次更新是交换端点的实现。
- en: These simple access patterns can be easily implemented with either a SQL or
    NoSQL persistent storage solution. It is highly recommended that REST endpoints
    use JSON as content type, especially as JSON marshaling and unmarshaling are natively
    supported in Go with the `encoding/json` library. We have previously explored
    persistent storage with PostgreSQL, but most major NoSQL data stores have Go drivers.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的访问模式可以很容易地使用 SQL 或 NoSQL 持久化存储解决方案实现。强烈建议 REST 端点使用 JSON 作为内容类型，尤其是在 Go
    中，`encoding/json` 库原生支持 JSON 的序列化和反序列化。我们之前已经探讨了使用 PostgreSQL 的持久化存储，但大多数主要的 NoSQL
    数据存储都有 Go 驱动程序。
- en: The `BookSwap` monolithic application would have lived in one single code base
    up until now, giving developers full visibility of all the changes that are being
    made to the application. However, in the microservices world, each service has
    its own code repository and team ownership.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookSwap` 单一应用程序直到现在都生活在单个代码库中，使开发者能够全面了解对应用程序所做的所有更改。然而，在微服务世界中，每个服务都有自己的代码仓库和团队所有权。'
- en: '*Figure 8**.9* depicts the five service integrations exposed by the new microservice
    architecture:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8**.9* 展示了新微服务架构暴露的五个服务集成：'
- en: '![Figure 8.9 – Five service integrations exposed by the new microservice architecture
    ](img/Figure_8.09_B18371.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 新微服务架构暴露的五个服务集成](img/Figure_8.09_B18371.jpg)'
- en: Figure 8.9 – Five service integrations exposed by the new microservice architecture
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 新微服务架构暴露的五个服务集成
- en: 'The microservices assume the role of consumer and provider according to the
    flow of data and the request flow between the two services:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务根据数据流和两个服务之间的请求流扮演消费者和提供者的角色：
- en: The client code is the consumer that issues the request to `SwapService`, which
    handles it by relying on the other services of the `BookSwap` application.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端代码是发出请求到 `SwapService` 的消费者，它通过依赖 `BookSwap` 应用程序的其他服务来处理请求。
- en: '`SwapService` is the consumer as it issues requests to `BookService` and `UserService`
    in order to process creation and update their corresponding model.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SwapService` 作为消费者，因为它向 `BookService` 和 `UserService` 发出请求，以处理创建和更新它们相应的模型。'
- en: '`UserService` is the consumer and `BookService` is the provider as it fetches
    the list of books belonging to the user.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserService` 是消费者，`BookService` 是提供者，因为它检索属于用户的书籍列表。'
- en: '`BookService` is the consumer and the external `PostingService` is the provider,
    as `PostingService` handles the side effects of all book swaps, which is a critically
    important detail because these side effects are what deliver the business value
    of the system in the real world.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookService` 是消费者，外部的 `PostingService` 是提供者，因为 `PostingService` 处理所有书籍交换的副作用，这是一个至关重要的细节，因为这些副作用是系统在现实世界中提供商业价值的原因。'
- en: Contract testing the integration between `BookService` and the external `PostingService`
    can help us to validate version upgrades, ensuring that external APIs continue
    to integrate well with our systems. This is a great way to ensure the continued
    successful operation of our system and all its dependencies.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 `BookService` 与外部 `PostingService` 之间的集成合同可以帮助我们验证版本升级，确保外部 API 继续与我们的系统良好集成。这是确保我们的系统及其所有依赖项持续成功运行的一个很好的方法。
- en: As we have seen from the `BookSwap` application in this section, monolithic
    applications can be converted in to a microservice architecture once the domain
    and team have the maturity to undertake this journey. In turn, this adds different
    kinds of complexity to the development, testing, and release processes. That complexity
    then enables onward scaling of the solution and team. A solid testing strategy,
    which includes contract testing, can help validate that the microservice architecture
    is stable, as well as scalable.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节中`BookSwap`应用程序的例子中，我们可以看到，一旦领域和团队具备承担这一旅程的成熟度，单体应用程序可以转换为微服务架构。反过来，这给开发、测试和发布过程增加了不同的复杂性。这种复杂性随后使解决方案和团队能够进行扩展。一个稳固的测试策略，包括契约测试，可以帮助验证微服务架构的稳定性以及可扩展性。
- en: Production best practices
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产最佳实践
- en: The final aspect of the microservice architectures that we will look at is some
    best practices when it comes to deployment and release. As we previously mentioned,
    the release pipelines should be automated to make it feasible for teams to release
    service multiple times a day. In this section, we will briefly explore some common
    patterns and solutions to consider when migrating to microservice architectures.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的微服务架构的最后一个方面是关于部署和发布的最佳实践。正如我们之前提到的，发布管道应该自动化，以便团队能够每天多次发布服务。在本节中，我们将简要探讨一些在迁移到微服务架构时需要考虑的常见模式和解决方案。
- en: Monitoring and observability
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控和可观察性
- en: In the microservices world, it can be difficult to have an understanding of
    how data travels through the system and how healthy our system is. This is alleviated
    by monitoring and observability solutions, which give us the required visibility.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务世界中，理解数据如何通过系统流动以及我们的系统健康状况可能很困难。这可以通过监控和可观察性解决方案得到缓解，它们为我们提供了所需的可视性。
- en: Observability versus monitoring
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性与监控
- en: 'Observability and monitoring are often used interchangeably, but they have
    two different intended purposes: observability aims to give teams access to data
    they need to debug problems, while monitoring aims to track performance and identify
    service anomalies. This means that monitoring is contained within observability.
    Observations need to be viewed in terms of meaningful value to the business in
    order to deliver reliable monitoring of properties, such as availability, performance,
    and capacity.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性和监控经常被互换使用，但它们有两个不同的预期目的：可观察性旨在为团队提供他们需要调试问题的数据，而监控旨在跟踪性能和识别服务异常。这意味着监控包含在可观察性中。观察结果需要从对业务有意义的价值观来考虑，以便提供对属性（如可用性、性能和容量）的可靠监控。
- en: We covered some important metrics for performance earlier in this chapter, in
    the *Performance testing in Go* section. Alongside these important metrics, `zap`
    ([https://pkg.go.dev/go.uber.org/zap](https://pkg.go.dev/go.uber.org/zap)), `logrus`
    ([https://github.com/sirupsen/logrus](https://github.com/sirupsen/logrus)), and
    `apex/log` ([https://github.com/apex/log](https://github.com/apex/log)).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的*Go中的性能测试*部分，我们讨论了一些重要的性能指标。除了这些重要指标之外，还有`zap` ([https://pkg.go.dev/go.uber.org/zap](https://pkg.go.dev/go.uber.org/zap))、`logrus`
    ([https://github.com/sirupsen/logrus](https://github.com/sirupsen/logrus))和`apex/log`
    ([https://github.com/apex/log](https://github.com/apex/log))。
- en: Deployment patterns
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署模式
- en: 'While a solid test strategy verifies the system for errors and performance
    issues, no code change or testing strategy is perfect. Deployment patterns will
    allow us to gradually release changes, making it easier to prevent outages. Two
    common patterns are as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个稳固的测试策略可以验证系统中的错误和性能问题，但没有任何代码更改或测试策略是完美的。部署模式将使我们能够逐步发布更改，从而更容易防止故障。以下有两种常见的模式：
- en: '**Canary deployments** involve releasing the change to a small percentage of
    traffic. If the canary is functioning correctly, then we roll out the change to
    larger percentages of traffic. However, if the metrics recorded in the canary
    deployment are not positive, we can roll back traffic to the old version of the
    application, which is still up and running. This minimizes the amount of work
    that must be done to handle the repercussions of a negative change.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金丝雀部署**涉及将更改发布到一小部分流量中。如果金丝雀运行正常，那么我们将更改推广到更大比例的流量中。然而，如果金丝雀部署中记录的指标不是积极的，我们可以将流量回滚到仍然运行的应用程序的老版本，从而最小化处理负面更改后果所需的工作量。'
- en: '**Blue-green deployments** involve maintaining two versions of the microservice
    to be changed. The blue version is running the current version of the service,
    while the green version is running the updated version. Once the green version
    has passed testing, user traffic is routed to the green environment. In the case
    of errors, traffic can be routed back to the blue version. Once the team is confident
    that the green version is functioning correctly, the blue version can be removed
    from the running environment or can be used for the next iteration.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝绿部署**涉及维护要更改的微服务的两个版本。蓝色版本正在运行当前版本的服务，而绿色版本正在运行更新后的版本。一旦绿色版本通过测试，用户流量将被路由到绿色环境。在出现错误的情况下，流量可以路由回蓝色版本。一旦团队对绿色版本的功能正确性有信心，蓝色版本可以从运行环境中移除，或用于下一次迭代。'
- en: These two popular deployment strategies will make it easier to avoid outages
    when rolling out new versions of a microservice, allowing us to quickly roll back
    to the previous version in the case of increased error rates. Such strategies
    are well supported by tools such as Kubernetes and service meshes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种流行的部署策略将使我们在推出微服务新版本时更容易避免中断，在错误率增加的情况下，我们可以快速回滚到之前的版本。这些策略得到了诸如Kubernetes和服务网格等工具的良好支持。
- en: The circuit breaker pattern
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断路器模式
- en: The circuit breaker pattern is a development pattern that allows us to avoid
    **cascading failures**, which is the process of one service increasing the probability
    that other services will fail. Circuit breakers typically wrap remote calls to
    other microservices. Once the error rate for calls to the remote services reaches
    an established threshold, the circuit breaker will immediately fail other requests,
    allowing the other service space to attempt to recover, and giving users a clear
    and timely response to explain the situation rather than keeping many requests
    in flight. An open circuit breaker then retries after a delay, becoming closed
    and able to pass further requests if the remote services are available, or becoming
    open again if the problems continue.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式是一种开发模式，它允许我们避免**级联故障**，即一个服务增加其他服务失败概率的过程。断路器通常封装对其他微服务的远程调用。一旦远程服务的调用错误率达到设定的阈值，断路器将立即拒绝其他请求，允许其他服务空间尝试恢复，并为用户提供清晰及时的反应来解释情况，而不是保持许多请求在空中。然后，开放的断路器在延迟后重试，如果远程服务可用，则变为关闭状态并能够传递进一步请求，如果问题持续，则再次变为开放状态。
- en: A popular open source circuit breaker implementation is the `hystrix-go` ([https://github.com/afex/hystrix-go](https://github.com/afex/hystrix-go))
    library, which implements error monitoring and retries. This pattern is simple
    and also requires us to consider default values and fallback behavior for all
    of our remote calls. The explicit implementation of the error cases for dependency
    outages brings further resilience to our microservice architecture.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的开源断路器实现是`hystrix-go` ([https://github.com/afex/hystrix-go](https://github.com/afex/hystrix-go))库，它实现了错误监控和重试。这种模式简单，同时也要求我们考虑所有远程调用的默认值和回退行为。对依赖故障的错误情况的显式实现为我们的微服务架构带来了额外的弹性。
- en: This brings us to the end of our exploration of microservice architecture implementation
    and testing. As we have seen in this chapter, a comprehensive testing strategy
    will allow us to take full advantage of the power of microservices, but we must
    be aware of the difference in the development process in order to be able to efficiently
    work with microservice architectures.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们结束了对微服务架构实现和测试的探索。正如我们在本章中看到的，一个全面的测试策略将使我们能够充分利用微服务的力量，但我们必须意识到开发过程中的差异，以便能够有效地与微服务架构一起工作。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we discussed how to test microservice architectures. Having
    focused on functional testing in previous chapters, we started by exploring non-functional
    testing. Then, we took a closer look at performance testing, one particularly
    important type of non-functional testing. Then, we explored the complexities that
    microservice architectures bring to the development process and learned how contract
    testing can help with the verification of API integrations.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何测试微服务架构。在前面章节中专注于功能测试之后，我们首先探索了非功能测试。然后，我们更详细地研究了性能测试，这是一种特别重要的非功能测试类型。然后，我们探讨了微服务架构给开发过程带来的复杂性，并学习了如何通过合同测试帮助验证API集成。
- en: We learned how to use the Pact tools to write contract tests using the same
    techniques and processes that developers use for unit testing. Finally, we explored
    how we might split up the monolithic `BookSwap` application, including which services,
    endpoints, and contract tests we would write.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用Pact工具编写使用与开发者为单元测试使用的相同技术和流程的合同测试。最后，我们探讨了如何拆分单体`BookSwap`应用程序，包括我们将编写哪些服务、端点和合同测试。
- en: In [*Chapter 9*](B18371_09.xhtml#_idTextAnchor197), *Challenges of Testing Concurrent
    Code*, we will tackle the complex topic of concurrency in Go. We will learn the
    fundamentals of concurrency in Go and then explore the testing challenges that
    concurrency introduces.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18371_09.xhtml#_idTextAnchor197)《测试并发代码的挑战》中，我们将探讨Go中的并发复杂问题。我们将学习Go并发的基础知识，然后探索并发引入的测试挑战。
- en: Questions
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between functional and non-functional testing?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能测试和非功能测试之间的区别是什么？
- en: What are some key metrics that performance testing should measure?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 性能测试应该测量哪些关键指标？
- en: How does performance testing ensure that the system is scalable?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 性能测试如何确保系统可扩展？
- en: What are some of the benefits of microservice architectures? What types of complexity
    are introduced by microservice architectures?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务架构有哪些好处？微服务架构引入了哪些类型的复杂性？
- en: What is contract testing?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合同测试是什么？
- en: Further reading
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Web Application Security: Exploitation and Countermeasures for Modern Web
    Applications*, Andrew Hoffman, published by O’Reilly'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Web应用程序安全：现代Web应用程序的利用和对策》，安德鲁·霍夫曼著，由O'Reilly出版
- en: '*Production-Ready Microservices: Building Standardized Systems Across an Engineering
    Organization*, Susan J. Fowler, published by O’Reilly'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《生产就绪微服务：在工程组织内构建标准化系统》，苏珊·J·福勒著，由O'Reilly出版
- en: '*Building Microservices: Designing Fine-Grained Systems*, Sam Newman, published
    by O’Reilly'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《构建微服务：设计细粒度系统》，萨姆·纽曼著，由O'Reilly出版
- en: '*Monolith to Microservices: Evolutionary Patterns to Transform Your Monolith*,
    Sam Newman, published by O’Reilly'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《单体到微服务：转型单体应用的演进模式》，萨姆·纽曼著，由O'Reilly出版
- en: 'Part 3: Advanced Testing Techniques'
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：高级测试技术
- en: The final part is dedicated to discussing the more challenging aspects of testing
    complex Go code, as all the tools and techniques required for testing applications
    are provided by the previous two sections. We begin our exploration by learning
    about Go concurrency mechanisms and what the concurrency untestable conditions
    are, including how to use Go’s race detector. Then, we revisit and expand our
    testing of edge cases by making use of fuzz tests and property-based testing,
    allowing us to test our code with a large amount of input to ensure that it is
    robust. Finally, we explore how to leverage Go’s recently introduced generics
    capability to write code that can work with different types, learn how to change
    table-driven tests to verify generic code, and leverage generics to create custom
    test utilities.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后部分致力于讨论测试复杂Go代码的更具挑战性的方面，因为前两节提供了测试应用程序所需的所有工具和技术。我们首先通过了解Go并发机制和并发不可测试的条件开始我们的探索，包括如何使用Go的竞态检测器。然后，我们通过利用模糊测试和基于属性的测试重新审视并扩展我们对边缘情况的测试，使我们能够用大量输入来测试我们的代码，以确保其健壮性。最后，我们探索如何利用Go最近引入的泛型能力来编写可以与不同类型一起工作的代码，学习如何将表驱动测试转换为验证泛型代码，并利用泛型创建自定义测试工具。
- en: 'This part has the following chapters:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 9*](B18371_09.xhtml#_idTextAnchor197)*, Challenges of Testing Concurrent
    Code*'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18371_09.xhtml#_idTextAnchor197)《测试并发代码的挑战》'
- en: '[*Chapter 10*](B18371_10.xhtml#_idTextAnchor218)*, Testing Edge Cases*'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18371_10.xhtml#_idTextAnchor218)《测试边缘情况》'
- en: '[*Chapter 11*](B18371_11.xhtml#_idTextAnchor231)*, Working with Generics*'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18371_11.xhtml#_idTextAnchor231)《与泛型一起工作》'
