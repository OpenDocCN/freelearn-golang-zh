- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Challenges of Testing Concurrent Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试并发代码的挑战
- en: In the previous chapters, we covered all of the essentials knowledge that TDD
    practitioners will need to test their applications. We learned how to unit test
    our code in the development phase, how to integration test our larger components,
    and how to end-to-end test our entire services. These are essential building blocks
    for building and running any software project. The test suite allows us to verify
    that our application is functioning according to the client’s requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们涵盖了TDD实践者测试应用程序所需的所有基本知识。我们学习了如何在开发阶段对代码进行单元测试，如何对较大的组件进行集成测试，以及如何对整个服务进行端到端测试。这些都是构建和运行任何软件项目的基本构建块。测试套件使我们能够验证我们的应用程序是否按照客户的要求运行。
- en: As the system grows and matures, developers then must inevitably consider how
    to change and evolve their code, ensuring that their system remains performant
    and scalable. As discussed in [*Chapter 7*](B18371_07.xhtml#_idTextAnchor162),
    *Refactoring in Go*, there are some common refactoring techniques that we can
    use to make the code change process easier. One common system refactoring technique
    is breaking up monolithic applications and replacing them with microservice architectures.
    In [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179), *Testing Microservice Architectures*,
    we learned how to split up the `BookSwap` application and test the integrations
    between microservices with the newly introduced technique of contract testing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的增长和成熟，开发者不可避免地必须考虑如何更改和演进他们的代码，确保他们的系统保持高性能和可扩展性。正如在[*第7章*](B18371_07.xhtml#_idTextAnchor162)中讨论的，*Go中的重构*，有一些常见的重构技术可以帮助我们使代码变更过程更加容易。一种常见的系统重构技术是将单体应用程序拆分，并用微服务架构替换。在第[*第8章*](B18371_08.xhtml#_idTextAnchor179)中，*测试微服务架构*，我们学习了如何使用新引入的合同测试技术拆分`BookSwap`应用程序并测试微服务之间的集成。
- en: 'As we step into the world of microservice architectures, testing gets more
    difficult due to two crucial aspects: services are changed by teams within the
    organization without any central oversight and the operation order can no longer
    be guaranteed. We covered the integration testing aspects in previous chapters,
    but we are yet to explore the difficulties brought on by the variations in operation
    order. Most importantly, we need to explore how to handle the different states
    that varying operation orders can put an application in.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们步入微服务架构的世界时，由于两个关键方面，测试变得更加困难：服务由组织内部的团队更改，没有任何中央监督，并且操作顺序无法保证。我们在前面的章节中涵盖了集成测试方面，但尚未探讨操作顺序变化带来的困难。最重要的是，我们需要探讨如何处理不同的操作顺序可能使应用程序处于的不同状态。
- en: This chapter will explore the implementation and testing of concurrent code.
    We will begin by discussing Go’s concurrency mechanisms, which are one of the
    main advantages of the Go programming language. Then, we will explore some common
    concurrency examples. We will learn how to make use of Go’s race detector, which
    is part of the Go toolchain. Finally, we will discuss what concurrency conditions
    cannot be tested and see how we can detect concurrency issues in the `BookSwap`
    application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨并发代码的实现和测试。我们将从讨论Go的并发机制开始，这是Go编程语言的主要优势之一。然后，我们将探讨一些常见的并发示例。我们将学习如何利用Go的工具链中的race
    detector，最后，我们将讨论哪些并发条件无法测试，并探讨如何在`BookSwap`应用程序中检测并发问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Go’s concurrency mechanisms – goroutines, channels, and synchronization primitives
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go的并发机制——goroutines、channels和同步原语
- en: Applied concurrency examples and patterns, including creating thread-safe data
    structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用并发示例和模式，包括创建线程安全的数据结构
- en: Untestable conditions of concurrent code – race conditions, deadlocks, and starvation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发代码不可测试的条件——竞争条件、死锁和饥饿
- en: The usage and limitations of the Go race detector
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go race detector的使用和限制
- en: Detecting and fixing concurrency issues in the `BookSwap` application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`BookSwap`应用程序中检测和修复并发问题
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described on the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装**Go版本1.19**或更高版本才能运行本章中的代码示例。安装过程在官方Go文档中描述，网址为[https://go.dev/doc/install](https://go.dev/doc/install)。
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter09](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter09).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含的代码示例在[https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter09](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter09)公开可用。
- en: Concurrency mechanisms in Go
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的并发机制
- en: Go’s in-built concurrency mechanisms are one of its biggest strengths and are
    often one of the main reasons developers choose to use Go for their services.
    Implementing concurrency in Go is easy (and painless!) due to its **goroutines**
    and **channels**. In this section, we will explore each mechanism and review its
    behavior so that we can better understand how to use and test them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Go内置的并发机制是其最大的优势之一，也是开发者选择使用Go为其服务的主要原因之一。由于Go的**goroutines**和**channels**，在Go中实现并发既简单（又痛苦！）我们将探索每个机制并回顾其行为，以便我们更好地理解如何使用和测试它们。
- en: '**Concurrency** is a program’s ability to process multiple tasks at the same
    time. This crucial ability allows us to get the most out of the CPU processing
    power, allowing us to make optimal use of our resources. This is important in
    all systems in order to be able to process as many requests as possible, without
    disrupting other flows in the program and keep computing costs low.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**是程序同时处理多个任务的能力。这种关键能力使我们能够充分利用CPU的处理能力，从而使我们能够最优化地使用我们的资源。这对于所有系统来说都很重要，以便能够处理尽可能多的请求，同时不干扰程序中的其他流程，并保持计算成本较低。'
- en: '*Figure 9**.1* depicts two concurrent tasks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.1*展示了两个并发任务：'
- en: '![Figure 9.1 – Concurrent execution flow of two tasks ](img/Figure_9.1_B18371.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 两个任务的并发执行流程](img/Figure_9.1_B18371.jpg)'
- en: Figure 9.1 – Concurrent execution flow of two tasks
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 两个任务的并发执行流程
- en: 'The tasks are divided into functions that form a call stack:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 任务被分为形成调用栈的函数：
- en: 'In this example, each task is divided into three functions that make up the
    call stack. The task begins when it receives its input and finishes when it has
    computed its result or output. **Task A** is divided into three functions: **Function
    A1**, **Function A2**, and **Function A3**. This separation is the same in **Task
    B**.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，每个任务被分为三个函数，这些函数构成了调用栈。任务从接收输入开始，并在计算结果或输出后结束。**任务A**被分为三个函数：**函数A1**、**函数A2**和**函数A3**。这种分离在**任务B**中也是相同的。
- en: The two tasks, **Task A** and **Task B**, are independent of each other. Each
    task receives its own input and calculates its own result. As the tasks are not
    connected, they can be computed in any order. This makes them suitable for executing
    as part of a **concurrent** **execution flow**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个任务，**任务A**和**任务B**，彼此独立。每个任务都接收自己的输入并计算自己的结果。由于任务之间没有连接，它们可以以任何顺序计算。这使得它们适合作为**并发****执行流程**的一部分来执行。
- en: When executing the tasks concurrently, subtasks are **scheduled** and **interrupted**
    for the most efficient execution. The ability to interrupt the functions in the
    call stack is a key requirement for the concurrent execution of these two tasks.
    We will learn how to prevent these interruptions in the following sections.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当并发执行任务时，子任务会被**调度**和**中断**以实现最有效的执行。在调用栈中中断函数的能力是这两个任务并发执行的关键要求。我们将在接下来的章节中学习如何防止这些中断。
- en: Each task begins when its input is received. In this example, **Input A** is
    received before **Input B** and its corresponding **Task A** starts execution
    first.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个任务从接收输入开始。在这个例子中，**输入A**在**输入B**之前接收，并且相应的**任务A**首先开始执行。
- en: The subtasks, or functions, are executed in an interleaving way, with the CPU
    executing functions from **Task A** and **Task B** in a combined way. We notice
    that the subtasks are executed in order within the task. This means that **Function
    A1** is executed before **Function A2**, but there are **no order guarantees**
    with regard to timing when it comes to the subtasks of **Task B**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子任务或函数以交错的方式执行，CPU以结合的方式执行**任务A**和**任务B**的函数。我们注意到子任务在任务内部是有序执行的。这意味着**函数A1**在**函数A2**之前执行，但关于**任务B**的子任务的执行时间上没有**顺序保证**。
- en: Once the task is completed successfully, the output is returned and the CPU
    is free to execute other tasks. We notice that even though **Input B** arrives
    second and **Task B** starts second, it completes first and **Result B** is returned
    first. The scheduling of the functions depends on the availability of resources
    and other factors. We will explore how scheduling works in Go in later sections.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦任务成功完成，输出将被返回，CPU 可以自由执行其他任务。我们注意到，尽管 **输入 B** 第二个到达，**任务 B** 第二个开始，但它首先完成，并且首先返回
    **结果 B**。函数的调度取决于资源的可用性和其他因素。我们将在后面的章节中探讨 Go 语言中调度的工作原理。
- en: Since there are no order guarantees between concurrently running tasks, we should
    be careful that the tasks we allow to run concurrently are independent and do
    not rely on each other. Otherwise, the concurrent execution of the tasks could
    lead to slow-running tasks or bugs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并发运行的任务之间没有顺序保证，我们应该小心允许并发运行的任务是独立的，并且不依赖于彼此。否则，任务的并发执行可能会导致运行缓慢的任务或错误。
- en: Avoid ordering assumptions
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 避免顺序假设
- en: Concurrency can be used under the hood in libraries, and it might not always
    be straightforward to see where it is used. Therefore, we should avoid making
    assumptions about ordering or execution time. We will learn how to make use of
    synchronization mechanisms and checks to ensure that conditions are met before
    execution is started.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 并发性可以在库的底层使用，并且它可能并不总是容易看到它的使用位置。因此，我们应该避免对顺序或执行时间做出假设。我们将学习如何利用同步机制和检查来确保在执行开始之前条件得到满足。
- en: Parallelism is often confused with concurrency, but it is a program’s ability
    to execute tasks simultaneously. Unlike concurrency, which does not guarantee
    task ordering, we know that the task execution in this pattern will be happening
    in parallel. Tasks should also be independent of each other, as they cannot wait
    for each other.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 并行性经常与并发性混淆，但它是指程序执行任务的同时性的能力。与并发性不同，并发性并不保证任务顺序，我们知道在这种模式下的任务执行将是并行的。任务也应该相互独立，因为它们不能相互等待。
- en: '*Figure 9**.2* depicts two parallel tasks:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9.2* 描述了两个并行任务：'
- en: '![Figure 9.2 – Parallel execution flow of two tasks ](img/Figure_9.2_B18371.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 两个任务的并行执行流程](img/Figure_9.2_B18371.jpg)'
- en: Figure 9.2 – Parallel execution flow of two tasks
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 两个任务的并行执行流程
- en: 'The parallel execution flow of two tasks happens simultaneously:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 两个任务的并行执行流程是同时发生的：
- en: The tasks begin executing once **Input A** and **Input B** are received.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦接收到 **输入 A** 和 **输入 B**，任务就开始执行。
- en: The tasks are executed simultaneously and independently, without interruption
    or interleaving.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务同时且独立地执行，不受干扰或交错。
- en: The tasks are completed at the same time, within a margin of error. There will
    always be deviations in resource usage and performance regardless of how much
    we attempt to specify them to be identical.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务在同一时间完成，误差范围内。无论我们尝试将它们指定得多么一致，资源使用和性能总会存在偏差。
- en: In order to achieve true parallelism, separate computing resources are required.
    This increases the cost of our system infrastructure, which is undesirable, if
    not a dealbreaker, for some engineering teams. Therefore, concurrency is often
    the preferred way to achieve multitasking in programs. As the system becomes successful,
    properly implemented concurrency can facilitate a smooth transition to parallelism
    when the system can handle such increased costs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现真正的并行性，需要单独的计算资源。这增加了我们系统基础设施的成本，对于某些工程团队来说，这可能是不受欢迎的，甚至可能是决定性的。因此，并发性通常是实现程序中多任务的首选方式。随着系统的成功，正确实现的并发性可以促进系统在能够承担这种增加成本的情况下，顺利过渡到并行性。
- en: In Go, the concurrent processing of functions or subtasks is executed using
    **goroutines**. We will look at what they are, how they are scheduled, and how
    to synchronize them in the following sections.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，函数或子任务的并发处理是通过 **goroutines** 来执行的。在接下来的几节中，我们将探讨它们是什么，如何进行调度，以及如何同步它们。
- en: Goroutines
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Goroutines
- en: Now that we understand the difference between concurrency and parallelism, we
    will focus our attention on the implementation of concurrency in Go for the remainder
    of this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了并发性和并行性之间的区别，我们将把注意力集中在本章剩余部分对 Go 语言中并发实现的探讨上。
- en: '**Goroutines** are functions or methods that can run concurrently with other
    functions or methods. They are often referred to as **lightweight threads**, as
    they have a small memory allocation and run over a much smaller number of OS threads.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Goroutines**是可以在与其他函数或方法并发运行的功能或方法。它们通常被称为**轻量级线程**，因为它们具有较小的内存分配，并且在一个远小于操作系统线程的数量上运行。'
- en: 'It is easy to instruct the Go runtime to run a function in its own goroutine
    by using the `go` keyword:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`go`关键字很容易指示Go运行时在其自己的goroutine中运行一个函数：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code snippet creates a `main` function and a `greet` function, which takes
    a string as a parameter and then prints it to the terminal. We instruct the runtime
    to run the function in its own goroutine by adding the `go` keyword in front of
    its invocation. At the end, we print the “Goodbye, friend!” line to signal that
    the `main` function has been completed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段创建了一个`main`函数和一个`greet`函数，该函数接受一个字符串作为参数，然后将其打印到终端。我们通过在其调用前添加`go`关键字来指示运行时在其自己的goroutine中运行该函数。最后，我们打印“再见，朋友！”这一行来表示`main`函数已完成。
- en: 'We run this little program using the usual command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用常规命令运行这个小程序：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The program does not print the greeting; instead, it only prints the goodbye
    line. This is due to the behavior of programs and goroutines. *Figure 9**.3* presents
    a visualization of these properties:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 程序没有打印问候语；相反，它只打印了再见行。这是由于程序和goroutine的行为所致。*图9**.3*展示了这些特性的可视化：
- en: '![Figure 9.3 – Goroutine execution of the greeting program ](img/Figure_9.3_B18371.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 问候程序的goroutine执行](img/Figure_9.3_B18371.jpg)'
- en: Figure 9.3 – Goroutine execution of the greeting program
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 问候程序的goroutine执行
- en: 'The program does not print the greeting to the terminal because of the intended
    **non-blocking behavior** of goroutine creation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于goroutine创建的**非阻塞行为**，程序没有将问候语打印到终端：
- en: The main function starts when we run our program. This function runs in its
    own goroutine, which we will refer to as the **main goroutine**. The main function
    has its own **execution time** based on the statements contained inside the body
    of the main function.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行我们的程序时，主函数开始执行。这个函数在其自己的goroutine中运行，我们将称之为**主goroutine**。主函数根据主函数体内的语句有自己的**执行时间**。
- en: During main function execution, the main goroutine instructs the Go runtime
    to `greet` function in this goroutine. This main goroutine has a **parent-child
    relationship** with the main goroutine. We will refer to this child goroutine
    as the **greet goroutine**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数执行期间，主goroutine指示Go运行时在这个goroutine中运行`greet`函数。这个主goroutine与主goroutine有**父子关系**。我们将把这个子goroutine称为**问候goroutine**。
- en: The creation of the child goroutine, which will run our `greet` function, is
    a **non-blocking operation**. This allows us to achieve the multitasking aspect
    of concurrency that we previously discussed.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建子goroutine，该goroutine将运行我们的`greet`函数，这是一个**非阻塞操作**。这使我们能够实现之前讨论的并发中的多任务方面。
- en: As the main goroutine is not blocked, it finishes its own work and completes
    its execution time. Once the main goroutine has completed, the Go runtime cleans
    up all of its resources. As the main goroutine has a parent-child relationship
    with the greet goroutine, the runtime **kills the** **greet goroutine**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于主goroutine没有被阻塞，它完成了自己的工作并完成了执行时间。一旦主goroutine完成，Go运行时会清理其所有资源。由于主goroutine与问候goroutine之间存在父子关系，运行时会**终止****问候goroutine**。
- en: The greet goroutine immediately stops execution and **shuts down**. Depending
    on how much execution time it has received from the CPU, the greet goroutine may
    be able to execute its print to the terminal or not.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问候goroutine立即停止执行并**关闭**。根据它从CPU获得的执行时间，问候goroutine可能能够执行其打印到终端的操作，也可能不能。
- en: Due to these properties, the program does not manage to reliably print the greeting
    to the terminal. We need to stop the main goroutine from shutting down in order
    to give time for the child goroutine to finish its execution.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些特性，程序无法可靠地将问候语打印到终端。我们需要阻止主goroutine关闭，以便给子goroutine足够的时间完成其执行。
- en: 'One solution is to block the main goroutine from terminating by invoking the
    `time.Sleep` function for a predetermined amount of time, such as 1 second. Another,
    more interesting, solution is to signal that the greet goroutine has completed
    its work by writing a value to a shared variable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是通过调用`time.Sleep`函数阻塞主goroutine的终止，持续预定的时间，例如1秒。另一种更有趣的解决方案是通过向共享变量写入值来指示问候goroutine已完成其工作：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The two functions share memory space, so it is possible for them to write and
    read to shared variables. The code snippet demonstrates this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数共享内存空间，因此它们可以写入和读取共享变量。代码片段展示了这一点：
- en: We create a variable of the `bool` type at the top, named `finished`. The purpose
    of this variable is to provide a signal to the main function that the `greet`
    function has completed.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在顶部创建了一个名为`finished`的`bool`类型变量。这个变量的目的是向`main`函数提供一个信号，表明`greet`函数已完成。
- en: Once the greet function writes its greeting to the terminal, it sets the value
    of the `finished` variable to `true`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`greet`函数将问候语写入终端，它就会将`finished`变量的值设置为`true`。
- en: Inside the body of the main function, we create a `for` loop, which will execute
    until the value of the `finished` variable is `true`. Using the `time.Sleep` function,
    we poll the value of the variable every 10 milliseconds.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数的主体内部，我们创建了一个`for`循环，该循环将一直执行，直到`finished`变量的值为`true`。使用`time.Sleep`函数，我们每10毫秒轮询变量的值。
- en: Once the `for` loop completes, the main goroutine completes its execution and
    all of the resources of both goroutines are cleaned up.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`for`循环完成，主goroutine完成其执行，并且两个goroutine的所有资源都被清理干净。
- en: 'Running this program will print the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序将打印以下内容：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, using this simple approach of writing to a shared variable, we have
    managed to block the main goroutine until its child goroutine finishes. We are
    finally able to see the greeting printed in the terminal and the program is executing
    correctly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用写入共享变量的简单方法，我们成功地阻塞了主goroutine，直到其子goroutine完成。我们终于能够在终端中看到打印的问候语，程序正在正确执行。
- en: This way of sharing information between goroutines is known as **communicating
    by sharing memory** and it is the traditional way to deal with concurrency in
    other programming languages. This approach is not without drawbacks. However,
    Go has another approach, which we will explore in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在goroutines之间共享信息的方式被称为**通过共享内存通信**，并且是处理其他编程语言中并发问题的传统方式。这种方法并非没有缺点。然而，Go还有另一种方法，我们将在下一节中探讨。
- en: Channels
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道
- en: '**Channels** provide another way for goroutines to communicate with one another.
    We can think of the in-built channel type as a pipe through which we can safely
    send information between goroutines, without having to use shared variables or
    memory. In Go, this principle is known as **sharing memory** **by communicating**.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**通道**为goroutines之间提供了一种相互通信的方式。我们可以将内置的通道类型视为一个管道，通过它可以安全地在goroutines之间发送信息，而无需使用共享变量或内存。在Go中，这个原则被称为**通过通信共享内存**。'
- en: '*Figure 9**.4* depicts the main operations and syntax of channels:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.4* 描述了通道的主要操作和语法：'
- en: '![Figure 9.4 – Operations and syntax of Go channels ](img/Figure_9.4_B18371.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – Go通道的操作和语法](img/Figure_9.4_B18371.jpg)'
- en: Figure 9.4 – Operations and syntax of Go channels
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – Go通道的操作和语法
- en: 'The interaction with the channel demonstrates the syntax of its two main operations:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与通道的交互展示了其两种主要操作的语法：
- en: '`ch chan bool`: The channel is a built-in type in Go, so it does not require
    us to import any libraries. A channel is declared using the `chan` keyword followed
    by a data type, `bool`, which the channel will be able to transport. Only this
    type of variable can be transported through it. This is compiler enforced.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ch chan bool`：通道是Go中的内置类型，因此我们不需要导入任何库。通道是通过使用`chan`关键字后跟数据类型`bool`来声明的，通道将能够传输这种类型的数据。只有这种类型的变量可以通过它传输。这是由编译器强制执行的。'
- en: '`ch <- true`: The first operation that channels support is the `<-`, and indicates
    the way that the data is flowing through the channel. In this case, the arrow
    points toward the channel where we send a `true` value to it.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ch <- true`：通道支持的第一种操作是`<-`，它表示数据通过通道流动的方式。在这种情况下，箭头指向通道，我们将一个`true`值发送给它。'
- en: '`f := <-ch`: The counterpart to the send operation is the receive operation.
    This operation is performed by pointing the channel operator away from the channel
    and allocating the receive to a local variable named `f`.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`f := <-ch`：发送操作的对应操作是接收操作。这个操作是通过将通道操作符指向通道并将接收分配给一个名为`f`的局部变量来执行的。'
- en: This is the basic usage of channels, although we will explore some further subtleties
    in later sections. The send and receive operations are **blocking and synchronous**,
    so both parties of the transaction need to be available for the operations to
    complete.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是通道的基本用法，尽管我们将在后面的章节中探讨一些更细微的细节。发送和接收操作是**阻塞和同步的**，因此交易双方都需要可用才能完成操作。
- en: 'Channels are a great **synchronization and communication mechanism**. We can
    make use of them to synchronize our main and greeter goroutines using more concise
    code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是一个优秀的**同步和通信机制**。我们可以利用它们通过更简洁的代码来同步主goroutine和greeter goroutine：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This simplified version of the solution makes use of a channel to synchronize
    the two goroutines:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简化的解决方案利用通道来同步两个goroutine：
- en: The `greet` function is changed to take in a channel parameter. Similarly, for
    maps and slices, the channel type has a built-in pointer reference, so we do not
    need to explicitly pass it by pointer using the `&` operator.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`greet`函数被修改为接受一个通道参数。同样，对于map和slice，通道类型有一个内置的指针引用，因此我们不需要使用`&`运算符显式地通过指针传递它。'
- en: Once the greeting is printed, the `greet` function sends the `true` value to
    the channel. This will signal to the main goroutine that the `greet` function
    has successfully completed.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦打印出问候语，`greet`函数就会向通道发送`true`值。这将向主goroutine发出信号，表明`greet`函数已成功完成。
- en: Inside the main function, we initialize a channel using the `make` function.
    The zero value of the channel type is `nil`, so we use the `make` function to
    create a channel that is ready to use. Under the hood, the `make` function will
    allocate all the resources required.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数内部，我们使用`make`函数初始化一个通道。通道类型的零值是`nil`，所以我们使用`make`函数创建一个准备好使用的通道。在底层，`make`函数将分配所有所需的资源。
- en: Once the `greet` function has been started in its own goroutine, the main function
    invokes the receive operation on the channel. Since the send and receive operations
    on channels are blocking, this will block the main goroutine until the `greet`
    goroutine has completed and has been able to send the value through the channel.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在它自己的goroutine中启动了`greet`函数，主函数就会在通道上调用接收操作。由于通道上的发送和接收操作是阻塞的，这将会阻塞主goroutine，直到`greet`
    goroutine完成并且能够通过通道发送值。
- en: The use of channels has simplified the implementation by removing the need to
    poll for the value of the `finished` variable. We also notice that the channel
    variable, `ch`, has been initialized inside the main function and been passed
    as a parameter. Since there is now no global variable, we have removed the need
    to communicate by sharing memory between the two goroutines.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通道简化了实现，消除了对轮询`finished`变量值的需要。我们还注意到，通道变量`ch`已经在主函数内部初始化，并作为参数传递。由于现在没有全局变量，我们消除了两个goroutine之间通过共享内存进行通信的需要。
- en: Channels support one final operation, the close operation. Unlike sends and
    receives, closing a channel changes the state of the channel and indicates the
    completion of work to the channel’s receivers. It is an operation that can be
    used for the purpose of synchronization, as opposed to supporting information
    exchange and communication between goroutines. A closed channel will immediately
    return the zero value of the channel type to all receive operations and cause
    a panic on all send operations that are attempted on the channel in the future.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通道支持一个最后的操作，即关闭操作。与发送和接收不同，关闭通道会改变通道的状态，并向通道的接收者指示工作的完成。这是一个可以用于同步的操作，而不是支持goroutine之间的信息交换和通信。一个关闭的通道将立即返回通道类型的零值给所有接收操作，并在未来尝试在通道上执行的所有发送操作上引发panic。
- en: 'Since the purpose of our channel is to synchronize the `greet` and `main` goroutines,
    we can make use of the close operation to further simplify our code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通道的目的在于同步`greet`和`main` goroutine，我们可以利用关闭操作来进一步简化我们的代码：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are a few tweaks we have made to our solution. The data type of the channel
    is now the empty `struct{}`, which reduces the memory footprint of the channel.
    Inside the `greet` function, we close the channel immediately after the function
    prints its greeting. While these changes do not seem significant, this solution
    will work for signaling to multiple receivers that work has completed, as opposed
    to having to write multiple values on the channel. This is a powerful mechanism
    that we can make use of to solve a variety of problems.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对我们的解决方案做了一些调整。通道的数据类型现在是空的`struct{}`，这减少了通道的内存占用。在`greet`函数内部，函数打印问候语后立即关闭通道。虽然这些变化看起来并不显著，但此解决方案可以用于向多个接收器发出工作已完成的通知，而不是需要在通道上写入多个值。这是一个强大的机制，我们可以利用它来解决各种问题。
- en: '*Figure 9**.5* summarizes the behavior of the channels we have studied so far:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.5* 总结了我们迄今为止研究过的通道的行为：'
- en: '![Figure 9.5 – Summary of channel operations and states ](img/Figure_9.5_B18371.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 通道操作和状态的总结](img/Figure_9.5_B18371.jpg)'
- en: Figure 9.5 – Summary of channel operations and states
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 通道操作和状态的总结
- en: 'This figure is a useful reference for understanding how channels will behave
    in our code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此图是理解通道在我们代码中如何行为的有用参考：
- en: '`make` function. They cannot be used to send information but are useful for
    passing to goroutines when those goroutines are started. The nil channel will
    be initialized for use at a future time:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`make`函数。它们不能用于发送信息，但在启动goroutine时很有用。nil通道将在未来某个时间初始化以供使用：'
- en: Send operations will block until the channel is initialized, after which the
    rules for initialized channels apply.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送操作将阻塞，直到通道初始化，之后将应用初始化通道的规则。
- en: Receive operations behave identically to send operations.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收操作的行为与发送操作相同。
- en: Close operations panic on nil channels. As nil channels are not ready to send
    information through, it would not make sense to close them. It is therefore considered
    a fatal error if we attempt to close nil channels.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭操作在nil通道上会引发恐慌。由于nil通道尚未准备好通过发送信息，因此关闭它们是没有意义的。因此，如果我们尝试关闭nil通道，这被视为一个致命错误。
- en: '**Initialized channels** are created using the make function and are ready
    to be used. They are ready for sending information through:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化通道**是通过make函数创建的，并准备好使用。它们可以用于发送信息：'
- en: Send operations will block until a receiver arrives. The sending goroutine will
    not be able to execute past this point until the operation completes.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送操作将阻塞，直到到达接收者。发送goroutine将无法执行到这一点，直到操作完成。
- en: Receive operations will block until a value arrives from the sender. As sends
    and receives are synchronous operations, both goroutines must be ready to complete
    the operation for the two parts of the transaction to be completed. So, if the
    sender starts up but the receiver is not yet ready, this will mean the sender
    halts until the receiver is ready, which can be a helpful property.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收操作将阻塞，直到从发送者那里收到值。由于发送和接收是同步操作，两个goroutine都必须准备好完成操作，以便完成事务的两个部分。因此，如果发送者启动但接收者尚未准备好，这意味着发送者将暂停，直到接收者准备好，这可以是一个有用的特性。
- en: Close operations complete immediately. Once the first operation completes, the
    channel will move into the **Closed Channel** state.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭操作立即完成。一旦第一个操作完成，通道将进入**关闭通道**状态。
- en: 'Closed channels are initialized channels that have been successfully closed.
    Channels in this state signal that they will no longer be able to transport information:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭的通道是已成功关闭的初始化通道。处于此状态的通道表示它们将不再能够传输信息：
- en: Send operations will panic. There is no easy way to know whether a channel is
    closed, so the panic lets senders know that they should stop sending values to
    it, but you should code carefully in order to avoid encountering a panic.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送操作将引发恐慌。没有简单的方法知道通道是否已关闭，因此恐慌让发送者知道他们应该停止向其发送值，但你应该小心编写代码，以避免遇到恐慌。
- en: Receive operations will immediately complete with the zero value of the channel’s
    data type. As we have seen in our greeter example, we can use the receive operation
    on closed channels as a synchronization mechanism.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收操作将立即使用通道数据类型的零值完成。正如我们在问候示例中看到的那样，我们可以使用关闭通道上的接收操作作为同步机制。
- en: Close operations will panic, as channels can only move into the closed state
    once. Again, defensive coding (for example, the single responsibility principle
    where only one part of your code is responsible for closing the channel) can help
    to control this.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭操作会引发恐慌，因为通道只能移动到关闭状态一次。再次强调，防御性编程（例如，单一责任原则，即代码的某一部分只负责关闭通道）可以帮助控制这种情况。
- en: One final aspect to note is that once a channel is closed, it cannot be opened
    again. This can create some complications when using them when solving more complicated
    problems. Now that we understand the fundamental behavior of goroutines and channels,
    we can explore some commonly applied concurrency examples in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，一旦通道被关闭，就不能再次打开。在解决更复杂问题时使用它们可能会引起一些复杂性。现在我们已经了解了 goroutines 和通道的基本行为，我们可以在下一节探索一些常用的并发示例。
- en: Applied concurrency examples
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用并发示例
- en: 'So far, we have learned about the main operations and behavior of goroutines
    and channels. These two concurrency mechanisms are important to understand, as
    they are pivotal to how Go implements concurrency. However, the Go standard library
    also includes concurrency primitives in its `sync` package. It contains synchronization
    primitives with a broad variety of uses:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 应用并发示例
- en: '`sync.Map` is a map implementation that is safe for concurrent use. We will
    explore how to create other thread-safe data structures in the next section.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Map` 是一种线程安全的映射实现。我们将在下一节探讨如何创建其他线程安全的数结构。'
- en: '`sync.Mutex` is an exclusion lock. It allows us to gatekeep resources for usage
    by one goroutine at a time. It is also possible to take a read-only or a read-write
    mutex depending on the problem being solved.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Mutex` 是一种排他锁。它允许我们一次只让一个 goroutine 使用资源。根据要解决的问题，也可以使用只读或读写互斥锁。'
- en: '`sync.Once` is a specialized lock that can only be acquired once. This is useful
    for wrapping around statements, such as cleanup code, which should only run once.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Once` 是一种特殊的锁，它只能被获取一次。这对于包装只应运行一次的语句，例如清理代码，非常有用。'
- en: '`sync.Pool` is a temporary set of objects that are individually saved and retrieved.
    It can be seen as a cache of objects, making it easy to create thread-safe lists.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Pool` 是一组临时对象，可以单独保存和检索。它可以被视为对象的缓存，使得创建线程安全的列表变得容易。'
- en: '`sync.WaitGroup` waits for a collection of goroutines to finish. This primitive
    has a counter and a lock under the hood, allowing it to keep track of how many
    goroutines it will need to wait for before completing. This can greatly simplify
    a main goroutine.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.WaitGroup` 等待一组 goroutines 完成。这个原语内部有一个计数器和锁，允许它跟踪在完成之前需要等待多少个 goroutines。这可以大大简化主
    goroutine。'
- en: You can read the full documentation of the synchronization primitives of the
    `sync` package in the official Golang documentation ([https://pkg.go.dev/sync](https://pkg.go.dev/sync)).
    These well-designed synchronization primitives give us the tools to solve many
    types of problems. Let us have a look at some of them in action in the next sections.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方 Golang 文档中阅读 `sync` 包的同步原语的完整文档（[https://pkg.go.dev/sync](https://pkg.go.dev/sync)）。这些精心设计的同步原语为我们提供了解决许多类型问题的工具。让我们在下一节中看看它们在实际中的应用。
- en: Closing once
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭操作会引发恐慌，因为通道只能进入关闭状态一次。再次强调，防御性编程（例如，单一责任原则，即代码的某一部分只负责关闭通道）可以帮助控制这种情况。
- en: As we saw in *Figure 9**.5*, channels panic if we attempt to close a channel
    multiple times. This is a great candidate for using `sync.Once`, although we can
    imagine other great uses of this mechanism, such as implementing the **Singleton
    pattern** or executing clean-up functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *图9**.5* 中看到的那样，如果我们尝试多次关闭通道，通道会引发恐慌。这是一个使用 `sync.Once` 的绝佳候选，尽管我们可以想象出这个机制的其他伟大用途，例如实现
    **单例模式** 或执行清理函数。
- en: 'This specialized lock is easy to use to ensure that a channel is only closed
    once:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特殊的锁很容易使用，以确保通道只关闭一次：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We implement the safe closing of a channel by wrapping it around the close
    operation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过包装关闭操作来实现通道的安全关闭：
- en: We create the `safelyClose` function, which takes in a pointer to the `sync.Once`
    type and the channel created by the main function. Note that unlike the channel
    type, we need to pass the `Once` type using explicit parameter pointer types.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了 `safelyClose` 函数，它接受一个指向 `sync.Once` 类型的指针和由主函数创建的通道。请注意，与通道类型不同，我们需要使用显式的参数指针类型传递
    `Once` 类型。
- en: Inside the `safelyClose` function, we call the close operation on the channel
    inside the `once.Do` method. The `Do` method takes a function as a parameter,
    so we wrap our statement inside an anonymous function.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`safelyClose`函数内部，我们在`once.Do`方法中调用channel的关闭操作。`Do`方法接受一个函数作为参数，因此我们将我们的语句包装在一个匿名函数中。
- en: Inside the main function, we create a zero-value `sync.Once` instance. There
    is no special initialization we need to undertake with synchronization primitives,
    so the zero value is ready for use.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数内部，我们创建了一个零值的`sync.Once`实例。对于同步原语，我们不需要进行特殊初始化，所以零值可以直接使用。
- en: We create multiple goroutines that execute the `safelyClose` function using
    a `for` loop. These goroutines all share the same `once` and channel instances.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`for`循环创建了多个goroutine，这些goroutine执行`safelyClose`函数。这些goroutine都共享相同的`once`和channel实例。
- en: Finally, we block the main goroutine with a receive operation from the channel.
    This operation will complete as soon as the first goroutine closes the channel.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过从channel接收操作来阻塞主goroutine。这个操作将在第一个goroutine关闭channel时完成。
- en: 'Running the example program shows that multiple goroutines are started, but
    the channel is closed only once:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例程序显示，启动了多个goroutine，但channel只关闭了一次：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see from the output, multiple goroutines are started, but the channel
    is only closed once. `sync.Once` is simple to use, but it can help us build safety
    around operations that should only be executed once, such as closing a channel.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，启动了多个goroutine，但channel只关闭了一次。`sync.Once`使用简单，但它可以帮助我们在应该只执行一次的操作周围建立安全性，例如关闭channel。
- en: Thread-safe data structures
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全数据结构
- en: Another frequent problem that engineers solve is building **thread-safe data
    structures**. These types of structures are safe for reading and writing by multiple
    goroutines. By default, Go’s slices and maps are not safe for concurrent use,
    so we will need to be mindful of multiple goroutines accessing shared data structures
    and resources. This is one of the reasons why communicating using channels, which
    are thread safe, is preferred to communicating via shared memory, represented
    by data structures or variables.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师经常解决的问题之一是构建**线程安全的数据结构**。这些类型的结构对多个goroutine的读写都是安全的。默认情况下，Go的slices和maps不是线程安全的，所以我们需要注意多个goroutine访问共享数据结构和资源。这也是为什么使用channel进行通信比通过共享内存（以数据结构或变量表示）进行通信更受欢迎的原因之一。
- en: '`sync.Map` ([https://pkg.go.dev/sync#Map](https://pkg.go.dev/sync#Map)) is
    an implementation of a map that is thread safe. This map uses locks under the
    hood, so it will not be as performant as the built-in map type. The synchronized
    map exposes methods providing reading and writing functionality:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Map` ([https://pkg.go.dev/sync#Map](https://pkg.go.dev/sync#Map)) 是一个线程安全的map实现。这个map在底层使用锁，所以它的性能可能不如内置的map类型。同步map公开了提供读取和写入功能的方法：'
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We interact with the synchronized map through wrapper methods:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过包装方法与同步map交互：
- en: We declare the `workerCount` constant at the top of the program, which will
    denote the number of goroutines we will be starting.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在程序顶部声明了`workerCount`常量，它将表示我们将启动的goroutine数量。
- en: 'The `greet` function takes in three parameters: an ID, a pointer to `sync.Map`,
    and a channel for us to signal that the goroutine has finished its work. We format
    a greeting string, which makes use of the ID that was passed in. Then, we save
    it in the map using the `Store` method and write a value to the `done` channel
    to signal to the main goroutine that this worker goroutine has finished.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`greet`函数接受三个参数：一个ID、一个指向`sync.Map`的指针，以及一个channel，用于我们发出goroutine已完成工作的信号。我们格式化一个问候字符串，该字符串使用了传入的ID。然后，我们使用`Store`方法将其保存到map中，并向`done`channel写入一个值，向主goroutine发出信号，表明这个工作goroutine已完成。'
- en: Inside the main function, we initialize the map. The zero value of this map
    is ready for usage, just as we saw with `sync.Once` earlier. We also initialize
    a channel, which we will use to signal to the main goroutine that the worker goroutines
    have completed.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数内部，我们初始化了map。这个map的零值已经准备好使用，就像我们之前看到的`sync.Once`一样。我们还初始化了一个channel，我们将使用它来向主goroutine发出信号，表明工作goroutine已完成。
- en: Then, we run through two `for` loops. The first loop starts the `greet` function
    in its own goroutine, while the second waits until values are received on the
    `done` channel. This allows us to wait for all goroutines to complete before continuing.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们运行两个 `for` 循环。第一个循环在其自己的 goroutine 中启动 `greet` 函数，而第二个循环等待在 `done` 通道上接收到值。这允许我们在继续之前等待所有
    goroutine 完成。
- en: Finally, we read all the values contained in the map using the `Range` method,
    which takes an anonymous function as a parameter. We print the entries and return
    `true`, which will allow the `Range` method to continue looping.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `Range` 方法读取 `map` 中包含的所有值，该方法接受一个匿名函数作为参数。我们打印条目并返回 `true`，这将允许 `Range`
    方法继续循环。
- en: 'The output of this program shows that the greetings can be saved and retrieved
    concurrently:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出显示，问候语可以同时保存和检索：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The built-in map type will panic when written to by multiple goroutines, so
    you should make sure to use the synchronized map in this case.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `map` 类型在多个 goroutine 同时写入时会引发 panic，所以你应该确保在这种情况下使用同步的 `map`。
- en: 'Similar to the approach of `sync.Map`, we can create our own thread-safe custom
    data structures by using the `sync.Mutex` lock to limit access to the underlying
    data structure. For example, we can create a thread-safe **Last In First Out**
    (**LIFO**) stack by following this approach:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `sync.Map` 的方法类似，我们可以通过使用 `sync.Mutex` 锁来限制对底层数据结构的访问来创建我们自己的线程安全自定义数据结构。例如，我们可以通过以下方法创建线程安全的
    **后进先出**（**LIFO**）堆栈：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The stack implementation makes use of `sync.Mutex`, which exposes two methods,
    `Lock` and `Unlock`, to limit access to the underlying data slice:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈实现使用了 `sync.Mutex`，它公开了两个方法，`Lock` 和 `Unlock`，以限制对底层数据切片的访问：
- en: The custom `Stack` struct has two fields, a lock and a data slice. These are
    unexported fields, as they should only be managed by the stack data structure
    itself.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义的 `Stack` 结构体有两个字段，一个锁和一个数据切片。这些字段是未导出的，因为它们应该只由堆栈数据结构本身来管理。
- en: '`Stack` has two methods. `Push` adds the element to the end of the data slice,
    while `Pop` removes the last element from the data slice and returns it. If the
    slice is empty, then the `Pop` method will return an error.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stack` 有两个方法。`Push` 将元素添加到数据切片的末尾，而 `Pop` 从数据切片中移除最后一个元素并返回它。如果切片为空，则 `Pop`
    方法将返回一个错误。'
- en: Both functions make use of the lock that is of the `sync.Mutex` type to ensure
    that both methods are called by one goroutine at a time. We make use of the `defer`
    keyword to ensure that the lock is released regardless of which execution path
    the method goes through.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个函数都使用了 `sync.Mutex` 类型的锁来确保一次只有一个 goroutine 调用这两个方法。我们使用 `defer` 关键字来确保无论方法通过哪个执行路径，锁都会被释放。
- en: '`sync.Mutex` is a versatile locking mechanism that can be used to block access
    to any code segment that accesses shared resources or requires unique control
    of a resource. This is known as a **critical** **code section**.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Mutex` 是一种多功能的锁定机制，可以用来阻止对任何访问共享资源或需要独占控制资源的代码段的访问。这被称为 **关键** **代码段**。'
- en: Similarly, the `sync` package also provides `sync.RWMutex`, which provides control
    of locking reads and writes separately. This level of control may be useful for
    creating thread-safe data structures that are used by many goroutines.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`sync` 包还提供了 `sync.RWMutex`，它提供了分别控制读写锁的能力。这种级别的控制对于创建由许多 goroutine 使用的线程安全数据结构可能很有用。
- en: Waiting for completion
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待完成
- en: 'The final synchronization primitive that we will explore in this section is
    `sync.WaitGroup`. Under the hood, `WaitGroup` manages an inner counter that maintains
    how many resources are left to complete. This specialized lock allows us to wait
    for multiple goroutines to complete, allowing us to simplify our synchronized
    map example from the previous section:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索的最后一个同步原语是 `sync.WaitGroup`。在底层，`WaitGroup` 管理一个内部计数器，它维护着剩余要完成资源的数量。这个专门的锁允许我们等待多个
    goroutine 完成，从而简化了上一节中的同步 `map` 示例：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have made a few key changes that greatly simplify our solution:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了一些关键性的更改，极大地简化了我们的解决方案：
- en: The `greet` function takes in a pointer to `sync.WaitGroup` instead of the done
    channel. At the top of the function, we defer the `Done` method on `WaitGroup`,
    which decreases its inner counter by 1, signaling that this goroutine has completed.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`greet` 函数接受一个指向 `sync.WaitGroup` 的指针，而不是完成通道。在函数顶部，我们使用 `defer` 关键字调用 `WaitGroup`
    的 `Done` 方法，这将减少其内部计数器 1，表示这个 goroutine 已完成。'
- en: Inside the main function, we initialize `sync.WaitGroup`, which is ready for
    use. We add `workerCount` to the inner counter, signaling to it how many goroutines
    we will start. `WaitGroup` will block until this inner counter reaches zero, which
    will happen as each child goroutine calls the `Done` method once as it finishes.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数内部，我们初始化 `sync.WaitGroup`，它已准备好使用。我们将 `workerCount` 添加到内部计数器，向其指示我们将启动多少个
    goroutine。`WaitGroup` 将阻塞，直到这个内部计数器达到零，这将在每个子 goroutine 调用 `Done` 方法一次后发生。
- en: Finally, we invoke the `Wait` method further down in the `main` function. This
    method will block until the inner counter of `WaitGroup` reaches 0\. This removes
    the need to read messages from our channel for each completed goroutine inside
    a `for` loop.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在 `main` 函数的更下方调用 `Wait` 方法。此方法将阻塞，直到 `WaitGroup` 的内部计数器达到 0。这消除了在 `for`
    循环中为每个完成的 goroutine 从通道读取消息的需要。
- en: This brings us to the end of our exploration of Go concurrency fundamentals
    and applications. As we have seen, Go concurrency makes use of goroutines, channels,
    and synchronization primitives. We can easily use locks to create thread-safe
    data structures and ensure that critical code sections are only accessed one goroutine
    at a time. In the next section, we will learn what problems the newly introduced
    aspect of concurrency brings to our programs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们到达了对 Go 并发基础和应用的探索的结尾。正如我们所见，Go 并发利用了 goroutine、通道和同步原语。我们可以轻松地使用锁来创建线程安全的数据结构，并确保关键代码部分一次只被一个
    goroutine 访问。在下一节中，我们将学习新引入的并发特性给我们的程序带来了哪些问题。
- en: Issues with concurrency
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发问题
- en: Writing concurrent code in Go is elegant and simple. However, it does make our
    code more complex. Developers need to be familiar with the behavior of concurrency
    mechanisms to understand the code they are reading. Furthermore, as timing plays
    a crucial part in how goroutines behave, we might have a hard time reproducing
    potential bugs. In this section, we look at three common concurrency issues. As
    we deep dive into each example, we will also have the opportunity to understand
    the behavior of Go’s concurrency mechanisms.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中编写并发代码既优雅又简单。然而，它确实使我们的代码更加复杂。开发者需要熟悉并发机制的行为，才能理解他们正在阅读的代码。此外，由于时间在 goroutine
    的行为中起着至关重要的作用，我们可能很难重现潜在的错误。在本节中，我们将探讨三个常见的并发问题。随着我们深入每个示例，我们也将有机会了解 Go 并发机制的行为。
- en: Data races
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据竞争
- en: A **data race** is the most common concurrency issue. This issue occurs when
    multiple goroutines access and modify the same shared resource concurrently. This
    is one of the reasons why we should avoid sharing the state between goroutines,
    preferring to share information between goroutines using channels.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据竞争** 是最常见的并发问题。当多个 goroutine 同时访问和修改相同的共享资源时，就会发生此问题。这是我们应避免在 goroutine
    之间共享状态，而倾向于使用通道在 goroutine 之间共享信息的原因之一。'
- en: 'We modify our previous greeting example by saving the formatted greetings into
    a slice, instead of immediately printing the greeting to the terminal:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将格式化的问候语保存到切片中，而不是立即将问候语打印到终端，修改了之前的问候示例：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At first glance, the code example hasn’t been modified very much:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，代码示例并没有做太多修改：
- en: At the top of the program, we declare the `greetings` string slice that we will
    be saving the greetings into. We also declare the `workerCount` constant as `3`,
    which is how many goroutines we will be running.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序顶部，我们声明了将要保存问候语的 `greetings` 字符串切片。我们还声明了 `workerCount` 常量，其值为 `3`，这是我们将要运行的
    goroutine 数量。
- en: The `greet` function takes in two parameters, the goroutine ID and a pointer
    to `sync.WaitGroup`. At the end of the function, we append the formatted greeting,
    `g`, to the `greetings` slice.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`greet` 函数接收两个参数，即 goroutine ID 和指向 `sync.WaitGroup` 的指针。在函数结束时，我们将格式化的问候语
    `g` 添加到 `greetings` 切片。'
- en: In the `main` function, we create `sync.WaitGroup` and run the `greet` function
    in multiple goroutines. `WaitGroup` is used to ensure that the main goroutine
    waits for all of its worker goroutines to complete. At the end of the `main` function,
    once all the `greet` goroutines have completed, we loop over the `greetings` slice
    and print each entry to the terminal.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们创建 `sync.WaitGroup` 并在多个 goroutine 中运行 `greet` 函数。`WaitGroup`
    用于确保主 goroutine 等待所有工作 goroutine 完成。在 `main` 函数的末尾，一旦所有 `greet` goroutine 完成，我们遍历
    `greetings` 切片并将每个条目打印到终端。
- en: 'As the `main` function waits for all the goroutines to complete, we expect
    that all goroutines will have their greeting saved correctly. As `workerCount`
    is equal to `3`, we expect three lines to be printed to the terminal. Let us run
    this program in the usual way and see its output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`main`函数等待所有goroutines完成，我们预计所有goroutines都将正确保存其问候。由于`workerCount`等于`3`，我们预计将在终端打印出三条线。让我们以通常的方式运行这个程序并查看其输出：
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Looking at the output, we see only two goroutines have had their results recorded.
    We can see that something has gone wrong with the code changes we have made.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 观察输出，我们看到只有两个goroutines记录了它们的结果。我们可以看到，我们做出的代码更改出了问题。
- en: 'This code example suffers from a data race. *Figure 9**.6* depicts the sequence
    of events happening in this example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例存在数据竞争。*图9**.6*展示了这个示例中发生的事件序列：
- en: '![Figure 9.6 – The data race events ](img/Figure_9.6_B18371.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 数据竞争事件](img/Figure_9.6_B18371.jpg)'
- en: Figure 9.6 – The data race events
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 数据竞争事件
- en: 'As multiple goroutines attempt to append their results to the `greetings` slice,
    they actually perform a few operations under the hood:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个goroutines尝试将它们的结果附加到`greetings`切片时，它们实际上在幕后执行一些操作：
- en: '`greetings` **reference**: **Goroutine 1** begins its execution by reading
    the reference to the greetings slice. It will complete its operations based on
    this value.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`greetings` **引用**：**Goroutine 1**开始执行，通过读取`greetings`切片的引用。它将根据这个值完成其操作。'
- en: '`greetings` **reference**: At a later time, **Goroutine 2** begins its execution
    by reading the reference to the greetings slice. This may or may not be the same
    value that **Goroutine 1** has read.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`greetings` **引用**：在稍后的时间，**Goroutine 2**开始执行，通过读取`greetings`切片的引用。这可能或可能不是**Goroutine
    1**读取的相同值。'
- en: '**(3) Write changed version**: During its execution, **Goroutine 1** is ready
    to write its changes and complete its execution. If there is space in the underlying
    array, the element is appended to it. Otherwise, a new, larger array is created
    and the elements are copied to it. A new slice is created with a reference to
    the updated underlying array.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**(3) 写入更改版本**：在执行过程中，**Goroutine 1**准备写入其更改并完成其执行。如果底层数组中有空间，元素将被附加到它。否则，将创建一个新的更大的数组，并将元素复制到它。创建一个新的切片，其引用指向更新的底层数组。'
- en: '**(4) Write changed version**: Finally, **Goroutine 2** is ready to write its
    changes as well. However, it is unaware of any changes that **Goroutine 1** has
    made up to this point. It is still working based on the reference that it has
    read at point **2**. **Goroutine 2** writes its changes, overwriting all the work
    that **Goroutine 1** will have saved at point **3**.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**(4) 写入更改版本**：最后，**Goroutine 2**准备写入其更改。然而，它对此前**Goroutine 1**所做的任何更改一无所知。它仍然基于它在**2**点读取的引用进行工作。**Goroutine
    2**写入其更改，覆盖了**Goroutine 1**将在**3**点保存的所有工作。'
- en: As the `greetings` slice is not protected by locks, goroutines can be interrupted
    at any point in this process. As these changes interleave, the goroutines can
    end up overwriting each other’s changes, leading to an inconsistent result. Depending
    on timing, your output may well look different from the preceding result. Also
    depending on the timing, we might see all of the greetings printed to the terminal
    and assume the program is functioning correctly, or we might see the inconsistent
    behavior we saw during our test run. Data races are commonly occurring issues
    in the world of concurrency and they can be hard to find and replicate.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`greetings`切片没有被锁保护，goroutines可以在这个过程中的任何时刻被中断。由于这些更改交织在一起，goroutines可能会最终覆盖彼此的更改，导致结果不一致。根据时间不同，你的输出可能看起来与前面的结果不同。也根据时间不同，我们可能会看到所有问候都打印到终端，并假设程序正在正确运行，或者我们可能会看到我们在测试运行期间看到的不一致行为。数据竞争是并发世界中的常见问题，它们可能很难找到和复制。
- en: Deadlocks
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死锁
- en: '**Deadlocks** are another common concurrency issue. This issue occurs when
    goroutines are blocked waiting for a resource that never becomes available. The
    goroutines will never be able to proceed. The Go runtime will detect when your
    program becomes blocked and trigger a panic, shutting down and cleaning up resources.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**死锁**是另一个常见的并发问题。当goroutines被阻塞等待永远不会变得可用的资源时，就会发生这个问题。goroutines将永远无法继续。Go运行时会检测到你的程序变得阻塞并触发panic，关闭并清理资源。'
- en: 'To fix our data race from the previous section, we’ll modify the code to make
    use of a channel to allow only one goroutine at a time to append to the greetings
    slice:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复上一节中的数据竞争，我们将修改代码以使用通道，允许一次只有一个goroutine向 `greetings` 切片追加：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At first glance, the example seems reasonable:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个例子似乎是合理的：
- en: 'The `greet` function takes in three parameters: an ID, a channel, and a pointer
    to `WaitGroup`. Inside the function, we read from the channel, append our greeting
    to the `greetings` slice, then write to the channel.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`greet` 函数接受三个参数：一个ID、一个通道以及指向 `WaitGroup` 的指针。在函数内部，我们从通道读取，将我们的问候语追加到 `greetings`
    切片，然后写入通道。'
- en: Inside the `main` function, we initialize the channel and `WaitGroup`. These
    are the synchronization mechanisms that our goroutines will use.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数内部，我们初始化通道和 `WaitGroup`。这些是我们goroutines将使用的同步机制。
- en: We then write a `for` loop, which will start as many goroutines running the
    `greet` function as `workerCount`, which is three.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们编写一个 `for` 循环，该循环将启动与 `workerCount` 相同数量的goroutine运行 `greet` 函数，这里为三个。
- en: After the loop, we send a value to the channel to get the first goroutine started.
    It also signals to the worker goroutines that the main goroutine is ready to process
    their results.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环之后，我们向通道发送一个值以启动第一个goroutine。这也向工作goroutine发出信号，表明主goroutine已准备好处理他们的结果。
- en: 'This seems like a reasonable technical solution that could ensure our data
    races are fixed. Let us run this program in the usual way and see its output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个合理的解决方案，可以确保我们的数据竞争问题得到解决。让我们以通常的方式运行这个程序并查看其输出：
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This program suffers from a deadlock, which is detected by the Go runtime.
    The stack trace indicates that two goroutines are blocked:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序存在死锁，由Go运行时检测到。堆栈跟踪表明有两个goroutine被阻塞：
- en: The main goroutine cannot complete the `Wait` method of `WaitGroup`
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主goroutine无法完成 `WaitGroup` 的 `Wait` 方法
- en: One of the worker goroutines cannot complete its channel send operation
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个工作goroutine无法完成其通道发送操作
- en: This deadlock is caused by the synchronous nature of channel operations. The
    last worker goroutine tries to send to the channel and signal that its work has
    completed, but there is no remaining receiver on the channel. Due to this, the
    worker remains blocked, `WaitGroup` never unblocks, and the whole program freezes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种死锁是由通道操作的同步性质引起的。最后一个工作goroutine试图向通道发送信号并表明其工作已完成，但通道上没有剩余的接收者。因此，工作goroutine保持阻塞状态，`WaitGroup`永远不会解锁，整个程序冻结。
- en: Common causes for goroutines becoming blocked are waiting to complete channel
    operations or waiting for one of the locks in the `sync` package to become available.
    Understanding the behavior of the concurrency mechanisms we are using is the best
    tool for avoiding issues and bugs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: goroutines 变得阻塞的常见原因包括等待完成通道操作或等待 `sync` 包中的某个锁变为可用。理解我们使用的并发机制的行为是避免问题和错误的最有效工具。
- en: Buffered channels
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: By default, channels are **unbuffered**, meaning that they have no capacity
    to store or buffer values. This is why all the channel operations that we have
    seen so far have been **synchronous**. However, this can be limiting for senders
    and receivers that operate at different speeds. A special kind of channel addresses
    this limitation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，通道是**无缓冲的**，这意味着它们没有存储或缓冲值的容量。这就是为什么我们迄今为止看到的所有通道操作都是**同步的**。然而，这可能会限制发送者和接收者，他们的操作速度不同。一种特殊的通道类型解决了这一限制。
- en: 'Buffered channels have the capacity to accept a predefined, limited number
    of values without a receiver. This allows us to process a limited number of `make`
    function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道能够接受预定义的、有限数量的值，而无需接收者。这允许我们处理有限数量的 `make` 函数：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The capacity is an integer, which has a default value of `0` for unbuffered
    channels. This parameter defines the size of the backing array that will save
    the channel’s values.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 容量是一个整数，对于无缓冲通道，其默认值为`0`。此参数定义了将保存通道值的后备数组的尺寸。
- en: '*Figure 9**.7* depicts the send and receive operations on the two types of
    channels:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.7* 展示了两种类型通道上的发送和接收操作：'
- en: '![Figure 9.7 – Send and receive operations on channels ](img/Figure_9.7_B18371.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 通道上的发送和接收操作](img/Figure_9.7_B18371.jpg)'
- en: Figure 9.7 – Send and receive operations on channels
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 通道上的发送和接收操作
- en: 'The timing of operations is the key difference between the channels:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的定时是通道之间的关键区别：
- en: On **unbuffered channels**, both the send and receive operations happen at the
    same time. The channel does not store any values and can only complete the operation
    once both the sender and receiver are available.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**无缓冲通道**上，发送和接收操作同时发生。通道不存储任何值，并且只能在发送者和接收者都可用时完成操作。
- en: On **buffered channels**, the channel has a limited capacity buffer that can
    save values, if it has the capacity to do so. The send and receive operations
    complete at different times, as the channel saves the sender’s value in its buffer.
    Once the receiver is ready, it can read the available value from its buffer and
    pass it on to the receiver.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**缓冲通道**上，通道有一个有限的容量缓冲区，可以保存值，如果它有足够的容量。发送和接收操作在不同的时间完成，因为通道将其发送者的值存储在其缓冲区中。一旦接收者准备好，它可以从其缓冲区中读取可用的值并将其传递给接收者。
- en: When the buffer is at capacity, buffered channels will block send operations,
    behaving like an unbuffered channel until the buffer starts to be emptied by the
    receiver.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当缓冲区达到容量时，缓冲通道将阻塞发送操作，直到缓冲区开始被接收者清空，此时其行为类似于无缓冲通道。
- en: 'We can make use of buffered channels to allow the `greet` workers to complete
    as soon as they write their value, instead of waiting for the main goroutine to
    be available to receive their values:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用缓冲通道允许`greet`工作goroutine在写入其值后立即完成，而不是等待主goroutine可用以接收它们的值：
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This simple example demonstrates the usage of buffered channels:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例演示了缓冲通道的使用：
- en: 'The `greet` function takes in two parameters again: an ID and channel with
    the `string` data type. The buffered channel has the same type as the unbuffered
    channel, so the `greet` function cannot detect whether it is using a buffered
    or unbuffered channel.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`greet`函数再次接受两个参数：一个ID和一个`string`数据类型的通道。缓冲通道与无缓冲通道具有相同的类型，因此`greet`函数无法检测它是否正在使用缓冲通道或无缓冲通道。'
- en: Inside the `greet` function, we format the greeting and send it to the channel.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`greet`函数内部，我们格式化问候语并将其发送到通道。
- en: At the top of the `main` function, we initialize the buffered channel by passing
    `workerCount` as the capacity of the channel. Then, we start the greet function
    in its own goroutine inside the `for` loop, passing the index and the channel
    as the parameters of the function.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数的顶部，我们通过传递`workerCount`作为通道的容量来初始化缓冲通道。然后，我们在`for`循环内部启动`greet`函数的自己的goroutine，并将索引和通道作为函数的参数传递。
- en: Finally, we print and receive two values from the channel and terminate the
    program.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从通道打印并接收两个值，然后终止程序。
- en: 'We run the program in the usual way to see how it behaves:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以通常的方式运行程序，以查看其行为：
- en: '[PRE18]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The program functions as intended: the worker goroutines complete immediately
    and the main goroutine prints two messages to the terminal, then completes successfully.
    However, this program does have an issue. The third greeting of the greeter goroutine
    is successfully sent to the channel but is never received. From the point of view
    of the greeter, its result was correctly sent and processed, when in fact the
    main goroutine never processed it.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 程序按预期运行：工作goroutine立即完成，主goroutine向终端打印两条消息，然后成功完成。然而，这个程序确实有一个问题。问候goroutine的第三次问候成功发送到通道，但从未被接收。从问候者的角度来看，其结果被正确发送和处理，而实际上主goroutine从未处理它。
- en: Since the receiver is only ready twice, our program has a **leaked resource**,
    which is a resource that has not been released correctly. While the Go garbage
    collector will collect unused memory, we should avoid writing this kind of code,
    as it can cause issues and bugs if these operations are performed at scale.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接收者只准备好两次，我们的程序有一个**泄漏的资源**，这是一种未正确释放的资源。虽然Go垃圾收集器会收集未使用的内存，但我们应避免编写此类代码，因为如果这些操作在规模上执行，可能会导致问题和错误。
- en: Buffered channels have a limited capacity to ensure that these types of resource
    leaks are avoided. They are often used to implement the **worker pool concurrency
    pattern**, which is the implementation of a collection of goroutines waiting to
    repeatedly process jobs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道具有有限的容量，以确保避免这类资源泄露。它们通常用于实现**工作池并发模式**，这是等待重复处理作业的一组goroutine的实现。
- en: So far, we have discussed the behavior and issues of concurrency mechanisms
    by studying code examples and reasoning around the problems that we are able to
    reproduce. In the next section, we will discuss how to make use of the Go tools
    to detect concurrency issues in our programs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过研究代码示例和推理我们可以重现的问题的行为和问题，讨论了并发机制的行为和问题。在下一节中，我们将讨论如何利用Go工具检测程序中的并发问题。
- en: The Go race detector
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go竞争检测器
- en: In [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179), *Testing Microservice Architectures*,
    we explored how to use the `pprof` tool to profile the CPU and memory usage of
    Go applications. One of the essential tools that can help us find issues with
    concurrency is the Go race detector. It is a powerful tool that analyzes our code
    to find concurrency problems when an application is running.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B18371_08.xhtml#_idTextAnchor179)《测试微服务架构》中，我们探讨了如何使用`pprof`工具来分析Go应用程序的CPU和内存使用情况。可以帮助我们找到并发问题的基本工具之一是Go竞争检测器。这是一个强大的工具，它分析我们的代码，以在应用程序运行时找到并发问题。
- en: Go’s race detector was added to the toolchain in Go 1.1, released in 2012\.
    This tool was designed to help developers find race conditions in their code.
    As we have seen in the previous examples, writing concurrent code in Go is easy,
    but bugs can appear in even the most readable and well-designed code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Go的竞争检测器是在2012年发布的Go 1.1版本中添加到工具链中的。这个工具旨在帮助开发者找到他们代码中的竞争条件。正如我们之前在示例中看到的，在Go中编写并发代码很容易，但即使在最可读和设计良好的代码中也可能出现错误。
- en: 'The race detector is enabled using the `–race` command-line flag, alongside
    the `go` command. For example, we can instruct it to run alongside our program:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`–race`命令行标志可以启用竞争检测器，与`go`命令一起使用。例如，我们可以指示它与我们的程序一起运行：
- en: '[PRE19]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The race detector can be used with other commands as well, including the `build`
    and `test` commands. This makes it easy to use the detector to find data races
    in your application at any stage in the development process.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争检测器也可以与其他命令一起使用，包括`build`和`test`命令。这使得在开发过程的任何阶段使用检测器来查找应用程序中的数据竞争变得容易。
- en: Once the detector is enabled, the compiler records memory access and the Go
    runtime analyzes these records for data races. As we know, data races are typically
    caused by multiple goroutines accessing and modifying one shared resource without
    making use of synchronization mechanisms.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用检测器，编译器就会记录内存访问，Go运行时会分析这些记录以查找数据竞争。正如我们所知，数据竞争通常是由多个goroutine在没有使用同步机制的情况下访问和修改一个共享资源所引起的。
- en: 'When a data race occurs, the detector will print a report with details of the
    problem, pinpointing the problem and guiding an observant developer toward the
    fix for the detected issue. Let us try it out with our data race example from
    the previous section:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生数据竞争时，检测器将打印出有关问题的详细报告，指明问题，并指导一个警觉的开发者找到检测到的问题的修复方法。让我们用上一节中的数据竞争示例来试一试：
- en: '[PRE20]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As expected, the race detector finds some issues with our data race example.
    The output points out the problem:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，竞争检测器在我们的数据竞争示例中发现了某些问题。输出指出了问题：
- en: The first data race is detected in the `greet` function at `main.go:15`. One
    goroutine reads a variable, while another goroutine writes to it.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个数据竞争发生在`main.go:15`的`greet`函数中。一个goroutine正在读取一个变量，而另一个goroutine正在写入它。
- en: The second data race is happening as the slice grows during append, which is
    indicated by the call to `runtime.growslice()`. This function copies the slice
    and handles the allocation of a larger backing array, if it is required. The modifications
    to this slice are also happening in an interleaving manner, with reads and writes
    happening in different goroutines.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当切片在追加过程中增长时，第二个数据竞争正在发生，这由对`runtime.growslice()`的调用指示。如果需要，此函数会复制切片并处理分配更大的后端数组。对这个切片的修改也是以交错的方式发生的，不同的goroutine中发生读取和写入。
- en: Finally, the output of the program is printed and the race detector summarizes
    that two data races have been found.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打印出程序的输出，竞争检测器总结说发现了两个数据竞争。
- en: 'As we already suspected, the concurrent changes made to the shared slice without
    synchronization mechanisms have caused a data race. The code block identified
    by the race detector is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所怀疑的，在未使用同步机制的情况下对共享切片进行的并发更改导致了数据竞争。由竞争检测器识别的代码块如下：
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The line highlighted by the detector is the read and write to the greetings
    slice during the append function. As we discussed in previous sections, the append
    function consists of multiple operations, which can cause data races if they are
    interleaving across multiple goroutines.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 检测器高亮显示的行是在 append 函数期间对问候切片的读取和写入。正如我们在前面的章节中讨论的，append 函数由多个操作组成，如果它们在多个 goroutines
    之间交错，可能会导致数据竞争。
- en: Due to the instrumentation that the race detector requires, it is only able
    to find data races as they are triggered. Therefore, our application should be
    subjected to realistic workloads and user journeys in order to detect issues.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于竞态检测器所需的仪器，它只能找到在触发时发生的数据竞争。因此，我们的应用程序应该接受现实工作负载和用户旅程，以便检测问题。
- en: According to the official Go documentation ([https://go.dev/blog/race-detector](https://go.dev/blog/race-detector)),
    race-enabled applications use 10 times the CPU and memory, so we should avoid
    running them in production. Instead, we should run our load tests and integration
    tests with the race detector enabled, since these tests usually exercise the most
    important parts of the program.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方 Go 文档（[https://go.dev/blog/race-detector](https://go.dev/blog/race-detector)），启用竞态检测的应用程序使用的
    CPU 和内存是未启用时的 10 倍，因此我们应该避免在生产环境中运行它们。相反，我们应该在启用竞态检测的情况下运行我们的负载测试和集成测试，因为这些测试通常涉及程序最重要的部分。
- en: Limitations of the race detector
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态检测器的局限性
- en: While the race detector is a very useful tool, we should remember that it can
    only check for race conditions. While it does not flag any false positives, the
    code can contain other concurrency issues. We should bear in mind that the race
    detector is simply an indicator.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然竞态检测器是一个非常有用的工具，但我们应记住它只能检查竞态条件。虽然它不会标记任何假阳性，但代码可能包含其他并发问题。我们应该记住，竞态检测器只是一个指示器。
- en: Untestable conditions
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无法测试的条件
- en: While the Go race detector is a useful tool, concurrency testing is difficult
    to perform and prove to be correct. The race detector only focuses on finding
    data races, but we have already seen that there are other concurrency issues in
    the previous section, *Issues with concurrency*, where we explored deadlocks and
    leaked resources.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Go 竞态检测器是一个有用的工具，但并发测试很难进行，并且证明是正确的。竞态检测器只关注查找数据竞争，但我们已经在前一节中看到，存在其他并发问题，例如
    *并发问题*，我们探讨了死锁和泄漏的资源。
- en: 'Due to the dependency on timing, there are four essentially untestable concurrency
    problems:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对时间的依赖，有四个基本上无法测试的并发问题：
- en: '**Race conditions**: Unstable or inconsistent behavior due to multiple goroutines
    that read and modify a shared resource without the correct usage of synchronization
    mechanisms. For example, goroutines reading and incrementing a common counter.'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**竞态条件**：由于多个 goroutines 在没有正确使用同步机制的情况下读取和修改共享资源，导致不稳定或不一致的行为。例如，goroutines
    读取和增加一个公共计数器。'
- en: '**Deadlocks**: Goroutines becoming blocked waiting for resources that never
    become available, either because they never reach the required state or because
    another goroutine has locked the resources and never released them. For example,
    a goroutine is waiting to receive from a nil channel, which never becomes initialized.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**死锁**：Goroutines 由于等待永远不会变得可用的资源而变得阻塞，这可能是因为它们从未达到所需状态，或者因为另一个 goroutine 锁定了资源而从未释放。例如，一个
    goroutine 正在等待从 nil 通道接收，而这个通道永远不会被初始化。'
- en: '**Livelocks**: Similar to deadlocks, goroutines become livelocked when they
    continue to attempt to acquire resources that never become available, either because
    they never reach the required state or because another resource has locked the
    resources and never released them. In this case, goroutines will waste CPU continuing
    to retry impossible operations. For example, a goroutine periodically polls to
    write to a variable that has been locked by another goroutine, which is waiting
    for a resource that the first goroutine has locked and never received.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**活锁**：与死锁类似，当 goroutines 继续尝试获取永远不会变得可用的资源时，它们会变得活锁，这可能是因为它们从未达到所需状态，或者因为另一个资源锁定了资源而从未释放。在这种情况下，goroutines
    将浪费 CPU 继续重试不可能的操作。例如，一个 goroutine 定期轮询写入一个被另一个 goroutine 锁定的变量，而这个变量正在等待第一个 goroutine
    锁定并从未接收到的资源。'
- en: '**Starvation**: Similar to livelocks, goroutines cannot get all the resources
    needed to continue processing. One or more goroutines are prevented from doing
    meaningful work by greedy goroutines that do not release resources. For example,
    a goroutine locks a resource and then proceeds to execute a very long-running
    operation, preventing other goroutines from gaining access to the resource in
    the meantime.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**饥饿**：与活锁类似，goroutine无法获取继续处理所需的所有资源。由于贪婪的goroutine没有释放资源，一个或多个goroutine被阻止执行有意义的工作。例如，一个goroutine锁定了一个资源，然后继续执行一个非常长时间的操作，阻止其他goroutine在同时获取对资源的访问。'
- en: '*Figure 9**.8* depicts a common scenario of where deadlocks commonly occur:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9.8* 展示了死锁通常发生的一个常见场景：'
- en: '![Figure 9.8 – A common deadlock problem ](img/Figure_9.8_B18371.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 常见的死锁问题](img/Figure_9.8_B18371.jpg)'
- en: Figure 9.8 – A common deadlock problem
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 常见的死锁问题
- en: In this scenario, both goroutines need two resources to complete their work.
    Each of the goroutines is holding onto a resource while it is waiting for the
    second resource. Neither goroutine can complete its work and a deadlock occurs.
    This same scenario can also lead to a livelock, if each goroutine is polling to
    check the state of a resource or another goroutine. In this case, each goroutine
    is using CPU cycles but never finishes executing.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，两个goroutine需要两个资源来完成它们的工作。每个goroutine在等待第二个资源的同时都持有着一个资源。没有任何一个goroutine能够完成其工作，从而发生死锁。如果每个goroutine都在轮询检查资源或另一个goroutine的状态，这种相同的场景也可能导致活锁。在这种情况下，每个goroutine都在使用CPU周期，但永远不会完成执行。
- en: These four untestable conditions are actually a result of **poorly designed
    code** or a **faulty understanding of the behavior of concurrency mechanisms**.
    This is the main reason that we have started this chapter by thoroughly discussing
    and exploring the fundamentals and behavior of Go’s concurrency mechanisms. These
    conditions can be detected by using good linters and a code review, but the best
    defense is to be aware of the problems when you are writing your code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个不可测试的条件实际上是**设计不良的代码**或**对并发机制行为的错误理解**的结果。这是我们开始本章时详细讨论和探索Go并发机制的基本原理和行为的主要原因。这些条件可以通过使用良好的linters和代码审查来检测，但最好的防御措施是在编写代码时意识到这些问题。
- en: '*Figure 9**.9* presents a summary of three rules of thumb when it comes to
    using concurrency:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9.9* 总结了使用并发时的三条经验法则：'
- en: '![Figure 9.9 – Concurrency rules of thumb ](img/Figure_9.9_B18371.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 并发经验法则](img/Figure_9.9_B18371.jpg)'
- en: Figure 9.9 – Concurrency rules of thumb
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 并发经验法则
- en: 'These three rules of thumb will help you minimize the difficult-to-detect concurrency
    issues we have discussed so far:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这三条经验法则将帮助您最小化我们迄今为止讨论的难以检测的并发问题：
- en: '**Share values with channels**: As discussed previously, we should avoid sharing
    results using variables and pointers. Even when correctly protected by locks,
    channels are much more efficient and can simplify your code.'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过通道共享值**：如前所述，我们应该避免使用变量和指针来共享结果。即使通过锁正确保护，通道也更为高效，并且可以简化您的代码。'
- en: '`defer` keyword as soon as you acquire it. This will ensure that your function
    releases the lock, regardless of the completion logic branch or any potential
    errors. You should also consider whether you need a read-write lock, or whether
    you can avoid starvation by acquiring read mutexes, where possible.'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦获取，就立即使用`defer`关键字。这将确保您的函数释放锁，无论完成逻辑分支或任何潜在的错误。您还应该考虑是否需要读写锁，或者是否可以通过获取读互斥锁来避免饥饿，如果可能的话。
- en: '**Wait for all children to complete**: As we have discussed, goroutines have
    a parent-child relationship with the goroutines they create. You should make use
    of synchronization mechanisms to ensure that the parent goroutine waits for all
    the goroutines it has created before shutting down to ensure that operations are
    completed correctly and resources are cleaned up correctly.'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等待所有子goroutine完成**：正如我们讨论的那样，goroutine与其创建的goroutine之间存在父子关系。您应该利用同步机制来确保在关闭之前，父goroutine等待它创建的所有goroutine，以确保操作正确完成并且资源得到正确清理。'
- en: Testing alone **cannot prove the absence** of the four untestable conditions,
    but it can give us statistical confidence that these errors will not occur in
    production, for the scenarios that are important to our systems. Therefore, writing
    tests that cover the concurrent parts of our code is an important part of our
    testing strategy.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的测试**不能证明**四个不可测试条件的不存在，但它可以给我们带来统计上的信心，即这些错误不会在我们的系统重要的场景中发生。因此，编写覆盖我们代码并发部分的测试是我们测试策略的重要组成部分。
- en: In the next section, we will look at how we can make use of the race detector
    to test the `BookSwap` application under concurrent conditions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何利用竞争检测器在并发条件下测试`BookSwap`应用程序。
- en: Use case – testing concurrency in the BookSwap application
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 测试BookSwap应用程序的并发性
- en: The last section of this chapter is dedicated to the detection of concurrency
    issues in the `BookSwap` web application. We will make use of Go’s race detector,
    alongside the testing strategies we have learned so far, to see what issues we
    can discover in the `BookSwap` application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分致力于检测`BookSwap`网络应用程序中的并发问题。我们将利用Go的竞争检测器，以及我们迄今为止学到的测试策略，来查看我们可以在`BookSwap`应用程序中发现哪些问题。
- en: You might be wondering why we would worry about the concurrency aspects of the
    `BookSwap` application, since we have not used any locks, channels, or goroutines
    in the code base we have seen so far. Go’s `net/http` library uses goroutines
    under the hood to serve HTTP requests, so the application can still have concurrency
    issues, even though it does not explicitly create its own goroutines and channels.
    This effect will be further amplified once the `BookSwap` application gets converted
    from a monolithic application to running in the microservice architecture we discussed
    in [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179), *Testing* *Microservice Architectures*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们会担心`BookSwap`应用程序的并发方面，因为我们迄今为止在代码库中没有使用任何锁、通道或goroutine。Go的`net/http`库在底层使用goroutine来处理HTTP请求，所以即使应用程序没有显式创建自己的goroutine和通道，它仍然可能存在并发问题。一旦`BookSwap`应用程序从单体应用转换为我们在[*第8章*](B18371_08.xhtml#_idTextAnchor179)中讨论的运行在微服务架构中，这种效果将会进一步放大。
- en: 'We already have all the tools available for writing tests that can simulate
    and verify the concurrent behavior of our application. We will write a test that
    creates `BookSwap` users concurrently:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了编写可以模拟和验证我们应用程序并发行为的测试所需的全部工具。我们将编写一个并发创建`BookSwap`用户的测试：
- en: '[PRE22]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This benchmark test sends requests concurrently to the `POST /users` endpoint
    of the `BookSwap` application:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基准测试并发地向`BookSwap`应用的`POST /users`端点发送请求：
- en: We declare a new test with the usual signature, which takes in a single `*testing.T`
    parameter.This test will run only when the `LONG` argument is passed to the test
    runner, as it required the `BookSwap` application to be up. The `userEndpoint`
    is returned by the `getTestEndpoint` helper function based on environment variables.
    For brevity, we have not included the implementation of this function here.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用通常的签名声明一个新的测试，它接受一个`*testing.T`参数。这个测试只有在将`LONG`参数传递给测试运行器时才会运行，因为它需要`BookSwap`应用程序处于运行状态。`userEndpoint`是由`getTestEndpoint`辅助函数根据环境变量返回的。为了简洁，我们没有在这里包含这个函数的实现。
- en: In the setup of the test, we marshal a map with the string key and value type,
    which contains all the JSON fields that we require to create a new user. We use
    the `json.Marshal` function in the standard library to do this. This function
    will return a slice of bytes, `[]byte`, which we will use as the request body
    for our HTTP POST calls.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试设置中，我们使用字符串键和值类型的map，其中包含我们创建新用户所需的全部JSON字段。我们使用标准库中的`json.Marshal`函数来完成这项工作。这个函数将返回一个字节数组`[]byte`，我们将将其用作HTTP
    POST调用的请求体。
- en: We repeat the same test in a `for` loop up to a `LOAD_AMOUNT` constant. The
    test runner will run the test in parallel according to the configuration that
    it has available. It’s important to include this `for` loop; otherwise, our goroutine
    will only make a single call.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`for`循环重复相同的测试，直到达到`LOAD_AMOUNT`常量。测试运行器将根据其可用的配置并行运行测试。包含这个`for`循环是很重要的；否则，我们的goroutine只会进行单个调用。
- en: We set up the test to run in parallel using the `t.Parallel` method. Under the
    hood, this creates multiple goroutines and distributes the test iterations across
    them. This method takes in a function as a parameter, which will set up any local
    state and be run in each of the goroutines of the test.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`t.Parallel`方法设置测试并行运行。在底层，这会创建多个goroutines并将测试迭代分配给它们。此方法接受一个函数作为参数，该函数将设置任何局部状态并在测试的每个goroutine中运行。
- en: In the loop, we convert the JSON byte slice into a buffer, which is required
    for the invocation of the `http.Post` function. This function takes in `usersEndpoint`,
    which will contain the URL to test against.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中，我们将JSON字节切片转换为缓冲区，这是调用`http.Post`函数所必需的。此函数接受`usersEndpoint`，它将包含要测试的URL。
- en: Once the HTTP request completes, it will return a response, against which we
    can make our assertions. We ensure that we close the body of the response in order
    to allow the same connection to be reused by another goroutine.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦HTTP请求完成，它将返回一个响应，我们可以对此做出断言。我们确保关闭响应的主体，以便允许同一连接被另一个goroutine重用。
- en: The simple configuration of the test will allow us to test our endpoint using
    a fixed number of concurrent requests. As we have seen in previous chapters, this
    function constructs the URL based on the environment variables specified for the
    application. If you want to run with the default values, set the `BOOKSWAP_BASE_URL`
    environment variable to http://localhost and the `BOOKSWAP_PORT` environment variable
    to `3000` to your terminal session.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的简单配置将允许我们使用固定数量的并发请求来测试我们的端点。正如我们在前面的章节中看到的，此函数根据为应用程序指定的环境变量构建URL。如果您想使用默认值运行，请将`BOOKSWAP_BASE_URL`环境变量设置为http://localhost，并将`BOOKSWAP_PORT`环境变量设置为`3000`到您的终端会话中。
- en: 'By default, the number of goroutines that will be used by the benchmark is
    equal to the `GOMAXPROCS` variable. This variable will be equal to the number
    of CPUs on the machine it is running. Your OS decides what counts as a CPU, so
    for a four-core machine with hyperthreading, `GOMAXPROCS` will be `8`. If you
    would like to adjust the number of goroutines, you can easily configure this by
    changing this environment variable. Just as we have done with the `pprof` tool
    in [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179), *Testing Microservice Architectures*,
    we run the `BookSwap` application with the race detector enabled:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，基准测试将使用的goroutine数量等于`GOMAXPROCS`变量。此变量将等于运行它的机器上的CPU数量。您的操作系统决定什么算作CPU，因此对于具有超线程的四核机器，`GOMAXPROCS`将是`8`。如果您想调整goroutine的数量，可以很容易地通过更改此环境变量来配置它。就像我们在[*第8章*](B18371_08.xhtml#_idTextAnchor179)中用`pprof`工具所做的那样，*测试微服务架构*，我们运行带有启用竞争检测器的`BookSwap`应用程序：
- en: '[PRE23]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The modification of resources and goroutines is happening in the `BookSwap`
    application itself, not the test code, so this is why we instrument the application
    and not the test code. Remember that the `BookSwap` application relies on a database
    now, we need to have PostgreSQL running and set the `BOOKSWAP_DB_URL` environment
    variable to the PostgreSQL connection string.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 资源和goroutines的修改发生在`BookSwap`应用程序本身，而不是测试代码中，这就是为什么我们测量应用程序而不是测试代码。记住，`BookSwap`应用程序现在依赖于数据库，我们需要运行PostgreSQL并设置`BOOKSWAP_DB_URL`环境变量为PostgreSQL连接字符串。
- en: 'In a separate terminal window, we run the benchmark in the usual way, as running
    the benchmark in parallel is not visible outside the test configuration:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，我们以通常的方式运行基准测试，因为并行运行基准测试在测试配置之外是不可见的：
- en: '[PRE24]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can then issue a `SIGINT` with *Ctrl* + *C* in the first console window in
    order to halt the race detector. If any data races are detected, they will be
    printed to the terminal, alongside the logs of `BookSwap`. Since the race detector
    is running separately from the test code, we cannot fail the test when data races
    are detected. We must therefore monitor the logs to see whether data races have
    been detected.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在第一个控制台中通过按下*Ctrl* + *C*发出`SIGINT`以停止竞争检测器。如果检测到数据竞争，它们将打印到终端，并伴随`BookSwap`的日志。由于竞争检测器是在测试代码之外运行的，因此检测到数据竞争时我们不能使测试失败。因此，我们必须监控日志以查看是否检测到数据竞争。
- en: This simple technique can be used for end-to-end testing and integration testing
    of our application. You can use it to implement any user journey or sequence of
    requests. However, we should always bear in mind that the race detector is a limited
    tool and that no amount of testing can definitively and conclusively prove the
    absence of untestable concurrency issues.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的技术可以用于我们应用程序的端到端测试和集成测试。你可以用它来实现任何用户旅程或请求序列。然而，我们应该始终牢记，竞争检测器是一个有限的工具，没有任何数量的测试可以最终和明确地证明不存在不可测试的并发问题。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the important and uniquely challenging topic of
    concurrency. As a good understanding of concurrency mechanisms is important to
    avoid issues, we started by learning the fundamentals of two of Go’s most central
    concurrency mechanisms, goroutines and channels. Then, we looked at three applied
    concurrency examples, which helped us further explore their behavior.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了重要且具有独特挑战性的并发主题。由于对并发机制的良好理解对于避免问题至关重要，所以我们首先学习了Go最核心的两个并发机制——goroutines和channels的基础知识。然后，我们研究了三个应用并发示例，这有助于我们进一步探索它们的行为。
- en: Once we were familiar with how concurrency works, we started looking at some
    commonly occurring issues with concurrency. The Go race detector is a tool that
    can help us detect data races and provide pinpoint guidance to engineers to help
    them to resolve the issue. However, due to the importance of timing, it is not
    possible to conclusively prove the absence of concurrency issues, so careful design
    is always the first defense. Finally, we looked at an applied example of how to
    use benchmarks to make concurrent calls to the `BookSwap` application and detect
    issues with Go’s race detector.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们熟悉了并发的工作方式，我们就开始研究一些常见的并发问题。Go竞争检测器是一个可以帮助我们检测数据竞争并提供精确指导以帮助工程师解决问题的工具。然而，由于时间的重要性，无法最终证明不存在并发问题，因此谨慎设计始终是第一道防线。最后，我们查看了一个应用示例，展示了如何使用基准测试对`BookSwap`应用程序进行并发调用并检测Go竞争检测器的问题。
- en: In [*Chapter 10*](B18371_10.xhtml#_idTextAnchor218), *Testing Edge Cases*, we
    will explore how to extend tests and ensure that our code is robust with Go’s
    fuzzing capability.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B18371_10.xhtml#_idTextAnchor218)，“测试边缘情况”，我们将探讨如何扩展测试并确保我们的代码通过Go的模糊测试能力变得健壮。
- en: Questions
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between concurrency and parallelism?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发和并行之间的区别是什么？
- en: What operations do unbuffered channels support and how do they behave?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无缓冲通道支持哪些操作？它们是如何表现的？
- en: What is the difference between `sync.Mutex` and `sync.WaitGroup`?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sync.Mutex`和`sync.WaitGroup`之间的区别是什么？'
- en: What is a data race? What is a deadlock?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是数据竞争？什么是死锁？
- en: How do you use Go’s race detector?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用Go的竞争检测器？
- en: Further reading
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Concurrency in Go: Tools and Techniques for Developers*, by Katherine Cox-Buday,
    published by O’Reilly'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Go中的并发：开发者的工具和技术》，作者凯瑟琳·考克斯-布达伊，由O’Reilly出版
- en: '*Network Programming with Go: Learn to Code Secure and Reliable Network Services
    from Scratch*, by Adam Woodbeck, published by No Starch Press'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《用Go进行网络编程：从零开始学习编写安全可靠的网络服务》，作者亚当·伍德贝克，由No Starch Press出版
- en: '*Introduction to Concurrency in Programming Languages*, by Matthew J. Sottile
    et al., published by Chapman & Hall'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《编程语言中的并发简介》，作者马修·J.索蒂尔等人，由Chapman & Hall出版
