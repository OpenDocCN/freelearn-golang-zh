- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Testing Edge Cases
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试边缘情况
- en: In the previous chapters, we discussed the implementation and testing of web
    applications. We made use of a variety of functional and non-functional tests
    to ensure that the individual services within our microservice architectures remained
    performant and delivered the correct functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了Web应用程序的实现和测试。我们使用了各种功能性和非功能性测试来确保我们微服务架构中的各个服务保持性能并正确交付功能。
- en: In [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085), *Building Efficient Test
    Suites*, we discussed the definitions of edge and corner cases, as well as learning
    how to implement them using table-driven testing. For production systems, it would
    be nearly impossible to fully test complex systems, no matter how dedicated we
    might be to implementing tests across a variety of scenarios. Therefore, testing
    strategies should be designed with system requirements and user journeys in mind.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章[*“构建高效的测试套件”*](B18371_04.xhtml#_idTextAnchor085)中，我们讨论了边缘情况和边界情况的定义，以及如何使用表格驱动测试来实现它们。对于生产系统，无论我们多么致力于在各种场景中实施测试，全面测试复杂的系统几乎是不可能的。因此，测试策略应该考虑到系统需求和用户旅程。
- en: However, no matter how carefully we design and implement them, testing strategies
    also have their limitations. As discussed in [*Chapter 9*](B18371_09.xhtml#_idTextAnchor197),
    *Challenges of Testing Concurrent Code*, testing cannot prove the absence of concurrency
    bugs but does give us statistical confidence that these errors will not happen
    under the scenarios covered by our testing strategy. We also discussed how concurrency
    issues are not implementation bugs and are in fact system design faults, so a
    thorough understanding of Go’s concurrency mechanisms is important in order to
    avoid such errors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论我们设计实施多么谨慎，测试策略也有其局限性。正如在第9章[*“并发代码的挑战”*](B18371_09.xhtml#_idTextAnchor197)中讨论的那样，测试不能证明并发错误的缺失，但确实给我们带来了统计上的信心，即这些错误不会在我们测试策略覆盖的场景下发生。我们还讨论了并发问题不是实现错误，而是系统设计故障，因此，为了避免此类错误，对Go的并发机制有深入理解非常重要。
- en: This chapter will explore the previously discussed topic of edge cases through
    a new lens. We will begin with an introduction to the concept of code robustness,
    which will allow us to write implementation code that is stable for a wide variety
    of inputs. Then, we will learn how to use Go’s newly introduced fuzz testing capability
    to write tests that cover a wide variety of inputs. Finally, we will explore property-based
    testing, which allows us to write assertions for the output properties that really
    matter to us, as opposed to exact value matches. This is a different approach
    to test writing than we have seen so far and can make writing tests for edge cases
    much simpler.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过一个新的视角来探讨之前讨论过的边缘情况主题。我们将从代码鲁棒性的概念介绍开始，这将使我们能够编写适用于广泛输入的稳定实现代码。然后，我们将学习如何使用Go新引入的模糊测试能力来编写覆盖广泛输入的测试。最后，我们将探索基于属性的测试，它允许我们为真正对我们重要的输出属性编写断言，而不是精确值匹配。这与我们迄今为止看到的测试编写方法不同，可以使编写边缘情况的测试变得更加简单。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Definition and best practices for achieving code robustness
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现代码鲁棒性的定义和最佳实践
- en: Go’s newly introduced fuzzing capability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go新引入的模糊测试能力
- en: The concept of property-based testing and how we can implement it in Go
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于属性的测试概念及其在Go中的实现
- en: How to use fuzzing and property-based testing in the `BookSwap` application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在`BookSwap`应用程序中使用模糊测试和基于属性的测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described in the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装**Go版本1.19**或更高版本才能运行本章中的代码示例。安装过程在官方Go文档[https://go.dev/doc/install](https://go.dev/doc/install)中有描述。
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter10](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter10).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含的代码示例在[https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter10](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter10)上公开可用。
- en: Code robustness
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码鲁棒性
- en: 'In [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085), *Building Efficient Test
    Suites*, we discussed the types of variable values that our testing strategies
    should cover. Among these values, we identified three types of test cases covering
    our parameters:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 4 章*](B18371_04.xhtml#_idTextAnchor085) *构建高效的测试套件*中，我们讨论了我们的测试策略应该覆盖的变量值类型。在这些值中，我们确定了三种类型的测试用例来覆盖我们的参数：
- en: Base cases
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本情况
- en: Edge cases
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘情况
- en: Boundary cases
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界情况
- en: We further identified corner cases that occur when multiple input variables
    are supplied with edge case values. We should write test cases that cover a broad
    range of values for the inputs supplied to our functions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进一步确定了当多个输入变量以边缘值提供时发生的边界情况。我们应该编写覆盖我们函数提供的输入值的广泛范围的测试用例。
- en: In the world of microservice architectures, we often don’t have control over
    which values are supplied to our services and functions, so the code we write
    should be stable under a variety of scenarios. In order to achieve this stability,
    we should implement a well-designed, well-tested robust code base.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构的世界里，我们往往无法控制提供给我们的服务和函数的值，因此我们编写的代码应该在各种情况下保持稳定。为了实现这种稳定性，我们应该实现一个设计良好、经过充分测试的稳健代码库。
- en: '**Code robustness** is an often overlooked quality that can help us achieve
    code that will remain stable even as it changes and goes through refactoring cycles.
    *Figure 10**.1* presents the main characteristics of robust code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码稳健性**是一个经常被忽视的质量，它可以帮助我们编写即使经过变化和重构周期也能保持稳定的代码。*图 10*.1 展示了稳健代码的主要特性：'
- en: '![Figure 10.1 – Characteristics of robust code ](img/Figure_10.1_B18371.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 稳健代码的特性](img/Figure_10.1_B18371.jpg)'
- en: Figure 10.1 – Characteristics of robust code
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 稳健代码的特性
- en: 'In a nutshell, robust code is easy for developers to work on due to the following
    characteristics:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，稳健代码由于以下特性而易于开发者工作：
- en: '**Easy to change**: Robust code is able to handle a wide variety of external
    factors, making it easier to refactor and change its dependencies. We will see
    that the other characteristics will contribute to making robust code easy to change.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于更改**：稳健代码能够处理各种外部因素，使其更容易重构和更改其依赖项。我们将看到其他特性将有助于使稳健代码易于更改。'
- en: '**Minimal assumptions**: Robust code makes minimal assumptions for the values
    of input parameters and resources that it has available. It should check any value
    that it does not generate internally to ensure that it is as expected.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小假设**：稳健代码对其可用的输入参数和资源的值做出最小假设。它应该检查它没有内部生成的任何值，以确保它符合预期。'
- en: '**Good error handling**: Robust code implements good error handling by checking
    for errors from external functions, gracefully ending current operations in the
    case of an error, and providing meaningful error messages to be returned to callers.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**良好的错误处理**：稳健代码通过检查外部函数的错误，在出现错误时优雅地结束当前操作，并向调用者提供有意义的错误信息来实现良好的错误处理。'
- en: '**Provides a clear API**: Robust code provides an easy-to-read and comprehensible
    API for external callers. It should make it clear what parameter types it expects
    and what possible errors it can return. While documentation is a useful supplement,
    we should not rely on it. Robust code should use custom types and interfaces to
    leverage compiler checks and type safety as much as possible.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供清晰的 API**：稳健代码为外部调用者提供了一个易于阅读和理解的 API。它应该清楚地说明它期望的参数类型和可能返回的错误。虽然文档是一个有用的补充，但我们不应依赖它。稳健代码应尽可能使用自定义类型和接口来利用编译器检查和类型安全。'
- en: '**Easy to test**: Due to the characteristics we have already explored, robust
    code is easy to test. A clear API makes it easy for us to design our test cases,
    mock any dependencies required, or formulate any contracts for the implementation
    of contract testing. Good error handling, which returns well-formulated errors,
    allows us to write concise assertions that verify returned error messages.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于测试**：由于我们已经探讨的特性，稳健代码易于测试。清晰的 API 使我们能够轻松设计测试用例，模拟所需的任何依赖项，或为合同测试的实施制定任何合同。良好的错误处理，返回良好构建的错误，使我们能够编写简洁的断言来验证返回的错误信息。'
- en: '`go vet` command in the official documentation – [https://pkg.go.dev/cmd/vet](https://pkg.go.dev/cmd/vet).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档中的`go vet`命令 – [https://pkg.go.dev/cmd/vet](https://pkg.go.dev/cmd/vet)。
- en: '**Easy to read**: Robust code that uses a consistent style, handles errors,
    and provides good APIs reduces the cognitive load that developers will require
    to understand its behavior. This makes it easier to read and search through.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于阅读**：使用一致风格、处理错误和提供良好API的健壮代码可以减少开发者理解其行为所需的认知负荷。这使得阅读和搜索变得更加容易。'
- en: '**Good naming/comments**: Documentation is another important but often overlooked
    aspect of writing code. Variable naming should be short, but representative of
    the functionality it provides. Functions and types should have accompanying documentation
    that clearly states their expected behavior and the functionality it provides.
    You can read more about how to write Go comments on the official blog – [https://tip.golang.org/doc/comment](https://tip.golang.org/doc/comment).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**良好的命名/注释**：文档是编写代码的一个重要但经常被忽视的方面。变量命名应该简短，但能代表其提供的功能。函数和类型应该有伴随的文档，清楚地说明它们的预期行为和提供的功能。您可以在官方博客上了解更多关于如何编写Go注释的信息
    - [https://tip.golang.org/doc/comment](https://tip.golang.org/doc/comment)。'
- en: 'Designing code with robustness in mind will help us create stable systems and
    microservice architectures. One of the common ways that developers implement systems
    is by emulating the principles of the **Unix philosophy**, which has been established
    by its creators and the community. It states that robustness results from transparency
    and simplicity, which are principles that relate well to Go software development.
    Looking at these principles, we can see that they are reflected in the characteristics
    we have examined in *Figure 10**.1*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以健壮性为设计目标将帮助我们创建稳定的系统和微服务架构。开发者实现系统的一种常见方式是通过模拟**Unix哲学**的原则，这是由其创造者和社区确立的。它指出，健壮性源于透明性和简单性，这些原则与Go软件开发密切相关。通过查看这些原则，我们可以看到它们在我们考察的*图10.1*中反映出来：
- en: Transparent code is easy to read and understand. Readability is aided by consistent
    styling, good naming/comments, and clear API definitions.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明代码易于阅读和理解。一致性风格、良好的命名/注释和清晰的API定义有助于提高可读性。
- en: Simple code is also easy to understand, but it is also uncomplicated and provides
    well-defined functionality that can be easily reused. This provides our systems
    with modularity, which allows us to reuse them to solve a wide variety of problems
    and situations. However, it should also be able to gracefully handle error cases
    or situations that it was not designed to accommodate.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的代码也容易理解，但它也很简单，提供了易于重用的明确功能。这为我们提供了模块化，使我们能够重用它们来解决各种问题和情况。然而，它也应该能够优雅地处理错误情况或它未设计来适应的情况。
- en: Just like Linux, open source software and libraries are generally seen as more
    robust than their proprietary counterparts, as they have a wider audience that
    can find and correct errors. This is one of the reasons that we have only explored
    open source libraries and tools throughout our entire exploration of TDD.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Linux一样，开源软件和库通常被认为比它们的专有版本更健壮，因为它们有更广泛的受众可以找到并纠正错误。这是我们为什么在整个TDD探索过程中只探索开源库和工具的一个原因。
- en: The opposite of robust code is fragile and error-prone code. This type of code
    is complicated to understand and can be difficult to refactor, even when using
    the strategies we explored in [*Chapter 7*](B18371_07.xhtml#_idTextAnchor162),
    *Refactoring in Go*. Often, code refactoring involves making code changes to add
    robustness to code using some of the best practices we will explore in the next
    section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与健壮代码相反的是脆弱且易出错的代码。这种类型的代码难以理解，即使使用我们在[*第7章*](B18371_07.xhtml#_idTextAnchor162)中探索的策略，也很难重构。通常，代码重构涉及对代码进行更改以增加健壮性，使用我们在下一节中将要探索的一些最佳实践。
- en: Best practices
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Now that we have a good grasp of the characteristics of robust code, we can
    begin to look at some best practices for implementing it in Go. We can begin our
    exploration by looking at a simple example of a fragile piece of code and exploring
    what we can do to make it more robust.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地掌握了健壮代码的特点，我们可以开始探讨在Go中实现它的最佳实践。我们可以通过查看一个简单的脆弱代码示例并探索我们可以做些什么来使其更加健壮来开始我们的探索。
- en: 'We will write a function that returns the values contained inside a Go map
    in key-sorted order. To achieve this, our function will do the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个函数，该函数以键排序顺序返回Go映射中包含的值。为了实现这一点，我们的函数将执行以下操作：
- en: Extract the keys contained inside the map.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从映射中提取包含的键。
- en: Sort the keys according to a given order parameter.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据给定的顺序参数对键进行排序。
- en: Extract the values corresponding to their keys and return them as a slice.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取与它们的键对应的值，并将它们作为切片返回。
- en: Map refresher
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 地图刷新器
- en: Go maps are dynamic, unordered collections of key-value pairs. Values can be
    accessed and modified using a unique key. They are represented using the built-in
    `map` type. The zero value of a map is nil, so it is initialized using a `make`
    function. Since Go 1.12, the `fmt` package will print maps in key-sorted order,
    but it is important to remember that the collection is unordered.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Go映射是动态的、无序的键值对集合。可以使用唯一的键访问和修改值。它们使用内置的`map`类型表示。映射的零值是nil，因此使用`make`函数进行初始化。自Go
    1.12以来，`fmt`包将按键排序顺序打印映射，但重要的是要记住，集合是无序的。
- en: 'Based on this knowledge, we can write a simple function to return the sorted
    values from a map:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些知识，我们可以编写一个简单的函数来从映射中返回排序后的值：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example function does work, returning sorted values, but it does have
    some areas for improvement to make it less fragile:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例函数确实可以工作，返回排序后的值，但它确实有一些可以改进的地方，使其不那么脆弱：
- en: '**Global variables**: The input map is a global variable, defined outside the
    scope of the function. The dependency between the function and the map is unclear
    from looking at the signature.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**全局变量**：输入地图是一个全局变量，其定义在函数的作用域之外。从函数签名中看，函数与地图之间的依赖关系并不明确。'
- en: '`GetValues`, does not give any indication of the sorting functionality. It
    is also unclear what the `dir` parameter is used for and what its allowed values
    are.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetValues`函数没有给出任何关于排序功能的指示。也不清楚`dir`参数的用途及其允许的值。'
- en: '`range` operator is able to handle a nil map passed to it without panic, but
    it is unclear what the expected behavior of the `GetValues` function is in this
    case.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`range`操作符能够处理传递给它的nil映射而不会引发panic，但在这个情况下`GetValues`函数的预期行为并不明确。'
- en: '`dir` parameter. The function handles the value of the parameter and performs
    the corresponding sorting, but the values will simply remain unsorted in the case
    of another value. Instead, it would be better if the caller of the function received
    some indication that the function was not able to perform its intended work.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dir`参数。该函数处理参数的值并执行相应的排序，但在另一个值的情况下，值将简单地保持未排序。更好的做法是，函数的调用者能够收到一些指示，表明函数无法执行其预期的工作。'
- en: '`dir` parameter is that it is validated against hardcoded values defined inside
    the function. Unless the value of the sorting direction is the same, including
    the letter case, the function will not match it. Furthermore, the caller has no
    idea what the accepted values are unless the implementation code is inspected.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dir`参数的验证是对函数内部定义的硬编码值进行的。除非排序方向的值相同，包括字母大小写，否则函数将不会匹配它。此外，除非检查实现代码，否则调用者不知道接受的值是什么。'
- en: '`sort` package to sort the keys in the correct order. This is a lot better
    than implementing a sorting algorithm from scratch, but the two sorting cases
    are implemented using different `sort` package functions.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sort`包对键进行正确的排序。这比从头实现排序算法要好得多，但两个排序情况是使用不同的`sort`包函数实现的。
- en: '**Memory allocation**: The slices used for the keys and sorted values are declared
    as their zero values, even though we already know how many keys are values we
    will be sorting. Under the hood, the Go runtime will have to expand the underlying
    arrays and copy the data as the number of values grows.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**内存分配**：用于键和排序值的切片被声明为它们的零值，尽管我们已经知道我们将要排序的键和值的数量。在底层，Go运行时会根据值的数量增长来扩展基本数组并复制数据。'
- en: 'We can add robustness to this function by addressing the issues we’ve found
    with the original implementation. This code refactoring is relatively straightforward,
    as this function is currently operating in isolation from any other code. A revised
    version is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过解决原始实现中我们发现的问题来增加这个函数的健壮性。由于这个函数目前是独立于任何其他代码运行的，所以这个代码重构相对简单。修改后的版本如下：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The changes we have made to this simple function have addressed a lot of the
    issues that we previously identified:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个简单函数所做的更改解决了我们之前确定的大多数问题：
- en: We introduce a new `SortDirection` type to replace the string value of the `dir`
    parameter. This type is used to create an `enum` with the acceptable sort direction
    values.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们引入一个新的`SortDirection`类型来替换`dir`参数的字符串值。这个类型用于创建一个包含可接受排序方向值的`enum`。
- en: The signature of the function has been changed to take the input map as a parameter,
    removing its dependency from the input map global variable. The function also
    returns a second error value in the case that it cannot complete its operation.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的签名已更改，以将输入映射作为参数，从而消除了其对输入映射全局变量的依赖。如果函数无法完成其操作，它还会返回第二个错误值。
- en: Alternatively, we could have allowed the `GetSortedValues` function to take
    a sorting function as a parameter, allowing the caller to implement their custom
    `sort` functions. This would allow us to move the entire sorting logic outside
    the function, but would also give calling code a lot more flexibility.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们本可以允许`GetSortedValues`函数接受一个排序函数作为参数，允许调用者实现他们自己的自定义`sort`函数。这将允许我们将整个排序逻辑移出函数，但也会给调用代码带来更多的灵活性。
- en: In the case that the input map is nil, the function returns an error and stops
    being executed. This is the behavior we have decided to implement for the function,
    making it clear to the user that an uninitialized map is considered an error case.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入映射为nil，则函数返回错误并停止执行。这是我们决定实现该函数的行为，使用户清楚地知道未初始化的映射被视为错误情况。
- en: Slices used for saving keys and values are initialized with the same capacity
    as the length of the input map. Appending values to these slices will not cause
    data reallocations and copying under the hood. As this is a small sample function,
    we will assume that the size of the map is enough to load in memory, but this
    might not be the case when processing very large datasets.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于保存键和值的切片以与输入映射的长度相同的容量初始化。将这些值追加到这些切片中不会导致底层的数据重新分配和复制。由于这是一个小型示例函数，我们将假设映射的大小足以在内存中加载，但在处理非常大的数据集时可能并非如此。
- en: We make use of a `switch` statement to check the values of the newly implemented
    `SortDirection`. The function has two acceptable cases for ascending and descending
    sort orders and returns an error in the case that another `enum` value is introduced
    without the correct implementation. Both cases implement sorting using the `sort.Slice`
    function.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`switch`语句来检查新实现的`SortDirection`的值。该函数有两个可接受的案例，用于升序和降序排序，如果引入了没有正确实现的另一个`enum`值，则返回错误。两种情况都使用`sort.Slice`函数实现排序。
- en: These changes have added robustness to our simple function, making it easier
    and more intuitive to use. We have also seen that adding code robustness is all
    about small changes, which add up to big improvements in our code stability and
    readability.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改增加了我们简单函数的鲁棒性，使其更容易和更直观地使用。我们还看到，添加代码鲁棒性完全是关于小的变化，这些变化累积起来可以显著提高我们的代码稳定性和可读性。
- en: Once we get into the habit of writing code with robustness and stability in
    mind, it becomes a habit to build it into our solutions, removing the need to
    return and refactor it later. As we have stated multiple times, test code is just
    as important as implementation code. Therefore, it should also be designed with
    robustness in mind. In the next sections, we will explore two strategies for writing
    robust test code that verifies edge cases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们养成了编写具有鲁棒性和稳定性的代码的习惯，它就会成为我们解决方案的一部分，从而消除了以后返回和重构的需要。正如我们多次提到的，测试代码与实现代码一样重要。因此，它也应该以鲁棒性为设计目标。在接下来的几节中，我们将探讨两种编写鲁棒测试代码的策略，以验证边缘情况。
- en: Usages of fuzzing
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试的使用
- en: As discussed previously, it is very difficult to write tests that cover all
    possible user scenarios and parameter value ranges. The number of test cases to
    write and maintain can become even more time-consuming than project work. In this
    section, we will explore Go’s fuzz testing capability, which can help us write
    tests that cover a wide variety of inputs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编写涵盖所有可能用户场景和参数值范围的测试非常困难。要编写和维护的测试用例数量可能比项目工作更耗时。在本节中，我们将探讨Go的模糊测试功能，它可以帮助我们编写涵盖广泛输入的测试。
- en: '**Fuzz testing** is a powerful technique that has been used to find bugs in
    a wide variety of software systems, including the Go standard library itself.
    It involves generating a wide variety of values and using them as input to the
    UUT. The generated values stress-test the UUT and help uncover bugs or unexpected
    behavior such as panics, memory leaks, or incorrect outputs.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**模糊测试**是一种强大的技术，已被用于在各种软件系统中查找错误，包括Go标准库本身。它涉及生成各种值并将它们用作UUT的输入。生成的值对UUT进行压力测试，有助于发现错误或意外行为，如恐慌、内存泄漏或输出错误。'
- en: Fuzz tests are automated, black-box tests that can be used to detect any potential
    functional or security issues in our system. They are usually run using a **fuzz
    tool**, which takes care of value generation, test execution, and error detection.
    In this section, we will focus on using fuzzing to detect functional errors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试是自动化的黑盒测试，可以用来检测我们系统中任何潜在的功能或安全问题。它们通常使用 **模糊工具** 运行，该工具负责值生成、测试执行和错误检测。在本节中，我们将重点介绍使用模糊测试来检测功能错误。
- en: '*Figure 10**.2* presents an overview of the steps involved in fuzz testing:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.2* 展示了模糊测试中涉及的步骤概述：'
- en: '![Figure 10.2 – The main steps of fuzz testing ](img/Figure_10.2_B18371.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 模糊测试的主要步骤](img/Figure_10.2_B18371.jpg)'
- en: Figure 10.2 – The main steps of fuzz testing
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 模糊测试的主要步骤
- en: 'Writing fuzz tests is not very different from regular unit tests:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 编写模糊测试与常规单元测试没有太大区别：
- en: '**Identify the fuzz target**: Just like with normal tests, we begin by identifying
    the UUT. The fuzz target will be the function that we will cover in our tests.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**识别模糊目标**：就像正常测试一样，我们首先识别 UUT。模糊目标将是我们在测试中要覆盖的函数。'
- en: '**Identify fuzz arguments**: The fuzz target is only suitable for fuzz testing
    if it takes in at least one parameter. These are the parameters that will be generated
    by the fuzz tool and used as input for the previously identified fuzz target.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**识别模糊参数**：模糊目标仅适用于模糊测试，如果它至少接受一个参数。这些参数将由模糊工具生成，并用作之前已识别的模糊目标的输入。'
- en: '**Generate fuzzed values**: Once the test is specified, the fuzz tool will
    begin to generate the random values for our fuzz arguments.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成模糊值**：一旦指定了测试，模糊工具将开始为我们生成模糊参数的随机值。'
- en: '**Run tests with fuzzed values**: The tests are executed with the generated
    fuzzed values. Typically, fuzz tests are fast-running unit tests, as they will
    be run with a large amount of generated fuzzed values.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用模糊值运行测试**：测试使用生成的模糊值执行。通常，模糊测试是快速运行的单元测试，因为它们将使用大量生成的模糊值。'
- en: '**Report and log failures**: The test runner will execute the tests, logging
    and reporting failures. Just like unit tests, fuzz tests can include assertions
    and verifications.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**报告和记录失败**：测试运行器将执行测试，记录和报告失败。就像单元测试一样，模糊测试可以包含断言和验证。'
- en: Fuzz testing can be used to validate any input values that the UUT or fuzz target
    has not generated. These can be values coming from other services in the system
    or from outside sources. It can be applied to files, policies, applications, and
    libraries.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试可以用来验证 UUT 或模糊目标未生成的任何输入值。这些可以是来自系统中的其他服务或外部来源的值。它可以应用于文件、策略、应用程序和库。
- en: Fuzz testing in Go
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 中的模糊测试
- en: The ability to fuzz-test is an important component of a well-rounded testing
    strategy. Fuzzing was added to the standard Go testing library in Go version 1.18\.
    This feature was highly anticipated by the Go community, making writing fuzzed
    tests as easy as writing unit tests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 能够进行模糊测试是全面测试策略的一个重要组成部分。模糊测试在 Go 1.18 版本中添加到标准 Go 测试库中。这个特性受到了 Go 社区的热烈期待，使得编写模糊测试与编写单元测试一样简单。
- en: 'Just like tests and benchmarks, fuzzed tests must follow a few rules:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像测试和基准测试一样，模糊测试必须遵循一些规则：
- en: Tests must begin with the `Fuzz` prefix. We notice that tests are exported functions,
    defined by starting with a capital letter. For example, a fuzz test for our `GetSortedValues`
    function would be named `FuzzGetSortedValues`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试必须以 `Fuzz` 前缀开始。我们注意到测试是导出函数，通过以大写字母开头定义。例如，对我们 `GetSortedValues` 函数的模糊测试将被命名为
    `FuzzGetSortedValues`。
- en: Tests must be defined in test files named with the `_test.go` postfix. As with
    other test files, we should use the name of the source file to name our test file.
    For example, if our sorting function was defined in a `sort.go` file, then its
    corresponding test file could be `sort_test.go`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试必须在以 `_test.go` 后缀命名的测试文件中定义。与其他测试文件一样，我们应该使用源文件名来命名我们的测试文件。例如，如果我们的排序函数定义在
    `sort.go` 文件中，那么其相应的测试文件可以是 `sort_test.go`。
- en: Tests must accept a single `*testing.F` parameter and have no return values.
    This is the way fuzzed tests interact with the test runner and fuzzing tool.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试必须接受单个 `*testing.F` 参数，并且没有返回值。这是模糊测试与测试运行器和模糊工具交互的方式。
- en: The fuzz target is defined by calling the `Fuzz` function on the `*testing.F`
    parameter. This function takes in a `*testing.T` parameter, followed by the fuzzing
    arguments. There can only be one fuzz target per test and the calls on the UUT
    will happen inside the fuzz target.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模糊目标是通过对`*testing.F`参数调用`Fuzz`函数来定义的。这个函数接受一个`*testing.T`参数，后面跟着模糊参数。每个测试只能有一个模糊目标，UUT的调用将发生在模糊目标内部。
- en: Fuzz arguments are added to the fuzzing tool using the `Add` function on the
    `*testing.F` parameter. This will instruct the tool to generate values to be used
    in the fuzz target.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`*testing.F`参数上的`Add`函数将模糊参数添加到模糊工具中。这将指示工具生成用于模糊目标的值。
- en: 'Fuzzing arguments can be of the following types:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模糊参数可以是以下类型：
- en: '`string`, `[]byte`'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`string`，`[]byte`'
- en: All `int` types, including `rune`
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有`int`类型，包括`rune`
- en: All `uint` types, including `byte`
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有`uint`类型，包括`byte`
- en: All `float` types
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有`float`类型
- en: '`bool`'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bool`'
- en: Due to a large number of test runs, fuzz tests will be run in parallel. They
    should therefore be deterministic.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于测试运行数量庞大，模糊测试将在并行中运行。因此，它们应该是确定的。
- en: Fuzz tests are run alongside your other unit tests using the `go test` command
    or with the `-fuzz` flag followed by a test name or package. Again, this is similar
    to how we run benchmark tests.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go test`命令或跟随测试名称或包的`-fuzz`标志，模糊测试将与您的其他单元测试并行运行。同样，这与我们运行基准测试的方式相似。
- en: 'The fuzzing tool monitors the test runs and reports errors that have occurred.
    Fuzz tests can fail for a few reasons: panics, test failures, non-recoverable
    errors, or timeouts. By default, the timeout for a fuzz target is 1 second, so
    your tests should be fast.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊工具监控测试运行并报告发生的错误。模糊测试可能因以下原因失败：恐慌、测试失败、不可恢复的错误或超时。默认情况下，模糊目标的超时时间为1秒，因此您的测试应该很快。
- en: Fuzzed tests will continue to run until a failing input is found or until the
    user cancels the test run manually. Alternatively, we can supply a maximum execution
    time or the maximum number of iterations using the `–fuzztime` command-line parameter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试将继续运行，直到找到失败的输入或用户手动取消测试运行。或者，我们可以使用`–fuzztime`命令行参数提供最大执行时间或最大迭代次数。
- en: A simple fuzz test
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的模糊测试
- en: 'We can write a simple fuzz test for the `GetSortedValues` function we wrote
    in the previous section:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为上一节中编写的`GetSortedValues`函数编写一个简单的模糊测试：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have written the fuzzed test according to the rules we have discussed and
    with the same techniques we use for unit tests:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经根据我们讨论的规则编写了模糊测试，并使用了与单元测试相同的技巧：
- en: We declare a fuzz test using the required signature. The test starts with the
    `Fuzz` prefix and takes in the `*``testing.F` parameter.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用所需的签名声明一个模糊测试。测试以`Fuzz`前缀开始，并接受`*testing.F`参数。
- en: We add two fuzz testing arguments to the fuzz testing tool using the `f.Add`
    method, one for the map key of the `int` type and one of the `string` type for
    the map value. These values will be generated by the fuzzing tool. Both of these
    types are accepted for fuzzing arguments.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`f.Add`方法向模糊测试工具添加两个模糊测试参数，一个用于`int`类型的映射键，另一个用于`string`类型的映射值。这些值将由模糊工具生成。这两种类型都接受为模糊参数。
- en: We define the fuzz target using the `f.Fuzz` method. This method takes a function
    as a parameter, which itself takes the fuzzing arguments as parameters. The function
    also takes in a `*testing.T` parameter, which makes it possible for us to write
    test assertions inside the fuzz target.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`f.Fuzz`方法定义模糊目标。此方法接受一个函数作为参数，该函数本身接受模糊参数作为参数。该函数还接受一个`*testing.T`参数，这使得我们能够在模糊目标内部编写测试断言。
- en: Inside the fuzz target, we write the testing code. We add the fuzzing arguments
    to the map, using the generated values to test our functionality. Then, we extract
    the keys from the map and sort them in ascending order.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模糊目标内部，我们编写测试代码。我们将模糊参数添加到映射中，使用生成的值来测试我们的功能。然后，我们从映射中提取键并按升序排序。
- en: We invoke the `GetSortedValues` function, which is our UUT for this test, passing
    it the input map that now contains the fuzzing arguments.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`GetSortedValues`函数，这是本测试的UUT，并传递包含模糊参数的输入映射。
- en: At the end of the test, we use the previously sorted slice of keys to assert
    that the values returned are sorted correctly.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试结束时，我们使用之前排序的键切片来断言返回的值已正确排序。
- en: 'We have successfully written our first fuzzed test. We can run it using the
    `go test` command with two configuration flags:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功编写了第一个模糊测试。我们可以使用带有两个配置标志的`go test`命令来运行它：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `–fuzz` flag instructs the test runner to execute the fuzzed test specified
    by name, while the `–fuzztime` flag specifies that the test should run for a maximum
    of 5 seconds. The output of our test run highlights some key metrics of the test
    run:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`–fuzz` 标志指示测试运行器执行指定名称的模糊测试，而 `–fuzztime` 标志指定测试应运行最长时间为5秒。我们的测试运行输出突出了测试运行的一些关键指标：'
- en: '`elapsed` indicates the amount of processing time'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elapsed` 表示处理时间'
- en: '`baseline coverage` indicates the number of scenarios that are applied to measure
    the coverage provided by the tests'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseline coverage` 表示应用于测量测试提供的覆盖范围的场景数量'
- en: '`execs` indicates the number of test cases that have been run with the fuzz
    target'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execs` 表示使用模糊目标运行的测试用例数量'
- en: '`new interesting` is the number of new inputs that are identified that expand
    the coverage of the fuzzed test'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new interesting` 是指识别出的新输入数量，这些输入扩展了模糊测试的覆盖范围'
- en: 'Now that we understand how to write and run fuzzed tests, we are ready to add
    them to our own testing strategies. However, it does have some drawbacks. *Figure
    10**.3* presents some of the advantages and disadvantages of fuzz testing:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何编写和运行模糊测试，我们准备将它们添加到自己的测试策略中。然而，它确实有一些缺点。*图10**.3 展示了模糊测试的一些优点和缺点：
- en: '![Figure 10.3 – Advantages and disadvantages of fuzz testing ](img/Figure_10.3_B18371.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 模糊测试的优点和缺点](img/Figure_10.3_B18371.jpg)'
- en: Figure 10.3 – Advantages and disadvantages of fuzz testing
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 模糊测试的优点和缺点
- en: 'The advantages of fuzz testing are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试的优点如下：
- en: '`testing` package, we can easily write fuzzed tests for anything in Go. However,
    it’s important to keep the scope of the tests small so that they can be executed
    quickly and efficiently.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `testing` 包，我们可以轻松地为Go中的任何内容编写模糊测试。然而，保持测试范围小很重要，这样它们可以快速高效地执行。
- en: '**Can be used early in the development life cycle**: As we have seen in our
    simple example, fuzzed tests can be written for functions or even small units
    of code. This makes it easy to leverage them at any stage of the development life
    cycle.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可以在开发生命周期的早期使用**：正如我们在简单示例中看到的，可以为函数甚至小的代码单元编写模糊测试。这使得在任何开发生命周期阶段利用它们变得容易。'
- en: '**Detects a wide variety of bugs**: Fuzzed testing generates values that cover
    edge cases and run over many executions. This makes it a great tool for detecting
    bugs that would otherwise not have been possible to find.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检测广泛的错误**：模糊测试生成覆盖边缘情况并在多次执行中运行的值。这使得它成为检测那些否则不可能找到的错误的好工具。'
- en: 'The disadvantages of fuzz testing are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试的缺点如下：
- en: '**Does not replace traditional testing**: Fuzzing complements rather than substitutes
    the types of tests that we have explored throughout this book. Therefore, it can
    take additional engineering effort to write these tests.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不取代传统测试**：模糊测试补充而不是取代我们在本书中探讨的测试类型。因此，编写这些测试可能需要额外的工程努力。'
- en: '**Does not provide guarantees**: Fuzzed tests only provide an indication of
    the stability of the UUT, not a guarantee. As it generates random values, it can
    only indicate to developers the presence of bugs for the inputs it does cover.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不提供保证**：模糊测试只提供UUT稳定性的指示，而不是保证。因为它生成随机值，所以它只能向开发者指示它所覆盖的输入中存在的错误。'
- en: '**Memory- & CPU-intensive**: As we have seen from our example output, fuzzed
    tests are run in parallel over a large number of scenarios. This makes them more
    memory- and CPU-intensive than unit tests.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**内存和CPU密集型**：正如我们从示例输出中看到的，模糊测试在大量场景中并行运行。这使得它们比单元测试更消耗内存和CPU。'
- en: Despite its drawbacks, fuzz testing is a useful and powerful testing technique
    that complements all the traditional testing methods we have explored so far.
    As it is able to generate a wide variety of inputs, fuzz testing is also an important
    tool that can help uncover security vulnerabilities. In security fuzz testing,
    we input malicious data to a program, while in functional fuzz testing, we input
    invalid data. We will not focus on security testing in this book, but it is another
    great use for fuzzing. It is especially useful for ensuring our systems remain
    stable in edge cases or when processing user inputs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有缺点，模糊测试是一种有用且强大的测试技术，它补充了我们迄今为止探索的所有传统测试方法。由于它能够生成大量输入，模糊测试也是一项重要的工具，可以帮助发现安全漏洞。在安全模糊测试中，我们将恶意数据输入到程序中，而在功能模糊测试中，我们输入无效数据。本书不会专注于安全测试，但这也是模糊测试的另一个用途。它特别有助于确保我们的系统在边缘情况或处理用户输入时保持稳定。
- en: Property-based testing
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于属性的测试
- en: 'Fuzz testing is a great step forward when testing edge cases in our application.
    We can think of it as analogous to chaos testing, where we test a huge variety
    of edge cases in the hope of detecting an error. However, we do not have any control
    over the random inputs. This leads to two problems:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试在测试我们应用程序的边缘情况时是一个巨大的进步。我们可以将其视为类似于混沌测试，在那里我们测试大量边缘情况，希望检测到错误。然而，我们对随机输入没有任何控制。这导致两个问题：
- en: We test a large number of irrelevant scenarios that are unlikely to happen in
    our system.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们测试了大量的无关场景，这些场景在我们系统中不太可能发生。
- en: We don’t know whether the scenarios that really matter have been covered by
    our fuzzed tests. Instead, it would be great if we had a more structured approach
    available to us.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不知道真正重要的场景是否已被我们的模糊测试覆盖。相反，如果我们有一个更结构化的方法可用，那就太好了。
- en: '**Property-based testing** is a testing technique that involves testing a program
    against a set of properties or specifications that are important to our user journeys
    and system behavior. This allows engineers to follow a systemic approach to testing,
    as opposed to focusing on verifying inputs.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于属性的测试**是一种测试技术，它涉及将程序与一组对我们用户旅程和系统行为重要的属性或规范进行测试。这允许工程师采用系统性的测试方法，而不是专注于验证输入。'
- en: In property-based testing, we generate random inputs that satisfy the set of
    constraints or properties that we have identified. The generation aspect ensures
    that we test against a larger space of edge cases than would have been possible
    with traditional, manually written tests. The focus on properties ensures that
    we cover the edge cases that matter to our applications. Again, this does not
    guarantee the absence of bugs, but it does ensure that we spend our time testing
    the things that matter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于属性的测试中，我们生成满足我们已识别的约束或属性集的随机输入。生成方面确保我们测试的边缘情况空间比传统手动编写的测试要大。对属性的重视确保我们覆盖了对我们应用程序重要的边缘情况。再次强调，这并不保证没有错误，但它确实确保我们花费时间测试重要的事情。
- en: 'The `testing/quick` package offers testing helper functionality that we can
    leverage to implement property-based tests:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`testing/quick`包提供了我们可以利用的测试辅助功能，以实现基于属性的测试：'
- en: The `quick.Check` function takes in a function with a `bool` return value and
    searches for arbitrary values that make the input function return `false`.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quick.Check`函数接受一个具有`bool`返回值的函数，并搜索使输入函数返回`false`的任意值。'
- en: The `quick.CheckEqual` function takes in two functions and looks for an input
    for which the functions return different results.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quick.CheckEqual`函数接受两个函数，并寻找一个使这两个函数返回不同结果的输入。'
- en: The `quick.Generator` interface defines a Generate method that custom types
    can implement. Once they satisfy this interface, we can generate random values
    for our custom types using the `quick.Value` function. This gives us the flexibility
    to generate values for any exported type.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quick.Generator`接口定义了一个`Generate`方法，自定义类型可以实现。一旦它们满足此接口，我们就可以使用`quick.Value`函数为我们的自定义类型生成随机值。这为我们提供了为任何导出类型生成值的灵活性。'
- en: The `Check` functions of the `quick` package also take in a `*quick.Config`
    parameter that allows us to configure our test run with the maximum number of
    iterations or another random generator.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`quick`包的`Check`函数也接受一个`*quick.Config`参数，允许我们使用最大迭代次数或其他随机生成器来配置我们的测试运行。'
- en: This type of testing is intuitive and easy to achieve. Looking back at the fuzzing
    example we implemented, the verifications in the fuzz target only asserted the
    order of the elements, not the values themselves. In fact, without realizing it,
    we wrote our first property-based test. The real value of property-based testing,
    however, lies in its search for failing function inputs, as opposed to generating
    fully random values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的测试直观且易于实现。回顾我们实施的模糊测试示例，模糊目标中的验证仅断言了元素顺序，而不是元素本身的值。实际上，我们没有意识到，我们已经编写了我们的第一个基于属性的测试。然而，基于属性的测试的真实价值在于其寻找导致失败的函数输入，而不是生成完全随机的值。
- en: 'We can re-implement our previously implemented fuzz test with property-based
    testing in mind:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新实现我们之前实现的模糊测试，同时考虑基于属性的测试：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The structure of the test is different, but it uses the same verifications
    as in the fuzzing test:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的结构不同，但它使用了与模糊测试相同的验证：
- en: The test uses the regular unit test signature, starting with the `Test` prefix
    and taking in a single parameter of `*testing.T`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试使用常规的单元测试签名，以`Test`前缀开始，并接受一个参数`*testing.T`。
- en: Inside the test, we declare an `isSorted` helper function, which takes in the
    two arguments we will generate, one for the key and one for the value of our new
    map entry. It also returns a `bool` value, making it suitable to be used with
    the `quick.Check` function.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试内部，我们声明一个`isSorted`辅助函数，它接受我们将生成的两个参数，一个用于新映射条目的键，一个用于值。它还返回一个`bool`值，使其适合与`quick.Check`函数一起使用。
- en: Inside the function, we add the generated values to the input map. Then, we
    copy the keys and sort them. We call the `GetSortedValues` function and our UUT
    and get the actual values to verify.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，我们将生成的值添加到输入映射中。然后，我们复制键并对其进行排序。我们调用`GetSortedValues`函数和我们的单元测试单元（UUT），以获取实际值进行验证。
- en: In the case of an error or a nil slice, we return `false`, stopping the test.
    We also return `false` if the sorted values are not as expected. This will signal
    to the `quick.Check` function that an error has occurred.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现错误或空切片的情况下，我们返回`false`，停止测试。如果排序后的值与预期不符，我们也会返回`false`。这将向`quick.Check`函数发出错误发生的信号。
- en: Inside the test, we pass the `isSorted` helper function to the `quick.Check`
    function and fail the test if it returns an error.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试内部，我们将`isSorted`辅助函数传递给`quick.Check`函数，如果它返回错误，则测试失败。
- en: 'In the case of error, the `quick.Check` function will report the values that
    have caused the failure. Forcing the test to fail, we will receive an output with
    information about the inputs that caused the failure:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现错误的情况下，`quick.Check`函数将报告导致失败的值。强制测试失败，我们将收到一个包含导致失败的输入信息的输出：
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The input values causing the failure can be used by engineers to debug the application
    and fix the cause of the failure.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 导致失败的输入值可以被工程师用来调试应用程序并修复失败的原因。
- en: The two testing techniques we have covered in this chapter, fuzz testing and
    property-based testing, allow us to take advantage of value generation and test
    a wide variety of edge cases for our system inputs. These testing techniques are
    complementary to the robust code best practices discussed at the beginning of
    the chapter and allow us to ensure the stability and reliability of our services.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们讨论的两种测试技术，模糊测试和基于属性的测试，使我们能够利用值生成并测试系统输入的广泛边缘情况。这些测试技术是本章开头讨论的健壮代码最佳实践的补充，并使我们能够确保我们服务的稳定性和可靠性。
- en: Use case – edge cases of the BookSwap application
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - BookSwap应用程序的边缘情况
- en: 'This chapter has taught us two new testing techniques: fuzzed testing and property-based
    testing. We have learned how to apply these to a simple function that provided
    the functionality of returning the key-sorted values contained inside an input
    map. In this section, we will end our exploration with a discussion of how these
    techniques can be applied to the `BookSwap` application we have built so far.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教会了我们两种新的测试技术：模糊测试和基于属性的测试。我们学习了如何将这些技术应用到提供返回输入映射中包含的键排序值的简单函数中。在本节中，我们将通过讨论如何将这些技术应用到我们迄今为止构建的`BookSwap`应用程序中结束我们的探索。
- en: 'As previously discussed, robust code should test any variables that it does
    not generate itself. We named these inputs as being from untrusted sources. *Figure
    10**.4* presents all the inputs that can be considered untrusted from the viewpoint
    of the processing service:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，健壮的代码应该测试它自己没有生成的任何变量。我们将这些输入命名为来自不可信的来源。*图10*.*4*展示了从处理服务的角度来看可以被认为是不可信的所有输入：
- en: '![Figure 10.4 – Untrusted input in the BookSwap application ](img/Figure_10.4_B18371.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – BookSwap应用程序中的不可信输入](img/Figure_10.4_B18371.jpg)'
- en: Figure 10.4 – Untrusted input in the BookSwap application
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – BookSwap应用程序中的不可信输入
- en: 'We identify two sources of untrusted input within the services of `BookSwap`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`BookSwap`的服务中确定了两个不可信输入的来源：
- en: '`UserService` receives input from the user. As we have no control over what
    the user submits, this interaction is a source of untrusted input.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserService`接收来自用户的输入。由于我们无法控制用户提交的内容，这种交互是不可信输入的来源。'
- en: '`UserService` receives information from `BookService`. As you may remember
    from our discussion in [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179), *Testing
    Microservice Architectures*, microservices change without any central oversight.
    Therefore, as `UserService` does not have any control over the functionality provided
    by this external service, this interaction is a source of untrusted input.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserService`从`BookService`接收信息。如您从我们在[*第8章*](B18371_08.xhtml#_idTextAnchor179)中讨论的*测试微服务架构*中记得，微服务在没有中央监督的情况下进行更改。因此，由于`UserService`无法控制此外部服务提供的功能，这种交互是不可信输入的来源。'
- en: The same applies to `BookService`, which receives requests from `UserService`.
    While this interaction does not actively send input to `BookService`, the request
    still contains untrusted information.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样适用于`BookService`，它接收来自`UserService`的请求。虽然这种交互不会主动向`BookService`发送输入，但请求仍然包含不可信的信息。
- en: 'Based on these insights, we can identify the need to implement fuzz testing
    for the HTTP handlers exposed by our web application. We will test the user creation
    operation that we have also tested in previous chapters. Fuzz testing of HTTP
    endpoints can easily achieve this using Go’s fuzzing capability:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些见解，我们可以确定需要为我们的Web应用程序公开的HTTP处理器实现模糊测试。我们将测试我们在前几章中也测试过的用户创建操作。使用Go的模糊测试功能可以轻松地对HTTP端点进行模糊测试：
- en: '[PRE6]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Other than the interaction with the fuzz testing tool for setting up the fuzzing
    target and arguments, the body of this test is identical to the HTTP testing we
    are already familiar with. We add four fuzzing arguments for the fields that the
    user creation request needs. Inside the fuzzing target, we create and marshal
    the request to JSON format. Finally, we send the request to the `/users` endpoint
    using the `http.Post` function. Just as the previous fuzz testing example we have
    seen in this chapter, we run this test using the `LONG=true go test -fuzz FuzzTestUserCreation
    -fuzztime=5s ./chapter10 -v` command. It requires the BookSwap application to
    be up and running, which we can easily do with the Docker command we've seen so
    far `docker compose -f docker-compose.book-swap.chapter10.yml up --build`. The
    test also relies on environment variables to construct the URL under test. If
    you want to run with the default values, set the `BOOKSWAP_BASE_URL` environment
    variable to http://localhost and the `BOOKSWAP_PORT` environment variable to `3000`
    to your terminal session.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与模糊测试工具交互以设置模糊测试目标和参数之外，此测试的主体与我们已熟悉的HTTP测试相同。我们为用户创建请求所需的字段添加了四个模糊测试参数。在模糊测试目标内部，我们创建并序列化请求到JSON格式。最后，我们使用`http.Post`函数将请求发送到`/users`端点。正如我们在本章中看到的上一个模糊测试示例，我们使用`LONG=true
    go test -fuzz FuzzTestUserCreation -fuzztime=5s ./chapter10 -v`命令运行此测试。这需要BookSwap应用程序正在运行，我们可以使用我们之前看到的Docker命令轻松做到这一点`docker
    compose -f docker-compose.book-swap.chapter10.yml up --build`。测试还依赖于环境变量来构建测试的URL。如果您想使用默认值运行，请将`BOOKSWAP_BASE_URL`环境变量设置为http://localhost，并将`BOOKSWAP_PORT`环境变量设置为`3000`到您的终端会话。
- en: This brings us to the end of our exploration of fuzz testing and property-based
    testing, which are two related techniques that allow us to easily write testing
    strategies that cover a wide variety of edge cases. Both of these techniques integrate
    well with Go’s `testing` package and can be easily implemented at any level of
    our application testing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们结束了对模糊测试和基于属性的测试的探索，这两种相关技术使我们能够轻松编写覆盖广泛边缘情况的测试策略。这两种技术都很好地与Go的`testing`包集成，并且可以在我们应用程序测试的任何级别轻松实现。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we revisited our understanding and approach to covering edge
    cases of input variables. We began our discussion with the concept of code robustness,
    focusing on writing code that can handle unexpected inputs and errors. Once code
    robustness becomes part of our mindset, we start to understand the edge cases
    of our code. However, it can be very difficult to manually implement tests to
    cover all these values.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了我们对于覆盖输入变量边缘情况的理解和策略。我们的讨论从代码健壮性的概念开始，关注于编写能够处理意外输入和错误的代码。一旦代码健壮性成为我们思维模式的一部分，我们就会开始理解代码的边缘情况。然而，手动实现测试以覆盖所有这些值可能非常困难。
- en: 'Two testing techniques leverage input generation to make this task easier:
    fuzz testing and property-based testing. Both of these techniques can be implemented
    with Go’s testing library, allowing us to easily leverage the benefits of these
    techniques to verify a broad range of edge cases to our components at any level.
    Finally, we looked at an applied example of how to use fuzz testing together with
    the `BookSwap` application’s user creation flow, ensuring that it is stable for
    generated values.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 两种测试技术利用输入生成来简化这项任务：模糊测试和基于属性的测试。这两种技术都可以使用Go的测试库实现，使我们能够轻松利用这些技术的优势来验证我们组件的广泛边缘情况。最后，我们查看了一个应用示例，展示了如何将模糊测试与`BookSwap`应用程序的用户创建流程结合使用，确保它对生成的值是稳定的。
- en: In [*Chapter 11*](B18371_11.xhtml#_idTextAnchor231), *Working with Generics*,
    we will explore another newly introduced Go feature, namely generics. We will
    see how it can make our implementation and testing code simpler and easier to
    use.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](B18371_11.xhtml#_idTextAnchor231)，*使用泛型*，我们将探讨Go语言中另一个新引入的特性，即泛型。我们将看到它如何使我们的实现和测试代码更加简单和易于使用。
- en: Questions
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are some of the characteristics of robust code?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 健壮代码有哪些特点？
- en: What is fuzz testing?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是模糊测试？
- en: What is the signature of a fuzzed test in Go?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Go中，模糊测试的签名是什么？
- en: What is property-based testing?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基于属性的测试？
- en: What are the untrusted inputs of the UUT?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UUT的不信任输入有哪些？
- en: Further reading
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The Art of Clean Code: Best Practices to Eliminate Complexity and Simplify
    Your Life*, Christian Mayer, published by No Starch Press'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《编写整洁代码的艺术：消除复杂性并简化生活的最佳实践》*，作者：Christian Mayer，由No Starch Press出版'
- en: '*How to Break Software: A Practical Guide to Testing*, James Whittaker, published
    by Pearson'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《如何破坏软件：测试的实用指南》*，作者：James Whittaker，由Pearson出版'
