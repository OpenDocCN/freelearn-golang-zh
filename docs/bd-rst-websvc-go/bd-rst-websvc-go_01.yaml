- en: Getting Started with REST API Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用REST API开发
- en: A web service is a communication mechanism defined between different computer
    systems. Without web services, custom peer-to-peer communication becomes cumbersome
    and platform specific. It is like a hundred different kinds of things that the
    web needs to understand and interpret. If computer systems align with the protocols
    that the web can understand easily, it is a great help.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务是在不同计算机系统之间定义的通信机制。没有Web服务，自定义的点对点通信变得繁琐且特定于平台。这就像是网络需要理解和解释的一百种不同的东西。如果计算机系统与网络易于理解的协议相一致，那将是一个很大的帮助。
- en: A web service is a software system designed to support interoperable machine-to-machine
    interaction over a network, **World Wide Web Consortium** (**W3C**), [https://www.w3.org/TR/ws-arch/](https://www.w3.org/TR/ws-arch/).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务是一种旨在支持网络上可互操作的机器对机器交互的软件系统，**万维网联盟**（**W3C**），[https://www.w3.org/TR/ws-arch/](https://www.w3.org/TR/ws-arch/)。
- en: Now, in simple words, a web service is a road between two endpoints where messages
    are transferred smoothly. Here, this transfer is usually one way. Two individual
    programmable entities can also communicate with each other through their own APIs.
    Two people communicate through language. Two applications communicate through
    the **Application Programming Interface **(**API**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，简单来说，Web服务是两个端点之间的通路，消息可以顺利传输。在这里，这种传输通常是单向的。两个独立的可编程实体也可以通过它们自己的API相互通信。两个人通过语言进行交流。两个应用程序通过**应用程序编程接口**（**API**）进行通信。
- en: The reader might be wondering; what is the importance of the API in the current
    digital world? The rise of the **Internet of Things **(**IoT**) made API usage
    heavier than before. Consciousness about the API is growing day by day, and there
    are hundreds of APIs that are being developed and documented all over the world
    every day. Notable major businesses are seeing futures in the **API as a Service**
    (**AAAS**). A bright example is **Amazon Web Services** (**AWS**). It is a huge
    success in the cloud world. Developers write their own applications using the
    REST API provided by the AWS.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能会想知道，在当前数字世界中API的重要性是什么？**物联网**（**IoT**）的兴起使API的使用比以往更加重要。对API的认识日益增长，每天都有数百个API在全球各地被开发和记录。一些重要的大型企业正在看到**作为服务的API**（**AAAS**）的未来。一个明显的例子是**亚马逊网络服务**（**AWS**）。它在云世界取得了巨大的成功。开发人员使用AWS提供的REST
    API编写自己的应用程序。
- en: A few more hidden use cases are from travel sites like Ibibo and Expedia, which
    fetch real-time prices by calling the APIs of third-party gateways and data vendors.
    Web services are often charged these days.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更隐秘的用例来自像Ibibo和Expedia这样的旅行网站，它们通过调用第三方网关和数据供应商的API来获取实时价格。如今，Web服务通常会收费。
- en: 'Topics to be covered in this chapter are:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主题包括：
- en: The different Web Services available
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的不同Web服务
- en: Representational State Transfer (REST) architecture in detail
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细介绍表现状态转移（REST）架构
- en: Introduction to Single Page Applications (SPA) with REST
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍使用REST构建单页应用程序（SPA）
- en: Setting up a Go project and running a development server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Go项目并运行开发服务器
- en: Building our first service for finding Roman numerals
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为查找罗马数字构建我们的第一个服务
- en: Using Gulp to auto-compile Go code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gulp自动编译Go代码
- en: Types of web services
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务的类型
- en: 'There are many types of web services which have evolved over time. Prominent
    ones are :'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，出现了许多类型的Web服务。其中一些主要的是：
- en: SOAP
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP
- en: UDDI
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDDI
- en: WSDL
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WSDL
- en: REST
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST
- en: Out of these, **SOAP** became popular in the early 2000s, when XML was on the
    top wave. The XML data format is used by various distributed systems to communicate
    with each other. SOAP is too complex to implement. Criticizers of SOAP point out
    how bulky the SOAP HTTP request is.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些中，**SOAP**在2000年代初变得流行，当时XML处于风口浪尖。各种分布式系统使用XML数据格式进行通信。SOAP的实现过于复杂。SOAP的批评者指出了SOAP
    HTTP请求的臃肿。
- en: 'A SOAP request usually consists of these three basic components:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP请求通常由以下三个基本组件组成：
- en: Envelope
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信封
- en: Header
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部
- en: Body
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体
- en: 'Just to perform an HTTP request and response cycle, we have to attach a lot
    of additional data in SOAP. A sample SOAP request looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅执行一个HTTP请求和响应周期，我们就必须在SOAP中附加大量额外的数据。一个示例SOAP请求如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a standard example of SOAP from the W3C standard ([https://www.w3.org/TR/2000/NOTE-SOAP-20000508/](https://www.w3.org/TR/2000/NOTE-SOAP-20000508/)).
    If we observe carefully, it is in XML format, with special tags specifying the
    envelope and body. Since XML operates on a lot of namespaces to function, additional
    information comes into play.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自W3C标准的SOAP的标准示例（[https://www.w3.org/TR/2000/NOTE-SOAP-20000508/](https://www.w3.org/TR/2000/NOTE-SOAP-20000508/)）。如果我们仔细观察，它是以XML格式呈现的，其中特殊标签指定了信封和主体。由于XML操作需要大量的命名空间来运行，额外的信息也会起作用。
- en: REST API
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API
- en: The name **Representational state transfer** (**REST**) was coined by Roy Fielding
    from the University of California. It is a very simplified and lightweight web
    service compared to SOAP. Performance, scalability, simplicity, portability, and
    modifiability are the main principles behind the REST design.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**表现状态转移**（**REST**）这个名字是由加利福尼亚大学的Roy Fielding创造的。与SOAP相比，它是一个非常简化和轻量级的Web服务。性能、可伸缩性、简单性、可移植性和可修改性是REST设计的主要原则。'
- en: The REST API allows different systems to communicate and send/receive data in
    a very simple way. Each and every REST API call has a relation between an HTTP
    verb and the URL. The resources in the database in an application can be mapped
    with an API endpoint in the REST.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: REST API允许不同的系统以非常简单的方式进行通信和发送/接收数据。每个REST API调用都与HTTP动词和URL之间存在关系。应用程序中的数据库资源可以与REST中的API端点进行映射。
- en: When you are using a mobile app on your phone, your phone might be secretly
    talking to many cloud services to retrieve, update, or delete your data. REST
    services have a huge impact on our daily lives.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在手机上使用移动应用时，您的手机可能会秘密地与许多云服务进行通信，以检索、更新或删除您的数据。REST服务对我们的日常生活有着巨大的影响。
- en: REST is a stateless, cacheable, and simple architecture that is not a protocol
    but a pattern.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一个无状态、可缓存的、简单的架构，不是协议而是一种模式。
- en: Characteristics of REST services
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST服务的特点
- en: 'These are the main properties that make REST simple and unique compared to
    its predecessors:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使REST简单且与其前身相比独特的主要特性：
- en: '**Client-server based architecture:** This architecture is most essential for
    the modern web to communicate over HTTP. A single client-server may look naive
    initially, but many hybrid architectures are evolving. We will discuss more of
    these shortly.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于客户端-服务器的架构：** 这种架构对于现代Web通过HTTP进行通信至关重要。单个客户端-服务器最初看起来可能很天真，但许多混合架构正在发展。我们将很快讨论更多这些内容。'
- en: '**Stateless:** This is the most important characteristic of a REST service.
    A REST HTTP request consists of all the data needed by the server to understand
    and give back the response. Once a request is served, the server doesn''t remember
    if the request has arrived after a while. So the operation will be a stateless
    one.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态：** 这是REST服务最重要的特点。REST HTTP请求包含服务器理解和返回响应所需的所有数据。一旦请求被处理，服务器就不会记住请求是否在一段时间后到达。因此，操作将是无状态的。'
- en: '**Cacheable**: Many developers think a technology stack is blocking their web
    application or API. But in reality, their architecture is the reason. The database
    can be a potential tuning piece in a web application. In order to scale an application
    well, we need to cache content and deliver it as a response. If the cache is not
    valid, it is our responsibility to bust it. REST services should be properly cached
    for scaling.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可缓存：** 许多开发人员认为技术堆栈阻碍了他们的Web应用程序或API。但实际上，他们的架构才是原因。数据库可以成为Web应用程序中的潜在调优部分。为了很好地扩展应用程序，我们需要缓存内容并将其作为响应交付。如果缓存无效，我们有责任清除它。REST服务应该被适当地缓存以进行扩展。'
- en: '**Scripts on demand:** Have you ever designed a REST service which serves the
    JavaScript files and you execute them on the fly? This code on demand is also
    the main characteristic REST can provide. It is more common to request scripts
    and data from the server.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需脚本：** 您是否曾经设计过一个REST服务，该服务提供JavaScript文件并在运行时执行它们？这种按需代码也是REST可以提供的主要特点。从服务器请求脚本和数据更为常见。'
- en: '**Multiple layered system:** The REST API can be served from multiple servers.
    One server can request the other, and so forth. So when a request comes from the
    client, request and response can be passed between many servers to finally supply
    a response back to the client. This easily implementable multi-layered system
    is always a good strategy for keeping the web application loosely coupled.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多层系统：** REST API可以由多个服务器提供。一个服务器可以请求另一个服务器，依此类推。因此，当客户端发出请求时，请求和响应可以在多个服务器之间传递，最终向客户端提供响应。这种易于实现的多层系统对于保持Web应用程序松散耦合始终是一个良好的策略。'
- en: '**Representation of resources:** The REST API provides the uniform interface
    to talk to. It uses a **Uniform Resource Identifier** (**URI**) to map the resources
    (data). It also has the advantage of requesting a specific data format as the
    response. The Internet Media Type(MIME type) can tell the server that the requested
    resource is of that particular type.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源的表示：** REST API提供了统一的接口进行通信。它使用统一资源标识符（URI）来映射资源（数据）。它还具有请求特定数据格式作为响应的优势。互联网媒体类型（MIME类型）可以告诉服务器请求的资源是特定类型的。'
- en: '**Implementational freedom:** REST is just a mechanism to define your web services.
    It is an architectural style that can be implemented in multiple ways. Because
    of this flexibility, you can create REST services in the way you wish to. Until
    it follows the principles of REST, your server has the freedom to choose the platform
    or technology.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现自由：** REST只是定义Web服务的一种机制。它是一种可以以多种方式实现的架构风格。由于这种灵活性，您可以按照自己的意愿创建REST服务。只要遵循REST的原则，您的服务器就有自由选择平台或技术。'
- en: Thoughtful caching is essential for the REST services to scale.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 周到的缓存对于REST服务的扩展至关重要。
- en: REST verbs and status codes
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST动词和状态码
- en: 'REST verbs specify an action to be performed on a specific resource or a collection
    of resources. When a request is made by the client, it should send this information
    in the HTTP request:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: REST动词指定要在特定资源或资源集合上执行的操作。当客户端发出请求时，应在HTTP请求中发送此信息：
- en: REST verb
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST动词
- en: Header information
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头信息
- en: Body (optional)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正文（可选）
- en: 'As we mentioned previously, REST uses the URI to decode its resource to be
    handled. There are quite a few REST verbs available, but six of them are used
    frequently. They are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，REST使用URI来解码其要处理的资源。有许多REST动词可用，但其中六个经常被使用。它们如下：
- en: '`GET`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`'
- en: '`POST`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`'
- en: '`PUT`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`'
- en: '`PATCH`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`'
- en: '`DELETE`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`'
- en: '`OPTIONS`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`'
- en: 'If you are a software developer, you will be dealing with these six most of
    the time. The following table explains the operation, target resource, and what
    happens if the request succeeds or fails:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是软件开发人员，您将大部分时间处理这六个。以下表格解释了操作、目标资源以及请求成功或失败时会发生什么：
- en: '| **REST Verb** | **Action** | **Success** | **Failure** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **REST动词** | **操作** | **成功** | **失败** |'
- en: '| `GET` | Fetches a record or set of resources from the server | 200 | 404
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 从服务器获取记录或资源集 | 200 | 404 |'
- en: '| `OPTIONS` | Fetches all available REST operations  | 200 | - |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `OPTIONS` | 获取所有可用的REST操作 | 200 | - |'
- en: '| `POST` | Creates a new set of resources or a resource | 201 | 404, 409 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 创建新的资源集或资源 | 201 | 404, 409 |'
- en: '| `PUT` | Updates or replaces the given record | 200, 204 | 404 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 更新或替换给定的记录 | 200, 204 | 404 |'
- en: '| `PATCH` | Modifies the given record | 200, 204 | 404 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 修改给定的记录 | 200, 204 | 404 |'
- en: '| `DELETE` | Deletes the given resource  | 200 | 404 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除给定的资源 | 200 | 404 |'
- en: The numbers in the **Success** and **Failure** columns of the preceding table
    are HTTP status codes. Whenever a client initiates a REST operation, since REST
    is stateless, the client should know a way to find out whether the operation was
    successful or not. For that reason, HTTP has status codes for the response. REST
    defines the preceding status code types for a given operation. This means a REST
    API should strictly follow the preceding rules to achieve client-server communication.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前表中**成功**和**失败**列中的数字是HTTP状态码。每当客户端发起REST操作时，由于REST是无状态的，客户端应该知道如何找出操作是否成功。因此，HTTP为响应定义了状态码。REST为给定操作定义了前面的状态码类型。这意味着REST
    API应严格遵循前面的规则，以实现客户端-服务器通信。
- en: All defined REST services have the following format. It consists of the host
    and API endpoint. The API endpoint is the URL path which is predefined by the
    server. Every REST request should hit that path.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有定义的REST服务都具有以下格式。它由主机和API端点组成。API端点是服务器预定义的URL路径。每个REST请求都应该命中该路径。
- en: A trivial REST API URI: `http://HostName/API endpoint/Query(optional)`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微不足道的REST API URI：`http://HostName/API endpoint/Query(optional)`
- en: Let us look at all the verbs in more detail. The REST API design starts with
    the defining of operations and API endpoints. Before implementing the API, the
    design document should list all the endpoints for the given resources. In the
    following section, we carefully observe the REST API endpoints using PayPal's
    REST API as a use case.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下所有的动词。REST API设计始于操作和API端点的定义。在实现API之前，设计文档应列出给定资源的所有端点。在接下来的部分中，我们将使用PayPal的REST
    API作为一个用例，仔细观察REST API端点。
- en: GET
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET
- en: 'A `GET` method fetches the given resource from the server. To specify a resource,
    `GET` uses a few types of URI queries:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`方法从服务器获取给定的资源。为了指定资源，`GET`使用了几种类型的URI查询：'
- en: Query parameters
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询参数
- en: Path-based parameters
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于路径的参数
- en: In case you didn't know, all of your browsing of the web is done by performing
    a `GET` request to the server. For example, if you type [www.google.com](http://www.google.com),
    you are actually making a `GET` request to fetch the search page. Here, your browser
    is the client and Google's web server is the backend implementer of web services.
    A successful `GET` operation returns a 200 status code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道，你所有的网页浏览都是通过向服务器发出`GET`请求来完成的。例如，如果你输入[www.google.com](http://www.google.com)，你实际上是在发出一个`GET`请求来获取搜索页面。在这里，你的浏览器是客户端，而Google的Web服务器是Web服务的后端实现者。成功的`GET`操作返回一个200状态码。
- en: 'Examples of path parameters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 路径参数的示例：
- en: Everyone knows **PayPal**. PayPal creates billing agreements with companies.
    If you register with PayPal for a payment system, they provide you with a REST
    API for all your billing needs. The sample `GET` request for getting the information
    of a billing agreement looks like this: `/v1/payments/billing-agreements/agreement_id`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都知道**PayPal**。PayPal与公司创建结算协议。如果您向PayPal注册支付系统，他们会为您提供一个REST API，以满足您所有的结算需求。获取结算协议信息的示例`GET`请求如下：`/v1/payments/billing-agreements/agreement_id`。
- en: Here, the resource query is with the path parameter. When the server sees this
    line, it interprets it as *I got an HTTP request with a need for agreement_id
    from the billing agreements*. Then it searches through the database, goes to the
    `billing-agreements` table, and finds an agreement with the given `agreement_id`.
    If that resource exists it sends the details to copy back in response (200 OK).
    Or else it sends a response saying resource not found (404).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，资源查询是通过路径参数进行的。当服务器看到这一行时，它会将其解释为*我收到了一个需要从结算协议中获取agreement_id的HTTP请求*。然后它会在数据库中搜索，转到`billing-agreements`表，并找到一个具有给定`agreement_id`的协议。如果该资源存在，它会发送详细信息以便在响应中复制（200
    OK）。否则，它会发送一个响应，说明资源未找到（404）。
- en: Using `GET`, you can also query a list of resources, instead of a single one
    like the preceding example. PayPal's API for getting billing transactions related
    to an agreement can be fetched with `/v1/payments/billing-agreements/transactions`.
    This line fetches all transactions that occurred on that billing agreement. In
    both, the case's data is retrieved in the form of a JSON response. The response
    format should be designed beforehand so that the client can consume it in the
    agreement.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GET`，你也可以查询资源列表，而不是像前面的例子那样查询单个资源。PayPal的用于获取与协议相关的结算交易的API可以通过`/v1/payments/billing-agreements/transactions`获取。这一行获取了在该结算协议上发生的所有交易。在这两种情况下，数据以JSON响应的形式检索。响应格式应该事先设计好，以便客户端可以在协议中使用它。
- en: 'Examples of query parameters are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数的示例如下：
- en: 'Query parameters are intended to add detailed information to identify a resource
    from the server. For example, take this sample fictitious API. Let us assume this
    API is created for fetching, creating, and updating the details of the book. A
    query parameter based `GET` request will be in this format:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询参数旨在添加详细信息，以从服务器识别资源。例如，以这个虚构的API为例。假设这个API是为了获取、创建和更新书籍的详细信息而创建的。基于查询参数的`GET`请求将采用这种格式：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding URI has few query parameters. The URI is requesting a book from
    the book''s resource that satisfies the following conditions:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的URI有一些查询参数。该URI请求一本满足以下条件的书籍：
- en: It should be a fiction book
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是一本虚构的书
- en: The book should have been published in the year 2017
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这本书应该在2017年出版
- en: '*Get all the fiction books that are released in the year 2017* is the question
    the client is posing to the server.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*获取所有在2017年出版的虚构书籍*是客户端向服务器提出的问题。'
- en: Path vs Query parameters—When to use them? It is a common rule of thumb that
    `Query` parameters are used to fetch multiple resources based on the query parameters.
    If a client needs a single resource with exact URI information, it can use `Path`
    parameters to specify the resource. For example, a user dashboard can be requested
    with `Path` parameters and fetch data on filtering can be modeled with `Query`
    parameters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Path vs Query 参数——何时使用它们？一个常见的经验法则是，`Query` 参数用于基于查询参数获取多个资源。如果客户端需要具有精确 URI
    信息的单个资源，可以使用 `Path` 参数来指定资源。例如，用户仪表板可以使用 `Path` 参数请求，并且可以使用 `Query` 参数对过滤数据进行建模。
- en: Use `Path` parameters for a single resource and `Query` parameters for multiple
    resources in a `GET` request.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GET` 请求中，对于单个资源使用 `Path` 参数，对于多个资源使用 `Query` 参数。
- en: POST, PUT, and PATCH
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST、PUT 和 PATCH
- en: The `POST` method is used to create a resource on the server. In the previous
    book's API, this operation creates a new book with the given details. A successful
    `POST` operation returns a 201 status code. The `POST` request can update multiple
    resources: `/v1/books`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 方法用于在服务器上创建资源。在之前的书籍 API 中，此操作使用给定的详细信息创建新书籍。成功的 `POST` 操作返回 201 状态码。`POST`
    请求可以更新多个资源：`/v1/books`。'
- en: 'The `POST` request has a body like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 请求的主体如下：'
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This actually creates a new book in the database. An ID is assigned to this
    record so that when we `GET` the resource, the URL is created. So `POST` should
    be done only once, in the beginning. In fact, *Lord of the Rings* was published
    in 1955\. So we entered the published date incorrectly. In order to update the
    resource, let us use the `PUT` request.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上在数据库中创建了一本新书。为这条记录分配了一个 ID，以便当我们 `GET` 资源时，URL 被创建。因此，`POST` 应该只在开始时执行一次。事实上，*指环王*
    是在 1955 年出版的。因此我们输入了错误的出版日期。为了更新资源，让我们使用 `PUT` 请求。
- en: 'The `PUT` method is similar to `POST.` It is used to replace the resource that
    already exists. The main difference is that `PUT` is idempotent. A `POST` call
    creates two instances with the same data. But `PUT` updates a single resource
    that already exists:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` 方法类似于 `POST`。它用于替换已经存在的资源。主要区别在于 `PUT` 是幂等的。`POST` 调用会创建两个具有相同数据的实例。但
    `PUT` 会更新已经存在的单个资源：'
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'with body that is JSON like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 带有如下 JSON 主体：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`1256` is the ID of the book. It updates the preceding book by `year:1955`.
    Did you observe the drawback of `PUT`? It actually replaced the entire old record
    with the new one. We needed to change a single column. But `PUT` replaced the
    whole record. That is bad. For this reason, the `PATCH` request was introduced.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`1256` 是书籍的 ID。它通过 `year:1955` 更新了前面的书籍。你注意到 `PUT` 的缺点了吗？它实际上用新的记录替换了整个旧记录。我们只需要更改一个列。但
    `PUT` 替换了整个记录。这很糟糕。因此，引入了 `PATCH` 请求。'
- en: 'The `PATCH` method is similar to `PUT`, except it won''t replace the whole
    record. `PATCH`, as the name suggests, patches the column that is being modified.
    Let us update the book `1256` with a new column called `ISBN`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATCH` 方法类似于 `PUT`，只是它不会替换整个记录。`PATCH`，顾名思义，是对正在修改的列进行修补。让我们使用一个新的列名 `ISBN`
    更新书籍 `1256`：'
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'with the JSON body like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如下的 JSON 主体：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It tells the server, *Search for the book with id 1256\. Then add/modify this
    column with the given value*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉服务器，*搜索 ID 为 1256 的书籍。然后添加/修改此列的给定值*。
- en: '`PUT` and `PATCH` both return the 200 status for success and 404 for not found.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` 和 `PATCH` 都对成功返回 200 状态，对未找到返回 404。'
- en: DELETE and OPTIONS
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DELETE 和 OPTIONS
- en: The `DELETE` API method is used to delete a resource from the database. It is
    similar to `PUT` but without any body. It just needs an ID of the resource to
    be deleted. Once a resource gets deleted, subsequent `GET` requests return a 404
    not found status.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE` API 方法用于从数据库中删除资源。它类似于 `PUT`，但没有任何主体。它只需要资源的 ID 来删除。一旦资源被删除，后续的 `GET`
    请求会返回 404 未找到状态。'
- en: Responses to this method are *not cacheable* (in case caching is implemented)
    because the `DELETE` method is idempotent.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对这种方法的响应*不可缓存*（如果实现了缓存），因为 `DELETE` 方法是幂等的。
- en: The `OPTIONS` API method is the most underrated in the API development. Given
    the resource, this method tries to know all possible methods (`GET`, `POST`, and
    so on) defined on the server. It is like looking at the menu card at a restaurant
    and then ordering an item which is available (whereas if you randomly order a
    dish, the waiter will tell you it is not available). It is best practice to implement
    the `OPTIONS` method on the server. From the client, make sure `OPTIONS` is called
    first, and if the method is available, then proceed with it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPTIONS` API 方法是 API 开发中最被低估的。给定资源，该方法尝试了解服务器上定义的所有可能的方法（`GET`、`POST`等）。这就像在餐厅看菜单然后点菜一样（而如果你随机点一道菜，服务员会告诉你这道菜没有了）。在服务器上实现
    `OPTIONS` 方法是最佳实践。从客户端确保首先调用 `OPTIONS`，如果该方法可用，然后继续进行。'
- en: Cross-Origin Resource Sharing (CORS)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨域资源共享（CORS）
- en: The most important application of this `OPTIONS` method is **Cross-Origin Resource
    Sharing** (**CORS**). Initially, browser security prevented the client from making
    cross-origin requests. It means a site loaded with the URL [www.foo.com](http://www.foo.com)
    can only make API calls to that host. If the client code needs to request files
    or data from [www.bar.com](http://www.bar.com), then the second server, [bar.com,](https://bar.com/)
    should have a mechanism to recognize [foo.com](http://foo.com) to get its resources.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `OPTIONS` 方法最重要的应用是**跨域资源共享**（**CORS**）。最初，浏览器安全性阻止客户端进行跨域请求。这意味着使用 URL [www.foo.com](http://www.foo.com)
    加载的站点只能对该主机进行 API 调用。如果客户端代码需要从 [www.bar.com](http://www.bar.com) 请求文件或数据，那么第二个服务器
    [bar.com](https://bar.com/) 应该有一种机制来识别 [foo.com](http://foo.com) 以获取其资源。
- en: 'This process explains the CORS:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程解释了 CORS：
- en: '[foo.com](http://foo.com) requests the `OPTIONS` method on [bar.com](http://bar.com).'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[foo.com](http://foo.com) 在 [bar.com](http://bar.com) 上请求 `OPTIONS` 方法。'
- en: '[bar.com](http://bar.com) sends a header like `Access-Control-Allow-Origin:
    http://foo.com` in response to the client.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[bar.com](http://bar.com) 在响应客户端时发送了一个头部，如 `Access-Control-Allow-Origin: http://foo.com`。'
- en: Next, [foo.com](http://foo.com) can access the resources on [bar.com](https://bar.com/)
    without any restrictions that call any `REST` method.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，[foo.com](http://foo.com)可以访问[bar.com](https://bar.com/)上的资源，而不受任何限制，调用任何`REST`方法。
- en: If [bar.com](http://bar.com) feels like supplying resources to any host after
    one initial request, it can set Access control to * (that is, any).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[bar.com](http://bar.com)感觉在一次初始请求后向任何主机提供资源，它可以将访问控制设置为*（即任何）。
- en: 'The following is the diagram depicting the process happening one after the
    other:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是描述依次发生的过程的图表：
- en: '![](img/32a06a64-3c6b-4f5d-90da-8c4745a520a1.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32a06a64-3c6b-4f5d-90da-8c4745a520a1.png)'
- en: Types of status codes
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态代码的类型
- en: There are a few families of status codes. Each family globally explains an operation
    status. Each member of that family may have a deeper meeting. So a REST API should
    strictly tell the client what exactly happened after the operation. There are
    60+ status codes available. But for REST, we concentrate on a few families of
    codes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个状态代码家族。每个家族都全局解释了一个操作状态。该家族的每个成员可能有更深层的含义。因此，REST API 应该严格告诉客户端操作后到底发生了什么。有60多种状态代码可用。但对于REST，我们集中在几个代码家族上。
- en: 2xx family (successful)
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2xx家族（成功）
- en: '200 and 201 fall under the success family. They indicate that an operation
    was successful. Plain **200** (**Operation Successful**) is a successful CRUD
    Operation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 200和201属于成功家族。它们表示操作成功。纯**200**（**操作成功**）是成功的CRUD操作：
- en: '**200** (**Successful Operation**) is the most common type of response status
    code in REST'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**200**（**操作成功**）是REST中最常见的响应状态代码'
- en: '**201** (**Successfully Created**)is returned when a `POST` operation successfully
    creates a resource on the server'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**201**（**创建成功**）当`POST`操作成功在服务器上创建资源时返回'
- en: '**204** (**No content**) is issued when a client needs a status but not any
    data back'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**204**（**无内容**）在客户端需要状态但不需要任何数据时发出'
- en: 3xx family (redirection)
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3xx家族（重定向）
- en: 'These status codes are used to convey redirection messages. The most important
    ones are **301** and **304**:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态代码用于传达重定向消息。最重要的是**301**和**304**：
- en: '**301** is issued when a resource is moved permanently to a new URL endpoint.
    It is essential when an old API is deprecated. It returns the new endpoint in
    the response with the 301 status. By seeing that, the client should use the new
    URL in response to achieving its target.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**301**在资源永久移动到新的URL端点时发出。当旧的API被弃用时，这是必不可少的。它返回响应中的新端点和301状态。通过查看这一点，客户端应该使用新的URL以响应实现其目标。'
- en: The **304** status code indicates that content is cached and no modification
    happened for the resource on the server. This helps in caching content at the
    client and only requests data when the cache is modified.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**304**状态代码表示内容已缓存，并且服务器上的资源未发生修改。这有助于在客户端缓存内容，并且仅在缓存被修改时请求数据。'
- en: 4xx family (client error)
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4xx家族（客户端错误）
- en: 'These are the standard error status codes which the client needs to interpret
    and handle further actions. These have nothing to do with the server. A wrong
    request format or ill-formed REST method can cause these errors. Of these, the
    most frequent status codes API developers use are **400**, **401**, **403**, **404**,
    and **405**:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是客户端需要解释和处理进一步操作的标准错误状态代码。这与服务器无关。错误的请求格式或格式不正确的REST方法可能会导致这些错误。其中，API开发人员最常用的状态代码是**400**、**401**、**403**、**404**和**405**：
- en: '**400** (**Bad Request**) is returned when the server cannot understand the
    client request.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**400**（**错误请求**）当服务器无法理解客户端请求时返回。'
- en: '**401** (**Unauthorized**) is returned when the client is not sending the authorization
    information in the header.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**401**（**未经授权**）当客户端未在标头中发送授权信息时返回。'
- en: '**403** (**Forbidden**) is returned when the client has no access to a certain
    type of resources.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**403**（**禁止**）当客户端无法访问某种类型的资源时返回。'
- en: '**404** (**Not Found**) is returned when the client request is on a resource
    that is nonexisting.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**404**（**未找到**）当客户端请求的资源不存在时返回。'
- en: '**405** (**Method Not Allowed**) is returned if the server bans a few methods
    on resources. `GET` and `HEAD` are exceptions.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**405**（**方法不允许**）如果服务器禁止资源上的一些方法，则返回。`GET`和`HEAD`是例外。'
- en: 5xx family (server error)
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5xx家族（服务器错误）
- en: 'These are the errors from the server. The client request may be perfect, but
    due to a bug in the server code, these errors can arise. The commonly used status
    codes are **500**, **501**, **502**, **503**,  and **504**:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是来自服务器的错误。客户端请求可能是完美的，但由于服务器代码中的错误，这些错误可能会出现。常用的状态代码有**500**、**501**、**502**、**503**和**504**：
- en: '**500** (**Internal Server Error**) status code gives the development error
    which is caused by some buggy code or some unexpected condition'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**500**（**内部服务器错误**）状态代码给出了由一些错误的代码或一些意外条件引起的开发错误'
- en: '**501** (**Not Implemented**) is returned when the server is no longer supporting
    the method on a resource'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**501**（**未实现**）当服务器不再支持资源上的方法时返回'
- en: '**502** (**Bad Gateway**) is returned when the server itself got an error response
    from another service vendor'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**502**（**错误网关**）当服务器本身从另一个服务供应商那里收到错误响应时返回'
- en: '**503** (**Service Unavailable**) is returned when the server is down due to
    multiple reasons, like a heavy load or for maintenance'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**503**（**服务不可用**）当服务器由于多种原因而关闭，如负载过重或维护时返回'
- en: '**504** (**Gateway Timeout**) is returned when the server is waiting a long
    time for a response from another vendor and is taking too much time to serve the
    client'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**504**（**网关超时**）当服务器等待另一个供应商的响应时间过长，并且为客户端提供服务的时间太长时返回'
- en: For more details on status codes, visit this link: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有关状态代码的更多详细信息，请访问此链接：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
- en: Rise of REST API with Single Page Applications
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API与单页应用的崛起
- en: You need to understand why **Single Page Applications **(**SPA**) are the hot
    topic today. Instead of building the UI in a traditional way (request web pages),
    these SPA designs make developers write code in a totally different way. There
    are many MVC frameworks, like AngularJS, Angular2, React JS, Knockout JS, Aurelia,
    and so on, to develop web UIs rapidly, but the essence of each of them is pretty
    simple. All MVC frameworks help us to implement one design pattern. That design
    pattern is *No requesting of web pages, only REST API.*
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要了解为什么**单页应用程序**（**SPA**）是当今的热门话题。这些SPA设计使开发人员以一种完全不同的方式编写代码，而不是以传统方式构建UI（请求网页）。有许多MVC框架，如AngularJS、Angular2、React
    JS、Knockout JS、Aurelia等，可以快速开发Web UI，但它们的本质都非常简单。所有MVC框架都帮助我们实现一种设计模式。这种设计模式是*不请求网页，只使用REST
    API*。
- en: The modern web frontend development has advanced a lot since 2010\. In order
    to exploit the features of** Model-View-Controller** (**MVC**) architecture, we
    need to consider the frontend as a separate entity which talks to the backend
    only using the REST API (most preferably, REST JSON).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 自2010年以来，现代Web前端开发已经取得了很大进步。为了利用**Model-View-Controller**（**MVC**）架构的特性，我们需要将前端视为一个独立的实体，只使用REST
    API（最好是REST JSON）与后端进行通信。
- en: Old and new ways of data flow in SPA
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPA中的旧和新数据流的方式
- en: 'All websites go through the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有网站都经历以下步骤：
- en: Request a web page from the server.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从服务器请求网页。
- en: Authenticate and show the Dashboard UI.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证并显示仪表板UI。
- en: Allow the user to modify and save.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户进行修改和保存。
- en: Request as many web pages from the server as needed to show individual pages
    on the site.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要从服务器请求尽可能多的网页，以在站点上显示单独的页面。
- en: 'But in the SPA, the flow is quite different:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 但在SPA中，流程完全不同：
- en: Request the HTML template/s to the browser in one single go.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一次性向浏览器请求HTML模板。
- en: Then, query the JSON REST API to fill a model (data object).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，查询JSON REST API以填充模型（数据对象）。
- en: Adjust the UI according to the data in the model (JSON).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据模型（JSON）中的数据调整UI。
- en: When users modify the UI, the model (data object) should change automatically.
    For example, in AngularJS, it is possible with two-way data binding. Finally,
    make REST API calls to notify the server about changes whenever you want.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户修改UI时，模型（数据对象）应该自动更改。例如，在AngularJS中，可以通过双向数据绑定实现。最后，可以随时进行REST API调用，通知服务器进行更改。
- en: 'In this way, communication happens only in the form of the REST API. The client
    takes care of logically representing the data. This causes systems to move from
    **Response Oriented Architecture** (**ROA**) to **Service Oriented Architecture**
    (**SOA**). Take a look at the following diagram:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，通信只以REST API的形式进行。客户端负责逻辑地表示数据。这导致系统从**响应导向架构**（**ROA**）转移到**服务导向架构**（**SOA**）。请看下面的图表：
- en: '![](img/19a08895-c507-4a77-b9f1-830361ac0668.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19a08895-c507-4a77-b9f1-830361ac0668.jpeg)'
- en: SPA reduces the bandwidth and improves the site performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: SPA减少了带宽，并提高了站点的性能。
- en: Why Go for REST API development?
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Go进行REST API开发？
- en: REST services are trivial in the modern web. SOA (which we discuss in more detail
    later) created an activity space for REST services to take web development to
    the next level. **Go** is a programming language from the house of Google for
    solving the bigger problems they have. It has been eight-plus years since its
    first appearance. It matured along the way with a developer community jumping
    in and creating huge scale systems in it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务在现代网络中是微不足道的。SOA（我们稍后会更详细地讨论）为REST服务创造了一个活动空间，将Web开发推向了一个新的水平。**Go**是谷歌公司推出的一种编程语言，用于解决他们所面临的更大的问题。自首次出现以来已经过去了八年多。它随着开发者社区的加入而不断成熟，并在其中创建了大规模的系统。
- en: Go is the darling of the web. It solves bigger problems in an easy way.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Go是Web的宠儿。它以一种简单的方式解决了更大的问题。
- en: 'One can choose Python or JavaScript (Node) for their REST API development.
    The main advantage of Go lies in its speed and compile-time error detection. Go
    is proved to be faster than dynamic programming languages in terms of computational
    performance by various benchmarks. These are the three reasons why a company should
    write their next API in Go:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可以选择Python或JavaScript（Node）进行REST API开发。Go的主要优势在于其速度和编译时错误检测。通过各种基准测试，Go被证明在计算性能方面比动态编程语言更快。这就是公司应该使用Go编写其下一个API的三个原因：
- en: To scale your API for a wider audience
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了扩展API以吸引更广泛的受众
- en: To enable your developers to build robust systems
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使您的开发人员能够构建健壮的系统
- en: To invest in the future viability of your projects
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了投资未来项目的可行性
- en: You can look at the neverending online debates for more information about REST
    services with Go. In later chapters, we try to build the fundamentals of designing
    and writing the REST services.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看关于Go的REST服务的不断进行的在线辩论以获取更多信息。在后面的章节中，我们将尝试构建设计和编写REST服务的基础知识。
- en: Setting up the project and running the development server
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目并运行开发服务器
- en: This is a building series book. It assumes you already know the basics of Go.
    If not, no worries. You can jump start and learn them quickly from Go's official
    site at [https://golang.org/](https://golang.org/). Go uses a different way of
    developing projects. Writing a standalone, simple program doesn't bother you much.
    But after learning the basics, people try to advance a step further. For that
    reason, as a Go developer, you should know how Go projects are laid out and the
    best practices to keep your code clean.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本系列构建的书。它假设您已经了解Go的基础知识。如果没有，也没关系。您可以从Go的官方网站[https://golang.org/](https://golang.org/)快速入门并快速学习。Go使用一种不同的开发项目的方式。编写一个独立的简单程序不会让您感到困扰。但是在学习了基础知识之后，人们会尝试进一步发展。因此，作为Go开发人员，您应该了解Go项目的布局方式以及保持代码清晰的最佳实践。
- en: 'Make sure you have done the following things before proceeding:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保已完成以下工作：
- en: Install Go compiler on your machine
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的计算机上安装Go编译器
- en: Set `GOROOT` and `GOPATH` environment variables
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`GOROOT`和`GOPATH`环境变量
- en: There are many online references from which you can get to know the preceding
    details. Depending on your machine type (Windows, Linux, or macOS X), set up a
    working Go compiler. We see more details about `GOPATH` in the following section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多在线参考资料可以了解到前面的细节。根据你的机器类型（Windows、Linux或macOS X），设置一个可用的Go编译器。我们将在下一节中看到有关`GOPATH`的更多细节。
- en: Demystifying GOPATH
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密GOPATH
- en: '`GOPATH` is nothing but the current appointed workspace on your machine. It
    is an environment variable that tells the Go compiler about where your source
    code, binaries, and packages are placed.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOPATH`只是你的机器上当前指定的工作空间。它是一个环境变量，告诉Go编译器你的源代码、二进制文件和包的位置。'
- en: The programmers coming from a Python background may know the Virtualenv tool
    to create multiple projects (with different Python interpreter versions) at the
    same time. But at a given time, one activates the environment and develops his
    project. Similarly,  you can have any number of Go projects on your machine. While
    developing, set the `GOPATH` to one of your projects. The Go compiler now activates
    that project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Python背景的程序员可能知道Virtualenv工具，可以同时创建多个项目（使用不同的Python解释器版本）。但在某个时间点，只能激活一个环境并开发自己的项目。同样，你可以在你的机器上有任意数量的Go项目。在开发时，将`GOPATH`设置为你的一个项目。Go编译器现在激活了该项目。
- en: 'It is a common practice to create a project under the home directory and set
    the `GOPATH` environment variable like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在家目录下创建一个项目并设置`GOPATH`环境变量是一种常见的做法，就像这样：
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we install external packages like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们这样安装外部包：
- en: '[PRE8]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Go copies the project called `mux` into the currently activated project `myproject`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Go将名为`mux`的项目复制到当前激活的项目`myproject`中。
- en: For Go get, use the `-u` flag to install updated dependencies of the external
    package and `-v` to see the verbose details of installation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Go get，使用`-u`标志来安装外部包的更新依赖项，使用`-v`来查看安装的详细信息。
- en: 'A typical Go project has the following structure, as mentioned on the official
    Go website:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Go项目具有以下结构，正如官方Go网站上所述：
- en: '![](img/b5ae002f-d91f-4d0f-bbb0-e5b366ae3876.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5ae002f-d91f-4d0f-bbb0-e5b366ae3876.png)'
- en: 'Let us understand this structure before digging further:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在深入研究之前先了解这个结构：
- en: '`bin`: Stores the binary of our project; a shippable binary which can be run
    directly'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin`：存储我们项目的可运行二进制文件'
- en: '`pkg`: Contains the package objects; a compiled program which supplies package
    methods'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg`：包含包对象的目录；一个提供包方法的编译程序'
- en: '`src`: The place for your project source code, tests, and user packages'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：项目源代码、测试和用户包的位置'
- en: In Go, all the packages which you import into your main program have an identical
    structure, `github.com/user/project`. But who creates all these directories? Should
    the developer do that? Nope. It is the developer's responsibility to create directories
    for his/her project. It means he/she only creates the directory `src/github.com/user/hello`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，你导入到你的主程序中的所有包都有一个相同的结构，`github.com/user/project`。但是谁创建所有这些目录？开发者需要做吗？不需要。开发者的责任是为他/她的项目创建目录。这意味着他/她只创建`src/github.com/user/hello`目录。
- en: 'When a developer runs the following command, the directories bin and package
    are created if they did not exist before. `.bin` consists of the binary of our
    project source code and `.pkg` consists of all internal and external packages
    we use in our Go programs:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者运行以下命令时，如果之前不存在，将创建`bin`和`package`目录。`.bin`包含我们项目源代码的二进制文件，`.pkg`包含我们在Go程序中使用的所有内部和外部包：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Building our first service – finding the Roman numeral
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个服务-查找罗马数字
- en: With the concepts we have built upto now, let us write our first basic REST
    service. This service takes the number range (1-10) from the client and returns
    its Roman string. Very primitive, but better than Hello World.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们到目前为止建立的概念，让我们编写我们的第一个基本REST服务。这个服务从客户端获取数字范围（1-10），并返回其罗马字符串。非常原始，但比Hello
    World好。
- en: '**Design:**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计：**'
- en: Our REST API should take an integer number from the client and serve back the
    Roman equivalent.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的REST API应该从客户端获取一个整数，并返回罗马数字等价物。
- en: 'The block of the API design document may look like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: API设计文档的块可能是这样的：
- en: '| **HTTP Verb** | **PATH** | **Action** | **Resource** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **路径** | **操作** | **资源** |'
- en: '| `GET` | `/roman_number/2` | show | `roman_number` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/roman_number/2` | 显示 | `roman_number` |'
- en: '**Implementation:**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**实施：**'
- en: Now we are going to implement the preceding simple API step-by-step.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将逐步实现前面的简单API。
- en: Code for this project is available at [https://github.com/narenaryan/gorestful](https://github.com/narenaryan/gorestful).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的代码可在[https://github.com/narenaryan/gorestful](https://github.com/narenaryan/gorestful)上找到。
- en: 'As we previously discussed, you should set the `GOPATH` first. Let us assume
    the `GOPATH` is `/home/naren/go`. Create a directory called `romanserver` in the
    following path. Replace *narenaryan* with your GitHub username (this is just a
    namespace for the code belonging to different users):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，你应该首先设置`GOPATH`。假设`GOPATH`是`/home/naren/go`。在以下路径中创建一个名为`romanserver`的目录。用你的GitHub用户名替换*narenaryan*（这只是属于不同用户的代码的命名空间）：
- en: '[PRE10]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our project is ready. We don''t have any database configured yet. Create an
    empty file called `main.go`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目已经准备好了。我们还没有配置任何数据库。创建一个名为`main.go`的空文件：
- en: '[PRE11]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our main logic for the API server goes into this file. For now, we can create
    a data file which works as a data service for our main program. Create one more
    directory for packaging the Roman numeral data:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API服务器的主要逻辑放在这个文件中。现在，我们可以创建一个作为我们主程序的数据服务的数据文件。再创建一个目录来打包罗马数字数据：
- en: '[PRE12]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, create an empty file called `data.go` in the `romanNumerals` directory.
     The `src` directory structure so far looks like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`romanNumerals`目录中创建一个名为`data.go`的空文件。到目前为止，`src`目录结构看起来是这样的：
- en: ;![](img/5d36f6b4-c619-4e06-8ddd-9374c32ac864.png)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/5d36f6b4-c619-4e06-8ddd-9374c32ac864.png)'
- en: 'Now let us start adding code to the files. Create data for the Roman numerals:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始向文件添加代码。为罗马数字创建数据：
- en: '[PRE13]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are creating a map called **Numerals**. This map holds information for converting
    a given integer to its Roman equivalent. We are going to import this variable
    into our main program to serve the request from the client.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个名为**Numerals**的映射。这个映射保存了将给定整数转换为其罗马等价物的信息。我们将把这个变量导入到我们的主程序中，以便为客户端的请求提供服务。
- en: 'Open `main.go` and add the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`main.go`并添加以下代码：
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Always use the Go fmt tool to format your Go code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用Go fmt工具格式化你的Go代码。
- en: Usage example: `go fmt github.com/narenaryan/romanserver`
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 用法示例：`go fmt github.com/narenaryan/romanserver`
- en: 'Now, install this project with the Go command `install`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Go命令`install`安装这个项目：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This step does two things:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步做了两件事：
- en: Compiles the package `romanNumerals` and places a copy in the `$GOPATH/pkg`
    directory
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译包`romanNumerals`并将副本放在`$GOPATH/pkg`目录中
- en: Places a binary in the `$GOPATH/bin`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制文件放入`$GOPATH/bin`
- en: 'We can run the preceding API server as this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样运行前面的API服务器：
- en: '[PRE16]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The server is up and running on `http://localhost:8000`. Now we can make a `GET`
    request to the API using a client like `Browser` or the `CURL` command. Let us
    fire a `CURL` command with a proper API `GET` request.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器正在`http://localhost:8000`上运行。现在我们可以使用像`浏览器`或`CURL`命令这样的客户端发出`GET`请求到API。让我们用一个合适的API`GET`请求来发出一个`CURL`命令。
- en: 'Request one is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请求一如下：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The response is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 响应如下：
- en: '[PRE18]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let us try a few incorrectly formed requests.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些格式不正确的请求。
- en: 'Request two is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请求二如下：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The response is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 响应如下：
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Request three is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请求三如下：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The response is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 响应如下：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our little Roman numerals API is doing the right thing. The right status codes
    are being returned. That is the point all API developers should keep in mind.
    The client should be informed why something went wrong.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小罗马数字API正在做正确的事情。正确的状态码正在被返回。这是所有API开发者应该牢记的要点。客户端应该被告知为什么出了问题。
- en: Breaking down the code
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码分解
- en: 'We just updated the empty files in one single go and started running the server.
    Let me now explain each and every piece of the file `main.go`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一次性更新了空文件并启动了服务器。现在让我解释一下`main.go`文件的每一部分：
- en: Imported a few packages. `github.com/narenaryan/romanNumerals` is the data service
    we created before.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入了一些包。`github.com/narenaryan/romanNumerals`是我们之前创建的数据服务。
- en: '`net/http` is the core package we used to handle an HTTP request through its
    `HandleFunc` function. That function''s arguments are `http.Request` and `http.ResponseWriter`.
    Those two deal with the request and response of an HTTP request.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http`是我们用来处理HTTP请求的核心包，通过它的`HandleFunc`函数。该函数的参数是`http.Request`和`http.ResponseWriter`。这两个处理HTTP请求的请求和响应。'
- en: '`r.URL.Path` is the URL path of the HTTP request. For the CURL Request one, it
    is `/roman_number/5`*.* We are splitting this path and using the second argument
    as a resource and the third argument as a value to get the Roman numeral. The `Split`
    function is in a core package called `strings`.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r.URL.Path`是HTTP请求的URL路径。对于CURL请求，它是`/roman_number/5`。我们正在拆分这个路径，并使用第二个参数作为资源，第三个参数作为值来获取罗马数字。`Split`函数在一个名为`strings`的核心包中。'
- en: The `Atoi` function converts an alphanumeric string to an integer. For the numerals
    map to consume, we need to convert the integer string to an integer. The `Atoi`
    function comes from a core package called `strconv`.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Atoi`函数将字母数字字符串转换为整数。为了使用数字映射，我们需要将整数字符串转换为整数。`Atoi`函数来自一个名为`strconv`的核心包。'
- en: We use `http.StatusXXX` to set the status code of the response header. The `WriteHeader`
    and `Write` functions are available on the response object for writing the header
    and body, respectively.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`http.StatusXXX`来设置响应头的状态码。`WriteHeader`和`Write`函数可用于在响应对象上分别写入头部和正文。
- en: Next, we created an HTTP server using `&http` while initializing a few parameters
    like address, port, timeout, and so on.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`&http`创建了一个HTTP服务器，同时初始化了一些参数，如地址、端口、超时等。
- en: The `time` package is used to define seconds in the program. It says, after
    10 seconds of inactivity, automatically return a 408 request timeout back to the
    client.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`包用于在程序中定义秒。它说，在10秒的不活动后，自动向客户端返回408请求超时。'
- en: '`EscapeString` escapes special characters to become valid HTML characters.
    For example, Fran & Freddie''s becomes `Fran &amp; Freddie''s&#34`.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EscapeString`将特殊字符转义为有效的HTML字符。例如，Fran & Freddie''s变成了`Fran &amp; Freddie''s&#34`。'
- en: Finally, start the server with the****  `ListenAndServe`**** function. It keeps
    your web server running until you kill it.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用`ListenAndServe`函数启动服务器。它会一直运行你的Web服务器，直到你关闭它。
- en: One should write unit tests for their API. In the upcoming chapters, we will
    see how to test an API end to end.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 应该为API编写单元测试。在接下来的章节中，我们将看到如何对API进行端到端测试。
- en: Live reloading the application with supervisord and Gulp
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用supervisord和Gulp实时重新加载应用程序
- en: Gulp is a nice tool for creating workflows. A workflow is a step-by-step process.
    It is nothing but a task streamlining application. You need NPM and Node installed
    on your machine. We use Gulp to watch the files and then update the binary and
    restart the API server. Sounds cool, right?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp是一个用于创建工作流的好工具。工作流是一个逐步的过程。它只是一个任务流程应用程序。你需要在你的机器上安装NPM和Node。我们使用Gulp来监视文件，然后更新二进制文件并重新启动API服务器。听起来很酷，对吧？
- en: The supervisor is an application to reload your server whenever the application
    gets killed. A process ID will be assigned to your server. To restart the app
    properly, we need to kill the existing instances and restart the application.
    We can write one such program in Go. But in order to not reinvent the wheel, we
    are using a popular program called supervisord.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 监督程序是一个在应用程序被杀死时重新加载服务器的应用程序。一个进程ID将被分配给你的服务器。为了正确重新启动应用程序，我们需要杀死现有的实例并重新启动应用程序。我们可以用Go编写一个这样的程序。但为了不重复造轮子，我们使用一个叫做supervisord的流行程序。
- en: Monitoring your Go web server with supervisord
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用supervisord监控你的Go Web服务器
- en: Sometimes your web application may stop due to operating system restarts or
    crashes. Whenever your web server gets killed, it is supervisor's job to bring
    it back to life. Even the system restart cannot take your web server away from
    the customers. So, strictly use supervisord for your app monitoring.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您的Web应用程序可能会因操作系统重新启动或崩溃而停止。每当您的Web服务器被终止时，supervisor的工作就是将其重新启动。即使系统重新启动也无法将您的Web服务器从客户端中移除。因此，请严格使用supervisord来监控您的应用程序。
- en: Installing supervisord
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装supervisord
- en: 'We can easily install supervisord on Ubuntu 16.04, with the `apt-get` command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`apt-get`命令在Ubuntu 16.04上轻松安装supervisord：
- en: '[PRE23]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This installs two tools, `supervisor` and `supervisorctl`. `supervisorctl` is
    intended to control the supervisord and add tasks, restart tasks, and so on.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装两个工具，`supervisor`和`supervisorctl`。`supervisorctl`用于控制supervisord并添加任务，重新启动任务等。
- en: 'On macOS X, we can install `supervisor` using the `brew` command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS X上，我们可以使用`brew`命令安装`supervisor`：
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, create a configuration file at:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在以下位置创建一个配置文件：
- en: '[PRE25]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can add any number of configuration files, and supervisord treats them
    as separate processes to run. Add the following content to the preceding file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加任意数量的配置文件，supervisord将它们视为独立的进程来运行。将以下内容添加到之前的文件中：
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By default, we have a file called `.supervisord.conf` at `/etc/supervisor/`.
    Look at it for more reference. In macOS X, the same file will be located at `/usr/local/etc/supervisord.ini`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们在`/etc/supervisor/`目录下有一个名为`.supervisord.conf`的文件。查看它以获取更多参考信息。在macOS
    X中，相同的文件将位于`/usr/local/etc/supervisord.ini`。
- en: 'Coming to the preceding configuration:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 关于之前的配置：
- en: The `[supervisord]` section tells the location of the log file for supervisord
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[supervisord]`部分告诉supervisord的日志文件位置'
- en: '**`[program:myserver]`** is the task block which traverses to the given directory
    and executes the command given'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`[program:myserver]`**是任务块，它遍历到给定目录并执行给定的命令'
- en: 'Now we can ask our `supervisorctl` to re-read the configuration and restart
    the tasks (process). For that, just say:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以要求我们的`supervisorctl`重新读取配置并重新启动任务（进程）。只需说：
- en: '`supervisorctl reread`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`supervisorctl reread`'
- en: '`supervisorctl update`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`supervisorctl update`'
- en: 'Then, launch `supervisorctl` with the command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令启动`supervisorctl`：
- en: '[PRE28]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will see something like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似于这样的内容：
- en: '`supervisorctl` is a great tool for controlling supervisor programs.![](img/0719632a-e003-4969-8db2-ab30fffaa133.png)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`supervisorctl`是一个用于控制supervisor程序的强大工具。![](img/0719632a-e003-4969-8db2-ab30fffaa133.png)'
- en: Since we named our romanserver `myserver` in the supervisor configuration file,
    we can start, stop, and restart that program from `supervisorctl`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在supervisor配置文件中将我们的romanserver命名为`myserver`，我们可以从`supervisorctl`启动，停止和重新启动该程序。
- en: Using Gulp for creating auto code compiling and server reloading
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gulp创建自动代码编译和服务器重新加载
- en: With the little introduction we gave about Gulp in the preceding section, we
    are going to write a gulpfile for telling the computer to execute a few tasks.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的章节中对Gulp进行了简要介绍，我们将编写一个gulpfile来告诉计算机执行一些任务。
- en: I install Gulp and Gulp-shell using `npm`**:**
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`npm`安装Gulp和Gulp-shell：
- en: '[PRE29]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After this, create a `gulpfile.js` in the root directory of the project. Here,
    it is `github.com/src/narenaryan/romanserver`. Now add this content to `gulpfile.js`.
    First, whenever a file changes, install binary task gets executed. Then, the supervisor
    will be restarted. The watch task looks for any file change and executes the preceding
    tasks. We are also ordering the tasks so that they occur one after the other synchronously.
    All of these tasks are Gulp tasks and can be defined by the `gulp.task` function.
    It takes two arguments with task name, task. `sell.task` allows Gulp to execute
    system commands:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在项目的根目录中创建一个`gulpfile.js`。这里是`github.com/src/narenaryan/romanserver`。现在将以下内容添加到`gulpfile.js`。首先，每当文件更改时，将执行安装二进制任务。然后，supervisor将被重新启动。监视任务会查找任何文件更改并执行之前的任务。我们还对任务进行排序，以便它们按顺序同步执行。所有这些任务都是Gulp任务，并且可以通过`gulp.task`函数定义。它接受两个参数，任务名称和任务。`sell.task`允许Gulp执行系统命令：
- en: '[PRE30]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, if you run the  `gulp` command in the `source` directory, it starts watching
    your source code changes:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果在`source`目录中运行`gulp`命令，它将开始监视您的源代码更改：
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, if we modify the code, then the code is compiled, installed, and the server
    restarted in a flash:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们修改了代码，那么代码会被编译，安装，并且服务器会立即重新启动：
- en: '![](img/b381310c-588c-4a06-af59-74a57019858f.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b381310c-588c-4a06-af59-74a57019858f.png)'
- en: Understanding the gulpfile
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解gulpfile
- en: 'In the gulpfile, we are performing the following instructions:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在gulpfile中，我们执行以下指令：
- en: Import Gulp and Gulp-shell.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入Gulp和Gulp-shell。
- en: Create tasks with `shell.task` as the function to execute.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shell.task`创建任务作为执行函数。
- en: '`shell.task` can execute a command-line instruction. Keep your shell commands
    inside that function.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shell.task`可以执行命令行指令。将你的shell命令放在该函数内。'
- en: Add a watch task for watching source files. The task list will be executed when
    files are modified.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为监视源文件添加一个监视任务。当文件被修改时，任务列表将被执行。
- en: Create a default task for running. Add a watch to it.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为运行创建一个默认任务。为其添加一个监视。
- en: Gulp is a great tool for these kinds of use cases. So, please go through the
    official documentation of Gulp at [http://gulpjs.com/](http://gulpjs.com/).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp是这类用例的绝佳工具。因此，请仔细阅读Gulp的官方文档[http://gulpjs.com/](http://gulpjs.com/)。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we gave an introduction to the REST API. We saw that REST is
    not a protocol, but an architectural pattern. HTTP is the actual protocol on which
    we can implement our REST service. We jumped into the fundamentals of the REST
    API to be clear about what they actually are. Then we explored types of web services.
    Before REST, we have something called SOAP, which uses XML as the data format.
    REST operates on JSON as the primary format. REST has verbs and status codes.
    We saw what a given status code refers to. We built a simple service which serves
    the Roman numerals for given numbers. In this process, we also saw how to package
    a Go project. We understood the GOPATH environment variable. It is a workspace
    defining a variable in Go. All packages and projects reside in that path. We then
    saw how to reload a development project on the fly with the help of supervisord
    and Gulp. These are node tools but can help us to keep our Go project up and running.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了REST API。我们看到REST不是一个协议，而是一种架构模式。HTTP是我们可以实现REST服务的实际协议。我们深入了解了REST
    API的基本原理，以便清楚地了解它们实际上是什么。然后我们探讨了Web服务的类型。在REST之前，我们有一个叫做SOAP的东西，它使用XML作为数据格式。REST使用JSON作为主要格式。REST有动词和状态码。我们了解了给定状态码指的是什么。我们构建了一个简单的服务，为给定的数字提供罗马数字。在这个过程中，我们还看到了如何打包一个Go项目。我们了解了GOPATH环境变量。它是Go中定义变量的工作空间。所有的包和项目都驻留在这个路径中。然后我们看到了如何使用supervisord和Gulp来实时重新加载开发项目。这些都是Node工具，但可以帮助我们保持我们的Go项目正常运行。
- en: In the next chapter, we dig deeper into URL routing. Starting from the built-in
    router, we explore Gorilla Mux, a powerful URL routing library.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究URL路由。从内置路由器开始，我们将探索Gorilla Mux，一个强大的URL路由库。
