["```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc main() {\n    numGenerator := generator()\n    for i := 0; i < 5; i++ {\n        fmt.Print(numGenerator(), \"\\t\")\n    }\n}\n// This function returns another function\nfunc generator() func() int {\n    var i = 0\n    return func() int {\n        i++\n        return i\n    }\n}\n```", "```go\ngo run closure.go\n```", "```go\n1 2 3 4 5\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n)\nfunc middleware(handler http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        fmt.Println(\"Executing middleware before request phase!\")\n        // Pass control back to the handler\n        handler.ServeHTTP(w, r)\n        fmt.Println(\"Executing middleware after response phase!\")\n    })\n}\nfunc mainLogic(w http.ResponseWriter, r *http.Request) {\n    // Business logic goes here\n    fmt.Println(\"Executing mainHandler...\")\n    w.Write([]byte(\"OK\"))\n}\nfunc main() {\n    // HandlerFunc returns a HTTP Handler\n    mainLogicHandler := http.HandlerFunc(mainLogic)\n    http.Handle(\"/\", middleware(mainLogicHandler))\n    http.ListenAndServe(\":8000\", nil)\n}\n```", "```go\ngo run customMiddleware.go\n```", "```go\nExecuting middleware before request phase!\nExecuting mainHandler...\nExecuting middleware after response phase!\n```", "```go\npackage main\n\n import (\n     \"encoding/json\"\n     \"fmt\"\n     \"net/http\"\n )\n\n type city struct {\n     Name string\n     Area uint64\n }\n\n func mainLogic(w http.ResponseWriter, r *http.Request) {\n     // Check if method is POST\n     if r.Method == \"POST\" {\n         var tempCity city\n         decoder := json.NewDecoder(r.Body)\n         err := decoder.Decode(&tempCity)\n         if err != nil {\n             panic(err)\n         }\n         defer r.Body.Close()\n         // Your resource creation logic goes here. For now it is plain print to console\n         fmt.Printf(\"Got %s city with area of %d sq miles!\\n\", tempCity.Name, tempCity.Area)\n         // Tell everything is fine\n         w.WriteHeader(http.StatusOK)\n         w.Write([]byte(\"201 - Created\"))\n     } else {\n         // Say method not allowed\n         w.WriteHeader(http.StatusMethodNotAllowed)\n         w.Write([]byte(\"405 - Method Not Allowed\"))\n     }\n }\n\n func main() {\n     http.HandleFunc(\"/city\", mainLogic)\n     http.ListenAndServe(\":8000\", nil)\n }\n```", "```go\ngo run cityAPI.go\n```", "```go\ncurl -H \"Content-Type: application/json\" -X POST http://localhost:8000/city -d '{\"name\":\"New York\", \"area\":304}'\n\ncurl -H \"Content-Type: application/json\" -X POST http://localhost:8000/city -d '{\"name\":\"Boston\", \"area\":89}'\n```", "```go\nGot New York city with area of 304 sq miles!\nGot Boston city with area of 89 sq miles!\n```", "```go\n201 - Created\n201 - Created\n```", "```go\npackage main\nimport (\n    \"encoding/json\"\n    \"log\"\n    \"net/http\"\n    \"strconv\"\n    \"time\"\n)\ntype city struct {\n    Name string\n    Area uint64\n}\n// Middleware to check content type as JSON\nfunc filterContentType(handler http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        log.Println(\"Currently in the check content type middleware\")\n        // Filtering requests by MIME type\n        if r.Header.Get(\"Content-type\") != \"application/json\" {\n            w.WriteHeader(http.StatusUnsupportedMediaType)\n            w.Write([]byte(\"415 - Unsupported Media Type. Please send JSON\"))\n            return\n        }\n        handler.ServeHTTP(w, r)\n    })\n}\n// Middleware to add server timestamp for response cookie\nfunc setServerTimeCookie(handler http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        handler.ServeHTTP(w, r)\n        // Setting cookie to each and every response\n        cookie := http.Cookie{Name: \"Server-Time(UTC)\", Value: strconv.FormatInt(time.Now().Unix(), 10)}\n        http.SetCookie(w, &cookie)\n        log.Println(\"Currently in the set server time middleware\")\n    })\n}\nfunc mainLogic(w http.ResponseWriter, r *http.Request) {\n    // Check if method is POST\n    if r.Method == \"POST\" {\n        var tempCity city\n        decoder := json.NewDecoder(r.Body)\n        err := decoder.Decode(&tempCity)\n        if err != nil {\n            panic(err)\n        }\n        defer r.Body.Close()\n        // Your resource creation logic goes here. For now it is plain print to console\n        log.Printf(\"Got %s city with area of %d sq miles!\\n\", tempCity.Name, tempCity.Area)\n        // Tell everything is fine\n        w.WriteHeader(http.StatusOK)\n        w.Write([]byte(\"201 - Created\"))\n    } else {\n        // Say method not allowed\n        w.WriteHeader(http.StatusMethodNotAllowed)\n        w.Write([]byte(\"405 - Method Not Allowed\"))\n    }\n}\nfunc main() {\n    mainLogicHandler := http.HandlerFunc(mainLogic)\n    http.Handle(\"/city\", filterContentType(setServerTimeCookie(mainLogicHandler)))\n    http.ListenAndServe(\":8000\", nil)\n}\n```", "```go\ngo run multipleMiddleware.go\n```", "```go\ncurl -i -H \"Content-Type: application/json\" -X POST http://localhost:8000/city -d '{\"name\":\"Boston\", \"area\":89}'\n```", "```go\nHTTP/1.1 200 OK\nDate: Sat, 27 May 2017 14:35:46 GMT\nContent-Length: 13\nContent-Type: text/plain; charset=utf-8\n\n201 - Created\n```", "```go\ncurl -i -X POST http://localhost:8000/city -d '{\"name\":\"New York\", \"area\":304}' \nHTTP/1.1 415 Unsupported Media Type\nDate: Sat, 27 May 2017 15:36:58 GMT\nContent-Length: 46\nContent-Type: text/plain; charset=utf-8\n\n415 - Unsupported Media Type. Please send JSON\n```", "```go\nhttp.Handle(\"/city\", filterContentType(setServerTimeCookie(mainLogicHandler)))\n```", "```go\ngo get github.com/justinas/alice\n```", "```go\nimport (\n    \"encoding/json\"\n    \"github.com/justinas/alice\"\n    \"log\"\n    \"net/http\"\n    \"strconv\"\n    \"time\"\n)\n```", "```go\nfunc main() {\n    mainLogicHandler := http.HandlerFunc(mainLogic)\n    chain := alice.New(filterContentType, setServerTimeCookie).Then(mainLogicHandler)\n    http.Handle(\"/city\", chain)\n    http.ListenAndServe(\":8000\", nil)\n}\n```", "```go\ngo get \"github.com/gorilla/handlers\"\n```", "```go\n192.168.2.20 - - [28/Jul/2006:10:27:10 -0300] \"GET /cgi-bin/try/ HTTP/1.0\" 200 3395\n127.0.0.1 - - [28/Jul/2006:10:22:04 -0300] \"GET / HTTP/1.0\" 200 2216\n```", "```go\npackage main\nimport (\n    \"github.com/gorilla/handlers\"\n    \"github.com/gorilla/mux\"\n    \"log\"\n    \"os\"\n    \"net/http\"\n)\nfunc mainLogic(w http.ResponseWriter, r *http.Request) {\n    log.Println(\"Processing request!\")\n    w.Write([]byte(\"OK\"))\n    log.Println(\"Finished processing request\")\n}\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/\", mainLogic)\n    loggedRouter := handlers.LoggingHandler(os.Stdout, r)\n    http.ListenAndServe(\":8000\", loggedRouter)\n}\n```", "```go\ngo run loggingMiddleware.go\n```", "```go\n2017/05/28 10:51:44 Processing request!\n2017/05/28 10:51:44 Finished processing request\n127.0.0.1 - - [28/May/2017:10:51:44 +0530] \"GET / HTTP/1.1\" 200 2\n127.0.0.1 - - [28/May/2017:10:51:44 +0530] \"GET /favicon.ico HTTP/1.1\" 404 19\n```", "```go\npackage main\nimport (\n    \"log\"\n    \"net\"\n    \"net/http\"\n    \"net/rpc\"\n    \"time\"\n)\ntype Args struct{}\ntype TimeServer int64\nfunc (t *TimeServer) GiveServerTime(args *Args, reply *int64) error {\n    // Fill reply pointer to send the data back\n    *reply = time.Now().Unix()\n    return nil\n}\nfunc main() {\n    // Create a new RPC server\n    timeserver := new(TimeServer)\n    // Register RPC server\n    rpc.Register(timeserver)\n    rpc.HandleHTTP()\n    // Listen for requests on port 1234\n    l, e := net.Listen(\"tcp\", \":1234\")\n    if e != nil {\n        log.Fatal(\"listen error:\", e)\n    }\n    http.Serve(l, nil)\n}\n```", "```go\npackage main\nimport (\n    \"log\"\n    \"net/rpc\"\n)\ntype Args struct {\n}\nfunc main() {\n    var reply int64\n    args := Args{}\n    client, err := rpc.DialHTTP(\"tcp\", \"localhost\"+\":1234\")\n    if err != nil {\n        log.Fatal(\"dialing:\", err)\n    }\n    err = client.Call(\"TimeServer.GiveServerTime\", args, &reply)\n    if err != nil {\n        log.Fatal(\"arith error:\", err)\n    }\n    log.Printf(\"%d\", reply)}\n```", "```go\ngo run RPCServer.go\n```", "```go\ngo run RPCClient.go \n```", "```go\n2017/05/28 19:26:31 1495979791\n```", "```go\ngo get github.com/gorilla/rpc\n```", "```go\npackage main\nimport (\n    jsonparse \"encoding/json\"\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"github.com/gorilla/mux\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/rpc/json\"\n)\n// Args holds arguments passed to JSON RPC service\ntype Args struct {\n    Id string\n}\n// Book struct holds Book JSON structure\ntype Book struct {\n    Id string `\"json:string,omitempty\"`\n    Name string `\"json:name,omitempty\"`\n    Author string `\"json:author,omitempty\"`\n}\ntype JSONServer struct{}\n// GiveBookDetail\nfunc (t *JSONServer) GiveBookDetail(r *http.Request, args *Args, reply *Book) error {\n    var books []Book\n    // Read JSON file and load data\n    raw, readerr := ioutil.ReadFile(\"./books.json\")\n    if readerr != nil {\n        log.Println(\"error:\", readerr)\n        os.Exit(1)\n    }\n    // Unmarshal JSON raw data into books array\n    marshalerr := jsonparse.Unmarshal(raw, &books)\n    if marshalerr != nil {\n        log.Println(\"error:\", marshalerr)\n        os.Exit(1)\n    }\n    // Iterate over each book to find the given book\n    for _, book := range books {\n        if book.Id == args.Id {\n            // If book found, fill reply with it\n            *reply = book\n            break\n        }\n    }\n    return nil\n}\nfunc main() {\n    // Create a new RPC server\n    s := rpc.NewServer()    // Register the type of data requested as JSON\n    s.RegisterCodec(json.NewCodec(), \"application/json\")\n    // Register the service by creating a new JSON server\n    s.RegisterService(new(JSONServer), \"\")\n    r := mux.NewRouter()\n    r.Handle(\"/rpc\", s)\n    http.ListenAndServe(\":1234\", r)\n}\n```", "```go\ngo run jsonRPCServer.go\n```", "```go\ncurl -X POST \\\n http://localhost:1234/rpc \\\n -H 'cache-control: no-cache' \\\n -H 'content-type: application/json' \\\n -d '{\n \"method\": \"JSONServer.GiveBookDetail\",\n \"params\": [{\n \"Id\": \"1234\"\n }],\n \"id\": \"1\"\n}'\n```", "```go\n{\"result\":{\"Id\":\"1234\",\"Name\":\"In the sunburned country\",\"Author\":\"Bill Bryson\"},\"error\":null,\"id\":\"1\"}\n```"]