["```go\n apt-get install sqlite3 libsqlite3-dev\n```", "```go\n brew install sqlite3\n```", "```go\n go get github.com/emicklei/go-restful\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"github.com/emicklei/go-restful\"\n    \"io\"\n    \"net/http\"\n    \"time\"\n)\nfunc main() {\n    // Create a web service\n    webservice := new(restful.WebService)\n    // Create a route and attach it to handler in the service\n    webservice.Route(webservice.GET(\"/ping\").To(pingTime))\n    // Add the service to application\n    restful.Add(webservice)\n    http.ListenAndServe(\":8000\", nil)\n}\nfunc pingTime(req *restful.Request, resp *restful.Response) {\n    // Write to the response\n   io.WriteString(resp, fmt.Sprintf(\"%s\", time.Now()))\n}\n```", "```go\ngo run basicExample.go\n```", "```go\ncurl -X GET \"http://localhost:8000/ping\"\n2017-06-06 07:37:26.238146296 +0530 IST\n```", "```go\nwebservice.GET(\"/ping\")\n```", "```go\nrestful.Add(webservice)\n```", "```go\ngo get github.com/mattn/go-sqlite3\n```", "```go\nimport \"database/sql\"\n```", "```go\npackage main\nimport (\n    \"database/sql\"\n    \"log\"\n    _ \"github.com/mattn/go-sqlite3\"\n)\n// Book is a placeholder for book\ntype Book struct {\n    id int\n    name string\n    author string\n}\nfunc main() {\n    db, err := sql.Open(\"sqlite3\", \"./books.db\")\n    log.Println(db)\n    if err != nil {\n        log.Println(err)\n    }\n    // Create table\n    statement, err := db.Prepare(\"CREATE TABLE IF NOT EXISTS books (id\nINTEGER PRIMARY KEY, isbn INTEGER, author VARCHAR(64), name VARCHAR(64) NULL)\")\n    if err != nil {\n        log.Println(\"Error in creating table\")\n    } else {\n        log.Println(\"Successfully created table books!\")\n    }\n    statement.Exec()\n    // Create\n    statement, _ = db.Prepare(\"INSERT INTO books (name, author, isbn) VALUES (?, ?, ?)\")\n    statement.Exec(\"A Tale of Two Cities\", \"Charles Dickens\", 140430547)\n    log.Println(\"Inserted the book into database!\")\n    // Read\n    rows, _ := db.Query(\"SELECT id, name, author FROM books\")\n    var tempBook Book\n    for rows.Next() {\n        rows.Scan(&tempBook.id, &tempBook.name, &tempBook.author)\n        log.Printf(\"ID:%d, Book:%s, Author:%s\\n\", tempBook.id,\ntempBook.name, tempBook.author)\n    }\n    // Update\n    statement, _ = db.Prepare(\"update books set name=? where id=?\")\n    statement.Exec(\"The Tale of Two Cities\", 1)\n    log.Println(\"Successfully updated the book in database!\")\n    //Delete\n    statement, _ = db.Prepare(\"delete from books where id=?\")\n    statement.Exec(1)\n    log.Println(\"Successfully deleted the book in database!\")\n}\n```", "```go\ngo run sqliteFundamentals.go\n```", "```go\n2017/06/10 08:04:31 Successfully created table books!\n2017/06/10 08:04:31 Inserted the book into database!\n2017/06/10 08:04:31 ID:1, Book:A Tale of Two Cities, Author:Charles Dickens\n2017/06/10 08:04:31 Successfully updated the book in database!\n2017/06/10 08:04:31 Successfully deleted the book in database!\n```", "```go\nstatement, err := db.Prepare(\"CREATE TABLE IF NOT EXISTS books (id INTEGER PRIMARY KEY, isbn INTEGER, author VARCHAR(64), name VARCHAR(64) NULL)\")\n```", "```go\nstatement, _ = db.Prepare(\"INSERT INTO books (name, author, isbn) VALUES (?, ?, ?)\")\nstatement.Exec(\"A Tale of Two Cities\", \"Charles Dickens\", 140430547)\n```", "```go\nrows, _ := db.Query(\"SELECT id, name, author FROM books\")\nvar tempBook Book\nfor rows.Next() {\n     rows.Scan(&tempBook.id, &tempBook.name, &tempBook.author)\n     log.Printf(\"ID:%d, Book:%s, Author:%s\\n\", tempBook.id, tempBook.name, tempBook.author)\n}\n```", "```go\npackage dbutils\n\nconst train = `\n      CREATE TABLE IF NOT EXISTS train (\n           ID INTEGER PRIMARY KEY AUTOINCREMENT,\n           DRIVER_NAME VARCHAR(64) NULL,\n           OPERATING_STATUS BOOLEAN\n        )\n`\n\nconst station = `\n        CREATE TABLE IF NOT EXISTS station (\n          ID INTEGER PRIMARY KEY AUTOINCREMENT,\n          NAME VARCHAR(64) NULL,\n          OPENING_TIME TIME NULL,\n          CLOSING_TIME TIME NULL\n        )\n`\nconst schedule = `\n        CREATE TABLE IF NOT EXISTS schedule (\n          ID INTEGER PRIMARY KEY AUTOINCREMENT,\n          TRAIN_ID INT,\n          STATION_ID INT,\n          ARRIVAL_TIME TIME,\n          FOREIGN KEY (TRAIN_ID) REFERENCES train(ID),\n          FOREIGN KEY (STATION_ID) REFERENCES station(ID)\n        )\n`\n```", "```go) character. The schedule holds the information of a train arriving at a particular station at a given time. Here, train and station are foreign keys to the schedule table. For train, the details related to it are columns. The package name is `dbutils`.When we mention the package names, all the Go programs in that package can share variables and functions exported without any need of actual importing.\n\nNow, let us add code to initialize the (create tables) database in the\u00a0`init-tables.go` file:\n\n```", "```go\n\nWe are importing `database/sql` to pass the type of argument in the function. All other statements in the function are similar to the SQLite3 example we gave in the preceding code. It is just creating three tables in the SQLite3 database. Our main program should pass the database driver to this function. If you observe here, we are not importing train, station, and schedule. But, since this file is in the\u00a0`db utils` package, variables in `models.go` are accessible here.\n\nNow our initial package is finished. You can build the object code for this package using the following command:\n\n```", "```go\n\nIt is not useful until we create and run our main program. So, let us write a simple main program that imports the\u00a0`Initialize` function from the `dbutils` package. Let us call the file `main.go`:\n\n```", "```go\n\nAnd run the program from the `railAPI` directory using the following command:\n\n```", "```go\n\nThe output you see should be something like the following:\n\n```", "```go\n\nIn the preceding program, we added the code for creating a database driver and passed the table creation task to the\u00a0`Initialize` function from the `dbutils` package. We can do that straight away in our main program, but it is good to decompose the logic into multiple packages and components. Now, we will extend this simple layout to create an API using the\u00a0`go-restful` package. The API should implement all the functions of our API design document.\n\nThe `railapi.db` file from the preceding directory tree picture gets created once we run our main program. SQLite3 will take care of creating the database file if it doesn't exist. SQLite3 databases are simple files. You can enter into the SQLite shell using the\u00a0`$ sqlite3 file_name` command.\n\nLet us modify the main program into a new one. We will go step by step and understand how to build REST services using `go-restful` in this example. First, add the necessary imports to the program:\n\n```", "```go\n\nWe need two external packages,\u00a0`go-restful` and `go-sqlite3`, for building the API logic. The first one is for handlers and the second package is for adding persistence features. `dbutils`is the one we previously created. The\u00a0`time` and `net/http` packages are for general purpose tasks.\n\nEven though concrete names are given to the columns in the SQLite database's tables, in GO programming we need a few structs to handle data coming in and out of the database. There should be data holders for all the models, so we will define them next. Take a look at the following code snippet:\n\n```", "```go\n\nThe `DB`variable is allocated to hold the global database driver. All the above structs are exact representations of the database models in the SQL. Go's `time.Time` struct type can actually hold the `TIME` field from the database.\n\nNow comes the actual `go-restful` implementation. We need to create a container for our API in `go-restful`. Then, we should register the web services to that container. Let us write the\u00a0`Register` function, as shown in the following code snippet:\n\n```", "```go\n\nWeb services in `go-restful` mainly work based on resources. So here, we are defining a function called `Register` on\u00a0`TrainResource`, taking\u00a0containers as arguments. We create a new `WebService` and add paths to it. A path is the URL endpoint and routes are the path parameters or query parameters attached to the function handlers. `ws`is the web service created to serve the `Train` resource.We attached three REST methods, namely `GET`, `POST`, and `DELETE` to three function handlers,\u00a0`getTrain`, `createTrain`, and\u00a0`removeTrain` respectively:\n\n```", "```go\n\nThese statements say that API will only entertain `Content-Type` as application/JSON in the request. For all other types, it automatically returns a 415--Media Not Supported error. The returned response is automatically converted to a pretty JSON. We can also have a list of formats such as XML, JSON, and so on. `go-restful` provides this feature out of the box.\n\nNow, let us define the function handlers:\n\n```", "```go\n\nAll these REST methods are defined on the instance of the `TimeResource` struct. Coming to the\u00a0`GET` handler, it is passing `Request` and `Response` as its arguments. The `path` parameters can be fetched using the\u00a0`request.PathParameter`function. The argument passed to it will be in agreement with the route we added in the preceding code snippet. That is,\u00a0`train-id`will be returned into the handler so that we can strip it and use it as criteria to fetch a record from our SQLite database.\u00a0\n\nIn the `POST` handler function, we are parsing the request body with the JSON package's `NewDecoder`function. `go-restful` doesn't have a function to parse raw data posted from the client. There are functions available to strip query parameters and form parameters, but this one is missing. So, we wrote our own logic to strip and parsed the JSON body, and used those results to insert data into our SQLite database. That handler is creating a `db` record for the train with the supplied details in the request.\n\nThe `DELETE` function is quite obvious if you understand the previous two handlers. We are making a `DELETE` SQL command using `DB.Prepare`and returning a 201 Status OK back, telling us the delete operation was successful. Otherwise, we are sending back the actual error as a server error. Now, let us write the main function handler, which is an entry point for our program:\n\n```", "```go\n\nThe first four lines here are performing the database-related housekeeping. Then, we are creating a new container using `restful.NewContainer`.Then, we are using a router called `CurlyRouter`(which allows us to use `{train_id}` syntax in paths while setting routes) for our container. Then, we created an instance of the\u00a0`TimeResource` struct\u00a0and passed this container to the `Register` method. That container can indeed act as an HTTP handler; so, we can pass it to the `http.Server`easily.\n\nUse `request.QueryParameter`to fetch the query parameters from an HTTP request in the\u00a0`go-restful` handler.\n\nThis code is available in the GitHub repo. Now, when we run the `main.go` file within the `$GOPATH/src/github.com/narenaryan` directory, we see this:\n\n```", "```go\n\nAnd make a curl\u00a0`POST` request to create a train:\n\n```", "```go\n\nThis creates a new train with the driver and operation status details. The response is the newly created resource with the train `ID` allocated:\n\n```", "```go\n\nNow, let us make a curl request to check the `GET`:\n\n```", "```go\n\nYou will see the JSON output, as follows:\n\n```", "```go\n\nWe can use the same names for both posting data and JSON returned, but in order to show the difference between two operations, different variable names are used. Now, delete the resource we created in the preceding code snippet with the\u00a0`DELETE` API call:\n\n```", "```go\n\nIt won't return any response body; it returns `Status 200 ok` if the operation was successful. Now, if we try to do a `GET` on the `ID` 1 train, then it returns us this response:\n\n```", "```go\n\nThese implementations can be extended to\u00a0`PUT` and `PATCH.` We need to add two more routes to the web service in the `Register` method and define respective handlers. Here, we created a web service for the\u00a0`Train` resource. In a similar way, web services can be created for doing CRUD operations on the\u00a0`Station`and `Schedule` tables. That task is left for the readers to explore.\n\n`go-restful` is a lightweight library that is powerful in creating RESTful services in an elegant way. The main theme is to convert resources (models) into consumable APIs. Using other heavy frameworks may speed up the development, but the API can end up slower because of the wrapping of code. `go-restful` is a lean and low-level package for API creation.\n\n`go-restful` also provides built-in support for documenting the REST API with **swagger**. Itis a tool that runs and generates templates for documenting the REST API we build. By integrating it with our `go-restful`-based web services, we can generate documentation on the fly. For more information, visit\u00a0[https://github.com/emicklei/go-restful-swagger12](https://github.com/emicklei/go-restful-swagger12).\n\n# Building RESTful APIs with the Gin framework\n\n`Gin-gonic` is a framework based on the\u00a0`httprouter`.We learned about the\u00a0`httprouter` in Chapter 2, *Handling Routing for Our REST Services*. It is an HTTP multiplexer like Gorilla Mux, but it is faster. `Gin` allows a high-level API to create REST\u00a0services in a clean way. `Gin` compares itself with another web framework called `martini`. All web frameworks allow us to do a lot more things such as templating and web server design, additional to service creation. Install the\u00a0`Gin` package using the following command:\n\n```", "```go\n\nLet us write a simple hello world program in `Gin` to get familiarized with the\u00a0`Gin` constructs. The file is\u00a0`ginBasic.go`:\n\n```", "```go\n\nThis simple server tries to implement a service that provides the UTC server time to the clients. We implemented one such service in\u00a0[Chapter 3](d4152cbc-41fa-414e-bd50-146e9549f41d.xhtml),\u00a0*Working with Middleware and RPC*. But here, if you look,\u00a0`Gin` allows you to do a lot of stuff with just a few lines of code; all the boilerplate details are taken away. Coming to the preceding program, we are creating a router with the\u00a0`gin.Default`function. Then, we are attaching routes with REST verbs as we did in `go-restful`; a route to the function handler. Then, we are calling the `Run`function by passing the port to run. The default port will be `8080`.\n\n`c` is the `gin.Context`that holds the information of the individual request. We can serialize data into JSON before sending it back to the client using the\u00a0`context.JSON` function. Now, if we run and see the preceding program:\n\n```", "```go\n\nMake a curl request:\n\n```", "```go\n\nAt the same time, the console where we are running the `Gin` server is beautifully presented with debug messages:\n\n![](img/54d2bbb0-6c1c-466d-b187-1828e5283490.png)\n\nIt is Apache-style debug logging showing the endpoint, the latency of the request, and the REST method.\n\nIn order to run `Gin` in production mode, set the\u00a0`GIN_MODE = release` environment variable. Then the console output will be muted and log files can be used for monitoring the logs.\n\nNow, let us write our Rail API in `Gin` to show how to implement exactly the same thing using the\u00a0`Gin` framework. I will use the same project layout, name my new project\u00a0`railAPIGin`, and use the `dbutils` as it is. First, let us prepare the imports for our program:\n\n```", "```go\n\nWe imported `sqlite3` and `dbutils` for database-related actions. We imported `gin`for creating our API server. `net/http`is useful in providing the intuitive status codes to be sent along with the response. Take a look at the following code snippet:\n\n```", "```go\n\nWe created a database driver that is available to all handler functions. `StationResource` is the placeholder for our JSON that decoded from both request body and data coming from the database. In case you noticed, it is slightly modified from the example of `go-restful`. Now, let us write the handlers implementing `GET`, `POST`, and `DELETE`\u00a0 methods for the `station` resource:\n\n```", "```go\n\nIn\u00a0`GetStation`, we are using the `c.Param`to strip the\u00a0`station_id` path parameter. After that, we are using that ID to fetch a database record from the SQLite3 station table. If you observed carefully, the SQL query is bit different. We are using the\u00a0`CAST` method to retrieve the SQL `TIME` field as a string for Go to consume properly. If you remove the casting, a panic error will be raised because we are trying to load a `TIME` field into the Go string at runtime. To give you an idea, the\u00a0`TIME` field looks like\u00a0*8:00:00*, *17:31:12,* and so on. Next, we are returning back the result using the\u00a0`gin.H`method if there is no error.\n\nIn\u00a0`CreateStation`,we are trying to perform an insert query. But before that, in order to get data from the body of the `POST` request, we are using a function called `c.BindJSON`.\u00a0This function loads the data into the struct that is passed as the argument. It means the station struct will be loaded with the data supplied from the body. That is why\u00a0`StationResource` has the JSON inference strings to tell what key values are expected. For example, this is such field of `StationResource` struct with inference string.\n\n```", "```go\n\nAfter collecting the data, we are preparing a database insert statement and executing it. The result is the ID of the inserted record. We are using that ID to send station details back to the client. In\u00a0`RemoveStation`,we are performing a `DELETE` SQL query. If the operation was successful, we return a 200 OK status back. Otherwise, we are sending the appropriate reason for a 500 Internal Server Error.\n\nNow comes the main program, which runs the database logic first to make sure tables are created. Then, it tries to create a `Gin` router and adds routes to it:\n\n```", "```go\n\nWe are registering the `GET`, `POST`, and `DELETE` routes with the `Gin` router. Then, we are passing routes and handlers to them. Finally, we are starting the server using the `Run`function of Gin with `8000` as the port. Run the preceding program, as follows:\n\n```", "```go\n\nNow, we can insert a new record by performing a `POST` request:\n\n```", "```go\n\nIt returns:\n\n```", "```go\n\nAnd now try to fetch the details using `GET`:\n\n```", "```go\n\nWe can also delete the station record using the following command:\n\n```", "```go\n\nIt returns a 200 OK status, confirming the resource was successfully deleted. As we already discussed,\u00a0`Gin` provides intuitive debugging on the console, showing the attached handler and highlighting the latency and REST verbs with colors:\n\n![](img/c1f2942f-5dfc-4fda-b9d3-7a9470ca687d.png)\n\nFor example, a\u00a0`200` is green, a `404` is yellow, `DELETE` is red,\u00a0and so on. `Gin` provides many other features such as the categorization of routes, redirects, and middleware functions.\u00a0\n\nUse the `Gin` framework if you are quickly prototyping a REST web service. You can also use it for many other things such as static file serving and so on. Remember that it is a fully-fledged web framework. For fetching the query parameters in Gin, use the following method on the\u00a0`Gin` context object:\u00a0`c.Query(\"param\")`.\n\n# Building a RESTful API with Revel.go\n\nRevel.go is also a fully-fledged web framework like Python's Django. It is older than Gin, and is termed as a high productivity web framework. It is an asynchronous, modular, and stateless framework. Unlike the\u00a0`go-restful` and `Gin` frameworks\u00a0where we created the project ourselves, Revel\u00a0generates a scaffold for working directly.\n\nInstall `Revel.go` using the following command:\n\n```", "```go\n\nIn order to run the scaffold tool, we should install one more supplementary package:\n\n```", "```go\n\nMake sure that\u00a0`$GOPATH/bin` is in your `PATH` variable. Some external packages install the binary in the\u00a0`$GOPATH/bin` directory. If it is in the path, we can access executables system-wide. Here, Revel installs a binary called `revel`. On Ubuntu or macOS X, you can do it using the following command:\n\n```", "```go\n\nAdd the preceding line to `~/.bashrc` to save the setting. On Windows, you need to directly call the executable by its location. Now we are ready to start with Revel. Let us create a new project called `railAPIRevel` in `github.com/narenaryan`:\n\n```", "```go\n\nThis creates a project scaffold without writing a single line of code. This is how web frameworks abstract things for quick prototyping. A Revel project layout tree looks like this:\n\n```", "```go\n\nOut of all those boilerplate directories, three things are important for creating an API. Those are:\n\n*   `app/controllers`\n*   `conf/app.conf`\n*   `conf/routes`\n\nControllers are the logic containers that execute the API logic. `app.conf` allows us to set the `host`, `port`, and `dev` mode/production mode and so on. `routes` defines the triple of the endpoint, REST verb, and function handler (here, controller's function). This means to define a function in the controller and attach it to a route in the routes file.\n\nLet us use the same example we have seen for `go-restful`, creating an API for trains. But here, due to the redundancy, we will drop the database logic. We will see shortly how to build `GET`, `POST`, and `DELETE` actions for the API using Revel. Now, modify the routes file to this:\n\n```", "```go\n\nThe syntax may look a bit new. It is a configuration file where we simply define a route in this format:\n\n```", "```go\n\nWe haven't defined handlers yet. In the endpoint, the path parameters are accessed using the\u00a0`:param`notation. This means for the `GET` request in the file, `train-id` will be passed as the `path` parameter. Now, move to the `controllers`\u00a0folder and modify the\u00a0 existing controller in\u00a0 `app.go` file to this:\n\n```", "```go\n\nWe created API handlers in the file `app.go`. Those handler names should match the ones we mentioned in the routes file. We can create a Revel controller using a struct with `*revel.Controller` as its member. Then, we can attach any number of handlers to it. The controller holds the information of incoming HTTP requests so that we can use the information such as query parameters, path parameters, JSON body, form data, and so on in our handler.\n\nWe are defining\u00a0`TrainResource`to work as a data holder. In `GetTrain`,we are fetching the path parameters using the\u00a0`c.Params.Route.Get`function. The argument to that function is the path parameter we specified in the route file (here,\u00a0`train-id`). The value will be a string. We need to convert it to `Int` type to map it with `train.ID`.Then, we are setting the response status as `200 OK` using the\u00a0`c.Response.Status` variable (not function). `c.RenderJSON` takes a struct and transforms it into the JSON body.\u00a0\n\nIn `CreateTrain,`we are adding the `POST` request logic. We are creating a new `TrainResource` struct and passing it to a function called `c.Params.BindJSON`.What `BindJSON`does is it plucks the parameters from the JSON `POST` body and tries to find matching fields in the struct and fill them. When we marshal a Go struct to JSON, field names will be translated to keys as it is. But, if we attach the\u00a0``jason:\"id\"`` string format to any struct field, it explicitly says that the JSON that is marshaled from this struct should have the key\u00a0`id`, not **ID**. This is a good practice in Go while working with JSON. Then, we are adding a status of 201 created to the HTTP response. We are returning the train struct, which will be converted into JSON internally.\n\nThe `RemoveTrain`handler logic is similar to that of `GET`. A\u00a0subtle difference is that nothing is sent in the body. As we previously mentioned, database CRUD logic is omitted from the preceding example. It is an exercise for readers to try adding SQLite3 logic by observing what we have done in the\u00a0`go-restful` and `Gin` sections.\n\nFinally, the default port on which the Revel server runs is `9000`. The configuration to change the port number is in the\u00a0`conf/app.conf`file. Let us follow the tradition of running our app on `8000`. So, modify the `http` port section of the file to the following. This tells the Revel server to run on a different port:\n\n```", "```go\n\nNow, we can run our Revel API server using this command:\n\n```", "```go\n\nOur app server starts at `http://localhost:8000`. Now, let us make a few API requests:\n\n```", "```go\n\n`POST` request:\n\n```"]