- en: Working with MongoDB and Go to Create REST APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB和Go创建REST API
- en: In this chapter, we are going to introduce the NoSQL database called `MongoDB`.
    We will learn how well MongoDB suits modern web services. We will begin by learning
    about `MongoDB` collections and documents. We will try to create an example API
    with `MongoDB` as the database. In this process, we will use a driver package
    called `mgo`. We willthen try to design a document model for the e-commerce REST
    services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍名为`MongoDB`的NoSQL数据库。我们将学习`MongoDB`如何适用于现代Web服务。我们将首先学习有关`MongoDB`集合和文档的知识。我们将尝试使用`MongoDB`作为数据库创建一个示例API。在这个过程中，我们将使用一个名为`mgo`的驱动程序包。然后，我们将尝试为电子商务REST服务设计一个文档模型。
- en: 'Basically, we are going to discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将讨论以下主题：
- en: Installing and using MongoDB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用MongoDB
- en: Working with the Mongo shell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mongo shell
- en: Building REST APIs with MongoDB as the database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongoDB作为数据库构建REST API
- en: Basics of database indexing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库索引的基础知识
- en: Designing an e-commerce document model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计电子商务文档模型
- en: Getting the code
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码
- en: You can get the code samples for this chapter from [https://github.com/narenaryan/gorestful/tree/master/chapter5](https://github.com/narenaryan/gorestful/tree/master/chapter5).
    This chapter's examples are a combination of single programs and projects. So,
    copy the respective directory to your `GOPATH` to run the code samples properly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/narenaryan/gorestful/tree/master/chapter5](https://github.com/narenaryan/gorestful/tree/master/chapter5)获取本章的代码示例。本章的示例是单个程序和项目的组合。因此，将相应的目录复制到您的`GOPATH`中，以正确运行代码示例。
- en: Introduction to MongoDB
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB简介
- en: '**MongoDB** is a popular NoSQL database that is attracting a lot of developers
    worldwide. It is different from traditional relational databases such as MySQL,
    PostgreSQL, and SQLite3\. The main big difference of MongoDB compared to other
    databases is the ease of scalability at the time of internet traffic. It also
    has JSON as its data model, which allows us to store JSON directly into the database.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**MongoDB**是一种受到全球开发人员青睐的流行NoSQL数据库。它不同于传统的关系型数据库，如MySQL、PostgreSQL和SQLite3。与其他数据库相比，MongoDB的主要区别在于在互联网流量增加时易于扩展。它还将JSON作为其数据模型，这使我们可以直接将JSON存储到数据库中。'
- en: 'Many huge companies such as Expedia, Comcast, and Metlife built their applications
    on MongoDB. It is already proven as a vital element in modern internet businesses.
    MongoDB stores data in a document; think of this as a row in SQL databases. All
    MongoDB documents are stored in a collection, and the collection is a table (in
    SQL analogy). A sample document for an IMDB movie looks like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大公司，如Expedia、Comcast和Metlife，都在MongoDB上构建了他们的应用程序。它已经被证明是现代互联网业务中的重要组成部分。MongoDB将数据存储在文档中；可以将其视为SQL数据库中的行。所有MongoDB文档都存储在一个集合中，而集合就是表（类比SQL）。IMDB电影的一个示例文档如下：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The main advantages of MongoDB over relational databases are:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB相对于关系型数据库的主要优势是：
- en: Easy to model (schema free)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于建模（无模式）
- en: Can leverage querying power
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以利用查询功能
- en: Document structure suits modern-day web applications (JSON)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档结构适合现代Web应用程序（JSON）
- en: More scalable than relational databases
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比关系型数据库更具可扩展性
- en: Installing MongoDB and using the shell
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装MongoDB并使用shell
- en: 'MongoDB can be easily installed on any platform. On Ubuntu 16.04, we need to
    perform some processes before running the `apt-get` command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB可以轻松安装在任何平台上。在Ubuntu 16.04上，我们需要在运行`apt-get`命令之前执行一些进程：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It will ask for confirmation of installation in the last step; press *Y*. Once
    the installation is done, we need to start the MongoDB daemon using the following
    command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在最后一步要求确认安装；按*Y*。安装完成后，我们需要使用以下命令启动MongoDB守护进程：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All the preceding commands are to be run by the root. If the user is not root,
    use the prepend `sudo` keyword before each command.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的命令都需要由root用户运行。如果用户不是root用户，请在每个命令前使用`sudo`关键字。
- en: We can also download MongoDB manually from the website and run the server with
    the `~/mongodb/bin/mongod/` command. For this, we need to create an init script
    because the server will be killed if we close the terminal. We can also use `nohup`
    for running the server in the background. Usually, it is better to install it
    using `apt-get`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从网站手动下载MongoDB，并使用`~/mongodb/bin/mongod/`命令运行服务器。为此，我们需要创建一个init脚本，因为如果关闭终端，服务器将被关闭。我们还可以使用`nohup`在后台运行服务器。通常最好使用`apt-get`进行安装。
- en: 'For installing MongoDB on macOS X, use the Homebrew software. We can easily
    install it using the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要在macOS X上安装MongoDB，请使用Homebrew软件。我们可以使用以下命令轻松安装它：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After that, we need to create the `db` directory where MongoDB stores its database:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要创建MongoDB存储其数据库的`db`目录：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, change the permissions of that file using `chown`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`chown`更改该文件的权限：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we have MongoDB ready. We can run it in a terminal window with the following
    command, which starts the MongoDB daemon:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了MongoDB。我们可以在终端窗口中使用以下命令运行它，这将启动MongoDB守护进程：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Take a look at the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下截图：
- en: '![](img/c03be89e-caf0-4908-b354-18561320761a.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c03be89e-caf0-4908-b354-18561320761a.png)'
- en: On Windows, we can manually download the installer binary and launch it by adding
    the installation `bin` directory to the `PATH` variable. Then, we can run it using
    the `mongod`command.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们可以手动从网站下载安装程序二进制文件，并通过将安装的`bin`目录添加到`PATH`变量中来启动它。然后，我们可以使用`mongod`命令运行它。
- en: Working with the Mongo shell
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mongo shell
- en: 'Whenever we start using MongoDB, the first thing we should do is play with
    it for a while. Looking for available databases, collections, documents, and so
    on can be done with a simple tool called Mongo shell. This shell is packaged along
    with the installation steps we mentioned in the preceding section. We need to
    launch it using the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们开始使用MongoDB时，我们应该先玩一会儿。查找可用的数据库、集合、文档等可以使用一个名为Mongo shell的简单工具。这个shell是与我们在前面部分提到的安装步骤一起打包的。我们需要使用以下命令启动它：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Refer to the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下截图：
- en: '![](img/22b8e49f-16bd-40a6-add0-135f45be6284.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22b8e49f-16bd-40a6-add0-135f45be6284.png)'
- en: If you see this screen, everything worked fine. If you are getting any errors,
    the server is not running or there is some other issue. For troubleshooting, you
    can look at the official MongoDB troubleshooting guide at [https://docs.mongodb.com/manual/faq/diagnostics](https://docs.mongodb.com/manual/faq/diagnostics/).
    The client gives the information about MongoDB versions and other warnings. To
    see all available shell commands, use the `help` command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到这个屏幕，一切都进行得很顺利。如果您遇到任何错误，服务器没有运行或者有其他问题。对于故障排除，您可以查看官方MongoDB故障排除指南[https://docs.mongodb.com/manual/faq/diagnostics](https://docs.mongodb.com/manual/faq/diagnostics/)。客户端提供了有关MongoDB版本和其他警告的信息。要查看所有可用的shell命令，请使用`help`命令。
- en: 'Now we are ready with our setup. Let us create a new collection called `movies`
    and insert the preceding example document into it. By default, the database will
    be a test database. You can switch to a new database using the `use`command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了。让我们创建一个名为`movies`的新集合，并将前面的示例文档插入其中。默认情况下，数据库将是一个测试数据库。您可以使用`use`命令切换到一个新的数据库：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It shows all available databases. By default, `admin`, `test`, and `local` are
    the three databases available. In order to create a new database, just use `use
    db_name`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示所有可用的数据库。默认情况下，`admin`，`test`和`local`是三个可用的数据库。为了创建一个新的数据库，只需使用`use db_name`：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This switches the current database to the `appdb` database.If you try to see
    this in the available databases, it won''t show up because MongoDB creates a database
    only when data is inserted into it (first collection or document). So, now we
    can create a new collection by inserting a document from the shell. Then, we can
    insert the preceding Star Trek movie record into a collection called `movies`,using
    this command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把当前数据库切换到`appdb`数据库。如果您尝试查看可用的数据库，它不会显示出来，因为MongoDB只有在插入数据时（第一个集合或文档）才会创建数据库。因此，现在我们可以通过从shell中插入一个文档来创建一个新的集合。然后，我们可以使用以下命令将前面的《星际迷航》电影记录插入到名为`movies`的集合中：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The JSON you inserted has an ID called `_id`. We can either provide it while
    inserting a document or MongoDB can insert one for you itself. In SQL databases,
    we use *auto-increment* along with an `ID` schema toincrement the `ID` field.
    Here, MongoDB generates a unique hash `ID` rather than a sequence. Let us insert
    one more document about `The Dark Knight`, but this time let us not pass the `_id`
    field:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您插入的JSON具有名为`_id`的ID。我们可以在插入文档时提供它，或者MongoDB可以为您自动插入一个。在SQL数据库中，我们使用*自动递增*以及一个`ID`模式来递增`ID`字段。在这里，MongoDB生成一个唯一的哈希`ID`而不是一个序列。让我们再插入一个关于`黑暗骑士`的文档，但这次让我们不传递`_id`字段：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you observe the acknowledgement JSON response, `insertId`hasnow changed
    to a very lengthy `59574125bf7a73d140d5ba4a`.This is the unique hash generated
    by MongoDB. Now, let us see all the documents in our collection. We can also insert
    a batch of documents at a given time using an `insertMany` function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察到确认的JSON响应，`insertId`现在已经更改为非常长的`59574125bf7a73d140d5ba4a`。这是MongoDB生成的唯一哈希。现在，让我们看看我们集合中的所有文档。我们还可以使用`insertMany`函数一次插入一批文档：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using the `find` function on the movies collection returns all matched documents
    in the collection. In order to return a single; document, use the `findOne` function.
    It returns the latest document from multiple results:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在movies集合上使用`find`函数返回集合中所有匹配的文档。为了返回单个文档，使用`findOne`函数。它从多个结果中返回最新的文档：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'How do we fetch a document with some criteria? This means querying. Querying
    in MongoDB is known as filtering data and returning a result. If we need to filter
    for movies that were released in 2008, then we can do this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何根据一些条件获取文档？这意味着查询。在MongoDB中查询被称为过滤数据并返回结果。如果我们需要过滤发布于2008年的电影，那么我们可以这样做：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The filter query from the preceding mongo statement is:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面mongo语句中的过滤查询是：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This states that the searching criteria is the *year* and the value should
    be *2008.* `$eq`is called a filtering operator, which helps to relate the condition
    between the field and data. It is equivalent to the `=` operator in SQL. In SQL,
    the equivalent query can be written as:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明搜索条件是*年份*，值应该是*2008*。`$eq`被称为过滤操作符，它有助于关联字段和数据之间的条件。它相当于SQL中的`=`操作符。在SQL中，等效的查询可以写成：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can simplify the last written mongo query statement to this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简化上次编写的mongo查询语句为：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This find query and above mongo query were the same, returning the same set
    of documents. The former syntax is using the `$eq`which is a query operator. From
    now on, let us call a *query operator* simply an *operator*. Other operators are:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询和上面的mongo查询是一样的，返回相同的一组文档。前一种语法使用了`$eq`，这是一个查询操作符。从现在开始，让我们简单地称之为*操作符*。其他操作符有：
- en: '| **Operator** | **Function** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **功能** |'
- en: '| `$lt` | Less than |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `$lt` | 小于 |'
- en: '| `$gt` | Greater than |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `$gt` | 大于 |'
- en: '| `$in` | In the |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `$in` | 在 |'
- en: '| `$lte` | Less than or equal to |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `$lte` | 小于或等于 |'
- en: '| `$ne` | Not equal to |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `$ne` | 不等于 |'
- en: 'Now, let us pose a question to ourselves. We want to fetch all the documents
    whose budget is more than $150,000,000\. How can we filter it with the knowledge
    we gained previously? Take a look at the following code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对自己提出一个问题。我们想获取所有预算超过1.5亿美元的文档。我们如何使用之前获得的知识进行过滤？看一下以下代码片段：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you observe, we accessed the budget key within the JSON using `boxOffice.budget`.The
    beauty of MongoDB is that it allows us to query the JSON with a lot of freedom.
    Can''t we add two or more operators to the criteria while fetching documents?
    Yes, we can! Let us find all movies in the database that were released in 2009
    with a budget of more than $150,000,000:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到，我们使用`boxOffice.budget`在JSON中访问了budget键。MongoDB的美妙之处在于它允许我们以很大的自由查询JSON。在获取文档时，我们不能给条件添加两个或更多的操作符吗？是的，我们可以！让我们找到数据库中2009年发布的预算超过1.5亿美元的所有电影：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This returns nothing because we don''t have any documents that match the given
    criteria. Comma-separated fields actually combine with the `AND`operation. Now,
    let us relax our condition and find movies that were either released in 2009 or
    had a budget of more than $150,000,000:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了空值，因为我们没有任何符合给定条件的文档。逗号分隔的字段实际上与`AND`操作结合在一起。现在，让我们放宽条件，找到2009年发布的电影或预算超过$150,000,000的电影：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the query is bit different. We used an operator called `$or`for finding
    the predicate of two conditions. The result will be the criteria for fetching
    the documents. `$or`needs to be assigned to a list that has a list of JSON condition
    objects. Since JSON can be nested, conditions can also be nested. This style of
    querying might look new to people coming from an SQL background. The MongoDB team
    designed it for the intuitive filtering of data. We can also write advanced queries
    such as inner joins, outer joins, nested queries, and so on easily in MongoDB
    with the clever use of operators.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，查询有点不同。我们使用了一个称为`$or`的运算符来查找两个条件的谓词。结果将是获取文档的条件。`$or`需要分配给一个包含JSON条件对象列表的列表。由于JSON可以嵌套，条件也可以嵌套。这种查询方式对于来自SQL背景的人来说可能是新的。MongoDB团队设计它用于直观地过滤数据。我们还可以使用运算符轻松地在MongoDB中编写高级查询，例如内连接、外连接、嵌套查询等。
- en: 'Unknowingly, we have finished three operations in CRUD. We saw how to create
    a database and a collection. Then, we inserted documents and read them using filters.
    Now it is time for the delete operation. We can delete a document from a given
    collection using the `deleteOne` and `deleteMany` functions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不知不觉中，我们已经完成了CRUD中的三个操作。我们看到了如何创建数据库和集合。然后，我们使用过滤器插入文档并读取它们。现在是删除操作的时候了。我们可以使用`deleteOne`和`deleteMany`函数从给定的集合中删除文档：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The argument passed to the **`deleteOne` **function is the filtering criteria,
    which is similar to the read operation. All the documents that match the given
    criteria will be removed from the collection. The response has a nice acknowledgment
    message with a count of documents that got deleted.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给**`deleteOne`**函数的参数是过滤条件，类似于读操作。所有匹配给定条件的文档都将从集合中删除。响应中有一个很好的确认消息，其中包含被删除的文档数量。
- en: All the preceding sections discuss the basics of MongoDB, but with the shell,
    which executes JavaScript statements. It is not quite useful executing `db` statements
    from the shell manually. We need to call the API of Mongo DB in Go using a driver
    program. In the upcoming section, we will see such a driver package called `mgo`.
    The official MongoDB drivers include languages such as Python, Java, and Ruby.
    Go's `mgo` driver is a third-party package.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的所有部分都讨论了MongoDB的基础知识，但是使用的是执行JavaScript语句的shell。手动从shell执行`db`语句并不是很有用。我们需要使用驱动程序在Go中调用Mongo
    DB的API。在接下来的部分中，我们将看到一个名为`mgo`的驱动程序包。官方的MongoDB驱动程序包括Python、Java和Ruby等语言。Go的`mgo`驱动程序是一个第三方软件包。
- en: Introducing mgo, a MongoDB driver for Go
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍`mgo`，一个用于Go的MongoDB驱动程序
- en: '`mgo` is a rich MongoDB driver that facilitates developers to write applications
    that talk to MongoDB without the need for the Mongo shell. The Go application
    can talk easily with MongoDB for all its CRUD operations using the `mgo` driver.
    It is an open-source implementation that can be used and modified freely. It is
    maintained by Labix. We can think it of as a wrapper around the MongoDB API. Installing
    the package is very simple, refer to the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`mgo`是一个丰富的MongoDB驱动程序，它方便开发人员编写应用程序，与MongoDB进行通信，而无需使用Mongo shell。使用`mgo`驱动程序，Go应用程序可以轻松地与MongoDB进行所有CRUD操作。这是一个开源实现，可以自由使用和修改。由Labix维护。我们可以将其视为MongoDB
    API的包装器。安装该软件包非常简单，请参考以下命令：'
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This installs the package in `$GOPATH`. Now, we can refer the package to our
    Go programs, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`$GOPATH`中安装软件包。现在，我们可以在我们的Go程序中引用该软件包，如下所示：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let us write a simple program that talks to MongoDB and inserts  `The Dark
    Knight` movie record:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序，与MongoDB通信并插入`The Dark Knight`电影记录：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you observe the code, we imported the `mgo` package as well as the `bson`
    package. Next, we created the structs that model our JSON to be inserted into
    the DB. In the main function, we created a session using the **`mgo.Dial` **function.
    After that, we fetched a collection using the `DB` and `C` functions in a chained
    manner:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察代码，我们导入了`mgo`软件包以及`bson`软件包。接下来，我们创建了模型我们的JSON要插入到数据库中的结构。在主函数中，我们使用**`mgo.Dial`**函数创建了一个会话。之后，我们使用链式方式的`DB`和`C`函数获取了一个集合：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, `c` stands for collection. We are fetching the movies collection from `appdb`.Then,
    we are creating a struct object by filling in data. Next, we used the **`Insert` **function
    on the `c` collectionto insert `darkNight` data into the collection. This function
    can also take a list of struct objects to insert a batch of movies. Then, we used
    the **`Find` **function on the collection to read a movie with a given criteria.
    Here, the criteria (querying) is formed differently compared to the one we used
    in the shell. Since Go is not the JavaScript shell, we need a translator that
    can convert a normal filter query to the MongoDB understandable query. The **`bson.M` **function
    is designed for that in `mgo` package:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`c`代表集合。我们正在从`appdb`中获取movies集合。然后，我们通过填充数据创建了一个结构对象。接下来，我们在`c`集合上使用**`Insert`**函数将`darkNight`数据插入集合中。该函数还可以接受一系列结构对象，以插入一批电影。然后，我们在集合上使用**`Find`**函数来读取具有给定条件的电影。在这里，与我们在shell中使用的条件不同，查询条件（查询）的形成也不同。由于Go不是JavaScript
    shell，我们需要一个可以将普通过滤查询转换为MongoDB可理解查询的转换器。`mgo`软件包中的**`bson.M`**函数就是为此而设计的：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But, what if we need to perform advanced queries with operators? We can do
    this by just replacing the plain JSON syntax with the `bson.M` function. We can
    find a movie from the database whose budget is more than $150,000,000with this
    query:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们需要使用运算符执行高级查询怎么办？我们可以通过用`bson.M`函数替换普通的JSON语法来实现这一点。我们可以使用以下查询从数据库中找到预算超过$150,000,000的电影：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you contrast this with the shell command, we just added `bson.M` in front
    of the JSON query and wrote the remaining query as it is. The operator symbol
    should be a string here (`"$gt"`).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将此与shell命令进行对比，我们只需在JSON查询前面添加`bson.M`，然后将其余查询按原样编写。操作符号应该在这里是一个字符串（`"$gt"`）。
- en: 'One more notable thing in the struct definition is that we added a `bson:identifier`
    tag to each field. Without this, Go stores the BoxOffice as boxoffice. So, in
    order for Go to maintain the CamelCase, we add these tags. Now, let us run this
    program and see the output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构定义中还有一个值得注意的事情是，我们为每个字段添加了`bson:identifier`标签。没有这个标签，Go会将BoxOffice存储为boxoffice。因此，为了让Go保持CamelCase，我们添加了这些标签。现在，让我们运行这个程序并查看输出：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output looks like the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The result from a query can be stored in a new struct and can be serialized
    to JSON for the client to use.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果可以存储在一个新的结构中，并可以序列化为JSON供客户端使用。
- en: RESTful API with Gorilla Mux and MongoDB
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gorilla Mux和MongoDB构建RESTful API
- en: 'In the previous chapters, we explored all the possible ways of building a RESTful
    API. We first looked into HTTP routers, then web frameworks. But as a personal
    choice, in order to make our API lightweight, one prefers Gorilla Mux as the default
    choice and `mgo` for the MongoDB driver. In this section, we are going to build
    a proper movies API with an end-to-end integration of the database and HTTP router.
    We saw how to create a new resource and retrieve it back using Go and MongoDB.
    Using that knowledge, let us write this program:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们探讨了构建RESTful API的所有可能方式。我们首先研究了HTTP路由器，然后是web框架。但作为个人选择，为了使我们的API轻量化，我们更喜欢Gorilla
    Mux作为默认选择，以及`mgo`作为MongoDB驱动程序。在本节中，我们将构建一个完整的电影API，其中包括数据库和HTTP路由器的端到端集成。我们看到了如何使用Go和MongoDB创建新资源并检索它。利用这些知识，让我们编写这个程序：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let us name this program `movieAPI.go` and run it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个程序命名为`movieAPI.go`并运行它：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we can make a `POST` API request using curl or Postman to create a new
    movie:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用curl或Postman发出`POST` API请求来创建一个新的电影：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This returns the following response:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下响应：
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our movie is successfully created. Here, the ID that is returned is generated
    by the `mgo` package. MongoDB expects the driver to provide the unique ID. If
    it''s not provided, then `Db` creates one itself. Now, let us make a `GET` API
    request using curl:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的电影已成功创建。这里返回的ID是由`mgo`包生成的。MongoDB希望驱动程序提供唯一的ID。如果没有提供，那么`Db`会自己创建一个。现在，让我们使用curl发出一个`GET`
    API请求：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It returns the same data that we got while creating the resource:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回了我们在创建资源时得到的相同数据：
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A lot of things are happening in the preceding program. We will explain it in
    detail in the upcoming sections.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中发生了很多事情。我们将在接下来的章节中详细解释。
- en: In the preceding program, the trivial logic for assigning the correct status
    codes is skipped in `PostMovie` for the sake of simplicity. The reader can feel
    free to modify the program to add the correct status codes for operations (200
    OK, 201 Created, and so on).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，为了简单起见，`PostMovie`中跳过了为操作分配正确状态代码的微不足道的逻辑。读者可以随意修改程序，为操作添加正确的状态代码（200
    OK，201 Created等）。
- en: At first, we are importing the necessary packages for our program. We imported `mgo`
    and `bson` for MongoDB-related implementation, Gorilla Mux for the HTTP router
    encoding/JSON, and ioutil for reading and writing JSON in the life cycle of an
    HTTP request.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入程序所需的必要包。我们导入了`mgo`和`bson`用于与MongoDB相关的实现，Gorilla Mux用于HTTP路由编码/JSON，以及ioutil用于在HTTP请求的生命周期中读取和写入JSON。
- en: 'Then, we created a struct called **`DB` **that stores the session and collection
    information of MongoDB. We need to have this in order to have a global session
    and use it for multiple things instead of creating a new session (client connection).
    Take a look at the following code snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个名为**`DB`**的结构，用于存储MongoDB的session和collection信息。我们需要这个结构，以便拥有全局session，并在多个地方使用它，而不是创建一个新的session（客户端连接）。看一下以下代码片段：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We need this because multiple HTTP handlers of Mux need this information. This
    is a simple trick of attaching common data to different functions. In Go, we can
    create a struct and add functions to it so that data in the struct is accessible
    in the functions. Then, we declared the structs that hold the information of the
    nested JSON for a movie. In Go, in order to create a nested JSON structure, we
    should nest the structures too.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这样做是因为Mux的多个HTTP处理程序需要这些信息。这是一种简单的将通用数据附加到不同函数的技巧。在Go中，我们可以创建一个结构，并向其添加函数，以便在函数中访问结构中的数据。然后，我们声明了存储电影嵌套JSON信息的结构。在Go中，为了创建嵌套的JSON结构，我们应该嵌套结构。
- en: Next, we defined two functions on the `DB` struct. We will use these functions
    as handlers for the Gorilla Mux router later. These two functions can access session
    and collection information without creating a new one. The **`GetMovie` **handler
    function reads the data from MongoDB and returns JSON back to the client. **`PostMovie` **creates
    a new resource (movie here) in the database in a collection called `moviex`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`DB`结构上定义了两个函数。我们将在后面使用这两个函数作为Gorilla Mux路由器的处理程序。这两个函数可以访问session和collection信息，而无需创建新的session。**`GetMovie`**处理程序从MongoDB读取数据，并将JSON返回给客户端。**`PostMovie`**在名为`moviex`的集合中在数据库中创建一个新资源（这里是电影）。
- en: Now, coming to the main function, we are creating the session and collection
    here. The `session` will be constant throughout the program's lifetime. But if
    needed, handler functions can override the collection by using a `session` variable.
    This allows us to write reusable database parameters. Then, we created a new router
    and attached handler functions and routes using **`HandleFunc`. **Then, we created
    a server that runs on the `8000` port of localhost.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来到主函数，我们在这里创建了session和collection。`session`将在整个程序的生命周期内保持不变。但如果需要，处理函数可以通过使用`session`变量来覆盖collection。这使我们能够编写可重用的数据库参数。然后，我们创建了一个新的路由器，并使用**`HandleFunc`**附加了处理函数和路由。然后，我们创建了一个在localhost的`8000`端口上运行的服务器。
- en: 'In `PostMovie`,we are creating a new hash ID using **`bson.NewObjectId()` **of
    the `mgo` function. This function returns the new hash each and every time we
    call it. We then pass this to the struct that we insert into the DB. We insert
    a document in the collection using the **`collection.Insert`** moviefunction.
    This returns an error if something goes wrong. For sending a message back, we
    are marshaling a struct using `json.Marshal`. If you carefully observe the structure
    of the `Movie` struct, it is like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PostMovie`中，我们使用`mgo`函数的**`bson.NewObjectId()`**创建一个新的哈希ID。这个函数每次调用时都会返回一个新的哈希。然后我们将其传递给我们插入到数据库中的结构。我们使用**`collection.Insert`**
    moviefunction在集合中插入一个文档。如果出现问题，这将返回一个错误。为了发送一条消息回去，我们使用`json.Marshal`对一个结构进行编组。如果你仔细观察`Movie`结构的结构，它是这样的：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The identifier on the right side, ``json:"id" bson:"_id,omitempty"``, is a helper
    to show how to serialize when marshaling or unmarshaling is performed on the struct.
    The `bson`tag shows how to insert the fields into MongoDB. `json`shows what format
    our HTTP handler should receive and send data from and to the client respectively.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的标识符``json:"id" bson:"_id,omitempty"``是一个辅助工具，用于在对结构执行编组或解组时显示序列化的方式。`bson`标签显示了如何将字段插入到MongoDB中。`json`显示了我们的HTTP处理程序应该从客户端接收和发送数据的格式。
- en: 'In `GetMovie`, we are fetching the ID passed as the path parameter using the `Mux.vars`map.
    We cannot directly pass the ID to MongoDB because it expects a BSON object instead
    of a plain string. In order to achieve that, we use the **`bson.ObjectIdHex` **function.
    Once we get the movie of the given ID, that will be loaded into the struct object.
    Next, we serialize it to JSON using the **`json.Marshal` **function and will send
    it back to the client. We can easily add `PUT` (update) and `DELETE` methods to
    the preceding code. We just need to define two more handlers, as shown in the
    following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetMovie`中，我们使用`Mux.vars`映射来获取作为路径参数传递的ID。我们不能直接将ID传递给MongoDB，因为它期望的是BSON对象而不是普通字符串。为了实现这一点，我们使用**`bson.ObjectIdHex`**函数。一旦我们得到了给定ID的电影，它将被加载到结构对象中。接下来，我们使用**`json.Marshal`**函数将其序列化为JSON，并将其发送回客户端。我们可以很容易地向前面的代码中添加`PUT`（更新）和`DELETE`方法。我们只需要定义另外两个处理程序，如下所示：
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The approach is exactly the same, except the DB methods of `mgo` are different.
    Here, we used the `Update` and `Remove` functions. Since these are not important
    ones, we can just send the status back to the client with no body. For those handlers
    to be active, we need to add these two lines in the main block of the preceding
    program:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与`mgo`的DB方法完全相同。在这里，我们使用了`Update`和`Remove`函数。由于这些不重要，我们可以只向客户端发送状态而不发送正文。为了使这些处理程序处于活动状态，我们需要在前面程序的主块中添加这两行：
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The complete code for these additions is available in the `chapter5/movieAPI_updated.go`
    file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些添加的完整代码可以在`chapter5/movieAPI_updated.go`文件中找到。
- en: Boosting the querying performance with indexing
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过索引提高查询性能
- en: We all know that while reading a book, indexes are very important. When we try
    to search for a topic in the book, we first roll our eyes through the index page.
    If the index is found, then we go to the specific page number for that topic.
    But there is a drawback here. We are using additional pages for the sake of this
    indexing. Similarly, MongoDB needs to go through all the documents whenever we
    query for something. If the document stores indexes for important fields, it can
    give back data to us quickly. At the same time, we are wasting extra space for
    indexing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，在阅读一本书时，索引非常重要。当我们试图在书中搜索一个主题时，我们首先翻阅索引页。如果找到索引，然后我们去到该主题的具体页码。但这里有一个缺点。我们为了这种索引而使用了额外的页面。同样，当我们查询某些内容时，MongoDB需要遍历所有文档。如果文档存储了重要字段的索引，它可以快速地将数据返回给我们。与此同时，我们浪费了额外的空间来进行索引。
- en: 'In the computing field, the B-tree is an important data structure to implement
    indexing because it can categorize nodes. By traversing that tree, we can find
    the data we need in fewer steps. We can create an index using the `createIndex`
    function provided by MongoDB. Let us take an example of students and their scores
    in an examination. We will be doing `GET` operations more frequently with the
    sorting of scores. The indexing for this scenario can be visualized in this form.
    Take a look at the following diagram:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算领域，B树是一个重要的数据结构，用于实现索引，因为它可以对节点进行分类。通过遍历该树，我们可以在较少的步骤中找到我们需要的数据。我们可以使用MongoDB提供的`createIndex`函数来创建索引。让我们以学生和他们在考试中的分数为例。我们将更频繁地进行`GET`操作，并对分数进行排序。这种情况下的索引可以用以下形式来可视化。看一下下面的图表：
- en: '![](img/b04cf3da-323c-4ca5-81d2-67fd41c87303.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b04cf3da-323c-4ca5-81d2-67fd41c87303.png)'
- en: This is the official example given by the MongoDB website. The score is the
    field to be indexed because of frequent use. Once it is indexed, the database
    stores the address for each document in a binary tree. Whenever someone queries
    this field, it checks for the range operator (in this case, it's `$lt`), traverses
    the binary tree, and gets the addresses of documents in shorter steps. Since the
    scoreis indexed, the sort operations are less costly. So, the time that it takes
    for the database to return the sorted (ascending or descending) result is shorter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是MongoDB网站提供的官方示例。由于频繁使用，分数是要进行索引的字段。一旦进行了索引，数据库就会在二叉树中存储每个文档的地址。每当有人查询这个字段时，它会检查范围运算符（在这种情况下是`$lt`），遍历二叉树，并以更短的步骤获取文档的地址。由于分数被索引，排序操作的成本较低。因此，数据库返回排序（升序或降序）结果所需的时间更短。
- en: 'Coming to our previous examples of the movies API, we can create indexes for
    data. By default, all `_id`fields are indexed, here using mongo shell to show
    that. Previously, we treated the year field as a string. Let us modify that to
    an integer and index it. Launch mongo shell using `mongo` command. Use a new mongo
    database and insert one document into it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的电影API示例，我们可以为数据创建索引。默认情况下，所有`_id`字段都被索引，这里使用mongo shell来展示。以前，我们将年份字段视为字符串。让我们将其修改为整数并进行索引。使用`mongo`命令启动mongo
    shell。使用一个新的mongo数据库并将一个文档插入其中：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Insert one more similar document with the different data:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再插入一个类似的不同数据的文档：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let us add indexing to the year with the `createIndex` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`createIndex`函数为年份添加索引：
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This single line adds the magic for retrieving the database records faster.
    Now, all the queries related to year leverage the indexing:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行为检索数据库记录添加了魔力。现在，所有与年份相关的查询都利用了索引：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There is no difference in the query result. But the lookup mechanism for documents
    by `MongoDB` has changed by indexing. For a larger number of documents, that could
    reduce the lookup time drastically.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果没有区别。但是通过索引，`MongoDB`文档的查找机制已经发生了变化。对于大量文档，这可能会大大减少查找时间。
- en: Indexing comes with a cost. Some queries run very slowly on different fields
    if indexing is not done properly. We can also have compound indexes in MongoDB
    that can index multiple fields.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是有成本的。如果索引没有正确地进行，一些查询在不同字段上运行得非常慢。在MongoDB中，我们还可以有复合索引，可以索引多个字段。
- en: 'In order to see the time of execution of a query, use the `explain` function
    after a `query` function. For example, `db.movies.find({year: {$lt: 2010}}).explain("executionStats")`.
    This explains the winning plan for a query, the time taken in milliseconds, indexes
    used, and so on.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '为了查看查询的执行时间，请在`query`函数之后使用`explain`函数。例如，`db.movies.find({year: {$lt: 2010}}).explain("executionStats")`。这将解释查询的获胜计划，以毫秒为单位的时间，使用的索引等等。'
- en: See the performance of indexed and non-indexed data using the `explain` function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`explain`函数查看索引和非索引数据的性能。
- en: Designing an e-commerce data document model
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计电子商务数据文档模型
- en: 'Up until now, we have seen how to interact with MongoDB and perform CRUD operations
    for our REST API. Here, we are going to define a real-world JSON document that
    can be implemented by MongoDB. Let us lay down the design of JSON for an e-commerce
    problem. These five components are a must for any e-commerce design:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何与MongoDB交互，并为我们的REST API执行CRUD操作。在这里，我们将定义一个可以由MongoDB实现的真实世界JSON文档。让我们为电子商务问题的JSON设计提出设计。这五个组件对于任何电子商务设计都是必不可少的：
- en: Product
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Customer/user
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户/用户
- en: Category
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类别
- en: Order
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单
- en: Review
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾
- en: 'Let us see a schema of each and every component:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个组件的模式：
- en: 'Product:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 产品：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Category:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'User:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 用户：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Order:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Review:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: All the preceding schemas are to give an idea of how an e-commerce REST service
    can be designed. All the necessary fields should be included in the final data.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述的模式都是为了让人了解如何设计电子商务REST服务。最终数据中应包含所有必要的字段。
- en: Note that the preceding JSON is not true JSON, but the form used in the Mongo
    shell. Please observe that difference while creating the service. The schema is
    given so that the reader can see how e-commerce relational data is designed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前述的JSON不是真正的JSON，而是Mongo shell中使用的形式。在创建服务时请注意这种差异。提供模式是为了让读者看到电子商务关系数据的设计方式。
- en: Since we defined the schema, there is a coding exercise for the reader. Can
    you create a REST service with the preceding schema by leveraging the knowledge
    we gained in the beginning sections of this chapter? Anyway, we will implement
    this model in other databases in upcoming chapters.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经定义了模式，读者可以进行编码练习。您能否利用我们在本章开头部分获得的知识来创建一个符合前述模式的REST服务？无论如何，我们将在接下来的章节中在其他数据库中实现这个模型。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: First, we started the chapter with an introduction to MongoDB and how it solves
    the problems of the modern web. MongoDB is a NoSQL database that is different
    from traditional relational databases. Then, we learned how to install MongoDB
    on all platforms and how to start the Mongo server. We then explored the features
    of the Mongo shell. The Mongo shell is a tool for quick checking or performing
    CRUD operations and many other operations in MongoDB. We looked at operator symbols
    for querying. We next introduced Go's MongoDB driver called `mgo`and learned its
    usages. We created a persistent movies API with the help of `mgo` and MongoDB.
    We saw how to map a Go struct to a JSON document.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从介绍MongoDB及其如何解决现代Web问题开始了本章。MongoDB是一种与传统关系数据库不同的NoSQL数据库。然后，我们学习了如何在所有平台上安装MongoDB以及如何启动Mongo服务器。然后我们探索了Mongo
    shell的特性。Mongo shell是一个用于快速检查或执行CRUD操作以及许多其他操作的工具。我们看了查询的操作符符号。接下来我们介绍了Go的MongoDB驱动程序`mgo`并学习了它的用法。我们使用`mgo`和MongoDB创建了一个持久的电影API。我们看到了如何将Go结构映射到JSON文档。
- en: Not all the queries are efficient in MongoDB. So, for boosting the query performance,
    we saw the indexing mechanism that reduces the document fetching time by arranging
    the documents in the order of a B-tree. We saw how to measure the execution time
    of a query using the `explain` command. Finally, we laid out an e-commerce document
    design by providing the BSON (Mongo shell's JSON).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，并非所有查询都是高效的。因此，为了提高查询性能，我们看到了通过索引机制来减少文档获取时间的方法，通过将文档按B树的顺序排列。我们看到了如何使用`explain`命令来测量查询的执行时间。最后，我们通过提供BSON（Mongo
    shell的JSON）来设计了一个电子商务文档。
