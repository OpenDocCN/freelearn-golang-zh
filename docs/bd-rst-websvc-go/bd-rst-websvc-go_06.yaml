- en: Working with Protocol Buffers and GRPC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协议缓冲区和GRPC
- en: In this chapter, we are going to enter the world of protocol buffers. We are
    going to discover the benefits of using protocol buffers instead of JSON, and
    where to use both. We will use Google's `proto` library to compile protocol buffers.
    We will try to write a few web services with protocol buffers that can talk to
    either Go, or other applications such as Python, NodeJS, and so on. Then, we will
    explain GRPC, an advanced simplified form of RPC. We will learn how GRPC and protocol
    buffers can help us build services that can be consumed by any client. We will
    also discuss HTTP/2 and its benefits over plain HTTP/1.1 JSON-based services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进入协议缓冲区的世界。我们将发现使用协议缓冲区而不是JSON的好处，以及何时使用两者。我们将使用Google的`proto`库来编译协议缓冲区。我们将尝试使用协议缓冲区编写一些可以与Go或其他应用程序（如Python、NodeJS等）通信的Web服务。然后，我们将解释GRPC，一种高级简化的RPC形式。我们将学习GRPC和协议缓冲区如何帮助我们构建可以被任何客户端消费的服务。我们还将讨论HTTP/2及其优势，以及其在普通HTTP/1.1基于JSON的服务上的优势。
- en: 'In short, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将涵盖以下主题：
- en: Protocol buffers introduction
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议缓冲区介绍
- en: Format of the protocol buffers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议缓冲区的格式
- en: Compilation process of a protobuf
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议缓冲区的编译过程
- en: GRPC, a modern RPC library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GRPC，一个现代的RPC库
- en: Bidirectional streaming with GRPC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GRPC进行双向流
- en: Getting the code
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码
- en: You can get the code samples for this chapter from [https://github.com/narenaryan/gorestful/tree/master/chapter6](https://github.com/narenaryan/gorestful/tree/master/chapter6).
    This chapter's examples are a combination of single programs and projects. So,
    copy the respective directory to your `GOPATH` to run the code samples properly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/narenaryan/gorestful/tree/master/chapter6](https://github.com/narenaryan/gorestful/tree/master/chapter6)获取本章的代码示例。本章的示例是单个程序和项目的组合。因此，请将相应的目录复制到您的`GOPATH`中，以正确运行代码示例。
- en: Introduction to protocol buffers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议缓冲区介绍
- en: 'HTTP/1.1 is the standard that is adopted by the web community. In recent times,
    HTTP/2 is becoming more popular because of its advantages. Some of the benefits
    of using HTTP/2 are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1是Web社区采用的标准。近年来，由于其优势，HTTP/2变得更加流行。使用HTTP/2的一些好处包括：
- en: Encryption of data via TLS (HTTPS)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过TLS（HTTPS）加密数据
- en: Compression of headers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部压缩
- en: Single TCP connection
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个TCP连接
- en: Fallback to HTTP/1.1
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回退到HTTP/1.1
- en: Support from all major browsers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有主要浏览器的支持
- en: 'The technical definition from Google about protocol buffers is:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌关于协议缓冲区的技术定义是：
- en: Protocol buffers are a flexible, efficient, automated mechanism for serializing
    structured data – think XML, but smaller, faster, and simpler. You define how
    you want your data to be structured once, then you can use special generated source
    code to easily write and read your structured data to and from a variety of data
    streams and using a variety of languages. You can even update your data structure
    without breaking deployed programs that are compiled against the "old" format.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区是一种灵活、高效、自动化的序列化结构化数据的机制 - 想象一下XML，但更小、更快、更简单。您只需定义一次您希望数据结构化的方式，然后您可以使用特殊生成的源代码轻松地将您的结构化数据写入和从各种数据流中读取，并使用各种语言。您甚至可以更新数据结构，而不会破坏针对“旧”格式编译的已部署程序。
- en: In Go, protocol buffers are coupled with HTTP/2\. They are a format like JSON
    but strictly typed, understandable only from the client to the server. First,
    we will understand why protobufs (short form of protocol buffers) exist and how
    to use them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，协议缓冲区与HTTP/2结合在一起。它们是一种类似JSON但严格类型化的格式，只能从客户端到服务器理解。首先，我们将了解为什么存在protobufs（协议缓冲区的简称）以及如何使用它们。
- en: 'Protocol buffers have many advantages over JSON/XML for serializing structured
    data, such as:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区在序列化结构化数据方面比JSON/XML有许多优势，例如：
- en: They are simpler
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们更简单
- en: They are 3 to 10 times smaller
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的大小是JSON/XML的3到10倍
- en: They are 20 to 100 times faster
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们快20到100倍
- en: They are less ambiguous
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不太模棱两可
- en: They generate data access classes that are easier to use programmatically
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们生成易于以编程方式使用的数据访问类
- en: Protocol buffer language
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议缓冲区语言
- en: A protocol buffer is a file with a minimalistic language syntax. We compile
    a protocol buffer and the target file is generated for a programming language.
    For example, in Go, the compiled file will be a `.go` file with structs mapping
    the protobuf file. In Java, a class file will be created. Think protocol buffer
    as the skeleton for data with a particular order. We need to know the types before
    jumping into the actual code. In order to make things easier, I am going to first
    show JSON and its equivalent in protocol buffers. Then, we will implement a solid
    example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区是具有极简语法的文件。我们编译协议缓冲区，目标文件将为编程语言生成。例如，在Go中，编译后的文件将是一个`.go`文件，其中包含映射protobuf文件的结构。在Java中，将创建一个类文件。将协议缓冲区视为具有特定顺序的数据的骨架。在跳入实际代码之前，我们需要了解类型。为了使事情变得更容易，我将首先展示JSON及其在协议缓冲区中的等效内容。然后，我们将实施一个实例。
- en: Here, we are going to use **proto3** as our protocol buffer version. There are
    slight variations in versions, but the latest one was released with improvements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用**proto3**作为我们的协议缓冲区版本。版本之间存在细微差异，但最新版本已经发布并进行了改进。
- en: 'There are many types of protocol buffer elements. Some of them are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的协议缓冲区元素。其中一些是：
- en: Scalar values
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量值
- en: Enumerations
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Default values
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认值
- en: Nested values
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套值
- en: Unknown types
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未知类型
- en: 'First, let us see how to define a message type in a protobuf. Here, we try
    to define a simple network interface message:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何在协议缓冲区中定义消息类型。在这里，我们尝试定义一个简单的网络接口消息：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The syntax may look new. In the preceding code, we were defining a message
    type called `NetworkInterface`.It has four fields: *index*, *maximum transmission
    unit (MTU)*, *name*, and *hardware address (MAC)*. If we wish to write the same
    in JSON, it would look like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 语法可能看起来很新。在前面的代码中，我们正在定义一个名为`NetworkInterface`的消息类型。它有四个字段：*index*、*最大传输单元（MTU）*、*名称*和*硬件地址（MAC）*。如果我们希望在JSON中写入相同的内容，它将如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The field names are changed to comply with the JSON style guide, but the essence
    and structure are the same. But, what are the sequential numbers (1,2,3,4) given
    to fields in the protobuf file? They are the ordering tags given to serialize
    and deserialize protocol buffer data between two systems. It is like hinting the
    protocol buffer encoding/decoding systems to write/read the data in that particular
    order, respectively. When the preceding protobuf file is compiled and the programming
    language target is generated, the protocol buffer message will be converted to
    a Go struct and fields are filled with empty default values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 字段名称已更改以符合JSON样式指南，但本质和结构是相同的。但是，在protobuf文件中给字段分配的顺序号（1,2,3,4）是什么？它们是序列化和反序列化协议缓冲区数据在两个系统之间的顺序标签。这类似于提示协议缓冲区编码/解码系统按照特定顺序分别写入/读取数据。当上述protobuf文件被编译并生成编程语言目标时，协议缓冲区消息将被转换为Go结构，并且字段将填充为空的默认值。
- en: Scalar values
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标量值
- en: 'The types we assigned to the fields in the `networkInterface` message are scalar
    types. These types are similar to Go types and exactly match with them. For other
    programming languages, they will be converted to the respective types. A protobuf
    is designed keeping Go in mind, so the majority of types such as `int`, `int32`,
    `int64`, `string`, and `bool`are exactly the same, but a few vary. They are:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`networkInterface`消息中的字段分配的类型是标量类型。这些类型类似于Go类型，并且与它们完全匹配。对于其他编程语言，它们将转换为相应的类型。Protobuf是为Go设计的，因此大多数类型（如`int`，`int32`，`int64`，`string`和`bool`）完全相同，但有一些不同。它们是：
- en: '| **Go type** | **Protobuf type** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '**Go类型** | **Protobuf类型**'
- en: '| `float32` | `float` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: float32 | float
- en: '| `float64` | `double` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: float64 | double
- en: '| `uint32` | `fixed32` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: uint32 | fixed32
- en: '| `uint64` | `fixed64` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: uint64 | fixed64
- en: '| `[]byte` | `bytes` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '[]byte | bytes'
- en: 'These things should be kept in mind while defining messages in protbuf files.
    Apart from that, we are free to use other Go types as normal scalar types. **Default
    values **are the values that will be filled with those types if the user doesn''t
    assign a value to those scalar values. We all know that in any given programming
    language, variables are defined and assigned. Defining allocates memory for the
    variable and assigning fills the variable with a value. In analogy, the scalar
    fields we defined in the preceding message will be assigned with default values.
    Let us see the default values for the given types:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义protbuf文件中的消息时，应该牢记这些事情。除此之外，我们可以自由地使用其他Go类型作为普通标量类型。**默认值**是如果用户没有为这些标量值分配值，则将填充这些类型的值。我们都知道在任何给定的编程语言中，变量是被定义和赋值的。定义为变量分配内存，赋值为变量填充值。类比地，我们在前面的消息中定义的标量字段将被分配默认值。让我们看看给定类型的默认值：
- en: '| **Protobuf type** | **Default value** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '**Protobuf类型** | **默认值**'
- en: '| `string` | `""` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: 字符串 | ""
- en: '| `bytes` | `empty bytes[]` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: bytes | 空字节[]
- en: '| `bool` | `false` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: bool | false
- en: '| `int`, `int32`, `int64`, `float`, `double` | `0` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: int，int32，int64，float，double | 0
- en: '| `enum` | `0` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: enum | 0
- en: Since protocol buffers make an agreement between end systems using a data structure,
    they don't take additional space for keys in JSON.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于协议缓冲区使用数据结构在端系统之间达成协议，因此在JSON中不需要为键占用额外的空间。
- en: Enumerations and repeated fields
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举和重复字段
- en: 'Enumerations provide the ordering of numbers for a given set of elements. The
    default order of values is from zero to *n*. So, in protocol buffer messages,
    we can have an enumeration type. Let us see an example of the `enum`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举为给定元素集提供数字的排序。默认值的顺序是从零到n。因此，在协议缓冲区消息中，我们可以有一个枚举类型。让我们看一个`enum`的例子：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What if we need to assign the same values for the multiple enumeration members.
    Protobuf3 allows an option called **allow aliases **to assign two different members
    the same value. For example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要为多个枚举成员分配相同的值怎么办。Protobuf3允许使用名为**allow aliases**的选项来为两个不同的成员分配相同的值。例如：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `STARTED` and `RUNNING` both have a `1` tag. This means that both can
    have the same value in the data. If we try to remove duplicated values, we should
    also remove the `allow_alias`option. Otherwise, the proto compiler throws an error
    (we will see shortly what a proto compiler is).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`STARTED`和`RUNNING`都有一个`1`标签。这意味着数据中两者可以具有相同的值。如果我们尝试删除重复的值，我们还应该删除`allow_alias`选项。否则，proto编译器会抛出错误（我们很快将看到proto编译器是什么）。
- en: '`Repeated` fields are the fields in the message of a protocol buffer that represent
    a list of items. In JSON, we have a list of elements for a given key. Similarly,
    repeated fields allow us to define an array/list of elements of a particular type:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Repeated`字段是协议缓冲区消息中表示项目列表的字段。在JSON中，对于给定的键，我们有一系列元素。同样，重复字段允许我们定义特定类型的元素的数组/列表：'
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, the third field is a repeated field, which means it
    is an array/list of proxies. The value could be something such as `["100.104.112.10",
    "100.104.112.12"]`, and so on. Apart from repeated fields, we can also use other
    messages as types. It is analogous to nested JSON. For example, take a look at
    the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，第三个字段是一个重复字段，这意味着它是一个代理的数组/列表。该值可以是诸如["100.104.112.10", "100.104.112.12"]之类的内容。除了重复字段，我们还可以使用其他消息作为类型。这类似于嵌套的JSON。例如，看一下以下代码：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We see we have a nested `innerJSON`as one of the members of `outerJSON`. How
    can we model the same thing in protobufs? We can do it using the nested messages,
    as shown in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`innerJSON`嵌套在`outerJSON`的成员之一。我们如何在protobuf中建模相同的事物？我们可以使用嵌套消息来做到这一点，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we are nesting the `Proxy` type into the `Site`. We will soon see a real
    example with all these types of fields.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`Proxy`类型嵌套到`Site`中。我们很快将看到一个包含所有这些类型字段的真实示例。
- en: Compiling a protocol buffer with protoc
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用protoc编译协议缓冲区
- en: 'Until now, we have discussed how to write a protocol buffer file that is previously
    written in JSON or another data format. But, how do we actually integrate it into
    our programs? Remember that protocol buffers are data formats, no more than that.
    They are a format of communication between various systems, similar to JSON. These
    are the practical steps we follow for using protobufs in our Go programs:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何编写协议缓冲区文件，该文件以前是用JSON或其他数据格式编写的。但是，我们如何将其实际集成到我们的程序中呢？请记住，协议缓冲区是数据格式，不仅仅是数据格式。它们是各种系统之间的通信格式，类似于JSON。这是我们在Go程序中使用protobuf的实际步骤：
- en: Install the `protoc` command-line tool and the `proto` library.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`protoc`命令行工具和`proto`库。
- en: Write a protobuf file with the `.proto` extension.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个带有`.proto`扩展名的protobuf文件。
- en: Compile it to target a programming language (here, it is Go).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其编译为目标编程语言（这里是Go）。
- en: Import structs from the generated target file and serialize the data.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从生成的目标文件中导入结构并序列化数据。
- en: On a remote machine, receive the serialized data and decode it into a struct
    or class.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在远程机器上，接收序列化数据并将其解码为结构或类。
- en: 'Take a look at the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图表：
- en: '![](img/6db67127-8a0c-4e2e-b2c9-b4ae112087c7.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6db67127-8a0c-4e2e-b2c9-b4ae112087c7.jpg)'
- en: 'The first step is to install the `protobuf` compiler on our machine. For this,
    download the `protobuf` package from [https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases).
    On macOS X, we can install `protobuf` using this command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在我们的机器上安装`protobuf`编译器。为此，请从[https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases)下载`protobuf`包。在macOS
    X上，我们可以使用此命令安装`protobuf`：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On Ubuntu or Linux, we can copy `protoc` to the `/usr/bin` folder:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu或Linux上，我们可以将`protoc`复制到`/usr/bin`文件夹中：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On Windows, we can just copy the executable (`.exe`) from [https://github.com/google/protobuf/releases/download/v3.3.0/protoc-3.3.0-win32.zip](https://github.com/google/protobuf/releases/download/v3.3.0/protoc-3.3.0-win32.zip) to
    the `PATH` environment variable. Let us write a simple protocol buffer to illustrate
    how to compile and use structs from the target file. Create a folder called `protofiles`
    in `$GOPATH/src/github.com/narenaryan` (this is the place for our Go projects)
    using the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们可以从[https://github.com/google/protobuf/releases/download/v3.3.0/protoc-3.3.0-win32.zip](https://github.com/google/protobuf/releases/download/v3.3.0/protoc-3.3.0-win32.zip)复制可执行文件（`.exe`）到`PATH`环境变量。让我们编写一个简单的协议缓冲区来说明如何编译和使用目标文件中的结构。使用以下命令在`$GOPATH/src/github.com/narenaryan`（这是我们Go项目的位置）中创建一个名为`protofiles`的文件夹：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, create a file called `person.proto`, which models a person''s information.
    Add a few messages to it, as shown in the following code snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建一个名为`person.proto`的文件，它模拟了一个人的信息。向其中添加一些消息，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We created two main messages called `AddressBook` and `Person`.`AddressBook`
    has a list of persons. A `Person` has a `name`, `id`, `email`, and `phone Number`. 
    In the second line, we declared the package as `protofiles` like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个主要消息，称为`AddressBook`和`Person`。`AddressBook`有一个人员列表。`Person`有`name`、`id`、`email`和`phone
    Number`。在第二行，我们将包声明为`protofiles`，如下所示：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This tells the compiler to add the generating file in relation to the given
    package name. Go cannot consume this `.proto` file directly.  We need to compile
    it to a valid Go file. When compiled, this package name `protofiles` will be used
    to set the  package of the output file (Go in this case). To compile this protocol
    buffer file, traverse to the `protofiles` directory and run this command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉编译器将生成的文件添加到给定包名称的相关位置。Go不能直接使用这个`.proto`文件。我们需要将其编译为有效的Go文件。编译后，此包名称`protofiles`将用于设置输出文件（在本例中为Go）的包。要编译此协议缓冲区文件，请转到`protofiles`目录并运行此命令：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command converts the given protocol buffer file(s) to the Go file(s) with
    the same name. You will see that, after running this command, there is a new file
    created in the same directory:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将给定的协议缓冲区文件转换为具有相同名称的Go文件。运行此命令后，您将看到在同一目录中创建了一个新文件：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The new file name is `person.pb.go`.If we open and inspect this file, it contains
    the following important block:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 新文件名为`person.pb.go`。如果我们打开并检查此文件，它包含以下重要块：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is just a part of that file. There will be many getter and setter methods
    created for the given structs such as `Person` and `AddressBook` in the output
    file. This code is automatically generated. We need to consume this code in the
    main program to create protocol buffer strings. Now, let us create a new directory
    called `protobufs`.This holds the `main.go` file that uses the `Person` struct
    from the `person.pb.go` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是该文件的一部分。将为给定的结构（如`Person`和`AddressBook`）创建许多getter和setter方法。此代码是自动生成的。我们需要在主程序中使用此代码来创建协议缓冲区字符串。现在，让我们创建一个名为`protobufs`的新目录。其中包含使用`person.pb.go`文件中的`Person`结构的`main.go`文件：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, for Go to serialize a struct to the protobinary format, we need to install
    the Go proto driver. Install it using the `go get` command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了让Go将结构序列化为协议二进制格式，我们需要安装Go proto驱动程序。使用`go get`命令安装它：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After this, let us compose `main.go`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们编写`main.go`：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are importing the **protocol buffer** (**pb**) from the `protofiles` package.
    There are structs that are mapped to the given protobuf in the `proto files.`
    We used the `Person` struct and initialized it. Then, we serialized the struct
    using the `proto.Marshal`function. If we run this program, the output looks like
    this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`protofiles`包中导入**协议缓冲区**（**pb**）。在`proto files`中，有一些结构映射到给定的协议缓冲区。我们使用`Person`结构并对其进行初始化。然后，我们使用`proto.Marshal`函数对结构进行序列化。如果我们运行这个程序，输出如下：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The second output of marshaled data is not intuitive because the `proto` library
    serializes data into binary bytes. Another good thing about protocol buffers in
    Go is that the structs generated by compiling the proto files can be used to generate
    JSON on the fly. Let us modify the preceding example to this. Call it `main_json.go`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '序列化数据的第二个输出并不直观，因为`proto`库将数据序列化为二进制字节。协议缓冲区在Go中的另一个好处是，通过编译proto文件生成的结构体可以用于实时生成JSON。让我们修改前面的例子。将其命名为`main_json.go`： '
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we run this, it prints a JSON string that can be sent to any client that
    can understand JSON:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，它会打印一个JSON字符串，可以发送给任何能理解JSON的客户端：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Any other language or platform can easily load this JSON string and use the
    data instantly. So, what is the benefit of using protocol buffers instead of JSON?
    First of all, protocol buffers are intended for two backend systems to communicate
    with each other with less overhead. Since the size of the binary is less than
    text, protocol marshaled data is of less size than JSON.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他语言或平台都可以轻松加载这个JSON字符串并立即使用数据。那么，使用协议缓冲区而不是JSON有什么好处呢？首先，协议缓冲区旨在使两个后端系统以更小的开销进行通信。由于二进制的大小比文本小，协议缓冲区序列化的数据比JSON的大小小。
- en: By using protocol buffers we map both JSON and protocol buffer formats to the
    Go struct. This gives the best of both worlds by converting one format to another
    on the fly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用协议缓冲区，我们可以将JSON和协议缓冲区格式映射到Go结构。这通过在转换一个格式到另一个格式时实现了两全其美。
- en: But, protocol buffers are just a data format. They don't have any importance
    if we don't communicate. So here, protocol buffers are used to pass messages between
    two end systems in the form of RPC. We saw how RPC works and also created an RPC
    client and server in the previous chapters. Now, we are going to extend that knowledge
    to use **Google Remote Procedure Call** (**GRPC**) with protocol buffers to scale
    our microservice communications. A server and client, in this case, can talk with
    each other in protocol buffer format.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，协议缓冲区只是一种数据格式。如果我们不进行通信，它们就没有任何重要性。因此，在这里，协议缓冲区用于以RPC的形式在两个端系统之间传递消息。我们看到了RPC是如何工作的，并且在前几章中还创建了RPC客户端和服务器。现在，我们将扩展这些知识，使用**Google远程过程调用**（**GRPC**）与协议缓冲区来扩展我们的微服务通信。在这种情况下，服务器和客户端可以以协议缓冲区格式进行通信。
- en: Introduction to GRPC
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GRPC简介
- en: GRPC is a transport mechanism that sends and receives messages between two systems.
    These two systems are traditionally a server and a client. As we described in
    the previous chapters, RPC can be implemented in Go for transferring JSON. We
    called it a JSON RPC service. Similarly, Google RPC is specially designed to transfer
    data in the form of protocol buffers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: GRPC是一种在两个系统之间发送和接收消息的传输机制。这两个系统通常是服务器和客户端。正如我们在前几章中所描述的，RPC可以在Go中实现以传输JSON。我们称之为JSON
    RPC服务。同样，Google RPC专门设计用于以协议缓冲区的形式传输数据。
- en: GRPC makes the service creation easy and elegant. It provides a nice set of
    APIs to define services and start running them. In this section, we will mainly
    focus on how to create a GRPC service and use it. The main advantage of GRPC is
    that it can be understood by multiple programming languages. Protocol buffers
    provide a common data structure. So, the combination enables the seamless communication
    between various tech stacks and systems. This is the integral concept of distributed
    computing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: GRPC使服务创建变得简单而优雅。它提供了一套不错的API来定义服务并开始运行它们。在本节中，我们将主要关注如何创建GRPC服务并使用它。GRPC的主要优势是它可以被多种编程语言理解。协议缓冲区提供了一个通用的数据结构。因此，这种组合使各种技术堆栈和系统之间能够无缝通信。这是分布式计算的核心概念。
- en: Square, Netflix, and so on leverage this GRPC to scale their huge traffic-prone
    services. Google's former product manager, Andrew Jessup, said in a conference
    that at Google, billions of GRPC calls are processed every single day. If any
    business organization needs to embrace what Google does, it too can handle the
    traffic demand with these tweaks in the services.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Square、Netflix等公司利用GRPC来扩展其庞大的流量服务。Google的前产品经理Andrew Jessup在一次会议上表示，在Google，每天处理数十亿次GRPC调用。如果任何商业组织需要采用Google的做法，它也可以通过对服务进行调整来处理流量需求。
- en: 'We need to install the `grpc` Go library and a `protoc-gen` plugin before writing
    the services. Install them using the following commands:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写服务之前，我们需要安装`grpc` Go库和`protoc-gen`插件。使用以下命令安装它们：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'GRPC has the following benefits over traditional HTTP/REST/JSON architecture:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: GRPC相对于传统的HTTP/REST/JSON架构具有以下优势：
- en: GRPC uses HTTP/2, which is a binary protocol
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GRPC使用HTTP/2，这是一种二进制协议
- en: Header compression is possible in HTTP/2, which means less overhead
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP/2中可以进行头部压缩，这意味着开销更小
- en: We can multiplex many requests on one connection
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在一个连接上复用多个请求
- en: Usage of protobufs for strict typing of data
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协议缓冲区进行数据的严格类型化
- en: Streaming of requests or responses is possible instead of request/response transactions
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以进行请求或响应的流式传输，而不是请求/响应事务
- en: 'Take a look at the following diagram:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图表：
- en: '![](img/8c77a0c5-6a5f-452f-b00f-d52b9b258101.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c77a0c5-6a5f-452f-b00f-d52b9b258101.jpg)'
- en: 'The diagram clearly shows that any backend system or mobile app can directly
    communicate to a GRPC server by firing a protocol buffer request. Let us write
    a money transaction service in Go using GRPC and protocol buffers. Here, we are
    going to show how the client and server can be implemented. The steps are:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图表清楚地显示了任何后端系统或移动应用都可以通过发送协议缓冲区请求直接与GRPC服务器通信。让我们使用GRPC和协议缓冲区在Go中编写一个货币交易服务。在这里，我们将展示客户端和服务器的实现方式。步骤如下：
- en: Create the protocol buffer file for the service and messages.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为服务和消息创建协议缓冲区文件。
- en: Compile the protocol buffer file.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译协议缓冲区文件。
- en: Use the generated Go package for creating a GRPC server.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成的Go包创建一个GRPC服务器。
- en: Create a GRPC client that talks to the server.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与服务器通信的GRPC客户端。
- en: 'For this project, create a folder called `datafiles` in your Go workspace (here,
    it is `$GOPATH/src/github.com/narenaryan/`):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，在你的Go工作空间中创建一个名为`datafiles`的文件夹（这里是`$GOPATH/src/github.com/narenaryan/`）：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a file called `transaction.proto` in it with messages and a service
    defined. We will shortly see what a service is:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中创建一个名为`transaction.proto`的文件，其中定义了消息和一个服务。我们很快将看到服务是什么：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is a minimalistic protocol buffer for a money transaction on the server.
    We already saw about message keywords in the proto file. The last keyword, `service`,
    is new to us. `service` tells GRPC to treat it as a service, and all the RPC methods
    will act as an interface for a server that implements this. A struct that implements
    a Go interface should implement all its functions. Now, let us compile this file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是服务器上的一个最简单的协议缓冲文件，用于货币交易。我们已经在proto文件中看到了关于消息关键字的信息。最后一个关键字`service`对我们来说是新的。`service`告诉GRPC将其视为服务，并且所有的RPC方法将作为实现此服务的服务器的接口。实现Go接口的结构体应该实现所有的函数。现在，让我们编译这个文件：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This command is slightly bigger than the one we used previously. This is because
    here we are using the `protoc-gen-go` plugin. The command simply says to use data
    files as the input directory for proto files and use the same directory for outputting
    the target Go files. Now, if we see the filesystem, there will be two files:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令比我们之前使用的命令稍微长一些。这是因为这里我们使用了`protoc-gen-go`插件。该命令简单地表示使用数据文件作为协议文件的输入目录，并使用相同的目录输出目标Go文件。现在，如果我们查看文件系统，将会有两个文件：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, create two more directories for server and client logic in `$GOPATH/src/github.com/narenaryan/grpc_example`.
    The server implements the interface that is generated from the proto file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`$GOPATH/src/github.com/narenaryan/grpc_example`中创建另外两个目录，用于服务器和客户端逻辑。服务器实现了从proto文件生成的接口：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, add a file called `server.go` to the `grpcServer` directory, which implements
    the transaction service:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将一个名为`server.go`的文件添加到`grpcServer`目录中，该文件实现了交易服务：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are a lot of things happening in the preceding file. First, we imported
    all the necessary imports. The new ones here are `context` and `reflection`.Context
    is used to create a `context` variable, which lives throughout an RPC request's
    lifetime. Both of these libraries are used by GRPC for its internal functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文件中发生了很多事情。首先，我们导入了所有必要的导入项。这里的新导入项是`context`和`reflection`。Context用于创建一个`context`变量，它在RPC请求的整个生命周期内存在。这两个库都被GRPC用于其内部函数。
- en: 'Before explaining the next sections, if we open the generated `transaction.pb.go`
    file, we can clearly see that there are two important things:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释下一节之前，如果我们打开生成的`transaction.pb.go`文件，我们可以清楚地看到有两件重要的事情：
- en: The `RegisterMoneyTransactionServer` function
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegisterMoneyTransactionServer`函数'
- en: The `MakeTransaction` function as part of the  `MoneyTransactionServer` interface
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeTransaction`函数作为`MoneyTransactionServer`接口的一部分。'
- en: In order to implement a service, we need both of these things; `MakeTransaction`
    for the actual service functionality, and `RegisterMoneyTransactionServer` for
    registering the service (that is, create an RPC server to run on a port).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个服务，我们需要这两个东西：`MakeTransaction`用于实际的服务功能，以及`RegisterMoneyTransactionServer`用于注册服务（即创建一个在端口上运行的RPC服务器）。
- en: 'The `in` variable of `MakeTransaction` has the RPC request details. It is basically
    a struct that maps to the `TransactionRequest` message we defined in the protocol
    buffer file. What returns from `MakeTransaction` is `TransactionResponse`.This
    function signature matches with the one we defined in the protocol buffer file
    initially:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeTransaction`的`in`变量具有RPC请求的详细信息。它基本上是一个映射到我们在协议缓冲文件中定义的`TransactionRequest`消息的结构。从`MakeTransaction`返回的是`TransactionResponse`。这个函数签名与我们最初在协议缓冲文件中定义的函数签名匹配：'
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let us write a client. We can write a client (or) server in any programming
    language, but here we are writing both a client and server in Go for understanding
    the Go GRPC API. Add a file called `client.go` in the `grpcClient` directory:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个客户端。我们可以用任何编程语言编写客户端（或）服务器，但是在这里，我们为了理解Go GRPC API，同时编写了一个客户端和服务器。在`grpcClient`目录中添加一个名为`client.go`的文件：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This client is also using the `grpc`package. It uses an empty context called
    `context.Background()`to pass to the `MakeTransaction`function. The second argument
    of the function is the `TransactionRequest` struct:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个客户端也使用了`grpc`包。它使用一个名为`context.Background()`的空上下文传递给`MakeTransaction`函数。函数的第二个参数是`TransactionRequest`结构体：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It clearly maps with the theory we discussed in the previous section. Now,
    let us run it and see the output. Open a new console and run the GRPC server by
    using the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它与我们在上一节讨论的理论明显相符。现在，让我们运行它并查看输出。打开一个新的控制台，并使用以下命令运行GRPC服务器：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The TCP server starts listening on port `50051`. Now, open one more terminal/shell
    and start the client program that talks to this server:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: TCP服务器开始监听端口`50051`。现在，打开另一个终端/Shell，并启动与该服务器通信的客户端程序：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It prints the output of the successful transaction:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印出成功交易的输出：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At the same time, the server logs this message to the console:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，服务器将此消息记录到控制台中：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the client made a single request to the GRPC server and passed details
    of `From A/c` number, `To A/c` number, and `Amount`. The server picks those details,
    processes them, and sends a response back saying everything is fine.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，客户端向GRPC服务器发出了一个请求，并传递了`From A/c`号码、`To A/c`号码和`Amount`的详细信息。服务器接收这些详细信息，处理它们，并发送一个回复，表示一切正常。
- en: Since I am running code samples on my machine, I have `narenaryan` as the project
    directory under [github.com](https://github.com/). You can replace it with any
    other name.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我在我的机器上运行代码示例，我在[github.com](https://github.com/)下有`narenaryan`作为项目目录。您可以用任何其他名称替换它。
- en: Bidirectional streaming with GRPC
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GRPC进行双向流
- en: The main advantage of GRPC over traditional HTTP/1.1 is that it uses a single
    TCP connection for sending and receiving multiple messages between the server
    and the client. We saw the example of a money transaction before. Another real-world
    use case is a GPS installed in a taxi. Here, the taxi is the client that sends
    its geographical points to the server along its route. Finally, the server can
    calculate the total fare amount depending on the time spent between points and
    the total distance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: GRPC相对于传统的HTTP/1.1的主要优势在于它使用单个TCP连接在服务器和客户端之间发送和接收多个消息。我们之前看到了资金交易的示例。另一个现实世界的用例是出租车上安装的GPS。在这里，出租车是客户端，它沿着路线发送其地理位置到服务器。最后，服务器可以根据点之间的时间和总距离计算总费用。
- en: Another such use case is when a server needs to notify the client whenever some
    processing is performed. This is called a server push model. The server can send
    a stream of results back when a client asked for them only once. This is different
    to polling, where the client requests something each and every time. This can
    be useful when there are a series of time-taking steps that need to be done. The
    GRPC client can escalate that job to the GRPC server. Then, the server takes its
    time and relays the message back to the client, which reads them and does something
    useful. Let us implement this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个这样的用例是当服务器需要在执行某些处理时通知客户端。这被称为服务器推送模型。当客户端仅请求一次时，服务器可以发送一系列结果。这与轮询不同，轮询中客户端每次都会请求。当需要执行一系列耗时步骤时，这可能很有用。GRPC客户端可以将该作业升级到GRPC服务器。然后，服务器花费时间并将消息传递回客户端，客户端读取并执行有用的操作。让我们实现这个。
- en: 'This concept is similar to WebSockets, but between any type of platform. Create
    a project called `serverPush`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念类似于WebSockets，但适用于任何类型的平台。创建一个名为`serverPush`的项目：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, write in `datafiles` a protocol buffer that is similar to the previous
    one:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`datafiles`中编写一个与之前类似的协议缓冲区：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have two messages and one service defined in the protocol buffer file. The
    exciting part is in the service; we are returning a stream instead of a plain
    response:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议缓冲区文件中定义了两个消息和一个服务。令人兴奋的部分在于服务中，我们返回的是一个流而不是一个普通的响应：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The use case of this project is: *the client sends a money transfer request
    to the server, the server does a few tasks and sends those step details as a stream
    of responses back to the server*. Now, let us compile that proto file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的用例是：*客户端向服务器发送资金转账请求，服务器执行一些任务，并将这些步骤详细信息作为一系列响应发送回服务器*。现在，让我们编译proto文件：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This creates a new file called `transaction.pb.go` in the `datafiles` directory.
    We use the definitions in this file in our server and client programs, which we
    will create shortly. Now, let us write the GRPC server code. This code is a bit
    different compared to the previous example because of the introduction of streams:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`datafiles`目录中创建一个名为`transaction.pb.go`的新文件。我们将在服务器和客户端程序中使用此文件中的定义，我们将很快创建。现在，让我们编写GRPC服务器代码。由于引入了流，这段代码与之前的示例有些不同：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, add this program to the file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此程序添加到文件中：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`MakeTransaction`is the function that interests us. It takes a request and
    a stream as its arguments. In the function, we are looping through the number
    of steps (here, it is three), and performing the computation. The server is simulating
    the mock I/O or computation using the `time.Sleep`function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeTransaction`是我们感兴趣的函数。它以请求和流作为参数。在函数中，我们循环执行步骤的次数（这里是三次），并执行计算。服务器使用`time.Sleep`函数模拟模拟I/O或计算：'
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This function sends a stream response from the server to the client. Now, let
    us compose the client program. This is also a bit different to the basic GRPC
    client that we saw in the preceding code. Create a new directory for the client
    program:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从服务器向客户端发送一个流式响应。现在，让我们编写客户端程序。这也与我们在前面的代码中看到的基本GRPC客户端有些不同。为客户端程序创建一个新目录：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, start writing the client logic in that file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在该文件中开始编写客户端逻辑：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, `ReceiveStream`is the custom function we wrote for the sake of sending
    a request and receiving a stream of messages. It takes two arguments: `MoneyTransactionClient`and
    `TransactionRequest`.It uses the first argument to create a stream and starts
    listening to it. Whenever the server exhausts all the messages, the client will
    stop listening and terminate. Then, an `io.EOF` error will be returned if the
    client tries to receive messages. We are logging the responses collected from
    the GRPC server. The second argument, `TransactionRequest`,is used to send the
    request to the server for the first time. Now, running it will make it more clear
    to us. On terminal one, run the GRPC server:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ReceiveStream`是我们为了发送请求和接收一系列消息而编写的自定义函数。它接受两个参数：`MoneyTransactionClient`和`TransactionRequest`。它使用第一个参数创建一个流并开始监听它。当服务器耗尽所有消息时，客户端将停止监听并终止。然后，如果客户端尝试接收消息，将返回一个`io.EOF`错误。我们正在记录从GRPC服务器收集的响应。第二个参数`TransactionRequest`用于第一次向服务器发送请求。现在，运行它将使我们更清楚。在终端一上，运行GRPC服务器：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It will keep on listening for incoming requests. Now, run the client on the
    second terminal to see the action:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它将继续监听传入的请求。现在，在第二个终端上运行客户端以查看操作：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This outputs the following to the console:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台上输出以下内容：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At the same time, the server also logs its own messages on terminal one:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，服务器还在终端一上记录自己的消息：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This process happens in sync with the server. The client stays alive until
    all the streaming messages are sent back. The server can handle any number of
    clients at a given time. Every client request is considered as an individual entity.
    This is an example of the server sending a stream of responses. There are other
    cases that can also be implemented with protocol buffers and GRPC:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与服务器同步进行。客户端保持活动状态，直到所有流式消息都被发送回来。服务器可以同时处理任意数量的客户端。每个客户端请求被视为一个独立的实体。这是服务器发送一系列响应的示例。还有其他情况可以使用协议缓冲区和GRPC实现：
- en: The client sending streamed requests to get one final response from the server
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端发送流式请求，以从服务器获取最终响应。
- en: The client and server are both sending streamed requests and responses at the
    same time
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器都同时发送流式请求和响应
- en: The official GRPC team has provided a nice example of routing a taxi on GitHub.
    You can take a look at it to learn more about the functioning of bidirectional
    streams at
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的GRPC团队在GitHub上提供了一个很好的出租车路线示例。您可以查看它以了解双向流的功能。
- en: '[https://github.com/grpc/grpc-go/tree/master/examples/route_guide](https://github.com/grpc/grpc-go/tree/master/examples/route_guide).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/grpc/grpc-go/tree/master/examples/route_guide](https://github.com/grpc/grpc-go/tree/master/examples/route_guide)。'
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started our journey by understanding the basics of protocol
    buffers. Then, we came across the protocol buffers language, which has many types
    such as scalar, enumeration, and repeated types. We saw a few analogies between
    JSON and protocol buffers. We learned why protocol buffers are more memory efficient
    than the plain JSON data format. We defined a sample protocol buffer by simulating
    a network interface. The `message`keyword is used to define messages in a protocol
    buffer.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从理解协议缓冲的基础知识开始我们的旅程。然后，我们遇到了协议缓冲语言，它有许多类型，如标量、枚举和重复类型。我们看到了JSON和协议缓冲之间的一些类比。我们了解了为什么协议缓冲比纯JSON数据格式更节省内存。我们通过模拟网络接口定义了一个样本协议缓冲。`message`关键字用于在协议缓冲中定义消息。
- en: Next, we installed the `protoc` compiler to compile our files written in the
    protocol buffer language. Then, we saw how to compile a `.proto` file to generate
    a `.go` file. This Go file has all the structs and interfaces for the main program
    to consume. Next, we wrote a protocol buffer for an address book and person.We
    saw how to use `grpc.Marshal`to serialize Go structs into binary, transmittable
    data. We also found out that the conversion from protocol buffer to JSON and vice
    versa is very easily achievable in Go.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们安装了`protoc`编译器来编译我们用协议缓冲语言编写的文件。然后，我们看到如何编译`.proto`文件以生成一个`.go`文件。这个Go文件包含了主程序消耗的所有结构和接口。接下来，我们为一个地址簿和人员编写了一个协议缓冲。我们看到了如何使用`grpc.Marshal`将Go结构序列化为二进制可传输数据。我们还发现，在Go中，协议缓冲与JSON之间的转换非常容易实现。
- en: We then moved to GRPC, an RPC technology from Google using protocol buffers.
    We saw the benefits of HTTP/2 and GRPC. We then defined a GRPC service and data
    in the form of protocol buffers. Next, we implemented a GRPC server and GRPC in
    respect to the file generated from `.proto`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向了使用协议缓冲的谷歌RPC技术GRPC。我们看到了HTTP/2和GRPC的好处。然后，我们定义了一个GRPC服务和协议缓冲形式的数据。接下来，我们实现了一个GRPC服务器和GRPC，关于从`.proto`生成的文件。
- en: GRPC provides a bidirectional and multiplexed transport mechanism. This means
    that it can use a single TCP connection for all its message transmissions. We
    implemented one such scenario where the client sends a message to a server and
    the server replies back with a stream of messages.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: GRPC提供了双向和多路传输机制。这意味着它可以使用单个TCP连接进行所有消息传输。我们实现了一个这样的场景，客户端向服务器发送消息，服务器回复一系列消息。
