["```go\nimport \"flag\"\nvar name = flag.String(\"name\", \"No Namer\", \"your wonderful name\")\n```", "```go\npackage main\n\nimport (\n  \"flag\"\n  \"log\"\n  )\n\nvar name = flag.String(\"name\", \"stranger\", \"your wonderful name\")\n\nfunc main(){\n  flag.Parse()\n  log.Printf(\"Hello %s, Welcome to the command line world\", *name)\n}\n```", "```go\ngo build flagExample.go\n```", "```go\n./flagExample\n```", "```go\nHello stranger, Welcome to the command line world\n```", "```go\n./flagExample -h\n\nOutput\n========\nUsage of ./flagExample:\n -name string\n your wonderful name (default \"stranger\") \n```", "```go\n./flagExample -name Albert\n(or)\n./flagExample -name=Albert\n```", "```go\nHello Albert, Welcome to the command line world\n```", "```go\npackage main\n\nimport (\n  \"flag\"\n  \"log\"\n  )\n\nvar name = flag.String(\"name\", \"stranger\", \"your wonderful name\")\nvar age = flag.Int(\"age\", 0, \"your graceful age\")\n\nfunc main(){\n  flag.Parse()\n  log.Printf(\"Hello %s (%d years), Welcome to the command line world\", *name, *age)\n}\n```", "```go\n./flagExampleMultiParam -name Albert -age 24\n\nHello Albert (24 years), Welcome to the command line world\n```", "```go\nvar name String \nfunc init() {\n  flag.IntVar(&name, \"name\", \"stranger\", \"your wonderful name\")\n}\n```", "```go\npackage main\n\nimport (\n  \"flag\"\n  \"log\"\n  )\n\nvar name string\nvar age int\n\nfunc init() {\n  flag.StringVar(&name, \"name\", \"stranger\", \"your wonderful name\")\n  flag.IntVar(&age, \"age\", 0, \"your graceful age\")\n}\n\nfunc main(){\n  flag.Parse()\n  log.Printf(\"Hello %s (%d years), Welcome to the command line world\", name, age)\n}\n```", "```go\ngo get github.com/urfave/cli\n```", "```go\npackage main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"github.com/urfave/cli\"\n)\n\nfunc main() {\n  // Create new app\n  app := cli.NewApp()\n\n  // add flags with three arguments\n  app.Flags = []cli.Flag {\n    cli.StringFlag{\n      Name: \"name\",\n      Value: \"stranger\",\n      Usage: \"your wonderful name\",\n    },\n    cli.IntFlag{\n      Name: \"age\",\n      Value: 0,\n      Usage: \"your graceful age\",\n    },\n  }\n  // This function parses and brings data in cli.Context struct\n  app.Action = func(c *cli.Context) error {\n    // c.String, c.Int looks for value of given flag\n    log.Printf(\"Hello %s (%d years), Welcome to the command line world\", c.String(\"name\"), c.Int(\"age\"))\n    return nil\n  }\n  // Pass os.Args to cli app to parse content\n  app.Run(os.Args)\n}\n```", "```go\ntype Flag interface {\n    fmt.Stringer\n    // Apply Flag settings to the given flag set\n    Apply(*flag.FlagSet)\n    GetName() string\n}\n```", "```go\ngo build cli/cliBasic.go\n```", "```go\npackage main\n\nimport (\n  \"github.com/urfave/cli\"\n  \"log\"\n  \"os\"\n)\n\nfunc main() {\n  app := cli.NewApp()\n  // define flags\n  app.Flags = []cli.Flag{\n    cli.StringFlag{\n      Name:  \"save\",\n      Value: \"no\",\n      Usage: \"Should save to database (yes/no)\",\n    },\n  }\n\n  app.Version = \"1.0\"\n  // define action\n  app.Action = func(c *cli.Context) error {\n    var args []string\n    if c.NArg() > 0 {\n      // Fetch arguments in a array\n      args = c.Args()\n      personName := args[0]\n      marks := args[1:len(args)]\n      log.Println(\"Person: \", personName)\n      log.Println(\"marks\", marks)\n    }\n    // check the flag value\n    if c.String(\"save\") == \"no\" {\n      log.Println(\"Skipping saving to the database\")\n    } else {\n      // Add database logic here\n      log.Println(\"Saving to the database\", args)\n    }\n    return nil\n  }\n\n  app.Run(os.Args)\n}\n```", "```go\ngo build cli/storeMarks.go\n```", "```go\n./storeMarks --save=yes Albert 89 85 97\n\n2017/09/02 21:02:02 Person: Albert\n2017/09/02 21:02:02 marks [89 85 97]\n2017/09/02 21:02:02 Saving to the database [Albert 89 85 97]\n```", "```go\n./storeMarks Albert 89 85 97\n\n2017/09/02 21:02:59 Person: Albert\n2017/09/02 21:02:59 marks [89 85 97]\n2017/09/02 21:02:59 Skipping saving to the database\n```", "```go\nNAME:\n storeMarks - A new cli application\n\nUSAGE:\n storeMarks [global options] command [command options] [arguments...]\n\nVERSION:\n 1.0\n\nCOMMANDS:\n help, h Shows a list of commands or help for one command\n\nGLOBAL OPTIONS:\n --save value Should save to database (yes/no) (default: \"no\")\n --help, -h show help\n --version, -v print the version\n```", "```go\ngo get -u github.com/levigross/grequests\n```", "```go\npackage main\n\nimport (\n  \"github.com/levigross/grequests\"\n  \"log\"\n)\n\nfunc main() {\n  resp, err := grequests.Get(\"http://httpbin.org/get\", nil)\n  // You can modify the request by passing an optional RequestOptions struct\n  if err != nil {\n    log.Fatalln(\"Unable to make request: \", err)\n  }\n  log.Println(resp.String())\n}\n```", "```go\ngo run grequests/basicRequest.go\n```", "```go\n{\n  \"args\": {},\n  \"headers\": {\n    \"Accept-Encoding\": \"gzip\",\n    \"Connection\": \"close\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"GRequests/0.10\"\n  },\n  \"origin\": \"116.75.82.9\",\n  \"url\": \"http://httpbin.org/get\"\n}\n```", "```go\ntype Response struct {\n    Ok bool\n    Error error\n    RawResponse *http.Response\n    StatusCode int\n    Header http.Header\n}\n```", "```go\npackage main\n\nimport (\n  \"github.com/levigross/grequests\"\n  \"log\"\n)\n\nfunc main() {\n  resp, err := grequests.Get(\"http://httpbin.org/get\", nil)\n  // You can modify the request by passing an optional RequestOptions struct\n  if err != nil {\n    log.Fatalln(\"Unable to make request: \", err)\n  }\n  var returnData map[string]interface{}\n  resp.JSON(&returnData)\n  log.Println(returnData)\n\n}\n```", "```go\ncurl https://api.github.com\n```", "```go\nexport GITHUB_TOKEN=YOUR_GITHUB_ACCESS_TOKEN\n```", "```go\npackage main\n\nimport (\n  \"github.com/levigross/grequests\"\n  \"log\"\n  \"os\"\n)\n\nvar GITHUB_TOKEN = os.Getenv(\"GITHUB_TOKEN\")\nvar requestOptions = &grequests.RequestOptions{Auth: []string{GITHUB_TOKEN, \"x-oauth-basic\"}}\n\ntype Repo struct {\n  ID int `json:\"id\"`\n  Name string `json:\"name\"`\n  FullName string  `json:\"full_name\"`\n  Forks int `json:\"forks\"`\n  Private bool `json:\"private\"`\n}\n\nfunc getStats(url string) *grequests.Response{\n  resp, err := grequests.Get(url, requestOptions)\n  // You can modify the request by passing an optional RequestOptions struct\n  if err != nil {\n    log.Fatalln(\"Unable to make request: \", err)\n  }\n  return resp\n}\n\nfunc main() {\n  var repos []Repo\n  var repoUrl = \"https://api.github.com/users/torvalds/repos\"\n  resp := getStats(repoUrl)\n  resp.JSON(&repos)\n  log.Println(repos)\n}\n```", "```go\n2017/09/03 17:59:41 [{79171906 libdc-for-dirk torvalds/libdc-for-dirk 10 false} {2325298 linux torvalds/linux 18274 false} {78665021 subsurface-for-dirk torvalds/subsurface-for-dirk 16 false} {86106493 test-tlb torvalds/test-tlb 25 false}]\n```", "```go\ntype Repo struct {\n  ID int `json:\"id\"`\n  Name string `json:\"name\"`\n  FullName string  `json:\"full_name\"`\n  Forks int `json:\"forks\"`\n  Private bool `json:\"private\"`\n}\n```", "```go\nvar GITHUB_TOKEN = os.Getenv(\"GITHUB_TOKEN\")\nvar requestOptions = &grequests.RequestOptions{Auth: []string{GITHUB_TOKEN, \"x-oauth-basic\"}}\n```", "```go\npackage main\n\nimport (\n  \"encoding/json\"\n  \"fmt\"\n  \"github.com/levigross/grequests\"\n  \"github.com/urfave/cli\"\n  \"io/ioutil\"\n  \"log\"\n  \"os\"\n)\n\nvar GITHUB_TOKEN = os.Getenv(\"GITHUB_TOKEN\")\nvar requestOptions = &grequests.RequestOptions{Auth: []string{GITHUB_TOKEN, \"x-oauth-basic\"}}\n\n// Struct for holding response of repositories fetch API\ntype Repo struct {\n  ID       int    `json:\"id\"`\n  Name     string `json:\"name\"`\n  FullName string `json:\"full_name\"`\n  Forks    int    `json:\"forks\"`\n  Private  bool   `json:\"private\"`\n}\n\n// Structs for modelling JSON body in create Gist\ntype File struct {\n  Content string `json:\"content\"`\n}\n\ntype Gist struct {\n  Description string          `json:\"description\"`\n  Public      bool            `json:\"public\"`\n  Files       map[string]File `json:\"files\"`\n}\n\n// Fetches the repos for the given Github users\nfunc getStats(url string) *grequests.Response {\n  resp, err := grequests.Get(url, requestOptions)\n  // you can modify the request by passing an optional RequestOptions struct\n  if err != nil {\n    log.Fatalln(\"Unable to make request: \", err)\n  }\n  return resp\n}\n\n// Reads the files provided and creates Gist on github\nfunc createGist(url string, args []string) *grequests.Response {\n  // get first teo arguments\n  description := args[0]\n  // remaining arguments are file names with path\n  var fileContents = make(map[string]File)\n  for i := 1; i < len(args); i++ {\n    dat, err := ioutil.ReadFile(args[i])\n    if err != nil {\n      log.Println(\"Please check the filenames. Absolute path (or) same directory are allowed\")\n      return nil\n    }\n    var file File\n    file.Content = string(dat)\n    fileContents[args[i]] = file\n  }\n  var gist = Gist{Description: description, Public: true, Files: fileContents}\n  var postBody, _ = json.Marshal(gist)\n  var requestOptions_copy = requestOptions\n  // Add data to JSON field\n  requestOptions_copy.JSON = string(postBody)\n  // make a Post request to Github\n  resp, err := grequests.Post(url, requestOptions_copy)\n  if err != nil {\n    log.Println(\"Create request failed for Github API\")\n  }\n  return resp\n}\n\nfunc main() {\n  app := cli.NewApp()\n  // define command for our client\n  app.Commands = []cli.Command{\n    {\n      Name:    \"fetch\",\n      Aliases: []string{\"f\"},\n      Usage:   \"Fetch the repo details with user. [Usage]: goTool fetch user\",\n      Action: func(c *cli.Context) error {\n        if c.NArg() > 0 {\n          // Github API Logic\n          var repos []Repo\n          user := c.Args()[0]\n          var repoUrl = fmt.Sprintf(\"https://api.github.com/users/%s/repos\", user)\n          resp := getStats(repoUrl)\n          resp.JSON(&repos)\n          log.Println(repos)\n        } else {\n          log.Println(\"Please give a username. See -h to see help\")\n        }\n        return nil\n      },\n    },\n    {\n      Name:    \"create\",\n      Aliases: []string{\"c\"},\n      Usage:   \"Creates a gist from the given text. [Usage]: goTool name 'description' sample.txt\",\n      Action: func(c *cli.Context) error {\n        if c.NArg() > 1 {\n          // Github API Logic\n          args := c.Args()\n          var postUrl = \"https://api.github.com/gists\"\n          resp := createGist(postUrl, args)\n          log.Println(resp.String())\n        } else {\n          log.Println(\"Please give sufficient arguments. See -h to see help\")\n        }\n        return nil\n      },\n    },\n  }\n\n  app.Version = \"1.0\"\n  app.Run(os.Args)\n}\n```", "```go\ngo build githubAPI/gitTool.go\n```", "```go\nNAME:\n gitTool - A new cli application\n\nUSAGE:\n gitTool [global options] command [command options] [arguments...]\n\nVERSION:\n 1.0\n\nCOMMANDS:\n fetch, f Fetch the repo details with user. [Usage]: goTool fetch user\n create, c Creates a gist from the given text. [Usage]: goTool name 'description' sample.txt\n help, h Shows a list of commands or help for one command\n\nGLOBAL OPTIONS:\n --help, -h show help\n --version, -v print the version\n```", "```go\necho 'I am sample1 file text' > githubAPI/sample1.txt\necho 'I am sample2 file text' > githubAPI/sample2.txt\n```", "```go\n./gitTool f torvalds\n```", "```go\n[{79171906 libdc-for-dirk torvalds/libdc-for-dirk 10 false} {2325298 linux torvalds/linux 18310 false} {78665021 subsurface-for-dirk torvalds/subsurface-for-dirk 16 false} {86106493 test-tlb torvalds/test-tlb 25 false}]\n```", "```go\n./gitTool c \"I am doing well\" sample1.txt sample2.txt\n```", "```go\n{\n  \"description\": \"the description for this gist\",\n  \"public\": true,\n  \"files\": {\n    \"file1.txt\": {\n      \"content\": \"String file contents\"\n    }\n  }\n}\n```", "```go\n\u251c\u2500\u2500 main.go\n\u251c\u2500\u2500 models\n\u2502   \u2514\u2500\u2500 models.go\n\u2514\u2500\u2500 utils\n    \u2514\u2500\u2500 encodeutils.go\n\n2 directories, 3 files\n```", "```go\ntouch main_test.go\n```", "```go\npackage main_test\n\nimport (\n  \"testing\"\n  \"net/http\"\n)\n\nfunc TestGetOriginalURL(t *testing.T) {\n  // make a dummy reques\n  response, err := http.Get(\"http://localhost:8000/v1/short/1\")\n\n    if http.StatusOK != response.StatusCode {\n      t.Errorf(\"Expected response code %d. Got %d\\n\", http.StatusOK, response.StatusCode)\n    }\n\n    if err != nil {\n      t.Errorf(\"Encountered an error:\", err)\n    }\n}\n```"]