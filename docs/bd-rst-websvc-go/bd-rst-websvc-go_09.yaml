- en: Scaling Our REST API Using Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用微服务扩展我们的REST API
- en: Building a REST API is easy in terms of concepts. But scaling them to accept
    huge traffic is a challenge. Till now, we looked into the details of creating
    REST API structures and sample REST APIs. In this chapter, we are going to explore
    the Go Kit, a wonderful, idiomatic Go package for building microservices. This
    is the microservices age, where startups are turning into enterprises in no time. 
    The microservice architecture allows companies to quickly iterate in parallel.
    We will start by defining microservices and then move on to Go Kit by creating
    REST-style microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上，构建REST API很容易。但是将它们扩展以接受大量流量是一个挑战。到目前为止，我们已经研究了创建REST API结构和示例REST API的细节。在本章中，我们将探索Go
    Kit，这是一个用于构建微服务的精彩的、符合惯例的Go软件包。这是微服务时代，创业公司在短时间内就成为企业。微服务架构允许公司快速并行迭代。我们将从定义微服务开始，然后通过创建REST风格的微服务来了解Go
    Kit。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The difference between monolith and microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体和微服务之间的区别
- en: The need for microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的需求
- en: Introducing Go Kit, a microservice toolkit in Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Go Kit，一个Go语言的微服务工具包
- en: Creating a REST API with Go Kit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Go Kit创建REST API
- en: Adding logging to the API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为API添加日志记录
- en: Adding instrumentation to the API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为API添加仪表板
- en: Getting the code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码
- en: You can get the code samples for this chapter at the GitHub repository link [https://github.com/narenaryan/gorestful/tree/master/chapter9](https://github.com/narenaryan/gorestful/tree/master/chapter9).
    In the previous chapter, we discussed Go API clients. Here, we come back to the
    REST API with microservice architecture.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库链接[https://github.com/narenaryan/gorestful/tree/master/chapter9](https://github.com/narenaryan/gorestful/tree/master/chapter9)中获取本章的代码示例。在上一章中，我们讨论了Go
    API客户端。在这里，我们回到了具有微服务架构的REST API。
- en: What are microservices?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: What are microservices? This is the question the enterprise world is asking
    the computing world. Because of the bigger teams, the companies are ready to embrace
    microservices for breaking down tasks. Microservice architecture replaces the
    traditional monolith with granular services that talk to each other with some
    kind of agreement.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是微服务？这是企业世界向计算世界提出的问题。由于团队规模较大，公司准备采用微服务来分解任务。微服务架构用粒度服务取代了传统的单体，并通过某种协议相互通信。
- en: 'Microservices bring the following benefits to the plate:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务为以下方面带来了好处：
- en: If the team is big, people can work on chunks of applications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果团队很大，人们可以在应用程序的各个部分上工作
- en: Adaptability is easy for the new developers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新开发人员很容易适应
- en: Adopting best practices, such as **Continuous Integration** (**CI**) and **Continuous
    Delivery** (**CD**)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用最佳实践，如**持续集成**（**CI**）和**持续交付**（**CD**）
- en: Easily replaceable software with loosely coupled architecture
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于替换的松散耦合架构软件
- en: In a monolith application (traditional application), a single huge server serves
    the incoming requests by multiplexing the computing power. It is good because
    we have everything, such as an application server, database, and other things,
    in a single place. It also has disadvantages. When a piece of software breaks,
    everything breaks. Also, developers need to set up an entire application to develop
    a small piece.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用程序（传统应用程序）中，一个巨大的服务器通过多路复用计算能力来服务传入的请求。这很好，因为我们在一个地方拥有一切，比如应用服务器、数据库和其他东西。但它也有缺点。当软件出现问题时，一切都会出现问题。此外，开发人员需要设置整个应用程序来开发一个小部分。
- en: 'The disadvantage list of a monolithic application could be:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序的缺点清单可能包括：
- en: Tightly coupled architecture
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧密耦合的架构
- en: Single point of failure
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单点故障
- en: Velocity of adding new features and components
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新功能和组件的速度
- en: Fragmentation of work is limited to teams
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作的碎片化仅限于团队
- en: Continuous deployment is very tough because an entire application needs to be
    pushed
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署非常困难，因为需要推送整个应用程序
- en: Looking at the monolith application, the entire stack is treated as a single
    entity. If the database fails, the app fails. If a bug in the code crashes the
    software application, the entire connectivity with clients goes down. This actually
    led to the emergence of microservices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 查看单体应用程序时，整个堆栈被视为单个实体。如果数据库出现故障，应用程序也会出现故障。如果代码中的错误导致软件应用程序崩溃，与客户端的整个连接也会中断。这实际上导致了微服务的出现。
- en: Let us take a scenario. A company run by Bob uses the traditional **Service
    Oriented Architecture** (**SOA**), where developers work around the clock to add
    new features. If there is a release, people need to test the code overall for
    every small component. The project moves from development to testing when all
    changes are done. Another company on the next street, run by Alice, uses the microservices
    architecture. All software developers in Alice's company work on individual services,
    that get tested by a continuous build pipeline that notifies things pretty quickly.
    The developers talk with each other's REST/RPC APIs to add new features. They
    can easily shift their stack from one technology to another, as compared to Bob's
    developers. This example shows that Alice's company's flexibility and velocity
    is greater than Bob's.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个场景。Bob经营的公司使用传统的**面向服务的架构**（**SOA**），开发人员全天候工作以添加新功能。如果有发布，人们需要对每个小组件的代码进行全面测试。当所有更改完成时，项目从开发转移到测试。下一条街上的另一家公司由Alice经营，使用微服务架构。Alice公司的所有软件开发人员都在个别服务上工作，这些服务通过连续的构建流水线进行测试，并且通知非常迅速。开发人员通过彼此的REST/RPC
    API交流以添加新功能。与Bob的开发人员相比，他们可以轻松地将其堆栈从一种技术转移到另一种技术。这个例子表明了Alice公司的灵活性和速度比Bob公司更大。
- en: Microservices also create a platform that allows us to use containers (docker,
    and so on). In microservices, orchestration and service discovery are very important
    to track the loosely coupled elements. A tool such as Kubernetes is used to manage
    the docker containers. Generally, it is a good practice to have a docker container
    for a microservice. Service discovery is the automatic detection of an IP address and
    other details on the fly. This removes the potential threat of hardcoding the
    stuff that is needed for microservices to consult each other.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务还创建了一个允许我们使用容器（docker等）的平台。在微服务中，编排和服务发现对于跟踪松散耦合的元素非常重要。诸如Kubernetes之类的工具用于管理docker容器。通常，为微服务拥有一个docker容器是一个很好的做法。服务发现是在飞行中自动检测IP地址和其他详细信息。这消除了硬编码微服务需要相互协商的东西的潜在威胁。
- en: Monolith versus microservices
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构与微服务
- en: 'Industry experts suggest starting a software application as a monolith and
    then breaking it down into microservices in the long run. This actually helps
    us focus on the application delivery, instead of studying the microservices patterns.
    Once the product is stabilized, then developers should find a way to loosely couple
    functionalities. Take a look at the following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 行业专家建议将软件应用程序作为单体架构开始，然后逐步将其拆分为微服务。这实际上帮助我们专注于应用程序交付，而不是研究微服务模式。一旦产品稳定下来，开发人员应该找到一种松散耦合功能的方法。看一下下面的图表：
- en: '![](img/a7355ea1-d2ba-4a9d-b60b-b49dac855c81.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7355ea1-d2ba-4a9d-b60b-b49dac855c81.jpg)'
- en: This diagram depicts the structure of monolith and microservice architectures.
    A monolith has everything wrapped in the form of an onion. It is called a tightly
    coupled system. In contrast, microservices are individual, easy to replace and
    modify. Each microservice can talk to each other through various transport mechanisms,
    such as HTTP and RPC. The format could be either JSON or Protocol Buffers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图描述了单体架构和微服务架构的结构。单体架构将所有内容包裹在洋葱形式中。它被称为紧密耦合的系统。相比之下，微服务是独立的，易于替换和修改。每个微服务可以通过各种传输机制（如HTTP和RPC）相互通信。格式可以是JSON或协议缓冲区。
- en: Go Kit, a package for building microservices
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go Kit，用于构建微服务的包
- en: In the enterprise world, people know about Netflix's Eureka and Spring Boot
    from the Java community. In Go, a package that tries to reach that level of implementation
    is obviously **Go kit**. It is a toolkit for building microservices.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业世界中，人们了解Netflix的Eureka和Java社区的Spring Boot。在Go中，一个试图达到那个实现水平的包显然是**Go kit**。这是一个用于构建微服务的工具包。
- en: 'It has a Go style of adding services, which makes us feel good. It comes with
    a procedure for adding the microservices. In the upcoming sections, we will see
    how to create a microservice with the steps defined by Go Kit. It mainly consists
    of many layers. There are three layers where request and response flow in Go Kit:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有Go风格的添加服务的方式，这让我们感觉良好。它带有一个添加微服务的过程。在接下来的章节中，我们将看到如何按照Go Kit定义的步骤创建微服务。它主要由许多层组成。在Go
    Kit中，有三个层，请求和响应在其中流动：
- en: '**Transport layer**: This takes care of transferring data from one service
    to another'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层**：这负责将数据从一个服务传输到另一个服务'
- en: '**Endpoint layer**: This takes care of building endpoints for the given services'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终端层**：这负责为给定服务构建终端'
- en: '**Service layer**: This is the actual business logic for the API handlers'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务层**：这是API处理程序的实际业务逻辑'
- en: 'Install Go Kit using this command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装Go Kit：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let us lay down the plan for our first microservice. We all know the encryption
    of messages. A message string can be encrypted using a key that outputs a gibberish
    message that can be passed over the wire. The recipient decrypts the message and
    gets back the original string. This process is called encryption in cryptography.
    We will try to implement this as part of our microservice illustration:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的第一个微服务制定计划。我们都知道消息的加密。可以使用密钥加密消息字符串，输出一个无意义的消息，可以通过网络传输。接收者解密消息并获得原始字符串。这个过程称为加密。我们将尝试将其作为微服务示例的一部分实现：
- en: First, develop logic for encryption
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，开发加密逻辑
- en: Then, integrate it with Go Kit
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，将其与Go Kit集成
- en: Go comes with packages for encrypting messages. We need to import encrypting
    algorithms from those packages and use them. As part of the first step, we will
    write a project that uses an **Advanced Encryption Standard** (**AES**).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Go自带了用于加密消息的包。我们需要从这些包中导入加密算法并使用它们。作为第一步，我们将编写一个使用**高级加密标准**（**AES**）的项目。
- en: 'Create a directory called `encryptString` in your `GOPATH/src/user` directory:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GOPATH/src/user`目录中创建一个名为`encryptString`的目录：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let us add one more in the new directory, called utils. Add two files, `main.go`in
    the project directory and `utils.go` in the new directory called `utils`. The
    directory structure looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在新目录中再添加一个，名为utils。在项目目录中添加两个文件，`main.go`和在名为`utils`的新目录中添加`utils.go`。目录结构如下：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now let us add the logic of encryption in our `utils.go` file. We create two
    functions, one for encrypting and another for decrypting the messages, as shown
    in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的`utils.go`文件中添加加密逻辑。我们创建两个函数，一个用于加密，另一个用于解密消息，如下所示：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The AES algorithm takes the initialization vector. Let us define that first:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: AES算法需要初始化向量。让我们首先定义它：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let us implement the logic for encryption and decryption:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现加密和解密的逻辑：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `EncryptString` function, we are creating a new cipher block using a
    key. Then we are passing that block to a cipher block encryptor function. That
    encryptor takes the block and initialization vector. Then we generate ciphertext
    (an encrypted message) by doing a `XORKeyStream` on the cipher block. It fills
    the ciphertext. Then we need to do a Base64 encoding to generate the protected
    string:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EncryptString`函数中，我们正在使用密钥创建一个新的密码块。然后我们将该块传递给密码块加密器函数。该加密器接受块和初始化向量。然后我们通过在密码块上进行`XORKeyStream`来生成密文（加密消息）。它填充了密文。然后我们需要进行Base64编码以生成受保护的字符串：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `DecryptString` function, decode Base64 encoding and create a cipher
    block with the key. Pass this cipher block with the initialization vector to `NewCFBEncrypter`.Next,
    use `XORKeyStream`to load content from cipher text to plain text. Basically, it
    is a process of swapping the encrypted and decrypted messages in `XORKeyStream`.
    This finishes the `utils.go` file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DecryptString`函数中，解码Base64编码并使用密钥创建一个密码块。将这个密码块与初始化向量传递给`NewCFBEncrypter`。接下来，使用`XORKeyStream`将密文加载到明文中。基本上，这是一个在`XORKeyStream`中交换加密和解密消息的过程。这完成了`utils.go`文件。
- en: 'Now let us edit the `main.go` file to leverage the preceding `utils` package:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编辑`main.go`文件，以利用前面的`utils`包：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are importing the encrypting/decrypting functions from the `utils`
    package and using them to show an example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`utils`包中导入加密/解密函数，并使用它们来展示一个例子。
- en: 'If we run this program, we see the following output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，我们会看到以下输出：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It shows how we can use the AES algorithm to encrypt a message and get it back
    using the same secret key. This algorithm is also called the **Rijndael** (pronounced
    rain-dahl) algorithm.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它展示了我们如何使用AES算法加密消息，并使用相同的秘钥将其解密。这个算法也被称为**Rijndael**（发音为rain-dahl）算法。
- en: Building a REST microservice with Go Kit
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go Kit构建REST微服务
- en: 'With this knowledge, we are ready to build our first microservice that provides
    the API for encryption/decryption. We use Go Kit and our encryption `utils` to
    write that microservice. As we discussed in the previous section, a Go-Kit microservice
    should be built in a step-wise manner. To create a service, we need to design
    a few things upfront. They are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，我们准备构建我们的第一个提供加密/解密API的微服务。我们使用Go Kit和我们的加密`utils`来编写这个微服务。正如我们在前一节中讨论的，Go-Kit微服务应该逐步构建。要创建一个服务，我们需要事先设计一些东西。它们是：
- en: Service implementation
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务实现
- en: Endpoints
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点
- en: Request/response models
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求/响应模型
- en: Transport
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输
- en: 'Sit tight. This terminology seems alien for now. We will be quite comfortable
    with it soon. Let us create a directory with the following directory structure.
    Every Go Kit project can be in this project structure. Let us call our project `encryptService.` Create
    these files in the same tree structure in the `encryptService` directory:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 坐稳。这个术语现在似乎很陌生。我们很快就会对它感到很舒适。让我们创建一个具有以下目录结构的目录。每个Go Kit项目都可以在这个项目结构中。让我们称我们的项目为`encryptService`。在`encryptService`目录中以相同的树结构创建这些文件：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will go through each and every file and see how things should be built.
    First, in Go Kit, create the interface that tells all functions our microservice
    performs. In this case, those functions are `Encrypt` and `Decrypt`. `Encrypt`
    takes the key and converts the text to a cipher message. `Decrypt` converts the
    cipher message back to the text using the key. Take a look at the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个查看每个文件，看看应该如何构建。首先，在Go Kit中，创建一个接口，告诉我们的微服务执行所有功能。在这种情况下，这些功能是`Encrypt`和`Decrypt`。`Encrypt`接受密钥并将文本转换为密码消息。`Decrypt`使用密钥将密码消息转换回文本。看一下以下代码：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The service needs to implement these functions to satisfy the interface. Next,
    create models for your services. Models specify what data a service can receive
    and produce back. Create a `models.go` file in the `helpers` directory of the
    project:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 服务需要实现这些函数以满足接口。接下来，为您的服务创建模型。模型指定服务可以接收和产生的数据。在项目的`helpers`目录中创建一个`models.go`文件：
- en: '`encryptService/helpers/models.go`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`encryptService/helpers/models.go`'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since we have two service functions, there are four functions mapped to the
    request and response. The next step is to create a struct that implements the
    preceding defined interface, `EncryptService`. So, create that logic in an implementations
    file in the following path:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有两个服务函数，所以有四个函数映射到请求和响应。下一步是创建一个实现前面定义的接口`EncryptService`的结构体。因此，在以下路径中的实现文件中创建该逻辑：
- en: '`encryptService/helpers/implementations.go`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`encryptService/helpers/implementations.go`'
- en: 'First, let us import all necessary packages. Also, give the package name:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入所有必要的包。同时，给出包的名称：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is leveraging the same AES encryption we saw in the previous example. In
    this file, we are creating a struct called `EncyptionServiceInstance`that has
    two methods, `Encrypt` and `Decrypt`.So it satisfies the preceding interface.
    Now, how can we link these actual service implementations with service requests
    and responses? We need to define endpoints for that. So, add the following endpoints
    to link service requests with service business logic.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了我们在前面示例中看到的相同的AES加密。在这个文件中，我们创建了一个名为`EncyptionServiceInstance`的结构体，它有两个方法，`Encrypt`和`Decrypt`。因此它满足了前面的接口。现在，我们如何将这些实际的服务实现与服务请求和响应联系起来呢？我们需要为此定义端点。因此，添加以下端点以将服务请求与服务业务逻辑链接起来。
- en: We are using the `Capitalized` function and variable names because in Go, any
    function or variable that is Capital is exported from that package name. In `main.go`,
    to use all these functions, we need to export them first. Giving capital names
    makes them visible to the main program.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Capitalized`函数和变量名称，因为在Go中，任何以大写字母开头的函数或变量都是从该包名导出的。在`main.go`中，要使用所有这些函数，我们需要首先将它们导出。给予大写名称使它们对主程序可见。
- en: 'Create `endpoints.go` in the `helpers` directory:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`helpers`目录中创建`endpoints.go`：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are clubbing the previous interface definition code with the endpoints
    definition code. Endpoints take a service as the argument and return a function.
    This function, in turn, takes a request and returns a response. These things are
    the same as what we defined in our `models.go`file. We check the errors, then
    return back the struct for a response.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将之前的接口定义代码与端点定义代码结合在一起。端点以服务作为参数并返回一个函数。这个函数又以请求为参数并返回一个响应。这些东西与我们在`models.go`文件中定义的内容相同。我们检查错误，然后返回响应的结构体。
- en: 'Now, things fit nicely. In the previous REST API examples we worked on, we
    always tried to unmarshal the JSON string into the Go structs. For a response,
    we converted the struct back into the JSON string by marshaling. Here, we unmarshal
    and marshal request and response, respectively. For that, we write one more file
    for encoding/decoding logic. Let us call that file `jsonutils.go` and add it in the `helpers`
    directory:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切都很好。在我们之前的REST API示例中，我们总是试图将JSON字符串解组为Go结构。对于响应，我们通过编组将结构转换回JSON字符串。在这里，我们分别解组和编组请求和响应。为此，我们编写一个用于编码/解码逻辑的文件。让我们称该文件为`jsonutils.go`并将其添加到`helpers`目录中：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`EncodeResponse`is common for marshaling the response of `EncyptService` and
    `DecryptService`,but while decoding JSON into structs we need two different methods.
    We defined them as `DecodeEncryptRequest` and `DecodeDecryptRequest`.These functions
    use Go''s internal JSON package to marshal and unmarshal data.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`EncodeResponse`用于编组`EncyptService`和`DecryptService`的响应，但是在将JSON解码为结构时，我们需要两种不同的方法。我们将它们定义为`DecodeEncryptRequest`和`DecodeDecryptRequest`。这些函数使用Go的内部JSON包来编组和解组数据。'
- en: 'Now we have all helper files that have the constructs needed to create a microservice.
    Let us design the `main` function that import the existing things and wire microservice
    to a server:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有需要创建微服务的构造的辅助文件。让我们设计`main`函数，导入现有的内容并将微服务连接到服务器：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We are importing Go Kit''s transport/http as `httptransport` to create handlers.
    A handler attaches the endpoints, JSON decoder, and JSON encoder. Then, using
    Go''s net/http, we are handling the HTTP requests for the given URL endpoint.`httptransport.NewServer`takes
    a few arguments: an endpoint, the JSON decoder, and the JSON encoder. Where is
    the logic for the service execution? It lies in the endpoint. An endpoint takes
    the request model and spits out the response model. Now, let us run this project
    within the `encryptService` directory:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导入Go Kit的transport/http作为`httptransport`来创建处理程序。处理程序附加了端点、JSON解码器和JSON编码器。然后，使用Go的net/http，我们处理给定URL端点的HTTP请求。`httptransport.NewServer`接受一些参数：一个端点，JSON解码器和JSON编码器。服务执行的逻辑在哪里？它在端点中。端点接受请求模型并输出响应模型。现在，让我们在`encryptService`目录中运行这个项目：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can make curl `POST` requests to check the output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用curl进行`POST`请求来检查输出：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We provided the key and message to the microservice. It returned the cipher
    message back. It means the service encrypted the text. Make one more request to
    decrypt the message by passing the same key along with the cipher message:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向微服务提供了密钥和消息。它返回了密文消息。这意味着服务加密了文本。通过传递相同的密钥以及密文消息，再发出一个请求来解密消息：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It returns us the exact message we passed initially. Hurray! We wrote our first
    microservice for encrypting/decrypting messages. Apart from handling normal HTTP
    requests, Go Kit provides many other useful constructs, such as middleware for:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回了我们最初传递的确切消息。万岁！我们编写了我们的第一个用于加密/解密消息的微服务。除了处理正常的HTTP请求外，Go Kit还提供了许多其他有用的构造，例如用于中间件的：
- en: Transport logging
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输日志
- en: Application logging
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序日志
- en: Application instrumentation
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序仪表化
- en: Service discovery
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: In the upcoming sections, we discuss a few important constructs from the preceding
    list.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论前面列表中的一些重要构造。
- en: Adding logging to your microservice
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的微服务添加日志记录
- en: 'In this section, let us learn how to add transport-level logging and application-level
    logging to our Go Kit microservices. We use the above example but modify it a
    little bit. Let us call our new project `encryptServiceWithLogging`. In the GitHub
    project of this book, you will find this directory. We visited the concepts of
    middleware many times in this book. For revision, a middleware is a function that
    tampers the request/response before/after it reaches the respective request handlers.
    Go Kit allows us to create logging middleware, which we attach to our service.
    That middleware will have the logging logic. In this example, we try to log to
    the Stderr (console). Add one new file called `middleware.go` to the `helpers`
    directory, as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们学习如何向我们的Go Kit微服务添加传输级别日志和应用程序级别日志。我们使用上面的示例，但稍作修改。让我们称我们的新项目为`encryptServiceWithLogging`。在本书的GitHub项目中，您将找到这个目录。在本书中，我们多次讨论了中间件的概念。作为复习，中间件是在到达相应的请求处理程序之前/之后篡改请求/响应的函数。Go
    Kit允许我们创建记录中间件，将其附加到我们的服务上。该中间件将具有记录逻辑。在这个示例中，我们尝试记录到Stderr（控制台）。如下所示，将一个名为`middleware.go`的新文件添加到`helpers`目录中：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We need to create a struct that has a logger and our service instance. Then,
    define a few methods on that whose names are similar to the service methods (in
    this case, they are `encrypt` and `decrypt`). The **Logger **is the Go Kit''s
    logger that has a `Log` function. This `Log` function takes a few arguments. It
    takes a pair of arguments. The first and second are one set. The third and fourth
    are another set. Refer to the following code snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个具有记录器和我们的服务实例的结构。然后，在该结构上定义一些方法，这些方法的名称与服务方法相似（在本例中，它们是`encrypt`和`decrypt`）。**Logger**是Go
    Kit的记录器，具有`Log`函数。这个`Log`函数接受一些参数。它接受一对参数。第一个和第二个是一组。第三个和第四个是另一组。请参考以下代码片段：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We need to maintain the order in which the log should print. After logging
    our request details, we make sure to allow the request to go to the next middleware/handler
    using this function. `Next`is of the type `EncryptService`, which is our actual
    implementation:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要维护日志应该打印的顺序。在记录我们的请求详细信息后，我们确保允许请求通过这个函数继续到下一个中间件/处理程序。`Next`是`EncryptService`类型，它是我们的实际实现：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For the encryption function, middleware logs a request for encryption and passes
    it to the implementation of the service. In order to hook this created middleware
    into our service, modify `main.go` to this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加密函数，中间件记录加密请求并将其传递给服务的实现。为了将创建的中间件挂接到我们的服务中，修改`main.go`如下：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We imported the log from Go Kit as `kitlog`.We created a new logger using `NewLogfmtLogger(os.Stderr)`.
    This attaches the logging to the console. Now, pass this logger and service to
    the `LoggingMiddleware`. It returns the service that can be passed to the HTTP
    server. Now, let us run the program from `encryptServiceWithLogging` and see what
    output logs on the console:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Go Kit中导入日志作为`kitlog`。我们使用`NewLogfmtLogger(os.Stderr)`创建了一个新的记录器。这将日志附加到控制台。现在，将这个记录器和服务传递给`LoggingMiddleware`。它返回可以传递给HTTP服务器的服务。现在，让我们从`encryptServiceWithLogging`运行程序，看看控制台上的输出日志：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It starts our microservice. Now, fire client requests from the `CURL` command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它启动我们的微服务。现在，从`CURL`命令发出客户端请求：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That logs the following messages on the server console:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这在服务器控制台上记录以下消息：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is to log the messages per application/service. System-level logging is
    also available and can be approached from the Go Kit's documentation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了记录每个应用程序/服务的消息。系统级别的日志记录也是可用的，并且可以从Go Kit的文档中获取。
- en: Adding instrumentation to your microservice
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的微服务添加仪表
- en: 'For any microservice, along with logging, instrumentation is vital. The `metrics` package
    of Go Kit records statistics about your service’s runtime behavior: counting the
    number of jobs processed, recording the duration of requests after they have finished,
    and so on. This is also a middleware that tampers the HTTP requests and collects
    metrics. To define a middleware, simply add one more struct, similar to the logging
    middleware. Metrics are useless unless we monitor. **Prometheus** is a metrics
    monitoring tool that can collect latency, number of requests for a given service,
    and so on. Prometheus scrapes the data from the metrics that Go Kit generates.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何微服务，除了日志记录，仪表是至关重要的。Go Kit的`metrics`包记录有关服务运行时行为的统计信息：计算已处理作业的数量，记录请求完成后的持续时间等。这也是一个篡改HTTP请求并收集指标的中间件。要定义一个中间件，只需添加一个与日志中间件类似的结构。除非我们监视，否则指标是无用的。**Prometheus**是一个可以收集延迟、给定服务的请求数等指标的指标监控工具。Prometheus从Go
    Kit生成的指标中抓取数据。
- en: 'You can download the latest stable version of Prometheus from this site. Before
    using Prometheus, make sure you install these packages, that are needed by the
    Go Kit:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这个网站下载最新稳定版本的Prometheus。在使用Prometheus之前，请确保安装Go Kit需要的这些包：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once these are installed, try to copy the last discussed logging service project
    into a directory called `encryptServiceWithInstrumentation`. The directory is
    exactly the same, except we add one more file called `instrumentation.go` to the
    `helpers` directory and modify our `main.go` to import the instrumentation middleware.
    The project structure looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这些包之后，尝试将最后讨论的日志服务项目复制到一个名为`encryptServiceWithInstrumentation`的目录中。该目录与原来完全相同，只是我们在`helpers`目录中添加了一个名为`instrumentation.go`的文件，并修改了我们的`main.go`以导入仪表中间件。项目结构如下：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Instrumentation can measure the number of requests per service and the latency
    in terms of parameters such as `Counter` and `Histogram`, respectively. We try
    to create a middleware that has these two measurements (requests count, latency)
    and implements the functions for the given services. In those middleware functions,
    we try to call the Prometheus client API to increment the number of requests,
    log the latency, and so on. The core Prometheus client library tries to increment
    a request count in this way:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表可以测量每个服务的请求数和延迟，以参数如`Counter`和`Histogram`为单位。我们尝试创建一个具有这两个测量（请求数、延迟）并实现给定服务的函数的中间件。在这些中间件函数中，我们尝试调用Prometheus客户端API来增加请求数、记录延迟等。核心的Prometheus客户端库尝试以这种方式增加请求计数：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`NewCounter`creates a new counter struct that expects counter options. These
    options are the name of the operation and other details. Then, we need to call
    the `With` function on the struct with the method, method name, and error code.This
    particular signature is demanded by Prometheus to generate the counter metric.
    Finally, we are incrementing the counter with the `Add(1)`function call.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewCounter`创建一个新的计数器结构，需要计数器选项。这些选项是操作的名称和其他细节。然后，我们需要在该结构上调用`With`函数，传入方法、方法名称和错误代码。这个特定的签名是Prometheus要求生成计数器指标的。最后，我们使用`Add(1)`函数调用增加计数器。'
- en: 'The newly added file `instrumentation.go` implementation looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 新添加的`instrumentation.go`文件的实现如下：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is exactly the same as the logging middleware code. We created a struct
    with a few fields. We attached the functions for both the encrypt and decrypt
    services. Inside the middleware function, we are looking for two metrics; one
    is count and the second one is latency. When a request is passed through this
    middleware:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这与日志中间件代码完全相同。我们创建了一个带有几个字段的结构体。我们附加了加密和解密服务的函数。在中间件函数内部，我们正在寻找两个指标；一个是计数，另一个是延迟。当一个请求通过这个中间件时：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This line increments the counter. Now see the other line:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行增加了计数器。现在看看另一行：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This line observes the latency by calculating the difference between the request
    arrival time and final time (since the defer keyword is used, this will be executed
    after the request and response cycle is completed). In simple words, the preceding
    middleware logs the request count and latency to the metrics provided by the Prometheus
    client. Now let us modify our `main.go` file to look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行通过计算请求到达时间和最终时间之间的差异来观察延迟（由于使用了defer关键字，这将在请求和响应周期完成后执行）。简而言之，前面的中间件将请求计数和延迟记录到Prometheus客户端提供的指标中。现在让我们修改我们的`main.go`文件，使其看起来像这样：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are importing the kit Prometheus package for initializing the metrics template,
    and the client Prometheus package for providing the option structs. We are creating
    `requestCount` and `requestLatency`metrics-type structs and passing them to our `InstrumentingMiddleware`,
    which is imported from `helpers`.  If you see this line:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了kit Prometheus包来初始化指标模板，以及客户端Prometheus包来提供选项结构。我们创建了`requestCount`和`requestLatency`类型的指标结构，并将它们传递给我们从`helpers`导入的`InstrumentingMiddleware`。如果你看到这一行：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is how we create a template that matches with the `RequestCount`in the `InstrumentingMiddleware`struct
    in `helpers.go`. The options that we pass will be appended to a single string
    while generating the metrics:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何创建一个模板，与`helpers.go`中的`InstrumentingMiddleware`结构中的`RequestCount`匹配。我们传递的选项将附加到一个字符串中，同时生成指标：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is a uniquely identifiable service instrumentation that tells us, *This
    is a request count operation for my microservice called Encryption*. There is
    one more interesting line we added to the server part of the code in `main.go`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个唯一可识别的服务仪器，告诉我们，“这是一个用于名为Encryption的我的微服务的请求计数操作”。我们还在`main.go`的服务器部分的代码中添加了一行有趣的内容：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This actually creates an endpoint that can generate a page with collected metrics.
    This page can be scraped (parsed) by Prometheus to store, plot, and display metrics.
    If we run the program and make 5 HTTP requests to the encrypt service and 10 HTTP
    requests to the decrypt service, the metrics page logs the count of requests and
    their latencies:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上创建了一个端点，可以生成一个包含收集到的指标的页面。Prometheus可以解析此页面以存储、绘制和显示指标。如果我们运行程序并对加密服务进行5次HTTP请求，并对解密服务进行10次HTTP请求，指标页面将记录请求的计数和它们的延迟：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Make 5 CURL requests to the encrypt service in a loop from another bash shell
    (in Linux):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个bash shell（在Linux中）循环对加密服务进行5次CURL请求：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Make 10 CURL requests in a loop for the decrypt service (the output is hidden
    for brevity):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对解密服务进行10次CURL请求（输出已隐藏以保持简洁）：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, visit the URL `http://localhost:8080/metrics` and you will see a page
    that the Prometheus Go client is generating for us. The content of the page will
    have this information:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，访问URL`http://localhost:8080/metrics`，您将看到Prometheus Go客户端为我们生成的页面。页面的内容将包含以下信息：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see, there are two types of metrics:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有两种类型的指标：
- en: '`encryption_myservice_request_count`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encryption_myservice_request_count`'
- en: '`encryption_myservice_request_latency_microseconds`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encryption_myservice_request_latency_microseconds`'
- en: If you see the number of requests to the `encrypt` method and `decrypt` method,
    they match with the CURL requests we made.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到对`encrypt`方法和`decrypt`方法的请求数，它们与我们发出的CURL请求相匹配。
- en: The `encryption_myservice` metrics type has count and latencymetrics for both
    the encrypt and decrypt microservices. The method parameter tells from which microservice
    the metrics are drawn.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`encryption_myservice`指标类型对加密和解密微服务都有计数和延迟指标。方法参数告诉我们这些指标是从哪个微服务中提取的。'
- en: These kinds of metrics give us key insights, such as which microservice is being
    used heavily and how the latency trends are over time, and so on. But in order
    to see the data in action, you need to install the Prometheus server and write
    a configuration file for Prometheus to scrape metrics from your Go Kit service.
    For more information about creating targets (hosts generating metrics pages) in
    Prometheus, visit [https://prometheus.io/docs/operating/configuration/](https://prometheus.io/docs/operating/configuration/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的指标为我们提供了关键的见解，例如哪个微服务被大量使用以及延迟趋势随时间的变化等。但是，要看到数据的实际情况，您需要安装Prometheus服务器，并为Prometheus编写一个配置文件，以从Go
    Kit服务中抓取指标。有关在Prometheus中创建目标（生成指标页面的主机）的更多信息，请访问[https://prometheus.io/docs/operating/configuration/](https://prometheus.io/docs/operating/configuration/)。
- en: We can also pass data from Prometheus to Grafana, a graphing and monitoring
    tool for nice real-time charts of metrics. Go Kit provides many other features,
    such as service discovery. Scaling microservices is only possible if the system
    is loosely coupled, monitored, and optimized.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将来自Prometheus的数据传递给Grafana，这是一个用于漂亮实时图表的图形化和监控工具。Go Kit还提供了许多其他功能，例如服务发现。只有在系统松散耦合、监控和优化的情况下，微服务才能进行扩展。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started with the definition of microservices. The main difference
    between a monolith application and a microservice is the way tightly coupled architecture
    is broken into loosely coupled architecture. Microservices talk to each other
    using either REST-based JSON or RPC-based protocol buffers. Using microservices,
    we can break business logic into multiple chunks. Each service does one job pretty
    well. This approach comes with a disadvantage. Monitoring and managing microservices
    is painful. Go provides a wonderful toolkit called Go Kit. It is a microservices
    framework using which we can generate boilerplate code for microservices.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从微服务的定义开始。单体应用程序和微服务之间的主要区别在于紧密耦合的架构是如何被分解为松散耦合的架构。微服务之间使用基于REST的JSON或基于RPC的协议缓冲区进行通信。使用微服务，我们可以将业务逻辑分解为多个部分。每个服务都很好地完成了一项工作。这种方法也带来了一个缺点。监控和管理微服务是痛苦的。Go提供了一个名为Go
    Kit的精彩工具包。这是一个微服务框架，使用它我们可以为微服务生成样板代码。
- en: We need to define a few things in Go Kit. We need to create implementations,
    endpoints, and models for a Go-Kit service. Endpoints take requests and return
    responses. Implementations have the actual business logic of services. Models
    are a nice way to decode and encode request and response objects. Go Kit provides
    various middleware for performing vital tasks such as logging, instrumentation
    (metrics), and service discovery.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在Go Kit中定义一些东西。我们需要为Go-Kit服务创建实现、端点和模型。端点接收请求并返回响应。实现具有服务的实际业务逻辑。模型是解码和编码请求和响应对象的一种好方法。Go
    Kit提供了各种中间件，用于执行重要任务，如日志记录、仪表（指标）和服务发现。
- en: The small organizations can start with a monolith, but in bigger organizations
    with huge teams, microservices suit better. In the next chapter, we can see how
    to deploy our Go services using Nginx. A service needs to be deployed for it to
    be exposed to the outside world.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 小型组织可以从单体应用开始，但在规模更大的组织中，拥有庞大团队的微服务更合适。在下一章中，我们将看到如何使用Nginx部署我们的Go服务。服务需要部署才能暴露给外部世界。
