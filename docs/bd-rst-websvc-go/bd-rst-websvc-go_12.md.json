["```go\ngo get github.com/gorilla/sessions\n```", "```go\nvar store = sessions.NewCookieStore([]byte(\"secret_key\"))\n```", "```go\nmkdir simpleAuth\ntouch main.py\n```", "```go\npackage main\nimport (\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"time\"\n    \"github.com/gorilla/mux\"\n    \"github.com/gorilla/sessions\"\n)\nvar store =\nsessions.NewCookieStore([]byte(os.Getenv(\"SESSION_SECRET\")))\nvar users = map[string]string{\"naren\": \"passme\", \"admin\": \"password\"}\n// HealthcheckHandler returns the date and time\nfunc HealthcheckHandler(w http.ResponseWriter, r *http.Request) {\n    session, _ := store.Get(r, \"session.id\")\n    if (session.Values[\"authenticated\"] != nil) && session.Values[\"authenticated\"] != false {\n        w.Write([]byte(time.Now().String()))\n    } else {\n        http.Error(w, \"Forbidden\", http.StatusForbidden)\n    }\n}\n// LoginHandler validates the user credentials\nfunc LoginHandler(w http.ResponseWriter, r *http.Request) {\n    session, _ := store.Get(r, \"session.id\")\n    err := r.ParseForm()\n    if err != nil {\n        http.Error(w, \"Please pass the data as URL form encoded\",\nhttp.StatusBadRequest)\n        return\n    }\n    username := r.PostForm.Get(\"username\")\n    password := r.PostForm.Get(\"password\")\n    if originalPassword, ok := users[username]; ok {\n        if password == originalPassword {\n            session.Values[\"authenticated\"] = true\n            session.Save(r, w)\n        } else {\n            http.Error(w, \"Invalid Credentials\", http.StatusUnauthorized)\n            return\n        }\n    } else {\n        http.Error(w, \"User is not found\", http.StatusNotFound)\n        return\n    }\n    w.Write([]byte(\"Logged In successfully\"))\n}\n// LogoutHandler removes the session\nfunc LogoutHandler(w http.ResponseWriter, r *http.Request) {\n    session, _ := store.Get(r, \"session.id\")\n    session.Values[\"authenticated\"] = false\n    session.Save(r, w)\n    w.Write([]byte(\"\"))\n}\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/login\", LoginHandler)\n    r.HandleFunc(\"/healthcheck\", HealthcheckHandler)\n    r.HandleFunc(\"/logout\", LogoutHandler)\n    http.Handle(\"/\", r)\n    srv := &http.Server{\n        Handler: r,\n        Addr: \"127.0.0.1:8000\",\n        // Good practice: enforce timeouts for servers you create!\n        WriteTimeout: 15 * time.Second,\n        ReadTimeout: 15 * time.Second,\n    }\n    log.Fatal(srv.ListenAndServe())\n}\n```", "```go\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_SECRET\")))\n```", "```go\nsession, _ := store.Get(r, \"session.id\")\n```", "```go\nerr := r.ParseForm()\n```", "```go\nsession.Values[\"authenticated\"] = true\nsession.Save(r, w)\n```", "```go\nsession, _ := store.Get(r, \"session.id\")\n```", "```go\nsession, _ := store.Get(r, \"session.id\")\nsession.Values[\"authenticated\"] = false\nsession.Save(r, w)\n```", "```go\nsession.id=MTUwODYzNDcwN3xEdi1CQkFFQ180SUFBUkFCRUFBQUpmLUNBQUVHYzNSeWFXNW5EQThBRFdGMWRHaGxiblJwWTJGMFpXUUVZbTl2YkFJQ0FBRT189iF-ruBQmyTdtAOaMR-Rr9lNtsf1OJgirBDkcBpdEa0=; path=/; domain=localhost; Expires=Tue Nov 21 2017 01:11:47 GMT+0530 (IST);\n```", "```go\n2017-10-22 06:54:36.464214959 +0530 IST\n```", "```go\nhttp://localhost:8000/logout\n```", "```go\nsudo apt-get install redis-server\n```", "```go\nbrew install redis\n```", "```go\nredis-server\n```", "```go\n[7:30:30] naren:~ $ redis-cli\n127.0.0.1:6379> SET Foo  1\nOK\n127.0.0.1:6379> GET Foo\n\"1\"\n```", "```go\n127.0.0.1:6379> INCR Foo\n(integer) 2\n```", "```go\n127.0.0.1:6379> SET name \"redis\"\nOK\n127.0.0.1:6379> INCR name\n(error) ERR value is not an integer or out of range\n```", "```go\ngo get gopkg.in/boj/redistore.v1\n```", "```go\npackage main\nimport (\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"time\"\n    \"github.com/gorilla/mux\"\n    redistore \"gopkg.in/boj/redistore.v1\"\n)\nvar store, err = redistore.NewRediStore(10, \"tcp\", \":6379\", \"\", []byte(os.Getenv(\"SESSION_SECRET\")))\nvar users = map[string]string{\"naren\": \"passme\", \"admin\": \"password\"}\n// HealthcheckHandler returns the date and time\nfunc HealthcheckHandler(w http.ResponseWriter, r *http.Request) {\n    session, _ := store.Get(r, \"session.id\")\n    if (session.Values[\"authenticated\"] != nil) && session.Values[\"authenticated\"] != false {\n        w.Write([]byte(time.Now().String()))\n    } else {\n        http.Error(w, \"Forbidden\", http.StatusForbidden)\n    }\n}\n// LoginHandler validates the user credentials\nfunc LoginHandler(w http.ResponseWriter, r *http.Request) {\n    session, _ := store.Get(r, \"session.id\")\n    err := r.ParseForm()\n    if err != nil {\n        http.Error(w, \"Please pass the data as URL form encoded\", http.StatusBadRequest)\n        return\n    }\n    username := r.PostForm.Get(\"username\")\n    password := r.PostForm.Get(\"password\")\n    if originalPassword, ok := users[username]; ok {\n        if password == originalPassword {\n            session.Values[\"authenticated\"] = true\n            session.Save(r, w)\n        } else {\n            http.Error(w, \"Invalid Credentials\", http.StatusUnauthorized)\n            return\n        }\n    } else {\n        http.Error(w, \"User is not found\", http.StatusNotFound)\n        return\n    }\n    w.Write([]byte(\"Logged In successfully\"))\n}\n// LogoutHandler removes the session\nfunc LogoutHandler(w http.ResponseWriter, r *http.Request) {\n    session, _ := store.Get(r, \"session.id\")\n    session.Options.MaxAge = -1\n    session.Save(r, w)\n    w.Write([]byte(\"\"))\n}\nfunc main() {\n    defer store.Close()\n    r := mux.NewRouter()\n    r.HandleFunc(\"/login\", LoginHandler)\n    r.HandleFunc(\"/healthcheck\", HealthcheckHandler)\n    r.HandleFunc(\"/logout\", LogoutHandler)\n    http.Handle(\"/\", r)\n    srv := &http.Server{\n        Handler: r,\n        Addr: \"127.0.0.1:8000\",\n        // Good practice: enforce timeouts for servers you create!\n        WriteTimeout: 15 * time.Second,\n        ReadTimeout: 15 * time.Second,\n    }\n    log.Fatal(srv.ListenAndServe())\n}\n```", "```go\n  session.Options.MaxAge = -1\n```", "```go\n[15:09:48] naren:~ $ redis-cli\n127.0.0.1:6379> KEYS *\n1) \"session_VPJ54LWRE4DNTYCLEJWAUN5SDLVW6LN6MLB26W2OB4JDT26CR2GA\"\n127.0.0.1:6379>\n```", "```go\n`{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}`\n```", "```go\n`{\n  \"sub\": \"1234567890\",\n  \"username\": \"Indiana Jones\",\n  \"admin\": true\n}`\n```", "```go\nsignature = HMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n```", "```go\ntokenString = base64UrlEncode(header) + \".\" + base64UrlEncode(payload) + \".\" + signature\n```", "```go\ngo get github.com/dgrijalva/jwt-go \n```", "```go\ntoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n    \"username\": \"admin\",\n    \"iat\":time.Now().Unix(),\n})\n```", "```go\ntokenString, err := token.SignedString(\"my_secret_key\")\n```", "```go\ntokenString = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoiMTUwODc0MTU5MTQ2NiJ9.5m6KkuQFCgyaGS_xcVy4xWakwDgtAG3ILGGTBgYVBmE\"\n\n```", "```go\ntoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n    // key function\n    if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n        return nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n    }\n    return \"my_secret_key\", nil\n})\n\nif claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {\n    // Use claims for authorization if token is valid\n    fmt.Println(claims[\"username\"], claims[\"iat\"])\n} else {\n    fmt.Println(err)\n}\n```", "```go\npackage main\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"time\"\n    jwt \"github.com/dgrijalva/jwt-go\"\n    \"github.com/dgrijalva/jwt-go/request\"\n    \"github.com/gorilla/mux\"\n)\nvar secretKey = []byte(os.Getenv(\"SESSION_SECRET\"))\nvar users = map[string]string{\"naren\": \"passme\", \"admin\": \"password\"}\n// Response is a representation of JSON response for JWT\ntype Response struct {\n    Token string `json:\"token\"`\n    Status string `json:\"status\"`\n}\n// HealthcheckHandler returns the date and time\nfunc HealthcheckHandler(w http.ResponseWriter, r *http.Request) {\n    tokenString, err := request.HeaderExtractor{\"access_token\"}.ExtractToken(r)\n    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n        // Don't forget to validate the alg is what you expect:\n        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n            return nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n        }\n        // hmacSampleSecret is a []byte containing your secret, e.g. []byte(\"my_secret_key\")\n        return secretKey, nil\n    })\n    if err != nil {\n        w.WriteHeader(http.StatusForbidden)\n        w.Write([]byte(\"Access Denied; Please check the access token\"))\n        return\n    }\n    if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {\n        // If token is valid\n        response := make(map[string]string)\n        // response[\"user\"] = claims[\"username\"]\n        response[\"time\"] = time.Now().String()\n        response[\"user\"] = claims[\"username\"].(string)\n        responseJSON, _ := json.Marshal(response)\n        w.Write(responseJSON)\n    } else {\n        w.WriteHeader(http.StatusForbidden)\n        w.Write([]byte(err.Error()))\n    }\n}\n// LoginHandler validates the user credentials\nfunc getTokenHandler(w http.ResponseWriter, r *http.Request) {\n    err := r.ParseForm()\n    if err != nil {\n        http.Error(w, \"Please pass the data as URL form encoded\", http.StatusBadRequest)\n        return\n    }\n    username := r.PostForm.Get(\"username\")\n    password := r.PostForm.Get(\"password\")\n    if originalPassword, ok := users[username]; ok {\n        if password == originalPassword {\n            // Create a claims map\n            claims := jwt.MapClaims{\n                \"username\": username,\n                \"ExpiresAt\": 15000,\n                \"IssuedAt\": time.Now().Unix(),\n            }\n            token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n            tokenString, err := token.SignedString(secretKey)\n            if err != nil {\n                w.WriteHeader(http.StatusBadGateway)\n                w.Write([]byte(err.Error()))\n            }\n            response := Response{Token: tokenString, Status: \"success\"}\n            responseJSON, _ := json.Marshal(response)\n            w.WriteHeader(http.StatusOK)\n            w.Header().Set(\"Content-Type\", \"application/json\")\n            w.Write(responseJSON)\n        } else {\n            http.Error(w, \"Invalid Credentials\", http.StatusUnauthorized)\n            return\n        }\n    } else {\n        http.Error(w, \"User is not found\", http.StatusNotFound)\n        return\n    }\n}\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/getToken\", getTokenHandler)\n    r.HandleFunc(\"/healthcheck\", HealthcheckHandler)\n    http.Handle(\"/\", r)\n    srv := &http.Server{\n        Handler: r,\n        Addr: \"127.0.0.1:8000\",\n        // Good practice: enforce timeouts for servers you create!\n        WriteTimeout: 15 * time.Second,\n        ReadTimeout: 15 * time.Second,\n    }\n    log.Fatal(srv.ListenAndServe())\n}\n```", "```go\n      claims := jwt.MapClaims{\n        \"username\": username,\n        \"ExpiresAt\": 15000,\n        \"IssuedAt\": time.Now().Unix(),\n      } \n```", "```go\nAccess Denied; Please check the access token\n```"]