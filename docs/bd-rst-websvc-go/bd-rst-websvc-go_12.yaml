- en: Handling Authentication for Our REST Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理我们的REST服务的身份验证
- en: In this chapter, we are going to explore authentication patterns in Go. Those
    patterns are `session-based authentication`, `JSON Web Tokens (JWT)`, and `Open
    Authentication 2 (OAuth2)`. We will try to leverage the Gorilla package's sessions
    library to create basic sessions. Then, we will try to move onto advanced REST
    API authentication strategies such as using stateless JWT. Finally, we will see
    how to implement our own OAuth2 and also learn what packages are available to
    provide us out-of-box OAuth2 implementations. In the previous chapter, the API
    gateway implemented authentication (using plugins) for us. If the API gateway
    is not present in our architecture, how do we secure our API? You will find the
    answer in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Go中的身份验证模式。这些模式是基于会话的身份验证、JSON Web Tokens（JWT）和Open Authentication
    2（OAuth2）。我们将尝试利用Gorilla包的sessions库来创建基本会话。然后，我们将尝试进入高级REST API身份验证策略，比如使用无状态JWT。最后，我们将看到如何实现我们自己的OAuth2，并了解有哪些包可用来提供给我们现成的OAuth2实现。在上一章中，API网关为我们实现了身份验证（使用插件）。如果API网关不在我们的架构中，我们如何保护我们的API？你将在本章中找到答案。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How authentication works
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证工作原理
- en: Introducing Postman, a visual client for testing APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Postman，一个用于测试API的可视化客户端
- en: Session-based authentication in Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中基于会话的身份验证
- en: Introducing Redis to store user sessions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入Redis来存储用户会话
- en: Introduction to JSON Web Tokens (JWT)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍JSON Web Tokens（JWT）
- en: OAuth2 architecture and basics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth2架构和基础知识
- en: Getting the code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码
- en: You can get the code samples for this chapter at [https://github.com/narenaryan/gorestful/tree/master/chapter12](https://github.com/narenaryan/gorestful/tree/master/chapter12).
    Since the example programs are not packages, the reader needs to create the project
    files by following the GOPATH way of writing projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/narenaryan/gorestful/tree/master/chapter12](https://github.com/narenaryan/gorestful/tree/master/chapter12)获取本章的代码示例。由于示例程序不是包，读者需要按照GOPATH的方式创建项目文件。
- en: How authentication works
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证工作原理
- en: Traditionally, authentication or simple authentication works in a session-centric
    way. A client that is requesting resources from the server tries to prove that
    it is the right consumer for any given resource. The flow starts like this. A
    client sends an authentication request to the server using user credentials. The
    server takes those credentials and matches them with the credentials stored on
    the server. If a match is successful, it writes something called a cookie in the
    response. This cookie is a small piece of information that is transferred to and
    from subsequent requests. The modern **user interfaces** (**UI**) of websites
    are **single-page applications** (**SPAs**). There, the static web assets like
    HTML, JS are served from a CDN to render the web page initially. From next time,
    the communication between the web page and application server happens only through
    REST API/Web services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，身份验证或简单身份验证以会话为中心的方式工作。请求服务器资源的客户端试图证明自己是任何给定资源的合适消费者。流程开始如下。客户端使用用户凭据向服务器发送身份验证请求。服务器接受这些凭据并将其与服务器上存储的凭据进行匹配。如果匹配成功，它会在响应中写入一个称为cookie的东西。这个cookie是一小段信息，传输到后续请求中。现代网站的用户界面（UI）是单页应用程序（SPA）。在那里，静态网页资产如HTML、JS是从CDN提供的，以渲染网页。从下一次开始，网页和应用服务器之间的通信只通过REST
    API/Web服务进行。
- en: 'A session is a nice way to record the user communication in a given period
    of time. The session is a concept that is usually stored in a cookie. The following
    diagram can sum up the entire process of authentication (simply auth):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 会话是记录用户在一定时间内的通信的一种好方法。会话通常存储在cookie中。以下图表可以总结认证（简称auth）的整个过程：
- en: '![](img/a377d17c-27dc-4a16-b66c-fa5adbdbc5ed.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a377d17c-27dc-4a16-b66c-fa5adbdbc5ed.png)'
- en: Now see the practical approach. A client (for example, a browser) sends a request
    to the **Login API** of the server. The server tries to check those credentials
    with the database and if credentials exist, writes a cookie back onto the response
    saying this user is authenticated. A cookie is a message to be consumed by the
    server at the later point of time. When the client receives the response, it stores
    that cookie locally. If the web browser is the client, it stores it in the cookie
    storage. From next time, the client can freely ask for resources from the server
    by showing the cookie as the key for passage. When a client decides to terminate
    the session, it calls the Logout API on the server. The server destroys the session
    in the response. This process continues. The server can also keep an expiration
    on cookies so that the authentication window is valid for a certain time if there
    is no activity. This is how all websites work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看实际的方法。客户端（例如浏览器）向服务器的登录API发送请求。服务器尝试使用数据库检查这些凭据，如果凭据存在，就会在响应中写入一个cookie，表示这个用户已经通过身份验证。cookie是服务器在以后的时间点要消耗的消息。当客户端接收到响应时，它会在本地存储该cookie。如果是Web浏览器是客户端，它会将其存储在cookie存储中。从下一次开始，客户端可以自由地通过显示cookie作为通行证来请求服务器的资源。当客户端决定终止会话时，它调用服务器上的注销API。服务器在响应中销毁会话。这个过程继续进行。服务器还可以在cookie上设置过期时间，以便在没有活动的情况下，认证窗口在一定时间内有效。这就是所有网站的工作原理。
- en: 'Now, we will try to implement one such system using the Gorilla kit''s `sessions`
    package. We already saw how the Gorilla kit provides an HTTP router in the initial
    chapters. This sessions package is one of them. We need to install the package
    first by using the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试使用Gorilla kit的`sessions`包来实现这样的系统。我们已经在最初的章节中看到了Gorilla kit如何提供HTTP路由。这个sessions包就是其中之一。我们需要首先使用以下命令安装这个包：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can create a new session using this statement:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下语句创建一个新的会话：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That `secret_key` should be the key that Gorilla sessions use to encrypt the
    session cookies. If we add a session as a normal text, anyone can read it. So,
    the server needs to encrypt a message to a random string. For that, it asks to
    provide a secret key. This secret key can be any randomly generated string. Keeping
    secret keys in code is not a good idea, so we try to store it as an environment
    variable and read it in code on the fly. We will see how we can implement one
    such system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`secret_key`应该是Gorilla sessions用来加密会话cookie的密钥。如果我们将会话添加为普通文本，任何人都可以读取它。因此，服务器需要将消息加密为一个随机字符串。为此，它要求提供一个密钥。这个密钥可以是任何随机生成的字符串。将密钥保存在代码中并不是一个好主意，所以我们尝试将其存储为环境变量，并在代码中动态读取它。我们将看到如何实现这样一个系统。'
- en: Session-based authentication
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于会话的身份验证
- en: 'Create a project called `simpleAuth` in GOPATH and add a `main.go` file,which
    holds the logic for our program:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在GOPATH中创建一个名为`simpleAuth`的项目，并添加一个名为`main.go`的文件，其中包含我们程序的逻辑：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this program, we are going to see how we can create a session-based authentication
    using the Gorilla sessions package. Refer to the following code snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们将看到如何使用Gorilla sessions包创建基于会话的身份验证。参考以下代码片段：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is a REST API that allows one to access the health condition (up or not)
    of the system. In order to authenticate, one needs to call the login endpoint
    first. The program imported two main packages called mux and sessions from the
    Gorilla kit. Mux is used to link the URL endpoints of HTTP requests to a function
    handler, and sessions is used to create new sessions and validate existing ones
    on the fly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个REST API，允许用户访问系统的健康状况（正常或异常）。为了进行身份验证，用户需要首先调用登录端点。该程序导入了两个名为mux和sessions的主要包，来自Gorilla
    kit。Mux用于将HTTP请求的URL端点链接到函数处理程序，sessions用于在运行时创建新会话和验证现有会话。
- en: 'In Go, we need to store sessions in the program memory. We can do that by creating
    `CookieStore.` This line explicitly tells the program to create one by picking
    the secret key from the environment variable called `SESSION_SECRET`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，我们需要将会话存储在程序内存中。我们可以通过创建`CookieStore`来实现。这行明确告诉程序从名为`SESSION_SECRET`的环境变量中选择一个密钥来创建一个密钥。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`sessions` has a new function called `NewCookieStore`that returns a store.
    We need to use this store to manage cookies. We can get a cookie session with
    this statement. If the session doesn''t exist, it returns an empty one:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessions`有一个名为`NewCookieStore`的新函数，返回一个存储。我们需要使用这个存储来管理cookie。我们可以通过这个语句获取一个cookie会话。如果会话不存在，它将返回一个空的会话：'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`session.id` is a custom name that we gave to the session. With this name,
    a cookie will be sent back in the client response. `LoginHandler`tries to parse
    the form that was supplied by the client as multipart form data. This step is
    essential in the program:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`session.id`是我们为会话指定的自定义名称。使用这个名称，服务器将在客户端响应中发送一个cookie。`LoginHandler`尝试解析客户端提供的多部分表单数据。这一步在程序中是必不可少的：'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This fills the `r.PostForm`map with the parsed key-value pairs. That API requires
    both username and password for its authentication. So, we are interested in scraping `username`
    and `password`. Once `LoginHandler` receives the data, it tries to check it with
    the details in a map called **users**.In a practical scenario, we use the database
    to validate those details. For simplicity''s sake, we hardcoded values and tried
    to authenticate from it. If the username doesn''t exist, return an error saying
    resource not found. If the username exists and the password is incorrect, return
    an `UnAuthorized` error message. If everything goes well, return a 200 response
    by setting the cookie value, like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用解析后的键值对填充`r.PostForm`映射。该API需要用户名和密码进行身份验证。因此，我们对`username`和`password`感兴趣。一旦`LoginHandler`接收到数据，它会尝试与名为**users**的映射中的详细信息进行检查。在实际场景中，我们使用数据库来验证这些详细信息。为了简单起见，我们硬编码了值并尝试进行身份验证。如果用户名不存在，则返回一个资源未找到的错误。如果用户名存在但密码不正确，则返回一个`UnAuthorized`错误消息。如果一切顺利，通过设置cookie值返回一个200响应，如下所示：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first statement sets the cookie key called `"authenticated"` to `true`.
    The second statement actually saves the session on the response. It takes request
    and response writers as the arguments. If we remove this statement, the cookie
    will not have any effect. Now, coming to the `HealthCheckHandler`, it does the
    same thing as `LoginHandler` initially, like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句将名为`"authenticated"`的cookie键设置为`true`。第二条语句实际上将会话保存在响应中。它以请求和响应写入器作为参数。如果我们删除这个语句，cookie将不会产生任何效果。现在，来看看`HealthCheckHandler`，它最初与`LoginHandler`做同样的事情，如下所示：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, it checks whether a given request has a cookie that has the key called
    `"authenticated"`. If that key exists and is true, it means it is the user that
    the server authenticated previously. But, if that key does not exist or the `"authenticated"`
    value is `false`, then the session is not valid, hence it returns a `StatusForbidden`
    error.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它检查给定的请求是否具有名为`"authenticated"`的cookie键。如果该键存在且为true，则表示之前服务器经过身份验证的用户。但是，如果该键不存在或`"authenticated"`值为`false`，则会话无效，因此返回一个`StatusForbidden`错误。
- en: 'There should be a way for the client to invalidate a login session. It can
    do that by calling the logout APIof the server. The API just sets the `"authenticated"`
    value to `false`. This tells the server that the client is not authenticated:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应该有一种方式来使登录会话失效。它可以通过调用服务器的注销API来实现。该API只是将`"authenticated"`值设置为`false`。这告诉服务器客户端未经身份验证：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this way, a simple authentication can be implemented using the sessions in
    any programming language, including Go.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，可以在任何编程语言中使用会话来实现简单的身份验证，包括Go。
- en: Don't forget to add this statement, as it is the actual one that modifies and
    saves the cookie: `session.Save(r, w)`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记添加这个语句，因为这是实际修改和保存cookie的语句：`session.Save(r, w)`。
- en: Now, let us see the execution of this program. Instead of CURL, we can use a
    wonderful tool called Postman. The main benefit is that it runs on all platforms
    including Microsoft Window; no need for CURL anymore.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个程序的执行。与其使用CURL，我们可以使用一个名为Postman的绝妙工具。其主要好处是它可以在包括Microsoft Window在内的所有平台上运行；不再需要CURL了。
- en: The error codes can mean different things. For example, Forbidden (403) is issued
    when the user tries to access a resource without authentication, whereas Resource
    Not Found (404) is issued when the given resource does not exist on the server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码可能意味着不同的事情。例如，当用户尝试在没有身份验证的情况下访问资源时，会发出Forbidden（403）错误，而当给定资源在服务器上不存在时，会发出Resource
    Not Found（404）错误。
- en: Introducing Postman, a tool for testing REST API
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Postman，一个用于测试REST API的工具
- en: Postman is a wonderful tool that allows Windows, macOS X, and Linux users to
    make HTTP API requests. You can download it at [https://www.getpostman.com/](https://www.getpostman.com/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Postman是一个很棒的工具，允许Windows、macOS X和Linux用户进行HTTP API请求。您可以在[https://www.getpostman.com/](https://www.getpostman.com/)下载它。
- en: 'After installing Postman, enter a URL in the Enter request URLinput text. Select
    the type of request (`GET`, `POST`, and so on). For each request, we can have
    many settings such as headers, `POST` body, and other details. Please go through
    the Postman documentation for more details. The basic usage of Postman is straightforward.
    Take a look at the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Postman后，在“输入请求URL”文本框中输入URL。选择请求类型（`GET`、`POST`等）。对于每个请求，我们可以有许多设置，如头部、`POST`主体和其他详细信息。请查阅Postman文档以获取更多详细信息。Postman的基本用法很简单。请看下面的截图：
- en: '![](img/0e02ffe3-9719-4ff1-9d82-832c209ba65d.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e02ffe3-9719-4ff1-9d82-832c209ba65d.png)'
- en: 'The builder is the window where we can add/edit requests. The preceding screenshot
    shows the empty builder where we try to make requests. Run the `main.go` in the
    preceding `simpleAuth` project and try to call the health check API, like this.
    Click on the Send button and you will see the response is forbidden:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器是我们可以添加/编辑请求的窗口。上面的截图显示了我们尝试发出请求的空构建器。运行上面的`simpleAuth`项目中的`main.go`，尝试调用健康检查API，就像这样。单击发送按钮，您会看到响应被禁止：
- en: '![](img/42a5cf72-dea0-41d6-b3a2-917401543995.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42a5cf72-dea0-41d6-b3a2-917401543995.png)'
- en: 'This is because we didn''t log in yet. Postman automatically saves the cookie
    once authentication is successful. Now, call the login API by changing the method
    type from `GET` to POST and URL to `http://localhost:8000/login`. We should also
    pass the auth details as multipart form data. It looks like the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们还没有登录。Postman在身份验证成功后会自动保存cookie。现在，将方法类型从`GET`更改为POST，URL更改为`http://localhost:8000/login`，调用登录API。我们还应该将auth详细信息作为多部分表单数据传递。它看起来像下面的截图：
- en: '![](img/cb63a0a0-deb2-444c-a841-d642d390a511.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb63a0a0-deb2-444c-a841-d642d390a511.png)'
- en: 'Now, if we hit send, it authenticates and receives the cookie. It returns a
    message saying Logged In successfully. We can also inspect the cookies by clicking
    on the Cookies link just below the Send and Save buttons on right-hand side. It
    shows the list of cookies saved and you will find a cookie called `session.id`
    there for localhost. The content will look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们点击发送，它会进行身份验证并接收cookie。它返回一条消息，说成功登录。我们还可以通过点击右侧“发送”和“保存”按钮下方的Cookies链接来检查cookies。它会显示已保存的cookie列表，你会在那里找到一个名为`session.id`的cookie，内容看起来像这样：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Try to call the health check API again, and it returns us the system date and
    time:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次调用健康检查API，它会返回系统日期和时间：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If a client makes a `GET` request to the logout API:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端向注销API发出`GET`请求：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The session will be invalidated and access to the resource will be forbidden
    until another login request is done.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 会话将被使无效，并且访问资源将被禁止，直到进行另一个登录请求。
- en: Persisting client sessions with Redis
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis持久化客户端会话
- en: The sessions we created until now are stored in the program memory. It means
    if the program crashes or restarts, all the logged sessions will be lost. It needs
    the client to re-authenticate once again to get a new session cookie. It can be
    an annoying thing sometimes. In order to save sessions in some place, we chose
    **Redis**. Redis is a key-value storage that is very fast because it lives in
    primary memory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们创建的会话都存储在程序内存中。这意味着如果程序崩溃或重新启动，所有已登录的会话都将丢失。客户端需要重新进行身份验证以获取新的会话cookie。有时这可能会很烦人。为了将会话保存在某个地方，我们选择了**Redis**。Redis是一个键值存储，非常快，因为它存在于主内存中。
- en: 'The Redis server stores any key-value pairs we supply. It provides basic data
    types such as strings, lists, hashes, sets, and so on. For more details, visit [https://redis.io/topics/data-types](https://redis.io/topics/data-types). We
    can install Redis with the following command on Ubuntu 16.04:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Redis服务器存储我们提供的任何键值对。它提供基本的数据类型，如字符串、列表、哈希、集合等。有关更多详细信息，请访问[https://redis.io/topics/data-types](https://redis.io/topics/data-types)。我们可以在Ubuntu
    16.04上使用以下命令安装Redis：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'On macOS X, we can just say:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS X上，我们可以这样说：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For Windows too, binaries are available on the Redis website. Once Redis is
    installed, we can start the Redis server with this command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，也可以在Redis网站上找到二进制文件。安装Redis后，可以使用以下命令启动Redis服务器：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It starts the server on default port `6379`. Now, we can store anything in
    that using Redis CLI (command-line tool). Open a new terminal and type `redis-cli`.
    Once the shell is launched, we can perform Redis commands to store and retrieve
    data into the user-defined type variables:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它在默认端口`6379`上启动服务器。现在，我们可以使用Redis CLI（命令行工具）在其中存储任何内容。打开一个新的终端，输入`redis-cli`。一旦启动了shell，我们可以执行Redis命令将数据存储和检索到用户定义的类型变量中：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can store a key value using the `SET` Redis command. It stores the value
    as a string. If we try to perform `GET`, it returns us the string. It is our responsibility
    to convert them to numbers. Redis provides us handy functions to operate on those
    keys. For example, we can increment a key like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`SET` Redis命令存储键值。它将值存储为字符串。如果我们尝试执行`GET`，它会返回字符串。我们有责任将它们转换为数字。Redis为我们提供了方便的函数来操作这些键。例如，我们可以像这样递增一个键：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Redis treats integers as integers internally. If you try to increment a non-number
    string, Redis throws an error:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Redis在内部将整数视为整数。如果尝试递增非数字字符串，Redis会抛出错误：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Why are we discussing Redis here? Because we are showing how Redis works and
    introducing a few basic commands on the Redis server. We are going to modify our
    project from `simpleAuth` to `simpleAuthWithRedis`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在这里讨论Redis？因为我们正在展示Redis的工作原理，并介绍Redis服务器上的一些基本命令。我们将把项目从`simpleAuth`修改为`simpleAuthWithRedis`。
- en: In that project, instead of storing sessions in program memory, we use Redis.
    Even though the program crashes, sessions are not lost since they are saved in
    the external server. Who writes the bridging logic for that? We should. Luckily,
    we have a package that takes care of that coordination between Redis and the Go
    sessions package.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在该项目中，我们使用Redis而不是在程序内存中存储会话。即使程序崩溃，会话也不会丢失，因为它们保存在外部服务器中。谁为此编写了桥接逻辑？我们应该。幸运的是，我们有一个包来处理Redis和Go会话包之间的协调。
- en: 'Install that package with the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装该包：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And create a new program with a few modifications. Here, instead of using the
    sessions library, we use the `redistore` package. `redistore` has a function called
    `NewRediStore` that takes Redis configuration as the arguments along with the
    secret key. All other functions remain same. Now, add a `main.go` file in the `simpleAuthWithRedis`
    directory:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 并创建一个带有一些修改的新程序。在这里，我们使用`redistore`包，而不是使用会话库。`redistore`有一个名为`NewRediStore`的函数，它以Redis配置作为参数以及秘钥。所有其他函数保持不变。现在，在`simpleAuthWithRedis`目录中添加一个`main.go`文件：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'One interesting change is that we removed the session instead of setting its
    value to `false`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的变化是，我们删除了会话，而不是将其值设置为`false`：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This improved program works exactly the same as the previous one, except the
    session is saved in Redis. Open the Redis CLI and type this command to get all
    available keys:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改进的程序与之前的程序完全相同，只是会话保存在Redis中。打开Redis CLI并输入以下命令以获取所有可用的键：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That lengthy `"session_VPJ54LWRE4DNTYCLEJWAUN5SDLVW6LN6MLB26W2OB4JDT26CR2GA"`
    is the key stored by the `redistore`. If we delete that key, the client will automatically
    be forbidden from accessing resources. Now, stop the running program and restart
    it. You will see the session is not lost. In this way, we can save the client
    session. We can also persist sessions on the SQLite database. Many third-party
    packages are written to make that much easier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那个冗长的`"session_VPJ54LWRE4DNTYCLEJWAUN5SDLVW6LN6MLB26W2OB4JDT26CR2GA"`是由`redistore`存储的键。如果我们删除该键，客户端将自动被禁止访问资源。现在停止运行程序并重新启动。您会看到会话没有丢失。通过这种方式，我们可以保存客户端会话。我们也可以在SQLite数据库上持久化会话。许多第三方包都是为了使这一点更容易而编写的。
- en: '**Redis** can serve the purpose of caching for your web applications. It can
    store temporary data such as sessions, frequently requested user content, and
    so on. It is usually compared to **memcached**.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redis**可以用作Web应用程序的缓存。它可以存储临时数据，如会话、频繁请求的用户内容等。通常与**memcached**进行比较。'
- en: Introduction to JSON Web Tokens (JWT) and OAuth2
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Web Tokens（JWT）和OAuth2简介
- en: The previous style of authentication is a plain username/password and session-based.
    It has a limitation of managing sessions by saving them in the program memory
    or Redis/SQLite3\. The modern REST API implements token-based authentication.
    Here, tokens can be any strings generated by the server, which allows the client
    to access resources by showing the token. Here, the token is computed in such
    a way that the client and the server only know how to encode/decode the token.
    **JWT** tries to solve this problem by enabling us to create tokens that we can
    pass around.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的身份验证方式是明文用户名/密码和基于会话的。它有一个通过将它们保存在程序内存或Redis/SQLite3中来管理会话的限制。现代REST API实现了基于令牌的身份验证。在这里，令牌可以是服务器生成的任何字符串，允许客户端通过显示令牌来访问资源。在这里，令牌是以这样一种方式计算的，即客户端和服务器只知道如何编码/解码令牌。**JWT**试图通过使我们能够创建可以传递的令牌来解决这个问题。
- en: 'Whenever a client passes the authentication details to the server, the server
    generates a token and passes it back to the client. The client saves that in some
    kind of storage, such as a database or local storage (in case of browser). The
    client uses that token to ask for resources from any API defined by the server:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每当客户端将认证详细信息传递给服务器时，服务器会生成一个令牌并将其传递回客户端。客户端将其保存在某种存储中，例如数据库或本地存储（在浏览器的情况下）。客户端使用该令牌向服务器定义的任何API请求资源：
- en: '![](img/976d6e2e-da56-43e7-9c9c-ad288472b2ac.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/976d6e2e-da56-43e7-9c9c-ad288472b2ac.png)'
- en: 'The steps can be summarized more briefly as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤可以更简要地总结如下：
- en: The client passes the username/password in a `POST` request to the login API.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将用户名/密码在`POST`请求中传递给登录API。
- en: The server authenticates the details and if successful, it generates a JWT and
    returns it back instead of creating a cookie. It is the client's responsibility
    to store this token.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器验证详细信息，如果成功，生成JWT并返回，而不是创建cookie。客户端有责任存储这个令牌。
- en: Now, the client has the JWT. It needs to add this in subsequent REST API calls
    such as `GET`, `POST`, `PUT`, and `DELETE` in the request headers.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，客户端有了JWT。它需要在后续的REST API调用中添加这个令牌，比如`GET`、`POST`、`PUT`和`DELETE`。
- en: Once again, the server checks the JWT and if it is successfully decoded, the
    server sends the data back by looking at the username supplied as part of the
    token.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器再次检查JWT，如果成功解码，服务器通过查看作为令牌一部分提供的用户名发送数据。
- en: JWT ensures that the data is sent from the correct client. The technique for
    creating a token takes cares of that logic. JWT leverages the secret key-based
    encryption.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JWT确保数据来自正确的客户端。创建令牌的技术负责处理这个逻辑。JWT利用基于秘钥的加密。
- en: JSON web token format
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON web token格式
- en: 'All we discussed in the preceding section was circling around a JWT token.
    We are going to see here what it really looks like and how it is produced. JWT is
    a string that is generated after performing few a steps. They are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分讨论的一切都围绕着JWT令牌。我们将在这里看到它真正的样子以及它是如何生成的。JWT是在执行几个步骤后生成的字符串。它们如下：
- en: Create a JWT header by doing **Base64Url** encoding on the header JSON.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对标头JSON进行**Base64Url**编码来创建JWT标头。
- en: Create a JWT payload by doing **Base64Url** encoding on the payload JSON.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对有效负载JSON进行**Base64Url**编码来创建JWT有效负载。
- en: Create a signature by encrypting the appended header and payload using a secret
    key.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用秘钥对附加的标头和有效负载进行加密来创建签名。
- en: JWT string can be obtained by appending the header, payload, and signature.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT字符串可以通过附加标头、有效负载和签名来获得。
- en: 'A header is a simple JSON object. It looks like the following code snippet
    in Go:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 标头是一个简单的JSON对象。在Go中，它看起来像以下代码片段：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`"alg"` is a short form for the algorithm (HMAC with SHA-256) used for creating
    a signature. The message type is `"JWT"`. This will be common for all the headers.
    The algorithm may change depending on the system.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`"alg"`是用于创建签名的算法（HMAC与SHA-256）的简写形式。消息类型是`"JWT"`。这对所有标头都是通用的。算法可能会根据系统而变化。'
- en: 'A payload looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有效负载看起来像这样：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Keys in payload object are called claims. A claim is a key that specifies some
    special meaning to the server. There are three types of claims:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有效负载对象中的键称为声明。声明是指定服务器某些特殊含义的键。有三种类型的声明：
- en: Public claims
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共声明
- en: Private claims (more important)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有声明（更重要）
- en: Reserved claims
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留声明
- en: Reserved claims
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留声明
- en: 'Reserved claims are the ones defined by the JWT standard. They are:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 保留声明是由JWT标准定义的声明。它们是：
- en: iat: issued at the time
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'iat: 发行时间'
- en: 'iss: issuer name'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'iss: 发行者名称'
- en: 'sub: subject text'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'sub: 主题文本'
- en: 'aud: audience name'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'aud: 受众名称'
- en: 'exp: expiration time'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'exp: 过期时间'
- en: For example, the server, while generating a token, can set an `exp` claim in
    the payload. The client then uses that token to access API resources. The server
    validates the token each time. When the expiration time is passed, the server
    will no longer validate the token. The client needs to generate a new token by
    logging in again.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，服务器在生成令牌时可以在有效负载中设置一个`exp`声明。然后客户端使用该令牌来访问API资源。服务器每次验证令牌时。当过期时间过去时，服务器将不再验证令牌。客户端需要通过重新登录生成新的令牌。
- en: Private claims
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有声明
- en: Private claims are the names used to identify one token from another. It can
    be used for authorization. Authorization is a process of identifying which client
    made the request. Multi-tenancy is having multiple clients in a system. The server
    can set a private claim called `username` on the payload of the token. Next time,
    the server can read this payload back and get the username, and then use that
    username to authorize and customize the API response.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 私有声明是用来识别一个令牌与另一个令牌的名称。它可以用于授权。授权是识别哪个客户端发出了请求的过程。多租户是在系统中有多个客户端。服务器可以在令牌的有效负载上设置一个名为`username`的私有声明。下次，服务器可以读取这个有效负载并获取用户名，然后使用该用户名来授权和自定义API响应。
- en: '`"username": "Indiana Jones"` is the private claim on the preceding sample
    payload. **Public claims** are the ones similar to private claims, but they should
    be registered with the IANA JSON Web Token Registry to make it as a standard.
    We limit the use of these.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`"username": "Indiana Jones"`是前面示例有效负载上的私有声明。**公共声明**类似于私有声明，但它们应该在IANA JSON
    Web Token注册表中注册为标准。我们限制了这些的使用。'
- en: 'A signature can be created by performing this (this is not code, just an illustration):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过执行以下操作来创建签名（这不是代码，只是一个示例）：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is simply performing an encryption algorithm on the Base64URL encoded header
    and payload with a secret. This secret can be any string. It is exactly similar
    to the secret we used in the previous cookie session. This secret is usually saved
    in the environment variable and loaded into the program.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对使用秘钥的Base64URL编码的标头和有效负载执行加密算法。这个秘钥可以是任何字符串。它与我们在以前的cookie会话中使用的秘钥完全相似。这个秘钥通常保存在环境变量中，并加载到程序中。
- en: 'Now we append the encoded header, encoded payload, and signature to get our
    token string:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们附加编码的标头、编码的有效负载和签名以获得我们的令牌字符串：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is how a JWT token is generated. Are we going to do all this stuff manually
    in Go? No. In Go, or any other programming language, a few packages are available
    to wrap this manual creation of a token and verification. Go has a wonderful,
    popular package called `jwt-go`.We are going to create a project in the next section
    that uses `jwt-go` to sign a JWT and also validate them. One can install the package
    using the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是JWT令牌是如何生成的。我们在Go中要手动做所有这些事情吗？不。在Go或任何其他编程语言中，有一些可用的包来包装令牌的手动创建和验证。Go有一个名为`jwt-go`的精彩、流行的包。我们将在下一节中创建一个使用`jwt-go`来签署JWT并验证它们的项目。可以使用以下命令安装该包：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is the official GitHub page for the project: [https://github.com/dgrijalva/jwt-go](https://github.com/dgrijalva/jwt-go). The
    package provides a few functions that allow us to create tokens. There are many
    other packages with different additional features. You can see all available packages
    and features supported at [https://jwt.io/#libraries-io](https://jwt.io/#libraries-io).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该项目的官方GitHub页面：[https://github.com/dgrijalva/jwt-go](https://github.com/dgrijalva/jwt-go)。该包提供了一些函数，允许我们创建令牌。还有许多其他具有不同附加功能的包。您可以在[https://jwt.io/#libraries-io](https://jwt.io/#libraries-io)上查看所有可用的包和支持的功能。
- en: Creating a JWT in Go
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中创建JWT
- en: 'The `jwt-go` package has a function called `NewWithClaims` that takes two arguments:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`jwt-go`包有一个名为`NewWithClaims`的函数，它接受两个参数：'
- en: Signing method such as HMAC256, RSA, and so on
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 签名方法如HMAC256、RSA等
- en: Claims map
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明映射
- en: 'For example, it looks like the following code snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它看起来像以下代码片段：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`jwt.SigningMethodHS256`is an encryption algorithm that is available within
    the package. The second argument is a map with claims such as private (here username)
    and reserved (issued at). Now we can generate a `tokenString` using the `SignedString`
    function on a token:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`jwt.SigningMethodHS256`是包中可用的加密算法。第二个参数是一个带有声明的映射，例如私有（这里是用户名）和保留（发行于）。现在我们可以使用`SignedString`函数在令牌上生成一个`tokenString`：'
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This `tokenString` then should be passed back to the client.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后应将此`tokenString`传回客户端。
- en: Reading a JWT in Go
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中读取JWT
- en: '`jwt-go` also gives us the API to parse a given JWT string. The `Parse`function
    takes a string and key function as arguments. The `key` function is a custom function
    that validates whether the algorithm is proper or not. Let us say this is a sample
    token string generated by the preceding encoding:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`jwt-go`还为我们提供了解析给定JWT字符串的API。`Parse`函数接受字符串和密钥函数作为参数。`key`函数是一个自定义函数，用于验证算法是否正确。假设这是由前面的编码生成的示例令牌字符串：'
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can parse and get back the original JSON using:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以解析并获取原始的JSON使用：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`token.Claims` is implemented by a map called `MapClaims`. We can get the original
    JSON key-value pairs from that map.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`token.Claims`由一个名为`MapClaims`的映射实现。我们可以从该映射中获取原始的JSON键值对。'
- en: OAuth 2 architecture and basics
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2架构和基础知识
- en: OAuth 2 is an authentication framework that is used to create authentication
    pattern between different systems. In this, the client, instead of making a request
    to the resource server, makes an initial request for some entity called resource
    owner. This resource owner gives back the authentication grant for the client
    (if credentials are successful). The client now sends this authentication grant
    to another entity called an authentication server. This authentication server
    takes the grant and returns an access token. This token is the key thing for a
    client to access API resources. It needs to make an API request to the resource
    server with this access token and the response is served. In this entire flow,
    the second part can be done using JWT. Before that, let us learn the difference
    between authentication and authorization.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2是用于在不同系统之间创建身份验证模式的身份验证框架。在此，客户端不是向资源服务器发出请求，而是首先请求某个名为资源所有者的实体。资源所有者返回客户端的身份验证授权（如果凭据成功）。客户端现在将此身份验证授权发送到另一个名为身份验证服务器的实体。此身份验证服务器接受授权并返回访问令牌。此令牌是客户端访问API资源的关键。它需要使用此访问令牌向资源服务器发出API请求，并提供响应。在整个流程中，第二部分可以使用JWT完成。在此之前，让我们了解身份验证和授权之间的区别。
- en: Authentication versus authorization
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证与授权
- en: '**Authentication** is the process of identifying whether a client is genuine
    or not. When a server authenticates a client, it checks the username/password
    pair and creates session cookie/JWT.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份验证**是识别客户端是否真实的过程。当服务器对客户端进行身份验证时，它会检查用户名/密码对并创建会话cookie/JWT。'
- en: '**Authorization **is the process of differentiating one client from another
    after a successful authentication. In cloud services, the resources requested
    by a client need to be served by checking that the resources belong to that client
    but not the other client. The permissions and access to resources vary for different
    clients. For example, the admin has the highest privileges of resources. A normal
    user''s access is limited.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**授权**是在成功身份验证后区分一个客户端与另一个客户端的过程。在云服务中，客户端请求的资源需要通过检查资源是否属于该客户端而不是其他客户端来提供。不同客户端的权限和资源访问也不同。例如，管理员拥有资源的最高权限。普通用户的访问受到限制。'
- en: OAuth2 is a protocol for authenticating multiple clients to a service, whereas
    the JWT is a token format. We need to encode/decode JWT tokens to implement the
    second stage (dashed lines in the following screenshot) of OAuth 2.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2是用于对多个客户端进行身份验证的协议，而JWT是一种令牌格式。我们需要对JWT令牌进行编码/解码以实现OAuth 2的第二阶段（以下截图中的虚线）。
- en: 'Take a look at the following diagram:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表：
- en: '![](img/e52ff092-f411-4ce0-b04b-536942867fa2.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e52ff092-f411-4ce0-b04b-536942867fa2.png)'
- en: In this diagram, we can implement the dashed section using JWT. Authentication
    is happening at the authentication server level and authorization happens at the
    resource server level.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我们可以使用JWT实现虚线部分。身份验证发生在身份验证服务器级别，授权发生在资源服务器级别。
- en: 'In the next section, let us write a program that does two things:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们编写一个程序，完成两件事：
- en: Authenticates the client and returns a JWT string.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对客户端进行身份验证并返回JWT字符串。
- en: Authorizes client API requests by validating JWT.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过验证JWT授权客户端API请求。
- en: 'Create a directory called `jwtauth`and add `main.go`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`jwtauth`的目录并添加`main.go`：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a very lengthy program to digest. First, we are importing `jwt-go` and
    its subpackage called `request`. We are creating a REST API for two endpoints;
    one for getting the access token by providing authentication details, and another
    one for fetching the health check API that authorizes the user.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常冗长的程序。首先，我们导入`jwt-go`及其名为`request`的子包。我们为两个端点创建了一个REST API；一个用于通过提供身份验证详细信息获取访问令牌，另一个用于获取授权用户的健康检查API。
- en: In the **`getTokenHandler` **handler function, we are comparing the username
    and password with our custom defined user map. This can be a database too. If
    authentication is successful, we are generating a JWT string and sending it back
    to the client.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在**`getTokenHandler`**处理函数中，我们正在将用户名和密码与我们自定义定义的用户映射进行比较。这也可以是一个数据库。如果身份验证成功，我们将生成一个JWT字符串并将其发送回客户端。
- en: 'In `HealthcheckHandler`, we are taking the access token from a header called
    `access_token`and validating it by parsing the JWT string. Who is writing the
    logic of validating? The JWT package itself. When a new JWT string is created
    it should have a claim called `ExpiresAt`. Refer to the following code snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HealthcheckHandler`中，我们从名为`access_token`的标头中获取访问令牌，并通过解析JWT字符串来验证它。谁编写验证逻辑？JWT包本身。当创建新的JWT字符串时，它应该有一个名为`ExpiresAt`的声明。参考以下代码片段：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The program's internal validation logic looks at the `IssuedAt` and `ExpiresAt`
    claims and tries to compute and see whether the given token is expired or not.
    If it is fresh, then it means the token is validated.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的内部验证逻辑查看`IssuedAt`和`ExpiresAt`声明，并尝试计算并查看给定的令牌是否已过期。如果是新鲜的，那么意味着令牌已验证。
- en: Now, when a token is valid, we can read the payload in the `HealthCheckHandler`
    where we parse the `access_token`string that passed as part of the HTTP request
    headers. `username`is a custom private claim we inserted for authorization. Therefore,
    we know who is actually sending this request. For each and every request there
    is no need for the session to be passed. Each API call is independent and token
    based. Information is encoded in a token itself.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当令牌有效时，我们可以在`HealthCheckHandler`中读取有效载荷，解析作为HTTP请求标头的`access_token`字符串。`username`是我们为授权插入的自定义私有声明。因此，我们知道实际发送此请求的是谁。对于每个请求，不需要传递会话。每个API调用都是独立的且基于令牌的。信息已经编码在令牌中。
- en: '`token.Claims.(jwt.MapClaims)` returns a map whose values are interfaces, not
    strings. In order to convert the value to a string, we should do `claims["username"].(string)`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`token.Claims.(jwt.MapClaims)`返回一个值为接口而不是字符串的映射。为了将值转换为字符串，我们应该这样做`claims["username"].(string)`。'
- en: 'Let us see how this program runs by making requests through the Postman tool:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过Postman工具来看看这个程序是如何运行的：
- en: '![](img/41e2bbd3-3948-4935-856a-88236498565f.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41e2bbd3-3948-4935-856a-88236498565f.png)'
- en: 'This returns a JSON string that has a JWT token. Copy it to the clipboard. If
    you try to make a request to the health check API without passing that JWT token
    as one of the headers, you will receive this error message instead of JSON :'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个包含JWT令牌的JSON字符串。将其复制到剪贴板。如果您尝试在不传递JWT令牌作为其中一个标头的情况下向健康检查API发出请求，您将收到此错误消息而不是JSON：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, copy that token back and make a `GET` request, adding an `access_token`
    header with a token string as the value. In Postman, the headers section is available
    where we can add headers and key-value pairs. Refer to the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将该令牌复制回来，并进行`GET`请求，添加一个`access_token`标头，其值为令牌字符串。在Postman中，标头部分可用于添加标头和键值对。请参阅以下屏幕截图：
- en: '![](img/76d0689e-288d-49e2-a116-ca6449a14e69.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76d0689e-288d-49e2-a116-ca6449a14e69.png)'
- en: It returns the time properly as part of the API response. We can also see which
    user's JWT token this is. This confirms the authorization part of our REST API.
    Instead of having the token validation logic in each and every API handler, we
    can have it as a middleware and make it applicable to all handlers. Refer to [Chapter
    3](d4152cbc-41fa-414e-bd50-146e9549f41d.xhtml), *Working with Middleware and RPC*,
    and modify the preceding program to have a middleware that validates the JWT token.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它将正确返回时间作为API响应的一部分。我们还可以看到这是哪个用户的JWT令牌。这证实了我们的REST API的授权部分。我们可以将令牌验证逻辑放在每个API处理程序中，也可以将其作为中间件，并将其应用于所有处理程序。请参阅[第3章](d4152cbc-41fa-414e-bd50-146e9549f41d.xhtml)，*使用中间件和RPC*，并修改前面的程序以具有验证JWT令牌的中间件。
- en: Token-based authentication doesn't usually provide a log out API or API for
    deleting the tokens that are provided in session based authentication. The server
    gives the authorized resources to the client as long as JWT is not expired. Once
    it expires, the client needs to refresh the token—that is to say, ask the server
    for a new token.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 基于令牌的认证通常不提供注销API或用于删除会话基础认证中提供的令牌的API。只要JWT没有过期，服务器就会向客户端提供授权资源。一旦过期，客户端需要刷新令牌，也就是说，向服务器请求一个新令牌。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we introduced the process of authentication. We saw how authentication
    usually works. Authentication can be of two types: session-based or token-based.
    Session-based authentication is also called simple authentication, where a session
    is created when the client successfully logs in. That session is saved back in
    the client and supplied for each and every request. There are two possible cases
    here. In the first case, the session will be saved in the server''s program memory.
    This kind of session will be cleared when the application restarts. The second
    case is to save the session cookie in Redis. Redis is an in-memory database that
    can act as a cache for any web application. Redis supports storing a few data
    types such as string, list, hash, and so on. We explored a package called `redistore`
    that replaces the built-in sessions package for persisting the session cookies.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了认证的过程。我们看到了认证通常是如何工作的。认证可以分为两种类型：基于会话的认证和基于令牌的认证。基于会话的认证也被称为简单认证，客户端成功登录时会创建一个会话。该会话被保存在客户端并在每个请求中提供。这里有两种可能的情况。在第一种情况下，会话将保存在服务器的程序内存中。当应用程序重新启动时，这种会话将被清除。第二种情况是将会话cookie保存在Redis中。Redis是一个可以作为任何Web应用程序缓存的内存数据库。Redis支持存储一些数据类型，如字符串、列表、哈希等。我们探讨了一个名为`redistore`的包，它用于替换用于持久化会话cookie的内置会话包。
- en: Next, we saw about JWT. A JWT is a token string that is the output of performing
    a few steps. First, create a header, payload, and signature. A signature can be
    obtained by combining both header and payload with `base64URL` encoding and applying
    an encryption algorithm such as HMAC. In token-based authentication, a client needs
    a JWT token for accessing server resources. So, initially, it requests the server
    to provide the access token (JWT token). Once the client gets this token, next
    time it makes API calls with the JWT token in the HTTP header and the server returns
    the response.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们了解了JWT。JWT是执行一些步骤的输出的令牌字符串。首先，创建一个标头、有效载荷和签名。通过使用`base64URL`编码和应用诸如HMAC之类的加密算法，可以获得签名。在基于令牌的认证中，客户端需要一个JWT令牌来访问服务器资源。因此，最初，它请求服务器提供访问令牌（JWT令牌）。一旦客户端获得此令牌，下次它使用JWT令牌进行API调用，并将服务器返回响应。
- en: We introduced OAuth 2.0, an authentication framework. In OAuth 2, the client
    first requests for a grant from the resource owner. Once it gets the grant, it
    then requests an access token from the authentication server. The authentication
    server gives the access token, which client can use to request an API. We implemented
    the second step of OAuth 2 with JWT.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了OAuth 2.0，一个认证框架。在OAuth 2中，客户端首先向资源所有者请求授权。一旦获得授权，它就会向认证服务器请求访问令牌。认证服务器会提供访问令牌，客户端可以用它来请求API。我们用JWT实现了OAuth
    2的第二步。
- en: We tested all our APIs with a tool called Postman. Postman is a great tool that
    helps us to test our APIs quickly on any machine. CURL is limited to Linux and
    macOS X. Postman is a wise choice for Windows because it has all the features
    of CURL.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个叫做Postman的工具来测试所有的API。Postman是一个很棒的工具，可以帮助我们在任何机器上快速测试我们的API。CURL只能在Linux和macOS
    X上使用。Postman对于Windows来说是一个明智的选择，因为它拥有CURL的所有功能。
- en: We came a long way from the first chapter by learning how to create HTTP routes,
    middlewares, and handlers. We then linked our applications with databases to store
    the resource data. After the basics, we explored the performance-tuning aspects
    such as microservices and RPC.  Finally, we saw how to deploy our web services
    and also secure them using authentication.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习如何创建HTTP路由、中间件和处理程序，我们从第一章走了很长的路。然后我们将我们的应用程序与数据库连接起来，以存储资源数据。在掌握了基础知识之后，我们探索了微服务和RPC等性能调优方面。最后，我们学会了如何部署我们的Web服务，并使用认证来保护它们。
