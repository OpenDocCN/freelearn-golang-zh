- en: Modern Microservice Architectures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代微服务架构
- en: In the world of computing and software, we hear about many cool new technologies
    and frameworks almost every week. Some of them stay and persist, whereas others
    fail the test of time and disappear. Needless to say, cloud computing sits very
    comfortably in the former category. We live in a world where cloud computing powers
    almost everything that needs serious backend computing power, from **Internet
    of Things **(**IOT**) devices that check the temperature on a refrigerator to
    video games that show you real-time stats for your scores compared to your peers
    in multiplayer games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算和软件领域，我们几乎每周都会听到许多新的、酷炫的技术和框架。有些技术会留存并持续发展，而其他一些则无法经受时间的考验而消失。毫无疑问，云计算非常舒适地属于前一类。我们生活在一个云计算几乎支配着一切需要严肃的后端计算能力的世界，从检查冰箱温度的物联网设备到向你展示多人游戏中实时得分与同伴相比较的视频游戏。
- en: Cloud computing benefits huge enterprises with offices all over the world, as
    well as minimal start-ups of two people writing code in a coffee shop. There is
    tons of material that cover why cloud computing is so important for modern information
    technologies. For the sake of efficiency, we'll provide a straightforward answer
    to this question, without going into long bullet points, graphs, and lengthy paragraphs.
    For businesses, it's all about making money and saving costs. Cloud computing
    drives costs down significantly for most organizations. That's because cloud computing
    saves you the cost of building your own data center. No expensive hardware needs
    to be bought, and no expensive buildings with fancy air-conditioning systems need
    to be commissioned. Additionally, almost all cloud computing offerings give you
    the ability to pay for only what you use and no more. Cloud computing also offers
    massive flexibility for software engineers and IT administrators to do their jobs
    quickly and efficiently, thus achieving developer happiness and increased productivity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算使遍布全球的大型企业以及在咖啡店写代码的两个人的小型初创公司受益匪浅。有大量的材料解释了为什么云计算对现代信息技术如此重要。为了效率起见，我们将直接回答这个问题，而不会列出长长的要点、图表和冗长的段落。对于企业来说，一切都是为了赚钱和节省成本。云计算显著降低了大多数组织的成本。这是因为云计算节省了建立自己数据中心的成本。不需要购买昂贵的硬件，也不需要委托昂贵的带有花哨空调系统的建筑。此外，几乎所有的云计算服务都可以让你只支付你使用的部分。云计算还为软件工程师和IT管理员提供了巨大的灵活性，使他们能够快速高效地完成工作，从而实现开发人员的幸福和增加生产力。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Design goals of cloud-native applications, especially scalability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生应用的设计目标，尤其是可扩展性
- en: Different cloud service models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的云服务模型
- en: The twelve-factor app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十二要素应用
- en: Microservice architectures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Communication patterns, especially synchronous versus asynchronous communication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信模式，尤其是同步与异步通信
- en: Why Go?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Go？
- en: Go (or Golang) is a relatively new programming language that is taking the software
    development world by storm. It was developed by Google to facilitate the construction
    of its backend software services. However, it's now being used by numerous enterprises
    and start-ups to write powerful applications. What sets Go apart is the fact that
    it was built from the ground up to provide performance that is destined to compete
    with very powerful languages, such as C/C++, while supporting a relatively simple
    syntax that resembles dynamic languages such as JavaScript. The Go runtime offers
    garbage collection; however, it does not rely on virtual machines to achieve that.
    Go programs are compiled into native machine code. When invoking the Go compiler,
    you simply choose the type of platform (Windows, Mac, and so on) that you'd like
    the binary to run on when you build. The compiler will then produce a single binary
    that works on that platform. This makes Go capable of cross-compiling and producing
    native binaries.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go（或Golang）是一种相对较新的编程语言，正在以其独特之处席卷软件开发世界。它是由谷歌开发的，旨在简化其后端软件服务的构建。然而，现在许多企业和初创公司都在使用它来编写强大的应用程序。Go的独特之处在于，它从头开始构建，旨在提供与C/C++等非常强大的语言竞争的性能，同时支持类似JavaScript等动态语言的相对简单的语法。Go运行时提供垃圾回收；但它不依赖虚拟机来实现。Go程序被编译成本机代码。在调用Go编译器时，你只需选择构建时希望二进制文件在哪个平台（Windows、Mac等）上运行。编译器将会生成适用于该平台的单个二进制文件。这使得Go能够进行交叉编译并生成本机二进制文件。
- en: Go is perfect for microservice architectures, which we will be seeing a lot
    of in the future. A microservice architecture is an architecture where you divide
    the responsibilities of your application between smaller services that only focus
    on specific tasks. These services can then communicate among themselves to obtain
    the information they need to produce results.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言非常适合微服务架构，这在未来会变得非常普遍。微服务架构是一种架构，其中你将应用程序的责任分配给只专注于特定任务的较小服务。这些服务可以相互通信，以获取它们需要产生结果的信息。
- en: Go is a fresh programming language, developed in the age of cloud computing,
    and with modern software technologies in mind. Go is optimized for portable microservice
    architectures due to the fact that a Go program mostly compiles to a single binary,
    making the need for dependencies and virtual machines in production environments
    almost non-existent. Go is also a pioneer in container technologies. **Docker**,
    the top name in software containers, is written in none other than Go. Due to
    Go's popularity, there is work being done by major cloud providers, as well as
    third-party contributors, to ensure that Go gets the API support it needs for
    different cloud platforms.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种新的编程语言，是在云计算时代开发的，考虑了现代软件技术。由于Go程序大多编译为单个二进制文件，使得在生产环境中几乎不需要依赖和虚拟机，因此Go被优化用于便携式微服务架构。Go也是容器技术的先驱。**Docker**，软件容器的顶级名称，就是用Go编写的。由于Go的流行，主要云提供商以及第三方贡献者正在努力确保Go获得其在不同云平台所需的API支持。
- en: The goal of this book is to build the knowledge bridge between the Go programming
    language and the cloud technologies of modern computing. In this book, you will
    gain practical knowledge of Go microservice architectures, message queues, containers,
    cloud platform Go APIs, SaaS applications design, monitoring cloud applications,
    and more.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标是在Go编程语言和现代计算的云技术之间建立知识桥梁。在本书中，您将获得关于Go微服务架构、消息队列、容器、云平台Go API、SaaS应用程序设计、监控云应用程序等方面的实际知识。
- en: Basic design goals
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本设计目标
- en: In order to fully benefit from the advantages of modern cloud platforms, we
    need to consider their characteristic properties when developing applications
    that should run on these platforms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用现代云平台的优势，我们在开发应用程序时需要考虑其特性属性。
- en: One of the main design goals of cloud applications is **scalability****.** On
    the one hand, this means growing your application's resources as needed in order
    to efficiently serve all your users. On the other hand, it also means shrinking
    your resources back to an appropriate level when you do not need them anymore.
    This allows you to run your application in a cost-efficient manner without having
    to constantly overprovision for peak workloads.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 云应用程序的主要设计目标之一是**可扩展性**。一方面，这意味着根据需要增加应用程序的资源，以有效地为所有用户提供服务。另一方面，它还意味着在不再需要这些资源时将资源缩减到适当的水平。这使您能够以成本效益的方式运行应用程序，而无需不断地为高峰工作负载进行过度配置。
- en: In order to achieve this, typical cloud deployments often use small virtual
    machine instances that host an application and scale by adding (or removing) more
    of these instances. This method of scaling is called **horizontal scaling** or
    **scale out**—as opposed to **vertical scaling** or **scale up**, where you would
    not increase the number of instances, but provision more resources to your existing
    instances. Horizontal scaling is often preferred to vertical scaling for several
    reasons. First, horizontal scaling promises unlimited linear scalability. On the
    other hand, vertical scaling has its limits due to the fact that the number of
    resources that you can add to an existing server cannot grow infinitely. Secondly,
    horizontal scaling is often more cost-efficient since you can use cheap commodity
    hardware (or, in cloud environments, smaller instance types), whereas larger servers
    often grow exponentially more expensive.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，典型的云部署通常使用托管应用程序的小型虚拟机实例，并通过添加（或移除）更多这些实例来进行扩展。这种扩展方法称为**水平扩展**或**横向扩展**，与**垂直扩展**或**纵向扩展**相对应，后者不增加实例数量，而是为现有实例提供更多资源。出于几个原因，水平扩展通常优于垂直扩展。首先，水平扩展承诺无限的线性可扩展性。另一方面，由于现有服务器可以添加的资源数量不能无限增长，垂直扩展存在其限制。其次，水平扩展通常更具成本效益，因为您可以使用廉价的通用硬件（或在云环境中使用较小的实例类型），而较大的服务器通常会呈指数增长地更加昂贵。
- en: '![](img/0d2cad23-ebf1-486b-8494-78877ecf4fff.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d2cad23-ebf1-486b-8494-78877ecf4fff.png)'
- en: Horizontal scaling versus vertical scaling; the first works by adding more instances
    and load-balancing the workload across them, whereas the latter works by adding
    more resources to existing instances
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展与垂直扩展；前者通过添加更多实例并在它们之间平衡工作负载来工作，而后者通过向现有实例添加更多资源来工作
- en: 'All major cloud providers offer the ability to perform horizontal scaling automatically,
    depending on your application''s current resource utilization. This feature is
    called **auto-scaling**. Unfortunately, you do not get horizontal scalability
    for free. In order to be able to scale out, your application needs to adhere to
    some very important design goals that often need to be considered from the start,
    as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的云提供商都提供根据应用程序当前资源利用率自动执行水平扩展的能力。这个功能称为**自动扩展**。不幸的是，您并不能免费获得水平扩展。为了能够进行扩展，您的应用程序需要遵循一些非常重要的设计目标，这些目标通常需要从一开始就考虑，如下所示：
- en: '**Statelessness**: Each instance of a cloud application should not have any
    kind of internal state (meaning that any kind of data is saved for later use,
    either in-memory or on the filesystem). In a scale-out scenario, subsequent requests
    might be served by another instance of the application and, for this reason, must
    not rely on any kind of state being present from previous requests. In order to
    achieve this, it is usually necessary to externalize any kind of persistent storage,
    such as databases and filesystems. Both database services and file storage are
    often offered as managed services by the cloud provider that you use in your application.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态性**：云应用程序的每个实例都不应该有任何内部状态（这意味着任何类型的数据都保存在内存中或文件系统上以备后用）。在扩展场景中，后续请求可能由应用程序的另一个实例提供服务，因此必须不依赖于之前请求中存在任何状态。为了实现这一点，通常需要将任何类型的持久存储（如数据库和文件系统）外部化。数据库服务和文件存储通常由您在应用程序中使用的云提供商作为托管服务提供。'
- en: Of course, this does not mean that you cannot deploy stateful applications to
    the cloud. They will just be considerably harder to scale out, hindering you from
    using cloud computing environments to their full potential.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不意味着你不能将有状态的应用部署到云上。它们只是会更难以扩展，阻碍你充分利用云计算环境。
- en: '**Ease of deployment**: When scaling out, you will need to deploy new instances
    of your application quickly. Creating a new instance should not require any kind
    of manual setup, but should be automated as much as possible (ideally completely).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署简便性**：在扩展时，您需要快速部署应用程序的新实例。创建新实例不应该需要任何手动设置，而应尽可能自动化（理想情况下完全自动化）。'
- en: '**Resiliency:** In a cloud environment, especially when using auto-scaling,
    instances may be shut down at a moment''s notice. Also, most cloud providers do
    not guarantee an extremely high availability on individual instances (and suggest
    scaling out instead, optionally across multiple availability zones). For this
    reason, termination and sudden death (either intentionally, in case of auto-scaling,
    or unintentionally, in case of failure) is something that we always need to expect
    in a cloud environment, and the application must handle it accordingly.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：在云环境中，特别是在使用自动扩展时，实例可能会在瞬间被关闭。此外，大多数云服务提供商不保证单个实例的极高可用性（并建议进行扩展，可选地跨多个可用区）。因此，终止和突然死亡（无论是有意的，例如自动扩展，还是无意的，例如故障）是我们在云环境中始终需要预期的事情，应用程序必须相应地处理。'
- en: Achieving these design goals is not always easy. Cloud providers often support
    you in this task by offering managed services (for example, highly scalable database
    services of distributed file storage) that otherwise you would have to worry about
    yourself. Concerning your actual application, there is the **twelve-factor app**
    methodology (which we will cover in more detail in a later section), which describes
    a set of rules for building scalable and resilient applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些设计目标并不总是容易的。云服务提供商通常通过提供托管服务（例如高度可扩展的数据库服务或分布式文件存储）来支持您完成这项任务，否则您将不得不自己担心这些问题。关于您的实际应用程序，有**十二要素应用**方法论（我们将在后面的部分详细介绍），它描述了构建可扩展和有弹性的应用程序的一套规则。
- en: Cloud service models
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云服务模型
- en: 'When it comes to cloud computing offerings, there are three main service models
    to consider for your project:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算提供中，有三种主要的服务模型可供您考虑：
- en: '**IaaS** (**Infrastructure as a Service**): This is the model where the cloud
    service provider gives you access to infrastructure on the cloud, such as servers
    (virtual and bare metal), networks, firewalls, and storage devices. You use IaaS
    when all that you need is for the cloud provider to manage the infrastructure
    for you and take the hassle and the cost of maintaining it out of your hands.
    IaaS is used by start-ups and organizations that want full control over their
    application''s layer. Most IaaS offerings come with a dynamic or elastic scaling
    option, which would scale your infrastructure based on your consumption. This,
    in effect, saves organizations costs since they only pay for what they use.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IaaS**（**基础设施即服务**）：这是云服务提供商为您提供云上基础设施的模型，例如服务器（虚拟和裸金属）、网络、防火墙和存储设备。当您只需要云提供商为您管理基础设施并摆脱维护的麻烦和成本时，您可以使用IaaS。创业公司和希望对应用程序层拥有完全控制的组织使用IaaS。大多数IaaS提供都带有动态或弹性扩展选项，根据您的消耗来扩展您的基础设施。这实际上可以节省组织的成本，因为他们只支付他们使用的部分。'
- en: '**PaaS** (**Platform as a Service**): This is the next layer up from IaaS.
    PaaS provides the computing platform you need to run your application. PaaS typically
    includes the operating systems you need to develop your applications, the databases,
    the web layer (if needed), and the programming language execution environment.
    With PaaS, you don''t have to worry about updates and patches for your application
    environment; it gets taken care of by the cloud provider. Let''s say you wrote
    a powerful .NET application that you want to see running in the cloud. A PaaS
    solution will provide the .NET environment you need to run your application, combined
    with the Windows server operating systems and the IIS web servers. It will also take
    care of load-balancing and scale for larger applications. Imagine the amount of
    money and effort you could save by adopting a PaaS platform instead of doing the
    effort in-house.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PaaS**（**平台即服务**）：这是从IaaS上一层的服务。PaaS提供了您运行应用程序所需的计算平台。PaaS通常包括您开发应用程序所需的操作系统、数据库、Web层（如果需要）和编程语言执行环境。使用PaaS，您不必担心应用程序环境的更新和补丁；这些都由云服务提供商来处理。假设您编写了一个强大的.NET应用程序，希望在云中运行。PaaS解决方案将提供您运行应用程序所需的.NET环境，结合Windows服务器操作系统和IIS
    Web服务器。它还将负责大型应用程序的负载平衡和扩展。想象一下，通过采用PaaS平台而不是在内部进行努力，您可以节省多少金钱和精力。'
- en: '**SaaS** (**Software as a Service**): This is the highest layer offering you
    can obtain as a cloud solution. A SaaS solution is when a fully functional piece
    of software is delivered over the web. You access SaaS solutions from a web browser.
    SaaS solutions are typically used by regular users of the software, as opposed
    to programmers or software professionals. A very famous example of a SaaS platform
    is Netflix—a complex piece of software hosted in the cloud, which is available
    to you via the web. Another popular example is Salesforce. Salesforce solutions
    get delivered to customers through web browsers with speed and efficiency.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SaaS**（**软件即服务**）：这是作为云解决方案可以获得的最高层。SaaS解决方案是指通过网络交付的完全功能的软件。您可以从Web浏览器访问SaaS解决方案。SaaS解决方案通常由软件的普通用户使用，而不是程序员或软件专业人员。一个非常著名的SaaS平台的例子是Netflix——一个复杂的软件，托管在云中，可以通过网络访问。另一个流行的例子是Salesforce。Salesforce解决方案通过Web浏览器以速度和效率交付给客户。'
- en: Cloud application architecture patterns
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云应用架构模式
- en: Usually, developing applications that run in a cloud environment is not that
    different from regular application development. However, there are a few architectural
    patterns that are particularly common when targeting a cloud environment, which
    you will learn in the following section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在云环境中开发应用程序并不比常规应用程序开发有太大的不同。然而，在针对云环境时，有一些特别常见的架构模式，你将在下一节中学到。
- en: The twelve-factor app
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十二要素应用
- en: 'The twelve-factor app methodology is a set of rules for building scalable and
    resilient cloud applications. It was published by Heroku, one of the dominant
    PaaS providers. However, it can be applied to all kinds of cloud applications,
    independent of concrete infrastructure or platform providers. It is also independent
    of programming languages and persistence services and can equally be applied to
    Go programming and, for example, Node.js programming. The twelve-factor app methodology
    describes (unsurprisingly) twelve factors that you should consider in your application
    for it to be easily scalable, resilient, and platform independent. You can read
    up on the full description on each factor on [https://12factor.net](https://12factor.net/).
    For the purpose of this book, we will highlight some factors that we deem especially
    important:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用方法论是一组用于构建可扩展和具有弹性的云应用程序的规则。它由Heroku发布，是主要的PaaS提供商之一。然而，它可以应用于各种云应用程序，独立于具体的基础设施或平台提供商。它也独立于编程语言和持久化服务，并且同样适用于Go编程和例如Node.js编程。十二要素应用方法论描述了（不出所料的）十二个因素，你应该在应用程序中考虑这些因素，以便它易于扩展、具有弹性并且独立于平台。你可以在[https://12factor.net](https://12factor.net/)上阅读每个因素的完整描述。在本书中，我们将重点介绍一些我们认为特别重要的因素：
- en: '**Factor II: Dependencies—Explicitly declare and isolate dependencies**:This
    factor deserves special mention because it is actually not as important in Go
    programming as in other languages. Typically, a cloud application should never
    rely on any required library or external tool being already present on a system.
    Dependencies should be explicitly declared (for example, using an npm `package.json`
    file for a Node.js application) so that a package manager can pull all these dependencies
    when deploying a new instance of the application. In Go, an application is typically
    deployed as a statically compiled binary that already contains all required libraries.
    However, even a Go application can be dependent on external system tools (for
    example, it can fork out to tools such as **ImageMagick**) or on existing C libraries.
    Ideally, you should deploy tools like these alongside your application. This is
    where container engines, such as Docker, shine.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**因素II：依赖-明确声明和隔离依赖**：这个因素值得特别提及，因为在Go编程中它实际上并不像在其他语言中那么重要。通常，云应用程序不应该依赖于系统上已经存在的任何必需的库或外部工具。依赖应该被明确声明（例如，使用Node.js应用程序的npm
    `package.json`文件），这样一个包管理器在部署应用程序的新实例时可以拉取所有这些依赖。在Go中，一个应用程序通常部署为一个已经包含所有必需库的静态编译二进制文件。然而，即使是一个Go应用程序也可能依赖于外部系统工具（例如，它可以调用像ImageMagick这样的工具）或现有的C库。理想情况下，你应该将这些工具与你的应用程序一起部署。这就是容器引擎（如Docker）的优势所在。'
- en: '**Factor III: Config—Store config in the environment**: Configuration is any
    kind of data that might vary for different deployment, for example, connection
    data and credentials for external services and databases. These kinds of data
    should be passed to the application via environment variables. In a Go application,
    retrieving these is then as easy as calling `os.Getenv ("VARIABLE_NAME")`. In
    more complex cases (for example, when you have many configuration variables),
    you can also resort to libraries such as `github.com/tomazk/envcfg` or `github.com/caarlos0/env`.
    For heavy lifting, you can use the `github.com/spf13/viper` library.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**因素III：配置-在环境中存储配置**：配置是可能因不同部署而变化的任何类型的数据，例如外部服务和数据库的连接数据和凭据。这些类型的数据应该通过环境变量传递给应用程序。在Go应用程序中，获取这些数据就像调用`os.Getenv("VARIABLE_NAME")`一样简单。在更复杂的情况下（例如，当你有许多配置变量时），你也可以使用诸如`github.com/tomazk/envcfg`或`github.com/caarlos0/env`这样的库。对于繁重的工作，你可以使用`github.com/spf13/viper`库。'
- en: '**Factor IV: Backing Services—Treat backing services as attached resources**:
    Ensure that services that your app depends on (such as databases, messaging systems,
    or external APIs) are easily swappable by configuration. For example, your app
    could accept an environment variable, such as `DATABASE_URL`, that might contain
    `mysql://root:root@localhost/test` for a local development deployment and `mysql://root:XXX@prod.XXXX.eu-central-1.rds.amazonaws.com`
    in your production setup.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**因素IV：后备服务-将后备服务视为附加资源**：确保应用程序依赖的服务（如数据库、消息系统或外部API）可以通过配置轻松替换。例如，你的应用程序可以接受一个环境变量，比如`DATABASE_URL`，它可能包含`mysql://root:root@localhost/test`用于本地开发部署，以及`mysql://root:XXX@prod.XXXX.eu-central-1.rds.amazonaws.com`用于生产环境设置。'
- en: '**Factor VI: Processes—Execute the app as one or more stateless processes**:
    Running application instances should be stateless; any kind of data that should
    persist beyond a single request/transaction needs to be stored in an external
    persistence service.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**因素VI：进程-将应用程序作为一个或多个无状态进程执行**：运行应用程序实例应该是无状态的；任何需要持久化超出单个请求/事务的数据都需要存储在外部持久化服务中。'
- en: One important case to keep in mind is user sessions in web applications. Often,
    user session data is stored in the process's memory (or is persisted to the local
    filesystem) in the expectancy that subsequent requests of the same user will be
    served by the same instance of your application. Instead, try to keep user sessions
    stateless or move the session state into an external data store, such as **Redis**
    or **Memcached**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建可扩展和具有弹性的云应用程序时，有一个重要的案例需要牢记，那就是Web应用程序中的用户会话。通常，用户会话数据存储在进程的内存中（或者持久化到本地文件系统），期望同一用户的后续请求将由应用程序的同一实例提供。相反，尝试保持用户会话无状态，或者将会话状态移入外部数据存储，比如Redis或Memcached。
- en: '**Factor IX: Disposability—Maximize robustness with fast startup and graceful
    shutdown**: In a cloud environment, sudden termination (both intentional, for
    example, in case of downscaling, and unintentional, in case of failures) needs
    to be expected. A twelve-factor app should have fast startup times (typically
    in the range of a few seconds), allowing it to rapidly deploy new instances. Besides,
    fast startup and graceful termination is another requirement. When a server shut
    down, the operating system will typically tell your application to shut down by
    sending a **SIGTERM** signal that the application can catch and react to accordingly
    (for example, by stopping to listen on the service port, finishing requests that
    are currently being processed, and then exiting).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第九因素：可处置性-通过快速启动和优雅关闭最大限度地提高鲁棒性：**在云环境中，需要预期突然终止（无论是有意的，例如在缩减规模的情况下，还是无意的，在失败的情况下）。十二因素应用程序应具有快速的启动时间（通常在几秒钟的范围内），使其能够快速部署新实例。此外，快速启动和优雅终止是另一个要求。当服务器关闭时，操作系统通常会通过发送**SIGTERM**信号告诉您的应用程序关闭，应用程序可以捕获并做出相应反应（例如，停止监听服务端口，完成当前正在处理的请求，然后退出）。'
- en: '**Factor XI: Logs—Treat logs as event streams:** Log data is often useful for
    debugging and monitoring your application''s behavior. However, a twelve-factor
    app should not concern itself with the routing or storage of its own log data.
    The easiest and simplest solution is to simply write your log stream to the process''s
    standard output stream (for example, just using `fmt.Println(...)`). Streaming
    events to `stdout` allows a developer to simply watch the event stream on their
    console when developing the application. In production setups, you can configure
    the execution environment to catch the process output and send the log stream
    to a place where it can be processed (the possibilities here are endless—you could
    store them in your server''s **journald**, send them to a syslog server, store
    your logs in an ELK setup, or send them to an external cloud service).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第十一因素：日志-将日志视为事件流：**日志数据通常用于调试和监视应用程序的行为。但是，十二因素应用程序不应关心其自己日志数据的路由或存储。最简单的解决方案是将日志流写入进程的标准输出流（例如，只需使用`fmt.Println(...)`）。将事件流式传输到`stdout`允许开发人员在开发应用程序时简单地观看事件流。在生产环境中，您可以配置执行环境以捕获进程输出并将日志流发送到可以处理的地方（这里的可能性是无限的-您可以将它们存储在服务器的**journald**中，将它们发送到syslog服务器，将日志存储在ELK设置中，或将它们发送到外部云服务）。'
- en: What are microservices?
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: When an application is maintained by many different developers over a longer
    period of time, it tends to get more and more complex. Bug fixes, new or changing
    requirements, and constant technological changes result in your software continually
    growing and changing. When left unchecked, this software evolution will lead to
    your application getting more complex and increasingly difficult to maintain.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用程序在较长时间内由许多不同的开发人员维护时，它往往会变得越来越复杂。错误修复、新的或变化的需求以及不断变化的技术变化导致您的软件不断增长和变化。如果不加控制，这种软件演变将导致您的应用程序变得更加复杂和越来越难以维护。
- en: Preventing this kind of software erosion is the objective of the microservice
    architecture paradigm that has emerged over the past few years. In a microservice
    architecture, a software system is split into a set of (potentially a lot of)
    independent and isolated services. These run as separate processes and communicate
    using network protocols (of course, each of these services should in itself be
    a twelve-factor app). For a more thorough introduction to the topic, we can recommend
    the original article on the microservice architecture by Lewis and Fowler at [https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这种软件侵蚀的目标是过去几年中出现的微服务架构范式。在微服务架构中，软件系统被分割成一组（可能很多）独立和隔离的服务。这些作为单独的进程运行，并使用网络协议进行通信（当然，这些服务中的每一个本身都应该是一个十二因素应用程序）。有关该主题的更全面介绍，我们可以推荐Lewis和Fowler在[https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)上关于微服务架构的原始文章。
- en: In contrast to traditional **Service-Oriented Architectures** (**SOA**), which
    have been around for quite a while, microservice architectures focus on simplicity.
    Complex infrastructure components such as ESBs are avoided at all costs, and instead
    of complicated communication protocols such as SOAP, simpler means of communication
    such as REST web services (about which you will learn more in [Chapter 2](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml),
    *Building Microservices Using Rest APIs*) or AMQP messaging (refer to [Chapter
    4](0a806398-0654-46f9-8e6f-02af9334821b.xhtml), *Asynchronous Microservice Architectures
    Using Message Queues*) are preferred.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的面向服务的架构（SOA）相比，这种架构已经存在了相当长的时间，微服务架构注重简单性。复杂的基础设施组件，如ESB，应尽一切可能避免，而复杂的通信协议，如SOAP，更倾向于更简单的通信方式，如REST
    Web服务（关于这一点，您将在[第2章](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml)中了解更多，*使用Rest
    API构建微服务*）或AMQP消息传递（参见[第4章](0a806398-0654-46f9-8e6f-02af9334821b.xhtml)，*使用消息队列的异步微服务架构*）。
- en: Splitting complex software into separate components has several benefits. For
    instance, different services can be built on different technology stacks. For
    one service, using Go as runtime and MongoDB as persistence layer may be the optimal
    choice, whereas a Node.js runtime with a MySQL persistence might be a better choice for
    other components. Encapsulating functionality in separate services allows developer
    teams to choose the right tool for the right job. Other advantages of microservices
    on an organizational level are that each microservice can be owned by different
    teams within an organization. Each team can develop, deploy, and operate their
    services independently, allowing them to adjust their software in a very flexible
    way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将复杂软件拆分为单独的组件有几个好处。例如，不同的服务可以构建在不同的技术堆栈上。对于一个服务，使用Go作为运行时和MongoDB作为持久层可能是最佳选择，而对于其他组件，使用Node.js运行时和MySQL持久层可能是更好的选择。将功能封装在单独的服务中允许开发团队为正确的工作选择正确的工具。在组织层面上，微服务的其他优势是每个微服务可以由组织内的不同团队拥有。每个团队可以独立开发、部署和操作他们的服务，使他们能够以非常灵活的方式调整他们的软件。
- en: Deploying microservices
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署微服务
- en: With their focus on statelessness and horizontal scaling, microservices work
    well with modern cloud environments. Nevertheless, when choosing a microservice
    architecture, deploying your application will tend to get more complex overall,
    as you will need to deploy more, different applications (all the more reason to
    stick with the twelve-factor app methodology).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们专注于无状态和水平扩展，微服务与现代云环境非常匹配。然而，选择微服务架构时，总体上部署应用程序将变得更加复杂，因为您将需要部署更多不同的应用程序（这更加坚定了坚持十二要素应用程序方法论的理由）。
- en: However, each individual service will be easier to deploy than a big monolithic
    application. Depending on the service's size, it will also be easier to upgrade
    a service to a new runtime or to replace it with a new implementation entirely.
    Also, you can scale each microservice individually. This allows you to scale out
    heavily used parts of your application while keeping less utilized components
    cost-efficient. Of course, this requires each service to support horizontal scaling.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每个单独的服务将比一个大型的单体应用程序更容易部署。根据服务的大小，将更容易将服务升级到新的运行时，或者完全替换为新的实现。此外，您可以单独扩展每个微服务。这使您能够在保持使用较少的组件成本高效的同时，扩展应用程序中使用频繁的部分。当然，这要求每个服务都支持水平扩展。
- en: Deploying microservices gets (potentially) more complex when different services
    use different technologies. A possible solution for this problem is offered by
    modern container runtimes such as Docker or RKT. Using containers, you can package
    an application with all its dependencies into a container image and then use that
    image to quickly spawn a container running your application on any server that
    can run Docker (or RKT) containers. (Let's return to the twelve-factor app—deploying
    applications in containers is one of the most thorough interpretations of dependency
    isolation as prescribed by **Factor II**.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 部署微服务在不同服务使用不同技术时变得更加复杂。现代容器运行时（如Docker或RKT）提供了这个问题的一个可能解决方案。使用容器，您可以将应用程序及其所有依赖项打包到一个容器映像中，然后使用该映像快速生成一个在任何可以运行Docker（或RKT）容器的服务器上运行您的应用程序的容器。（让我们回到十二要素应用程序——在容器中部署应用程序是**要素II**规定的依赖项隔离的最彻底解释之一。）
- en: Running container workloads is a service offered by many major cloud providers
    (such as AWS' **Elastic Container Service**, the **Azure Container Service**,
    or the **Google Container Engine**). Apart from that, there are also container
    orchestration engines such as **Docker Swarm**, **Kubernetes**, or **Apache Mesos**
    that you can roll out on IaaS cloud platforms or your own hardware. These orchestration
    engines offer the possibility to distribute container workloads over entire server
    clusters, and offer a very high degree of automation. For example, the cluster
    manager will take care of deploying containers across any number of servers, automatically
    distributing them according to their resource requirements and usages. Many orchestration
    engines also offer auto-scaling features and are often tightly integrated with
    cloud environments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 许多主要云提供商（如AWS的**弹性容器服务**、**Azure容器服务**或**Google容器引擎**）提供运行容器工作负载的服务。除此之外，还有容器编排引擎，如**Docker
    Swarm**、**Kubernetes**或**Apache Mesos**，您可以在IaaS云平台或自己的硬件上部署。这些编排引擎提供了在整个服务器集群上分发容器工作负载的可能性，并提供了非常高的自动化程度。例如，集群管理器将负责在任意数量的服务器上部署容器，根据它们的资源需求和使用自动分发它们。许多编排引擎还提供自动扩展功能，并且通常与云环境紧密集成。
- en: You will learn more about deploying microservices with Docker and Kubernetes
    in [Chapter 6](af835c34-a409-4898-9a55-74fc9d05b46b.xhtml), *Deploying Your Application
    in Containers*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在[第6章](af835c34-a409-4898-9a55-74fc9d05b46b.xhtml)中了解有关使用Docker和Kubernetes部署微服务的更多信息，*在容器中部署您的应用程序*。
- en: REST web services and asynchronous messaging
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST网络服务和异步消息
- en: When building a microservice architecture, your individual services need to
    communicate with one another. One widely accepted de facto standard for microservice
    communication is RESTful web services (about which you will learn more in [Chapter
    2](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml), *Building Microservices Using
    Rest APIs*, and [Chapter 3](9c1db13f-619b-43a7-96a1-c6fc65e13b67.xhtml), *Securing
    Microservices*). These are usually built on top of HTTP (although the REST architectural
    style itself is more or less protocol independent) and follow the client/server
    model with a request/reply communication model.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建微服务架构时，您的各个服务需要相互通信。微服务通信的一个被广泛接受的事实标准是RESTful网络服务（关于这一点，您将在[第2章](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml)和[第3章](9c1db13f-619b-43a7-96a1-c6fc65e13b67.xhtml)中了解更多，*使用Rest
    API构建微服务*和*保护微服务*）。这些通常建立在HTTP之上（尽管REST架构风格本身更多或多少是协议独立的），并遵循请求/回复通信模型的客户端/服务器模型。
- en: '![](img/ee12981f-07fd-4efe-b986-a5914fb37798.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee12981f-07fd-4efe-b986-a5914fb37798.png)'
- en: Synchronous versus Asynchronous communication model
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同步与异步通信模型
- en: This architecture is typically easy to implement and to maintain. It works well
    for many use cases. However, the synchronous request/reply pattern may hit its
    limits when you are implementing a system with complex processes that span many
    services. Consider the first part of the preceding diagram. Here, we have a user
    service that manages an application's user database. Whenever a new user is created,
    we will need to make sure that other services in the system are also made aware
    of this new user. Using RESTful HTTP, the user service needs to notify these other
    services by REST calls. This means that the user service needs to know all other
    services that are in some way affected by the user management domain. This leads
    to a tight coupling between the components, which is something you'd generally
    like to avoid.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构通常易于实现和维护。它适用于许多用例。然而，同步请求/响应模式在实现跨多个服务的复杂流程的系统时可能会受到限制。考虑前图的第一部分。在这里，我们有一个用户服务，管理应用程序的用户数据库。每当创建新用户时，我们需要确保系统中的其他服务也知道这个新用户。使用RESTful
    HTTP，用户服务需要通过REST调用通知其他服务。这意味着用户服务需要知道所有其他受用户管理领域影响的服务。这导致组件之间的紧耦合，这通常是您希望避免的。
- en: 'An alternative communication pattern that can solve these issues is the publish/subscribe
    pattern. Here, services emit events that other services can listen on. The service
    emitting the event does not need to know which other services are actually listening
    to these events. Again, consider the second part of the preceding diagram—here,
    the user service publishes an event stating that a new user has just been created.
    Other services can now subscribe to this event and are notified whenever a new
    user has been created. These architectures usually require the use of a special
    infrastructure component: the message broker. This component accepts published
    messages and routes them to their subscribers (typically using a queue as intermediate
    storage).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以解决这些问题的另一种通信模式是发布/订阅模式。在这里，服务发出其他服务可以监听的事件。发出事件的服务不需要知道哪些其他服务实际上正在监听这些事件。再次考虑前图的第二部分—在这里，用户服务发布一个事件，说明刚刚创建了一个新用户。其他服务现在可以订阅此事件，并在创建新用户时得到通知。这些架构通常需要使用一个特殊的基础设施组件：消息代理。该组件接受发布的消息并将其路由到其订阅者（通常使用队列作为中间存储）。
- en: The publish/subscribe pattern is a very good method to decouple services from
    one another—when a service publishes events, it does not need to concern itself
    with where they will go, and when another service subscribes to events, it also
    does not know where they came from. Furthermore, asynchronous architectures tend
    to scale better than ones with synchronous communication. Horizontal scaling and
    load balancing are easily accomplished by distributing messages to multiple subscribers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅模式是一种非常好的方法，可以将服务解耦—当一个服务发布事件时，它不需要关心它们将去哪里，当另一个服务订阅事件时，它也不知道它们来自哪里。此外，异步架构往往比同步通信更容易扩展。通过将消息分发给多个订阅者，可以轻松实现水平扩展和负载平衡。
- en: Unfortunately, there is no such thing as a free lunch; this flexibility and
    scalability are paid for with additional complexity. Also, it becomes hard to
    debug single transactions across multiple services. Whether this trade-off is
    acceptable for you needs to be assessed on a case-by-case basis.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有免费的午餐；这种灵活性和可伸缩性是以额外的复杂性为代价的。此外，跨多个服务调试单个事务变得困难。是否接受这种权衡需要根据具体情况进行评估。
- en: In [Chapter 4](0a806398-0654-46f9-8e6f-02af9334821b.xhtml), *Asynchronous Microservice
    Architectures Using Message Queues*, you will learn more about asynchronous communication
    patterns and message brokers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](0a806398-0654-46f9-8e6f-02af9334821b.xhtml)中，*使用消息队列的异步微服务架构*，您将了解更多关于异步通信模式和消息代理的信息。
- en: The MyEvents platform
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MyEvents平台
- en: Throughout this book, we will build a useful SaaS application called *MyEvents*.
    MyEvents will utilize the technologies that you'll be learning in order to become
    a modern, scalable, cloud-native, and snappy application. MyEvents is an event
    management platform that allows users to book tickets for events all over the
    world. With MyEvents, you will be able to book tickets for yourself and your peers
    for concerts, carnivals, circuses, and more. MyEvents will keep a record of the
    bookings, the users, and the different locations where the events are taking place.
    It will manage your reservations efficiently.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将构建一个名为*MyEvents*的有用的SaaS应用程序。MyEvents将利用您将学习的技术，成为一个现代、可扩展、云原生和快速的应用程序。MyEvents是一个活动管理平台，允许用户预订世界各地的活动门票。使用MyEvents，您将能够为自己和同伴预订音乐会、嘉年华、马戏团等活动的门票。MyEvents将记录预订、用户和活动举办地的不同位置。它将有效地管理您的预订。
- en: 'We will make use of microservices, message queues, ReactJS, MongoDB, AWS, and
    more to construct MyEvents. In order to understand the application better, let''s
    take a look at the logical entities that our overall application will be managing.
    They will be managed by multiple microservices in order to establish a clear separation
    of concerns and to achieve the flexibility and scalability that we need:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用微服务、消息队列、ReactJS、MongoDB、AWS等技术构建MyEvents。为了更好地理解应用程序，让我们来看看我们的整体应用程序将要管理的逻辑实体。它们将由多个微服务管理，以建立明确的关注点分离，并实现我们需要的灵活性和可伸缩性：
- en: '![](img/86218de4-5f52-4787-b4ae-da6793c91daa.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86218de4-5f52-4787-b4ae-da6793c91daa.png)'
- en: We will have multiple users; each **User** can have multiple bookings for events,
    and each **Booking** will correspond to a single **Event**. For each one of our
    events, there will be a **Location** where the event is taking place. Inside the
    **Location**, we will need to identify the **Hall** or room where the event is
    taking place.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有多个用户；每个**用户**可以为事件预订多次，每个**预订**将对应一个**事件**。对于我们的每一个事件，都会有一个**位置**，事件发生的地方。在**位置**内，我们需要确定事件发生的**大厅**或房间。
- en: 'Now, let''s take a look at the microservice architecture and the different
    components that make our application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看微服务架构和构成我们应用程序的不同组件：
- en: '![](img/0b450d72-d8b9-4a62-9d7a-e8ee0ef54b28.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b450d72-d8b9-4a62-9d7a-e8ee0ef54b28.png)'
- en: Microservice architecture
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构
- en: 'We will use a ReactJS frontend to interface with the users of our applications.
    The ReactJS UI will use an API gateway (AWS  or local) to communicate with the
    different microservices that form the body of our application. There are two main
    microservices that represent the logic of MyEvents:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用ReactJS前端与我们应用程序的用户进行交互。ReactJS UI将使用API网关（AWS或本地）与构成我们应用程序主体的不同微服务进行通信。有两个主要的微服务代表了MyEvents的逻辑：
- en: '**Event Service**: This is the service that handles the events, their locations,
    and changes that happen to them'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件服务**：这是处理事件、它们的位置以及发生在它们身上的变化的服务'
- en: '**Booking Service**: This service handles bookings made by users'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订服务**：此服务处理用户的预订'
- en: All our services will be integrated using a publish/subscribe architecture based
    on message queues. Since we aim to provide you with practical knowledge in the
    world of microservices and cloud computing, we will support multiple types of
    message queues. We will support **Kafka**, **RabbitMQ**, and **SQS** from AWS.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的服务将使用基于消息队列的发布/订阅架构进行集成。由于我们的目标是为您提供微服务和云计算领域的实用知识，我们将支持多种类型的消息队列。我们将支持**Kafka**、**RabbitMQ**和AWS的**SQS**。
- en: The persistence layer will support multiple database technologies as well, in
    order to expose you to various practical database engines that empower your projects.
    We will support **MongoDB**, and **DynamoDB</span>**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 持久层还将支持多种数据库技术，以便让您接触到各种实用的数据库引擎，从而增强您的项目。我们将支持**MongoDB**和**DynamoDB**。
- en: All of our services will support metrics APIs, which will allow us to monitor
    the statistics of our services via **Prometheus**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的服务都将支持指标API，这将允许我们通过**Prometheus**监控我们服务的统计数据。
- en: The MyEvents platform is designed in a way that will build strong foundations
    of knowledge and exposure to the powerful world of microservices and cloud computing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: MyEvents平台的设计方式将为您构建微服务和云计算强大的知识基础和曝光。
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this introductory chapter, you learned about the basic design principles
    of cloud-native application development. This includes design goals, such as supporting
    (horizontal) scalability and resilience, and also architectural patterns, such
    as the twelve-factor app and microservice architectures.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个介绍性的章节中，您了解了云原生应用程序开发的基本设计原则。这包括设计目标，如支持（水平）可伸缩性和弹性，以及架构模式，如十二要素应用程序和微服务架构。
- en: Over the course of the following chapters, you will learn to apply many of these
    principles while building the MyEvents application. In [Chapter 2](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml),
    *Building Microservices Using Rest APIs*, you will learn how to implement a small
    microservice that offers a RESTful web service using the Go programming language.
    In the next chapters, you will continue to extend this small application and learn
    how to handle the deployment and operate on of this application in various cloud
    environments.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将学习在构建MyEvents应用程序时应用许多这些原则。在[第2章](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml)中，*使用Rest
    API构建微服务*，您将学习如何使用Go编程语言实现提供RESTful web服务的小型微服务。在接下来的章节中，您将继续扩展这个小应用程序，并学习如何在各种云环境中处理部署和操作这个应用程序。
