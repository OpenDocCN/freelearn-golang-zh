["```go\n$ go get github.com/gorilla/mux\n```", "```go\nimport \"github.com/gorilla/mux\"\n```", "```go\nr := mux.NewRouter()\n```", "```go\neventsrouter := r.PathPrefix(\"/events\").Subrouter()\n```", "```go\neventsrouter.Methods(\"GET\").Path(\"/{SearchCriteria}/{search}\").HandlerFunc(handler.findEventHandler)\n```", "```go\neventsrouter.Methods(\"GET\").Path(\"\").HandlerFunc(handler.allEventHandler)\n```", "```go\neventsrouter.Methods(\"POST\").Path(\"\").HandlerFunc(handler.newEventHandler)\n```", "```go\ntype eventServiceHandler struct {}\n\nfunc (eh *eventServiceHandler) findEventHandler(w http.ResponseWriter, r *http.Request) {\n\n}\n\nfunc (eh *eventServiceHandler) allEventHandler(w http.ResponseWriter, r *http.Request) {\n\n}\n\nfunc (eh *eventServiceHandler) newEventHandler(w http.ResponseWriter, r *http.Request) {\n\n}\n```", "```go\nhttp.ListenAndServe(\":8181\", r)\n```", "```go\nfunc ServeAPI(endpoint string) error {\n  handler := &eventservicehandler{}\n  r := mux.NewRouter()\n  eventsrouter := r.PathPrefix(\"/events\").Subrouter()\n  eventsrouter.Methods(\"GET\").Path(\"/{SearchCriteria}/{search}\").HandlerFunc(handler.FindEventHandler)\n  eventsrouter.Methods(\"GET\").Path(\"\").HandlerFunc(handler.AllEventHandler)\n  eventsrouter.Methods(\"POST\").Path(\"\").HandlerFunc(handler.NewEventHandler)\n  return http.ListenAndServe(endpoint, r)\n}\n```", "```go\ntype eventServiceHandler struct {}\n\nfunc (eh *eventServiceHandler) findEventHandler(w http.ResponseWriter, r *http.Request) {}\n\nfunc (eh *eventServiceHandler) allEventHandler(w http.ResponseWriter, r *http.Request) {}\n\nfunc (eh *eventServiceHandler) newEventHandler(w http.ResponseWriter, r *http.Request) {}\n```", "```go\ntype DatabaseHandler interface {\n    AddEvent(Event) ([]byte, error)\n    FindEvent([]byte) (Event, error)\n    FindEventByName(string) (Event, error)\n    FindAllAvailableEvents() ([]Event, error)\n}\n```", "```go\ntype Event struct {\n    ID bson.ObjectId `bson:\"_id\"`\n    Name string\n    Duration int\n    StartDate int64\n    EndDate int64\n    Location Location\n}\ntype Location struct {\n    Name string\n    Address string\n    Country string\n    OpenTime int\n    CloseTime int\n    Halls []Hall\n}\ntype Hall struct {\n    Name string `json:\"name\"`\n    Location string `json:\"location,omitempty\"`\n    Capacity int `json:\"capacity\"`\n}\n```", "```go\ngo get gopkg.in/mgo.v2\n```", "```go\npackage mongolayer\nimport (\n    mgo \"gopkg.in/mgo.v2\"\n    \"gopkg.in/mgo.v2/bson\"\n)\n```", "```go\nconst (\n    DB = \"myevents\"\n    USERS = \"users\"\n    EVENTS = \"events\"\n)\n```", "```go\ntype MongoDBLayer struct {\n    session *mgo.Session\n}\n```", "```go\nfunc NewMongoDBLayer(connection string) (*MongoDBLayer, error) {\n    s, err := mgo.Dial(connection)\n    if err!= nil{\n        return nil,err\n    }\n    return &MongoDBLayer{\n        session: s,\n    }, err\n}\n```", "```go\nfunc (mgoLayer *MongoDBLayer) AddEvent(e persistence.Event) ([]byte, error) {\n    s := mgoLayer.getFreshSession()\n    defer s.Close()\n    if !e.ID.Valid() {\n        e.ID = bson.NewObjectId()\n    }\n    //let's assume the method below checks if the ID is valid for the location object of the event\n    if !e.Location.ID.Valid() {\n        e.Location.ID = bson.NewObjectId()\n    }\n    return []byte(e.ID), s.DB(DB).C(EVENTS).Insert(e)\n}\n```", "```go\nfunc (mgoLayer *MongoDBLayer) getFreshSession() *mgo.Session {\n    return mgoLayer.session.Copy()\n}\n```", "```go\nfunc (mgoLayer *MongoDBLayer) FindEvent(id []byte) (persistence.Event, error) {\n    s := mgoLayer.getFreshSession()\n    defer s.Close()\n    e := persistence.Event{}\n    err := s.DB(DB).C(EVENTS).FindId(bson.ObjectId(id)).One(&e)\n    return e, err\n}\n```", "```go\nfunc (mgoLayer *MongoDBLayer) FindEventByName(name string) (persistence.Event, error) {\n    s := mgoLayer.getFreshSession()\n    defer s.Close()\n    e := persistence.Event{}\n    err := s.DB(DB).C(EVENTS).Find(bson.M{\"name\": name}).One(&e)\n    return e, err\n}\n```", "```go\nerr := s.DB(DB).C(EVENTS).Find(bson.M{\"name\":name}).One(&e)\n```", "```go\nfunc (mgoLayer *MongoDBLayer) FindAllAvailableEvents() ([]persistence.Event, error) {\n    s := mgoLayer.getFreshSession()\n    defer s.Close()\n    events := []persistence.Event{}\n    err := s.DB(DB).C(EVENTS).Find(nil).All(&events)\n    return events, err\n}\n```", "```go\nerr := s.DB(DB).C(EVENTS).Find(nil).All(&events)\n```", "```go\ntype eventServiceHandler struct {}\nfunc (eh *eventServiceHandler) findEventHandler(w http.ResponseWriter, r *http.Request) {}\nfunc (eh *eventServiceHandler) allEventHandler(w http.ResponseWriter, r *http.Request) {}\nfunc (eh *eventServiceHandler) newEventHandler(w http.ResponseWriter, r *http.Request) {}\n```", "```go\ntype eventServiceHandler struct {\n    dbhandler persistence.DatabaseHandler\n}\n```", "```go\nfunc newEventHandler(databasehandler persistence.DatabaseHandler) *eventServiceHandler {\n    return &eventServiceHandler{\n        dbhandler: databasehandler,\n    }\n}\n```", "```go\neventsrouter := r.PathPrefix(\"/events\").Subrouter()\neventsrouter.Methods(\"GET\").Path(\"/{SearchCriteria}/{search}\").HandlerFunc(handler.findEventHandler)\n```", "```go\nfunc (eh *eventServiceHandler) findEventHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    criteria, ok := vars[\"SearchCriteria\"]\n    if !ok {\n        w.WriteHeader(400)\n        fmt.Fprint(w, `{error: No search criteria found, you can either search by id via /id/4\n                   to search by name via /name/coldplayconcert}`)\n        return\n    }\n    searchkey, ok := vars[\"search\"]\n    if !ok {\n        w.WriteHeader(400)\n        fmt.Fprint(w, `{error: No search keys found, you can either search by id via /id/4\n                   to search by name via /name/coldplayconcert}`)\n        return\n    }\n    var event persistence.Event\n    var err error\n    switch strings.ToLower(criteria) {\n        case \"name\":\n        event, err = eh.dbhandler.FindEventByName(searchkey)\n        case \"id\":\n        id, err := hex.DecodeString(searchkey)\n        if err == nil {\n            event, err = eh.dbhandler.FindEvent(id)\n        }\n    }\n    if err != nil {\n        fmt.Fprintf(w, \"{error %s}\", err)\n        return\n    }\n    w.Header().Set(\"Content-Type\", \"application/json;charset=utf8\")\n    json.NewEncoder(w).Encode(&event)\n}\n```", "```go\ncriteria, ok := vars[\"SearchCriteria\"]\n```", "```go\nif !ok {\n    fmt.Fprint(w, `{error: No search criteria found, you can either search by id via /id/4 to search by name via /name/coldplayconcert}`)\n    return\n}\n```", "```go\nsearchkey, ok := vars[\"search\"]\nif !ok {\n    fmt.Fprint(w, `{error: No search keys found, you can either search by id via /id/4\n               to search by name via /name/coldplayconcert}`)\n    return\n}\n```", "```go\nvar event persistence.Event\nvar err error\nswitch strings.ToLower(criteria) {\n    case \"name\":\n    event, err = eh.dbhandler.FindEventByName(searchkey)\n    case \"id\":\n    id, err := hex.DecodeString(searchkey)\n\n    if nil == err {\n        event, err = eh.dbhandler.FindEvent(id)\n    }\n}\n```", "```go\nif err != nil {\n    w.WriteHeader(404)\n    fmt.Fprintf(w, \"Error occured %s\", err)\n    return\n}\n```", "```go\nw.Header().Set(\"Content-Type\", \"application/json;charset=utf8\")\njson.NewEncoder(w).Encode(&event)\n```", "```go\nfunc (eh *eventServiceHandler) allEventHandler(w http.ResponseWriter, r *http.Request) {\n    events, err := eh.dbhandler.FindAllAvailableEvents()\n    if err != nil {\n        w.WriteHeader(500)\n        fmt.Fprintf(w, \"{error: Error occured while trying to find all available events %s}\", err)\n        return\n    }\n    w.Header().Set(\"Content-Type\", \"application/json;charset=utf8\")\n    err = json.NewEncoder(w).Encode(&events)\n    if err != nil {\n        w.WriteHeader(500)\n        fmt.Fprintf(w, \"{error: Error occured while trying encode events to JSON %s}\", err)\n    }\n}\n```", "```go\nfunc (eh *eventServiceHandler) newEventHandler(w http.ResponseWriter, r *http.Request) {\n    event := persistence.Event{}\n    err := json.NewDecoder(r.Body).Decode(&event)\n    if err != nil {\n        w.WriteHeader(500)\n        fmt.Fprintf(w, \"{error: error occured while decoding event data %s}\", err)\n        return\n    }\n    id, err := eh.dbhandler.AddEvent(event)\n    if nil != err {\n        w.WriteHeader(500)\n        fmt.Fprintf(w, \"{error: error occured while persisting event %d %s}\",id, err)\n        return\n    }\n```", "```go\nerr := json.NewDecoder(r.Body).Decode(&event)\n```", "```go\nfunc ServeAPI(endpoint string, dbHandler persistence.DatabaseHandler) error {\n    handler := newEventHandler(dbHandler)\n    r := mux.NewRouter()\n    eventsrouter := r.PathPrefix(\"/events\").Subrouter()\neventsrouter.Methods(\"GET\").Path(\"/{SearchCriteria}/{search}\").HandlerFunc(handler.findEventHandler)\n    eventsrouter.Methods(\"GET\").Path(\"\").HandlerFunc(handler.allEventHandler)\n    eventsrouter.Methods(\"POST\").Path(\"\").HandlerFunc(handler.newEventHandler)\n\n    return http.ListenAndServe(endpoint, r)\n}\n```", "```go\npackage configuration\nvar (\n    DBTypeDefault = dblayer.DBTYPE(\"mongodb\")\n    DBConnectionDefault = \"mongodb://127.0.0.1\"\n    RestfulEPDefault = \"localhost:8181\"\n)\ntype ServiceConfig struct {\n    Databasetype dblayer.DBTYPE `json:\"databasetype\"`\n    DBConnection string `json:\"dbconnection\"`\n    RestfulEndpoint string `json:\"restfulapi_endpoint\"`\n}\nfunc ExtractConfiguration(filename string) (ServiceConfig, error) {\n    conf := ServiceConfig{\n        DBTypeDefault,\n        DBConnectionDefault,\n        RestfulEPDefault,\n    }\n    file, err := os.Open(filename)\n    if err != nil {\n        fmt.Println(\"Configuration file not found. Continuing with default values.\")\n        return conf, err\n    }\n    err = json.NewDecoder(file).Decode(&conf)\n    return conf,err\n}\n```", "```go\npackage dblayer\n\nimport (\n  \"gocloudprogramming/chapter2/myevents/src/lib/persistence\"\n  \"gocloudprogramming/chapter2/myevents/src/lib/persistence/mongolayer\"\n)\n\ntype DBTYPE string\n\nconst (\n  MONGODB DBTYPE = \"mongodb\"\n  DYNAMODB DBTYPE = \"dynamodb\"\n)\n\nfunc NewPersistenceLayer(options DBTYPE, connection string) (persistence.DatabaseHandler, error) {\n\n  switch options {\n  case MONGODB:\n    return mongolayer.NewMongoDBLayer(connection)\n  }\n  return nil, nil\n}\n```", "```go\npackage main\nfunc main(){\n    confPath := flag.String(\"conf\", `.\\configuration\\config.json`, \"flag to set\n                            the path to the configuration json file\")\n    flag.Parse()\n\n    //extract configuration\n    config, _ := configuration.ExtractConfiguration(*confPath)\n    fmt.Println(\"Connecting to database\")\n    dbhandler, _ := dblayer.NewPersistenceLayer(config.Databasetype, config.DBConnection)\n\n    //RESTful API start\n    log.Fatal(rest.ServeAPI(config.RestfulEndpoint, dbhandler, eventEmitter))\n}\n```"]