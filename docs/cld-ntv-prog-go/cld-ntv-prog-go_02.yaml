- en: Building Microservices Using Rest APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rest API构建微服务
- en: In this chapter, we'll go on a journey to learn about the world of microservices.
    We'll learn about how they are structured, how they communicate, and how they
    persist data. The concept of microservices is a key concept to cover due to the
    fact that most of the modern cloud applications in production today rely on microservices
    to achieve resiliency and scalability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将踏上学习微服务世界的旅程。我们将了解它们的结构、它们的通信方式以及它们如何持久化数据。由于今天大多数现代云应用程序在生产中都依赖微服务来实现弹性和可伸缩性，微服务的概念是一个需要涵盖的关键概念。
- en: 'In this chapter, we will cover the following topics :'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Deep diving into the microservices architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解微服务架构
- en: RESTful web APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful web API
- en: Building RESTful APIs in the Go language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go语言中构建RESTful API
- en: The background
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景
- en: We provided a practical definition for microservices in the first chapter. In
    this chapter, let's define microservices a bit more.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一章中提供了微服务的实际定义。在本章中，让我们更详细地定义微服务。
- en: To fully appreciate microservices, let's start by telling the story of their
    rise. Before the idea of microservices became popular, most applications used
    to be monolithic. A monolithic application is a single application that tries
    to get numerous tasks accomplished at once. Then, as new features are needed,
    the application will get bigger and bulkier. This, in effect, produced unmaintainable
    applications in the long run. With the emergence of cloud computing, and distributed
    applications with massive loads, the need for a more flexible application architecture
    became obvious.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分理解微服务，让我们从它们崛起的故事开始。在微服务的概念变得流行之前，大多数应用程序都是单体的。单体应用程序是一个试图一次完成许多任务的单一应用程序。然后，随着需要新功能，应用程序会变得越来越庞大。这实际上会导致长期来看应用程序难以维护。随着云计算和大规模负载的分布式应用程序的出现，更灵活的应用程序架构的需求变得明显。
- en: 'In [Chapter 1](34c20397-6b29-4142-a491-73f710111135.xhtml), *Modern Microservice
    Architectures*, we provided an introduction to the MyEvents application, which
    we will be expecting to build in this book. The MyEvents application is used to
    manage event bookings for concerts, plays, and so on. The main tasks for the application
    include the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](34c20397-6b29-4142-a491-73f710111135.xhtml)中，《现代微服务架构》，我们介绍了MyEvents应用程序，这是我们在本书中将要构建的应用程序。MyEvents应用程序用于管理音乐会、戏剧等活动的预订。该应用程序的主要任务包括以下内容：
- en: '**Process bookings**: For example, a user makes a booking for a concert next
    month. We will need to store this reservation, ensure that there are seats available
    for this event, and confirm no prior reservations were made with the same name,
    among other things.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理预订**：例如，用户预订了下个月的音乐会。我们需要存储这个预订，确保这个活动有座位可用，并确认之前没有用相同的姓名进行过预订，等等。'
- en: '**Handle events**: Our application needs to be aware of all the concerts, plays,
    and other types of events that we''re expecting to support. We need to know the
    event addresses, the total number of seats, their duration, and so on.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理活动**：我们的应用程序需要了解我们预计要支持的所有音乐会、戏剧和其他类型的活动。我们需要知道活动地址、座位总数、活动持续时间等。'
- en: '**Handle search**: Our application needs to be capable of performing efficient
    searches to retrieve our bookings and events.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理搜索**：我们的应用程序需要能够执行高效的搜索来检索我们的预订和活动。'
- en: 'The following image shows how a monolithic application design for MyEvents
    would look like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了MyEvents的单体应用程序设计的样子：
- en: '![](img/9e7ba468-f203-4763-9927-f25afa449093.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e7ba468-f203-4763-9927-f25afa449093.png)'
- en: Monolithic application
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序
- en: We'll build multiple software layers within the application to handle each distinct
    task needed. Our application will become a program with a large code base. Since
    the code is all connected, there will always be a risk of change in one layer
    affecting code on the other layers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用程序中构建多个软件层来处理每个需要的不同任务。我们的应用程序将成为一个具有庞大代码库的程序。由于代码都是相互连接的，一个层的变化总会影响其他层的代码。
- en: Since it's a single program, it won't be easy to write some of the software
    layers in different programming languages. This is typically a very good option
    to have when you know there is a really good library in language X to support
    feature Y, however, language X is not good for feature Z.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个单一程序，要在不同的编程语言中编写一些软件层不会很容易。当你知道语言X中有一个非常好的库来支持特性Y时，这通常是一个非常好的选择，但是语言X对于特性Z并不好。
- en: Also, as you add new features or layers, your single program will keep growing
    with no good scalability options. Wouldn't it be better to be able to run different
    software layers on different servers so that you can control your application
    load without throwing more hardware on one or two servers?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着添加新功能或层，您的单一程序将不断增长，而没有良好的可伸缩性选项。能否在不同的服务器上运行不同的软件层，以便您可以控制应用程序的负载，而不是在一两台服务器上增加更多的硬件呢？
- en: Software engineers have tried to solve the monolithic application's dilemma
    for a long time. Microservices is one approach to address the issues that come
    with monolithic applications. Before the term microservices became popular, there
    was the concept of SOA, which was similar in principle to microservices.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师们长期以来一直试图解决单体应用程序的困境。微服务是解决单体应用程序带来的问题的一种方法。在微服务这个术语变得流行之前，有SOA的概念，原则上类似于微服务。
- en: Before we dive more into microservices, it is worth mentioning that monolithic
    applications are not always bad. It all depends on what you are trying to achieve.
    If you are trying to build an application that is expected to have a limited set
    of tasks, and not expected to grow by much, then a single well-built application
    might be all you need. If on the other hand, you are looking to build a complex
    application that is expected to perform numerous independent tasks, being maintained
    by multiple people, while handling massive data loads, then the microservices
    architecture is your friend.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更深入地了解微服务之前，值得一提的是，单片应用程序并不总是坏的。这一切取决于您想要实现什么。如果您试图构建一个预期具有有限任务集的应用程序，并且不预期增长很多，那么一个单一构建良好的应用程序可能就是您所需要的。另一方面，如果您试图构建一个复杂的应用程序，预期执行许多独立任务，由多人维护，同时处理大量数据负载，那么微服务架构就是您的朋友。
- en: So, what are microservices?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，什么是微服务？
- en: Simply put, microservices is the idea that instead of putting all of your code
    in one basket (monolithic application), you write multiple small software services
    or *microservices*. Each service is expected to focus on one task and perform
    it well. The accumulation of those services will make up your application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，微服务是这样的理念，即不是将所有代码放在一个篮子里（单片应用程序），而是编写多个小型软件服务或*微服务*。每个服务都预期专注于一个任务并且执行得很好。这些服务的累积将构成您的应用程序。
- en: '![](img/c86ee87c-6276-4227-b8e1-ae23d271b8be.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c86ee87c-6276-4227-b8e1-ae23d271b8be.png)'
- en: Microservices application
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应用程序
- en: For the MyEvents application, each software layer from the monolithic application
    will translate into a software service. This will then communicate together to
    form our application. Each one of those software services will be, in effect,
    a microservice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MyEvents应用程序，单片应用程序中的每个软件层将转化为一个软件服务。然后，它们将一起通信以构成我们的应用程序。这些软件服务中的每一个实际上都是一个微服务。
- en: Since those services collaborate to build a complex application, they need to
    be able to communicate via protocols that they all understand. Microservices that
    use web Restful APIs for communication make use of the HTTP protocol extensively.
    We'll cover Restful APIs in more detail in this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些服务合作构建复杂的应用程序，它们需要能够通过它们都理解的协议进行通信。使用Web Restful API进行通信的微服务广泛使用HTTP协议。我们将在本章更详细地介绍Restful
    API。
- en: Microservices internals
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务内部
- en: 'To build proper microservices, there are several components we would need to
    consider. To understand the five components, let''s discuss the main tasks a microservice
    is expected to undertake:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建适当的微服务，我们需要考虑几个组件。为了理解这五个组件，让我们讨论一下微服务预期承担的主要任务：
- en: The microservice will need to be able to send and receive messages with other
    services and the outside world so that tasks can be carried out in harmony. The
    communication aspect of a microservice takes different forms. Restful APIs are
    very popular when interacting with the outside world, and message queues are very
    helpful when communicating with other services. There are other popular techniques
    that are also popular such as **gRPC**.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务将需要能够与其他服务和外部世界发送和接收消息，以便任务可以和谐地进行。微服务的通信方面采取不同的形式。与外部世界互动时，Restful API非常受欢迎，与其他服务通信时，消息队列非常有帮助。还有其他一些流行的技术也很受欢迎，比如**gRPC**。
- en: The microservice will need a configuration layer; this could be via environmental
    variables, a file or database. This configuration layer will tell the microservice
    how to operate. For example, let's assume that our service needs to listen on
    a TCP address and a port number to be able to receive messages; the TCP address
    and the port number will be part of the configuration that gets fed to our service
    when it starts up.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务将需要一个配置层；这可以通过环境变量、文件或数据库来实现。这个配置层将告诉微服务如何操作。例如，假设我们的服务需要监听TCP地址和端口号以便接收消息；TCP地址和端口号将是在服务启动时传递给我们的服务的配置的一部分。
- en: The microservice will need to log events that happen to it so that we can troubleshoot
    issues and understand behaviors. For example, if a communication issue occurs
    while sending a message to another service, we'll need the error to be logged
    somewhere in order for us to be able to identify the problem.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务将需要记录发生在其上的事件，以便我们能够排除故障并了解行为。例如，如果在向另一个服务发送消息时发生通信问题，我们需要将错误记录在某个地方，以便我们能够识别问题。
- en: The microservice will need to be able to persist data by storing it in a database
    or other forms of data stores; we'll also need to be able to retrieve data at
    a later time. For example, in case of the MyEvents application, our microservices
    will need to store and retrieve data related to the users, the bookings, and the
    events.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务将需要能够通过将数据存储在数据库或其他形式的数据存储中来持久化数据；我们还需要能够在以后检索数据。例如，在MyEvents应用程序的情况下，我们的微服务将需要存储和检索与用户、预订和事件相关的数据。
- en: Finally, there is the core, the most important piece of our microservice. The
    core is the code responsible for the task that our microservice is expected to
    do. For example, if our microservice is responsible for handling user bookings,
    then the microservice core is where we write the code that would perform the task
    of handling the user's bookings.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，有核心部分，是我们微服务中最重要的部分。核心部分是负责我们微服务预期任务的代码。例如，如果我们的微服务负责处理用户预订，那么微服务的核心部分就是我们编写处理用户预订任务的代码的地方。
- en: 'So, based on the previous five points, the building blocks of a microservice
    should look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据前面的五点，微服务的构建模块应该是这样的：
- en: '![](img/d6337162-f1f4-432d-b2f9-b8cfedbc3356.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6337162-f1f4-432d-b2f9-b8cfedbc3356.png)'
- en: Building blocks of a microservice
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的构建模块
- en: Those building blocks provide a good foundation to build efficient microservices.
    The rules are not set in stone. You can make your microservice either simpler
    or more complex, depending on the application you are trying to build.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构建块为构建高效的微服务提供了良好的基础。规则并非一成不变。您可以根据您尝试构建的应用程序使您的微服务变得更简单或更复杂。
- en: RESTful Web APIs
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful Web API
- en: '**REST** stands for **Representational State Transfer**. REST is simply a way
    for different services to communicate and exchange data. The core of the REST
    architecture consists of a client and a server. The server listens for incoming
    messages, then replies to it, whereas the client starts the connection, then sends
    messages to the server.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**代表**表述性状态转移**。REST只是不同服务进行通信和交换数据的一种方式。REST架构的核心包括客户端和服务器。服务器监听传入的消息，然后回复它，而客户端启动连接，然后向服务器发送消息。'
- en: In the modern web programming world, RESTful web applications use the HTTP protocol
    for communication. The RESTful client would be an HTTP client, and the RESTful
    server would be the HTTP server. The HTTP protocol is the key application layer
    communication protocol that powers the internet, which is why RESTful applications
    can also be called web applications. The communication layer of the RESTful applications
    is often simply referred as RESTful APIs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代网络编程世界中，RESTful网络应用程序使用HTTP协议进行通信。RESTful客户端将是一个HTTP客户端，而RESTful服务器将是HTTP服务器。HTTP协议是支持互联网的关键应用层通信协议，这就是为什么RESTful应用程序也可以称为网络应用程序。RESTful应用程序的通信层通常简称为RESTful
    API。
- en: REST APIs allow applications developed in various types of platforms to communicate.
    This includes other microservices in your application that run on other operating
    systems, as well as client applications running on other devices. For example,
    a smartphone can communicate with your web services reliably via REST.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: REST API允许在各种平台上开发的应用程序进行通信。这包括在其他操作系统上运行的应用程序中的其他微服务，以及在其他设备上运行的客户端应用程序。例如，智能手机可以通过REST可靠地与您的Web服务通信。
- en: '![](img/273f5c32-2834-40fe-8258-1084b7ffbd41.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/273f5c32-2834-40fe-8258-1084b7ffbd41.png)'
- en: Web RESTful API
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Web RESTful API
- en: To understand how RESTful applications work, we will first need to gain a decent
    understanding of how the HTTP protocol works. HTTP is an application-level protocol
    used for data communications all over the web, the clouds, and the world of modern
    microservices.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解RESTful应用程序的工作原理，我们首先需要对HTTP协议的工作原理有一个相当好的理解。HTTP是一种应用级协议，用于在整个网络、云和现代微服务世界中进行数据通信。
- en: 'HTTP is a client-server, request-response protocol. This means that the data
    flow works as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一种客户端-服务器，请求-响应协议。这意味着数据流程如下：
- en: An HTTP client sends a request to an HTTP server
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP客户端向HTTP服务器发送请求
- en: The HTTP server listens to incoming requests, then responds to them as they
    come
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP服务器监听传入的请求，然后在其到达时做出响应
- en: '![](img/0e6d3274-ef4e-4aac-9b64-2ed72455b6a2.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e6d3274-ef4e-4aac-9b64-2ed72455b6a2.png)'
- en: Requests and response
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和响应
- en: 'An HTTP client request is typically one of two things:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP客户端请求通常是以下两种情况之一：
- en: The client is requesting a resource from the server
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端正在从服务器请求资源
- en: The client is requesting to add/edit a resource on the server
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端正在请求在服务器上添加/编辑资源
- en: The nature of the resource depends on your application. For example, if your
    client is a web browser trying to access a web page, then your client will send
    a request to the server asking for an HTML web page. The HTML page would be the
    resource returned within the response of the HTTP web server to the client.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的性质取决于您的应用程序。例如，如果您的客户端是尝试访问网页的Web浏览器，那么您的客户端将向服务器发送请求，请求HTML网页。HTML页面将作为资源在HTTP
    Web服务器的响应中返回给客户端。
- en: In the world of communicating microservices, REST applications usually use the
    HTTP protocol in combination with the JSON data format in order to exchange data
    messages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在通信微服务的世界中，REST应用程序通常使用HTTP协议结合JSON数据格式来交换数据消息。
- en: 'Consider the following scenario: In our MyEvents application, one of our microservices
    needs to obtain the information of an event (duration, start date, end date, and
    location) from another microservice. The microservice in need of the information
    will be our client, whereas the microservice providing the information will be
    our server. Let''s assume that our client microservice has the event ID, but needs
    the server microservice to provide the information of the event that belongs to
    that ID.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情景：在我们的MyEvents应用程序中，我们的一个微服务需要从另一个微服务获取事件信息（持续时间、开始日期、结束日期和位置）。需要信息的微服务将是我们的客户端，而提供信息的微服务将是我们的服务器。假设我们的客户端微服务具有事件ID，但需要服务器微服务提供属于该ID的事件的信息。
- en: 'The client will send a request inquiring about the event information via the
    event ID; the server will respond with the information enclosed in the JSON format,
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将通过事件ID发送请求，询问有关事件信息；服务器将以JSON格式回复信息，如下所示：
- en: '![](img/7ca15c58-6040-4454-a917-d086045e320b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ca15c58-6040-4454-a917-d086045e320b.png)'
- en: JSON document with response
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 带有响应的JSON文档
- en: This description sounds simple; however, it doesn't deliver the full picture.
    The inquiring part of the client needs more elaboration in order for us to understand
    how REST APIs really work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个描述听起来很简单；然而，它并没有提供完整的图片。客户端的询问部分需要更多的阐述，以便我们了解REST API的真正工作原理。
- en: There are two primary pieces of information that a REST API client request needs
    to specify in order to declare its intent—the *request URL* and the *request method*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: REST API客户端请求需要指定两个主要信息以声明其意图——*请求URL*和*请求方法*。
- en: The request URL is the address of the resource at the server that the client
    seeks. An URL is a web address, an example of a REST API URL would be [http://quotes.rest/qod.json](http://quotes.rest/qod.json),
    which is an API service that returns a quote for the day.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请求URL是客户端寻找的服务器上资源的地址。URL是一个Web地址，REST API URL的一个示例是[http://quotes.rest/qod.json](http://quotes.rest/qod.json)，这是一个返回当天引用的API服务。
- en: In our scenario, the MyEvents client microservice can send an HTTP request to
    the [http://10.12.13.14:5500/events/id/1345](http://10.12.13.14:5500/events/id/1345) URL
    to inquire about event ID `1345`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，MyEvents客户端微服务可以向[http://10.12.13.14:5500/events/id/1345](http://10.12.13.14:5500/events/id/1345)
    URL发送HTTP请求来查询事件ID`1345`。
- en: 'The request method is basically the type of operation that we would like to
    execute. That could range from a request to obtain a resource to a request to
    edit a resource, add a resource, or even delete a resource. In the HTTP protocol,
    there are multiple types of methods that need to be part of the client request;
    the following are some of the most common methods:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请求方法基本上是我们想要执行的操作类型。这可以是从请求获取资源到编辑资源、添加资源，甚至删除资源的请求。在HTTP协议中，有多种类型的方法需要成为客户端请求的一部分；以下是一些最常见的方法：
- en: '`GET`: A very common HTTP method in web applications; this is how we request
    a resource from our HTTP web servers; this is the request type we would use in
    our scenario to request the data of event ID `1345`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：在Web应用程序中非常常见的HTTP方法；这是我们从HTTP Web服务器请求资源的方式；这是我们在场景中使用的请求类型，用于请求事件ID`1345`的数据。'
- en: '`POST`: The HTTP method we would use to update or create a resource.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：我们用来更新或创建资源的HTTP方法。'
- en: Let's assume that we would like to update a piece of information that belongs
    to event ID 1345 using `POST`, then we'd send a `POST` request to relative URL
    `../events/id/1345` with new event information in the request body.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用`POST`更新属于事件ID 1345的某些信息，那么我们将发送一个`POST`请求到相对URL`../events/id/1345`，并在请求体中附上新的事件信息。
- en: If on the other hand, we would like to create a new event that has an ID of
    1346, we shouldn't send a `POST` request to `../events/id/1346` with the new event
    information because the ID doesn't yet exist. What we should do is just send a
    `POST` request to `.../events` and attach all the new event information in the
    request body.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想创建一个ID为1346的新事件，我们不应该发送`POST`请求到`../events/id/1346`，因为该ID尚不存在。我们应该只是发送一个`POST`请求到`.../events`，并在请求体中附上所有新的事件信息。
- en: '`PUT`: The HTTP method to create or overwrite a resource.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：用于创建或覆盖资源的HTTP方法。'
- en: Unlike `POST`, the `PUT` request can be used to create a new resource by sending
    a request to a resource ID that didn't exist from before. So, for example, if
    we want to create a new event with an ID `1346`, we can send a `PUT` request to
    `../events/id/1346`, and the web server should create the resource for us.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与`POST`不同，`PUT`请求可以通过向之前不存在的资源ID发送请求来创建新资源。因此，例如，如果我们想创建一个ID为`1346`的新事件，我们可以发送一个`PUT`请求到`../events/id/1346`，Web服务器应该为我们创建资源。
- en: '`PUT` can also be used to fully overwrite an existing resource. So, unlike
    `POST`, we shouldn''t use `PUT` to just update a single piece of information of
    a resource.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`也可以用于完全覆盖现有资源。因此，与`POST`不同，我们不应该使用`PUT`来仅更新资源的单个信息。'
- en: '`DELETE`: It is used to delete a resource. For example, if we send a delete
    request to the relative URL `../events/id/1345` of the web server, the web server
    will then delete the resource from the database.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：用于删除资源。例如，如果我们向Web服务器的相对URL`../events/id/1345`发送删除请求，Web服务器将从数据库中删除资源。'
- en: Gorilla web toolkit
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gorilla web toolkit
- en: Now that we have covered how web Restful APIs work, it's time to understand
    how to best implement them in Go. The Go language comes with a very powerful web
    package in the standard library; Go also enjoys the support of numerous third-party
    packages. In this book, we will use a very popular Go web third-party toolkit
    called Gorilla web toolkit. The Gorilla web toolkit consists of a collection of
    Go packages that together helps build powerful web applications quickly and efficiently.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Web Restful API的工作原理，是时候了解如何在Go中最佳实现它们了。Go语言自带了一个非常强大的标准库web包；Go还享受着众多第三方包的支持。在本书中，我们将使用一个非常流行的Go
    web第三方工具包，名为Gorilla web toolkit。Gorilla web toolkit由一系列Go包组成，一起帮助快速高效地构建强大的Web应用程序。
- en: The key package in the Gorilla web toolkit ecosystem is called `gorilla/mux`.
    The `mux` package is described in the package documentation as *a request router
    and dispatcher*. This is basically a software component that accepts an incoming
    HTTP request, then decides what to do based on the nature of the request. For
    example, let's assume that a client sends an HTTP request to our web server. The
    HTTP router dispatcher component in our web server can then detect that the incoming
    request includes a `GET` method with a relative URL of `../events/id/1345`. It
    will then retrieve the information of the event ID `1345` and send it back to
    the client.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla web toolkit生态系统中的关键包称为`gorilla/mux`。`mux`包在包文档中被描述为*请求路由器和调度器*。这基本上是一个软件组件，它接受传入的HTTP请求，然后根据请求的性质决定要做什么。例如，假设客户端向我们的Web服务器发送了一个HTTP请求。我们的Web服务器中的HTTP路由调度器组件可以检测到传入请求包含一个相对URL为`../events/id/1345`的`GET`方法。然后它将检索事件ID`1345`的信息并将其发送回客户端。
- en: Implementing a Restful API
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施Restful API
- en: 'The first step to utilize the package is to make use of the `go get` command
    in order to obtain the package to our development environment:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 利用该包的第一步是使用`go get`命令将包获取到我们的开发环境中：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With that, the `mux` package will be ready to use. In our code, we can now
    `import` the `mux` package to our web server code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，`mux`包将准备就绪。在我们的代码中，我们现在可以将`mux`包导入到我们的web服务器代码中：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside our code, we now need to create a router using the Gorilla `mux` package.
    This is accomplished via the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，现在需要使用Gorilla `mux`包创建一个路由器。这可以通过以下代码实现：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this, we will get a router object called `r`, to help us define our routes
    and link them with actions to execute.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们将得到一个名为`r`的路由器对象，帮助我们定义我们的路由并将它们与要执行的操作链接起来。
- en: From this point forward, the code will differ based on the microservice in question
    since different services will support different routes and actions. Earlier in
    this chapter, we covered the following four different types of services to use
    in our MyEvents application—Web UI service, search microservice, bookings microservice,
    and events microservice. Let's focus on the events microservice.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，代码将根据所涉及的微服务而有所不同，因为不同的服务将支持不同的路由和操作。在本章的前面，我们介绍了在MyEvents应用程序中使用的四种不同类型的服务——Web
    UI服务、搜索微服务、预订微服务和事件微服务。让我们专注于事件微服务。
- en: 'The events microservice will need to support a RESTFul API interface that is
    capable of doing the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事件微服务将需要支持一个RESTFul API接口，能够执行以下操作：
- en: Searching for events via an ID or event name
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过ID或事件名称搜索事件
- en: Retrieving all events at once
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次性检索所有事件
- en: Creating a new event
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新事件
- en: Let's focus on each one of those tasks. Since we are in the process of designing
    a web RESTful API for the microservice, each task will need to translate into
    an HTTP method combined with a URL and an HTTP body if need be.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于这些任务中的每一个。由于我们正在设计一个微服务的Web RESTful API，因此每个任务都需要转换为一个HTTP方法，结合一个URL和一个HTTP正文（如果需要）。
- en: 'The following is the break down:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是详细说明：
- en: 'Searching for events via:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过搜索事件：
- en: 'ID: Relative URL is `/events/id/3434`, method is `GET`, and no data is expected
    in the HTTP body'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID：相对URL是“/events/id/3434”，方法是“GET”，在HTTP正文中不需要数据
- en: 'Name: Relative URL is `/events/name/jazz_concert`, method is `GET`, and no
    data is expected in the HTTP body'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：相对URL是“/events/name/jazz_concert”，方法是“GET”，在HTTP正文中不需要数据
- en: 'Retrieving all events at once: Relative URL is `/events`, method is `GET`,
    and no data is expected in the HTTP body'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次性检索所有事件：相对URL是“/events”，方法是“GET”，在HTTP正文中不需要数据
- en: 'Creating a new event: Relative URL is `/events`, the method is `POST`, and
    expected data in the HTTP body needs to be the JSON representation of the new
    event we would like to add. Let''s say we would like to add the event of `opera
    aida` that would play in the U.S., then the HTTP body would look like this:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新事件：相对URL是“/events”，方法是“POST”，并且HTTP正文中需要的数据是我们想要添加的新事件的JSON表示。假设我们想要添加在美国演出的“歌剧艾达”事件，那么HTTP正文将如下所示：
- en: '![](img/c90b3caa-a35a-4beb-bfec-24831041eb2a.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90b3caa-a35a-4beb-bfec-24831041eb2a.png)'
- en: Now, if you look at the HTTP translations of each task, you will notice that
    their relative URLs all share a common property, which is the fact that it starts
    with `/events`. In the Gorilla web toolkit, we can create a subrouter for the
    `/events`—relative URL. A subrouter is basically an object that will be in charge
    of any incoming HTTP request directed towards a relative URL that starts with
    `/events`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您查看每个任务的HTTP翻译，您会注意到它们的相对URL都有一个共同的属性，即它们都以“/events”开头。在Gorilla web工具包中，我们可以为“/events”相对URL创建一个子路由器。子路由器基本上是一个对象，负责处理任何指向以“/events”开头的相对URL的传入HTTP请求。
- en: 'To create a subrouter for URLs prefixed with `/events`, the following code
    is needed:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要为以“/events”为前缀的URL创建一个子路由器，需要以下代码：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code makes use of the router object we created earlier, then calls
    the `PathPrefix` method, which is used to capture any URL path that starts with
    `/events`. Then, finally, we call the `Subrouter()` method, which will create
    a new router object for us to use from now on to handle any incoming requests
    to URLs that start with `/events`. The new router is called `eventsrouter`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了我们之前创建的路由器对象，然后调用了`PathPrefix`方法，用于捕获以“/events”开头的任何URL路径。最后，我们调用了`Subrouter()`方法，这将为我们创建一个新的路由器对象，以便从现在开始处理任何以“/events”开头的URL的传入请求。新的路由器称为`eventsrouter`。
- en: 'Next, the `eventsrouter` object can be used to define what to do with the rest
    of the URLs that share the `/events` prefix. So, let''s revisit the list of HTTP
    translations for our tasks and explore the code needed to get them done:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`eventsrouter`对象可以用来定义其余共享“/events”前缀的URL的操作。因此，让我们重新查看我们任务的HTTP翻译列表，并探索完成它们所需的代码：
- en: '**Task:** Searching for events via:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任务：**通过搜索事件：'
- en: '`id`: Relative URL is `/events/id/3434`, the method is `GET`, and no data is
    expected in the HTTP body'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：相对URL是“/events/id/3434”，方法是“GET”，在HTTP正文中不需要数据'
- en: '`name`: Relative URL is `/events/name/jazz_concert`, the method is `GET`, and
    no data is expected in the HTTP body:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：相对URL是“/events/name/jazz_concert”，方法是“GET”，在HTTP正文中不需要数据：'
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The handler object in the preceding code is basically the object that implements
    the methods that represent the functionality that we expect to be mapped to the
    incoming HTTP request. More on that later.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的处理程序对象基本上是实现我们期望映射到传入HTTP请求的功能的方法的对象。稍后再详细介绍。
- en: '**Task:** Retrieving all events at once—Relative URL is `/events`, the method
    is `GET`, and no data is expected in the HTTP body:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任务：**一次性检索所有事件——相对URL是“/events”，方法是“GET”，在HTTP正文中不需要数据'
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Task:** Creating a new event—Relative URL is `/events,` the method is `POST`,
    and expected data in the HTTP body needs to be the JSON representation of the
    new event we would like to add:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任务：**创建一个新事件——相对URL是“/events”，方法是“POST”，并且HTTP正文中需要的数据是我们想要添加的新事件的JSON表示：'
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For tasks 2 and 3, the code is self-explanatory. The Gorilla `mux` package allows
    us access to Go methods that eloquently define the properties of the incoming
    HTTP request that we would like to capture. The package also allows us to chain
    the calls together in a line to efficiently structure our code. The `Methods()` call
    defined the expected HTTP method, the `Path()` call defined the expected relative
    URL path (note that we placed the call on the `eventsrouter` object, which would
    append `/events` to the relative path defined in the `Path()` call), and finally
    comes the `HandlerFunc()` method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任务2和3，代码是不言自明的。Gorilla `mux`包允许我们访问优雅地定义我们想要捕获的传入HTTP请求的属性的Go方法。该包还允许我们将调用链接在一起，以有效地构造我们的代码。`Methods()`调用定义了预期的HTTP方法，`Path()`调用定义了预期的相对URL路径（请注意，我们将调用放在`eventsrouter`对象上，它将在`Path()`调用中定义的相对路径后附加`/events`），最后是`HandlerFunc()`方法。
- en: The `HandlerFunc()` method is how we will link the captured incoming HTTP request
    with an action. `HandlerFunc()` takes an argument of the `func(http.ResponseWriter,
    *http.Request)` type. This argument is basically a function with two important
    arguments—an HTTP response object that we need to fill with our response to the
    incoming request and an HTTP request object, which will contain all the information
    about the incoming HTTP request.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandlerFunc()`方法是我们将捕获的传入HTTP请求与操作关联的方式。`HandlerFunc()`接受一个`func(http.ResponseWriter,
    *http.Request)`类型的参数。这个参数基本上是一个具有两个重要参数的函数——一个HTTP响应对象，我们需要用我们的响应填充它，以响应传入的请求，以及一个HTTP请求对象，其中包含有关传入HTTP请求的所有信息。'
- en: The functions we pass to `HandlerFunc()` in the preceding code is `handler.findEventHandler`,
    `handler.allEventHandler`, and `handler.newEventHandler`—all support the `func(http.ResponseWriter,
    *http.Request)` signature. `handler` is a Go struct object, created to host all
    those functions. The `handler` object belongs to a custom Go struct type called
    `eventServiceHandler`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们传递给`HandlerFunc()`的函数是`handler.findEventHandler`、`handler.allEventHandler`和`handler.newEventHandler`，它们都支持`func(http.ResponseWriter,
    *http.Request)`签名。`handler`是一个Go结构对象，用于承载所有这些函数。`handler`对象属于一个名为`eventServiceHandler`的自定义Go结构类型。
- en: 'In order for the `eventServiceHandler` type to support the HTTP handlers for
    tasks 1, 2, and 3, it needs to be defined like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`eventServiceHandler`类型支持任务1、2和3的HTTP处理程序，它需要定义如下：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we created `eventServiceHandler` as a struct type with
    no fields, then, we attached three empty methods to it. Each one of the handler
    methods supports the function signature needed to become an argument for the Gorilla
    `mux` package `HandlerFunc()` method. The detailed implementation of each one
    of the `eventServiceHandler` methods will be discussed in more detail in this
    chapter when we cover the persistence layer of our microservice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将`eventServiceHandler`创建为一个没有字段的结构类型，然后将三个空方法附加到它上面。每一个处理程序方法都支持成为Gorilla
    `mux`包`HandlerFunc()`方法的参数所需的函数签名。在本章中，当我们讨论微服务的持久层时，将更详细地讨论`eventServiceHandler`方法的详细实现。
- en: Now, let's go back to task 1\. The `/{SearchCriteria}/{search}` path in our
    code represents the equivalent of the `/id/2323` path to search for the event
    ID `2323`, or the path `/name/opera aida` to search for an event with name `opera
    aida`. The curly braces in our path alert the Gorilla `mux` package that `SearchCriteria` and
    `search` are basically variables expected to be substituted in the real-incoming
    HTTP request URL with other things.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到任务1。我们代码中的`/{SearchCriteria}/{search}`路径代表了搜索事件ID`2323`的等价路径`/id/2323`，或者搜索名称为`opera
    aida`的事件的路径`/name/opera aida`。我们路径中的大括号提醒Gorilla `mux`包，`SearchCriteria`和`search`基本上是预期在真实传入的HTTP请求URL中用其他内容替换的变量。
- en: The Gorilla `mux` package enjoys powerful support for URL path variables. It
    also supports pattern-matching via regular expressions. So, for example, if I
    use a path that looks like `/{search:[0-9]+}`, it will provide me a variable called
    `search` that hosts a number.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla `mux`包支持URL路径变量的强大功能。它还支持通过正则表达式进行模式匹配。因此，例如，如果我使用一个看起来像`/{search:[0-9]+}`的路径，它将为我提供一个名为`search`的变量，其中包含一个数字。
- en: 'After we finish defining our routers, paths, and handlers, we will need to
    specify the local TCP address where our web server will listen for incoming HTTP
    requests. For this, we need Go''s `net/http` package; here''s what the code would
    look like:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成定义路由器、路径和处理程序之后，我们需要指定本地TCP地址，以便我们的Web服务器监听传入的HTTP请求。为此，我们需要Go的`net/http`包；代码如下：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this single line of code, we created a web server. It will listen for incoming
    HTTP requests on local port `8181` and will use the `r` object as the router for
    the requests. We created the `r` object earlier using the `mux` package.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行代码中，我们创建了一个Web服务器。它将在本地端口`8181`上监听传入的HTTP请求，并将使用`r`对象作为请求的路由器。我们之前使用`mux`包创建了`r`对象。
- en: It's now time to put all the code we covered up to this point together. Let's
    assume that the code lives inside a function called `ServeAPI()` that is responsible
    for activating the Restful API logic for our microservice.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们到目前为止涵盖的所有代码放在一起了。假设代码位于一个名为`ServeAPI()`的函数中，该函数负责激活我们微服务的Restful API逻辑。
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We defined the `eventServiceHandler` object to look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`eventServiceHandler`对象如下：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Obviously, the next step will be to fill in the empty methods of the `eventServiceHandler`
    type. We have the `findEventHandler()`, `allEventHandler()`, and `newEventHandler()` methods.
    Each one of them needs a persistence layer to carry out their tasks. That is because
    they either retrieve stored data or add new data to a store.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，下一步将是填写`eventServiceHandler`类型的空方法。我们有`findEventHandler()`、`allEventHandler()`和`newEventHandler()`方法。它们每一个都需要一个持久层来执行它们的任务。这是因为它们要么检索存储的数据，要么向存储添加新数据。
- en: As mentioned earlier in this section, the persistence layer is the component
    of a microservice that is tasked with storing data in databases or retrieving
    data from databases. We arrived to the point where we need to cover the persistence
    layer in much more detail.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中前面提到过，持久层是微服务的一个组件，负责将数据存储在数据库中或从数据库中检索数据。我们已经到了需要更详细地介绍持久层的时候了。
- en: Persistence layer
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久层
- en: The first decision that needs to be made when designing a persistence layer
    is to decide on the type of the data store. The data store could be a relational
    SQL database such as Microsoft SQL or MySQL, among others. Alternatively, it can
    be a NoSQL store, such as MongoDB, or Apache Cassandra, among others.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计持久层时需要做出的第一个决定是决定数据存储的类型。数据存储可以是关系型SQL数据库，如Microsoft SQL或MySQL等。或者，它可以是NoSQL存储，如MongoDB或Apache
    Cassandra等。
- en: In an efficient and complex production environment, the code needs to be capable
    of switching from one data store to another without too much refactoring. Consider
    the following example—you build a number of microservices for a start-up that
    relies on MongoDB as the data store; then, as the organization changes, you decide
    that AWS cloud-based DynamoDB would make a better data store for the microservices.
    If the code doesn't allow easily unplugging MySQL, then plugging a MongoDB layer
    in its place, tons of code refactoring will be needed in our microservices. In
    Go, we will achieve that flexible design using interfaces.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在高效和复杂的生产环境中，代码需要能够在不需要太多重构的情况下从一个数据存储切换到另一个。考虑以下例子——您为一家依赖MongoDB作为数据存储的初创公司构建了许多微服务；然后，随着组织的变化，您决定AWS基于云的DynamoDB将成为微服务更好的数据存储。如果代码不允许轻松地拔掉MySQL，然后插入MongoDB层，那么我们的微服务将需要大量的代码重构。在Go语言中，我们将使用接口来实现灵活的设计。
- en: It is worth mentioning that in microservices architectures, different services
    can require different types of datastores, so it is normal for one microservice
    to use MongoDB, whereas another service would use MySQL.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，在微服务架构中，不同的服务可能需要不同类型的数据存储，因此一个微服务使用MongoDB，而另一个服务可能使用MySQL是很正常的。
- en: 'Let''s assume that we are building a persistence layer for the events microservice.
    Based on what we have covered so far, the events microservice persistence layer
    would primarily care about three things:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在为事件微服务构建持久层。根据我们目前所涵盖的内容，事件微服务的持久层主要关心三件事：
- en: Adding a new event to the databases
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向数据库添加新事件
- en: Finding an event by ID
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过ID查找事件
- en: Finding an event by name
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名称查找事件
- en: 'To achieve flexible code design, we would need the preceding three functionalities
    to be defined in an interface. It would look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现灵活的代码设计，我们需要在接口中定义前面三个功能。它会是这样的：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Event` datatype is a struct type that represents the data of an event,
    such as the event name, location, time, among other things. For now, let's focus
    on the `DatabaseHandler` interface. It supports four methods that represent the
    required tasks from the events service persistence layer. We can then create numerous
    concrete implementations from this interface. One implementation can support MongoDB,
    while another can support the cloud-native AWS DynamoDB database.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`数据类型是一个代表事件数据的结构类型，例如事件名称、位置、时间等。现在，让我们专注于`DatabaseHandler`接口。它支持四种方法，代表了事件服务持久层所需的任务。然后我们可以从这个接口创建多个具体的实现。一个实现可以支持MongoDB，而另一个可以支持云原生的AWS
    DynamoDB数据库。'
- en: We'll cover AWS DynamoDB in a later chapter. In this chapter, the focus will
    be on MongoDB.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中介绍AWS DynamoDB。本章的重点将放在MongoDB上。
- en: MongoDB
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB
- en: If you are not already familiar with the MongoDB NoSQL database engine, this
    section will be very useful for you.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对MongoDB NoSQL数据库引擎还不熟悉，本节将对您非常有用。
- en: MongoDB is a NoSQL document store database engine. The two keywords to understand
    MongoDB are *NoSQL* and *document store*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个NoSQL文档存储数据库引擎。理解MongoDB的两个关键词是*NoSQL*和*文档存储*。
- en: NoSQL is a relatively recent keyword in the software industry that is used to
    indicate that a database engine does not deeply rely on relational data. Relational
    data is the idea that there are webs of relations between different pieces of
    data in your database, following the relations between your data will build a
    full picture of what the data represents.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL是软件行业中相对较新的关键词，用于指示数据库引擎不太依赖关系数据。关系数据是指数据库中不同数据之间存在关系的概念，遵循数据之间的关系将构建出数据代表的完整图景。
- en: Take MySQL as an example of a relational database. Data gets stored in numerous
    tables, then, primary and foreign keys are used to define the relations between
    the different tables. MongoDB doesn't work this way, which is why MySQL is considered
    as a SQL database, whereas MongoDB is considered NoSQL.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以MySQL作为关系型数据库的例子。数据存储在多个表中，然后使用主键和外键来定义不同表之间的关系。MongoDB不是这样工作的，这就是为什么MySQL被认为是SQL数据库，而MongoDB被认为是NoSQL数据库。
- en: 'If you are not yet familiar with Mongodb, or don’t have a local installation
    you can test with. Go to [https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)
    , where you find a list of helpful links to guide through the process of installing
    and running the database in your operating system of choice. Generally, when installed,
    Mongodb provides two key binaries: `mongod` and `mongo`. The `mongod` command
    is what you need to execute, in order to run your database. Any software you then
    write will communicate with `mongod` to access Mongodb’s data. The `mongo` command,
    on the other hand, is basically a client tool you can use to test the data on
    Mongodb, the `mongo` command communicates with `mongod`, similarly to any application
    you write that accesses the database.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还不熟悉Mongodb，或者没有本地安装可以测试。转到[https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)，在那里您会找到一系列有用的链接，指导您完成在所选操作系统中安装和运行数据库的过程。通常，安装后，Mongodb提供两个关键二进制文件：`mongod`和`mongo`。`mongod`命令是您需要执行的，以便运行您的数据库。然后编写的任何软件都将与`mongod`通信，以访问Mongodb的数据。另一方面，`mongo`命令基本上是一个客户端工具，您可以使用它来测试Mongodb上的数据，`mongo`命令与`mongod`通信，类似于您编写的任何访问数据库的应用程序。
- en: 'There are two flavors of MongoDB: the community edition, and the enterprise
    edition. Obviously, the enterprise edition targets larger enterprise installations,
    whereas the community edition is what you’d use for your testing and smaller scale
    deployments.  Here are the links for the community edition guides covering the
    three major operating systems:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种MongoDB：社区版和企业版。显然，企业版针对更大的企业安装，而社区版是您用于测试和较小规模部署的版本。以下是涵盖三个主要操作系统的社区版指南的链接：
- en: 'For linux Mongodb installation and deployment: [https://docs.mongodb.com/manual/administration/install-on-linux/](https://docs.mongodb.com/manual/administration/install-on-linux/)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Linux Mongodb安装和部署：[https://docs.mongodb.com/manual/administration/install-on-linux/](https://docs.mongodb.com/manual/administration/install-on-linux/)
- en: 'For Windows Mongodb installation and deployment: [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Mongodb安装和部署：[https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/)
- en: 'For OS X Mongodb installation and deployment: [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于OS X Mongodb安装和部署：[https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/)
- en: 'Overall, there are three main steps you need to consider when deploying a Mongodb
    instance:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在部署Mongodb实例时，有三个主要步骤需要考虑：
- en: 'Install Mongodb for your operating system, the download page can be found here:
    [https://www.mongodb.com/download-center](https://www.mongodb.com/download-center)'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的操作系统安装Mongodb，下载页面在这里：[https://www.mongodb.com/download-center](https://www.mongodb.com/download-center)
- en: Ensure MongoDB’s key binaries are defined in your environmental path, so that
    you can run them from the terminal no matter what your current directory is. The
    key binaries are `mongod` and `mongo`. Another binary worth mentioning is `mongos`,
    which is important if you are planning to utilize clustering
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保MongoDB的关键二进制文件在您的环境路径中定义，以便您可以从终端运行它们，无论当前目录是什么。关键二进制文件是`mongod`和`mongo`。另一个值得一提的二进制文件是`mongos`，如果您计划使用集群，则这一点很重要
- en: 'Run the `mongod` command with no arguments, and this will run Mongodb with
    all your default settings. Alternatively, you can use it with different configuration.
    You can either use a configuration file or just runtime parameters. You can find
    information about the configuration file here: [https://docs.mongodb.com/manual/reference/configuration-options/#configuration-file](https://docs.mongodb.com/manual/reference/configuration-options/#configuration-file).  To
     start `mongod` with a custom configuration file, you can use the `--config` option,
    here is an example: `mongod --config /etc/mongod.conf`. On the other hand, for
    runtime parameters, you can just use `--option` to change an option when running
    `mongod`, for example you can type `mongod --port 5454` to start `mongod` on a
    different port than the default'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`mongod`命令，不带任何参数，这将使用所有默认设置运行Mongodb。或者，您可以使用不同的配置。您可以使用配置文件或运行时参数。您可以在这里找到有关配置文件的信息：[https://docs.mongodb.com/manual/reference/configuration-options/#configuration-file](https://docs.mongodb.com/manual/reference/configuration-options/#configuration-file)。要使用自定义配置文件启动`mongod`，可以使用`--config`选项，这是一个示例：`mongod
    --config /etc/mongod.conf`。另一方面，对于运行时参数，您可以在运行`mongod`时使用`--option`来更改选项，例如，您可以键入`mongod
    --port 5454`以在与默认值不同的端口上启动`mongod`
- en: There are different types of NoSQL databases. One of these types is the *document
    store* database. The idea of a document store is that data gets stored in numerous
    document files stacked together to represent what we are trying to store. Let's
    take the data store needed for the event's microservice as an example. If we are
    using a document store in the microservice persistence layer, each event will
    be stored in a separate document with a unique ID. Say that we have an Opera Aida
    event, a Coldplay concert event, and a ballet performance event. In MongoDB, we
    would create a collection of documents called *events*, which will contain three
    documents—one for the Opera, one for Coldplay, and one for the ballet performance.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的NoSQL数据库。其中一种类型是*文档存储*数据库。文档存储的概念是数据存储在许多文档文件中，堆叠在一起以表示我们要存储的内容。让我们以事件微服务所需的数据存储为例。如果我们在微服务持久层中使用文档存储，每个事件将存储在一个单独的带有唯一ID的文档中。假设我们有一个Aida歌剧事件，一个Coldplay音乐会事件和一个芭蕾表演事件。在MongoDB中，我们将创建一个名为*events*的文档集合，其中包含三个文档——一个用于歌剧，一个用于Coldplay，一个用于芭蕾表演。
- en: 'So, to solidify our understanding of how MongoDB would represent this data,
    here is a diagram of the events collection:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了巩固我们对MongoDB如何表示这些数据的理解，这里是事件集合的图表：
- en: '![](img/0f10361f-cb37-42de-b2ee-16b8b80c7786.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f10361f-cb37-42de-b2ee-16b8b80c7786.png)'
- en: Events collection
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 事件集合
- en: 'Collections and documents are important concepts in MongoDB. A production MongoDB
    environment typically consists of multiple collections; each collection would
    represent a different piece of our data. So, for example, our MyEvents application
    consists of a number of microservices, each microservice cares about a distinctive
    piece of data. The bookings microservice would store data in a bookings collection,
    and the events microservices would store data in an events collection. We''d also
    need the user''s data to be stored separately in order to manage the users of
    our applications independently. Here is what this would end up looking like:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，集合和文档是重要的概念。生产环境中的MongoDB通常由多个集合组成；每个集合代表我们数据的不同部分。例如，我们的MyEvents应用程序由许多微服务组成，每个微服务关心不同的数据部分。预订微服务将在预订集合中存储数据，而事件微服务将在事件集合中存储数据。我们还需要将用户数据单独存储，以便独立管理我们应用程序的用户。这将看起来像这样：
- en: '![](img/9bc4b09d-c5d4-4727-b6d7-a08167d37aef.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bc4b09d-c5d4-4727-b6d7-a08167d37aef.png)'
- en: Our MongoDB database
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的MongoDB数据库
- en: You can download this file from [https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下链接下载此文件：[https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf)。
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Cloud-Native-Programming-with-Golang](https://github.com/PacktPublishing/Cloud-Native-programming-with-Golang).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该书的代码包也托管在GitHub上：[https://github.com/PacktPublishing/Cloud-Native-Programming-with-Golang](https://github.com/PacktPublishing/Cloud-Native-programming-with-Golang)。
- en: 'Since we have focused so far on the events microservice as a showcase on how
    to build a microservice, let''s dive deeper into the events collection, which
    would be used by the event''s microservice:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们迄今为止专注于事件微服务作为构建微服务的展示，让我们深入了解事件集合，这将被事件微服务使用：
- en: '![](img/9422f73b-196c-4be4-a1c2-7e17df8ecd1f.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9422f73b-196c-4be4-a1c2-7e17df8ecd1f.png)'
- en: Events collection
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 事件集合
- en: 'Each document in the events collection needs to include all the information
    necessary to represent a single event. Here''s how an event document should look
    like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 事件集合中的每个文档都需要包含表示单个事件所需的所有信息。以下是事件文档应该看起来的样子：
- en: '![](img/5505e49b-7894-44b0-93e1-b4b75e9245f4.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5505e49b-7894-44b0-93e1-b4b75e9245f4.png)'
- en: If you haven't noticed already, the preceding JSON document is the same as the
    HTTP body document that we presented as an example of what the add event API HTTP
    `POST` request body looks like.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有注意到，前面的JSON文档与我们提供的HTTP `POST`请求体示例相同，这是一个添加事件API的HTTP请求体示例。
- en: 'In order to write software that can work with this data, we need to create
    models. Models are basically data structures containing fields that match the
    data we are expecting from the database. In the case of Go, we''d use struct types
    to create our models. Here is what a model for an event should look like:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写可以处理这些数据的软件，我们需要创建模型。模型基本上是包含与我们从数据库中期望的数据匹配的字段的数据结构。在Go的情况下，我们将使用结构类型来创建我们的模型。以下是事件模型应该看起来的样子：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Event struct` is the data structure or model for our event document. It
    contains the ID, event name, event duration, event start date, event end date,
    and event location. Since the event location needs to hold more information than
    just a single field, we will create a struct type called location to model a location.
    The `Location struct` type contains the location's name, address, country, open
    time and close time, and the halls in that area. A hall is basically the room
    inside the location where the event is taking place.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event struct`是我们事件文档的数据结构或模型。它包含ID、事件名称、事件持续时间、事件开始日期、事件结束日期和事件位置。由于事件位置需要包含比单个字段更多的信息，我们将创建一个名为location的结构类型来模拟位置。`Location
    struct`类型包含位置的名称、地址、国家、开放时间和关闭时间，以及该区域的大厅。大厅基本上是位置内部的房间，活动在那里举行。'
- en: So, for example, Mountain View, Opera house in downtown Mountain View would
    be the location, whereas the silicon valley room on the east side would be the
    hall.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，Mountain View，位于Mountain View市中心的歌剧院将是位置，而位于东侧的硅谷房间将是大厅。
- en: In turn, the hall cannot be represented by a single field since we need to know
    its name, its location in the building (south-east, west, and so forth), and its
    capacity (the number of people it can host).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，大厅不能由单个字段表示，因为我们需要知道它的名称、建筑物内的位置（东南、西部等）以及其容量（它可以容纳的人数）。
- en: The `bson.ObjectId` type in the event struct is a special type that represents
    MongoDB document ID. The `bson` package can be found in the `mgo` adapter, which
    is the Go third part framework of choice to communicate with MongoDB. The `bson.ObjectId`
    type also provides some helpful methods that we can use later in our code to verify
    the validity of the ID.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 事件结构中的`bson.ObjectId`类型是表示MongoDB文档ID的特殊类型。`bson`包可以在`mgo`适配器中找到，这是与MongoDB通信的Go第三方框架的选择。`bson.ObjectId`类型还提供了一些有用的方法，我们可以在代码中稍后使用这些方法来验证ID的有效性。
- en: Before we start covering `mgo`, let's take a moment to explain what `bson` means.
    `bson` is a data format used by MongoDB to represent data in stored documents.
    It could be simply considered as binary JSON because it is a binary-encoded serialization
    of JSON-like documents. The specification can be found at: [http://bsonspec.org/](http://bsonspec.org/).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始介绍`mgo`之前，让我们花一点时间解释一下`bson`的含义。`bson`是MongoDB用于表示存储文档中的数据的数据格式。它可以简单地被认为是二进制JSON，因为它是JSON样式文档的二进制编码序列化。规范可以在此链接找到：[http://bsonspec.org/](http://bsonspec.org/)。
- en: Now, let's cover `mgo`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来介绍`mgo`。
- en: MongoDB and the Go language
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB和Go语言
- en: mgo is a popular MongoDB driver written in the Go language. The package page
    can be found at: [http://labix.org/mgo](http://labix.org/mgo). The driver is nothing
    more than a number of Go packages that facilitate writing Go programs capable
    of working with MongoDB.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: mgo是用Go语言编写的流行的MongoDB驱动程序。包页面可以在[http://labix.org/mgo](http://labix.org/mgo)找到。该驱动程序只是一些Go包，可以方便地编写能够与MongoDB一起工作的Go程序。
- en: 'In order to make use of `mgo`, the first step is to make use of the `go get`
    command to retrieve the package:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`mgo`，第一步是使用`go get`命令检索包：
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With the preceding command executed, we get the ability to use `mgo` in our
    code. We'd need to import the `mgo` package and the `bson` package that we discussed
    earlier. The package name we use to host our MongoDB persistence layer is called
    `mongolayer`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令后，我们可以在代码中使用`mgo`。我们需要导入`mgo`包和之前讨论过的`bson`包。我们用来托管我们的MongoDB持久层的包名叫做`mongolayer`。
- en: 'Let''s have a look at the `mongolayer` package:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`mongolayer`包：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, let''s create some constants to represent the name of our database and
    the names of the collections involved in our persistence layer. The database name
    in MongoDB would be `myevents`. The collection names we''ll use are `users` for
    the users collection, and `events` for the collection of events in our database:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一些常量来表示我们的数据库名称以及我们持久层中涉及的集合的名称。MongoDB中的数据库名称将是`myevents`。我们将使用的集合名称是`users`，用于用户集合，以及`events`，用于我们数据库中的事件集合。
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In order to expose the features of the `mgo` package, we will need to utilize
    a database session object that belongs to the `mgo` package, the session object
    type is called `*mgo.session`. To make use of `*mgo.session` inside our code,
    we will wrap it with a struct type called `MongoDBLayer`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了公开`mgo`包的功能，我们需要利用属于`mgo`包的数据库会话对象，该会话对象类型称为`*mgo.session`。为了在我们的代码中使用`*mgo.session`，我们将其包装在名为`MongoDBLayer`的结构类型中，如下所示：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is now time to implement the `DatabaseHandler` interface that we covered
    earlier in order to construct the concrete persistence layer of our application.
    In the Go language, it is typically preferred to use a pointer type when implementing
    an interface because pointers preserve references to the original memory addresses
    of the underlying objects as opposed to copying the entire object around when
    we make use of it. In other words, the implementer object type for the `DatabaseHandler`
    interface needs to be a pointer to a `MongoDBLayer` struct object, or just simply
    `*MongoDBLayer`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现我们之前讨论过的`DatabaseHandler`接口了，以构建应用程序的具体持久层。在Go语言中，通常首选在实现接口时使用指针类型，因为指针保留对底层对象的原始内存地址的引用，而不是在使用时复制整个对象。换句话说，`DatabaseHandler`接口的实现对象类型需要是指向`MongoDBLayer`结构对象的指针，或者简单地说是`*MongoDBLayer`。
- en: 'However, before we start implementing the interface, we will first need to
    create a constructor function that returns an object of the `*MongoDBLayer` type.
    This is idiomatic in Go in order for us to be able to execute any necessary initialization
    code while creating a new object of the `*MongoDBLayer` type. In our cases, the
    initialization code is basically to obtain a connection session handler to the
    desired MongoDB database address. The following is what the constructor code will
    look like:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始实现接口之前，我们首先需要创建一个构造函数，返回`*MongoDBLayer`类型的对象。这在Go语言中是惯用的，以便我们能够在创建`*MongoDBLayer`类型的新对象时执行任何必要的初始化代码。在我们的情况下，初始化代码基本上是获取所需的MongoDB数据库地址的连接会话处理程序。构造函数代码如下所示：
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we created a constructor function called `NewMongoDBLayer`,
    which requires a single argument of type string. The argument represents the connection
    string with the information needed to establish the connection to the MongoDB
    database. According to `mgo` documentation at [https://godoc.org/gopkg.in/mgo.v2#Dial](https://godoc.org/gopkg.in/mgo.v2#Dial),
    the format of the connection string needs to look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个名为`NewMongoDBLayer`的构造函数，它需要一个字符串类型的单个参数。该参数表示连接字符串，其中包含建立与MongoDB数据库连接所需的信息。根据`mgo`文档[https://godoc.org/gopkg.in/mgo.v2#Dial](https://godoc.org/gopkg.in/mgo.v2#Dial)，连接字符串的格式需要如下所示：
- en: '![](img/d5bfd2e3-f4bc-45d4-9c86-8cbf1998639b.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5bfd2e3-f4bc-45d4-9c86-8cbf1998639b.png)'
- en: If it is just a localhost connection, the connection string will look as follows: `mongodb://127.0.0.1`
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只是本地主机连接，连接字符串将如下所示：`mongodb://127.0.0.1`
- en: If a port number is not provided in the connection string, the port defaults
    to `27017`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接字符串中没有提供端口号，则端口默认为`27017`。
- en: Now, let's look at the code inside our constructor function. In the first line,
    we call `mgo.Dial()` with the connection string as an argument. The `mgo.Dial()`
    is the function in the `mgo` package, which will return a MongoDB connection session
    for us to use later in our code. It returns two results—the `*mgo.Session` object
    and an error object. We use struct literals at the end to return a fresh object
    of type pointer to `MongoDBLayer`, which hosts the newly created `*mgo.Session`
    object. We also return the error object so that we communicate to the caller any
    errors that would have occurred during the initialization process.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看构造函数内的代码。在第一行中，我们使用连接字符串作为参数调用`mgo.Dial()`。`mgo.Dial()`是`mgo`包中的函数，它将为我们返回一个MongoDB连接会话，以便稍后在我们的代码中使用。它返回两个结果——`*mgo.Session`对象和一个错误对象。我们在最后使用结构文字返回指向`MongoDBLayer`类型的新对象的指针，其中包含新创建的`*mgo.Session`对象。我们还返回错误对象，以便在初始化过程中向调用者传达任何错误。
- en: Now, with the constructor out of the way, it's time to implement the methods
    of the `DatabaseHandler` interface. So far, we have four methods—`AddEvent(Event)`,
    `FindEvent([]byte)`, `FindEventByName(string)`, and `FindAllAvailableEvents()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构造函数已经完成，是时候实现`DatabaseHandler`接口的方法了。到目前为止，我们有四种方法——`AddEvent(Event)`、`FindEvent([]byte)`、`FindEventByName(string)`和`FindAllAvailableEvents()`。
- en: 'Here is what the code for the `AddEvent(Event)` method will look like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddEvent(Event)`方法的代码如下：'
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The method takes an argument of type  `persistence.Event`, which models the
    information expected from an event as we covered earlier. It returns a slice of
    bytes, which represents the event ID, and an error object, which will be nil if
    no errors are found.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个类型为`persistence.Event`的参数，该类型模拟了我们之前介绍的事件所期望的信息。它返回一个字节片，表示事件ID，以及一个错误对象，如果没有找到错误，则为nil。
- en: 'In the first line, we call a `getFreshSession()` method—this is a helper method
    implemented in our code to help retrieve a fresh database session from the connection
    pool. Here is what the method code looks like:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们调用了`getFreshSession()`方法——这是我们代码中实现的一个帮助方法，用于从连接池中检索一个新的数据库会话。该方法的代码如下：
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `session.Copy()` is the method that is called whenever we are requesting
    a new session from the `mgo` package connection pool. `mgoLayer.session` here
    is basically the `*mgo.Session` object we have hosted inside the `MongoDBLayer`
    struct. It is idiomatic to call `session.Copy()` at the beginning of any method
    or function that is about to issue queries or commands to MongoDB via the `mgo`
    package. The `getFreshSession()` method is just a helper method that calls `session.Copy()` for
    us and returns the resulting session.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`session.Copy()`是每当我们从`mgo`包连接池中请求新会话时调用的方法。`mgoLayer.session`在这里基本上是我们在`MongoDBLayer`结构体中托管的`*mgo.Session`对象。在即将通过`mgo`包向MongoDB发出查询或命令的任何方法或函数的开头调用`session.Copy()`是惯用的。`getFreshSession()`方法只是一个帮助方法，它调用`session.Copy()`为我们返回结果的会话。'
- en: Now, let's return to the `AddEvent()` method. We now have a working `*mgo.Session`
    object from the database connection pool to use in our code. The first thing to
    do is to call defer `s.Close()` to ensure that this session gets returned back
    to the `mgo` database connection pool after the `AddEvent()` method exits.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`AddEvent()`方法。我们现在有一个来自数据库连接池的工作`*mgo.Session`对象可供我们在代码中使用。首先要做的是调用`defer
    s.Close()`，以确保在`AddEvent()`方法退出后，该会话会返回到`mgo`数据库连接池中。
- en: Next, we check whether the event ID supplied by the `Event` argument object
    is valid and whether the ID field of the `Event` object is of the `bson.ObjectID` type
    as we covered earlier. `bson.ObjectID` supports a `Valid()` method, which we can
    use to detect whether the ID is a valid MongoDB document ID or not. If the supplied
    event ID is not valid, we will create one of our own using the `bson.NewObjectID()`
    function call. We will then repeat the same pattern with the location-embedded
    object inside the event.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查`Event`参数对象提供的事件ID是否有效，以及`Event`对象的ID字段是否是我们之前介绍的`bson.ObjectID`类型。`bson.ObjectID`支持`Valid()`方法，我们可以使用它来检测ID是否是有效的MongoDB文档ID。如果提供的事件ID无效，我们将使用`bson.NewObjectID()`函数调用创建一个新的ID。然后，我们将在事件内部嵌入的位置对象中重复相同的模式。
- en: Finally, at the end, we will return two results—the first result is the event
    ID of the added event, and a second result is an error object representing the
    result of the event insertion operation. In order to insert the event object to
    the MongoDB database, we will use the session object in the `s` variable, then
    call `s.DB(DB).C(EVENTS)` to obtain an object that represents our events collection
    in the database. The object will be of the `*mgo.Collection` type. The `DB()`
    method helps us access the database; we will give it the `DB` constant as an argument,
    which has our database name. The `C()` method helps us access the collection;
    we will give it the `EVENTS` constant, which has the name of our events collection.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将返回两个结果——第一个结果是添加事件的事件ID，第二个结果是表示事件插入操作结果的错误对象。为了将事件对象插入MongoDB数据库，我们将使用`s`变量中的会话对象，然后调用`s.DB(DB).C(EVENTS)`来获取一个表示数据库中我们事件集合的对象。该对象将是`*mgo.Collection`类型。`DB()`方法帮助我们访问数据库；我们将给它`DB`常量作为参数，它包含我们的数据库名称。`C()`方法帮助我们访问集合；我们将给它`EVENTS`常量，它包含我们事件集合的名称。
- en: The `DB` and `EVENTS` constants were defined earlier in our code. Then, finally,
    we will call the `Insert()` method of the collection object, with the `Event`
    object as an argument, which is why the code ends up looking like this—`s.DB(DB).C(EVENTS).Insert(e)`.
    This line is what we need in order to insert a new document into a MongoDB database
    collection that utilizes Go objects and the `mgo` package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`DB`和`EVENTS`常量在我们的代码中早已定义。最后，我们将调用集合对象的`Insert()`方法，并将`Event`对象作为参数传递，这就是为什么代码最终看起来像这样——`s.DB(DB).C(EVENTS).Insert(e)`。这一行是我们需要的，以便将新文档插入到使用Go对象和`mgo`包的MongoDB数据库集合中。'
- en: 'Now, let''s look at the code for `FindEvent()`, which we use to retrieve the
    information of a certain event from the database from its ID. The code will look
    as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`FindEvent()`的代码，我们将使用它来从数据库中根据ID检索特定事件的信息。代码如下：
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note how the ID is passed as a slice of bytes instead of a `bson.ObjectId` type.
    We do this to ensure that the `FindEvent()` method in the `DatabaseHandler` interface
    stays as generic as possible. For example, we know that in the world of MongoDB,
    the ID will be of the `bson.ObjectId` type, but what if we now want to implement
    a MySQL database layer? It would not make sense to have the ID argument type passed
    to `FindEvent()` as `bson.ObjectId`. So, that's why we picked the `[]byte` type
    to represent our ID argument. In theory, we should be able to convert a slice
    of bytes to any other type that can represent an id.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ID以字节片的形式传递，而不是`bson.ObjectId`类型。我们这样做是为了确保`DatabaseHandler`接口中的`FindEvent()`方法尽可能通用。例如，我们知道在MongoDB的世界中，ID将是`bson.ObjectId`类型，但是如果我们现在想要实现一个MySQL数据库层呢？将ID参数类型传递给`FindEvent()`为`bson.ObjectId`是没有意义的。这就是为什么我们选择了`[]byte`类型来表示我们的ID参数。理论上，我们应该能够将字节片转换为任何其他可以表示ID的类型。
- en: An important remark is that we could also have picked the empty interface type
    (`interface{}`), which in Go can be converted to any other type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，我们也可以选择空接口类型（`interface{}`），在Go中可以转换为任何其他类型。
- en: In the first line of the `FindEvent()` method, we obtained a fresh session from
    the connection pool using the `mgoLayer.getFreshSession()` as before. We then
    call `defer s.Close()` to ensure that the session goes back to the connection
    pool after we are done.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FindEvent（）`方法的第一行中，我们像以前一样使用`mgoLayer.getFreshSession（）`从连接池中获取了一个新的会话。然后我们调用`defer
    s.Close（）`确保会话在完成后返回到连接池。
- en: Next, we created an empty event object `e` using the code `e := persistence.Event{}`.
    We then use `s.DB(DB).C(EVENTS)` to access the events collection in MongoDB. There
    is a method called `FindId()`, which is supported by `*mgoCollection` objects
    of `mgo`. The method takes an object of the `bson.ObjectId` type as an argument
    then searches for the document with the desired ID.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用代码`e：= persistence.Event{}`创建了一个空的事件对象`e`。然后我们使用`s.DB（DB）.C（EVENTS）`来访问MongoDB中的事件集合。有一个名为`FindId（）`的方法，它由`*mgoCollection`对象支持`mgo`。该方法以`bson.ObjectId`类型的对象作为参数，然后搜索具有所需ID的文档。
- en: '`FindId()` returns an object of the `*mgo.Query` type, which is a common type
    in `mgo` that we can use to retrieve results of queries. In order to feed the
    retrieved document data to the `e` object we created earlier, we will need to
    call the `One()` method, which belongs to the `*mgo.Query` type, and pass a reference
    to `e` as an argument. By doing this, `e` will obtain the data of the retrieved
    document with the desired ID. If the operation fails, the `One()` method will
    return an error object containing the error information, otherwise `One()` will
    return nil.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindId（）`返回`*mgo.Query`类型的对象，这是`mgo`中的常见类型，我们可以使用它来检索查询的结果。为了将检索到的文档数据提供给我们之前创建的`e`对象，我们需要调用`One（）`方法，该方法属于`*mgo.Query`类型，并将`e`的引用作为参数传递。通过这样做，`e`将获得所需ID的检索文档的数据。如果操作失败，`One（）`方法将返回包含错误信息的错误对象，否则`One（）`将返回nil。'
- en: At the end of the `FindEvent()` method, we will return the event object and
    the error object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FindEvent（）`方法的末尾，我们将返回事件对象和错误对象。
- en: 'Now, let''s look at the implementation of the `FindEventByName()` method, which
    retrieves an event by its name from the MongoDB database. Here is what the code
    looks like:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`FindEventByName（）`方法的实现，该方法从MongoDB数据库中根据名称检索事件。代码如下所示：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The method is very similar to the `FindEvent()` method, except for two things.
    The first difference is the fact that `FindEvent()` takes a string as an argument,
    which represents the event name that we would like to find.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法与`FindEvent（）`方法非常相似，除了两个方面。第一个区别是`FindEvent（）`需要一个字符串作为参数，该字符串表示我们想要查找的事件名称。
- en: 'The second difference is that we query for an event name instead of an event
    ID. The code line where we query the document uses a method called `Find()` instead
    of `FindId()`, which makes the code look like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是我们查询事件名称而不是事件ID。我们查询文档的代码行使用了一个名为`Find（）`的方法，而不是`FindId（）`，这使得代码看起来像这样：
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Find()` method takes an argument that represents the query we would like
    to pass along to MongoDB. The `bson` package provides a nice type called `bson.M`,
    which is basically a map we can use to represent the query parameters that we
    would like to look for. In our case, we are looking for the name that got passed
    as an argument to `FindEventByName`. The name field in the event collection in
    our database is simply coded as `name`, whereas the variable that got passed to
    us as an argument and has the name is called `name`. Hence, our query ends up
    as `bson.M{"name":name}`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Find（）`方法接受一个表示我们想要传递给MongoDB的查询的参数。`bson`包提供了一个很好的类型叫做`bson.M`，它基本上是一个我们可以用来表示我们想要查找的查询参数的映射。在我们的情况下，我们正在寻找传递给`FindEventByName`的名称。我们数据库中事件集合中的名称字段简单地编码为`name`，而传递给我们的参数并具有名称的变量称为`name`。因此，我们的查询最终变为`bson.M{"name":name}`。'
- en: 'Last but not least is our `FindAllAvailableEvents()` method. The method returns
    all available events in our database. In other words, it returns the entire events
    collection from our MongoDB database. Here is what the code looks like:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是我们的`FindAllAvailableEvents（）`方法。该方法返回我们数据库中所有可用的事件。换句话说，它从我们的MongoDB数据库返回整个事件集合。代码如下所示：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code is almost the same as `FindEventByName()`, except for three simple
    differences. The first difference is obviously the fact that `FindAllAvailableEvents()`
    doesn't take any arguments.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与`FindEventByName（）`几乎相同，除了三个简单的区别。第一个区别显然是`FindAllAvailableEvents（）`不需要任何参数。
- en: The second difference is the fact that we need the query results to be fed to
    a slice of the event's objects instead of a single event object. This is why the
    return type is `[]persistence.Event` , instead of just `persistence.Event`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是我们需要将查询结果提供给事件对象的切片，而不是单个事件对象。这就是为什么返回类型是`[]persistence.Event`，而不仅仅是`persistence.Event`。
- en: 'The third difference is that the `Find()` method will take an argument of nil
    instead of a `bson.M` object. This will cause the code to look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个区别是`Find（）`方法将采用nil作为参数，而不是`bson.M`对象。这将导致代码如下所示：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the `Find()` method gets a nil argument, it will return everything found
    in the associated MongoDB collection. Also, note that we used `All()` instead
    of `One()` after `Find()`. That is because we expect multiple results and not
    just one.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Find（）`方法得到一个nil参数时，它将返回与关联的MongoDB集合中找到的一切。还要注意的是，在`Find（）`之后我们使用了`All（）`而不是`One（）`。这是因为我们期望多个结果而不仅仅是一个。
- en: With this, we finish covering our persistence layer.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们完成了对持久层的覆盖。
- en: Implementing our RESTful APIs handler functions
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的RESTful API处理程序函数
- en: 'So, now that have covered our persistence layer, it''s time to return to our
    RESTful API handlers and cover their implementation. Earlier in this chapter,
    we defined the `eventServiceHandler` struct type to look like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经覆盖了我们的持久层，现在是时候返回我们的RESTful API处理程序并覆盖它们的实现了。在本章的前面，我们定义了`eventServiceHandler`结构类型如下：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `eventServiceHandler` type now needs to support the `DatabaseHandler` interface
    type we created earlier in the chapter in order to be capable of performing database
    operations. This will make the struct look like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`eventServiceHandler`类型现在需要支持我们在本章前面创建的`DatabaseHandler`接口类型，以便能够执行数据库操作。这将使结构看起来像这样：'
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we will need to write a constructor to initialize the `eventServiceHandler`
    object; it will look as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一个构造函数来初始化`eventServiceHandler`对象；它将如下所示：
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, we left the three methods of the `eventServiceHandler` struct type
    empty. Let's go through them one by one.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将`eventServiceHandler`结构类型的三种方法留空。让我们逐一进行。
- en: 'The first method `findEventHandler()` is responsible for handling HTTP requests
    used to query events stored in our database. We can query events via their IDs
    or names. As mentioned earlier in the chapter, when searching for an ID, the request
    URL will resemble `/events/id/3434` and will be of the `GET` type. On the other
    hand, when searching by name, the request will resemble `/events/name/jazz_concert`
    and be of the `GET` type. As a reminder, the following is how we defined the path
    and linked it to the handler:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法`findEventHandler()`负责处理用于查询存储在我们的数据库中的事件的HTTP请求。我们可以通过它们的ID或名称查询事件。如本章前面提到的，当搜索ID时，请求URL将类似于`/events/id/3434`，并且将是`GET`类型。另一方面，当按名称搜索时，请求将类似于`/events/name/jazz_concert`，并且将是`GET`类型。作为提醒，以下是我们如何定义路径并将其链接到处理程序的方式：
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`{SearchCriteria}` and `{Search}` are two variables in our path. `{SearchCriteria}`
    can be replaced with `id` or `name`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`{SearchCriteria}`和`{Search}`是我们路径中的两个变量。`{SearchCriteria}`可以替换为`id`或`name`。'
- en: 'Here is what the code for the `findEventHandler` method will look like:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`findEventHandler`方法的代码：
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The method takes two arguments: an object of the `http.ResponseWriter` type, which
    represents the HTTP response we need to fill, whereas the second argument is of
    the `*http.Request` type, which represents the HTTP request that we received.
    In the first line, we use `mux.Vars()` with the request object as an argument;
    this will return a map of keys and values, which will represent our request URL
    variables and their values. So, for example, if the request URL looks like `/events/name/jazz_concert`,
    we will have two key-value pairs in our resulting map—the first key is `"SearchCriteria"`
    with a value of `"name"`, whereas the second key is `"search"` with a value of
    `jazz_concert`. The resulting map is stored in the vars variable.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受两个参数：`http.ResponseWriter`类型的对象，表示我们需要填充的HTTP响应，而第二个参数是`*http.Request`类型，表示我们收到的HTTP请求。在第一行，我们使用`mux.Vars()`和请求对象作为参数；这将返回一个键值对的地图，它将表示我们的请求URL变量及其值。因此，例如，如果请求URL看起来像`/events/name/jazz_concert`，我们将在我们的结果地图中有两个键值对——第一个键是`"SearchCriteria"`，值为`"name"`，而第二个键是`"search"`，值为`jazz_concert`。结果地图存储在vars变量中。
- en: 'We then obtain the criteria from our map in the next line:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在下一行从我们的地图中获取标准：
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So, the criteria variable will now have either `name` or `id` if the user sent
    the correct request URL. The `ok` variable is of the boolean type; if `ok` is
    true, then we will find a key called `SearchCriteria` in our `vars` map. If it
    is false, then we know that the request URL we received is not valid.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果用户发送了正确的请求URL，标准变量现在将是`name`或`id`。`ok`变量是布尔类型；如果`ok`为true，则我们将在我们的`vars`地图中找到一个名为`SearchCriteria`的键。如果为false，则我们知道我们收到的请求URL无效。
- en: 'Next, we check whether we retrieved the search criteria; if we didn''t, then
    we report the error and then exit. Notice here how we report the error in a JSON
    like format? That is because it is typically preferred for RESTful APIs with JSON
    body formats to return everything in JSON form, including errors. Another way
    to do this is to create a JSONError type and feed it our error strings; however,
    I will just spell out the JSON string here in the code for simplicity:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否检索到搜索标准；如果没有，我们报告错误然后退出。请注意这里我们如何以类似JSON的格式报告错误？这是因为通常首选使用JSON格式的RESTful
    API返回所有内容，包括错误。另一种方法是创建一个JSONError类型并将其设置为我们的错误字符串；但是，为简单起见，我将在这里的代码中明确说明JSON字符串。
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`fmt.Fprint` allows us to write the error message directly to the `w` variable,
    which contains our HTTP response writer. The `http.responseWriter` object type
    supports Go''s `io.Writer` interface, which can be used with `fmt.Fprint()`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Fprint`允许我们直接将错误消息写入包含我们的HTTP响应写入器的`w`变量。`http.responseWriter`对象类型支持Go的`io.Writer`接口，可以与`fmt.Fprint()`一起使用。'
- en: 'Now, we will need to do the same with the `{search}` variable:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对`{search}`变量做同样的处理：
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It''s time to extract the information from the database based on the provided
    request URL variables; here is how we do it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候根据提供的请求URL变量从数据库中提取信息了；这是我们的做法：
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In case of the name search criteria, we will use the `FindEventByName()` database
    handler method to search by name. In case of the ID search criteria, we will convert
    the search key to a slice of bytes using `hex.DecodeString()`—if we successfully
    obtain the slice of bytes, we will call `FindEvent()` with the obtained ID.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称搜索标准的情况下，我们将使用`FindEventByName()`数据库处理程序方法按名称搜索。在ID搜索标准的情况下，我们将使用`hex.DecodeString()`将搜索键转换为字节片——如果我们成功获得字节片，我们将使用获得的ID调用`FindEvent()`。
- en: 'We then check whether any errors occurred during the database operations by
    checking the err object. If we find errors, we write a `404` error header in our
    response, then print the error in the HTTP response body:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过检查err对象来检查数据库操作期间是否发生了任何错误。如果我们发现错误，我们在我们的响应中写入一个`404`错误头，然后在HTTP响应正文中打印错误：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last thing we need to do is to convert the response to a JSON format, so
    we change the HTTP `content-type` header to `application/json`; then, we use the
    powerful Go JSON package to convert the results obtained from our database calls
    to the JSON format:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是将响应转换为JSON格式，因此我们将HTTP`content-type`头更改为`application/json`；然后，我们使用强大的Go
    JSON包将从我们的数据库调用中获得的结果转换为JSON格式：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s look at the code for the `allEventHandler()` method, which will
    return all the available events in the HTTP response:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`allEventHandler()`方法的代码，该方法将返回HTTP响应中所有可用的事件：
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We start by calling the `FindAllAvailableEvents()` that belongs to the database
    handler in order to obtain all events from the database. We then check whether
    any errors occurred. If any found, we write an error header, print the error to
    the HTTP response, and then return from the function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用数据库处理程序的`FindAllAvailableEvents()`来获取数据库中的所有事件。然后检查是否发生了任何错误。如果发现任何错误，我们将写入错误头，将错误打印到HTTP响应中，然后从函数中返回。
- en: If no errors have occurred, we write `application/json` to the `Content-Type` header
    of the HTTP response. We then encode the events to the JSON format and send them
    to the HTTP response writer object. Again, if any errors occur, we will log them
    and then exit.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生错误，我们将`application/json`写入HTTP响应的`Content-Type`头。然后将事件编码为JSON格式并发送到HTTP响应写入器对象。同样，如果发生任何错误，我们将记录它们然后退出。
- en: 'Now, let''s discuss the `newEventHandler()` handler method, which will add
    a new event to our database using the data retrieved from incoming HTTP requests.
    We expect the event data in the incoming HTTP request to be in the JSON format.
    Here is what the code will look like:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论`newEventHandler()`处理程序方法，它将使用从传入的HTTP请求中检索到的数据向我们的数据库添加一个新事件。我们期望传入的HTTP请求中的事件数据以JSON格式存在。代码如下所示：
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the first line, we create a new object of the `persistence.Event` type, which
    we will use to hold the data we are expecting to parse out from the incoming HTTP
    request.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了一个`persistence.Event`类型的新对象，我们将使用它来保存我们期望从传入的HTTP请求中解析出的数据。
- en: 'In the second line, we use Go''s JSON package to take the body of the incoming
    HTTP request (which we obtain by calling `r.Body`). We then decode the JSON data
    embedded in it and feed it to the new event object, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们使用Go的JSON包获取传入HTTP请求的主体（通过调用`r.Body`获得）。然后解码其中嵌入的JSON数据，并将其传递给新的事件对象，如下所示：
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We then check our errors as usual. If no errors are observed, we call the `AddEvent()`
    method of our database handler and pass the event object as the argument. This
    in effect will add the event object we obtained from the incoming HTTP request
    to the database. We then check errors again as usual and exit.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像往常一样检查我们的错误。如果没有观察到错误，我们调用数据库处理程序的`AddEvent()`方法，并将事件对象作为参数传递。这实际上将把我们从传入的HTTP请求中获取的事件对象添加到数据库中。然后像往常一样再次检查错误并退出。
- en: 'To put the final touches on our events microservice, we will need to do three
    things. The first is to allow the `ServeAPI()` function we covered earlier in
    this chapter, which define the HTTP routes and handlers, to call the `eventServiceHandler`
    constructor. The code will end up looking like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的事件微服务的最后要点，我们需要做三件事。第一件是允许我们在本章前面介绍的`ServeAPI()`函数调用`eventServiceHandler`构造函数，该函数定义了HTTP路由和处理程序。代码最终将如下所示：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The second final touch we need to do is to write a configuration layer for
    our microservice. As mentioned earlier in the chapter, a well-designed microservice
    needs a configuration layer which reads from a file, a database, an environmental
    variable, or a similar medium. There are three main parameters we need to support
    for now for our configuration—the database type used by our microservice (MongoDB
    is our default), the database connection string (default is `mongodb://127.0.0.1`
    for a local connection), and the Restful API endpoint. Here is what our configuration
    layer will end up looking like:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第二个最后要点是为我们的微服务编写一个配置层。如本章前面提到的，一个设计良好的微服务需要一个配置层，它可以从文件、数据库、环境变量或类似的介质中读取。目前，我们需要支持我们的配置层的三个主要参数——我们微服务使用的数据库类型（MongoDB是我们的默认值）、数据库连接字符串（本地连接的默认值是`mongodb://127.0.0.1`）和Restful
    API端点。我们的配置层最终将如下所示：
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The third touch is to build a database layer package that acts as the gateway
    to the persistence layer in our microservice. The package will utilize the factory
    design pattern by implementing a factory function. A factory function will manufacture
    our database handler.  This is done by taking the name of the database that we
    would like to connect to, as well as the connection string, then returning a database
    handler object which we can use for database related tasks from this point forward.
    We currently only support MongoDB, so here is how this would look like:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个要点是构建一个数据库层包，作为我们微服务中持久层的入口。该包将利用工厂设计模式，通过实现一个工厂函数来制造我们的数据库处理程序。工厂函数将制造我们的数据库处理程序。这是通过获取我们想要连接的数据库的名称和连接字符串，然后返回一个数据库处理程序对象，从此时起我们可以使用它来处理数据库相关的任务。目前我们只支持MongoDB，所以代码如下：
- en: '[PRE41]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The fourth and final touch is our `main` package. We will write the main function
    that makes use of the `flag` package to take the location of the configuration
    file from the user and then use the configuration file to initialize the database
    connection and the HTTP server. The following is the resultant code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个也是最后一个要点是我们的`main`包。我们将编写主函数，利用`flag`包从用户那里获取配置文件的位置，然后使用配置文件初始化数据库连接和HTTP服务器。以下是生成的代码：
- en: '[PRE42]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this piece of code, we come to the conclusion of this chapter. In the next
    chapter, we will discuss how to secure our microservice.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们结束了本章。在下一章中，我们将讨论如何保护我们的微服务。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a wide range of topics regarding designing and building
    modern microservices. You now should have practical knowledge regarding RESTful
    web APIs, NoSQL data stores like MongoDB, and proper Go design patterns for scalable
    code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了关于设计和构建现代微服务的广泛主题。现在，您应该对RESTful Web API、像MongoDB这样的NoSQL数据存储以及用于可扩展代码的适当Go设计模式有实际的知识。
