["```go\nopenssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365\n```", "```go\ngo run %GOROOT%/src/crypto/tls/generate_cert.go --host=localhost\n```", "```go\n http.ListenAndServe(endpoint, r)\n```", "```go\nr := mux.NewRouter()\n```", "```go\nhttp.ListenAndServeTLS(endpoint, \"cert.pem\", \"key.pem\", r)\n```", "```go\nhttp.ListenAndServeTLS(tlsendpoint, \"cert.pem\", \"key.pem\", r)\n\n```", "```go\ngo http.ListenAndServe(endpoint,r)\nhttp.ListenAndServeTLS(tlsendpoint, \"cert.pem\", \"key.pem\", r)\n```", "```go\nhttpErrChan := make(chan error) \nhttptlsErrChan := make(chan error) \ngo func() { httptlsErrChan <- http.ListenAndServeTLS(tlsendpoint, \"cert.pem\", \"key.pem\", r) }() \ngo func() { httpErrChan <- http.ListenAndServe(endpoint, r) }()\n\n```", "```go\nfunc ServeAPI(endpoint, tlsendpoint string, databasehandler persistence.DatabaseHandler) (chan error, chan error) { \n   handler := newEventHandler(databaseHandler)\n    r := mux.NewRouter() \n    eventsrouter := r.PathPrefix(\"/events\").Subrouter()     eventsrouter.Methods(\"GET\").Path(\"/{SearchCriteria}/{search}\").HandlerFunc(handler.FindEventHandler) eventsrouter.Methods(\"GET\").Path(\"\").HandlerFunc(handler.AllEventHandler) eventsrouter.Methods(\"POST\").Path(\"\").HandlerFunc(handler.NewEventHandler) \n    httpErrChan := make(chan error) \n    httptlsErrChan := make(chan error) \n    go func() { httptlsErrChan <- http.ListenAndServeTLS(tlsendpoint, \"cert.pem\", \"key.pem\", r) }() \n    go func() { httpErrChan <- http.ListenAndServe(endpoint, r) }() \n    return httpErrChan, httptlsErrChan\n} \n```", "```go\n//RESTful API start \nhttpErrChan, httptlsErrChan := rest.ServeAPI(config.RestfulEndpoint, config.RestfulTLSEndPint, dbhandler) \nselect { \ncase err := <-httpErrChan: \n     log.Fatal(\"HTTP Error: \", err) \ncase err := <-httptlsErrChan: \n     log.Fatal(\"HTTPS Error: \", err) \n}\n```", "```go\npackage configuration\n\nimport ( \n         \"encoding/json\" \"fmt\" \n         \"gocloudprogramming/chapter3/myevents/src/lib/persistence/dblayer\" \n         \"os\"\n       )\n\nvar ( \n      DBTypeDefault       = dblayer.DBTYPE(\"mongodb\") \n      DBConnectionDefault = \"mongodb://127.0.0.1\" \n      RestfulEPDefault    = \"localhost:8181\" \n      RestfulTLSEPDefault = \"localhost:9191\"\n    )\n\ntype ServiceConfig struct { \n     Databasetype      dblayer.DBTYPE `json:\"databasetype\"` \n     DBConnection      string         `json:\"dbconnection\"` \n     RestfulEndpoint   string         `json:\"restfulapi_endpoint\"` \n     RestfulTLSEndPint string         `json:\"restfulapi-tlsendpoint\"`\n}\n\nfunc ExtractConfiguration(filename string) (ServiceConfig, error) { \n   conf := ServiceConfig{ \n               DBTypeDefault, \n               DBConnectionDefault, \n               RestfulEPDefault, \n               RestfulTLSEPDefault, \n              }\n   file, err := os.Open(filename) \n   if err != nil { \n       fmt.Println(\"Configuration file not found. Continuing with default values.\") \n       return conf, err \n    }\n   err = json.NewDecoder(file).Decode(&conf) \n   return conf, err\n}\n```"]