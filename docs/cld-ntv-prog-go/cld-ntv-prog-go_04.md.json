["```go\n$ docker run --detach \\ \n    --name rabbitmq \\ \n    -p 5672:5672 \\ \n    -p 15672:15672 \\ \n    rabbitmq:3-management \n```", "```go\n$ echo 'deb http://www.rabbitmq.com/debian/ testing main' | \\ \n    sudo tee /etc/apt/sources.list.d/rabbitmq.list \n$ wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | \\ \n    sudo apt-key add - \n$ apt-get update \n$ apt-get install -y rabbitmq-server \n```", "```go\n$ rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc \n$ yum install rabbitmq-server-3.6.6-1.noarch.rpm \n```", "```go\n$ go get -u github.com/streadway/amqp\n```", "```go\nimport \"github.com/streadway/amqp\" \n\nfunc main() { \n  connection, err := amqp.Dial(\"amqp://guest:guest@localhost:5672\") \n  if err != nil { \n    panic(\"could not establish AMQP connection: \" + err.Error()) \n  } \n\n  defer connection.Close() \n} \n```", "```go\nimport \"github.com/streadway/amqp\" \nimport \"os\" \n\nfunc main() { \n  amqpURL := os.Getenv(\"AMQP_URL\"); \n  if amqpURL == \"\" { \n    amqpURL = \"amqp://guest:guest@localhost:5672\" \n  } \n\n  connection, err := amqp.Dial(amqpURL) \n  // ... \n} \n```", "```go\nconnection, err := amqp.Dial(amqpURL) \nif err != nil { \n  panic(\"could not establish AMQP connection: \" + err.Error()) \n} \n\nchannel, err := connection.Channel() \nif err != nil { \n  panic(\"could not open channel: \" + err.Error()) \n} \n```", "```go\nerr = channel.ExchangeDeclare(\"events\", \"topic\", true, false, false, false, nil) \nif err != nil { \n  panic(err) \n} \n```", "```go\nmessage := amqp.Publishing { \n  Body: []byte(\"Hello World\"),\n} \n```", "```go\nerr = channel.Publish(\"events\", \"some-routing-key\", false, false, message) \nif err != nil { \n  panic(\"error while publishing message: \" + err.Error()) \n} \n```", "```go\n_, err = channel.QueueDeclare(\"my_queue\", true, false, false, false, nil) \nif err != nil { \n  panic(\"error while declaring the queue: \" + err.Error()) \n} \n\nerr = channel.QueueBind(\"my_queue\", \"#\", \"events\", false, nil) \nif err != nil { \n  panic(\"error while binding the queue: \" + err.Error())\n} \n```", "```go\nmsgs, err := channel.Consume(\"my_queue\", \"\", false, false, false, false, nil) \nif err != nil { \n  panic(\"error while consuming the queue: \" + err.Error()) \n} \n```", "```go\nfor msg := range msgs { \n  fmt.Println(\"message received: \" + string(msg.Body)) \n  msg.Ack(false) \n} \n```", "```go\npackage contracts \n\nimport \"time\" \n\ntype EventCreatedEvent struct { \n  ID         string    `json:\"id\"` \n  Name       string    `json:\"id\"` \n  LocationID string    `json:\"id\"` \n  Start      time.Time `json:\"start_time\"` \n  End        time.Time `json:\"end_time\"` \n} \n```", "```go\nfunc (e *EventCreatedEvent) EventName() string { \n  return \"event.created\" \n} \n```", "```go\npackage msgqueue \n\ntype Event interface { \n  EventName() string \n} \n```", "```go\npackage msgqueue \n\ntype EventEmitter interface { \n  Emit(event Event) error \n} \n```", "```go\npackage amqp \n\nimport \"github.com/streadway/amqp\" \n\ntype amqpEventEmitter struct { \n  connection *amqp.Connection \n} \n```", "```go\nfunc (a *amqpEventEmitter) setup() error {\n   channel, err := a.connection.Channel()\n   if err != nil {\n     return err\n   }\n\n   defer channel.Close() \n\n  return channel.ExchangeDeclare(\"events\", \"topic\", true, false, false, false, nil) \n } \n```", "```go\nfunc NewAMQPEventEmitter(conn *amqp.Connection) (EventEmitter, error) { \n  emitter := &amqpEventEmitter{ \n    connection: conn, \n  } \n\n  err := emitter.setup()\n   if err != nil { \n    return nil, err \n  } \n\n  return emitter, nil \n} \n```", "```go\nimport \"encoding/json\"\n\n // ...\n\n func (a *amqpEventEmitter) Emit(event Event) error { \n  jsonDoc, err := json.Marshal(event) \n  if err != nil { \n    return err \n  } \n} \n```", "```go\nfunc (a *amqpEventEmitter) Emit(event Event) error { \n  // ... \n\n  chan, err := a.connection.Channel(); \n  if err != nil { \n    return err \n  } \n\n  defer chan.Close() \n\n  msg := amqp.Publishing{ \n    Headers:     amqpTable{\"x-event-name\": event.EventName()}, \n    Body:        jsonDoc, \n    ContentType: \"application/json\", \n  } \n\n  return chan.Publish( \n    \"events\", \n    event.EventName(), \n    false, \n    false, \n    msg \n  ) \n} \n```", "```go\ntype ServiceConfig struct { \n  // ... \n  AMQPMessageBroker string `json:\"amqp_message_broker\"` \n} \n```", "```go\nfunc ExtractConfiguration(filename string) ServiceConfig { \n  // ... \n\n  json.NewDecoder(file).Decode(&conf) \n  if broker := os.Getenv(\"AMQP_URL\"); broker != \"\" { \n    conf.AMQPMessageBroker = broker \n  } \n\n  return conf \n} \n```", "```go\npackage main \n\n// ... \nimport \"github.com/streadway/amqp\" \nimport msgqueue_amqp \"todo.com/myevents/lib/msgqueue/amqp\" \n\nfunc main() { \n  // ... \n\n  config := configuration.ExtractConfiguration(*confPath) \n  conn, err := amqp.Dial(config.AMQPMessageBroker) \n  if err != nil { \n    panic(err) \n  } \n\n  emitter, err := msgqueue_amqp.NewAMQPEventEmitter(conn) \n  if err != nil { \n    panic(err) \n  } \n\n  // ... \n} \n```", "```go\nfunc ServeAPI(endpoint string, dbHandler persistence.DatabaseHandler, eventEmitter msgqueue.EventEmitter) error { \n  handler := newEventHandler(dbHandler, eventEmitter) \n  // ... \n} \n```", "```go\ntype eventServiceHandler struct { \n  dbhandler persistence.DatabaseHandler \n  eventEmitter msgqueue.EventEmitter \n} \n\nfunc newEventHandler(dbhandler persistence.DatabaseHandler, eventEmitter msgqueue.EventEmitter) *eventServiceHandler { \n  return &eventServiceHandler{ \n    dbhandler: dbhandler, \n    eventEmitter: eventEmitter, \n  } \n} \n```", "```go\nfunc (eh *eventServiceHandler) newEventHandler(w http.ResponseWriter, r *http.Request) { \n  id, err := eh.dbhandler.AddEvent(event) \n  if err != nil { \n    // ... \n  } \n\n  msg := contracts.EventCreatedEvent{ \n    ID: hex.EncodeToString(id), \n    Name: event.Name, \n    LocationID: event.Location.ID, \n    Start: time.Unix(event.StartDate, 0), \n    End: time.Unix(event.EndDate, 0), \n  } \n  eh.eventEmitter.emit(&msg) \n\n  // ... \n} \n```", "```go\npackage msgqueue \n\ntype EventListener interface { \n  Listen(eventNames ...string) (<-chan Event, <-chan error, error) \n} \n```", "```go\npackage amqp \n\nimport \"github.com/streadway/amqp\" \n\ntype amqpEventListener struct { \n  connection *amqp.Connection \n  queue      string \n} \n```", "```go\nfunc (a *ampqEventListener) setup() error { \n  channel, err := a.connection.Channel() \n  if err != nil { \n    return nil \n  } \n\n  defer channel.Close() \n\n  _, err := channel.QueueDeclare(a.queue, true, false, false, false, nil) \n  return err \n} \n```", "```go\nfunc NewAMQPEventListener(conn *amqp.Connection, queue string) (msgqueue.EventListener, error) { \n  listener := &amqpEventListener{ \n    connection: conn, \n    queue:      queue, \n  } \n\n  err := listener.setup() \n  if err != nil { \n    return nil, err \n  } \n\n  return listener, nil \n} \n```", "```go\nfunc (a *amqpEventListener) Listen(eventNames ...string) (<-chan msgqueue.Event, <-chan error, error) { \n  channel, err := a.connection.Channel() \n  if err != nil { \n    return nil, nil, err \n  } \n\n  defer channel.Close() \n\n  for _, eventName := range eventNames { \n    if err := channel.QueueBind(a.queue, eventName, \"events\", false, nil); err != nil { \n      return nil, nil, err \n    } \n  } \n} \n```", "```go\nfunc (a *amqpEventListener) Listen(eventNames ...string) (<-chan msgqueue.Event, <-chan error, error) { \n  // ... \n\n  msgs, err := channel.Consume(a.queue, \"\", false, false, false, false, nil) \n  if err != nil { \n    return nil, nil, err \n  } \n} \n```", "```go\nfunc (a *amqpEventListener) Listen(eventNames ...string) (<-chan msgqueue.Event, <-chan error, error) { \n  // ... \n\n  events := make(chan msgqueue.Event) \n  errors := make(errors) \n\n  go func() { \n    for msg := range msgs { \n      // todo: Map message to actual event struct \n    } \n  }() \n\n  return events, errors, nil \n} \n```", "```go\nrawEventName, ok := msg.Headers[\"x-event-name\"] \nif !ok { \n  errors <- fmt.Errorf(\"msg did not contain x-event-name header\") \n  msg.Nack(false) \n  continue \n} \n\neventName, ok := rawEventName.(string) \nif !ok { \n  errors <- fmt.Errorf( \n    \"x-event-name header is not string, but %t\", \n    rawEventName \n  ) \n  msg.Nack(false) \n  continue \n} \n```", "```go\nvar event msgqueue.Event \n\nswitch eventName { \n  case \"event.created\": \n    event = new(contracts.EventCreatedEvent) \n  default: \n    errors <- fmt.Errorf(\"event type %s is unknown\", eventName) \n    continue \n} \n\nerr := json.Unmarshal(msg.Body, event) \nif err != nil { \n  errors <- err \n  continue \n} \n\nevents <- event \n```", "```go\npackage main \n\nimport \"github.com/streadway/amqp\" \nimport \"todo.com/myevents/lib/configuration\" \nimport msgqueue_amqp \"todo.com/myevents/lib/msgqueue/amqp\" \nimport \"flag\" \n\nfunc main() { \n  confPath := flag.String(\"config\", \"./configuration/config.json\", \"path to config file\") \n  flag.Parse() \n  config := configuration.ExtractConfiguration(*confPath) \n\n  dblayer, err := dblayer.NewPersistenceLayer(config.Databasetype, config.DBConnection) \n  if err != nil { \n    panic(err) \n  } \n\n  conn, err := amqp.Dial(config.AMQPMessageBroker) \n  if err != nil { \n    panic(err) \n  } \n\n  eventListener, err := msgqueue_amqp.NewAMQPEventListener(conn) \n  if err != nil { \n    panic(err) \n  } \n} \n```", "```go\npackage listener \n\nimport \"log\" \nimport \"todo.com/myevents/lib/msgqueue\" \nimport \"todo.com/myevents/lib/persistence\" \nimport \"gopkg.in/mgo.v2/bson\" \n\ntype EventProcessor struct { \n  EventListener msgqueue.EventListener \n  Database      persistence.DatabaseHandler \n} \n\nfunc (p *EventProcessor) ProcessEvents() error { \n  log.Println(\"Listening to events...\") \n\n  received, errors, err := p.EventListener.Listen(\"event.created\") \n  if err != nil { \n    return err \n  } \n\n  for { \n    select { \n      case evt := <-received: \n        p.handleEvent(evt) \n      case err = <-errors: \n        log.Printf(\"received error while processing msg: %s\", err) \n    } \n  } \n} \n```", "```go\nfunc (p *EventProcessor) handleEvent(event msgqueue.Event) { \n  switch e := event.(type) { \n    case *contracts.EventCreatedEvent: \n      log.Printf(\"event %s created: %s\", e.ID, e) \n      p.Database.AddEvent(persistence.Event{ID: bson.ObjectId(e.ID)}) \n    case *contracts.LocationCreatedEvent: \n      log.Printf(\"location %s created: %s\", e.ID, e) \n      p.Database.AddLocation(persistence.Location{ID: bson.ObjectId(e.ID)}) \n    default: \n      log.Printf(\"unknown event: %t\", e) \n  } \n} \n```", "```go\nfunc main() { \n  // ... \n\n  eventListener, err := msgqueue_amqp.NewAMQPEventListener(conn) \n  if err != nil { \n    panic(err) \n  } \n\n  processor := &listener.EventProcessor{eventListener, dblayer} \n  processor.ProcessEvents() \n} \n```", "```go\nfunc main() { \n  // ... \n\n  processor := &listener.EventProcessor{eventListener, dblayer} \n  go processor.ProcessEvents() \n\n  rest.ServeAPI(config.RestfulEndpoint, dbhandler, eventEmitter) \n} \n```", "```go\n$ docker run -d --name kafka -p 9092:9092 spotify/kafka\n```", "```go\n$ go get github.com/Shopify/sarama\n```", "```go\nimport \"github.com/Shopify/sarama\" \n\nfunc main() { \n  config := sarama.NewConfig() \n  brokers := []string{\"localhost:9092\"} \n  client, err := sarama.NewClient(brokers, config) \n\n  if err != nil { \n    panic(err) \n  } \n} \n```", "```go\nfunc main() { \n  brokerList := os.Getenv(\"KAFKA_BROKERS\") \n  if brokerList == \"\" { \n    brokerList = \"localhost:9092\" \n  } \n\n  brokers := strings.Split(brokerList, \",\") \n  config := sarama.NewConfig() \n\n  client, err := sarama.NewClient(brokers, config) \n  // ... \n} \n```", "```go\nproducer, err := sarama.NewSyncProducerFromClient(client) \nif err != nil { \n  panic(err) \n} \n```", "```go\npackage kafka \n\ntype kafkaEventEmitter struct { \n  producer sarama.SyncProducer \n} \n```", "```go\nfunc NewKafkaEventEmitter(client sarama.Client) (msgqueue.EventEmitter, error) { \n  producer, err := sarama.NewSyncProducerFromClient(client) \n  if err != nil { \n    return nil, err \n  } \n\n  emitter := &kafkaEventEmitter{ \n    producer: producer, \n  } \n\n  return emitter, nil \n} \n```", "```go\nfunc (e *kafkaEventEmitter) Emit(event msgqueue.Event) error { \n  jsonBody, err := json.Marshal(event) \n  if err != nil { \n    return err \n  } \n\n  msg := &sarama.ProducerMessage{ \n    Topic: event.EventName(), \n    Value: sarama.ByteEncoder(jsonBody), \n  } \n\n  _, _, err = e.producer.SendMessage(msg) \n  return err \n} \n```", "```go\npackage msgqueue \n\ntype Event interface { \n  EventName() string \n} \n```", "```go\npackage msgqueue \n\ntype Event interface { \n  PartitionKey() string \n  EventName() string \n} \n```", "```go\nfunc (e *EventCreatedEvent) PartitionKey() string { \n  return e.ID \n} \n```", "```go\npackage kafka \n\ntype messageEnvelope struct { \n  EventName string      `json:\"eventName\"` \n  Payload   interface{} `json:\"payload\"` \n} \n```", "```go\nfunc (e *kafkaEventEmitter) Emit(event msgqueue.Event) error { \n  envelope := messageEnvelope{event.EventName(), event} \n  jsonBody, err := json.Marshal(&envelope) \n  // ... \n```", "```go\npackage kafka \n\nimport \"github.com/Shopify/sarama\" \nimport \"todo.com/myevents/lib/msgqueue\" \n\ntype kafkaEventListener struct { \n  consumer   sarama.Consumer \n  partitions []int32 \n} \n```", "```go\nfunc NewKafkaEventListener(client sarama.Client, partitions []int32) (msgqueue.EventListener, error) { \n  consumer, err := sarama.NewConsumerFromClient(client) \n  if err != nil { \n    return nil, err \n  } \n\n  listener := &kafkaEventListener{ \n    consumer: consumer, \n    partitions: partitions, \n  } \n\n  return listener, nil \n} \n```", "```go\nfunc (k *kafkaEventListener) Listen(events ...string) (<-chan msgqueue.Event, <-chan error, error) { \n  var err error \n\n  topic := \"events\" \n  results := make(chan msgqueue.Event) \n  errors := make(chan error) \n} \n```", "```go\nfunc (k *kafkaEventListener) Listen(events ...string) (<-chan msgqueue.Event, <-chan error, error) { \n  var err error \n\n  topic := \"events\" \n  results := make(chan msgqueue.Event) \n  errors := make(chan error) \n\n  partitions := k.partitions \n  if len(partitions) == 0 { \n    partitions, err = k.consumer.partitions(topic) \n    if err != nil { \n      return nil, nil, err \n    } \n  } \n\n  log.Printf(\"topic %s has partitions: %v\", topic, partitions) \n} \n```", "```go\nfunc (k *kafkaEventListener) Listen(events ...string) (<-chan msgqueue.Event, <-chan error, error) { \n  // ... \n\n  log.Printf(\"topic %s has partitions: %v\", topic, partitions) \n\n  for _, partitions := range partitions { \n    con, err := k.consumer.ConsumePartition(topic, partition, 0) \n    if err != nil { \n      return nil, nil, err \n    } \n\n    go func() { \n      for msg := range con.Messages() { \n\n      } \n    }() \n  } \n} \n```", "```go\nfor msg := range con.Messages() { \n  body := messageEnvelope{} \n  err := json.Unmarshal(msg.Value, &body) \n  if err != nil { \n    errors <- fmt.Errorf(\"could not JSON-decode message: %s\", err) \n    continue \n  } \n} \n```", "```go\n$ go get -u github.com/mitchellh/mapstructure\n```", "```go\nfor msg := range con.Messages() { \n  body := messageEnvelope{} \n  err := json.Unmarshal(msg.Value, &body) \n  if err != nil { \n    errors <- fmt.Errorf(\"could not JSON-decode message: %s\", err) \n    continue \n  } \n\n  var event msgqueue.Event \n  switch body.EventName { \n    case \"event.created\": \n      event = contracts.EventCreatedEvent{} \n    case \"location.created\": \n      event = contracts.LocationCreatedEvent{} \n    default: \n      errors <- fmt.Errorf(\"unknown event type: %s\", body.EventName) \n      continue \n  } \n\n  cfg := mapstructure.DecoderConfig{ \n    Result: event, \n    TagName: \"json\", \n  } \n  err = mapstructure.NewDecoder(&cfg).Decode(body.Payload) \n  if err != nil { \n    errors <- fmt.Errorf(\"could not map event %s: %s\", body.EventName, err) \n  } \n} \n```", "```go\nfor msg := range con.Messages() { \n  // ...   \n  err = mapstructure.NewDecoder(&cfg).Decode(body.Payload) \n  if err != nil { \n    errors <- fmt.Errorf(\"could not map event %s: %s\", body.EventName, err) \n  } \n\n  results <- event \n} \n```"]