- en: Deploying Your Application in Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中部署您的应用程序
- en: In the past few chapters, we focused on the actual development of our Go application.
    However, there is more to software engineering than just writing code. Usually,
    you will also need to concern yourself with the question of how you will deploy
    your application into its runtime environment. Especially in microservice architectures,
    where each Service may be built on a completely different technology stack, deployment
    can quickly become a challenge.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们专注于我们的Go应用程序的实际开发。然而，软件工程不仅仅是编写代码。通常情况下，您还需要关注如何将应用程序部署到其运行时环境中的问题。特别是在微服务架构中，每个服务可能构建在完全不同的技术堆栈上，部署很快就会变成一个挑战。
- en: When you are deploying Services that use different technologies (for example,
    when you have Services written in Go, Node.js, and Java), you will need to provide
    an environment in which all these Services can actually be run. Using traditional
    virtual machines or bare-metal servers, this can become quite a hassle. Even though
    modern cloud providers make quickly spawning and disposing VMs easily, maintaining
    an infrastructure for all possible kinds of Services becomes an operational challenge.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当您部署使用不同技术的服务（例如，当您有使用Go、Node.js和Java编写的服务时），您需要提供一个环境，其中所有这些服务实际上可以运行。使用传统虚拟机或裸机服务器，这可能会变得非常麻烦。即使现代云提供商可以快速生成和处理虚拟机，维护所有可能类型服务的基础设施也会成为一个运营挑战。
- en: This is where modern container technologies such asa60;**Docker** or **RKT**
    shine. Using containers, you can package an application with all its dependencies
    into a container image and then use that image to quickly spawn a container running
    your application on any server that can run these containers. The only software
    that needs to run on your servers themselves (be it virtualized or bare-metal)
    is the container runtime environment (typically, Docker or RKT).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是现代容器技术（如**Docker**或**RKT**）的亮点所在。使用容器，您可以将应用程序及其所有依赖项打包到容器映像中，然后使用该映像快速生成在任何可以运行这些容器的服务器上运行您的应用程序的容器。需要在服务器上运行的唯一软件（无论是虚拟化还是裸机）是容器运行时环境（通常是Docker或RKT）。
- en: In this chapter, we will show you how to package the MyEvents application, which
    we built over the last few chapters, in container images and how to deploy these
    images. Since we are thinking big, we will also take a look at cluster managers,
    such as **Kubernetes**, that allows you to deploy containers over many servers
    at once, allowing you to make your application deployment more resilient and scalable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何将我们在过去几章中构建的MyEvents应用程序打包成容器映像，并如何部署这些映像。由于我们的设想很大，我们还将研究诸如**Kubernetes**之类的集群管理器，它允许您一次在许多服务器上部署容器，从而使您的应用程序部署更具弹性和可伸缩性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using Docker to build and run container images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker构建和运行容器映像
- en: Setting up complex multi-container applications with Docker Compose
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose设置复杂的多容器应用程序
- en: Container cloud infrastructures with Kubernetes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes的容器云基础设施
- en: What are containers?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是容器？
- en: Container technologies such as Docker use isolation features offered by modern
    operating systems, such as **namespaces** and **control groups** (**cgroups**)
    in Linux. Using these features allows the operating system to isolate multiple
    running processes from each other to a very large extent. For example, a container
    runtime might provide two processes with two entirely separate filmount namespaces
    or two separate networking stacks using network namespaces. In addition to namespaces,
    cgroups can be used to ensure that each process does not use more than a previously
    allocated amount of resources (such as CPU time, memory or I/O, and network bandwidth).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Docker之类的容器技术使用现代操作系统提供的隔离功能，例如Linux中的**命名空间**和**控制组**（**cgroups**）。使用这些功能允许操作系统在很大程度上隔离多个运行中的进程。例如，容器运行时可能会使用两个完全独立的文件系统命名空间或使用网络命名空间来提供两个完全独立的网络堆栈。除了命名空间，cgroups还可以用于确保每个进程不会使用超过先前分配的资源量（例如CPU时间、内存或I/O和网络带宽）。
- en: In contrast to traditional virtual machines, a container runs completely within
    the operating system of the host environment; there is no virtualized hardware
    and OS running on that. Also, in many container runtimes, you do not even have
    all the typical processes that you will find in a regular operating system. For
    example, a Docker container will typically not have an init process like regular
    Linux systems have; instead, the root process (PID 1) in your container will be
    your application (also, as the container only exists as long as its **PID 1**
    process exists, it will cease to exist as soon as your application exists).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统虚拟机相比，容器完全在主机环境的操作系统中运行；没有虚拟化的硬件和操作系统在其中运行。此外，在许多容器运行时中，您甚至没有在常规操作系统中找到的所有典型进程。例如，Docker容器通常不会像常规Linux系统那样具有init进程；相反，容器中的根进程（PID
    1）将是您的应用程序（此外，由于容器只存在于其**PID 1**进程存在的时间，一旦您的应用程序存在，它就会停止存在）。
- en: Of course, this does not apply to all container runtimes. LXC, for example,
    will give you a complete Linux system within your container (at least the user-space
    part of it), including an init process as PID 1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不适用于所有容器运行时。例如，LXC将在容器中为您提供完整的Linux系统（至少是用户空间的部分），包括PID 1作为init进程。
- en: Most container runtimes also come with a concept of **container images**. These
    contain prepackaged filesystems from which you can spawn new containers. Many
    container-based deployments actually use container images as deployment artifacts,
    in which the actual build artifact (for example, a compiled Go binary, Java application,
    or Node.js app) are packaged together with their runtime dependencies (which are
    not that many for compiled Go binaries; however, for other applications, a container
    image might contain a Java runtime, a Node.js installation, or anything else required
    for the application to work). Having a container image for your applications can
    also help make your application scalable and resilient since it is easy to spawn
    new containers from your application image.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数容器运行时还具有**容器镜像**的概念。这些镜像包含预打包的文件系统，可以从中生成新的容器。许多基于容器的部署实际上使用容器镜像作为部署工件，其中实际的构建工件（例如，编译的Go二进制文件、Java应用程序或Node.js应用程序）与其运行时依赖项一起打包（对于编译的Go二进制文件来说，依赖项并不多；但是对于其他应用程序来说，容器镜像可能包含Java运行时、Node.js安装或应用程序工作所需的其他任何内容）。为您的应用程序拥有一个容器镜像也可以帮助使您的应用程序具有可伸缩性和弹性，因为很容易从您的应用程序镜像中生成新的容器。
- en: Container runtimes such as Docker also tend to treat containers as **immutable**
    (meaning that containers are typically not changed in any way after having been
    started). When deploying your application in containers, the typical way to deploy
    a new version of your application would be to build a new container image (containing
    the updated version of your application), then create a new container from that
    new image and delete the container running the old version of your application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Docker之类的容器运行时还倾向于将容器视为**不可变**（意味着容器通常在启动后不会以任何方式更改）。在容器中部署应用程序时，部署新版本应用程序的典型方式是构建一个新的容器镜像（其中包含更新版本的应用程序），然后从该新镜像创建一个新的容器，并删除运行旧版本应用程序的容器。
- en: Introduction to Docker
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker简介
- en: Currently, the de facto standard for application container runtimes is **Docker**,
    although there are other runtimes, for example, RKT (pronounced rocket). In this
    chapter, we will focus on Docker. However, many container runtimes are interoperable
    and built on common standards. For example, RKT containers can easily be spawned
    from Docker images. This means that even if you decide to deploy your application
    using Docker images, you are not running into a vendor lock-in.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，应用程序容器运行时的事实标准是**Docker**，尽管还有其他运行时，例如RKT（发音为rocket）。在本章中，我们将专注于Docker。但是，许多容器运行时是可互操作的，并建立在共同的标准上。例如，RKT容器可以轻松地从Docker镜像生成。这意味着即使您决定使用Docker镜像部署应用程序，也不会陷入供应商锁定。
- en: Running simple containers
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行简单的容器
- en: We have worked with Docker before in [Chapter 4](0a806398-0654-46f9-8e6f-02af9334821b.xhtml),
    *Asynchronous Microservice Architectures Using Message Queues*, to quickly set
    up RabbitMQ and Kafka message brokers; however, we did not go into details on
    how Docker actually works. We will assume that you already have a working Docker
    installation on your local machine. If not, take a look at the official installation
    instructions to learn how you can install Docker on your operating system: [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在[第4章](0a806398-0654-46f9-8e6f-02af9334821b.xhtml)中使用Docker快速设置了RabbitMQ和Kafka消息代理，但是我们没有详细介绍Docker的工作原理。我们假设您已经在本地机器上安装了可用的Docker。如果没有，请查看官方安装说明，了解如何在您的操作系统上安装Docker：[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)。
- en: 'To test whether your Docker installation is working correctly, try the following
    command on the command line:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的Docker安装是否正常工作，请在命令行上尝试以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command uses the new Docker command structure introduced in Docker
    1.13\. If you are running an older version of Docker, use `docker run` instead
    of `docker container run`. You can test your current Docker version using the
    `docker version` command. Also, note that Docker changed its versioning scheme
    after version 1.13, so the next version after 1.13 will be 17.03.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使用了Docker 1.13中引入的新Docker命令结构。如果您使用的是较旧版本的Docker，请使用`docker run`而不是`docker
    container run`。您可以使用`docker version`命令测试当前的Docker版本。此外，请注意，Docker在1.13版本之后改变了其版本方案，因此1.13之后的下一个版本将是17.03。
- en: 'The Docker run command follows the `docker container run [flags...] [image
    name] [arguments...]` pattern. In this case, `hello-world` is the name of the
    image to run, and the `--rm` flag indicates that the container should be removed
    immediately after it has finished running. When running the preceding command,
    you should receive an output similar to the one in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Docker run命令遵循`docker container run [flags...] [image name] [arguments...]`模式。在这种情况下，`hello-world`是要运行的镜像的名称，`--rm`标志表示容器在完成运行后应立即被删除。运行上述命令时，您应该会收到类似以下截图中的输出：
- en: '![](img/c105a19e-13ea-4866-b495-8bd31540f1b4.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c105a19e-13ea-4866-b495-8bd31540f1b4.png)'
- en: docker container run output
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: docker container run输出
- en: Actually, the `docker run` command did multiple things, here. First of all,
    it detected that the `hello-world` image was not present on the local machine
    and downloaded it from the official Docker image registry (if you run the same
    command again, you will note that the image will not be downloaded since it is
    already present on the local machine).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`docker run`命令在这里做了多件事情。首先，它检测到`hello-world`镜像在本地机器上不存在，并从官方Docker镜像注册表下载了它（如果再次运行相同的命令，您会注意到镜像不会被下载，因为它已经存在于本地机器上）。
- en: It then created a new container from the `hello-world` image that it just downloaded
    and started that container. The container image consists only of a small program
    that prints some text to the command line and then immediately exists.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它从刚刚下载的`hello-world`镜像创建了一个新的容器，并启动了该容器。容器镜像只包含一个小程序，该程序将一些文本打印到命令行，然后立即退出。
- en: Remember that a Docker container has no init system and typically has one process
    running in it. As soon as that process terminates, the container will stop running.
    Since we created the container with the `--rm` flag, the Docker engine will also
    delete the container automatically after it has stopped running.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Docker容器没有init系统，通常只有一个在其中运行的进程。一旦该进程终止，容器将停止运行。由于我们使用`--rm`标志创建了容器，Docker引擎在容器停止运行后也会自动删除容器。
- en: 'Next, let''s do something more complex. Execute the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们做一些更复杂的事情。执行以下命令：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will download the `nginx` image and spawn a new container from
    it. In contrast to the `hello-world` image, this image will run a web server that
    runs for an indefinite time. In order to not block your shell indefinitely, the
    `-d` flag (short for `--detach`) is used to start the new container in the background.
    The `--name` flag is responsible for giving the new container an actual name (if
    omitted, a random name will be generated for the container).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将下载`nginx`镜像并从中生成一个新的容器。与`hello-world`镜像相比，这个镜像将运行一个无限时间的Web服务器。为了不让你的shell无限期地阻塞，使用`-d`标志（代表`--detach`）在后台启动新的容器。`--name`标志负责为新容器指定一个实际的名称（如果省略，容器将生成一个随机名称）。
- en: 'The **NGINX** web server running within the container by default listens on
    TCP port 80\. However, each Docker container has its own separate networking stack,
    so you cannot just access this port by navigating to `http://localhost`. The `-p
    80:80` flag tells the Docker Engine to forward the container''s TCP port 80 to
    localhost''s port 80\. To check whether the container is actually running now,
    run the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在容器中运行的**NGINX** Web服务器监听TCP端口80。然而，每个Docker容器都有自己独立的网络堆栈，所以你不能通过导航到`http://localhost`来访问这个端口。`-p
    80:80`标志告诉Docker引擎将容器的TCP端口80转发到localhost的端口80。要检查容器是否实际在运行，运行以下命令：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command lists all currently running containers, the images from
    which they were created, and their port mappings. You should receive an output
    similar to the one in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令列出了所有当前运行的容器，它们所创建的镜像，以及它们的端口映射。你应该会收到类似以下截图的输出：
- en: '![](img/a55cd8f5-2137-449c-bc44-e91a42579439.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a55cd8f5-2137-449c-bc44-e91a42579439.png)'
- en: docker container ls output
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: docker容器ls输出
- en: When the container is running, you can now access the web server you just started
    via `http://localhost`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器运行时，你现在可以通过`http://localhost`访问你刚刚启动的Web服务器。
- en: Building your own images
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你自己的镜像
- en: Up until now, you have worked with publicly available, premade images from the
    Docker Hub, such as the `nginx` image (or the RabbitMQ and Spotify/Kafka images
    in [Chapter 4](0a806398-0654-46f9-8e6f-02af9334821b.xhtml), *Asynchronous Microservice
    Architectures Using Message Queues*). However, with Docker, it is also easy to
    build your own images. Generally, Docker images are built from a **Dockerfile**.
    A Dockerfile is a kind of a construction manual for new Docker images and describes
    how a Docker image should be built, starting from a given base image. Since it
    rarely makes sense to start with a completely empty filesystem (empty as *in not
    even a shell or standard libraries*), images are often built on distribution images
    that contain the user-space tools of popular Linux distributions. Popular base
    images include U*buntu*, *Debian*, or C*entOS*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经使用了来自Docker Hub的公开可用的预制镜像，比如`nginx`镜像（或者[第4章](0a806398-0654-46f9-8e6f-02af9334821b.xhtml)中的RabbitMQ和Spotify/Kafka镜像，*使用消息队列的异步微服务架构*）。然而，使用Docker，构建自己的镜像也很容易。通常，Docker镜像是从**Dockerfile**构建的。Dockerfile是一种新Docker镜像的构建手册，描述了应该如何从给定的基础镜像构建Docker镜像。由于从完全空的文件系统开始（即*没有shell或标准库*）很少有意义，因此镜像通常是在包含流行Linux发行版用户空间工具的发行版镜像上构建的。流行的基础镜像包括Ubuntu、Debian或CentOS。
- en: 'Let''s build a short example `Dockerfile`. For demonstration purposes, we will
    build our own version of the `hello-world` image. For this, create a new empty
    directory and create a new file named `Dockerfile` with the following contents:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个简短的`Dockerfile`示例。为了演示目的，我们将构建自己版本的`hello-world`镜像。为此，创建一个新的空目录，并创建一个名为`Dockerfile`的新文件，内容如下：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The line starting with `FROM` denotes the base image on which you are building
    your custom image. It always needs to be the first line of a `Dockerfile`. The
    `MAINTAINER` statement contains only metadata.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以`FROM`开头的行表示你正在构建自定义镜像的基础镜像。它总是需要作为`Dockerfile`的第一行。`MAINTAINER`语句只包含元数据。
- en: The `RUN` statement is executed when the container image is being built (meaning
    that the final container image will have a `/hello.txt` file with the contents
    `Hello World` in its filesystem). A `Dockerfile` may contain many such `RUN` statements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`语句在构建容器镜像时执行（这意味着最终容器镜像将在其文件系统中有一个`/hello.txt`文件，内容为`Hello World`）。一个`Dockerfile`可能包含许多这样的`RUN`语句。'
- en: In contrast to that, the `CMD` statement is executed when a container created
    from the image is being run. The command specified here will be the first and
    main process (PID 1) of a container created from the image.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`CMD`语句在从镜像创建的容器运行时执行。这里指定的命令将是从镜像创建的容器的第一个和主要进程（PID 1）。
- en: 'You can build the actual Docker image using the `docker image build` command
    (`docker build` in versions older than 1.13), as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`docker image build`命令（在1.13版本之前的版本中使用`docker build`）来构建实际的Docker镜像，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/cb54a379-ad3a-435c-808a-f90e39cd9075.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb54a379-ad3a-435c-808a-f90e39cd9075.png)'
- en: docker image build output
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: docker镜像构建输出
- en: 'The `-t test-image` flag contains the name that your new image should get.
    After building the image, you can find it using the `docker image ls` command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t test-image`标志包含你的新镜像应该得到的名称。构建完镜像后，你可以使用`docker image ls`命令找到它：'
- en: '![](img/6834320f-4f42-402d-976f-cef8450e908f.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6834320f-4f42-402d-976f-cef8450e908f.png)'
- en: docker image ls output
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: docker镜像ls输出
- en: 'The name specified with `-t` allows you to create and run a new container from
    the preceding image using the already known `docker container run` command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-t`指定的名称允许您使用已知的`docker container run`命令从前面的镜像创建和运行新的容器：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As before, this command will create a new container (this time, from our freshly
    created image), start it (actually, start the command specified by the `CMD` statement
    in the `Dockerfile`), and then remove the container after the command has finished
    (thanks to the `--rm` flag).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，这个命令将创建一个新的容器（这次是从我们新创建的镜像），启动它（实际上是启动`Dockerfile`中`CMD`语句指定的命令），然后在命令完成后删除容器（感谢`--rm`标志）。
- en: Networking containers
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络容器
- en: Often, your application consists of multiple processes that communicate with
    each other (starting from relatively simple cases such as an application server
    talking to a database up to complex microservice architectures). When using containers
    to manage all these processes, you will typically have one container per process.
    In this section, we will take a look at how you can have multiple Docker containers
    communicate with each other over their network interfaces.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您的应用程序由多个相互通信的进程组成（从相对简单的情况，如应用服务器与数据库通信，到复杂的微服务架构）。当使用容器管理所有这些进程时，通常每个进程都有一个容器。在本节中，我们将看看如何让多个Docker容器通过它们的网络接口相互通信。
- en: In order to enable container-to-container communication, Docker offers a network
    management feature. The command line allows you to create new virtual networks
    and then add containers to these virtual networks. Containers within one network
    can communicate with each other and resolve their internal IP addresses via Docker's
    built-in DNS server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现容器之间的通信，Docker提供了网络管理功能。命令行允许您创建新的虚拟网络，然后将容器添加到这些虚拟网络中。同一网络中的容器可以相互通信，并通过Docker内置的DNS服务器解析它们的内部IP地址。
- en: 'Let''s test this by creating a new network with Docker using the `docker network
    create` command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`docker network create`命令在Docker中创建一个新网络来测试一下：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After this, you will be able to see the new network then running `docker network
    ls`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将能够通过运行`docker network ls`来看到新的网络：
- en: '![](img/827535c6-bac6-4153-9588-2900e0d82ac0.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/827535c6-bac6-4153-9588-2900e0d82ac0.png)'
- en: docker network ls output
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: docker网络ls输出
- en: 'After having created a new network, you can attach containers to this network.
    For starters, begin by creating a new container from the `nginx` image and attaching
    it to the test network using the `--network` flag:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个新网络后，您可以将容器连接到这个网络。首先，从`nginx`镜像创建一个新容器，并使用`--network`标志将其附加到测试网络：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, create a new container in the same network. Since we have already started
    a web server, our new container will contain an HTTP client that we will use to
    connect to our new web server (note that we did not bind the container''s HTTP
    port to the localhost using the `-p` flag as we did before). For this, we will
    use the appropriate/curl image. This is an image that basically contains a containerized
    version of the cURL command-line utility. Since our web server container has the
    name web, we can now simply use that name for establishing a network connection:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在相同的网络中创建一个新的容器。由于我们已经启动了一个web服务器，我们的新容器将包含一个HTTP客户端，我们将使用它来连接到我们的新web服务器（请注意，我们没有像之前那样使用`-p`标志将容器的HTTP端口绑定到本地主机）。为此，我们将使用适当的/curl镜像。这是一个基本上包含了cURL命令行实用程序的容器化版本的镜像。由于我们的web服务器容器的名称为web，我们现在可以简单地使用该名称来建立网络连接：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This command will simply print the web server''s index page to the command line:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将简单地将web服务器的索引页面打印到命令行：
- en: '![](img/4dd1c98a-6d10-4638-855e-f7855e635eba.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4dd1c98a-6d10-4638-855e-f7855e635eba.png)'
- en: docker container run output
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: docker容器运行输出
- en: This demonstrates that the cURL container created from the appropriate/curl
    image is able to reach the web container via HTTP. When establishing the connection,
    you can simply use the container's name (in this case, *web*). Docker will automatically
    resolve this name to the container's IP address.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明从适当的/curl镜像创建的cURL容器能够通过HTTP访问web容器。在建立连接时，您可以简单地使用容器的名称（在本例中为*web*）。Docker将自动将此名称解析为容器的IP地址。
- en: Armed with the knowledge of Docker images and networking, you can now get to
    packaging the MyEvents application into container images and running them on Docker.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了Docker镜像和网络的知识，现在可以将MyEvents应用程序打包成容器镜像并在Docker上运行。
- en: Working with volumes
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用卷
- en: An individual Docker container is often very short-lived. Deploying a new version
    of your application may result in a number of containers being deleted and new
    ones being spawned. If your application is running in a cloud environment (we
    will have a look at cloud-based container environments later in this chapter),
    your container may suffer from a node failure and will be re-scheduled on another
    cloud instance. This is completely tolerable for stateless applications (in our
    example, the event service and booking service).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 单个Docker容器通常存活时间很短。部署应用程序的新版本可能会导致删除多个容器并生成新的容器。如果您的应用程序在云环境中运行（我们将在本章后面看到基于云的容器环境），您的容器可能会受到节点故障的影响，并将被重新调度到另一个云实例上。对于无状态应用程序（在我们的示例中，事件服务和预订服务），这是完全可以接受的。
- en: However, this gets difficult for stateful containers (in our example, this would
    be both the message broker and database containers). After all, if you delete
    a MongoDB container and create a new one with a similar configuration, the actual
    data managed by the database will be gone. This is where **volumes** come into
    play.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于有状态的容器（在我们的示例中，这将是消息代理和数据库容器），这变得困难。毕竟，如果您删除一个MongoDB容器，并创建一个具有类似配置的新容器，那么数据库管理的实际数据将会丢失。这就是**卷**发挥作用的地方。
- en: Volumes are Docker's way to make data persist beyond the lifecycle of an individual
    container. They contain files and exist independently of individual containers.
    Each volume can be *mounted* into an arbitrary number of containers, allowing
    you to share files between containers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 卷是Docker使数据持久化超出单个容器生命周期的方式。它们包含文件，独立于单个容器存在。每个卷可以被挂载到任意数量的容器中，允许您在容器之间共享文件。
- en: 'To test this, create a new volume using the `docker volume create` command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，使用`docker volume create`命令创建一个新卷：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will create a new volume named *test*. You can find this volume again
    by using the `docker volume ls` command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为*test*的新卷。您可以使用`docker volume ls`命令再次找到这个卷：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After having created a volume, you can mount it into a container using the
    `-v` flag of the `docker container run` command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个卷后，您可以使用`docker container run`命令的`-v`标志将其挂载到容器中：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command creates a new container that has the test volume mounted into the
    `/my-volume` directory. The container's command will be a bash shell that creates
    a `test.txt` file within this directory. After this, the container will terminate
    and be deleted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建一个新的容器，将测试卷挂载到`/my-volume`目录中。容器的命令将是一个创建`test.txt`文件的bash shell。之后，容器将终止并被删除。
- en: 'To ensure that the files within the volume are still there, you can now mount
    this volume into a second container:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保卷内的文件仍然存在，现在可以将此卷挂载到第二个容器中：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This container will print the `test.txt` file's contents to the command line.
    This demonstrates that the test volume still contains all its data, even though
    the container that initially populated it with data has already been deleted.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该容器将`test.txt`文件的内容打印到命令行。这表明测试卷仍然包含所有数据，即使最初填充数据的容器已经被删除。
- en: Building containers
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器
- en: We will start with building container images for the components of the MyEvents
    application. As of now, our application consists of three components—two backend
    services (event and booking service) and the React frontend application. While
    the frontend application does not contain any kind of backend logic itself, we
    will at least need a web server to deliver this application to the user. This
    makes three container images in total that we need to build. Let's start with
    the backend components.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从构建MyEvents应用程序的组件容器镜像开始。目前，我们的应用程序由三个组件组成——两个后端服务（事件和预订服务）和React前端应用程序。虽然前端应用程序本身不包含任何后端逻辑，但我们至少需要一个Web服务器将此应用程序提供给用户。这总共需要构建三个容器镜像。让我们从后端组件开始。
- en: Building containers for the backend services
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为后端服务构建容器
- en: Both the event and booking service are Go applications that are compiled into
    single executable binaries. For this reason, it is not necessary to include any
    kind of source files or even the Go tool chain in the Docker image.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 事件和预订服务都是编译为单个可执行二进制文件的Go应用程序。因此，在Docker镜像中不需要包含任何源文件甚至Go工具链。
- en: 'It is important to note at this point that you will need compiled Linux binaries
    of your Go applications for the next steps. When on macOS or Windows, you will
    need to set the `GOOS` environment variable when invoking `go build`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上需要注意的是，您将需要为接下来的步骤编译Go应用程序的Linux二进制文件。在macOS或Windows上，调用`go build`时需要设置`GOOS`环境变量：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'On macOS and Linux, you can check for the correct binary type using the `file`
    command. For a Linux `ELF` binary, the `file` command should print a output similar
    to the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS和Linux上，您可以使用`file`命令检查正确的二进制类型。对于Linux的`ELF`二进制文件，`file`命令应该打印类似以下的输出：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Start by compiling Linux binaries for both the event service and the booking
    service.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编译Linux二进制文件，分别用于事件服务和预订服务。
- en: 'When you have compiled both services, continue by defining the Docker image
    build process for the event service. For this, create a new file named `Dockerfile`
    in the event service''s root directory:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编译了这两个服务后，继续为事件服务定义Docker镜像构建过程。为此，在事件服务的根目录中创建一个名为`Dockerfile`的新文件：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This Dockerfile contains some new statements that we did not cover before. The
    `COPY` statement copies a file from the host's local filesystem into the container
    image. This means that we are assuming that you have built your Go application
    using `go build` before starting the Docker build. The `USER` command causes all
    subsequent `RUN` statements and the `CMD` statement to run as that user (and not
    root). The `ENV` command sets an environment variable that will be available to
    the application. Finally, the `EXPOSE` statement declares that containers created
    from this image will need the TCP port `8181`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Dockerfile包含了一些我们之前没有涉及的新语句。`COPY`语句将文件从主机的本地文件系统复制到容器镜像中。这意味着我们假设您在开始Docker构建之前已经使用`go
    build`构建了Go应用程序。`USER`命令导致所有后续的`RUN`语句和`CMD`语句以该用户身份运行（而不是root）。`ENV`命令设置一个环境变量，将对应用程序可用。最后，`EXPOSE`语句声明从该镜像创建的容器将需要TCP端口`8181`。
- en: 'Continue by building the container image using the `docker image build` command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用`docker image build`命令构建容器镜像：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, add a similar Docker file to the `bookingservice`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向`bookingservice`添加一个类似的Docker文件：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Again, build the image using `docker image build`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`docker image build`命令构建镜像：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To test our new images, we can now spawn the respective containers. However,
    before starting the actual application containers, we will need to create a virtual
    network for these container and the required persistence services. Both event
    and booking service each require a MongoDB instance and a shared AMQP (or Kafka)
    message broker.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的新镜像，现在可以生成相应的容器。但是，在启动实际应用程序容器之前，我们需要为这些容器和所需的持久性服务创建一个虚拟网络。事件和预订服务分别需要一个MongoDB实例和一个共享的AMQP（或Kafka）消息代理。
- en: 'Let''s start by creating the container network:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建容器网络开始：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, add a RabbitMQ container to your network:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将RabbitMQ容器添加到您的网络中：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Continue by adding two MongoDB containers:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 继续添加两个MongoDB容器：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, you can start the actual application containers:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以启动实际的应用程序容器：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note the port mappings. Currently, both services have their REST API listen
    on TCP port `8181`. As long as these two APIs run in different containers, it
    is completely valid. However, when mapping these ports to host ports (for example,
    for testing purposes), we would have a port conflict that we resolve here by mapping
    the booking service's port `8181` to `8282`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意端口映射。目前，两个服务都在TCP端口`8181`上监听其REST API。只要这两个API在不同的容器中运行，这是完全有效的。但是，当将这些端口映射到主机端口（例如，用于测试目的）时，我们将会有一个端口冲突，我们通过将预订服务的端口`8181`映射到`8282`来解决这个问题。
- en: Also, note how the `-e` flags are used to pass environment variables into the
    running containers. For example, using the `MONGO_URL` environment variable, it
    becomes easy to connect the two application containers to different databases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意如何使用`-e`标志将环境变量传递到运行的容器中。例如，使用`MONGO_URL`环境变量，可以轻松地将两个应用程序容器连接到不同的数据库。
- en: 'After having started all these containers, you will be able to reach the event
    service via `http://localhost:8181` and the booking service via `http://localhost:8282`
    from your local machine. The following `docker container ls` command should now
    show you five running containers:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动了所有这些容器之后，您将能够从本地机器通过`http://localhost:8181`访问事件服务，通过`http://localhost:8282`访问预订服务。以下`docker
    container ls`命令现在应该显示您有五个正在运行的容器：
- en: '![](img/ecbca662-2530-4267-a40b-8d8974f8304c.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecbca662-2530-4267-a40b-8d8974f8304c.png)'
- en: docker container ls output
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: docker container ls 输出
- en: Using static compilation for smaller images
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态编译以获得更小的镜像
- en: Currently, we are building our application images on top of the `debian:jessie`
    image. This image contains the user-space tools and libraries of a typical Debian
    installation and takes about 123 MB in size (you can find this out using the `docker
    image ls` command). Add another 10 MB for the compiled Go application that you
    are adding to that base image, each of the resulting images will be about 133
    MB in size (which does not mean that our two images for the event service and
    booking service will together take up 266 MB of your disk space. They are both
    built on the same base image, and Docker is very efficient at optimizing disk
    space usage for container images).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在构建我们的应用程序镜像，这些镜像是基于`debian:jessie`镜像的。这个镜像包含了典型的Debian安装的用户空间工具和库，大小约为123MB（您可以使用`docker
    image ls`命令找到这一点）。再加上另外10MB用于编译的Go应用程序，每个生成的镜像大小约为133MB（这并不意味着我们的事件服务和预订服务的两个镜像将共同占用266MB的磁盘空间。它们都是基于相同的基础镜像构建的，Docker非常有效地优化了容器镜像的磁盘空间使用）。
- en: However, our application does not use most of these tools and libraries, so
    our container images could be much smaller. By this, we can optimize the local
    disk space usage (although the Docker Engine is already quite efficient at this),
    optimize the transfer times when the image is downloaded from an image repository,
    and reduce the attack surface against malicious users.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的应用程序并没有使用大部分这些工具和库，所以我们的容器镜像可以更小。通过这样做，我们可以优化本地磁盘空间的使用（尽管Docker引擎已经相当有效），优化从镜像仓库下载镜像时的传输时间，并减少对恶意用户的攻击面。
- en: 'Typically, compiled Go binaries have very few dependencies. You do not need
    any kind of runtime libraries or VMs, and all Go libraries that you use in your
    project are embedded directly into the resulting executable file. However, if
    you compile your application in Linux, the Go compiler will link the resulting
    binary against a few C standard libraries that are typically available on any
    Linux system. If you are on Linux, you can easily find out against which libraries
    your program was linked by invoking the `ldd` binary with one of your compiled
    Go binaries as argument. If your binary is linked against the C standard library,
    you will receive the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译的Go二进制文件几乎没有依赖性。您不需要任何运行时库或虚拟机，您在项目中使用的所有Go库都直接嵌入到生成的可执行文件中。但是，如果您在Linux上编译应用程序，Go编译器将会将生成的二进制文件链接到一些C标准库，这些库通常在任何Linux系统上都可用。如果您在Linux上，可以通过使用`ldd`二进制文件并将其中一个已编译的Go二进制文件作为参数来轻松找出您的程序链接到了哪些库。如果您的二进制文件链接到C标准库，您将收到以下输出：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This means that your Go application actually needs these Linux libraries to
    run and that you cannot just arbitrarily delete them from your image to make it
    smaller.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您的Go应用程序实际上需要这些Linux库来运行，您不能随意从镜像中删除它们以使其更小。
- en: 'If you cross-compiled your application on Windows or macOS using the `GOOS=linux`
    environment variable, you will probably not have this issue. As the compiler on
    those systems do not have access to the Linux standard C libraries, it will, by
    default, produce a statically linked binary that does not have any dependencies
    at all. When invoked with such a binary, `ldd` will render the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows或macOS上使用`GOOS=linux`环境变量交叉编译应用程序，您可能不会遇到这个问题。因为这些系统上的编译器无法访问Linux标准C库，它将默认产生一个没有任何依赖的静态链接二进制文件。当使用这样的二进制文件调用`ldd`时，将呈现以下输出：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'On Linux, you can force the Go compiler to create statically linked binaries
    by setting the `CGO_ENABLED=0` environment variable for your Go build command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，您可以通过为Go构建命令设置`CGO_ENABLED=0`环境变量来强制Go编译器创建静态链接的二进制文件：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Having completely statically linked binary allows you to create a much smaller
    container image. Instead of building on `debian:jessie` as a base image, you can
    now use the *scratch* image. The `scratch` image is a special image. It is directly
    built into the Docker Engine, and you cannot download it from the Docker Hub.
    What is special about the `scratch` image is that it is completely empty, empty
    as in does not contain one single file—this means no standard libraries, no system
    utilities, and not even a shell. Although these properties typically make the
    scratch image cumbersome to use, it is perfectly suited for building minimal container
    images for statically linked applications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完全静态链接的二进制文件使您可以创建一个更小的容器镜像。现在，您可以使用*scratch*镜像而不是在`debian:jessie`上构建基础镜像。`scratch`镜像是一个特殊的镜像。它直接内置在Docker
    Engine中，您无法从Docker Hub下载它。`scratch`镜像的特殊之处在于它完全为空，没有一个文件——这意味着没有标准库，没有系统实用程序，甚至没有一个shell。尽管这些特性通常使得scratch镜像难以使用，但它非常适合为静态链接应用程序构建最小的容器镜像。
- en: 'Change the event service''s `Dockerfile` as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更改事件服务的`Dockerfile`：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, change the booking service''s `Dockerfile` in a similar way. Build both
    container images again using the `docker image build` command from the preceding
    code. After that, verify your image size using the `docker image ls` command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以类似的方式更改预订服务的`Dockerfile`。然后，使用前面的代码中的`docker image build`命令再次构建这两个容器镜像。之后，使用`docker
    image ls`命令验证您的镜像大小：
- en: '![](img/2e70b403-4ec6-4fd8-a171-df7d4bee38b8.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e70b403-4ec6-4fd8-a171-df7d4bee38b8.png)'
- en: docker image ls output
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: docker image ls输出
- en: Building containers for the frontend
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为前端构建容器
- en: Now that we have container images for our backend applications, we can direct
    our attention to the frontend application. Since this application runs in the
    user's browser, we do not really need a containerized runtime environment for
    it. What we do need though is a way to deliver the application to the user. Since
    the entire application consists of a bit of HTML and JavaScript files, we can
    build a container image that contains a simple NGINX web server that serves these
    files to the users.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为后端应用程序构建了容器镜像，我们可以将注意力转向前端应用程序。由于该应用程序在用户的浏览器中运行，我们实际上不需要为其提供容器化的运行时环境。但我们确实需要一种向用户交付应用程序的方式。由于整个应用程序由一些HTML和JavaScript文件组成，我们可以构建一个包含简单NGINX
    Web服务器的容器镜像，用于向用户提供这些文件。
- en: For this, we will be building on the `nginx:1.11-alpine` image. This image contains
    a minimal version of the NGINX web server, built on Alpine Linux. Alpine is a
    Linux distribution optimized for small size. The entire `nginx:1.11-alpine` image
    is only 50 MB in size.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将在`nginx:1.11-alpine`镜像上构建。该镜像包含了一个基于Alpine Linux构建的最小版本的NGINX Web服务器。Alpine是一个针对小尺寸进行优化的Linux发行版。整个`nginx:1.11-alpine`镜像的大小仅为50MB。
- en: 'Add the following `Dockerfile` to your frontend application directory:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下`Dockerfile`添加到前端应用程序目录中：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Obviously, our web server will need to service both the `index.html` and the
    compiled Webpack bundle at `dist/bundle.js` to the users, so these are copied
    into the container image with `COPY`. However, from all the dependencies installed
    into the `node_modules/` directory, our users will need only a very specific subset.
    For these reasons, we are copying these five files explicitly into the container
    image, instead of just using `COPY` for the entire `node_modules/` directory.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的Web服务器需要为用户提供`index.html`和`dist/bundle.js`中编译的Webpack捆绑文件的服务，因此这些文件将使用`COPY`复制到容器镜像中。然而，从`node_modules/`目录中安装的所有依赖项中，我们的用户只需要一个非常特定的子集。因此，我们将这五个文件明确地复制到容器镜像中，而不是仅使用`COPY`复制整个`node_modules/`目录。
- en: 'Before actually building the container image, ensure that you have a recent
    Webpack build of your application and all dependencies installed. You can also
    use the `-p` flag to trigger Webpack to create a production build of your application
    that will be optimized for size:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际构建容器镜像之前，请确保您的应用程序有最新的Webpack构建和所有安装的依赖项。您还可以使用`-p`标志来触发Webpack创建一个针对大小进行优化的生产构建：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After this, build your container:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，构建您的容器：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can now start this container using the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令启动此容器：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we are not passing the `--network=myevents` flag in this case. This
    is because the frontend container does not actually need to communicate with the
    backend services directly. All communication is initiated from the user's browser,
    not from within the actual frontend container.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，我们没有传递`--network=myevents`标志。这是因为前端容器实际上不需要直接与后端服务通信。所有通信都是由用户的浏览器发起的，而不是从实际的前端容器内部发起的。
- en: The `-p 80:80` flag binds the container's TCP port 80 to your local TCP port
    80\. This allows you to now open `http://localhost` in your browser and view the
    MyEvents frontend application. If you still have the backend containers from the
    previous sections running, the application should work out of the box.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p 80:80`标志将容器的TCP端口80绑定到本地TCP端口80。这样，您现在可以在浏览器中打开`http://localhost`并查看MyEvents前端应用程序。如果您仍然在运行前几节的后端容器，则应用程序应该可以直接使用。'
- en: Deploying your application with Docker Compose
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose部署应用程序
- en: Up until now, actually deploying the MyEvents application from existing container
    images involved a number of `docker container run` commands. Although this works
    reasonably well for testing, it becomes tedious once your application runs in
    production, especially when you want to deploy updates or scale the application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，从现有的容器镜像部署MyEvents应用程序实际上涉及了许多`docker container run`命令。尽管这对于测试来说效果还不错，但一旦您的应用程序在生产环境中运行时，特别是当您想要部署更新或扩展应用程序时，这将变得很繁琐。
- en: One possible solution for this is **Docker Compose**. Compose is a tool that
    allows you to describe applications composed of multiple containers in a declarative
    way (in this case, a YAML file that describes which components have built your
    application).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的一个可能解决方案是**Docker Compose**。Compose是一个工具，允许您以声明方式描述由多个容器组成的应用程序（在本例中，是一个描述构建应用程序的组件的YAML文件）。
- en: 'Docker Compose is part of the regular Docker installation packages, so if you
    have Docker installed in your local machine, you should also have Docker Compose
    available. You can easily test this by invoking the following command on your
    command line:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是常规Docker安装包的一部分，因此如果你在本地机器上安装了Docker，你也应该有Docker Compose可用。你可以通过在命令行上调用以下命令来轻松测试：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If Compose is not available on your local machine, consult the installation
    manual at [https://docs.docker.com/compose/install](https://docs.docker.com/compose/install)
    for a detailed description on how to set up Compose.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的本地机器上没有Compose，请查阅[https://docs.docker.com/compose/install](https://docs.docker.com/compose/install)上的安装手册，详细描述如何设置Compose。
- en: Every Compose project is described by a `docker-compose.yml` file. The Compose
    file will later contain a description of all containers, networks, and volumes
    that you need for your application. Compose will then try to reconcile the desired
    state expressed in the Compose file with the actual state of the local Docker
    engine (for example, by creating, deleting, starting, or stopping containers).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Compose项目都由一个`docker-compose.yml`文件描述。Compose文件将包含你的应用程序所需的所有容器、网络和卷的描述。Compose将尝试通过创建、删除、启动或停止容器等方式，将Compose文件中表达的期望状态与本地Docker引擎的实际状态协调。
- en: 'Create such a file at the root of your project directory with the following
    contents:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目目录的根目录创建一个包含以下内容的文件：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note the `version: "3"` declaration in the Compose file. Compose supports multiple
    declaration formats, the most recent being version 3\. In some documentations,
    examples, or open source projects, you will most likely stumble across Compose
    files written for older versions. Compose files that do not declare a version
    at all are interpreted as version 1 files.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '在Compose文件中注意`version: "3"`的声明。Compose支持多种声明格式，最近的版本是版本3。在一些文档、示例或开源项目中，你很可能会遇到为旧版本编写的Compose文件。根本不声明版本的Compose文件被解释为版本1文件。'
- en: 'Right now, the preceding Compose file does nothing more than declare that your
    application requires a virtual network named `myevents`. Nevertheless, you can
    use Compose to reconcile the desired state (one network named `myevents` must
    exist) by running the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，上述Compose文件仅仅声明你的应用程序需要一个名为`myevents`的虚拟网络。然而，你可以使用Compose通过运行以下命令来协调所需的状态（必须存在一个名为`myevents`的网络）：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Right now, the preceding command will print a warning message since we are declaring
    a container network that is not used by any container.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，上述命令将打印一个警告消息，因为我们声明了一个没有被任何容器使用的容器网络。
- en: 'Containers are declared in the Compose file under the `services`. Each container
    has a name (used as a key in the YAML structure) and can have various properties
    (such as the image to be used). Let''s continue by adding a new container to the
    Compose file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在Compose文件中声明在`services`下。每个容器都有一个名称（在YAML结构中用作键）和各种属性（例如要使用的镜像）。让我们继续向Compose文件中添加一个新的容器：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is the RabbitMQ container that you have created manually earlier using
    the `docker container run -d --network myevents -p 15672:15672 rabbitmq:3-management` command.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你之前使用`docker container run -d --network myevents -p 15672:15672 rabbitmq:3-management`命令手动创建的RabbitMQ容器。
- en: 'You can now create this container by running the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过运行以下命令创建这个容器：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `-d` flag has the same effect as with the docker container run command;
    it will cause the container(s) to be started in the background.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`标志与docker container run命令具有相同的效果；它将导致容器在后台启动。'
- en: As soon as the RabbitMQ container starts running, you can actually invoke `docker-compose
    up` as many times as you like. Since the already running RabbitMQ container matches
    the specification from the Compose file, Compose will not take any further action.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦RabbitMQ容器开始运行，你实际上可以随意多次调用`docker-compose up`。由于已经运行的RabbitMQ容器与Compose文件中的规范匹配，Compose不会采取任何进一步的操作。
- en: 'Let''s continue by adding the two MongoDB containers to the Compose file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向Compose文件中添加两个MongoDB容器：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run `docker-compose up -d` another time. Compose will still not touch the RabbitMQ
    container, as it is still up to spec. However, it will create two new MongoDB
    containers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`docker-compose up -d`。Compose仍然不会触及RabbitMQ容器，因为它仍然符合规范。但是，它将创建两个新的MongoDB容器。
- en: 'Next, we can add the two application Services:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加两个应用程序服务：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that we are not specifying an `image` attribute for these two containers,
    but a `build` attribute, instead. This will cause Compose to actually build the
    images for these containers on-demand from the Dockerfile found in the respective
    directories.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有为这两个容器指定`image`属性，而是使用了`build`属性。这将导致Compose根据需要从各自目录中的Dockerfile实际构建这些容器的镜像。
- en: It is important to note that the Docker build does not compile your Go binaries.
    Instead, it will rely on them being already there. In [Chapter 9](465ef76f-a2b2-42f7-b9c4-3c60ac552f77.xhtml),
    *Continuous Delivery*, you will learn how to use CI pipelines to automate these
    build steps.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，Docker构建不会编译你的Go二进制文件。相反，它将依赖于它们已经存在。在[第9章](465ef76f-a2b2-42f7-b9c4-3c60ac552f77.xhtml)
    *持续交付*中，你将学习如何使用CI流水线来自动化这些构建步骤。
- en: 'You can also use the `docker-compose` command to trigger individual steps of
    this pipeline separately. For example, use `docker-compose pull` to download recent
    versions of all images used in the `Compose` file from the Docker Hub:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`docker-compose`命令单独触发这个流水线的各个步骤。例如，使用`docker-compose pull`从Docker Hub下载Compose文件中使用的所有镜像的最新版本：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For containers that do not use a predefined image, use `docker-compose build`
    to rebuild all images:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不使用预定义镜像的容器，使用`docker-compose build`重新构建所有镜像：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Create the new containers with another `docker-compose up -d`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用另一个`docker-compose up -d`创建新的容器。
- en: Ensure that you have stopped any previously created containers that might be
    bound to the TCP ports 8181 or 8282\. Use the `docker container ls` and `docker
    container stop` commands to locate and stop these containers.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已停止任何先前创建的可能绑定到TCP端口8181或8282的容器。使用`docker container ls`和`docker container
    stop`命令来定位并停止这些容器。
- en: 'You can also use the `docker-compose ps` command to get an overview of the
    currently running containers associated with the current Compose project:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`docker-compose ps`命令来查看与当前Compose项目关联的当前正在运行的容器的概述：
- en: '![](img/bbe15948-950f-4e04-948f-1eab0d05b679.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbe15948-950f-4e04-948f-1eab0d05b679.png)'
- en: docker-compose ps output
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: docker-compose ps 输出
- en: 'Finally, add the frontend application to the Compose file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将前端应用程序添加到Compose文件中：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you learned in this section, Docker Compose enables you to describe your
    application's architecture in a declarative way, allowing easy deployment and
    updates of your application on any server that supports a Docker instance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本节中学到的，Docker Compose使您能够以声明方式描述应用程序的架构，从而可以在支持Docker实例的任何服务器上轻松部署和更新应用程序。
- en: Up until now, we have always worked on a single host (most probably, your local
    machine). This is good for development, but for a production setup, you will need
    to concern yourself with deploying your application to a remote server. Also,
    since cloud architectures are all about scale, over the next few sections, we
    will also take a look at how to manage containerized applications at scale.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在单个主机上工作（很可能是您的本地机器）。这对开发来说很好，但是对于生产设置，您需要考虑将应用程序部署到远程服务器上。此外，由于云架构都是关于规模的，接下来的几节中，我们还将看看如何在规模上管理容器化应用程序。
- en: Publishing your images
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布您的镜像
- en: You now have the ability to build container images from your application components
    and to run containers from these images on your local machine. However, in a production
    context, the machine on which you have built a container image is rarely the machine
    that you will run it on. To actually be able to deploy your application to any
    cloud environment, you will need a way to distribute built container images to
    any number of hosts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从应用程序组件构建容器镜像，并在本地机器上从这些镜像运行容器。但是，在生产环境中，构建容器镜像的机器很少是您将在其上运行它的机器。要实际能够将应用程序部署到任何云环境，您需要一种将构建的容器镜像分发到任意数量的主机的方法。
- en: This is where container registries come into play. In fact, you have already
    worked with a container registry earlier in this chapter, that is, the Docker
    Hub. Whenever you use a Docker image that is not present on your local machine
    (let's say, for example, the `nginx` image), the Docker engine will pull this
    image from the Docker Hub onto your local machine. However, you can also use a
    container registry such as the Docker Hub to publish your own container images
    and then pull them from another instance.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是容器注册表发挥作用的地方。实际上，在本章的早些时候，您已经使用过一个容器注册表，也就是Docker Hub。每当您使用本地机器上不存在的Docker镜像（比如，例如`nginx`镜像），Docker引擎将从Docker
    Hub将此镜像拉到您的本地机器上。但是，您也可以使用诸如Docker Hub之类的容器注册表来发布自己的容器镜像，然后从另一个实例中拉取它们。
- en: At the Docker Hub (which you can access in your browser via [https://hub.docker.com](https://hub.docker.com)),
    you can register as a user and then upload your own images. For this, click on
    the Create Repository after logging in and choose a new name for your image.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Hub（您可以通过浏览器访问[https://hub.docker.com](https://hub.docker.com)），您可以注册为用户，然后上传自己的镜像。为此，请在登录后单击创建存储库，然后选择一个新名称作为您的镜像。
- en: 'To push a new image into your newly created repository, you will first need
    to log in with your Docker Hub account on your local machine. Use the following `docker
    login` command for this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新镜像推送到您新创建的存储库中，您首先需要在本地机器上使用您的Docker Hub帐户登录。使用以下`docker login`命令：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, you will be able to push images into the new repository. The image names
    will need to start with your Docker Hub username, followed by a slash:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将能够将镜像推送到新的存储库中。镜像名称将需要以您的Docker Hub用户名开头，后面跟着一个斜杠：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: By default, images pushed to the Docker Hub will be publicly visible. The Docker
    Hub also offers the possibility to push private images as a paid feature. Private
    images can only be pulled after you have successfully authenticated using the
    `docker login` command.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，推送到Docker Hub的镜像将是公开可见的。Docker Hub还提供了推送私有镜像作为付费功能的可能性。只有在成功使用`docker
    login`命令进行身份验证后，才能拉取私有镜像。
- en: 'Of course, you do not have to use the Docker Hub to distribute your own images.
    There are alternative providers, such as Quay ([https://quay.io](https://quay.io/)),
    and all major cloud providers also offer the possibility to host managed container
    registries for you. However, when using a registry other than the Docker Hub,
    some of the preceding commands will change slightly. For starters, you will have
    to tell the `docker login` command the registry that you will be signing in:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不必使用Docker Hub来分发自己的镜像。还有其他提供者，比如Quay（[https://quay.io](https://quay.io/)），所有主要的云提供商也提供了托管容器注册表的可能性。但是，当使用除Docker
    Hub之外的注册表时，一些前面的命令将略有变化。首先，您将不得不告诉`docker login`命令您将要登录的注册表：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Also, container images that you want to push will not only need to start with
    your Docker Hub username, but with the entire registry hostname:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您想要推送的容器镜像不仅需要以您的Docker Hub用户名开头，还需要以整个注册表主机名开头：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you do not want to entrust your container images to a third-party provider,
    you can also roll out your own container registry. Fittingly, there is a Docker
    image that you can use to quickly set up your own registry:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想将您的容器镜像委托给第三方提供者，您还可以部署自己的容器注册表。恰当地，有一个Docker镜像可以让您快速设置自己的注册表：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will set up a container registry that is reachable at: `http://localhost:5000`.
    You can treat it like any other third-party registry:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置一个可在`http://localhost:5000`访问的容器注册表。您可以像对待其他第三方注册表一样对待它：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Having a private container registry listening on `localhost:5000` is fine for
    development, but for a production setup, you will need additional configuration
    options. For example, you will need to configure TLS transfer encryption for your
    registry (by default, the Docker engine will refuse to any non-encrypted Docker
    registry other than localhost), and you will also need to set up authentication
    (unless you explicitly intend to run a publicly accessible container registry).
    Take a look a the registry's official deployment guide to learn how to set up
    encryption and authentication: [https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个在`localhost:5000`上监听的私有容器注册表对于开发来说是可以的，但是对于生产设置，您将需要额外的配置选项。例如，您将需要为您的注册表配置TLS传输加密（默认情况下，Docker引擎将拒绝除localhost以外的任何非加密Docker注册表），您还需要设置身份验证（除非您明确打算运行一个公开访问的容器注册表）。查看注册表的官方部署指南，了解如何设置加密和身份验证：[https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/)。
- en: Deploying your application to the cloud
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的应用程序部署到云端
- en: To conclude this chapter, we will have a look at how you can deploy your containerized
    application to a cloud environment.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将看看如何将容器化的应用部署到云环境中。
- en: Container engines, such as, Docker allow you to provision multiple Services
    in isolated environments, without having to provision separate virtual machines
    for individual Services. However, as typical for Cloud applications, our container
    architecture needs to be easily scalable and also resilient to failure.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 容器引擎，比如 Docker，允许您在隔离的环境中提供多个服务，而无需为单独的服务提供独立的虚拟机。然而，与典型的云应用一样，我们的容器架构需要易于扩展，并且对故障有弹性。
- en: This is where container orchestration system such as Kubernetes comes into play.
    These are systems that allow you to deploy containerized applications over entire
    clusters of hosts. They allow for easy scaling since you can easily add new hosts
    to an existing cluster (after which new container workloads may automatically
    be scheduled on them) and also make your system resilient; node failures can be
    quickly detected, which allows containers on those nodes to be started somewhere
    else to ensure their availability.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是容器编排系统（如Kubernetes）发挥作用的地方。这些系统允许您在整个主机集群上部署容器化的应用程序。它们允许轻松扩展，因为您可以轻松地向现有集群添加新主机（之后新的容器工作负载可能会自动安排在它们上面），并且使您的系统具有弹性；节点故障可以被快速检测到，这允许在其他地方启动那些节点上的容器以确保它们的可用性。
- en: Introduction to Kubernetes
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes简介
- en: One of the most prominent container orchestrators is Kubernetes (which is Greek
    for *helmsman*). Kubernetes is an open source product originally developed by
    Google and now owned by the Cloud Native Computing Foundation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的容器编排器之一是Kubernetes（希腊语意为*舵手*）。Kubernetes是由谷歌最初开发的开源产品，现在由云原生计算基金会拥有。
- en: 'The following diagram shows the basic architecture of a Kubernetes cluster:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了Kubernetes集群的基本架构：
- en: '![](img/392103eb-b9ad-4cdc-9ccc-5413b070389c.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/392103eb-b9ad-4cdc-9ccc-5413b070389c.png)'
- en: The central component of each Kubernetes cluster is the master server (which,
    of course, does not have to be an actual single server. In production setups,
    you will often have multiple master servers that are configured for high availability).
    The master server stores the entire cluster state in an end data store. The API
    Server is the component that offers a REST API that can be used by both internal
    components (such as the scheduler, controllers, or Kubelets) and external users
    (you!). The scheduler tracks available resources on the individual nodes (such
    as memory and CPU usage) and decides on which node in the cluster new containers
    should be scheduled. Controllers are components that manage high-level concepts
    such as replication controllers or autoscaling groups.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Kubernetes集群的中心组件是主服务器（当然，不一定是实际的单个服务器。在生产设置中，您通常会有多个配置为高可用性的主服务器）。主服务器将整个集群状态存储在端数据存储中。API服务器是提供REST
    API的组件，可以被内部组件（如调度器、控制器或Kubelet）和外部用户（您！）使用。调度器跟踪各个节点上的可用资源（如内存和CPU使用情况），并决定集群中新容器应该在哪个节点上安排。控制器是管理高级概念的组件，如复制控制器或自动缩放组。
- en: The Kubernetes nodes are the place where the actual application containers managed
    by the master server are started. Each node runs a Docker Engine and a **Kubelet**.
    The Kubelet is connected to the master server's REST API and is responsible for
    actually starting the containers that were scheduled for this node by the scheduler.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes节点是由主服务器管理的实际应用程序容器启动的地方。每个节点运行一个Docker引擎和一个**Kubelet**。Kubelet连接到主服务器的REST
    API，并负责实际启动调度器为该节点安排的容器。
- en: In Kubernetes, containers are organized in Pods. A Pod is Kubernetes' smallest
    possible scheduling unit and consists of one or more Docker containers. All containers
    in a Pod are guaranteed to be run on the same host. Each Pod will receive an IP
    address that is unique and routable within the whole cluster (meaning that Pods
    running on one host will be able to communicate with Pods running on other nodes
    via their IP addresses).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，容器被组织在Pod中。Pod是Kubernetes的最小调度单元，由一个或多个Docker容器组成。Pod中的所有容器都保证在同一主机上运行。每个Pod将接收一个唯一的可路由IP地址，该地址在整个集群内是唯一的（这意味着在一个主机上运行的Pod将能够通过它们的IP地址与在其他节点上运行的Pod进行通信）。
- en: The Kube Proxy is the component that ensures that users can actually reach your
    applications. In Kubernetes, you can define Services that group multiple Pods.
    The Kube Proxy assigns a unique IP address to each Service, and forward network
    traffic to all Pods matched by a Service. This way, the Kube Proxy also implements
    a very simple but effective load balancing, when there are multiple instances
    of an application running in multiple Pods.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Kube Proxy是确保用户实际可以访问您的应用程序的组件。在Kubernetes中，您可以定义将多个Pod分组的服务。Kube Proxy为每个服务分配一个唯一的IP地址，并将网络流量转发到服务匹配的所有Pod。这样，Kube
    Proxy还实现了一个非常简单但有效的负载平衡，当多个应用程序实例在多个Pod中运行时。
- en: You may have noticed that Kubernetes' architecture is quite complex. Setting
    up a Kubernetes cluster is a challenging task, which we will not cover in detail
    in this book. For local development and testing, we will use the Minikube tool,
    which automatically creates a virtualized Kubernetes environment on your local
    machine. When you are running your application in a public cloud environment,
    you can also use tools that automatically set up a production-ready Kubernetes
    environment for you. Some cloud providers even provide managed Kubernetes clusters
    for you (for example, the **Google Container Engine** and the **Azure Container
    Service** are both built on Kubernetes).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到Kubernetes的架构非常复杂。设置Kubernetes集群是一项具有挑战性的任务，在本书中我们不会详细介绍。对于本地开发和测试，我们将使用Minikube工具，在您的本地机器上自动创建一个虚拟化的Kubernetes环境。当您在公共云环境中运行应用程序时，您还可以使用工具为您自动设置一个生产就绪的Kubernetes环境。一些云提供商甚至为您提供托管的Kubernetes集群（例如，**Google容器引擎**和**Azure容器服务**都是基于Kubernetes构建的）。
- en: Setting up a local Kubernetes with Minikube
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Minikube设置本地Kubernetes
- en: 'To get started with Minikube, you will need three tools on your local machine:
    Minikube itself (which will handle setting up the virtual Kubernetes environment
    on your machine), VirtualBox (which will be used as a virtualization environment),
    and kubectl (which is the command-line client for working with Kubernetes). Although
    we are using Minikube in this example, each and every kubectl command that we
    are showing in the following sections will work on nearly every Kubernetes cluster,
    regardless of how it was set up.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Minikube，您需要在本地机器上安装三个工具：Minikube本身（将在您的机器上设置虚拟Kubernetes环境），VirtualBox（将用作虚拟化环境）和kubectl（用于与Kubernetes一起工作的命令行客户端）。尽管在本示例中我们使用Minikube，但我们在接下来的章节中展示的每个kubectl命令几乎都适用于几乎每个Kubernetes集群，无论它是如何设置的。
- en: Start by setting up VirtualBox. For this, download an installer from the official
    download page at [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)
    and follow the installation instructions for your operating system.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先设置VirtualBox。为此，请从官方下载页面[https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)下载安装程序，并按照您的操作系统的安装说明进行操作。
- en: 'Next, download a recent build of Minikube. You can find all releases at: [https://github.com/kubernetes/minikube/releases](https://github.com/kubernetes/minikube/releases)
    (at the time of writing, the most recent release was 0.18.0). Again, follow the
    installation instructions for your operating system. Alternatively, use the following
    command to quickly download and set up Minikube (replace `linux` with `darwin`
    or `windows`, respectively):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，下载最新版本的Minikube。您可以在[https://github.com/kubernetes/minikube/releases](https://github.com/kubernetes/minikube/releases)找到所有版本（在撰写本文时，最新版本为0.18.0）。同样，按照您的操作系统的安装说明进行操作。或者，使用以下命令快速下载并设置Minikube（分别将`linux`替换为`darwin`或`windows`）：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Lastly, set up kubectl. You can find the installation instructions at: [https://kubernetes.io/docs/tasks/kubectl/install](https://kubernetes.io/docs/tasks/kubectl/install).
    Alternatively, use the following command (again, replace `linux` with `darwin`
    or `windows` as necessary):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置kubectl。您可以在以下位置找到安装说明：[https://kubernetes.io/docs/tasks/kubectl/install](https://kubernetes.io/docs/tasks/kubectl/install)。或者，使用以下命令（根据需要将`linux`替换为`darwin`或`windows`）：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After having set up all the requirements, you can use the `minikube start`
    command to start your local Kubernetes environment:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好所有要求之后，您可以使用`minikube start`命令启动本地Kubernetes环境：
- en: '[PRE49]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This command will download an ISO image, then start a new virtual machine from
    this image and install various Kubernetes components. Grab a coffee and do not
    be surprised if this takes a few minutes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将下载一个ISO镜像，然后从该镜像启动一个新的虚拟机，并安装各种Kubernetes组件。喝杯咖啡，如果这需要几分钟，不要感到惊讶：
- en: '![](img/e2c578b1-67b9-475e-8318-1b47a0864fd6.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2c578b1-67b9-475e-8318-1b47a0864fd6.png)'
- en: minikube start output
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: minikube start输出
- en: The `minikube start` command also creates a configuration file for kubectl that
    enables you to use kubectl with your minikube VM without any further configuration.
    You can find this file in your home directory at `~/.kube/config`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`minikube start`命令还会创建一个配置文件，用于使您可以在没有任何进一步配置的情况下使用kubectl与minikube VM。您可以在主目录下的`~/.kube/config`中找到此文件。'
- en: 'To test whether the entire setup works as expected, run the `kubectl get nodes`
    command. This command will print a list of all nodes that are part of the Kubernetes
    cluster. In a Minikube setup, you should see exactly one node:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 测试整个设置是否按预期工作，请运行`kubectl get nodes`命令。该命令将打印出Kubernetes集群中所有节点的列表。在Minikube设置中，您应该只能看到一个节点：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![](img/2259d431-8edc-496e-8ab7-8b073fe91bf1.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2259d431-8edc-496e-8ab7-8b073fe91bf1.png)'
- en: kubectl get nodes output
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get nodes输出
- en: Core concepts of Kubernetes
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes的核心概念
- en: Before diving back into MyEvents, let's take a more thorough look at some of
    Kubernetes' core concepts. We will start by creating a new Pod that contains a
    simple NGINX web server.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解MyEvents之前，让我们更仔细地看一下一些Kubernetes的核心概念。我们将首先创建一个包含简单NGINX Web服务器的新Pod。
- en: 'Kubernetes resources (such as Pods and Services) are usually defined in YAML
    files that declaratively describe the desired state of your cluster (similar to
    the Docker Compose configuration files that you have worked with before). For
    our new NGINX Pod, create a new file named `nginx-pod.yaml` anywhere in your local
    filesystem:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes资源（如Pod和服务）通常在YAML文件中定义，这些文件以声明方式描述了您的集群的期望状态（类似于您之前使用的Docker Compose配置文件）。对于我们的新NGINX
    Pod，创建一个名为`nginx-pod.yaml`的新文件，放在您的本地文件系统的任何位置：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This so-called manifest file describes what your new Pod should look like. In
    the `metadata` section, you can set basic metadata, such as the Pod's name or
    any additional labels (we will need those later). The `spec` section contains
    the actual specification of what the Pod should look like. As you can see, the
    `spec.containers` section is formatted as a list; in theory, you could add additional
    containers here that would then run within the same Pod.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个所谓的清单文件描述了你的新Pod应该是什么样子。在`metadata`部分，您可以设置基本的元数据，比如Pod的名称或任何额外的标签（我们以后会需要这些）。`spec`部分包含了Pod应该是什么样子的实际规范。正如你所看到的，`spec.containers`部分被格式化为一个列表；理论上，你可以在这里添加额外的容器，然后在同一个Pod中运行。
- en: 'After having created this file, use the `kubectl apply` command to create the
    Pod:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完这个文件后，使用`kubectl apply`命令创建Pod：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After this, you can use the `kubectl get pods` command to verify that your
    Pod has successfully been created. Note that it may take a few seconds to minutes
    until the Pod changes its status from `ContainerCreating` to `Running`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以使用`kubectl get pods`命令验证您的Pod是否已成功创建。请注意，从`ContainerCreating`到`Running`状态可能需要几秒钟到几分钟的时间：
- en: '[PRE53]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![](img/fcfee8cc-9752-48f7-b3ae-d564aec74df2.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcfee8cc-9752-48f7-b3ae-d564aec74df2.png)'
- en: kubectl get pods output
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get pods 输出
- en: Note that the `kubectl` command communicates directly with the Kubernetes API
    server (although when using Minikube, that is not a very big distinction, since
    all components are running on the same virtual machine anyway), not with the cluster
    nodes. In theory, your Kubernetes cluster could be made of many hosts, and the
    Kubernetes scheduler would automatically pick the best-suited host on which to
    run your new Pod on.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`kubectl`命令直接与Kubernetes API服务器通信（尽管在使用Minikube时，这并没有太大的区别，因为所有组件都在同一台虚拟机上运行），而不是与集群节点通信。理论上，您的Kubernetes集群可能由许多主机组成，Kubernetes调度程序会自动选择最适合的主机来运行您的新Pod。
- en: 'There are more things that you can configure for a single Pod. For example,
    you might want to restrict your application''s memory or CPU usage. In this case,
    you could add the following settings to your newly created Pod manifest:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多的事情可以为单个Pod配置。例如，您可能希望限制应用程序的内存或CPU使用。在这种情况下，您可以将以下设置添加到您新创建的Pod清单中：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `resources.limits` section will instruct Kubernetes to create a container
    with a memory limit of 128 MB and a CPU limit of one half CPU core.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources.limits`部分将指示Kubernetes创建一个带有128MB内存限制和半个CPU核心的容器。'
- en: The important thing to note about Kubernetes Pods is that they are not meant
    to be persistent. Pods may be terminated at a moment's notice and may get lost
    whenever a node fails. For this reason, it is recommended to use a Kubernetes
    controller (such as the Deployment controller) to create Pods for you.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Kubernetes Pod的重要事情是，它们不是持久的。Pod可能会在任何时候被终止，并且在节点失败时可能会丢失。因此，建议使用Kubernetes控制器（如部署控制器）为您创建Pod。
- en: 'Before continuing, delete your Pod using the `kubectl delete` command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，使用`kubectl delete`命令删除您的Pod：
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, create a new `nginx-deployment.yaml` file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的`nginx-deployment.yaml`文件：
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This manifest will create a so-called Deployment controller for you. A Deployment
    controller will make sure that a given number of Pods of a given configuration
    is running at any time—in this case, two Pods (specified in the `spec.replicas`
    field) that are described by the `spec.template` field (note that the `spec.template`
    fields matches the Pod definition that we have already written before, minus the
    name).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单将为您创建一个所谓的部署控制器。部署控制器将确保在任何时候运行指定配置的给定数量的Pod——在这种情况下，两个Pod（在`spec.replicas`字段中指定）由`spec.template`字段描述（注意`spec.template`字段匹配我们之前已经编写的Pod定义，减去名称）。
- en: 'As before, create the Deployment using the `kubectl apply` command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，使用`kubectl apply`命令创建部署：
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Verify the success of your actions using the `kubectl get pods` command. You
    should note that two Pods will be scheduled (having names like `nginx-deployment-1397492275-qz8k5`):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl get pods`命令验证您的操作的成功。您应该注意到将安排两个Pod（名称类似于`nginx-deployment-1397492275-qz8k5`）：
- en: '![](img/24c3dc96-8f3e-4085-9ad2-16fea98b64b0.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24c3dc96-8f3e-4085-9ad2-16fea98b64b0.png)'
- en: kubectl get pods output
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get pods 输出
- en: 'There''s more that you can do with Deployments. For starters, try deleting
    one of the automatically generated Pods using the `kubectl delete` command (keep
    in mind that on your machine, you will have a different Pod name):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 部署还有更多的功能。首先，尝试使用`kubectl delete`命令删除一个自动生成的Pod（请记住，在您的机器上，您将有一个不同的Pod名称）：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: After deleting the Pod, call `kubectl get pods` again. You will note that the
    Deployment controller almost immediately created a new Pod.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 删除Pod后，再次调用`kubectl get pods`。您会注意到，部署控制器几乎立即创建了一个新的Pod。
- en: 'Also, you might decide that two instances of your application is not sufficient
    and that you want to scale your application further. For this, you can simply
    increase the Deployment controller''s `spec.scale` property. To increase (or decrease)
    the scale, you can either edit your existing YAML file and then call `kubectl
    apply` again. Alternatively, you can directly edit the resource using the `kubectl
    edit` command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能会决定您的应用程序的两个实例不足，您希望进一步扩展您的应用程序。为此，您可以简单地增加部署控制器的`spec.scale`属性。要增加（或减少）规模，您可以编辑现有的YAML文件，然后再次调用`kubectl
    apply`。或者，您可以直接使用`kubectl edit`命令编辑资源：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Especially for the `spec.scale` property, there is also a special `kubectl
    scale` command that you can use:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于`spec.scale`属性，还有一个特殊的`kubectl scale`命令可以使用：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '![](img/0f53bd75-2285-45b3-ab56-5e01be6f9f7f.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/0f53bd75-2285-45b3-ab56-5e01be6f9f7f.png)
- en: kubectl get pods output
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get pods输出
- en: Services
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: 'Currently, we have four NGINX containers running, but no way to actually access
    them. This is where Services come into play. Create a new YAML file named `nginx-service.yaml`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有四个运行的NGINX容器，但没有实际访问它们的方式。这就是服务发挥作用的地方。创建一个名为`nginx-service.yaml`的新YAML文件：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Note that the `spec.selector` property matches the `metadata.labels` property
    that you have specified in the Deployment manifest. All Pods created by a Deployment
    controller will have a given set of labels (which are really just arbitrary key/value
    mappings). The `spec.selector` property of a Service now specifies which labels
    a Pod should have to be recognized by this Service. Also, note the `type: NodePort`
    property, which is going to be important later.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，`spec.selector`属性与您在部署清单中指定的`metadata.labels`属性匹配。由部署控制器创建的所有Pod都将具有一组给定的标签（实际上只是任意的键/值映射）。服务的`spec.selector`属性现在指定了一个Pod应该具有哪些标签，以便被此服务识别。还要注意`type:
    NodePort`属性，这将在后面变得重要。'
- en: 'After creating the file, use `kubectl apply` as usual to create the service
    definition:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件后，像往常一样使用`kubectl apply`来创建服务定义：
- en: '![](img/b7f872bb-8f02-4beb-87a1-89a89edd01c0.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/b7f872bb-8f02-4beb-87a1-89a89edd01c0.png)
- en: kubectl apply output
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl apply输出
- en: <pre>**$ kubectl apply -f nginx-service.yaml**
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <pre>**$ kubectl apply -f nginx-service.yaml**
- en: Next, call `kubectl get services` to inspect the newly created Service definition.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用`kubectl get services`来检查新创建的服务定义。
- en: In the `kubectl get services` output, you will find your newly created `nginx`
    Service (along with the Kubernetes Service, which is always there).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kubectl get services`输出中，您将找到您新创建的`nginx`服务（以及始终存在的Kubernetes服务）。
- en: 'Remember the `type: NodePort` property that you specified when creating the
    Service? The effect of this property is that the Kube proxy on each node now opened
    up a TCP port. The port number of this port is chosen randomly. In the preceding
    example, this is the TCP port 31455\. You can use this Port to connect to your
    Service from outside the Kubernetes cluster (for example, from your local machine).
    Any and all traffic received on this port is forwarded to one of the Pods matched
    by the `selector` specified in the Service''s specification.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '记住在创建服务时指定的`type: NodePort`属性吗？这个属性的效果是，每个节点上的Kube代理现在打开了一个TCP端口。此端口的端口号是随机选择的。在前面的例子中，这是TCP端口31455。您可以使用此端口从Kubernetes集群外部连接到您的服务（例如，从您的本地计算机）。在此端口接收到的任何流量都将转发到服务规范中指定的`selector`匹配的Pod之一。'
- en: The special thing about services is that typically they will have a (much) longer
    lifespan than your average Pod. When new Pods are added (maybe because you have
    increased the replica count of the Deployment controller), these will automatically
    be added. Also, when Pods are removed (again, maybe because of a changed replica
    count, but also because of a node failure or just because a Pod was manually deleted),
    they will stop receiving traffic.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的特殊之处在于，它们通常会比平均Pod的寿命要长得多。当添加新的Pod（可能是因为您增加了部署控制器的副本数量）时，这些将自动添加。同样，当Pod被删除（可能是因为副本数量发生了变化，也可能是因为节点故障或者只是手动删除了Pod），它们将停止接收流量。
- en: 'If you are using Minikube, you can now use the `minikube service` command to
    quickly find a node''s public IP address to open this service in your browser:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Minikube，现在可以使用`minikube service`命令快速找到节点的公共IP地址，以在浏览器中打开此服务：
- en: '[PRE62]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In addition to the node port, also note the cluster IP property in the preceding
    output; this is an IP address that you can use within the cluster to reach any
    Pod matched by this Service. So, in this example, you could start a new Pod running
    your own application, and use the IP address `10.0.0.223` to access the `nginx`
    Service within this application. Also, since IP addresses are cumbersome to work
    with, you will also be able to use the Service name (`nginx`, in this case) as
    a DNS name.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 除了节点端口，还要注意前面输出中的集群IP属性；这是一个IP地址，您可以在集群内使用它来访问此服务匹配的任何Pod。因此，在这个例子中，您可以启动一个运行您自己应用程序的新Pod，并使用IP地址`10.0.0.223`来访问此应用程序中的`nginx`服务。此外，由于IP地址很麻烦，您还可以使用服务名称（在本例中为`nginx`）作为DNS名称。
- en: Persistent volumes
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久卷
- en: Often, you will need a place to store files and data in a persistent way. Since
    individual Pods are fairly short-lived in a Kubernetes environment, it is usually
    not a good solution to store files directly in a container's filesystem. In Kubernetes,
    this issue is solved using persistent volumes, which are basically a more flexible
    abstraction of the Docker volumes that you have already worked with before.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您需要一个持久地存储文件和数据的地方。由于在Kubernetes环境中，单个Pod的生命周期相当短暂，直接在容器的文件系统中存储文件通常不是一个好的解决方案。在Kubernetes中，通过使用持久卷来解决这个问题，这基本上是Docker卷的更灵活的抽象，您之前已经使用过。
- en: 'To create a new persistent volume, create a new `example-volume.yaml` file with
    the following contents:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的持久卷，创建一个新的`example-volume.yaml`文件，内容如下：
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Create the volume using `kubectl apply -f example-volume.yaml`. After this,
    you can find it again by running `kubectl get pv`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f example-volume.yaml`创建卷。之后，您可以通过运行`kubectl get pv`再次找到它。
- en: The preceding manifest file creates a new volume that stores its files in the
    `/data/volume01` directory on the host that the volume is used on.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的清单文件创建了一个新的卷，将其文件存储在所使用的主机上的`/data/volume01`目录中。
- en: Other than in a local development environment, using a hostPath volume for persistent
    data is a terrible idea. If a Pod using this Persistent Volume is rescheduled
    on another node, it does not have access to the same data that it had before.
    Kubernetes support a large variety of volume types that you can use to make volumes
    accessible across multiple hosts.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在本地开发环境之外，使用hostPath卷来存储持久数据是一个糟糕的主意。如果使用此持久卷的Pod在另一个节点上重新调度，它将无法访问之前的相同数据。Kubernetes支持多种卷类型，可以使卷在多个主机之间可访问。
- en: 'For example, in AWS, you could use the following volume definition:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在AWS中，你可以使用以下卷定义：
- en: '[PRE64]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Before using a persistent volume in a Pod, you will need to claim it. Kubernetes
    makes an important distinction between creating persistent volumes and using them
    in containers. This is because the person creating a persistent volume and the
    one using (claiming) it are often different. Also, by decoupling the creation
    of volumes and their usage, Kubernetes also decouples the usage of volumes in
    Pods from the actual underlying storage technology.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pod中使用持久卷之前，你需要索赔它。Kubernetes在创建持久卷和在容器中使用它之间有一个重要的区别。这是因为创建持久卷的人和使用（索赔）它的人通常是不同的。此外，通过解耦卷的创建和使用，Kubernetes还将卷在Pod中的使用与实际底层存储技术解耦。
- en: '![](img/65c9aafa-74bd-4d3c-9404-2c32b6da6253.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65c9aafa-74bd-4d3c-9404-2c32b6da6253.png)'
- en: 'Next, create a `PersistentVolumeClaim` by creating a `example-volume-claim.yaml`
    file and then calling `kubectl apply -f example-volume-claim.yaml`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过创建一个`example-volume-claim.yaml`文件，然后调用`kubectl apply -f example-volume-claim.yaml`来创建一个`PersistentVolumeClaim`：
- en: '[PRE65]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When calling `kubectl get pv` again, you will find that the status field of
    the `volume01` volume has changed to `Bound`. You can now use the newly created
    persistent volume claim when creating a Pod or Deployment:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用`kubectl get pv`时，你会发现`volume01`卷的状态字段已更改为`Bound`。现在你可以在创建Pod或Deployment时使用新创建的持久卷索赔：
- en: '[PRE66]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: When you operate your Kubernetes cluster in a cloud environment, Kubernetes
    is also able to create new persistent volumes automatically by talking to the
    cloud provider's API, for example, to create new EBS devices.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在云环境中操作你的Kubernetes集群时，Kubernetes还能够通过与云提供商的API交谈来自动创建新的持久卷，例如创建新的EBS设备。
- en: Deploying MyEvents to Kubernetes
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将MyEvents部署到Kubernetes
- en: Now that you took your first steps with Kubernetes, we can work on deploying
    the MyEvents application into a Kubernetes cluster.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在Kubernetes上迈出了第一步，我们可以开始将MyEvents应用程序部署到Kubernetes集群中。
- en: Creating the RabbitMQ broker
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RabbitMQ代理
- en: Let's start by creating the RabbitMQ broker. Since RabbitMQ is not a stateless
    component, we will use a special controller offered by Kubernetes—the `StatefulSet`
    Controller. This works similar to a Deployment controller, but will create Pods
    with a persistent identity.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建RabbitMQ代理开始。由于RabbitMQ不是一个无状态的组件，我们将使用Kubernetes提供的一个特殊控制器——`StatefulSet`控制器。这与Deployment控制器类似，但会创建具有持久标识的Pod。
- en: 'To create a new `StatefulSet`, create a new file named `rabbitmq-statefulset.yaml`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的`StatefulSet`，创建一个名为`rabbitmq-statefulset.yaml`的新文件：
- en: '[PRE67]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This definition is missing one important thing, though, that is, persistence.
    Currently, if the RabbitMQ Pod should fail for any reason, a new one will be scheduled
    without any of the state (in this case, exchanges, queues, and not-yet-dispatched
    messages) that the broker previously had. For this reason, we should also declare
    a persistent volume that can be used by this `StatefulSet`. Instead of manually
    creating a new `PersistentVolume` and a new `PersistentVolumeClaim`, we can simply
    declare a `volumeClaimTemplate` for the `StatefulSet` and let Kubernetes provision
    the new volume automatically. In a Minikube environment this is possible, because
    Minikube ships with an automatic provisioner for such volumes. In cloud environments,
    you will find similar volume provisioners.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这个定义缺少一个重要的东西，那就是持久性。目前，如果RabbitMQ Pod因任何原因失败，新的Pod将被调度而不会保留之前的状态（在这种情况下，交换、队列和尚未分发的消息）。因此，我们还应该声明一个持久卷，可以被这个`StatefulSet`使用。我们可以简单地为`StatefulSet`声明一个`volumeClaimTemplate`，让Kubernetes自动提供新的卷，而不是手动创建新的`PersistentVolume`和`PersistentVolumeClaim`。在Minikube环境中，这是可能的，因为Minikube附带了这样的卷的自动提供程序。在云环境中，你会找到类似的卷提供程序。
- en: 'Add the following section to the `StatefulSet`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下部分添加到`StatefulSet`中：
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `volumeClaimTemplate` will instruct the `StatefulSet` controller to automatically
    provision a new `PersistentVolume` and a new `PersistentVolumeClaim` for each
    instance of the `StatefulSet`. If you increase the replica count, the controller
    will automatically create more volumes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`volumeClaimTemplate`将指示`StatefulSet`控制器自动为`StatefulSet`的每个实例提供新的`PersistentVolume`和新的`PersistentVolumeClaim`。如果增加副本计数，控制器将自动创建更多的卷。'
- en: 'The last thing left to do is actually use the volume claim within the `rabbitmq`
    container. For this, modify the container spec as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是实际在`rabbitmq`容器中使用卷索赔。为此，修改容器规范如下：
- en: '[PRE69]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Create the `StatefulSet` using `kubectl apply -f rabbitmq-statefulset.yaml`.
    After this, you should see a new Pod named `rmq-0` starting up when you run `kubectl
    get pods`. You should also see the automatically generated persistent volumes
    and the respective claims when running `kubectl get pv` and `kubectl get pvc`,
    respectively.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f rabbitmq-statefulset.yaml`创建`StatefulSet`。之后，当你运行`kubectl
    get pods`时，你应该会看到一个名为`rmq-0`的新Pod正在启动。当分别运行`kubectl get pv`和`kubectl get pvc`时，你还应该看到自动生成的持久卷和相应的索赔。
- en: 'Next, create a `Service` to allow other Pods to access your RabbitMQ broker:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个`Service`，允许其他Pod访问你的RabbitMQ代理：
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As usual, create the Service using `kubectl apply -f rabbitmq-service.yaml`.
    After creating the Service, you will be able to resolve it via DNS using the hostname
    `amqp-broker` (or in its long form, `amqp-broker.default.svc.cluster.local`).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，使用`kubectl apply -f rabbitmq-service.yaml`创建Service。创建Service后，你将能够通过主机名`amqp-broker`（或其完整形式`amqp-broker.default.svc.cluster.local`）通过DNS解析它。
- en: Creating the MongoDB containers
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MongoDB容器
- en: 'Next, let''s create the MongoDB containers. Conceptually, they are not much
    different than the RabbitMQ container that you created in the preceding section.
    Just as before, we will use a `StatefulSet` with automatically provisioned volumes.
    Place the following contents in a new file called `events-db-statefulset.yaml`
    and then call `kubectl apply` on this file:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建MongoDB容器。在概念上，它们与您在前一节中创建的RabbitMQ容器没有太大的不同。与之前一样，我们将使用自动配置的卷来创建`StatefulSet`。将以下内容放入一个名为`events-db-statefulset.yaml`的新文件中，然后在此文件上调用`kubectl
    apply`：
- en: '[PRE71]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, define a Service that matches this `StatefulSet` by creating a new file, `events-db-service.yaml`,
    and calling `kubectl apply`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过创建一个新文件`events-db-service.yaml`，并调用`kubectl apply`来定义与此`StatefulSet`匹配的Service：
- en: '[PRE72]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now, we need to repeat this for the booking service's MongoDB containers. You
    can reuse almost the same definitions from above; simply replace `events` with
    `bookings` and create the `StatefulSet` and Service `bookings-db`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为预订服务的MongoDB容器重复这个过程。您几乎可以从上面重复相同的定义；只需用`bookings`替换`events`，并创建`StatefulSet`和Service`bookings-db`。
- en: Making images available to Kubernetes
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使镜像可用于Kubernetes
- en: 'Before you can now deploy your actual microservices, you need to make sure
    that the Kubernetes cluster has access to your images. Typically, you will need
    to have your self-built images available in a container registry for this. If
    you are using Minikube and want to save yourself the hassle of setting up your
    own image registry, you can do the following instead:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要确保Kubernetes集群可以访问您的镜像，然后才能部署实际的微服务。通常，您需要将自己构建的镜像可用于容器注册表。如果您使用Minikube并且想要避免设置自己的镜像注册表的麻烦，可以使用以下方法：
- en: '[PRE73]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The first command will instruct your local shell to connect not to your local
    Docker Engine, but the Docker Engine within the Minikube VM, instead. Then, using
    a regular `docker container build` command, you can build the container image
    you are going to use directly on the Minikube VM.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令将指示您的本地shell连接到Minikube VM内的Docker Engine，而不是本地Docker Engine。然后，使用常规的`docker
    container build`命令，您可以直接在Minikube VM上构建要使用的容器镜像。
- en: 'If your images are available in a private registry (like, for example, the
    Docker Hub, Quay.io or a self-hosted registry), you will need to configure your
    Kubernetes cluster so that it is authorized to actually access these images. For
    this, you will add your registry credentials as a `Secret` object. For this, use
    the `kubectl create secret` command:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的镜像可用于私有注册表（例如Docker Hub、Quay.io或自托管注册表），则需要配置Kubernetes集群，以便它被授权实际访问这些镜像。为此，您将把注册表凭据添加为`Secret`对象。使用`kubectl
    create secret`命令：
- en: '[PRE74]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the code example above, `my-private-registry` is an arbitrarily chosen name
    for your set of Docker credentials. The `--docker-server` flag `https://index.docker.io/v1/`
    specifies the URL of the official Docker Hub. If you are using a third-party registry,
    remember to change this value accordingly.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，`my-private-registry`是您的Docker凭据集的任意选择的名称。`--docker-server`标志`https://index.docker.io/v1/`指定了官方Docker
    Hub的URL。如果您使用第三方注册表，请记住相应地更改此值。
- en: 'You can now use this newly created `Secret` object when creating a new Pod,
    by adding an `imagePullSecrets` attribute to the Pod specification:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在创建新的Pod时使用这个新创建的`Secret`对象，通过向Pod规范添加`imagePullSecrets`属性：
- en: '[PRE75]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Using the `imagePullSecrets` attribute also works when you are creating Pods
    using a `StatefulSet` or a Deploymet controller.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`StatefulSet`或Deploymet控制器创建Pod时，`imagePullSecrets`属性也可以使用。
- en: Deploying the MyEvents components
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署MyEvents组件
- en: Now that you have your container images available on your Kubernetes cluster
    (either by building them locally on your Minikube VM or by pushing them to a registry
    and authorizing your cluster to access that registry), we can begin deploying
    the actual event service. Since the event service itself is stateless, we will
    deploy it using a regular Deployment object, not as `StatefulSet`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的容器镜像可以在Kubernetes集群上使用（无论是在Minikube VM上本地构建还是将它们推送到注册表并授权您的集群访问该注册表），我们可以开始部署实际的事件服务。由于事件服务本身是无状态的，我们将使用常规的Deployment对象部署它，而不是`StatefulSet`。
- en: 'Continue by creating a new file—`events-deployment.yaml`—with the following
    contents:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过创建一个新文件`events-deployment.yaml`，并使用以下内容：
- en: '[PRE76]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note the  `imagePullPolicy: Never` property. This is necessary if you have
    built the `myevents/eventservice` image directly on the Minikube VM. If you have
    an actual container registry available to which you can push your image, you should
    omit this property (and add a `imagePullSecrets` attribute, instead).'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意`imagePullPolicy: Never`属性。如果您直接在Minikube VM上构建了`myevents/eventservice`镜像，则这是必需的。如果您有一个实际的容器注册表可用，可以将镜像推送到该注册表，您应该省略此属性（并添加`imagePullSecrets`属性）。'
- en: 'Next, create the respective Service by creating a new file, `events-service.yaml`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过创建一个新文件`events-service.yaml`来创建相应的Service：
- en: '[PRE77]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Create both Deployment and Service with the respective `kubectl apply` calls.
    Shortly thereafter, you should see the respective containers showing up in the
    `kubectl get pods` output.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相应的`kubectl apply`调用创建Deployment和Service。不久之后，您应该会在`kubectl get pods`输出中看到相应的容器出现。
- en: Proceed similarly for the booking service. You can find the full manifest files
    for the booking service in the code examples of this book.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地进行预订服务。您可以在本书的代码示例中找到预订服务的完整清单文件。
- en: 'Finally, let''s deploy the frontend application. Create another Deployment
    with the following manifest:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，让我们部署前端应用程序。使用以下清单创建另一个Deployment： '
- en: '[PRE78]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create the corresponding `Service` with the following manifest:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建以下清单来创建相应的`Service`：
- en: '[PRE79]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Configuring HTTP Ingress
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置HTTP Ingress
- en: At this point, you have all required services for the MyEvents application running
    in your Kubernetes cluster. However, there is no convenient way (yet) to access
    these services from outside the cluster. One possible solution to make them accessible
    would be to use **NodePort** services (which we have done before in one of the
    previous sections). However, this would result in your services being exposed
    at some randomly chosen high TCP ports, which is not desirable for a production
    setup (HTTP(S) services should be available at TCP ports `80` and `443`).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的Kubernetes集群中正在运行MyEvents应用程序所需的所有服务。但是，目前还没有方便的方法可以从集群外部访问这些服务。使它们可访问的一种可能解决方案是使用**NodePort**服务（我们在以前的某个部分中已经做过）。但是，这将导致您的服务在一些随机选择的高TCP端口上暴露，这对于生产设置来说是不可取的（HTTP(S)服务应该在TCP端口`80`和`443`上可用）。
- en: 'If your Kubernetes cluster is running in a public cloud environment (more precisely,
    AWS, GCE, or Azure), you can create a `LoadBalancer` `Service` as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Kubernetes集群在公共云环境中运行（更确切地说是AWS、GCE或Azure），您可以按以下方式创建`LoadBalancer` `Service`：
- en: '[PRE80]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This will provision the appropriate cloud provider resources (for example, an
    **Elastic Load Balancer** in AWS) to make your service publicly accessible at
    a standard port.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您的服务提供适当的云提供商资源（例如，在AWS中为**弹性负载均衡器**）以使您的服务在标准端口上公开访问。
- en: However, Kubernetes also offers another feature that allows you to handle incoming
    HTTP traffic called **Ingress**. Ingress resources offer you a more fine-grained
    control of how your HTTP services should be accessible from the outside world.
    For example, our application consists of two backend services and one frontend
    application, all three of which need to be publicly accessible via HTTP. While
    it is possible to create separate `LoadBalancer` services for each of these components,
    this would result in each of these three services receiving its own IP address
    and requiring its own hostname (for example, serving the frontend app on `https://myevents.example`,
    and the two backend services on `https://events.myevents.example` and `https://bookings.myevents.example`).
    This may get cumbersome to use, and in many microservice architecture, there is
    often a requirement to present a single entry point for external API access. Using
    Ingress, we can declare a path-to-service mapping that, for example, makes all
    backend services accessible at `https://api.myevents.example`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Kubernetes还提供了另一个功能，允许您处理传入的HTTP流量，称为**Ingress**。Ingress资源为您提供了更精细的控制，以确定您的HTTP服务应该如何从外部世界访问。例如，我们的应用程序由两个后端服务和一个前端应用程序组成，这三个组件都需要通过HTTP公开访问。虽然可以为这些组件的每个创建单独的`LoadBalancer`服务，但这将导致这三个服务分别获得自己的IP地址，并需要自己的主机名（例如，在`https://myevents.example`上提供前端应用程序，并在`https://events.myevents.example`和`https://bookings.myevents.example`上提供两个后端服务）。这可能会变得繁琐，并且在许多微服务架构中，通常需要提供外部API访问的单个入口点。使用Ingress，我们可以声明路径到服务的映射，例如，使所有后端服务在`https://api.myevents.example`上可访问。
- en: '[https://github.com/kubernetes/ingress/blob/master/controllers/nginx/README.md](https://github.com/kubernetes/ingress/blob/master/controllers/nginx/README.md).'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes/ingress/blob/master/controllers/nginx/README.md](https://github.com/kubernetes/ingress/blob/master/controllers/nginx/README.md)。'
- en: 'Before using Ingress resources, you will need to enable an Ingress controller
    for your Kubernetes clusters. This is highly specific to your individual environment;
    some cloud-providers offer special solutions for handling Kubernetes Ingress traffic,
    while in other environments, you will need to run your own. Using Minikube, however,
    enabling Ingress is a simple command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Ingress资源之前，您需要为Kubernetes集群启用Ingress控制器。这与您的个人环境高度相关；一些云提供商提供了处理Kubernetes
    Ingress流量的特殊解决方案，而在其他环境中，您需要自己运行。但是，使用Minikube，启用Ingress是一个简单的命令：
- en: '[PRE81]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If instead, you intend to run your own Ingress controller on Kubernetes, take
    a look at the official documentation of the NGINX Ingress controller. It may seem
    complicated at first, but just as many internal Kubernetes services, an Ingress
    controller also just consists of Deployment and Service recources.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算在Kubernetes上运行自己的Ingress控制器，请查看NGINX Ingress控制器的官方文档。起初可能看起来很复杂，但就像许多内部Kubernetes服务一样，Ingress控制器也只包括Deployment和Service资源。
- en: After enabling the Ingress controller in Minikube, your Minikube VM will start
    responding to HTTP requests on ports `80` and `443`. To determine which IP address
    you need to connect to, run the `minikube ip` command.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在Minikube中启用Ingress控制器后，您的Minikube VM将开始在端口`80`和`443`上响应HTTP请求。要确定需要连接的IP地址，运行`minikube
    ip`命令。
- en: 'To make our services accessible to the open world, create a new Kubernetes
    resource in a new file—`ingress.yaml`—with the following contents:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的服务对外界可访问，创建一个新的Kubernetes资源文件`ingress.yaml`，其中包含以下内容：
- en: '[PRE82]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create the Ingress resource using `kubectl apply -f ingress.yaml`. Of course,
    the `myevents.example` domain will not be publicly accessible (that''s the entire
    point of the `.example` top-level domain); so, to actually test this setup, you
    can add a few entries to your host file (`/etc/hosts` on macOS and Linux; `C:\Windows\System32\drivers\etc\hosts`
    on Windows):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f ingress.yaml`创建Ingress资源。当然，`myevents.example`域名将不会公开访问（这是`.example`顶级域的整个目的）；因此，要实际测试此设置，您可以将一些条目添加到您的主机文件（macOS和Linux上的`/etc/hosts`；Windows上的`C:\Windows\System32\drivers\etc\hosts`）：
- en: '[PRE83]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Typically, `192.168.99.100` should be the (only locally routable) IP address
    of the Minikube VM. Cross-check with the output of the `minikube ip` command to
    be sure.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`192.168.99.100`应该是Minikube VM的（唯一可路由的）IP地址。通过运行`minikube ip`命令的输出进行交叉检查以确保。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to use container technologies such as Docker
    to package your application, including all its dependencies into container images.
    You learned how to build container images from your application and deploy them
    in a production container environment built on Kubernetes.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何使用诸如Docker之类的容器技术将您的应用程序及其所有依赖项打包到容器映像中。您学会了如何从您的应用程序构建容器映像，并在基于Kubernetes构建的生产容器环境中部署它们。
- en: We will get back to building container images in Chapter 9, where you will learn
    how to further automate your container build tool chain, allowing you to completely
    automate your application deployment, starting with a git push command and ending
    with an updated container image running in your Kubernetes cloud.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第9章回到构建容器映像，您将学习如何进一步自动化容器构建工具链，使您能够完全自动化应用程序部署，从git push命令开始，到在您的Kubernetes云中运行更新的容器映像结束。
- en: Up until now, we have been fairly cloud-agnostic. Each and every example that
    we have looked at so far will work in any major public or private cloud, be it
    AWS, Azure, GCE, or OpenStack. If fact, container technologies are often considered
    an excellent way to abstract from the individual quirks of the cloud providers
    and avoid a (potentially costly) vendor lock-in.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直相当云不可知。到目前为止，我们所看到的每个示例都可以在任何主要的公共或私有云中运行，无论是AWS、Azure、GCE还是OpenStack。事实上，容器技术通常被认为是摆脱云提供商的个别怪癖并避免（潜在的昂贵）供应商锁定的绝佳方式。
- en: All this will change in the next two chapters, where we will take a look at
    one of the major cloud providers—**Amazon Web Services** (**AWS**). You will learn
    about the intricacies of each of these providers, how to deploy the MyEvents application
    onto these platforms, and how to use the unique features offered by them.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些将在接下来的两章中发生变化，我们将看看其中一个主要的云服务提供商——**亚马逊网络服务**（**AWS**）。您将了解每个提供商的复杂性，如何将MyEvents应用程序部署到这些平台上，以及如何使用它们提供的独特功能。
