- en: AWS I – Fundamentals, AWS SDK for Go, and EC2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS I - 基础知识，Go的AWS SDK和EC2
- en: Welcome to a new step in our journey to learn cloud programming in the Go language.
    In this chapter, we'll start discussing cloud technologies by covering the popular **Amazon
    Web Services** (**AWS**) platform. AWS was among the first cloud platforms to
    be offered for customers to use in their start-ups, their enterprises, and even
    for their personal side projects. AWS was launched by Amazon in 2006 and has been
    growing continuously ever since. Due to the large size of the topic, we will divide
    the material into two chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们学习Go语言云编程的新阶段。在本章中，我们将开始讨论云技术，涵盖热门的亚马逊网络服务（AWS）平台。AWS是最早提供给客户在其创业公司、企业甚至个人项目中使用的云平台之一。AWS于2006年由亚马逊推出，并自那时起不断增长。由于该主题的规模较大，我们将把材料分成两章。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The fundamentals of AWS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS基础知识
- en: The AWS SDK for Go
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go的AWS SDK
- en: How to set up and secure EC2 instances
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置和保护EC2实例
- en: AWS fundamentals
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS基础知识
- en: The simplest definition of AWS is that it's a service provided by Amazon, where
    you can buy virtual machines, databases, message queues, RESTful API endpoints,
    and all kinds of software products hosted on their cloud platform. To fully appreciate
    AWS, we will need to cover some of the major services that are offered on the
    platform. We will then dig deeper to learn how to reap the power of Go to build
    applications capable of utilizing the services AWS provides via its cloud APIs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: AWS的最简单定义是，它是亚马逊提供的一项服务，您可以在其云平台上购买虚拟机、数据库、消息队列、RESTful API端点以及各种托管的软件产品。要充分了解AWS，我们需要涵盖平台上提供的一些主要服务。然后，我们将深入学习如何利用Go来构建能够利用AWS通过其云API提供的服务的应用程序的能力。
- en: '**Elastic** **Compu****te** **Cloud** (**E****C2**): The **Elastic Compute
    Cloud** (**EC2**) is one of the most popular services provided by AWS. It can
    simply be described as a service to be used when needing to spin new server instances
    on AWS. EC2 is special in that it makes the process of starting servers and allocating
    resources practically easy for users and developers. EC2 allows auto-scaling,
    which means that applications can automatically scale up and down based on the
    user''s needs. The service supports multiple setups and operating systems.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性计算云（EC2）：弹性计算云（EC2）是AWS提供的最受欢迎的服务之一。它可以简单地描述为在AWS上需要旋转新服务器实例时使用的服务。EC2之所以特殊，是因为它使启动服务器和分配资源的过程对用户和开发人员来说几乎是轻而易举的。EC2支持自动扩展，这意味着应用程序可以根据用户的需求自动扩展和缩减。该服务支持多种设置和操作系统。
- en: '**Simple Storage Service** (**S3**): S3 allows developers to store different
    types of data for later retrieval and data analysis.S3 is another popular AWS
    service that is used by numerous developers all over the world. Typically, developers
    store images, photos, videos, and similar types of data on S3\. The service is
    reliable, scales well, and easy to use. The use cases for S3 are plentiful; it
    can be used for web sites, mobile applications, IOT sensors, and more.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单存储服务（S3）：S3允许开发人员存储不同类型的数据以供以后检索和数据分析。S3是另一个全球众多开发人员使用的热门AWS服务。通常，开发人员在S3上存储图像、照片、视频和类似类型的数据。该服务可靠、扩展性好，易于使用。S3的用例很多；它可用于网站、移动应用程序、IOT传感器等。
- en: '**Simple Queue Service (SQS)**: SQS is a hosted message queue service provided
    by AWS. In a nutshell, we can describe a message queue as a piece of software
    that can reliably receive messages, queue them, and deliver them between other
    applications. SQS is a scalable, reliable, and distributed hosted message queue.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单队列服务（SQS）：SQS是AWS提供的托管消息队列服务。简而言之，我们可以将消息队列描述为一种软件，可以可靠地接收消息、排队并在其他应用程序之间传递它们。SQS是一种可扩展、可靠且分布式的托管消息队列。
- en: '**Amazon API Gateway**: Amazon API gateway is a hosted service that enables
    developers to create secure web APIs at scale. It not only allows you to create
    and publish APIs, but also exposes sophisticated features such as access control,
    authorization, API versioning, and status monitoring.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊API网关：亚马逊API网关是一个托管服务，使开发人员能够大规模创建安全的Web API。它不仅允许您创建和发布API，还公开了诸如访问控制、授权、API版本控制和状态监控等复杂功能。
- en: '**DynamoDB**: DynamoDB is a NoSQL database that is hosted in AWS and provided
    as a service. The database is flexible, reliable, and scalable with a latency
    of only few milliseconds. NoSQL is a term used to describe databases that are
    nonrelational and enjoy high performance. A nonrelational database is a type of
    database that doesn''t use tables with relations to store data. DynamoDB makes
    use of two data models: a document store and a key-value store. A document store
    database stores data in a collection of document files, whereas a key-value store
    puts data in simple key value pairs. In the next chapter, you will learn how to
    build Go applications in AWS that are capable of utilizing the power of DynamoDB.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DynamoDB：DynamoDB是一种托管在AWS中并作为服务提供的NoSQL数据库。该数据库灵活、可靠，延迟仅为几毫秒。NoSQL是用来描述非关系型且性能高的数据库的术语。非关系型数据库是一种不使用关系表来存储数据的数据库类型。DynamoDB利用了两种数据模型：文档存储和键值存储。文档存储数据库将数据存储在一组文档文件中，而键值存储将数据放入简单的键值对中。在下一章中，您将学习如何构建能够利用DynamoDB强大功能的AWS中的Go应用程序。
- en: '**AWS SDK for** **Go**: The AWS SDK for Go is a collection of Go libraries
    that empower developers to write applications that can interact with the AWS ecosystem.
    Those libraries are the tools we''ll utilize to make use of the different AWS
    services that we have mentioned so far, such as EC2, S3, DynamoDB, and SQS.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go语言的AWS SDK：AWS SDK for Go是一组Go库，赋予开发人员编写可以与AWS生态系统进行交互的应用程序的能力。这些库是我们将利用的工具，用于利用我们迄今提到的不同AWS服务，如EC2、S3、DynamoDB和SQS。
- en: Throughout this chapter and the next one, we will be covering those technologies
    in deeper detail. Every single topic we will discuss in this chapter is massive
    and can be covered in entire books. So, instead of covering every single aspect
    of each AWS service, we will provide practical insights into each service and
    how to utilize them as a whole to build powerful production grade applications.
    Before diving deep into each AWS service, let's cover some general concepts in
    the AWS world.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，我们将更深入地介绍这些技术。我们将在本章讨论的每个主题都是庞大的，可以用整本书来覆盖。因此，我们不会覆盖每个AWS服务的每个方面，而是提供对每个服务的实际见解，以及如何将它们作为一个整体来构建强大的生产级应用程序。在深入研究每个AWS服务之前，让我们先了解一些AWS世界中的一般概念。
- en: The AWS console
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS控制台
- en: 'The AWS console is the web portal that provides us access to the multitude
    of services and features that AWS offers. To access the portal, you first need
    to navigate to [aws.amazon.com](http://aws.amazon.com), and then choose the Sign
    In to the Console option, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: AWS控制台是一个网页门户，为我们提供访问AWS提供的多种服务和功能。要访问该门户，您首先需要导航到[aws.amazon.com](http://aws.amazon.com)，然后选择“登录到控制台”选项，如下所示：
- en: '![](img/439b8a86-a7fb-4a58-a6f1-d6aa839a59bb.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/439b8a86-a7fb-4a58-a6f1-d6aa839a59bb.jpg)'
- en: 'Once you sign in to the console, you will be greeted with a web page that showcases
    the services provided by AWS:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录控制台，您将看到一个展示AWS提供的服务的网页：
- en: '![](img/d546f848-b579-4e2c-942b-b3f31811b158.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d546f848-b579-4e2c-942b-b3f31811b158.png)'
- en: AWS command-line interface (CLI)
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS命令行界面（CLI）
- en: AWS CLI is an open source tool that provides commands to interact with AWS services.
    AWS CLI is cross-platform; it can run on Linux, macOS, and Windows. In this chapter,
    we will use the tool for certain tasks, such as copying files from an `S3` folder
    to an EC2 instance. AWS CLI can perform tasks that are similar to those performed
    by the AWS console; this includes configuration, deployment, and monitoring of
    AWS services. The tool can be found at [https://aws.amazon.com/cli/](https://aws.amazon.com/cli/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI是一个开源工具，提供与AWS服务交互的命令。AWS CLI是跨平台的；它可以在Linux、macOS和Windows上运行。在本章中，我们将使用该工具执行某些任务，例如从`S3`文件夹复制文件到EC2实例。AWS
    CLI可以执行类似于AWS控制台执行的任务；这包括AWS服务的配置、部署和监控。该工具可以在以下网址找到：[https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)。
- en: AWS regions and zones
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS区域和可用区
- en: AWS services are hosted on multiple geographical locations around the world.
    In the world of AWS, locations consist of regions and availability zones. Each
    region is an independent geographical location. Each region contains multiple
    isolated internal locations known as availability zones. Some services — such
    as Amazon EC2, for example—give you full power as to which regions to use for
    your service deployment. You can also replicate resources across regions. You
    can find a list of available AWS regions at [http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: AWS服务托管在世界各地的多个地理位置。在AWS世界中，位置包括区域和可用区。每个区域是一个独立的地理位置。每个区域包含多个隔离的内部位置，称为可用区。一些服务
    —— 例如Amazon EC2，例如 —— 让您完全控制要为您的服务部署使用哪些区域。您还可以在区域之间复制资源。您可以在以下网址找到可用的AWS区域列表：[http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions)。
- en: For complex application deployments in AWS, developers typically deploy their
    microservices into multiple regions. This ensures that the application will enjoy
    high availability, even if any Amazon data center in a certain region suffers
    from a failure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在AWS中进行复杂应用程序部署的开发人员，他们通常将其微服务部署到多个区域。这样可以确保即使某个区域的亚马逊数据中心遭受故障，应用程序也能享受高可用性。
- en: AWS tags
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS标签
- en: AWS tags is another important concept in the AWS universe. It allows you to
    categorize your different AWS resources properly. This is very useful, especially
    when you use numerous AWS services for different things. For example, you can
    set one or more tags to identify the `S3` storage bucket that you use for your
    mobile application. The same tags can then be used to identify the EC2 instance
    you use for that mobile application backend. A tag is a key value pair; the value
    is optional.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: AWS标签是AWS宇宙中的另一个重要概念。它允许您正确分类您的不同AWS资源。这非常有用，特别是当您为不同的事物使用多个AWS服务时。例如，您可以设置一个或多个标签来识别您用于移动应用程序的`S3`存储桶。然后可以使用相同的标签来识别您用于该移动应用程序后端的EC2实例。标签是键值对；值是可选的。
- en: A good resource for better understanding AWS tags can be found at: [https://aws.amazon.com/answers/account-management/aws-tagging-strategies/](https://aws.amazon.com/answers/account-management/aws-tagging-strategies/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地理解AWS标签的资源可以在以下网址找到：[https://aws.amazon.com/answers/account-management/aws-tagging-strategies/](https://aws.amazon.com/answers/account-management/aws-tagging-strategies/)。
- en: AWS Elastic Beanstalk
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS弹性Beanstalk
- en: Before we start to practically dive into AWS services, it is important to mention
    a useful service in the AWS ecosystem called *Elastic Beanstalk*. The purpose
    of this service is to provide an easy-to-use configuration wizard via the AWS
    console, which allows you to quickly deploy and scale your applications on AWS.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际深入研究AWS服务之前，有必要提到AWS生态系统中一个有用的服务，称为*弹性Beanstalk*。该服务的目的是通过AWS控制台提供一个易于使用的配置向导，让您可以快速在AWS上部署和扩展您的应用程序。
- en: This service is useful in multiple scenarios, and we encourage the reader to
    explore it after reading this chapter and the next chapter of the book. However,
    we will not be focusing on Elastic Beanstalk in this book. That is because the
    purpose of this book when it comes to AWS is to provide you a practical foundational
    knowledge on the inner workings of the main AWS services. This knowledge will
    make it easy for you to not only deploy and run applications on AWS, but also
    to have a good grasp of how things work, and make tweaks when necessary. The foundational
    knowledge is also what you would need to then move your skills to the next level
    beyond this book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这项服务在多种场景中都很有用，我们鼓励读者在阅读本章和本书的下一章之后探索它。然而，在本书中我们不会专注于Elastic Beanstalk。这是因为本书在涉及AWS时的目的是为您提供关于主要AWS服务内部工作的实用基础知识。这些知识将使您不仅能够在AWS上部署和运行应用程序，还能够对事物的运作有很好的把握，并在必要时进行调整。这些基础知识也是您需要将技能提升到本书之外的下一个水平所需的。
- en: Covering AWS Beanstalk without diving into the key AWS services that make AWS
    a great choice for developers will not be enough for you to obtain enough knowledge
    to be effective in the long run. However, if you take a look at AWS Beanstalk
    after going through this chapter and the next chapter of the book, you will be
    able to understand what happens behind the scenes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 涵盖AWS Beanstalk而不深入探讨使AWS成为开发人员的绝佳选择的关键AWS服务将不足以让您获得足够的知识以长期有效。然而，如果您在阅读本章和本书的下一章之后再看AWS
    Beanstalk，您将能够理解幕后发生了什么。
- en: The service can be found at[ https://aws.amazon.com/elasticbeanstalk/](https://aws.amazon.com/elasticbeanstalk/).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务可以在[https://aws.amazon.com/elasticbeanstalk/](https://aws.amazon.com/elasticbeanstalk/)找到。
- en: AWS services
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS服务
- en: Now, it's time to learn how to utilize the power of Go to interact with AWS
    and build cloud native applications. In this section, we'll start a practical
    dive into some AWS services needed to build modern production grade cloud applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候学习如何利用Go的力量与AWS交互并构建云原生应用程序了。在本节中，我们将开始实际深入一些构建现代生产级云应用程序所需的AWS服务。
- en: AWS SDK for Go
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS SDK for Go
- en: As mentioned earlier, the AWS SDK for Go is a collection of libraries that enables
    Go to expose the power of AWS. In order to utilize the SDK, there are some key
    concepts we need to cover first.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，AWS SDK for Go是一组库，使Go能够展现AWS的强大功能。为了利用SDK，我们首先需要了解一些关键概念。
- en: 'The first step we will need to do is to install the AWS SDK for Go; this is
    done by running the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一步是安装AWS SDK for Go；通过运行以下命令来完成：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Like any other Go package, this command will deploy the AWS SDK libraries to
    our development machine.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他Go包一样，这个命令将在我们的开发机器上部署AWS SDK库。
- en: Configuring the AWS region
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置AWS区域
- en: 'The second step is to specify the AWS region; this helps identify where to
    send the SDK requests when making calls. There is no default region for the SDK,
    which is why we must specify one. There are two ways to do that:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是指定AWS区域；这有助于确定在进行调用时发送SDK请求的位置。SDK没有默认区域，这就是为什么我们必须指定一个区域。有两种方法可以做到这一点：
- en: Assigning the region value to an environmental variable called `AWS_REGION`.
    An example of a region value is `us-west-2` or `us-east-2`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将区域值分配给名为`AWS_REGION`的环境变量。区域值的示例是`us-west-2`或`us-east-2`。
- en: Specifying it in the code—more to that later.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中指定它——稍后会更多。
- en: Configuring AWS SDK authentication
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置AWS SDK身份验证
- en: The third step is to achieve proper AWS authentication; this step is more involved,
    but very important to ensure the security of our code that is interacting with
    different AWS services. To do this, we will need to provide security credentials
    to our applications in order to make secure calls to AWS.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是实现适当的AWS身份验证；这一步更加复杂，但非常重要，以确保我们的代码与不同的AWS服务进行交互时的安全性。为了做到这一点，我们需要向我们的应用程序提供安全凭据，以便对AWS进行安全调用。
- en: 'There are two main ways to generate the credentials you need to make your code
    works when talking to AWS via the SDK:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 生成您需要使代码在通过SDK与AWS通信时正常工作的凭据有两种主要方法：
- en: 'Creating a user, which is simply an identity that represents a person or a
    service. You can assign individual permissions to users directly or assemble multiple
    users into a group that allow users to share permissions. The AWS SDK for Go requires
    users to be secured using AWS access keys to authenticate requests you send to
    AWS. An AWS access key is composed of two pieces: an access key ID and a secret
    access key. This is what we use when running applications from our local servers.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户，它只是代表一个人或一个服务的身份。您可以直接为用户分配单独的权限，或将多个用户组合成一个允许用户共享权限的组。AWS SDK for Go要求用户使用AWS访问密钥来对发送到AWS的请求进行身份验证。AWS访问密钥由两部分组成：访问密钥ID和秘密访问密钥。这是我们在本地服务器上运行应用程序时使用的内容。
- en: The next way is to create a role. A role is very similar to a user in that it's
    an identity with specific permissions assigned to it. However, a role is not meant
    to be assigned to people; it instead is assigned to whoever needs it based on
    specific conditions. For example, a role can be attached to an EC2 instance, which
    would allow applications running on this EC2 instance to make secure calls to
    AWS without specifying a distinct user. This is the recommended approach when
    running applications on EC2 instances, where the applications are expected to
    make AWS API calls.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一种方法是创建一个角色。角色与用户非常相似，因为它是具有特定权限的身份。然而，角色不是分配给人员的；它是根据特定条件分配给需要它的人员。例如，可以将角色附加到EC2实例，这将允许在该EC2实例上运行的应用程序进行安全调用AWS，而无需指定不同的用户。这是在EC2实例上运行应用程序时的推荐方法，其中预期应用程序将进行AWS
    API调用。
- en: Creating IAM Users
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建IAM用户
- en: If you are running your application from your own local machine, the recommended
    way to create access keys is to create a user that has specific permissions to
    access the AWS services that you would like your code to utilize. This is done
    by creating a user in the **AWS identity and access management** (**IAM**).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是从自己的本地计算机运行应用程序，创建访问密钥的推荐方式是创建一个具有特定权限访问AWS服务的用户。这是通过在**AWS身份和访问管理**（**IAM**）中创建用户来完成的。
- en: 'To create a user in IAM, we will first need to log in to the AWS main web console,
    then click on IAM, which should be under the Security, Identity & Compliance category:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要在IAM中创建用户，我们首先需要登录到AWS主要网络控制台，然后点击IAM，它应该在“安全性、身份和合规性”类别下：
- en: '![](img/bcd9b3b4-a29c-4430-95c3-736eccb72700.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcd9b3b4-a29c-4430-95c3-736eccb72700.jpg)'
- en: 'Next, we will need to click on the User option on the right-hand side, then
    click on Add user to create a new IAM user:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要点击右侧的“用户”选项，然后点击“添加用户”来创建一个新的IAM用户：
- en: '![](img/eebc7730-bb98-494a-9a3c-8e94d4ea0874.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eebc7730-bb98-494a-9a3c-8e94d4ea0874.png)'
- en: 'From there, you will be treated with a user creation wizard to help you create
    a user and generate access keys. In the first step of this wizard, you will get
    to choose a username and select the AWS access type for the user. The AWS access
    type consists of two main types: programmatic access or AWS management console
    access. Obviously, to create users capable of being used by the AWS SDK, we will
    need to select programmatic access, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将被引导使用用户创建向导来帮助您创建用户并生成访问密钥。在此向导的第一步中，您将可以选择用户名并选择用户的AWS访问类型。AWS访问类型包括两种主要类型：程序访问或AWS管理控制台访问。显然，为了创建可以被AWS
    SDK使用的用户，我们需要选择程序访问，如下所示：
- en: '![](img/5b021144-db9b-4003-8e25-fb18962a8969.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b021144-db9b-4003-8e25-fb18962a8969.png)'
- en: 'The next step will involve attaching permissions to the user being created.
    There are three approaches for assigning permissions to users. However, before
    we discuss the three approaches, we will need first to understand the concept
    of policies. A policy is simply a flexible approach to define permissions. For
    example, a new policy can be created to define a read-only access to a specific
    S3 folder. Any user or group who then get this policy attached to them will only
    be permitted a read-only access to this specific S3 folder. AWS provides a number
    of precreated policies that we can use in our configuration. For example, there
    is a policy called **AmazonS3FullAccess**, which allows full access to S3 to its
    holders. Now, let''s return to the three approaches for assigning permissions
    to users:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将涉及将权限附加到正在创建的用户。然而，在我们讨论三种方法之前，我们首先需要了解策略的概念。策略只是定义权限的一种灵活方法。例如，可以创建一个新策略来定义对特定S3文件夹的只读访问权限。然后，任何获得此策略附加的用户或组将只被允许对此特定S3文件夹进行只读访问。AWS提供了许多预创建的策略，我们可以在我们的配置中使用。例如，有一个名为**AmazonS3FullAccess**的策略，允许其持有者对S3进行完全访问。现在，让我们回到为用户分配权限的三种方法：
- en: '**Adding the user to a group**: A group is an entity that can have its own
    policies. Multiple users can be added to one or more groups. You can think of
    a group simply as a folder of users. Users under a specific group will enjoy access
    to all permissions allowed by the policies of the said group. The configuration
    wizard in this step will allow you to create a new group and assign policies to
    it, if need be. This is typically the recommended way to assign permissions to
    users.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将用户添加到组中**：组是一个可以拥有自己策略的实体。多个用户可以添加到一个或多个组中。您可以将组简单地看作是用户的文件夹。特定组下的用户将享有所述组策略允许的所有权限。在这一步中的配置向导将允许您创建一个新组并为其分配策略，如果需要的话。这通常是分配权限给用户的推荐方式。'
- en: '**Copying permissions from existing users**: This allows the new user to enjoy
    all groups and policies already configured for a different user. This is good
    to use, for example, to add a user to a new team.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从现有用户复制权限**：这允许新用户享有已为不同用户配置的所有组和策略。例如，将用户添加到新团队中时使用。'
- en: '**Attaching existing policies directly**: This allows assigning policies directly
    to the new users without going through groups or copying from other users. The
    disadvantage of this approach is that if each user get assigned individual policies
    without the sense of order provided by groups, it becomes tedious to manage the
    users as they grow in numbers.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接附加现有策略**：这允许直接将策略分配给新用户，而无需经过组或从其他用户复制。这种方法的缺点是，如果每个用户都被分配了个别的策略，而没有组提供的秩序感，随着用户数量的增加，管理用户将变得繁琐。'
- en: 'The following is a screenshot of the three options being presented:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是三个选项的截图：
- en: '![](img/ce462fe2-dd3a-4a7f-bc32-05af793fdade.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce462fe2-dd3a-4a7f-bc32-05af793fdade.png)'
- en: Once this setting of permissions is done, we get to review our choices and proceed
    to create a new user. Once a new user gets created, we will get an option to download
    the user's access keys as a CSV file. We must do that in order to be able to utilize
    those access keys later in our applications. An access key is composed of the
    access key ID and the secret access key value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完成权限设置后，我们可以审查我们的选择并继续创建新用户。一旦创建了新用户，我们将有一个选项来下载用户的访问密钥作为CSV文件。我们必须这样做才能在以后的应用程序中利用这些访问密钥。访问密钥由访问密钥ID和秘密访问密钥值组成。
- en: 'Once you have your access keys, there are multiple approaches to allow your
    code to use them; we will discuss three of them:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了访问密钥，有多种方法可以让您的代码使用它们；我们将讨论其中的三种：
- en: '**Utilizing a environmental variables directly**: There are two main environmental
    variables that our AWS SDK code will look for, and a third environmental variable,
    which is optional. We will only discuss the two main environmental variables:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接使用环境变量**：AWS SDK代码将查找两个主要的环境变量，以及一个可选的第三个环境变量。我们只讨论两个主要的环境变量：'
- en: '`AWS_ACCESS_KEY_ID`: Where we set the key ID of our access key'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWS_ACCESS_KEY_ID`：在这里我们设置访问密钥的密钥ID'
- en: '`AWS_SECRET_ACCESS_KEY`: Where we set the secret key value of our access key'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWS_SECRET_ACCESS_KEY`：在这里我们设置访问密钥的秘密密钥值'
- en: Environmental variables are typically checked, by default, by the SDK before
    moving on to the next approach.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量通常在SDK默认情况下在移动到下一个方法之前进行检查。
- en: '**Utilizing a credentials file**: The credentials file is a plain text file
    that will host your access keys. The file must be named `credentials` and needs
    to be located in the `.aws/` folder of the home directory of your computer. The
    home directory will obviously vary depending on your operating system. In Windows,
    you can point out your home directory using the environmental variable `%UserProfile%`.
    In Unix platforms, you use an environmental variable called `$HOME` or just `~`.
    The credentials file is of the `.ini` format and can look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**利用凭证文件**：凭证文件是一个存放访问密钥的纯文本文件。该文件必须命名为`credentials`，并且必须位于计算机主目录的`.aws/`文件夹中。主目录显然会根据您的操作系统而变化。在Windows中，您可以使用环境变量`%UserProfile%`指定主目录。在Unix平台上，您可以使用名为`$HOME`或`~`的环境变量。凭证文件是`.ini`格式的，可能如下所示：'
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The names between the square brackets are called **profiles**. As shown from
    the preceding snippet, your credentials file can specify different access keys
    mapped to different profiles. However, then comes an important question, what
    would be the profile to use for our application? For this, we would need to create
    an environmental variable called `AWS_PROFILE,` which will specify the profile
    name and the name of the application that it is assigned to. For example, let''s
    say our application is called `testAWSapp`, and that we want it to utilize the
    `test-account` profile, we will then set the `AWS_PROFILE` environmental variable
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号之间的名称称为**配置文件**。如前面的片段所示，您的凭证文件可以指定映射到不同配置文件的不同访问密钥。然而，接下来出现一个重要问题，那就是我们的应用程序应该使用哪个配置文件？为此，我们需要创建一个名为`AWS_PROFILE`的环境变量，该变量将指定配置文件名称和分配给其的应用程序名称。例如，假设我们的应用程序名为`testAWSapp`，我们希望它使用`test-account`配置文件，那么我们将设置`AWS_PROFILE`环境变量如下：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the `AWS_PROFILE` environmental variable is not set, the *default* profile
    gets picked up by default.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未设置`AWS_PROFILE`环境变量，则默认情况下将选择*default*配置文件。
- en: '**Hardcoding the access keys in your application**: This is typically not recommended
    for security reasons. So although it is technically possible, do not try this
    in any production systems since anyone who would have access to your application
    code (maybe in GitHub) will be able to retrieve and use your access keys.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**在应用程序中硬编码访问密钥**：出于安全原因，通常不建议这样做。因此，尽管从技术上讲是可能的，但不要在任何生产系统中尝试这样做，因为任何可以访问您的应用程序代码（可能在GitHub中）的人都可以检索并使用您的访问密钥。'
- en: Creating IAM Roles
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建IAM角色
- en: 'As mentioned earlier, IAM roles are recommended if your application is running
    on an Amazon EC2 instance. Creating an IAM role via the AWS console starts similar
    to creating an IAM user:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果您的应用程序在Amazon EC2实例上运行，则建议使用IAM角色。通过AWS控制台创建IAM角色的过程与创建IAM用户类似：
- en: We first log in to the AWS console ([aws.amazon.com](http://aws.amazon.com))
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先登录到AWS控制台（[aws.amazon.com](http://aws.amazon.com)）
- en: We then select IAM from under the Security, Identity & Compliance category
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们从“安全，身份和合规性”类别下选择IAM
- en: 'From there, we will take a different path. This time, we click on Roles on
    the right-hand side, then select Create new role:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们将走另一条路。这一次，我们点击右侧的“角色”，然后选择“创建新角色”：
- en: '![](img/5c9cad36-2933-4b29-b19e-59c49d9f6dca.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c9cad36-2933-4b29-b19e-59c49d9f6dca.jpg)'
- en: After selecting to create a new role, we will get treated with the role creation
    wizard.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 选择创建新角色后，我们将得到角色创建向导。
- en: 'We first get asked to select a role type. For our case, we will need to select
    the EC2 Service role, then Amazon EC2:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先被要求选择角色类型。对于我们的情况，我们需要选择EC2服务角色，然后选择Amazon EC2：
- en: '![](img/4c35989d-e81b-4523-8448-190604016ca7.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c35989d-e81b-4523-8448-190604016ca7.jpg)'
- en: 'From there, we will click on Next Step. We will then need to select the policies
    that our new role will use:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将点击下一步。然后，我们需要选择我们的新角色将使用的策略：
- en: '![](img/85f26f5d-5d7e-4f21-9493-e92d1cfd1556.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85f26f5d-5d7e-4f21-9493-e92d1cfd1556.jpg)'
- en: 'For the purpose of our application, let''s select the following four policies:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的应用程序，让我们选择以下四个策略：
- en: AmazonS3FullAccess
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonS3FullAccess
- en: AmazonSQSFullAccess
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonSQSFullAccess
- en: AmazonDynamoDBFullAccess
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonDynamoDBFullAccess
- en: AmazonAPIGatewayAdministrator
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonAPIGatewayAdministrator
- en: 'We will click on Next step again, then, we move to the final step where we
    get to set the role name, review our configuration, and then click on Create role to
    create a new role. For our purposes, I created a new role called `EC2_S3_API_SQS_Dynamo`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次点击下一步，然后我们进入最后一步，在这一步中我们可以设置角色名称，审查我们的配置，然后点击“创建角色”来创建一个新角色。为了我们的目的，我创建了一个名为`EC2_S3_API_SQS_Dynamo`的新角色：
- en: '![](img/8a4276c7-38b6-4ee6-984b-d9b77ebcf165.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a4276c7-38b6-4ee6-984b-d9b77ebcf165.jpg)'
- en: Once we click on Create role, a new role with our selected policies gets created.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击“创建角色”，一个具有我们选择的策略的新角色就会被创建。
- en: This role can then be attached on an EC2 instance, where our application code
    will run. We will explore how to do that in the EC2 section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将此角色附加到EC2实例上，我们的应用程序代码将在其中运行。我们将在EC2部分探讨如何做到这一点。
- en: The fundamentals of the AWS SDK for Go
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS SDK for Go的基础知识
- en: In order to harness the power of the AWS SDK for Go, there are two key concepts
    we will need to cover.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用AWS SDK for Go的功能，我们需要掌握两个关键概念。
- en: Sessions
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话
- en: The first concept is the idea of sessions. A session is an object from the SDK
    that contains configuration information that we can then use with other objects
    to communicate with AWS services.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个概念是会话的概念。会话是SDK中包含配置信息的对象，我们可以将其与其他对象一起使用，以与AWS服务进行通信。
- en: The `session` objects can be shared and used by different pieces of code. The
    object should be cached and reused. Creating a new `session` object involves loading
    the configuration data, so reusing it saves resources. `session` objects are safe
    to use concurrently as long as they don't get modified.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`session`对象可以被共享并被不同的代码片段使用。应该缓存并重复使用该对象。创建新的`session`对象涉及加载配置数据，因此重用它可以节省资源。只要不被修改，`session`对象就可以安全地并发使用。'
- en: 'To create a new `session` object, we can simply write the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的`session`对象，我们可以简单地编写以下代码：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will create a new `session` and store it in a variable called session.
    If we create a new `session` via the preceding code, default configurations would
    be utilized. If we need to override a configuration, we can pass a pointer to
    an object of the `aws.Config` type struct as an argument to the `NewSession()`
    struct. Let''s say we want to set  `Region`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的`session`并将其存储在名为session的变量中。如果我们通过上述代码创建一个新的`session`，将使用默认配置。如果需要覆盖配置，可以将`aws.Config`类型结构体的对象指针作为参数传递给`NewSession()`结构体。假设我们想设置`Region`：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Another constructor we can use to create a new session is called `NewSessionWithOptions()`;
    this helps override some of the environmental variables we used to provide information
    needed to create a session. For example, we discussed earlier how we can define
    a profile to host the credentials to be utilized by our application. Here is how
    this would look like:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一个构造函数来创建一个新的会话，称为`NewSessionWithOptions()`；这有助于覆盖我们用于提供创建会话所需信息的一些环境变量。例如，我们之前讨论过如何定义一个配置文件来存储应用程序使用的凭据。这是它的样子：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Service clients
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务客户端
- en: The second concept is the idea of service clients. A service client is an object
    that provides API access to a specific AWS service such as S3 or SQS.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个概念是服务客户端的概念。服务客户端是一个对象，它提供对特定AWS服务（如S3或SQS）的API访问。
- en: 'Service client objects are created from session objects. Here is an example
    of a piece of code that makes use of an S3 service client to obtain a list of
    buckets (an S3 bucket is simply a container of files and folders), then prints
    out the name of each bucket individually:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 服务客户端对象是从会话对象创建的。以下是一个利用S3服务客户端获取存储桶列表（S3存储桶只是文件和文件夹的容器）并逐个打印每个存储桶名称的代码片段示例：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Service client objects are typically safe to use concurrently as long as you
    ensure that you don't change the configuration in your concurrent code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 只要确保不在并发代码中更改配置，服务客户端对象通常是安全的并发使用。
- en: Under the hood, service clients make use of Restful API calls to interact with
    AWS. However, they take care of all the tedious code involved with building and
    securing HTTP requests for you.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，服务客户端使用Restful API调用与AWS进行交互。但是，它们会为您处理构建和保护HTTP请求所涉及的所有繁琐代码。
- en: As we go through this chapter and the next chapter, we will create session and
    service client objects to access the different AWS services. Sessions and service
    clients are the building coding blocks that we need to build proper AWS cloud
    native applications. The SDK allows you to dive deep into the underlying requests;
    this is typically helpful if we want to perform some operations on multiple requests
    before they get sent out.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们阅读本章和下一章时，我们将创建会话和服务客户端对象，以访问不同的AWS服务。会话和服务客户端是我们构建适当的AWS云原生应用程序所需的构建代码块。SDK允许您深入了解底层请求；如果我们想在发送请求之前执行一些操作，这通常是有帮助的。
- en: 'Most of the API method calls of the AWS SDK adhere to the following pattern:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: AWS SDK的大多数API方法调用都遵循以下模式：
- en: The API method name would typically describe a certain operation. For example,
    let's say that we have an **Simple Queue Service** (**SQS**) service client object,
    and that we need to get the URL address of a certain queue. The method name will
    be `GetQueueUrl`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API方法的名称通常描述某个操作。例如，假设我们有一个**简单队列服务**（**SQS**）服务客户端对象，并且我们需要获取特定队列的URL地址。方法名称将是`GetQueueUrl`。
- en: The input argument to the API method typically looks like `<method name>Input`;
    so, in case of the `GetQueueUrl` method, it's input type is `GetQueueUrlInput`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API方法的输入参数通常类似于`<method name>Input`；因此，在`GetQueueUrl`方法的情况下，其输入类型是`GetQueueUrlInput`。
- en: The output type from the API method is typically similar to <method name>Output;
    so, in case of the `GetQueueURL` method, it's output type is `GetQueueUrlOutput`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API方法的输出类型通常类似于<method name>Output；因此，在`GetQueueURL`方法的情况下，其输出类型是`GetQueueUrlOutput`。
- en: Native datatypes
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本机数据类型
- en: Another important remark regarding the SDK methods is that almost all of the
    datatypes used as arguments or in struct fields are pointers, even if the data
    type is native. For example, instead of using a string datatype for a string value,
    the SDK tends to use `*`string instead, same with ints and other types. In order
    to make life easier for the developer, the AWS SDK for Go provides helper methods
    to convert between native datatypes and their pointers while ensuring nil checks
    are performed to avoid runtime panics.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于SDK方法的另一个重要说明是，几乎所有用作参数或结构字段的数据类型都是指针，即使数据类型是本机的。例如，SDK倾向于使用`*`string而不是使用字符串数据类型来表示字符串值，整数和其他类型也是如此。为了让开发人员的生活更轻松，AWS
    SDK为Go提供了帮助方法，用于在确保执行nil检查以避免运行时恐慌的同时，在本机数据类型和它们的指针之间进行转换。
- en: 'The helper method to convert a native data type into a pointer to the same
    data type follows this pattern: `aws.<datatype>`. For example, if we call `aws.String("hello")`,
    the method will return a pointer to a string where the `Hello` value is stored.
    If we call `aws.Int(1)`, the method returns a pointer to an int of value 1.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将本机数据类型转换为相同数据类型的指针的帮助方法遵循以下模式：`aws.<datatype>`。例如，如果我们调用`aws.String("hello")`，该方法将返回一个指向存储`Hello`值的字符串的指针。如果我们调用`aws.Int(1)`，该方法将返回一个值为1的int的指针。
- en: 'On the other hand, the method to convert a pointer back to its data type while
    doing nil checks follows this pattern: `aws.<datatype>Value`. So, for example,
    if we call `aws.IntValue(p)`, where `p` is a pointer to an int of value 1, the
    result returned is simply an int with value 1\. To clarify further, here is the
    implementation of `aws.IntValue` inside the SDK code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，将指针转换回其数据类型的方法在进行nil检查时遵循以下模式：`aws.<datatype>Value`。例如，如果我们调用`aws.IntValue(p)`，其中`p`是值为1的int指针，返回的结果就是一个值为1的int。为了进一步澄清，以下是SDK代码中`aws.IntValue`的实现：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Shared configuration
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享配置
- en: Since it is likely that different microservices would need to use the same configuration
    settings when interacting with AWS, the AWS provides an option to make use of
    what is called shared configuration. Shared configuration is basically a configuration
    file that is stored locally. The filename and path is `.aws/config`. Remember
    that the `.aws` folder would exist in the home folder of our operating system;
    the folder was covered before when discussing the credentials file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同的微服务可能需要在与AWS交互时使用相同的配置设置，AWS提供了一种使用所谓的共享配置的选项。共享配置基本上是一个存储在本地的配置文件。文件名和路径是`.aws/config`。请记住，`.aws`文件夹将存在于操作系统的主文件夹中；在讨论凭据文件时已经涵盖了该文件夹。
- en: 'The configuration file should follow an ini-like format similar to the credentials
    file. It also supports profiles in a similar way to what we covered earlier in
    the credentials file. Here is an example of what `.aws/config` should look like:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件应遵循类似于凭据文件的ini格式。它还支持与我们之前在凭据文件中介绍的方式类似的配置文件中的配置文件。以下是`.aws/config`应该是什么样子的示例：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To allow microservices in a particular server to make use of the AWS configuration
    file of said server, there are two methods:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让特定服务器中的微服务能够使用该服务器的AWS配置文件，有两种方法：
- en: Set the `AWS_SDK_LOAD_CONFIG` environmental variable to true; this will cause
    the SDK code to use the configuration file.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AWS_SDK_LOAD_CONFIG`环境变量设置为true；这将导致SDK代码使用配置文件。
- en: 'When creating the session object, utilize the `NewSessionWithOptions` constructor
    to enable using shared configuration. Here is what the code would look like:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建会话对象时，利用`NewSessionWithOptions`构造函数来启用共享配置。代码如下：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For the full AWS Go SDK documentation, you can visit [https://docs.aws.amazon.com/sdk-for-go/api/](https://docs.aws.amazon.com/sdk-for-go/api/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的AWS Go SDK文档，您可以访问[https://docs.aws.amazon.com/sdk-for-go/api/](https://docs.aws.amazon.com/sdk-for-go/api/)。
- en: Pagination methods
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页方法
- en: Some API operations can return a huge number of results. For example, let's
    say that we need to issue an API call to retrieve a list of items from an S3 bucket.
    Now, let's assume the S3 bucket contains tons of items, and returning all of them
    in one API call is not efficient. The AWS Go SDK provides a feature called **Pagination**
    to help in that scenario. With pagination, you get your results in multiple pages.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一些API操作可能会返回大量结果。例如，假设我们需要发出API调用来从S3存储桶中检索项目列表。现在，假设S3存储桶包含大量项目，并且在一个API调用中返回所有项目是不高效的。AWS
    Go SDK提供了一个名为**Pagination**的功能来帮助处理这种情况。通过分页，您可以在多个页面中获取结果。
- en: 'You can read each page at a time, and then move to the next page of items when
    ready to process new items. API calls that support pagination is similar to <method
    name>Pages. For example, the pagination API method call that corresponds to the
    `ListObjects` S3 method is `ListObjectsPages`. The `ListObjectPages` method will
    iterate over the pages resulted from the `ListObject` operation. It takes two
    arguments—the first argument is of the `ListObjectInput` type, which will tell
    `ListObjectPages` about the name of the S3 bucket we are trying to read as well
    as the maximum number of keys we want per page. The second argument is a function
    that gets called with the response data for each page. Here is what the function
    signature looks like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以一次读取每页，然后在准备处理新项目时转到下一页。支持分页的API调用类似于<方法名称>Pages。例如，与`ListObjects` S3方法对应的分页API方法调用是`ListObjectsPages`。`ListObjectPages`方法将迭代从`ListObject`操作结果的页面。它接受两个参数——第一个参数是`ListObjectInput`类型，它将告诉`ListObjectPages`我们要读取的S3存储桶的名称，以及我们希望每页的最大键数。第二个参数是一个函数，每页的响应数据都会调用该函数。函数签名如下：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This argument function has two arguments of its own. The first argument carries
    the results of our operation; in our case, the results will be hosted in an object
    of type `ListObjectsOutput`. The second argument is of the `bool` type, which
    is basically a flag that is true if we are at the last page. The function return
    type is `bool`; we can use the return value to stop iterating over pages if we
    wish so. This means that whenever we return false, the pagination will stop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数函数有两个参数。第一个参数携带我们操作的结果；在我们的情况下，结果将托管在`ListObjectsOutput`类型的对象中。第二个参数是`bool`类型，基本上是一个标志，如果我们在最后一页，则为true。函数返回类型是`bool`；我们可以使用返回值来停止迭代页面。这意味着每当我们返回false时，分页将停止。
- en: 'Here is an example from the SDK documentation that showcases Pagination perfectly,
    utilizing the methods we discussed. The following code will use pagination to
    go through a list of items contained in an S3 bucket. We will request a maximum
    of 10 keys per page. We will print object keys per page, then we will exit once
    we go through three pages at most. Here is what the code will look like:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是SDK文档中的一个示例，完美展示了分页功能，利用了我们讨论过的方法。以下代码将使用分页功能来浏览存储在S3存储桶中的项目列表。我们将每页请求最多10个键。我们将打印每页的对象键，然后在最多浏览三页后退出。代码如下：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Waiters
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待者
- en: Waiters are API calls that allow us to wait until a certain operation is completed.
    Most waiter methods typically adhere to the WaitUntil<action> format. For example,
    when working with the DynamoDB database, there is an API method call named `WaitUntilTableExists`
    , which will simply wait till a condition is met.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 等待器是允许我们等待直到某个操作完成的API调用。大多数等待方法通常遵循WaitUntil<action> 格式。例如，在使用DynamoDB数据库时，有一个名为`WaitUntilTableExists`的API方法调用，它将简单地等待直到满足条件。
- en: Handling Errors
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'The AWS Go SDK returns errors of the `awserr.Error` type, which is a special
    interface type in the AWS SDK that satisfies the generic Go error interface type.
    The `awserr.Error` supports three main methods:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Go SDK返回`awserr.Error`类型的错误，这是AWS SDK中的特殊接口类型，满足通用的Go错误接口类型。`awserr.Error`支持三种主要方法：
- en: '`Code()` : Returns the error code related to the problem'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Code()`: 返回与问题相关的错误代码'
- en: '`Message()`: Returns a string description of the error'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message()`: 返回错误的字符串描述'
- en: '`OrigErr()`: Returns the original error that is wrapped with the `awserr.Error`
    type; for example, if the problem is related to networking, `OrigErr()` returns
    the original error that probably belonged to the Go net package'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrigErr()`: 返回包装在`awserr.Error`类型中的原始错误；例如，如果问题与网络有关，`OrigErr()`将返回原始错误，该错误可能属于Go
    net包'
- en: In order to expose and make use of the `awserr.Error` type, we will need to
    make use of the type assertion feature in Go.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了暴露和利用`awserr.Error`类型，我们需要使用Go语言中的类型断言功能。
- en: 'Let''s showcase how to make use of the `awserr.Error` type with a practical
    example. Let''s assume that in our application, we use a Dynamodb service client
    object to retrieve an item from a Dynamodb table via the item ID. However, we
    made a mistake in the table name and now it doesn''t exist, which will cause the
    call to fail. Code will look like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示如何使用实际示例中的`awserr.Error`类型。假设在我们的应用程序中，我们使用Dynamodb服务客户端对象通过项目ID从Dynamodb表中检索项目。但是，我们在表名中犯了一个错误，现在它不存在，这将导致调用失败。代码如下：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From the preceding code, if the `dynamodbsvc.GetItem()` method fails and we
    can''t get the item, we capture whether an error occurred, then we use Go''s type
    assertion to obtain the underlying `awserr.Error` type from our error object.
    We then proceed to check the error code and compare it to the error code in our
    SDK that indicates a resource not found problem. If it''s indeed a resource not
    found problem, we print a message indicating as such then return. The following
    is the specific piece of code from the preceding code where we did the error detection
    and handling as described in the current paragraph:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中，如果`dynamodbsvc.GetItem()`方法失败并且我们无法获取该项，我们捕获错误是否发生，然后使用Go的类型断言从我们的错误对象中获取底层的`awserr.Error`类型。然后我们继续检查错误代码并将其与我们的SDK中指示资源未找到问题的错误代码进行比较。如果确实是资源未找到的问题，我们打印一条指示这样的消息然后返回。以下是前面的代码中我们进行错误检测和处理的具体代码段，如当前段落所述：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Elastic Compute Cloud (EC2)
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性计算云（EC2）
- en: Similarly to any other AWS service, we will start from the AWS console in order
    to be able to initiate and deploy EC2 instances. As mentioned earlier, EC2 can
    simply be described as a service to be used when needing to spin new server instances
    on AWS. Let's explore the steps we will need to take to create, then access EC2
    instances.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他AWS服务一样，我们将从AWS控制台开始，以便能够启动和部署EC2实例。如前所述，EC2简单地可以描述为在AWS上需要旋转新服务器实例时使用的服务。让我们探索创建和访问EC2实例所需的步骤。
- en: Creating EC2 instances
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建EC2实例
- en: 'In the AWS console main screen, we will need to choose EC2 in order to start
    a new EC2 instance:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS控制台的主屏幕上，我们需要选择EC2以启动新的EC2实例：
- en: '![](img/8b254480-4e67-4e85-9c40-a7ad48b3e8ba.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b254480-4e67-4e85-9c40-a7ad48b3e8ba.jpg)'
- en: 'The next screen will expose lots of different options to manage EC2 instances.
    For now, what we need to do is to click on the Launch Instance button. You will
    note that the AWS region is shown here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕将显示许多不同的选项来管理EC2实例。现在，我们需要做的是单击“启动实例”按钮。您会注意到AWS区域在这里显示：
- en: '![](img/a8be8561-3162-45b5-8c30-0915899f8628.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8be8561-3162-45b5-8c30-0915899f8628.png)'
- en: Afterward, we will get to select the image to use as our virtual server on the
    cloud. An **Amaz****on Machine Image** (**AMI**) is an acronym to describe an
    Amazon virtual server image combined with all the information it needs to be launched.
    An AMI includes a template that describes the operating system, the applications
    in the virtual server, the launch permissions that specify which AWS account can
    use the AMI to launch instances of the virtual server image, and a device mapping
    to specify the volumes to be attached to the instance once it launches. Amazon
    provides a number of premade AMIs that we can use right away. However, you can
    also create your own.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将选择要在云上用作虚拟服务器的镜像。**Amazon Machine Image**（AMI）是一个缩写，用于描述Amazon虚拟服务器镜像以及启动所需的所有信息。AMI包括一个模板，描述了操作系统、虚拟服务器中的应用程序、指定哪个AWS帐户可以使用AMI启动虚拟服务器实例的启动权限，以及指定一次启动后要附加到实例的卷的设备映射。亚马逊提供了许多现成的AMI，我们可以立即使用。但是，您也可以创建自己的AMI。
- en: 'The following is what the AMI selection screen in the AWS console looks like:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是AWS控制台中AMI选择屏幕的外观：
- en: '![](img/d69e094e-1c94-437d-add1-0060b6bf08d1.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d69e094e-1c94-437d-add1-0060b6bf08d1.png)'
- en: As you can tell from the AMI descriptions, an AMI defines operating systems,
    command-line tools, programming language environments such as Python, Ruby, and
    Pert.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从AMI描述中可以看出，AMI定义了操作系统、命令行工具、编程语言环境（如Python、Ruby和Pert）。
- en: For now, let's select the Amazon Linux AMI option to proceed to the next step.
    In this step, we get to select our desired server image. Here is where you get
    to select the number of CPU cores, the memory, and network performance among other
    things. You would note the term EBS being under Instance Storage. **Elastic Block
    Store** (**EBS**), which provides cloud hosted storage volumes and offers high
    availability, scalability, and durability. Each EBS gets replicated within its
    availability zone.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们选择亚马逊Linux AMI选项，以继续下一步。在这一步中，我们可以选择我们想要的服务器镜像。在这里，您可以选择CPU核心数、内存和网络性能等。您会注意到“EBS”一词位于“实例存储”下。**弹性块存储**（**EBS**）提供云托管存储卷，并提供高可用性、可扩展性和耐用性。每个EBS都在其可用性区域内复制。
- en: '![](img/51a9e520-77b9-4ad0-9ee7-51de8abda736.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51a9e520-77b9-4ad0-9ee7-51de8abda736.png)'
- en: 'Next, we can click on either the Review and Launch button to launch the AMI
    or the Next: Configure Instance Details button to look deeper into the configuration
    options for the instance. Deeper configuration options include the number of instances,
    the subnet, the network address, among others.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以点击“审阅并启动”按钮来启动AMI，或者点击“下一步：配置实例详细信息”按钮来深入了解实例的配置选项。更深入的配置选项包括实例数量、子网、网络地址等。
- en: 'Configuring the instance details is also where we assign an IAM role (which
    we discussed earlier) to the EC2\. The IAM role we created earlier in the chapter
    was called EC2_S3_API_SQS_Dynamo, which will allow applications running on this
    EC2 instance to access S3 service, the API gateway service, the SQS service, and
    the Dynamo database. Here is what the configuration page will look like:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 配置实例详细信息也是我们为EC2分配IAM角色（我们之前讨论过的）的地方。我们在本章前面创建的IAM角色名为EC2_S3_API_SQS_Dynamo，它将允许在此EC2实例上运行的应用程序访问S3服务、API网关服务、SQS服务和Dynamo数据库。配置页面将如下所示：
- en: '![](img/eb2ab8db-ed50-4cb2-bec9-0f5d60b37301.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb2ab8db-ed50-4cb2-bec9-0f5d60b37301.jpg)'
- en: 'For the purpose of this chapter, we will click on Review and Launch to review
    then launch the instance. Let''s take a look at the review page:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这一章的目的，我们将点击“审阅并启动”来审阅然后启动实例。让我们来看一下审阅页面：
- en: '![](img/ca591d91-4d43-445a-89a6-8339e3474ff6.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca591d91-4d43-445a-89a6-8339e3474ff6.png)'
- en: Once we are satisfied with all the settings, we can go ahead and click on Launch.
    This will show a dialog requesting a public-private key pair. The concept of public
    key encryption was discussed in Chapter 3 in more detail. In a nutshell, we can
    describe public-private key encryption as a method of encryption, where you can
    share a public key with other people so that they encrypt messages before they
    send them to you. The encrypted message can then only be decrypted via the private
    key that only you possess.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对所有设置感到满意，我们可以继续点击“启动”。这将显示一个对话框，要求一个公钥-私钥对。公钥加密的概念在第3章中有更详细的讨论。简而言之，我们可以将公钥与其他人分享，以便他们在发送消息之前对其进行加密。加密的消息只能通过您拥有的私钥解密。
- en: For AWS, in order to allow developers to connect to their services securely,
    AWS requests developers to select a public-private key pair to secure access.
    The public key is stored in AWS, whereas the private key is stored by the developer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AWS，为了允许开发人员安全地连接到他们的服务，AWS要求开发人员选择公钥-私钥对以确保访问安全。公钥存储在AWS中，而私钥由开发人员存储。
- en: '![](img/40ca0b47-18a0-45da-ad3b-5a37710db0e6.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40ca0b47-18a0-45da-ad3b-5a37710db0e6.png)'
- en: 'If you don''t already have a public-private key pair with AWS, this is the
    step where we can create one. AWS also allows you to proceed without creating
    a key, which will obviously be less secure and not recommended in production applications.
    So let''s take a look at the three options we get when click on the first list
    box:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有在AWS上拥有公钥-私钥对，这是我们可以创建的步骤。AWS还允许您在不创建密钥的情况下继续，这显然会更不安全，不建议在生产应用中使用。让我们看看当我们点击第一个列表框时会得到的三个选项：
- en: '![](img/4aeacf13-62ec-47ca-88ac-6bcc7f158ccc.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4aeacf13-62ec-47ca-88ac-6bcc7f158ccc.jpg)'
- en: 'If you select the option to create a new key pair, you will get the option
    to name your key pair and to download the private key. You must download the private
    key and store it in a secure location so that you can make use of it later:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择创建新的密钥对选项，您将有机会命名您的密钥对并下载私钥。您必须下载私钥并将其存储在安全位置，以便以后使用：
- en: '![](img/2ff9d334-940c-4e1c-86fa-c4fc60679122.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ff9d334-940c-4e1c-86fa-c4fc60679122.png)'
- en: 'Finally, after we download the private key and are ready to launch the instance(s),
    we can click on the Launch Instances button. This will initiate the process of
    starting the instance(s) and show us a status indicating as such. Here is what
    the next screen typically looks like:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们下载私钥并准备启动实例后，我们可以点击“启动实例”按钮。这将启动启动实例的过程，并显示状态指示。下一个屏幕通常是这样的：
- en: '>![](img/a6e34d0c-cdb9-4f2f-bc98-a0ade1e12ccf.png)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/a6e34d0c-cdb9-4f2f-bc98-a0ade1e12ccf.png)'
- en: Perfect; with this step done, we have our own Linux virtual machine running
    in the Amazon Cloud. Let's find out how to connect to it and explore it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 完美；通过这一步，我们在亚马逊云中拥有了我们自己的Linux虚拟机。让我们找出如何连接并探索它。
- en: Accessing EC2 instances
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问EC2实例
- en: In order to get access to an EC2 instance that we have already created, we need
    to first log in to the AWS console, then select EC2 as before. This will provide
    you access to the EC2 dashboard. From there, we will need to click on instances
    in order to access the currently created EC2 instances under our account.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问我们已经创建的EC2实例，我们需要首先登录AWS控制台，然后像之前一样选择EC2。这将为您提供访问EC2仪表板的权限。从那里，我们需要点击实例，以访问我们帐户下当前创建的EC2实例。
- en: '![](img/3fd786ae-a434-4833-9052-c0e58581b0d2.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fd786ae-a434-4833-9052-c0e58581b0d2.jpg)'
- en: This will open up a list of EC2 instances that were already created. The instance
    we just created is the first one; you will note that its instance ID matches with
    the instance ID that was shown when we created the instance earlier.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个已经创建的EC2实例列表。我们刚刚创建的实例是第一个；您会注意到它的实例ID与我们之前创建实例时显示的实例ID相匹配。
- en: '![](img/72ea8a59-0a45-4664-838d-498421c065ce.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72ea8a59-0a45-4664-838d-498421c065ce.jpg)'
- en: The preceding screenshot shows us that the instance is currently running on
    AWS. We can connect to it like any remote server if we so desire. Let's explore
    how to do that.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示我们的实例目前正在AWS上运行。如果需要，我们可以像连接到任何远程服务器一样连接到它。让我们探讨如何做到这一点。
- en: The first step is to select the instance in question, then click on the Connect
    button. This will not connect directly to your instance; however, it will provide
    a list of useful instructions of how to establish the connection to your EC2 instance.
    In order to establish the connection, you will need to utilize the SSH protocol
    combined with the private encryption key that was downloaded earlier to remotely
    log in to the EC2 virtual server. **Secure Shell** (**SSH**) is a protocol mostly
    used to securely login to remote computers by users.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是选择相关的实例，然后点击连接按钮。这不会直接连接到您的实例；但是，它会提供一系列有用的指令，说明如何建立与您的EC2实例的连接。为了建立连接，您需要使用SSH协议和之前下载的私人加密密钥远程登录到EC2虚拟服务器。**Secure
    Shell** (**SSH**) 是一种用户安全登录远程计算机的协议。
- en: The approach to invoke SSH can be different from one operating system to another.
    For example, if you are using the Windows operating system, then you should use
    the popular PuTTY tool (found at [https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html) )
    to establish the SSH connection to the EC2 instance. If you are using macOS or
    Linux, you can use the SSH command directly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 调用SSH的方法可能因操作系统而异。例如，如果您使用的是Windows操作系统，那么您应该使用流行的PuTTY工具（在 [https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html)
    找到）来建立与EC2实例的SSH连接。如果您使用的是macOS或Linux，您可以直接使用SSH命令。
- en: Accessing EC2 instances from a Linux or macOS machine
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Linux或macOS机器访问EC2实例
- en: In order to access EC2 instances created on AWS from a Linux or a macOS machine,
    we will need to use the SSH command.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从Linux或macOS机器访问在AWS上创建的EC2实例，我们需要使用SSH命令。
- en: 'The first step is to ensure that the connection private key—which we downloaded
    earlier when we created the EC2 instance—is secure and cannot be accessed by external
    parties. This is typically done by executing the following command on the terminal:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确保连接的私钥——我们在创建EC2实例时下载的——是安全的，不能被外部方访问。这通常是通过在终端上执行以下命令来完成的：
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`my-super-secret-key-pair.pem` is the name of the file that contains the private
    key. Obviously, if the filename is different, then you will need to ensure that
    the command will target the correct filename. For the preceding command to work,
    we will need to run it from the same folder as where the key is located. Otherwise,
    we will need to specify the path to the key.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`my-super-secret-key-pair.pem` 是包含私钥的文件名。显然，如果文件名不同，那么您需要确保命令将针对正确的文件名。为了使上述命令生效，我们需要从与密钥所在的相同文件夹运行它。否则，我们需要指定密钥的路径。'
- en: 'After we ensure that the key is protected against public access, we will need
    to make use of the SSH command to connect to our EC2 instance. For this, we will
    need three pieces of information: the private key filename, the EC2 image username,
    and the DNS name of the connection. We already know the key filename, which means
    we now need to figure out the username and the DNS name of the connection. The
    username will depend on the EC2 instance operating system. The following table
    shows the operating system to username mapping:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保密钥受到公共访问的保护之后，我们需要使用SSH命令连接到我们的EC2实例。为此，我们需要三个信息：私钥文件名、EC2镜像用户名和连接的DNS名称。我们已经知道了密钥文件名，这意味着我们现在需要找出连接的用户名和DNS名称。用户名将取决于EC2实例的操作系统。以下表显示了操作系统到用户名的映射：
- en: '| **Operating System** | **User Name** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统** | **用户名** |'
- en: '| Amazon Linux | `ec2-user` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: 亚马逊Linux | `ec2-user`
- en: '| RHEL (Red Hat Enterprise Linux) | `ec2-user` or root |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: RHEL（Red Hat Enterprise Linux） | `ec2-user` 或 root
- en: '| Ubuntu | ubuntu or root |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: Ubuntu | ubuntu 或 root
- en: '| Centos | centos |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: Centos | centos
- en: '| Fedora | `ec2-user` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: Fedora | `ec2-user`
- en: '| SUSE | `ec2-user` or root |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: SUSE | `ec2-user` 或 root
- en: For other operating systems, if `ec2-user` or root don't work, check with the
    **Amazon Machine Image** (**AMI**) provider.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他操作系统，如果 `ec2-user` 或 root 无法使用，请与 **Amazon Machine Image** (**AMI**) 提供商确认。
- en: 'Now, the remaining piece of information we need is the DNS name of the connection
    to the EC2 instance. We can find it by simply looking at the EC2 instance details
    on the status page:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要的剩下的信息是连接到EC2实例的DNS名称。我们可以通过简单地查看状态页面上的EC2实例详细信息来找到它：
- en: '![](img/ad397b79-0039-4abe-bede-8632405a7396.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad397b79-0039-4abe-bede-8632405a7396.jpg)'
- en: 'With this, we have all what we need to execute an SSH command to access our
    EC2 instance; the command will look as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就有了执行SSH命令访问我们的EC2实例所需的一切；命令如下所示：
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The private key name in the preceding command is `my-super-secret-key-pair.pem`,
    the username is `ec2-user`, whereas the DNS is `ec2-54-193-5-28.us-west-1.compute.amazonaws.com`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令中的私钥名称是 `my-super-secret-key-pair.pem`，用户名是 `ec2-user`，DNS是 `ec2-54-193-5-28.us-west-1.compute.amazonaws.com`。
- en: 'This command will allow us access to the EC2 instance that we just created;
    here is what the screen will look like:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将允许我们访问我们刚刚创建的EC2实例；屏幕上会显示如下内容：
- en: '![](img/7ff19708-efe2-4851-ac97-938e07d0f6bf.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ff19708-efe2-4851-ac97-938e07d0f6bf.jpg)'
- en: Accessing EC2 from Windows
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Windows访问EC2
- en: 'To access EC2 from Windows, we can either use a Windows version of the SSH
    tool we covered in the preceding section or we can use PuTTY. PuTTY is a very
    popular SSH and telnet client that can run on Windows or Unix. To download PuTTY,
    we need to visit [https://www.chiark.greenend.org.uk/~sgtatham/PuTTY/latest.html](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html).
    Once we download PuTTY, install and run it, the main screen will look similar
    to this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Windows访问EC2，我们可以使用我们在前一节中介绍的SSH工具的Windows版本，或者我们可以使用PuTTY。PuTTY是一个非常受欢迎的SSH和telnet客户端，可以在Windows或Unix上运行。要下载PuTTY，我们需要访问[https://www.chiark.greenend.org.uk/~sgtatham/PuTTY/latest.html](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html)。下载PuTTY后，安装并运行它，主屏幕将类似于这样：
- en: '![](img/207250d6-fde7-4379-9169-0abf6ea8e15c.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/207250d6-fde7-4379-9169-0abf6ea8e15c.jpg)'
- en: Before we can use PuTTY to connect to our EC2 instance, we will need to convert
    the private key file that we obtained earlier into a different file type that
    can be easily consumed by the PuTTY software.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用PuTTY连接到我们的EC2实例之前，我们需要将之前获得的私钥文件转换为可以被PuTTY软件轻松消耗的不同文件类型。
- en: 'To perform the private key conversion, we will need the help of a tool called
    **PuTTYgen**, which gets installed with PuTTY. PuTTYgen can be found under All
    Programs>PuTTY>PuTTYgen. Here is what PuTTYgen looks like after it starts:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行私钥转换，我们将需要一个名为**PuTTYgen**的工具的帮助，它随PuTTY一起安装。PuTTYgen可以在所有程序>PuTTY>PuTTYgen下找到。启动后，PuTTYgen看起来像这样：
- en: '![](img/cdff06dc-02fb-4712-8e2f-03c302af006f.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdff06dc-02fb-4712-8e2f-03c302af006f.jpg)'
- en: Under Parameters, ensure that RSA is selected as the encryption algorithm, with
    2048 as the number of bits in the generated key.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数下，确保选择RSA作为加密算法，生成的密钥中有2048位。
- en: 'To proceed, let''s click on the Load button in order to be able to load our
    AWS private key into the tool. The Load button will open a dialog to allow us
    to select the private key file. We will need to select the option to show all
    files in order to make the private key file view-able:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续，让我们点击“加载”按钮，以便能够将我们的AWS私钥加载到工具中。加载按钮将打开一个对话框，允许我们选择私钥文件。我们需要选择显示所有文件的选项，以便查看私钥文件：
- en: '![](img/2d2982a9-f062-4409-a9a5-1db4a6b3dafa.jpg)![](img/f8583255-4a60-463b-a99f-438c4c5a4202.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d2982a9-f062-4409-a9a5-1db4a6b3dafa.jpg)![](img/f8583255-4a60-463b-a99f-438c4c5a4202.jpg)'
- en: We can then select the key, then click on Open in order for the key to get loaded
    into the PuTTYgen tool. The next step is to click on Save Private Key to finish
    the key conversion. A warning will show up inquiring whether you are sure you
    want to save this key without a passphrase to protect it; click on Yes. The passphrase
    is supposed to be an extra layer of protection; however, it requires user input
    to work. So, if we want to automate the SSH connection to the EC2 instance, we
    shouldn't have the passphrase enabled. After we click on Yes, we can select the
    filename for the converted file; then, we click on Save to create and save the
    file. The PuTTY private key is of the `*.ppk` type.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以选择密钥，然后点击“打开”，以便将密钥加载到PuTTYgen工具中。下一步是点击“保存私钥”以完成密钥转换。会出现一个警告，询问您是否确定要保存此密钥而不使用密码来保护它；点击“是”。密码是额外的保护层；但是，它需要用户输入才能工作。因此，如果我们想要自动化SSH连接到EC2实例，我们不应该启用密码。点击“是”后，我们可以选择转换文件的文件名；然后，我们点击“保存”以创建和保存文件。PuTTY私钥是`*.ppk`类型的。
- en: '![](img/8c85fbf2-43ae-4a09-aa1b-5d27f808eed9.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c85fbf2-43ae-4a09-aa1b-5d27f808eed9.jpg)'
- en: Perfect; we now have a PuTTY private key ready for our use case. The next step
    is to open the PuTTY tool in order to use this key to connect to the EC2 instance
    via SSH.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 完美；我们现在有一个PuTTY私钥可以用于我们的用例。下一步是打开PuTTY工具，以使用此密钥通过SSH连接到EC2实例。
- en: After we open PuTTY, we need to go to the SSH option under the Connection category,
    then from there, navigate to the Auth option. At the Auth window, we will search
    for the option to load the PuTTY private key file we created earlier.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 打开PuTTY后，我们需要转到连接类别下的SSH选项，然后从那里导航到Auth选项。在Auth窗口中，我们将搜索我们之前创建的PuTTY私钥文件的加载选项。
- en: '![](img/7e53ca77-6eab-49df-8f7d-768d851c25e3.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e53ca77-6eab-49df-8f7d-768d851c25e3.jpg)'
- en: 'Next, we will need to click on the Session category on the right-hand side.
    Then, under the Host Name (or IP address) field on the right-hand side, we will
    need to enter the username and the public DNS address in the following format:
    `username@DNS public` name. In our case, it looks like this: `ec2-user@ec2-54-193-5-28.us-west-1.compute.amazonaws.com`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要点击右侧的“会话”类别。然后，在右侧的“主机名（或IP地址）”字段下，我们需要输入用户名和公共DNS地址，格式如下：`用户名@DNS公共`名称。在我们的情况下，看起来是这样的：`ec2-user@ec2-54-193-5-28.us-west-1.compute.amazonaws.com`：
- en: '![](img/4cf2b45f-2151-4049-8945-fde0f0f4e015.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cf2b45f-2151-4049-8945-fde0f0f4e015.jpg)'
- en: From there, we can click on Open to open a session to the EC2 instance. The
    first time we try to open the session, we will get a message asking whether we
    trust the server we are trying to connect to. If we trust it, we need to click
    on Yes, which will cache the server's host key into the registry.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以点击“打开”以打开到EC2实例的会话。第一次尝试打开会话时，我们会收到一条消息，询问我们是否信任我们要连接的服务器。如果我们信任它，我们需要点击“是”，这将把服务器的主机密钥缓存到注册表中。
- en: '![](img/77b9cfd9-072d-4096-921b-496eb7385b4c.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77b9cfd9-072d-4096-921b-496eb7385b4c.jpg)'
- en: 'This will open up a secure session to our EC2 instance; we can then use it
    however we like:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开到我们的EC2实例的安全会话；然后我们可以随心所欲地使用它：
- en: '![](img/00be9dc3-a3da-4f8d-a8a9-2d4181bfe384.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00be9dc3-a3da-4f8d-a8a9-2d4181bfe384.jpg)'
- en: 'PuTTY has the ability to save existing session information. After we finish
    our configuration, we can choose a name then click on Save as shown in the following
    figure in order to save the session information:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: PuTTY有保存现有会话信息的功能。完成配置后，我们可以选择一个名称，然后点击“另存为”，如下图所示，以保存会话信息：
- en: '![](img/500c1a98-a1ce-4b03-8708-36d030ee784b.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/500c1a98-a1ce-4b03-8708-36d030ee784b.jpg)'
- en: Security groups
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全组
- en: Great! This covers enough practical knowledge about how to configure and set
    up an EC2 instance in different operating systems. Now, there is an additional
    topic we need to cover, that is, Security Groups. You can think of a security
    group as a collection of firewall rules around your EC2 instance. For example,
    by adding a security rule, you can allow applications running on your EC2 to accept
    HTTP traffic. You can create rules to allow access to specific TCP or UDP ports,
    and much more.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！这足以涵盖如何在不同操作系统中配置和设置EC2实例的实用知识。现在，我们需要涵盖的另一个主题是安全组。您可以将安全组视为围绕您的EC2实例的防火墙规则集合。例如，通过添加安全规则，您可以允许在您的EC2上运行的应用程序接受HTTP流量。您可以创建规则以允许访问特定的TCP或UDP端口，以及其他更多内容。
- en: Since we are expected to deploy web services to our EC2 instances, such as the
    *events microservice*. We need to create a security group that allows HTTP traffic,
    then assign the group to our EC2 instance.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们预计将Web服务部署到我们的EC2实例上，比如*事件微服务*。我们需要创建一个允许HTTP流量的安全组，然后将该组分配给我们的EC2实例。
- en: 'The first step we will need to do is to open up the EC2 dashboard by going
    to the AWS console main screen, then selecting EC2 as we did before. Once we are
    inside the EC2 dashboard, we can click on Security Groups on the left-hand side,
    which will be under the Network & Security category:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一步是打开EC2仪表板，方法是转到AWS控制台主屏幕，然后选择EC2，就像我们之前做的那样。一旦我们进入EC2仪表板，我们可以点击左侧的安全组，它将位于网络和安全类别下：
- en: '![](img/36d1816b-74f9-4ab2-990c-27c3e84882cd.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36d1816b-74f9-4ab2-990c-27c3e84882cd.jpg)'
- en: The security groups dashboard will show a list of all the Security Groups that
    have been already created. The dashboard allows us to create new groups or edit
    existing groups. Since, in our case, we are creating a new group, we will need
    to click on Create Security Group on the upper left-hand side of the dashboard.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 安全组仪表板将显示已经创建的所有安全组的列表。该仪表板允许我们创建新组或编辑现有组。由于在我们的情况下，我们正在创建一个新组，我们需要点击仪表板左上角的“创建安全组”。
- en: '![](img/1670b49c-b298-42f0-8ee2-c1170abfab72.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1670b49c-b298-42f0-8ee2-c1170abfab72.jpg)'
- en: A form window will come up with fields that we need to fill in order to create
    our security group. First, we will need to provide a name for the security group,
    an optional description, the name of the virtual private cloud where our security
    group will apply. A virtual private cloud is simply defined as a logically isolated
    section in the AWS cloud; we can define our own.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表单窗口将弹出，我们需要填写字段以创建我们的安全组。首先，我们需要为安全组提供一个名称，一个可选的描述，我们的安全组将应用的虚拟私有云的名称。虚拟私有云简单地定义为AWS云中的逻辑隔离部分；我们可以定义自己的。
- en: '![](img/5bd0cd79-5c5f-499d-834b-4748c570f914.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bd0cd79-5c5f-499d-834b-4748c570f914.jpg)'
- en: In the preceding screenshot, we named our security group HTTP Access; we described
    it as the security group to enable HTTP access, and then we choose the default
    VPC.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们将我们的安全组命名为HTTP访问；我们将其描述为启用HTTP访问的安全组，然后我们选择默认VPC。
- en: 'The next step is to click on the Add Rule button to start defining the rules
    that will compose our security group. After we click on it, a new row will appear
    inside the Security group rules section. We need to click on the listbox under
    the Type column, then select HTTP. Here is what the result will look like:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是点击“添加规则”按钮，开始定义组成我们安全组的规则。点击后，安全组规则部分将出现新行。我们需要点击“类型”列下的列表框，然后选择HTTP。结果如下：
- en: '![](img/b9f229e1-0ed8-4178-b573-d739f09ebedd.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9f229e1-0ed8-4178-b573-d739f09ebedd.jpg)'
- en: You will note that the protocol, port range, and source fields will be filled
    up for you. TCP is the underlying protocol for HTTP, whereas port 80 is the HTTP
    port.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到协议、端口范围和源字段将为您填写。TCP是HTTP的基础协议，端口80是HTTP端口。
- en: We can also add an HTTPS rule if we would like; we will follow the same steps,
    except when we choose the Type, where HTTPS will be chosen instead of HTTP. You
    can also explore the rest of the options to discover what other exceptions can
    be created under a security rule.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们也可以添加一个HTTPS规则；我们将按照相同的步骤进行，只是在选择类型时，选择HTTPS而不是HTTP。您还可以探索其他选项，以了解安全规则下可以创建哪些其他异常。
- en: '![](img/13c00405-b940-45fc-ba07-6ff2f18c67a4.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13c00405-b940-45fc-ba07-6ff2f18c67a4.jpg)'
- en: 'Once a security group is created, we will find it in the list of our security
    groups:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 创建安全组后，我们将在我们的安全组列表中找到它：
- en: '![](img/f075d6d8-2d43-49d2-b962-408777d5df54.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f075d6d8-2d43-49d2-b962-408777d5df54.jpg)'
- en: 'Once we have a security group created, we can attach it to an existing EC2
    instance. This is done by going back to the EC2 Dashboard, then selecting Running
    instances, and then selecting the instance of interest from the list of EC2 instances.
    From there, we click on Actions, then Networking, and then Change Security Groups:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了安全组后，我们可以将其附加到现有的EC2实例。这是通过返回EC2仪表板，然后选择“运行中的实例”，然后从EC2实例列表中选择感兴趣的实例来完成的。然后，我们点击“操作”，然后“网络”，然后“更改安全组”：
- en: '![](img/61cd6d91-ca7e-4826-bd10-8f75bfbc3c8c.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61cd6d91-ca7e-4826-bd10-8f75bfbc3c8c.jpg)'
- en: 'From there, we can choose the Security Groups that we would like to attach
    to our instance:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以选择要附加到我们实例的安全组：
- en: '![](img/98eb077e-f893-4185-8fdb-351b31958231.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98eb077e-f893-4185-8fdb-351b31958231.jpg)'
- en: Perfect; with this, our EC2 instance now allows HTTP access to applications
    running inside it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 完美；有了这个，我们的EC2实例现在允许在其内部运行的应用程序访问HTTP。
- en: Another important remark is that we can assign security groups to EC2 instances
    at the time of the EC2 instance creation. We access this option by clicking on
    Configure Instance Details while creating a new instance, then following the configuration
    wizard to the Configure Security Group option.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的说明是，我们可以在创建EC2实例时将安全组分配给EC2实例。我们可以通过在创建新实例时点击“配置实例详细信息”，然后按照配置向导到“配置安全组”选项来访问此选项。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started covering AWS, by learning how to configure EC2 and
    how to work with the AWS SDK for Go. In the next chapter, we'll continue to dive
    deeper into AWS, by learning about some of the key AWS services and how to write
    Go code that can make proper use of them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始学习如何配置EC2以及如何使用AWS SDK for Go。在下一章中，我们将继续深入了解AWS，学习一些关键的AWS服务以及如何编写能够正确利用它们的Go代码。
