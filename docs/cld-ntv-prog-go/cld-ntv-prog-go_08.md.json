["```go\naws s3 cp s3://<my_bucket>/<my_folder>/events my_local_events_copy\n```", "```go\nchmod u+x <my_executable_file>\n```", "```go\n sess, err := session.NewSession(&aws.Config{\n   Region: aws.String(\"us-west-1\"),\n })\n if err != nil {\n   log.Fatal(err)\n }\n sqsSvc := sqs.New(sess)\n```", "```go\n  QUResult, err := sqsSvc.GetQueueUrl(&sqs.GetQueueUrlInput{\n    QueueName: aws.String(\"eventqueue\"),\n  })\n  if err != nil {\n    log.Fatal(err)\n  }\n```", "```go\nsendResult, err := sqsSvc.SendMessage(&sqs.SendMessageInput{\n  MessageAttributes: map[string]*sqs.MessageAttributeValue{\n    \"message_type\": &sqs.MessageAttributeValue{\n      DataType: aws.String(\"String\"),\n      StringValue: aws.String(\"RESERVATION\"),\n    },\n    \"Count\": &sqs.MessageAttributeValue{\n      DataType: aws.String(\"Number\"),\n      StringValue: aws.String(\"2\"),\n    },\n  },\n  MessageBody: aws.String(\"[{customer:'Kevin S',event:'Pink Floyd Concert'},{customer:'Angela      T',event:'Cold Play Concert'}]\"),\n  QueueUrl: QUResult.QueueUrl,\n})\n```", "```go\n  if err != nil {\n    log.Fatal(err)\n  }\n  log.Println(\"Message sent successfully\", *sendResult.MessageId)\n```", "```go\n  QUResult, err := sqsSvc.GetQueueUrl(&sqs.GetQueueUrlInput{\n    QueueName: aws.String(\"eventqueue\"),\n  })\n  if err != nil {\n    log.Fatal(err)\n  }\n  recvMsgResult, err := sqsSvc.ReceiveMessage(&sqs.ReceiveMessageInput{\n    AttributeNames: []*string{\n      aws.String(sqs.MessageSystemAttributeNameSentTimestamp),\n    },\n    MessageAttributeNames: []*string{\n      aws.String(sqs.QueueAttributeNameAll),\n    },\n    QueueUrl: QUResult.QueueUrl,\n    MaxNumberOfMessages: aws.Int64(10),\n    WaitTimeSeconds: aws.Int64(20),\n  })\n```", "```go\nfor i, msg := range recvMsgResult.Messages {\n    log.Println(\"Message:\", i, *msg.Body)\n    for key, value := range msg.MessageAttributes {\n      log.Println(\"Message attribute:\", key, aws.StringValue(value.StringValue))\n    }\n\n    for key, value := range msg.Attributes {\n      log.Println(\"Attribute: \", key, *value)\n    }\n\n    log.Println(\"Deleting message...\")\n    resultDelete, err := sqsSvc.DeleteMessage(&sqs.DeleteMessageInput{\n      QueueUrl: QUResult.QueueUrl,\n      ReceiptHandle: msg.ReceiptHandle,\n    })\n    if err != nil {\n      log.Fatal(\"Delete Error\", err)\n    }\n    log.Println(\"Message deleted... \")\n  }\n```", "```go\npackage msgqueue\n\n// EventEmitter describes an interface for a class that emits events\ntype EventEmitter interface {\n  Emit(e Event) error\n}\n```", "```go\npackage msgqueue\n\n// EventListener describes an interface for a class that can listen to events.\ntype EventListener interface {\n Listen(events ...string) (<-chan Event, <-chan error, error)\n Mapper() EventMapper\n}\n```", "```go\ntype SQSEmitter struct {\n  sqsSvc *sqs.SQS\n  QueueURL *string\n}\n```", "```go\nfunc NewSQSEventEmitter(s *session.Session, queueName string) (emitter msgqueue.EventEmitter, err error) {\n  if s == nil {\n    s, err = session.NewSession()\n    if err != nil {\n      return\n    }\n  }\n  svc := sqs.New(s)\n  QUResult, err := svc.GetQueueUrl(&sqs.GetQueueUrlInput{\n    QueueName: aws.String(queueName),\n  })\n  if err != nil {\n    return\n  }\n  emitter = &SQSEmitter{\n    sqsSvc: svc,\n    QueueURL: QUResult.QueueUrl,\n  }\n  return\n}\n```", "```go\nfunc (sqsEmit *SQSEmitter) Emit(event msgqueue.Event) error {\n  data, err := json.Marshal(event)\n  if err != nil {\n    return err\n  }\n  _, err = sqsEmit.sqsSvc.SendMessage(&sqs.SendMessageInput{\n    MessageAttributes: map[string]*sqs.MessageAttributeValue{\n      \"event_name\": &sqs.MessageAttributeValue{\n        DataType: aws.String(\"string\"),\n        StringValue: aws.String(event.EventName()),\n      },\n    },\n    MessageBody: aws.String(string(data)),\n    QueueUrl: sqsEmit.QueueURL,\n  })\n  return err\n}\n```", "```go\ntype SQSListener struct {\n  mapper msgqueue.EventMapper\n  sqsSvc *sqs.SQS\n  queueURL *string\n  maxNumberOfMessages int64\n  waitTime int64\n  visibilityTimeOut int64\n}\n```", "```go\nfunc NewSQSListener(s *session.Session, queueName string, maxMsgs, wtTime, visTO int64) (listener msgqueue.EventListener, err error) {\n  if s == nil {\n    s, err = session.NewSession()\n    if err != nil {\n      return\n    }\n  }\n  svc := sqs.New(s)\n  QUResult, err := svc.GetQueueUrl(&sqs.GetQueueUrlInput{\n    QueueName: aws.String(queueName),\n  })\n  if err != nil {\n    return\n  }\n  listener = &SQSListener{\n    sqsSvc: svc,\n    queueURL: QUResult.QueueUrl,\n    mapper: msgqueue.NewEventMapper(),\n    maxNumberOfMessages: maxMsgs,\n    waitTime: wtTime,\n    visibilityTimeOut: visTO,\n  }\n  return\n}\n```", "```go\nfunc (sqsListener *SQSListener) receiveMessage(eventCh chan msgqueue.Event, errorCh chan error, events ...string) {\n  recvMsgResult, err := sqsListener.sqsSvc.ReceiveMessage(&sqs.ReceiveMessageInput{\n    MessageAttributeNames: []*string{\n      aws.String(sqs.QueueAttributeNameAll),\n    },\n    QueueUrl: sqsListener.queueURL,\n    MaxNumberOfMessages: aws.Int64(sqsListener.maxNumberOfMessages),\n    WaitTimeSeconds: aws.Int64(sqsListener.waitTime),\n    VisibilityTimeout: aws.Int64(sqsListener.visibilityTimeOut),\n  })\n  if err != nil {\n    errorCh <- err\n  }\n```", "```go\nbContinue := false\nfor _, msg := range recvMsgResult.Messages {\n  value, ok := msg.MessageAttributes[\"event_name\"]\n  if !ok {\n    continue\n  }\n  eventName := aws.StringValue(value.StringValue)\n  for _, event := range events {\n    if strings.EqualFold(eventName, event) {\n      bContinue = true\n      break\n    }\n  }\n\n  if !bContinue {\n    continue\n  }\n```", "```go\nmessage := aws.StringValue(msg.Body)\nevent, err := sqsListener.mapper.MapEvent(eventName, []byte(message))\nif err != nil {\n  errorCh <- err\n  continue\n}\neventCh <- event\n```", "```go\n    _, err = sqsListener.sqsSvc.DeleteMessage(&sqs.DeleteMessageInput{\n      QueueUrl: sqsListener.queueURL,\n      ReceiptHandle: msg.ReceiptHandle,\n    })\n\n    if err != nil {\n      errorCh <- err\n    }\n  }\n}\n```", "```go\nfunc (sqsListener *SQSListener) Listen(events ...string) (<-chan msgqueue.Event, <-chan error, error) {\n  if sqsListener == nil {\n    return nil, nil, errors.New(\"SQSListener: the Listen() method was called on a nil pointer\")\n  }\n  eventCh := make(chan msgqueue.Event)\n  errorCh := make(chan error)\n  go func() {\n    for {\n      sqsListener.receiveMessage(eventCh, errorCh)\n    }\n  }()\n\n  return eventCh, errorCh, nil\n}\n```", "```go\n{\n    name: \"opera aida\",\n    startdate: 768346784368,\n    enddate: 43988943,\n    duration: 120, //in minutes\n    location:{\n        id : 3 , //=>assign as an index\n        name: \"West Street Opera House\",\n        address: \"11 west street, AZ 73646\",\n        country: \"U.S.A\",\n        opentime: 7,\n        clostime: 20\n        Hall: {\n            name : \"Cesar hall\",\n            location : \"second floor, room 2210\",\n            capacity: 10\n        }\n    }\n}\n```", "```go\ntype DatabaseHandler interface {\n  AddEvent(Event) ([]byte, error)\n  FindEvent([]byte) (Event, error)\n  FindEventByName(string) (Event, error)\n  FindAllAvailableEvents() ([]Event, error)\n}\n```", "```go\n  sess, err := session.NewSession(&aws.Config{\n    Region: aws.String(\"us-west-1\"),\n  })\n  if err != nil {\n    //handler error, let's assume we log it then exit.\n    log.Fatal(err)\n  }\n  dynamodbsvc := dynamodb.New(sess)\n```", "```go\ntype DynamoDBLayer struct {\n  service *dynamodb.DynamoDB\n}\n```", "```go\nfunc NewDynamoDBLayerByRegion(region string) (persistence.DatabaseHandler, error) {\n  sess, err := session.NewSession(&aws.Config{\n    Region: aws.String(region),\n  })\n  if err != nil {\n    return nil, err\n  }\n  return &DynamoDBLayer{\n    service: dynamodb.New(sess),\n  }, nil\n}\n```", "```go\nfunc NewDynamoDBLayerBySession(sess *session.Session) persistence.DatabaseHandler {\n  return &DynamoDBLayer{\n    service: dynamodb.New(sess),\n  }\n}\n```", "```go\ntype Event struct {\n  ID bson.ObjectId `bson:\"_id\"`\n  Name string \n  Duration int\n  StartDate int64\n  EndDate int64\n  Location Location\n}\n```", "```go\ntype Event struct {\n  ID bson.ObjectId `bson:\"_id\"`\n  Name string `dynamodbav:\"EventName\"`\n  Duration int\n  StartDate int64\n  EndDate int64\n  Location Location\n}\n```", "```go\nfunc (dynamoLayer *DynamoDBLayer) AddEvent(event persistence.Event) ([]byte, error) {\n  av, err := dynamodbattribute.MarshalMap(event)\n  if err != nil {\n    return nil, err\n  }\n  _, err = dynamoLayer.service.PutItem(&dynamodb.PutItemInput{\n    TableName: aws.String(\"events\"),\n    Item: av,\n  })\n  if err != nil {\n    return nil, err\n  }\n  return []byte(event.ID), nil\n}\n```", "```go\nfunc (dynamoLayer *DynamoDBLayer) FindEvent(id []byte) (persistence.Event, error) {\n  //create a GetItemInput object with the information we need to search for our event via it's ID attribute\n  input := &dynamodb.GetItemInput{\n    Key: map[string]*dynamodb.AttributeValue{\n      \"ID\": {\n        B: id,\n      },\n    },\n    TableName: aws.String(\"events\"),\n  }\n  //Get the item via the GetItem method\n  result, err := dynamoLayer.service.GetItem(input)\n  if err != nil {\n    return persistence.Event{}, err\n  }\n  //Utilize dynamodbattribute.UnmarshalMap to unmarshal the data retrieved into an Event object\n  event := persistence.Event{}\n  err = dynamodbattribute.UnmarshalMap(result.Item, &event)\n  return event, err\n}\n```", "```go\n{\n  B: id,\n}\n```", "```go\nfunc (dynamoLayer *DynamoDBLayer) FindEventByName(name string) (persistence.Event, error) {\n  //Create the QueryInput type with the information we need to execute the query\n  input := &dynamodb.QueryInput{\n    KeyConditionExpression: aws.String(\"EventName = :n\"),\n    ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{\n      \":n\": {\n        S: aws.String(name),\n      },\n    },\n    IndexName: aws.String(\"EventName-index\"),\n    TableName: aws.String(\"events\"),\n  }\n  // Execute the query\n  result, err := dynamoLayer.service.Query(input)\n  if err != nil {\n    return persistence.Event{}, err\n  }\n  //Obtain the first item from the result\n  event := persistence.Event{}\n  if len(result.Items) > 0 {\n    err = dynamodbattribute.UnmarshalMap(result.Items[0], &event)\n  } else {\n    err = errors.New(\"No results found\")\n  }\n  return event, err\n}\n```", "```go\nfunc (dynamoLayer *DynamoDBLayer) FindAllAvailableEvents() ([]persistence.Event, error) {\n  // Create the ScanInput object with the table name\n  input := &dynamodb.ScanInput{\n    TableName: aws.String(\"events\"),\n  }\n\n  // Perform the scan operation\n  result, err := dynamoLayer.service.Scan(input)\n  if err != nil {\n    return nil, err\n  }\n\n  // Obtain the results via the unmarshalListofMaps function\n  events := []persistence.Event{}\n  err = dynamodbattribute.UnmarshalListOfMaps(result.Items, &events)\n  return events, err\n}\n```"]