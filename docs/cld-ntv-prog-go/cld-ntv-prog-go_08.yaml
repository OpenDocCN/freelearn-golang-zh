- en: AWS II–S3, SQS, API Gateway, and DynamoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS II–S3、SQS、API Gateway和DynamoDB
- en: In this chapter, we'll continue covering the massive topic of Amazon Web Services.
    In this chapter, we'll cover the S3 service, SQS service, AWS API Gateway service,
    and DynamoDB service. Every single one of these services is a powerful tool in
    your arsenal to build production applications deployed on the cloud.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续介绍亚马逊网络服务的大主题。在本章中，我们将介绍S3服务、SQS服务、AWS API网关服务和DynamoDB服务。这些服务中的每一个都是您在云上构建生产应用程序的强大工具。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: The AWS S3 storage service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS S3存储服务
- en: The SQS message queue service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQS消息队列服务
- en: The AWS API gateway service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS API网关服务
- en: The DynamoDB database service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DynamoDB数据库服务
- en: Simple Storage Service (S3)
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单存储服务（S3）
- en: Amazon S3 is an AWS service responsible for storing and analyzing data. The
    data typically includes files of all sorts and shapes (including music files,
    photos, text files, and video files). S3, for example, can be utilized to store
    code files for static data. Let's take a tour of how to use the S3 service in
    AWS.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon S3是AWS负责存储和分析数据的服务。数据通常包括各种类型和形状的文件（包括音乐文件、照片、文本文件和视频文件）。例如，S3可以用于存储静态数据的代码文件。让我们来看看如何在AWS中使用S3服务。
- en: Configuring S3
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置S3
- en: The S3 service stores files in buckets. Each bucket can hold files directly
    or can include a number of folders, and, in turn, each folder can hold a number
    of files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: S3服务将文件存储在存储桶中。每个存储桶可以直接保存文件，也可以包含多个文件夹，而每个文件夹又可以保存多个文件。
- en: 'We will use the AWS web console to configure S3, similar to what we did with
    EC2\. The first step will be to navigate to the AWS web console and then select
    S3:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用AWS Web控制台来配置S3，类似于我们在EC2中所做的。第一步是导航到AWS Web控制台，然后选择S3：
- en: '![](img/fa3ea49a-4f8e-4191-bfb1-ddc51cd6d8d7.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa3ea49a-4f8e-4191-bfb1-ddc51cd6d8d7.png)'
- en: 'This will open the Amazon S3 console; from there, we can click on Create bucket
    to create a new bucket to store data folders:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开Amazon S3控制台；从那里，我们可以点击“创建存储桶”来创建一个新的存储桶来存储数据文件夹：
- en: '![](img/c2cb783f-9073-4468-8c89-c36969afa322.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2cb783f-9073-4468-8c89-c36969afa322.png)'
- en: This will start a wizard that will walk you through the different steps needed
    to properly create a bucket. This will give you the power to set the bucket name,
    enable versioning or logging, set tags, and set permissions. Once done, a new
    bucket will get created for you. The bucket name has to be unique so that it won't
    get conflicted with buckets used by other AWS users.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个向导，将引导您完成创建存储桶所需的不同步骤。这将使您有权设置存储桶名称、启用版本控制或日志记录、设置标签和设置权限。完成后，将为您创建一个新的存储桶。存储桶名称必须是唯一的，以免与其他AWS用户使用的存储桶发生冲突。
- en: 'I created a bucket called `mnandbucket`; it will show up in the list of buckets
    in my S3 main web page. If you have more buckets than what the page can show,
    you can search for buckets in the search bar:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个名为`mnandbucket`的存储桶；它将显示在我的S3主网页的存储桶列表中。如果您的存储桶比页面能显示的更多，您可以在搜索栏中搜索存储桶：
- en: '![](img/9209eb72-1f0b-412b-8674-e8f855a5c7d3.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9209eb72-1f0b-412b-8674-e8f855a5c7d3.png)'
- en: 'Once we enter a bucket, we can then create folders and upload files:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入存储桶，我们就可以创建文件夹并上传文件：
- en: '![](img/84fb98d0-037a-4d65-b425-8a8de899ec32.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84fb98d0-037a-4d65-b425-8a8de899ec32.png)'
- en: Perfect! With that, we have a practical idea of what S3 is about.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！通过这样，我们对S3是什么有了一个实际的了解。
- en: You can download this file from [https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下网址下载此文件：[https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf)。
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Cloud-Native-Programming-with-Golang](https://github.com/PacktPublishing/Cloud-Native-programming-with-Golang).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该书的代码包也托管在GitHub上，网址为[https://github.com/PacktPublishing/Cloud-Native-Programming-with-Golang](https://github.com/PacktPublishing/Cloud-Native-programming-with-Golang)。
- en: S3 storage can be utilized to store our application files for later use. So,
    for example, say we built our `events` microservice to run in a Linux environment,
    and the filename for the application is simply `events`. We can then simply store
    the file in an S3 folder; then, whenever we need an EC2 instance to obtain the
    file, we can use the AWS command-line tools in the Ec2 instance to achieve that.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: S3存储可以用于存储我们的应用程序文件以供以后使用。例如，假设我们构建了我们的`events`微服务以在Linux环境中运行，并且应用程序的文件名简单地是`events`。然后我们可以简单地将文件存储在S3文件夹中；然后，每当我们需要EC2实例获取文件时，我们可以使用Ec2实例中的AWS命令行工具来实现。
- en: 'We first need to ensure that the AWS roles are properly defined to allow our
    EC2 instance to access the S3 storage as was covered earlier. Then, from there,
    to copy the file from S3 to our EC2 instance, we will need to issue the following
    command from our EC2 instance:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保AWS角色已经正确定义，以允许我们的EC2实例访问S3存储，就像之前介绍的那样。然后，从那里，要将文件从S3复制到我们的EC2实例，我们需要从我们的EC2实例中发出以下命令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command will retrieve the `events` file from the S3 storage, then
    copy it to a new file called `my_local_events_copy`, which will live in the current
    folder. `<my_bucket>` and `<my_folder>` represent the bucket and the folder where
    the events file exists on the S3 storage, respectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将从S3存储中检索`events`文件，然后将其复制到一个名为`my_local_events_copy`的新文件中，该文件将位于当前文件夹中。`<my_bucket>`和`<my_folder>`分别表示S3存储中事件文件所在的存储桶和文件夹。
- en: 'After we copy an executable file to EC2, we will need to give it access to
    execute via the Linux `chmod` command. This is achieved utilizing the following
    command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在将可执行文件复制到EC2后，我们需要通过Linux的`chmod`命令给予它执行权限。这是通过以下命令实现的：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding command, `<my_executable_file>` is the file that we would like
    to obtain enough access in our EC2 instance to execute.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，`<my_executable_file>`是我们想要在EC2实例中获得足够访问权限以执行的文件。
- en: Simple Queue Service (SQS)
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单队列服务（SQS）
- en: As mentioned earlier, SQS is the message queue provided by AWS. Applications
    that can interact with SQS can send and receive messages within the AWS ecosystem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，SQS是AWS提供的消息队列。可以与SQS交互的应用程序可以在AWS生态系统内发送和接收消息。
- en: 'Let''s start by discussing how to configure an SQS from the Amazon console.
    As usual, the first step is to log in to the Amazon console and then select our
    service from the main dashboard. The service name in this case will be called
    Simple Queue Service:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论如何从Amazon控制台配置SQS开始。通常情况下，第一步是登录到Amazon控制台，然后从主仪表板中选择我们的服务。在这种情况下，服务名称将被称为简单队列服务：
- en: '![](img/ffd92463-21cb-4417-a776-8e51ca287e69.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffd92463-21cb-4417-a776-8e51ca287e69.png)'
- en: 'From there, we will need to either click on Getting started or on Create New
    Queue. The queue creation page will offer us the ability to configure the behavior
    of the new queue. For example, we can set the maximum message size allowed, the
    number of days we can retain a message, or even the wait time to receive a message:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要单击“入门”或“创建新队列”。队列创建页面将为我们提供配置新队列行为的能力。例如，我们可以设置允许的最大消息大小、保留消息的天数或接收消息的等待时间：
- en: '![](img/d01b6f1b-b33e-4864-8925-295cc565b8f5.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d01b6f1b-b33e-4864-8925-295cc565b8f5.png)'
- en: Once you are satisfied with your settings, click on Create Queue—I picked the
    name `eventqueue`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当您满意您的设置时，单击“创建队列”——我选择了名称`eventqueue`。
- en: '![](img/5027860c-394a-4bde-9e32-7a8c8b3ee3f5.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5027860c-394a-4bde-9e32-7a8c8b3ee3f5.png)'
- en: This will create a new AWS SQS queue that we can utilize in our code. Now, it's
    time to discuss how we can write code to interact with our new queue.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的AWS SQS队列，我们可以在我们的代码中使用。现在，是时候讨论如何编写代码与我们的新队列进行交互了。
- en: Perfect! With our queue created, we are ready to write some code to send and
    receive messages via the newly created AWS SQS queue. Let's start with exploring
    the code we need to write in order to send some data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！有了我们创建的队列，我们准备编写一些代码，通过新创建的AWS SQS队列发送和接收消息。让我们开始探索我们需要编写的代码，以便发送一些数据。
- en: The docs for the AWS SDK Go SQS package can be found at [https://godoc.org/github.com/aws/aws-sdk-go/service/sqs](https://godoc.org/github.com/aws/aws-sdk-go/service/sqs).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: AWS SDK Go SQS包的文档可以在[https://godoc.org/github.com/aws/aws-sdk-go/service/sqs](https://godoc.org/github.com/aws/aws-sdk-go/service/sqs)找到。
- en: 'As any other AWS service, there are two first key steps we will need to get
    out of the way:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他AWS服务一样，我们需要先完成两个关键步骤：
- en: Obtaining or creating a session object
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取或创建会话对象
- en: Creating a service client for our desired AWS service
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们想要的AWS服务创建服务客户端
- en: 'The preceding steps are covered via the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤通过以下代码进行了覆盖：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code sets the region via the code when calling the `NewSession()` constructor;
    however, we have the choice to use a shared configuration instead, as mentioned
    in the preceding chapter. I made use of `log.Fatal()` in this code since it's
    only testing code, so if anything fails, I would want to exit with the error message
    reported.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`NewSession()`构造函数时，前面的代码通过代码设置了区域；但是，我们也可以选择使用共享配置，如前一章所述。我在这段代码中使用了`log.Fatal()`，因为这只是测试代码，所以如果出现任何错误，我希望退出并报告错误消息。
- en: 'Next, we will need to obtain the message queue URL. The URL is important because
    it serves as a unique identifier for the message queue in the SDK method calls.
    We can obtain the URL either from the AWS console SQS page, where the URL of our
    queue will show in the Details tab when the queue is selected or via code by utilizing
    the queue name we chose when creating our queue. In my case, I called my queue
    `eventqueue`; so, let''s take a look at how we can obtain the URL from that name
    through our code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要获取消息队列的URL。URL很重要，因为它在SDK方法调用中充当消息队列的唯一标识符。我们可以通过AWS控制台SQS页面获取URL，当选择队列时，队列的URL将显示在详细信息选项卡中，也可以通过使用我们创建队列时选择的队列名称来通过代码获取URL。在我的情况下，我称我的队列为`eventqueue`；所以，让我们看看如何通过我们的代码从该名称获取URL：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `QUResult` object is of the `*GetQueueUrlOutput` type, which is a pointer
    to a struct that contains a field called `QueueUrl` of the `*string` type. This
    field should have our queue URL if the `GetQueueUrl()` method  is executed successfully.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`QUResult`对象是`*GetQueueUrlOutput`类型的，它是指向包含`*string`类型的`QueueUrl`字段的结构体的指针。如果`GetQueueUrl()`方法成功执行，该字段应该包含我们的队列URL。'
- en: Perfect! Now that we have the URL of our queue, we are ready to send some data
    over the message queue. However, before we do that, we will need to cover some
    important definitions to understand the code that is yet to come.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们有了队列的URL，我们准备通过消息队列发送一些数据。但在这样做之前，我们需要了解一些重要的定义，以理解即将到来的代码。
- en: '**Message body***:* A message body is simply the core message we are trying
    to send. For example, if I want to send a hello message via SQS, then the message
    body would be hello.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息主体***:* 消息主体只是我们试图发送的核心消息。例如，如果我想通过SQS发送一个hello消息，那么消息主体将是hello。'
- en: '**Message attributes***:* Message attributes are a collection of structured
    metadata items. You can think of them simply as a list of key value pairs that
    you can define and send with your message. Message attributes are optional; however,
    they can be powerful because they allow sending messages that are more structured
    and sophisticated than just text. Message attributes allow us to understand what
    the message might contain before we start processing the message body. We can
    include up to 10 message attributes per message. Message attributes support three
    main data types: string, number, and binary. A Binary type represents binary data
    such as compressed files and images.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息属性***:* 消息属性是一组结构化的元数据项。您可以简单地将它们视为您可以定义并与消息一起发送的键值对列表。消息属性是可选的；但是，它们可能非常有用，因为它们允许发送比纯文本更结构化和复杂的消息。消息属性允许我们在开始处理消息主体之前了解消息可能包含的内容。我们可以在每条消息中包含多达10个消息属性。消息属性支持三种主要数据类型：字符串、数字和二进制。二进制类型表示二进制数据，如压缩文件和图像。'
- en: 'Now, let''s return to our sample code; let''s say that we want to send a message
    via SQS for our events app to represent a customer reservation for  some concerts;
    our message will have the following properties:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的示例代码；假设我们想通过SQS发送一条消息给我们的事件应用，表示某些音乐会的客户预订；我们的消息将具有以下属性：
- en: '**Message attributes**: We would like two message attributes:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息属性**：我们希望有两个消息属性：'
- en: '`message_type`: The type of the message we are trying to send—in our case,
    the value of this attribute will be "RESERVATION"'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message_type`：我们尝试发送的消息类型——在我们的情况下，此属性的值将是"RESERVATION"'
- en: '`Count`: The number of reservations included in this message'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Count`：包含在此消息中的预订数量'
- en: '**Message body**: This entails the reservation data in JSON format. The data
    includes the customer names reserving the concert and the event name (the concert,
    in this case)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息正文**：这包括以JSON格式表示的预订数据。数据包括预订音乐会的客户姓名和事件名称（在这种情况下是音乐会）'
- en: 'Here is what the code will look like:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的样子：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code makes use of the `SendMessage()` method to send the message. `SendMessage()` takes
    an argument of the `*SendMessageInput{}` type, which is where we define the message
    attributes, message body, and where we identify the queue URL.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用`SendMessage()`方法发送消息。`SendMessage()`接受`*SendMessageInput{}`类型的参数，我们在其中定义消息属性、消息正文，并标识队列URL。
- en: 'Afterward, we can then check whether any error occurred. We can obtain the
    ID for the message we created via the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以检查是否发生了任何错误。我们可以通过以下代码获取我们创建的消息的ID：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Perfect! With this piece of sample code, we now know how to send message over
    SQS. Now, let's learn how to receive them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！有了这段示例代码，我们现在知道如何通过SQS发送消息。现在，让我们学习如何接收它们。
- en: There are some concepts that we will need to cover and questions we will need
    answered before we start looking into the message receiving code. Let's assume
    that we have a microservice architecture where more than one microservices are
    reading messages from an SQS message queue. An important question to answer is,
    what do we do after one of our services receives a message? Should that message
    be allowed to be received by the other services afterward? The answer for those
    two questions depends on the purpose of the said message. If the message is supposed
    to be consumed and processed once, then we will need to ensure that the first
    service to properly receive this message should then delete it from the queue.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看消息接收代码之前，有一些概念需要涵盖和问题需要回答。让我们假设我们有一个微服务架构，超过一个微服务从SQS消息队列中读取消息。一个重要的问题是，我们的服务接收到消息后该怎么办？该消息之后是否允许其他服务接收？这两个问题的答案取决于消息的目的。如果消息应该被消费和处理一次，那么我们需要确保第一个正确接收到消息的服务应该从队列中删除它。
- en: In the world of AWS SQS, a message does not get deleted from the queue when
    it gets received in a standard queue. We will instead need to explicitly delete
    the message from the queue after we receive it in order to ensure that it disappears,
    if that's our intention. However, there is another complication. Let's assume
    that microservice A received a message and started processing it. However, before
    microservice A got to deleting the message from the queue, microservice B received
    the message and started processing it, which we don't want.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS SQS的世界中，当标准队列中的消息被接收时，消息不会从队列中删除。相反，我们需要在接收消息后明确从队列中删除消息，以确保它消失，如果这是我们的意图。然而，还有另一个复杂之处。假设微服务A接收了一条消息并开始处理它。然而，在微服务A删除消息之前，微服务B接收了消息并开始处理它，这是我们不希望发生的。
- en: To avoid that scenario, SQS introduces a concept called **visibility timeout**.
    A visibility timeout simply makes a message invisible for a certain period of
    time after it gets received by one consumer. This timeout gives us some time to
    decide what to do with the message before other consumers get to see it and process
    it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，SQS引入了一个叫做**可见性超时**的概念。可见性超时简单地使消息在被一个消费者接收后一段时间内不可见。这个超时给了我们一些时间来决定在其他消费者看到并处理消息之前该怎么处理它。
- en: One important remark is that there is not always a guarantee against receiving
    a message twice. The reason for that is because SQS queues are typically distributed
    among multiple servers. There are rare cases where a delete request doesn't reach
    the server because it is offline, which means the message might survive despite
    a delete request.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的说明是，并不总是能保证不会收到重复的消息。原因是因为SQS队列通常分布在多个服务器之间。有时删除请求无法到达服务器，因为服务器离线，这意味着尽管有删除请求，消息可能仍然存在。
- en: Another important concept in the world of SQS is long polling or wait time.
    Since SQS is distributed and might have some delays every now and then, some messages
    might be slow to be received. If we care about receiving messages even if they
    are slow, then we will need to wait longer when listening to incoming messages.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQS的世界中，另一个重要概念是长轮询或等待时间。由于SQS是分布式的，可能偶尔会有一些延迟，有些消息可能接收得比较慢。如果我们关心即使消息接收慢也要接收到消息，那么在监听传入消息时我们需要等待更长的时间。
- en: 'The following is a sample piece of code that shows receiving a message from
    a queue:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例代码片段，显示从队列接收消息：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we attempt to listen to incoming message from the SQS
    queue, which we created. We use the `GetQueueURL()` method as before to retrieve
    the queue URL to utilize in the `ReceiveMessage()` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们尝试监听来自我们创建的SQS队列的传入消息。我们像之前一样使用`GetQueueURL()`方法来检索队列URL，以便在`ReceiveMessage()`方法中使用。
- en: The `ReceiveMessage()` method allows us to specify the message attributes (which
    we discussed earlier) that we would like to capture, as well as the general  system
    attributes. System attributes are general properties of the message, such as the
    time stamp that came with it. In the preceding code, we ask for all the message
    attributes, but only for the message time stamp system attribute.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReceiveMessage()`方法允许我们指定我们想要捕获的消息属性（我们之前讨论过的），以及一般的系统属性。系统属性是消息的一般属性，例如随消息一起传递的时间戳。在前面的代码中，我们要求所有消息属性，但只要消息时间戳系统属性。'
- en: We set the maximum number of messages we would like to receive in a single call
    to be 10\. It is important to point out that this is only the maximum number of
    message requested, so it is common to receive less. Finally, we will set the polling
    time to be a maximum of 20 seconds. If we receive messages faster than 20 seconds,
    the call returns with the captured messages without having to wait.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置单次调用中要接收的最大消息数为10。重要的是要指出，这只是请求的最大消息数，因此通常会收到更少的消息。最后，我们将轮询时间设置为最多20秒。如果我们在20秒内收到消息，调用将返回捕获的消息，而无需等待。
- en: 'Now, what should we do with the captured messages? For the sake of showcasing
    code, let''s say that we would like to print the message body and message attributes
    to the standard output. Afterward, we delete the messages. Here is what this would
    look like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该怎么处理捕获的消息呢？为了展示代码，假设我们想要将消息正文和消息属性打印到标准输出。之后，我们删除这些消息。这是它的样子：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that in the preceding code, we used an object called `msg.ReceiptHandle` in
    the `DeleteMessage()` method in order to identify the message we would like to
    delete. ReceiptHandle is an object that we obtain whenever we receive a message
    from the queue; the purpose of this object is to allow us to delete the message
    that we received afterward. Whenever a message is received, a ReceiptHandle is
    created.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码中，我们在`DeleteMessage()`方法中使用了一个名为`msg.ReceiptHandle`的对象，以便识别我们想要删除的消息。ReceiptHandle是我们从队列接收消息时获得的对象；这个对象的目的是允许我们在接收消息后删除消息。每当接收到一条消息时，都会创建一个ReceiptHandle。
- en: 'Also, we received the message in the preceding code and then dissect it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在前面的代码中，我们接收了消息然后对其进行了解析：
- en: We call `msg.Body` to retrieve the body of our message
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`msg.Body`来检索我们消息的正文
- en: We call `msg.MessageAttributes` to obtain the message attributes of our message
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`msg.MessageAttributes`来获取我们消息的消息属性
- en: We call `msg.Attributes` to obtain the system attributes that came with our
    message
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`msg.Attributes`来获取随消息一起传递的系统属性
- en: With that, we have enough knowledge to implement an SQS message queue emitter
    and listener for our `events` application. In a previous chapter, we created two
    key interface that need to be implemented for message queues in our application.
    One of them was the emitter interface, which was responsible for sending a message
    over a message queue. The other was the listener interface, which was responsible
    for receiving a message from a message queue.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，我们就有足够的知识来为我们的`events`应用程序实现一个SQS消息队列发射器和监听器。在之前的章节中，我们为应用程序中的消息队列创建了两个关键接口需要实现。其中一个是发射器接口，负责通过消息队列发送消息。另一个是监听器接口，负责从消息队列接收消息。
- en: 'As a quick refresher, how is what the emitter interface looked like:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速的复习，发射器接口的样子是什么：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, here is what the listener interface looked like:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是监听器接口的样子：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Listen` method takes a list of event names, then return those events in
    a channel, as well as any errors occurred while trying to receive the events via
    the message queue. This is called the channel generator pattern.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Listen`方法接受一个事件名称列表，然后将这些事件以及尝试通过消息队列接收事件时发生的任何错误返回到一个通道中。这被称为通道生成器模式。'
- en: So, for our application to support the SQS message queue, we will need to implement
    those two interfaces. Let's start with the `Emitter` interface. We'll create a
    new folder inside `./src/lib/msgqueue`; the new folder name will be `sqs`. Inside
    the `sqs` folder, we create two files—`emitter.go` and `listener.go`. `emitter.go`
    is where we will implement the emitter interface.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了支持SQS消息队列，我们需要实现这两个接口。让我们从`Emitter`接口开始。我们将在`./src/lib/msgqueue`内创建一个新文件夹；新文件夹的名称将是`sqs`。在`sqs`文件夹内，我们创建两个文件——`emitter.go`和`listener.go`。`emitter.go`是我们将实现发射器接口的地方。
- en: 'We start by creating a new object to implement the emitter interface—the object
    is called `SQSEmitter`. It will contain the SQS service client object, as well
    as the URL of our queue:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新对象来实现发射器接口——这个对象被称为`SQSEmitter`。它将包含SQS服务客户端对象，以及我们队列的URL：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will then need to create a constructor for our emitter. In the constructor,
    we''ll create the SQS service client from either an existing session or from a
    newly created session. We will also utilize the `GetQueueUrl` method in order
    to obtain the URL of our queue. Here is what this will look like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要为我们的发射器创建一个构造函数。在构造函数中，我们将从现有会话或新创建的会话中创建SQS服务客户端。我们还将利用`GetQueueUrl`方法来获取我们队列的URL。这是它的样子：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next step is to implement the `Emit()` method of the emitter interface.
    The message we will emit should have the following properties:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现发射器接口的`Emit()`方法。我们将发射的消息应具有以下属性：
- en: It will contain a single message attribute called `event_name`, which will hold
    the name of the event we are trying to send. As covered before, in this book,
    an event name describes the type of the event our application is trying to process.
    We had three event names—`eventCreated`, `locationCreated`, and `eventBooked`.
    Remember here that `eventCreated` and `eventBooked` , refer to application events
    (and not message queue events) being created or booked, like concerts or circus
    acts for example.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将包含一个名为`event_name`的单个消息属性，其中将保存我们试图发送的事件的名称。如前所述，在本书中，事件名称描述了我们的应用程序试图处理的事件类型。我们有三个事件名称
    - `eventCreated`、`locationCreated`和`eventBooked`。请记住，这里的`eventCreated`和`eventBooked`是指应用程序事件（而不是消息队列事件）的创建或预订，例如音乐会或马戏团表演。
- en: It will contain a message body, which will hold the event data. The message
    body will be in JSON format.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将包含一个消息正文，其中将保存事件数据。消息正文将以JSON格式呈现。
- en: 'Here is what the code will look like:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将如下所示：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this, we have an SQS message queue implementation for the emitter interface.
    Now, let's discuss the listener interface.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就有了一个用于发射器接口的SQS消息队列实现。现在，让我们讨论监听器接口。
- en: 'The listener interface will be implemented in the `./src/lib/msgqueue/listener.go` file.
    We start with the object that will implement the interface. The object name is
    `SQSListener`. It will contain the message queue event type mapper, the SQS client
    service object, the URL of the queue, the maximum number of messages to be received
    from one API call, the wait time for messages to be received, and the visibility
    timeout. Here is what this will look like:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器接口将在`./src/lib/msgqueue/listener.go`文件中实现。我们从将实现接口的对象开始。对象名称是`SQSListener`。它将包含消息队列事件类型映射器、SQS客户端服务对象、队列的URL、从一个API调用中接收的消息的最大数量、消息接收的等待时间和可见性超时。这将如下所示：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will first start with the constructor; the code will be similar to the constructor
    we built for the emitter. We will ensure that we have an AWS session object, a
    service client object, and obtain the URL of our queue based on the queue name:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从构造函数开始；代码将类似于我们为发射器构建的构造函数。我们将确保我们有一个AWS会话对象、一个服务客户端对象，并根据队列名称获取我们队列的URL：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Afterward, we will need to implement the `Listen()` method of the `listener`
    interface. The method does the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要实现`listener`接口的`Listen()`方法。该方法执行以下操作：
- en: It takes a list of event names as arguments
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将接收到的事件名称列表作为参数
- en: It listens to incoming messages
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它监听传入的消息
- en: When it receives a message, it checks the message event name and compares it
    with the list of event names that were passed as arguments
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它接收到消息时，它会检查消息事件名称并将其与作为参数传递的事件名称列表进行比较
- en: If a message is received that does not belong to a requested event, it gets
    ignored
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果接收到不属于请求事件的消息，它将被忽略
- en: If a message is received that belongs to a known event, it gets passed through
    the a Go channel of the 'Event' type to the outside world
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果接收到属于已知事件的消息，它将通过“Event”类型的Go通道传递到外部世界
- en: Messages that are accepted get deleted after they pass through the Go channel
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Go通道传递后，接受的消息将被删除
- en: Any errors that occur get passed through another Go channel for error objects
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生的任何错误都会通过另一个Go通道传递给错误对象
- en: 'Let''s focus on the code that will listen and receive messages for the time
    being. We will create a new method called `receiveMessage()` for that. Here is
    how it is broken down:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时专注于将监听和接收消息的代码。我们将创建一个名为`receiveMessage()`的新方法。以下是它的分解：
- en: 'First, we receive messages and pass any errors to a Go error channel:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们接收消息并将任何错误传递到Go错误通道：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then go through the received messages one by one and check their message
    attributes—if the event name does not belong to the list of requested event names,
    we ignore it by moving to the next message:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们逐条查看接收到的消息并检查它们的消息属性 - 如果事件名称不属于请求的事件名称列表，我们将通过移动到下一条消息来忽略它：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we continue, we retrieve the message body, then use our event mapper object
    to translate it to an Event type that we can use in our external code. The event
    mapper object was created in [Chapter 4](0a806398-0654-46f9-8e6f-02af9334821b.xhtml),
    *Asynchronous Microservice Architectures Using Message Queues*; it simply takes
    an event name and the binary form of the event, then it returns an Event object
    to us. After that, we obtain the event object and pass it to the events channel.
    If we detect errors, we pass the error to the errors channel, then move to the
    next message:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们继续，我们将检索消息正文，然后使用我们的事件映射器对象将其翻译为我们在外部代码中可以使用的事件类型。事件映射器对象是在[第4章](0a806398-0654-46f9-8e6f-02af9334821b.xhtml)中创建的，*使用消息队列的异步微服务架构*；它只是获取事件名称和事件的二进制形式，然后将一个事件对象返回给我们。之后，我们获取事件对象并将其传递到事件通道。如果我们检测到错误，我们将错误传递到错误通道，然后移动到下一条消息：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, if we reach to this point without errors, then we know we succeeded
    in processing the message. So, the next step will be to delete the message so
    that it won''t be processed by someone else:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果我们在没有错误的情况下到达这一点，那么我们知道我们成功处理了消息。因此，下一步将是删除消息，以便其他人不会处理它：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is great. You might wonder, however, how come we didn''t put this code
    directly in the `Listen()` method? The answer is simple: we did that to clean
    up our code and avoid one massive method. This is because the piece of code we
    just covered needs to be called in a loop so that we keep receiving messages from
    the message queue continuously.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒。然而，你可能会想，为什么我们没有直接将这段代码放在`Listen()`方法中呢？答案很简单：我们这样做是为了清理我们的代码，避免一个庞大的方法。这是因为我们刚刚覆盖的代码片段需要在循环中调用，以便我们不断地从消息队列中接收消息。
- en: 'Now, let''s look at the `Listen()` method. The method will need to call `receiveMessage()` in
    a loop inside a goroutine. The reason why a goroutine is needed is because otherwise
    the `Listen()` method would block its calling thread. Here is what this will look
    like:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`Listen()`方法。该方法将需要在goroutine内的循环中调用`receiveMessage()`。需要goroutine的原因是，否则`Listen()`方法会阻塞其调用线程。这是它的样子：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code first ensures that the `*SQSListener` object is not nil,
    then it creates the events and the errors Go channels to be utilized for communicating
    the results of the `receiveMessage()` method to the outside world.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码首先确保`*SQSListener`对象不为空，然后创建用于将`receiveMessage()`方法的结果传递给外部世界的events和errors
    Go通道。
- en: AWS API gateway
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS API网关
- en: The next step in our quest to dive into cloud native applications is to take
    a tour into the AWS API gateway. As mentioned earlier, the AWS API gateway is
    a hosted service that allows developers to build flexible APIs for their applications.
    In this section, we will go through a practical introduction about the service
    and how it can be used.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入云原生应用程序的下一步是进入AWS API网关。如前所述，AWS API网关是一个托管服务，允许开发人员为其应用程序构建灵活的API。在本节中，我们将介绍有关该服务的实际介绍以及如何使用它的内容。
- en: Similar to the other services that we have covered so far, we will create an
    API gateway via the AWS console. The first step, as usual, would be to visit and
    log in to the AWS console at [aws.amazon.com](http://aws.amazon.com).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今为止涵盖的其他服务类似，我们将通过AWS控制台创建一个API网关。首先，像往常一样，访问并登录到[aws.amazon.com](http://aws.amazon.com)的AWS控制台。
- en: 'The second step would be to go to the home page, and then select API Gateway
    from under Application Services:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是转到主页，然后从应用服务下选择API Gateway：
- en: '![](img/c4769d0c-1552-453c-97eb-858fb84c6788.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4769d0c-1552-453c-97eb-858fb84c6788.png)'
- en: 'Next, we will need to select API from the left-hand side, then click on Create
    API. This will start the process of creating a new API to use for our application:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从左侧选择API，然后点击创建API。这将开始创建一个新的API供我们的应用使用的过程：
- en: '![](img/ca26727e-794e-46a8-a48b-b373300c0a3a.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca26727e-794e-46a8-a48b-b373300c0a3a.png)'
- en: 'From there, we get to pick a name of our new API, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以选择我们的新API的名称，如下所示：
- en: '![](img/6fecc87a-19a7-464a-bc6a-deea81ef9aba.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fecc87a-19a7-464a-bc6a-deea81ef9aba.png)'
- en: 'Now, after creating the API, we will need to create mappings between the AWS
    API gateway, and the addresses of the RESTful APIs embedded in our MyEvents application.
    The MyEvents application included more than one microservice. One of those microservices
    was the events services; it supported several tasks that could be activated via
    its RESTful API. As a refresher, here is a quick summary of the API tasks and
    examples of their relative URL addresses:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在创建API之后，我们需要在AWS API网关和嵌入在我们的MyEvents应用程序中的RESTful API的地址之间创建映射。MyEvents应用程序包含多个微服务。其中一个微服务是事件服务；它支持可以通过其RESTful
    API激活的多个任务。作为复习，这里是API任务的快速摘要和它们相对URL地址的示例：
- en: '**Searching for events**:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**搜索事件**：'
- en: '**ID**: The relative URL is `/events/id/3434`, method is `GET`, and no data
    expected in the HTTP body'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID**：相对URL是`/events/id/3434`，方法是`GET`，HTTP主体中不需要数据。'
- en: '**Name**: The relative URL is `/events/name/jazz_concert`, method is `GET`,
    and no data expected in the HTTP body'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：相对URL是`/events/name/jazz_concert`，方法是`GET`，HTTP主体中不需要数据。'
- en: '**Retrieving all events at once**: The relative URL is `/events`, method is
    `GET`, and no data expected in the HTTP body'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一次检索所有事件**：相对URL是`/events`，方法是`GET`，HTTP主体中不需要数据。'
- en: '**Creating a new event**: The relative URL is `/events`, method is `POST`,
    and the expected data in the HTTP body needs to be the JSON representation of
    the new event we would like to add. Let’s say we would like to add the event of
    `opera aida` that would play in the U.S. Then, the HTTP body would look like this:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建新事件**：相对URL是`/events`，方法是`POST`，HTTP主体中期望的数据需要是我们想要添加的新事件的JSON表示。假设我们想要添加在美国演出的`aida歌剧`。那么HTTP主体会是这样的：'
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's explore the events microservice API task by task and learn how to get
    the AWS API gateway to act as a front door to the application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个探索事件微服务API的任务，并学习如何让AWS API网关充当应用程序的前门。
- en: 'From the preceding description, we have three relative URLs:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的描述中，我们有三个相对URL：
- en: '`/events/id/{id}`, where `{id}` is a number. We support `GET` HTTP requests
    with that URL.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/events/id/{id}`，其中`{id}`是一个数字。我们支持使用该URL进行`GET` HTTP请求。'
- en: '`/events/name/{name}`, where `{name}` is a string. We support `GET` HTTP requests
    with that URL'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/events/name/{name}`，其中`{name}`是一个字符串。我们支持使用该URL进行`GET` HTTP请求。'
- en: '`/events`, where we support `GET` and `POST` requests with this URL.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/events`，我们支持使用此URL进行`GET`和`POST`请求。'
- en: 'To represent those relative URLs with their methods in our AWS API gateway,
    we will need to perform the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的AWS API网关中表示这些相对URL和它们的方法，我们需要执行以下操作：
- en: Create a new resource and call it `events`. We will first visit our newly created
    API page. Then, from there, we will create a new resource by clicking on Actions
    and selecting Create Resource:![](img/0f3fdfa1-1a5b-484e-899b-6d84c1f92329.png)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`events`的新资源。首先访问我们新创建的API页面。然后，通过点击操作并选择创建资源来创建一个新资源：![](img/0f3fdfa1-1a5b-484e-899b-6d84c1f92329.png)
- en: 'Ensure that you set both the name and the path to `events` on the new resource:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在新资源上设置名称和路径为`events`：
- en: '![](img/8f64e9d5-4c76-44f1-8619-dcb9dd28cf83.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f64e9d5-4c76-44f1-8619-dcb9dd28cf83.png)'
- en: Afterwards, select the newly created `events` resource and create a new resource
    called `id`. Select the `events` resource again, but this time, create a new resource
    called `name`. Here is what this will look like:![](img/c3ee5533-1b7b-4d69-bf25-4fc82b937394.png)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择新创建的`events`资源并创建一个名为`id`的新资源。再次选择`events`资源，但这次创建一个名为`name`的新资源。这是它的样子：![](img/c3ee5533-1b7b-4d69-bf25-4fc82b937394.png)
- en: Select the `id` resource, then create a new resource. This time, call the resource
    name `id` again; however, the resource path needs to be `{id}`. This is important
    because it indicates that `id` is a parameter that can accept other values. Meaning
    that this resource can represent a relative URL that looks like this `/events/id/3232`:![](img/aac14ca8-f2ab-409e-8c10-9b70f2b7b08c.png)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`id`资源，然后创建一个新的资源。这一次，再次将资源名称命名为`id`；但是，资源路径需要是`{id}`。这很重要，因为它表明`id`是一个可以接受其他值的参数。这意味着这个资源可以表示一个相对URL，看起来像这样`/events/id/3232`：![](img/aac14ca8-f2ab-409e-8c10-9b70f2b7b08c.png)
- en: Similar to step 4, we will select the `name` resource, then create another resource
    underneath, which will have the resource name as `name` and the resource path
    as `{name}`. Here is what this will end up looking like:![](img/26f4531e-fb61-48cf-b537-ede864da0d7e.png)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与步骤4类似，我们将选择`name`资源，然后在其下创建另一个资源，资源名称为`name`，资源路径为`{name}`。这是最终的样子：![](img/26f4531e-fb61-48cf-b537-ede864da0d7e.png)
- en: Now, this should cover all our relative URLs. We need to attach the supported
    HTTP methods to their corresponding resources. First, we will go the `events`
    resource and then attach a `GET` method as well as a `POST` method to it. To do
    that, we need to click on s, then select Create Method:![](img/136c1c91-6bc1-4cb8-b5a0-1ee19ebc5beb.png)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这应该涵盖了我们所有的相对URL。我们需要将支持的HTTP方法附加到相应的资源上。首先，我们将转到`events`资源，然后将`GET`方法以及`POST`方法附加到它上面。为了做到这一点，我们需要点击s，然后选择创建方法：![](img/136c1c91-6bc1-4cb8-b5a0-1ee19ebc5beb.png)
- en: We can then select GET as the method type:![](img/fb182a15-d591-4060-aafd-36923b802351.png)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以选择GET作为方法类型：![](img/fb182a15-d591-4060-aafd-36923b802351.png)
- en: We then select the integration type of HTTP. From there, we will need to set
    the endpoint URL. The endpoint URL needs to be the absolute path of the API endpoint
    that corresponds to this resource. In our case, since we are under the 'events'
    resource, the absolute address for the resource on the 'events' microservice would
    be `<EC2 DNS Address>/events`. Let's assume that the DNS is `http://ec2.myevents.com`;
    this will make the absolute path `http://ec2.myevents.com/events`. Here is what
    this configuration will look like:![](img/7f554357-b403-4375-b3a6-8b06db91e1d6.png)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们选择HTTP作为集成类型。从那里，我们需要设置端点URL。端点URL需要是与此资源对应的API端点的绝对路径。在我们的情况下，因为我们在'events'资源下，该资源在'events'微服务上的绝对地址将是`<EC2
    DNS Address>/events`。假设DNS是`http://ec2.myevents.com`；这将使绝对路径为`http://ec2.myevents.com/events`。这是这个配置的样子：![](img/7f554357-b403-4375-b3a6-8b06db91e1d6.png)
- en: We will repeat the preceding step; however, this time we will create a `POST`
    method.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重复上述步骤；但是，这一次我们将创建一个`POST`方法。
- en: We select the `{id}` resource, then create a new `GET` method. The `EndPoint`
    URL needs to include the `{id}`; here is what this will look like:![](img/9eb620b8-1220-4b85-8857-cfb8a0c7dc39.png)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择`{id}`资源，然后创建一个新的`GET`方法。`EndPoint` URL需要包括`{id}`；这是它的样子：![](img/9eb620b8-1220-4b85-8857-cfb8a0c7dc39.png)
- en: 'We will repeat the same step with the `{name}` resource; here is what the Endpoint
    URL will look like: `http://ec2.myevents.com/events/name/{name}`.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重复使用`{name}`资源进行相同的步骤；这是Endpoint URL的样子：`http://ec2.myevents.com/events/name/{name}`。
- en: 'Perfect! With this, we created AWS API gateway mappings to our events microservice
    API. We can use the same technique to add more resources in our MyEvents API that
    would point to other microservices that belong to the MyEvents application. The
    next step is to deploy the API. The first thing we need to do is to create a new
    stage. A stage is a way to identify a deployed RESTful API that is callable by
    users. We will need to create a stage before we can deploy a RESTful API. To deploy
    an API, we will need to click on Actions and then on Deploy API:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！通过这样，我们为我们的事件微服务API创建了AWS API网关映射。我们可以使用相同的技术在我们的MyEvents API中添加更多资源，这些资源将指向属于MyEvents应用程序的其他微服务。下一步是部署API。我们需要做的第一件事是创建一个新的阶段。阶段是一种标识已部署的可由用户调用的RESTful
    API的方式。在部署RESTful API之前，我们需要创建一个阶段。要部署API，我们需要点击操作，然后点击部署API：
- en: '![](img/c7f19c7c-5bd3-48b3-b059-fc6327340fdc.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7f19c7c-5bd3-48b3-b059-fc6327340fdc.png)'
- en: 'If we don''t already have a stage, we will need to select [New Stage] as our
    Deployment stage, then pick a stage name, and finally click on Deploy. I will
    call my stage `beta`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有阶段，我们需要选择[New Stage]作为我们的部署阶段，然后选择一个阶段名称，最后点击部署。我将我的阶段命名为`beta`：
- en: '![](img/d4035639-deb8-48ed-85a4-bfd9e61d9a85.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4035639-deb8-48ed-85a4-bfd9e61d9a85.png)'
- en: 'Once we deploy our RESTful API resources to a stage, we can start using it.
     We can find out the API URLs for our AWS API gateway door to our events microservice
    by navigating to Stages, then clicking on the desired resource to explore, the
    selected resource API URL is defined here as `Invoke URL`. In the below figure,
    we selected the events resource, the API URL can be found on the right hand side:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将RESTful API资源部署到一个阶段，我们就可以开始使用它。我们可以通过导航到阶段，然后点击所需资源来查找我们的AWS API网关门到我们的事件微服务的API
    URL。在下图中，我们选择了events资源，API URL可以在右侧找到：
- en: '![](img/747e1c87-2da3-44a7-bbbb-90e4df64b407.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/747e1c87-2da3-44a7-bbbb-90e4df64b407.png)'
- en: DynamoDB
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DynamoDB
- en: DynamoDB is a very important part of the AWS ecosystem; it typically serves
    as the backend database for numerous cloud native applications. DynamoDB is a
    distributed high-performance database hosted in the cloud, which is offered as
    a service by AWS.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB是AWS生态系统中非常重要的一部分；它通常作为众多云原生应用程序的后端数据库。DynamoDB是一个分布式高性能数据库，托管在云中，由AWS作为服务提供。
- en: DynamoDB components
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DynamoDB组件
- en: 'Before we discuss how to write code that can interact with DynamoDB, we will
    need to first cover some important concepts regarding the database. DynamoDB consists
    of the following components:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何编写可以与DynamoDB交互的代码之前，我们需要首先了解一些关于数据库的重要概念。DynamoDB由以下组件组成：
- en: '**Tables***:* Like a typical database engine, DynamoDB stores data in a collection
    of tables. For example, in our MyEvents application, we can have an `events` table
    that would store events information such as concert names and start dates. Similarly,
    we can also have a `bookings` table to host booking information for our users.
    We can also have a `users` table to store our users information.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表：与典型的数据库引擎一样，DynamoDB将数据存储在一组表中。例如，在我们的MyEvents应用程序中，我们可以有一个“事件”表，用于存储诸如音乐会名称和开始日期之类的事件信息。同样，我们还可以有一个“预订”表，用于存储我们用户的预订信息。我们还可以有一个“用户”表，用于存储我们用户的信息。
- en: '**Items***:* Items are nothing more than the rows of the DynamoDB tables. Information
    inside an item is known as attributes. If we take the `events` table as an example,
    an item would be a single event in that table. Similarly, if we take the `users` table
    as an example, each item is a user. Each item in the table needs a unique identifier,
    also known as primary key, that will distinguish the item from all the other items
    in the table.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目：项目只是DynamoDB表的行。项目内的信息称为属性。如果我们以“事件”表为例，项目将是该表中的单个事件。同样，如果我们以“用户”表为例，每个项目都是一个用户。表中的每个项目都需要一个唯一标识符，也称为主键，以区分该项目与表中所有其他项目。
- en: '**Attributes**: As mentioned in the previous point, attributes represent the
    information inside an item. Each item consists of one or more attributes. You
    can think of an attribute as the holders of your data. Each attribute consists
    of an attribute name and attribute value. If we take the `events` table as an
    example, each `event` item will have an `ID` attribute to represent the event
    ID, a `name` attribute to represent an event name, a `startdate` attribute, an
    `enddate` attribute, and so on.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性：如前所述，属性代表项目内的信息。每个项目由一个或多个属性组成。您可以将属性视为数据的持有者。每个属性由属性名称和属性值组成。如果我们以“事件”表为例，每个“事件”项目将具有一个“ID”属性来表示事件ID，一个“名称”属性来表示事件名称，一个“开始日期”属性，一个“结束日期”属性等等。
- en: The item primary key is the only attribute in an item that must be defined beforehand.
    However, any other attribute inside an item doesn't need to be predefined. This
    makes DynamoDB a schemaless database, which means that the structure of the database
    table does not need to be defined before filling the table with data.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 项目主键是项目中必须预先定义的唯一属性。但是，项目中的任何其他属性都不需要预定义。这使得DynamoDB成为一个无模式数据库，这意味着在填充表格数据之前不需要定义数据库表的结构。
- en: Most of the attributes in DynamoDB are scalar. This means that they can have
    only one value. An example of a scalar attribute is a string attribute or number
    attribute. Some attributes can be nested, where an attribute can host another
    attribute and so on. Attributes are allowed to get nested up to 32 levels deep.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB中的大多数属性都是标量的。这意味着它们只能有一个值。标量属性的一个示例是字符串属性或数字属性。有些属性可以是嵌套的，其中一个属性可以承载另一个属性，依此类推。属性允许嵌套到32级深度。
- en: Attribute value data types
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性值数据类型
- en: 'As mentioned earlier, each DynamoDB attribute consists of an attribute name
    and an attribute value. The attribute value in turn consists of two pieces: the
    value''s data type name, and the value data. In this section, we''ll focus on
    the data types.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个DynamoDB属性由属性名称和属性值组成。属性值又由两部分组成：值的数据类型名称和值数据。在本节中，我们将重点关注数据类型。
- en: 'There are three main data types categories:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个主要的数据类型类别：
- en: '**Scalar Types***:* This is the simplest data type; it represents a single
    value. The scalar type category encompasses the following data type names:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量类型：这是最简单的数据类型；它表示单个值。标量类型类别包括以下数据类型名称：
- en: '`*S*`**: **This is simply a string type; it utilizes the UTF-8 encoding; the
    length of the string must be between zero and 400 KB.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`：这只是一个字符串类型；它利用UTF-8编码；字符串的长度必须在零到400 KB之间。'
- en: '`N`**: **This is a number type. They can be positive, negative, or simply zero.
    They can go up to 38 digits precision.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`N`：这是一个数字类型。它们可以是正数、负数或零。它们可以达到38位精度。'
- en: '`*B*`**: **An attribute of type binary. Binary data includes compressed texts,
    encrypted data, or images. The length needs to be between 0 and 400 KB. Our applications
    must encode binary data values in base64-encoded format before sending them to
    DynamoDB.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`B`：二进制类型的属性。二进制数据包括压缩文本、加密数据或图像。长度需要在0到400 KB之间。我们的应用程序必须在将二进制数据值发送到DynamoDB之前以base64编码格式对二进制数据进行编码。'
- en: '`*BOOL*`**: **An attribute of Boolean. It can be either true or false.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOL`：布尔属性。它可以是true或false。'
- en: '**Document Types***:* The document types is a complex structure with nested
    attributes. There are two data types name that fall under this category:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档类型：文档类型是一个具有嵌套属性的复杂结构。此类别下有两个数据类型名称：
- en: '`L`**: **An attribute of type list. This type can store an ordered collection
    of values. There are no restrictions on the data types that can be stored in a
    list.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L`：列表类型的属性。此类型可以存储有序集合的值。对可以存储在列表中的数据类型没有限制。'
- en: '`*Map*`**: **A map type stores data in an unordered collection of name-value
    pairs.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`：地图类型将数据存储在无序的名称-值对集合中。'
- en: '**Set Types***: *A set type can represent multiple scalar values. All items
    in a set type must be of the same type. There are three data type names that fall
    under this category:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合类型：集合类型可以表示多个标量值。集合类型中的所有项目必须是相同类型。此类别下有三个数据类型名称：
- en: '`*NS*`**: **A set of numbers'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NS`：一组数字'
- en: '`SS`**: **A set of strings'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SS`：一组字符串'
- en: '`BS`**: **A set of binary values'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BS`：一组二进制值'
- en: Primary keys
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主键
- en: As mentioned earlier, the only part of a DynamoDB table item that needs to be
    defined beforehand is the primary key. In this section, we'll take a deeper look
    into the primary keys of the DynamoDB database engine. The main task of the primary
    key is to uniquely identify each item in a table so that no two items can have
    the same key.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，DynamoDB表项中唯一需要预先定义的部分是主键。在本节中，我们将更深入地了解DynamoDB数据库引擎的主键。主键的主要任务是唯一标识表中的每个项目，以便没有两个项目可以具有相同的键。
- en: 'DynamoDB supports two different kinds of primary keys:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB支持两种不同类型的主键：
- en: '**Partition key***:* This is a simple type of primary key. It is composed of
    one attribute known as the partition key. DynamoDB stores its data in multiple
    partitions. A partition is the storage layer for a DynamoDB table, backed by solid
    state hard drives. The partition key''s value is used as an input to an internal
    hash function, which generates an output that determines the partition in which
    the item will be stored.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区键**：这是一种简单类型的主键。它由一个称为分区键的属性组成。DynamoDB将数据存储在多个分区中。分区是DynamoDB表的存储层，由固态硬盘支持。分区键的值被用作内部哈希函数的输入，生成一个确定项目将被存储在哪个分区的输出。'
- en: '**Composite key***:* This type of key is composed of two attributes. The first
    attribute is the partition key which we discussed earlier, whereas the second
    attribute is what is known as the ''sort key''. If you utilize a composite key
    as your primary key, then more than one item can share the same partition key.
    Items with the same partition key are stored together. The sort key is then utilized
    to sort items with the same partition key. The sort key must be unique for each
    item.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合键**：这种类型的键由两个属性组成。第一个属性是我们之前讨论过的分区键，而第二个属性是所谓的''排序键''。如果您将复合键用作主键，那么多个项目可以共享相同的分区键。具有相同分区键的项目将被存储在一起。然后使用排序键对具有相同分区键的项目进行排序。排序键对于每个项目必须是唯一的。'
- en: Each primary key attribute must be a scalar, which means it can only hold a
    single value. There are three datatypes allowed for primary key attributes—a string,
    number, or binary.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主键属性必须是标量，这意味着它只能保存单个值。主键属性允许的三种数据类型是字符串、数字或二进制。
- en: Secondary indexes
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二级索引
- en: Primary keys in DynamoDB provide efficient and fast access to items in tables,
    when we query the items via their primary keys. However, there are a lot of scenarios
    where we may want to query items in tables via attributes other than the primary
    keys. DynamoDB allows us to create secondary indexes that target attributes different
    than primary key attributes. These indexes enable us to run efficient queries
    on nonprimary key items.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB中的主键为我们通过它们的主键快速高效地访问表中的项目提供了便利。然而，有很多情况下，我们可能希望通过除主键以外的属性查询表中的项目。DynamoDB允许我们创建针对非主键属性的二级索引。这些索引使我们能够在非主键项目上运行高效的查询。
- en: A secondary index is nothing more than a data structure that contains a subset
    of attributes from a table. A table is allowed to have multiple secondary indexes,
    which provides flexibility when querying data from tables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 二级索引只是包含来自表的属性子集的数据结构。表允许具有多个二级索引，这在查询表中的数据时提供了灵活性。
- en: 'In order to further understand secondary queries, we will need to cover some
    basic definitions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解二级查询，我们需要涵盖一些基本定义：
- en: '**Base Table**: Each and every secondary index belongs to exactly one table.
    The table from which the index is based and from where the index obtains its data
    is called the base table.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本表**：每个二级索引都属于一个表。索引所基于的表，以及索引获取数据的表，称为基本表。'
- en: '**Projected attributes***:* Project attributes are the attributes that get
    copied from the base table into the index. DynamoDB copies these attributes into
    the data structure of the index, along with the primary keys of the base table.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投影属性**：投影属性是从基本表复制到索引中的属性。DynamoDB将这些属性与基本表的主键一起复制到索引的数据结构中。'
- en: '**Global secondary index***:* An index with a partition key and a sort key
    that are different from those on the base table. This type of index is considered
    `global` because queries performed on that index can span all the data in the
    base table. You can create a global secondary index either at the same time you
    create a table or at a later time.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局二级索引**：具有与基本表不同的分区键和排序键的索引。这种类型的索引被认为是`全局`的，因为对该索引执行的查询可以跨越基本表中的所有数据。您可以在创建表时或以后创建全局二级索引。'
- en: '**Local secondary index***:* An index with the same partition key as the base
    table, but a different sort key. This type of index is `local` because every partition
    of a local secondary index is associated with the base table partition that has
    the same partition key value. You can only create a local secondary index at the
    same time when you create a table.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地二级索引**：一个具有与基本表相同的分区键，但不同排序键的索引。这种类型的索引是`本地`的，因为本地二级索引的每个分区都与具有相同分区键值的基本表分区相关联。您只能在创建表时同时创建本地二级索引。'
- en: Creating tables
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表
- en: 'Let''s make use of the AWS web console to create DynamoDB tables that we can
    then access later in our code. The first step is to visit the AWS management console
    main dashboard, then click on DynamoDB:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用AWS Web控制台创建DynamoDB表，然后我们可以在代码中访问这些表。第一步是访问AWS管理控制台主仪表板，然后点击DynamoDB：
- en: '![](img/bbf657e8-3fd0-422b-bce5-0a885e5138d7.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbf657e8-3fd0-422b-bce5-0a885e5138d7.png)'
- en: 'After clicking on DynamoDB, we will move to the DynamoDB main dashboard, where
    we can create a new table:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 点击DynamoDB后，我们将转到DynamoDB主仪表板，在那里我们可以创建一个新表：
- en: '![](img/198c41bb-7bec-468e-bd0b-503c805615c7.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/198c41bb-7bec-468e-bd0b-503c805615c7.png)'
- en: 'The next step is to pick the table name and the primary keys. As we mentioned
    earlier, the primary key in DynamoDB can consist of up to two attributes—the partition
    key and the sort key. Let''s say we are creating a table called `events`. Let''s
    use a simple primary key that consists only of a partition key called `ID` that
    is of the `Binary` type:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是选择表名和主键。正如我们之前提到的，DynamoDB中的主键可以由最多两个属性组成——分区键和排序键。假设我们正在创建一个名为`events`的表。让我们使用一个简单的主键，它只包含一个名为`ID`的`Binary`类型的分区键：
- en: '![](img/ca49341a-0bd3-45b7-8476-66525e3d9459.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca49341a-0bd3-45b7-8476-66525e3d9459.png)'
- en: 'We will also leave the default settings. We will revisit some of those settings
    such as secondary indexes later. After we are done with the configuration, we
    will need to click on Create to create the table. We will then repeat the process
    with all other tables that we would like to create:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也将保留默认设置。稍后我们将重新访问一些设置，比如次要索引。配置完成后，我们需要点击创建来创建表格。然后我们将重复这个过程，创建所有其他我们想要创建的表格：
- en: '![](img/480544e0-799f-4345-becd-7df929b5a06f.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/480544e0-799f-4345-becd-7df929b5a06f.png)'
- en: 'Once a table is created, we can now connect to it, edit it, and read from it
    through our code. However, before we start discussing code, we will need to create
    a secondary index. To do that, we will need to first visit our newly created table
    by selecting the Tables option on the left-hand side. We will then select the
    `events` table from tables list. Afterward, we will need to pick the Indexes tab,
    then click on Create Index to create a new secondary index:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦表格创建完成，我们现在可以通过我们的代码连接到它，编辑它，并从中读取。但是，在我们开始讨论代码之前，我们需要创建一个次要索引。为此，我们需要首先访问我们新创建的表格，选择左侧的Tables选项。然后，我们将从表格列表中选择`events`表。之后，我们需要选择Indexes选项卡，然后点击Create
    Index来创建一个新的次要索引：
- en: '![](img/46bf125c-75b5-4d92-9907-664ff938dc5c.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46bf125c-75b5-4d92-9907-664ff938dc5c.png)'
- en: 'The secondary index name needs to be the attribute name from our table that
    we would like to use as our secondary index. In our case, the attribute that we
    would like to use for queries is the event name. This attribute represents the
    index that we need in order to run an efficient query when querying for events
    by their names instead of their IDs. Here is what the Create index dialog looks
    like; let''s fill the different fields, then click on Create Index:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 次要索引名称需要是我们表格中希望用作次要索引的属性名称。在我们的情况下，我们希望用于查询的属性是事件名称。这个属性代表了我们需要的索引，以便在查询事件时通过它们的名称而不是它们的ID来运行高效的查询。创建索引对话框如下所示；让我们填写不同的字段，然后点击创建索引：
- en: '![](img/c1356996-0d2d-423e-9014-bbd34892db27.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1356996-0d2d-423e-9014-bbd34892db27.png)'
- en: Perfect! With this step, we now have our table ready for our code. Note that
    in the screenshot above how the index name is `EventName-index`. We will utilize
    that name later in our Go code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！通过这一步，我们现在已经准备好我们的表格了。请注意上面的屏幕截图中索引名称为`EventName-index`。我们将在后面的Go代码中使用该名称。
- en: The Go language and DynamoDB
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go语言和DynamoDB
- en: Amazon has provided the Go language with powerful packages that we can utilize
    to build applications that can efficiently interact with DynamoDB. The main package
    can be found at [https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/](https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/)
    .
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊已经为Go语言提供了强大的包，我们可以利用它们来构建可以有效地与DynamoDB交互的应用程序。主要包可以在[https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/](https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/)找到。
- en: 'Before we start diving into the code, let''s take a refresher on the `DatabaseHandler`
    interface we discussed in [Chapter 2](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml),
    *Building Microservices Using Rest APIs*. This interface represents the database
    handler layer of our microservices, which is where the database access code lives.
    In case of the `events` service, this interface supported  four methods. Here
    is what it looked like:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入代码之前，让我们回顾一下我们在[第2章](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml)中讨论的`DatabaseHandler`接口，*使用Rest
    API构建微服务*。这个接口代表了我们的微服务的数据库处理程序层，也就是数据库访问代码所在的地方。在`events`服务的情况下，这个接口支持了四种方法。它看起来是这样的：
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In our quest to gain a practical understanding on how to write applications
    that can work with DynamoDB, we will implement the preceding four methods to utilize
    DynamoDB as the backend database.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们努力实现如何编写可以与DynamoDB一起工作的应用程序的实际理解的过程中，我们将实现前面的四种方法来利用DynamoDB作为后端数据库。
- en: 'Similar to other AWS services, the AWS Go SDK provides a service client object
    that we can use to interact with DynamoDB. Also, similar to other AWS services,
    we will need to obtain a session object first, then use it to create a DynamoDB
    service client object. Here is what that code should look like:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他AWS服务类似，AWS Go SDK提供了一个服务客户端对象，我们可以用它来与DynamoDB交互。同样，我们需要首先获取一个会话对象，然后使用它来创建一个DynamoDB服务客户端对象。代码应该是这样的：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`dynamodbsvc` ends up being our service client object, which we can then use
    to interact with DynamoDB.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamodbsvc`最终成为我们的服务客户端对象，我们可以用它来与DynamoDB交互。'
- en: 'Now, we will need to create a new file called dynamolayer.go, which will exist
    under the relative folder `./lib/persistence/dynamolayer`, which is under our
    application:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个名为dynamolayer.go的新文件，它将存在于相对文件夹`./lib/persistence/dynamolayer`下，这是我们应用程序的一部分：
- en: '![](img/f489a243-776b-4e69-bfef-7f9e3020517a.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f489a243-776b-4e69-bfef-7f9e3020517a.png)'
- en: 'The `dynamolayer.go` file is where our code will live. The first step we will
    need to follow in order to implement the `databasehandler` interface is to create
    a `struct` type, which will implement the interface methods. Let''s call the new
    type `DynamoDBLayer`; here is what the code will look like:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamolayer.go`文件是我们的代码所在的地方。为了实现`databasehandler`接口，我们需要遵循的第一步是创建一个`struct`类型，它将实现接口方法。让我们称这个新类型为`DynamoDBLayer`；代码如下：'
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `DynamoDBLayer` struct contains one field of type `*dynamodb.DynamoDB`;
    this struct field represents the AWS service client for DynamoDB, which is the
    key object type we'll use in our code to interact with DynamoDB.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`DynamoDBLayer`结构包含一个类型为`*dynamodb.DynamoDB`的字段；这个结构字段表示DynamoDB的AWS服务客户端，这是我们在代码中与DynamoDB交互的关键对象类型。'
- en: 'The next step is to write some constructors to initialize the `DynamoDBLayer`
    struct. We will create two constructors—the first constructor assumes that we
    don''t have an existing AWS session object to use in our code. It will take a
    single string argument, which represents our AWS region (for example, `us-west-1`).
    It will then utilize the region string to create a session object targeting that
    region. Afterward, the session object will be used to create a DynamoDB service
    client object, which can be assigned to a new `DynamoDBLayer` object. Here is
    what the first constructor will look like:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编写一些构造函数来初始化`DynamoDBLayer`结构。我们将创建两个构造函数——第一个构造函数假设我们没有现有的AWS会话对象可用于我们的代码。它将接受一个字符串参数，表示我们的AWS区域（例如，`us-west-1`）。然后，它将利用该区域字符串创建一个针对该区域的会话对象。之后，会话对象将用于创建一个DynamoDB服务客户端对象，该对象可以分配给一个新的`DynamoDBLayer`对象。第一个构造函数将如下所示：
- en: '[PRE24]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second constructor is the one we would use if we already had an existing
    AWS session object. It takes the session object as an argument, then use it to
    create a new DynamoDB service client, which we can assign to a new `DynamoDBLayer`
    object. Here is what the code will look like:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数是我们在已经有现有的AWS会话对象时会使用的构造函数。它接受会话对象作为参数，然后使用它创建一个新的DynamoDB服务客户端，我们可以将其分配给一个新的`DynamoDBLayer`对象。代码将如下所示：
- en: '[PRE25]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Perfect! Now, with the constructors out of the way, let's implement the `DatabaseHandler`
    interface methods.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，构造函数已经完成，让我们实现`DatabaseHandler`接口方法。
- en: 'Before we continue writing our code, we will need to first cover two important
    concepts:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续编写代码之前，我们需要先介绍两个重要的概念：
- en: '`*dynamoDB.AttributeValue`: This is a struct type that lives inside the dynamodb
    Go package. It represents a DynamoDB item attribute value.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*dynamoDB.AttributeValue`：这是一个结构类型，位于dynamodb Go包内。它表示DynamoDB项目属性值。'
- en: '`dynamodbattribute`: This is a subpackage that falls underneath the dynamodb
    package. The docs for this package can be found at:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamodbattribute`：这是一个位于dynamodb包下的子包。该包的文档可以在以下位置找到：'
- en: '`https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/dynamodbattribute/`.
    The package is responsible for converting between Go types and `dynamoDB.AttributeValues.`
    This provides a very convenient way to convert Go types inside our application
    into types that can be understood by the dynamoDB package methods, and vice versa.
    `dynamodbattribute` can convert slices, maps, structs, and even scalar values
    to and from `dynamoDB.AttributeValues` by utilizing marshal and unmarshal methods.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/dynamodbattribute/`。该包负责在Go应用程序内部将Go类型与`dynamoDB.AttributeValues`之间进行转换。这提供了一种非常方便的方式，将我们应用程序内部的Go类型转换为可以被dynamoDB包方法理解的类型，反之亦然。`dynamodbattribute`可以利用marshal和unmarshal方法将切片、映射、结构甚至标量值转换为`dynamoDB.AttributeValues`。'
- en: We will be utilizing the power of the `dynamoDB.AttributeValue` type as well
    as the `dynamodbattribute` package from now on to write code capable of working
    with DynamoDB.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从现在开始利用`dynamoDB.AttributeValue`类型的强大功能，以及`dynamodbattribute`包来编写能够与DynamoDB一起工作的代码。
- en: 'The first `DatabaseHandler` interface method that we will cover is the `AddEvent()`
    method. This method takes an argument of the `Event` type, and then adds it as
    an item into the events table in the database. Before we start covering the method''s
    code, we will need to first understand the AWS SDK components that we''ll need
    to utilize:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的第一个`DatabaseHandler`接口方法是`AddEvent()`方法。该方法接受一个`Event`类型的参数，然后将其作为一个项目添加到数据库中的事件表中。在我们开始介绍方法的代码之前，我们需要先了解一下我们需要利用的AWS
    SDK组件：
- en: '`AddEvent()` will need to make use of an AWS SDK method called `PutItem()`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddEvent()`将需要使用AWS SDK方法`PutItem()`'
- en: The `PutItem()` method takes an argument of the PutItemInput type
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PutItem()`方法接受一个`PutItemInput`类型的参数'
- en: '`PutItemInput` needs two pieces of information to serve our purposes—the table
    name, and the item that we would like to add'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PutItemInput`需要两个信息来满足我们的目的——表名和我们想要添加的项目'
- en: The table name field of the `PutItemInput` type is of the *string type, whereas
    the item is of the `map[string]*AttributeValue` type
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PutItemInput`类型的表名字段是*string类型，而项目是`map[string]*AttributeValue`类型'
- en: In order to convert our Go type Event into `map[string]*AttributeValue`, which
    as per the preceding point is the item field type we will need for `PutItemInput`,
    we can utilize a method called `dynamodbattribute.MarshalMap()`
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将我们的Go类型Event转换为`map[string]*AttributeValue`，根据前面的观点，这是我们需要为`PutItemInput`使用的项目字段类型，我们可以利用一个名为`dynamodbattribute.MarshalMap()`的方法
- en: 'There is one more important remark we will need to cover; the following is
    what our `Event` type looks like:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重要的备注我们需要介绍；以下是我们的`Event`类型的样子：
- en: '[PRE26]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It contains all the key information we typically need to describe an event
    such as a concert. However, when working with DynamoDB, there is one issue with
    the `Event` type—the keyword `Name` is a reserved keyword in the DynamoDB world.
    This means that if we leave the struct like this, we won''t be able to use the
    `Name` field of the Event struct in our queries. Fortunately, the `dynamodbattribute`
    package supports a struct tag called `dynamodbav`, which allows us to mask the
    struct field name with another name. This will allow us to use the struct field
    Name in our Go code, but have it exposed as a different name to DynamoDB. The
    following is what the code will look like after adding the struct field:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含了通常需要描述诸如音乐会之类的事件的所有关键信息。然而，在使用DynamoDB时，`Event`类型有一个问题——在DynamoDB世界中，关键字`Name`是一个保留关键字。这意味着如果我们保留结构体不变，我们将无法在查询中使用Event结构体的Name字段。幸运的是，`dynamodbattribute`包支持一个名为`dynamodbav`的结构标签，它允许我们用另一个名称掩盖结构字段名。这将允许我们在Go代码中使用结构字段Name，但在DynamoDB中以不同的名称公开它。添加结构字段后，代码将如下所示：
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we utilized the `dynamodbav` struct tag to define the
    `Name` struct field as `EventName` when interfacing with DynamoDB.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们利用了`dynamodbav`结构标签，将`Name`结构字段定义为与DynamoDB交互时的`EventName`。
- en: 'Perfect! Now, let''s look at the `AddEvent()` method code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，让我们看一下`AddEvent()`方法的代码：
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first step in the preceding code was to marshal the event object to `map[string]*AttributeValue`.
    The next step was to call the `PutItem()` method, which belongs to the DynamoDB
    service client. `PutItem` took an argument of the `PutItemInput` type as discussed
    earlier, which contained the table name and the marshaled item data that we would
    like to add. At the end, if no errors occur, we will return a byte representation
    of the event ID.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的第一步是将事件对象编组为`map[string]*AttributeValue`。接下来是调用属于DynamoDB服务客户端的`PutItem()`方法。`PutItem`接受了前面讨论过的`PutItemInput`类型的参数，其中包含了我们想要添加的表名和编组的项目数据。最后，如果没有错误发生，我们将返回事件ID的字节表示。
- en: 'The next `DatabaseHandler` interface method that we will need to discuss is
    `FindEvent()`. This method retrieves an event via its ID. Remember here that when
    we created the `events`  table, we set the ID attribute as its key. Here are some
    points we will need to cover to understand the incoming piece of code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要讨论的下一个`DatabaseHandler`接口方法是`FindEvent()`。该方法通过其ID检索事件。请记住，当我们创建`events`表时，我们将ID属性设置为其键。以下是我们需要了解的一些要点，以了解即将到来的代码：
- en: '`FindEvent()` utilizes an AWS SDK method called `GetItem()`.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindEvent()`利用了一个名为`GetItem()`的AWS SDK方法。'
- en: '`FindEvent()` takes an argument of the `GetItemInput` type.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindEvent()`接受`GetItemInput`类型的参数。'
- en: 'The `GetItemInput` type needs two pieces of information: the table name and
    the value of the item key.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetItemInput`类型需要两个信息：表名和项目键的值。'
- en: The `GetItem()` method returns a struct type called `GetItemOutput`, which has
    a field called `Item`. The `Item` field is where our retrieved database table
    item will be hosted.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetItem()`方法返回一个名为`GetItemOutput`的结构类型，其中有一个名为`Item`的字段。`Item`字段是我们检索的数据库表项目所在的位置。'
- en: The item obtained from the database will be represented with the `map[string]*AttributeValue`
    type. We can then make use of the `dynamodbattribute.UnmarshalMap()` function
    to convert it to an `Event` type.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中获取的项目将以`map[string]*AttributeValue`类型表示。然后，我们可以利用`dynamodbattribute.UnmarshalMap()`函数将其转换为`Event`类型。
- en: 'Here is what the code will look like at the end:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 代码最终将如下所示：
- en: '[PRE29]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note in the preceding code that the `Key` field of the `GetItemInput` struct
    was of the `map[string]*AttributeValue` type. The key to this map is the attribute
    name, which is `ID` in our case, whereas the value of this map is of the `*AttributeValue` type and
    is as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码中，`GetItemInput`结构体的`Key`字段是`map[string]*AttributeValue`类型。该映射的键是属性名称，在我们的情况下是`ID`，而该映射的值是`*AttributeValue`类型，如下所示：
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `B` in the preceding code is a struct field in `AttributeValue`, which represents
    a binary type, whereas `id` is simply the byte slice argument that got passed
    to our `FindEvent()` method.  The reason why we used the binary type field is
    because our ID key attribute of the events table was of type binary.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的`B`是`AttributeValue`中的一个结构字段，表示二进制类型，而`id`只是传递给我们的`FindEvent()`方法的字节片参数。我们使用二进制类型字段的原因是因为我们的事件表的ID键属性是二进制类型。
- en: 'Let''s now move to the third `DatabaseHandler` interface method for the events
    microservice, which is the `FindEventByName()` method. This method retrieves an
    event via its name. Remember that when we created the `events` table earlier,
    we set the `EventName` attribute as the secondary index. The reason why we did
    that is because we wanted the ability to query items from the `events` table via
    the event names. Again, before we start covering the code, here is what we need
    to know about the method:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到事件微服务的第三个`DatabaseHandler`接口方法，即`FindEventByName()`方法。该方法通过名称检索事件。请记住，当我们之前创建`events`表时，我们将`EventName`属性设置为二级索引。我们这样做的原因是因为我们希望能够通过事件名称从`events`表中查询项目。在我们开始讨论代码之前，这是我们需要了解的关于该方法的信息：
- en: '`FindEventByName()` utilizes an AWS SDK method called `Query()` in order to
    query the database.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindEventByName()`利用了一个名为`Query()`的AWS SDK方法来查询数据库。'
- en: 'The `Query()` method takes an argument of the `QueryInput` type, which needs
    four pieces of information:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Query()`方法接受`QueryInput`类型的参数，其中需要四个信息：'
- en: The query that we would like to execute, in our case, the query is simply `EventName
    = :n`.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望执行的查询，在我们的情况下，查询只是`EventName = :n`。
- en: The  value of `:n` in the above expression. This is a parameter that we will
    need to fill with the name of the event we are trying to find.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述表达式中`:n`的值。这是一个参数，我们需要用要查找的事件的名称来填充它。
- en: The index name that we would like to utilize for our query. In our case, the
    secondary index we created for the EventName attribute was called `EventName-index`
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要为我们的查询使用的索引名称。在我们的情况下，我们为EventName属性创建的二级索引被称为`EventName-index`。
- en: The table name where we would like to run the query.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要运行查询的表名。
- en: If the `Query()` method succeeds, we get our result items as slice of maps;
    the result items will be of the `[]map[string]*AttributeValue` type. Since we
    only seek a single item, we can just retrieve the first item of that map slice.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Query()`方法成功，我们将得到我们的结果项作为map切片；结果项将是`[]map[string]*AttributeValue`类型。由于我们只寻找单个项目，我们可以直接检索该地图切片的第一个项目。
- en: The `Query()` method returns an object of the type `QueryOutput` struct, which
    contains a field called `Items`. The `Items` field is where our query result set
    will be hosted.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Query()`方法返回一个`QueryOutput`结构类型的对象，其中包含一个名为`Items`的字段。`Items`字段是我们的查询结果集所在的地方。'
- en: We then will need to utilize the `dynamodbattribute.UnmarshalMap()` function
    in order to convert the item of the `map[string]*AttributeValue` type into an
    `Event` type.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们需要利用`dynamodbattribute.UnmarshalMap()`函数将`map[string]*AttributeValue`类型的项目转换为`Event`类型。
- en: 'Here is what the code will look like:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下所示：
- en: '[PRE31]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Queries in DynamoDB is an important topic. I recommend that you read the AWS
    docs explaining queries, which can be found at [http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html)
    to properly understand how queries work in DynamoDB.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB中的查询是一个重要的主题。我建议您阅读AWS文档，解释查询的工作原理，可以在[http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html)找到。
- en: 'The last `DatabaseHandler` interface method we will discuss in this chapter
    is the `FindAllAvailableEvents()` method. This method retrieves all the items
    of the ''events'' table in DynamoDB. Here is what we need to know before diving
    into the code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章讨论的最后一个`DatabaseHandler`接口方法是`FindAllAvailableEvents()`方法。这个方法检索DynamoDB中'events'表的所有项目。在深入代码之前，我们需要了解以下内容：
- en: '`FindAllAvailableEvents()` needs to utilize an AWS SDK method called `Scan()`.
    This method performs a scan operation. A scan operation can be simply defined
    as a read that goes through every single item in a table or in a secondary index.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindAllAvailableEvents()`需要利用一个名为`Scan()`的AWS SDK方法。这个方法执行扫描操作。扫描操作可以简单地定义为遍历表中的每个项目或者二级索引中的每个项目的读取操作。'
- en: The `Scan()` method requires an argument of the type `ScanInput` struct.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scan()`方法需要一个`ScanInput`结构类型的参数。'
- en: The `ScanInput` type needs to know the table name in order to perform the scan
    operation.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScanInput`类型需要知道表名才能执行扫描操作。'
- en: The `Scan()` method returns an object of the `ScanOutput` struct type. The `ScanOutput`
    struct contains a field called `Items` of the `[]map[string]*AttributeValue` type.
    This is where the results of the scan operation will go.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scan()`方法返回一个`ScanOutput`结构类型的对象。`ScanOutput`结构包含一个名为`Items`的字段，类型为`[]map[string]*AttributeValue`。这就是扫描操作的结果所在的地方。'
- en: The `Items` struct field can be converted to a slice of `Event` types via the
    `dynamodbattribute.UnmarshalListofMaps()` function.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Items`结构字段可以通过`dynamodbattribute.UnmarshalListofMaps()`函数转换为`Event`类型的切片。'
- en: 'The code looks as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下所示：
- en: '[PRE32]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: One important remark to mention about scan operations is that since in a production
    environment, a scan operation can return a massive number of results, it is sometimes
    advised to utilize the pagination feature of the AWS SDK that we mentioned in
    the preceding chapter with the scans. The pagination feature allows the results
    of your operations to come in multiple pages, which you can then iterate through.
    Scan pagination can be performed via the `ScanPages()` method.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 关于扫描操作的一个重要说明是，由于在生产环境中，扫描操作可能返回大量结果，有时建议利用我们在前一章中提到的AWS SDK的分页功能来进行扫描。分页功能允许您的操作结果分页显示，然后您可以进行迭代。扫描分页可以通过`ScanPages()`方法执行。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a practical dive into some of the most popular services
    in the AWS world. By now, we have covered enough knowledge to build production-level
    Go applications that are capable of utilizing some of the key features that AWS
    provides for cloud native applications.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了AWS世界中一些最受欢迎的服务。到目前为止，我们已经掌握了足够的知识，可以构建能够利用AWS为云原生应用程序提供的一些关键功能的生产级Go应用程序。
- en: In the next chapter, we'll take another step to learn more about building Go
    cloud native applications by covering the topic of continuous delivery.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步学习构建Go云原生应用程序的知识，涵盖持续交付的主题。
