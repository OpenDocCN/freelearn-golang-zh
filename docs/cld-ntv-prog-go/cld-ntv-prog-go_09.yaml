- en: Continuous Delivery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付
- en: In the previous three chapters, you learned about modern container technologies
    and cloud environments, how to create container images from your application (or,
    more precisely, the MyEvents application), and how to deploy them into these environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的三章中，您了解了现代容器技术和云环境，如何从您的应用程序（或更准确地说，MyEvents应用程序）创建容器映像，以及如何将它们部署到这些环境中。
- en: In this chapter, you will learn how to adopt **continuous integration** (**CI**)
    and **continuous delivery** (**CD**) for anjhalocvhurty your application. CI describes
    a practice in which you continuously build and verify your software project (ideally,
    on each and every change made to your software). CD extends this approach by also
    continually deploying your application in very short release cycles (in this case,
    of course, into a cloud environment).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何为您的应用程序采用**持续集成**（**CI**）和**持续交付**（**CD**）。CI描述了一种实践，即您持续构建和验证您的软件项目（理想情况下，对软件的每一次更改都进行构建和验证）。CD通过在非常短的发布周期内（在这种情况下，当然是进入云环境）不断部署您的应用程序来扩展这种方法。
- en: Both of these approaches require a high degree of automation to work reliably,
    both concerning your application's build and deployment processes. In previous
    chapters, we have already looked at how you can use container technologies to
    deploy your application. Since technologies such as Docker and Kubernetes are
    easily automated, they usually integrate very well with CD.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都需要高度自动化才能可靠地工作，涉及到应用程序的构建和部署过程。在之前的章节中，我们已经看过您如何使用容器技术部署您的应用程序。由于Docker和Kubernetes等技术很容易自动化，它们通常与CD非常好地集成。
- en: In the course of this chapter, you will learn how to set up your project for
    adopting CI and CD (for example, by setting up proper version control and dependency
    management). We will also introduce a few popular tools that you can use to trigger
    new builds and releases automatically whenever your application's code changes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，您将学习如何为采用CI和CD设置您的项目（例如，通过设置适当的版本控制和依赖管理）。我们还将介绍一些流行的工具，您可以使用这些工具在应用程序代码更改时自动触发新的构建和发布。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Managing a Go project in version control
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在版本控制中管理Go项目
- en: Using dependency vendoring for reproducible builds
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖捆绑进行可重复构建
- en: Using Travis CI and/or GitLab to automatically build your application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Travis CI和/或GitLab自动构建您的应用程序
- en: Automatically deploying your application to a Kubernetes cluster
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动将您的应用程序部署到Kubernetes集群
- en: Setting up your project
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的项目
- en: Before actually implementing continuous delivery for our project, let's start
    by making some preparations. Later, these will make it easier for the tools that
    we will use to easily build and deploy your application in an automated way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际为我们的项目实施持续交付之前，让我们先做一些准备工作。稍后，这些准备工作将使我们将要使用的工具更容易地以自动化的方式构建和部署您的应用程序。
- en: Setting up version control
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置版本控制
- en: Before automatically building your application, you will need a place to store
    your application's source code. This is typically the job of a **version control
    system** (**VCS**). Often, the tools that enable you to do continuous delivery
    are tightly integrated with version control systems, for example, by triggering
    a new build and deployment of your application whenever the source code is changed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动构建您的应用程序之前，您需要一个存储应用程序源代码的地方。这通常是**版本控制系统**（**VCS**）的工作。通常情况下，使您能够进行持续交付的工具与版本控制系统紧密集成，例如，通过在源代码更改时触发应用程序的新构建和部署。
- en: If you did not do this already on your own, your first step should now be to
    put your existing code base into a VCS. In this example, we will be working with
    the current de facto standard VCS, Git. Although there are many other version
    control systems, Git is the most widely adopted; you will find many providers
    and tools that offer you Git repositories as a managed service or for self-hosting.
    Also, many (if not most) CD tools are integrated with Git.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有自己做过这个，那么您现在的第一步应该是将您现有的代码库放入VCS中。在本例中，我们将使用当前事实上的标准VCS，即Git。尽管还有许多其他版本控制系统，但Git是最广泛采用的；您会发现许多提供商和工具为您提供Git存储库作为托管服务或自托管。此外，许多（如果不是大多数）CD工具都与Git集成。
- en: 'For the remainder of this chapter, we will assume that you are familiar with
    the basic workings of Git. If you wish to read up on how to work with Git, we
    recommend the book *Git: Mastering Version Control* by *Ferdinando Santacroce
    et al.*, also published by Packt.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章的其余部分，我们将假设您熟悉Git的基本工作原理。如果您希望了解如何使用Git，我们推荐Packt出版的*Git: Mastering Version
    Control*一书，作者是*Ferdinando Santacroce等人*。'
- en: 'We will also assume that you have two remote Git repositories available where
    you can push your Go application source code and the frontend application source
    code. For the first continuous delivery tool that we will be working with, we
    will assume that your repositories are hosted at GitHub at the following URLs:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设您有两个远程Git存储库可用，您可以将Go应用程序源代码和前端应用程序源代码推送到这些存储库。对于我们将要使用的第一个持续交付工具，我们将假设您的存储库托管在GitHub的以下URL：
- en: '`git+ssh://git@github.com/<user>/myevents.git`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git+ssh://git@github.com/<user>/myevents.git`'
- en: '`git+ssh://git@github.com/<user>/myevents-frontend.git`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git+ssh://git@github.com/<user>/myevents-frontend.git`'
- en: Of course, the actual repository URLs will vary according to your username.
    In the following examples, we will use `<user>` consistently as a placeholder
    for your GitHub username, so remember to replace it with your actual username
    whenever necessary.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，实际的存储库URL将根据您的用户名而变化。在以下示例中，我们将始终使用`<user>`作为您的GitHub用户名的占位符，因此请记住在必要时用您的实际用户名替换它。
- en: 'You can start by setting up a local Git repository to track changes to your
    source code on your local machine. To initialize a new Git repository, run the
    following command in your Go project''s root directory (typically, `todo.com/myevents`
    in your GOPATH directory):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在本地机器上设置一个本地的Git仓库来跟踪源代码的更改。要初始化一个新的Git仓库，请在Go项目的根目录中运行以下命令（通常在GOPATH目录中的`todo.com/myevents`）：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will set up a new Git repository, but not add any files to version control,
    yet. Before actually adding any files to your repository, configure a `.gitignore`
    file that prevents Git from adding your compiled files to version control:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置一个新的Git存储库，但尚未将任何文件添加到版本控制中。在实际将任何文件添加到存储库之前，请配置一个`.gitignore`文件，以防止Git将您的编译文件添加到版本控制中：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After having created the `.gitignore` file, run the following commands to add
    your current code base to the version control system:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`.gitignore`文件后，运行以下命令将当前代码库添加到版本控制系统中：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, configure your remote repository using the `git remote` command and push
    your source code using `git push`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`git remote`命令配置远程存储库，并使用`git push`推送您的源代码：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Having a working source code repository is the first step to building a continuous
    integration/delivery pipeline. In the following steps, we will configure CI/CD
    tools to build and deploy your application whenever you push new code into the
    master branch of your remote Git repository.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个可工作的源代码存储库是构建持续集成/交付流水线的第一步。在接下来的步骤中，我们将配置CI/CD工具，以便在您将新代码推送到远程Git存储库的主分支时构建和部署您的应用程序。
- en: Use the same Git commands to create a new Git repository for your frontend application,
    and to push it to a remote repository on GitHub.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的Git命令为您的前端应用程序创建一个新的Git存储库，并将其推送到GitHub上的远程存储库。
- en: Vendoring your dependencies
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的依赖项放入vendor中
- en: Up until now, we have simply installed Go libraries that we needed for the MyEvents
    application (such as the `gopkg.in/mgo.v2` or the `github.com/gorilla/mux` packages)
    using the `go get` command. Although this works reasonably well for development,
    installing dependencies using `go get` has one significant disadvantage, that
    is, each time you run `go get` on a package that has not yet been downloaded,
    it will get the most recent version of that library (technically, the latest *master*
    branch of the respective source code repository). This can have nasty consequences;
    imagine that you have cloned your repository at one point in time and installed
    all dependencies using `go get ./...`. A week later, you repeat these steps, but
    may now wind up with completely different versions of your dependencies (libraries
    that are actively maintained and developed may get dozens of new commits to its
    master branch each day). This is especially critical if one of these changes changed
    the libraries' API, which may result in your code not compiling anymore from one
    day to the next.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是使用`go get`命令安装了MyEvents应用程序所需的Go库（例如`gopkg.in/mgo.v2`或`github.com/gorilla/mux`包）。尽管这对开发来说效果还不错，但使用`go
    get`安装依赖有一个显著的缺点，即每次在尚未下载的包上运行`go get`时，它将获取该库的最新版本（从技术上讲，是相应源代码库的最新*master*分支）。这可能会产生不好的后果；想象一下，您在某个时间点克隆了您的存储库，并使用`go
    get ./...`安装了所有依赖项。一周后，您重复这些步骤，但现在可能会得到完全不同版本的依赖项（积极维护和开发的库可能每天都会有数十个新的提交到其主分支）。如果其中一个更改改变了库的API，这可能导致您的代码从一天到另一天无法再编译。
- en: To solve this issue, Go 1.6 introduced the concept of **vendoring**. Using vendoring
    allows you to copy libraries that your project requires into a `vendor/` directory
    within your package (so, in our case, `todo.com/myevents/vendor/` will contain
    directories such as `todo.com/myevents/vendor/github.com/gorilla/mux/`). When
    running `go build` to compile a package, libraries from the `vendor/` directory
    will be favored over libraries in your GOPATH. You can then simply put the `vendor/`
    directory into version control alongside your application code and have reproducible
    builds when cloning your source code repository.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Go 1.6引入了**vendoring**的概念。使用vendoring允许您将项目所需的库复制到包内的`vendor/`目录中（因此，在我们的情况下，`todo.com/myevents/vendor/`将包含诸如`todo.com/myevents/vendor/github.com/gorilla/mux/`的目录）。在运行`go
    build`编译包时，`vendor/`目录中的库将优先于GOPATH中的库。然后，您可以简单地将`vendor/`目录与应用程序代码一起放入版本控制，并在克隆源代码存储库时进行可重复的构建。
- en: Of course, manually copying libraries into your package's `vendor/` directory
    quickly becomes tedious. Typically, this work is being done by **dependency managers**.
    Currently, there are multiple dependency managers for Go, the most popular being
    **Godep** and **Glide**. These are both community projects; an official dependency
    manager, simply called **dep**, is currently in development and already considered
    safe for production use, but was, at the time of writing this book, still designated
    as an experiment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，手动将库复制到包的`vendor/`目录中很快就变得乏味。通常，这项工作是由**依赖管理器**完成的。目前，Go有多个依赖管理器，最流行的是**Godep**和**Glide**。这两者都是社区项目；一个官方的依赖管理器，简称为**dep**，目前正在开发中，并且已经被认为是安全的用于生产，但在撰写本书时，仍被指定为实验。
- en: You can find more information on dep at [https://github.com/golang/dep](https://github.com/golang/dep).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/golang/dep](https://github.com/golang/dep)找到有关dep的更多信息。
- en: 'In this case, we will populate our application''s `vendor/` directory using
    Glide. First of all, install Glide by running the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用Glide填充我们应用程序的`vendor/`目录。首先，通过运行以下命令安装Glide：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will place a glide executable in your `$GOPATH/bin` directory. If you
    want to use glide globally, you can copy it from there into your path as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的`$GOPATH/bin`目录中放置一个glide可执行文件。如果您想要全局使用glide，可以将它从那里复制到您的路径中，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Glide works similar to package managers that you might know from other programming
    languages (for example, npm for Node.js or Compose for PHP). It operates by reading
    a `glide.yaml` file from your package directory. In this file, you declare all
    dependencies that your application has and can optionally provide specific versions
    of these libraries that Glide should install for you. To create a `glide.yaml`
    file from an existing application, run the `glide init .` command in your package
    directory:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Glide 的工作方式类似于您可能从其他编程语言中了解的包管理器（例如，Node.js 的 npm 或 PHP 的 Compose）。它通过从包目录中读取
    `glide.yaml` 文件来操作。在此文件中，您声明应用程序的所有依赖项，并可以选择为 Glide 安装这些库提供特定版本。要从现有应用程序创建 `glide.yaml`
    文件，请在包目录中运行 `glide init .` 命令：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While initializing your project, Glide will inspect the libraries used by your
    application and try to automatically optimize your dependency declaration. For
    example, if Glide finds a library that provides stable versions (usually, Git
    tags), it will prompt you whether you would prefer using the latest of these stable
    versions instead of the (potentially more unstable) master branch of a dependency.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化项目时，Glide 将检查应用程序使用的库，并尝试自动优化您的依赖声明。例如，如果 Glide 发现一个提供稳定版本（通常是 Git 标签）的库，它将提示您是否希望使用这些稳定版本的最新版本，而不是依赖项的（可能更不稳定）主分支。
- en: 'When running `glide init`, it will produce an output similar to this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `glide init` 时，它将产生类似于此的输出：
- en: '![](img/d741911d-8bef-4db2-bcc7-34bad737e478.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d741911d-8bef-4db2-bcc7-34bad737e478.png)'
- en: 'The `glide init` command will create a `glide.yaml` file in your application''s
    root directory in which all required dependencies are declared. For the MyEvents
    application, this file should look similar to this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`glide init` 命令将在应用程序的根目录中创建一个 `glide.yaml` 文件，其中声明了所有必需的依赖项。对于 MyEvents 应用程序，此文件应该类似于这样：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `glide.yaml` file declares which dependencies your project requires. After
    creating this file, you can run the `glide update` command to actually resolve
    the declared dependencies and download them into your `vendor/` directory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`glide.yaml` 文件声明了您的项目需要哪些依赖项。创建此文件后，您可以运行 `glide update` 命令来实际解析声明的依赖项并将它们下载到您的
    `vendor/` 目录中。'
- en: 'As you can see in the preceding screenshot, `glide update` will not only download
    the dependencies declared in your `glide.yaml` file into the `vendor/` directory,
    but also their dependencies. In the end, Glide will recursively download the entire
    dependency tree of your application and place it in the `vendor/` directory:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，`glide update` 不仅会将 `glide.yaml` 文件中声明的依赖项下载到 `vendor/` 目录中，还会下载它们的依赖项。最终，Glide
    将递归下载应用程序的整个依赖树，并将其放在 `vendor/` 目录中。
- en: '![](img/bff51f22-c24e-4569-8fd8-5f46b49ee7eb.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bff51f22-c24e-4569-8fd8-5f46b49ee7eb.png)'
- en: For each package it downloaded, Glide will write the exact version into a new
    file, `glide.lock` (you can take a look at this file by opening it, but it is
    really not meant to be edited manually). The `glide.lock` file allows you to reconstruct
    this exact set of dependencies with their exact versions at any later moment in
    time by running `glide install`. You can verify this behavior by deleting your
    `vendor/` directory and then running `glide install`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于它下载的每个包，Glide 将精确的版本写入一个新文件 `glide.lock`（您可以通过打开它来查看此文件，但实际上不应手动编辑）。`glide.lock`
    文件允许您通过运行 `glide install` 在任何以后的时间点重建这组精确的依赖项及其精确的版本。您可以通过删除您的 `vendor/` 目录然后运行
    `glide install` 来验证此行为。
- en: 'Having a `vendor/` directory and the Glide configuration files leaves you with
    the following two options:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有 `vendor/` 目录和 Glide 配置文件会给您以下两个选项：
- en: You can place your entire `vendor/` directory into version control alongside
    your actual application files. The upside of this is that now anyone can clone
    your repository (anyone, in this case, includes CI/CD tools that want to build
    and deploy your code) and have all dependencies in their exact required versions
    readily available. This way, building your application from scratch is literally
    nothing more than a `git clone` or `go build` command. On the downside, your source
    code repository grows larger and may take more disk space to store and more time
    to clone.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将整个 `vendor/` 目录与实际应用程序文件一起放入版本控制。好处是，现在任何人都可以克隆您的存储库（在这种情况下，任何人都包括想要构建和部署您的代码的
    CI/CD 工具），并且所有依赖项的确切所需版本都可以立即使用。这样，从头构建应用程序实际上只是一个 `git clone` 或 `go build` 命令。缺点是，您的源代码存储库会变得更大，可能需要更多的磁盘空间来存储，克隆需要更多的时间。
- en: Alternatively, you can just place the `glide.yaml` and `glide.lock` files into
    version control and exclude the `vendor/` directory from version control by adding
    it to the `.gitignore` file. On the upside, this makes your repository smaller
    and faster to clone. However, after cloning your repository, users will now need
    to explicitly run `glide install` to download the dependencies specified in your
    `glide.lock` file from the internet.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您可以将 `glide.yaml` 和 `glide.lock` 文件放入版本控制，并通过将其添加到 `.gitignore` 文件中来排除 `vendor/`
    目录。好处是，这样可以使您的存储库更小，克隆速度更快。但是，在克隆存储库后，用户现在需要显式运行 `glide install` 从互联网下载 `glide.lock`
    文件中指定的依赖项。
- en: 'Both of these options work reasonably well, so ultimately this is a matter
    of personal taste. Since repository size and disk space are rarely a consideration
    these days, and because it makes the build process significantly easier, my personal
    preference is to put my entire `vendor/` directory into version control:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项都可以很好地工作，因此最终这是个人口味的问题。由于存储库大小和磁盘空间在这些天很少被考虑，而且因为它使构建过程显着更容易，所以我个人偏好于将整个
    `vendor/` 目录放入版本控制：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This takes care of our backend services, but there is also still the frontend
    application that we need to consider. Since we have been using npm to install
    our dependencies in [Chapter 5](82bdbb64-f1d4-42fb-9532-ecd5feca2ba7.xhtml), *Building
    a Frontend with React*, most of the work has been already done for us. Interestingly,
    the exact same argument about whether to put dependencies into version control
    or not (in this case, the `node_modules/` directory instead of `vendor/`) also
    applies to npm. Also, yes, just as with Go''s `vendor/` directory, I prefer to
    put my entire `node_modules/` directory in version control:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这关注了我们的后端服务，但我们还需要考虑前端应用程序。由于我们在[第5章](82bdbb64-f1d4-42fb-9532-ecd5feca2ba7.xhtml)中使用npm来安装我们的依赖项，大部分工作已经为我们完成。有趣的是，关于是否将依赖项放入版本控制的确切论点（在这种情况下，是`node_modules/`目录而不是`vendor/`）也适用于npm。是的，就像Go的`vendor/`目录一样，我更喜欢将整个`node_modules/`目录放入版本控制中：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Explicitly declaring your project's dependencies (including the used versions)
    is a big step to ensure reproducible builds. Depending on whether you chose to
    include your dependencies into version control or not, users have either the entire
    application source code (including dependencies) readily available directly after
    cloning the source code repository or can at least easily reconstruct it by running
    `glide install` or `npm install`, respectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 明确声明项目的依赖关系（包括使用的版本）是确保可重现构建的重要一步。根据您选择是否将依赖项包含在版本控制中，用户在克隆源代码存储库后要么直接获得整个应用程序源代码（包括依赖项），要么可以通过运行`glide
    install`或`npm install`来轻松重建它。
- en: Now that we have our project put in version control and have explicitly declared
    dependencies, we can take a look at some of the most popular CI/CD tools that
    you can use to continuously build and deploy your application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将项目放入版本控制，并明确声明了依赖关系，我们可以看一下一些最流行的CI/CD工具，您可以使用它们来持续构建和部署您的应用程序。
- en: Using Travis CI
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Travis CI
- en: '**Travis CI** is a hosted service for continuous integration. It is very tightly
    coupled to GitHub (which is why you will need a Git repository on GitHub to actually
    use Travis CI). It is free to use for open source projects, which, together with
    its good GitHub integration, makes it the go-to choice for many popular projects.
    For building private GitHub projects, there is a paid usage model.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**Travis CI**是一个持续集成的托管服务。它与GitHub紧密耦合（这就是为什么您实际上需要在GitHub上拥有一个Git存储库才能使用Travis
    CI）。它对于开源项目是免费的，这与其良好的GitHub集成一起，使其成为许多热门项目的首选。对于构建私有GitHub项目，有一个付费使用模式。'
- en: 'The configuration of your Travis build is done by a `.travis.yml` file that
    needs to be present at the root level of your repository. Basically, this file
    can look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Travis构建的配置是通过一个名为`.travis.yml`的文件完成的，该文件需要存在于存储库的根级别。基本上，这个文件可以看起来像这样：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `language` property describes which programming language your project is
    written in. Depending on whichever language you provide here, you will have different
    tools available in your build environment. The `go` property describes for which
    versions of Go your application should be built. Testing your code for multiple
    versions of Go is especially important for libraries that might be used by a multitude
    of users in potentially very different environments. The `env` property contains
    environment variables that should be passed into the built environment. Note that
    we have used the `CGO_ENABLED` environment variable before in [Chapter 6](af835c34-a409-4898-9a55-74fc9d05b46b.xhtml),
    *Deploying Your Application in Containers*, to instruct the Go compiler to produce
    statically linked binaries.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`language`属性描述了您的项目所使用的编程语言。根据您在这里提供的语言，您将在构建环境中有不同的工具可用。`go`属性描述了应该为哪些Go版本构建您的应用程序。对于可能被多种用户在潜在非常不同的环境中使用的库来说，测试您的代码是否适用于多个Go版本尤为重要。`env`属性包含应该传递到构建环境中的环境变量。请注意，我们之前在[第6章](af835c34-a409-4898-9a55-74fc9d05b46b.xhtml)中使用过`CGO_ENABLED`环境变量，*在容器中部署您的应用程序*，来指示Go编译器生成静态链接的二进制文件。'
- en: 'The `install` property describes the steps necessary to set up your application''s
    dependencies. If left out entirely, Travis will automatically run `go get ./...`
    to download the latest versions of all our dependencies (which is exactly what
    we do not want). The `install: true` property actually instructs Travis not to
    do anything to set up our dependencies, which is exactly the way to go if your
    dependencies have been already included in your source code repository.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`install`属性描述了设置应用程序依赖项所需的步骤。如果完全省略，Travis将自动运行`go get ./...`来下载所有依赖项的最新版本（这正是我们不想要的）。`install:
    true`属性实际上指示Travis不执行任何设置依赖项的操作，这正是我们应该采取的方式，如果您的依赖项已经包含在您的源代码存储库中。'
- en: 'If you decided not to include your `vendor/` directory in version control,
    the install step needs to contain instructions for Travis to download Glide and
    then use it to install your project''s dependencies:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定不在版本控制中包含您的`vendor/`目录，则安装步骤需要包含Travis下载Glide并使用它来安装项目的依赖项的说明：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `script` property then contains the commands that Travis should run to
    actually build your project. The most obvious step to build your application is,
    of course, the `go build` command. Of course, you can add additional steps here.
    For example, you could use the `go vet` command to check your source code for
    common errors:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`script`属性包含Travis应该运行的命令，以实际构建您的项目。当然，构建您的应用程序的最明显的步骤是`go build`命令。当然，您可以在这里添加额外的步骤。例如，您可以使用`go
    vet`命令来检查您的源代码是否存在常见错误：'
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `$(go list ./... | grep -v vendor)` command is a special hack used to instruct
    `go vet` not to analyze the `vendor/` source code in your package directory. Otherwise,
    `go vet` would probably complain about a lot of issues in your project's dependencies
    that you would not want to (or even can not) fix, anyway.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(go list ./... | grep -v vendor)`命令是一个特殊的技巧，用于指示`go vet`不要分析包目录中的`vendor/`源代码。否则，`go
    vet`可能会抱怨您的项目依赖项中的许多问题，您可能不想（甚至无法）修复。'
- en: 'After creating the `.travis.yml` file, add it to version control and push it
    into the remote repository:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`.travis.yml`文件后，将其添加到版本控制并将其推送到远程存储库：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that you have a *.travis.yml* file in your repository, you can enable the
    Travis build for this repository. For this, sign in to Travis CI on [https://travis-ci.org](https://travis-ci.org)
    (or [https://travis-ci.com](https://travis-ci.com) if you are planning to use
    the paid tier) using your GitHub credentials. After signing in, you will find
    a list of your publicly available GitHub repositories, alongside a switch that
    allows you to enable Travis builds for each repository (just as in the following
    screenshot):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的存储库中有一个*.travis.yml*文件，您可以为该存储库启用Travis构建。为此，请使用GitHub凭据登录[https://travis-ci.org](https://travis-ci.org)（如果您打算使用付费版，则使用[https://travis-ci.com](https://travis-ci.com)），登录后，您将找到您的公开可用GitHub存储库列表，以及一个开关，允许您为每个存储库启用Travis构建（就像以下截图中一样）：
- en: '![](img/16b2df49-adb2-4bc2-9640-7f1178f4f7d8.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16b2df49-adb2-4bc2-9640-7f1178f4f7d8.png)'
- en: Go ahead and enable both the `myevents` and `myevents-frontend` repositories
    (it's not that bad if there's no `.travis.yml` file in one of these repositories,
    yet).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 继续启用`myevents`和`myevents-frontend`存储库（如果其中一个存储库中没有`.travis.yml`文件也没关系）。
- en: After enabling your project in the Travis user interface, the next Git push
    into your repository will automatically trigger a build on Travis. You can test
    this, for example, by making a small change to your code or by just adding a new
    empty text file somewhere and pushing it to GitHub. In the Travis user interface,
    you will note a new build popping up for your project quickly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Travis用户界面中启用项目后，下一次对存储库的Git推送将自动触发Travis上的构建。您可以通过对代码进行小的更改或只是在某个地方添加一个新的空文本文件并将其推送到GitHub来测试这一点。在Travis用户界面中，您会很快注意到项目的新构建弹出。
- en: 'The build will run for a while (it may take a while from the build being scheduled
    to the actual execution). After that, you will see whether the build was completed
    successfully or whether errors occurred (you will also receive a notification
    via email in the latter case), as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 构建将运行一段时间（从计划构建到实际执行可能需要一段时间）。之后，您将看到构建是否成功完成或是否发生错误（在后一种情况下，您还将通过电子邮件收到通知），如下所示：
- en: '![](img/88e50e75-5a21-4d8c-905d-1f5e5d6d0187.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88e50e75-5a21-4d8c-905d-1f5e5d6d0187.png)'
- en: If you have specified multiple Go versions to test against, you will note multiple
    build jobs for each commit (just like in the preceding screenshot). Click on any
    one of them to receive a detailed build output. This is especially useful if your
    build should fail for any reason (which is entirely possible when you push code
    that does not pass `go vet` or does not even compile).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经指定了多个要测试的Go版本，您将注意到每个提交都有多个构建作业（就像前面的截图中一样）。单击其中任何一个以接收详细的构建输出。如果您的构建因任何原因失败（当您推送无法通过`go
    vet`或甚至无法编译的代码时，这是非常有用的）。
- en: '![](img/4724ad2c-300e-4671-af09-0060ff769771.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4724ad2c-300e-4671-af09-0060ff769771.png)'
- en: In general, Travis integrates with GitHub really well. In the GitHub UI, you
    will also see the current build status of each commit and can also use Travis
    to verify pull requests before they are being merged into the master branch.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，Travis与GitHub集成得非常好。在GitHub用户界面中，您还将看到每个提交的当前构建状态，并且还可以使用Travis在将其合并到主分支之前验证拉取请求。
- en: So far, we have used Travis to verify that the code in the repository does not
    contain any errors and compiles (which is typically the goal of continuous integration).
    However, we have not yet configured any actual deployment of your application.
    This is what we'll be doing in the following steps.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用Travis来验证存储库中的代码是否不包含任何错误并且可以编译（这通常是持续集成的目标）。但是，我们还没有配置应用程序的实际部署。这就是我们接下来要做的事情。
- en: 'Within a Travis build, you can use Docker to build and run container images.
    To enable Docker support, add the following properties to the top of your `.travis.yml`
    file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Travis构建中，您可以使用Docker构建和运行容器映像。要启用Docker支持，请将以下属性添加到您的`.travis.yml`文件的顶部：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since we do not actually want to build Docker images for multiple different
    versions of Go, it is also completely alright to remove the Go versions 1.6 to
    1.8 from the Travis file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们实际上不想为多个不同版本的Go构建Docker映像，因此完全可以从Travis文件中删除Go版本1.6到1.8。
- en: 'As our project actually consists of two deployment artifacts (event service
    and booking service), there is another optimization that we can make: we can use
    a build matrix to build both of these services in parallel. For this, add an `env`
    property to your `.travis.yml` file and adjust the `script` property, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的项目实际上由两个部署构件（事件服务和预订服务）组成，我们可以进行另一个优化：我们可以使用构建矩阵并行构建这两个服务。为此，请将`env`属性添加到您的`.travis.yml`文件，并调整`script`属性，如下所示：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With this configuration, Travis will start two build jobs for each change in
    your code repository, each of those building one of the two services contained
    in that repository.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，Travis将为代码存储库中的每次更改启动两个构建作业，其中每个构建一个包含在该存储库中的两个服务之一。
- en: 'After that, you can add a `docker image build` command to the `script` property
    to build a container image from the compiled service:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以将`docker image build`命令添加到`script`属性中，以从编译的服务构建容器映像：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding command builds a Docker image named either `myevents/eventservice`
    or `myevents/bookingservice` (dependent on the current value of `$SERVICE`). The
    Docker image is built with the current branch (or Git tag) name as the tag. This
    means that a new push to the *master* branch will result in a `myevents/eventservice:master` image being
    built. When a Git tag named *v1.2.3* is pushed, a `myevents/eventservice:v1.2.3`
    image will be created.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令构建了一个名为`myevents/eventservice`或`myevents/bookingservice`的Docker镜像（取决于当前`$SERVICE`的值）。Docker镜像是使用当前分支（或Git标签）名称作为标记构建的。这意味着对*master*分支的新推送将导致构建一个`myevents/eventservice:master`镜像。当推送名为*v1.2.3*的Git标签时，将创建一个`myevents/eventservice:v1.2.3`镜像。
- en: 'Lastly, you will need to push the new Docker image to a registry. For this,
    add a new property, `after_success`, to your `.travis.yml` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要将新的Docker镜像推送到注册表。为此，请将一个新属性`after_success`添加到您的`.travis.yml`文件中：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The commands specified in `after_success` will be run after all commands in
    `scripts` have successfully been completed. In this case, we are checking the
    content of the `$TRAVIS_TAG` environment variable; as a consequence, only Docker
    images built for Git tags will actually be pushed to the remote registry.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`after_success`中指定的命令将在`scripts`中的所有命令成功完成后运行。在这种情况下，我们正在检查`$TRAVIS_TAG`环境变量的内容；因此，只有为Git标签构建的Docker镜像才会实际推送到远程注册表。
- en: 'If you are using a different Docker Image Registry than the Docker Hub, remember
    to specify the registry''s URL in the `docker login` command. For example, when
    using `quay.io` as registry, the command should look as follows: `docker login
    -u="${DOCKER_USERNAME}" -p"${DOCKER_PASSWORD}" quay.io`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是与Docker Hub不同的Docker镜像注册表，请记住在`docker login`命令中指定注册表的URL。例如，当使用`quay.io`作为注册表时，命令应如下所示：`docker
    login -u="${DOCKER_USERNAME}" -p="${DOCKER_PASSWORD}" quay.io`。
- en: 'For this command to work, you will need to have the environment variables `$DOCKER_USERNAME`
    and `$DOCKER_PASSWORD` defined. In theory, you could define these in the `env`
    section of your `.travis.yml` file. However, for sensitive data such as passwords,
    it would be a massively stupid idea to define them in a publicly available file
    for everyone to see. Instead, you should use the Travis user interface to configure
    these variables for your build. For this, go to the Settings page of your project,
    which you will find when clicking on the More options button on your project overview
    page:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此命令工作，您需要定义环境变量`$DOCKER_USERNAME`和`$DOCKER_PASSWORD`。理论上，您可以在`.travis.yml`文件的`env`部分中定义这些变量。但是，对于诸如密码之类的敏感数据，将它们定义在公开可用的文件中供所有人查看是一个非常愚蠢的想法。相反，您应该使用Travis用户界面为构建配置这些变量。为此，请转到项目的设置页面，您可以在项目概述页面上单击“更多选项”按钮时找到：
- en: '![](img/66335f96-033a-4f38-bb3c-71714e5d2844.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66335f96-033a-4f38-bb3c-71714e5d2844.png)'
- en: 'In the project settings, you will find a section labeled Environment Variables.
    Configure your Docker Registry credentials here by specifying the `DOCKER_USERNAME`
    and `DOCKER_PASSWORD` variables:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目设置中，您将找到一个名为环境变量的部分。通过指定`DOCKER_USERNAME`和`DOCKER_PASSWORD`变量在这里配置您的Docker注册表凭据：
- en: '![](img/d2472861-3242-4f9d-9a2d-a8fa53dafc32.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2472861-3242-4f9d-9a2d-a8fa53dafc32.png)'
- en: 'Alternatively, you can add secret variables to your `.travis.yml` file by encrypting
    them before placing them in version control. For this, you will need the Travis
    command-line client CLI. Travis CLI is a Ruby tool that you can install via the
    Ruby package manager, `gem`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过加密后将秘密变量添加到您的`.travis.yml`文件中，然后将其放置在版本控制中。为此，您将需要Travis命令行客户端CLI。Travis
    CLI是一个Ruby工具，您可以通过Ruby软件包管理器`gem`安装。
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After that, you can use the Travis CLI to encrypt a variable and automatically
    add it to your `.travis.yml` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以使用Travis CLI对变量进行加密，并自动将其添加到您的`.travis.yml`文件中：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will add a new variable to your `.travis.yml` file that looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向您的`.travis.yml`文件添加一个新变量，看起来像这样：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Both adding your secret variables via the Travis UI and encrypting and adding
    them to your `.travis.yml` file are valid approaches for handling sensitive data
    in Travis builds.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Travis UI添加您的秘密变量以及对其进行加密并将其添加到您的`.travis.yml`文件中，这两种方法都是处理Travis构建中的敏感数据的有效方法。
- en: 'Save the new build configuration in `.travis.yml` and push it to GitHub. To
    build and publish a new Docker image, you can now push a new `git` tag:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将新的构建配置保存在`.travis.yml`中，并将其推送到GitHub。要构建和发布新的Docker镜像，现在可以推送一个新的`git`标签：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At this point, Travis CI will pull your code, compile all your Go binaries,
    and publish two Docker images for the two backend services to the Docker registry
    configured in your build configuration.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Travis CI将拉取您的代码，编译所有Go二进制文件，并为构建配置中配置的Docker注册表发布两个后端服务的Docker镜像。
- en: 'We will still need to add a similar build configuration for the frontend application.
    Actually, the steps for building the Docker image are exactly identical; however,
    instead of `go build`, we will need to run the Webpack module bundler. The following
    is a `.travis.yml` file that should cover the entire frontend build:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要为前端应用程序添加类似的构建配置。实际上，构建Docker镜像的步骤完全相同；但是，我们需要运行Webpack模块打包程序而不是`go build`。以下是一个应该涵盖整个前端构建的`.travis.yml`文件：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Deploying to Kubernetes
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到Kubernetes
- en: Using GitHub and Travis, we have now automated the entire workflow from changing
    the application's source code over building new binaries to creating new Docker
    images and pushing them to a container registry. That is great, but we are still
    missing one crucial step, that is, getting the new container images to run in
    your production environment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitHub和Travis，我们现在已经自动化了从更改应用程序源代码到构建新二进制文件再到创建新的Docker镜像并将其推送到容器注册表的整个工作流程。这很棒，但我们仍然缺少一个关键步骤，那就是在生产环境中运行新的容器映像。
- en: In the previous chapters, you have already worked with Kubernetes and deployed
    your containerized applications into a Minikube environment. For this section,
    we will assume that you already have a publicly accessible Kubernetes environment
    up and running (for example, using a `kops`-provisioned cluster in AWS or the
    Azure Container Service).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您已经使用 Kubernetes 并将容器化应用部署到 Minikube 环境中。对于本节，我们将假设您已经拥有一个正在运行的公共可访问的
    Kubernetes 环境（例如，使用 AWS 中的 `kops` 提供的集群或 Azure 容器服务）。
- en: 'First of all, Travis CI will need to access your Kubernetes cluster. For this,
    you can create a **service account** in your Kubernetes cluster. This Service
    Account will then receive an API token that you can configure as a secret environment
    variable in your Travis build. To create a service account, run the following
    command on your local machine (assuming that you have `kubectl` set up to communicate
    with your Kubernetes cluster):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Travis CI 需要访问您的 Kubernetes 集群。为此，您可以在 Kubernetes 集群中创建一个 **服务账户**。然后，该服务账户将收到一个
    API 令牌，您可以在 Travis 构建中配置为秘密环境变量。要创建服务账户，请在本地机器上运行以下命令（假设您已经设置了 `kubectl` 以与 Kubernetes
    集群通信）：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding command will create a new service account named `travis-ci` and
    a new secret object that contains that account''s API token. To determine the
    secret, now run the `kubectl describe serviceaccount travis-ci` command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将创建一个名为 `travis-ci` 的新服务账户和一个包含该账户 API 令牌的新密钥对象。要确定密钥，现在运行 `kubectl describe
    serviceaccount travis-ci` 命令：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Use the token secret name (in this case, `travis-ci-token-mtxrh`) to access
    the actual API token:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用令牌密钥名称（在本例中为 `travis-ci-token-mtxrh`）来访问实际的 API 令牌：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You will need both the `ca.crt` and the `token` properties. Both of these values
    are BASE64-encoded, so you will need to pipe both values through `base64 --decode`
    to access the actual values:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要 `ca.crt` 和 `token` 属性。这两个值都是 BASE64 编码的，因此您需要通过 `base64 --decode` 管道传递这两个值来访问实际值：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Together with the API server's URL, these two values can be used to authenticate
    against a Kubernetes cluster from Travis CI (or other CI/CD tools).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与 API 服务器的 URL 一起，这两个值可以用于从 Travis CI（或其他 CI/CD 工具）对 Kubernetes 集群进行身份验证。
- en: 'To actually configure the Kubernetes deployment in your Travis CI build, start
    by setting up `kubectl` in your builds by adding the following commands to your
    `install` section:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Travis CI 构建中实际配置 Kubernetes 部署，请从在 `install` 部分添加以下命令开始设置 `kubectl`：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For these steps to work, you will need to have the environment variables `$KUBE_CA_CERT`
    and `$KUBE_TOKEN` configured as secret environment variables in your Travis CI
    settings with the values that you took from the preceding `kubectl get secret`
    command.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这些步骤生效，您需要在 Travis CI 设置中将环境变量 `$KUBE_CA_CERT` 和 `$KUBE_TOKEN` 配置为秘密环境变量，并使用从上述
    `kubectl get secret` 命令中获取的值。
- en: 'After having `kubectl` configured, you can now add an additional step to the
    `after_success` command of both your projects:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了 `kubectl` 后，您现在可以将额外的步骤添加到您的项目的 `after_success` 命令中：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `kubectl set image` command will change the container image that should
    be used for a given Deployment object (in this case, assuming that you have deployments
    named `eventservice` and `bookingservice`). The Kubernetes deployment controller
    will then proceed to create new Pods with the new container image and shut down
    the Pods running the old image.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl set image` 命令将更改应该用于给定 Deployment 对象的容器镜像（在本例中，假设您有名为 `eventservice`
    和 `bookingservice` 的部署）。Kubernetes 部署控制器将继续使用新的容器镜像创建新的 Pod，并关闭运行旧镜像的 Pod。'
- en: Using GitLab
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitLab
- en: GitHub and Travis are excellent tools for building and deploying open source
    projects (and also private projects if you do not mind paying for their services).
    However, in some cases, you might want to host your source code management and
    CI/CD systems in your own environment instead of relying on an external service
    provider.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 和 Travis 都是构建和部署开源项目（以及私有项目，如果您不介意为其服务付费）的优秀工具。然而，在某些情况下，您可能希望在自己的环境中托管源代码管理和
    CI/CD 系统，而不是依赖外部服务提供商。
- en: This is where GitLab comes into play. GitLab is a software that offers a service
    similar to GitHub and Travis combined (meaning source code management and CI)
    that you can host on your own infrastructure. In the following section, we will
    show you how to set up your own GitLab instance and build a build and deployment
    pipeline similar to the one built in the preceding section using GitLab and its
    CI features.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 GitLab 发挥作用的地方。GitLab 是一种类似于 GitHub 和 Travis 组合的服务的软件（意味着源代码管理和 CI），您可以在自己的基础设施上托管。在接下来的部分中，我们将向您展示如何设置自己的
    GitLab 实例，并构建一个类似于前一节中使用 GitLab 和其 CI 功能构建的构建和部署流水线。
- en: GitLab offers both an open source **Community Edition** (**CE**) and a paid-for
    **Enterprise Edition** (**EE**) that offers some additional features. For our
    purposes, the CE will do just fine.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 提供开源的 **社区版**（**CE**）和付费的 **企业版**（**EE**），提供一些额外的功能。对于我们的目的，CE 就足够了。
- en: Setting up GitLab
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 GitLab
- en: 'You can set up your own GitLab instance easily using the Docker images provided
    by the vendor. To start a GitLab CE server, run the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用供应商提供的 Docker 镜像轻松地设置自己的 GitLab 实例。要启动 GitLab CE 服务器，请运行以下命令：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note the `GITLAB_OMNIBUS_CONFIG` environment variable that is passed into the
    container. This variable can be used to inject configuration code (written in
    Ruby) into the container; in this case, it is used to configure the GitLab instance's
    public HTTP address. When starting GitLab on your local machine, it is usually
    easiest to use your machine's public IP address for this (on Linux or macOS, use
    the `ifconfig` command to find it).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意传递到容器中的 `GITLAB_OMNIBUS_CONFIG` 环境变量。此变量可用于将配置代码（用 Ruby 编写）注入到容器中；在本例中，它用于配置
    GitLab 实例的公共 HTTP 地址。在本地启动 GitLab 时，通常最容易使用您的机器的公共 IP 地址（在 Linux 或 macOS 上，使用
    `ifconfig` 命令找到它）。
- en: 'If you are setting up GitLab on a server for production usage (as opposed to
    on your local machine for experimentation), you might want to create two data
    volumes for configuration and repository data that you can then use in your container.
    This will allow you to easily upgrade your GitLab installation to a newer version
    later:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要在服务器上为生产使用设置GitLab（而不是在本地机器上进行实验），您可能希望为配置和存储库数据创建两个数据卷，然后可以在容器中使用。这将使您能够轻松地将GitLab安装升级到较新的版本：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After creating the volumes, use the `-v gitlab-config:/etc/gitlab` and `-v gitlab-data:/var/opt/gitlab`
    flags in your `docker container run` command to actually use these volumes for
    your Gitlab instance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建卷后，在`docker container run`命令中使用`-v gitlab-config:/etc/gitlab`和`-v gitlab-data:/var/opt/gitlab`标志，以实际为Gitlab实例使用这些卷。
- en: 'The GitLab server running in the newly created container will probably take
    a few minutes to start up entirely. After that, you can access your GitLab instance
    at `http://localhost`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的容器中运行的GitLab服务器可能需要几分钟才能完全启动。之后，您可以在`http://localhost`上访问您的GitLab实例：
- en: '![](img/c04abec5-6eee-4d39-b32c-cb97723094e1.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c04abec5-6eee-4d39-b32c-cb97723094e1.png)'
- en: When opening GitLab for the first time in your browser, you will be prompted
    to set a new password for the initial user. After setting the password, you can
    sign in with the username `root` and the password that you set previously. If
    you are setting up a production instance of GitLab, your next step would now be
    to set up a new user that you can sign in as instead of root. For demo purposes,
    it is also alright to continue working as root.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首次在浏览器中打开GitLab时，您将被提示为初始用户设置新密码。设置密码后，您可以使用用户名`root`和之前设置的密码登录。如果您正在设置GitLab的生产实例，下一步将是设置一个新用户，您可以使用该用户登录，而不是root。出于演示目的，继续作为root进行工作也是可以的。
- en: 'After logging in for the first time, you will see a Start page on which you
    can create new groups and a new project. A GitLab project is (usually) always
    associated with a Git source code repository. In order to set up a CI/CD pipeline
    for the MyEvents application, proceed to create two new projects called `myevents`
    and `myevents-frontend`, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首次登录后，您将看到一个“开始”页面，您可以在该页面上创建新的组和新项目。GitLab项目通常与Git源代码存储库相关联。为了为MyEvents应用程序设置CI/CD流水线，请继续创建两个名为`myevents`和`myevents-frontend`的新项目，如下所示：
- en: '![](img/07777c0a-aa0a-4247-9772-06718a2f6731.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07777c0a-aa0a-4247-9772-06718a2f6731.png)'
- en: In order to push code into your new GitLab instance, you will need to provide
    an SSH public key for authentication. For this, click on your user icon in the
    upper-right corner, select Settings, and then the SSH Keys tab. Paste your SSH
    public key into the input field and save it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将代码推送到新的GitLab实例中，您需要提供用于身份验证的SSH公钥。为此，请点击右上角的用户图标，选择“设置”，然后选择SSH密钥选项卡。将您的SSH公钥粘贴到输入字段中并保存。
- en: 'Next, add your new GitLab repositories as remotes to your existing MyEvents
    repositories and push your code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将您的新GitLab存储库添加为现有MyEvents存储库的远程，并推送您的代码：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Proceed similarly for the frontend application. After this, you will be able
    to find your files in the GitLab web UI:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地进行前端应用程序的设置。之后，您将能够在GitLab Web UI中找到您的文件：
- en: '![](img/92b3c8ba-ce38-4039-9d42-6c2ae24deb6c.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92b3c8ba-ce38-4039-9d42-6c2ae24deb6c.png)'
- en: Setting up GitLab CI
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置GitLab CI
- en: 'In order to use GitLab''s CI feature, you will need to set up one additional
    component: the GitLab CI Runner. While GitLab itself is responsible for managing
    your application''s source code and deciding when to trigger a new CI build, the
    CI Runner is the component that is responsible for actually executing these jobs.
    Separating the actual GitLab container from the CI Runner allows you to distribute
    your CI infrastructure and have, for example, multiple runners on separate machines.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '为了使用GitLab的CI功能，您需要设置一个额外的组件：GitLab CI Runner。虽然GitLab本身负责管理应用程序的源代码并决定何时触发新的CI构建，但CI
    Runner负责实际执行这些作业。将实际的GitLab容器与CI Runner分开允许您分发CI基础设施，并且例如在不同的机器上拥有多个Runner。 '
- en: 'The GitLab CI Runner can also be set up using a Docker image. To set up the
    CI Runner, run the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab CI Runner也可以使用Docker镜像进行设置。要设置CI Runner，请运行以下命令：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After starting the GitLab CI Runner, you will need to register it at the main
    GitLab instance. For this, you will need the runners registration token. You can
    find this token in the Admin Area of the GitLab UI. Access the Admin Area via
    the wrench icon in the upper-right corner, then select Runners. You will find
    the runners registration token in the first text paragraph:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 启动GitLab CI Runner后，您需要在主GitLab实例上注册它。为此，您将需要Runner的注册令牌。您可以在GitLab UI的管理区域中找到此令牌。通过右上角的扳手图标访问管理区域，然后选择Runners。您将在第一个文本段落中找到Runner的注册令牌：
- en: '![](img/f25a2ddd-5d9c-476b-ae80-db15d56b0664.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f25a2ddd-5d9c-476b-ae80-db15d56b0664.png)'
- en: 'To register your runner, run the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册您的Runner，请运行以下命令：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This command registers the previously started GitLab CI Runner at the main GitLab
    instance. The `--url` flag configures the URL that the main GitLab instance is
    reachable at (usually, this can be `http://gitlab` when your runner is on the
    same container network as your main Gitlab instance; alternatively, you can use
    your host machine's public IP address here, which in my case is `http://192.168.2.125/`).
    Next, copy and paste the registration token for the `--registration-token` flag.
    The `--executor` flag configures the GitLab CI Runner to run each build job in
    its own isolated Docker container. The `--docker-image` flag configures the Docker
    image that should be used as a build environment by default. The `--docker-volumes`
    flag ensures that you can use the Docker Engine from within your builds (this
    is especially important since we will be building our own Docker images within
    these builds).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在主GitLab实例上注册先前启动的GitLab CI Runner。`--url`标志配置了主GitLab实例的可访问URL（通常情况下，当您的runner在与主Gitlab实例相同的容器网络上时，这可以是`http://gitlab`；或者，您可以在这里使用您主机的公共IP地址，我的情况下是`http://192.168.2.125/`）。接下来，复制并粘贴`--registration-token`标志的注册令牌。`--executor`标志配置GitLab
    CI Runner在自己的隔离Docker容器中运行每个构建作业。`--docker-image`标志配置默认情况下应该用作构建环境的Docker镜像。`--docker-volumes`标志确保您可以在构建中使用Docker
    Engine（这一点尤为重要，因为我们将在这些构建中构建我们自己的Docker镜像）。
- en: Mounting the `/var/run/docker.sock` socket into your Gitlab Runner exposes the
    Docker engine that is running on your host to the users of your CI system. This
    might pose a security risk if you do not trust these users. Alternatively, you
    can set up a new Docker engine that itself runs in a container (called Docker-in-Docker).
    Refer to the GitLab documentation at [https://docs.gitlab.com/ce/ci/docker/using_docker_build.html#use-docker-in-docker-executor](https://docs.gitlab.com/ce/ci/docker/using_docker_build.html#use-docker-in-docker-executor)
    for detailed setup instructions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将`/var/run/docker.sock`套接字挂载到您的Gitlab Runner中，将您主机上运行的Docker引擎暴露给您的CI系统的用户。如果您不信任这些用户，这可能构成安全风险。或者，您可以设置一个新的Docker引擎，它本身运行在一个容器中（称为Docker-in-Docker）。有关详细的设置说明，请参阅GitLab文档[https://docs.gitlab.com/ce/ci/docker/using_docker_build.html#use-docker-in-docker-executor](https://docs.gitlab.com/ce/ci/docker/using_docker_build.html#use-docker-in-docker-executor)。
- en: 'The `docker exec` command should produce an output similar to the one in the
    following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker exec`命令应该产生类似于以下截图的输出：'
- en: '![](img/8e7c0c49-fc88-4de9-ae55-15cdf43c3c10.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e7c0c49-fc88-4de9-ae55-15cdf43c3c10.png)'
- en: 'After the runner has been successfully registered, you should be able to find
    it in the GitLab administration UI:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 成功注册Runner后，您应该能够在GitLab管理UI中找到它：
- en: '![](img/59e6a201-ec4f-4f53-ba09-fef9f12f571c.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59e6a201-ec4f-4f53-ba09-fef9f12f571c.png)'
- en: Now that you have a working CI Runner, you can start configuring your actual
    CI jobs. Similarly to Travis CI, GitLab CI jobs are configured via a configuration
    file that is placed within the source code repository. Similarly to the already
    known `.travis.yml`, this file is named `.gitlab-ci.yml`. Although they are similarly
    named, their format is a little bit different.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有一个工作的CI Runner，您可以开始配置实际的CI作业。与Travis CI类似，GitLab CI作业是通过一个配置文件进行配置的，该文件放置在源代码存储库中。与已知的`.travis.yml`类似，该文件名为`.gitlab-ci.yml`。尽管它们的名称相似，但其格式略有不同。
- en: Each GitLab CI configuration consists of multiple Stages (by default, build,
    test, and deploy, although this is completely customizable). Each stage can consist
    of an arbitrary number of Jobs. All stages together form a Pipeline. Each job
    of a pipeline is run in its own isolated Docker container.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GitLab CI配置由多个阶段组成（默认情况下为构建、测试和部署，尽管这是完全可定制的）。每个阶段可以包含任意数量的作业。所有阶段一起形成一个流水线。流水线中的每个作业都在自己隔离的Docker容器中运行。
- en: 'Let''s start with the MyEvents backend services. Place a new file, `.gitlab-ci.yml`*, *in
    the root directory of your project:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从MyEvents后端服务开始。在项目的根目录中放置一个新文件`.gitlab-ci.yml`：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So, what does this code snippet actually do? First, it instructs the GitLab
    CI Runner to start this build within a Docker container based on the `golang:1.9.2`
    image. This ensures that you have access to the latest Go SDK in your build environment.
    The three commands in the `before_script` section take care of setting up a `$GOPATH`,
    and the one command in the `script` section is the actual compilation step.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这段代码实际上是做什么呢？首先，它指示GitLab CI Runner在基于`golang:1.9.2`镜像的Docker容器中启动此构建。这确保您在构建环境中可以访问最新的Go
    SDK。`before_script`部分中的三个命令负责设置`$GOPATH`，`script`部分中的一个命令是实际的编译步骤。
- en: Note that this build configuration assumes that your project has all its dependencies
    vendored in version control. If you have just a `glide.yaml` file in your project,
    you will also need to set up Glide and run `glide install` before actually running
    `go build`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此构建配置假定您的项目的所有依赖项都已在版本控制中进行了分发。如果您的项目中只有一个`glide.yaml`文件，那么在实际运行`go build`之前，您还需要设置Glide并运行`glide
    install`。
- en: Finally, the artifacts property defines that the `eventservice` executable that
    was created by Go `build` should be archived as a build artifact. This will allow
    users to download this build artifact later. Also, the artifact will be available
    in later jobs of the same pipeline.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，artifacts属性定义了由Go `build`创建的`eventservice`可执行文件应作为构建artifact进行存档。这将允许用户稍后下载此构建artifact。此外，该artifact将在同一流水线的后续作业中可用。
- en: 'Now, add the `.gitlab-ci.yml` file to your source code repository and push
    it to the GitLab server:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`.gitlab-ci.yml`文件添加到您的源代码存储库中，并将其推送到GitLab服务器：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When you have pushed the configuration file, head to your project page in the
    GitLab web UI and go to the Pipelines tab. You will find an overview of all build
    pipelines that were started for your project, and also their success:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当您推送配置文件后，转到GitLab Web UI中的项目页面，然后转到Pipelines选项卡。您将找到为您的项目启动的所有构建流水线的概述，以及它们的成功情况：
- en: '![](img/33e32a1a-00f5-495b-9f43-8f986ea74847.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33e32a1a-00f5-495b-9f43-8f986ea74847.png)'
- en: 'Right now, our pipeline consists of only one stage (`build`) with one job (`build:eventservice`).
    You can see this in the Stages column of the `Pipelines` overview. To inspect
    the exact output of the `build:eventservice` job, click on the pipeline status
    icon and then on the `build:eventservice` job:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的流水线只包括一个阶段（`build`）和一个作业（`build:eventservice`）。您可以在`Pipelines`概述的`Stages`列中看到这一点。要查看`build:eventservice`作业的确切输出，请单击流水线状态图标，然后单击`build:eventservice`作业：
- en: '![](img/9c40d302-b4a0-4296-9cec-2e86e028362f.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c40d302-b4a0-4296-9cec-2e86e028362f.png)'
- en: 'Next, we can extend our `.gitlab-ci.yml` configuration file to also include
    the build for the booking service:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以扩展我们的`.gitlab-ci.yml`配置文件，以包括预订服务的构建：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When you push your code again, you will note that the next Pipeline started
    for your project consists of two jobs that run in parallel (more or less, depending
    on the configuration of the GitLab CI Runner and its current workload):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当您再次推送代码时，您会注意到为您的项目启动的下一个流水线由两个作业并行运行（更多或更少，取决于GitLab CI Runner的配置及其当前工作负载）：
- en: '![](img/5a64c80c-9044-4845-86c9-aaee701680d0.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a64c80c-9044-4845-86c9-aaee701680d0.png)'
- en: 'Next, we can add two jobs that build the actual Docker images. These jobs need
    to be executed after the already configured build steps, because we will need
    the compiled Go binaries to create the Docker images. Owing to this, we cannot
    configure the docker build steps to run in the build stage (all jobs within one
    stage are executed in parallel—at least, potentially—and cannot be dependent on
    each other). For this reason, we will start by reconfiguring the build stages
    for our project. This is also done on a per-project basis in the `.gitlab-ci.yml`
    file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加两个构建实际Docker镜像的作业。这些作业需要在已经配置的构建步骤之后执行，因为我们需要编译后的Go二进制文件来创建Docker镜像。因此，我们无法将docker构建步骤配置为在构建阶段运行（一个阶段内的所有作业是并行执行的，至少在潜在情况下，并且不能相互依赖）。因此，我们将首先重新配置项目的构建阶段。这也是在`.gitlab-ci.yml`文件中基于每个项目的基础上完成的：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we can use these new stages in our actual build jobs:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在实际的构建作业中使用这些新的阶段：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `dependencies` property declares that this step requires the `build:eventservice`
    job to complete first. It also makes the build artifacts of that job available
    within this job. The `script` consists of just the `docker container build` command
    (`$CI_COMMIT_REF_NAME`) that contains the name of the current Git branch or tag.
    The `only` property ensures that the Docker image is only built when a new Git
    tag is pushed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies`属性声明了这一步需要先完成`build:eventservice`作业。它还使得该作业的构建产物在这个作业中可用。`script`只包含`docker
    container build`命令(`$CI_COMMIT_REF_NAME`)，其中包含当前Git分支或标签的名称。`only`属性确保只有在推送新的Git标签时才构建Docker镜像。'
- en: 'Add a corresponding build job for building the booking service container image:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为构建预订服务容器镜像添加相应的构建作业：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the modified `.gitlab-ci.yml` file to version control, and also, create
    a new Git tag to test the new build pipeline:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将修改后的`.gitlab-ci.yml`文件添加到版本控制中，并创建一个新的Git标签来测试新的构建流水线：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the Pipeline overview, you will now find four build jobs:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在流水线概述中，您现在会找到四个构建作业：
- en: '![](img/40656dbf-18bd-45c8-8bd6-88f06b83c95c.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40656dbf-18bd-45c8-8bd6-88f06b83c95c.png)'
- en: 'After building the Docker images, we can now add a fifth build step for publishing
    the created registries into a Docker registry:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像后，我们现在可以添加第五个构建步骤，将创建的注册表发布到Docker注册表中：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similar to our preceding Travis CI build, this build job relies on the environment
    variables `$DOCKER_USERNAME` and `$DOCKER_PASSWORD`. Luckily, GitLab CI offers
    a similar feature to Travis CI''s secret environment variables. For this, open
    the project''s Settings tab in the GitLab web UI, then select the CI/CD Pipelines
    tab and search for the Secret Variables section:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的Travis CI构建类似，这个构建作业依赖于环境变量`$DOCKER_USERNAME`和`$DOCKER_PASSWORD`。幸运的是，GitLab
    CI提供了类似于Travis CI的秘密环境变量的功能。为此，在GitLab web UI中打开项目的设置选项卡，然后选择CI/CD Pipelines选项卡，搜索秘密变量部分：
- en: '![](img/392d38cf-4057-4fdd-a622-4eb0882d6e35.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/392d38cf-4057-4fdd-a622-4eb0882d6e35.png)'
- en: Use this feature to configure the credentials for the container registry of
    your choice (remember to adjust the `docker login` command in the preceding build
    job accordingly if you are using a registry other than Docker Hub).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此功能配置您选择的容器注册表的凭据（如果您使用的是Docker Hub之外的注册表，请记得相应地调整前面构建作业中的`docker login`命令）。
- en: 'Finally, let''s add the final build step for actually deploying our application
    into a Kubernetes cluster:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为将应用程序实际部署到Kubernetes集群中添加最终的构建步骤：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This build step uses the `alpine:3.5` base image (a minimalist Linux distribution
    with a very small image size), in which we first download and then configure the
    `kubectl` binary. These steps are similar to our Travis CI deployment, which we
    configured in the preceding section, and require the environment variables `$KUBE_CA_CERT`
    and `$KUBE_TOKEN` to be configured as secret variables in the GitLab UI.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构建步骤使用了`alpine:3.5`基础镜像（一个非常小的镜像大小的极简Linux发行版），其中我们首先下载，然后配置`kubectl`二进制文件。这些步骤与我们在前面部分配置的Travis
    CI部署类似，并且需要在GitLab UI中将环境变量`$KUBE_CA_CERT`和`$KUBE_TOKEN`配置为秘密变量。
- en: Note that, in this example, we are using a Kubernetes Service Account named
    `gitlab-ci` (previously, we created an account named `travis-ci`). So, for this
    example to work, you will need to create an additional service account using the
    commands that have already been used in the preceding section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，我们使用了一个名为`gitlab-ci`的Kubernetes服务账户（之前，我们创建了一个名为`travis-ci`的账户）。因此，为了使这个例子工作，您需要使用在前面部分已经使用过的命令创建一个额外的服务账户。
- en: 'At this point, our GitLab-based build and deployment pipeline is complete.
    Take another look at the Pipelines view in the GitLab UI to have a last look at
    our pipeline in all its glory:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们基于GitLab的构建和部署流水线已经完成。再次查看GitLab UI中的流水线视图，以充分了解我们的流水线：
- en: '![](img/910c4c84-ff01-46bf-90e0-c10a53ca8d9d.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/910c4c84-ff01-46bf-90e0-c10a53ca8d9d.png)'
- en: GitLab's pipeline feature is a nearly perfect solution for implementing complex
    build and deployment pipelines. While other CI/CD tools constrain you into a single
    build job with one environment, GitLab pipelines allow you to use an isolated
    environment for each step of your build, and to even run these in parallel if
    possible.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab的流水线功能几乎是实现复杂构建和部署流程的完美解决方案。而其他CI/CD工具会限制你只能使用一个环境进行单一构建作业，GitLab的流水线允许你为构建的每个步骤使用一个隔离的环境，甚至在可能的情况下并行运行这些步骤。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to easily automate your application's build
    and deployment workflow. Having an automated deployment workflow is especially
    important in microservice architectures where you have many different components
    that are deployed often. Without automation, deploying complex distributed application
    would become increasingly tedious and would eat away your productivity.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何轻松自动化应用程序的构建和部署工作流程。在微服务架构中，拥有自动化的部署工作流程尤为重要，因为你会经常部署许多不同的组件。如果没有自动化，部署复杂的分布式应用程序将变得越来越繁琐，并且会影响你的生产效率。
- en: Now that the deployment problem of our application is solved (in short, containers
    + continuous delivery), we can direct our attention to other matters. That our
    application is running where we deployed it does not mean that it is actually
    doing what it is supposed to do. This is why we need to monitor applications that
    are run in production environments. Monitoring enables you to track your application's
    behavior at runtime and note errors quickly, which is why the focus of the next
    chapter will be on monitoring your application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用部署问题已经解决（简而言之，容器+持续交付），我们可以将注意力转向其他事项。我们部署的应用程序在运行并不意味着它实际上在做它应该做的事情。这就是为什么我们需要监控在生产环境中运行的应用程序。监控能够让你在运行时跟踪应用程序的行为并快速发现错误，这就是为什么下一章的重点将放在监控你的应用程序上。
