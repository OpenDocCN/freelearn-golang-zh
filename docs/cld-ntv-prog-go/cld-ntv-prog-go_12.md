# 第十二章：接下来该去哪里？

欢迎来到我们学习 Go 语言云原生编程的最后一章。到目前为止，你应该已经掌握了足够的知识来构建生产级别的微服务，设计复杂的分布式架构，利用亚马逊云服务的强大功能，为你的软件赋予容器的力量，等等。

然而，云原生编程的主题非常深入和广泛。这意味着你仍然可以学习一些主题，丰富你在这个领域的知识和技能。本章的目的是为你提供一些实用的概述，让你在吸收了本书中的知识之后，能够继续探索一些本书未涵盖的强大主题。

在这一章中，我们将涵盖以下主题：

+   其他微服务通信模式和协议，比如协议缓冲区和 GRPC

+   云提供商提供的更多有用功能

+   其他云提供商（Azure、GCP 和 OpenStack）

+   无服务器计算

# 微服务通信

在本书中，我们涵盖了微服务相互通信的两种方法：

+   第一种方法是通过 RESTful API，其中一个 Web HTTP 层将被构建到一个微服务中，有效地允许微服务与任何 Web 客户端进行通信，无论这个 Web 客户端是另一个微服务还是一个 Web 浏览器。这种方法的一个优点是它赋予了微服务在需要时与外部世界通信的能力，因为 HTTP 现在是一个被所有软件堆栈支持的通用协议。然而，这种方法的缺点是 HTTP 可能是一个具有多层的重型协议，在内部微服务之间需要快速高效的通信时可能不是最佳选择。

+   第二种方法是通过消息队列，其中消息代理软件（如 RabbitMQ 或 Kafka）将促进微服务之间的消息交换。消息代理接收来自发送微服务的消息，将消息排队，然后将其传递给之前表明对这些消息感兴趣的微服务。这种方法的一个主要优势是它可以巩固大规模分布式微服务架构中的数据一致性，如第十一章 *迁移*中所解释的那样。这种方法使得事件驱动的分布式架构成为可能，比如事件溯源和 CQRS。然而，如果我们的扩展需求相对简单，这种方法可能对我们的需求来说过于复杂。这是因为它要求我们维护一个带有所有配置和后端的消息代理软件。在这些情况下，直接的微服务之间的通信可能就是我们所需要的一切。

如果你还没有注意到，这两种方法的一个明显的缺点是它们都不能提供直接高效的微服务之间的通信。我们可以采用两种流行的技术来实现直接的微服务通信：协议缓冲区和 GRPC。

# 协议缓冲区

在它们的官方文档中，协议缓冲区被定义为一种语言中立、平台中立的序列化结构化数据的机制。让我们看一个例子，帮助建立协议缓冲区是什么的清晰图景。

假设您的应用程序中有两个微服务；第一个微服务（服务 1）已经收集了有关新客户的信息，并希望将其发送给第二个微服务（服务 2）。这些数据被视为结构化数据，因为它包含结构化信息，如客户姓名、年龄、工作和电话号码。发送这些数据的一种方式是将其作为 JSON 文档（我们的数据格式）通过 HTTP 从服务 1 发送到服务 2。然而，如果我们想更快地以更小的形式发送这些数据呢？这就是协议缓冲区的作用。在服务 1 内部，协议缓冲区将获取客户对象，然后将其序列化为紧凑形式。然后，我们可以将这个编码后的紧凑数据发送到服务 2，通过高效的通信协议，如 TCP 或 UDP。

请注意，在前面的例子中，我们将协议缓冲区描述为服务内部。这是因为协议缓冲区是作为软件库提供的，我们可以导入并包含在我们的代码中。有许多编程语言的协议缓冲区包（Go、Java、C#、C++、Ruby、Python 等）。

协议缓冲区的工作方式如下：

1.  您在一个特殊的文件中定义您的数据，称为`proto`文件。

1.  您使用一个名为协议缓冲区编译器的软件来将 proto 文件编译成您选择的编程语言的代码文件。

1.  您使用生成的代码文件与您选择的编程语言的协议缓冲区软件包结合起来构建您的软件。

这就是协议缓冲区的要点。要更深入地了解协议缓冲区，请访问[`developers.google.com/protocol-buffers/`](https://developers.google.com/protocol-buffers/)，那里有很好的文档可以帮助您开始使用这项技术。

目前有两个常用的协议缓冲区版本：协议缓冲区 2 和协议缓冲区 3。当前在线可用的大部分培训资源都覆盖了最新版本，协议缓冲区 3。如果您正在寻找协议缓冲区版本 2 的资源，您可以在我的网站上查看这篇文章[`www.minaandrawos.com/2014/05/27/practical-guide-protocol-buffers-protobuf-go-golang/`](http://www.minaandrawos.com/2014/05/27/practical-guide-protocol-buffers-protobuf-go-golang/)。

# GRPC

协议缓冲区技术缺少的一个关键特性是通信部分。协议缓冲区擅长将数据编码和序列化为紧凑形式，以便与其他微服务共享。然而，当协议缓冲区的概念最初被构想时，只考虑了序列化，而没有考虑实际将数据发送到其他地方的部分。因此，开发人员过去常常需要自己动手实现 TCP 或 UDP 应用层来在服务之间交换编码数据。然而，如果我们没有时间和精力来担心一个高效的通信层呢？这就是 GRPC 的作用。

GRPC 可以简单地描述为在协议缓冲区之上加上一个 RPC 层。**远程过程调用**（**RPC**）层是一种软件层，允许不同的软件部分，如微服务，通过高效的通信协议（如 TCP）进行交互。使用 GRPC，您的微服务可以通过协议缓冲区版本 3 序列化您的结构化数据，然后能够与其他微服务通信，而无需担心实现通信层。

如果您的应用程序架构需要微服务之间的高效快速交互，同时又不能使用消息队列或 Web API，那么请考虑在下一个应用程序中使用 GRPC。

要开始使用 GRPC，请访问[`grpc.io/`](https://grpc.io/)。与协议缓冲区类似，GRPC 支持多种编程语言。

# 更多关于 AWS

在本书中，我们专门介绍了 AWS 基础知识的两章内容，重点介绍了如何编写能够轻松适应亚马逊云的 Go 微服务。然而，AWS 是一个非常深入的话题，值得一整本书来覆盖，而不仅仅是几章。在本节中，我们将简要介绍一些有用的 AWS 技术，这些技术我们在本书中没有涉及到。您可以将以下部分作为学习 AWS 的下一步的介绍。

# DynamoDB 流

在第八章中，*AWS II - S3、SQS、API Gateway 和 DynamoDB*，我们介绍了流行的 AWS DynamoDB 服务。我们了解了 DynamoDB 是什么，它如何对数据进行建模，以及如何编写能够利用 DynamoDB 功能的 Go 应用程序。

在本书中，有一个强大的 DynamoDB 功能我们没有机会介绍，那就是 DynamoDB 流。DynamoDB 流允许我们捕获 DynamoDB 表中项目发生的更改，同时发生更改。实际上，这意味着我们可以实时地对数据库中发生的数据更改做出反应。和往常一样，让我们举个例子来巩固其含义。

假设我们正在构建云原生分布式微服务应用程序，为大型多人游戏提供支持。假设我们使用 DynamoDB 作为应用程序的数据库后端，并且我们的某个微服务向数据库添加了新玩家。如果我们在应用程序中使用 DynamoDB 流，其他感兴趣的微服务将能够在新玩家添加后不久捕获新玩家的信息。这使得其他微服务可以根据这些新信息采取相应的行动。例如，如果其中一个其他微服务负责在游戏地图中定位玩家，它将把新玩家附加到游戏地图上的起始位置。

DynamoDB 流的工作方式很简单。它们按顺序捕获发生在 DynamoDB 表项上的更改。信息被存储在一个长达 24 小时的日志中。我们编写的其他应用程序可以访问此日志并捕获数据更改。

换句话说，如果一个项目被创建、删除或更新，DynamoDB 流将存储项目的主键和发生的数据修改。

需要在需要监控的表上启用 DynamoDB 流。如果由于任何原因，表不再需要监控，我们也可以在现有表上禁用 DynamoDB 流。DynamoDB 流与 DynamoDB 表并行操作，这基本上意味着使用它们不会对性能产生影响。

要开始使用 DynamoDB 流，请查看[`docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html`](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html)。

要开始使用 Go 编程语言中的 DynamoDB 流支持，请查看[`docs.aws.amazon.com/sdk-for-go/api/service/dynamodbstreams/`](https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodbstreams/)。

# AWS 上的自动扩展

由于 AWS 从一开始就设计用于与大规模分布式微服务应用程序一起使用，AWS 具有内置功能，允许这些大型应用程序的开发人员在云中自动扩展其应用程序，尽可能少地进行手动干预。

在 AWS 的世界中，自动扩展这个词有三个主要含义：

+   能够自动替换不健康的应用程序或不良的 EC2 实例，无需您的干预。

+   能够自动创建新的 EC2 实例来处理微服务应用程序的增加负载，无需您的干预。然后，能够在应用程序负载减少时关闭 EC2 实例。

+   当应用程序负载增加时，自动增加可用于应用程序的云服务资源的能力。AWS 云资源不仅限于 EC2。根据您的需求，可以自动增加或减少的云服务资源的一个示例是 DynamoDB 读取和写入吞吐量。

为了满足自动缩放的广泛定义，AWS 自动缩放服务提供了三个主要功能：

+   EC2 实例的车队管理：此功能允许您监视运行中的 EC2 实例的健康状况，自动替换不良实例而无需手动干预，并在配置了多个区域时在多个区域之间平衡 Ec2 实例。

+   动态缩放：此功能允许您首先配置跟踪策略，以调整应用程序的负载量。例如，监视 CPU 利用率或捕获传入请求的数量。然后，动态缩放功能可以根据您配置的目标限制自动添加或删除 EC2 实例。

+   应用程序自动缩放：此功能允许您根据应用程序的需求动态扩展超出 EC2 的 AWS 服务资源。

要开始使用 AWS 自动缩放服务，请访问[`aws.amazon.com/autoscaling/`](https://aws.amazon.com/autoscaling/)。

# 亚马逊关系数据库服务

在第八章中，*AWS II - S3、SQS、API Gateway 和 DynamoDB*，当我们涵盖 AWS 世界中的数据库服务时，我们专门涵盖了 DynamoDB。 DynamoDB 是亚马逊在 AWS 上提供的托管 NoSQL 数据库服务。如果您对数据库引擎有足够的技术专长，您可能会问一个显而易见的问题：关系数据库呢？难道也不应该有一个托管的 AWS 服务吗？

上述两个问题的答案是肯定的，它被称为 Amazon 关系数据库服务（RDS）。 AWS RDS 允许开发人员轻松在云上配置、操作、扩展和部署关系数据库引擎。

Amazon RDS 支持许多开发人员使用和喜爱的知名关系数据库引擎。这包括 PostgreSQL、MySQL、MariaDB、Oracle 和 Microsoft SQL Server。除了 RDS，亚马逊还提供一个名为数据库迁移服务的服务，允许您轻松地将现有数据库迁移到 Amazon RDS 或复制到 Amazon RDS。

要开始使用 AWS RDS，请访问[`aws.amazon.com/rds/`](https://aws.amazon.com/rds/)。要构建能够与 RDS 交互的 Go 应用程序，请访问[`docs.aws.amazon.com/sdk-for-go/api/service/rds/`](https://docs.aws.amazon.com/sdk-for-go/api/service/rds/)。

# 其他云提供商

到目前为止，我们已经专注于 AWS 作为云提供商。当然，还有其他提供商提供类似的服务，其中最大的两个是微软 Azure 云和谷歌云平台。除此之外，还有许多其他提供商也提供基于开源平台 OpenStack 的 IaaS 解决方案。

所有云提供商都采用类似的概念，因此如果您对其中一个有经验，您可能会在其他云提供商中找到自己的路。出于这个原因，我们决定不在本书中深入涵盖它们中的每一个，而是专注于 AWS，并简要展望其他提供商以及它们的不同之处。

# 微软 Azure

您可以在[`azure.microsoft.com/en-us/free/`](https://azure.microsoft.com/en-us/free/)上注册 Azure 云。与 AWS 一样，Azure 提供多个区域和可用性区域，您可以在其中运行您的服务。此外，大多数 Azure 核心服务的工作方式类似于 AWS，尽管它们通常被命名为不同的名称：

+   管理虚拟机的服务（在 AWS 术语中为 EC2）就是**虚拟机**。创建虚拟机时，您需要选择一个镜像（支持 Linux 和 Windows 镜像），提供一个 SSH 公钥，并选择一个机器大小。其他核心概念的命名方式类似。您可以使用**网络安全组**配置网络访问规则，使用**Azure 负载均衡器**（在 AWS 中称为弹性负载均衡器）负载平衡流量，并使用**VM 规模集**管理自动扩展。

+   关系型数据库（由 AWS 的关系数据库服务管理）由**Azure SQL 数据库**管理。但是，在撰写本书时，仅支持 Microsoft SQL 数据库。对 MySQL 和 PostgreSQL 数据库的支持仅作为预览服务提供。

+   类似于 DynamoDB 的 NoSQL 数据库以**Azure Cosmos DB**的形式提供。

+   提供类似于简单队列服务的消息队列服务的是**队列存储**服务。

+   可以使用**应用程序网关**访问您的服务提供的 API。

要从 Go 应用程序中使用 Azure 服务，可以使用**Azure SDK for Go**，可在[`github.com/Azure/azure-sdk-for-go`](https://github.com/Azure/azure-sdk-for-go)上获得。您可以使用通常的`go get`命令进行安装：

```go
$ go get -u github.com/Azure/azure-sdk-for-go/...
```

Azure SDK for Go 目前仍在积极开发中，应谨慎使用。为了不受 SDK 中的任何重大更改的影响，请确保使用依赖管理工具（如*Glide*）将此库的一个版本放入您的*vendor/directory*中（正如您在第九章中学到的，*持续交付*）。

# Google Cloud Platform

**Google Cloud Platform**（**GCP**）是 Google 提供的 IaaS。您可以在[`console.cloud.google.com/freetrial`](https://console.cloud.google.com/freetrial)上注册。与 Azure 云一样，您会发现许多核心功能，尽管名称不同：

+   您可以使用**Google 计算引擎**管理虚拟实例。与往常一样，每个实例都是从一个镜像、一个选择的机器类型和一个 SSH 公钥创建的。您可以使用**防火墙规则**而不是安全组，并且自动缩放组称为**托管实例组**。

+   **Cloud SQL**服务提供关系型数据库。GCP 支持 MySQL 和 PostgreSQL 实例。

+   对于 NoSQL 数据库，您可以使用**Cloud Datastore**服务。

+   **Cloud Pub/Sub**服务提供了实现复杂的发布/订阅架构的可能性（事实上，超越了 AWS 提供的 SQS 的可能性）。

由于两者都来自 Google，可以毫不夸张地说 GCP 和 Go 是密不可分的（双关语）。您可以通过通常的`go get`命令安装 Go SDK：

```go
$ go get -u cloud.google.com/go
```

# OpenStack

还有许多云提供商在开源云管理软件 OpenStack（[`www.openstack.org`](https://www.openstack.org)）上构建其产品。OpenStack 是一个高度模块化的软件，基于它构建的云可能在设置上有很大差异，因此很难对它们做出普遍有效的陈述。典型的 OpenStack 安装可能包括以下服务：

+   Nova 管理虚拟机实例，Neutron 管理网络。在管理控制台中，您会在“实例”和“网络”标签下找到这些功能。

+   **Zun**和**Kuryr**管理容器。由于这些组件相对较新，可能更常见的是在 OpenStack 云中找到托管的 Kubernetes 集群。

+   **Trove**为关系型和非关系型数据库（如 MySQL 或 MongoDB）提供数据库服务。

+   **Zaqar**提供类似于 SQS 的消息服务。

如果您想从 Go 应用程序访问 OpenStack 功能，则有多个库可供选择。首先，有官方客户端库 - [github.com/openstack/golang-client](http://github.com/openstack/golang-client) - 但目前尚不建议用于生产。在撰写本书时，OpenStack 的最成熟的 Go 客户端库是[github.com/gophercloud/gophercloud](http://github.com/openstack/golang-client)库。

# 在云中运行容器

在第六章中，*在容器中部署您的应用程序*，我们深入了解了如何使用现代容器技术部署 Go 应用程序。当涉及将这些容器部署到云环境时，您有多种不同的方法可以做到这一点。

部署容器化应用程序的一种可能性是使用诸如**Kubernetes**之类的编排引擎。当您使用 Microsoft Azure 云或 Google Cloud Platform 时，这尤其容易。这两个提供商都提供 Kubernetes 作为托管服务，尽管不是以这个名称; 寻找**Azure 容器服务**（**AKS**）或**Google 容器引擎**（**GKE**）。

尽管 AWS 不提供托管的 Kubernetes 服务，但他们有一个类似的服务称为**EC2 容器服务**（**ECS**）。由于 ECS 是 AWS 独家提供的服务，它与其他 AWS 核心服务紧密集成，这既是优势也是劣势。当然，您可以使用在 VM、网络和存储形式提供的构建块在 AWS 上设置自己的 Kubernetes 集群。这是非常复杂的工作，但不要绝望。您可以使用第三方工具自动在 AWS 上设置 Kubernetes 集群。其中一个工具是**kops**。

您可以在[`github.com/kubernetes/kops`](https://github.com/kubernetes/kops)下载 kops。之后，请按照 AWS 的设置说明进行设置，您可以在项目文档中找到[`github.com/kubernetes/kops/blob/master/docs/aws.md`](https://github.com/kubernetes/kops/blob/master/docs/aws.md)。

Kops 本身也是用 Go 编写的，并使用了您在第七章中已经遇到的 AWS SDK。看一下源代码，看看 AWS 客户端库的一些非常复杂的用法的真实例子。

# 无服务器架构

在使用传统的基础设施即服务时，您将获得一些虚拟机以及相应的基础设施（如存储和网络）。通常需要自己操作在这些虚拟机中运行的所有内容。这通常意味着不仅是您编译的应用程序，还包括整个操作系统，包括每个完整的 Linux（或 Windows）系统的内核和系统服务。您还需要负责基础设施的容量规划（这意味着估算应用程序的资源需求并为自动扩展组定义合理的边界）。

所有这些都意味着**操作开销**会让您无法专注于实际工作，也就是构建和部署推动业务的软件。为了减少这种开销，您可以使用平台即服务（PaaS）而不是基础设施即服务（IaaS）。一种常见的 PaaS 托管形式是使用容器技术，开发人员只需提供一个容器镜像，提供商负责运行（和可选地扩展）应用程序，并管理底层基础设施。典型的基于容器的 PaaS 提供包括 AWS 的 EC2 容器服务或任何 Kubernetes 集群，例如 Azure 容器服务或 Google 容器引擎。非基于容器的 PaaS 提供可能包括 AWS Elastic Beanstalk 或 Google App Engine。

最近，又出现了另一种方法，旨在消除 PaaS 提供的操作开销：**无服务器计算**。当然，这个名字是非常误导的，因为在无服务器架构上运行的应用程序显然仍然需要服务器。关键的区别在于这些服务器的存在完全对开发人员隐藏。开发人员只提供要执行的应用程序，提供商负责为该应用程序提供基础设施，并部署和运行它。这种方法与微服务架构很搭配，因为部署使用 web 服务、消息队列或其他方式相互通信的小代码片段变得非常容易。在极端情况下，这经常导致单个函数被部署为服务，从而产生无服务器计算的替代术语：**函数即服务**（**FaaS**）。

许多云服务提供商作为其服务的一部分提供 FaaS 功能，其中最突出的例子是**AWS Lambda**。在撰写本书时，AWS Lambda 并不正式支持 Go 作为编程语言（支持的语言包括 JavaScript、Python、Java 和 C#），而运行 Go 函数只能使用第三方包装器，例如[`github.com/eawsy/aws-lambda-go`](https://github.com/eawsy/aws-lambda-go)。

其他云服务提供商提供类似的服务。Azure 提供**Azure Functions**（支持 JavaScript、C#、F#、PHP、Bash、Batch 和 PowerShell），GCP 提供**Cloud Functions**作为 Beta 产品（仅支持 JavaScript）。如果您正在运行 Kubernetes 集群，可以使用 Fission 框架（[`github.com/fission/fission`](https://github.com/fission/fission)）来运行自己的 FaaS 平台（甚至支持 Go）。然而，Fission 是一个处于早期 alpha 开发阶段的产品，目前还不建议用于生产环境。

您可能已经注意到，流行的 FaaS 提供中对 Go 语言的支持还不够广泛。然而，鉴于 Go 作为一种编程语言和无服务器架构的流行，还不是所有的希望都已经失去。

# 总结

到此，我们的书就要结束了。到目前为止，您应该已经掌握了足够的知识，可以构建复杂的云原生微服务应用程序，这些应用程序具有弹性、分布式和可扩展性。通过本章，您还应该有了下一步如何将您新获得的知识提升到更高水平的想法。我们感谢您给我们提供机会，引导您完成这次学习之旅，并期待成为您未来旅程的一部分。
