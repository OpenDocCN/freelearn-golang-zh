- en: Developer Environment for Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go的开发环境
- en: Go is a modern programming language built for the 21st century application development.
    Hardware and technology have advanced significantly over the past decade, and
    most of the other languages do not take advantage of these technical advancements.
    As we shall see throughout the book, Go allows us to build network applications
    that take advantage of concurrency and parallelism made available with multicore
    systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go是为21世纪应用程序开发而构建的现代编程语言。在过去的十年里，硬件和技术有了显著的进步，大多数其他语言没有利用这些技术进步。正如我们将在整本书中看到的，Go允许我们构建利用多核系统提供的并发性和并行性的网络应用程序。
- en: 'In this chapter, we will look at some of the topics required to work through
    rest of the book, such as:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一些在书的其余部分工作所需的主题，比如：
- en: Go configuration—`GOROOT`, `GOPATH`, and so on.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go配置——`GOROOT`、`GOPATH`等。
- en: Go package management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go包管理
- en: Project structure used throughout the book
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整本书中使用的项目结构
- en: Container technology and how to use Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器技术以及如何使用Docker
- en: Writing tests in Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中编写测试
- en: GOROOT
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GOROOT
- en: In order to run or build a Go project, we need to have access to the Go binary
    and its libraries. A typical installation of Go (instructions can be found at [https://golang.org/dl/](https://golang.org/dl/))
    on Unix-based systems will place the Go binary at `/usr/bin/go`. However, it is
    possible to install Go on a different path. In that case, we need to set the `GOROOT` environment
    variable to point to our Go installation path and also append it to our `PATH`
    environment variable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行或构建一个Go项目，我们需要访问Go二进制文件及其库。在Unix系统上，典型的Go安装（安装说明可以在[https://golang.org/dl/](https://golang.org/dl/)找到）会将Go二进制文件放在`/usr/bin/go`。然而，也可以在不同的路径上安装Go。在这种情况下，我们需要设置`GOROOT`环境变量指向我们的Go安装路径，并将其附加到我们的`PATH`环境变量中。
- en: GOPATH
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GOPATH
- en: Programmers tend to work on many projects and it is good practice to have the
    source code separate from nonprogramming-related files. It is a common practice
    to have the source code in a separate location or workspace. Every programming
    language has its own conventions on how the language-related projects should be
    set up and Go is no exception to this.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员倾向于在许多项目上工作，将源代码与非编程相关文件分开是一个好习惯。将源代码放在一个单独的位置或工作空间是一个常见的做法。每种编程语言都有其自己的约定，规定语言相关项目应该如何设置，Go也不例外。
- en: '`GOPATH` is the most important environment variable the developer has to set.
    It tells the Go compiler where to find the source code for the project and its
    dependencies. There are conventions within the `GOPATH` that need to be followed,
    and they have to deal with folder hierarchies.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOPATH`是开发人员必须设置的最重要的环境变量。它告诉Go编译器在哪里找到项目和其依赖项的源代码。`GOPATH`中有一些需要遵循的约定，它们与文件夹层次结构有关。'
- en: src/
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: src/
- en: This is the directory that will contain the source code of our projects and
    their dependencies. In general, we want our source code to have version control
    and be hosted on the cloud. It would also be great if we or anyone else could
    easily use our project. This requires a little extra setup on our part.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目录将包含我们项目和它们依赖项的源代码。一般来说，我们希望我们的源代码有版本控制，并且托管在云上。如果我们或其他人能够轻松地使用我们的项目，那将是很好的。这需要我们做一些额外的设置。
- en: Let's imagine that our project is hosted at `http://git-server.com/user-name/my-go-project`.
    We want to clone and build this project on our local system. To make it properly
    work, we need to clone it to `$GOPATH/src/git-server.com/user-name/my-go-project`.
    When we build a Go project with dependencies for the first time, we will see that
    the `src/` folder has many directories and subdirectories that contain the dependencies
    of our project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的项目托管在`http://git-server.com/user-name/my-go-project`。我们想要在本地系统上克隆和构建这个项目。为了使其正常工作，我们需要将其克隆到`$GOPATH/src/git-server.com/user-name/my-go-project`。当我们第一次为Go项目构建依赖项时，我们会看到`src/`文件夹中有许多包含我们项目依赖项的目录和子目录。
- en: pkg/
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pkg/
- en: Go is a compiled programming language; we have the source code and code for
    the dependencies that we want to use in our project. In general, every time we
    build a binary, the compiler has to read the source code of our project and dependencies
    and then compile it to machine code. Compiling unchanged dependencies every time
    we compile our main program would lead to a very slow build process. This is the
    reason that **object files** exist; they allow us to compile dependencies into
    reusable machine code that can be readily included in our Go binary.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种编译型编程语言；我们有我们想要在项目中使用的源代码和依赖项的代码。一般来说，每次构建一个二进制文件，编译器都必须读取我们项目和依赖项的源代码，然后将其编译成机器代码。每次编译我们的主程序时编译未更改的依赖项会导致非常缓慢的构建过程。这就是**目标文件**存在的原因；它们允许我们将依赖项编译成可重用的机器代码，可以直接包含在我们的Go二进制文件中。
- en: 'These object files are stored in `$GOPATH/pkg`; they follow a directory structure
    similar to that of `src/`, except that they are within a subdirectory. These directories
    tend to follow the naming pattern of `<OS>_<CPU-Architecture>`, because we can
    build executable binaries for multiple systems:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目标文件存储在`$GOPATH/pkg`中；它们遵循与`src/`类似的目录结构，只是它们位于一个子目录中。这些目录往往遵循`<OS>_<CPU-Architecture>`的命名模式，因为我们可以为多个系统构建可执行二进制文件：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: bin/
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bin/
- en: Go compiles and builds our projects into executable binaries and places them
    in this directory. Depending on the build specs, they might be executable on your
    current system or other systems. In order to use the binaries that are available
    in the `bin/` directory, we need to set the corresponding `GOBIN=$GOPATH/bin` environment
    variable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Go将我们的项目编译和构建成可执行二进制文件，并将它们放在这个目录中。根据构建规范，它们可能在当前系统或其他系统上可执行。为了使用`bin/`目录中可用的二进制文件，我们需要设置相应的`GOBIN=$GOPATH/bin`环境变量。
- en: Package management
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包管理
- en: In the days of yore, all programs were written from scratch—every utility function
    and every library to run the code had to written by hand. Now a days, we don't
    want to deal with the low level details on a regular basis; it would be unimaginable
    to write all the required libraries and utilities from scratch. Go comes with
    a rich library, which will be enough for most of our needs. However, it is possible
    that we might need a few extra libraries or features not provided by the standard
    library. Such libraries should be available on the internet, and we can download
    and add them into our project to start using them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，所有程序都是从头开始编写的——每个实用函数和运行代码的库都必须手工编写。现在，我们不希望经常处理低级细节；从头开始编写所有所需的库和实用程序是不可想象的。Go带有丰富的库，这对于我们大多数需求来说已经足够了。然而，可能我们需要一些标准库提供的额外库或功能。这样的库应该可以在互联网上找到，并且我们可以下载并将它们添加到我们的项目中以开始使用它们。
- en: In the previous section, *GOPATH*, we discussed how all our projects are saved
    into qualified paths of the `$GOPATH/src/git-server.com/user-name/my-go-project` form.
    This is true for any and all dependencies we might have. There are multiple ways
    to handle dependencies in Go. Let's look at some of them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节*GOPATH*中，我们讨论了所有项目都保存在`$GOPATH/src/git-server.com/user-name/my-go-project`形式的合格路径中。这对于我们可能拥有的任何依赖项都是正确的。在Go中处理依赖项有多种方法。让我们看看其中一些。
- en: go get
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: go get
- en: 'The `go get` is the utility provided by the standard library for package management.
    We can install a new package/library by running the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get`是标准库提供的用于包管理的实用程序。我们可以通过运行以下命令来安装新的包/库：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will download and build the source code and then install it as a binary
    executable (if it can be used as a standalone executable). The `go get` utility
    also installs all the dependencies required by the dependency retrieved for our
    project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载并构建源代码，然后将其安装为二进制可执行文件（如果可以作为独立可执行文件使用）。`go get`实用程序还会安装我们项目所需的所有依赖项。
- en: The `go get` utility is a very simple tool. It will install the latest master
    commit on the Git repository. For simple projects, this might be enough. However,
    as projects start growing in size and complexity, keeping track of the version
    of dependency being used might become critical. Unfortunately, `go get` is not
    great for such projects, and we might want to look at other package management
    tools.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get`实用程序是一个非常简单的工具。它将安装Git存储库上的最新主提交。对于简单的项目，这可能足够了。然而，随着项目在大小和复杂性上的增长，跟踪使用的依赖版本可能变得至关重要。不幸的是，`go
    get`对于这样的项目并不是很好，我们可能需要看看其他包管理工具。'
- en: glide
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: glide
- en: 'The `glide` is one of the most widely used package management tool in Go community.
    It addresses the limitations of `go get`, but it needs to be installed manually
    by the developer. The following is a simple way to install and use `glide`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`glide`是Go社区中最广泛使用的包管理工具之一。它解决了`go get`的限制，但需要开发人员手动安装。以下是安装和使用`glide`的简单方法：'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In case you do not wish to install `glide` via `curl` and `sh`, other options
    are available and described in better detail on the project page, available at [https://github.com/masterminds/glide](https://github.com/masterminds/glide).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您不希望通过`curl`和`sh`安装`glide`，还有其他选项可在项目页面上更详细地描述，该页面位于[https://github.com/masterminds/glide](https://github.com/masterminds/glide)。 '
- en: go dep
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: go dep
- en: The `go dep` is a new dependency management tool being developed by the Go community.
    Right now, it requires Go 1.7 or newer to compile, and it is ready for production
    use. However, it is still undergoing changes and hasn't yet been merged into Go's
    standard library.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`go dep`是Go社区正在开发的新的依赖管理工具。现在，它需要Go 1.7或更新版本进行编译，并且已经准备好供生产使用。然而，它仍在进行更改，并且尚未合并到Go的标准库中。'
- en: Structuring a project
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目结构
- en: A project might have more than just the source code for the project, for example,
    configuration files and project documentation. Depending upon preferences, the
    way the project is structured can drastically change. However, the most important
    thing to remember is that the entry point to the whole program is through the
    `main` function, which is implemented within `main.go` as a convention.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目可能不仅仅包括项目的源代码，例如配置文件和项目文档。根据偏好，项目的结构方式可能会发生很大变化。然而，最重要的是要记住整个程序的入口是通过`main`函数，这是在`main.go`中作为约定实现的。
- en: 'The application we will be building in this book, will have the following initial
    structure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中将构建的应用程序将具有以下初始结构：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Working with book's code
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用书中的代码
- en: 'The source code discussed throughout the book can be obtained in two ways:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中讨论的源代码可以通过两种方式获得：
- en: Using `go get -u github.com/last-ent/distributed-go`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go get -u github.com/last-ent/distributed-go`
- en: Downloading the code bundle from the website and extracting it to `$GOPATH/src/github.com/last-ent/distributed-go`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网站下载代码包并将其提取到`$GOPATH/src/github.com/last-ent/distributed-go`
- en: The code for complete book should now be available at `$GOPATH/src/github.com/last-ent/distributed-go` and
    the code specific for each chapter will be available in that particular chapter
    number's directory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 完整书籍的代码现在应该可以在`$GOPATH/src/github.com/last-ent/distributed-go`中找到，每章的特定代码将在该特定章节编号的目录中找到。
- en: For example,
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，
- en: Code for Chapter 1 -> `$GOPATH/src/github.com/last-ent/distributed-go/chapter1`
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章的代码 -> `$GOPATH/src/github.com/last-ent/distributed-go/chapter1`
- en: Code for Chapter 2 -> `$GOPATH/src/github.com/last-ent/distributed-go/chapter2`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章的代码 -> `$GOPATH/src/github.com/last-ent/distributed-go/chapter2`
- en: And so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: Whenever we discuss code in any particular chapter, it is implied that we are
    in the respective chapter's folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在任何特定章节中讨论代码时，都意味着我们在相应章节的文件夹中。
- en: Containers
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器
- en: Throughout the book, we will be writing Go programs that will be compiled to
    binaries and run directly on our system. However, in the latter chapters we will
    be using `docker-compose` to build and run multiple Go applications. These applications
    can run without any real problem on our local system; however, our ultimate goal
    is to be able to run these programs on servers and to be able to access them over
    the internet.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将编写Go程序，这些程序将被编译为二进制文件，并直接在我们的系统上运行。然而，在后面的章节中，我们将使用`docker-compose`来构建和运行多个Go应用程序。这些应用程序可以在我们的本地系统上运行而没有任何真正的问题；然而，我们的最终目标是能够在服务器上运行这些程序，并能够通过互联网访问它们。
- en: 'During the 1990s and early 2000s, the standard way to deploy applications to
    the internet was to get a server instance, copy the code or binary onto the instance,
    and then start the program. This worked great for a while, but soon complications
    began to arise. Here are a few of them:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代和21世纪初，将应用程序部署到互联网的标准方式是获取服务器实例，将代码或二进制文件复制到实例上，然后启动程序。这在一段时间内运行良好，但很快就开始出现了复杂性。以下是其中一些：
- en: Code that worked on the developer's machine might not work on the server.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发人员的机器上运行的代码可能在服务器上无法运行。
- en: Programs that ran perfectly on a server instance might fail upon applying the
    latest patch to the server's OS.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器实例上运行良好的程序可能在将最新补丁应用到服务器操作系统时失败。
- en: For every new instance added as part of a service, various installation scripts
    had to be run so that we can bring the new instance to be on par with all the
    other instances. This can be a very slow process.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为服务的一部分添加每个新实例时，必须运行各种安装脚本，以便我们可以使新实例与所有其他实例保持一致。这可能是一个非常缓慢的过程。
- en: Extra care had to be taken to ensure that the new instance and all the software
    versions installed on it are compatible with the APIs being used by our program.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须特别注意确保新实例及其上安装的所有软件版本与我们的程序使用的API兼容。
- en: It was also important to ensure that all config files and important environment
    variables were copied to the new instance; otherwise, the application might fail
    with little or no clue.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还必须确保所有配置文件和重要的环境变量都被复制到新实例；否则，应用程序可能会在没有或几乎没有线索的情况下失败。
- en: Usually the version of the program that ran on local system versus test system
    versus production system were all configured differently, and this meant that
    it was possible for our application to fail on one of the three types of systems.
    If such a situation occurred, we would end up having to spend extra time and effort
    trying to figure out whether the issue is specific to one particular instance,
    one particular system, and so on.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常在本地系统上运行的程序版本与测试系统上运行的程序版本与生产系统上运行的程序版本都配置不同，这意味着我们的应用程序可能会在这三种类型的系统中的一种上失败。如果发生这种情况，我们最终将不得不花费额外的时间和精力来尝试弄清楚问题是否特定于某个实例、某个系统等等。
- en: It would be great if we could avoid such a situation from arising, in a sensible
    manner. **Containers** try to solve this problem using OS-level virtualization.
    What does this mean?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能以明智的方式避免这种情况发生，那将是很好的。**容器**试图使用操作系统级别的虚拟化来解决这个问题。这是什么意思呢？
- en: All programs and applications are run in a section of memory known as **user
    space**. This allows the operating system to ensure that a program is not able
    to cause major hardware or software issues. This allows us to recover from any
    program crashes that might occur in the user space applications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所有程序和应用程序都在称为**用户空间**的内存部分中运行。这使操作系统能够确保程序无法引起重大的硬件或软件问题。这使我们能够从用户空间应用程序中可能发生的任何程序崩溃中恢复过来。
- en: 'The real advantage of containers is that they allow us to run applications
    in isolated user spaces, and we can even customize the following attributes of
    user spaces:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的真正优势在于它们允许我们在隔离的用户空间中运行应用程序，我们甚至可以自定义用户空间的以下属性：
- en: Connected devices such as network adapters and TTY
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接的设备，如网络适配器和TTY
- en: CPU and RAM resources
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU和RAM资源
- en: Files and folders accessible from host OS
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机操作系统可访问的文件和文件夹
- en: However, how does this help us solve the problems we stated earlier? For that,
    let's take a deeper look at **Docker**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这如何帮助我们解决之前提到的问题呢？为此，让我们深入了解一下**Docker**。
- en: Docker
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker
- en: Modern software development makes extensive use of containers for product development
    and product deployment to server instances. Docker is a container technology promoted
    by Docker, Inc ([https://www.docker.com](https://www.docker.com/)), and as of
    this writing, it is the most predominantly used container technology. The other
    major alternative is **rkt** developed by CoreOS ([https://coreos.com/rkt](https://coreos.com/rkt)),
    though in this book, we will only be looking at Docker.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件开发在产品开发和产品部署到服务器实例中广泛使用容器技术。Docker是Docker, Inc（[https://www.docker.com](https://www.docker.com/)）推广的容器技术，截至目前为止，它是最广泛使用的容器技术。另一个主要的替代品是由CoreOS开发的**rkt**（[https://coreos.com/rkt](https://coreos.com/rkt)），但在本书中，我们只会关注Docker。
- en: Docker versus Virtual Machine (VM)
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Docker与虚拟机（VM）相比
- en: Looking at the description of Docker so far, we might wonder if it is yet another
    Virtual Machine. However, this is not the case, because a VM requires us to run
    a complete guest OS on top of our machine, or hypervisor, as well as all the required
    binaries. In the case of Docker, we use OS level virtualization, which allows
    us to run our containers in isolated user spaces.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，看了Docker的描述，我们可能会想它是否是另一个虚拟机。然而，这并不是这样，因为虚拟机需要我们在机器或超级用户之上运行完整的客户操作系统，以及所有所需的二进制文件。在Docker的情况下，我们使用操作系统级别的虚拟化，这允许我们在隔离的用户空间中运行我们的容器。
- en: 'The biggest advantage of a VM is that we can run different types of OSes on
    a system, for example, Windows, FreeBSD, and Linux. However, in the case of Docker,
    we can run any flavor of Linux, and the only limitation is that it has to be Linux:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: VM的最大优势是我们可以在系统上运行不同类型的操作系统，例如Windows、FreeBSD和Linux。然而，在Docker的情况下，我们可以运行任何Linux版本，唯一的限制是它必须是Linux：
- en: '![](img/c6fa5f9a-7c70-4dd4-99be-a7baebfe3499.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6fa5f9a-7c70-4dd4-99be-a7baebfe3499.png)'
- en: Docker container versus VM
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器与虚拟机
- en: The biggest advantage of Docker containers is that since it runs natively on
    Linux as a discrete process making it lightweight and unaware of all the capabilities
    of the host OS.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器的最大优势是，由于它在Linux上作为一个独立的进程运行，因此它轻量级且不知道主机操作系统的所有功能。
- en: Understanding Docker
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解Docker
- en: Before we start using Docker, let's take a brief look at how the Docker is meant
    to be used, how it is structured, and what are the major components of the complete
    system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用Docker之前，让我们简要了解一下Docker的使用方式，结构以及完整系统的主要组件是什么。
- en: 'The following list and the accompanying image should help understand the architecture
    of Docker pipeline:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表和附带的图片应该有助于理解Docker管道的架构：
- en: '**Dockerfile**: It consists of instructions on how to build an image that runs
    our program.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerfile**：它包含了构建运行我们程序的镜像的指令。'
- en: '**Docker client**: This is a command-line program used by the user to interact
    with Docker daemon.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker客户端**：这是用户用来与Docker守护程序交互的命令行程序。'
- en: '**Docker daemon**: This is the Daemon application that listens for commands
    to manage building or running containers and pushing containers to Docker registry.
    It is also responsible for configuring container networks, volumes, and so on.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker守护程序**：这是一个守护程序应用程序，用于监听管理构建或运行容器以及将容器推送到Docker注册表的命令。它还负责配置容器网络、卷等。'
- en: '**Docker images**: Docker images contain all the steps necessary to build a
    container binary that can be executed on any Linux machine with Docker installed.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker镜像**：Docker镜像包含构建可在安装了Docker的任何Linux机器上执行的容器二进制文件所需的所有步骤。'
- en: '**Docker registry**: The Docker registry is responsible for storing and retrieving
    the Docker images. We can use a public Docker registry or a private one. Docker
    Hub is used as the default Docker registry.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker注册表**：Docker注册表负责存储和检索Docker镜像。我们可以使用公共Docker注册表或私有注册表。Docker Hub被用作默认的Docker注册表。'
- en: '**Docker Container**: The Docker container is different from the Container
    we have been discussing so far. A Docker container is a runnable instance of a
    Docker image. A Docker container can be created, started, stopped, and so on.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker容器**：Docker容器与我们迄今讨论的容器不同。Docker容器是Docker镜像的可运行实例。Docker容器可以被创建、启动、停止等。'
- en: '**Docker API**: The Docker client we discussed earlier is a command-line interface
    to interact with Docker API. This means that the Docker daemon need not be running
    on the same machine as does the Docker client. The default setup that we will
    be using throughout the book talks to the Docker daemon on the local system using
    UNIX sockets or a network interface:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker API**：我们之前讨论过的Docker客户端是与Docker API交互的命令行界面。这意味着Docker守护程序不需要在与Docker客户端相同的机器上运行。本书中将使用的默认设置是使用UNIX套接字或网络接口与本地系统上的Docker守护程序通信：'
- en: '![](img/142493fb-c42c-4468-994f-7ff76fcd91e4.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/142493fb-c42c-4468-994f-7ff76fcd91e4.png)'
- en: Docker architecture
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Docker架构
- en: Testing Docker setup
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试Docker设置
- en: Let's ensure that our Docker setup works perfectly. For our purpose, Docker
    Community Edition should suffice ([https://www.docker.com/community-edition](https://www.docker.com/community-edition)).
    Once we have it installed, we will check if it works by running a few basic commands.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们的Docker设置完美运行。对于我们的目的，Docker社区版应该足够了([https://www.docker.com/community-edition](https://www.docker.com/community-edition))。安装完成后，我们将通过运行一些基本命令来检查它是否正常工作。
- en: 'Let''s start by checking what version we have installed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先检查我们安装了什么版本：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s try to dig deeper into details about our Docker installation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着深入了解一下我们的Docker安装的细节：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On Linux, when you try to run docker commands, you might get **Permission denied** error.
    In order to interact with Docker, you can either prefix the command with `sudo`
    or you can create a "docker" user group and add your user to this group. See link
    for more details [https://docs.docker.com/install/linux/linux-postinstall/.](https://docs.docker.com/install/linux/linux-postinstall/)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，当您尝试运行docker命令时，可能会出现**Permission denied**错误。为了与Docker交互，您可以在命令前加上`sudo`，或者您可以创建一个“docker”用户组并将您的用户添加到该组中。有关更多详细信息，请参阅链接[https://docs.docker.com/install/linux/linux-postinstall/.](https://docs.docker.com/install/linux/linux-postinstall/)
- en: 'Let''s try to run a Docker image. If you remember the discussion regarding
    the Docker registry, you know that we do not need to build a Docker image using
    Dockerfile, to run a Docker container. We can directly pull it from Docker Hub
    (the default Docker registry) and run the image as a container:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行一个Docker镜像。如果您还记得关于Docker注册表的讨论，您就知道我们不需要使用Dockerfile构建Docker镜像，就可以运行Docker容器。我们可以直接从Docker
    Hub（默认的Docker注册表）拉取它并将镜像作为容器运行：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding command could also have been executed, as shown here though,
    merely using `docker run ...`, which is more convenient:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令也可以像这样执行，只需使用`docker run ...`，这更方便：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we have a long set of built images, we can list them all and similarly
    for Docker containers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一长串构建的镜像，我们可以列出它们所有，同样也适用于Docker容器：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, it is important to note that as we keep using docker to build and
    run images and containers, we will start creating a backlog of "dangling" images,
    which we might not really use again. However, they will end up eating storage
    space. In order to get rid of such "dangling" images, we can use the following
    command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得注意的是，随着我们不断使用docker来构建和运行镜像和容器，我们将开始创建一堆“悬空”的镜像，我们可能不会再真正使用。但是，它们最终会占用存储空间。为了摆脱这样的“悬空”镜像，我们可以使用以下命令：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Dockerfile
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Dockerfile
- en: Now that we have the basics of Docker under our belt, let's look at the `Dockerfile` file
    we will be using as a template in this book.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了Docker的基础知识，让我们来看看在本书中将用作模板的`Dockerfile`文件。
- en: 'Next, let''s look at an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一个例子：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: main.go
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: main.go
- en: 'Let''s create a bare minimum Go program so that we can use it in the Docker
    image. It will take the `NAME` environmental variable and print `<NAME> is your
    uncle.` and then quit:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个最基本的Go程序，这样我们就可以在Docker镜像中使用它。它将获取`NAME`环境变量并打印`<NAME> is your uncle.`然后退出：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have all the code in place, let''s build the Docker image using
    the `Dockerfile` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经把所有的代码都放好了，让我们使用`Dockerfile`文件构建Docker镜像：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Testing in Go
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Go中进行测试
- en: Testing is an important part of programming, whether it is in Go or in any other
    language. Go has a straightforward approach to writing tests, and in this section,
    we will look at some important tools to help with testing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是编程的重要部分，无论是在Go中还是在任何其他语言中。Go有一种直接的方法来编写测试，在本节中，我们将看一些重要的工具来帮助测试。
- en: 'There are certain rules and conventions we need to follow to test our code.
    They can be listed as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遵循一些规则和约定来测试我们的代码。它们可以列举如下：
- en: Source files and associated test files are placed in the same package/folder
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件和相关的测试文件放置在同一个包/文件夹中
- en: The name of the test file for any given source file is `<source-file-name>_test.go`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何给定源文件的测试文件的名称是`<source-file-name>_test.go`
- en: Test functions need to have the "Test" prefix, and the next character in the
    function name should be capitalized
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试函数需要以"Test"前缀开头，并且函数名的下一个字符应该是大写的
- en: 'In the remainder of this section, we will look at three files and their associated
    tests:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将查看三个文件及其相关的测试：
- en: '`variadic.go` and `variadic_test.go`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variadic.go`和`variadic_test.go`'
- en: '`addInt.go` and `addInt_test.go`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addInt.go`和`addInt_test.go`'
- en: '`nil_test.go` (there isn''t any source file for these tests)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nil_test.go`（这些测试没有任何源文件）'
- en: Along the way, we will introduce any further concepts we might use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将介绍我们可能使用的任何进一步的概念。
- en: variadic.go
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: variadic.go
- en: 'In order to understand the first set of tests, we need to understand what a
    variadic function is and how Go handles it. Let''s start with the definition:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解第一组测试，我们需要了解什么是变参函数以及Go如何处理它。让我们从定义开始：
- en: '*Variadic function is a function that can accept any number of arguments during
    function call.*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*Variadic函数是在函数调用期间可以接受任意数量的参数的函数。*'
- en: Given that Go is a statically typed language, the only limitation imposed by
    the type system on a variadic function is that the indefinite number of arguments
    passed to it should be of the same data type. However, this does not limit us
    from passing other variable types. The arguments are received by the function
    as a slice of elements if arguments are passed, else `nil`, when none are passed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Go是一种静态类型语言，对变参函数的唯一限制是传递给它的不定数量的参数应该是相同的数据类型。但是，这并不限制我们传递其他变量类型。如果传递了参数，则函数将接收到一个元素的切片，否则为`nil`。
- en: 'Let''s look at the code to get a better idea:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下代码，以便更好地理解：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use the `...` prefix before the data type to define a functions as a variadic
    function. Note that we can have only one variadic parameter per function and it
    has to be the last parameter. We can see this error if we uncomment the line for
    `badVariadic` and try to test the code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在数据类型之前使用`...`前缀来定义函数作为变参函数。请注意，每个函数只能有一个变参参数，并且它必须是最后一个参数。如果我们取消注释`badVariadic`行并尝试测试代码，我们会看到这个错误。
- en: variadic_test.go
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: variadic_test.go
- en: 'We would like to test the two valid functions, `simpleVariadicToSlice` and `mixedVariadicToSlice`,
    for various rules defined in the previous section. However, for the sake of brevity,
    we will test these:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要测试两个有效的函数，`simpleVariadicToSlice`和`mixedVariadicToSlice`，以验证前一节中定义的各种规则。但是，为了简洁起见，我们将测试这些：
- en: '`simpleVariadicToSlice`: This is for no arguments, three arguments, and also
    to look at how to pass a slice to a variadic function'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simpleVariadicToSlice`：这是为了没有参数，三个参数，以及查看如何将切片传递给变参函数'
- en: '`mixedVariadicToSlice`: This is to accept a simple argument and a variadic
    argument'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mixedVariadicToSlice`：这是为了接受一个简单的参数和一个变参参数'
- en: 'Let''s now look at the code to test these two functions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下测试这两个函数的代码：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Running tests in variadic_test.go
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`variadic_test.go`中运行测试
- en: 'Let''s run these tests and see the output. We''ll use the `-v` flag while running
    the tests to see the output of each individual test:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这些测试并查看输出。在运行测试时，我们将使用`-v`标志来查看每个单独测试的输出：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: addInt.go
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: addInt.go
- en: The tests in `variadic_test.go` elaborated on the rules for the variadic function.
    However, you might have noticed that `TestSimpleVariadicToSlice` ran three tests
    in its function body, but `go test` treats it as a single test. Go provides a
    good way to run multiple tests within a single function, and we shall look them
    in `addInt_test.go`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`variadic_test.go`中的测试详细说明了变参函数的规则。但是，您可能已经注意到`TestSimpleVariadicToSlice`在其函数体中运行了三个测试，但`go
    test`将其视为单个测试。Go提供了一种很好的方法来在单个函数内运行多个测试，我们将在`addInt_test.go`中查看它们。'
- en: 'For this example, we will use a very simple function as shown in this code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用一个非常简单的函数，如下所示：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: addInt_test.go
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: addInt_test.go
- en: You might have also noticed in `TestSimpleVariadicToSlice` that we duplicated
    a lot of logic, while the only varying factor was the input and expected values.
    One style of testing, known as **Table-driven development**, defines a table of
    all the required data to run a test, iterates over the "rows" of the table and
    runs tests against them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还注意到在`TestSimpleVariadicToSlice`中，我们重复了很多逻辑，而唯一变化的因素是输入和期望值。一种测试风格，称为**表驱动开发**，定义了运行测试所需的所有数据的表，迭代表的“行”，并对它们运行测试。
- en: 'Let''s look at the tests we will be testing against no arguments and variadic
    arguments:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们将要测试的没有参数和变参参数：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Running tests in addInt_test.go
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在addInt_test.go中运行测试
- en: 'Let''s now run the tests in this file, and we are expecting each of the row
    in the `testCases` table, which we ran, to be treated as a separate test:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行这个文件中的测试，并且我们期望`testCases`表中的每一行被视为一个单独的测试：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: nil_test.go
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: nil_test.go
- en: 'We can also create tests that are not specific to any particular source file;
    the only criteria is that the filename needs to have the `<text>_test.go` form. The
    tests in `nil_test.go` elucidate on some useful features of the language which
    the developer might find useful while writing tests. They are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建不特定于任何特定源文件的测试；唯一的标准是文件名需要采用`<text>_test.go`的形式。`nil_test.go`中的测试阐明了语言的一些有用特性，开发人员在编写测试时可能会发现有用。它们如下：
- en: '`httptest.NewServer`*:* Imagine the case where we have to test our code against
    a server that sends back some data. Starting and coordinating a full blown server
    to access some data is hard. The `http.NewServer` solves this issue for us.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httptest.NewServer`*:* 想象一下我们需要针对发送数据的服务器测试我们的代码的情况。启动和协调一个完整的服务器来访问一些数据是困难的。`http.NewServer`为我们解决了这个问题。'
- en: '`t.Helper`: If we use the same logic to pass or fail a lot of `testCases`,
    it would make sense to segregate this logic into a separate function. However,
    this would skew the test run call stack. We can see this by commenting `t.Helper()`
    in the tests and rerunning `go test`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Helper`：如果我们使用相同的逻辑来通过或失败很多`testCases`，将这个逻辑分离到一个单独的函数中是有意义的。然而，这会扭曲测试运行调用堆栈。我们可以通过注释测试中的`t.Helper()`并重新运行`go
    test`来看到这一点。'
- en: We can also format our command-line output to print pretty results. We will
    show a simple example of adding a tick mark for passed cases and cross mark for
    failed cases.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以格式化我们的命令行输出以打印漂亮的结果。我们将展示一个简单的例子，为通过的案例添加一个勾号，为失败的案例添加一个叉号。
- en: 'In the test, we will run a test server, make GET requests on it, and then test
    the expected output versus actual output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们将运行一个测试服务器，在其上进行GET请求，然后测试预期输出与实际输出：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running tests in nil_test.go
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在nil_test.go中运行测试
- en: 'We run three tests, where two test cases will pass and one will fail. This
    way we can see the tick mark and cross mark in action:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了三个测试，其中两个测试案例将通过，一个将失败。这样我们就可以看到勾号和叉号的效果。
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started by looking at the fundamental setup for running
    Go projects successfully. Then we looked at how to install dependencies for our
    Go projects and how to structure our project. We also looked at the important
    concepts behind Containers, what problems they solve, and how we will be using
    them in the book along with an example. Next, we looked at how to write tests
    in Go, and along the way, we learned a few interesting concepts when dealing with
    a variadic function and other useful test functions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先看了成功运行Go项目的基本设置。然后我们看了如何为我们的Go项目安装依赖以及如何构建项目结构。我们还研究了容器背后的重要概念，它们解决了什么问题，以及我们将如何在本书中使用它们以及一个示例。接下来，我们看了如何在Go中编写测试，并且在这个过程中，我们学到了一些有趣的概念，比如处理可变参数函数和其他有用的测试函数。
- en: In the next chapter, we will start looking at one of the core fundamentals of
    Go programming—goroutines and the important details to keep in mind when using
    them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始研究Go编程的核心基础之一——goroutines以及在使用它们时需要牢记的重要细节。
