["```go\npackage main \n\nimport ( \n    \"fmt\" \n) \n\n// Simple individual tasks \nfunc makeHotelReservation() { \n    fmt.Println(\"Done making hotel reservation.\") \n} \nfunc bookFlightTickets() { \n    fmt.Println(\"Done booking flight tickets.\") \n} \nfunc orderADress() { \n    fmt.Println(\"Done ordering a dress.\") \n} \nfunc payCreditCardBills() { \n    fmt.Println(\"Done paying Credit Card bills.\") \n} \n\n// Tasks that will be executed in parts \n\n// Writing Mail \nfunc writeAMail() { \n    fmt.Println(\"Wrote 1/3rd of the mail.\") \n    continueWritingMail1() \n} \nfunc continueWritingMail1() { \n    fmt.Println(\"Wrote 2/3rds of the mail.\") \n    continueWritingMail2() \n} \nfunc continueWritingMail2() { \n    fmt.Println(\"Done writing the mail.\") \n} \n\n// Listening to Audio Book \nfunc listenToAudioBook() { \n    fmt.Println(\"Listened to 10 minutes of audio book.\") \n    continueListeningToAudioBook() \n} \nfunc continueListeningToAudioBook() { \n    fmt.Println(\"Done listening to audio book.\") \n} \n\n// All the tasks we want to complete in the day. \n// Note that we do not include the sub tasks here. \nvar listOfTasks = []func(){ \n    makeHotelReservation, bookFlightTickets, orderADress, \n    payCreditCardBills, writeAMail, listenToAudioBook, \n} \n\nfunc main() { \n    for _, task := range listOfTasks { \n        task() \n    } \n} \n```", "```go\nDone making hotel reservation.\nDone booking flight tickets.\nDone ordering a dress.\nDone paying Credit Card bills.\nWrote 1/3rd of the mail.\nWrote 2/3rds of the mail.\nDone writing the mail.\nListened to 10 minutes of audio book.\nDone listening to audio book.\n```", "```go\n/******************************************************************** \n  We start by making Writing Mail & Listening Audio Book concurrent. \n*********************************************************************/ \n// Tasks that will be executed in parts \n\n// Writing Mail \nfunc writeAMail() { \n    fmt.Println(\"Wrote 1/3rd of the mail.\") \n    go continueWritingMail1()  // Notice the addition of 'go' keyword. \n} \nfunc continueWritingMail1() { \n    fmt.Println(\"Wrote 2/3rds of the mail.\") \n    go continueWritingMail2()  // Notice the addition of 'go' keyword. \n} \nfunc continueWritingMail2() { \n    fmt.Println(\"Done writing the mail.\") \n} \n\n// Listening to Audio Book \nfunc listenToAudioBook() { \n    fmt.Println(\"Listened to 10 minutes of audio book.\") \n    go continueListeningToAudioBook()  // Notice the addition of 'go'   keyword. \n} \nfunc continueListeningToAudioBook() { \n    fmt.Println(\"Done listening to audio book.\") \n} \n```", "```go\nDone making hotel reservation.\nDone booking flight tickets.\nDone ordering a dress.\nDone paying Credit Card bills.\nWrote 1/3rd of the mail.\nListened to 10 minutes of audio book.\n```", "```go\npackage main \n\nimport ( \n    \"fmt\" \n    \"sync\" \n) \n\n// Simple individual tasks \nfunc makeHotelReservation(wg *sync.WaitGroup) { \n    fmt.Println(\"Done making hotel reservation.\") \n    wg.Done()\n} \nfunc bookFlightTickets(wg *sync.WaitGroup) { \n    fmt.Println(\"Done booking flight tickets.\") \n    wg.Done() \n} \nfunc orderADress(wg *sync.WaitGroup) { \n    fmt.Println(\"Done ordering a dress.\") \n    wg.Done() \n} \nfunc payCreditCardBills(wg *sync.WaitGroup) { \n    fmt.Println(\"Done paying Credit Card bills.\") \n    wg.Done() \n} \n\n// Tasks that will be executed in parts \n\n// Writing Mail \nfunc writeAMail(wg *sync.WaitGroup) { \n    fmt.Println(\"Wrote 1/3rd of the mail.\") \n    go continueWritingMail1(wg) \n} \nfunc continueWritingMail1(wg *sync.WaitGroup) { \n    fmt.Println(\"Wrote 2/3rds of the mail.\") \n    go continueWritingMail2(wg) \n} \nfunc continueWritingMail2(wg *sync.WaitGroup) { \n    fmt.Println(\"Done writing the mail.\") \n    wg.Done() \n} \n\n// Listening to Audio Book \nfunc listenToAudioBook(wg *sync.WaitGroup) { \n    fmt.Println(\"Listened to 10 minutes of audio book.\") \n    go continueListeningToAudioBook(wg) \n} \nfunc continueListeningToAudioBook(wg *sync.WaitGroup) { \n    fmt.Println(\"Done listening to audio book.\") \n    wg.Done() \n} \n\n// All the tasks we want to complete in the day. \n// Note that we do not include the sub tasks here. \nvar listOfTasks = []func(*sync.WaitGroup){ \n    makeHotelReservation, bookFlightTickets, orderADress, \n    payCreditCardBills, writeAMail, listenToAudioBook, \n} \n\nfunc main() { \n    var waitGroup sync.WaitGroup \n    // Set number of effective goroutines we want to wait upon \n    waitGroup.Add(len(listOfTasks)) \n\n    for _, task := range listOfTasks{ \n        // Pass reference to WaitGroup instance \n        // Each of the tasks should call on WaitGroup.Done() \n        task(&waitGroup) \n    } \n    // Wait until all goroutines have completed execution. \n    waitGroup.Wait() \n}\n```", "```go\nDone making hotel reservation.\nDone booking flight tickets.\nDone ordering a dress.\nDone paying Credit Card bills.\nWrote 1/3rd of the mail.\nListened to 10 minutes of audio book.\nDone listening to audio book.\nWrote 2/3rds of the mail.\nDone writing the mail.\n```", "```go\nfunc main() { \n    var waitGroup sync.WaitGroup \n    // Set number of effective goroutines we want to wait upon \n    waitGroup.Add(len(listOfTasks)) \n\n    for _, task := range listOfTasks { \n        // Pass reference to WaitGroup instance \n        // Each of the tasks should call on WaitGroup.Done() \n        go task(&waitGroup) // Achieving maximum concurrency \n    } \n\n    // Wait until all goroutines have completed execution. \n    waitGroup.Wait() \n```", "```go\nListened to 10 minutes of audio book.\nDone listening to audio book.\nDone booking flight tickets.\nDone ordering a dress.\nDone paying Credit Card bills.\nWrote 1/3rd of the mail.\nWrote 2/3rds of the mail.\nDone writing the mail.\nDone making hotel reservation.\n```", "```go\npackage main \n\nimport ( \n    \"fmt\" \n    \"sync\" \n    \"time\" \n) \n\nfunc printTime(msg string) { \n    fmt.Println(msg, time.Now().Format(\"15:04:05\")) \n} \n\n// Task that will be done over time \nfunc writeMail1(wg *sync.WaitGroup) { \n    printTime(\"Done writing mail #1.\") \n    wg.Done() \n} \nfunc writeMail2(wg *sync.WaitGroup) { \n    printTime(\"Done writing mail #2.\") \n    wg.Done() \n} \nfunc writeMail3(wg *sync.WaitGroup) { \n    printTime(\"Done writing mail #3.\") \n    wg.Done() \n} \n\n// Task done in parallel \nfunc listenForever() { \n    for { \n        printTime(\"Listening...\") \n    } \n} \n\nfunc main() { \n    var waitGroup sync.WaitGroup \n    waitGroup.Add(3) \n\n    go listenForever() \n\n    // Give some time for listenForever to start \n    time.Sleep(time.Nanosecond * 10) \n\n    // Let's start writing the mails \n    go writeMail1(&waitGroup) \n    go writeMail2(&waitGroup) \n    go writeMail3(&waitGroup) \n\n    waitGroup.Wait() \n} \n```", "```go\nDone writing mail #3\\. 19:32:57\nListening... 19:32:57\nListening... 19:32:57\nDone writing mail #1\\. 19:32:57\nListening... 19:32:57\nListening... 19:32:57\nDone writing mail #2\\. 19:32:57\n```", "```go\n// Denoted as G in runtime \ntype g struct { \n    stack         stack // offset known to runtime/cgo \n    m               *m    // current m; offset known to arm liblink \n    goid           int64 \n    waitsince   int64   // approx time when the g become blocked \n    waitreason string  // if status==Gwaiting \n    gopc          uintptr // pc of go statement that created this goroutine \n    startpc       uintptr // pc of goroutine function \n    timer         *timer  // cached timer for time.Sleep \n\n    // ... \n} \n```", "```go\n// Denoted as M in runtime \ntype m struct { \n    g0               *g         // goroutine with scheduling stack \n    tls               [6]uintptr // thread-local storage (for x86 extern register) \n    curg            *g         // current running goroutine \n    p                 puintptr   // attached p for executing go code (nil if not executing go code) \n    id                 int32 \n    createstack [32]uintptr // stack that created this thread. \n    spinning      bool        // m is out of work and is actively looking for work \n\n    // ... \n} \n```", "```go\n// Denoted as P in runtime code \ntype p struct { \n    id     int32 \n    m     muintptr // back-link to associated m (nil if idle) \n    runq [256]guintptr \n\n    //... \n} \n```", "```go\npackage main \n\nimport ( \n    \"fmt\" \n    \"sync\" \n) \n\nfunc simpleFunc(index int, wg *sync.WaitGroup) { \n    // This line should fail with Divide By Zero when index = 10 \n    fmt.Println(\"Attempting x/(x-10) where x = \", index, \" answer is : \", index/(index-10)) \n    wg.Done() \n} \n\nfunc main() { \n    var wg sync.WaitGroup \n    wg.Add(40) \n    for i := 0; i < 40; i += 1 { \n        go func(j int) { \n            simpleFunc(j, &wg) \n        }(i) \n    } \n\n    wg.Wait() \n}\n```", "```go\nAttempting x/(x-10) where x = 39 answer is : 1 Attempting x/(x-10) where x = 20 answer is : 2... Attempting x/(x-10) where x = 37 answer is : 1 Attempting x/(x-10) where x = 11 answer is : 11 panic: runtime error: integer divide by zerogoroutine 15 [running]:main.simpleFunc(0xa, 0xc42000e280) ...exit status 2\n```", "```go\npackage main \n\nimport ( \n    \"fmt\" \n    \"sync\" \n) \n\nfunc simpleFunc(index int, wg *sync.WaitGroup) { \n    // functions with defer keyword are executed at the end of the function \n    // regardless of whether the function was executed successfully or not. \n    defer func() { \n        if r := recover(); r != nil { \n            fmt.Println(\"Recovered from\", r) \n        } \n    }() \n\n    // We have changed the order of when wg.Done is called because \n    // we should call upon wg.Done even if the following line fails. \n    // Whether a defer function exists or not is dependent on whether it is registered \n    // before or after the failing line of code. \n    defer wg.Done() \n    // This line should fail with Divide By Zero when index = 10 \n    fmt.Println(\"Attempting x/(x-10) where x = \", index, \" answer is : \", index/(index-10)) \n} \n\nfunc main() { \n    var wg sync.WaitGroup \n    wg.Add(40) \n    for i := 0; i < 40; i += 1 { \n        go func(j int) { \n            simpleFunc(j, &wg) \n        }(i) \n    } \n\n    wg.Wait() \n}\n```", "```go\nAttempting x/(x-10) where x = 39 answer is : 1 Attempting x/(x-10) where x = 14 answer is : 3 Recovered from runtime error: integer divide by zero Attempting x/(x-10) where x = 3 answer is : 0 ...Attempting x/(x-10) where x = 29 answer is : 1 Attempting x/(x-10) where x = 9 answer is : -9 \n```", "```go\nDone writing mail #3\\. 19:32:57\nListening... 19:32:57\nListening... 19:32:57\nDone writing mail #1\\. 19:32:57\nListening... 19:32:57\nListening... 19:32:57\nDone writing mail #2\\. 19:32:57\n```"]