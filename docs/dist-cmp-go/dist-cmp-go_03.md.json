["```go\n// cashier.go \npackage main \n\nimport ( \n    \"fmt\" \n    \"sync\" \n) \n\nfunc main() { \n    var wg sync.WaitGroup \n    // ordersProcessed & cashier are declared in main function \n    // so that cashier has access to shared state variable 'ordersProcessed'. \n    // If we were to declare the variable inside the 'cashier' function, \n    // then it's value would be set to zero with every function call. \n    ordersProcessed := 0 \n    cashier := func(orderNum int) { \n        if ordersProcessed < 10 { \n            // Cashier is ready to serve! \n            fmt.Println(\"Processing order\", orderNum) \n            ordersProcessed++ \n        } else { \n            // Cashier has reached the max capacity of processing orders. \n            fmt.Println(\"I am tired! I want to take rest!\", orderNum) \n        } \n        wg.Done() \n    } \n\n    for i := 0; i < 30; i++ { \n        // Note that instead of wg.Add(60), we are instead adding 1 \n        // per each loop iteration. Both are valid ways to add to WaitGroup as long as we can ensure the right number of calls. \n        wg.Add(1) \n        go func(orderNum int) { \n            // Making an order \n            cashier(orderNum) \n        }(i) \n\n    } \n    wg.Wait() \n} \n```", "```go\nProcessing order 29\nProcessing order 22\nProcessing order 23\nProcessing order 13\nProcessing order 24\nProcessing order 25\nProcessing order 21\nProcessing order 26\nProcessing order 0\nProcessing order 27\nProcessing order 14\nI am tired! I want to take rest! 28\nI am tired! I want to take rest! 1\nI am tired! I want to take rest! 7\nI am tired! I want to take rest! 8\nI am tired! I want to take rest! 2\nI am tired! I want to take rest! 15\n...\n```", "```go\n// wochan.go \n\npackage main \n\nimport ( \n   \"fmt\" \n   \"sync\" \n) \n\nfunc createCashier(cashierID int, wg *sync.WaitGroup) func(int) { \n   ordersProcessed := 0 \n   return func(orderNum int) { \n         if ordersProcessed < 10 { \n               // Cashier is ready to serve! \n               //fmt.Println(\"Cashier \", cashierID, \"Processing order\", orderNum, \"Orders Processed\", ordersProcessed) \n               fmt.Println(cashierID, \"->\", ordersProcessed) \n               ordersProcessed++ \n         } else { \n               // Cashier has reached the max capacity of processing orders. \n               fmt.Println(\"Cashier \", cashierID, \"I am tired! I want to take rest!\", orderNum) \n         } \n         wg.Done() \n   } \n} \n\nfunc main() { \n   cashierIndex := 0 \n   var wg sync.WaitGroup \n\n   // cashier{1,2,3} \n   cashiers := []func(int){} \n   for i := 1; i <= 3; i++ { \n         cashiers = append(cashiers, createCashier(i, &wg)) \n   } \n\n   for i := 0; i < 30; i++ { \n         wg.Add(1) \n\n         cashierIndex = cashierIndex % 3 \n\n         func(cashier func(int), i int) { \n               // Making an order \n               go cashier(i) \n         }(cashiers[cashierIndex], i) \n\n         cashierIndex++ \n   } \n   wg.Wait() \n} \n```", "```go\nCashier 2 Processing order 7\nCashier 1 Processing order 6\nCashier 3 Processing order 8\nCashier 3 Processing order 29\nCashier 1 Processing order 9\nCashier 3 Processing order 2\nCashier 2 Processing order 10\nCashier 1 Processing order 3\n...\n```", "```go\n     3 -> 0\n     3 -> 1\n     1 -> 0\n     ...\n     2 -> 3\n     3 -> 1 # Cashier 3 sees ordersProcessed as 1 but three lines above, Cashier 3 \n was at ordersProcessed == 4!\n     3 -> 5\n     1 -> 4\n     1 -> 4 # Cashier 1 sees ordersProcessed == 4 twice.\n     2 -> 4\n     2 -> 4 # Cashier 2 sees ordersProcessed == 4 twice.\n     ...\n```", "```go\n      $ go run -race wochan.go \n      Cashier 1 Processing order 0\n      Cashier 2 Processing order 1\n      ==================\n      WARNING: DATA RACE\n      Cashier 3 Processing order 2\n      Read at 0x00c4200721a0 by goroutine 10:\n      main.createCashier.func1()\n     wochan.go:11 +0x73\n\n      Previous write at 0x00c4200721a0 by goroutine 7:\n      main.createCashier.func1()\n     wochan.go:14 +0x2a7\n\n      Goroutine 10 (running) created at:\n      main.main.func1()\n     wochan.go:40 +0x4a\n      main.main()\n     wochan.go:41 +0x26e\n\n      Goroutine 7 (finished) created at:\n      main.main.func1()\n     wochan.go:40 +0x4a\n      main.main()\n     wochan.go:41 +0x26e\n      ==================\n      Cashier 2 Processing order 4\n      Cashier 3 Processing order 5\n      ==================\n      WARNING: DATA RACE\n      Read at 0x00c420072168 by goroutine 9:\n      main.createCashier.func1()\n     wochan.go:11 +0x73\n\n      Previous write at 0x00c420072168 by goroutine 6:\n      main.createCashier.func1()\n     wochan.go:14 +0x2a7\n\n      Goroutine 9 (running) created at:\n      main.main.func1()\n     wochan.go:40 +0x4a\n      main.main()\n     wochan.go:41 +0x26e\n\n      Goroutine 6 (finished) created at:\n      main.main.func1()\n     wochan.go:40 +0x4a\n      main.main()\n     wochan.go:41 +0x26e\n      ==================\n      Cashier 1 Processing order 3\n      Cashier 1 Processing order 6\n      Cashier 2 Processing order 7\n      Cashier 3 Processing order 8\n      ...\n      Found 2 data race(s)\n      exit status 66\n```", "```go\n// simchan.go \npackage main \n\nimport \"fmt\" \n\n// helloChan waits on a channel until it gets some data and then prints the value. \nfunc helloChan(ch <- chan string) { \n    val := <- ch \n    fmt.Println(\"Hello, \", val) \n} \n\nfunc main() { \n    // Creating a channel \n    ch := make(chan string) \n\n    // A Goroutine that receives data from a channel \n    go helloChan(ch) \n\n    // Sending data to a channel. \n    ch <- \"Bob\" \n} \n```", "```go\nHello, Bob\n```", "```go\n// wichan.go \npackage main \n\nimport ( \n    \"fmt\" \n    \"sync\" \n) \n\nfunc cashier(cashierID int, orderChannel <-chan int, wg *sync.WaitGroup) { \n    // Process orders upto limit. \n    for ordersProcessed := 0; ordersProcessed < 10; ordersProcessed++ { \n        // Retrieve order from orderChannel \n        orderNum := <-orderChannel \n\n        // Cashier is ready to serve! \n        fmt.Println(\"Cashier \", cashierID, \"Processing order\", orderNum, \"Orders Processed\", ordersProcessed) \n        wg.Done() \n    } \n} \n\nfunc main() { \n    var wg sync.WaitGroup \n    wg.Add(30) \n    ordersChannel := make(chan int) \n\n    for i := 0; i < 3; i++ { \n        // Start the three cashiers \n        func(i int) { \n            go cashier(i, ordersChannel, &wg) \n        }(i) \n    } \n\n    // Start adding orders to be processed. \n    for i := 0; i < 30; i++ { \n        ordersChannel <- i \n    } \n    wg.Wait() \n} \n```", "```go\n$ go run -race wichan.go \nCashier 2 Processing order 2 Orders Processed 0\nCashier 2 Processing order 3 Orders Processed 1\nCashier 0 Processing order 0 Orders Processed 0\nCashier 1 Processing order 1 Orders Processed 0\n...\nCashier 0 Processing order 27 Orders Processed 9\n```", "```go\n// elems.go \npackage main \n\nimport \"fmt\" \n\nfunc main() { \n    // Let's create three simple functions that take an int argument \n    fcn1 := func(i int) { \n        fmt.Println(\"fcn1\", i) \n    } \n    fcn2 := func(i int) { \n        fmt.Println(\"fcn2\", i*2) \n    } \n    fcn3 := func(i int) { \n        fmt.Println(\"fcn3\", i*3) \n    } \n\n    ch := make(chan func(int)) // Channel that sends & receives functions that take an int argument \n    done := make(chan bool)    // A Channel whose element type is a boolean value. \n\n    // Launch a goroutine to work with the channels ch & done. \n    go func() { \n        // We accept all incoming functions on Channel ch and call the functions with value 10\\. \n        for fcn := range ch { \n            fcn(10) \n        } \n        // Once the loop terminates, we print Exiting and send true to done Channel. \n        fmt.Println(\"Exiting\") \n        done <- true \n    }() \n\n    // Sending functions to channel ch \n    ch <- fcn1 \n    ch <- fcn2 \n    ch <- fcn3 \n\n    // Close the channel once we are done sending it data. \n    close(ch) \n\n    // Wait on the launched goroutine to end. \n    <-done \n} \n```", "```go\nfcn1 10\nfcn2 20\nfcn3 30\nExiting\n```", "```go\nch := make(chan int) \ngo func() {ch <- 100}     // Send 100 into channel.                \n                             Channel: send100          \ngo func() {val := <- ch}  // Goroutine waiting on channel.        \n                             Channel: recv1         \ngo func() {val := <- ch}  // Another goroutine waiting on channel.\n                             Channel: recv2\n```", "```go\n// unichans.go \npackage main \n\nimport ( \n    \"fmt\" \n    \"sync\" \n) \n\nfunc recv(ch <-chan int, wg *sync.WaitGroup) { \n    fmt.Println(\"Receiving\", <-ch) \n    wg.Done() \n} \n\nfunc send(ch chan<- int, wg *sync.WaitGroup) { \n    fmt.Println(\"Sending...\") \n    ch <- 100 \n    fmt.Println(\"Sent\") \n    wg.Done() \n} \n\nfunc main() { \n    var wg sync.WaitGroup \n    wg.Add(2) \n\n    ch := make(chan int) \n    go recv(ch, &wg) \n    go send(ch, &wg) \n\n    wg.Wait() \n} \n```", "```go\nSending...\nReceiving 100 # (or) Sent\nSent # (or) Receiving 100  \n```", "```go\n// unichans2.go \n// ... \n// Changed function \nfunc recv(ch <-chan int, wg *sync.WaitGroup) { \n    fmt.Println(\"Receiving\", <-ch) \n    fmt.Println(\"Trying to send\") // signalling that we are going to send over channel. \n    ch <- 13                      // Sending over channel \n    wg.Done() \n} \n```", "```go\n$ go run unichans.go \n# command-line-arguments\nunichans.go:11: invalid operation: ch <- 13 (send to receive-only type <-chan int)  \n```", "```go\n// buffchan.go \npackage main \n\nimport ( \n    \"fmt\" \n    \"sync\" \n) \n\nfunc recv(ch <-chan int, wg *sync.WaitGroup) { \n    fmt.Println(\"Receiving\", <-ch) \n    wg.Done() \n} \n\nfunc send(ch chan<- int, wg *sync.WaitGroup) { \n    fmt.Println(\"Sending...\") \n    ch <- 100 \n    fmt.Println(\"Sent\") \n    wg.Done() \n} \n\nfunc main() { \n    var wg sync.WaitGroup \n    wg.Add(2) \n\n    // Using a buffered channel. \n    ch := make(chan int, 10) \n    go recv(ch, &wg) \n    go send(ch, &wg) \n\n    wg.Wait() \n} \n```", "```go\nSending...\nSent\nReceiving 100\n```", "```go\n// closed.go \npackage main \n\nimport \"fmt\" \n\ntype msg struct { \n    ID    int \n    value string \n} \n\nfunc handleIntChan(intChan <-chan int, done chan<- int) { \n    // Even though there are only 4 elements being sent via channel, we retrieve 6 values. \n    for i := 0; i < 6; i++ { \n        fmt.Println(<-intChan) \n    } \n    done <- 0 \n} \n\nfunc handleMsgChan(msgChan <-chan msg, done chan<- int) { \n    // We retrieve 6 values of element type struct 'msg'. \n    // Given that there are only 4 values in the buffered channel, \n    // the rest should be zero value of struct 'msg'. \n    for i := 0; i < 6; i++ { \n        fmt.Println(fmt.Sprintf(\"%#v\", <-msgChan)) \n    } \n    done <- 0 \n} \n\nfunc main() { \n    intChan := make(chan int) \n    done := make(chan int) \n\n    go func() { \n        intChan <- 9 \n        intChan <- 2 \n        intChan <- 3 \n        intChan <- 7 \n        close(intChan) \n    }() \n    go handleIntChan(intChan, done) \n\n    msgChan := make(chan msg, 5) \n    go func() { \n        for i := 1; i < 5; i++ { \n            msgChan <- msg{ \n                ID:    i, \n                value: fmt.Sprintf(\"VALUE-%v\", i), \n            } \n        } \n        close(msgChan) \n    }() \n    go handleMsgChan(msgChan, done) \n\n    // We wait on the two channel handler goroutines to complete. \n    <-done \n    <-done \n\n    // Since intChan is closed, this will cause a panic to occur. \n    intChan <- 100 \n} \n```", "```go\n9\n2\n3\n7\n0\n0\nmain.msg{ID:1, value:\"VALUE-1\"}\nmain.msg{ID:2, value:\"VALUE-2\"}\nmain.msg{ID:3, value:\"VALUE-3\"}\nmain.msg{ID:4, value:\"VALUE-4\"}\nmain.msg{ID:0, value:\"\"}\nmain.msg{ID:0, value:\"\"}\npanic: send on closed channel\n\ngoroutine 1 [running]:\nmain.main()\n     closed.go:58 +0x194\n\n    Process finished with exit code 2\n\n```", "```go\n// naiveMultiplexing.go \npackage main \n\nimport \"fmt\" \n\nfunc main() { \n    channels := [5](chan int){ \n        make(chan int), \n        make(chan int), \n        make(chan int), \n        make(chan int), \n        make(chan int), \n    } \n\n    go func() { \n        // Starting to wait on channels \n        for _, chX := range channels { \n            fmt.Println(\"Receiving from\", <- chX) \n        } \n    }() \n\n    for i := 1; i < 6; i++ { \n        fmt.Println(\"Sending on channel:\", i) \n        channels[i] <- 1 \n    } \n} \n```", "```go\nSending on channel: 1\nfatal error: all goroutines are asleep - deadlock!\n\ngoroutine 1 [chan send]:\nmain.main()\n /home/entux/Documents/Code/GO-WORKSPACE/src/distributed-go/ch3/naiveSwitch.go:23 +0x2b1\n\ngoroutine 5 [chan receive]:\nmain.main.func1(0xc4200160c0, 0xc420016120, 0xc420016180, 0xc4200161e0, 0xc420016240)\n GO-WORKSPACE/src/distributed-go/ch3/naiveSwitch.go:17 +0xba\ncreated by main.main\n GO-WORKSPACE/src/distributed-go/ch3/naiveSwitch.go:19 +0x18b\n\n```", "```go\n      select { \n      case <- ch1: \n        // Statements to execute if ch1 receives a message \n      case val := <- ch2: \n        // Save message received from ch2 into a variable and\n        execute statements for ch2 \n      }\n```", "```go\n      for { \n        select { \n            case <- ch1: \n            // Statements to execute if ch1 receives a message \n            case val := <- ch2: \n            // Save message received from ch2 into a variable and\n            execute statements for ch2 \n            default: \n            // Statements to execute if none of the channels has yet\n            received a message. \n        } \n      } \n```", "```go\n// multiplexing.go \n\npackage main \n\nimport ( \n    \"fmt\" \n) \n\nfunc main() { \n    ch1 := make(chan int) \n    ch2 := make(chan string) \n    ch3 := make(chan int, 3) \n    done := make(chan bool) \n    completed := make(chan bool) \n\n    ch3 <- 1 \n    ch3 <- 2 \n    ch3 <- 3 \n    go func() { \n        for { \n\n            select { \n                case <-ch1: \n                      fmt.Println(\"Received data from ch1\") \n                case val := <-ch2: \n                      fmt.Println(val) \n                case c := <-ch3: \n                      fmt.Println(c) \n                case <-done: \n                      fmt.Println(\"exiting...\") \n                      completed <- true \n                      return \n            } \n        } \n    }() \n\n    ch1 <- 100 \n    ch2 <- \"ch2 msg\" \n    // Uncomment us to avoid leaking the 'select' goroutine! \n    //close(done) \n    //<-completed \n} \n```", "```go\n1\nReceived data from ch1\n2\n3\n```", "```go\n1\n2\n3\nReceived data from ch1\nch2 msg\nexiting...\n```"]