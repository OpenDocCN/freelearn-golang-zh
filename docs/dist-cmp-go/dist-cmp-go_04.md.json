["```go\n// helloServer.go \n\npackage main \n\nimport ( \n    \"fmt\" \n    \"log\" \n    \"net/http\" \n) \n\nfunc helloWorldHandler(w http.ResponseWriter, r *http.Request) { \n    msg := fmt.Sprintf(\"Received request [%s] for path: [%s]\", r.Method, r.URL.Path) \n    log.Println(msg) \n\n    response := fmt.Sprintf(\"Hello, World! at Path: %s\", r.URL.Path) \n    fmt.Fprintf(w, response) \n} \n\nfunc main() { \n    http.HandleFunc(\"/\", helloWorldHandler) // Catch all Path \n\n    log.Println(\"Starting server at port :8080...\") \n    http.ListenAndServe(\":8080\", nil) \n} \n```", "```go\nhttp://localhost:8080/ --> Hello, World! at Path: / \nhttp://localhost:8080/asdf htt--> Hello, World! at Path: /asdf \nhttp://localhost:8080/some-path/123 --> Hello, World! at Path: /some-path/123 \n```", "```go\n2017/10/03 13:35:46 Starting server at port :8080... \n2017/10/03 13:36:01 Received request [GET] for path: [/] \n2017/10/03 13:37:22 Received request [GET] for path: [/asdf] \n2017/10/03 13:37:40 Received request [GET] for path: [/some-path/123] \n```", "```go\n{ \n    \"id\": \"string\", \n    \"title\": \"string\", \n    \"link\": \"string\" \n} \n```", "```go\n// Request \nGET \"<URL>/api/books/\" \n\n// Response \n[ \n  { \n     \"id\": \"1\", \n     \"title\": \"book1\", \n     \"link\": \"http://link-to-book-1.com\" \n   }, \n   { \n     \"id\": \"2\", \n     \"title\": \"book2\", \n     \"link\": \"http://link-to-book-2.com\" \n   } \n ] \n```", "```go\n// Request \nGET \"<URL>/api/books/1\" \n\n// Response \n{ \n   \"id\": \"1\", \n   \"title\": \"book1\", \n   \"link\": \"http://link-to-book-1.com\" \n } \n```", "```go\n// Request \nPOST \"<URL>/api/books\" \n\n// payload \n{ \n   \"title\": \"book5\", \n   \"link\": \"http://link-to-book-5.com\" \n } \n\n // response \n { \n    \"id\": \"3\", \n    \"title\": \"book5\", \n    \"link\": \"http://link-to-book-5.com\" \n  } \n```", "```go\n// Request \nPUT \"<URL>/api/books/3\" \n\n// payload \n{ \n   \"title\": \"book5\", \n   \"link\": \"http://link-to-book-15.com\" \n } \n\n // response \n { \n    \"id\": \"3\", \n    \"title\": \"book5\", \n    \"link\": \"http://link-to-book-15.com\" \n  }\n```", "```go\n  // Request \n  DELETE \"<URL>/api/books/2\" \n\n  // Response \n  [] \n```", "```go\n$ tree \n. \n\u251c\u2500\u2500 books-handler \n\u2502 \u251c\u2500\u2500 actions.go \n\u2502 \u251c\u2500\u2500 common.go \n\u2502 \u2514\u2500\u2500 handler.go \n\u2514\u2500\u2500 main.go \n\n1 directory, 5 files \n```", "```go\n// restServer/main.go \n\npackage main \n\nimport ( \n    \"fmt\" \n    \"log\" \n    \"net/http\" \n\n    booksHandler \"github.com/last-ent/distributed-go/chapter4/books-handler\" \n) \n\nfunc main() { \n    // Get state (map) for books available on REST server. \n    books := booksHandler.GetBooks() \n    log.Println(fmt.Sprintf(\"%+v\", books)) \n\n    actionCh := make(chan booksHandler.Action) \n\n    // Start goroutine responsible for handling interaction with the books map \n    go booksHandler.StartBooksManager(books, actionCh) \n\n    http.HandleFunc(\"/api/books/\", booksHandler.MakeHandler(booksHandler.BookHandler, \"/api/books/\", actionCh)) \n\n    log.Println(\"Starting server at port 8080...\") \n    http.ListenAndServe(\":8080\", nil) \n} \n```", "```go\n// restServer/books-handler/common.go \n\npackage booksHandler \n\nimport ( \n    \"encoding/json\" \n    \"fmt\" \n    \"log\" \n    \"net/http\" \n) \n\n// bookResource is used to hold all data needed to represent a Book resource in the books map. \ntype bookResource struct { \n    Id    string 'json:\"id\"' \n    Title string 'json:\"title\"' \n    Link  string 'json:\"link\"' \n} \n\n// requestPayload is used to parse request's Payload. We ignore Id field for simplicity. \ntype requestPayload struct { \n    Title string 'json:\"title\"' \n    Link  string 'json:\"link\"' \n} \n\n// response struct consists of all the information required to create the correct HTTP response. \ntype response struct { \n    StatusCode int \n    Books      []bookResource \n} \n\n// Action struct is used to send data to the goroutine managing the state (map) of books. \n// RetChan allows us to send data back to the Handler function so that we can complete the HTTP request. \ntype Action struct { \n    Id      string \n    Type    string \n    Payload requestPayload \n    RetChan chan<- response \n} \n\n// GetBooks is used to get the initial state of books represented by a map. \nfunc GetBooks() map[string]bookResource { \n    books := map[string]bookResource{} \n    for i := 1; i < 6; i++ { \n        id := fmt.Sprintf(\"%d\", i) \n        books[id] = bookResource{ \n            Id:    id, \n            Title: fmt.Sprintf(\"Book-%s\", id), \n            Link:  fmt.Sprintf(\"http://link-to-book%s.com\", id), \n        } \n    } \n    return books \n} \n\n// MakeHandler shows a common pattern used reduce duplicated code. \nfunc MakeHandler(fn func(http.ResponseWriter, *http.Request, string, string, chan<- Action), \n    endpoint string, actionCh chan<- Action) http.HandlerFunc { \n\n    return func(w http.ResponseWriter, r *http.Request) { \n        path := r.URL.Path \n        method := r.Method \n\n        msg := fmt.Sprintf(\"Received request [%s] for path: [%s]\", method, path) \n        log.Println(msg) \n\n        id := path[len(endpoint):] \n        log.Println(\"ID is \", id) \n        fn(w, r, id, method, actionCh) \n    } \n} \n\n// writeResponse uses the pattern similar to MakeHandler. \nfunc writeResponse(w http.ResponseWriter, resp response) { \n    var err error \n    var serializedPayload []byte \n\n    if len(resp.Books) == 1 { \n        serializedPayload, err = json.Marshal(resp.Books[0]) \n    } else { \n        serializedPayload, err = json.Marshal(resp.Books) \n    } \n\n    if err != nil { \n        writeError(w, http.StatusInternalServerError) \n        fmt.Println(\"Error while serializing payload: \", err) \n    } else { \n        w.Header().Set(\"Content-Type\", \"application/json\") \n        w.WriteHeader(resp.StatusCode) \n        w.Write(serializedPayload) \n    } \n} \n\n// writeError allows us to return error message in JSON format. \nfunc writeError(w http.ResponseWriter, statusCode int) { \n    jsonMsg := struct { \n        Msg  string 'json:\"msg\"' \n        Code int    'json:\"code\"' \n    }{ \n        Code: statusCode, \n        Msg:  http.StatusText(statusCode), \n    } \n\n    if serializedPayload, err := json.Marshal(jsonMsg); err != nil { \n        http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError) \n        fmt.Println(\"Error while serializing payload: \", err) \n    } else { \n        w.Header().Set(\"Content-Type\", \"application/json\") \n        w.WriteHeader(statusCode) \n        w.Write(serializedPayload) \n    } \n} \n```", "```go\n// restServer/books-handler/actions.go \n\npackage booksHandler \n\nimport ( \n    \"net/http\" \n) \n\n// actOn{GET, POST, DELETE, PUT} functions return Response based on specific Request type. \n\nfunc actOnGET(books map[string]bookResource, act Action) { \n    // These initialized values cover the case: \n    // Request asked for an id that doesn't exist. \n    status := http.StatusNotFound \n    bookResult := []bookResource{} \n\n    if act.Id == \"\" { \n\n        // Request asked for all books. \n        status = http.StatusOK \n        for _, book := range books { \n            bookResult = append(bookResult, book) \n        } \n    } else if book, exists := books[act.Id]; exists { \n\n        // Request asked for a specific book and the id exists. \n        status = http.StatusOK \n        bookResult = []bookResource{book} \n    } \n\n    act.RetChan <- response{ \n        StatusCode: status, \n        Books:      bookResult, \n    } \n} \n\nfunc actOnDELETE(books map[string]bookResource, act Action) { \n    book, exists := books[act.Id] \n    delete(books, act.Id) \n\n    if !exists { \n        book = bookResource{} \n    } \n\n    // Return the deleted book if it exists else return an empty book. \n    act.RetChan <- response{ \n        StatusCode: http.StatusOK, \n        Books:      []bookResource{book}, \n    } \n} \n\nfunc actOnPUT(books map[string]bookResource, act Action) { \n    // These initialized values cover the case: \n    // Request asked for an id that doesn't exist. \n    status := http.StatusNotFound \n    bookResult := []bookResource{} \n\n    // If the id exists, update its values with the values from the payload. \n    if book, exists := books[act.Id]; exists { \n        book.Link = act.Payload.Link \n        book.Title = act.Payload.Title \n        books[act.Id] = book \n\n        status = http.StatusOK \n        bookResult = []bookResource{books[act.Id]} \n    } \n\n    // Return status and updated resource. \n    act.RetChan <- response{ \n        StatusCode: status, \n        Books:      bookResult, \n    } \n\n} \n\nfunc actOnPOST(books map[string]bookResource, act Action, newID string) { \n     // Add the new book to 'books'. \n     books[newID] = bookResource{ \n         Id:    newID, \n         Link:  act.Payload.Link, \n         Title: act.Payload.Title, \n    } \n\n    act.RetChan <- response{ \n        StatusCode: http.StatusCreated, \n        Books:      []bookResource{books[newID]}, \n    } \n} \n```", "```go\n// restServer/books-handler/handler.go \n\npackage booksHandler \n\nimport ( \n    \"encoding/json\" \n    \"fmt\" \n    \"io/ioutil\" \n    \"log\" \n    \"net/http\" \n) \n\n// StartBooksManager starts a goroutine that changes the state of books (map). \n// Primary reason to use a goroutine instead of directly manipulating the books map is to ensure \n// that we do not have multiple requests changing books' state simultaneously. \nfunc StartBooksManager(books map[string]bookResource, actionCh <-chan Action) { \n    newID := len(books) \n    for { \n        select { \n        case act := <-actionCh: \n            switch act.Type { \n            case \"GET\": \n                actOnGET(books, act) \n            case \"POST\": \n                newID++ \n                newBookID := fmt.Sprintf(\"%d\", newID) \n                actOnPOST(books, act, newBookID) \n            case \"PUT\": \n                actOnPUT(books, act) \n            case \"DELETE\": \n                actOnDELETE(books, act) \n            } \n        }  \n    } \n} \n\n/* BookHandler is responsible for ensuring that we process only the valid HTTP Requests. \n\n * GET -> id: Any \n\n * POST -> id: No \n *      -> payload: Required \n\n * PUT -> id: Any \n *     -> payload: Required \n\n * DELETE -> id: Any \n*/ \nfunc BookHandler(w http.ResponseWriter, r *http.Request, id string, method string, actionCh chan<- Action) { \n\n     // Ensure that id is set only for valid requests \n     isGet := method == \"GET\"\n     idIsSetForPost := method == \"POST\" && id != \"\"\n     isPutOrPost := method == \"PUT\" || method == \"POST\"\n     idIsSetForDelPut := (method == \"DELETE\" || method == \"PUT\") && id != \"\"\n     if !isGet && !(idIsSetForPost || idIsSetForDelPut || isPutOrPost) {\n         writeError(w, http.StatusMethodNotAllowed) \n         return \n     } \n\n     respCh := make(chan response) \n     act := Action{ \n         Id:      id, \n         Type:    method, \n         RetChan: respCh, \n     } \n\n     // PUT & POST require a properly formed JSON payload \n     if isPutOrPost { \n         var reqPayload requestPayload \n         body, _ := ioutil.ReadAll(r.Body) \n         defer r.Body.Close() \n\n         if err := json.Unmarshal(body, &reqPayload); err != nil { \n             writeError(w, http.StatusBadRequest) \n             return \n         } \n\n         act.Payload = reqPayload \n     } \n\n     // We have all the data required to process the Request. \n     // Time to update the state of books. \n     actionCh <- act \n\n     // Wait for respCh to return data after updating the state of books. \n     // For all successful Actions, the HTTP status code will either be 200 or 201\\. \n     // Any other status code means that there was an issue with the request. \n     var resp response \n     if resp = <-respCh; resp.StatusCode > http.StatusCreated { \n         writeError(w, resp.StatusCode) \n         return \n     } \n\n     // We should only log the delete resource and not send it back to user \n     if method == \"DELETE\" { \n         log.Println(fmt.Sprintf(\"Resource ID %s deleted: %+v\", id, resp.Books)) \n         resp = response{ \n             StatusCode: http.StatusOK, \n             Books:      []bookResource{}, \n         } \n     } \n\n     writeResponse(w, resp) \n } \n```", "```go\n$ # List all books on server \n$ # Note that we use '-L' flag while using cURL. \n$ # This takes care of any http redirections that might be required. \n$ curl -L localhost:8080/api/books | jq # GET CALL \n % Total % Received % Xferd Average Speed Time Time Time Current \n Dload Upload Total Spent Left Speed \n100 46 100 46 0 0 9721 0 --:--:-- --:--:-- --:--:-- 11500 \n100 311 100 311 0 0 59589 0 --:--:-- --:--:-- --:--:-- 59589 \n[ \n { \n \"id\": \"3\", \n \"title\": \"Book-3\", \n \"link\": \"http://link-to-book3.com\" \n }, \n { \n \"id\": \"4\", \n \"title\": \"Book-4\", \n \"link\": \"http://link-to-book4.com\" \n }, \n { \n \"id\": \"5\", \n \"title\": \"Book-5\", \n \"link\": \"http://link-to-book5.com\" \n }, \n { \n \"id\": \"1\", \n \"title\": \"Book-1\", \n \"link\": \"http://link-to-book1.com\" \n }, \n { \n \"id\": \"2\", \n \"title\": \"Book-2\", \n \"link\": \"http://link-to-book2.com\" \n } \n] \n\n$ curl localhost:8080/api/books/3 | jq # GET a single resource. \n % Total % Received % Xferd Average Speed Time Time Time Current \n Dload Upload Total Spent Left Speed \n100 61 100 61 0 0 13255 0 --:--:-- --:--:-- --:--:-- 15250 \n{ \n \"id\": \"3\", \n \"title\": \"Book-3\", \n \"link\": \"http://link-to-book3.com\" \n} \n```", "```go\n$ # We can make other method calls by providing -X flag with method name in caps. \n$ curl -LX DELETE localhost:8080/api/books/2 | jq # DELETE a resource. \n % Total % Received % Xferd Average Speed Time Time Time Current \n Dload Upload Total Spent Left Speed \n100 2 100 2 0 0 337 0 --:--:-- --:--:-- --:--:-- 400 \n[] \n$ curl -L localhost:8080/api/books | jq # GET all books after resource deletion. \n % Total % Received % Xferd Average Speed Time Time Time Current \n Dload Upload Total Spent Left Speed \n100 46 100 46 0 0 21465 0 --:--:-- --:--:-- --:--:-- 46000 \n100 249 100 249 0 0 91008 0 --:--:-- --:--:-- --:--:-- 91008 \n[ \n { \n \"id\": \"5\", \n \"title\": \"Book-5\", \n \"link\": \"http://link-to-book5.com\" \n }, \n { \n \"id\": \"1\", \n \"title\": \"Book-1\", \n \"link\": \"http://link-to-book1.com\" \n }, \n { \n \"id\": \"3\", \n \"title\": \"Book-3\", \n \"link\": \"http://link-to-book3.com\" \n }, \n { \n \"id\": \"4\", \n \"title\": \"Book-4\", \n \"link\": \"http://link-to-book4.com\" \n } \n] \n```", "```go\n$ # We can use -d flag to provide payload in a Request \n$ curl -H \"Content-Type: application/json\" -LX PUT -d '{\"title\": \"New Book Title\", \"link\": \"New Link\"}' localhost:8080/api/books/4 | jq \n % Total % Received % Xferd Average Speed Time Time Time Current \n Dload Upload Total Spent Left Speed \n100 100 100 53 100 47 13289 11785 --:--:-- --:--:-- --:--:-- 17666 \n{ \n \"id\": \"4\", \n \"title\": \"New Book Title\", \n \"link\": \"New Link\" \n} \n$ curl -L localhost:8080/api/books | jq # GET all books after updating a resource \n % Total % Received % Xferd Average Speed Time Time Time Current \n Dload Upload Total Spent Left Speed \n100 46 100 46 0 0 9886 0 --:--:-- --:--:-- --:--:-- 11500 \n100 241 100 241 0 0 47024 0 --:--:-- --:--:-- --:--:-- 47024 \n[ \n { \n \"id\": \"1\", \n \"title\": \"Book-1\", \n \"link\": \"http://link-to-book1.com\" \n }, \n { \n \"id\": \"3\", \n \"title\": \"Book-3\", \n \"link\": \"http://link-to-book3.com\" \n }, \n { \n \"id\": \"4\", \n \"title\": \"New Book Title\", \n \"link\": \"New Link\" \n }, \n { \n \"id\": \"5\", \n \"title\": \"Book-5\", \n \"link\": \"http://link-to-book5.com\" \n } \n] \n```", "```go\n$ curl -H \"Content-Type: application/json\" -LX POST -d '{\"title\":\"Ultra New Book\", \"link\": \"Ultra New Link\"}' localhost:8080/api/books/ | jq # POST ie., create a new resource. \n % Total % Received % Xferd Average Speed Time Time Time Current \n Dload Upload Total Spent Left Speed \n100 111 100 59 100 52 99k 89655 --:--:-- --:--:-- --:--:-- 59000 \n{ \n \"id\": \"6\", \n \"title\": \"Ultra New Book\", \n \"link\": \"Ultra New Link\" \n} \n % Total % Received % Xferd Average Speed Time Time Time Current \n Dload Upload Total Spent Left Speed \n100 46 100 46 0 0 8234 0 --:--:-- --:--:-- --:--:-- 9200 \n100 301 100 301 0 0 46414 0 --:--:-- --:--:-- --:--:-- 46414 \n[ \n { \n \"id\": \"4\", \n \"title\": \"New Book Title\", \n \"link\": \"New Link\" \n }, \n { \n \"id\": \"5\", \n \"title\": \"Book-5\", \n \"link\": \"http://link-to-book5.com\" \n }, \n { \n \"id\": \"1\", \n \"title\": \"Book-1\", \n \"link\": \"http://link-to-book1.com\" \n }, \n { \n \"id\": \"6\", \n \"title\": \"Ultra New Book\", \n \"link\": \"Ultra New Link\" \n }, \n { \n \"id\": \"3\", \n \"title\": \"Book-3\", \n \"link\": \"http://link-to-book3.com\" \n } \n] \n```", "```go\n$ go run main.go \n2017/10/09 21:07:50 map[5:{Id:5 Title:Book-5 Link:http://link-to-book5.com} 1:{Id:1 Title:Book-1 Link:http://link-to-book1.com} 2:{Id:2 Title:Book-2 Link:http://link-to-book2.com} 3:{Id:3 Title:Book-3 Link:http://link-to-book3.com} 4:{Id:4 Title:Book-4 Link:http://link-to-book4.com}] \n2017/10/09 21:07:50 Starting server at port 8080... \n2017/10/09 21:07:56 Received request [GET] for path: [/api/books/] \n2017/10/09 21:07:56 ID is \n2017/10/09 21:09:18 Received request [GET] for path: [/api/books/3] \n2017/10/09 21:09:18 ID is 3 \n2017/10/09 21:11:38 Received request [DELETE] for path: [/api/books/2] \n2017/10/09 21:11:38 ID is 2 \n2017/10/09 21:11:38 Resource ID 2 deleted: [{Id:2 Title:Book-2 Link:http://link-to-book2.com}] \n2017/10/09 21:12:16 Received request [GET] for path: [/api/books/] \n2017/10/09 21:12:16 ID is \n2017/10/09 21:15:22 Received request [PUT] for path: [/api/books/4] \n2017/10/09 21:15:22 ID is 4 \n2017/10/09 21:16:01 Received request [GET] for path: [/api/books/] \n2017/10/09 21:16:01 ID is \n2017/10/09 21:17:07 Received request [POST] for path: [/api/books/] \n2017/10/09 21:17:07 ID is \n2017/10/09 21:17:36 Received request [GET] for path: [/api/books/] \n2017/10/09 21:17:36 ID is \n```", "```go\npackage main \n\nimport ( \n    \"bytes\" \n    \"encoding/json\" \n    \"fmt\" \n    \"io/ioutil\" \n    \"net/http\" \n) \n\ntype bookResource struct { \n    Id    string 'json:\"id\"' \n    Title string 'json:\"title\"' \n    Link  string 'json:\"link\"' \n} \n\nfunc main() { \n    // GET \n    fmt.Println(\"Making GET call.\") \n    // It is possible that we might have error while making an HTTP request \n    // due to too many redirects or HTTP protocol error. We should check for this eventuality. \n    resp, err := http.Get(\"http://localhost:8080/api/books\")\n    if err != nil {\n        fmt.Println(\"Error while making GET call.\", err) \n        return \n    } \n\n    fmt.Printf(\"%+v\\n\\n\", resp)\n\n    // The response body is a data stream from the server we got the response back from. \n    // This data stream is not in a useable format yet. \n    // We need to read it from the server and convert it into a byte stream. \n    body, _ := ioutil.ReadAll(resp.Body) \n    defer resp.Body.Close() \n\n    var books []bookResource \n    json.Unmarshal(body, &books) \n\n    fmt.Println(books) \n    fmt.Println(\"\\n\") \n\n    // POST \n    payload, _ := json.Marshal(bookResource{ \n        Title: \"New Book\", \n        Link:  \"http://new-book.com\", \n    }) \n\n    fmt.Println(\"Making POST call.\") \n    resp, err = http.Post( \n        \"http://localhost:8080/api/books/\", \n        \"application/json\", \n        bytes.NewBuffer(payload), \n    ) \n    if err != nil { \n        fmt.Println(err) \n    } \n\n    fmt.Printf(\"%+v\\n\\n\", resp)\n\n    body, _ = ioutil.ReadAll(resp.Body) \n    defer resp.Body.Close() \n\n    var book bookResource \n    json.Unmarshal(body, &book) \n\n    fmt.Println(book) \n\n    fmt.Println(\"\\n\") \n} \n```", "```go\n$ go run main.go \n\nMaking GET call. \n&{Status:200 OK StatusCode:200 Proto:HTTP/1.1 ProtoMajor:1 ProtoMinor:1 Header:map[Content-Type:[application/json] Date:[Mon, 09 Oct 2017 20:07:43 GMT] Content-Length:[488]] Body:0xc4200f0040 ContentLength:488 TransferEncoding:[] Close:false Uncompressed:false Trailer:map[] Request:0xc42000a900 TLS:<nil>} \n\n[{2 Book-2 http://link-to-book2.com} {3 Book-3 http://link-to-book3.com} {4 Book-4 http://link-to-book4.com} {5 Book-5 http://link-to-book5.com} {6 New Book http://new-book.com} {7 New Book http://new-book.com} {8 New Book http://new-book.com} {1 Book-1 http://link-to-book1.com}] \n\nMaking POST call. \n&{Status:201 Created StatusCode:201 Proto:HTTP/1.1 ProtoMajor:1 ProtoMinor:1 Header:map[Content-Type:[application/json] Date:[Mon, 09 Oct 2017 20:07:43 GMT] Content-Length:[58]] Body:0xc4200f0140 ContentLength:58 TransferEncoding:[] Close:false Uncompressed:false Trailer:map[] Request:0xc4200fc100 TLS:<nil>} \n\n{9 New Book http://new-book.com} \n```"]