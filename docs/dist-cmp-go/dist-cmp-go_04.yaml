- en: The RESTful Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful Web
- en: 'In the previous chapters, we looked at two of the most important components
    of Go—goroutines and channels. In the following chapters, we will build a distributed
    application using Go, and it is very important to understand how to write applications
    for the internet or, in our case, the web. In this chapter, we shall look at a
    particular way of building web applications using the REST web protocol. We shall
    also look at how to interact with a REST-based web application. We shall be covering
    them in the following manner:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们看了Go语言中最重要的两个组件——goroutines和channels。在接下来的章节中，我们将使用Go构建一个分布式应用程序，了解如何为互联网或者在我们的情况下是Web编写应用程序非常重要。在本章中，我们将介绍使用REST网络协议构建Web应用程序的一种特定方式。我们还将学习如何与基于REST的Web应用程序进行交互。我们将按以下方式进行介绍：
- en: A brief look at HTTP and sessions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对HTTP和会话的简要介绍
- en: Fundamentals to build a REST server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建REST服务器的基础知识
- en: Design a simple REST server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个简单的REST服务器
- en: Tools to interact with a REST server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与REST服务器交互的工具
- en: HTTP and sessions
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP和会话
- en: In this section we will take a brief look at the HTTP protocol and how it has
    evolved over time. Also discuss how servers keep track of user state using HTTP
    sessions. This knowledge will come in handy when we try to understand how REST
    protocol works.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍HTTP协议及其随时间的演变。还讨论服务器如何使用HTTP会话跟踪用户状态。当我们尝试理解REST协议的工作原理时，这些知识将会派上用场。
- en: A brief history of HTTP
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP的简要历史
- en: 'In order to better understand the advantages of the REST protocol, let us take
    a small detour into how the internet was used before the REST web protocol came
    onto the scene. The internet in 1990s was mostly used to store and share documents
    as marked up documents using **HTTP** (**Hypertext Transfer Protocol**). For this
    chapter, HTTP can be summarized as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解REST协议的优势，让我们先来了解一下REST网络协议出现之前互联网的使用方式。1990年代的互联网主要用于存储和共享使用**HTTP**（**超文本传输协议**）标记的文档。对于本章来说，HTTP可以总结如下：
- en: HTTP is a network communication protocol that starts with an HTTP request and
    ends with an HTTP response.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP是一个网络通信协议，以HTTP请求开始，以HTTP响应结束。
- en: HTTP responses during the early periods consisted of plain text documents, but
    soon the HTML format gained traction as it allowed for more stylized documents.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早期的HTTP响应由纯文本文档组成，但很快HTML格式开始流行，因为它允许更多样式化的文档。
- en: 'Web browsers brought in a new age of internet: merely displaying text documents
    with different font weights wasn''t enough. CSS and JavaScript came to the fore
    to make these documents customizable and more interactive. All these advancements
    led to what we now call the *web*.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web浏览器带来了互联网的新时代：仅仅显示不同字体权重的文本文档已经不够了。CSS和JavaScript开始出现，使这些文档可以定制化和更加交互。所有这些进步导致了我们现在所说的*web*。
- en: 'One could interact with a web server using a URL and an HTTP method. There
    are nine HTTP methods, but, for the purpose of this book, we are only interested
    in five of them:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用URL和HTTP方法与Web服务器进行交互。有九种HTTP方法，但是在本书的目的中，我们只对其中的五种感兴趣：
- en: '`GET`: This is used when sending simple HTTP requests'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：在发送简单的HTTP请求时使用'
- en: '`POST` : This is used when we want to include valuable information while sending
    HTTP requests'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：当我们想在发送HTTP请求时包含有价值的信息时使用'
- en: '`PUT`, `PATCH`, and `DELETE`: Technically, they are identical to, `POST` method,
    although they differ in functionally'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`，`PATCH`和`DELETE`：从技术上讲，它们与`POST`方法相同，尽管在功能上有所不同'
- en: We shall revisit these HTTP methods in the next section and explore them in
    greater detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节重新讨论这些HTTP方法，并对它们进行更详细的探讨。
- en: HTTP sessions
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP会话
- en: The HTTP protocol in itself is stateless; that is, it has no idea of what is
    accessing a web page, who can POST to a page, and so on. For the majority of HTTP
    servers during this period (1990s), they could be thought of as file server; that
    is, they serve static files over the internet. However, the modern web experience
    is more expansive. Consider visiting Gmail or Facebook, and the website knows
    who we are and we are shown customized content that is dynamically generated for
    us. They maintain the "state" of which article we are reading or the mail we are
    writing. If we were to close the browser and return to the website after a while,
    it can drop us right back to where we left off. Given that the HTTP protocol and
    HTTP servers are stateless, how do these websites keep track of all these things
    and link them back to the correct user? The answer is an HTTP session.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议本身是无状态的；也就是说，它不知道谁在访问网页，谁可以向页面发送POST请求等等。在这个时期（1990年代）的大多数HTTP服务器中，它们可以被视为文件服务器；也就是说，它们通过互联网提供静态文件。然而，现代的网络体验更加广泛。想象一下访问Gmail或Facebook，网站知道我们是谁，我们看到的是为我们动态生成的定制内容。它们保持我们正在阅读的文章或正在撰写的邮件的“状态”。如果我们关闭浏览器一段时间后返回网站，它可以让我们回到我们离开的地方。鉴于HTTP协议和HTTP服务器是无状态的，这些网站如何跟踪所有这些内容并将它们链接回正确的用户呢？答案是HTTP会话。
- en: When we log onto a website from a browser, we provide it with credentials to
    identify ourselves. The server responds back with a response that also consists
    of a token, which will be used to identify us in the near future. The token can
    be in the form of a session ID, cookie, authentication header, and so on. A web
    server maintains a table of such tokens and the corresponding user IDs. After
    we have logged onto a website, the browser always sends the corresponding token
    in the headers to the server with every request. As a result, the web server is
    able to keep track of each user and show correct content to any given user. How
    does the server do this? It maintains all the state information on the server
    side!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从浏览器登录网站时，我们提供凭据来识别自己。服务器回复的响应也包括一个标记，这个标记将在不久的将来用来识别我们。这个标记可以是会话ID、cookie、认证头等形式。Web服务器维护这些标记和相应的用户ID的表。在我们登录网站后，浏览器总是在每个请求中的头部发送相应的标记给服务器。因此，Web服务器能够跟踪每个用户并向任何给定的用户显示正确的内容。服务器是如何做到这一点的呢？它在服务器端维护所有的状态信息！
- en: The REST protocol
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST协议
- en: Even in the 1990s, the computers and internet technology kept advancing rapidly
    and the web browsers kept evolving simultaneously. This meant that the web servers
    themselves could start offloading some of the work to the web client; that is,
    the web browser. Slowly this began to lead developers to experiment with different
    software architectures for developing web applications. By 2010, the REST protocol
    became the most prevalent way to design a modern web application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在20世纪90年代，计算机和互联网技术仍然迅速发展，而Web浏览器也在同时不断进化。这意味着Web服务器本身可以开始将一些工作转移到Web客户端；也就是说，Web浏览器。慢慢地，这开始引导开发人员尝试不同的软件架构来开发Web应用程序。到2010年，REST协议成为设计现代Web应用程序的最普遍方式。
- en: '**REST** (**Representation State Transfer Protocol**) was first described by
    *Roy Fielding* in his seminal paper titled, *Architectural Styles and the Design
    of Network-based Software Architectures* ([https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf](https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf)).
    This way of designing a web application has many advantages. It is practical,
    efficient in CPU usage and network load, scales better for increasing internet
    traffic, and so on. The following are some of the properties and benefits of using
    REST software architecture.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**（**表述状态转移协议**）首次由*Roy Fielding*在他的开创性论文中描述，题为*基于网络的软件架构的体系结构风格和设计*（[https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf](https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf)）。这种设计Web应用程序的方式有许多优点。它是实用的，CPU使用效率高，网络负载小，对于不断增加的互联网流量更具扩展性等。以下是使用REST软件架构的一些属性和好处。'
- en: The server and client architecture
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器和客户端架构
- en: In the *HTTP sessions* section, we described a server that was doing most of
    the work and browser was responsible for relaying user inputs to the server, parsing
    the HTML document returned back from the server, and rendering it in the browser
    for the user. REST allows us to split the application into a server and client.
    A server (backend) is responsible for executing business logic, and a client (frontend)
    is responsible for communicating user interaction to the server. It might sound
    like not much has changed; however, the remaining properties of REST architecture
    will be more apparent.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在*HTTP会话*部分，我们描述了一个大部分工作都由服务器完成，浏览器负责将用户输入传递给服务器，解析服务器返回的HTML文档，并在浏览器中呈现给用户。REST允许我们将应用程序分成服务器和客户端。服务器（后端）负责执行业务逻辑，客户端（前端）负责将用户交互传递给服务器。这可能听起来并没有太多改变；然而，REST架构的其余属性将更加明显。
- en: The standard data format
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准数据格式
- en: REST revolves around the communication state and data between the backend and
    frontend using a standard data format. This results in the decoupling of backend
    and frontend. This means that we are no longer bound to using only a web browser
    to communicate with the server, and this in turn means that our servers are now
    capable of being used to interact with web applications, command-line applications,
    and so on. REST allows us to use any type of data format for communication, although
    JSON format has become the lingua franca for communication over REST protocol.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: REST围绕着使用标准数据格式在后端和前端之间通信状态和数据。这导致了后端和前端的解耦。这意味着我们不再局限于只使用Web浏览器与服务器通信，这反过来意味着我们的服务器现在能够与Web应用程序、命令行应用程序等进行交互。REST允许我们使用任何类型的数据格式进行通信，尽管JSON格式已经成为REST协议通信的通用语言。
- en: Resources
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: Since our frontend and backend are separate, we need to communicate the state
    and data between the two. In the frontend, we will need to show all available
    entities for the service we are providing. These entities are called **resources**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的前端和后端是分开的，我们需要在两者之间通信状态和数据。在前端，我们需要显示我们提供的服务的所有可用实体。这些实体被称为**资源**。
- en: Consider a server that provides us with a REST interface (REST API) that has
    a list of books in our personal library. In this case, *list of books* are resources
    and we can request information about each of them from the backend at particular
    endpoints. For our example, the endpoint can be `<URL>/api/books`. `/api` prefix
    is a convention generally used in REST applications to express that we are interacting
    with the backend URLs. The resources can generally be thought of as a collection
    of data, like rows of a database table.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个提供REST接口（REST API）的服务器，它在我们的个人图书馆中有一本书的列表。在这种情况下，*书籍列表*是资源，我们可以在特定的端点从后端请求关于每本书的信息。对于我们的例子，端点可以是`<URL>/api/books`。`/api`前缀通常在REST应用程序中使用，表示我们正在与后端URL交互。资源通常可以被认为是数据的集合，就像数据库表的行。
- en: Reusing the HTTP protocol
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重用HTTP协议
- en: We defined endpoints in the previous subsection, *Resources*, but how do we
    interact with them? REST is built on top of the HTTP protocol and it uses HTTP
    methods, or verbs in the case of REST, to interact with the server. Let's take
    our endpoint from the previous example, `/api/books`, to understand how it is
    used.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一小节*资源*中定义了端点，但是我们如何与它们交互呢？REST是建立在HTTP协议之上的，并且它使用HTTP方法或在REST的情况下使用动词来与服务器交互。让我们以前面的例子`/api/books`为例，来了解它是如何使用的。
- en: GET
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GET
- en: 'REST uses the `GET` verb to retrieve items of the specific resource type. Given
    that we have a lot of items, it is possible to retrieve a specific resource item
    and to retrieve all the available resource items. Retrieval of a specific resource
    item is generally done by providing the id of the item. The following shows the
    two forms of `GET` used for retrieval:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: REST使用`GET`动词来检索特定资源类型的项目。鉴于我们有很多项目，可以检索特定资源项目以及检索所有可用的资源项目。通常通过提供项目的id来检索特定资源项目。以下显示了用于检索的两种`GET`形式：
- en: '`/api/books`: This returns a list of all books in the library'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/books`：返回图书馆中所有书籍的列表'
- en: '`/api/books/<id>` : This returns information about a particular book in the
    library'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/books/<id>`：返回图书馆中特定书籍的信息'
- en: POST
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: POST
- en: REST uses the `POST` verb to create a new item of the specific resource type.
    Resource creation might require extra information, which is provided in the body
    of the `POST` request. The information being provided as part of the body has
    to be in the data format the REST server can handle. POSTing to `/api/books` signifies
    that we want to add a new book to the list of books in our library.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: REST使用`POST`动词来创建特定资源类型的新项目。资源创建可能需要额外的信息，这些信息在`POST`请求的正文中提供。作为正文的一部分提供的信息必须是REST服务器可以处理的数据格式。对`/api/books`进行POST表示我们想要向图书馆的书籍列表中添加一本新书。
- en: PUT and PATCH
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PUT和PATCH
- en: These take the form `/api/books/<id>`. These methods are only applicable for
    an already existing resource. They will update a given resource with the data
    or new state of the resource provided in the request's body. `PUT` expects a resource's
    new state to be provided in completion, including fields that haven't changed.
    `PATCH` can be thought of as a more relaxed version of `PUT` because we do not
    need to provide the complete new state but only the fields that need to be updated.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些采用`/api/books/<id>`的形式。这些方法仅适用于已经存在的资源。它们将使用请求的正文更新给定资源的数据或新状态。`PUT`期望提供资源的新状态，包括未更改的字段。`PATCH`可以被认为是`PUT`的更轻松版本，因为我们不需要提供完整的新状态，而只需要更新的字段。
- en: DELETE
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DELETE
- en: REST uses the `DELETE` verb to remove a specific resource item. It takes the
    form of `/api/resource/<id>`. It deletes a particular resource based on `<id>`.
    REST supports deletion of all items of a given resource type, although this doesn't
    make sense as it is now possible for a user to accidentally delete all items of
    the resource type. For this and many other reasons, no server actually implements
    this feature.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: REST使用`DELETE`动词来删除特定的资源项目。它采用`/api/resource/<id>`的形式。它根据`<id>`删除特定的资源。REST支持删除给定资源类型的所有项目，尽管这没有意义，因为现在用户可能会意外删除资源类型的所有项目。出于这个原因和许多其他原因，没有服务器实际实现这个功能。
- en: Upgradable components
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可升级的组件
- en: Consider the case where we need to make changes to the UI and this is not going
    to affect the server logic. If a website was not split according to client and
    server architecture, we would have to upgrade the complete website and this would
    be quite a time-consuming task. Thanks to the split of frontend and backend, we
    can make changes and upgrade only the required system. Thus, we can ensure minimal
    disruption of service.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们需要对UI进行更改，而这不会影响服务器逻辑的情况。如果网站没有根据客户端和服务器架构进行拆分，我们将不得不升级整个网站，这将是一项非常耗时的任务。由于前端和后端的拆分，我们可以只对所需的系统进行更改和升级。因此，我们可以确保最小的服务中断。
- en: Fundamentals of a REST server
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST服务器的基础知识
- en: Now that we have an understanding of how a REST application should behave, let's
    build one! We shall start out by first building a simple web server, then design
    the books REST server by describing design decisions and API definitions, and
    finally build a REST server based on the design.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了REST应用程序应该如何行为，让我们来构建一个吧！我们将首先构建一个简单的Web服务器，然后通过描述设计决策和API定义来设计图书REST服务器，最后根据设计构建REST服务器。
- en: A simple web server
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的Web服务器
- en: 'Go provides us with an inbuilt library for building web servers, `net/http`.
    For every endpoint we want to create on our server, we have to do two things:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Go为我们提供了一个内置的用于构建Web服务器的库，`net/http`。对于我们想要在服务器上创建的每个端点，我们必须做两件事：
- en: Create a handler function for the endpoint, which accepts two parameters, one
    for writing to response and one to handle the incoming Request.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为端点创建一个处理程序函数，接受两个参数，一个用于写入响应，另一个用于处理传入的请求。
- en: Register the endpoint using `net/http.HandleFunc`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`net/http.HandleFunc`注册端点。
- en: The following is a simple web server that accepts all incoming requests, logs
    them on to the console, and then returns a `Hello, World!` message.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的Web服务器，它接受所有传入的请求，将它们记录到控制台，然后返回`Hello, World!`消息。
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are some sample requests and responses when requesting the URL in the
    browser:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中请求URL时，以下是一些示例请求和响应：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And the following is the server output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务器的输出：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that even though we have provided multiple paths, they are all defaulting
    to the `/` path.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使我们提供了多个路径，它们都默认为`/`路径。
- en: Designing a REST API
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计REST API
- en: We have looked at the history behind HTTP and the core concepts behind the REST
    protocol. We built a simple web server to show some of the server-side code needed
    to build a REST server. It is time for us to design and build a REST server using
    everything we have learned so far.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了HTTP背后的历史和REST协议的核心概念。我们构建了一个简单的Web服务器，以展示构建REST服务器所需的一些服务器端代码。现在是时候利用我们迄今为止学到的一切来设计和构建一个REST服务器了。
- en: We will start by defining the data format for our REST API, and then we will
    create a web server that works as per the REST API specifications we defined.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义我们的REST API的数据格式，然后创建一个符合我们定义的REST API规范的Web服务器。
- en: The data format
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据格式
- en: In this section, we will describe the format of the book resource, and then
    we will start defining each of the REST API interactions as well as the expected
    result from these interactions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将描述书籍资源的格式，然后我们将开始定义每个REST API交互以及这些交互的预期结果。
- en: The book resource
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 书籍资源
- en: 'The following is the basic definition of a book resource. It is a JSON array
    with the format `"<key>": "<value-type>"`, though the actual entities used in
    the application will consist of real values:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是书籍资源的基本定义。它是一个JSON数组，格式为`"<key>": "<value-type>"`，尽管应用中使用的实际实体将包含真实值：'
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: GET /api/books
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: GET /api/books
- en: This REST API call will retrieve a list of all items of the book resource type.
    The response's JSON format in our example consists of an array of the book resource
    type. However, this return format is not the only way to return items. An alternate
    but more popular format consists of a JSON object with key "data" that consists
    of the actual results and any further keys that the server might want to send
    back in the response.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个REST API调用将检索书籍资源类型的所有项目的列表。在我们的示例中，响应的JSON格式包括书籍资源类型的数组。然而，这种返回格式并不是返回项目的唯一方式。另一种但更流行的格式包括一个带有"数据"键的JSON对象，其中包含实际结果和服务器可能希望在响应中发送的任何其他键。
- en: 'Let''s now look at the simple format we will be using in our example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下我们在示例中将使用的简单格式：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: GET /api/books/<id>
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: GET /api/books/<id>
- en: This form of the `GET` call will retrieve a single book resource item based
    on the `<id>` provided. In general the response's JSON object will be of the defined
    resource type, though a server might decide to add or remove certain fields based
    on the service's logic. For our API, we will return all the fields defined in
    our resource type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`GET`调用将基于提供的`<id>`检索单个书籍资源项目。一般来说，响应的JSON对象将是定义的资源类型，尽管服务器可能决定根据服务的逻辑添加或删除某些字段。对于我们的API，我们将返回我们资源类型中定义的所有字段。
- en: 'Let''s look at an example when we try to retrieve a book resource with id `"1"`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，当我们尝试检索id为`"1"`的书籍资源时：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: POST /api/books
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: POST /api/books
- en: This REST API call will create a new item of book resource type. However, in
    order to create a new item, we would need to provide all the necessary data. It
    is possible to have `POST` requests that do not require any extra information.
    But in our case, we need to send information such as the `title` and `link` to
    the book as request's payload.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个REST API调用将创建一个新的书籍资源类型的项目。然而，为了创建一个新的项目，我们需要提供所有必要的数据。可能有不需要任何额外信息的`POST`请求。但在我们的情况下，我们需要发送诸如`title`和`link`之类的信息作为请求的负载。
- en: In this example, we want to create a book item with the title `"book5"` and
    link `"http://link-to-book5.com"`. Note that since our server already has two
    items of the book resource type, the new item is created with id of `"3"`; this
    is the implementation as per our server. Other REST servers might behave differently.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们想要创建一个标题为`"book5"`，链接为`"http://link-to-book5.com"`的书籍项目。请注意，由于我们的服务器已经有两个书籍资源类型的项目，新项目将以`"3"`的id创建；这是根据我们服务器的实现。其他REST服务器可能会有不同的行为。
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: PUT /api/books/<id>
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: PUT /api/books/<id>
- en: We will use `PUT` in our REST API to update a specific resource type. `PUT`
    defined in our API is stringent with accepting the payload without complete data,
    that is, it will reject with incomplete payloads.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的REST API中使用`PUT`来更新特定的资源类型。我们的API中定义的`PUT`对接受不完整数据的负载非常严格，也就是说，它将拒绝不完整的负载。
- en: 'In this example, we will modify the newly created book `"3"` and change its
    link to point at `"http://link-to-book-15.com"`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将修改新创建的书籍`"3"`，并将其链接更改为指向`"http://link-to-book-15.com"`：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: DELETE /api/books/<id>
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: DELETE /api/books/<id>
- en: This is the REST API call used to delete a specific book resource. This kind
    of request doesn't need a body and only requires the book id as part of the URL
    as shown in the next example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于删除特定书籍资源的REST API调用。这种请求不需要主体，只需要书籍id作为URL的一部分，如下一个例子所示。
- en: 'In this example, we will delete book `2`. Note that we do not return anything
    in response; other REST servers might return the deleted item:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将删除书籍`2`。请注意，我们不会在响应中返回任何内容；其他REST服务器可能会返回已删除的项目：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Unsuccessful requests
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不成功的请求
- en: It is possible that we could send ill-constructed requests, requests on unavailable
    entities, or bad incomplete payloads. For all such instances, we will send relevant
    HTTP error codes. Depending upon a server's implementation, it is possible to
    return a single error code. Some servers return a standard error code "404" for
    added security to not let malicious users try to find items of resource type they
    do not own.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会发送构造不良的请求、对不可用实体的请求或不完整的负载。对于所有这些情况，我们将发送相关的HTTP错误代码。根据服务器的实现，可能会返回单个错误代码。一些服务器返回标准的错误代码"404"，以增加安全性，不让恶意用户尝试查找他们不拥有的资源类型的项目。
- en: Design decisions
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设计决策
- en: 'We have defined our REST API and next we would like to implement the server.
    It is important to formulate what we want our server to accomplish before writing
    any code. The following are some of the specifications for the server:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的REST API，接下来我们想要实现服务器。在编写任何代码之前，制定我们希望服务器实现的目标非常重要。以下是服务器的一些规格：
- en: We need to extract `<id>` for `PUT`, `DELETE`, and single resource `GET` Requests.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要提取`<id>`用于`PUT`、`DELETE`和单个资源`GET`请求。
- en: We want to log every incoming request similar to the `helloWorldHandler`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望记录每个传入的请求，类似于`helloWorldHandler`。
- en: It would be tedious and bad coding practice to duplicate so much effort. We
    can make use of closures and function literals to create new functions for us
    that will combine the tasks from previous two points.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制这么多的工作是繁琐的，也是不好的编码实践。我们可以利用闭包和函数文字来为我们创建新的函数，这些函数将合并前两点的任务。
- en: In order to keep the example simple, we shall be using a `map[string]bookResource`
    to store the state of all book resources. All operations will be done on this
    map. In real-world servers, we would generally be using a database to store these
    resources.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保持示例简单，我们将使用`map[string]bookResource`来存储所有书籍资源的状态。所有操作将在此映射上进行。在现实世界的服务器中，我们通常会使用数据库来存储这些资源。
- en: Go server can handle concurrent requests, and this means that we should ensure
    that the map of book resources is safe from race conditions.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go服务器可以处理并发请求，这意味着我们应该确保书籍资源的映射免受竞争条件的影响。
- en: Let's look at what the code might look like based on the design we came up with.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看基于我们设计的代码可能是什么样子。
- en: The REST server for books API
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 书籍API的REST服务器
- en: 'We have divided our program as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将程序分为以下部分：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now let's look at the source code of each file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看每个文件的源代码。
- en: main.go
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主要.go
- en: 'The `main.go` source file consists of code mostly responsible for assembling
    and running the web server. The logic to actually respond to HTTP requests are
    distributed across other files:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go`源文件主要负责组装和运行Web服务器的代码。实际响应HTTP请求的逻辑分布在其他文件中：'
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: books-handler/common.go
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: books-handler/common.go
- en: 'The code in this source file is generic logic, which might be shared across
    multiple requests:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此源文件中的代码是通用逻辑，可能会在多个请求之间共享：
- en: It is generally a good practice to identify the logic that is not tied to one
    particular handler and then move it into `common.go` or similar source files,
    as this would make them easier to find and reduce duplicated code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好的做法是识别与特定处理程序无关的逻辑，然后将其移入`common.go`或类似的源文件，这样可以更容易找到它们并减少重复的代码。
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: books-handler/actions.go
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: books-handler/actions.go
- en: 'This source file consists of functions to handle each of the HTTP request''s
    method calls:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此源文件包含处理每个HTTP请求方法调用的函数：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: books-handler/handler.go
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: books-handler/handler.go
- en: 'The `handler.go` source file consists of all logic required to work with and
    handle book requests. Note that apart from consisting the logic for handling HTTP
    requests, it also deals with maintaining the state of books on the server:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`handler.go`源文件包含处理和处理书籍请求所需的所有逻辑。请注意，除了包含处理HTTP请求的逻辑外，它还处理了服务器上书籍状态的维护：'
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Even though we have created a REST server from scratch, this is not a complete
    REST server. To make writing a REST server feasible, a lot of important details
    have been left out. But in reality, we should use one of the existing libraries
    that will help us build a proper REST server.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经从头开始创建了一个REST服务器，但这并不是一个完整的REST服务器。为了使编写REST服务器成为可能，许多重要细节已被省略。但实际上，我们应该使用现有的库之一来帮助我们构建一个合适的REST服务器。
- en: So far so good but how do we interact with a REST server and with the server
    based on the code we have seen so far? Let's look at this in the next section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但根据我们迄今为止看到的代码，我们如何与REST服务器以及基于该代码的服务器进行交互？让我们在下一节中看看这个问题。
- en: How to make REST calls
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行REST调用
- en: Up to this point, we have used the web browser to make HTTP requests. This works
    for a normal HTTP server or to make simple `GET` Requests to a REST server. However,
    the browser will not be able to make other type of REST calls on our behalf.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用Web浏览器进行了HTTP请求。这适用于普通的HTTP服务器或对REST服务器进行简单的`GET`请求。但是，浏览器将无法代表我们进行其他类型的REST调用。
- en: Most web applications use JavaScript, Ajax, and other frontend technologies
    to interact with a REST server. However, we do not have to create a full-blown
    web frontend to interact with a REST server; we can make use of a few tools and
    also write programs to make REST calls for us.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web应用程序使用JavaScript、Ajax和其他前端技术与REST服务器进行交互。但是，我们不必创建一个完整的Web前端来与REST服务器进行交互；我们可以利用一些工具，还可以编写程序来代替我们进行REST调用。
- en: cURL
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: cURL
- en: cURL is a free command-line tool used to interact over a computer network. It
    can be used to communicate over multiple protocols including HTTP, HTTPS, FTP,
    SCP, and so on. Let's make REST calls to the server created in the previous section.
    To improve readability, we can make use of the `jq` library.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'cURL是一个免费的命令行工具，用于在计算机网络上进行交互。它可以用于多种协议的通信，包括HTTP、HTTPS、FTP、SCP等。让我们对在前一节中创建的服务器进行REST调用。为了提高可读性，我们可以使用`jq`库。 '
- en: GET
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GET
- en: 'Let''s now look at cURL commands to make HTTP requests. Depending on the state
    of your server, the output on making the `GET` Request might be different:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看使用cURL命令进行HTTP请求。根据服务器的状态，进行`GET`请求可能会有不同的输出：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: DELETE
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DELETE
- en: 'Assuming that we have a book with the id `"2"`, we can delete it using cURL,
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个id为“2”的书籍，我们可以使用cURL进行删除，如下所示：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: PUT
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PUT
- en: 'Let''s update an existing book resource with the id `"4"`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新具有id为“4”的现有书籍资源：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: POST
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: POST
- en: 'Now that we know how to send payload to a server using cURL, let''s create
    a new book resource item:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用cURL向服务器发送有效负载，让我们创建一个新的书籍资源项：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here are the commands for quick reference:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是快速参考命令：
- en: '`curl -L localhost:8080/api/books | jq # GET CALL`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl -L localhost:8080/api/books | jq # GET CALL`'
- en: '`curl localhost:8080/api/books/3 | jq # GET a single resource.`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl localhost:8080/api/books/3 | jq # 获取单个资源。`'
- en: '`curl -LX DELETE localhost:8080/api/books/2 | jq # DELETE a resource.`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl -LX DELETE localhost:8080/api/books/2 | jq # 删除一个资源。`'
- en: '`curl -H "Content-Type: application/json" -LX PUT -d ''{"title": "New Book
    Title", "link": "New Link"}'' localhost:8080/api/books/4 | jq`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl -H "Content-Type: application/json" -LX PUT -d ''{"title": "New Book
    Title", "link": "New Link"}'' localhost:8080/api/books/4 | jq`'
- en: '`curl -H "Content-Type: application/json" -LX POST -d ''{"title":"Ultra New
    Book", "link": "Ultra New Link"}'' localhost:8080/api/books/ | jq # POST ie.,
    create a new resource.`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl -H "Content-Type: application/json" -LX POST -d ''{"title":"Ultra New
    Book", "link": "Ultra New Link"}'' localhost:8080/api/books/ | jq # POST即创建一个新资源。`'
- en: 'And the following is the server''s console output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务器的控制台输出：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: An important thing to keep in mind is that even though we use redirection flag
    `-L`, for POST requests the body will not be sent. We need to make sure that we
    are sending it to finally resolved endpoint.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 需要牢记的一点是，即使我们使用重定向标志`-L`，对于POST请求，请求体也不会被发送。我们需要确保将其发送到最终解析的端点。
- en: This should give us the basic idea of how to use a REST client.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们一个如何使用REST客户端的基本概念。
- en: Postman
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Postman
- en: Let's now look at a GUI-based tool that can be used to make REST calls called
    **Postman** ([https://www.getpostman.com/](https://www.getpostman.com/)). For
    the sake of brevity, we shall look at a `GET` and a `POST` call.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个可以用来进行REST调用的基于GUI的工具**Postman**([https://www.getpostman.com/](https://www.getpostman.com/))。为了简洁起见，我们将看一个`GET`和一个`POST`调用。
- en: 'The following screenshot illustrates how to make a `GET` request using Postman.
    Note how Postman allows us to view the returned JSON in an easy-to-read format:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图说明了如何使用Postman进行`GET`请求。请注意，Postman允许我们以易于阅读的格式查看返回的JSON：
- en: '![](img/a2ca97d8-66c9-4629-b037-cdf38406349c.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2ca97d8-66c9-4629-b037-cdf38406349c.png)'
- en: GET /api/books
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: GET /api/books
- en: 'The following screenshot shows how to make a `POST` request. Note that we could
    easily provide it with a JSON payload:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了如何进行`POST`请求。请注意，我们可以很容易地提供一个JSON有效负载：
- en: '![](img/a96d1b37-ddb5-4eb0-b640-5e525e3e100e.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a96d1b37-ddb5-4eb0-b640-5e525e3e100e.png)'
- en: POST /api/books
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: POST /api/books
- en: Hopefully, the previous sections and these screenshots are sufficient to get
    an understanding of how to use Postman.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 希望前面的部分和这些屏幕截图足以让我们了解如何使用Postman。
- en: net/http
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: net/http
- en: 'Let''s look at how to send `GET` and `POST` from Go programmatically:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从Go程序中以编程方式发送`GET`和`POST`：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the console output from running the program:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行程序时的控制台输出：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Further details regarding the `net/http` library can be found at [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`net/http`库的更多详细信息可以在[https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/)找到。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the brief history of HTTP and sessions. Next,
    we looked at the problems REST protocols were designed to solve and how they came
    into prominence. Then, we developed a deep understanding of what a REST protocol
    is, how to design an application based around it, how to build a REST server based
    on our design, and finally we looked at different ways to interact with a REST
    server using cURL, Postman, and Go programs. You're free to use whichever you
    want to interact with a REST server. However, for the remainder of the book, we
    will see interactions with REST servers using cURL.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了HTTP和会话的简要历史。接下来，我们看了REST协议旨在解决的问题以及它们是如何引起关注的。然后，我们深入了解了REST协议是什么，如何设计基于它的应用程序，如何基于我们的设计构建REST服务器，最后我们看了使用cURL、Postman和Go程序与REST服务器交互的不同方式。您可以自由选择与REST服务器交互的方式。但是，在本书的其余部分，我们将看到使用cURL与REST服务器交互。
- en: Now that we have discussed all the important topics that are fundamental to
    develop distributed and web-oriented applications. In the next chapter, [Chapter
    5](../Text/Ch05.xhtml), *Introducing Goophr* we can start discussing what a distributed
    document indexer is on a conceptual level and how to design it, plan for data
    communication, and so on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了开发分布式和面向Web的应用程序所必需的所有重要主题。在下一章，[第5章](../Text/Ch05.xhtml)，*介绍Goophr*，我们可以开始讨论分布式文档索引器在概念层面上是什么，以及如何设计它，规划数据通信等等。
