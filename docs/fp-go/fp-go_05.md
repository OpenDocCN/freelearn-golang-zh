

# 第五章：不可变性

在本章中，我们将探讨不可变性。我们将讨论什么是不可变性，以及 Go 语言如何帮助在结构体级别上保持不可变性。为了理解这是如何工作的，我们将查看 Go 如何处理对象的指针和引用，性能影响是什么，以及如何在指针-引用权衡之间做出决定。我们还将深入研究垃圾回收、单元测试和*纯*函数式编程的影响。

这些是我们将在本章中涵盖的主要主题：

+   什么是不可变性？

+   如何编写不可变代码

+   Go 中的指针和引用是如何工作的？

+   分析可变和不可变代码的性能

+   使用不可变代码进行并发和测试的示例

# 技术要求

对于本章，你可以使用 Go 1.18 或更高版本的任何版本，因为我们将使用泛型来编写一些后续示例。你可以在 GitHub 上找到所有代码：[`github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter5`](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter5)。

# 什么是不可变性？

当我们在这章中谈论不可变性时，我们是在谈论那些状态随时间不变的结构体。换句话说，当结构体被创建时，这就是它在整个生命周期中将如何表示的。我们仍然可以创建新的结构体和删除旧的结构体。因此，系统级别的状态将通过创建新的结构体和删除旧的结构体而有效地改变。这有几个优点：

+   首先，因为我们的结构体不会改变，我们可以安全地将数据传递给一个函数，并且知道无论发生什么，传递给函数的副本都将保持完整。

+   其次，不可变结构体使得编写正确、并发的代码更加容易。由于结构体的状态不能被任何调用它的函数改变，我们可以安全地进行并行执行，并使用相同的结构体作为输入数据调用多个函数。

+   第三，这使得我们的代码更容易推理。在每一步中，我们的结构体的状态都更加可预测。

不可变性不仅仅是我们在编写函数式代码时追求的东西。在许多面向对象的编程语言中，编写不可变代码是首选。这本书中提到它的原因是因为它与纯函数紧密相关，我们在上一章中看到了纯函数。如果你想编写真正的*纯*函数式代码，你需要不可变结构体。如果你在函数中更改结构体，这将被视为副作用。回想一下上一章，我们将尽可能消除副作用。话虽如此，本章中的几乎所有内容都可以应用到传统的面向对象语言中。

## 数据层上的不可变性

不可变性是一个强大的概念，我们可以将其应用于我们编写的程序。但它也表现为我们存储的数据的概念。如果我们正在编写处理极其敏感数据的软件，例如**电子健康记录**（**EHR**），我们可能希望数据是不可变的。也就是说，每当我们的 EHR 中的某些信息发生变化时，我们希望这种变化是完全可追踪的。这样，您的 EHR 的整个历史在任何时候都是可见的。

通过使医疗数据不可变，您可以始终查看文件过去的样子。例如，您可以查看患者所做的任何血液检查或之前记录的任何笔记。这也有助于作为可审计的日志——记录的每次更改都是可追踪的。想象一下，如果一位医生不小心删除了血液检查的结果。如果您的数据存储是不可变的，血液检查将不会在数据层被删除（而是被标记为“已删除”，以便应用层可以选择不将其显示给用户）。它还可以防止恶意行为——如果恶意行为者获得了对应用程序的访问权限并决定开始更改医生的笔记文本，这将显示为*新*笔记。原始笔记仍然存在，至少在数据层中。

想象一下，如果我们没有不可变性，每次新数据可用时实际信息都会更新会发生什么。这将远非理想。想象一下，每次血液检查都会覆盖过去的结果——这将模糊您医疗历史中的任何趋势，删除对医疗从业者有价值的信息。或者更糟，一旦删除了医疗图像，它就会一直被删除，患者将不得不进行相同的测试系列。这不仅对患者的体验不利，而且在一些国家，这还可能很昂贵。

这种在数据层实现的可追溯性和不可变性的想法，在某种程度上，最终导致了现在被称为**区块链**的东西。虽然我不知道有任何主流的基于区块链数据库的电子健康记录（EHR）系统，但至少全球有公司正在努力使这一现实成为可能。这样做是有意义的。

区块链数据库默认是不可变的。除了适合之前提到的电子健康记录（EHR）示例外，它目前还被用于货币交易。在区块链数据库中，整个区块的历史都是可见的。当对区块进行更新时，会向链中添加一个新的区块，其中包含更新的信息，而不是覆盖现有的区块。这就是加密货币可以模拟金融交易的方式。这里所解释的只是冰山一角，因为我省略了区块链如何保证不可变性和提供篡改机制的具体解释。

在数据层对不可变性的深入研究超出了本书的范围，但希望这个简短的概述为您进一步探索这些想法提供了一个良好的起点。

# 如何在 Go 中编写不可变代码

当我们谈论 Go 中的不可变性时，我们特别关注如何在代码中拥有不可变的结构体。在这个核心，我们必须看看 Go 如何使用指针以及按值传递和按引用传递之间的区别。这是让新 Go 程序员感到困惑的事情，而且有足够多的边缘情况，即使是经验丰富的 Go 程序员偶尔也会自己绊倒。

从本质上讲，这取决于我们在传递结构体到函数时是否使用指针。如果我们的代码完全不含指针，那么我们也会编写不可变代码。

为了演示这一点，让我们看一下以下代码片段。我们有一个结构体来定义一个人，以及一个用来更改这个人名字的函数：

```go
type Person struct {
    name string
    age  int
}
func main() {
    p := Person{
        name: "Benny",
        age:  55,
    }
    setName(p, "Bjorn")
    fmt.Println(p.name)
}
func setName(p Person, name string) {
    p.name = name
}
```

这个函数的结果，可能出乎意料，是`Benny`。`setName`函数并没有改变`Person`对象的名字。最终，我们都习惯了这样一个想法：要在函数中更新结构体，我们需要使用指针：

```go
func main() {
    p := Person{
        name: "Benny",
        age:  55,
    }
    setName(&p, "Bjorn")
    fmt.Println(p.name)
}
func setName(p *Person, name string) {
    p.name = name
}
```

现在，当我们运行这段代码时，输出是`Bjorn`，正如我们所预期的。这两个例子之间的区别在于，在第一个例子中，我们使用的是按值传递，而在第二个例子中，我们使用的是按引用传递。

如果我们看看第一个函数中发生的事情，我们会看到我们的`Person`对象正在被复制，而这个副本随后被传递给`setName`函数。因此，我们对这个结构体进行的每一个操作都是在副本本身上进行的，而不是在真正的对象上。然而，在第二个例子中，通过使用指针，我们能够访问实际的`Person`对象，而不仅仅是副本。在底层，第二个例子传递了结构体的地址（指针）。Go 的语法为我们模糊了一些指针引用和取消引用的操作，这使得它看起来像是一个相当小的变化。

通常，我们希望保持代码的不可变性。因此，我们希望避免在代码中使用指针。那么，我们如何更新我们的结构体呢？`setName`函数为我们提供了有用的功能。回想一下，尽管我们不能改变我们使用的对象的状态，但我们仍然可以自由地创建和销毁它们。解决方案是创建一个新的对象，它具有我们原始对象的所有属性，并应用了一些更改。为了继续我们的上一个例子，让我们重构`setName`函数以实现所需的功能：

```go
func main() {
    p := Person{
        name: "Benny",
        age:  55,
    }
    p = setName(p, "Bjorn")
    fmt.Println(p.name)
}
func setName(p Person, name string) Person {
    p.name = name
    return p
}
```

在前面的例子中，你可以看到我们需要在不破坏不可变性的前提下更新结构体的核心变化。我们通过让函数接受副本（按值传递）作为输入并返回一个应用了更改的新结构体来实现这一点。在我们的调用函数中，我们现在可以选择是否保留两个对象或者丢弃原始对象，只保留新返回的对象。

这种语法对 Go 程序员来说应该相当熟悉，因为这与我们处理切片时的做法类似。例如，如果我们想向切片中添加一个值，我们会编写如下代码：

```go
func main() {
    names := []string{"Miranda", "Paula"}
    names = append(names, "Yvonne")
    fmt.Printf("%v\n", names)
}
```

这段代码会返回`[Miranda Paula Yvonne]`。当与不可变结构体一起工作时，我们的语法将看起来类似于这样。

## 为集合数据类型编写不可变代码

之前，我们看到了如何轻松地将函数从不可变转换为可变。我们只需用一个接受值并返回新值的函数替换掉接受指针的函数。当与集合`Map`数据类型一起工作时，情况会有所不同，以下示例中可以看出：

```go
func main() {
    m := map[string]int{}
    addValue(m, "red", 10)
    fmt.Printf("%v\n", m)
}
func addValue(m map[string]int, colour string, value int) {
    m[colour] = value
}
```

这段代码的输出是`[red 10]`。尽管我们在`addValue`函数中没有使用指针，但该函数并不是在映射的副本上操作，而是在映射本身上操作。**在 Go 中，映射总是以引用传递的方式操作**。

如果我们尝试使用类似设置与切片（另一种集合数据类型）一起使用，它将按预期工作：

```go
func main() {
    names := []string{"Miranda"}
    addValue(names, "Yvonne")
    fmt.Printf("%v\n", names)
}
func addValue(s []string, name string) {
    s = append(s, name)
}
```

这里的输出是`Miranda`。使用指针，我们再次可以使函数可变：

```go
func main() {
    names := []string{"Miranda"}
    addValue(&names, "Yvonne")
    fmt.Printf("%v\n", names)
}
func addValue(s *[]string, name string) {
    *s = append(*s, name)
}
```

如果我们运行前面的代码，输出将是`[Miranda Yvonne]`。这在 Go 中很常见，经验丰富的程序员已经习惯了这一点，但这也可能让初学者感到困惑。

# 可变和不可变代码的性能测量

关于不可变代码的常见抱怨是，它的性能不如其可变版本。即使没有深入研究 Go 运行时的性能特征，这似乎是一个合理的说法。毕竟，在不可变版本中，每次函数调用都会生成一个对象的新副本。然而，在实践中，这些性能差异通常是可以忽略不计的。

尽管如此，即使会有显著的性能影响，你也需要质疑这些性能牺牲在你的环境中是否合理。作为交换，你得到了线程安全、易于维护、理解和测试的代码。作为工程师，我们常常非常渴望寻求最优化解决方案，尽可能少地使用内存和 CPU 时间。然而，对于许多实际应用来说，性能影响足够小，以至于这并不是用户会注意到的。而且对于维护你代码的其他工程师来说，他们通常更希望得到的是更易于理解的东西，而不是更快的东西。

与其他语言不同，Go 由于垃圾回收而可能会遭受一定的性能损失。如果你想从系统中榨取每一分性能，也许 Go 也不是完成这项工作的正确工具。现在我们已经排除了这一点，我们应该看看实际的基准测试，并深入探讨不可变代码的性能影响。

## 基准测试函数

虽然我们可以从抽象的角度推理函数的性能，例如空间-时间复杂度，但要真正了解性能，我们应该进行性能测试。毕竟，可变和不可变函数的运行时复杂度可以近似相同。关心指针的实现过于底层，不值得考虑。因此，我们将设置一个测试来确定哪种性能更差。作为提醒，这里的假设是，使用指针的可变代码将比我们的不可变版本更快。这种假设的潜在原因是，复制结构体比将指针传递给函数更耗费资源。

让我们设置两个类似于构造函数的函数，一个用于不可变版本，另一个用于可变版本。第一个函数创建一个 `Person` 对象，然后将该函数传递给一个设置人名的函数，然后传递给另一个设置人年龄的函数：

```go
func immutableCreatePerson() Person {
    p := Person{}
    p = immutableSetName(p, "Sean")
    p = immutableSetAge(p, 29)
    return p
}
func immutableSetName(p Person, name string) Person {
    p.name = name
    return p
}
func immutableSetAge(p Person, age int) Person {
    p.age = age
    return p
}
```

在这里，我们可以看到 `Person` 对象首先被复制到 `immutableSetName`，然后又被复制到 `immutableSetAge`。最后，我们将这个 `Person` 返回给调用函数。

现在，让我们也设置一个可变版本的代码。在可变版本中，我们创建一个 `Person` 对象。但是，当将其传递给设置姓名和年龄的可变函数时，我们将传递一个指向我们对象的指针：

```go
func mutableCreatePerson() *Person {
    p := &Person{}
    mutableSetName(p, "Tom")
    mutableSetAge(p, 31)
    return p
}
func mutableSetName(p *Person, name string) {
    p.name = name
}
func mutableSetAge(p *Person, age int) {
    p.age = age
}
```

在这里，我们可以看到指针被用来在函数之间避免复制 `Person` 对象。在这些示例中，有一点需要指出的是，这两个函数在 Go 中是相同的：

```go
func mutableSetName(p *Person, name string)
```

而当函数绑定到一个对象上时：

```go
func (p *Person) mutableSetName(name string)
```

在我们调用这些函数的方式以及函数名冲突的后果方面，有一些实际的区别。尽管如此，对于可变和不可变示例，它们的性能特征是相同的。

在处理完这些之后，让我们编写我们的基准测试。Go 有内置的基准测试支持，就像它有内置的测试支持一样。这使得编写基准测试变得相当容易，因为要基准测试的整个代码可以放在一页上：

```go
package pkg
import "testing"
func BenchmarkImmutablePerson(b *testing.B) {
    for n := 0; n < b.N; n++ {
        immutableCreatePerson()
    }
}
func BenchmarkMutablePerson(b *testing.B) {
    for n := 0; n < b.N; n++ {
        mutableCreatePerson()
    }
}
```

使用这个内置的基准测试支持，我们可以使用以下命令运行我们的基准测试：

```go
go test -bench=.
```

在我的 **Amazon Web Service** (**AWS**) EC2 实例上，经过几次运行的平均结果如下：

```go
BenchmarkImmutablePerson        0.3758 ns/op
BenchmarkMutablePerson          0.3775 ns/op
```

这些 `ns/op` 属性的具体值在您的机器上可能会有所不同，所以不要过于关注具体值。这里应该令人惊讶的是，我们的不可变代码比我们的可变代码表现更好。

要理解发生了什么，我们需要看看垃圾回收以及栈与堆分配。

## 理解栈、堆和垃圾回收

垃圾回收是一个足够复杂的话题，可能值得整章讨论。在这里，我们将采取一些捷径，并深入了解这一过程，但会简化一些步骤。Go 本身是开源的，并且有良好的文档。

### 通过垃圾回收回收内存

Go 是一种垃圾回收语言，这意味着内存管理由 Go 运行时负责。这减少了程序员方面的努力，因为它消除了手动管理内存的需要。这可以消除或减少代码中某些类型错误的可能性，例如内存泄漏。

通过自动垃圾回收，我们，程序员，不需要考虑管理我们应用程序的内存。内存会为我们保留，并在之后无我们的干预下归还给系统。为了使这一过程工作，Go 运行时需要在幕后做一些工作。本质上，运行时会触发一个“垃圾回收”过程来释放内存。它通过暂时冻结我们的应用程序，检查哪些对象不再需要，并将它们从我们应用程序的工作内存中移除来实现。有不同方法来确定哪些对象不再需要，以及在我们程序的生命周期中删除它们的机制。通常，垃圾回收器会尝试确定是否还有对数据的引用。如果有对数据的引用，它仍然可以通过你的程序访问，因此不应该被删除。

要了解这个过程如何影响性能，将垃圾回收视为一个“停止世界”的过程是有帮助的。这意味着它完全停止所有执行，识别垃圾，并将其移除以释放内存。在实践中，Go 使用多个线程来识别垃圾对象。这种方法被称为“并发标记-清除垃圾回收器”。尽管这是并发的，但仍然存在性能开销。当人们在决定为他们的应用程序使用哪种语言时，垃圾回收的开销在谈话中经常意外地出现。这在与 Go、C/C++ 或 Rust 之间的选择中尤为明显。

虽然在最新的 Go 版本中垃圾回收的性能影响已经减少，但影响不能完全消除。有方法可以调整 Go 中垃圾回收器的行为，但通常这不是一个推荐的方法。通常，算法的低效实现会超过垃圾回收带来的负面影响。

### 栈和堆

我们接下来要讨论的主题是栈和堆。在运行时，有两种类型的内存可用，即栈和堆。栈是一种**后进先出**（**LIFO**）的数据结构。这意味着当数据从栈中移除时，最后插入的项目将被删除。Go 使用栈来存储函数调用链中的数据，这包括局部变量、函数的输入参数等等。

当一个函数被调用时，该函数的数据将被推送到栈顶。当函数执行完毕后，这些数据将从栈中移除。因此，当你的应用程序中调用函数时，栈会持续地增长和缩小。栈可用的空间是有限的；超出这个限制会导致一个众所周知的问题，即*栈溢出*。栈上的元素可以被认为是具有有限生命周期的，因为它们在函数结束时迅速从内存中移除。

另一方面，堆是应用程序生命周期内的共享内存。存储在这里的数据不仅限于函数的生命周期。这意味着这些数据可以从应用程序的多个地方被引用（指向）。为了避免堆不断扩展，堆内存由垃圾回收器管理。垃圾回收器会扫描堆中的内存，以确定是否还需要这些数据。如果数据不再需要，它将被删除。

在栈和堆的实现中，从堆中回收内存比从栈中回收内存更便宜。栈不需要垃圾回收器“停止世界”来扫描要删除的对象。因此，如果我们尽可能在栈上而不是在堆上分配内存，我们的程序将运行得更快。但这并不总是可能的，因为有些数据我们希望在单个函数之外的环境中保持活跃。此外，堆分配通常比栈分配慢，因为堆分配所需的内存需要从内存池中回收——这是 Go 从操作系统申请的一组内存。这是一个可能很慢的操作，因为程序需要等待内存变得可用。

要了解这如何影响之前我们查看的不变和可变示例的性能，我们需要了解 Go 如何选择存储变量的位置。在理论上，这听起来很简单——如果数据只需要在单个函数中使用，它就是一个栈变量；否则，我们必须将其存储在堆上。然而，在实践中，还有更多的事情需要考虑。

首先，编译器将尝试证明一个变量仅属于单个函数。编译器通过一个称为 *逃逸分析* 的过程来完成这项工作，在这个过程中，它会寻找那些逃离单个函数上下文的变量。如果一个变量不属于单个函数，它就会将其存储在堆上。Go 运行时还会查看数据的大小。将大型数据存储在堆上而不是栈上更有意义，因为栈的空间通常更有限。栈空间是一个真实的问题，我们将在下一章讨论递归时对其进行更深入的探讨。

这如何与我们的指针可变性的讨论联系起来？在示例代码中，我们用它来基准测试两个函数，不可变代码可以在栈上分配所有内存。可变示例不太幸运，因为它使用了指针，这会导致数据分配在堆上，这是逃离单个函数的上下文。因此，我们在性能上看到的影响是由垃圾收集器回收内存所造成的。

重要的是要注意，垃圾收集器的具体实现，甚至逃逸分析的算法，随着时间的推移可能会改变。要了解 Go 最新版本中的垃圾收集器是如何工作的，最好阅读该版本的文档。

### 观察逃逸分析的实际操作

让我们通过探索 Go 中的逃逸分析行为来展示我们的推理是有道理的。首先，我们将稍微修改我们的代码，通过添加一个 pragma 来防止编译器内联我们的函数。在 Go 中，pragma 是一种特殊的注释，它向编译器提供一些指令。我们将为每个函数添加这个 pragma，这样它们都会包含这个注释，如下所示：

```go
//go:noinline
func immutableCreatePerson() Person {
    p := Person{}
    p = immutableSetName(p, "Sean")
    p = immutableSetAge(p, 29)
    return p
}
```

这意味着函数不会被编译器删除。函数内联是编译器的一种优化过程，它在幕后发生，以加快我们程序的执行速度。再次强调，这值得单独一章来讨论，但超出了本书的范围。

一旦我们为每个函数添加了 pragma，我们就可以使用以下命令构建我们的应用程序：

```go
go build -gcflags '-m -l'
```

这告诉 Go 编译器向我们解释逃逸分析决策在哪里被做出，以及这些决策的结果是什么。当我们查看输出时，我们得到以下内容：

```go
# github.com/PacktPublishing/Chapter5/Benchmark/pkg
./person.go:17:23: leaking param: p to result ~r0 level=0
./person.go:17:33: leaking param: name to result ~r0
  level=0
./person.go:23:22: leaking param: p to result ~r0 level=0
./person.go:37:21: p does not escape
./person.go:37:32: leaking param: name
./person.go:42:20: p does not escape
./person.go:30:7: &Person{} escapes to heap
```

这表明，在第 30 行，我们的 `Person` 正逃逸到堆上。当一个对象逃逸到堆上时，最终必须由垃圾收集器来处理，以便我们的内存空间可以被回收。

在幕后发生了很多事情，我们简化了 Go 中垃圾收集工作的一些方式。但总体来说，这应该作为一个例子，说明指针和可变代码比没有指针的不可变代码更快这一假设是不成立的。

# 何时编写可变函数

到目前为止，本章主要讨论了为什么我们更喜欢编写不可变函数。但有些情况下，无论是编写可变函数都有意义。唯一真正的理由是性能。正如我们之前看到的，性能影响通常可以忽略，但并非总是如此。如果你使用包含大量数据的结构体，将它们复制到每个函数中可能会对性能产生负面影响，足以削弱你的应用程序。唯一真正知道这是否是这种情况的方法是向你的应用程序添加性能指标。即便如此，也必须在更高效的代码和更易于维护的代码之间做出权衡。通常，试图从你的应用程序中挤出更多性能会阻碍长期的可维护性。

使用指针编写可变代码的另一个可能原因是需要在你应用程序中具有唯一性的资源。如果你在代码中实现传统的面向对象模式，你可能已经实现了单例模式。如果你想有一个真正的单例，你应该使用指针而不是复制单例。否则，你将在不同的函数中有多个单例副本，每个可能都有不同的状态。在你的代码中是否使用单例是一个不同书籍中的讨论话题。

# 函子和单子是什么？

在上一章中，我们讨论了函数纯度的概念。一个函数不应该产生任何副作用，并且应该是幂等的。在本章中，我们看到了如何使结构体不可变，以及这与函数纯度的联系。正如之前提到的，即使在纯函数式语言中，尽可能消除副作用，你仍然有期望的副作用行为。例如，从用户那里获取输入，或将数据写入数据库，都是增加程序价值的副作用。

在本节中，我们将尝试理解纯函数式语言如何实现这一点。我们还将查看 Go 语言中的实现，以实现相同的结果，基于我们对不可变结构和纯函数的知识。

在介绍本节之前，通常说已经有太多的单子解释，而且它们都是错误的或者在某些方面有所欠缺。关于函数式编程有很多书籍，或者博客文章和视频，试图提供好的解释。新解释频繁提出的事实应该让你对这一主题的复杂性有所了解。我没有提供“最终需要的单子解释”的宏伟目标。相反，我将尝试将其简化为核心思想，并尽可能接近实际应用。因此，我们将避免深入到范畴论的理论层面。以下是一个希望是“足够好”的解释，而不是一个完美整体性的解释。

## 什么是函子？

在我们演示什么是单子之前，我们需要了解什么是函子。简单来说，函子是一个可以对数据结构中包含的每个元素应用操作的函数。在 Haskell 中，这个函数的实现称为 `fmap`。在 Go 中，这个函数可能看起来像这样：

```go
func fmapA, B any B, sliceA []A) []B
```

在前面的类型签名中，我们使用了切片。切片是一种包含其他数据元素的数据类型。`fmap` 实现不必在切片上操作——任何包含数据元素的数据结构都可以，例如指针（它们可以可选地包含一个数据元素）、函数本身、树，或者正如我们将在下一页看到的那样，一个单子。

如果我们要在 Go 中编写一个操作切片的 `fmap` 实现如之前所示的功能签名，我们只需为 `sliceA` 中的每个元素调用提供的 `mapFunc`。这个结果将存储在新的切片 `sliceB` 中：

```go
func fmapA, B any B, sliceA []A) []B {
    sliceB := make([]B, len(sliceA))
    for i, a := range sliceA {
        sliceB[i] = mapFunc(a)
    }
    return sliceB
}
```

注意前面示例中泛型的使用，我们可以用它来在两个 `any` 类型之间进行映射。但输入是 `A`，输出是 `B`。因此，映射函数**改变了**我们数据的数据类型。

让我们看看如何使用这个函数。想象一下，我们有一个整数切片，我们想将其转换成字符串切片。我们可以使用我们的 `fmap` 函数来完成这个任务。我们只需要向 `fmap` 提供一个函数，该函数接受一个整数并返回一个字符串：

```go
import (
    "fmt"
    "strconv"
)
func main() {
    integers := []int{1, 2, 3}
    strings := fmap(strconv.Itoa, integers)
    fmt.Printf("%T transformed to %T - %v\n", integers,
      strings, strings)
}
```

当我们运行前面的函数时，我们得到以下输出（回想一下，`%T` 打印变量的类型）：

```go
[]int transformed to []string - [1 2 3]
```

这告诉我们，我们的 `int`、`slice` 被转换成了字符串切片，并且不出所料，包含的值是 `[1, 2, 3]`。

这基本上就是一个函子的定义。它是一个将给定数据结构中的所有数据转换为不同类型数据的函数。`fmap` 实现是一个纯的、高阶函数。

## 从函子到单子

下一步是从函子到单子的转换。那么，单子究竟是什么呢？当我们试图对单子进行某种理论描述时，我们可能会得到以下内容。

单子是一种软件设计模式。它是一种可以将类似类型的函数组合起来，并将非单子类型的结果包装成一个新的单子类型，提供额外函数的数据类型。为了使一个类型成为单子，它需要定义两个函数：

1.  **一个将 T 类型的值包装到 Monad[T] 中的函数**

1.  **一个组合 Monad[T] 类型函数的函数**

我们将通过一个实际示例来演示单子。一个流行的单子是 `Maybe` 单子，在一些编程语言中也称为 `Optional`。`Maybe` 单子是一种可能包含具体值的类型，但也可能为空。

要在 Go 中模拟 `Maybe` 单子，我们将使用一个定义我们结构体操作的接口。接下来，我们还将创建两个实现，一个用于值存在的情况，另一个用于值不存在的情况：

```go
type Maybe[A any] interface {
    Get() (A)
    GetOrElse(def A) A
}
```

在前面的接口实现中，我们定义了两个函数：`Get`和`GetOrElse`。可以定义更多；具体的函数并不那么重要。重要的是，我们有一种方式来模拟可能存在或可能不存在的值。

注意，我们在这里没有使用指针，我们只使用了具体类型。`Maybe`单子通常被引入以避免使用指针。通过避免使用指针，我们可以消除在运行时调用*空指针*时发生的一类错误。在 Go 中，`null`或`nil`从类型分类的角度来看也没有真正的意义。`nil`指针属于每个类型，这意味着其中没有真正有用的信息，我们希望我们的类型系统尽可能声明式。 （Go 确实有“类型 nil”，函数可以在其上安全地调用。然而，在使用时仍需谨慎。这并不是编程语言的常见行为，甚至可能会让经验丰富的 Go 程序员感到困惑。）

乔治·霍尔，他首次引入了空指针概念，称这是他的“*十亿美元的错误*”。

我们将用于模拟值的存在和不存在的情况的两个实现分别是`Just`和`Nothing`。这些名称是从 Haskell 借用的；你会在不同的编程语言中找到这些值的不同的名称。`Just`表示存在一个具体值，而`Nothing`表示不存在。我们将首先实现值存在的情况，使用`JustMaybe`类型：

```go
type JustMaybe[A any] struct {
    value A
}
func (j JustMaybe[A]) Get() (A) {
    return j.value
}
func (j JustMaybe[A]) GetOrElse(def A) A {
    return j.value
}
```

上述代码遵循`Maybe`接口。因此，我们可以将`JustMaybe`用作`Maybe`的一个实例。为了实现值的缺失，我们将实现类似的`NothingMaybe`：

```go
type NothingMaybe[A any] struct{}
func Nothing[A any]() Maybe[A] {
    return NothingMaybe[A]{}
}
func (n NothingMaybe[A]) Get() (A) {
    return *new(A)
}
func (n NothingMaybe[A]) GetOrElse(def A) A {
    return def
}
```

每个函数的实现相当直接。也许最令人惊讶的是`Get`函数中对于`NothingMonad`的`return`语句，我们写的是：

```go
    return *new(A)
```

这个语句返回`A`的新实例，但`A`在编译时是一个未知值。通过使用`new`，我们可以实例化它，但它将返回一个指针值，我们将解引用它以返回一个具体值。

接下来，让我们也创建这两个实现的构造函数，这些是可以将给定类型的值包装到单子表示中的函数。回想一下，这是我们单子模式的要求：

```go
func JustA any JustMaybe[A] {
    return JustMaybe[A]{value: a}
}
func Nothing[A any]() Maybe[A] {
    return NothingMaybe[A]{}
}
```

这两种实现将使我们能够实现给定值的“存在”和“不存在”。例如，我们现在可以在一个函数中使用这些实现：

```go
func getFromMap(m map[string]int, key string) Maybe[int] {
    if value, ok := m[key]; ok {
        return Justint
    } else {
        return Nothing[int]()
    }
}
```

在前面的函数中，我们通过查找给定的键从映射中获取一个值。如果存在值，我们返回我们的单子`JustMaybe`实现；否则，我们返回`NothingMaybe`实现。

可以编写一些便利函数，例如`fromNullable(*value)`，它将根据传递给函数的值是否存在返回`JustMaybe`或`NothingMaybe`。

记住，我们的单子类型是一个包含底层元素的数据结构。因此，我们也可以在这个类型上实现`fmap`函数。在这个实现中，我们将一个类型为`A`的`Maybe`转换为类型为`B`的`Maybe`。我们需要提供一个函数来从底层类型`A`映射到底层类型`B`以完成此操作：

```go
func fmapA, B any B) Maybe[B]
{
    switch m.(type) {
    case JustMaybe[A]:
        j := m.(JustMaybe[A])
        return JustMaybe[B]{
            value: mapFunc(j.value),
        }
    case NothingMaybe[A]:
        return NothingMaybe[B]{}
    default:
        panic("unknown type")
    }
}
```

在前面的代码中，我们使用类型切换来确定我们的`Maybe`单子的类型，以确定它是否代表`JustMaybe`或`NothingMaybe`实现。如果类型匹配`JustMaybe`，我们将从类型`A`映射到类型`B`的底层值，并返回这个新封装的单子。

这是一个单子的不完整定义，但是一个实际实现的实例。这个概念可以进一步扩展，但 Go 没有提供方便的方式来进一步探索，所以它不太可能在现实世界中经常使用。

# 摘要

在本章中，我们简要回顾了 Go 中的不可变性。我们通过值传递或引用传递来回顾了 Go 中不可变性的工作方式。我们了解到指针并不能保证你的代码比避免它们时更高效。我们还讨论了不可变代码的一些好处，例如提高代码库的可读性和可理解性。我们还简要介绍了这使得并发更容易正确实现，因为状态在函数之间不会被修改。

最后，我们通过查看单子以及使用`Maybe`单子的实际实现来结束了对上一章开始讨论的纯函数的讨论。

在下一章中，我们将探讨编写函数式代码时必须拥有的函数。

# 第二部分：使用函数式编程技术

在我们建立了函数式编程的基本思想并看到它们如何与面向对象范式相关联之后，我们将继续这部分内容。在这里，我们将探讨如何在类级别上利用函数式编程来组合更大的程序。我们将学习如何迭代地解决问题与递归地解决问题，函数类型的三种重要类别，以及如何将函数链接起来以编写更易读的代码。

这部分包含以下章节：

+   *第六章**，函数的三个常见类别*

+   *第七章**，递归*

+   *第八章**，使用流畅编程进行可读的函数组合*
