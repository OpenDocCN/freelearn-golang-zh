

# 第十一章：函数式编程库

在本书的前几章中，我们探讨了如何在 Go 中使用函数式编程技术。在这个过程中，我们查看了几种函数的创建方式，例如 Filter、Map、Reduce 等。我们还探讨了数据结构，如单子及其与 Maybe 数据类型的结合应用，它可以表示一个存在或不存在但不依赖于 nil 的值。

如前所述，这些是函数式程序员工具箱中的常用工具。因此，有一些开源库内置了这些功能。由于泛型是 Go 中最近添加的特性（在撰写本文时大约 1 年前），并非所有库都利用泛型来实现这些概念。因此，本章将涵盖适用于所有 Go 版本的库，以及仅适用于支持泛型的版本的库。

在本章中，我们将涵盖以下主题：

+   用于创建常见 FP 函数的预泛型库

+   用于创建常见 FP 函数的后泛型库

# 技术要求

对于本章，任何版本的 Go 都足以实现预泛型库代码。一旦我们转向后泛型库，就需要 1.18 或更高版本来支持代码。所有代码都可以在 GitHub 上找到，网址为[`github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter11`](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter11)。

在我们深入探讨这个主题之前，有一些与技术要求相关的事项需要指出。

## 这个库是否仍然活跃——示例是否仍然与之匹配？

当撰写一本关于特定编程语言的书籍时，很难以永恒的方式撰写它。但编程库可能比其他任何内容都更难保持永恒。这里有两大原因，这是需要承认的：

+   实现可能会更改，并且版本控制并不总是得到尊重。

+   该库未来可能会失去支持。

第一个问题，*更改实现*，应该会通过本章只探讨流行库这一事实得到一定程度的缓解，其中流行度是通过 GitHub 上的参与度和 GitHub 上的星标来评判的。这是一个不完美的衡量标准，但总比没有任何依据要好。

我希望这些库尊重版本控制，并且尽可能地限制破坏性更改。尽管如此，我无法保证这些库不会更改，也无法保证你在阅读这一章时函数将按原样工作。在代码示例中，我将突出显示正在展示的库版本，以便至少可以通过获取库的正确版本来重现结果，即使这不是最新版本。这引出了第二个，*相关*问题。

该库可能会变得不再受支持。如果您正在使用库的较旧版本来重现本章中的示例，因为最新版本引入了一些破坏性更改，那么您会遇到一些已知问题的风险，并且您可能不会得到支持，因为您正在使用较旧版本。但是，即使这里显示的示例与库的最新版本正确工作，该库仍然可能过时。如果一切按预期工作，并且库被认为是功能完整的，这并不立即是一个红旗。

然而，这也意味着找到这些库可能会有困难。确定这一点最好的方法是通过查看 GitHub（或 GitLab）页面上的任何活动。例如，最近的提交是在几天或几周前，还是几年前？贡献者是否积极回应问题，或者他们是否都未得到回复？他们是否在 Discord 或 IRC 上与社区互动？这些都是可以暗示库维护得如何的例子。

## 法律要求

我会简要介绍这部分内容，因为我不是律师。但是，任何处理开源代码的人都应该意识到，并非所有开源代码都是许可的。

注意

在与库合作之前，尤其是在商业环境中，务必审查软件许可，并确认您的用例在法律上是允许的，以及哪些条件下允许。（例如，某些许可允许带有归属的使用代码。其他许可可能仅允许非商业用途，等等。）

# 用于创建常见函数的前泛型库

无论是否有泛型，在任何编程语言中操作集合式数据结构是很常见的。存储一系列值，无论是代表测试分数的数字列表，还是医院中所有员工的集合结构，都是如此常见，以至于您迟早会遇到这些数据结构。对这些数据结构执行的操作也可以归入几个类别，尤其是当我们将它们抽象为高阶函数时。您可能必须以某种方式修改数据元素（例如，将所有值乘以二）或以某种方式修改容器（例如，删除所有奇数）。正如我们所见，我们不想实现一个像`removeOdds`或`multiplyNumbers`这样的函数，我们想写的是一个可以根据谓词过滤任何元素或根据转换修改元素的函数（这些分别是过滤和映射函数）。

在泛型引入之前，没有明确且最佳的方式来处理这个问题。当时不抽象这些用例的理由是，针对你的数据结构编写特定函数会在性能方面提供最佳结果。所以，你会放弃一些开发者舒适度，但会得到一个性能更好的应用程序。事后看来，集合上的许多操作具有相同的实现，这意味着实际上没有真正的性能差异。人们想出构建重复实现抽象的方法，这只是一个自然的结果。

广义而言，在泛型引入之前，有两条途径可以解决这个问题——要么通过针对空接口（`interface{}`）编程，这是一个任何数据类型在 Go 中隐式遵守的接口，要么通过代码生成。前者，针对`interface{}`的编程，在类型安全和运行时安全方面有太多的缺点，因此不太可能强烈推荐。但后者，代码生成，仍然值得一看，仅仅是因为代码生成在泛型世界之后仍然可能有用，尽管适用于不同的用例。

库与自定义实现

在这本书中，我们看到了创建遵循函数式编程范式的自定义函数集的方法。库可能提供更高效的实现，并可以防止你重新发明轮子。然而，如果你想保持你的依赖图轻量级，现在 Go 有了泛型，自己提供一些实现会更容易。在泛型引入之前的 Go 版本中，这样做要困难得多，我更倾向于基于库的方法。无论是基于空接口的方法还是代码生成的方法，在没有错误和头痛的情况下实现都不是很容易。

## 泛型之前的 Go 代码生成库

如同其名，代码生成是一种生成 Go 代码的技术，然后我们可以像使用常规 Go 代码一样在我们的应用程序中使用它。Go 工具链提供了所有必要的工具来实现这一点。在 Go 中，你可以给你的代码添加注释，编译器会将其解释为命令。这些注释使得在程序编译时触发特殊操作成为可能。这些注释被称为**指令**。例如，你可以在一个函数上添加注释，告诉编译器避免内联这个函数（编译器可以忽略它，所以这更像是一个建议而不是命令）：

```go
//go:noinline
func someFunc() {}
```

代码生成库背后的想法，我们将在稍后探讨，是使用这些特殊的注释可以触发为特定类型生成函数，这些函数实现了常见的函数式编程操作，如过滤、映射、归约等。我们将要探讨的第一个库，Pie，正是以这种方式工作的。

### Pie 的切片

我们将要探索的库是由 Elliot Chance 编写的 **Pie**，可在 GitHub 上找到：[`github.com/elliotchance/pie/tree/master/v1`](https://github.com/elliotchance/pie/tree/master/v1)。此库有两个版本：

+   版本 1 专注于 Go 1.17 或更低版本

+   版本 2 是用于处理泛型的较新版本，需要 Go 1.18 或更高版本才能运行

在版本 1 中，有两种使用此库的方法。您可以直接使用函数来操作常见数据类型（`[]string`、`[]float64` 或 `[]int`），或者您可以使用此库为您自己的数据类型生成函数。首先，我们将探索内置结构，然后转向为自定义类型生成函数。

#### 使用 Pie 的内置函数

Pie 支持三种数据类型的内置函数：

+   `[]string`

+   `[]float64`

+   `[]int`

这些相当常见，因此默认支持这些功能是有意义的。在本书的各个示例中，我们已经展示了如何过滤整数切片以保留仅偶数。然后，我们使用 Map 函数对它们进行平方。在 Pie 中这样做很容易，并且遵循与我们之前在 *第六章* 和之后实现的代码相同的思路。由于我们是通过使用库来完成这项工作的，让我们首先查看 `go.mod` 文件的内容，以突出显示我们正在使用 Pie 的哪个版本：

```go
go 1.17
require github.com/elliotchance/pie v1.39.0
```

注意

这显示的是 `go 1.17`，因为我们明确地正在查看在泛型引入之前可以使用的库。

现在我们已经导入了库（在运行 `go get` 之后），我们可以在我们的应用程序中使用它。让我们构建前面解释过的 Filter 和 Map 示例：

```go
package main
import (
        "fmt"
        "github.com/elliotchance/pie/pie"
)
func main() {
        out := pie.Ints{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}.
                Filter(func(i int) bool {
                        return i%2 == 0
                }).
                Map(func(i int) int { return i * i })
        fmt.Printf("result: %v\n", out)
}
```

运行此代码将输出 `result: [4 16 36 64 100]`，正如预期的那样。Pie 允许我们构建和链式调用函数，类似于我们在本书中迄今为止所看到的。开箱即用，这仅适用于字符串切片、整数和 float64。每种类型都需要在库中进行自定义实现。通过将函数附加到具体类型，它可以支持为不同数据类型定义的多个 Filter 和 Map 函数。这也是我们自己考虑过要做的事情，正如所指出的，这是一项耗时且重复的工作。

Pie 通过使用代码生成来生成每种数据类型的实现，从而减少了这部分重复工作。在这个库中代码生成是如何工作的细节超出了本书的范围，但我鼓励您在 GitHub 上查看这个库本身，并深入研究代码，以更好地理解它是如何构建的，因为这确实非常有趣。

Pie 随带了许多函数。要获取每个函数的最新列表及其描述，请查看 [`github.com/elliotchance/pie/tree/master/v1`](https://github.com/elliotchance/pie/tree/master/v1) 上的 wiki。

#### Pie 用于自定义数据类型

如果我们想为我们的自定义数据类型使用 Pie，我们需要生成执行此操作的代码：

1.  首先，让我们设置一个结构体，我们可以在所有以下示例中使用它。我们将创建一个表示狗的结构体，并为`[]Dog`类型创建一个类型别名：

    ```go
    //go:generate pie Dogs.*
    type Dogs []Dog
    type Dog struct {
        Name string
        Age  int
    }
    ```

1.  设置好之后，我们可以运行`go generate`命令，为我们的自定义数据类型生成 Pie 的所有函数。这在我们类型定义所在的目录中创建了一个新的文件`dogs_pie.go`。通过查看生成的文件，我们可以看到哪些函数被生成。例如，`Reverse`函数是专门为`Dog`数据类型生成的。这里逐字复制如下：

    ```go
    // Reverse returns a new copy of the slice with the
      elements ordered in reverse.
    // This is useful when combined with Sort to get a
      descending sort order:
    //
    //   ss.Sort().Reverse()
    //
    func (ss Dogs) Reverse() Dogs {
     // Avoid the allocation. If there is one element or
        less it is already
     // reversed.
     if len(ss) < 2 {
               return ss
     }
     sorted := make([]Dog, len(ss))
     for i := 0; i < len(ss); i++ {
        sorted[i] = ss[len(ss)-i-1]
     }
     return sorted
    }
    ```

1.  我们还可以找到为`Dog`数据类型定义的 Filter 和 Map 函数。同样，这些函数是逐字复制的，但注释已被省略：

    ```go
    func (ss Dogs) Filter(condition func(Dog) bool) (ss2
        Dogs) {
     for _, s := range ss {
        if condition(s) {
     ss2 = append(ss2, s)
          }
     }
     return
    }
    func (ss Dogs) Map(fn func(Dog) Dog) (ss2 Dogs) {
     if ss == nil {
        return nil
     }
     ss2 = make([]Dog, len(ss))
     for i, s := range ss {
        ss2[i] = fn(s)
     }
     return
    }
    ```

这种方法应该强调的是，如果您为许多不同的类型生成这些函数，您将在代码库中添加大量相似但不完全相同的代码。由于这个原因，您构建的可执行文件将更大，尽管这不再是您经常需要考虑的事情，但如果您针对的是内存可用性有限的平台，这可能会成为障碍。

话虽如此，让我们看看如何在`main`函数中的另一个示例中利用生成的函数。首先，我们将创建一些狗，每只狗都有一个名字和年龄。然后，我们将过滤出年龄大于 10 岁的狗。这些结果将根据年龄排序，并将作为结果打印出来：

```go
func main() {
        MyDogs := []pkg.Dog{
                pkg.Dog{
                        "Bucky",
                        1,
                },
                pkg.Dog{
                        "Keeno",
                        15,
                },
                pkg.Dog{
                        "Tala",
                        16,
                },
                pkg.Dog{
                        "Amigo",
                        7,
                },
        }
        results := pkg.Dogs(MyDogs).
                Filter(func(d pkg.Dog) bool {
                        return d.Age > 10
                }).SortUsing(func(a, b pkg.Dog) bool {
                return a.Age < b.Age
        })
        fmt.Printf("results: %v\n", results)
}
```

给定这个输入，我们得到以下输出：

```go
results: [{Keeno 15} {Tala 16}]
```

在 Pie 中，对于 Go 的预泛型版本，还有更多功能可以探索。但现在让我们将焦点转移到当代 Go 代码上，看看自 Go 1.18 以来我们可以利用的库。

go generate 和 go 环境

要使用 Pie 或通过`go get`下载的任何其他可执行文件运行`go generate`，您需要确保您的环境设置已正确配置，以便发现此类可执行文件。在基于*nix 的系统上，这意味着需要将`go/bin`添加到`$PATH`变量中。在 Windows 上，您需要将`go/bin`添加到环境变量中。在最坏的情况下，您可以下载 GitHub 源代码或查找下载 go 依赖项的目录，并通过`go install`自行构建它们，然后将可执行文件移动到已为您系统注册的环境位置。

饼图和 Hasgo

为了保持透明度，还有一个库遵循与 Pie 类似的方法，但将函数定制为类似 Haskell 的实现。这个库叫做 **Hasgo** ([`github.com/DylanMeeus/hasgo`](https://github.com/DylanMeeus/hasgo))，我是它的作者。虽然这两个库的工作方式相似，但 Pie 提供了更多的内置函数，并且完全支持 Go 1.18。但是，如果你之前编写过 Haskell，Hasgo 在函数命名和文档方面可能感觉更熟悉。

# 泛型之后的函数式编程库

自从 Go 中引入泛型以来，函数式编程库的受欢迎程度有所上升。不再需要与空接口纠缠，也不必依赖代码生成来构建构成函数式编程语言的基础。在本节中，我们将探索几个库，并比较它们的实现方式。在这样做的时候，我们将坚持使用大致相同但可能展示一些与本书中迄今为止所见不同的函数的示例。

## 带有泛型的 Pie

我们将要查看的第一个库是 Pie。在上一节中，我们指出目前有两个版本的 Pie 可用：v1，它针对泛型引入之前的 Go 进行了定制；v2，它提供了相同的功能，但利用泛型来实现。v2 正在积极维护，因此我预计随着时间的推移，v1 和 v2 将不再提供功能对等。尽管如此，Go 社区在尽可能的地方都很好地采用了最新的 Go 版本，所以我不认为这会成为任何人的障碍。

在我们深入代码之前，这是 `go.mod` 文件的片段，只是为了突出我们正在使用 Pie 的哪个版本：

```go
go 1.18
require github.com/elliotchance/pie/v2 v2.3.0
```

`go 1.18` 语句表示我们可以使用泛型，因为泛型是在这个版本中引入的。任何高于 1.18 的版本都将适用于我们即将看到的示例。

与泛型之前的示例一样，我们将使用 `Dog` 结构体和 `[]Dog` 类型的切片。与之前的非泛型示例不同，我们不需要添加编译器指令来生成任何代码，也不需要为 `[]Dog` 添加类型别名（尽管在实际应用中使用它仍然是一种好的实践）：

```go
type Dog struct {
        Name string
        Age  int
}
```

在 `main` 函数中，我们将创建一个狗的切片。然后，我们将再次筛选出年龄大于 10 岁的狗。然后，我们将它们的名称映射为大写，最后按年龄返回排序后的结果：

```go
import"github.com/elliotchance/pie/v2"
func main() {
        MyDogs := []Dog{
                Dog{
                        "Bucky",
                        1,
                },
                Dog{
                        "Keeno",
                        15,
                },
                Dog{
                        "Tala",
                        16,
                },
                Dog{
                        "Amigo",
                        7,
                },
        }
        result := pie.Of(MyDogs).
                Filter(func(d Dog) bool {
                        return d.Age > 10
                }).Map(func(d Dog) Dog {
                d.Name = strings.ToUpper(d.Name)
                return d
        }).
                SortUsing(func(a, b Dog) bool {
                        return a.Age < b.Age
                })
        fmt.Printf("out: %v\n", result)
}
```

如您所见，代码与预泛型版本非常相似。然而，没有使用代码生成来实现这一点。此外，请注意 `pie.Of()` 确定了我们正在操作的数据类型。在预泛型版本中，这是我们必须为 `[]Dog` 创建类型别名的原因之一——这样代码生成器就可以使用 Filter、Map、Reduce 或其他方法为正确的切片类型附加它，并用于点符号风格的函数链式调用。有了泛型，我们就不再需要这样做。一般来说，如果你想在团队中引入泛型，Pie 是一个很好的库去探索，因为熟悉点符号风格的函数调用链对于习惯了面向对象方法的开发者来说看起来很自然。如前所述，它有一套广泛的函数可以直接使用。接下来，让我们看看一个基于 **Lodash** 的函数式编程库。

## Lodash，适用于 Go

**lo** ([`github.com/samber/lo`](https://github.com/samber/lo)) 是一个库，类似于 Pie，它为 Go 添加了易于使用的功能，并且目前非常受欢迎。它受到了 JavaScript 中极其流行的 Lodash 库 ([`github.com/lodash/lodash`](https://github.com/lodash/lodash)) 的启发，该库目前在 GitHub 上有超过 55,000 个星标，并且被广泛使用。

目前，lo 支持 38 个在切片上操作的功能，其中 16 个操作在 Map 数据类型上，还有许多方便的搜索、元组、通道和（集合）交集样式操作的功能。在这里概述所有这些功能并不实际，但如果你的问题需要操作这些常见的容器数据类型，那么在重新发明轮子之前检查这个库是否满足你的需求是个好主意。在本节中，我们将查看一个与用于 Pie 的示例类似的例子。

### 使用 lo 的一个示例实现

由于我们正在导入一个新的库，以下代码片段显示了我们将用于这些示例的库及其版本：

```go
go 1.18
require (
        github.com/samber/lo v1.37.0
)
```

为了演示这个库，我们还将使用一个 `main` 函数和狗的切片。在这种情况下，我们想要做以下事情。首先，我们将去除切片中的重复项，以确保切片中的每个元素都是唯一的。然后，我们将所有狗的名字转换为大写形式。这是我们将会打印的结果：

```go
func main() {
        result :=
                lo.Map(lo.Uniq(MyDogs), func(d Dog, i int)
                    Dog {
                        d.Name = strings.ToUpper(d.Name)
                        return d
                })
        fmt.Printf("%v\n", result)
}
```

在这个小型示例中，您可以看到库的使用更像是（纯）函数式编程语言选择的一种风格，而不是面向对象代码中常见的点符号风格。我们通过将它们作为高阶函数的输入参数来链式调用函数调用。请注意，这些不是惰性求值的。在前面的示例中，首先运行 `Uniq` 函数，它从我们的输入切片中删除重复条目。然后运行 `Map` 函数并应用转换。记住，我们通过调用 `d.Name = ...` 来修改 `Dog` 结构体，但这不会修改原始数据元素。我们在这本书的前几章中对此进行了更详细的探讨。

有一个额外的功能值得指出。`lo` 包含了支持并发函数调用的库的子集。在 `lo` 的 `lo/parallel` 目录下有一个包，支持函数调用的并行评估。让我们重写我们的示例，但让 `Map` 函数以并发方式工作。（**此外，请注意，这个包被称为 parallel，但讨论的是** **并发代码**）。

首先，这是导入语句和导入别名：

```go
        lop "github.com/samber/lo/parallel"
```

接下来，这是运行 `Map` 函数的并发代码，而 `Uniq` 函数仍然按顺序运行：

```go
        result :=
                lop.Map(lo.Uniq(MyDogs), func(d Dog, i int)
                    Dog {
                        d.Name = strings.ToUpper(d.Name)
                        return d
                })
        fmt.Printf("%v\n", result)
```

这几乎不需要我们进行重构，但利用了 goroutines 来实现并发。相当不错！

为了结束这一章，让我们看看由 `lo` 的同一作者编写的一个库，该库包含类似于 monad 的数据结构，例如我们曾在 *第五章* 中探讨的 `Maybe` 数据类型。

## Mo，为 go

Mo 是一个在 Go 中添加对类似 monad 数据结构支持的库，并且相对流行。它完全支持 Go 1.18+，因此是围绕泛型构建的。您可以在以下位置找到该包本身：[`github.com/samber/mo`](https://github.com/samber/mo)。

值得花时间探索这个库并阅读文档，特别是当您阅读这本书时，这可能已经发生了变化。本质上，它的工作方式与 *第五章* 中的 `Maybe` 实现相同，尽管在这个库中，该类型被称为 `Option`。我们可以创建一个可选包含值的类型，但也可以表示值的缺失。然后，这个数据类型支持转换数据或以 nil 安全的方式获取数据的函数。例如，让我们创建一个包含狗的选项：

```go
func main() {
        maybe := mo.Some(Dog{"Bucky", 1})
        getOrElse := maybe.OrElse(Dog{})
        fmt.Println(getOrElse)
}
```

这将打印以下内容：

```go
{Bucky 1}
```

现在，如果我们使用这个来表示 `nil` 值，我们仍然可以以类型安全的方式访问它。`OrElse` 函数将确保使用备份作为函数调用的结果，这是调用者提供的默认值。例如，让我们在我们的 `main` 函数中添加以下代码：

```go
        maybe2 := mo.None[Dog]()
        getOrElse2 := maybe2.OrElse(Dog{"Default", -1})
        fmt.Println(getOrElse2)
```

输出将看起来像这样：

```go
{Default -1}
```

这个库还支持其他类型，例如`Future`和`Task`。但其中一个特别有用的类型是`Result`类型，它或多或少类似于`Maybe`类型，但旨在处理值可以可选地包含错误的情况。我们将在下面的代码片段中演示这一点。首先，我们将调用`Ok()`函数，它使用有效的`Dog`对象创建`Result`类型。在第二种情况下，我们将使用错误而不是`Dog`对象来创建`Result`类型。在这两种情况下，我们将尝试获取并打印结果以及错误信息：

```go
        ok := mo.Ok(MyDogs[0])
        result1 := ok.OrElse(Dog{})
        err1 := ok.Error()
        fmt.Println(result1, err1)
        err := errors.New("dog not found")
        ok2 := mo.ErrDog
        result2 := ok2.OrElse(Dog{"Default", -1})
        err2 := ok2.Error()
        fmt.Println(result2, err2)
```

如果我们运行这个函数，我们将得到以下输出：

```go
{Bucky 1} <nil>
{Default -1} dog not found
```

这表明根据`Result`的`error`值的内容，类型的行为是不同的。在第一种情况下，我们没有错误，我们得到正确的狗，错误为空。在第二种情况下，我们得到作为`OrElse`语句一部分提供的默认值，以及底层错误信息。

# 摘要

在本章中，我们探讨了实现函数式编程范式概念的库。我们首先了解了 Pie 库，这个库可以帮助用户在 Go 1.18 引入泛型之前或之后使用 Go 构建函数式编程的代码。特别是对于泛型之前的版本，我们研究了为自定义类型生成代码以获得类似泛型行为的方法。Pie 库使我们能够展示自从引入泛型以来，我们能够多么容易地创建如 Map 和 Filter 之类的函数。

然后，我们探讨了受 Lodash 启发的 Go 库`lo`。这个库支持在切片和映射等容器数据类型上操作的一些常见函数，但与 Pie 不同，它采用嵌套方法进行函数链式调用，而不是点符号语法。`lo`库为某些函数提供了并发实现，所以如果性能是一个关注点，并且并发似乎是正确的解决方案，那么检查这个库是个好主意。

最后，我们探讨了添加到 Go 中的类似 monad 的数据结构库`mo`。具体来说，我们探讨了`Option`数据结构，它与我们在*第五章*中创建的`Maybe`数据结构类似。`mo`还提供了一个`Result`类型，它是为错误处理而构建的，并允许我们在处理潜在的`error`值时编写更安全的代码。
