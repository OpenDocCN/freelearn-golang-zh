- en: Chapter 3. Structural Patterns - Composite, Adapter, and Bridge Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。结构模式 - 组合，适配器和桥接设计模式
- en: We are going to start our journey through the world of structural patterns.
    Structural patterns, as the name implies, help us to shape our applications with
    commonly used structures and relationships.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始我们的结构模式之旅。结构模式，顾名思义，帮助我们用常用的结构和关系来塑造我们的应用程序。
- en: The Go language, by nature, encourages use of composition almost exclusively
    by its lack of inheritance. Because of this, we have been using the **Composite**
    design pattern extensively until now, so let's start by defining the Composite
    design pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言本质上鼓励使用组合，几乎完全不使用继承。因此，我们一直在广泛使用**组合**设计模式，所以让我们从定义组合设计模式开始。
- en: Composite design pattern
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合设计模式
- en: The Composite design pattern favors composition (commonly defined as a *has
    a* relationship) over inheritance (an *is a* relationship). The c*omposition over
    inheritance* approach has been a source of discussions among engineers since the
    nineties. We will learn how to create object structures by using a *has a* approach.
    All in all, Go doesn't have inheritance because it doesn't need it!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式倾向于组合（通常定义为*拥有*关系）而不是继承（*是*关系）。自上世纪九十年代以来，*组合优于继承*的方法一直是工程师之间讨论的话题。我们将学习如何使用*拥有*方法创建对象结构。总的来说，Go没有继承，因为它不需要！
- en: Description
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: 'In the Composite design pattern, you will create hierarchies and trees of objects.
    Objects have different objects with their own fields and methods inside them.
    This approach is very powerful and solves many problems of inheritance and multiple
    inheritances. For example, a typical inheritance problem is when you have an entity
    that inherits from two completely different classes, which have absolutely no
    relationship between them. Imagine an athlete who trains, and who is a swimmer who
    swims:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合设计模式中，您将创建对象的层次结构和树。对象内部有不同的对象，具有它们自己的字段和方法。这种方法非常强大，解决了继承和多重继承的许多问题。例如，典型的继承问题是当您有一个实体从两个完全不同的类继承时，它们之间绝对没有关系。想象一个训练的运动员，和一个游泳的游泳者：
- en: The `Athlete` class has a `Train()` method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Athlete`类有一个`Train()`方法'
- en: The `Swimmer` class has a `Swim()` method
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Swimmer`类有一个`Swim()`方法'
- en: The `Swimmer` class inherits from the `Athlete` class, so it inherits its `Train`
    method and declares its own `Swim` method. You could also have a cyclist who is
    also an athlete, and declares a `Ride` method.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swimmer`类继承自`Athlete`类，因此它继承了其`Train`方法并声明了自己的`Swim`方法。您还可以有一个自行车手，也是一名运动员，并声明了一个`Ride`方法。'
- en: 'But now imagine an animal that eats, like a dog that also barks:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在想象一下，一种会吃东西的动物，比如一只也会叫的狗：
- en: The `Cyclist` class has a `Ride()` method
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cyclist`类有一个`Ride()`方法'
- en: The `Animal` class has `Eat()`, `Dog()`, and `Bark()` methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animal`类有`Eat()`，`Dog()`和`Bark()`方法'
- en: Nothing fancy. You could also have a fish that is an animal, and yes, swims!
    So, how do you solve it? A fish cannot be a swimmer that also trains. Fish don't
    train (as far as I know!). You could make a `Swimmer` interface with a `Swim`
    method, and make the swimmer athlete and fish implement it. This would be the
    best approach, but you still would have to implement `swim` method twice, so code
    reusability would be affected. What about a triathlete? They are athletes who
    swim, run, and ride. With multiple inheritances, you could have a sort of solution,
    but that will become complex and not maintainable very soon.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 没有花哨的东西。您也可以有一条鱼是一种动物，是的，会游泳！那么，您如何解决呢？鱼不能是一个还会训练的游泳者。鱼不训练（据我所知！）。您可以创建一个带有`Swim`方法的`Swimmer`接口，并使游泳者运动员和鱼实现它。这将是最好的方法，但您仍然必须两次实现`swim`方法，因此代码的可重用性将受到影响。那么三项全能运动员呢？他们是游泳，跑步和骑车的运动员。通过多重继承，您可以有一种解决方案，但这很快就会变得复杂且难以维护。
- en: Objectives
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: As you have probably imagined already, the objective of the composition is to
    avoid this type of hierarchy hell where the complexity of an application could
    grow too much, and the clarity of the code is affected.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经想象的那样，组合的目标是避免这种层次结构混乱，其中应用程序的复杂性可能会增长太多，代码的清晰度受到影响。
- en: The swimmer and the fish
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游泳者和鱼
- en: We will solve the described problem of the athlete and the fish that swims in
    a very idiomatic Go way. With Go, we can use two types of composition--the **direct**
    composition and the **embedding** composition. We will first solve this problem
    by using direct composition which is having everything that is needed as fields
    within the struct.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以Go的方式解决运动员和游泳的鱼的问题。在Go中，我们可以使用两种类型的组合--**直接**组合和**嵌入**组合。我们将首先通过使用直接组合来解决这个问题，即在结构体内部拥有所需的一切。
- en: Requirements and acceptance criteria
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求和验收标准
- en: 'Requirements are like the ones described previously. We''ll have an athlete
    and a swimmer. We will also have an animal and a fish. The `Swimmer` and the `Fish` methods
    must share the code. The athlete must train, and the animal must eat:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要求与之前描述的要求相似。我们将有一个运动员和一个游泳者。我们还将有一个动物和一条鱼。`Swimmer`和`Fish`方法必须共享代码。运动员必须训练，动物必须吃：
- en: We must have an `Athlete` struct with a `Train` method
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个带有`Train`方法的`Athlete`结构
- en: We must have a `Swimmer` with a `Swim` method
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个带有`Swim`方法的`Swimmer`
- en: We must have an `Animal` struct with an `Eat` method
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个带有`Eat`方法的`Animal`结构
- en: We must have a `Fish` struct with a `Swim` method that is shared with the `Swimmer`,
    and not have inheritance or hierarchy issues
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个带有`Swim`方法的`Fish`结构，该方法与`Swimmer`共享，而不会出现继承或层次结构问题
- en: Creating compositions
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建组合
- en: The Composite design pattern is a pure structural pattern, and it doesn't have
    much to test apart from the structure itself. We won't write unit tests in this
    case, and we'll simply describe the ways to create those compositions in Go.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式是一种纯粹的结构模式，除了结构本身之外，没有太多需要测试的地方。在这种情况下，我们不会编写单元测试，而只是描述在Go中创建这些组合的方法。
- en: 'First, we''ll start with the `Athlete` structure and its `Train` method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从`Athlete`结构和其`Train`方法开始：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is pretty straightforward. Its `Train` method prints the
    word `Training` and a new line. We''ll create a composite swimmer that has an
    `Athlete` struct inside it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常简单。它的`Train`方法打印单词`Training`和一个换行符。我们将创建一个具有`Athlete`结构的复合游泳者：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `CompositeSwimmerA` type has a `MyAthlete` field of type `Athlete`. It
    also stores a `func()` type. Remember that in Go, functions are first-class citizens
    and they can be used as parameters, fields, or arguments just like any variable.
    So `CompositeSwimmerA` has a `MySwim` field that stores a **closure**, which takes
    no arguments and returns nothing. How can I assign a function to it? Well, let''s
    create a function that matches the `func()` signature (no arguments, no return):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompositeSwimmerA`类型有一个`Athlete`类型的`MyAthlete`字段。它还存储一个`func()`类型。请记住，在Go中，函数是一等公民，它们可以像任何变量一样作为参数、字段或参数使用。因此，`CompositeSwimmerA`有一个`MySwim`字段，其中存储了一个**闭包**，它不带参数并且不返回任何内容。我如何将函数分配给它呢？好吧，让我们创建一个与`func()`签名匹配的函数（无参数，无返回）：'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That''s all! The `Swim()` function takes no arguments and returns nothing,
    so it can be used as the `MySwim` field in the `CompositeSwimmerA` struct:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！`Swim()`函数不带参数并且不返回任何内容，因此它可以用作`CompositeSwimmerA`结构中的`MySwim`字段：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because we have a function called `Swim()`, we can assign it to the `MySwim`
    field. Note that the `Swim` type doesn't have the parenthesis that will execute
    its contents. This way we take the entire function and copy it to `MySwim` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们有一个名为`Swim()`的函数，我们可以将其分配给`MySwim`字段。请注意，`Swim`类型没有括号，这将执行其内容。这样我们就可以将整个函数复制到`MySwim`方法中。
- en: 'But wait. We haven''t passed any athlete to the `MyAthlete` field and we are
    using it! It''s going to fail! Let''s see what happens when we execute this snippet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。我们还没有将运动员传递给`MyAthlete`字段，我们正在使用它！这将失败！让我们看看执行此片段时会发生什么：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That''s weird, isn''t it? Not really because of the nature of zero-initialization
    in Go. If you don''t pass an `Athlete` struct to the `CompositeSwimmerA` type,
    the compiler will create one with its values zero-initialized, that is, an `Athlete`
    struct with its fields initialized to zero. Check out [Chapter 1](ch01.html "Chapter 1. Ready...
    Steady... Go!"), *Ready... Steady... Go!* to recall zero-initialization if this
    seems confusing. Consider the `CompositeSwimmerA` struct code again:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这很奇怪，不是吗？实际上并不是，因为Go中的零初始化的性质。如果您没有将`Athlete`结构传递给`CompositeSwimmerA`类型，编译器将创建一个其值为零初始化的结构，也就是说，一个`Athlete`结构，其字段的值初始化为零。如果这看起来令人困惑，请查看[第1章](ch01.html
    "第1章。准备...开始...跑！")*准备...开始...跑！*来回顾零初始化。再次考虑`CompositeSwimmerA`结构代码：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we have a pointer to a function stored in the `MySwim` field. We can assign
    the `Swim` function the same way, but with an extra step:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个存储在`MySwim`字段中的函数指针。我们可以以相同的方式分配`Swim`函数，但需要多一步：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we need a variable that contains the function `Swim`. This is because
    a function doesn't have an address to pass it to the `CompositeSwimmerA` type.
    Then, to use this function within the struct, we have to make a two-step call.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个包含函数`Swim`的变量。这是因为函数没有地址，无法将其传递给`CompositeSwimmerA`类型。然后，为了在结构体内使用这个函数，我们必须进行两步调用。
- en: 'What about our fish problem? With our `Swim` function, it is not a problem
    anymore. First, we create the `Animal` struct:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们的鱼问题呢？有了我们的`Swim`函数，这不再是问题。首先，我们创建`Animal`结构：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we''ll create a `Shark` object that embeds the `Animal` object:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将创建一个嵌入`Animal`对象的`Shark`对象：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Wait a second! Where is the field name of the `Animal` type? Did you realize
    that I used the word *embed* in the previous paragraph? This is because, in Go,
    you can also embed objects within objects to make it look a lot like inheritance.
    That is, we won''t have to explicitly call the field name to have access to its
    fields and method because they''ll be part of us. So the following code will be
    perfectly okay:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！`Animal`类型的字段名在哪里？你有没有意识到我在上一段中使用了*embed*这个词？这是因为在Go中，您还可以将对象嵌入到对象中，使其看起来很像继承。也就是说，我们不必显式调用字段名来访问其字段和方法，因为它们将成为我们的一部分。因此，以下代码将是完全正常的：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we have an `Animal` type, which is zero-initialized and embedded. This
    is why I can call the `Eat` method of the `Animal` struct without creating it
    or using the intermediate field name. The output of this snippet is the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`Animal`类型，它是零初始化并嵌入的。这就是为什么我可以调用`Animal`结构的`Eat`方法而不创建它或使用中间字段名。此片段的输出如下：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, there is a third method to use the Composite pattern. We could create
    a `Swimmer` interface with a `Swim` method and a `SwimmerImpl` type to embed it
    in the athlete swimmer:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有第三种使用组合模式的方法。我们可以创建一个带有`Swim`方法的`Swimmer`接口和一个`SwimmerImpl`类型，将其嵌入到运动员游泳者中：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this method, you have more explicit control over object creation. The
    `Swimmer` field is embedded, but won''t be zero-initialized as it is a pointer
    to an interface. The correct use of this approach will be the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，您可以更明确地控制对象的创建。`Swimmer`字段被嵌入，但不会被零初始化，因为它是一个指向接口的指针。这种方法的正确使用将是以下方式：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the output for `CompositeSwimmerB` is the following, as expected:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompositeSwimmerB`的输出如下，如预期的那样：'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Which approach is better? Well, I have a personal preference, which shouldn't
    be considered the rule of thumb. In my opinion, the *interfaces* approach is the
    best for quite a few reasons, but mainly for explicitness. First of all, you are
    working with interfaces  which are preferred instead of structs. Second, you aren't
    leaving parts of your code to the zero-initialization feature of the compiler.
    It's a really powerful feature, but one that must be used with care, because it
    can lead to runtime problems which you'll find at compile time when working with
    interfaces. In different situations, zero-initialization will save you at runtime,
    in fact! But I prefer to work with interfaces as much as possible, so this is
    not actually one of the options.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更好？嗯，我有个人偏好，不应被视为金科玉律。在我看来，*接口*方法是最好的，原因有很多，但主要是因为明确性。首先，您正在使用首选的接口而不是结构。其次，您不会将代码的部分留给编译器的零初始化特性。这是一个非常强大的功能，但必须小心使用，因为它可能导致运行时问题，而在使用接口时，您会在编译时发现这些问题。在不同的情况下，零初始化实际上会在运行时为您节省，事实上！但我尽可能多地使用接口，所以这实际上并不是一个选项。
- en: Binary Tree compositions
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉树组合
- en: 'Another very common approach to the Composite pattern is when working with
    Binary Tree structures. In a Binary Tree, you need to store instances of itself
    in a field:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种非常常见的组合模式是在使用二叉树结构时。在二叉树中，您需要在字段中存储自身的实例：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is some kind of recursive compositing, and, because of the nature of recursivity,
    we must use pointers so that the compiler knows how much memory it must reserve
    for this struct. Our `Tree` struct stored a `LeafValue` object for each instance
    and a new `Tree` in its `Right` and `Left` fields.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种递归组合，由于递归的性质，我们必须使用指针，以便编译器知道它必须为此结构保留多少内存。我们的`Tree`结构为每个实例存储了一个`LeafValue`对象，并在其`Right`和`Left`字段中存储了一个新的`Tree`。
- en: 'With this structure, we could create an object like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个结构，我们可以创建一个对象，就像这样：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can print the contents of its deepest branch like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样打印其最深层分支的内容：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Composite pattern versus inheritance
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合模式与继承
- en: 'When using the Composite design pattern in Go, you must be very careful not
    to confuse it with inheritance. For example, when you embed a `Parent` struct
    within a `Son` struct, like in the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中使用组合设计模式时，必须非常小心，不要将其与继承混淆。例如，当您在`Son`结构中嵌入`Parent`结构时，就像以下示例中一样：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You cannot consider that the `Son` struct is also the `Parent` struct. What
    this means is that you cannot pass an instance of the `Son` struct to a function
    that is expecting a `Parent` struct like the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能认为`Son`结构也是`Parent`结构。这意味着您不能将`Son`结构的实例传递给期望`Parent`结构的函数，就像以下示例中一样：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you try to pass a `Son` instance to the `GetParentField` method, you will
    get the following error message:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试将`Son`实例传递给`GetParentField`方法时，您将收到以下错误消息：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This, in fact, makes a lot of sense. What''s the solution for this? Well, you
    can simply composite the `Son`  struct with the parent without embedding so that
    you can access the `Parent` instance later:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这是有很多道理的。这个问题的解决方案是什么？嗯，您可以简单地将`Son`结构与父结构组合起来，而不是嵌入，以便稍后可以访问`Parent`实例：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So now you could use the `P` field to pass it to the `GetParentField` method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在你可以使用`P`字段将其传递给`GetParentField`方法：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Final words on the Composite pattern
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于组合模式的最后几句话
- en: At this point, you should be really comfortable using the Composite design pattern.
    It's a very idiomatic Go feature, and the switch from a pure object-oriented language
    is not very painful. The Composite design pattern makes our structures predictable
    but also allows us to create most of the design patterns as we will see in later
    chapters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该真的很熟悉使用组合设计模式。这是Go语言中非常惯用的特性，从纯面向对象的语言切换过来并不是非常痛苦的。组合设计模式使我们的结构可预测，但也允许我们创建大多数设计模式，正如我们将在后面的章节中看到的。
- en: Adapter design pattern
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器设计模式
- en: One of the most commonly used structural patterns is the **Adapter** pattern.
    Like in real life, where you have plug adapters and bolt adapters, in Go, an adapter
    will allow us to use something that wasn't built for a specific task at the beginning.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的结构模式之一是**适配器**模式。就像在现实生活中，您有插头适配器和螺栓适配器一样，在Go中，适配器将允许我们使用最初未为特定任务构建的东西。
- en: Description
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Adapter pattern is very useful when, for example, an interface gets outdated
    and it's not possible to replace it easily or fast. Instead, you create a new
    interface to deal with the current needs of your application, which, under the
    hood, uses implementations of the old interface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当接口过时且无法轻松或快速替换时，适配器模式非常有用。相反，您可以创建一个新接口来处理应用程序当前需求，该接口在底层使用旧接口的实现。
- en: Adapter also helps us to maintain the *open/closed principle* in our apps, making
    them more predictable too. They also allow us to write code which uses some base
    that we can't modify.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器还帮助我们在应用程序中保持*开闭原则*，使其更可预测。它们还允许我们编写使用一些无法修改的基础的代码。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The open/closed principle was first stated by Bertrand Meyer in his book *Object-Oriented
    Software Construction*. He stated that code should be open to new functionality,
    but closed to modifications. What does it mean? Well, it implies a few things.
    On one hand, we should try to write code that is extensible and not only one that
    works. At the same time, we should try not to modify the source code (yours or
    other people's) as much as we can, because we aren't always aware of the implications
    of this modification. Just keep in mind that extensibility in code is only possible
    through the use of design patterns and interface-oriented programming.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 开闭原则首次由Bertrand Meyer在他的书《面向对象的软件构造》中提出。他指出代码应该对新功能开放，但对修改关闭。这是什么意思？嗯，这意味着一些事情。一方面，我们应该尝试编写可扩展的代码，而不仅仅是可工作的代码。同时，我们应该尽量不修改源代码（你的或其他人的），因为我们并不总是意识到这种修改的影响。只需记住，代码的可扩展性只能通过设计模式和面向接口的编程来实现。
- en: Objectives
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: The Adapter design pattern will help you fit the needs of two parts of the code
    that are incompatible at first. This is the key to being kept in mind when deciding
    if the Adapter pattern is a good design for your problem--two interfaces that
    are incompatible, but which must work together, are good candidates for an Adapter
    pattern (but they could also use the facade pattern, for example).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器设计模式将帮助您满足最初不兼容的代码部分的需求。这是在决定适配器模式是否适合您的问题时要牢记的关键点——最初不兼容但必须一起工作的两个接口是适配器模式的良好候选对象（但它们也可以使用外观模式，例如）。
- en: Using an incompatible interface with an Adapter object
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用不兼容的接口与适配器对象
- en: For our example, we will have an old `Printer` interface and a new one. Users
    of the new interface don't expect the signature that the old one has, and we need
    an Adapter so that users can still use old implementations if necessary (to work
    with some legacy code, for example).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将有一个旧的`Printer`接口和一个新的接口。新接口的用户不希望旧接口的签名，并且我们需要一个适配器，以便用户仍然可以在必要时使用旧的实现（例如与一些旧代码一起工作）。
- en: Requirements and acceptance criteria
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求和验收标准
- en: 'Having an old interface called `LegacyPrinter` and a new one called `ModernPrinter`,
    create a structure that implements the `ModernPrinter` interface and can use the
    `LegacyPrinter` interface as described in the following steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`LegacyPrinter`的旧接口和一个名为`ModernPrinter`的新接口，创建一个结构来实现`ModernPrinter`接口，并按照以下步骤使用`LegacyPrinter`接口：
- en: Create an Adapter object that implements the `ModernPrinter` interface.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现`ModernPrinter`接口的适配器对象。
- en: The new Adapter object must contain an instance of the `LegacyPrinter` interface.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的适配器对象必须包含`LegacyPrinter`接口的实例。
- en: When using `ModernPrinter`, it must call the `LegacyPrinter` interface under
    the hood, prefixing it with the text `Adapter`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`ModernPrinter`时，它必须在后台调用`LegacyPrinter`接口，并在前面加上文本`Adapter`。
- en: Unit testing our Printer adapter
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试我们的打印机适配器
- en: 'We will write the legacy code first, but we won''t test it as we should imagine
    that it isn''t our code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写旧代码，但不会测试它，因为我们应该想象它不是我们的代码：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The legacy interface called `LegacyPrinter` has a `Print` method that accepts
    a string and returns a message. Our `MyLegacyPrinter` struct implements the `LegacyPrinter` interface
    and modifies the passed string by prefixing the text `Legacy Printer:`. After
    modifying the text, the `MyLegacyPrinter` struct prints the text on the console,
    and then returns it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`LegacyPrinter`的旧接口有一个接受字符串并返回消息的`Print`方法。我们的`MyLegacyPrinter`结构实现了`LegacyPrinter`接口，并通过在传递的字符串前加上文本`Legacy
    Printer:`来修改传递的字符串。在修改文本后，`MyLegacyPrinter`结构将文本打印到控制台，然后返回它。
- en: 'Now we''ll declare the new interface that we''ll have to adapt:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将声明我们需要适配的新接口：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this case, the new `PrintStored` method doesn''t accept any string as an
    argument, because it will have to be stored in the implementers in advance. We
    will call our Adapter pattern''s `PrinterAdapter` interface:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，新的`PrintStored`方法不接受任何字符串作为参数，因为它必须提前存储在实现者中。我们将调用我们的适配器模式的`PrinterAdapter`接口：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As mentioned earlier, the `PrinterAdapter` adapter must have a field to store
    the string to print. It must also have a field to store an instance of the `LegacyPrinter`
    adapter. So let''s write the unit tests:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`PrinterAdapter`适配器必须有一个字段来存储要打印的字符串。它还必须有一个字段来存储`LegacyPrinter`适配器的实例。因此，让我们编写单元测试：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will use the message `Hello World!` for our adapter. When using this message
    with an instance of the `MyLegacyPrinter` struct, it prints the text `Legacy Printer:
    Hello World!`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将使用消息`Hello World!`作为我们的适配器。当将此消息与`MyLegacyPrinter`结构的实例一起使用时，它会打印文本`Legacy
    Printer: Hello World!`：'
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We created an instance of the `PrinterAdapter` interface called `adapter`.
    We passed an instance of the `MyLegacyPrinter` struct as the `LegacyPrinter` field
    called `OldPrinter`. Also, we set the message we want to print in the `Msg` field:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`adapter`的`PrinterAdapter`接口的实例。我们将`MyLegacyPrinter`结构的实例作为`LegacyPrinter`字段传递给`OldPrinter`。此外，我们在`Msg`字段中设置要打印的消息：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we used the `PrintStored` method of the `ModernPrinter` interface; this
    method doesn''t accept any argument and must return the modified string. We know
    that the `MyLegacyPrinter` struct returns the passed string prefixed with the
    text `LegacyPrinter:`, and the adapter will prefix it with the text `Adapter:`
    So, in the end, we must have the text `Legacy Printer: Adapter: Hello World!\n`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '然后我们使用了`ModernPrinter`接口的`PrintStored`方法；这个方法不接受任何参数，必须返回修改后的字符串。我们知道`MyLegacyPrinter`结构返回传递的字符串，并在前面加上文本`LegacyPrinter:`，适配器将在前面加上文本`Adapter:`。因此，最终我们必须有文本`Legacy
    Printer: Adapter: Hello World!\n`。'
- en: 'As we are storing an instance of an interface, we must also check that we handle
    the situation where the pointer is nil. This is done with the following test:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在存储接口的实例，因此我们还必须检查我们处理指针为nil的情况。这是通过以下测试完成的：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we don''t pass an instance of the `LegacyPrinter` interface, the Adapter
    must ignore its adapt nature, and simply print and return the original message.
    Time to run our tests; consider the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有传递`LegacyPrinter`接口的实例，适配器必须忽略其适配性质，简单地打印并返回原始消息。是时候运行我们的测试了；考虑以下内容：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implementation
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'To make our single test pass, we must reuse the old `MyLegacyPrinter` that
    is stored in `PrinterAdapter` struct:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的单个测试通过，我们必须重用存储在`PrinterAdapter`结构中的旧`MyLegacyPrinter`：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `PrintStored` method, we check whether we actually have an instance of
    a `LegacyPrinter`. In this case, we compose a new string with the stored message
    and the `Adapter` prefix to store it in the returning variable (called `newMsg`).
    Then we use the pointer to the `MyLegacyPrinter` struct to print the composed
    message using the `LegacyPrinter` interface.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PrintStored`方法中，我们检查是否实际上有一个`LegacyPrinter`的实例。在这种情况下，我们将存储的消息和`Adapter`前缀组合成一个新的字符串，以便将其存储在返回变量（称为`newMsg`）中。然后我们使用指向`MyLegacyPrinter`结构的指针来使用`LegacyPrinter`接口打印组合的消息。
- en: 'In case there is no `LegacyPrinter` instance stored in the `OldPrinter` field,
    we simply assign the stored message to the returning variable `newMsg` and return
    the method. This should be enough to pass our tests:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`OldPrinter`字段中没有存储`LegacyPrinter`实例，我们只需将存储的消息分配给返回变量`newMsg`并返回该方法。这应该足以通过我们的测试：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Perfect! Now we can still use the old `LegacyPrinter` interface by using this
    `Adapter` while we use the `ModernPrinter` interface for future implementations.
    Just keep in mind that the Adapter pattern must ideally just provide the way to
    use the old `LegacyPrinter` and nothing else. This way, its scope will be more
    encapsulated and more maintainable in the future.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在我们可以通过使用这个`Adapter`来继续使用旧的`LegacyPrinter`接口，同时我们可以为将来的实现使用`ModernPrinter`接口。只要记住，适配器模式理想上只提供使用旧的`LegacyPrinter`的方法，而不提供其他任何东西。这样，它的范围将更加封装和在将来更易于维护。
- en: Examples of the Adapter pattern in Go's source code
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go源代码中适配器模式的示例
- en: 'You can find Adapter implementations at many places in the Go language''s source
    code. The famous `http.Handler` interface has a very interesting adapter implementation.
    A very simple, `Hello World` server in Go is usually done like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Go语言源代码的许多地方找到适配器实现。著名的`http.Handler`接口有一个非常有趣的适配器实现。在Go中，一个非常简单的`Hello
    World`服务器通常是这样做的：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The HTTP package has a function called `Handle` (like a `static` method in
    Java) that accepts two parameters--a string to represent the route and a `Handler`
    interface. The `Handler` interface is like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP包有一个名为`Handle`的函数（类似于Java中的`static`方法），它接受两个参数--一个表示路由的字符串和一个`Handler`接口。`Handler`接口如下：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need to implement a `ServeHTTP` method that the server side of an HTTP connection
    will use to execute its context. But there is also a function `HandlerFunc` that
    allows you to define some endpoint behavior:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个`ServeHTTP`方法，HTTP连接的服务器端将使用它来执行其上下文。但是还有一个`HandlerFunc`函数，允许您定义一些端点行为：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `HandleFunc` function is actually part of an adapter for using functions
    directly as `ServeHTTP` implementations. Read the last sentence slowly again--can
    you guess how it is done?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleFunc`函数实际上是使用函数直接作为`ServeHTTP`实现的适配器的一部分。再慢慢读一遍最后一句--你能猜出它是如何实现的吗？'
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can define a type that is a function in the same way that we define a struct.
    We make this function-type to implement the `ServeHTTP` method. Finally, from
    the `ServeHTTP` function, we call the receiver itself `f(w, r)`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个与定义结构相同的函数类型。我们使这个函数类型实现`ServeHTTP`方法。最后，从`ServeHTTP`函数中，我们调用接收器本身`f(w,
    r)`。
- en: You have to think about the implicit interface implementation of Go. When we
    define a function like `func(ResponseWriter, *Request)`, it is implicitly being
    recognized as `HandlerFunc`. And because the `HandleFunc` function implements
    the `Handler` interface, our function implements the `Handler` interface implicitly
    too. Does this sound familiar to you? If *A = B* and *B = C*, then *A = C*. Implicit
    implementation gives a lot of flexibility and power to Go, but you must also be
    careful, because you don't know if a method or function could be implementing
    some interface that could provoke undesirable behaviors.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须考虑Go的隐式接口实现。当我们定义一个像`func(ResponseWriter, *Request)`这样的函数时，它会被隐式地识别为`HandlerFunc`。而且因为`HandleFunc`函数实现了`Handler`接口，我们的函数也隐式地实现了`Handler`接口。这听起来很熟悉吗？如果*A
    = B*，*B = C*，那么*A = C*。隐式实现为Go提供了很多灵活性和功能，但你也必须小心，因为你不知道一个方法或函数是否实现了可能引起不良行为的某个接口。
- en: 'We can find more examples in Go''s source code. The `io` package has another
    powerful example with the use of pipes. A pipe in Linux is a flow mechanism that
    takes something on the input and outputs something else on the output. The `io`
    package has two interfaces, which are used everywhere in Go''s source code--the `io.Reader`
    and the `io.Writer` interface:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Go的源代码中找到更多的示例。`io`包使用管道的示例非常有力。在Linux中，管道是一种流机制，它将输入的内容输出为输出的其他内容。`io`包有两个接口，它们在Go的源代码中随处可见--`io.Reader`和`io.Writer`接口：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We use `io.Reader` everywhere, for example, when you open a file using `os.OpenFile`,
    it returns a file, which, in fact, implements the `io.Reader` interface. Why is
    it useful? Imagine that you write a `Counter` struct that counts from the number
    you provide to zero:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到处都使用`io.Reader`，例如，当您使用`os.OpenFile`打开文件时，它返回一个文件，实际上实现了`io.Reader`接口。这有什么用呢？想象一下，您编写了一个`Counter`结构，从您提供的数字开始计数到零：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you provide the number 3 to this small snippet, it will print the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向这个小片段提供数字3，它将打印以下内容：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Well, not really impressive! What if I want to write to a file instead of printing?
    We can implement this method too. What if I want to print to a file and to the
    console? Well, we can implement this method too. We must modularize it a bit more
    by using the `io.Writer` interface:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，不是很令人印象深刻！如果我想要写入文件而不是打印呢？我们也可以实现这种方法。如果我想要打印到文件和控制台呢？嗯，我们也可以实现这种方法。我们必须通过使用`io.Writer`接口将其模块化一些：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we provide an `io.Writer` in the `Writer` field. This way, we could create
    the counter like this: `c := Counter{os.Stdout}`, and we will get a console `Writer`.
    But wait a second, we haven't solved the issue where we wanted to take the count
    to many `Writer` consoles. But we can write a new `Adapter` with an `io.Writer`
    and, using a `Pipe()` to connect a reader with a writer, we can read on the opposite
    extreme. This way, you can solve the issue where these two interfaces, `Reader`
    and `Writer`, which are incompatible, can be used together.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`Writer`字段中提供了一个`io.Writer`。这样，我们可以像这样创建计数器：`c := Counter{os.Stdout}`，我们将得到一个控制台`Writer`。但等一下，我们还没有解决我们想要将计数带到许多`Writer`控制台的问题。但是我们可以编写一个新的`Adapter`，其中包含一个`io.Writer`，并使用`Pipe()`连接读取器和写入器，我们可以在相反的极端进行读取。这样，您可以解决这两个不兼容的接口`Reader`和`Writer`可以一起使用的问题。
- en: 'In fact, we don''t need to write the Adapter--the Go''s `io` library has one
    for us in `io.Pipe()`. The pipe will allow us to convert a `Reader` to a `Writer`
    interface. The `io.Pipe()` method will provide us a `Writer` (the entrance of
    the pipe) and a `Reader` (the exit) to play with. So let''s create a pipe, and
    assign the provided writer to the `Counter` of the preceding example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不需要编写适配器--Go的`io`库在`io.Pipe()`中为我们提供了一个适配器。管道将允许我们将`Reader`转换为`Writer`接口。`io.Pipe()`方法将为我们提供一个`Writer`（管道的入口）和一个`Reader`（出口）供我们使用。因此，让我们创建一个管道，并将提供的写入器分配给前面示例的`Counter`：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now we have a `Reader` interface where we previously had a `Writer`. Where can
    we use the `Reader`? The `io.TeeReader` function helps us to copy the stream of
    data from a `Reader` interface to the `Writer` interface and, it returns a new
    `Reader` that you can still use to stream data again to a second writer. So we
    will stream the data from the same reader to two writers--the `file` and the `Stdout`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个`Reader`接口，之前我们有了一个`Writer`。我们在哪里可以使用`Reader`？`io.TeeReader`函数帮助我们将数据流从`Reader`接口复制到`Writer`接口，并返回一个新的`Reader`，您仍然可以使用它将数据流再次传输到第二个写入器。因此，我们将从相同的读取器流式传输数据到两个写入器--`file`和`Stdout`。
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'So now we know that we are writing to a file that we have passed to the `TeeReader`
    function. We still need to print to the console. The `io.Copy` adapter can be
    used like `TeeReader`--it takes a reader and writes its contents to a writer:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们正在写入一个文件，我们已经传递给`TeeReader`函数。我们仍然需要打印到控制台。`io.Copy`适配器可以像`TeeReader`一样使用--它接受一个读取器并将其内容写入写入器：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We have to launch the `Copy` function in a different Go routine so that the
    writes are performed concurrently, and one read/write doesn''t block a different
    read/write. Let''s modify the `counter` variable to make it count till 5 again:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在不同的Go例程中启动`Copy`函数，以便并发执行写入操作，并且一个读/写不会阻塞另一个读/写。让我们修改`counter`变量，使其再次计数到5：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this modification to the code, we get the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对代码进行这种修改，我们得到了以下输出：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Okay, the count has been printed on the console. What about the file?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，计数已经打印在控制台上。文件呢？
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Awesome! By using the `io.Pipe()` adapter provided in the Go native library,
    we have uncoupled our counter from its output, and we have adapted a `Writer`
    interface to a `Reader` one.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！通过使用Go原生库中提供的`io.Pipe()`适配器，我们已经将计数器与其输出解耦，并将`Writer`接口适配为`Reader`接口。
- en: What the Go source code tells us about the Adapter pattern
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go源代码告诉我们有关适配器模式的信息
- en: With the Adapter design pattern, you have learned a quick way to achieve the
    open/close principle in your applications. Instead of modifying your old source
    code (something which could not be possible in some situations), you have created
    a way to use the old functionality with a new signature.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过适配器设计模式，您已经学会了一种快速实现应用程序中开/闭原则的方法。与其修改旧的源代码（在某些情况下可能不可能），不如创建一种使用新签名的旧功能的方法。
- en: Bridge design pattern
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥梁设计模式
- en: 'The **Bridge** pattern is a design with a slightly cryptic definition from
    the original *Gang of Four* book. It decouples an abstraction from its implementation
    so that the two can vary independently. This cryptic explanation just means that
    you could even decouple the most basic form of functionality: decouple an object
    from what it does.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**桥梁**模式是从原始*四人帮*书中得到的定义略微神秘的设计。它将抽象与其实现解耦，以便两者可以独立变化。这种神秘的解释只是意味着您甚至可以解耦最基本的功能形式：将对象与其功能解耦。'
- en: Description
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Bridge pattern tries to decouple things as usual with design patterns. It
    decouples abstraction (an object) from its implementation (the thing that the
    object does). This way, we can change what an object does as much as we want.
    It also allows us to change the abstracted object while reusing the same implementation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 桥梁模式试图像通常的设计模式一样解耦事物。它将抽象（对象）与其实现（对象执行的操作）解耦。这样，我们可以随心所欲地更改对象的操作。它还允许我们更改抽象对象，同时重用相同的实现。
- en: Objectives
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: The objective of the Bridge pattern is to bring flexibility to a struct that
    change often. Knowing the inputs and outputs of a method, it allows us to change
    code without knowing too much about it and leaving the freedom for both sides
    to be modified more easily.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 桥梁模式的目标是为经常更改的结构带来灵活性。通过了解方法的输入和输出，它允许我们在不太了解代码的情况下进行更改，并为双方留下更容易修改的自由。
- en: Two printers and two ways of printing for each
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个打印机和每种打印方式都有两种。
- en: For our example, we will go to a console printer abstraction to keep it simple.
    We will have two implementations. The first will write to the console. Having
    learned about the `io.Writer` interface in the previous section, we will make
    the second write to an `io.Writer` interface to provide more flexibility to the
    solution. We will also have two abstracted object users of the implementations--a
    `Normal` object, which will use each implementation in a straightforward manner,
    and a `Packt` implementation, which will append the sentence `Message from Packt:`
    to the printing message.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将转到控制台打印机抽象以保持简单。我们将有两个实现。第一个将写入控制台。在上一节中了解了`io.Writer`接口后，我们将使第二个写入`io.Writer`接口，以提供更多灵活性。我们还将有两个抽象对象使用这些实现——一个`Normal`对象，它将以直接的方式使用每个实现，以及一个`Packt`实现，它将在打印消息中附加句子`Message
    from Packt:`。
- en: At the end of this section, we will have two abstraction objects, which have
    two different implementations of their functionality. So, actually, we will have
    2² possible combinations of object functionality.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的结尾，我们将有两个抽象对象，它们有两种不同的功能实现。因此，实际上，我们将有2²种可能的对象功能组合。
- en: Requirements and acceptance criteria
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要求和验收标准
- en: 'As we mentioned previously, we will have two objects (`Packt` and `Normal`
    printer) and two implementations (`PrinterImpl1` and `PrinterImpl2`) that we will
    join by using the Bridge design pattern. More or less, we will have the following
    requirements and acceptance criteria:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们将有两个对象（`Packt`和`Normal`打印机）和两个实现（`PrinterImpl1`和`PrinterImpl2`），我们将使用桥接设计模式将它们连接起来。更多或更少，我们将有以下要求和验收标准：
- en: A `PrinterAPI` that accepts a message to print
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受要打印的消息的`PrinterAPI`
- en: An implementation of the API that simply prints the message to the console
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单地将消息打印到控制台的API实现
- en: An implementation of the API that prints to an `io.Writer` interface
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将消息打印到`io.Writer`接口的API实现
- en: A `Printer` abstraction with a `Print` method to implement in printing types
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Printer`抽象，具有实现打印类型的`Print`方法
- en: A `normal` printer object, which will implement the `Printer` and the `PrinterAPI`
    interface
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`normal`打印机对象，它将实现`Printer`和`PrinterAPI`接口
- en: The `normal` printer will forward the message directly to the implementation
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`normal`打印机将直接将消息转发到实现'
- en: A `Packt` printer, which will implement the `Printer` abstraction and the `PrinterAPI`
    interface
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Packt`打印机，它将实现`Printer`抽象和`PrinterAPI`接口
- en: The `Packt` printer will append the message `Message from Packt:` to all prints
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt`打印机将在所有打印中附加消息`Message from Packt:`'
- en: Unit testing the Bridge pattern
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试桥接模式
- en: 'Let''s start with *acceptance criteria 1*, the `PrinterAPI` interface. Implementers
    of this interface must provide a `PrintMessage(string)` method that will print
    the message passed as an argument:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从*验收标准1*开始，即`PrinterAPI`接口。该接口的实现者必须提供一个`PrintMessage(string)`方法，该方法将打印作为参数传递的消息：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will pass to *acceptance criteria 2* with an implementation of the previous
    API:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过前一个API的实现转到*验收标准2*：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our `PrinterImpl1` is a type that implements the `PrinterAPI` interface by
    providing an implementation of the `PrintMessage` method. The `PrintMessage` method
    is not implemented yet, and returns an error. This is enough to write our first
    unit test to cover `PrinterImpl1`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PrinterImpl1`是一种通过提供`PrintMessage`方法的实现来实现`PrinterAPI`接口的类型。`PrintMessage`方法尚未实现，并返回错误。这足以编写我们的第一个单元测试来覆盖`PrinterImpl1`：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In our test to cover `PrintAPI1`, we created an instance of `PrinterImpl1`
    type. Then we used its `PrintMessage` method to print the message `Hello` to the
    console. As we have no implementation yet, it must return the error srring `Not
    implemented yet`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们创建了一个`PrinterImpl1`类型的实例来覆盖`PrintAPI1`。然后我们使用它的`PrintMessage`方法将消息`Hello`打印到控制台。由于我们还没有实现，它必须返回错误字符串`Not
    implemented yet`：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Okay. Now we have to write the second API test that will work with an `io.Writer`
    interface:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们必须编写第二个API测试，它将使用`io.Writer`接口：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, our `PrinterImpl2` struct stores an `io.Writer` implementer.
    Also, our `PrintMessage` method follows the `PrinterAPI` interface.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的`PrinterImpl2`结构存储了一个`io.Writer`实现。此外，我们的`PrintMessage`方法遵循了`PrinterAPI`接口。
- en: 'Now that we are familiar with the `io.Writer` interface, we are going to make
    a test object that implements this interface, and stores whatever is written to
    it in a local field. This will help us check the contents that are being sent
    through the writer:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了`io.Writer`接口，我们将创建一个测试对象来实现这个接口，并将写入它的任何内容存储在一个本地字段中。这将帮助我们检查通过写入器发送的内容：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In our test object, we checked that the content isn''t empty before writing
    it to the local field. If it''s empty, we return the error, and if not, we write
    the contents of `p` in the `Msg` field. We will use this small struct in the following
    tests for the second API:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试对象中，我们在将其写入本地字段之前检查内容是否为空。如果为空，我们返回错误，如果不为空，我们将`p`的内容写入`Msg`字段。我们将在以下测试中使用这个小结构来测试第二个API：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s stop for a second here. We create an instance of `PrinterImpl2` called
    `api2` in the first line of the preceding code. We haven''t passed any instance
    of `io.Writer` on purpose, so we also checked that we actually receive an error
    first. Then we try to use its `PrintMessage` method, but we must get an error
    because it doesn''t have any `io.Writer` instance stored in the `Writer` field.
    The error must be `You need to pass an io.Writer to PrinterImpl2`, and we implicitly
    check the contents of the error. Let''s continue with the test:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里停顿一下。我们在前面的代码的第一行创建了一个名为`api2`的`PrinterImpl2`实例。我们故意没有传递任何`io.Writer`实例，所以我们首先检查我们是否真的收到了错误。然后我们尝试使用它的`PrintMessage`方法，但我们必须得到一个错误，因为它在`Writer`字段中没有存储任何`io.Writer`实例。错误必须是`You
    need to pass an io.Writer to PrinterImpl2`，我们隐式检查错误的内容。让我们继续测试：
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: For the second part of this unit test, we use an instance of the `TestWriter`
    object as an `io.Writer` interface, `testWriter`. We passed the message `Hello`
    to `api2`, and checked whether we receive any error. Then, we check the contents
    of the `testWriter.Msg` field--remember that we have written an `io.Writer` interface
    that stored any bytes passed to its `Write` method in the `Msg` field. If everything
    is correct, the message should contain the word `Hello`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个单元测试的第二部分，我们使用`TestWriter`对象的一个实例作为`io.Writer`接口，`testWriter`。我们将消息`Hello`传递给`api2`，并检查是否收到任何错误。然后，我们检查`testWriter.Msg`字段的内容--请记住，我们已经编写了一个`io.Writer`接口，它会将传递给其`Write`方法的任何字节存储在`Msg`字段中。如果一切正确，消息应该包含单词`Hello`。
- en: 'Those were our tests for `PrinterImpl2`. As we don''t have any implementations
    yet, we should get a few errors when running this test:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是我们对`PrinterImpl2`的测试。由于我们还没有任何实现，所以在运行这个测试时应该会得到一些错误。
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: At least one test passes--the one that checks that an error message (any) is
    being returned when using the `PrintMessage` without `io.Writer` being stored.
    Everything else fails, as expected at this stage.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有一个测试通过了--检查在使用`PrintMessage`时是否返回了错误消息（任何错误）。其他一切都失败了，这在这个阶段是预期的。
- en: 'Now we need a printer abstraction for objects that can use `PrinterAPI` implementers.
    We will define this as the `PrinterAbstraction` interface with a `Print` method.
    This covers the *acceptance criteria 4*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个打印机抽象，用于可以使用`PrinterAPI`实现者的对象。我们将定义这个为`PrinterAbstraction`接口，其中包含一个`Print`方法。这涵盖了*验收标准4*：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For *acceptance criteria 5*, we need a normal printer. A `Printer` abstraction
    will need a field to store a `PrinterAPI`. So our the `NormalPrinter` could look
    like the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*验收标准5*，我们需要一个普通打印机。`Printer`抽象将需要一个字段来存储`PrinterAPI`。因此，我们的`NormalPrinter`可能如下所示：
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is enough to write a unit test for the `Print()` method:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以编写`Print（）`方法的单元测试：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first part of the test checks that the `Print()` method isn't implemented
    yet when using `PrinterImpl1 PrinterAPI` interface. The message we'll use along
    this test is `Hello io.Writer`. With the `PrinterImpl1,` we don't have an easy
    way to check the contents of the message, as we print directly to the console.
    Checking, in this case, is visual, so we can check *acceptance criteria 6:*
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的第一部分检查了在使用`PrinterImpl1 PrinterAPI`接口时，`Print（）`方法尚未实现。我们将在这个测试中使用的消息是`Hello
    io.Writer`。使用`PrinterImpl1`时，我们没有简单的方法来检查消息的内容，因为我们直接打印到控制台。在这种情况下，检查是视觉的，所以我们可以检查*验收标准6*：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The second part of `NormalPrinter` tests uses `PrinterImpl2`, the one that needs
    an `io.Writer` interface implementer. We reuse our `TestWriter` struct here to
    check the contents of the message. So, in short, we want a `NormalPrinter` struct
    that accepts a `Msg` of type string and a Printer of type `PrinterAPI`. At this
    point, if I use the `Print` method, I shouldn't get any error, and the `Msg` field
    on `TestWriter` must contain the message we passed to `NormalPrinter` on its initialization.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`NormalPrinter`测试的第二部分使用`PrinterImpl2`，这需要一个`io.Writer`接口的实现者。我们在这里重用我们的`TestWriter`结构来检查消息的内容。简而言之，我们希望一个接受`string`类型的`Msg`和`PrinterAPI`类型的`Printer`的`NormalPrinter`结构。在这一点上，如果我使用`Print`方法，我不应该收到任何错误，并且`TestWriter`上的`Msg`字段必须包含我们在初始化`NormalPrinter`时传递给它的消息。'
- en: 'Let''s run the tests:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试：
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There is a trick to quickly check the validity of a unit test--the number of
    times we called `t.Error` or `t.Errorf` must match the number of messages of error
    on the console and the lines where they were produced. In the preceding test results,
    there are three errors at *lines 72*, *85*, and *89*, which exactly match the
    checks we wrote.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个技巧可以快速检查单元测试的有效性--我们调用`t.Error`或`t.Errorf`的次数必须与控制台上的错误消息数量以及它们产生的行数相匹配。在前面的测试结果中，有三个错误分别在*第72行*、*第85行*和*第89行*，这恰好与我们编写的检查相匹配。
- en: 'Our `PacktPrinter` struct will have a very similar definition to `NormalPrinter`
    at this point:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PacktPrinter`结构在这一点上将与`NormalPrinter`的定义非常相似：
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This covers *acceptance criteria 7*. And we can almost copy and paste the contents
    of the previous test with a few changes:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了*验收标准7*。我们几乎可以复制并粘贴以前的测试内容，只需做一些更改：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: What have we changed here? Now we have `passedMessage`, which represents the
    message we are passing to `PackPrinter`. We also have an expected message that
    contains the prefixed message from `Packt`. If you remember *acceptance criteria
    8*, this abstraction must prefix the text `Message from Packt:` to any message
    that is passed to it, and, at the same time, it must be able to use any implementation
    of a `PrinterAPI` interface.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了什么改变？现在我们有了`passedMessage`，它代表了我们传递给`PackPrinter`的消息。我们还有一个预期的消息，其中包含了来自`Packt`的带前缀的消息。如果您还记得*验收标准8*，这个抽象必须给传递给它的任何消息加上`Message
    from Packt：`的前缀，并且同时，它必须能够使用`PrinterAPI`接口的任何实现。
- en: 'The second change is that we actually create `PacktPrinter` structs instead
    of the `NormalPrinter` structs; everything else is the same:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个改变是，我们实际上创建了`PacktPrinter`结构，而不是`NormalPrinter`结构；其他一切都是一样的：
- en: '[PRE62]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Three checks, three errors. All tests have been covered, and we can finally
    move on to the implementation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 三个检查，三个错误。所有测试都已覆盖，我们终于可以继续实施了。
- en: Implementation
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'We will start implementing in the same order that we created our tests, first
    with the `PrinterImpl1` definition:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照创建测试的顺序开始实现，首先是`PrinterImpl1`的定义：
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Our first API takes the message `msg` and prints it to the console. In the
    case of an empty string, nothing will be printed. This is enough to pass the first
    test:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个API接收消息`msg`并将其打印到控制台。在空字符串的情况下，将不会打印任何内容。这足以通过第一个测试：
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can see the `Hello` message in the second line of the output of the test,
    just after the `RUN` message.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在测试输出的第二行中看到`Hello`消息，就在`RUN`消息之后。
- en: 'The `PrinterImpl2` struct isn''t very complex either. The difference is that
    instead of printing to the console, we are going to write on an `io.Writer` interface,
    which must be stored in the struct:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrinterImpl2`结构也不是很复杂。不同之处在于，我们将在`io.Writer`接口上写入，而不是打印到控制台，这必须存储在结构中。'
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As defined in our tests, we checked the contents of the `Writer` field first
    and returned the expected error message `**You need to pass an io.Writer to PrinterImpl2**`
    , if nothing is stored. This is the message we''ll check later in the test. Then,
    the `fmt.Fprintf` method takes an `io.Writer` interface as the first field and
    a message formatted as the rest, so we simply forward the contents of the `msg`
    argument to the `io.Writer` provided:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的测试，我们首先检查了`Writer`字段的内容，并返回了预期的错误消息`**You need to pass an io.Writer to
    PrinterImpl2**`，如果没有存储任何内容。这是我们稍后将在测试中检查的消息。然后，`fmt.Fprintf`方法将`io.Writer`接口作为第一个字段，并将格式化的消息作为其余部分，因此我们只需将`msg`参数的内容转发给提供的`io.Writer`：
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now we''ll continue with the normal printer. This printer must simply forward
    the message to the `PrinterAPI` interface stored without any modification. In
    our test, we are using two implementations of `PrinterAPI`--one that prints to
    the console and one that writes to an `io.Writer` interface:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将继续使用普通打印机。这个打印机必须简单地将消息转发给存储在`PrinterAPI`接口中的`Printer`，而不做任何修改。在我们的测试中，我们使用了两种`PrinterAPI`的实现--一种打印到控制台，一种写入到`io.Writer`接口：
- en: '[PRE67]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We returned nil as no error has occurred. This should be enough to pass the
    unit tests:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回nil，因为没有发生错误。这应该足以通过单元测试：
- en: '[PRE68]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the preceding output, you can see the `Hello io.Writer` message that the `PrinterImpl1` struct
    writes to `stdout`. We can consider this check as having passed:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，您可以看到`PrinterImpl1`结构写入`stdout`的`Hello io.Writer`消息。我们可以认为这个检查已经通过了：
- en: 'Finally, the `PackPrinter` method is similar to `NormalPrinter`, but just prefixes
    every message with the text `Message from Packt:` :'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`PackPrinter`方法类似于`NormalPrinter`，但只是在每条消息前加上文本`Message from Packt:`：
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Like in the `NormalPrinter` method, we accepted a `Msg` string and a `PrinterAPI`
    implementation in the `Printer` field. Then we used the `fmt.Sprintf` method to
    compose a new string with the text `Message from Packt:` and the provided message.
    We took the composed text and passed it to the `PrintMessage` method of `PrinterAPI`
    stored in the `Printer` field of the `PacktPrinter` struct:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`NormalPrinter`方法一样，我们接受了`Msg`字符串和`PrinterAPI`实现，存储在`Printer`字段中。然后，我们使用`fmt.Sprintf`方法来组合一个新的字符串，其中包含文本`Message
    from Packt:`和提供的消息。我们取得组合的文本，并将其传递给存储在`PacktPrinter`结构的`Printer`字段中的`PrinterAPI`的`PrintMessage`方法：
- en: '[PRE70]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Again, you can see the results of using `PrinterImpl1` for writing to `stdout`
    with the text `Message from Packt: Hello io.Writer`. This last test should cover
    all of our code in the Bridge pattern. As you have seen previously, you can check
    the coverage by using the `-cover` flag:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，您可以看到使用`PrinterImpl1`写入`stdout`的结果，文本为`Message from Packt: Hello io.Writer`。这最后的测试应该覆盖桥接模式中的所有代码。正如您之前所见，您可以使用`-cover`标志来检查覆盖率：'
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Wow! 100% coverage-this looks good. However, this doesn't mean that the code
    is perfect. We haven't checked that the contents of the messages weren't empty,
    maybe something that should be avoided, but it isn't a part of our requirements,
    which is also an important point. Just because some feature isn't in the requirements
    or the acceptance criteria doesn't mean that it shouldn't be covered.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！100%的覆盖率-看起来不错。然而，这并不意味着代码是完美的。我们还没有检查消息的内容是否为空，也许这是应该避免的，但这不是我们的要求的一部分，这也是一个重要的观点。仅仅因为某个功能不在需求或验收标准中，并不意味着它不应该被覆盖。
- en: Reuse everything with the Bridge pattern
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用桥接模式重用一切
- en: With the Bridge pattern, we have learned how to uncouple an object and its implementation
    for the `PrintMessage` method. This way, we can reuse its abstractions as well
    as its implementations. We can swap the printer abstractions as well as the printer
    APIs as much as we want without affecting the user code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过桥接模式，我们学会了如何将对象及其实现与`PrintMessage`方法解耦。这样，我们可以重用其抽象以及其实现。我们可以随意交换打印机抽象以及打印机API，而不影响用户代码。
- en: We have also tried to keep things as simple as possible, but I'm sure that you
    have realized that all implementations of the `PrinterAPI` interface could have
    been created using a factory. This would be very natural, and you could find many
    implementations that have followed this approach. However, we shouldn't get into
    over-engineering, but should analyze each problem to make a precise design of
    its needs and finds the best way to create a reusable, maintainable, and *readable*
    source code. Readable code is commonly forgotten, but a robust and uncoupled source
    code is useless if nobody can understand it to maintain it. It's like a book of
    the tenth century--it could be a precious story but pretty frustrating if we have
    difficulty understanding its grammar.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还尽量保持事情尽可能简单，但我相信您已经意识到，所有`PrinterAPI`接口的实现都可以使用工厂来创建。这将是非常自然的，您可能会发现许多实现都遵循了这种方法。然而，我们不应该陷入过度设计，而应该分析每个问题，以精确地设计其需求，并找到创建可重用、可维护和*可读*源代码的最佳方式。可读的代码通常被遗忘，但如果没有人能够理解和维护它，那么强大而不耦合的源代码就是无用的。这就像十世纪的书籍一样--它可能是一部宝贵的故事，但如果我们难以理解它的语法，那就会非常令人沮丧。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have seen the power of composition in this chapter and many of the ways that
    Go takes advantage of it by its own nature. We have seen that the Adapter pattern
    can help us make two incompatible interfaces work together by using an `Adapter`
    object in between. At the same time, we have seen some real-life examples in Go's
    source code, where the creators of the language used this design pattern to improve
    the possibilities of some particular piece of the standard library. Finally, we
    have seen the Bridge pattern and its possibilities, allowing us to create swapping
    structures with complete reusability between objects and their implementations.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了组合的力量，以及Go语言如何利用它的本质。我们已经看到适配器模式可以帮助我们通过在两个不兼容的接口之间使用“适配器”对象来使它们一起工作。同时，我们在Go语言的源代码中看到了一些真实的例子，语言的创建者使用了这种设计模式来改进标准库中某个特定部分的可能性。最后，我们已经看到了桥接模式及其可能性，允许我们在对象和它们的实现之间创建可完全重用的交换结构。
- en: Also, we have used the Composite design pattern throughout the chapter, not
    only when explaining it. We have mentioned it earlier but design patterns make
    use of each other very frequently. We have used pure composition instead of embedding
    to increase readability, but, as you have learned, you can use both interchangeably
    according to your needs. We will keep using the Composite pattern in the following
    chapters, as it is the foundation for building relationships in the Go programming
    language.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在整个章节中，我们一直在使用组合设计模式，不仅仅是在解释它时。我们之前提到过它，但设计模式经常彼此使用。我们使用纯粹的组合而不是嵌入来增加可读性，但是，正如你已经学到的，根据需要可以互换使用两者。在接下来的章节中，我们将继续使用组合模式，因为它是构建Go编程语言中关系的基础。
