["```go\ntype UserFinder interface { \n  FindUser(id int32) (User, error) \n} \n\n```", "```go\ntype User struct { \n  ID int32 \n} \n\n```", "```go\ntype UserList []User \n\n```", "```go\ntype UserListProxy struct { \n  SomeDatabase UserList \n  StackCache UserList \n  StackCapacity int \n  DidDidLastSearchUsedCache bool \n} \n\nfunc (u *UserListProxy) FindUser(id int32) (User, error) { \n  return User{}, errors.New(\"Not implemented yet\") \n} \n\n```", "```go\nimport ( \n   \"math/rand\" \n   \"testing\" \n) \n\nfunc Test_UserListProxy(t *testing.T) { \n  someDatabase := UserList{} \n\n  rand.Seed(2342342) \n  for i := 0; i < 1000000; i++ { \n    n := rand.Int31() \n    someDatabase = append(someDatabase, User{ID: n}) \n  } \n\n```", "```go\nproxy := UserListProxy{ \n  SomeDatabase:  &someDatabase, \n  StackCapacity:  2, \n  StackCache: UserList{}, \n} \n\n```", "```go\nknownIDs := [3]int32 {someDatabase[3].ID, someDatabase[4].ID,someDatabase[5].ID} \n\n```", "```go\nt.Run(\"FindUser - Empty cache\", func(t *testing.T) { \n  user, err := proxy.FindUser(knownIDs[0]) \n  if err != nil { \n    t.Fatal(err) \n  } \n\n```", "```go\n  if user.ID != knownIDs[0] { \n    t.Error(\"Returned user name doesn't match with expected\") \n  } \n\n  if len(proxy.StackCache) != 1 { \n    t.Error(\"After one successful search in an empty cache, the size of it must be one\") \n  } \n\n  if proxy.DidLastSearchUsedCache { \n    t.Error(\"No user can be returned from an empty cache\") \n  } \n} \n\n```", "```go\nt.Run(\"FindUser - One user, ask for the same user\", func(t *testing.T) { \n  user, err := proxy.FindUser(knownIDs[0]) \n  if err != nil { \n    t.Fatal(err) \n  } \n\n  if user.ID != knownIDs[0] { \n    t.Error(\"Returned user name doesn't match with expected\") \n  } \n\n  if len(proxy.StackCache) != 1 { \n    t.Error(\"Cache must not grow if we asked for an object that is stored on it\") \n  } \n\n  if !proxy.DidLastSearchUsedCache { \n    t.Error(\"The user should have been returned from the cache\") \n  } \n}) \n\n```", "```go\nuser1, err := proxy.FindUser(knownIDs[0]) \nif err != nil { \n  t.Fatal(err) \n} \n\nuser2, _ := proxy.FindUser(knownIDs[1]) \nif proxy.DidLastSearchUsedCache { \n  t.Error(\"The user wasn't stored on the proxy cache yet\") \n} \n\nuser3, _ := proxy.FindUser(knownIDs[2]) \nif proxy.DidLastSearchUsedCache { \n  t.Error(\"The user wasn't stored on the proxy cache yet\") \n} \n\n```", "```go\nfor i := 0; i < len(proxy.StackCache); i++ { \n  if proxy.StackCache[i].ID == user1.ID { \n    t.Error(\"User that should be gone was found\") \n  } \n} \n\nif len(proxy.StackCache) != 2 { \n  t.Error(\"After inserting 3 users the cache should not grow\" + \n\" more than to two\") \n} \n\n```", "```go\n  for _, v := range proxy.StackCache { \n    if v != user2 && v != user3 { \n      t.Error(\"A non expected user was found on the cache\") \n    } \n  } \n} \n\n```", "```go\n$ go test -v .\n=== RUN   Test_UserListProxy\n=== RUN   Test_UserListProxy/FindUser_-_Empty_cache\n=== RUN   Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user\n=== RUN   Test_UserListProxy/FindUser_-_overflowing_the_stack\n--- FAIL: Test_UserListProxy (0.06s)\n --- FAIL: Test_UserListProxy/FindUser_-_Empty_cache (0.00s)\n proxy_test.go:28: Not implemented yet\n --- FAIL: Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user (0.00s)\n proxy_test.go:47: Not implemented yet\n --- FAIL: Test_UserListProxy/FindUser_-_overflowing_the_stack (0.00s)\n proxy_test.go:66: Not implemented yet\nFAIL\nexit status 1\nFAIL\n\n```", "```go\ntype UserList []User \n\nfunc (t *UserList) FindUser(id int32) (User, error) { \n  for i := 0; i < len(*t); i++ { \n    if (*t)[i].ID == id { \n      return (*t)[i], nil \n    } \n  } \n  return User{}, fmt.Errorf(\"User %s could not be found\\n\", id) \n} \n\n```", "```go\nfunc (u *UserListProxy) FindUser(id int32) (User, error) { \n  user, err := u.StackCache.FindUser(id) \n  if err == nil { \n    fmt.Println(\"Returning user from cache\") \n    u.DidLastSearchUsedCache = true \n    return user, nil \n  } \n\n```", "```go\n  user, err = u.SomeDatabase.FindUser(id) \n  if err != nil { \n    return User{}, err \n  } \n\n```", "```go\nfunc (u *UserListProxy) addUserToStack(user User) { \n  if len(u.StackCache) >= u.StackCapacity { \n    u.StackCache = append(u.StackCache[1:], user) \n  } \n  else { \n    u.StackCache.addUser(user) \n  } \n} \n\nfunc (t *UserList) addUser(newUser User) { \n  *t = append(*t, newUser) \n} \n\n```", "```go\nu.addUserToStack(user) \n\n```", "```go\n  fmt.Println(\"Returning user from database\") \n  u.DidLastSearchUsedCache = false \n  return user, nil \n} \n\n```", "```go\n$ go test -v .\n=== RUN   Test_UserListProxy\n=== RUN   Test_UserListProxy/FindUser_-_Empty_cache\nReturning user from database\n=== RUN   Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user\nReturning user from cache\n=== RUN   Test_UserListProxy/FindUser_-_overflowing_the_stack\nReturning user from cache\nReturning user from database\nReturning user from database\n--- PASS: Test_UserListProxy (0.09s) \n--- PASS: Test_UserListProxy/FindUser_-_Empty_cache (0.00s)\n--- PASS: Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user (0.00s)\n--- PASS: Test_UserListProxy/FindUser_-_overflowing_the_stack (0.00s)\nPASS\nok\n\n```", "```go\ntype IngredientAdd interface { \n  AddIngredient() (string, error) \n} \n\n```", "```go\ntype PizzaDecorator struct{ \n  Ingredient IngredientAdd \n} \n\nfunc (p *PizzaDecorator) AddIngredient() (string, error) { \n  return \"\", errors.New(\"Not implemented yet\") \n} \n\n```", "```go\ntype Meat struct { \n  Ingredient IngredientAdd \n} \n\nfunc (m *Meat) AddIngredient() (string, error) { \n  return \"\", errors.New(\"Not implemented yet\") \n} \n\n```", "```go\ntype Onion struct { \n  Ingredient IngredientAdd \n} \n\nfunc (o *Onion) AddIngredient() (string, error) { \n  return \"\", errors.New(\"Not implemented yet\") \n}  \n\n```", "```go\nfunc TestPizzaDecorator_AddIngredient(t *testing.T) { \n  pizza := &PizzaDecorator{} \n  pizzaResult, _ := pizza.AddIngredient() \n  expectedText := \"Pizza with the following ingredients:\" \n  if !strings.Contains(pizzaResult, expectedText) { \n    t.Errorf(\"When calling the add ingredient of the pizza decorator it must return the text %sthe expected text, not '%s'\", pizzaResult, expectedText) \n  } \n} \n\n```", "```go\n$ go test -v -run=TestPizzaDecorator .\n=== RUN   TestPizzaDecorator_AddIngredient\n--- FAIL: TestPizzaDecorator_AddIngredient (0.00s)\ndecorator_test.go:29: Not implemented yet\ndecorator_test.go:34: When the the\u00a0AddIngredient method of the pizza decorator object is called, it must return the text\nPizza with the following ingredients:\nFAIL\nexit status 1\nFAIL \n\n```", "```go\nfunc TestOnion_AddIngredient(t *testing.T) { \n  onion := &Onion{} \n  onionResult, err := onion.AddIngredient() \n  if err == nil { \n    t.Errorf(\"When calling AddIngredient on the onion decorator without\" + \"an IngredientAdd on its Ingredient field must return an error, not a string with '%s'\", onionResult) \n  } \n\n```", "```go\n  onion = &Onion{&PizzaDecorator{}} \n  onionResult, err = onion.AddIngredient() \n\n  if err != nil { \n    t.Error(err) \n  } \n  if !strings.Contains(onionResult, \"onion\") { \n    t.Errorf(\"When calling the add ingredient of the onion decorator it\" + \"must return a text with the word 'onion', not '%s'\", onionResult) \n  } \n} \n\n```", "```go\n$ go test -v -run=TestOnion_AddIngredient .\n=== RUN   TestOnion_AddIngredient\n--- FAIL: TestOnion_AddIngredient (0.00s)\ndecorator_test.go:48: Not implemented yet\ndecorator_test.go:52: When calling the add ingredient of the onion decorator it must return a text with the word 'onion', not ''\nFAIL\nexit status 1\nFAIL\n\n```", "```go\nfunc TestMeat_AddIngredient(t *testing.T) { \n  meat := &Meat{} \n  meatResult, err := meat.AddIngredient() \n  if err == nil { \n    t.Errorf(\"When calling AddIngredient on the meat decorator without\" + \"an IngredientAdd in its Ingredient field must return an error,\" + \"not a string with '%s'\", meatResult) \n  } \n\n  meat = &Meat{&PizzaDecorator{}} \n  meatResult, err = meat.AddIngredient() \n  if err != nil { \n    t.Error(err) \n  } \n\n  if !strings.Contains(meatResult, \"meat\") { \n    t.Errorf(\"When calling the add ingredient of the meat decorator it\" + \"must return a text with the word 'meat', not '%s'\", meatResult) \n  } \n} \n\n```", "```go\ngo test -v -run=TestMeat_AddIngredient .\n=== RUN   TestMeat_AddIngredient\n--- FAIL: TestMeat_AddIngredient (0.00s)\ndecorator_test.go:68: Not implemented yet\ndecorator_test.go:72: When calling the add ingredient of the meat decorator it must return a text with the word 'meat', not ''\nFAIL\nexit status 1\nFAIL\n\n```", "```go\nfunc TestPizzaDecorator_FullStack(t *testing.T) { \n  pizza := &Onion{&Meat{&PizzaDecorator{}}} \n  pizzaResult, err := pizza.AddIngredient() \n  if err != nil { \n    t.Error(err) \n  } \n\n  expectedText := \"Pizza with the following ingredients: meat, onion\" \n  if !strings.Contains(pizzaResult, expectedText){ \n    t.Errorf(\"When asking for a pizza with onion and meat the returned \" + \"string must contain the text '%s' but '%s' didn't have it\", expectedText,pizzaResult) \n  } \n\n  t.Log(pizzaResult) \n} \n\n```", "```go\ngo test -v -run=TestPizzaDecorator_FullStack .\n=== RUN   TestPizzaDecorator_FullStack\n--- FAIL: TestPizzaDecorator_FullStack (0.\ndecorator_test.go:80: Not implemented yet\ndecorator_test.go:87: When asking for a pizza with onion and meat the returned string must contain the text 'Pizza with the following ingredients: meat, onion' but '' didn't have it\nFAIL\nexit status 1\nFAIL\n\n```", "```go\ntype PizzaDecorator struct { \n  Ingredient IngredientAdd \n} \n\nfunc (p *PizzaDecorator) AddIngredient() (string, error) { \n  return \"Pizza with the following ingredients:\", nil \n} \n\n```", "```go\ngo test -v -run=TestPizzaDecorator_Add .\n=== RUN   TestPizzaDecorator_AddIngredient\n--- PASS: TestPizzaDecorator_AddIngredient (0.00s)\nPASS\nok\n\n```", "```go\ntype Onion struct { \n  Ingredient IngredientAdd \n} \n\nfunc (o *Onion) AddIngredient() (string, error) { \n  if o.Ingredient == nil { \n    return \"\", errors.New(\"An IngredientAdd is needed in the Ingredient field of the Onion\") \n  } \n  s, err := o.Ingredient.AddIngredient() \n  if err != nil { \n    return \"\", err \n  } \n  return fmt.Sprintf(\"%s %s,\", s, \"onion\"), nil \n} \n\n```", "```go\ngo test -v -run=TestOnion_AddIngredient .\n=== RUN   TestOnion_AddIngredient\n--- PASS: TestOnion_AddIngredient (0.00s)\nPASS\nok\n\n```", "```go\ntype Meat struct { \n  Ingredient IngredientAdd \n} \n\nfunc (m *Meat) AddIngredient() (string, error) { \n  if m.Ingredient == nil { \n    return \"\", errors.New(\"An IngredientAdd is needed in the Ingredient field of the Meat\") \n  } \n  s, err := m.Ingredient.AddIngredient() \n  if err != nil { \n    return \"\", err \n  } \n  return fmt.Sprintf(\"%s %s,\", s, \"meat\"), nil \n} \n\n```", "```go\ngo test -v -run=TestMeat_AddIngredient .\n=== RUN   TestMeat_AddIngredient\n--- PASS: TestMeat_AddIngredient (0.00s)\nPASS\nok\n\n```", "```go\ngo test -v -run=TestPizzaDecorator_FullStack .\n=== RUN   TestPizzaDecorator_FullStack\n--- PASS: TestPizzaDecorator_FullStack (0.00s)\ndecorator_test.go:92: Pizza with the following ingredients: meat, onion,\nPASS\nok\n\n```", "```go\ntype MyServer struct{} \n\nfunc (m *MyServer) ServeHTTP(w http.ResponseWriter, r *http.Request) { \n  fmt.Fprintln(w, \"Hello Decorator!\") \n} \n\n```", "```go\nfunc main() { \n  http.Handle(\"/\", &MyServer{}) \n\n  log.Fatal(http.ListenAndServe(\":8080\", nil)) \n} \n\n```", "```go\n$ curl http://localhost:8080\nHello Decorator!\n\n```", "```go\ntype LoggerServer struct { \n  Handler   http.Handler \n  LogWriter io.Writer \n} \n\nfunc (s *LoggerServer) ServeHTTP(w http.ResponseWriter, r *http.Request) { \n  fmt.Fprintf(s.LogWriter, \"Request URI: %s\\n\", r.RequestURI) \n  fmt.Fprintf(s.LogWriter, \"Host: %s\\n\", r.Host) \n  fmt.Fprintf(s.LogWriter, \"Content Length: %d\\n\",  \nr.ContentLength) \n  fmt.Fprintf(s.LogWriter, \"Method: %s\\n\", r.Method)fmt.Fprintf(s.LogWriter, \"--------------------------------\\n\") \n\n  s.Handler.ServeHTTP(w, r) \n} \n\n```", "```go\nfunc main() { \n  http.Handle(\"/\", &LoggerServer{ \n    LogWriter:os.Stdout, \n    Handler:&MyServer{}, \n  }) \n\n  log.Fatal(http.ListenAndServe(\":8080\", nil)) \n} \n\n```", "```go\n$ curl http://localhost:8080\nHello Decorator!\n\n```", "```go\n$ go run server_decorator.go\nRequest URI: /\nHost: localhost:8080\nContent Length: 0\nMethod: GET\n\n```", "```go\ntype BasicAuthMiddleware struct { \n  Handler  http.Handler \n  User     string \n  Password string \n} \n\n```", "```go\nfunc (s *BasicAuthMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) { \n  user, pass, ok := r.BasicAuth() \n\n  if ok { \n    if user == s.User && pass == s.Password { \n      s.Handler.ServeHTTP(w, r) \n    } \n    else { \n      fmt.Fprintf(w, \"User or password incorrect\\n\") \n    } \n  } \n  else { \n    fmt.Fprintln(w, \"Error trying to retrieve data from Basic auth\") \n  } \n} \n\n```", "```go\nfunc main() { \n  fmt.Println(\"Enter the type number of server you want to launch from the  following:\") \n  fmt.Println(\"1.- Plain server\") \n  fmt.Println(\"2.- Server with logging\") \n  fmt.Println(\"3.- Server with logging and authentication\") \n\n  var selection int \n  fmt.Fscanf(os.Stdin, \"%d\", &selection) \n} \n\n```", "```go\n   switch selection { \n   case 1: \n     mySuperServer = new(MyServer) \n   case 2: \n     mySuperServer = &LoggerMiddleware{ \n       Handler:   new(MyServer), \n       LogWriter: os.Stdout, \n     } \n   case 3: \n     var user, password string \n\n     fmt.Println(\"Enter user and password separated by a space\") \n     fmt.Fscanf(os.Stdin, \"%s %s\", &user, &password) \n\n     mySuperServer = &LoggerMiddleware{ \n     Handler: &SimpleAuthMiddleware{ \n       Handler:  new(MyServer), \n       User:     user, \n       Password: password, \n     }, \n     LogWriter: os.Stdout, \n   } \n   default: \n   mySuperServer = new(MyServer) \n } \n\n```", "```go\nhttp.Handle(\"/\", mySuperServer) \nlog.Fatal(http.ListenAndServe(\":8080\", nil)) \n\n```", "```go\n$go run server_decorator.go \nEnter the server type number you want to launch from the following: \n1.- Plain server \n2.- Server with logging \n3.- Server with logging and authentication \n\nEnter user and password separated by a space \nmario castro\n\n```", "```go\n$ curl http://localhost:8080\nError trying to retrieve data from Basic auth\n\n```", "```go\n$ curl -u no:correct http://localhost:8080\nUser or password incorrect\n\n```", "```go\nRequest URI: /\nHost: localhost:8080\nContent Length: 0\nMethod: GET\n\n```", "```go\n$ curl -u packt:publishing http://localhost:8080\nHello Decorator!\n\n```", "```go\ntype MyPrinter struct{} \nfunc(m *MyPrinter)Print(){ \n  println(\"Hello\") \n} \n\n```", "```go\ntype Printer interface { \n  Print() \n} \n\n```", "```go\ntype CurrentWeatherDataRetriever interface { \n  GetByCityAndCountryCode(city, countryCode string) (Weather, error) \n  GetByGeoCoordinates(lat, lon float32) (Weather, error) \n} \n\n```", "```go\ntype Weather struct { \n  ID   int    `json:\"id\"` \n  Name string `json:\"name\"` \n  Cod  int    `json:\"cod\"` \n  Coord struct { \n    Lon float32 `json:\"lon\"` \n    Lat float32 `json:\"lat\"` \n  } `json:\"coord\"`  \n\n  Weather []struct { \n    Id          int    `json:\"id\"` \n    Main        string `json:\"main\"` \n    Description string `json:\"description\"` \n    Icon        string `json:\"icon\"` \n  } `json:\"weather\"` \n\n  Base string `json:\"base\"` \n  Main struct { \n    Temp     float32 `json:\"temp\"` \n    Pressure float32 `json:\"pressure\"` \n    Humidity float32 `json:\"humidity\"` \n    TempMin  float32 `json:\"temp_min\"` \n    TempMax  float32 `json:\"temp_max\"` \n  } `json:\"main\"` \n\n  Wind struct { \n    Speed float32 `json:\"speed\"` \n    Deg   float32 `json:\"deg\"` \n  } `json:\"wind\"` \n\n  Clouds struct { \n    All int `json:\"all\"` \n  } `json:\"clouds\"` \n\n  Rain struct { \n    ThreeHours float32 `json:\"3h\"` \n  } `json:\"rain\"` \n\n  Dt  uint32 `json:\"dt\"` \n  Sys struct { \n    Type    int     `json:\"type\"` \n    ID      int     `json:\"id\"` \n    Message float32 `json:\"message\"` \n    Country string  `json:\"country\"` \n    Sunrise int     `json:\"sunrise\"` \n    Sunset  int     `json:\"sunset\"` \n  }`json:\"sys\"` \n} \n\n```", "```go\n`json:\"something,omitempty\" \n\n```", "```go\ntype CurrentWeatherData struct { \n  APIkey string \n} \n\n```", "```go\n func getMockData() io.Reader { \n  response := `{\n    \"coord\":{\"lon\":-3.7,\"lat\":40.42},\"weather : [{\"id\":803,\"main\":\"Clouds\",\"description\":\"broken clouds\",\"icon\":\"04n\"}],\"base\":\"stations\",\"main\":{\"temp\":303.56,\"pressure\":1016.46,\"humidity\":26.8,\"temp_min\":300.95,\"temp_max\":305.93},\"wind\":{\"speed\":3.17,\"deg\":151.001},\"rain\":{\"3h\":0.0075},\"clouds\":{\"all\":68},\"dt\":1471295823,\"sys\":{\"type\":3,\"id\":1442829648,\"message\":0.0278,\"country\":\"ES\",\"sunrise\":1471238808,\"sunset\":1471288232},\"id\":3117735,\"name\":\"Madrid\",\"cod\":200}` \n\n  r := bytes.NewReader([]byte(response)) \n  return r \n} \n\n```", "```go) used to open and close the string. This way, you can use as many quotes as you want without any problem.\n\nFurther on, we use a special function in the bytes package called `NewReader`, which accepts an slice of bytes (which we create by converting the type from string), and returns an `io.Reader` implementor with the contents of the slice. This is perfect to mimic the `Body` member of an HTTP response.\n\nWe will write a test to try `response parser`. Both methods return the same type, so we can use the same `JSON parser` for both:\n\n```", "```go\n\nIn the preceding test, we first asked for some mock data, which we store in the variable `r`. Later, we created a type of `CurrentWeatherData`, which we called `openWeatherMap`. Finally, we asked for a weather value for the provided `io.Reader`\u00a0interface that we store in the variable `weather`. After checking for errors, we make sure that the ID is the same as the one stored in the mock data that we got from the `getMockData` method.\n\nWe have to declare the `responseParser` method before running tests, or the code won't compile:\n\n```", "```go\n\nWith all the aforementioned, we can run this test:\n\n```", "```go\n\nOkay. We won't write more tests, because the rest would be merely integration tests, which are outside of the scope of explanation of a structural pattern, and will force us to have an API key as well as an Internet connection. If you want to see what the integration tests look like for this example, refer to the code that comes bundled with the book.\n\n## Implementation\n\nFirst of all, we are going to implement the parser that our methods will use to parse the JSON response from the `OpenWeatherMap` REST API:\n\n```", "```go\n\nAnd this should be enough to pass the test by now:\n\n```", "```go\n\nAt least we have our parser well tested. Let's structure our code to look like a library. First, we will create the methods to retrieve the weather of a city by its name and its country code, and the method that uses its latitude and longitude:\n\n```", "```go\n\nA piece of cake? Of course! Everything must be as easy as possible, and it is a sign of a good job. The complexity in this facade is to create connections to the `OpenWeatherMap` API, and control the possible errors. This problem is shared between all the Facade methods in our example, so we don't need to write more than one API call right now.\n\nWhat we do is pass the URL that the REST API needs in order to return the information we desire. This is achieved by the `fmt.Sprintf` function, which formats the strings in each case. For example, to gather the data using a city name and a country code, we use the following string:\n\n```", "```go\n\nThis takes the pre-formatted string [https://openweathermap.org/api](https://openweathermap.org/api) and formats it by replacing each `%s`\u00a0specifier with the city, the `countryCode` that we introduced in the arguments, and the API key member of the `CurrentWeatherData` type.\n\nBut, we haven't set any API key! Yes, because this is a library, and the users of the library will have to use their own API keys. We are hiding the complexity of creating the URIs, and handling the errors.\n\nFinally, the `doRequest` function is a big fish, so we will see it in detail, step by step:\n\n```", "```go\n\nFirst, the signature tells us that the\u00a0`doRequest`\u00a0method accepts a URI string, and returns a pointer to the\u00a0`Weather`\u00a0variable and an error. We start by creating an `http.Client` class, which will make the requests. Then, we create a request object, which will use the `GET` method, as described in the `OpenWeatherMap` webpage, and the URI we passed. If we were to use a different method, or more than one, they would have to be brought about by arguments in the signature. Nevertheless, we will use just the\u00a0`GET` method, so we could hardcode it there.\n\nThen, we check whether the request object has been created successfully, and set a header that says that the content type is a JSON:\n\n```", "```go\n\nThen we make the request, and check for errors. Because we have given names to our return types, if any error occurs, we just have to return the function, and Go will return the variable `err` and the variable `weather` in the state they were in at that precise moment.\n\nWe check the status code of the response, as we only accept 200 as a good response. If 200 isn't returned, we will create an error message with the contents of the body and the status code returned:\n\n```", "```go\n\nFinally, if everything goes well, we use the `responseParser` function we wrote earlier to parse the contents of Body, which is an `io.Reader` interface. Maybe you are wondering why we aren't controlling `err` from the\u00a0`response parser` method. It's funny, because we are actually controlling it. `responseParser` and `doRequest` have the same return signature. Both return a `Weather` pointer and an error (if any), so we can return directly whatever the result was.\n\n## Library created with the Facade pattern\n\nWe have the first milestone for a library for the `OpenWeatherMap` API using the facade pattern. We have hidden the complexity of accessing the `OpenWeatherMap` REST API in the `doRequest` and `responseParser` functions, and the users of our library have an easy-to-use syntax to query the API. For example, to retrieve the weather for Madrid, Spain, a user will only have to introduce arguments and an API key at the beginning:\n\n```", "```go\n\nThe console output for the weather in Madrid at the moment of writing this chapter is the following:\n\n```", "```go\n\nA typical summer day!\n\n# Flyweight design pattern\n\nOur next pattern is the **Flyweight** design pattern. It's very commonly used in computer graphics and the video game industry, but not so much in enterprise applications.\n\n## Description\n\nFlyweight is a pattern which allows sharing the state of a heavy object between many instances of some type. Imagine that you have to create and store too many objects of some heavy type that are fundamentally equal. You'll run out of memory pretty quickly. This problem can be easily solved with the Flyweight pattern, with additional help of the Factory pattern. The factory is usually in charge of encapsulating object creation, as we saw previously.\n\n## Objectives\n\nThanks to the Flyweight pattern, we can share all possible states of objects in a single common object, and thus minimize object creation by using pointers to already created objects.\n\n## Example\n\nTo give an example, we are going to simulate something that you find on betting webpages. Imagine the final match of the European championship, which is viewed by millions of people across the continent. Now imagine that we own a betting webpage, where we provide historical information about every team in Europe. This is plenty of information, which is usually stored in some distributed database, and each team has, literally, megabytes of information about their players, matches, championships, and so on.\n\nIf a million users access information about a team and a new instance of the information is created for each user querying for historical data, we will run out of memory in the blink of an eye. With our Proxy solution, we could make a cache of the *n* most recent searches to speed up queries, but if we return a clone for every team, we will still get short on memory (but faster thanks to our cache). Funny, right?\n\nInstead, we will store each team's information just once, and we will deliver references to them to the users. So, if we face a million users trying to access information about a match, we will actually just have two teams in memory with a million pointers to the same memory direction.\n\n## Acceptance criteria\n\nThe acceptance criteria for a Flyweight pattern must always reduce the amount of memory that is used, and must be focused primarily on this objective:\n\n1.  We will create a `Team` struct with some basic information such as the team's name, players, historical results, and an image depicting their shield.\n2.  We must ensure correct team creation (note the word *creation* here, candidate for a creational pattern), and not having duplicates.\n3.  When creating the same team twice, we must have two pointers pointing to the same memory address.\n\n## Basic structs and tests\n\nOur `Team` struct will contain other structs inside, so a total of four structs will be created. The `Team` struct has the following signature:\n\n```", "```go\n\nEach team has an ID, a name, some image in an slice of bytes representing the team's shield, a slice of players, and a slice of historical data. This way, we will have two teams' ID:\n\n```", "```go\n\nWe declare two constants by using the\u00a0`const` and `iota`\u00a0keywords. The\u00a0`const`\u00a0keyword simply declares that the following declarations are constants. `iota` is a untyped integer that automatically increments its value for each new constant between the parentheses. The\u00a0`iota`\u00a0value starts to reset to 0 when we declare `TEAM_A`, so `TEAM_A` is equal to 0\\. On the\u00a0`TEAM_B`\u00a0variable, `iota` is incremented by one so `TEAM_B` is equal to 1\\. The\u00a0`iota`\u00a0assignment is an elegant way to save typing when declaring constant values that doesn't need specific value (like the\u00a0*Pi* constant on the\u00a0`math` package).\n\nOur `Player` and `HistoricalData` are the following:\n\n```", "```go\n\nAs you can see, we also need a `Match` struct, which is stored within `HistoricalData`\u00a0struct. A `Match` struct, in this context, represents the historical result of a match:\n\n```", "```go\n\nThis is enough to represent a team, and to fulfill *Acceptance Criteria 1*. You have probably guessed that there is a lot of information on each team, as some of the European teams have existed for more than 100 years.\n\nFor *Acceptance Criteria 2,* the word *creation* should give us some clue about how to approach this problem. We will build a factory to create and store our teams. Our Factory will consist of a map of years, including pointers to `Teams` as values, and a `GetTeam` function. Using a map will boost the team search if we know their names in advance. We will also dispose of a method to return the number of created objects, which will be called the\u00a0`GetNumberOfObjects` method:\n\n```", "```go\n\nThis is enough to write our first unit test:\n\n```", "```go\n\nIn our test, we verify all the acceptance criteria. First we create a factory, and then ask for a pointer of `TEAM_A`. This pointer cannot be `nil`, or the test will fail.\n\nThen we call for a second pointer to the same team. This pointer can't be nil either, and it should point to the same memory address as the previous one so we know that it has not allocated a new memory.\n\nFinally, we should check whether the number of created teams is only one, because we have asked for the same team twice. We have two pointers but just one instance of the team. Let's run the tests:\n\n```", "```go\n\nWell, it failed. Both pointers were nil and it has not created any object. Interestingly, the function that compares the two pointers doesn't fail; all in all, nil equals nil.\n\n## Implementation\n\nOur `GetTeam` method will need to scan the `map` field called `createdTeams` to make sure the queried team is already created, and return it if so. If the team wasn't created, it will have to create it and store it in the map before returning:\n\n```", "```go\n\nThe preceding code is very simple. If the parameter name exists in the `createdTeams` map, return the pointer. Otherwise, call a factory for team creation. This is interesting enough to stop for a second and analyze. When you use the Flyweight pattern, it is very common to have a Flyweight factory, which uses other types of creational patterns to retrieve the objects it needs.\n\nSo, the `getTeamFactory` method will give us the team we are looking for, we will store it in the map, and return it. The team factory will be able to create the two teams: `TEAM_A` and `TEAM_B`:\n\n```", "```go\n\nWe are simplifying the objects' content so that we can focus on the Flyweight pattern's implementation. Okay, so we just have to define the function to retrieve the number of objects created, which is done as follows:\n\n```", "```go\n\nThis was pretty easy. The `len` function returns the number of elements in an array or slice, the number of characters in a `string`, and so on. It seems that everything is done, and we can launch our tests again:\n\n```", "```go\n\nPanic! Have we forgotten something? By reading the stack trace on the panic message, we can see some addresses, some files, and it seems that the `GetTeam` method is trying to assign an entry to a nil map on *line 71* of the `flyweight.go` file. Let's look at *line 71* closely (remember, if you are writing code while following this tutorial, that the error will probably be in a different line so look closely at your own stark trace):\n\n```", "```go\n\nOkay, this line is on the `GetTeam` method, and, when the method passes through here, it means that it had not found the team on the map-it has created it (the variable team), and is trying to assign it to the map. But the map is nil, because we haven't initialized it when creating the factory. This has a quick solution. In our test, initialize the map where we have created the factory:\n\n```", "```go\n\nI'm sure you have seen the problem here already. If we don't have access to the package, we can initialize the variable. Well, we can make the variable public, and that's all. But this would involve every implementer necessarily knowing that they have to initialize the map, and its signature is neither convenient, or elegant. Instead, we are going to create a simple factory builder to do it for us. This is a very common approach in Go:\n\n```", "```go\n\nSo now, in the test, we replace the factory creation with a call to this function:\n\n```", "```go\n\nAnd we run the test again:\n\n```", "```go\n\nPerfect! Let's improve the test by adding a second test, just to ensure that everything will be running as expected with more volume. We are going to create a million calls to the team creation, representing a million calls from users. Then, we will simply check that the number of teams created is only two:\n\n```", "```go\n\nIn this test, we retrieve `TEAM_A`\u00a0and `TEAM_B` 500,000 times each to reach a million users. Then, we make sure that just two objects were created:\n\n```", "```go\n\nPerfect! We can even check where the pointers are pointing to, and where they are located. We will check with the first three as an example. Add these lines at the end of the last test, and run it again:\n\n```", "```go\n\nIn the preceding test, we use the\u00a0`Printf`\u00a0method to print information about pointers. The `%p` flag gives you the memory location of the object that the pointer is pointing to. If you reference the pointer by passing the `&` symbol, it will give you the direction of the pointer itself.\n\nRun the test again with the same command; you will see three new lines in the output with information similar to the following:\n\n```"]