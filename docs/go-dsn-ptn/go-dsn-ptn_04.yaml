- en: Chapter 4. Structural Patterns - Proxy, Facade, Decorator, and Flyweight Design
    Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。结构模式 - 代理，外观，装饰器和享元设计模式
- en: With this chapter, we will finish with the Structural patterns. We have left
    some of the most complex ones till the end so that you get more used to the mechanics
    of design patterns, and the features of Go language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们将完成结构模式。我们将最复杂的一些模式留到最后，以便您更加熟悉设计模式的机制和Go语言的特性。
- en: In this chapter, we will work at writing a cache to access a database, a library
    to gather weather data, a server with runtime middleware, and discuss a way to
    save memory by saving shareable states between the types values.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将致力于编写一个用于访问数据库的缓存，一个用于收集天气数据的库，一个带有运行时中间件的服务器，并讨论通过在类型值之间保存可共享状态来节省内存的方法。
- en: Proxy design pattern
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理设计模式
- en: We'll start the final chapter on structural patterns with the Proxy pattern.
    It's a simple pattern that provides interesting features and possibilities with
    very little effort.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以代理模式开始最终章节。这是一个简单的模式，可以提供有趣的功能和可能性，而且只需很少的努力。
- en: Description
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Proxy pattern usually wraps an object to hide some of its characteristics.
    These characteristics could be the fact that it is a remote object (remote proxy),
    a very heavy object such as a very big image or the dump of a terabyte database
    (virtual proxy), or a restricted access object (protection proxy).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式通常包装一个对象，以隐藏其某些特征。这些特征可能是它是一个远程对象（远程代理），一个非常重的对象，例如非常大的图像或千兆字节数据库的转储（虚拟代理），或者是一个受限制的访问对象（保护代理）。
- en: Objectives
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The possibilities of the Proxy pattern are many, but in general, they all try
    to provide the same following functionalities:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式的可能性很多，但总的来说，它们都试图提供以下相同的功能：
- en: Hide an object behind the proxy so the features can be hidden, restricted, and
    so on
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏对象在代理后面，以便可以隐藏，限制等功能
- en: Provide a new abstraction layer that is easy to work with, and can be changed
    easily
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个易于使用和易于更改的新抽象层
- en: Example
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: For our example, we are going to create a remote proxy, which is going to be
    a cache of objects before accessing a database. Let's imagine that we have a database
    with many users, but instead of accessing the database each time we want information
    about a user, we will have a **First In First Out** (**FIFO**) stack of users
    in a Proxy pattern (FIFO is a way of saying that when the cache needs to be emptied,
    it will delete the first object that entered first).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将创建一个远程代理，它将是在访问数据库之前对象的缓存。假设我们有一个包含许多用户的数据库，但是我们不会每次想要获取有关用户的信息时都访问数据库，而是在代理模式下拥有一个用户的**先进先出**（**FIFO**）堆栈（FIFO是一种说法，当缓存需要清空时，它将删除最先进入的对象）。
- en: Acceptance criteria
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'We will wrap an imaginary database, represented by a slice, with our Proxy
    pattern. Then, the pattern will have to stick to the following acceptance criteria:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用代理模式包装一个由切片表示的想象数据库。然后，该模式将必须遵循以下验收标准：
- en: All accesse to the database of users will be done through the Proxy type.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有对用户数据库的访问都将通过代理类型完成。
- en: A stack of `n` number of recent users will be kept in the Proxy.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理中将保留`n`个最近用户的堆栈。
- en: If a user already exists in the stack, it won't query the database, and will
    return the stored one
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户已经存在于堆栈中，则不会查询数据库，并将返回存储的用户
- en: If the queried user doesn't exist in the stack, it will query the database,
    remove the oldest user in the stack if it's full, store the new one, and return
    it.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果查询的用户不在堆栈中，则将查询数据库，如果堆栈已满，则删除堆栈中最旧的用户，存储新用户，并返回它。
- en: Unit test
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Since version 1.7 of Go, we can embed tests within tests by using closures so
    we can group them in a more human-readable way, and reduce the number of `Test_`
    functions. Refer to [Chapter 1](ch01.html "Chapter 1. Ready... Steady... Go!")
    , *Ready... Steady... Go!* to learn how to install the new version of Go if your
    current version is older than version 1.7.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自Go的1.7版本以来，我们可以通过使用闭包在测试中嵌入测试，以便以更易读的方式对它们进行分组，并减少`Test_`函数的数量。请参阅[第1章](ch01.html
    "第1章。准备...开始...Go！")，*准备...开始...Go！*，了解如何安装新版本的Go，如果您当前的版本早于1.7版本。
- en: 'The types for this pattern will be the proxy user and user list structs as
    well as a `UserFinder` interface that the database and the Proxy will implement.
    This is key because the Proxy must implement the same interfaces as the features
    of the type it tries to wrap:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的类型将是代理用户和用户列表结构以及`UserFinder`接口，数据库和代理将实现该接口。这很关键，因为代理必须实现与其尝试包装的类型的特性相同的接口：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `UserFinder` is the interface that the database and the Proxy implement.
    The `User` is a type with a member called `ID`, which is `int32` type:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserFinder`是数据库和代理实现的接口。`User`是一种具有名为`ID`的成员的类型，它是`int32`类型：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, the `UserList` is a type of a slice of users. Consider the following
    syntax for that:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`UserList`是用户切片的一种类型。考虑以下语法：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you are asking why we aren't using a slice of users directly, the answer
    is that by declaring a sequence of users this way, we can implement the `UserFinder`
    interface but with a slice, we can't.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么我们不直接使用用户切片，答案是，通过这种方式声明用户序列，我们可以实现`UserFinder`接口，但是使用切片，我们无法。
- en: Finally, the Proxy type, called `UserListProxy` will be composed of a `UserList`
    slice, which will be our database representation. The `StackCache` members which
    will also be of `UserList` type for simplicity, `StackCapacity` to give our stack
    the size we want.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代理类型称为`UserListProxy`，将由`UserList`切片组成，这将是我们的数据库表示。`StackCache`成员也将是`UserList`类型，以简化`StackCapacity`，以便给我们的堆栈指定大小。
- en: 'We will cheat a bit for the purpose of this tutorial and declare a Boolean
    state on a field called `DidDidLastSearchUsedCache` that will hold if the last
    performed search has used the cache, or has accessed the database:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本教程的目的，我们将稍微作弊，声明一个名为`DidDidLastSearchUsedCache`的字段上的布尔状态，该状态将保存上次执行的搜索是否使用了缓存，或者是否访问了数据库。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `UserListProxy` type will cache a maximum of `StackCapacity` users, and
    rotate the cache if it reaches this limit. The `StackCache` members will be populated
    from objects from `SomeDatabase` type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserListProxy`类型将缓存最多`StackCapacity`个用户，并在达到此限制时旋转缓存。`StackCache`成员将从`SomeDatabase`类型的对象中填充。'
- en: 'The first test is called `TestUserListProxy`, and is listed next:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试称为`TestUserListProxy`，并列在下面：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding test creates a user list of 1 million users with random names.
    To do so, we feed the random number generator by calling the `Seed()` function
    with some constant seed so our randomized results are also constant; and the user
    IDs are generated from it. It might have some duplicates, but it serves our purpose.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试创建了一个包含随机名称的100万用户的用户列表。为此，我们通过调用`Seed()`函数使用一些常量种子来为随机数生成器提供输入，以便我们的随机化结果也是常量；用户ID是从中生成的。它可能有一些重复，但它满足了我们的目的。
- en: 'Next, we need a proxy with a reference to `someDatabase`, which we have just
    created:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个代理，它引用了刚刚创建的`someDatabase`：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, we have a `proxy` object composed of a mock database with 1 million
    users, and a cache implemented as a FIFO stack with a size of 2\. Now we will
    get three random IDs from `someDatabase` to use in our stack:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们有一个由1百万用户组成的模拟数据库和一个大小为2的FIFO堆栈实现的缓存的`proxy`对象。现在我们将从`someDatabase`中获取三个随机ID来使用我们的堆栈：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We took the fourth, fifth, and sixth IDs from the slice (remember that arrays
    and slices start with 0, so the index 3 is actually the fourth position in the
    slice).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从切片中取出了第四、第五和第六个ID（请记住，数组和切片从0开始，因此索引3实际上是切片中的第四个位置）。
- en: 'This is going to be our starting point before launching the embedded tests.
    To create an embedded test, we have to call the `Run` method of the `testing.T`
    pointer, with a description and a closure with the `func(t *testing.T)` signature:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们在启动嵌入式测试之前的起点。要创建嵌入式测试，我们必须调用`testing.T`指针的`Run`方法，其中包括描述和具有`func(t *testing.T)`签名的闭包：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For example, in the preceding code snippet, we give the description `FindUser
    - Empty cache`. Then we define our closure. First it tries to find a user with
    a known ID, and checks for errors. As the description implies, the cache is empty
    at this point, and the user will have to be retrieved from the `someDatabase` array:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的代码片段中，我们给出了描述`FindUser - Empty cache`。然后我们定义我们的闭包。首先它尝试查找具有已知ID的用户，并检查错误。由于描述暗示，此时缓存为空，用户将不得不从`someDatabase`数组中检索：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, we check whether the returned user has the same ID as that of the expected
    user at index 0 of the `knownIDs` slice, and that the proxy cache now has a size
    of 1\. The state of the member `DidLastSearchUsedCache` proxy must not be `true`,
    or we will not pass the test. Remember, this member tells us whether the last
    search has been retrieved from the slice that represents a database, or from the
    cache.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查返回的用户是否具有与`knownIDs`切片的索引0处的预期用户相同的ID，并且代理缓存现在的大小为1。成员`DidLastSearchUsedCache`的状态代理不能是`true`，否则我们将无法通过测试。请记住，此成员告诉我们上次搜索是从表示数据库的切片中检索的，还是从缓存中检索的。
- en: 'The second embedded test for the Proxy pattern is to ask for the same user
    as before, which must now be returned from the cache. It''s very similar to the
    previous test, but now we have to check if the user is returned from the cache:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式的第二个嵌入式测试是要求与之前相同的用户，现在必须从缓存中返回。这与以前的测试非常相似，但现在我们必须检查用户是否从缓存中返回：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, again we ask for the first known ID. The proxy cache must maintain a size
    of 1 after this search, and the `DidLastSearchUsedCache` member must be true this
    time, or the test will fail.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们再次要求第一个已知的ID。代理缓存在此搜索后必须保持大小为1，并且这次`DidLastSearchUsedCache`成员必须为true，否则测试将失败。
- en: 'The last test will overflow the `StackCache` array on the `proxy` type. We
    will search for two new users that our `proxy` type will have to retrieve from
    the database. Our stack has a size of 2, so it will have to remove the first user
    to allocate space for the second and third users:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的测试将使`proxy`类型的`StackCache`数组溢出。我们将搜索两个新用户，我们的`proxy`类型将不得不从数据库中检索这些用户。我们的堆栈大小为2，因此它将不得不删除第一个用户以为第二个和第三个用户分配空间：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have retrieved the first three users. We aren't checking for errors because
    that was the purpose of the previous tests. This is important to recall that there
    is no need to over-test your code. If there is any error here, it will arise in
    the previous tests. Also, we have checked that the `user2` and `user3` queries
    do not use the cache; they shouldn't be stored there yet.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检索到了前三个用户。我们不检查错误，因为这是以前测试的目的。重要的是要记住，没有必要过度测试您的代码。如果这里有任何错误，它将在以前的测试中出现。此外，我们已经检查了`user2`和`user3`查询是否未使用缓存；它们不应该被存储在那里。
- en: 'Now we are going to look for the `user1` query in the Proxy. It shouldn''t
    exist, as the stack has a size of 2, and `user1` was the first to enter, hence,
    the first to go out:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在代理中查找`user1`查询。它不应该存在，因为堆栈的大小为2，而`user1`是第一个进入的，因此也是第一个出去的：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It doesn't matter if we ask for a thousand users; our cache can't be bigger
    than our configured size.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们要求一千个用户，我们的缓存都不能大于我们配置的大小。
- en: 'Finally, we are going to again range over the users stored in the cache, and
    compare them with the last two we queried. This way, we will check that just those
    users are stored in the cache. Both must be found on it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将再次遍历存储在缓存中的用户，并将它们与我们查询的最后两个用户进行比较。这样，我们将检查只有这些用户存储在缓存中。两者都必须在其中找到：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the tests now should give some errors, as usual. Let''s run them now:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试应该会出现一些错误，像往常一样。现在让我们运行它们：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, let's implement the `FindUser` method to act as our Proxy.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们实现`FindUser`方法以充当我们的代理。
- en: Implementation
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: In our Proxy, the `FindUser` method will search for a specified ID in the cache
    list. If it finds it, it will return the ID. If not, it will search in the database.
    Finally, if it's not in the database list, it will return an error.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代理中，`FindUser`方法将在缓存列表中搜索指定的ID。如果找到它，它将返回ID。如果没有找到，它将在数据库中搜索。最后，如果它不在数据库列表中，它将返回一个错误。
- en: 'If you remember, our Proxy pattern is composed of two `UserList` types (one
    of them a pointer), which are actually slices of `User` type. We will implement
    a `FindUser` method in `User` type too, which, by the way, has the same signature
    as the `UserFinder` interface:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得，我们的代理模式由两种`UserList`类型组成（其中一种是指针），它们实际上是`User`类型的切片。我们还将在`User`类型中实现一个`FindUser`方法，该方法与`UserFinder`接口具有相同的签名：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `FindUser` method in the `UserList` slice will iterate over the list to
    try and find a user with the same ID as the `id` argument, or return an error
    if it can't find it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserList`切片中的`FindUser`方法将遍历列表，尝试找到与`id`参数相同ID的用户，或者如果找不到则返回错误。'
- en: You may be wondering why the pointer `t` is between parentheses. This is to
    dereference the underlying array before accessing its indexes. Without it, you'll
    have a compilation error, because the compiler tries to search the index before
    dereferencing the pointer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么指针`t`在括号之间。这是为了在访问其索引之前取消引用底层数组。如果没有它，您将会遇到编译错误，因为编译器会在取消引用指针之前尝试搜索索引。
- en: 'So, the first part of the proxy `FindUser` method can be written as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代理`FindUser`方法的第一部分可以编写如下：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use the preceding method to search for a user in the `StackCache` member.
    The error will be nil if it can find it, so we check this to print a message to
    the console, change the state of `DidLastSearchUsedCache` to `true` so that the
    test can check whether the user was retrieved from cache, and finally, return
    the user.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用上述方法在`StackCache`成员中搜索用户。如果找到用户，错误将为nil，因此我们检查这一点，以便在控制台打印一条消息，将`DidLastSearchUsedCache`的状态更改为`true`，以便测试可以检查用户是否从缓存中检索，并最终返回用户。
- en: 'So, if the error was not nil, it means that it couldn''t find the user in the
    stack. So, the next step is to search in the database:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果错误不是nil，则意味着它无法在堆栈中找到用户。因此，下一步是在数据库中搜索：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can reuse the `FindUser` method we wrote for `UserList` database in this
    case, because both have the same type for the purpose of this example. Again,
    it searches the user in the database represented  by the `UserList` slice, but
    in this case, if the user isn't found, it returns the error generated in `UserList`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以重用我们为`UserList`数据库编写的`FindUser`方法，因为在这个例子的目的上，两者具有相同的类型。同样，它在数据库中搜索由`UserList`切片表示的用户，但在这种情况下，如果找不到用户，则返回`UserList`中生成的错误。
- en: 'When the user is found (`err` is nil), we have to add the user to the stack.
    For this purpose, we write a dedicated private method that receives a pointer
    of type `UserListProxy`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到用户（`err`为nil）时，我们必须将用户添加到堆栈中。为此，我们编写了一个专用的私有方法，该方法接收`UserListProxy`类型的指针：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `addUserToStack` method takes the user argument, and adds it to the stack
    in place. If the stack is full, it removes the first element in it before adding.
    We have also written an `addUser` method to `UserList` to help us in this. So,
    now in `FindUser` method, we just have to add one line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`addUserToStack`方法接受用户参数，并将其放置在堆栈中。如果堆栈已满，则在添加之前删除其中的第一个元素。我们还编写了一个`addUser`方法来帮助我们在`UserList`中。因此，现在在`FindUser`方法中，我们只需添加一行：'
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This adds the new user to the stack, removing the last if necessary.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将新用户添加到堆栈中，必要时删除最后一个。
- en: 'Finally, we just have to return the new user of the stack, and set the appropriate
    value on `DidLastSearchUsedCache` variable. We also write a message to the console
    to help in the testing process:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需返回堆栈的新用户，并在`DidLastSearchUsedCache`变量上设置适当的值。我们还向控制台写入一条消息，以帮助测试过程：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this, we have enough to pass our tests:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就有足够的内容来通过我们的测试：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see in the preceding messages that our Proxy has worked flawlessly.
    It has returned the first search from the database. Then, when we search for the
    same user again, it uses the cache. Finally, we made a new test that calls three
    different users and we can observe, by looking at the console output, that just
    the first was returned from the cache and that the other two were fetched from
    the database.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在前面的消息中看到，我们的代理已经完美地工作。它已经从数据库中返回了第一次搜索。然后，当我们再次搜索相同的用户时，它使用了缓存。最后，我们进行了一个新的测试，调用了三个不同的用户，通过查看控制台输出，我们可以观察到只有第一个用户是从缓存中返回的，其他两个是从数据库中获取的。
- en: Proxying around actions
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 围绕操作进行代理
- en: Wrap proxies around types that need some intermediate action, like giving authorization
    to the user or providing access to a database, like in our example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要进行一些中间操作的类型周围包装代理，比如为用户提供授权或提供对数据库的访问，就像我们的示例一样。
- en: Our example is a good way to separate application needs from database needs.
    If our application accesses the database too much, a solution for this is not
    in your database. Remember that the Proxy uses the same interface as the type
    it wraps, and, for the user, there shouldn't be any difference between the two.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例是将应用程序需求与数据库需求分离的好方法。如果我们的应用程序对数据库的访问过多，解决方案并不在于数据库。请记住，代理使用与其包装的类型相同的接口，对于用户来说，两者之间不应该有任何区别。
- en: Decorator design pattern
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器设计模式
- en: We'll continue this chapter with the big brother of the Proxy pattern, and maybe,
    one of the most powerful design patterns of all. The **Decorator** pattern is
    pretty simple, but, for instance, it provides a lot of benefits when working with
    legacy code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续本章，介绍代理模式的大哥，也许是最强大的设计模式之一。**装饰器**模式非常简单，但是在处理旧代码时提供了许多好处。
- en: Description
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Decorator design pattern allows you to decorate an already existing type
    with more functional features without actually touching it. How is it possible?
    Well, it uses an approach similar to *matryoshka dolls*, where you have a small
    doll that you can put inside a doll of the same shape but bigger, and so on and
    so forth.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式允许您在不实际触及它的情况下为已经存在的类型添加更多的功能特性。这是如何可能的呢？嗯，它使用了一种类似于*玛特里奥什卡娃娃*的方法，您可以将一个小娃娃放在一个相同形状但更大的娃娃中，依此类推。
- en: The Decorator type implements the same interface of the type it decorates, and
    stores an instance of that type in its members. This way, you can stack as many
    decorators (dolls) as you want by simply storing the old decorator in a field
    of the new one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器类型实现了它装饰的类型的相同接口，并在其成员中存储该类型的实例。这样，您可以通过简单地将旧的装饰器存储在新装饰器的字段中来堆叠尽可能多的装饰器（玩偶）。
- en: Objectives
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: When you think about extending legacy code without the risk of breaking something,
    you should think of the Decorator pattern first. It's a really powerful approach
    to deal with this particular problem.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当您考虑扩展旧代码而不会破坏任何东西时，您应该首先考虑装饰器模式。这是一种处理这个特定问题的非常强大的方法。
- en: A different field where the Decorator is very powerful may not be so obvious
    though it reveals itself when creating types with lots of features based on user
    inputs, preferences, or similar inputs. Like in a Swiss knife, you have a base
    type (the frame of the knife), and from there you unfold its functionalities.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器非常强大的另一个领域可能并不那么明显，尽管当基于用户输入、偏好或类似输入创建具有许多功能的类型时，它会显现出来。就像瑞士军刀一样，您有一个基本类型（刀的框架），然后您展开其功能。
- en: 'So, precisely when are we going to use the Decorator pattern? Answer to this
    question:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们什么时候会使用装饰器模式呢？对这个问题的回答：
- en: When you need to add functionality to some code that you don't have access to,
    or you don't want to modify to avoid a negative effect on the code, and follow
    the open/close principle (like legacy code)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要向一些无法访问的代码添加功能，或者您不希望修改以避免对代码产生负面影响，并遵循开放/封闭原则（如旧代码）时。
- en: When you want the functionality of an object to be created or altered dynamically,
    and the number of features is unknown and could grow fast
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您希望动态创建或更改对象的功能，并且功能数量未知且可能快速增长时
- en: Example
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: In our example, we will prepare a `Pizza` type, where the core is the pizza
    and the ingredients are the decorating types. We will have a couple of ingredients
    for our pizza-onion and meat.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将准备一个`Pizza`类型，其中核心是披萨，配料是装饰类型。我们的披萨上会有一些配料，比如洋葱和肉。
- en: Acceptance criteria
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'The acceptance criteria for a Decorator pattern is to have a common interface
    and a core type, the one that all layers will be built over:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式的验收标准是具有一个公共接口和一个核心类型，所有层都将在其上构建：
- en: We must have the main interface that all decorators will implement. This interface
    will be called `IngredientAdd`, and it will have the `AddIngredient() string`
    method.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有所有装饰器都将实现的主要接口。这个接口将被称为`IngredientAdd`，它将具有`AddIngredient() string`方法。
- en: We must have a core `PizzaDecorator` type (the decorator) that we will add ingredients
    to.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个核心`PizzaDecorator`类型（装饰器），我们将向其添加配料。
- en: We must have an ingredient "onion"  implementing the same `IngredientAdd` interface
    that will add the string `onion` to the returned pizza.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个实现相同`IngredientAdd`接口的配料“onion”，它将向返回的披萨添加字符串`onion`。
- en: We must have a ingredient "meat" implementing the `IngredientAdd` interface
    that will add the string `meat` to the returned pizza.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个实现`IngredientAdd`接口的配料“meat”，它将向返回的披萨添加字符串`meat`。
- en: 'When calling `AddIngredient` method on the top object, it must return a fully
    decorated `pizza` with the text `Pizza with the following ingredients: meat, onion`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在顶层对象上调用`AddIngredient`方法时，它必须返回一个带有文本`Pizza with the following ingredients:
    meat, onion`的完全装饰的`pizza`。'
- en: Unit test
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'To launch our unit tests, we must first create the basic structures described
    in accordance with the acceptance criteria. To begin with, the interface that
    all decorating types must implement is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的单元测试，我们必须首先根据验收标准创建基本结构。首先，所有装饰类型必须实现的接口如下：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following code defines the `PizzaDecorator` type, which must have `IngredientAdd`
    inside, and which implements `IngredientAdd` too:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了`PizzaDecorator`类型，其中必须包含`IngredientAdd`，并且它也实现了`IngredientAdd`：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The definition of the `Meat` type will be very similar to that of the  `PizzaDecorator` structure:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meat`类型的定义将与`PizzaDecorator`结构的定义非常相似：'
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we define the `Onion` struct in a similar fashion:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们以类似的方式定义`Onion`结构体：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is enough to implement the first unit test, and to allow the compiler
    to run them without any compiling errors:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这已足以实现第一个单元测试，并允许编译器在没有任何编译错误的情况下运行它们：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now it must compile without problems, so we can check that the test fails:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它必须能够无问题地编译，这样我们就可以检查测试是否失败：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our first test is done, and we can see that the `PizzaDecorator` struct isn''t
    returning anything yet, that''s why it fails. We can now move on to the `Onion`
    type. The test of the `Onion` type is quite similar to that of the `Pizza` decorator,
    but we must also make sure that we actually add the ingredient to the `IngredientAdd` method
    and not to a nil pointer:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个测试已经完成，我们可以看到`PizzaDecorator`结构体还没有返回任何东西，这就是为什么它失败了。现在我们可以继续进行`Onion`类型的测试。`Onion`类型的测试与`Pizza`装饰器的测试非常相似，但我们还必须确保我们实际上将配料添加到`IngredientAdd`方法而不是空指针：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first half of the preceding test examines the returning error when no `IngredientAdd` method
    is passed to the `Onion` struct initializer. As no pizza is available to add the
    ingredient, an error must be returned:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面测试的前半部分检查了当没有将`IngredientAdd`方法传递给`Onion`结构体初始化程序时返回错误。由于没有可用的披萨来添加配料，必须返回错误：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The second part of the `Onion` type test actually passes `PizzaDecorator` structure
    to the initializer. Then, we check whether no error is being returned, and also
    whether the returning string contains the word `onion` in it. This way, we can
    ensure that onion has been added to the pizza.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Onion`类型测试的第二部分实际上将`PizzaDecorator`结构传递给初始化程序。然后，我们检查是否没有返回错误，以及返回的字符串是否包含单词`onion`。这样，我们可以确保洋葱已添加到比萨中。'
- en: 'Finally for the `Onion` type, the console output of this test with our current
    implementation will be the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后对于`Onion`类型，我们当前实现的测试的控制台输出将如下所示：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `meat` ingredient is exactly the same, but we change the type to meat instead
    of onion:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`meat`成分完全相同，但我们将类型更改为肉而不是洋葱：'
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, the result of the tests will be similar:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试的结果将是类似的：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we must check the full stack test. Creating a pizza with onion and
    meat must return the text `Pizza with the following ingredients: meat, onion`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须检查完整的堆栈测试。创建一个带有洋葱和肉的比萨必须返回文本`带有以下配料的比萨：肉，洋葱`：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our test creates a variable called `pizza` which, like the m*atryoshka dolls*,
    embeds types of the `IngredientAdd` method in several levels. Calling the `AddIngredient`
    method executes the method at the "onion" level, which executes the "meat" one,
    which, finally, executes that of the `PizzaDecorator` struct. After checking that
    no error had been returned, we check whether the returned text follows the needs
    of the *acceptance criteria 5*. The tests are run with the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试创建了一个名为`pizza`的变量，就像`套娃`玩偶一样，嵌入了多个级别的`IngredientAdd`方法的类型。调用`AddIngredient`方法执行"洋葱"级别的方法，该方法执行"肉"级别的方法，最后执行`PizzaDecorator`结构的方法。在检查是否没有返回错误后，我们检查返回的文本是否符合*验收标准5*的需求。测试使用以下命令运行：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: From the preceding output, we can see that the tests now return an empty string
    for our decorated type. This is, of course, because no implementation has been
    done yet. This was the last test to check the fully decorated implementation.
    Let's look closely at the implementation then.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到测试现在为我们装饰的类型返回一个空字符串。当然，这是因为尚未进行任何实现。这是最后一个测试，用于检查完全装饰的实现。然后让我们仔细看看实现。
- en: Implementation
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'We are going to start implementing the `PizzaDecorator` type. Its role is to
    provide the initial text of the full pizza:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始实现`PizzaDecorator`类型。它的作用是提供完整比萨的初始文本：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A single line change on the return of the `AddIngredient` method was enough
    to pass the test:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AddIngredient`方法的返回上进行了一行更改就足以通过测试：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Moving on to the `Onion` struct implementation, we must take the beginning
    of our `IngredientAdd` returned string, and add the word `onion` at the end of
    it in order to get a composed pizza in return:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`Onion`结构的实现，我们必须取得我们返回的`IngredientAdd`字符串的开头，并在其末尾添加单词`onion`，以便得到一份组合的比萨：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Checking that we actually have a pointer to `IngredientAdd` first, we use the
    contents of the inner `IngredientAdd`, and check it for errors. If no errors occur,
    we receive a new string composed of this content, a space, and the word `onion`
    (and no errors). Looks good enough to run the tests:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查我们是否实际上有一个指向`IngredientAdd`的指针，我们使用内部`IngredientAdd`的内容，并检查是否有错误。如果没有错误发生，我们将收到一个由此内容、一个空格和单词`onion`（没有错误）组成的新字符串。看起来足够好来运行测试：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Implementation of the `Meat` struct is very similar:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meat`结构的实现非常相似：'
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And here goes their test execution:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的测试执行如下：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Okay. So, now all the pieces are to be tested separately. If everything is
    okay, the test of the *full stacked* solution must be passing smoothly:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在所有的部分都要分别测试。如果一切正常，*完全堆叠*解决方案的测试必须顺利通过：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Awesome! With the Decorator pattern, we could keep stacking `IngredientAdds`
    which call their inner pointer to add functionality to `PizzaDecorator`. We aren't
    touching the core type either, nor modifying or implementing new things. All the
    new features are implemented by an external type.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！使用装饰器模式，我们可以不断堆叠调用它们内部指针以向`PizzaDecorator`添加功能的`IngredientAdds`。我们也不会触及核心类型，也不会修改或实现新的东西。所有新功能都是由外部类型实现的。
- en: A real-life example - server middleware
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个现实生活的例子-服务器中间件
- en: By now, you should have understood how the Decorator pattern works. Now we can
    try a more advanced example using the small HTTP server that we designed in the
    Adapter pattern section. You learned that an HTTP server can be created by using
    the `http` package, and implementing the `http.Handler` interface. This interface
    has only one method called `ServeHTTP(http.ResponseWriter, http.Request)`. Can
    we use the Decorator pattern to add more functionality to a server? Of course!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经了解了装饰器模式的工作原理。现在我们可以尝试使用我们在适配器模式部分设计的小型HTTP服务器的更高级示例。您已经学会了可以使用`http`包创建HTTP服务器，并实现`http.Handler`接口。该接口只有一个名为`ServeHTTP(http.ResponseWriter,
    http.Request)`的方法。我们可以使用装饰器模式为服务器添加更多功能吗？当然可以！
- en: We will add a couple of pieces to this server. First, we are going to log every
    connection made to it to the `io.Writer` interface (for the sake of simplicity,
    we'll use the `io.Writer` implementation of the `os.Stdout` interface so that
    it outputs to the console). The second piece will add basic HTTP authentication
    to every request made to the server. If the authentication passes, a `Hello Decorator!` message
    will appear. Finally, the user will be able to select the number of decoration
    items that he/she wants in the server, and the server will be structured and created
    at runtime.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向此服务器添加一些部分。首先，我们将记录对其进行的每个连接到`io.Writer`接口（为简单起见，我们将使用`os.Stdout`接口的`io.Writer`实现，以便将其输出到控制台）。第二部分将在发送到服务器的每个请求上添加基本的HTTP身份验证。如果身份验证通过，将出现`Hello
    Decorator!`消息。最后，用户将能够选择他/她在服务器中想要的装饰项的数量，并且服务器将在运行时进行结构化和创建。
- en: Starting with the common interface, http.Handler
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从常见接口http.Handler开始
- en: 'We already have the common interface that we will decorate using nested types.
    We first need to create our core type, which is going to be the `Handler` that
    returns the sentence `Hello Decorator!`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了我们将使用嵌套类型进行装饰的通用接口。我们首先需要创建我们的核心类型，这将是返回句子`Hello Decorator!`的`Handler`。
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This handler can be attributed to the `http.Handle` method to define our first
    endpoint. Let''s check this now by creating the package''s `main` function, and
    sending a `GET` request to it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序可以归因于`http.Handle`方法，以定义我们的第一个端点。现在让我们通过创建包的`main`函数来检查这一点，并向其发送一个`GET`请求：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Execute the server using the Terminal to execute the  `**go run main.go**`
    command. Then, open a new Terminal to make the `GET` request. We''ll use the `curl`
    command to make our requests:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用终端执行服务器以执行`**go run main.go**`命令。然后，打开一个新的终端进行`GET`请求。我们将使用`curl`命令进行请求：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We have crossed the first milestone of our decorated server. The next step
    is to decorate it with logging capabilities. To do so, we must implement the `http.Handler`
    interface, in a new type, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经跨越了我们装饰服务器的第一个里程碑。下一步是用日志功能装饰它。为此，我们必须实现`http.Handler`接口，以新类型的形式进行如下实现：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We call this type `LoggerServer`. As you can see, it stores not only a `Handler`,
    but also `io.Writer` to write the output of the log. Our implementation of the
    `ServeHTTP` method prints the request URI, the host, the content length, and the
    used method `io.Writer`. Once printing is finished, it calls the `ServeHTTP` function
    of its inner `Handler` field.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这种类型为`LoggerServer`。正如你所看到的，它不仅存储`Handler`，还存储`io.Writer`以写入日志的输出。我们的`ServeHTTP`方法的实现打印请求URI、主机、内容长度和使用的方法`io.Writer`。打印完成后，它调用其内部`Handler`字段的`ServeHTTP`函数。
- en: 'We can decorate `MyServer` with this `LoggerMiddleware`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`LoggerMiddleware`装饰`MyServer`：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now run the `**curl **`  command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`**curl **`命令：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Our **curl** command returns the same message, but if you look at the Terminal
    where you have run the Go application, you can see the logging:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**curl**命令返回相同的消息，但是如果你查看运行Go应用程序的终端，你可以看到日志：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We have decorated `MyServer` with logging capabilities without actually modifying
    it. Can we do the same with authentication? Of course! After logging the request,
    we will authenticate it by using **HTTP Basic Authentication** as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用日志功能装饰了`MyServer`，而实际上并没有修改它。我们能否用相同的方法进行身份验证？当然可以！在记录请求后，我们将使用**HTTP基本身份验证**进行身份验证：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The **BasicAuthMiddleware** middleware stores three fields--a handler to decorate
    like in the previous middlewares, a user, and a password, which will be the only
    authorization to access the contents on the server. The implementation of the
    `decorating` method will proceed as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**BasicAuthMiddleware**中间件存储三个字段--一个要装饰的处理程序，就像前面的中间件一样，一个用户和一个密码，这将是访问服务器内容的唯一授权。`decorating`方法的实现将如下进行：'
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding implementation, we use the `BasicAuth` method from `http.Request`
    to automatically retrieve the user and password from the request, plus an `ok/ko`
    from the parsing action. Then we check whether the parsing is correct (returning
    a message to the requester if incorrect, and finishing the request). If no problems
    have been detected during parsing, we check whether the username and the password
    match with the ones stored in `BasicAuthMiddleware`. If the credentials are valid,
    we shall call the decorated type (our server), but if the credentials aren't valid,
    we receive the `User or password incorrect` message in return, and the request
    is finished.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实现中，我们使用`http.Request`的`BasicAuth`方法自动从请求中检索用户和密码，以及解析操作的`ok/ko`。然后我们检查解析是否正确（如果不正确则向请求者返回消息，并结束请求）。如果在解析过程中没有检测到问题，我们将检查用户名和密码是否与`BasicAuthMiddleware`中存储的用户名和密码匹配。如果凭据有效，我们将调用装饰类型（我们的服务器），但如果凭据无效，我们将收到`用户或密码不正确`的消息，并结束请求。
- en: 'Now, we need to provide the user with a way to choose among different types
    of servers. We will retrieve user input data in the main function. We''ll have
    three options to choose from:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为用户提供一种选择不同类型服务器的方式。我们将在主函数中检索用户输入数据。我们将有三个选项可供选择：
- en: Simple server
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单服务器
- en: Server with logging
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有日志的服务器
- en: Server with logging and authentication
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有日志和身份验证的服务器
- en: 'We have to use the `Fscanf` function to retrieve input from the user:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`Fscanf`函数从用户那里检索输入：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `Fscanf` function needs an `io.Reader`  implementor as the first argument
    (which is going to be the input in the console), and it takes the server selected
    by the user from it. We'll pass `os.Stdin` as the `io.Reader` interface to retrieve
    user input. Then, we'll write the type of data it is going to parse. The `%d` specifier
    refers to an integer number. Finally, we'll write memory direction to store the
    parsed input, in this case, the memory position of the `selection` variable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fscanf`函数需要一个`io.Reader`实现者作为第一个参数（这将是控制台中的输入），并从中获取用户选择的服务器。我们将传递`os.Stdin`作为`io.Reader`接口来检索用户输入。然后，我们将写入它将要解析的数据类型。`%d`指定符指的是整数。最后，我们将写入存储解析输入的内存地址，即`selection`变量的内存位置。'
- en: 'Once the user selects an option, we can take the basic server and decorate
    it at runtime, switching over to the selected option:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择了一个选项，我们就可以在运行时获取基本服务器并进行装饰，切换到所选的选项：
- en: '[PRE51]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first option will be handled by the default `switch` option--a plain `MyServer`.
    In the case of the second option, we decorate a plain server with logging. The
    third Option is a bit more developed--we ask the user for a username and a password
    using `Fscanf` again. Note that you can scan more than one input, as we are doing
    to retrieve the user and the password. Then, we take the basic server, decorate
    it with authentication, and finally, with logging.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项将由默认的`switch`选项处理--一个普通的`MyServer`。在第二个选项的情况下，我们用日志装饰了一个普通服务器。第三个选项更加复杂--我们再次使用`Fscanf`要求用户输入用户名和密码。请注意，您可以扫描多个输入，就像我们正在检索用户和密码一样。然后，我们获取基本服务器，用身份验证进行装饰，最后再加上日志。
- en: If you follow the indentation of the nested types of option three, the request
    passes through the logger, then the authentication middleware, and finally, the `MyServer`
    argument if everything is okay. The requests will follow the same route.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循第三个选项的嵌套类型的缩进，请求将通过记录器，然后通过身份验证中间件，最后，如果一切正常，将通过`MyServer`参数。请求将遵循相同的路线。
- en: 'The end of the main function takes the decorated handler, and launches the
    server on the `8080` port:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数的结尾采用了装饰处理程序，并在`8080`端口上启动服务器：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'So, let''s launch the server with the third option:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用第三个选项启动服务器：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We will first test the plain server by choosing the first option. Run the server
    with the command **go run server_decorator.go**, and select the first option.
    Then, in a different Terminal, run the basic request with curl, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过选择第一个选项来测试普通服务器。使用命令**go run server_decorator.go**运行服务器，并选择第一个选项。然后，在另一个终端中，使用curl运行基本请求，如下所示：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Uh, oh! It doesn''t give us access. We haven''t passed any user and password,
    so it tells us that we cannot continue. Let''s try with some random user and password:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，不！它没有给我们访问权限。我们没有传递任何用户名和密码，因此它告诉我们我们无法继续。让我们尝试一些随机的用户名和密码：
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'No access! We can also check in the Terminal where we launched the server and
    where every request is being logged:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 没有访问权限！我们还可以在启动服务器的终端中检查每个请求的记录位置：
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, enter the correct username and password:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输入正确的用户名和密码：
- en: '[PRE57]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here we are! Our request has also been logged, and the server has granted access
    to us. Now we can improve our server as much as we want by writing more middlewares
    to decorate the server's functionality.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到这里了！我们的请求也已被记录，服务器已经授予我们访问权限。现在我们可以通过编写更多的中间件来改进服务器的功能。
- en: A few words about Go's structural typing
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于Go的结构化类型的几句话
- en: Go has a feature that most people dislike at the beginning--structural typing.
    This is when your structure defines your type without explicitly writing it. For
    example, when you implement an interface, you don't have to write explicitly that
    you are actually implementing it, contrary to languages such as Java where you
    have to write the keyword `implements`. If your method follows the signature of
    the interface, you are actually implementing the interface. This can also lead
    to accidental implementations of interface, something that could provoke an impossible-to-track
    mistake, but that is very unlikely.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个大多数人一开始不喜欢的特性 - 结构化类型。这是指您的结构定义了您的类型，而无需明确编写它。例如，当您实现一个接口时，您不必明确地写出您实际上正在实现它，与Java等语言相反，在那里您必须写出关键字`implements`。如果您的方法遵循接口的签名，那么您实际上正在实现接口。这也可能导致意外实现接口，这可能引起无法跟踪的错误，但这种情况非常罕见。
- en: 'However, structural typing also allows you to define an interface after defining
    their implementers. Imagine a `MyPrinter` struct as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，结构化类型也允许您在定义实现者之后定义接口。想象一个`MyPrinter`结构如下：
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Imagine we have been working with the `MyPrinter` type for few months now,
    but it didn''t implement any interface, so it can''t be a possible candidate for
    a Decorator pattern, or maybe it can? What if we wrote an interface that matches
    its `Print` method after a few months? Consider the following code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在已经使用`MyPrinter`类型工作了几个月，但它没有实现任何接口，因此不能成为装饰器模式的可能候选，或者可能可以？如果几个月后编写了一个与其`Print`方法匹配的接口，会发生什么？考虑以下代码片段：
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It actually implements the `Printer` interface, and we can use it to create
    a Decorator solution.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上实现了`Printer`接口，我们可以使用它来创建一个装饰器解决方案。
- en: Structural typing allows a lot of flexibility when writing programs. If you
    don't know whether a type should be a part of an interface or not, you can leave
    it and add the interface later, when you are completely sure about it. This way,
    you can decorate types very easily and with little modification in your source
    code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化类型在编写程序时提供了很大的灵活性。如果您不确定类型是否应该是接口的一部分，可以将其留下，并在完全确定后再添加接口。这样，您可以非常轻松地装饰类型，并且在源代码中进行很少的修改。
- en: Summarizing the Decorator design pattern - Proxy versus Decorator
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结装饰器设计模式 - 代理与装饰器
- en: You might be wondering, what's the difference between the Decorator pattern
    and the Proxy pattern? In the Decorator pattern, we decorate a type dynamically.
    This means that the decoration may or may not be there, or it may be composed
    of one or many types. If you remember, the Proxy pattern wraps a type in a similar
    fashion, but it does so at compile time and it's more like a way to access some
    type.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道装饰器模式和代理模式之间有什么区别？在装饰器模式中，我们动态地装饰一个类型。这意味着装饰可能存在也可能不存在，或者可能由一个或多个类型组成。如果您记得，代理模式以类似的方式包装类型，但它是在编译时这样做的，更像是一种访问某种类型的方式。
- en: At the same time, a decorator might implement the entire interface that the
    type it decorates also implements **or not**. So you can have an interface with
    10 methods and a decorator that just implements one of them and it will still
    be valid. A call on a method not implemented by the decorator will be passed to
    the decorated type. This is a very powerful feature but also very prone to undesired
    behaviors at runtime if you forget to implement any interface method.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，装饰器可能实现其装饰的类型也实现的整个接口**或者不实现**。因此，您可以拥有一个具有10个方法的接口和一个只实现其中一个方法的装饰器，它仍然有效。对装饰器未实现的方法的调用将传递给装饰的类型。这是一个非常强大的功能，但如果您忘记实现任何接口方法，它也很容易出现运行时的不良行为。
- en: In this aspect, you may think that the Proxy pattern is less flexible, and it
    is. But the Decorator pattern is weaker, as you could have errors at runtime,
    which you can avoid at compile time by using the Proxy pattern. Just keep in mind
    that the Decorator is commonly used when you want to add functionality to an object
    at runtime, like in our web server. It's a compromise between what you need and
    what you want to sacrifice to achieve it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，你可能会认为代理模式不够灵活，确实如此。但装饰器模式更弱，因为你可能会在运行时出现错误，而使用代理模式可以在编译时避免这些错误。只需记住，装饰器通常用于在运行时向对象添加功能，就像我们的Web服务器一样。这是你需要的东西和你愿意牺牲以实现它之间的妥协。
- en: Facade design pattern
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观设计模式
- en: The next pattern we'll see in this chapter is the Facade pattern. When we discussed
    the Proxy pattern, you got to know that it was a way to wrap an type to hide some
    of its features of complexity from the user. Imagine that we group many proxies
    in a single point such as a file or a library. This could be a Facade pattern.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们将看到的下一个模式是外观模式。当我们讨论代理模式时，你了解到它是一种包装类型以隐藏某些特性或复杂性的方式。想象一下，我们将许多代理组合在一个单一点，比如一个文件或一个库。这就是外观模式。
- en: Description
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: A facade, in architectural terms, is the front wall that hides the rooms and
    corridors of a building. It protects its inhabitants from cold and rain, and provides
    them privacy. It orders and divides the dwellings.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在建筑学中，外观是隐藏建筑物房间和走廊的前墙。它保护居民免受寒冷和雨水的侵袭，并为他们提供隐私。它对住宅进行排序和划分。
- en: The Facade design pattern does the same, but in our code. It shields the code
    from unwanted access, orders some calls, and hides the complexity scope from the
    user.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 外观设计模式在我们的代码中做了相同的事情。它保护代码免受未经授权的访问，对一些调用进行排序，并将复杂性范围隐藏在用户视野之外。
- en: Objectives
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: You use Facade when you want to hide the complexity of some tasks, especially
    when most of them share utilities (such as authentication in an API). A library
    is a form of facade, where someone has to provide some methods for a developer
    to do certain things in a friendly way. This way, if a developer needs to use
    your library, he doesn't need to know all the inner tasks to retrieve the result
    he/she wants.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要隐藏某些任务的复杂性时，特别是当大多数任务共享实用程序时（例如在API中进行身份验证）。库是外观的一种形式，其中某人必须为开发人员提供一些方法，以便以友好的方式执行某些操作。这样，如果开发人员需要使用你的库，他不需要知道检索所需结果的所有内部任务。
- en: 'So, you use the Facade design pattern in the following scenarios:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在以下情况下使用外观设计模式：
- en: When you want to decrease the complexity of some parts of our code. You hide
    that complexity behind the facade by providing a more easy-to-use method.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要减少我们代码的某些部分的复杂性时。你通过提供更易于使用的方法将复杂性隐藏在外观后面。
- en: When you want to group actions that are cross-related in a single place.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要将相关的操作分组到一个地方时。
- en: When you want to build a library so that others can use your products without
    worrying about how it all works.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要构建一个库，以便其他人可以使用你的产品而不必担心它是如何工作的。
- en: Example
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: As an example, we are going to take the first steps toward writing our own library
    that accesses `OpenWeatherMaps` service. In case you are not familiar with `OpenWeatherMap`
    service, it is an HTTP service that provides you with live information about weather,
    as well as historical data on it. The **HTTP REST** API is very easy to use, and
    will be a good example on how to create a Facade pattern for hiding the complexity
    of the network connections behind the REST service.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，我们将迈出编写访问`OpenWeatherMaps`服务的自己库的第一步。如果你不熟悉`OpenWeatherMap`服务，它是一个提供实时天气信息以及历史数据的HTTP服务。**HTTP
    REST** API非常易于使用，并且将是一个很好的例子，说明如何为隐藏REST服务背后的网络连接的复杂性创建外观模式。
- en: Acceptance criteria
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受标准
- en: 'The `OpenWeatherMap` API gives lots of information, so we are going to focus
    on getting live weather data in one city in some geo-located place by using its
    latitude and longitude values. The following are the requirements and acceptance
    criteria for this design pattern:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenWeatherMap` API提供了大量信息，因此我们将专注于通过使用其纬度和经度值在某个地理位置获取实时天气数据。以下是此设计模式的要求和接受标准：'
- en: Provide a single type to access the data. All information retrieved from `OpenWeatherMap` service
    will pass through it.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个单一类型来访问数据。从`OpenWeatherMap`服务检索到的所有信息都将通过它传递。
- en: Create a way to get the weather data for some city of some country.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一种获取某个国家的某个城市的天气数据的方法。
- en: Create a way to get the weather data for some latitude and longitude position.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一种获取某个纬度和经度位置的天气数据的方法。
- en: Only second and thrird point must be visible outside of the package; everything
    else must be hidden (including all connection-related data).
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有第二和第三点必须在包外可见；其他所有内容都必须隐藏（包括所有连接相关的数据）。
- en: Unit test
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'To start with our API Facade, we will need an interface with the methods asked
    in *acceptance criteria 2* and *acceptance criteria 3*:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的API外观，我们需要一个接口，其中包含*接受标准2*和*接受标准3*中要求的方法：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We will call *acceptance criteria 2* `GetByCityAndCountryCode`; we will also
    need a city name and a country code in the string format. A country code is a
    two-character code, which represents the **International Organization for Standardization**
    (**ISO**) name of world countries. It returns a `Weather` value, which we will
    define later, and an error if something goes wrong.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称*接受标准2*为`GetByCityAndCountryCode`；我们还需要一个城市名称和一个国家代码，格式为字符串。国家代码是一个两个字符的代码，代表着世界各国的**国际标准化组织**（**ISO**）名称。它返回一个`Weather`值，我们稍后会定义，并且如果出现问题会返回一个错误。
- en: '*Acceptance criteria 3* will be called `GetByGeoCoordinates`, and will need
    latitude and longitude values in the `float32` format. It will also return a `Weather`
    value and an error. The `Weather` value is going to be defined according to the
    returned JSON that the `OpenWeatherMap` API works with. You can find the description
    of this JSON at the webpage [http://openweathermap.org/current#current_JSON](http://openweathermap.org/current#current_JSON).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*验收标准3*将被称为`GetByGeoCoordinates`，并且需要`float32`格式的纬度和经度值。它还将返回`Weather`值和错误。`Weather`值将根据`OpenWeatherMap`
    API使用的返回JSON进行定义。您可以在网页[http://openweathermap.org/current#current_JSON](http://openweathermap.org/current#current_JSON)上找到此JSON的描述。'
- en: 'If you look at the JSON definition, it has the following type:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查看JSON定义，它具有以下类型：
- en: '[PRE61]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It''s quite a long struct, but we have everything that a response could include.
    The struct is called `Weather`, as it is composed of an ID, a name and a Code
    (`Cod`), and a few anonymous structs, which are: `Coord`, `Weather`, `Base`, `Main`,
    `Wind`, `Clouds`, `Rain`, `Dt`, and `Sys`. We could write these anonymous structs
    outside of the `Weather` struct by giving them a name, but it would only be useful
    if we have to work with them separately.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当长的结构，但我们拥有响应可能包含的所有内容。该结构称为`Weather`，因为它由ID，名称和代码（`Cod`）以及一些匿名结构组成，即`Coord`，`Weather`，`Base`，`Main`，`Wind`，`Clouds`，`Rain`，`Dt`和`Sys`。我们可以通过给它们命名来在`Weather`结构之外编写这些匿名结构，但是只有在我们必须单独使用它们时才有用。
- en: After every member and struct within our `Weather` struct, you can find a ``json:"something"``
    line. This comes in handy when differentiating between the JSON key name and your
    member name. If the JSON key is `something`, we aren't forced to call our member
    `something`. For example, our ID member will be called `id` in the JSON response.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Weather`结构中的每个成员和结构之后，您可以找到一个``json：“something”``行。当区分JSON键名和成员名时，这非常方便。如果JSON键是`something`，我们就不必将我们的成员称为`something`。例如，我们的ID成员在JSON响应中将被称为`id`。
- en: 'Why don''t we give the name of the JSON keys to our types? Well, if your fields
    in your type are lowercase, the `encoding/json` package won''t parse them correctly.
    Also, that last annotation provides us a certain flexibility, not only in terms
    of changing the members'' names, but also of omitting some key if we don''t need
    it, with the following signature:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不将JSON键的名称给我们的类型？好吧，如果您的类型中的字段是小写的，则`encoding/json`包将无法正确解析它们。此外，最后的注释为我们提供了一定的灵活性，不仅可以更改成员名称，还可以省略一些键（如果我们不需要），具有以下签名：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With `omitempty` at the end, the parse won't fail if this key is not present
    in the bytes representation of the JSON key.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在末尾使用`omitempty`，如果此键在JSON键的字节表示中不存在，则解析不会失败。
- en: 'Okay, our acceptance criteria 1 ask for a single point of access to the API.
    This is going to be called `CurrentWeatherData`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的验收标准1要求对API进行单点访问。这将被称为`CurrentWeatherData`：
- en: '[PRE63]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `CurrentWeatherData` type has an API key as public member to work. This
    is because you have to be a registered user in `OpenWeatherMap` to enjoy their
    services. Refer to the `OpenWeatherMap` API's webpage for documentation on how
    to get an API key. We won't need it in our example, because we aren't going to
    do integration tests.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentWeatherData`类型具有API密钥作为公共成员以工作。这是因为您必须是`OpenWeatherMap`中的注册用户才能享受其服务。请参阅`OpenWeatherMap`
    API的网页，了解如何获取API密钥的文档。在我们的示例中，我们不需要它，因为我们不打算进行集成测试。'
- en: 'We need mock data so that we can write a `mock` function to retrieve the data.
    When sending an HTTP request, the response is contained in a member called body
    in the form of an `io.Reader`. We have already worked with types that implement
    the `io.Reader` interface, so this should look familiar to you. Our `mock` function
    appears like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要模拟数据，以便我们可以编写`mock`函数来检索数据。发送HTTP请求时，响应以`io.Reader`的形式包含在名为body的成员中。我们已经使用了实现`io.Reader`接口的类型，因此这对您来说应该很熟悉。我们的`mock`函数如下所示：
- en: '[PRE64]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This preceding mocked data was produced by making a request to `OpenWeatherMap`
    using an API key. The `response` variable is a string containing a JSON response.
    Take a close look at the grave accent ([PRE65]
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`OpenWeatherMap`使用API密钥进行请求生成了前面的模拟数据。`response`变量是包含JSON响应的字符串。仔细看一下重音符（[PRE65]
- en: func TestOpenWeatherMap_responseParser(t *testing.T) {
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: func TestOpenWeatherMap_responseParser（t * testing.T）{
- en: r := getMockData()
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: r：= getMockData（）
- en: 'openWeatherMap := CurrentWeatherData{APIkey: ""}'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: openWeatherMap：= CurrentWeatherData {APIkey：""}
- en: weather, err := openWeatherMap.responseParser(r)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: weather，err：= openWeatherMap.responseParser（r）
- en: if err != nil {
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: if err！= nil {
- en: t.Fatal(err)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: t.Fatal（err）
- en: '}'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if weather.ID != 3117735 {
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果weather.ID！= 3117735 {
- en: t.Errorf("Madrid id is 3117735, not %d\n", weather.ID)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: t.Errorf（“马德里id为3117735，而不是％d\n”，weather.ID）
- en: '}'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: func (p *CurrentWeatherData) responseParser(body io.Reader) (*Weather, error)
    {
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: func（p * CurrentWeatherData）responseParser（body io.Reader）（* Weather，error）{
- en: return nil, fmt.Errorf("Not implemented yet")
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 返回nil，fmt.Errorf（“尚未实施”）
- en: '}'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: go test -v -run=responseParser .
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: go test -v -run=responseParser。
- en: === RUN   TestOpenWeatherMap_responseParser
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: === RUN TestOpenWeatherMap_responseParser
- en: '--- FAIL: TestOpenWeatherMap_responseParser (0.00s)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '---失败：测试OpenWeatherMap_responseParser（0.00秒）'
- en: 'facade_test.go:72: Not implemented yet'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: facade_test.go：72：尚未实施
- en: FAIL
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 失败
- en: exit status 1
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 退出状态1
- en: FAIL
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 失败
- en: '[PRE68]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: func (p *CurrentWeatherData) responseParser(body io.Reader) (*Weather, error)
    {
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: func（p * CurrentWeatherData）responseParser（body io.Reader）（* Weather，error）{
- en: w := new(Weather)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: w：= new（Weather）
- en: err := json.NewDecoder(body).Decode(w)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: err：= json.NewDecoder（body）.Decode（w）
- en: if err != nil {
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: if err！= nil {
- en: return nil, err
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 返回nil，err
- en: '}'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return w, nil
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 返回w，nil
- en: '}'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: go test -v -run=responseParser .
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: go test -v -run=responseParser。
- en: === RUN   TestOpenWeatherMap_responseParser
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: === RUN TestOpenWeatherMap_responseParser
- en: '--- PASS: TestOpenWeatherMap_responseParser (0.00s)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '---通过：测试OpenWeatherMap_responseParser（0.00秒）'
- en: PASS
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通过
- en: ok
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 好的
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: func (c *CurrentWeatherData) GetByGeoCoordinates(lat, lon float32) (weather
    *Weather, err error) {
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: func（c * CurrentWeatherData）GetByGeoCoordinates（lat，lon float32）（weather * Weather，err
    error）{
- en: return c.doRequest(
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 返回c.doRequest（
- en: fmt.Sprintf("http://api.openweathermap.org/data/2.5/weather q=%s,%s&APPID=%s",
    lat, lon, c.APIkey))
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Sprintf（“http://api.openweathermap.org/data/2.5/weather q =％s，％s＆APPID =％s”，lat，lon，c.APIkey）
- en: '}'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: func (c *CurrentWeatherData) GetByCityAndCountryCode(city, countryCode string)
    (weather *Weather, err error) {
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: func (c *CurrentWeatherData) GetByCityAndCountryCode(city, countryCode string)
    (weather *Weather, err error) {
- en: return c.doRequest(
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: return c.doRequest(
- en: fmt.Sprintf("http://api.openweathermap.org/data/2.5/weather?lat=%f&lon=%f&APPID=%s",
    city, countryCode, c.APIkey) )
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Sprintf("http://api.openweathermap.org/data/2.5/weather?lat=%f&lon=%f&APPID=%s",
    city, countryCode, c.APIkey) )
- en: '}'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: fmt.Sprintf("http://api.openweathermap.org/data/2.5/weather?lat=%f&lon=%f&APPID=%s",
    city, countryCode, c.APIkey)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Sprintf("http://api.openweathermap.org/data/2.5/weather?lat=%f&lon=%f&APPID=%s",
    city, countryCode, c.APIkey)
- en: '[PRE72]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: func (o *CurrentWeatherData) doRequest(uri string) (weather *Weather, err error)
    {
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: func (o *CurrentWeatherData) doRequest(uri string) (weather *Weather, err error)
    {
- en: client := &http.Client{}
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: client := &http.Client{}
- en: req, err := http.NewRequest("GET", uri, nil)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: === RUN   TestTeamFlyweightFactory_GetTeam
- en: if err != nil {
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: if err != nil {
- en: return
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: '}'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: req.Header.Set("Content-Type", "application/json")
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: req.Header.Set("Content-Type", "application/json")
- en: '[PRE73]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: resp, err := client.Do(req)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: resp, err := client.Do(req)
- en: if err != nil {
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s)'
- en: return
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: '}'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if resp.StatusCode != 200 {
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: if resp.StatusCode != 200 {
- en: byt, errMsg := ioutil.ReadAll(resp.Body)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: byt, errMsg := ioutil.ReadAll(resp.Body)
- en: if errMsg == nil {
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: if errMsg == nil {
- en: errMsg = fmt.Errorf("%s", string(byt))
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: errMsg = fmt.Errorf("%s", string(byt))
- en: '}'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: err = fmt.Errorf("Status code was %d, aborting. Error message was:\n%s\n",resp.StatusCode,
    errMsg)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: err = fmt.Errorf("状态码为%d，中止。错误消息为:\n%s\n",resp.StatusCode, errMsg)
- en: return
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: '}'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE74]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: weather, err = o.responseParser(resp.Body)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: weather, err = o.responseParser(resp.Body)
- en: resp.Body.Close()
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: resp.Body.Close()
- en: return
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: '}'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE75]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: weatherMap := CurrentWeatherData{*apiKey}
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: weatherMap := CurrentWeatherData{*apiKey}
- en: weather, err := weatherMap.GetByCityAndCountryCode("Madrid", "ES")
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: weather, err := weatherMap.GetByCityAndCountryCode("Madrid", "ES")
- en: if err != nil {
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: /home/mcastro/Desktop/go-design-patterns/structural/flyweight/flyweight.go:71
    +0x159
- en: t.Fatal(err)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: t.Fatal(err)
- en: '}'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: fmt.Printf("Temperature in Madrid is %f celsius\n", weather.Main.Temp-273.15)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Printf("马德里的温度为%f摄氏度\n", weather.Main.Temp-273.15)
- en: '[PRE76]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: $ Temperature in Madrid is 30.600006 celsius
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: $ 马德里的温度为30.600006摄氏度
- en: '[PRE77]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: type Team struct {
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: type Team struct {
- en: ID             uint64
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ID             uint64
- en: Name           string
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Name           string
- en: Shield         []byte
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Shield         []byte
- en: Players        []Player
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Players        []Player
- en: HistoricalData []HistoricalData
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE78]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: const (
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: const (
- en: TEAM_A = iota
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: TEAM_A = iota
- en: TEAM_B
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: TEAM_B
- en: )
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '[PRE79]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: type Player struct {
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: type Player struct {
- en: Name    string
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Name    string
- en: Surname string
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Surname string
- en: PreviousTeam uint64
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: PreviousTeam uint64
- en: Photo   []byte
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Photo   []byte
- en: '}'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: type HistoricalData struct {
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: type HistoricalData struct {
- en: Year          uint8
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Year          uint8
- en: LeagueResults []Match
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: LeagueResults []Match
- en: '}'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE80]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: type Match struct {
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: type Match struct {
- en: Date          time.Time
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Date          time.Time
- en: VisitorID     uint64
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: VisitorID     uint64
- en: LocalID       uint64
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: LocalID       uint64
- en: LocalScore    byte
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: LocalScore    byte
- en: VisitorScore  byte
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: VisitorScore  byte
- en: LocalShoots   uint16
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: LocalShoots   uint16
- en: VisitorShoots uint16
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: VisitorShoots uint16
- en: '}'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE81]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: type teamFlyweightFactory struct {
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: type teamFlyweightFactory struct {
- en: createdTeams map[string]*Team
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: createdTeams map[string]*Team
- en: '}'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: req, err := http.NewRequest("GET", uri, nil)
- en: func (t *teamFlyweightFactory) GetTeam(name string) *Team {
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: func (t *teamFlyweightFactory) GetTeam(name string) *Team {
- en: return nil
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: return nil
- en: '}'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: func (t *teamFlyweightFactory) GetNumberOfObjects() int {
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return 0
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: return 0
- en: '}'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE82]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: func TestTeamFlyweightFactory_GetTeam(t *testing.T) {
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: if err != nil {
- en: factory := teamFlyweightFactory{}
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: factory := teamFlyweightFactory{}
- en: teamA1 := factory.GetTeam(TEAM_A)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: teamA1 := factory.GetTeam(TEAM_A)
- en: if teamA1 == nil {
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: if teamA1 == nil {
- en: t.Error("The pointer to the TEAM_A was nil")
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: t.Error("TEAM_A的指针为空")
- en: '}'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: teamA2 := factory.GetTeam(TEAM_A)
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: teamA2 := factory.GetTeam(TEAM_A)
- en: if teamA2 == nil {
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: if teamA2 == nil {
- en: t.Error("The pointer to the TEAM_A was nil")
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: t.Error("TEAM_A的指针为空")
- en: '}'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if teamA1 != teamA2 {
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: if teamA1 != teamA2 {
- en: t.Error("TEAM_A pointers weren't the same")
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: t.Error("TEAM_A的指针不同")
- en: '}'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if factory.GetNumberOfObjects() != 1 {
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: if factory.GetNumberOfObjects() != 1 {
- en: 't.Errorf("The number of objects created was not 1: %d\n", factory.GetNumberOfObjects())'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 't.Errorf("创建的对象数量不是1: %d\n", factory.GetNumberOfObjects())'
- en: '}'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: if err != nil {
- en: '}'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE83]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: $ go test -v -run=GetTeam .
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: $ go test -v -run=GetTeam .
- en: === RUN   TestTeamFlyweightFactory_GetTeam
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: === RUN   TestTeamFlyweightFactory_GetTeam
- en: '--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: HistoricalData []HistoricalData
- en: 'flyweight_test.go:11: The pointer to the TEAM_A was nil'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 'flyweight_test.go:11: TEAM_A的指针为空'
- en: 'flyweight_test.go:21: The pointer to the TEAM_A was nil'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 'flyweight_test.go:21: TEAM_A的指针为空'
- en: 'flyweight_test.go:31: The number of objects created was not 1: 0'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 'flyweight_test.go:31: 创建的对象数量不是1: 0'
- en: FAIL
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: FAIL
- en: exit status 1
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: panic(0x530900, 0xc0820025c0)
- en: FAIL
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: FAIL
- en: '[PRE84]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: func (t *teamFlyweightFactory) GetTeam(teamID int) *Team {
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: func (t *teamFlyweightFactory) GetTeam(teamID int) *Team {
- en: if t.createdTeams[teamID] != nil {
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: if t.createdTeams[teamID] != nil {
- en: return t.createdTeams[teamID]
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: return t.createdTeams[teamID]
- en: '}'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: team := getTeamFactory(teamID)
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: return Team{
- en: t.createdTeams[teamID] = &team
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: t.createdTeams[teamID] = &team
- en: return t.createdTeams[teamID]
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: return t.createdTeams[teamID]
- en: '}'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE85]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: func getTeamFactory(team int) Team {
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: func getTeamFactory(team int) Team {
- en: switch team {
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: switch team {
- en: 'case TEAM_B:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 'case TEAM_B:'
- en: return Team{
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: func (t *teamFlyweightFactory) GetNumberOfObjects() int {
- en: 'ID:   2,'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 'ID:   2,'
- en: 'Name: TEAM_B,'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 'Name: TEAM_B,'
- en: '}'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'default:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 'default:'
- en: return Team{
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: return Team{
- en: 'ID:   1,'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 'ID:   1,'
- en: 'Name: TEAM_A,'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'Name: TEAM_A,'
- en: '}'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE86]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: func (t *teamFlyweightFactory) GetNumberOfObjects() int {
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: func (t *teamFlyweightFactory) GetNumberOfObjects() int {
- en: return len(t.createdTeams)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: return len(t.createdTeams)
- en: '}'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE87]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: $ go test -v -run=GetTeam .
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: $ go test -v -run=GetTeam .
- en: === RUN   TestTeamFlyweightFactory_GetTeam
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 'goroutine 5 [running]:'
- en: '--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s)'
- en: 'panic: assignment to entry in nil map [recovered]'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 'panic: 分配给nil映射中的条目 [已恢复]'
- en: 'panic: assignment to entry in nil map'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 'panic: 分配给nil映射中的条目'
- en: 'goroutine 5 [running]:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: func TestTeamFlyweightFactory_GetTeam(t *testing.T) {
- en: panic(0x530900, 0xc0820025c0)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: team := getTeamFactory(teamID)
- en: /home/mcastro/Go/src/runtime/panic.go:481 +0x3f4
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: /home/mcastro/Go/src/runtime/panic.go:481 +0x3f4
- en: testing.tRunner.func1(0xc082068120)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 测试.tRunner.func1(0xc082068120)
- en: /home/mcastro/Go/src/testing/testing.go:467 +0x199
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: /home/mcastro/Go/src/testing/testing.go:467 +0x199
- en: panic(0x530900, 0xc0820025c0)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: panic(0x530900, 0xc0820025c0)
- en: /home/mcastro/Go/src/runtime/panic.go:443 +0x4f7
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: /home/mcastro/Go/src/runtime/panic.go:443 +0x4f7
- en: /home/mcastro/go-design-patterns/structural/flyweight.(*teamFlyweightFactory).GetTeam(0xc08202fec0,
    0x0, 0x0)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: /home/mcastro/go-design-patterns/structural/flyweight.(*teamFlyweightFactory).GetTeam(0xc08202fec0,
    0x0, 0x0)
- en: /home/mcastro/Desktop/go-design-patterns/structural/flyweight/flyweight.go:71
    +0x159
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: exit status 1
- en: /home/mcastro/go-design-patterns/structural/flyweight.TestTeamFlyweightFactory_GetTeam(0xc082068120)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: /home/mcastro/go-design-patterns/structural/flyweight.TestTeamFlyweightFactory_GetTeam(0xc082068120)
- en: /home/mcastro/Desktop/go-design-patterns/structural/flyweight/flyweight_test.go:9
    +0x61
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: /home/mcastro/Desktop/go-design-patterns/structural/flyweight/flyweight_test.go:9
    +0x61
- en: testing.tRunner(0xc082068120, 0x666580)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: testing.tRunner(0xc082068120, 0x666580)
- en: /home/mcastro/Go/src/testing/testing.go:473 +0x9f
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: /home/mcastro/Go/src/testing/testing.go:473 +0x9f
- en: created by testing.RunTests
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: created by testing.RunTests
- en: /home/mcastro/Go/src/testing/testing.go:582 +0x899
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: /home/mcastro/Go/src/testing/testing.go:582 +0x899
- en: exit status 2
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: exit status 2
- en: FAIL
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: FAIL
- en: '[PRE88]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: t.createdTeams[teamName] = &team
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: t.createdTeams[teamName] = &team
- en: '[PRE89]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: factory := teamFlyweightFactory{
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: factory := teamFlyweightFactory{
- en: 'createdTeams: make(map[int]*Team,0),'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 'createdTeams: make(map[int]*Team,0),'
- en: '}'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE90]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: func NewTeamFactory() teamFlyweightFactory {
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: func NewTeamFactory() teamFlyweightFactory {
- en: return teamFlyweightFactory{
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: return teamFlyweightFactory{
- en: 'createdTeams: make(map[int]*Team),'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 'createdTeams: make(map[int]*Team),'
- en: '}'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE91]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: func TestTeamFlyweightFactory_GetTeam(t *testing.T) {
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: func TestTeamFlyweightFactory_GetTeam(t *testing.T) {
- en: factory := NewTeamFactory()
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: factory := NewTeamFactory()
- en: '...'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE92]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: $ go test -v -run=GetTeam .
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: $ go test -v -run=GetTeam .
- en: === RUN   TestTeamFlyweightFactory_GetTeam
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: === RUN   TestTeamFlyweightFactory_GetTeam
- en: '--- PASS: TestTeamFlyweightFactory_GetTeam (0.00s)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '--- PASS: TestTeamFlyweightFactory_GetTeam (0.00s)'
- en: PASS
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: PASS
- en: ok
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: ok
- en: '[PRE93]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: func Test_HighVolume(t *testing.T) {
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: func Test_HighVolume(t *testing.T) {
- en: factory := NewTeamFactory()
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: factory := NewTeamFactory()
- en: teams := make([]*Team, 500000*2)
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: teams := make([]*Team, 500000*2)
- en: for i := 0; i < 500000; i++ {
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: for i := 0; i < 500000; i++ {
- en: teams[i] = factory.GetTeam(TEAM_A)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: teams[i] = factory.GetTeam(TEAM_A)
- en: '}'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: for i := 500000; i < 2*500000; i++ {
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: for i := 500000; i < 2*500000; i++ {
- en: teams[i] = factory.GetTeam(TEAM_B)
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: teams[i] = factory.GetTeam(TEAM_B)
- en: '}'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if factory.GetNumberOfObjects() != 2 {
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: if factory.GetNumberOfObjects() != 2 {
- en: 't.Errorf("The number of objects created was not 2: %d\n",factory.GetNumberOfObjects())'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 't.Errorf("The number of objects created was not 2: %d\n",factory.GetNumberOfObjects())'
- en: '}'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE94]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: $ go test -v -run=Volume .
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: $ go test -v -run=Volume .
- en: === RUN   Test_HighVolume
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: === RUN   Test_HighVolume
- en: '--- PASS: Test_HighVolume (0.04s)'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '--- PASS: Test_HighVolume (0.04s)'
- en: PASS
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: PASS
- en: ok
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: ok
- en: '[PRE95]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: for i:=0; i<3; i++ {
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: for i:=0; i<3; i++ {
- en: fmt.Printf("Pointer %d points to %p and is located in %p\n", i, teams[i], &teams[i])
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Printf("Pointer %d points to %p and is located in %p\n", i, teams[i], &teams[i])
- en: '}'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE96]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Pointer 0 points to 0xc082846000 and is located in 0xc082076000
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: Pointer 0 points to 0xc082846000 and is located in 0xc082076000
- en: Pointer 1 points to 0xc082846000 and is located in 0xc082076008
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: Pointer 1 points to 0xc082846000 and is located in 0xc082076008
- en: Pointer 2 points to 0xc082846000 and is located in 0xc082076010
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: Pointer 2 points to 0xc082846000 and is located in 0xc082076010
- en: '```'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: What it tells us is that the first three positions in the map point to the same
    location, but that we actually have three different pointers, which are, effectively,
    much lighter than our team object.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们的是，地图中的前三个位置指向相同的位置，但实际上我们有三个不同的指针，它们实际上比我们的团队对象轻得多。
- en: What's the difference between Singleton and Flyweight then?
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么单例模式和享元模式有什么区别呢？
- en: Well, the difference is subtle but it's just there. With the Singleton pattern,
    we ensure that the same type is created only once. Also, the Singleton pattern
    is a Creational pattern. With Flyweight, which is a Structural pattern, we aren't
    worried about how the objects are created, but about how to structure a type to
    contain heavy information in a light way. The structure we are talking about is
    the `map[int]*Team` structure in our example. Here, we really didn't care about
    how we created the object; we have simply written an uncomplicated the `getTeamFactory` method
    for it. We gave major importance to having a light structure to hold a shareable
    object (or objects), in this case, the map.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，差异微妙，但确实存在。使用单例模式，我们确保只创建一次相同的类型。此外，单例模式是一种创建模式。对于享元模式，它是一种结构模式，我们不关心对象是如何创建的，而是关心如何以轻量的方式构造一个类型来包含重的信息。我们谈论的结构是我们的例子中的`map[int]*Team`结构。在这里，我们真的不关心如何创建对象；我们只是为它编写了一个简单的`getTeamFactory`方法。我们非常重视拥有一个轻量级的结构来容纳可共享的对象（或对象），在这种情况下是地图。
- en: Summary
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Summary
- en: We have seen several patterns to organize code structures. Structural patterns
    are concerned about how to create objects, or how they do their business (we'll
    see this in the behavioral patterns).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几种组织代码结构的模式。结构模式关心如何创建对象，或者它们如何进行业务（我们将在行为模式中看到这一点）。
- en: Don't feel confused about mixing several patterns. You could end up mixing six
    or seven quite easily if you strictly follow the objectives of each one. Just
    keep in mind that over-engineering is as bad as no engineering at all. I remember
    prototyping a load balancer one evening, and after two hours of crazy over-engineered
    code, I had such a mess in my head that I preferred to start all over again.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为混合了几种模式而感到困惑。如果您严格遵循每种模式的目标，您很容易混合六七种模式。只要记住，过度设计和根本不设计一样糟糕。我记得有一天晚上我做了一个负载均衡器的原型，经过两个小时的疯狂过度设计的代码后，我的脑子里一团糟，我宁愿重新开始。
- en: In the next chapter, we'll see behavioral patterns. They are a bit more complex,
    and they often use Structural and Creational patterns for their objectives, but
    I'm sure that the reader will find them quite challenging and interesting.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到行为模式。它们更加复杂，通常使用结构模式和创建模式来实现它们的目标，但我相信读者会觉得它们非常具有挑战性和有趣。
