["```go\ntype PrintStrategy interface { \n  Print() error \n} \n\n```", "```go\ntype ConsoleSquare struct {} \n\ntype ImageSquare struct { \n  DestinationFilePath string \n} \n\n```", "```go\nfunc(c *ConsoleSquare) Print() error { \n  println(\"Square\")  \n  return nil \n} \n\n```", "```go\nfunc (t *ImageSquare) Print() error { \n  width := 800 \n  height := 600 \n\n  origin := image.Point{0, 0} \n\n  bgImage := image.NewRGBA(image.Rectangle{ \n    Min: origin, \n    Max: image.Point{X: width, Y: height}, \n  }) \n\n  bgColor := image.Uniform{color.RGBA{R: 70, G: 70, B: 70, A:0}} \n  quality := &jpeg.Options{Quality: 75} \n\n  draw.Print(bgImage, bgImage.Bounds(), &bgColor, origin, draw.Src) \n\n```", "```go\n  squareWidth := 200 \n  squareHeight := 200 \n  squareColor := image.Uniform{color.RGBA{R: 255, G: 0, B: 0, A: 1}} \n  square := image.Rect(0, 0, squareWidth, squareHeight) \n  square = square.Add(image.Point{ \n    X: (width / 2) - (squareWidth / 2), \n    Y: (height / 2) - (squareHeight / 2), \n  }) \n  squareImg := image.NewRGBA(square) \n\n  draw.Print(bgImage, squareImg.Bounds(), &squareColor, origin, draw.Src) \n\n```", "```go\n  w, err := os.Create(t.DestinationFilePath) \n  if err != nil { \n    return fmt.Errorf(\"Error opening image\") \n  } \n  defer w.Close() \n\n  if err = jpeg.Encode(w, bgImage, quality); err != nil { \n    return fmt.Errorf(\"Error writing image to disk\") \n  } \n\n  return nil \n} \n\n```", "```go\nvar output = flag.String(\"output\", \"console\", \"The output to use between 'console' and 'image' file\") \n\n```", "```go\nfunc main(){ \n    flag.Parse() \n\n```", "```go\nvar activeStrategy PrintStrategy \n\nswitch *output { \ncase \"console\": \n  activeStrategy = &TextSquare{} \ncase \"image\": \n  activeStrategy = &ImageSquare{\"/tmp/image.jpg\"} \ndefault: \n  activeStrategy = &TextSquare{} \n} \n\n```", "```go\n  err := activeStrategy.Print() \n  if err != nil { \n    log.Fatal(err) \n  } \n}\n\n```", "```go\n$ go run main.go --output=console\nSquare\n\n```", "```go\n$ go run main.go --output=console\nSquare\n$ go run main.go --output console\nSquare\n$ go run main.go\nSquare\n\n```", "```go\n$ go run main.go --output image\n\n```", "```go\ntype PrintStrategy interface { \n  Print() error \n  SetLog(io.Writer) \n  SetWriter(io.Writer) \n} \n\n```", "```go\ntype PrintOutput struct { \n  Writer    io.Writer \n  LogWriter io.Writer \n} \n\nfunc(d *PrintOutput) SetLog(w io.Writer) { \n  d.LogWriter = w \n} \n\nfunc(d *PrintOutput) SetWriter(w io.Writer) { \n  d.Writer = w \n} \n\n```", "```go\npackage shapes \n\ntype TextSquare struct { \n  strategy.PrintOutput \n} \n\n```", "```go\nfunc (t *TextSquare) Print() error { \n  r := bytes.NewReader([]byte(\"Circle\")) \n  io.Copy(t.Writer, r) \n  return nil \n} \n\n```", "```go\nfunc (t *TextSquare) Print() error { \n  t.Writer.Write([]byte(\"Circle\")) \n  return nil \n} \n\n```", "```go\ntype ImageSquare struct { \n  strategy.PrintOutput \n} \n\n```", "```go\ndraw.Print(bgImage, squareImg.Bounds(), &squareColor, origin, draw.Src) \n\nif i.Writer == nil { \n  return fmt.Errorf(\"No writer stored on ImageSquare\") \n} \nif err := jpeg.Encode(i.Writer, bgImage, quality); err != nil { \n  return fmt.Errorf(\"Error writing image to disk\") \n} \n\nif i.LogWriter != nil { \n  io.Copy(i.LogWriter, \"Image written in provided writer\\n\") \n} \n\nreturn nil \n\n```", "```go\nconst ( \n  TEXT_STRATEGY  = \"text\" \n  IMAGE_STRATEGY = \"image\" \n) \n\nfunc NewPrinter(s string) (strategy.Output, error) { \n  switch s { \n  case TEXT_STRATEGY: \n    return &TextSquare{ \n      PrintOutput: strategy.PrintOutput{ \n        LogWriter: os.Stdout, \n      }, \n    }, nil \n  case IMAGE_STRATEGY: \n    return &ImageSquare{ \n      PrintOutput: strategy.PrintOutput{ \n        LogWriter: os.Stdout, \n      }, \n    }, nil \n  default: \n    return nil, fmt.Errorf(\"Strategy '%s' not found\\n\", s) \n  } \n} \n\n```", "```go\nvar output = flag.String(\"output\", \"text\", \"The output to use between \"+ \n  \"'console' and 'image' file\") \n\nfunc main() { \n  flag.Parse() \n\n```", "```go\nactiveStrategy, err := shapes.NewPrinter(*output) \nif err != nil { \n  log.Fatal(err) \n} \n\n```", "```go\nswitch *output { \ncase shapes.TEXT_STRATEGY: \n  activeStrategy.SetWriter(os.Stdout) \ncase shapes.IMAGE_STRATEGY: \n  w, err := os.Create(\"/tmp/image.jpg\") \n  if err != nil { \n    log.Fatal(\"Error opening image\") \n  } \n  defer w.Close() \n\n  activeStrategy.SetWriter(w) \n} \n\n```", "```go\nerr = activeStrategy.Print() \nif err != nil { \n  log.Fatal(err) \n} \n\n```", "```go\n$ go run main.go --output text\nCircle\n\n```", "```go\n$ go run main.go --output image\nImage written in provided writer\n\n```", "```go\ntype ChainLogger interface { \n  Next(string) \n} \n\n```", "```go\ntype FirstLogger struct { \n  NextChain ChainLogger \n} \n\nfunc (f *FirstLogger) Next(s string) {} \n\ntype SecondLogger struct { \n  NextChain ChainLogger \n} \n\nfunc (f *SecondLogger) Next(s string) {} \n\ntype WriterLogger struct { \n  NextChain ChainLogger \n  Writer    io.Writer \n} \nfunc (w *WriterLogger) Next(s string) {} \n\n```", "```go\ntype myTestWriter struct { \n  receivedMessage string \n} \n\nfunc (m *myTestWriter) Write(p []byte) (int, error) { \n  m.receivedMessage += string(p) \n  return len(p), nil \n} \n\nfunc(m *myTestWriter) Next(s string){ \n  m.Write([]byte(s)) \n} \n\n```", "```go\nfunc TestCreateDefaultChain(t *testing.T) { \n  //Our test ChainLogger \n  myWriter := myTestWriter{} \n\n  writerLogger := WriterLogger{Writer: &myWriter} \n  second := SecondLogger{NextChain: &writerLogger} \n  chain := FirstLogger{NextChain: &second} \n\n```", "```go\nt.Run(\"3 loggers, 2 of them writes to console, second only if it founds \" + \n  \"the word 'hello', third writes to some variable if second found 'hello'\", \n  func(t *testing.T){ \n    chain.Next(\"message that breaks the chain\\n\") \n\n    if myWriter.receivedMessage != \"\" { \n      t.Fatal(\"Last link should not receive any message\") \n    } \n\n    chain.Next(\"Hello\\n\") \n\n    if !strings.Contains(myWriter.receivedMessage, \"Hello\") { \n      t.Fatal(\"Last link didn't received expected message\") \n    } \n}) \n\n```", "```go\ngo test -v .\n=== RUN   TestCreateDefaultChain\n=== RUN   TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_'hello',_third_writes_to_some_variable_if_second_found_'hello'\n--- FAIL: TestCreateDefaultChain (0.00s)\n--- FAIL: TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_'hello',_third_writes_to_some_variable_if_second_found_'hello' (0.00s)\n chain_test.go:33: Last message didn't received expected message\nFAIL\nexit status 1\nFAIL\n\n```", "```go\ntype myTestWriter struct { \n  receivedMessage *string \n} \n\nfunc (m *myTestWriter) Write(p []byte) (int, error) { \n  if m.receivedMessage == nil { \n         m.receivedMessage = new(string) \n} \n  tempMessage := fmt.Sprintf(\"%s%s\", m.receivedMessage, p) \n  m.receivedMessage = &tempMessage \n  return len(p), nil \n} \n\nfunc (m *myTestWriter) Next(s string) { \n  m.Write([]byte(s)) \n} \n\n```", "```go\nt.Run(\"3 loggers, 2 of them writes to console, second only if it founds \"+ \n\"the word 'hello', third writes to some variable if second found 'hello'\", \nfunc(t *testing.T) { \n  chain.Next(\"message that breaks the chain\\n\") \n\n  if myWriter.receivedMessage != nil { \n    t.Error(\"Last link should not receive any message\") \n  } \n\n  chain.Next(\"Hello\\n\") \n\n  if myWriter.receivedMessage == \"\" || !strings.Contains(*myWriter.receivedMessage, \"Hello\") { \n    t.Fatal(\"Last link didn't received expected message\") \n  } \n}) \n\n```", "```go\ngo test -v . \n=== RUN   TestCreateDefaultChain \n=== RUN   TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_'hello',_third_writes_to_some_variable_if_second_found_'hello' \n--- FAIL: TestCreateDefaultChain (0.00s) \n--- FAIL: TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_'hello',_third_writes_to_some_variable_if_second_found_'hello' (0.00s) \n        chain_test.go:40: Last link didn't received expected message \nFAIL \nexit status 1 \nFAIL\n\n```", "```go\ntype FirstLogger struct { \n  NextChain ChainLogger \n} \n\nfunc (f *FirstLogger) Next(s string) { \n  fmt.Printf(\"First logger: %s\\n\", s) \n\n  if f.NextChain != nil { \n    f.NextChain.Next(s) \n  } \n} \n\n```", "```go\ntype SecondLogger struct { \n  NextChain ChainLogger \n} \n\nfunc (se *SecondLogger) Next(s string) { \n  if strings.Contains(strings.ToLower(s), \"hello\") { \n    fmt.Printf(\"Second logger: %s\\n\", s) \n\n    if se.NextChain != nil { \n      se.NextChain.Next(s) \n    } \n\n    return \n  } \n\n  fmt.Printf(\"Finishing in second logging\\n\\n\") \n} \n\n```", "```go\ntype WriterLogger struct { \n  NextChain ChainLogger \n  Writer    io.Writer \n} \n\nfunc (w *WriterLogger) Next(s string) { \n  if w.Writer != nil { \n    w.Writer.Write([]byte(\"WriterLogger: \" + s)) \n  } \n\n  if w.NextChain != nil { \n    w.NextChain.Next(s) \n  } \n} \n\n```", "```go\ngo test -v .\n=== RUN   TestCreateDefaultChain\n=== RUN   TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_'hello',_third_writes_to_some_variable_if_second_found_'hello'\nFirst logger: message that breaks the chain\nFinishing in second logging\nFirst logger: Hello\nSecond logger: Hello\n--- PASS: TestCreateDefaultChain (0.00s)\n --- PASS: TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_'hello',_third_writes_to_some_variable_if_second_found_'hello' (0.00s)\nPASS\nok\n\n```", "```go\ntype ClosureChain struct { \n  NextChain ChainLogger \n  Closure   func(string) \n} \n\nfunc (c *ClosureChain) Next(s string) { \n  if c.Closure != nil { \n    c.Closure(s) \n  } \n\n  if c.NextChain != nil { \n    c.Next(s) \n  } \n} \n\n```", "```go\nt.Run(\"2 loggers, second uses the closure implementation\", func(t *testing.T) { \n  myWriter = myTestWriter{} \n  closureLogger := ClosureChain{ \n    Closure: func(s string) { \n      fmt.Printf(\"My closure logger! Message: %s\\n\", s) \n      myWriter.receivedMessage = &s \n    }, \n  } \n\n  writerLogger.NextChain = &closureLogger \n\n  chain.Next(\"Hello closure logger\") \n\n  if *myWriter.receivedMessage != \"Hello closure logger\" { \n    t.Fatal(\"Expected message wasn't received in myWriter\") \n  } \n}) \n\n```", "```go\ngo test -v . \n=== RUN   TestCreateDefaultChain \n=== RUN   TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_'hello',_third_writes_to_some_variable_if_second_found_'hello' \nFirst logger: message that breaks the chain \nFinishing in second logging \n\nFirst logger: Hello \nSecond logger: Hello \n=== RUN   TestCreateDefaultChain/2_loggers,_second_uses_the_closure_implementation \nFirst logger: Hello closure logger \nSecond logger: Hello closure logger \nMy closure logger! Message: Hello closure logger \n--- PASS: TestCreateDefaultChain (0.00s) \n    --- PASS: TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_'hello',_third_writes_to_some_variable_if_second_found_'hello' (0.00s) \n    --- PASS: TestCreateDefaultChain/2_loggers,_second_uses_the_closure_implementation (0.00s) \nPASS \nok\n\n```", "```go\ntype Command interface { \n  Execute() \n} \n\n```", "```go\ntype ConsoleOutput struct { \n  message string \n} \n\nfunc (c *ConsoleOutput) Execute() { \n  fmt.Println(c.message) \n} \n\n```", "```go\n func CreateCommand(s string) Command { \n   fmt.Println(\"Creating command\") \n\n   return &ConsoleOutput{ \n         message: s, \n   } \n} \n\n```", "```go\ntype CommandQueue struct { \n  queue []Command \n} \n\nfunc (p *CommandQueue) AddCommand(c Command) { \n  p.queue = append(p.queue, c) \n\n  if len(p.queue) == 3 { \n    for _, command := range p.queue { \n      command.Execute() \n    } \n\n    p.queue = make([]Command, 3) \n  } \n} \n\n```", "```go\nfunc main() { \n  queue := CommandQueue{} \n\n  queue.AddCommand(CreateCommand(\"First message\")) \n  queue.AddCommand(CreateCommand(\"Second message\")) \n  queue.AddCommand(CreateCommand(\"Third message\")) \n\n  queue.AddCommand(CreateCommand(\"Fourth message\")) \n  queue.AddCommand(CreateCommand(\"Fifth message\")) \n} \n\n```", "```go\n$go run command.go\nCreating command\nCreating command\nCreating command\nFirst message\nSecond message\nThird message\nCreating command\nCreating command\n\n```", "```go\ntype Command interface { \n  Info() string \n} \n\n```", "```go\ntype TimePassed struct { \n  start time.Time \n} \n\nfunc (t *TimePassed) Info() string { \n  return time.Since(t.start).String() \n} \n\n```", "```go\ntype HelloMessage struct{} \n\nfunc (h HelloMessage) Info() string { \n  return \"Hello world!\" \n} \n\n```", "```go\nfunc main() { \n  var timeCommand Command \n  timeCommand = &TimePassed{time.Now()} \n\n  var helloCommand Command \n  helloCommand = &HelloMessage{} \n\n  time.Sleep(time.Second) \n\n  fmt.Println(timeCommand.Info()) \n  fmt.Println(helloCommand.Info()) \n} \n\n```", "```go\ngo run command.go\n1.000216755s\nHello world!\n\n```", "```go\ntype Command interface { \n  Info() string \n} \n\n```", "```go\ntype TimePassed struct { \n  start time.Time \n} \n\nfunc (t *TimePassed) Info() string { \n  return time.Since(t.start).String() \n} \n\n```", "```go\ntype ChainLogger interface { \n  Next(Command) \n} \n\n```", "```go\ntype Logger struct { \n  NextChain ChainLogger \n} \n\nfunc (f *Logger) Next(c Command) { \n  time.Sleep(time.Second) \n\n  fmt.Printf(\"Elapsed time from creation: %s\\n\", c.Info()) \n\n  if f.NextChain != nil { \n    f.NextChain.Next(c) \n  } \n} \n\n```", "```go\nfunc main() { \n  second := new(Logger) \n  first := Logger{NextChain: second} \n\n  command := &TimePassed{start: time.Now()} \n\n  first.Next(command) \n} \n\n```", "```go\ngo run chain_command.go\nElapsed time from creation: 1.0003419s\nElapsed time from creation: 2.000682s\n\n```"]