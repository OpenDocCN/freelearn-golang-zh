["```go\npackage main \n\nfunc main() { \n  helloWorld() \n} \n\nfunc helloWorld(){ \n  println(\"Hello World!\") \n} \n\n```", "```go\n$ go run main.go\nHello World!\n\n```", "```go\npackage main \n\nfunc main() { \n  go helloWorld() \n} \n\nfunc helloWorld(){ \n  println(\"Hello World!\") \n} \n\n```", "```go\n$ go run main.go \n$\n\n```", "```go\npackage main \nimport \"time\" \n\nfunc main() { \n  go helloWorld() \n\n  time.Sleep(time.Second) \n} \n\nfunc helloWorld(){ \n  println(\"Hello World!\") \n} \n\n```", "```go\n$ go run main.go\nHello World!\n\n```", "```go\npackage main \nimport \"time\" \n\nfunc main() { \n  go func() { \n    println(\"Hello World\") \n  }() \n  time.Sleep(time.Second) \n} \n\n```", "```go\npackage main \nimport \"time\" \n\nfunc main() { \n  go func(msg string) { \n    println(msg) \n  }(\"Hello World\") \n  time.Sleep(time.Second) \n} \n\n```", "```go\npackage main \nimport \"time\" \n\nfunc main() { \n  messagePrinter := func(msg string) { \n    println(msg) \n  } \n\n  go messagePrinter(\"Hello World\") \n  go messagePrinter(\"Hello goroutine\") \n  time.Sleep(time.Second) \n} \n\n```", "```go\n$ go run main.go\nHello World\nHello goroutine\n\n```", "```go\npackage main \n\nimport ( \n  \"sync\" \n  \"fmt\" \n) \n\nfunc main() { \n  var wait sync.WaitGroup \n  wait.Add(1) \n\n  go func(){ \n    fmt.Println(\"Hello World!\") \n    wait.Done() \n  }() \n  wait.Wait() \n} \n\n```", "```go\n$ go run main.go \nHello World!\n\n```", "```go\npackage main \n\nimport ( \n  \"sync\" \n  \"fmt\" \n) \n\nfunc main() { \n  var wait sync.WaitGroup \n  wait.Add(1) \n\n  go func(){ \n    fmt.Println(\"Hello World!\") \n    wait.Add(-1) \n  }() \n  wait.Wait() \n} \n\n```", "```go\npackage main \nimport ( \n  \"fmt\" \n  \"sync\" \n) \n\nfunc main() { \n  var wait sync.WaitGroup \n\n  goRoutines := 5 \n  wait.Add(goRoutines) \n\n  for i := 0; i < goRoutines; i++ { \n    go func(goRoutineID int) { \n      fmt.Printf(\"ID:%d: Hello goroutines!\\n\", goRoutineID) \n      wait.Done() \n    }(i) \n  } \n  wait.Wait() \n} \n\n```", "```go\n$ go run main.go \n\nID:4: Hello goroutines!\nID:0: Hello goroutines!\nID:1: Hello goroutines!\nID:2: Hello goroutines!\nID:3: Hello goroutines!\n\n```", "```go\n$ go run main.go\nID:4: Hello goroutines!\nID:2: Hello goroutines!\nID:1: Hello goroutines!\nID:3: Hello goroutines!\nID:0: Hello goroutines!\n\n```", "```go\nfunc toUpperSync(word string) string { \n  //Code will go here \n} \n\n```", "```go\nfunc toUpperSync(word string, f func(string)) { \n  //Code will go here \n} \n\n```", "```go\nfunc toUpperSync(word string, f func(string)) { \n  f(strings.ToUpper(word)) \n} \n\n```", "```go\npackage main \n\nimport ( \n  \"fmt\" \n  \"strings\" \n) \n\nfunc main() { \n  toUpperSync(\"Hello Callbacks!\", func(v string) {   \n    fmt.Printf(\"Callback: %s\\n\", v) }) \n} \n\nfunc toUpperSync(word string, f func(string)) { \n  f(strings.ToUpper(word)) \n} \n\n```", "```go\n$ go run main.go\nCallback: HELLO CALLBACKS!\n\n```", "```go\npackage main \nimport ( \n  \"fmt\" \n  \"strings\" \n  \"sync\" \n) \n\nvar wait sync.WaitGroup \n\nfunc main() { \n  wait.Add(1) \n\n  toUpperAsync(\"Hello Callbacks!\", func(v string) { \n    fmt.Printf(\"Callback: %s\\n\", v) \n    wait.Done() \n  }) \n\n  println(\"Waiting async response...\") \n  wait.Wait() \n} \n\nfunc toUpperAsync(word string, f func(string)) { \n  go func(){ \n    f(strings.ToUpper(word)) \n  }() \n} \n\n```", "```go\n$ go run main.go \n\nWaiting async response...\nCallback: HELLO CALLBACKS!\n\n```", "```go\nfunc main() { \n  wait.Add(1) \n\n  toUpperAsync(\"Hello Callbacks!\", func(v string) { \n    toUpperAsync(fmt.Sprintf(\"Callback: %s\\n\", v), func(v string) { \n      fmt.Printf(\"Callback within %s\", v) \n      wait.Done() \n    }) \n  }) \n  println(\"Waiting async response...\") \n  wait.Wait() \n} \n\n```", "```go\n$ go run main.go \nWaiting async response...\nCallback within CALLBACK: HELLO CALLBACKS!\n\n```", "```go\ntype Counter struct { \n  sync.Mutex \n  value int \n} \n\n```", "```go\npackage main \n\nimport ( \n  \"sync\" \n  \"time\" \n) \n\nfunc main() { \n  counter := Counter{} \n\n  for i := 0; i < 10; i++ { \n    go func(i int) { \n      counter.Lock() \n      counter.value++ \n      defer counter.Unlock() \n    }(i) \n  } \n  time.Sleep(time.Second) \n\n  counter.Lock() \n  defer counter.Unlock() \n\n  println(counter.value) \n} \n\n```", "```go\n$ go run -race main.go \n10\n\n```", "```go\nfor i := 0; i < 10; i++ { \n  go func(i int) { \n    //counter.Lock() \n    counter.value++ \n    //counter.Unlock() \n  }(i) \n} \n\n```", "```go\n$ go run -race main.go \n==================\nWARNING: DATA RACE\nRead at 0x00c42007a068 by goroutine 6:\n main.main.func1()\n [some_path]/concurrency/locks/main.go:19 +0x44\nPrevious write at 0x00c42007a068 by goroutine 5:\n main.main.func1()\n [some_path]/concurrency/locks/main.go:19 +0x60\nGoroutine 6 (running) created at:\n main.main()\n [some_path]/concurrency/locks/main.go:21 +0xb6\nGoroutine 5 (finished) created at:\n main.main()\n [some_path]/concurrency/locks/main.go:21 +0xb6\n==================\n10\nFound 1 data race(s)\nexit status 66\n\n```", "```go\npackage main \n\nimport \"sync\" \n\ntype Counter struct { \n  sync.Mutex \n  value int \n} \n\nfunc main() { \n  counter := Counter{} \n\n  for i := 0; i < 1; i++ { \n    go func(i int) { \n      counter.value++ \n    }(i) \n  } \n} \n\n```", "```go\n$ go run -race main.go\n$\n\n```", "```go\nfor i := 0; i < 2; i++ { \n  go func(i int) { \n    counter.value++ \n  }(i) \n} \n\n```", "```go\n$ go run -race main.go\nWARNING: DATA RACE\nRead at 0x00c42007a008 by goroutine 6:\n main.main.func1()\n [some_path]concurrency/race_detector/main.go:15 +0x44\nPrevious write at 0x00c42007a008 by goroutine 5:\n main.main.func1()\n [some_path]/concurrency/race_detector/main.go:15 +0x60\nGoroutine 6 (running) created at:\n main.main()\n [some_path]/concurrency/race_detector/main.go:16 +0xad\nGoroutine 5 (finished) created at:\n main.main()\n [some_path]/concurrency/race_detector/main.go:16 +0xad\n==================\nFound 1 data race(s)\nexit status 66\n\n```", "```go\n$ GOMAXPROCS=1 go run -race main.go\n$\n\n```", "```go\npackage main \n\nimport \"fmt\" \n\nfunc main() { \n  channel := make(chan string) \n  go func() { \n    channel <- \"Hello World!\" \n  }() \n\n  message := <-channel \n  fmt.Println(message) \n} \n\n```", "```go\npackage main \n\nimport ( \n  \"fmt\" \n  \"time\" \n) \n\nfunc main() { \n  channel := make(chan string) \n\n  var waitGroup sync.WaitGroup \n\n  waitGroup.Add(1) \n  go func() { \n    channel <- \"Hello World!\" \n    println(\"Finishing goroutine\") \n    waitGroup.Done() \n  }() \n\n  time.Sleep(time.Second) \n  message := <-channel \n  fmt.Println(message) \n  waitGroup.Wait() \n} \n\n```", "```go\n$ go run main.go\n\nFinishing goroutine\nHello World!\n\n```", "```go\npackage main \n\nimport ( \n  \"fmt\" \n  \"time\" \n) \n\nfunc main() { \n  channel := make(chan string, 1) \n\n  go func() { \n    channel <- \"Hello World!\" \n    println(\"Finishing goroutine\") \n  }() \n\n  time.Sleep(time.Second) \n\n  message := <-channel \n  fmt.Println(message) \n} \n\n```", "```go\n$ go run main.go\n\nFinishing goroutine\nHello World!\n\n```", "```go\npackage main \n\nimport ( \n  \"fmt\" \n  \"time\" \n) \n\nfunc main() { \n  channel := make(chan string, 1) \n\n  go func() { \n    channel <- \"Hello World! 1\" \n    channel <- \"Hello World! 2\" \n    println(\"Finishing goroutine\") \n  }() \n\n  time.Sleep(time.Second) \n\n  message := <-channel \n  fmt.Println(message) \n} \n\n```", "```go\n$ go run main.go\nHello World! 1\n\n```", "```go\npackage main \n\nimport ( \n  \"fmt\" \n  \"time\" \n) \n\nfunc main() { \n  channel := make(chan string, 1) \n\n go func(ch chan<- string) { \n    ch <- \"Hello World!\" \n    println(\"Finishing goroutine\") \n  }(channel) \n\n  time.Sleep(time.Second) \n\n  message := <-channel \n  fmt.Println(message) \n} \n\n```", "```go\nfunc receivingCh(ch <-chan string) { \n  msg := <-ch \n  println(msg) \n} \n\n```", "```go\nfunc receivingCh(ch <-chan string) { \n  msg := <-ch \n  println(msg) \n  ch <- \"hello\" \n} \n\n```", "```go\n$ go run main.go\n./main.go:20: invalid operation: ch <- \"hello2\" (send to receive-only type <-chan string)\n\n```", "```go\nfunc sendString(ch chan<- string, s string) { \n  ch <- s \n} \n\n```", "```go\nfunc receiver(helloCh, goodbyeCh <-chan string, quitCh chan<- bool) { \n  for { \n    select { \n    case msg := <-helloCh: \n      println(msg) \n    case msg := <-goodbyeCh: \n      println(msg) \n    case <-time.After(time.Second * 2): \n      println(\"Nothing received in 2 seconds. Exiting\") \n      quitCh <- true \n      break \n    } \n  } \n} \n\n```", "```go\npackage main \nimport \"time\" \n\nfunc main() { \n  helloCh := make(chan string, 1) \n  goodbyeCh := make(chan string, 1) \n  quitCh := make(chan bool) \n  go receiver(helloCh, goodbyeCh, quitCh) \n\n  go sendString(helloCh, \"hello!\") \n\n  time.Sleep(time.Second) \n\n  go sendString(goodbyeCh, \"goodbye!\") \n  <-quitCh \n} \n\n```", "```go\n$ go run main.go\n\nhello!\ngoodbye!\nNothing received in 2 seconds. Exiting\n\n```", "```go\npackage main \n\nimport \"time\" \n\nfunc main() { \n  ch := make(chan int) \n\n  go func() { \n    ch <- 1 \n    time.Sleep(time.Second) \n\n    ch <- 2 \n\n    close(ch) \n  }() \n  for v := range ch { \n    println(v) \n  } \n} \n\n```", "```go\n$ go run main.go\n\n1\n2\n\n```", "```go\npackage channel_singleton \nimport ( \n  \"testing\" \n  \"time\" \n  \"fmt\" \n) \n\nfunc TestStartInstance(t *testing.T) { \n  singleton := GetInstance() \n  singleton2 := GetInstance() \n\n  n := 5000 \n\n  for i := 0; i < n; i++ { \n    go singleton.AddOne() \n    go singleton2.AddOne() \n  } \n\n  fmt.Printf(\"Before loop, current count is %d\\n\", singleton.GetCount()) \n\n  var val int \n  for val != n*2 { \n    val = singleton.GetCount() \n    time.Sleep(10 * time.Millisecond) \n  } \n  singleton.Stop() \n} \n\n```", "```go\nvar addCh chan bool = make(chan bool) \nvar getCountCh chan chan int = make(chan chan int) \nvar quitCh chan bool = make(chan bool) \n\nfunc init() { \n  var count int \n\n  go func(addCh <-chan bool, getCountCh <-chan chan int, quitCh <-chan bool) { \n    for { \n      select { \n      case <-addCh: \n        count++ \n      case ch := <-getCountCh: \n        ch <- count \n      case <-quitCh: \n        return \n      } \n    } \n  }(addCh, getCountCh, quitCh) \n} \n\n```", "```go\ntype singleton struct {} \n\nvar instance singleton \nfunc GetInstance() *singleton { \n  return &instance \n} \n\n```", "```go\nfunc (s *singleton) AddOne() { \n  addCh <- true \n} \n\n```", "```go\nfunc (s *singleton) GetCount() int { \n  resCh := make(chan int) \n  defer close(resCh) \n  getCountCh <- resCh \n  return <-resCh \n} \n\n```", "```go\nfunc (s *singleton) Stop() { \n  quitCh <- true \n  close(addCh) \n  close(getCountCh) \n  close(quitCh) \n} \n\n```", "```go\n$ go test -v .\n=== RUN   TestStartInstance\nBefore loop, current count is 4911\n--- PASS: TestStartInstance (0.03s)\nPASS\nok\n\n```", "```go\ntype singleton struct { \n  count int \n  sync.RWMutex \n} \n\nvar instance singleton \n\nfunc GetInstance() *singleton { \n  return &instance \n} \n\nfunc (s *singleton) AddOne() { \n  s.Lock() \n  defer s.Unlock() \n  s.count++ \n} \n\nfunc (s *singleton) GetCount()int { \n  s.RLock() \n  defer s.RUnlock() \n  return s.count \n} \n\n```"]