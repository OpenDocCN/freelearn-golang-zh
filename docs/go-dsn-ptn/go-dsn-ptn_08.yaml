- en: Chapter 8. Introduction to Gos Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。Gos并发简介
- en: We have just finished with the *Gang Of Four* design patterns that are commonly
    used in object oriented programming languages. They have been used extensively
    for the last few decades (even before they were explicitly defined in a book).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了在面向对象编程语言中广泛使用的*四人帮*设计模式。在过去的几十年里，它们已经被广泛使用（甚至在它们被明确定义在一本书中之前）。
- en: In this chapter, we are going to see concurrency in the Go language. We will,
    learn that with multiple cores and multiple processes, applications can help us
    to achieve better performance and endless possibilities. We will look at how to
    use some of the already known patterns in concurrently safe ways.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到Go语言中的并发性。我们将学习，通过多个核心和多个进程，应用程序可以帮助我们实现更好的性能和无限的可能性。我们将看看如何以并发安全的方式使用一些已知的模式。
- en: A little bit of history and theory
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点历史和理论
- en: When we talk about Go's concurrency, it's impossible not to talk about history.
    In the last decades, we saw an improvement in the speed of CPUs until we reached
    the hardware limits imposed by current hardware materials, design, and architectures.
    When we reached this point, we started to play with the first multicore computers,
    the first double CPU motherboards, and then single CPUs with more than one core
    in their heart.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论Go的并发性时，不可能不谈论历史。在过去的几十年里，我们看到CPU速度的提高，直到我们达到了当前硬件材料、设计和架构所施加的硬件限制。当我们达到这一点时，我们开始尝试第一台多核计算机，第一台双CPU主板，然后是心脏中有多个核心的单CPU。
- en: Unfortunately, the languages we are using are still the ones created when we
    had single core CPUs, such as Java or C++. While being terrific systems languages,
    they lack a proper concurrency support by design. You can develop concurrent apps
    in both of the languages used in your project by using third party tools or by
    developing your own (not a very easy task).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们正在使用的语言仍然是在我们拥有单核CPU时创建的语言，比如Java或C++。虽然它们是很棒的系统语言，但它们在设计上缺乏适当的并发支持。你可以通过使用第三方工具或开发自己的工具在项目中的这两种语言中开发并发应用（这并不是一件很容易的任务）。
- en: Go's concurrency was designed with these caveats in mind. The creators wanted
    garbage collected and procedural language that is familiar for newcomers, but
    which, at the same time, can be used to write concurrent applications easily and
    without affecting the core of the language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Go的并发是在考虑到这些警告的情况下设计的。创作者们希望有垃圾回收和程序化语言，对新手来说很熟悉，但同时又可以轻松编写并发应用，而不影响语言的核心。
- en: We have experienced this in the early chapters. We have developed more than
    20 design patterns without a word about concurrency. This clearly shows that the
    concurrent features of the Go language are completely separated from the core
    language while being part of it, a perfect example of abstraction and encapsulation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在早期章节中已经经历过这一点。我们开发了20多种设计模式，却没有提到并发。这清楚地表明，Go语言的并发特性完全与核心语言分离，同时又是其一部分，这是抽象和封装的完美例子。
- en: There are many concurrency models in computer science, the most famous being
    the actor model present in languages such as **Erlang** or **Scala**. Go, on the
    other side, uses **Communicating Sequential Processes** (**CSP**), which has a
    different approach to concurrency.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中有许多并发模型，最著名的是出现在诸如**Erlang**或**Scala**等语言中的actor模型。另一方面，Go使用**通信顺序进程**（**CSP**），它对并发有不同的方法。
- en: Concurrency versus parallelism
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发与并行
- en: 'Many people have misunderstood the differences between both, even thinking
    that they are the same. There is a popular speech by Rob Pike, one of the creators
    of Go, *Concurrency is not parallelism*, which I really agree with. As a quick
    summary of the talk, we can extract the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人误解了两者之间的区别，甚至认为它们是相同的。Rob Pike，Go的创始人之一，有一次流行的演讲，*并发不等于并行*，我非常同意。作为这次演讲的快速总结，我们可以得出以下结论：
- en: Concurrency is about dealing with many things at once
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发是同时处理许多事情的能力
- en: Parallelism is about doing many things at the same time
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行性是同时做很多事情的能力
- en: Concurrency enables parallelism by designing a correct structure of concurrency
    work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设计正确的并发工作结构，并发能够实现并行。
- en: For example, we can think of the mechanism of a bike. When we pedal, we usually
    push down the pedal to produce force (and this push, raises our opposite leg on
    the opposite pedal). We cannot push with both legs at the same time because the
    cranks don't allow us to do it. But this design allows the construction of a parallel
    bike, commonly called a **tandem bike**. A tandem bike is a bike that two people
    can ride at the same time; they both pedal and apply force to the bike.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以想象一辆自行车的机制。当我们踩踏时，通常是向下踩踏板产生力量（这种推动会使我们的另一条腿上升到相反的踏板）。我们不能同时用两条腿推动，因为曲柄不允许我们这样做。但这种设计允许建造一辆平行自行车，通常称为**串联自行车**。串联自行车是两个人可以同时骑的自行车；他们都踩踏板并施加力量给自行车。
- en: In the bike example, concurrency is the design of a bike that, with two legs
    (Goroutines), you can produce power to move the bike by yourself. The design is
    concurrent and correct. If we use a tandem bike and two people (two cores), the
    solution is concurrent, correct, and parallel. But the key thing is that with
    a concurrent design, we don't have to worry about parallelism; we can think about
    it as an extra feature if our concurrent design is correct. In fact, we can use
    the tandem bike with only one person, but the concurrent design of the legs, pedals,
    chain, wheels of a bike is still correct.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在自行车的例子中，并发是设计一辆自行车，用两条腿（Goroutines）可以自己产生动力来移动自行车。这种设计是并发和正确的。如果我们使用串联自行车和两个人（两个核心），解决方案是并发的、正确的和并行的。但关键是，通过并发设计，我们不必担心并行性；如果我们的并发设计是正确的，我们可以将其视为额外的功能。事实上，我们可以只用一个人使用串联自行车，但自行车的并发设计仍然是正确的。
- en: '![Concurrency versus parallelism](img/B05557_08_01-1-300x255.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![并发与并行](img/B05557_08_01-1-300x255.jpg)'
- en: With concurrency, on the left side, we have a design and a structure that is
    executed sequentially by the same CPU core. Once we have this design and structure,
    parallelism can be achieved by simply repeating this structure on a different
    thread.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发方面，左侧有一个由同一CPU核心顺序执行的设计和结构。一旦有了这个设计和结构，通过在不同的线程上重复这个结构，就可以实现并行。
- en: This is how Go eases the reasoning about concurrent and parallel programs by
    simply not worrying too much about parallel execution and focusing much more on
    concurrent design and structure. Breaking a big task into smaller tasks that can
    be run concurrently usually provides much better performance in a single-core
    computer, but, if this design can also be run in parallel, we could achieve an
    even higher throughput (or not, depending on the design).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Go通过简单地不太担心并行执行而更多地关注并发设计和结构来简化关于并发和并行程序的推理。将一个大任务分解成可以并发运行的小任务通常会在单核计算机上提供更好的性能，但如果这种设计也可以并行运行，我们可能会实现更高的吞吐量（或者不会，这取决于设计）。
- en: In fact, we can set the number of cores in use in a Go app by setting the environment
    variable `GOMAXPROCS` to the number of cores we want. This is not only useful
    when using schedulers, such as **Apache Mesos**, but it gives us more control
    about how a Go app works and performs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以通过将环境变量`GOMAXPROCS`设置为所需的核心数来设置Go应用程序中使用的核心数。这不仅在使用调度程序（如**Apache Mesos**）时很有用，而且还可以更好地控制Go应用程序的工作和性能。
- en: So, to recap, it is very important to keep in mind that concurrency is about
    structure and parallelism is about execution. We must think about making our programs
    concurrent in a better way, by breaking them down into smaller pieces of work,
    and Go's scheduler will try to make them parallel if it's possible and allowed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要总结一下，重要的是要记住，并发是关于结构，而并行是关于执行。我们必须考虑以更好的方式使我们的程序并发，通过将它们分解成更小的工作片段，如果可能且允许的话，Go的调度器将尝试使它们并行化。
- en: CSP versus actor-based concurrency
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSP与基于actor的并发
- en: The most common and, perhaps, intuitive way to think about concurrency is close
    to the way the actor model works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见且可能直观的思考并发的方式接近actor模型的工作方式。
- en: '![CSP versus actor-based concurrency](img/B05557_08_02-1-300x164.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![CSP与基于actor的并发](img/B05557_08_02-1-300x164.jpg)'
- en: In the actor model, if **Actor 1** wants to communicate with **Actor 2**, then
    **Actor 1** must know **Actor 2** first; for example, it must have its process
    ID, maybe from the creation step, and put a message on its inbox queue. After
    placing the message, **Actor 1** can continue its tasks without getting blocked
    if **Actor 2** cannot process the message immediately.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在actor模型中，如果**Actor 1**想要与**Actor 2**通信，那么**Actor 1**必须首先了解**Actor 2**；例如，它必须有它的进程ID，可能是从创建步骤中获得，并将消息放在其收件箱队列中。放置消息后，**Actor
    1**可以继续其任务，而不会被阻塞，即使**Actor 2**无法立即处理消息。
- en: 'CSP, on the other side, introduces a new entity into the equation-channels.
    Channels are the way to communicate between processes because they are completely
    anonymous (unlike actors, where we need to know their process IDs). In the case
    of CSP, we don''t have a process ID to use to communicate. Instead, we have to
    create a channel to the processes to allow incoming and outgoing communication.
    In this case, what we know that the receiver is the channel it uses to receive
    data:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，CSP引入了一个新的实体-通道。通道是进程之间进行通信的方式，因为它们是完全匿名的（不像actor，我们需要知道它们的进程ID）。在CSP的情况下，我们没有进程ID用于通信。相反，我们必须创建一个通道给进程，以允许传入和传出的通信。在这种情况下，我们知道接收者是它用来接收数据的通道：
- en: '![CSP versus actor-based concurrency](img/B05557_08_03-1-300x37.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![CSP与基于actor的并发](img/B05557_08_03-1-300x37.jpg)'
- en: In this diagram, we can see that the processes are anonymous, but we have a
    channel with ID 1, that is, **Channel 1**, which connects them together. This
    abstraction does not tell us how many processes are on each side of the channel;
    it simply connects them and allows communication between processes by using the
    channel.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我们可以看到这些进程是匿名的，但我们有一个ID为1的通道，即**通道1**，将它们连接在一起。这种抽象并没有告诉我们每一侧通道上有多少个进程；它只是简单地连接它们，并允许它们通过通道进行通信。
- en: The key here is that channels isolate both extremes so that process A can send
    data through a channel that will be handled by potentially one or more processes
    that' are transparent to A. It also works the same in reverse; process B can receive
    data from many channels one at a time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于通道隔离了两个极端，以便进程A可以通过一个通道发送数据，这些数据将由潜在的一个或多个对A透明的进程处理。它也在相反的情况下起作用；进程B可以一次从许多通道接收数据。
- en: Goroutines
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: In Go, we achieve concurrency by working with Goroutines. They are like processes
    that run applications in a computer concurrently; in fact, the main loop of Go
    could be considered a Goroutine, too. Goroutines are used in places where we would
    use actors. They execute some logic and die (or keep looping if necessary).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，我们通过使用Goroutines来实现并发。它们就像在计算机上同时运行应用程序的进程；实际上，Go的主循环也可以被认为是一个Goroutine。Goroutines在我们使用actor的地方使用。它们执行一些逻辑然后消失（或者如果有必要，保持循环）。
- en: But Goroutines are not threads. We can launch thousands of concurrent Goroutines,
    even millions. They are incredibly cheap, with a small growth stack. We will use
    Goroutines to execute code that we want to work concurrently. For example, three
    calls to three services to compose a response can be designed concurrently with
    three Goroutines to do the service calls potentially in parallel and a fourth
    Goroutine to receive them and compose the response. What's the point here? That
    if we have a computer with four cores, we could potentially run this service call
    in parallel, but if we use a one-core computer, the design will still be correct
    and the calls will be executed concurrently in only one core. By designing concurrent
    applications, we don't need to worry about parallel execution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但是Goroutines不是线程。我们可以启动成千上万甚至百万个并发的Goroutines。它们非常廉价，堆栈增长很小。我们将使用Goroutines来执行我们想要并发工作的代码。例如，通过三个Goroutines并行设计三个服务的调用来组成一个响应，可能并行进行服务调用，并且第四个Goroutine接收它们并组成响应。这里的重点是什么？如果我们有一台有四个核心的计算机，我们可能可以并行运行这个服务调用，但如果我们使用一台单核心的计算机，设计仍然是正确的，调用将在一个核心中并发执行。通过设计并发应用程序，我们不需要担心并行执行。
- en: Returning to the bike analogy, we were pushing the pedals of the bike with our
    two legs. That's two Goroutines concurrently pushing the pedals. When we use the
    tandem, we had a total of four Goroutines, possibly working in parallel. But we
    also have two hands to handle the front and rear brakes. That's a total of eight
    Goroutines for our two threads bike. Actually, we don't pedal when we brake and
    we don't brake when we pedal; that's a correct concurrent design. Our nervous
    system transports the information about when to stop pedaling and when to start
    braking. In Go, our nervous system is composed of channels; we will see them after
    playing a bit with Goroutines first.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回到自行车的比喻，我们用两条腿踩踏自行车踏板。这是两个Goroutines同时踩踏踏板。当我们使用双人自行车时，我们总共有四个Goroutines，可能在并行工作。但我们也有两只手来控制前后刹车。这是我们双人自行车上的八个Goroutines。实际上，我们刹车时不踩踏板，踩踏板时不刹车；这是一个正确的并发设计。我们的神经系统传输关于何时停止踩踏板和何时开始刹车的信息。在Go中，我们的神经系统由通道组成；在玩弄Goroutines之后，我们将会看到它们。
- en: Our first Goroutine
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个Goroutine
- en: 'Enough of the explanations now. Let''s get our hands dirty. For our first Goroutine,
    we will print the message `Hello World!` in a Goroutine. Let''s start with what
    we''ve been doing up until now:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在足够的解释了。让我们动手吧。对于我们的第一个Goroutine，我们将在一个Goroutine中打印消息`Hello World!`。让我们从我们到目前为止一直在做的事情开始：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running this small snippet of code will simply output `Hello World!` in the
    console:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段小代码片段将在控制台中简单地输出`Hello World!`：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Not impressive at all. To run it in a new Goroutine, we just need to add the
    keyword `go` at the beginning of the call to the function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一点也不令人印象深刻。要在新的Goroutine中运行它，我们只需要在对函数的调用前加上关键字`go`：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this simple word, we are telling Go to start a new Goroutine running the
    contents of the `helloWorld` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的词，我们告诉Go启动一个新的Goroutine来运行`helloWorld`函数的内容。
- en: 'So, let''s run it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们运行它：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What? It printed nothing! Why is that? Things get complicated when you start
    to deal with concurrent applications. The problem is that the `main` function
    finishes before the `helloWorld` function gets executed. Let's analyse it step
    by step. The `main` function starts and schedules a new Goroutine that will execute
    the `helloWorld` function, but the function isn't executed when the function finishes--it
    is still in the scheduling process.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？什么都没打印！为什么？当你开始处理并发应用程序时，事情变得复杂起来。问题在于`main`函数在`helloWorld`函数被执行之前就结束了。让我们一步一步地分析一下。`main`函数开始并安排一个新的Goroutine来执行`helloWorld`函数，但当函数结束时，函数并没有被执行——它仍然在调度过程中。
- en: 'So, our `main` problem is that the `main` function has to wait for the Goroutine
    to be executed before finishing. So let''s pause for a second to give some room
    to the Goroutine:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们`main`函数的问题在于`main`函数必须等待Goroutine被执行后才能结束。所以让我们停顿一秒钟，给Goroutine一些空间：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `time.Sleep` function effectively sleeps the main Goroutine for one second
    before continuing (and exiting). If we run this now, we must get the message:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Sleep`函数有效地使主Goroutine在继续（并退出）之前休眠一秒钟。如果我们现在运行这个程序，我们必须得到这个消息：'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I suppose you must have noticed by now the small gap of time where the program
    is freezing before finishing. This is the function for sleeping. If you are doing
    a lot of tasks, you might want to raise the waiting time to whatever you want.
    Just remember that in any application the `main` function cannot finish before
    the rest of the Goroutines.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你现在一定已经注意到了程序在结束之前会有一个小的冻结时间。这是休眠的函数。如果你正在做很多任务，你可能想把等待时间延长到你想要的任何时间。只要记住，在任何应用程序中，`main`函数不能在其他Goroutines之前结束。
- en: Anonymous functions launched as new Goroutines
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数作为新的Goroutines启动
- en: 'We have defined the `helloWorld` function so that it can be launched with a
    different Goroutine. This is not strictly necessary because you can launch snippets
    of code directly in the function''s scope:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`helloWorld`函数，以便可以使用不同的Goroutine启动它。这并不是严格必要的，因为你可以直接在函数的作用域中启动代码片段：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is also valid. We have used an anonymous function and we have launched
    it in a new Goroutine using the `go` keyword. Take a closer look at the closing
    braces of the function-they are followed by opening and closing parenthesis, indicating
    the execution of the function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是有效的。我们使用了一个匿名函数，并使用`go`关键字在一个新的Goroutine中启动它。仔细看函数的闭括号——它们后面跟着开括号和闭括号，表示函数的执行。
- en: 'We can also pass data to anonymous functions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以向匿名函数传递数据：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is also valid. We had defined an anonymous function that received a string,
    which then printed the received string. When we called the function in a different
    Goroutine, we passed the message we wanted to print. In this sense, the following
    example would also be valid:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是有效的。我们定义了一个接收字符串的匿名函数，然后打印接收到的字符串。当我们在不同的Goroutine中调用函数时，我们传递了要打印的消息。在这个意义上，以下示例也是有效的：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, we have defined a function within the scope of our `main` function
    and stored it in a variable called `messagePrinter`. Now we can concurrently print
    as many messages as we want by using the `messagePrinter(string)` signature:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在`main`函数的范围内定义了一个函数，并将其存储在名为`messagePrinter`的变量中。现在我们可以通过使用`messagePrinter（string）`签名并发打印任意数量的消息：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have just scratched the surface of concurrent programming in Go, but we can
    already see that it can be quite powerful. But we definitely have to do something
    with that sleeping period. WaitGroups can help us with this problem.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚触及了Go中并发编程的表面，但我们已经可以看到它可以非常强大。但我们绝对必须解决这个休眠期的问题。WaitGroups可以帮助我们解决这个问题。
- en: WaitGroups
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WaitGroups
- en: 'WaitGroup comes in the synchronization package (the `sync` package) to help
    us synchronize many concurrent Goroutines. It works very easily--every time we
    have to wait for one Goroutine to finish, we add `1` to the group, and once all
    of them are added, we ask the group to wait. When the Goroutine finishes, it says
    `Done` and the WaitGroup will take one from the group:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: WaitGroup位于同步包（`sync`包）中，帮助我们同步许多并发的Goroutines。它非常容易使用-每当我们必须等待一个Goroutine完成时，我们向组中添加`1`，一旦它们全部添加，我们要求组等待。当Goroutine完成时，它会说`Done`，WaitGroup将从组中取出一个：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the simplest possible example of a WaitGroup. First, we created a variable
    to hold it called the `wait` variable. Next, before launching the new Goroutine,
    we say to the WaitGroup `hey, you'll have to wait for one thing to finish` by
    using the `wait.Add(1)` method. Now we can launch the `1` that the WaitGroup has
    to wait for, which in this case is the previous Goroutine that prints `Hello World`
    and says `Done` (by using the `wait.Done()` method) at the end of the Goroutine.
    Finally, we indicate to the WaitGroup to wait. We have to remember that the function
    `wait.Wait()` was probably executed before the Goroutine.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最简单的WaitGroup示例。首先，我们创建了一个变量来保存它，称为`wait`变量。接下来，在启动新的Goroutine之前，我们告诉WaitGroup“嘿，你必须等待一件事情完成”，使用`wait.Add（1）`方法。现在我们可以启动WaitGroup必须等待的`1`，在这种情况下是打印`Hello
    World`并在Goroutine结束时说`Done`（使用`wait.Done（）`方法）的先前Goroutine。最后，我们指示WaitGroup等待。我们必须记住，函数`wait.Wait（）`可能在Goroutine之前执行。
- en: 'Let''s run the code again:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行代码：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now it just waits the necessary time and not one millisecond more before exiting
    the application. Remember that when we use the `Add(value)` method, we add entities
    to the WaitGroup, and when we use the `Done()` method, we subtract one.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它只等待必要的时间，而不是在退出应用程序之前多等待一毫秒。请记住，当我们使用`Add（value）`方法时，我们向WaitGroup添加实体，当我们使用`Done（）`方法时，我们减去一个。
- en: 'Actually, the `Add` function takes a delta value, so the following code is
    equivalent to the previous:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Add`函数接受一个增量值，因此以下代码等同于上一个：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, we added `1` before launching the Goroutine and we added `-1`
    (subtracted 1) at the end of it. If we know in advance how many Goroutines we
    are going to launch, we can also call the `Add` method just once:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在启动Goroutine之前添加了`1`，并在其末尾添加了`-1`（减去1）。如果我们预先知道要启动多少个Goroutines，我们也可以只调用一次`Add`方法：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we are going to create five Goroutines (as stated in the `goroutines`
    variable). We know it in advance, so we simply add them all to the WaitGroup.
    We are then going to launch the same amount of `goroutine` variables by using
    a `for` loop. Every time one Goroutine finishes, it calls the `Done()` method
    of the WaitGroup that is effectively waiting at the end of the main loop.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建五个Goroutines（如`goroutines`变量中所述）。我们事先知道这一点，所以我们只需将它们全部添加到WaitGroup中。然后，我们将使用`for`循环启动相同数量的`goroutine`变量。每当一个Goroutine完成时，它都会调用WaitGroup的`Done（）`方法，该方法实际上在主循环的末尾等待。
- en: 'Again, in this case, the code reaches the end of the `main` function before
    all Goroutines are launched (if any), and the WaitGroup makes the execution of
    the main flow wait until all `Done` messages are called. Let''s run this small
    program:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在这种情况下，代码在启动所有Goroutines（如果有的话）之前到达`main`函数的末尾，并且WaitGroup使主流程的执行等待，直到所有`Done`消息被调用。让我们运行这个小程序：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We haven''t mentioned it before, but we have passed the iteration index to
    each Goroutine as the parameter `GoroutineID` to print it with the message `Hello
    goroutines!` You might also have noticed that the Goroutines aren''t executed
    in order. Of course! We are dealing with a scheduler that doesn''t guarantee the
    order of execution of the Goroutines. This is something to keep in mind when programming
    concurrent applications. In fact, if we execute it again, we won''t necessarily
    get the same order of output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有提到，但我们已将迭代索引作为参数`GoroutineID`传递给每个Goroutine，以便用消息`Hello goroutines！`打印它。您可能还注意到Goroutines不按顺序执行。当然！我们正在处理一个不保证Goroutines执行顺序的调度程序。这是编写并发应用程序时要牢记的事情。实际上，如果我们再次执行它，我们不一定会得到相同的输出顺序：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Callbacks
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: Now that we know how to use WaitGroups, we can also introduce the concept of
    callbacks. If you have ever worked with languages like JavaScript that use them
    extensively, this section will be familiar to you. A callback is an anonymous
    function that will be executed within the context of a different function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用WaitGroups，我们还可以介绍回调的概念。如果您曾经使用过像JavaScript这样广泛使用回调的语言，这一部分对您来说将是熟悉的。回调是将在不同函数的上下文中执行的匿名函数。
- en: 'For example, we want to write a function to convert a string to uppercase,
    as well as making it asynchronous. How do we write this function so that we can
    work with callbacks? There''s a little trick-we can have have a function that
    takes a string and returns a string:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想要编写一个将字符串转换为大写的函数，同时使其异步化。我们如何编写这个函数以便使用回调？有一个小技巧——我们可以有一个接受一个字符串并返回一个字符串的函数：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So take the returning type of this function (a string) and put it as the second
    parameter in an anonymous function, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将这个函数的返回类型（一个字符串）作为匿名函数的第二个参数，如下所示：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, the `toUpperSync` function returns nothing, but also takes a function that,
    by coincidence, also takes a string. We can execute this function with the result
    we will usually return.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`toUpperSync`函数不返回任何内容，但也接受一个函数，巧合的是，这个函数也接受一个字符串。我们可以用通常返回的结果来执行这个函数。
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We execute the `f` function with the result of calling the `strings.ToUpper`
    method with the provided word (which returns the word `parameter` in uppercase).
    Let''s write the `main` function too:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用提供的单词调用`strings.ToUpper`方法的结果来执行`f`函数（它返回大写的`parameter`）。我们也写`main`函数：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In our main code, we have defined our callback. As you can see, we passed the
    test `Hello Callbacks!` to convert it to uppercase. Next we pass the callback
    to be executed with the result of passing our string to uppercase. In this case,
    we simply print the text in the console with the text `Callback` in front of it.
    When we execute this code, we get the following result:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主要代码中，我们已经定义了我们的回调。正如你所看到的，我们传递了测试`Hello Callbacks!`来将其转换为大写。接下来，我们传递回调以执行将我们的字符串转换为大写的结果。在这种情况下，我们只是在控制台上打印文本，并在其前面加上文本`Callback`。当我们执行这段代码时，我们得到以下结果：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Strictly speaking, this is a synchronous callback. To make it asynchronous
    we have to introduce some concurrent handling:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，这是一个同步回调。要使它异步，我们必须引入一些并发处理：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the same code executed asynchronously. We use WaitGroups to handle
    concurrency (we will see later that channels can also be used for this). Now,
    our function `toUpperAsync` is, as its name implies, asynchronous. We launched
    the callback in a different Goroutine by using the keyword `go` when calling the
    callback. We write a small message to show the ordering nature of the concurrent
    execution more precisely. We wait until the callback signals that it''s finished
    and we can exit the program safely. When we execute this, we get the following
    result:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是异步执行的相同代码。我们使用WaitGroups来处理并发（稍后我们将看到通道也可以用于此）。现在，我们的函数`toUpperAsync`就像其名字所暗示的那样是异步的。我们通过在调用回调时使用关键字`go`在不同的Goroutine中启动了回调。我们写了一条小消息来更准确地显示并发执行的顺序性质。我们等待直到回调信号它已经完成，然后我们可以安全地退出程序。当我们执行这个时，我们得到以下结果：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the program reaches the end of the `main` function before executing
    the callback in the `toUpperAsync` function. This pattern brings many possibilities,
    but leaves us open to one big problem called callback hell.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，程序在执行`toUpperAsync`函数的回调之前就已经到达了`main`函数的末尾。这种模式带来了许多可能性，但也让我们面临一个被称为回调地狱的大问题。
- en: Callback hell
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调地狱
- en: 'The term **callback hell** is commonly used to refer to when many callbacks
    have been stacked within each other. This makes them difficult to reason with
    and handle when they grow too much. For example, using the same code as before,
    we could stack another asynchronous call with the contents that we previously
    printed to the console:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**回调地狱**通常用来指代当许多回调被堆叠在一起时。当它们增长过多时，这使得它们难以理解和处理。例如，使用与之前相同的代码，我们可以堆叠另一个异步调用与先前打印到控制台的内容：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '(We have omitted imports, the package name, and the `toUpperAsync` function
    as they have not changed.) Now we have the `toUpperAsync` function within a `toUpperAsync`
    function, and we could embed many more if we want. In this case, we again pass
    the text that we previously printed on the console to use it in the following
    callback. The inner callback finally prints it on the console, giving the following
    output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: （我们省略了导入、包名和`toUpperAsync`函数，因为它们没有改变。）现在我们在`toUpperAsync`函数中有一个`toUpperAsync`函数，如果我们愿意，我们可以嵌套更多。在这种情况下，我们再次传递我们先前在控制台上打印的文本，以便在下一个回调中使用。内部回调最终在控制台上打印它，得到以下输出：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, we can assume that the outer callback will be executed before
    the inner one. That's why we don't need to add one more to the WaitGroup.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以假设外部回调将在内部回调之前执行。这就是为什么我们不需要在WaitGroup中再添加一个。
- en: The point here is that we must be careful when using callbacks. In very complex
    systems, too many callbacks are hard to reason with and hard to deal with. But
    with care and rationality, they are powerful tools.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于我们在使用回调时必须小心。在非常复杂的系统中，太多的回调很难理解和处理。但是经过谨慎和理性的处理，它们是强大的工具。
- en: Mutexes
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: If you are working with concurrent applications, you have to deal with more
    than one resource potentially accessing some memory location. This is usually
    called **race condition**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理并发应用程序，你必须处理多个资源可能访问某个内存位置。这通常被称为**竞争条件**。
- en: In simpler terms, a race condition is similar to that moment where two people
    try to get the last piece of pizza at exactly the same time--their hands collide.
    Replace the pizza with a variable and their hands with Goroutines and we'll have
    a perfect analogy.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，竞争条件类似于两个人同时试图拿到最后一块披萨的时刻——他们的手碰到了一起。用变量替换披萨，用Goroutines替换他们的手，我们就有了一个完美的类比。
- en: There is one character at the dinner table to solve this issues--a father or
    mother. They have kept the pizza on a different table and we have to ask for permission
    to stand up before getting our slice of pizza. It doesn't matter if all the kids
    ask at the same time--they will only allow one kid to stand.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有一个人物在晚餐桌上解决这些问题——一个父亲或母亲。他们把披萨放在另一张桌子上，我们必须在拿到我们的披萨之前请求站起来的许可。不管所有的孩子同时问，他们只会允许一个孩子站起来。
- en: Well, a mutex is like our parents. They'll control who can access the pizza--I
    mean, a variable--and they won't allow anyone else to access it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，互斥锁就像我们的父母。他们会控制谁可以访问披萨——我的意思是，一个变量——他们不会允许其他人访问它。
- en: To use a mutex, we have to actively lock it; if it's already locked (another
    Goroutine is using it), we'll have to wait until it's unlocked again. Once we
    get access to the mutex, we can lock it again, do whatever modifications are needed,
    and unlock it again. We'll look at this using an example.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用互斥锁，我们必须主动锁定它；如果它已经被锁定（另一个Goroutine正在使用它），我们必须等待直到它再次解锁。一旦我们获得对互斥锁的访问权，我们可以再次锁定它，进行任何必要的修改，然后再次解锁它。我们将通过一个示例来看看这个过程。
- en: An example with mutexes - concurrent counter
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用互斥锁的示例-并发计数器
- en: Mutexes are widely used in concurrent programming. Maybe not so much in Go because
    it has a more idiomatic way of concurrent programming in its use of channels,
    but it's worth seeing how they work for the situations where channels simply don't
    fit so well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁在并发编程中被广泛使用。在Go语言中可能没有那么常见，因为它在并发编程中使用通道的更具惯性的方式，但是值得看看它们在通道不太适用的情况下是如何工作的。
- en: For our example, we are going to develop a small concurrent counter. This counter
    will add one to an integer field in a `Counter` type. This should be done in a
    concurrent-safe way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将开发一个小型并发计数器。这个计数器将在`Counter`类型中的整数字段中添加一个。这应该以一种并发安全的方式完成。
- en: 'Our `Counter` structure is defined like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Counter`结构定义如下：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Counter` structure has a field of `int` type that stores the current value
    of the count. It also embeds the `Mutex` type from the `sync` package. Embedding
    this field will allow us to lock and unlock the entire structure without actively
    calling a specific field.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`结构有一个`int`类型的字段，用于存储计数的当前值。它还嵌入了`sync`包中的`Mutex`类型。嵌入这个字段将允许我们锁定和解锁整个结构，而无需主动调用特定字段。'
- en: 'Our `main` function launches 10 Goroutines that try to add one to the field
    value of `Counter` structure. All of this is done concurrently:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main`函数启动了10个Goroutines，它们尝试将`Counter`结构的字段值加一。所有这些都是并发完成的。
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have created a type called `Counter`. Using a `for` loop, we have launched
    a total of 10 Goroutines, as we saw in the *Anonymous functions launched as new
    Goroutines* section. But inside every Goroutine, we are locking the counter so
    that no more Goroutines can access it, adding one to the field value, and unlocking
    it again so others can access it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`Counter`的类型。使用`for`循环，我们启动了总共10个Goroutines，就像我们在*作为新Goroutines启动的匿名函数*部分看到的那样。但是在每个Goroutine内部，我们都锁定了计数器，以便没有更多的Goroutines可以访问它，将一个添加到字段值中，然后再次解锁，以便其他人可以访问它。
- en: Finally, we'll print the value held by the counter. It must be 10 because we
    have launched 10 Goroutines.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将打印计数器持有的值。它必须是10，因为我们启动了10个Goroutines。
- en: But how can we know that this program is thread safe? Well, Go comes with a
    very handy built-in feature called the "race detector".
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们如何知道这个程序是线程安全的呢？好吧，Go自带了一个非常方便的内置功能，叫做“竞争检测器”。
- en: Presenting the race detector
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍竞争检测器
- en: We already know what a race condition is. To recap, it is used when two processes
    try to access the same resource at the same time with one or more writing operations
    (both processes writing or one process writing while the other reads) involved
    at that precise moment.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道什么是竞争条件。简而言之，当两个进程尝试在同一时间访问同一资源，并且在那一刻涉及一个或多个写操作（两个进程都在写入，或者一个进程在写入而另一个在读取）时，就会使用它。
- en: 'Go has a very handy tool to help diagnose race conditions, that you can run
    in your tests or your main application directly. So let''s reuse the example we
    just wrote for the *mutexes* section and run it with the race detector. This is
    as simple as adding the `-race` command-line flag to the command execution of
    our program:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个非常方便的工具来帮助诊断竞争条件，你可以在你的测试或主应用程序中直接运行。所以让我们重用我们刚刚为*互斥锁*部分编写的示例，并使用竞争检测器运行它。这就像在我们的程序的命令执行中添加`-race`命令行标志一样简单：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Well, not very impressive is it? But in fact it is telling us that it has not
    detected a potential race condition in the code of this program. Let''s make the
    detector of `-race` flag warn us of a possible race condition by not locking `counter`
    before we modify it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '嗯，这不是很令人印象深刻，是吗？但实际上它告诉我们，在这个程序的代码中没有检测到潜在的竞争条件。让我们通过在修改`counter`之前不锁定它来使`-race`标志的检测器警告我们可能存在竞争条件： '
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside the `for` loop, comment the `Lock` and `Unlock` calls before and after
    adding `1` to the field value. This will introduce a race condition. Let''s run
    the same program again with the race flag activated:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环内，在将`1`添加到字段值之前和之后，注释掉`Lock`和`Unlock`调用。这将引入竞争条件。让我们再次运行相同的程序，并激活竞争标志：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'I have reduced the output a bit to see things more clearly. We can see a big,
    uppercase message reading `WARNING: DATA RACE`. But this output is very easy to
    reason with. First, it is telling us that some memory position represented by
    *line 19* on our `main.go` file is reading some variable. But there is also a
    write operation in *line 19* of the same file!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经减少了一些输出，以便更清楚地看到事情。我们可以看到一个大写的警告消息，上面写着“警告：数据竞争”。但这个输出很容易理解。首先，它告诉我们，我们的`main.go`文件上的*第19行*代表的某个内存位置正在读取某个变量。但在同一文件的*第19行*上也有一个写操作！
- en: This is because a "`++`" operation requires a read of the current value and
    a write to add one to it. That's why the race condition is in the same line, because
    every time it's executed it reads and writes the field in the `Counter` structure.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为“++”操作需要读取当前值并写入一个值。这就是为什么竞争条件在同一行中，因为每次执行它时，它都会读取并写入`Counter`结构中的字段。
- en: 'But let''s keep in mind that the race detector works at runtime. It doesn''t
    analyze our code statically! What does it mean? It means that we can have a potential
    race condition in our design that the race detector will not detect. For example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但是让我们记住，竞争检测器是在运行时工作的。它不会静态分析我们的代码！这是什么意思？这意味着我们的设计中可能存在潜在的竞争条件，竞争检测器不会检测到。例如：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will leave the code as shown in the preceding example. We will take all
    locks and unlocks from the code and launch a single Goroutine to update the `value`
    field:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留前面示例中显示的代码。我们将从代码中删除所有锁定和解锁，并启动一个单个Goroutine来更新`value`字段：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'No warnings, so the code is correct. Well, we know, by design, it''s not. We
    can raise the number of Goroutines executed to two and see what happens:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 没有警告，所以代码是正确的。好吧，我们知道，按设计，它不是。我们可以将执行的Goroutines数量提高到两个，然后看看会发生什么：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s execute the program again:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次执行程序：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now yes, the race condition is detected. But what if we reduce the number of
    processors in use to just one? Will we have a race condition too?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是的，竞争条件被检测到了。但是如果我们将正在使用的处理器数量减少到只有一个，我们也会有竞争条件吗？
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It seems that no race condition has been detected. This is because the scheduler
    executed one Goroutine first and then the other, so, finally, the race condition
    didn't occur. But with a higher number of Goroutines it will also warn us about
    a race condition, even using only one core.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎没有检测到竞争条件。这是因为调度程序首先执行了一个Goroutine，然后执行了另一个，所以最终没有发生竞争条件。但是，使用更多的Goroutines，即使只使用一个核心，它也会警告我们有关竞争条件。
- en: So, the race detector can help us to detect race conditions that are happening
    in our code, but it won't protect us from a bad design that is not immediately
    executing race conditions. A very useful feature that can save us from lots of
    headaches.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，竞争检测器可以帮助我们检测代码中发生的竞争条件，但它不会保护我们免受不立即执行竞争条件的糟糕设计。这是一个非常有用的功能，可以帮我们避免很多麻烦。
- en: Channels
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道
- en: Channels are the second primitive in the language that allows us to write concurrent
    applications. We have talked a bit about channels in the *Communicating sequential
    processes* section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是语言中允许我们编写并发应用程序的第二个原语。我们在*通信顺序进程*部分已经谈到了一些关于通道的内容。
- en: Channels are the way we communicate between processes. We could be sharing a
    memory location and using mutexes to control the processes' access. But channels
    provide us with a more natural way to handle concurrent applications that also
    produces better concurrent designs in our programs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是我们在进程之间进行通信的方式。我们可以共享一个内存位置，并使用互斥锁来控制进程的访问。但是通道为我们提供了一种更自然的方式来处理并发应用程序，这也在我们的程序中产生了更好的并发设计。
- en: Our first channel
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个通道
- en: Working with many Goroutines seems pretty difficult if we can't create some
    synchronization between them. The order of execution could be irrelevant as soon
    as they are synchronized. Channels are the second key feature to write concurrent
    applications in Go.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能在它们之间创建一些同步，那么使用许多Goroutines似乎是相当困难的。只要它们被同步，执行顺序可能就不重要了。通道是在Go中编写并发应用程序的第二个关键特性。
- en: A TV channel in real life is something that connects an emission (from a studio)
    to millions of TVs (the receivers). Channels in Go work in a similar fashion.
    One or more Goroutines can work as emitters, and one or more Goroutine can act
    as receivers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现实生活中的电视频道是将一个发射（来自工作室）连接到数百万台电视机（接收器）的东西。Go中的通道以类似的方式工作。一个或多个Goroutines可以作为发射器，一个或多个Goroutine可以作为接收器。
- en: One more thing channels, by default, block the execution of Goroutines until
    something is received. It is as if our favourite TV show delays the emission until
    we turn the TV on so we don't miss anything.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事，通道默认情况下会阻塞Goroutines的执行，直到接收到消息。这就好像我们最喜欢的电视节目延迟发射，直到我们打开电视，这样我们就不会错过任何东西。
- en: How is this done in Go?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中如何实现这一点？
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To create channels in Go, we use the same syntax that we use to create slices.
    The `make` keyword is used to create a channel, and we have to pass the keyword
    `chan` and the type that the channel will transport, in this case, strings. With
    this, we have a blocking channel with the name `channel`. Next, we launch a Goroutines
    that sends the message `Hello World!` to the channel. This is indicated by the
    intuitive arrow that shows the flow--the `Hello World!` text going to (`<-`) a
    channel. This works like an assignment in a variable, so we can only pass something
    to a channel by first writing the channel, then the arrow, and finally the value
    to pass. We cannot write `"Hello World!" -> channel`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中创建通道时，我们使用创建切片时使用的相同语法。使用`make`关键字创建通道，我们必须传递关键字`chan`和通道将传输的类型，本例中为字符串。有了这个，我们就有了一个名为`channel`的阻塞通道。接下来，我们启动一个Goroutines，向通道发送消息`Hello
    World!`。这由直观的箭头表示，显示了流向--`Hello World!`文本传递给（`<-`）通道。这就像在变量中进行赋值一样，所以我们只能通过先写通道，然后箭头，最后是要传递的值来传递东西给通道。我们不能写`"Hello
    World!" -> channel`。
- en: As we mentioned earlier, this channel is blocking the execution of Gorountines
    until a message is received. In this case, the execution of the `main` function
    is stopped until the message from the launched Goroutines reaches the other end
    of the channel in the line `message := <-channel`. In this case, the arrow points
    in the same direction, but it's placed before the channel, indicating that the
    data is being extracted from the channel and assigned to a new variable called
    `message` (using the new assignment "`:=`" operator).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这个通道会阻塞Goroutines的执行，直到接收到消息。在这种情况下，`main`函数的执行会在启动的Goroutines的消息到达通道的另一端的行`message
    := <-channel`之前停止。在这种情况下，箭头指向相同的方向，但是放在通道之前，表示数据正在从通道中提取并分配给一个名为`message`的新变量（使用新的赋值"`:=`"运算符）。
- en: 'In this case, we don''t need to use a WaitGroup to synchronize the `main` function
    with the created Goroutines, as the default nature of channels is to block until
    data is received. But does it work the other way around? If there is no receiver
    when the Goroutine sends the message, does it continue? Let''s edit this example
    to see this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要使用WaitGroup来同步`main`函数和创建的Goroutines，因为通道的默认性质是阻塞直到接收到数据。但是反过来呢？如果Goroutine发送消息时没有接收器，它会继续吗？让我们编辑这个例子来看看：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We are going to use the `Sleep` function again. In this case, we print a message
    when the Goroutine is finished. The big difference is in the `main` function.
    Now we wait one second before we listen to the channel for data:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`Sleep`函数。在这种情况下，我们在Goroutine完成时打印一条消息。最大的区别在于`main`函数。现在，在我们监听通道获取数据之前，我们等待一秒钟：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The output can differ because, again, there are no guarantees in the order of
    execution, but now we can see that no message is printed until one second has
    passed. After the initial delay, we start listening to the channel, take the data,
    and print it. So the emitter also has to wait for a cue from the other side of
    the channel to continue its execution.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能会有所不同，因为再次强调，执行顺序没有保证，但现在我们可以看到，直到一秒钟过去之前都没有消息被打印出来。在初始延迟之后，我们开始监听通道，接收数据并打印出来。因此，发射器也必须等待来自通道另一侧的提示才能继续执行。
- en: To recap, channels are ways to communicate between Goroutines by sending data
    through one end and receiving it at the other (like a pipe). In their default
    state, an emitter Goroutine will block its execution until a receiver Goroutine
    takes the data. The same goes for a receiver Goroutine, which will block until
    some emitter sends data through the channel. So you can have passive listeners
    (waiting for data) or passive emitters (waiting for listeners).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，通道是通过一端发送数据，另一端接收数据的方式，在Goroutines之间进行通信（就像管道一样）。在它们的默认状态下，发射器Goroutine将阻塞其执行，直到接收器Goroutine接收数据。接收器Goroutine也是一样，它将阻塞，直到某个发射器通过通道发送数据。因此，你可以有被动的监听器（等待数据）或被动的发射器（等待监听器）。
- en: Buffered channels
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: 'A buffered channel works in a similar way to default unbuffered channels. You
    also pass and take values from them by using the arrows, but, unlike unbuffered
    channels, senders don''t need to wait until some Goroutine picks the data that
    they are sending:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道的工作方式与默认的非缓冲通道类似。你也可以通过使用箭头来传递和获取值，但与非缓冲通道不同的是，发送者不需要等待某个Goroutine接收它们发送的数据：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This example is like the first example we used for channels, but now we have
    set the capacity of the channel to one in the `make` statement. With this, we
    tell the compiler that this channel has a capacity of one string before getting
    blocked. So the first string doesn''t block the emitter, but the second would.
    Let''s run this example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与我们用于通道的第一个例子类似，但现在我们在`make`语句中将通道的容量设置为1。通过这样做，我们告诉编译器，在被阻塞之前，该通道可以容纳一个字符串。因此，第一个字符串不会阻塞发射器，但第二个会。让我们运行这个例子：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we can run this small program as many times as we want--the output will
    always be in the same order. This time, we have launched the concurrent function
    and waited for one second. Previously, the anonymous function wouldn't continue
    until the second has passed and someone can pick the sent data. In this case,
    with a buffered channel, the data is held in the channel and frees the Goroutine
    to continue its execution. In this case, the Goroutine is always finishing before
    the wait time passes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以随意运行这个小程序，输出将始终按照相同的顺序。这一次，我们启动了并发函数并等待了一秒钟。以前，匿名函数在第二秒过去并且有人可以接收到发送的数据之前是不会继续的。在这种情况下，使用缓冲通道，数据被保存在通道中并释放Goroutine以继续执行。在这种情况下，Goroutine总是在等待时间过去之前完成。
- en: 'This new channel has a size of one, so a second message would block the Goroutine
    execution:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新通道的大小为1，因此第二个消息会阻塞Goroutine的执行：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, we add a second `Hello world! 2` message, and we provide it with an index.
    In this case, the output of this program could be like the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了第二个`Hello world! 2`消息，并为其提供了一个索引。在这种情况下，该程序的输出可能如下所示：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Indicating that we have just taken one message from the channel buffer, we have
    printed it, and the `main` function finished before the launched Goroutine could
    finish. The Goroutine got blocked when sending the second message and couldn't
    continue until the other end took the first message. Then it prints it so quickly
    that it doesn't have time to print the message to show the ending of the Goroutine.
    If you keep executing the program on the console, sooner or later the scheduler
    will finish the Goroutine execution before the main thread.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表示我们刚刚从通道缓冲区中取出了一条消息，我们已经打印出来了，并且`main`函数在启动的Goroutine完成之前就结束了。当发送第二条消息时，Goroutine被阻塞，直到另一端接收了第一条消息。然后它打印出来得如此之快，以至于没有时间打印出消息来显示Goroutine的结束。如果你在控制台上不断执行程序，sooner
    or later调度器会在主线程之前完成Goroutine的执行。
- en: Directional channels
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方向性通道
- en: One cool feature about Go channels is that, when we use them as parameters,
    we can restrict their directionality so that they can be used only to send or
    to receive. The compiler will complain if a channel is used in the restricted
    direction. This feature applies a new level of static typing to Go apps and makes
    code more understandable and more readable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Go通道的一个很酷的特性是，当我们将它们用作参数时，我们可以限制它们的方向性，使它们只能用于发送或接收。如果通道在受限方向上被使用，编译器会报错。这个特性为Go应用程序应用了新的静态类型级别，并使代码更易理解和更易读。
- en: 'We''ll take a simple example with channels:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用通道来举一个简单的例子：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The line where we launch the new Goroutine `go func(ch chan<- string)` states
    that the channel passed to this function can only be used as an input channel,
    and you can't listen to it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们启动新的Goroutine `go func(ch chan<- string)`的那一行，声明了传递给这个函数的通道只能用作输入通道，你不能监听它。
- en: 'We can also pass a channel that will be used as a receiver channel only:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以传递一个只用作接收器通道的通道：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, the arrow is on the opposite side of the keyword `chan`, indicating
    an extracting operation from the channel. Keep in mind that the channel arrow
    always points left, to indicate a receiving channel, it must go on the left, and
    to indicate an inserting channel, it must go on the right.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，箭头位于`chan`关键字的相反方向，表示从通道中提取操作。请记住，通道箭头总是指向左边，以指示接收通道，它必须指向左边，以指示插入通道，它必须指向右边。
- en: 'If we try to send a value through this *receive only* channel, the compiler
    will complain about it:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图通过这个*只接收*通道发送一个值，编译器会抱怨：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This function has a receive only channel that we will try to use to send the
    message `hello` through. Let''s see what the compiler says:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一个只接收通道，我们将尝试通过它发送消息`hello`。让我们看看编译器说了什么：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It doesn't like it and asks us to correct it. Now the code is even more readable
    and safe, and we have just placed an arrow in front or behind the `chan` argument.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它不喜欢它，并要求我们纠正它。现在代码更加可读和安全，我们只是在`chan`参数的前面或后面放置了一个箭头。
- en: The select statement
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择语句
- en: The select statement is also a key feature in Go. It is used to handle more
    than one channel input within a Goroutine. In fact, it opens lots of possibilities,
    and we will use it extensively in the following chapters.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`语句也是Go中的一个关键特性。它用于在一个Goroutine中处理多个通道输入。事实上，它打开了许多可能性，在接下来的章节中我们将广泛使用它。'
- en: '![The select statement](img/B05557_08_04-1.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![选择语句](img/B05557_08_04-1.jpg)'
- en: In the `select` structure, we ask the program to choose between one or more
    channels to receive their data. We can save this data in a variable and make something
    with it before finishing the select. The `select` structure is just executed once;
    it doesn't matter if it is listening to more channels, it will be executed only
    once and the code will continue executing. If we want it to handle the same channels
    more than once, we have to put it in a `for` loop.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`select`结构中，我们要求程序在一个或多个通道之间选择接收它们的数据。我们可以将这些数据保存在一个变量中，并在完成选择之前对其进行处理。`select`结构只执行一次；不管它是否在监听多个通道，它只会执行一次，代码将继续执行。如果我们希望它多次处理相同的通道，我们必须将其放在一个`for`循环中。
- en: We will make a small app that will send the message `hello` and the message
    `goodbye` to the same Goroutine, which will print them and exit if it doesn't
    receive anything else in five seconds.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小应用程序，将消息`hello`和消息`goodbye`发送到同一个Goroutine中，该Goroutine将打印它们，并在五秒内没有收到其他消息时退出。
- en: 'First, we will make a generic function that sends a string over a channel:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个通用函数，用于通过通道发送一个字符串：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we can send a string over a channel by simply calling the `sendString`
    method. It''s time for the receiver. The receiver will take messages from both
    channels--the one that sends `hello` messages and the one that sends `goodbye`
    messages. You can also see this in the previous diagram:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过简单调用`sendString`方法向通道发送一个字符串。现在是接收者的时间了。接收者将从两个通道接收消息--一个发送`hello`消息的通道，一个发送`goodbye`消息的通道。你也可以在之前的图表中看到这一点：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Let's start with the arguments. This function takes three channels--two receiving
    channels and one to send something through it. Then, it starts an infinite loop
    with the `for` keyword. This way we can keep listening to both channels forever.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从参数开始。这个函数接受三个通道--两个接收通道和一个用于通过它发送东西的通道。然后，它使用`for`关键字开始一个无限循环。这样我们就可以永远保持对两个通道的监听。
- en: 'Inside the scope of `select` block, we have to use a case for each channel
    we want to handle (have you realized how similar it is to the `switch` statement?).
    Let''s see the three cases step by step:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`select`块的范围内，我们必须为我们想要处理的每个通道使用一个case（你是否意识到它与`switch`语句有多么相似？）。让我们一步一步地看看这三种情况：
- en: The first case takes the incoming data from the `helloCh` argument and saves
    it in a variable called `msg`. Then it prints the contents of this variable.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种情况接收来自`helloCh`参数的传入数据，并将其保存在一个名为`msg`的变量中。然后它打印出这个变量的内容。
- en: The second case takes the incoming data from the `goodbyeCh` argument and saves
    it in a variable called `msg` too. Then it also prints the content of this variable.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种情况接收来自`goodbyeCh`参数的传入数据，并将其保存在一个名为`msg`的变量中。然后它也打印出这个变量的内容。
- en: The third case is quite interesting. It calls the `time` function. After that,
    if we check its signature, it accepts a time and duration value and returns a
    receiving channel. This receiving channel will receive a time, the value of `time`
    after the specified duration has passed. In our example, we use the channel it
    returns as a timeout. Because the select is restarted after each handle, the timer
    is restarted too. This is a very simple way to set a timer to a Goroutine waiting
    for the response of one or many channels.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种情况非常有趣。它调用`time`函数。之后，如果我们检查它的签名，它接受一个时间和持续时间值，并返回一个接收通道。这个接收通道将在指定的持续时间过去后接收一个时间，`time`的值。在我们的例子中，我们使用它返回的通道作为超时。因为每次处理后`select`都会重新启动，计时器也会重新启动。这是一个非常简单的方法，可以为等待一个或多个通道的响应的Goroutine设置一个计时器。
- en: 'Everything is ready for the `main` function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数准备就绪：'
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Again, step by step, we created the three channels that we'll need in this exercise.
    Then, we launched our `receiver` function in a different Goroutine. This Goroutine
    is handled by Go's scheduler and our program continues. We launched a new Goroutine
    to send the message `hello` to the `helloCh` arguments. Again, this is going to
    occur eventually when the Go's scheduler decides.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 再一步一步地，我们创建了这个练习中需要的三个通道。然后，我们在一个不同的Goroutine中启动了我们的`receiver`函数。这个Goroutine由Go的调度程序处理，我们的程序继续执行。我们启动了一个新的Goroutine，向`helloCh`参数发送消息`hello`。同样，这将在Go的调度程序决定时最终发生。
- en: Our program continues again and waits for a second. In this break, Go's scheduler
    will have time to execute the receiver and the first message (if it hasn't done
    so yet), so the `hello!` message will appear on the console during the break.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序再次继续，并等待一秒。在这个间歇中，Go的调度程序将有时间执行接收者和第一条消息（如果尚未执行），所以`hello!`消息将在间歇期间出现在控制台上。
- en: A new message is sent over the `goodbye` channel with the `goodbye!` text in
    a new Goroutine, and our program continues again to a line where we wait for an
    incoming message in the `quitCh` argument.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的消息通过`goodbye`通道以`goodbye!`文本的形式发送到一个新的Goroutine中，我们的程序再次继续执行，等待在`quitCh`参数中接收到一条消息的行。
- en: We have launched three Goroutines already--the receiver that it is still running,
    the first message that had finished when the message was handled by the `select`
    statement, and the second message was been printed almost immediately and had
    finished too. So just the receiver is running at this moment, and if it doesn't
    receive any other message in the following two seconds, it will handle the incoming
    message from the `time` structure. After `channel` type, print a message to say
    that it is quitting, send a `true` to the `quitCh`, and break the infinite loop
    where it was looping.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经启动了三个Goroutine--接收者仍在运行，第一个消息在消息被`select`语句处理时已经完成，第二个消息几乎立即被打印并完成了。所以此刻只有接收者在运行，如果在接下来的两秒内没有收到其他消息，它将处理来自`time`结构的传入消息。在`channel`类型之后，打印一条消息以表明它正在退出，向`quitCh`发送一个`true`，并中断它正在循环的无限循环。
- en: 'Let''s run this small app:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个小应用程序：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The result  may not be very impressive, but the concept is clear. We can handle
    many incoming channels in the same Goroutine by using the select statement.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能并不令人印象深刻，但概念是清晰的。我们可以使用select语句在同一个Goroutine中处理许多传入的通道。
- en: Ranging over channels too!
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也可以对通道进行范围遍历！
- en: 'The last feature about channels that we will see is ranging over channels.
    We are talking about the range keyword. We have used it extensively to range over
    lists, and we can use it to range over a channel too:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到关于通道的最后一个特性是对通道进行范围遍历。我们谈论的是范围关键字。我们已经广泛使用它来遍历列表，我们也可以用它来遍历通道：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this case, we have created an unbuffered channel, but it would work with
    a buffered one too. We launched a function in a new Goroutine that sends the number
    "1" over a channel, waits a second, sends the number "2", and closes the channel.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了一个非缓冲通道，但它也可以使用缓冲通道。我们在一个新的Goroutine中启动一个函数，该函数通过通道发送数字"1"，等待一秒，发送数字"2"，然后关闭通道。
- en: The last step is to range over the channel. The syntax is quite similar to a
    list range. We store the incoming data from the channel in the variable `v` and
    we print this variable to the console. The range keeps iterating until the channel
    is closed, taking data from the channel.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是对通道进行范围遍历。语法与列表范围非常相似。我们将从通道中存储传入的数据到变量`v`，并将这个变量打印到控制台。范围会一直迭代，直到通道关闭，从通道中获取数据。
- en: Can you guess the output of this little program?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出这个小程序的输出吗？
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Again, not very impressive. It prints the number "1", then waits a second, prints
    the number "2", and exits the application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，并不令人印象深刻。它打印数字"1"，然后等待一秒，打印数字"2"，然后退出应用程序。
- en: According to the design of this concurrent app, the range was iterates over
    possible incoming data from the
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个并发应用程序的设计，范围会迭代可能从通道中传入的数据
- en: channel
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通道
- en: until the concurrent Goroutine closes this channel. At that moment, the range
    finishes and the app can exit.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 直到并发Goroutine关闭这个通道。在那一刻，范围结束，应用程序可以退出。
- en: Range is very useful in taking data from a channel, and it's commonly used in
    fan-in patterns where many different Goroutines send data to the same channel.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 范围在从通道中获取数据时非常有用，并且通常用于多个不同的Goroutine向同一个通道发送数据的扇入模式中。
- en: Using it all - concurrent singleton
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用所有这些-并发单例
- en: Now that we know how to create Goroutines and channels, we'll put all our knowledge
    in a single package. Think back to the first few chapter, when we explained the
    singleton pattern-it was some structure or variable that could only exist once
    in our code. All access to this structure should be done using the pattern described,
    but, in fact, it wasn't concurrent safe.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何创建Goroutines和通道，我们将把所有的知识放在一个单一的包中。回想一下前几章，当我们解释单例模式时--它是一种只能在我们的代码中存在一次的结构或变量。对这个结构的所有访问都应该使用所描述的模式，但实际上，它并不是并发安全的。
- en: Now we will write with concurrency in mind. We will write a concurrent counter,
    like the one we wrote in the *mutexes* section, but this time we will solve it
    with channels.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将考虑并发编写。我们将编写一个并发计数器，就像我们在*互斥*部分中编写的那样，但这次我们将使用通道来解决它。
- en: Unit test
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: To restrict concurrent access to the `singleton` instance, just one Goroutine
    will be able to access it. We'll access it using channels--the first one to add
    one, the second one to get the current count, and the third one to stop the Goroutine.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制对`singleton`实例的并发访问，只有一个Goroutine能够访问它。我们将使用通道访问它--第一个通道用于添加一个，第二个通道用于获取当前计数，第三个通道用于停止Goroutine。
- en: We will add one 10,000 times using 10,000 different Goroutines launched from
    two different `singleton` instances. Then, we'll introduce a loop to check the
    count of the `singleton` until it is 5,000, but we'll write how much the count
    is before starting the loop.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用从两个不同的`singleton`实例启动的10,000个不同的Goroutine添加10,000次。然后，我们将引入一个循环来检查`singleton`的计数，直到达到5,000，但我们将在开始循环之前写下计数是多少。
- en: 'Once the count has reached 5,000, the loop will exit and quit the running Goroutine-the
    test code looks like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计数达到5,000，循环将退出并退出运行的Goroutine--测试代码看起来像这样：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we can see the full test we'll use. After creating two instances of the
    `singleton`, we have created a `for` loop that launches the `AddOne` method 5,000
    times from each instance. This is not happening yet; they are being scheduled
    and will be executed eventually. We are printing the count of the `singleton`
    instance to clearly see this eventuality; depending on the computer, it will print
    some number greater than 0 and lower than 10,000.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们将使用的完整测试。在创建两个`singleton`实例之后，我们创建了一个`for`循环，从每个实例中启动`AddOne`方法5,000次。这还没有发生；它们正在被调度，最终将被执行。我们打印`singleton`实例的计数，以清楚地看到这种可能性；根据计算机的不同，它将打印出一个大于0且小于10,000的数字。
- en: The last step before stopping the Goroutine that is holding the count is to
    enter a loop that checks the value of the count and waits 10 milliseconds if the
    value is not the expected value (10,000). Once it reaches this value, the loop
    will exit and we can stop the `singleton` instance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在停止持有计数的Goroutine之前的最后一步是进入一个循环，检查计数的值，并在值不是预期值（10,000）时等待10毫秒。一旦达到这个值，循环将退出，我们可以停止`singleton`实例。
- en: We'll jump directly to the implementation as the requirement is quite simple.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于要求非常简单，我们将直接跳转到实施。
- en: Implementation
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'First of all, we''ll create the Goroutine that will hold the count:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建将保存计数的Goroutine：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We created three channels, as we mentioned earlier:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了三个通道，正如我们之前提到的：
- en: The `addCh` channel is used to communicate with the action of adding one to
    the count, and receives a `bool` type just to signal "add one" (we don't need
    to send the number, although we could).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addCh`通道用于与添加一个计数的动作进行通信，并接收一个`bool`类型，只是为了发出“添加一个”的信号（虽然我们可以发送数字，但我们不需要）。'
- en: The `getCountCh` channel will return a channel that will receive the current
    value of the count. Take a moment to reason about the `getCountCh` channel-it's
    a channel that receives a channel that receives integer types. It sounds a bit
    complicated, but it will make more sense when we finish the example, don't worry.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCountCh`通道将返回一个将接收计数的当前值的通道。花点时间思考一下`getCountCh`通道-它是一个接收整数类型的通道的通道。听起来有点复杂，但当我们完成示例时，它会更有意义，不用担心。'
- en: The `quitCh` channel will communicate to the Goroutine that it should end its
    infinite loop and finish itself too.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quitCh`通道将通知Goroutine应该结束其无限循环并结束自身。'
- en: Now we have the channels that we need to perform the actions we want. Next,
    we launch the Goroutine passing the channels as arguments. As you can see, we
    are restricting the direction of the channels to provide more type safety. Inside
    this Goroutine, we create an infinite `for` loop. This loop won't stop until a
    break is executed within it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了执行我们想要的操作所需的通道。接下来，我们启动Goroutine，将通道作为参数传递。正如你所看到的，我们正在限制通道的方向，以提供更多的类型安全性。在这个Goroutine内部，我们创建了一个无限的`for`循环。这个循环不会停止，直到在其中执行了一个中断。
- en: 'Finally, the `select` statement, if you remember, was a way to receive data
    from different channels at the same time. We have three cases, so we listen to
    the three incoming channels that entered as arguments:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`select`语句，如果你还记得，是一种同时从不同通道接收数据的方法。我们有三种情况，因此我们监听了作为参数输入的三个传入通道：
- en: The `addCh` case will add one to the count. Remember that only one case can
    be executed on each iteration so that no Goroutine could be accessing the current
    count until we finish adding one.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addCh`情况将计数增加一。请记住，每次迭代只能执行一个情况，以便没有Goroutine可以访问当前计数，直到我们完成添加一个。'
- en: The `getCountCh` channel receives a channel that receives an integer, so we
    capture this new channel and send the current value through it to the other end.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCountCh`通道接收一个接收整数的通道，因此我们捕获了这个新通道，并通过它发送当前值到另一端。'
- en: The `quitCh` channel breaks the `for` loop, so the Goroutine ends.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quitCh`通道中断`for`循环，因此Goroutine结束。'
- en: One last thing. The `init()` function in any package will get executed on program
    execution, so we don't need to worry about executing this function specifically
    from our code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事。在任何包中，`init()`函数将在程序执行时执行，因此我们不需要担心从我们的代码中特别执行此函数。
- en: 'Now, we''ll create the type that the tests are expecting. We will see that
    all the magic and logic is hidden from the end user in this type (as we have seen
    in the code of the test):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建测试所期望的类型。我们将看到所有的魔术和逻辑都隐藏在这种类型中，对最终用户来说（正如我们在测试代码中看到的）：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `singleton` type works similar to the way it worked in [Chapter 2](ch02.html
    "Chapter 2. Creational Patterns - Singleton, Builder, Factory, Prototype, and
    Abstract Factory Design Patterns") , *Creational Patterns - Singleton, Builder,
    Factory, Prototype, and Abstract Factory*, but this time it won't hold the count
    value. We created a local value for it called `instance`, and we return the pointer
    to this instance when we call the `GetInstance()` method. It is not strictly necessary
    to do it this way, but we don't need to allocate a new instance of the `singleton`
    type every time we want to access the count variable.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`singleton`类型的工作方式类似于[第2章](ch02.html "第2章。创建模式-单例，生成器，工厂，原型和抽象工厂设计模式")中的工作方式，*创建模式-单例，生成器，工厂，原型和抽象工厂*，但这次它不会保存计数值。我们为其创建了一个名为`instance`的本地值，并在调用`GetInstance()`方法时返回指向此实例的指针。这样做并不是严格必要的，但我们不需要在每次访问计数变量时分配`singleton`类型的新实例。'
- en: 'First, the `AddOne()` method will have to add one to the current count. How?
    By sending `true` to the `addCh` channel. That''s simple:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`AddOne()`方法将不得不将当前计数加一。如何？通过向`addCh`通道发送`true`。这很简单：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This small snippet will trigger the `addCh` case in our Goroutine in turn.
    The `addCh` case simply executes `count++` and finishes, letting `select` channel
    control flow that is executed on `init` function above to execute the next instruction:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小片段将依次触发我们的Goroutine中的`addCh`情况。`addCh`情况只是执行`count++`并完成，让`select`通道控制流执行`init`函数中的下一个指令：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `GetCount` method creates a channel every time it's called and defers the
    action of closing it at the end of the function. This channel is unbuffered as
    we have seen previously in this chapter. An unbuffered channel blocks the execution
    until it receives some data. So we send this channel to `getCountCh` which is
    a channel too and, effectively, expects a `chan int` type to send the current
    count value back through it. The `GetCount()` method will not return until the
    value of `count` variable arrives to the `resCh` channel.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCount`方法每次被调用时都会创建一个通道，并推迟在函数结束时关闭它的操作。这个通道是无缓冲的，正如我们在本章中之前看到的那样。无缓冲通道会阻塞执行，直到它接收到一些数据。因此，我们将这个通道发送到`getCountCh`，它也是一个通道，并且有效地期望一个`chan
    int`类型通过它发送当前计数值。`GetCount()`方法将不会返回，直到`count`变量的值到达`resCh`通道。'
- en: 'You might be thinking, why aren''t we using the same channel in both directions
    to receive the value of the count? This way we will avoid an allocation. Well,
    if we use the same channel inside the `GetCount()` method, we will have two listeners
    in this channel--one in `select` statement, at the beginning of the file on the
    `init` function, and one there, so it could resolve to any of them when sending
    the value back:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么我们不在两个方向上使用相同的通道来接收计数的值？这样我们就可以避免分配。如果我们在`GetCount()`方法中使用相同的通道，我们将在这个通道中有两个监听器--一个在`select`语句中，在文件的开头的`init`函数中，一个在那里，所以当发送值时它可以解析到任何一个：
- en: '[PRE57]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Finally, we have to stop the Goroutine at some moment. The `Stop` method sends
    the value to the `singleton` type Goroutine so that the `quitCh` case is triggered
    and the `for` loop is broken. The next step is to close all channels so that no
    more data can be sent through them. This is very convenient when you know that
    you won't be using some of your channels anymore.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在某个时刻停止Goroutine。`Stop`方法向`singleton`类型的Goroutine发送值，以触发`quitCh`情况并打破`for`循环。下一步是关闭所有通道，以便不再通过它们发送数据。当你知道你不会再使用一些通道时，这非常方便。
- en: 'Time to execute the tests and take a look:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试并查看时间：
- en: '[PRE58]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Very little code output, but everything has worked as expected. In the test,
    we printed the value of the count before entering the loop that iterates until
    it reaches the value 10,000\. As we saw previously, the Go scheduler will try
    to run the content of the Goroutines using as many OS threads as you configured
    by using the `GOMAXPROCS` configuration. In my computer, it is set to `4` because
    my computer has four cores. But the point is that we can see that a lot of things
    can happen after launching a Goroutine (or 10,000) and the next execution line.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的代码很少，但一切都按预期工作。在测试中，我们在进入循环之前打印了计数的值，直到达到值10000。正如我们之前看到的，Go调度器将尝试使用尽可能多的OS线程来运行Goroutines的内容，通过使用`GOMAXPROCS`配置来配置。在我的电脑上，它设置为`4`，因为我的电脑有四个核心。但关键是我们可以看到在启动Goroutine（或10000个）和下一个执行行之后会发生很多事情。
- en: But what about its use of mutexes?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但互斥锁的使用呢？
- en: '[PRE59]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this case, the code is much leaner. As we saw previously, we can embed the
    mutex within the `singleton` structure. The count is also held in the `count`
    field and the `AddOne()` and `GetCount()` methods lock and unlock the value to
    be concurrently safe.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，代码要简洁得多。正如我们之前看到的，我们可以在`singleton`结构中嵌入互斥锁。计数也保存在`count`字段中，`AddOne()`和`GetCount()`方法锁定和解锁值以确保并发安全。
- en: One more thing. In this `singleton` instance, we are using the `RWMutex` type
    instead of the already known `sync.Mutex` type. The main difference here is that
    the `RWMutex` type has two types of locks--a read lock and a write lock. The read
    lock, executed by calling the `RLock` method, only waits if a write lock is currently
    active. At the same time, it only blocks a write lock, so that many read actions
    can be done in parallel. It makes a lot of sense; we don't want to block a Goroutine
    that wants to read a value just because another Goroutine is also reading the
    value-it won't change. The `sync.RWMutex` type helps us to achieve this logic
    in our code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事。在这个`singleton`实例中，我们使用的是`RWMutex`类型，而不是已知的`sync.Mutex`类型。这里的主要区别在于`RWMutex`类型有两种锁--读锁和写锁。通过调用`RLock`方法执行读锁，只有在当前存在写锁时才会等待。同时，它只会阻止写锁，因此可以并行进行许多读操作。这是有道理的；我们不希望因为另一个Goroutine也在读取值（它不会改变）而阻塞想要读取值的Goroutine。`sync.RWMutex`类型帮助我们在代码中实现这种逻辑。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen how to write a concurrent Singleton using mutexes and channels.
    While the channels example was more complex, it also shows the core power of Go's
    concurrency, as you can achieve complex levels of event-driven architectures by
    simply using channels.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用互斥锁和通道编写并发的Singleton。虽然通道的例子更复杂，但它也展示了Go并发的核心力量，因为你可以通过简单地使用通道实现复杂的事件驱动架构。
- en: Just keep in mind that, if you haven't written concurrent code in the past,
    it can take some time to start thinking concurrently in a comfortable way. But
    it's nothing that practice cannot solve.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你以前没有编写过并发代码，开始以舒适的方式并发思考可能需要一些时间。但这并不是练习不能解决的问题。
- en: We have seen the importance of designing concurrent apps to achieve parallelism
    in our programs. We have dealt with most of Go's primitives to write concurrent
    applications, and now we can write common concurrent design patterns.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了设计并发应用程序以实现程序并行性的重要性。我们已经处理了大部分Go的原语，编写了并发应用程序，现在我们可以编写常见的并发设计模式。
