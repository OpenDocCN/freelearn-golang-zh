- en: Chapter 9. Concurrency Patterns - Barrier, Future, and Pipeline Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 并发模式-屏障、未来和管道设计模式
- en: 'Now that we are familiar with the concepts of concurrency and parallelism,
    and we have understood how to achieve them by using Go''s concurrency primitives,
    we can see some patterns regarding concurrent work and parallel execution. In
    this chapter we''ll see the following patterns:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了并发和并行的概念，并且已经了解了如何使用Go的并发原语来实现它们，我们可以看到关于并发工作和并行执行的一些模式。在本章中，我们将看到以下模式：
- en: Barrier is a very common pattern, especially when we have to wait for more than
    one response from different Goroutines before letting the program continue
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏障是一种非常常见的模式，特别是当我们必须等待来自不同Goroutines的多个响应才能让程序继续时。
- en: Future pattern allows us to write an algorithm that will be executed eventually
    in time (or not) by the same Goroutine or a different one
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来模式允许我们编写一个算法，该算法最终将由同一个Goroutine或不同的Goroutine在时间上执行（或不执行）
- en: Pipeline is a powerful pattern to build complex synchronous flows of Goroutines
    that are connected with each other according to some logic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道是一种强大的模式，用于构建与某种逻辑相连的Goroutines的复杂同步流
- en: Take a quick look at the description of the three patterns. They all describe
    some sort of logic to synchronize execution in time. It's very important to keep
    in mind that we are now developing concurrent structures with all the tools and
    patterns we have seen in the previous chapters. With Creational patterns we were
    dealing with creating objects. With the Structural patterns we were learning how
    to build idiomatic structures and in Behavioral patterns we were managing mostly
    with algorithms. Now, with Concurrency patterns, we will mostly manage the timing
    execution and order execution of applications that has more than one *flow*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览一下这三种模式的描述。它们都描述了一些逻辑来同步执行时间。非常重要的是要记住，我们现在正在使用前几章中看到的所有工具和模式来开发并发结构。在创建模式中，我们处理创建对象。在结构模式中，我们学习如何构建成惯用的结构，在行为模式中，我们主要处理算法。现在，使用并发模式，我们将主要管理应用程序的定时执行和顺序执行，这些应用程序具有多个*流*。
- en: Barrier concurrency pattern
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏障并发模式
- en: We are going to start with the Barrier pattern. Its purpose is simple--put up
    a barrier so that nobody passes until we have all the results we need, something
    quite common in concurrent applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从屏障模式开始。它的目的很简单-设置一个屏障，以便在我们获得所有需要的结果之前没有人通过，这在并发应用程序中非常常见。
- en: Description
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: Imagine the situation where we have a microservices application where one service
    needs to compose its response by merging the responses of another three microservices.
    This is where the Barrier pattern can help us.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这样的情况，我们有一个微服务应用程序，其中一个服务需要通过合并另外三个微服务的响应来组成其响应。这就是屏障模式可以帮助我们的地方。
- en: Our Barrier pattern could be a service that will block its response until it
    has been composed with the results returned by one or more different Goroutines
    (or services). And what kind of primitive do we have that has a blocking nature?
    Well, we can use a lock, but it's more idiomatic in Go to use an unbuffered channel.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的屏障模式可以是一个服务，它将阻止其响应，直到它已与一个或多个不同的Goroutines（或服务）返回的结果组合在一起。那么我们有什么样的原语具有阻塞特性呢？嗯，我们可以使用锁，但在Go中更惯用的是使用无缓冲通道。
- en: Objectives
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'As its name implies, the Barrier pattern tries to stop an execution so it doesn''t
    finish before it''s ready to finish. The Barrier pattern''s objectives are as
    follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，屏障模式试图阻止执行，以便在准备好结束之前不要完成。屏障模式的目标如下：
- en: Compose the value of a type with the data coming from one or more Goroutines.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类型的值与来自一个或多个Goroutines的数据组合在一起。
- en: Control the correctness of any of those incoming data pipes so that no inconsistent
    data is returned. We don't want a partially filled result because one of the pipes
    has returned an error.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制任何这些传入数据管道的正确性，以便不返回不一致的数据。我们不希望部分填充的结果，因为其中一个管道返回了错误。
- en: An HTTP GET aggregator
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个HTTP GET聚合器
- en: For our example, we are going to write a very typical situation in a microservices
    application-an app that performs two HTTP `GET` calls and joins them in a single
    response that will be printed on the console.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将在微服务应用程序中编写一个非常典型的情况-一个执行两个HTTP `GET`调用并将它们合并成单个响应的应用程序，然后将其打印在控制台上。
- en: Our small app must perform each request in a different Goroutine and print the
    result on the console if both responses are correct. If any of them returns an
    error, then we print just the error.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小应用程序必须在不同的Goroutine中执行每个请求，并在控制台上打印结果，如果两个响应都正确。如果其中任何一个返回错误，那么我们只打印错误。
- en: 'The design must be concurrent, allowing us to take advantage of our multicore
    CPUs to make the calls in parallel:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 设计必须是并发的，允许我们利用多核CPU并行进行调用：
- en: '![An HTTP GET aggregator](img/B05557_09_01-300x173.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![一个HTTP GET聚合器](img/B05557_09_01-300x173.jpg)'
- en: In the preceding diagram, the solid lines represent calls and the dashed lines
    represent channels. The balloons are Goroutines, so we have two Goroutines launched
    by the `main` function (which could also be considered a Goroutine). These two
    functions will communicate back to the `main` function by using a **common channel**
    that they received when they were created on the `makeRequest` calls.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，实线表示调用，虚线表示通道。气球是Goroutines，因此我们有两个Goroutines由`main`函数启动（也可以被认为是Goroutine）。这两个函数将通过使用它们在`makeRequest`调用时接收到的**公共通道**与`main`函数进行通信。
- en: Acceptance criteria
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'Our main objective in this app is to get a merged response of two different
    calls, so we can describe our acceptance criteria like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个应用程序中的主要目标是获取两个不同调用的合并响应，因此我们可以这样描述我们的验收标准：
- en: Print on the console the merged result of the two calls to `http://httpbin.org/headers`
    and `http://httpbin.org/User-Agent` URLs. These are a couple of public endpoints
    that respond with data from the incoming connections. They are very popular for
    testing purposes. You will need an internet connection to do this exercise.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台上打印两次对`http://httpbin.org/headers`和`http://httpbin.org/User-Agent` URL的调用的合并结果。这些是一对公共端点，会响应来自传入连接的数据。它们非常受欢迎，用于测试目的。您需要互联网连接才能完成此练习。
- en: If any of the calls fails, it must not print any result-just the error message
    (or error messages if both calls failed).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何一个调用失败，它不得打印任何结果-只打印错误消息（或者如果两个调用都失败，则打印错误消息）。
- en: The output must be printed as a composed result when both calls have finished.
    It means that we cannot print the result of one call and then the other.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个调用都完成时，输出必须作为组合结果打印出来。这意味着我们不能先打印一个调用的结果，然后再打印另一个调用的结果。
- en: Unit test - integration
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试 - 集成
- en: 'To write unit or integration tests for concurrent designs can sometimes be
    tricky, but this won''t stop us from writing our awesome unit tests. We will have
    a single `barrier` method that accepts a set of endpoints defined as a `string`
    type. The barrier will make a `GET` request to each endpoint and compose the result
    before printing it out. In this case, we will write three integration tests to
    simplify our code so we don''t need to generate mock responses:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为并发设计编写单元测试或集成测试有时可能会很棘手，但这不会阻止我们编写出色的单元测试。我们将有一个名为`barrier`的方法，接受一个定义为`string`类型的端点集。屏障将对每个端点进行`GET`请求，并在打印结果之前组合结果。在这种情况下，我们将编写三个集成测试，以简化我们的代码，这样我们就不需要生成模拟响应：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have a single test that will execute three subtests:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个单一的测试，将执行三个子测试：
- en: The first test makes two calls to the correct endpoints
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个测试对正确的端点进行两次调用
- en: The second test will have an incorrect endpoint, so it must return an error
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个测试将有一个错误的端点，因此它必须返回一个错误
- en: The last test will return the maximum timeout time so that we can force a timeout
    error
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个测试将返回最大超时时间，以便我们可以强制超时错误
- en: 'We will have a function called `barrier` that will accept an undetermined number
    of endpoints in the form of strings. Its signature could be like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个名为`barrier`的函数，它将接受形式为字符串的不确定数量的端点。它的签名可能是这样的：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the `barrier` function doesn''t return any value because its
    result will be printed on the console. Previously, we have written an implementation
    of an `io.Writer` interface to emulate the writing on the operating system''s
    `stdout` library. Just to change things a bit, we will capture the `stdout` library
    instead of emulating one. The process to capture the `stdout` library isn''t difficult
    once you understand concurrency primitives in Go:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`barrier`函数不返回任何值，因为它的结果将打印在控制台上。之前，我们已经编写了一个`io.Writer`接口的实现，以模拟在操作系统的`stdout`库上的写入。为了改变一些东西，我们将捕获`stdout`库而不是模拟一个。一旦你理解了Go语言中的并发原语，捕获`stdout`库的过程并不困难：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Don't feel daunted by this code; it's really simple. First we created a pipe;
    we have done this before in [Chapter 3](ch03.html "Chapter 3. Structural Patterns
    - Composite, Adapter, and Bridge Design Patterns"), *Structural Patterns - Adapter,
    Bridge, and Composite Design Patterns*, when we talked about the Adapter design
    pattern. To recall, a pipe allows us to connect an `io.Writer` interface to an
    `io.Reader` interface so that the reader input is the `Writer` output. We define
    the `os.Stdout` as the writer. Then, to capture `stdout` output, we will need
    a different Goroutine that listens while we write to the console. As you know,
    if we write, we don't capture, and if we capture, we are not writing. The keyword
    here is `while`; it is a good rule of thumb that if you find this word in some
    definition, you'll probably need a concurrent structure. So we use the `go` keyword
    to launch a different Goroutine that copies reader input to a bytes buffer before
    sending the contents of the buffer through a channel (that we should have previously
    created).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这段代码吓到；它真的很简单。首先我们创建了一个管道；我们在[第3章](ch03.html "第3章 结构模式 - 组合、适配器和桥接设计模式")中已经做过这个操作，*结构模式
    - 适配器、桥接和组合设计模式*，当我们谈论适配器设计模式时。回想一下，管道允许我们将`io.Writer`接口连接到`io.Reader`接口，以便读取器的输入是`Writer`的输出。我们将`os.Stdout`定义为写入器。然后，为了捕获`stdout`输出，我们将需要一个不同的Goroutine来监听我们写入控制台时。正如你所知，如果我们写入，我们就不会捕获，如果我们捕获，我们就不会写入。这里的关键词是`while`；这是一个经验法则，如果你在某个定义中找到这个词，你可能需要一个并发结构。因此，我们使用`go`关键字启动一个不同的Goroutine，将读取器的输入复制到字节缓冲区，然后通过通道发送缓冲区的内容（我们应该先前创建）。
- en: At this point, we have a listening Goroutine, but we haven't printed anything
    yet, so we call our (not yet written) function `barrier` with the provided endpoints.
    Next, we have to close the writer to signal the Goroutine that no more input is
    going to come to it. Our channel called out blocks execution until some value
    is received (the one sent by our launched Goroutine). The last step is to return
    the contents captured from the console.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们有一个监听的Goroutine，但我们还没有打印任何东西，所以我们用提供的端点调用我们的（尚未编写的）函数`barrier`。接下来，我们必须关闭写入器以向Goroutine发出不会再有更多输入的信号。我们称为out的通道会阻塞执行，直到接收到某个值（由我们启动的Goroutine发送的值）。最后一步是返回从控制台捕获的内容。
- en: 'OK, so we have a function called `captureBarrierOutput` that will capture the
    outputs in `stdout` and return them as a string. We can write our tests now:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们有一个名为`captureBarrierOutput`的函数，它将在`stdout`中捕获输出并将其作为字符串返回。现在我们可以编写我们的测试了：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All the tests are very easy to implement. All in all, it is the `captureBarrierOutput`
    function that calls the `barrier` function. So we pass the endpoints and check
    the returned result. Our composed response directed to [http://httpbin.org](http://httpbin.org)
    must contain the text *Accept-Encoding* and *User-Agent* in the responses of each
    endpoint. If we don''t find those texts, the test will fail. For debugging purposes,
    we log the response in case we want to check it with the `-v` flag on the go test:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些测试都非常容易实现。总的来说，是`captureBarrierOutput`函数调用了`barrier`函数。所以我们传递端点并检查返回的结果。我们发送到[http://httpbin.org](http://httpbin.org)的组合响应必须包含每个端点响应中的*Accept-Encoding*和*User-Agent*文本。如果我们找不到这些文本，测试将失败。为了调试目的，如果我们想要使用`-v`标志检查它，我们会记录响应在go
    test中：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time we used an incorrect endpoint URL, so the response must return the
    error prefixed with the word *ERROR* that we will write ourselves in the `barrier`
    function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用了不正确的端点URL，所以响应必须返回以*ERROR*为前缀的错误，这是我们自己在`barrier`函数中编写的。
- en: 'The last function will reduce the timeout of the HTTP `GET` client to a minimum
    of 1 ms, so we force a timeout:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数将把HTTP `GET`客户端的超时减少到最少1毫秒，以便强制超时：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `timeoutMilliseconds` variable will be a package variable that we will have
    to define later during implementation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeoutMilliseconds`变量将是一个我们在实现过程中需要定义的包变量。'
- en: Implementation
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'We needed to define a package variable called `timeoutMilliseconds`. Let''s
    start from there:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一个名为`timeoutMilliseconds`的包变量。让我们从那里开始：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The initial timeout delay is 5 seconds (5,000 milliseconds) and we will need
    those packages in our code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 初始超时延迟为5秒（5,000毫秒），我们将需要这些包在我们的代码中。
- en: OK, so we need a function that launches a Goroutine for each endpoint URL. Do
    you remember how we achieve the communication between Goroutines? Exactly--channels!
    So we will need a channel to handle responses and a channel to handle errors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们需要一个函数为每个端点URL启动一个Goroutine。你还记得我们是如何在Goroutines之间进行通信的吗？没错--通道！所以我们需要一个处理响应的通道和一个处理错误的通道。
- en: 'But we can simplify it a bit more. We will receive two correct responses, two
    errors, or a response and an error; in any case, there are always two responses,
    so we can join errors and responses in a merged type:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以简化它一些。我们将收到两个正确的响应、两个错误，或一个响应和一个错误；无论如何，总是有两个响应，所以我们可以将错误和响应合并成一个合并类型：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, each Goroutine will send back a value of the `barrierResp` type. This value
    will have a value for `Err` or a value for the `Resp` field.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个Goroutine将发送一个`barrierResp`类型的值。这个值将有一个`Err`值或一个`Resp`字段的值。
- en: 'The procedure is simple: we create a channel of size 2, the one that will receive
    responses of the `barrierResp` type, we launch both requests and wait for two
    responses, and then check to see if there is any error:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程很简单：我们创建了一个大小为2的通道，用于接收`barrierResp`类型的响应，我们启动了两个请求并等待两个响应，然后检查是否有任何错误：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Following the previous description, we created a buffered channel called `in`,
    making it the size of the incoming endpoints, and we deferred channel closing.
    Then, we launched a function called `makeRequest` with each endpoint and the response
    channel.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的描述，我们创建了一个名为`in`的缓冲通道，使其大小与传入的端点一样，并推迟了通道关闭。然后，我们使用每个端点和响应通道启动了一个名为`makeRequest`的函数。
- en: Now we will loop  twice, once for each endpoint. In the loop, we block the execution
    waiting for data from the `in` channel. If we find an error, we print it prefixed
    with the word *ERROR* as we expect in our tests, and set `hasErrorvar` to true.
    After two responses, if we don't find any error (`hasError== false`) we print
    every response and the channel will be closed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将循环两次，每次对应一个端点。在循环中，我们阻塞执行，等待来自`in`通道的数据。如果我们发现错误，我们会打印带有*ERROR*前缀的错误，因为这是我们在测试中期望的，并将`hasErrorvar`设置为true。在两个响应之后，如果我们没有发现任何错误（`hasError==
    false`），我们会打印每个响应，并关闭通道。
- en: 'We still lack the `makeRequest` function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然缺少`makeRequest`函数：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `makeRequest` function is a very straightforward functions that accepts
    a channel to output `barrierResp` values to and a URL to request. We create an
    `http.Client` and set its timeout field to the value of the `timeoutMilliseconds`
    package variable. This is how we can change the timeout delay before the `in`
    function tests. Then, we simply make the `GET` call, take the response, parse
    it to a byte slice, and send it through the `out` channel.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeRequest`函数是一个非常简单的函数，它接受一个通道来输出`barrierResp`值和一个要请求的URL。我们创建一个`http.Client`并将其超时字段设置为`timeoutMilliseconds`包变量的值。这是我们在`in`函数测试之前可以改变超时延迟的方法。然后，我们简单地进行`GET`调用，获取响应，将其解析为字节切片，并通过`out`通道发送。'
- en: We do all this by filling a variable called `res` of the `barrierResp` type.
    If we find an error while performing a `GET` request or parsing the body of the
    result, we fill the `res.Err` field, send it to the `out` channel (which has the
    opposite side connected to the original Goroutine), and exit the function (so
    we don't send two values through the `out` channel by mistake).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过填充`barrierResp`类型的`res`变量来完成所有这些。如果我们在执行`GET`请求或解析结果的主体时发现错误，我们会填充`res.Err`字段，将其发送到`out`通道（其对面连接到原始Goroutine），并退出函数（这样我们就不会错误地通过`out`通道发送两个值）。
- en: 'Time to run the tests. Remember that you need an Internet connection, or the
    first two tests will fail. We will first try the test that has two endpoints that
    are correct:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行测试了。请记住，您需要互联网连接，否则前两个测试将失败。我们将首先尝试具有两个正确端点的测试：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Perfect. We have a JSON response with a key, `headers`, and another JSON response
    with a key `User-Agent`. In our integration tests, we were looking for the strings, `User-Agent`
    and `Accept-Encoding`, which are present, so the test has passed successfully.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。我们得到了一个带有键`headers`的JSON响应，以及另一个带有键`User-Agent`的JSON响应。在我们的集成测试中，我们正在寻找字符串`User-Agent`和`Accept-Encoding`，这些字符串都存在，所以测试已成功通过。
- en: 'Now we will run the test that has an incorrect endpoint:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将运行一个具有不正确端点的测试：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see that we have had an error where `http://malformed-url` has returned
    a *no such host* error. A request to this URL must return a text with the word
    `ERROR:` prefixed, as we stated during the acceptance criteria, that's why this
    test is correct (we don't have a false positive).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当`http://malformed-url`返回*no such host*错误时，我们出现了错误。对这个URL的请求必须返回一个以`ERROR:`为前缀的文本，正如我们在验收标准中所述，这就是为什么这个测试是正确的（我们没有假阳性）。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In testing, it''s very important to understand the concepts of "false positive"
    and "false negative" tests. A false positive test is roughly described as a test
    that passes a condition when it shouldn''t (result: all passed) while the false
    negative is just the reverse (result: test failed). For example, we could be testing
    that a string is returned when doing the requests but, the returned string could
    be completely empty! This will lead to a false negative, a test that doesn''t
    fail even when we are checking a behavior that is incorrect on purpose (a request
    to `http://malformed-url`).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，理解“假阳性”和“假阴性”测试的概念非常重要。假阳性测试大致描述为当不应该通过条件时通过条件的测试（结果：全部通过），而假阴性则正好相反（结果：测试失败）。例如，我们可能正在测试请求时返回一个字符串，但是返回的字符串可能完全为空！这将导致假阴性，即即使我们正在检查一个有意不正确的行为（对`http://malformed-url`的请求），测试也不会失败。
- en: 'The last test reduced the timeout time to 1 ms:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试将超时时间缩短为1毫秒：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again, the test passed successfully and we have got two timeout errors. The
    URLs were correct, but we didn't have a response in less than one millisecond,
    so the client has returned a timeout error.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，测试成功通过，我们得到了两个超时错误。URL是正确的，但我们在一毫秒内没有得到响应，所以客户端返回了超时错误。
- en: Waiting for responses with the Barrier design pattern
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用屏障设计模式等待响应
- en: The Barrier pattern opens the door of microservices programming with its composable
    nature. It could be considered a Structural pattern, as you can imagine.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 屏障模式以其可组合的特性打开了微服务编程的大门。它可以被认为是一种结构模式，正如你可以想象的那样。
- en: The Barrier pattern is not only useful to make network requests; we could also
    use it to split some task into multiple Goroutines. For example, an expensive
    operation could be split into a few smaller operations distributed in different
    Goroutines to maximize parallelism and achieve better performance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 屏障模式不仅对进行网络请求有用；我们还可以使用它将某些任务分割成多个Goroutines。例如，一个昂贵的操作可以分割成几个较小的操作，分布在不同的Goroutines中，以最大程度地实现并行性并获得更好的性能。
- en: Future design pattern
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来设计模式
- en: The Future design pattern (also called **Promise**) is a quick and easy way
    to achieve concurrent structures for asynchronous programming. We will take advantage
    of first class functions in Go to develop *Futures*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 未来设计模式（也称为**Promise**）是实现异步编程的并发结构的一种快速简便的方法。我们将利用Go中的一级函数来开发*Futures*。
- en: Description
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: In short, we will define each possible behavior of an action before executing
    them in different Goroutines. Node.js uses this approach, providing event-driven
    programming by default. The idea here is to achieve a *fire-and-forget* that handles
    all possible results in an action.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将在不同的Goroutines中定义每个动作的可能行为，然后执行它们。Node.js使用这种方法，默认提供事件驱动编程。这里的想法是实现一个*fire-and-forget*，处理动作的所有可能结果。
- en: To understand it better, we can talk about a type that has embedded the behavior
    in case an execution goes well or in case it fails.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们可以谈论一个类型，它在执行顺利或失败的情况下嵌入了行为。
- en: '![Description](img/B05557_09_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![描述](img/B05557_09_02.jpg)'
- en: In the preceding diagram, the `main` function launches a **Future** within a
    new Goroutine. It won't wait for anything, nor will it receive any progress of
    the Future. It really fires and forgets it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，`main`函数在一个新的Goroutine中启动了一个**Future**。它不会等待任何东西，也不会接收Future的任何进度。它真的只是启动并忘记了它。
- en: 'The interesting thing here is that we can launch a new Future within a Future
    and embed as many Futures as we want in the same Goroutine (or new ones). The
    idea is to take advantage of the result of one Future to launch the next. For
    example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，我们可以在一个Future中启动一个新的Future，并在同一个Goroutine（或新的Goroutine）中嵌入尽可能多的Futures。这个想法是利用一个Future的结果来启动下一个。例如：
- en: '![Description](img/B05557_09_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![描述](img/B05557_09_03.jpg)'
- en: Here, we have the same Future. In this case, if the `Execute` function returned
    a correct result, the `Success` function is executed, and only in this case we
    execute a new Goroutine with another Future inside (or even without a Goroutine).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有相同的Future。在这种情况下，如果`Execute`函数返回了正确的结果，那么将执行`Success`函数，只有在这种情况下，我们才会执行一个新的Goroutine，里面包含另一个Future（甚至可以不使用Goroutine）。
- en: This is a kind of lazy programming, where a Future could be calling to itself
    indefinitely or just until some rule is satisfied. The idea is to define the behavior
    in advance and let the future resolve the possible solutions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种懒惰的编程，其中一个Future可能会无限地调用自身，或者直到满足某些规则为止。这个想法是预先定义行为，让未来解决可能的解决方案。
- en: Objectives
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'With the Future pattern, we can launch many new Goroutines, each with an action
    and its own handlers. This enables us to do the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未来模式，我们可以启动许多新的Goroutines，每个Goroutine都有一个动作和自己的处理程序。这使我们能够做到以下几点：
- en: Delegate the action handler to a different Goroutine
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将动作处理程序委托给不同的Goroutine
- en: Stack many asynchronous calls between them (an asynchronous call that calls
    another asynchronous call in its results)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在它们之间堆叠许多异步调用（一个异步调用在其结果中调用另一个异步调用）
- en: A simple asynchronous requester
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的异步请求者
- en: We are going to develop a very simple example to try to understand how a Future
    works. In this example, we will have a method that returns a string or an error,
    but we want to execute it concurrently. We have learned ways to do this already.
    Using a channel, we can launch a new Goroutine and handle the incoming result
    from the channel.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个非常简单的示例来尝试理解Future的工作原理。在这个示例中，我们将有一个返回字符串或错误的方法，但我们希望并发执行它。我们已经学会了如何做到这一点。使用通道，我们可以启动一个新的Goroutine，并处理来自通道的传入结果。
- en: But in this case, we will have to handle the result (string or error), and we
    don't want this. Instead, we will define what to do in case of success and what
    to do in case of error and fire-and-forget the Goroutine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种情况下，我们将不得不处理结果（字符串或错误），而我们不希望这样做。相反，我们将定义成功时要执行的操作，以及出现错误时要执行的操作，并且忘记 Goroutine。
- en: Acceptance criteria
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'We don''t have functional requirements for this task. Instead, we will have
    technical requirements for it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们没有功能性需求。相反，我们将对其进行技术要求：
- en: Delegate the function execution to a different Goroutine
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数执行委托给不同的 Goroutine
- en: The function will return a string (maybe) or an error
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数将返回一个字符串（也许）或一个错误
- en: The handlers must be already defined before executing the function
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序必须在执行函数之前已经定义好
- en: The design must be reusable
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计必须是可重用的
- en: Unit tests
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'So, as we mentioned, we will use first class functions to achieve this behavior,
    and we will need three specific types of function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如我们提到的，我们将使用一等函数来实现这种行为，我们将需要三种特定类型的函数：
- en: '`type SuccessFunc func(string)`: The `SuccessFunc` function will be executed
    if everything went well. Its string argument will be the result of the operation,
    so this function will be called by our Goroutine.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type SuccessFunc func(string)`: 如果一切顺利，`SuccessFunc` 函数将被执行。它的字符串参数将是操作的结果，因此我们的
    Goroutine 将调用这个函数。'
- en: '`type FailFunc func(error)`: The `FailFunc` function handles the opposite result,
    that is, when something goes wrong, and, as you can see, it will return an error.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type FailFunc func(error)`: `FailFunc` 函数处理相反的结果，也就是当出现问题时，正如你所见，它会返回一个错误。'
- en: '`type ExecuteStringFunc func() (string, error)`: Finally, the `ExecuteStringFunc` function
    is a type that defines the operation we want to perform. Maybe it will return
    a string or an error. Don''t worry if this all seems confusing; it will be clearer
    later.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type ExecuteStringFunc func() (string, error)`: 最后，`ExecuteStringFunc` 函数是一个类型，定义了我们想要执行的操作。也许它会返回一个字符串或一个错误。如果这一切看起来令人困惑，不要担心；稍后会更清楚。'
- en: 'So, we create the `future` object, we define a success behavior, we define
    a fail behavior, and we pass an `ExecuteStringFunc` type to be executed. In the
    implementation file, we''ll need a new type:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了 `future` 对象，定义了成功的行为，定义了失败的行为，并传递了一个要执行的 `ExecuteStringFunc` 类型。在实现文件中，我们需要一个新类型：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will also create two tests in the `_test.go` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在 `_test.go` 文件中创建两个测试：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will define functions by chaining them, as you would usually see in Node.js.
    Code like this is compact and not particularly difficult to follow:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过链接定义函数，就像你通常在 Node.js 中看到的那样。这样的代码紧凑而且不难跟踪：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `future.Success` function must be defined in the `MaybeString` structure
    to accept a `SuccessFunc` function that will be executed if everything goes correctly
    and return the same pointer to the `future` object (so we can keep chaining).
    The `Fail` function must also be defined in the `MaybeString` structure and must
    accept a `FailFunc` function to later return the pointer. We return the pointer
    in both cases so we can define the `Fail` and the `Success` or vice versa.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`future.Success` 函数必须在 `MaybeString` 结构中定义，以接受一个 `SuccessFunc` 函数，如果一切正常则执行，并返回相同指针给
    `future` 对象（这样我们就可以继续链式调用）。`Fail` 函数也必须在 `MaybeString` 结构中定义，并且必须接受一个 `FailFunc`
    函数，然后返回指针。我们在两种情况下都返回指针，这样我们就可以定义 `Fail` 和 `Success` 或者反之亦然。'
- en: Finally, we use the `Execute` method to pass an `ExecuteStringFunc` type (a
    function that accepts nothing and returns a string or an error). In this case,
    we return a string and nil, so we expect that the `SuccessFunc` function will
    be executed and we log the result to the console. In case that fail function is
    executed, the test has failed because the `FailFunc` function shouldn't be executed
    for a returned nil error.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `Execute` 方法传递一个 `ExecuteStringFunc` 类型（一个接受空参数并返回一个字符串或一个错误的函数）。在这种情况下，我们返回一个字符串和
    nil，所以我们期望 `SuccessFunc` 函数将被执行，并且我们将结果记录到控制台。如果执行了失败函数，那么测试就失败了，因为不应该为返回的 nil
    错误执行 `FailFunc` 函数。
- en: 'But we still lack something here. We said that the function must be executed
    asynchronously in a different Goroutine, so we have to synchronize this test somehow
    so that it doesn''t finish too soon. Again, we can use a channel or a `sync.WaitGroup`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还缺少一些东西。我们说过函数必须在不同的 Goroutine 中异步执行，所以我们必须以某种方式同步这个测试，以防它结束得太快。同样，我们可以使用一个通道或
    `sync.WaitGroup`：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have seen WaitGroups before in the previous channel. This WaitGroup is configured
    to wait for one signal (`wg.Add(1)`). The `Success` and `Fail` methods will trigger
    the `Done()` method of the `WaitGroup` to allow execution to continue and finish
    testing (that is why the `Wait()` method is at the end). Remember that each `Done()`
    method will subtract one from the WaitGroup, and we have added only one, so our
    `Wait()` method will only block until one `Done()` method is executed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在之前的频道中见过 WaitGroups。这个 WaitGroup 被配置为等待一个信号（`wg.Add(1)`）。`Success` 和 `Fail`
    方法将触发 `WaitGroup` 的 `Done()` 方法，以允许执行继续并完成测试（这就是为什么 `Wait()` 方法在最后）。记住，每个 `Done()`
    方法都会从 WaitGroup 中减去一个，而我们只添加了一个，所以我们的 `Wait()` 方法只会阻塞，直到一个 `Done()` 方法被执行。
- en: 'Using what we know of making a `Success` result unit test, it''s easy to make
    a Failed result unit test by swapping the `t.Fail()` method call from the error
    to success so that the test fails if a call to success is done:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们对制作 `Success` 结果单元测试的了解，通过将错误调用 `t.Fail()` 方法从错误调用成功调用中交换，很容易制作一个失败的结果单元测试，这样如果调用成功，则测试失败：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you are using an IDE like me, your `Success`, `Fail`, and `Execute` method
    calls must be in red. This is because we lack our method''s declaration in the
    implementation file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样使用 IDE，你的 `Success`、`Fail` 和 `Execute` 方法调用必须是红色的。这是因为我们在实现文件中缺少了方法的声明：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our test seems ready to execute. Let''s try it out:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试似乎已经准备好执行了。让我们试一下：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Well... the tests have failed, yes... but not in a controllable way. Why is
    this? We don't have any implementation yet, so no `Success` or `Fail` functions
    are being executed either. Our WaitGroup is waiting forever for a call to the `Done()`
    method that will never arrive, so it can't continue and finish the test. That's
    the meaning of *All Goroutines are asleep - deadlock!*. In our specific example,
    it would mean *Nobody is going to call Done(), so we are dead!*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯... 测试失败了，是的... 但不是以可控的方式。为什么呢？因为我们还没有任何实现，所以`Success`或`Fail`函数也没有被执行。我们的WaitGroup永远在等待调用`Done()`方法，但这个调用永远不会到来，所以它无法继续并完成测试。这就是*所有Goroutines都在休眠-死锁*的含义。在我们的具体例子中，这意味着*没有人会调用Done()，所以我们已经死了*。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Thanks to the Go compiler and the runtime executor, we can detect deadlocks
    easily. Imagine if Go runtime couldn't detect deadlocks--we would be effectively
    stuck in a blank screen without knowing what was wrong.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go编译器和运行时执行器，我们可以轻松地检测死锁。想象一下，如果Go运行时无法检测死锁，我们将陷入一片空白的屏幕中，不知道出了什么问题。
- en: So how can we solve this? Well, an easy way would be with a timeout that calls
    the `Done()` method after waiting a while for completion. For this code, it's
    safe to wait for 1 second because it's not doing long-running operations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们该如何解决这个问题呢？嗯，一个简单的方法是使用超时，在等待一段时间后调用`Done()`方法。对于这段代码来说，等待1秒是安全的，因为它不执行长时间运行的操作。
- en: 'We will declare a `timeout` function within our `test` file that waits for
    a second, then prints a message, sets the test as failed, and lets the WaitGroup
    continue by calling its `Done()` method:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的`test`文件中声明一个`timeout`函数，等待一秒，然后打印一条消息，将测试设置为失败，并通过调用其`Done()`方法让WaitGroup继续：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The final look of each subtest is similar to our previous example of the `"Success
    result"`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子测试的最终外观与我们之前的`"Success result"`示例类似：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s see what happens when we execute our tests again:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们再次执行测试时会发生什么：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our tests failed, but in a controlled way. Look at the end of the `FAIL` lines--notice
    how the elapsed time is 1 second because it has been triggered by the timeout,
    as we can see in the logging messages.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试失败了，但是以一种可控的方式。看一下`FAIL`行的末尾--注意经过的时间是1秒，因为它被超时触发了，正如我们在日志消息中所看到的。
- en: It's time to pass to the implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候转向实现了。
- en: Implementation
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: According to our tests, the implementation must take a `SuccessFunc`, a `FailFunc`,
    and an `ExecuteStringFunc` function in a chained fashion within the `MaybeString`
    type and launches the `ExecuteStringFunc` function asynchronously to call `SuccessFunc`
    or `FailFunc` functions according to the returned result of the `ExecuteStringFunc`
    function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的测试，实现必须以链式方式在`MaybeString`类型中接受`SuccessFunc`、`FailFunc`和`ExecuteStringFunc`函数，并异步调用`ExecuteStringFunc`函数，根据返回的结果调用`SuccessFunc`或`FailFunc`函数。
- en: 'The chain is implemented by storing the functions within the type and returning
    the pointer to the type. We are talking about our previously declared type methods,
    of course:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 链式调用是通过在类型中存储函数并返回类型的指针来实现的。当然，我们谈论的是我们之前声明的类型方法：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We needed two fields to store the `SuccessFunc` and `FailFunc` functions, which
    are named the `successFunc` and `failFunc` fields respectively. This way, calls
    to the `Success` and `Fail` methods simply store their incoming functions to our
    new fields. They are simply setters that also return the pointer to the specific
    `MaybeString` value. These type methods take a pointer to the `MaybeString` structure,
    so don't forget to put "`*`" on `MaybeString` after the `func` declaration.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个字段来存储`SuccessFunc`和`FailFunc`函数，它们分别被命名为`successFunc`和`failFunc`字段。这样，对`Success`和`Fail`方法的调用只是将它们的传入函数存储到我们的新字段中。它们只是返回特定`MaybeString`值的指针的设置器。这些类型方法接受`MaybeString`结构的指针，所以在`func`声明之后不要忘记在`MaybeString`上加上"`*`"。
- en: Execute takes the `ExecuteStringFunc` method and executes it asynchronously.
    This seems quite simple with a Goroutine, right?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Execute方法接受`ExecuteStringFunc`方法并异步执行它。这似乎很简单，使用Goroutine就可以了，对吧？
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Looks quite simple because it is simple! We launch the Goroutine that executes
    the `f` method (an `ExecuteStringFunc`) and takes its result--maybe a string and
    maybe an error. If an error is present, we call the field `failFunc` in our `MaybeString`
    structure. If no error is present, we call the `successFunc` field. We use a Goroutine
    to delegate a function execution and error handling so our Goroutine doesn't have
    to do it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，因为它确实很简单！我们启动了执行`f`方法（一个`ExecuteStringFunc`）的Goroutine，并获取它的结果--可能是一个字符串，也可能是一个错误。如果存在错误，我们调用`MaybeString`结构中的`failFunc`字段。如果没有错误，我们调用`successFunc`字段。我们使用Goroutine来委托函数执行和错误处理，这样我们的Goroutine就不必自己处理它。
- en: 'Let''s run unit tests now:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行单元测试：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Great! Look how the execution time is now nearly zero, so our timeouts have
    not been executed (actually, they were executed, but the tests already finished
    and their result was already stated).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！看看执行时间现在几乎为零，所以我们的超时没有被执行（实际上，它们已经被执行了，但测试已经完成，它们的结果已经被说明）。
- en: What's more, now we can use our `MaybeString` type to asynchronously execute
    any type of function that accepts nothing and returns a string or an error. A
    function that accepts nothing seems a bit useless, right? But we can use closures
    to introduce a context into this type of function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，现在我们可以使用我们的`MaybeString`类型来异步执行任何接受空参数并返回字符串或错误的函数。接受空参数的函数似乎有点无用，对吧？但是我们可以使用闭包将上下文引入到这种类型的函数中。
- en: 'Let''s write a `setContext` function that takes a string as an argument and
    returns an `ExecuteStringFunc` method that returns the previous argument with
    the suffix `Closure!`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个`setContext`函数，它接受一个字符串作为参数，并返回一个`ExecuteStringFunc`方法，该方法返回前面的参数加上后缀`Closure!`：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So, we can write a new test that uses this closure:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以编写一个使用这个闭包的新测试：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `setContext` function returns an `ExecuteStringFunc` method it can pass
    directly to the `Execute` function. We call the `setContext` function with an
    arbitrary text that we know will be returned.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`setContext`函数返回一个`ExecuteStringFunc`方法，它可以直接传递给`Execute`函数。我们使用一个我们知道会返回的任意文本来调用`setContext`函数。'
- en: Let's execute our tests again. Now everything has to go well!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次执行我们的测试。现在一切都要顺利进行！
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It gave us an OK too. Closure test shows the behavior that we explained before.
    By taking a message `"Hello"` and appending it with something else (`"Closure!"`),
    we can change the context of the text we want to return. Now scale this to a HTTP
    `GET` call, a call to a database, or anything you can imagine. It will just need
    to end by returning a string or an error. Remember, however, that everything within
    the `setContext` function but outside of the anonymous function that we are returning
    is not concurrent, and will be executed asynchronously before calling execute,
    so we must try to put as much logic as possible within the anonymous function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它也给了我们一个OK。闭包测试显示了我们之前解释的行为。通过取一个消息`"Hello"`并将其附加到其他内容(`"Closure!"`)，我们可以改变我们想要返回的文本的上下文。现在将其扩展到HTTP
    `GET`调用，对数据库的调用，或者您可以想象的任何其他内容。它只需要以返回一个字符串或错误的方式结束。但是请记住，`setContext`函数中除了我们要返回的匿名函数之外的所有内容都不是并发的，并且在调用execute之前将异步执行，因此我们必须尽量将尽可能多的逻辑放在匿名函数中。
- en: Putting the Future together
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将未来放在一起
- en: We have seen a good way to achieve asynchronous programming by using a function
    type system. However, we could have done it without functions by setting an interface
    with `Success`, `Fail`, and `Execute` methods and the types that satisfy them,
    and using the Template pattern to execute them asynchronously, as we have previously
    seen in this chapter. It is up to you!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了通过使用函数类型系统来实现异步编程的好方法。然而，我们也可以通过设置一个具有`Success`、`Fail`和`Execute`方法以及满足它们的类型的接口来实现，然后使用模板模式来异步执行它们，正如我们在本章中之前看到的那样。这取决于你！
- en: Pipeline design pattern
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pipeline设计模式
- en: The third and final pattern we will see in this chapter is the Pipeline pattern.
    You will use this pattern heavily in your concurrent structures, and we can consider
    it one of the most useful too.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中看到的第三种模式是Pipeline模式。您将在并发结构中大量使用此模式，我们也可以认为它是最有用的模式之一。
- en: Description
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: 'We already know what a pipeline is. Every time that we write any function that
    performs some logic, we are writing a pipeline: If *this* then *that*, or else
    *something else*. Pipelines pattern can be made more complex by using a few functions
    that call to each other. They can even get looped in their out execution.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道了管道是什么。每当我们编写任何执行一些逻辑的函数时，我们都在编写一个管道：如果*这样*，那么*那样*，否则*其他*。通过使用一些相互调用的函数，管道模式可以变得更加复杂。它们甚至可以在它们的执行中被循环。
- en: The Pipeline pattern in Go works in a similar fashion, but each step in the
    Pipeline will be in a different Goroutine and communication, and synchronizing
    will be done using channels.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的Pipeline模式以类似的方式工作，但Pipeline中的每个步骤都将在不同的Goroutine中进行，并且使用通道进行通信和同步。
- en: Objectives
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'When creating a Pipeline, we are mainly looking for the following benefits:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Pipeline时，我们主要寻求以下好处：
- en: We can create a concurrent structure of a multistep algorithm
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个多步算法的并发结构
- en: We can exploit the parallelism of multicore machines by decomposing an algorithm
    in different Goroutines
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过将算法分解为不同的Goroutines来利用多核机器的并行性
- en: However, just because we decompose an algorithm in different Goroutines doesn't
    necessarily mean that it will execute the fastest. We are constantly talking about
    CPUs, so ideally the algorithm must be CPU-intensive to take advantage of a concurrent
    structure. The overhead of creating Goroutines and channels could make an algorithm
    smaller.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅因为我们将算法分解为不同的Goroutines并不一定意味着它会执行得最快。我们一直在谈论CPU，所以理想情况下，算法必须是CPU密集型的，以利用并发结构。创建Goroutines和通道的开销可能会使算法变得更小。
- en: A concurrent multi-operation
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发多操作
- en: We are going to do some math for our example. We are going to generate a list
    of numbers starting with 1 and ending at some arbitrary number N. Then we will
    take each number, power it to 2, and sum the resulting numbers to a unique result.
    So, if *N=3*, our list will be [1,2,3]. After powering them to 2, our list becomes
    [1,4,9]. If we sum the resulting list, the resulting value is 14.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的示例进行一些数学运算。我们将生成一个从1开始，以某个任意数字N结束的数字列表。然后我们将取每个数字，将其平方，并将结果数字求和到一个唯一的结果。因此，如果*N=3*，我们的列表将是[1,2,3]。将它们平方后，我们的列表变为[1,4,9]。如果我们对结果列表求和，得到的值是14。
- en: Acceptance criteria
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'Functionally speaking, our Pipeline pattern needs to raise to the power of
    2 every number and then sum them all. It will be divided into a number generator
    and two operations, so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，我们的Pipeline模式需要将每个数字提升到2的幂，然后将它们全部求和。它将被分为一个数字生成器和两个操作，因此：
- en: Generate a list from 1 to N where N can be any integer number.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从1到N生成一个列表，其中N可以是任何整数。
- en: Take each number of this generated list and raise it to the power of 2.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取出这个生成列表的每个数字并将其提升到2的幂。
- en: Sum each resulting number into a final result and return it.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个结果数字求和到最终结果并返回它。
- en: Beginning with tests
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从测试开始
- en: 'We will create only one function that will manage everything. We will call
    this function `LaunchPipeline` to simplify things. It will take an integer as
    an argument, which will be our N number, the number of items in our list. The
    declaration in the implementation file looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个管理一切的函数。我们将称这个函数为`LaunchPipeline`以简化事情。它将以一个整数作为参数，这将是我们的N数字，列表中的项目数。在实现文件中的声明如下：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In our test file, we will create a table of tests by using a slice of slices:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试文件中，我们将使用一个切片的切片创建一个测试表：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our table is a slice of slices of integer types. On each slice, the first integer
    represents the list size and the second position represents the item within the
    list. It is, effectively, a matrix. When passing 3, it must return 14\. When passing
    5, it must return 55\. Then we have to iterate over the table and pass the first
    index of each array to the `LaunchPipeline` function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表是一个整数类型的切片的切片。在每个切片上，第一个整数代表列表大小，第二个位置代表列表中的项。实际上，它是一个矩阵。当传入3时，它必须返回14。当传入5时，它必须返回55。然后，我们必须遍历表，并将每个数组的第一个索引传递给`LaunchPipeline`函数：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using `range`, we get every row in the matrix . Each row is contained in a
    temporary variable called `test`. `test[0]` represents `N` and `test[1]` the expected
    result. We compare the expected result with the returning value of the `LaunchPipeline`
    function. If they aren''t the same, the test fails:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`range`，我们得到矩阵中的每一行。每一行都包含在一个临时变量`test`中。`test[0]`代表`N`，`test[1]`代表预期结果。我们将预期结果与`LaunchPipeline`函数的返回值进行比较。如果它们不相同，测试就失败了。
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Implementation
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'The key for our implementation is to separate every operation in a different
    Goroutine and connect them with channels. The `LaunchPipeline` function is the
    one that orchestrates them all, as shown in the following diagram:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的关键是将每个操作分开放在不同的Goroutine中，并用通道连接它们。`LaunchPipeline`函数是协调它们所有的函数，如下图所示：
- en: '![Implementation](img/B05557_09_04.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Implementation](img/B05557_09_04.jpg)'
- en: 'The operation consist of three steps: generate a list of numbers, raise them
    to the power of 2, and add the resulting numbers.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作包括三个步骤：生成一个数字列表，将它们提升到2的幂，并将结果相加。
- en: 'Each step in this Pipeline pattern will have the following structure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道模式中的每一步都有以下结构：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This function represents a common step. Let''s dissect it in the same order
    that the Go scheduler will probably take to execute it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数代表一个常见的步骤。让我们按照Go调度程序可能执行它的顺序来分解它：
- en: The `functionName` function will commonly receive a channel to take values from
    (`in <-chan int`). We call it the `in` function, as in the word incoming. We can't
    send values through it within the scope of this function; that's why the arrow
    points `out` of the keyword `chan`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`functionName`函数通常会接收一个通道来获取值（`in <-chan int`）。我们称之为`in`函数，就像单词incoming一样。在这个函数的范围内，我们无法通过它发送值；这就是为什么箭头指向`chan`关键字的外部。'
- en: The `functionName` function returns a channel (`<-chan in`) that the function
    caller will only be allowed to take values from (again, represented by the arrow
    pointing `out` of the keyword `chan`). This also means that any value that goes
    through that channel must be generated within the scope of the function.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`functionName`函数返回一个通道（`<-chan in`），函数调用者只能从中获取值（同样，箭头指向`chan`关键字的外部）。这也意味着通过该通道传递的任何值都必须在函数范围内生成。'
- en: In the first line of the function, we create a channel called `out` that will
    be the return of the function (*point 2* in this list).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数的第一行，我们创建了一个名为`out`的通道，它将成为函数的返回值（*在这个列表中的第2个点*）。
- en: Then, we will launch a new Goroutine. Its scope will enter into play after returning
    this function, so let's continue.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将启动一个新的Goroutine。它的范围将在返回此函数后进入，所以让我们继续。
- en: We return the previously created `out` channel.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回先前创建的`out`通道。
- en: Eventually, after finishing the execution of the function and returning the
    channel `out`, the Goroutine executes. It will take values from the `in` channel
    until it's closed. So the caller of this function is responsible for closing this
    channel, otherwise the Goroutine will never end!
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，在执行函数并返回通道`out`之后，Goroutine执行。它将从`in`通道中获取值，直到通道关闭。因此，这个函数的调用者负责关闭这个通道，否则Goroutine将永远不会结束！
- en: When the `in` channel is closed, the for loop finishes and we close the `out`
    channel. Any Goroutine making use of this channel will not receive any new values
    since the last that was sent.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`in`通道关闭时，for循环结束，我们关闭`out`通道。任何使用这个通道的Goroutine都不会再接收到新值，因为最后一个值已经发送了。
- en: 'The only step that doesn''t completely fit this approach is the first step
    that receives a number, representing the upper threshold on the list instead of
    a channel of incoming values. So, if we code this operation for each step in our
    pipeline, the final diagram looks more like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一不完全符合这种方法的步骤是第一步，它接收一个数字，代表列表上限，而不是一个传入值的通道。因此，如果我们为管道中的每一步编写这个操作，最终的图表看起来更像这样：
- en: '![Implementation](img/B05557_09_05.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Implementation](img/B05557_09_05.jpg)'
- en: Although the idea is exactly the same, now we can see that it's the function
    `LaunchPipeline` that is the one that is going to be receiving channels and sending
    them back to the next step in the Pipeline. Using this diagram, we can clearly
    see the flow of the pipeline creation by following the numbers of the arrows.
    A solid arrow represents a function call and a dashed arrow a channel.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管想法完全相同，但现在我们可以看到，实际上是`LaunchPipeline`函数将接收通道并将它们发送回管道中的下一步。使用这个图表，我们可以清楚地看到通过跟随箭头的数字来创建管道的流程。实线箭头表示函数调用，虚线箭头表示通道。
- en: Let's look a little more closely at the code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下代码。
- en: The list generator
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表生成器
- en: 'The first step in the operation is list generation. The list starts at `1`
    and we will receive an integer representing the higher threshold. We have to pass
    each number in the list to the next step:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的第一步是列表生成。列表从`1`开始，我们将接收一个代表上限的整数。我们必须将列表中的每个数字传递到下一步：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As we mentioned earlier, this is the pattern that we will follow in each step:
    create a channel, launch the Goroutine that will send the data through the channel,
    and immediately return the channel. This Goroutine will iterate from 1 to the
    max argument, which is the higher threshold for our list, and send each number
    through the channel. After sending every number, the channel is closed so that
    no more data can be sent through it, but the data already buffered can be retrieved.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这是我们在每个步骤中遵循的模式：创建一个通道，启动通过通道发送数据的Goroutine，并立即返回通道。这个Goroutine将从1迭代到max参数，这是我们列表的最高阈值，并通过通道发送每个数字。在发送每个数字之后，通道被关闭，以便不能再通过它发送更多数据，但已经缓冲的数据可以被检索。
- en: Raising numbers to the power of 2
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数字提升到2的幂
- en: 'The second step will take every incoming number from the first step''s channel
    (that is taken from the arguments) and raise it to the power of 2\. Every result
    must be sent to the third step using a new channel:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步将从第一步的通道中接收每个传入的数字（从参数中获取）并将其提升到2的幂。每个结果都必须使用新的通道发送到第三步：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We use the same pattern again: create a channel and launch the Goroutine while
    we return the created channel.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用相同的模式：创建一个通道并启动Goroutine，同时返回创建的通道。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `for-range` loop keeps taking values from a channel indefinitely until the
    channel is closed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-range`循环不断地从通道中获取值，直到通道关闭。'
- en: Final reduce operation
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终的归约操作
- en: 'The third and final step receives every number from the second step and keeps
    adding them to a local value until the connection channel is closed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步也是最后一步，接收来自第二步的每个数字，并将它们添加到本地值，直到连接通道关闭：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The function sum also takes a channel as an argument (the one returned from
    *step 2*). It also follows the same pattern of creating a channel, launching the
    Goroutine, and returning a channel. Goroutine keeps adding values to a variable
    called `sum` until the `in` channel is closed. When the `in` channel is closed,
    the value of sum is sent to the `out` channel, and it's immediately closed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: sum函数还接受一个通道作为参数（从*步骤2*返回的通道）。它也遵循创建通道、启动Goroutine和返回通道的相同模式。Goroutine不断将值添加到一个名为`sum`的变量，直到`in`通道关闭。当`in`通道关闭时，sum的值被发送到`out`通道，并立即关闭。
- en: Launching the Pipeline pattern
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动管道模式
- en: 'Finally, we can implement the `LaunchPipeline` function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现`LaunchPipeline`函数：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The function `generator` first returns the channel that is passed to the power
    function. The `power` function returns the second channel that is passed to the `sum`
    function. The function `sum` finally returns the first channel that will receive
    a unique value, the result. Let''s try to test this now:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`generator`首先返回传递给power函数的通道。`power`函数返回传递给`sum`函数的第二个通道。函数`sum`最终返回将接收唯一值（结果）的第一个通道。现在让我们尝试测试一下：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Awesome! It''s worth mentioning that the `LaunchPipeline` function doesn''t
    need to allocate every channel, and can be rewritten like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！值得一提的是，`LaunchPipeline`函数不需要分配每个通道，并且可以重写如下：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The result of the `generator` function is passed directly to the `power` function
    and the result of `power` to `sum` functions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`generator`函数的结果直接传递给`power`函数，`power`的结果传递给`sum`函数。'
- en: Final words on the Pipeline pattern
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道模式的最后一句话
- en: With the Pipeline pattern, we can create really complex concurrent workflows
    in a very easy way. In our case, we created a linear workflow, but it could also
    have conditionals, pools, and fan-in and fan-out behavior. We will see some of
    these in the following chapter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道模式，我们可以以非常简单的方式创建非常复杂的并发工作流程。在我们的案例中，我们创建了一个线性工作流，但它也可以有条件、池和扇入和扇出行为。我们将在接下来的章节中看到其中一些。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Concurrency design patterns are a step forward in difficulty, and take some
    time to grasp. Our biggest mistake as concurrent programmers is thinking in terms
    of parallelism (How can I make this parallel? or How can I run this in a new thread?)
    instead of in terms of concurrent structures.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 并发设计模式是难度上的一大步，并需要一些时间来掌握。作为并发程序员，我们最大的错误是以并行性的方式思考（我怎样才能并行？或者我怎样才能在一个新线程中运行？），而不是以并发结构的方式思考。
- en: Pure functions (functions that will always produce the same output (given the
    same input) without affecting anything outside their scope) help in this design.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数（在其范围之外不会影响任何东西的函数，将始终产生相同的输出（给定相同的输入））对此设计有所帮助。
- en: Concurrent programming requires practice and more practice. Go makes it easy
    once you understand the basic primitives. Diagrams can help you to understand
    the possible flow of data, but the best way of understanding it all is simply
    to practice.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程需要练习和更多的练习。一旦你理解了基本的原语，Go就会变得很容易。图表可以帮助你理解数据的可能流动，但理解一切的最好方法就是简单地练习。
- en: In the following chapter, we will see how to use a pool of pipeline workers
    to do some work instead of having a unique pipeline. Also, we will learn how to
    create the publish/subscriber pattern in a concurrent structure and see how different
    the same pattern can be when we build by using concurrency.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何使用管道工作池来执行一些工作，而不是使用唯一的管道。此外，我们将学习如何在并发结构中创建发布/订阅模式，并看到在使用并发构建相同模式时，相同模式可以有多大的不同。
