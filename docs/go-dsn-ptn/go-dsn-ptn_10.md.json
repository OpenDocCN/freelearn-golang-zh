["```go\n   // workers_pipeline.go file \n    type Request struct { \n          Data    interface{} \n          Handler RequestHandler \n    } \n\n```", "```go\ntype RequestHandler func(interface{}) \n\n```", "```go\nfunc NewStringRequest(s string, id int, wg *sync.WaitGroup) Request { \n    myRequest := Request{ \n        Data: \"Hello\", Handler: func(i interface{})\n        { \n            defer wg.Done() \n            s, ok := i.(string) \n                if !ok{ \n                    log.Fatal(\"Invalid casting to string\") \n                 } \n             fmt.Println(s) \n         } \n    } \n} \n\n```", "```go\n   // worker.go file \n    type WorkerLauncher interface { \n        LaunchWorker(in chan Request) \n    } \n\n```", "```go\n   // dispatcher.go file \n    type Dispatcher interface { \n        LaunchWorker(w WorkerLauncher) \n        MakeRequest(Request) \n        Stop() \n    } \n\n```", "```go\n    type dispatcher struct { \n        inCh chan Request \n    } \n\n```", "```go\n    func (d *dispatcher) LaunchWorker(id int, w WorkerLauncher) { \n        w.LaunchWorker(d.inCh) \n    } \n\n    func (d *dispatcher) Stop(){ \n        close(d.inCh) \n    } \n\n    func (d *dispatcher) MakeRequest(r Request) { \n        d.inCh <- r \n    } \n\n```", "```go\n    func (d *dispatcher) MakeRequest(r Request) { \n        select { \n        case d.inCh <- r: \n        case <-time.After(time.Second * 5): \n            return \n        } \n    } \n\n```", "```go\n    func NewDispatcher(b int) Dispatcher { \n        return &dispatcher{ \n            inCh:make(chan Request, b), \n        } \n    } \n\n```", "```go\n   // worker.go file \n    type PreffixSuffixWorker struct { \n        id int \n        prefixS string \n        suffixS string \n    } \n\n    func (w *PreffixSuffixWorker) LaunchWorker(i int, in chan Request) {} \n\n```", "```go\n    func (w *PreffixSuffixWorker) uppercase(in <-chan Request) <-chan Request { \n        out := make(chan Request) \n\n        go func() { \n            for msg := range in { \n                s, ok := msg.Data.(string) \n\n                if !ok { \n                    msg.handler(nil) \n                    continue \n                } \n\n                msg.Data = strings.ToUpper(s) \n\n                out <- msg \n            } \n\n            close(out) \n        }() \n\n        return out \n    } \n\n```", "```go\nfunc (w *PreffixSuffixWorker) append(in <-chan Request) <-chan Request { \n    out := make(chan Request) \n    go func() { \n        for msg := range in { \n        uppercaseString, ok := msg.Data.(string) \n\n        if !ok { \n            msg.handler(nil) \n            continue \n            } \n        msg.Data = fmt.Sprintf(\"%s%s\", uppercaseString, w.suffixS) \n        out <- msg \n        } \n        close(out) \n    }() \n    return out \n} \n\n```", "```go\n    func (w *PreffixSuffixWorker) prefix(in <-chan Request) { \n        go func() { \n            for msg := range in { \n                uppercasedStringWithSuffix, ok := msg.Data.(string) \n\n                if !ok { \n                    msg.handler(nil) \n                    continue \n                } \n\n                msg.handler(fmt.Sprintf(\"%s%s\", w.prefixS, uppercasedStringWithSuffix)) \n            } \n        }() \n    } \n\n```", "```go\n    func (w *PreffixSuffixWorker) LaunchWorker(in chan Request) { \n        w.prefix(w.append(w.uppercase(in))) \n    } \n\n```", "```go\n   // workers_pipeline.go \n    func main() { \n        bufferSize := 100 \n        var dispatcher Dispatcher = NewDispatcher(bufferSize) \n\n```", "```go\n    workers := 3 \n    for i := 0; i < workers; i++ { \n        var w WorkerLauncher = &PreffixSuffixWorker{ \n            prefixS: fmt.Sprintf(\"WorkerID: %d -> \", i), \n            suffixS: \" World\", \n            id:i, \n        } \n        dispatcher.LaunchWorker(w) \n    } \n\n```", "```go\n    requests := 10 \n\n    var wg sync.WaitGroup \n    wg.Add(requests) \n\n```", "```go\n    for i := 0; i < requests; i++ { \n        req := NewStringRequest(\"(Msg_id: %d) -> Hello\", i, &wg) \n        dispatcher.MakeRequest(req) \n    } \n\n    dispatcher.Stop() \n\n    wg.Wait() \n}\n```", "```go\n go run *\n WorkerID: 1 -> (MSG_ID: 0) -> HELLO World\n WorkerID: 0 -> (MSG_ID: 3) -> HELLO World\n WorkerID: 0 -> (MSG_ID: 4) -> HELLO World\n WorkerID: 0 -> (MSG_ID: 5) -> HELLO World\n WorkerID: 2 -> (MSG_ID: 2) -> HELLO World\n WorkerID: 1 -> (MSG_ID: 1) -> HELLO World\n WorkerID: 0 -> (MSG_ID: 6) -> HELLO World\n WorkerID: 2 -> (MSG_ID: 9) -> HELLO World\n WorkerID: 0 -> (MSG_ID: 7) -> HELLO World\n WorkerID: 0 -> (MSG_ID: 8) -> HELLO World\n\n```", "```go\n//workers_pipeline.go file \npackage main \n\nimport \"testing\" \n\nfunc Test_Dispatcher(t *testing.T){ \n    //pasted code from main function \n bufferSize := 100\n var dispatcher Dispatcher = NewDispatcher(bufferSize)\n workers := 3\n for i := 0; i < workers; i++ \n    {\n var w WorkerLauncher = &PreffixSuffixWorker{\n prefixS: fmt.Sprintf(\"WorkerID: %d -> \", i), \nsuffixS: \" World\", \nid: i,\n}\n dispatcher.LaunchWorker(w)\n }\n //Simulate Requests\n requests := 10\n var wg \n    sync.WaitGroup\n wg.Add(requests) \n} \n\n```", "```go\nfor i := 0; i < requests; i++ { \n    req := Request{ \n        Data: fmt.Sprintf(\"(Msg_id: %d) -> Hello\", i), \n        handler: func(i interface{}) \n        { \n            s, ok := i.(string) \n            defer wg.Done() \n if !ok \n            {\n t.Fail()\n }\n ok, err := regexp.Match(\n`WorkerID\\: \\d* -\\> \\(MSG_ID: \\d*\\) -> [A-Z]*\\sWorld`,\n []byte(s)) \n if !ok || err != nil {\n t.Fail()\n } \n        }, \n    } \n    dispatcher.MakeRequest(req) \n} \n\n```", "```go\ngo test -v .\n=== RUN   Test_Dispatcher\n--- PASS: Test_Dispatcher (0.00s)\nPASS\nok\n\n```", "```go\n    type Subscriber interface { \n        Notify(interface{}) error \n        Close() \n    } \n\n```", "```go\n    type Publisher interface { \n        start() \n        AddSubscriberCh() chan<- Subscriber \n        RemoveSubscriberCh() chan<- Subscriber \n        PublishingCh() chan<- interface{} \n        Stop() \n    } \n\n```", "```go\n    // writer_sub.go file \n    package main \n\n    import \"errors\" \n\n    type writerSubscriber struct { \n        id int \n        Writer io.Writer \n    } \n\n    func (s *writerSubscriber) Notify(msg interface{}) error { \n        return erorrs.NeW(\"Not implemented yet\") \n    } \n    func (s *writerSubscriber) Close() {} \n\n```", "```go\n    package main \n    func TestStdoutPrinter(t *testing.T) { \n\n```", "```go\n    func TestWriter(t *testing.T) { \n        sub := NewWriterSubscriber(0, nil) \n\n```", "```go\n    func NewWriterSubscriber(id int, out io.Writer) Subscriber { \n        return &writerSubscriber{} \n    } \n\n```", "```go\n    type mockWriter struct { \n        testingFunc func(string) \n    } \n\n    func (m *mockWriter) Write(p []byte) (n int, err error) { \n        m.testingFunc(string(p)) \n        return len(p), nil \n    } \n\n```", "```go\n    // writer_sub_test.go file \n    func TestPublisher(t *testing.T) { \n        msg := \"Hello\" \n\n        var wg sync.WaitGroup \n        wg.Add(1) \n\n        stdoutPrinter := sub.(*writerSubscriber) \n        stdoutPrinter.Writer = &mockWriter{ \n            testingFunc: func(res string) { \n                if !strings.Contains(res, msg) { \n                    t.Fatal(fmt.Errorf(\"Incorrect string: %s\", res)) \n                } \n                wg.Done() \n            }, \n        } \n\n```", "```go\nerr := sub.Notify(msg) \nif err != nil { \n    t.Fatal(err) \n    } \n\n    wg.Wait() \n    sub.Close() \n} \n\n```", "```go\ngo test -cover -v -run=TestWriter .\n=== RUN   TestWriter\n--- FAIL: TestWriter (0.00s)\n writer_sub_test.go:40: Not implemented yet\nFAIL\ncoverage: 6.7% of statements\nexit status 1\nFAIL\n\n```", "```go\nerr := sub.Notify(msg)\nif err != nil {\n wg.Done()\nt.Error(err)\n }\n wg.Wait()\nsub.Close()\n } \n\n```", "```go\n    // publisher.go type \n    type publisher struct { \n        subscribers []Subscriber \n    } \n\n```", "```go\n    // publisher_test.go \n    type mockSubscriber struct { \n        notifyTestingFunc func(msg interface{}) \n        closeTestingFunc func() \n    } \n\n    func (m *mockSubscriber) Close() { \n        m.closeTestingFunc() \n    } \n\n    func (m *mockSubscriber) Notify(msg interface{}) error { \n        m.notifyTestingFunc(msg) \n        return nil \n    } \n\n```", "```go\n    func TestPublisher(t *testing.T) { \n        msg := \"Hello\" \n\n        p := NewPublisher() \n\n```", "```go\n   // publisher.go file \n    func NewPublisher() Publisher { \n        return &publisher{} \n    } \n\n```", "```go\n        var wg sync.WaitGroup \n\n        sub := &mockSubscriber{ \n            notifyTestingFunc: func(msg interface{}) { \n                defer wg.Done() \n\n                s, ok := msg.(string) \n                if !ok { \n                    t.Fatal(errors.New(\"Could not assert result\")) \n                } \n\n                if s != msg { \n                    t.Fail() \n                } \n            }, \n            closeTestingFunc: func() { \n                wg.Done() \n            }, \n        } \n\n```", "```go\n        p.AddSubscriberCh() <- sub \n        wg.Add(1) \n\n        p.PublishingCh() <- msg \n        wg.Wait() \n\n```", "```go\n        pubCon := p.(*publisher) \n        if len(pubCon.subscribers) != 1 { \n            t.Error(\"Unexpected number of subscribers\") \n        } \n\n```", "```go\n   wg.Add(1) \n   p.RemoveSubscriberCh() <- sub \n   wg.Wait() \n\n   //Number of subscribers is restored to zero \n   if len(pubCon.subscribers) != 0 { \n         t.Error(\"Expected no subscribers\") \n   } \n\n   p.Stop() \n}  \n\n```", "```go\n    type publisher struct { \n        subscribers []Subscriber \n        addSubCh    chan Subscriber \n        removeSubCh chan Subscriber \n        in          chan interface{} \n        stop        chan struct{} \n    } \n\n    func (p *publisher) AddSubscriberCh() chan<- Subscriber { \n        return nil \n    } \n\n    func (p *publisher) RemoveSubscriberCh() chan<- Subscriber { \n        return nil \n    } \n\n    func (p *publisher) PublishingCh() chan<- interface{} { \n        return nil \n    } \n\n    func (p *publisher) Stop(){} \n\n```", "```go\ngo test -cover -v -run=TestPublisher .\natal error: all goroutines are asleep - deadlock!\ngoroutine 1 [chan receive]:\ntesting.(*T).Run(0xc0420780c0, 0x5244c6, 0xd, 0x5335a0, 0xc042037d20)\n /usr/local/go/src/testing/testing.go:647 +0x31d\ntesting.RunTests.func1(0xc0420780c0)\n /usr/local/go/src/testing/testing.go:793 +0x74\ntesting.tRunner(0xc0420780c0, 0xc042037e10)\n /usr/local/go/src/testing/testing.go:610 +0x88\ntesting.RunTests(0x5335b8, 0x5ada40, 0x2, 0x2, 0x40d7e9)\n /usr/local/go/src/testing/testing.go:799 +0x2fc\ntesting.(*M).Run(0xc042037ed8, 0xc04200a4f0)\n /usr/local/go/src/testing/testing.go:743 +0x8c\nmain.main()\n go-design-patterns/concurrency_3/pubsub/_test/_testmain.go:56 +0xcd\ngoroutine 5 [chan send (nil chan)]:\ngo-design-patterns/concurrency_3/pubsub.TestPublisher(0xc042078180)\n go-design-patterns/concurrency_3/pubsub/publisher_test.go:55 +0x372\ntesting.tRunner(0xc042078180, 0x5335a0)\n /usr/local/go/src/testing/testing.go:610 +0x88\ncreated by testing.(*T).Run\n /usr/local/go/src/testing/testing.go:646 +0x2f3\nexit status 2\nFAIL  go-design-patterns/concurrency_3/pubsub   1.587s\n\n```", "```go\n    type writerSubscriber struct { \n        in     chan interface{} \n        id     int \n        Writer io.Writer \n    } \n\n    func NewWriterSubscriber(id int, out io.Writer) Subscriber { \n        if out == nil { \n            out = os.Stdout \n        } \n\n        s := &writerSubscriber{ \n            id:     id, \n            in:     make(chan interface{}), \n            Writer: out, \n        } \n\n        go func(){ \n            for msg := range s.in { \n                fmt.Fprintf(s.Writer, \"(W%d): %v\\n\", s.id, msg) \n            } \n        }() \n\n        return s \n    } \n\n```", "```go\n    func (s *writerSubscriber) Close() { \n        close(s.in) \n    } \n\n```", "```go\n    func (s *writerSubscriber) Notify(msg interface{}) (err error) { \n        defer func(){ \n            if rec := recover(); rec != nil { \n                err = fmt.Errorf(\"%#v\", rec) \n            } \n        }() \n\n        select { \n        case s.in <- msg: \n        case <-time.After(time.Second): \n            err = fmt.Errorf(\"Timeout\\n\") \n        } \n\n        return \n    } \n\n```", "```go\ngo test -run=TestWriter -v .\n=== RUN   TestWriter\n--- PASS: TestWriter (0.00s)\nPASS\nok\n\n```", "```go\n    type publisher struct { \n        subscribers []Subscriber \n        addSubCh    chan Subscriber \n        removeSubCh chan Subscriber \n        in          chan interface{} \n        stop        chan struct{} \n    } \n\n```", "```go\n    func (p *publisher) AddSubscriber() { \n        return p.addSubCh \n    } \n\n    func (p *publisher) RemoveSubscriberCh() { \n        return p.removeSubCh \n    } \n\n    func (p *publisher) PublishMessage(){ \n        return p.in \n    } \n\n```", "```go\nfunc (p *publisher) Stop(){ \n  close(p.stop) \n} \n\n```", "```go\nfunc (p *publisher) start() { \n  for { \n    select { \n    case msg := <-p.in: \n      for _, ch := range p.subscribers { \n        sub.Notify(msg) \n      } \n\n```", "```go\n    case sub := <-p.addSubCh: \n    p.subscribers = append(p.subscribers, sub) \n\n```", "```go\n     case sub := <-p.removeSubCh: \n     for i, candidate := range p.subscribers { \n         if candidate == sub { \n             p.subscribers = append(p.subscribers[:i], p.subscribers[i+1:]...) \n             candidate.Close() \n             break \n        } \n    } \n\n```", "```go\n    case <-p.stop: \n    for _, sub := range p.subscribers { \n        sub.Close() \n            } \n\n        close(p.addSubCh) \n        close(p.in) \n        close(p.removeSubCh) \n\n        return \n        } \n    } \n} \n\n```", "```go\ngo test -race .\nok\n\n```"]