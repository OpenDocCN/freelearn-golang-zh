- en: Chapter 10. Concurrency Patterns - Workers Pool and Publish/Subscriber Design
    Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。并发模式 - 工作者池和发布/订阅设计模式
- en: We have reached the final chapter of the book, where we will discuss a couple
    of patterns with concurrent structures. We will explain every step in detail so
    you can follow the examples carefully.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了本书的最后一章，在这里我们将讨论一些具有并发结构的模式。我们将详细解释每一步，以便您可以仔细跟随示例。
- en: The idea is to learn about patterns to design concurrent applications in idiomatic
    Go. We are using channels and Goroutines heavily, instead of locks or sharing
    variables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是学习如何在Go中设计并发应用程序的模式。我们大量使用通道和Goroutines，而不是锁或共享变量。
- en: We will look at one way to develop a pool of workers. This is useful to control
    the number of Goroutines in an execution.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将看一种开发工作者池的方法。这对于控制执行中的Goroutines数量非常有用。
- en: The second example is a rewrite of the Observer pattern, which we saw on [Chapter
    7](ch07.html "Chapter 7. Behavioral Patterns - Visitor, State, Mediator, and Observer
    Design Patterns"), *Behavioral Patterns - Visitor, State, Mediator, and Observer
    Design Patterns*, written with a concurrent structure. With this example we'll
    dig a bit more into the concurrent structures and look at how they can differ
    from a common approach.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个例子是对观察者模式的重写，我们在[第7章](ch07.html "第7章。行为模式 - 访问者、状态、中介者和观察者设计模式")中看到了，*行为模式
    - 访问者、状态、中介者和观察者设计模式*，使用并发结构编写。通过这个例子，我们将更深入地了解并发结构，并看看它们与常规方法有何不同。
- en: Workers pool
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作者池
- en: One problem we may face with some of the previous approaches to concurrency
    is their unbounded context. We cannot let an app create  an unlimited amount of
    Goroutines. Goroutines are light, but the work they perform could be very heavy.
    A workers pool helps us to solve this problem.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到的一个问题是，以前的一些并发方法的上下文是无限的。我们不能让一个应用程序创建无限数量的Goroutines。Goroutines很轻，但它们执行的工作可能非常繁重。工作者池帮助我们解决了这个问题。
- en: Description
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: With a pool of workers, we want to bound the amount of Goroutines available
    so that we have a deeper control of the pool of resources. This is easy to achieve
    by creating a channel for each worker and having workers with either an idle or
    busy status. The task can seem daunting, but it's not at all.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一组工作者，我们希望限制可用的Goroutines数量，以便更深入地控制资源池。通过为每个工作者创建一个通道，并使工作者处于空闲或繁忙状态，这很容易实现。这项任务可能看起来令人生畏，但实际上并不是。
- en: Objectives
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'Creating a Worker pool is all about resource control: CPU, RAM, time, connections,
    and so on. The workers pool design pattern helps us to do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个工作者池主要是关于资源控制：CPU、RAM、时间、连接等等。工作者池设计模式帮助我们做到以下几点：
- en: Control access to shared resources using quotas
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配额控制对共享资源的访问
- en: Create a limited amount of Goroutines per app
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个应用程序创建有限数量的Goroutines
- en: Provide more parallelism capabilities to other concurrent structures
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其他并发结构提供更多的并行能力
- en: A pool of pipelines
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一组管道
- en: In the previous chapter, we saw how to work with a pipeline. Now we will launch
    a bounded number of them so that the Go scheduler can try to process requests
    in parallel. The idea here is to control the number of Goroutines, stop them gracefully
    when the app has finished, and maximize parallelism using a concurrent structure
    without race conditions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用管道。现在我们将启动有限数量的管道，以便Go调度器可以尝试并行处理请求。这里的想法是控制Goroutines的数量，在应用程序完成时优雅地停止它们，并使用并发结构最大化并行性，而不会出现竞争条件。
- en: The pipeline we will use is similar to the one we used in the previous chapter,
    where we were generating numbers, raising them to the power of 2, and summing
    the final results. In this case, we are going to pass strings to which we will
    append and prefix data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的管道类似于我们在上一章中使用的管道，那里我们生成数字，将它们提升到2的幂，并求和最终结果。在这种情况下，我们将传递字符串，然后附加和前缀数据。
- en: Acceptance criteria
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'In business terms, we want something that tells us that, worker has processed
    a request, a predefined ending, and incoming data parsed to uppercase:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从业务角度来看，我们希望有一些东西告诉我们，工作者已经处理了一个请求，有一个预定义的结尾，并且传入的数据被解析为大写：
- en: When making a request with a string value (any), it must be uppercase.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用一个字符串值（任意）发出请求时，它必须是大写的。
- en: Once the string is uppercase, a predefined text must be appended to it. This
    text should not be uppercase.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦字符串变成大写，预定义的文本必须附加到它上面。这个文本不应该是大写的。
- en: With the previous result, the worker ID must be prefixed to the final string.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的结果，工作者ID必须添加到最终字符串的前缀。
- en: The resulting string must be passed to a predefined handler.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果字符串必须传递给预定义的处理程序。
- en: We haven't talked about how to do it technically, just what the business wants.
    With the entire description, we'll at least have workers, requests, and handlers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论如何在技术上实现，只是业务需求。通过整个描述，我们至少会有工作者、请求和处理程序。
- en: Implementation
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'The very beginning is a request type. According to the description, it must
    hold the string that will enter the pipeline as well as the handler function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始是一个请求类型。根据描述，它必须包含将进入管道的字符串以及处理程序函数：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Where is the `string`? We have a `Data` field of type `interface{}` so we can
    use it to pass a string. By using an interface, we can reuse this type for a `string`,
    an `int`, or a `struct` data type. The receiver is the one who must know how to
    deal with the incoming interface.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “字符串”在哪里？我们有一个“Data”字段，类型为“interface{}”，所以我们可以用它来传递一个字符串。通过使用接口，我们可以重用这种类型来传递一个“string”，一个“int”，或一个“struct”数据类型。接收者必须知道如何处理传入的接口。
- en: 'The `Handler` field has the type `Request` handler, which we haven''t defined
    yet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “处理程序”字段的类型是“请求”处理程序，我们还没有定义：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A request handler is any function that accepts an interface as its first argument,
    and returns nothing. Again, we see the `interface{}`, where we would usually see
    a string. This is one of the receivers we mentioned previously, which we'll need
    to cast the incoming result.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理程序是接受接口作为其第一个参数并返回空的任何函数。再次看到`interface{}`，在这里我们通常会看到一个字符串。这是我们之前提到的接收器之一，我们需要用它来转换传入的结果。
- en: 'So, when sending a request, we must fill it with some value in the `Data` field
    and implement a handler; for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当发送请求时，我们必须在`Data`字段中填充一些值并实现处理程序；例如：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The handler is defined by using a closure. We again check the type if the interface
    (and we defer the call to the `Done()` method at the end). In case of an improper
    interface, we simply print its contents and return. If the casting is OK, we also
    print them, but here is where we will usually do something with the result of
    the operation; we have to use type casting to retrieve the contents of the `interface{}`
    (which is a string). This must be done in every step in the pipeline, although
    it will introduce a bit of overhead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序是通过闭包定义的。我们再次检查接口的类型（并在最后推迟调用`Done()`方法）。如果接口不正确，我们只需打印其内容并返回。如果转换正确，我们也会打印它们，但这是我们通常会对操作结果做一些事情的地方；我们必须使用类型转换来检索`interface{}`的内容（这是一个字符串）。尽管这会引入一些开销，但这必须在管道的每一步中完成。
- en: 'Now we need a type that can handle `Request` types. Possible implementations
    are virtually infinite, so it is better to define an interface first:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个可以处理`Request`类型的类型。可能的实现方式几乎是无限的，因此最好先定义一个接口：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `WorkerLauncher` interface must implement only the `LaunchWorker(chan Request)`
    method. Any type that implements this interface will have to receive a channel
    of `Request` type to satisfy it. This channel of the `Request` type is the single
    entrance point to the pipeline.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkerLauncher`接口只需实现`LaunchWorker(chan Request)`方法。任何实现此接口的类型都必须接收一个`Request`类型的通道来满足它。这种类型的`Request`通道是管道的唯一入口点。'
- en: The dispatcher
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调度程序
- en: 'Now, to launch workers in parallel and handle all the possible incoming channels,
    we''ll need something like a dispatcher:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了并行启动工作程序并处理所有可能的传入通道，我们需要类似于调度程序的东西：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A `Dispatcher` interface can launch an injected `WorkerLaunchers` type in its
    own `LaunchWorker` method. The `Dispatcher` interface must use the `LaunchWorker`
    method of any of the `WorkerLauncher` types to initialize a pipeline. This way
    we can reuse the `Dispatcher` interface to launch many types of `WorkerLaunchers`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispatcher`接口可以在其自己的`LaunchWorker`方法中启动注入的`WorkerLaunchers`类型。`Dispatcher`接口必须使用任何`WorkerLauncher`类型的`LaunchWorker`方法来初始化管道。这样我们就可以重用`Dispatcher`接口来启动许多类型的`WorkerLaunchers`。'
- en: When using `MakeRequest(Request)`, the `Dispatcher` interface exposes a nice
    method to inject a new `Request` into the workers pool.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`MakeRequest(Request)`时，`Dispatcher`接口公开了一个很好的方法，可以将新的`Request`注入到工作池中。
- en: Finally, the user must call stop when all Goroutines must be finished. We must
    handle graceful shutdown in our apps, and we want to avoid Goroutine leaks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用户必须在所有Goroutines都完成时调用stop。我们必须在应用程序中处理优雅的关闭，并且我们希望避免Goroutine泄漏。
- en: 'We have enough interfaces, so let''s start with the dispatcher which is a bit
    less complicated:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有足够的接口，所以让我们从稍微不那么复杂的调度程序开始：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our `dispatcher` structure stores a channel of `Request` type in one of its
    fields. This is going to be the single point of entrance for requests in any pipeline.
    We said that it must implement three methods, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`dispatcher`结构在其字段中存储了一个`Request`类型的通道。这将是任何管道中请求的唯一入口点。我们说它必须实现三种方法，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the `Dispatcher` interface doesn't need to do anything special
    to itself before launching a worker, so the `LaunchWorker` method on the `Dispatcher`
    simply executes the `LaunchWorker` method of the incoming `WorkerLauncher,`which
    also has a `LaunchWorker` method to initiate itself. We have previously defined
    that a `WorkerLauncher` type needs at least an ID and a channel for incoming requests,
    so that's what we are passing through.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Dispatcher`接口在启动工作程序之前不需要对自身执行任何特殊操作，因此`Dispatcher`上的`LaunchWorker`方法只是执行传入`WorkerLauncher`的`LaunchWorker`方法，后者也有一个`LaunchWorker`方法来初始化自身。我们之前已经定义了`WorkerLauncher`类型至少需要一个ID和一个传入请求的通道，所以这就是我们传递的内容。
- en: It may seem unnecessary to implement the `LaunchWorker` method in the `Dispatcher`
    interface. In different scenarios, it could be interesting to save running worker
    IDs in the dispatcher to control which ones are up or down; the idea is to hide
    launching implementation details. In this case, the `Dispatcher` interface is
    merely acting as a Facade design pattern hiding some implementation details from
    the user.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Dispatcher`接口中实现`LaunchWorker`方法似乎是不必要的。在不同的场景中，保存运行中的工作程序ID在调度程序中控制哪些工作程序正在运行或关闭可能是有趣的；这个想法是隐藏启动实现细节。在这种情况下，`Dispatcher`接口只是作为一个Facade设计模式，隐藏了一些实现细节。
- en: The second method is `Stop`. It closes the incoming requests channel, provoking
    a chain reaction. We saw in the pipeline example that, when closing the incoming
    channel, each for-range loop within the Goroutines breaks and the Goroutine is
    also finished. In this case, when closing a shared channel, it will provoke the
    same reaction, but in every listening Goroutine, so all pipelines will be stopped.
    Cool, huh?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是`Stop`。它关闭了传入请求通道，引发了一连串的反应。我们在管道示例中看到，当关闭传入通道时，每个Goroutines中的for-range循环都会中断，并且Goroutine也会结束。在这种情况下，当关闭共享通道时，它会引发相同的反应，但是在每个监听Goroutine中，因此所有管道都将停止。酷，对吧？
- en: 'Request implementation is very simple; we just pass the request in the argument
    to the channel of incoming requests. The Goroutine will block there forever until
    the opposite end of the channel retrieves the request. Forever? That seems like
    a lot if something happens. We can introduce a timeout, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的实现非常简单；我们只需将请求作为参数传递给传入请求的通道。Goroutine将永远阻塞在那里，直到通道的另一端检索到请求。永远？如果发生了什么事情，这似乎很长。我们可以引入一个超时，如下所示：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you remember from previous chapters, we can use select to control which
    operation is performed over a channel. Like a `switch` case, just one operation
    can be executed. In this case, we have two different operations: sending and receiving.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得之前的章节，我们可以使用 select 来控制对通道的操作。就像 `switch` 语句一样，只能执行一个操作。在这种情况下，我们有两种不同的操作：发送和接收。
- en: The first case is a sending operation--try to send this, and it will block there
    until someone takes the value in the opposite side of the channel. Not a huge
    improvement, then. The second case is a receiving operation; it will be triggered
    after 5 seconds if the upper request can't be sent successfully, and the function
    will return. It would be very convenient to return an error here, but to make
    things simple, we will leave it empty
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况是发送操作——尝试发送这个，它将在那里阻塞，直到有人在通道的另一侧取走值。然后并没有太大的改进。第二种情况是接收操作；如果无法成功发送大写请求，它将在
    5 秒后触发，并返回。在这里返回错误会非常方便，但为了简单起见，我们将留空。
- en: 'Finally, in the dispatcher, for convenience, we will define a `Dispatcher`
    creator:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在调度程序中，为了方便起见，我们将定义一个 `Dispatcher` 创建者：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By using this function instead of creating the dispatcher manually, we can simply
    avoid small mistakes, such as forgetting to initialize the channel field. As you
    can see, the `b` argument refers to the buffer size in the channel.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个函数而不是手动创建调度程序，我们可以简单地避免小错误，比如忘记初始化通道字段。正如你所看到的，`b` 参数指的是通道中的缓冲区大小。
- en: The pipeline
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流水线
- en: 'So, our dispatcher is done and we need to develop the pipeline described in
    the acceptance criteria. First, we need a type to implement the `WorkerLauncher`
    type:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的调度程序已经完成，我们需要开发验收标准中描述的流水线。首先，我们需要一个类型来实现 `WorkerLauncher` 类型：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `PreffixSuffixWorker` variable stores an ID, a string to prefix, and another
    string to suffix the incoming data of the `Request` type. So, the values to prefix
    and append will be static in these fields, and we will take them from there.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreffixSuffixWorker` 变量存储一个 ID，一个要添加的字符串，以及 `Request` 类型的传入数据的另一个字符串。因此，要添加的值和后缀将在这些字段中是静态的，并且我们将从这里获取它们。'
- en: 'We will implement the `LaunchWorker` method later and begin with each step
    in the pipeline. According to *first acceptance criteria*, the incoming string
    must be uppercase. So, the uppercase method will be the first step in our pipeline:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后实现 `LaunchWorker` 方法，并从流水线的每一步开始。根据*第一个验收标准*，传入的字符串必须是大写。因此，大写方法将是我们流水线中的第一步：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Good. As in the previous chapter, a step in the pipeline accepts a channel of
    incoming data and returns a channel of the same type. It has a very similar approach
    to the examples we developed in the previous chapter. This time, though, we aren't
    using package functions, and uppercase is part of the `PreffixSuffixWorker` type
    and the incoming data is a `struct` instead of an `int`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。就像在前一章中一样，流水线中的一步接受传入数据的通道，并返回相同类型的通道。它的方法与我们在前一章中开发的示例非常相似。不过，这一次，我们没有使用包函数，大写是
    `PreffixSuffixWorker` 类型的一部分，传入的数据是一个 `struct` 而不是一个 `int`。
- en: The `msg` variable is a `Request` type and it will have a handler function and
    data in the form of an interface. The `Data` field should be a string, so we type
    cast it before using it. When type casting a value, we will receive the same value
    with the requested type and a `true` or `false` flag (represented by the `ok`
    variable). If the `ok` variable is `false`, the cast could not be done and we
    won't throw the value down the pipeline. We stop this `Request` here by sending
    a `nil` to the handler (which will also provoke a type-casting error).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg` 变量是一个 `Request` 类型，它将具有一个处理函数和一个接口形式的数据。`Data` 字段应该是一个字符串，所以我们在使用它之前对其进行类型转换。当对值进行类型转换时，我们将收到请求类型的相同值和一个
    `true` 或 `false` 标志（由 `ok` 变量表示）。如果 `ok` 变量为 `false`，则转换无法完成，我们将不会将该值传递到流水线中。我们通过向处理程序发送
    `nil` 来停止这个 `Request`（这也会引发类型转换错误）。'
- en: Once we have a nice string in the `s` variable, we can uppercase it and store
    it again in the `Data` field to send down the pipeline to the next step. Be aware
    that the value will be sent as an interface again, so the next step will need
    to cast it again. This is the downside of using this approach.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 `s` 变量中有一个好的字符串，我们就可以将其大写并再次存储在 `Data` 字段中，以便将其发送到流水线的下一步。请注意，该值将再次作为接口发送，因此下一步将需要再次对其进行转换。这是使用这种方法的缺点。
- en: 'With the first step done, let''s continue with the second. According to the
    *second acceptance criteria* now, a predefined text must be appended. This text
    is the one stored in the `suffixS` field:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步完成后，让我们继续进行第二步。根据*第二个验收标准*，现在必须添加预定义的文本。这个文本是存储在 `suffixS` 字段中的文本：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `append` function has the same structure as the `uppercase` function. It
    receives and returns a channel of incoming requests, and launches a new Goroutine
    that iterates over the incoming channel until it is closed. We need to type cast
    the incoming value, as mentioned previously.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 函数的结构与 `uppercase` 函数相同。它接收并返回一个传入请求的通道，并启动一个新的 Goroutine，该 Goroutine
    遍历传入的通道直到它关闭。我们需要对传入的值进行类型转换，如前所述。'
- en: In this step in the pipeline the incoming string is uppercase (after doing a
    type assertion). To append any text to it, we just need to use the `fmt.Sprintf()`
    function, as we have done many times before, which formats a new string with the
    provided data. In this case, we pass the value of the `suffixS` field as the second
    value, to append it to the end of the string.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在流水线中的这一步中，传入的字符串是大写的（在进行类型断言后）。要附加任何文本，我们只需要使用 `fmt.Sprintf()` 函数，就像我们之前做过很多次一样，它使用提供的数据格式化一个新的字符串。在这种情况下，我们将
    `suffixS` 字段的值作为第二个值传递，以将其附加到字符串的末尾。
- en: 'Just the last step in the pipeline is missing, the prefix operation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线中只缺少最后一步，即前缀操作：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What's calling your attention in this function? Yes, it doesn't return any channel
    now. We could have done this entire pipeline in two ways. I suppose you have realized
    that we have used a `Future` handler function to execute with the final result
    in the pipeline. A second approach would be to pass a channel to return the data
    back to its origin. In some cases, a Future would be enough, while in others it
    could be more convenient to pass a channel so that it can be connected to a different
    pipeline (for example).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中吸引你注意力的是什么？是的，它现在不返回任何通道。我们可以以两种方式完成整个管道。我想你已经意识到我们使用了`Future`处理函数来执行管道中的最终结果。第二种方法是传递一个通道将数据返回到其原始位置。在某些情况下，Future就足够了，而在其他情况下，将通道传递可能更方便，以便它可以连接到不同的管道（例如）。
- en: In any case, the structure of a step in a pipeline must be very familiar to
    you already. We cast the value, check the result of the casting, and send nil
    to the handler if anything went wrong. But, in case everything was OK, the last
    thing to do is to format the text again to place the `prefixS` field at the beginning
    of the text, to send the resulting string back to the origin by calling the request's
    handler.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，管道中的一步的结构对您来说应该已经非常熟悉了。我们对值进行转换，检查转换的结果，并在出现问题时向处理程序发送nil。但是，如果一切顺利，最后要做的就是再次格式化文本，将`prefixS`字段放在文本开头，通过调用请求的处理程序将生成的字符串发送回原始位置。
- en: 'Now, with our worker almost finished, we can implement the `LaunchWorker` method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几乎完成了我们的工作程序，我们可以实现`LaunchWorker`方法：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's all for workers! We simply pass the returning channels to the next steps
    in the Pipeline, as we did in the previous chapter. Remember that the pipeline
    is executed from inside to outside of the calls. So, what's the order of execution
    of any incoming data to the pipeline?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 工作程序就是这些了！我们只需将返回的通道传递给管道中的下一步，就像我们在上一章中所做的那样。请记住，管道是从调用内部到外部执行的。那么，任何传入管道的数据的执行顺序是什么？
- en: The data enters the pipeline through the Goroutine launched in the `uppercase`
    method.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据通过`uppercase`方法中启动的Goroutine进入管道。
- en: Then, it goes to the Goroutine launched in `append`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它进入了在`append`中启动的Goroutine。
- en: Finally, in enters the Goroutine launched in `prefix` method, which doesn't
    return anything but executes the handler after prefixing the incoming string with
    more data.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它进入了在`prefix`方法中启动的Goroutine，它不返回任何东西，但在给传入的字符串加上更多数据后执行处理程序。
- en: Now we have a full pipeline and a dispatcher of pipelines. The dispatcher will
    launch as many instances of the pipelines as we want to route the incoming requests
    to any available worker.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个完整的管道和一个管道的分发器。分发器将启动我们想要的管道实例，将传入的请求路由到任何可用的工作程序。
- en: If none of the workers takes the request within 5 seconds, the request is lost.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何工作程序在5秒内接受请求，请求将丢失。
- en: Let's use this library in a small app.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个小应用程序中使用这个库。
- en: An app using the workers pool
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工作程序池的应用程序
- en: 'We will launch three workers of our defined pipeline. We use the `NewDispatcher`
    function to create the dispatcher and the channel that will receive all requests.
    This channel has a fixed buffer, which will be able to store up to 100 incoming
    messages before blocking:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动我们定义的管道的三个工作程序。我们使用`NewDispatcher`函数创建分发器和接收所有请求的通道。该通道具有固定的缓冲区，可以在阻塞之前存储多达100条传入消息：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we will launch the workers by calling the `LaunchWorker` method in the
    `Dispatcher` interface three times with an already filled `WorkerLauncher` type:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过在`Dispatcher`接口中三次调用`LaunchWorker`方法，并使用已填充的`WorkerLauncher`类型来启动工作程序：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each `WorkerLauncher` type is an instance of `PreffixSuffixWorker`. The prefix
    will be a small text showing the worker ID and the suffix text `world`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`WorkerLauncher`类型都是`PreffixSuffixWorker`的一个实例。前缀将是一个显示工作程序ID和后缀文本`world`的小文本。
- en: 'At this point, we have three workers with three Goroutines, each running concurrently
    and waiting for messages to arrive:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们有三个工作程序，每个都有三个Goroutines，同时运行并等待消息到达：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will make 10 requests. We also need a WaitGroup to properly synchronize
    the app so that it doesn''t exit too early. You can find yourself using WaitGroups
    quite a lot when dealing with concurrent applications. For 10 requests, we''ll
    need to wait for 10 calls to the `Done()` method, so we call the `Add()` method
    with a *delta* of 10\. It''s called delta because you can also pass a -5 later
    to leave it in five requests. In some situations, it can be useful:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发出10个请求。我们还需要一个WaitGroup来正确同步应用程序，以免过早退出。在处理并发应用程序时，您可能会经常使用WaitGroups。对于10个请求，我们需要等待10次对`Done()`方法的调用，因此我们使用*delta*为10调用`Add()`方法。它被称为delta，因为您稍后也可以传递-5以使其在五个请求中保持。在某些情况下，这可能很有用：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To make requests, we will iterate a `for` loop. First, we create a `Request`
    using the function `NewStringRequest` that we wrote at the beginning of the Implementation
    section. In this value, the `Data` field will be the text we'll pass down the
    pipeline, and it will be the text that is "in the middle" of the appending and
    suffixing operation. In this case, we will send the message number and the word
    `hello`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发出请求，我们将迭代一个`for`循环。首先，我们使用在实现部分开头编写的`NewStringRequest`函数创建一个`Request`。在这个值中，`Data`字段将是我们将通过管道传递的文本，它将是附加和后缀操作的“中间”文本。在这种情况下，我们将发送消息编号和单词`hello`。
- en: Once we have a request, we call the `MakeRequest` method with it. After all
    requests have been done, we stop the dispatcher that, as explained previously,
    will provoke a chain reaction that will stop all Goroutines in the pipeline.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个请求，我们就用它调用`MakeRequest`方法。完成所有请求后，我们停止分发器，如前所述，这将引发一个连锁反应，将停止管道中的所有Goroutines。
- en: 'Finally, we wait for the group so that all calls to the `Done()` method are
    received, which signals that all operations have been finished. It''s time to
    try it out:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们等待组，以便接收对`Done()`方法的所有调用，这表明所有操作都已完成。是时候试一试了：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s analyze the first message:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析第一条消息：
- en: 'This would be zero, so the message sent is `(Msg_id: 0) -> Hello`.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这将是零，所以发送的消息是`(Msg_id: 0) -> Hello`。'
- en: 'Then, the text is uppercased, so now we have `(MSG_ID: 0) -> HELLO`.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，文本被转换为大写，所以现在我们有`(MSG_ID: 0) -> HELLO`。'
- en: 'After uppercasing an append operation with the text `world` (note the space
    at the beginning of the text) is done. This will give us the text `(MSG_ID: 0)
    -> HELLO World`.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在将文本`world`（注意文本开头的空格）转换为大写后进行附加操作。这将给我们文本`(MSG_ID: 0) -> HELLO World`。'
- en: 'Finally, the text `WorkerID: 1` (in this case, the first worker took the task,
    but it could be any of them) is appended to the text from step 3 to give us the
    full returned message, `WorkerID: 1 -> (MSG_ID: 0) -> HELLO World`.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，文本`WorkerID: 1`（在这种情况下，第一个工作者接受了任务，但也可能是任何一个工作者）被附加到步骤3的文本中，给我们完整的返回消息，`WorkerID:
    1 -> (MSG_ID: 0) -> HELLO World`。'
- en: No tests?
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有测试？
- en: 'Concurrent applications are difficult to test, especially if you are doing
    networking operations. It can be difficult, and code can change a lot just to
    test it. In any case, it is not justifiable to not perform tests. In this case,
    it is not especially difficult to test our small app. Create a test and copy/paste
    the contents of the `main` function there:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 并发应用程序很难测试，特别是如果你正在进行网络操作。测试可能会很困难，代码可能会发生很大变化。无论如何，不进行测试是不可接受的。在这种情况下，测试我们的小应用并不特别困难。创建一个测试，将`main`函数的内容复制/粘贴到那里：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we have to rewrite our handler to test that the returned contents are the
    ones we are expecting. Go to the `for` loop to modify the function that we are
    passing as a handler on each `Request`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须重写我们的处理程序，以测试返回的内容是否符合我们的期望。转到`for`循环，修改我们作为每个`Request`处理程序传递的函数：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are going to use regular expressions to test the business. If you are not
    familiar with regular expressions, they are a quite powerful feature that help
    you to match content within a string. If you remember in our exercises when we
    were using the `strings` package. `Contains` is the function to find a text inside
    a string. We can also do it with regular expressions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用正则表达式来测试业务。如果你不熟悉正则表达式，它们是一个非常强大的功能，可以帮助你在字符串中匹配内容。如果你还记得我们在练习中使用`strings`包时。`Contains`是用来在字符串中查找文本的函数。我们也可以用正则表达式来做。
- en: The problem is that regular expressions are quite expensive and consume a lot
    of resources.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于正则表达式非常昂贵，消耗大量资源。
- en: 'We are using the `Match` function of the `regexp` package to provide a template
    to match. Our template is `WorkerID\: \d* -> \(MSG_ID: \d\) -> [A-Z]*\sWorld`
    (without quotes). Specifically, it describes the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '我们正在使用`regexp`包的`Match`函数来提供一个匹配模板。我们的模板是`WorkerID\: \d* -> \(MSG_ID: \d\)
    -> [A-Z]*\sWorld`（不带引号）。具体来说，它描述了以下内容：'
- en: 'A string that has the content `WorkerID: \d* -> (MSG_ID: \d*", here "\d*` indicates
    any digit written zero or more times, so it will match `WorkerID: 10 -> (MSG_ID:
    1"` and `"WorkerID: 1 -> (MSG_ID: 10`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个包含内容`WorkerID: \d* -> (MSG_ID: \d*`的字符串，这里的`\d*`表示任意数字写零次或多次，因此它将匹配`WorkerID:
    10 -> (MSG_ID: 1"`和`"WorkerID: 1 -> (MSG_ID: 10`。'
- en: '`"\) -> [A-Z]*\sWorld"` (parentheses must be escaped using backslashes). "`*`"
    means any uppercase character written zero or more times, so `"\s"` is a white
    space and it must finish with the text `World`, so `) -> HELLO World"` will match,
    but `) -> Hello World"` won''t, because `"Hello` must be all uppercase.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"\) -> [A-Z]*\sWorld"`（括号必须使用反斜杠进行转义）。"`*`"表示任意大写字母写零次或多次，所以`"\s"`是一个空格，它必须以文本`World`结束，所以`)
    -> HELLO World"`会匹配，但`) -> Hello World"`不会，因为`"Hello`必须全部大写。'
- en: 'Running this test gives us the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个测试给我们以下输出：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Not bad, but we aren't testing that code is being executed concurrently, so
    this is more a business test than a unit test. Concurrency testing would force
    us to write the code in a completely different manner to check that it is creating
    the proper amount of Goroutines and the pipeline is following the expected workflow.
    This is not bad, but it's quite complex, and outside of the context of this book.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，但我们没有测试代码是否在并发执行，所以这更像是业务测试而不是单元测试。并发测试会迫使我们以完全不同的方式编写代码，以检查它是否创建了适当数量的Goroutines，并且流水线是否遵循了预期的工作流程。这并不是坏事，但它非常复杂，超出了本书的范围。
- en: Wrapping up the Worker pool
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结工作池
- en: With the workers pool, we have our first complex concurrent application that
    can be used in real-world production systems. It also has room to improve, but
    it is a very good design pattern to build concurrent bounded apps.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有了工作池，我们有了第一个可以在真实生产系统中使用的复杂并发应用程序。它还有改进的空间，但它是一个非常好的设计模式，可以构建并发有界应用程序。
- en: It is key that we always have the number of Goroutines that are being launched
    under control. While it's easy to launch thousands to achieve more parallelism
    in an app, we must be very careful that they don't have code that can hang them
    in an infinite loop, too.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，我们始终要控制正在启动的Goroutines的数量。虽然很容易启动成千上万个Goroutines来实现更多的并行性，但我们必须非常小心，确保它们没有代码会使它们陷入无限循环。
- en: With the workers pool, we can now fragment a simple operation in many parallel
    tasks. Think about it; this could achieve the same result with one simple call
    to `fmt.Printf`, but we have done a pipeline with it; then, we launched few instances
    of this pipeline and finally, distributed the workload between all those pipes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有了工作池，我们现在可以将一个简单操作分解为许多并行任务。想想看；这可以通过一次简单的`fmt.Printf`调用来实现相同的结果，但我们已经用它做了一个流水线；然后，我们启动了几个这样的流水线实例，最后，在所有这些管道之间分配了工作负载。
- en: Concurrent Publish/Subscriber design pattern
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发发布/订阅设计模式
- en: In this section, we will implement the Observer design pattern that we showed
    previously on Behavioral patterns, but with a concurrent structure and thread
    safety.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将实现我们之前在行为模式中展示的观察者设计模式，但采用并发结构和线程安全。
- en: Description
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: 'If you remember from the previous explanation, the Observer pattern maintains
    a list of observers or subscribers that want to be notified of a particular event.
    In this case, each subscriber is going to run in a different Goroutine as well
    as the publisher. We will have new problems with building this structure:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得之前的解释，观察者模式维护了一个想要被通知特定事件的观察者或订阅者列表。在这种情况下，每个订阅者将在不同的Goroutine中运行，就像发布者一样。我们将在构建这个结构时遇到新的问题：
- en: Now, the access to the list of subscribers must be serialized. If we are reading
    the list with one Goroutine, we cannot be removing a subscriber from it or we
    will have a race.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，订阅者列表的访问必须是串行化的。如果我们用一个Goroutine读取列表，我们就不能从中删除一个订阅者，否则就会出现竞争。
- en: When a subscriber is removed, the subscriber's Goroutine must be closed too,
    or it will keep iterating forever and we will run into Goroutine leaks.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个订阅者被移除时，订阅者的Goroutine也必须被关闭，否则它将永远迭代下去，我们将遇到Goroutine泄漏的问题。
- en: When stopping the publisher, all subscribers must stop their Goroutines, too.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当停止发布者时，所有订阅者也必须停止它们的Goroutines。
- en: Objectives
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The objectives of this publish/subscriber are the same as the ones we wrote
    on the Observer pattern. The difference here is the way we will develop it. The
    idea is to make a concurrent structure to achieve the same functionality, which
    is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个发布/订阅的目标与我们在观察者模式中写的目标相同。这里的区别在于我们将如何开发它。这个想法是创建一个并发结构来实现相同的功能，即：
- en: Providing an event-driven architecture where one event can trigger one or more
    actions
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个事件驱动的架构，其中一个事件可以触发一个或多个动作
- en: Uncoupling the actions that are performed from the event that triggers them
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将执行的动作与触发它们的事件解耦
- en: Providing more than one source event that triggers the same action
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供多个触发相同动作的源事件
- en: The idea is to uncouple senders from receivers, hiding from the sender the identity
    of the receivers that will process its event, and hiding the receivers from the
    number of senders that can communicate with them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是解耦发送者和接收者，隐藏发送者处理其事件的接收者的身份，并隐藏接收者可以与之通信的发送者的数量。
- en: In particular, if I develop a click in a button in some application, it could
    do something (such as log us in somewhere). Weeks later, we might decide to make
    it show a popup, too. If, every time we want to add some functionality to this
    button, we have to change the code where it handles the click action, that function
    will become huge and not very portable to other projects. If we use a publisher
    and one observer for every action, the click function only needs to publish one
    single event using a publisher, and we will just write subscribers to this event
    every time we want to improve the functionality. This is especially important
    in applications with user interfaces where many things to do in a single UI action
    can slow the responsiveness of an interface, completely destroying the user experience.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果我在某个应用程序的按钮上开发了一个点击，它可能会执行一些操作（比如在某处登录）。几周后，我们可能决定也让它显示一个弹出窗口。如果每次我们想要为这个按钮添加一些功能，我们都必须更改处理点击操作的代码，那么这个函数将变得非常庞大，而且对其他项目的可移植性也不是很好。如果我们为每个动作使用一个发布者和一个观察者，点击函数只需要使用一个发布者发布一个事件，每次我们想要改进功能时，我们只需要为这个事件编写订阅者。这在用户界面应用程序中尤为重要，因为在单个UI操作中要做的事情很多，可能会减慢界面的响应速度，完全破坏用户体验。
- en: By using a concurrent structure to develop the Observer pattern, a UI cannot
    feel all the tasks that are being executed in the background if a concurrent structure
    is defined and the device allows us to execute parallel tasks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用并发结构来开发观察者模式，如果定义了并发结构并且设备允许我们执行并行任务，UI就无法感知到后台执行的所有任务。
- en: Example - a concurrent notifier
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 并发通知器
- en: We will develop a *notifier* similar to the one we developed in  [Chapter 7](ch07.html
    "Chapter 7. Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns"), *Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns*. This is to focus on the concurrent nature of the structure instead
    of detailing too many things that have already been explained. We have developed
    an observer already, so we are familiar with the concept.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个类似于我们在[第7章](ch07.html "第7章。行为模式 - 访问者、状态、中介者和观察者设计模式")中开发的*notifier*，*行为模式
    - 访问者、状态、中介者和观察者设计模式*。这是为了专注于结构的并发性质，而不是详细说明已经解释过的太多东西。我们已经开发了一个观察者，所以我们对这个概念很熟悉。
- en: This particular notifier will work by passing around `interface{}` values, like
    in the workers pool example. This way, we can use it for more than a single type
    by introducing some overhead when casting on the receiver.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的通知器将通过传递`interface{}`值来工作，就像在工作池示例中一样。这样，我们可以通过在接收器上进行转换来将其用于多个类型，引入一些开销。
- en: 'We will work with two interfaces now. First, a `Subscriber` interface:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用两个接口。首先是`Subscriber`接口：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Like in the previous example, it must have a `Notify` method in the `Subscriber`
    interface of new events. This is the `Notify` method that accepts an `interface{}`
    value and returns an error. The `Close()` method, however, is new, and it must
    trigger whatever actions are needed to stop the Goroutine where the subscriber
    is listening for new events.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的示例中一样，`Subscriber`接口必顶有一个`Notify`方法来通知新事件。这是接受`interface{}`值并返回错误的`Notify`方法。然而，`Close()`方法是新的，它必须触发停止订阅者正在监听新事件的Goroutine的任何操作。
- en: 'The second and final interface is the `Publisher` interface:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和最终的接口是`Publisher`接口：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Publisher` interface has the same actions we already know for a publisher
    but to work with channels. The `AddSubscriberCh` and `RemoveSubscriberCh` methods
    accepts a `Subscriber` interface (any type that satisfies the `Subscriber` interface).
    It must have a method to publish messages and a `Stop` method to stop them all
    (publisher and subscriber Goroutines)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publisher`接口具有与发布者相同的操作，但是用于与通道一起工作。`AddSubscriberCh`和`RemoveSubscriberCh`方法接受`Subscriber`接口（满足`Subscriber`接口的任何类型）。它必须有一种发布消息的方法和一个`Stop`方法来停止它们所有（发布者和订阅者Goroutines）'
- en: Acceptance criteria
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'Requirements between this example and the one in the [Chapter 7](ch07.html
    "Chapter 7. Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns") *, Behavioral patterns - Visitor, State, Mediator, and Observer Design
    Patterns* must not change. The objective in both examples is the same so the requirements
    must also be the same. In this case, our requirements are technical, so we actually
    need to add some more acceptance criteria:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子和[第7章](ch07.html "第7章。行为模式 - 访问者，状态，中介者和观察者设计模式")中的例子之间的要求*，行为模式 - 访问者，状态，中介者和观察者设计模式*不得更改。在这两个例子中，目标是相同的，因此要求也必须相同。在这种情况下，我们的要求是技术性的，因此我们实际上需要添加一些更多的验收标准：
- en: We must have a publisher with a `PublishingCh` method that returns a channel
    to send messages through and triggers a `Notify` method on every observer subscribed.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一个带有`PublishingCh`方法的发布者，该方法返回一个通道以发送消息，并在每个订阅的观察者上触发`Notify`方法。
- en: We must have a method to add new subscribers to the publisher.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一种方法来向发布者添加新的订阅者。
- en: We must have a method to remove new subscribers from the publisher.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一种方法来从发布者中移除新的订阅者。
- en: We must have a method to stop a subscriber.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一种方法来停止订阅者。
- en: We must have a method to stop a `Publisher` interface that will also stop all
    subscribers.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一种方法来停止`Publisher`接口，这也将停止所有订阅者。
- en: All inter Goroutine communication must be synchronized so that no Goroutine
    is locked waiting for a response. In such cases, an error is returned after the
    specified timeout period has passed.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有Goroutine之间的通信必顶是同步的，以便没有Goroutine被锁定等待响应。在这种情况下，超时后将返回错误。
- en: Well, these criteria seem quite daunting. We have left out some requirements
    that would add even more complexity, such as removing non-responding subscribers
    or checks to monitor that the publisher Goroutine is always on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这些标准似乎相当令人生畏。我们忽略了一些要求，这些要求将增加更多的复杂性，例如删除不响应的订阅者或检查以确保发布者Goroutine始终处于活动状态。
- en: Unit test
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: We have mentioned previously that testing concurrent applications can be difficult.
    With the correct mechanism, it still can be done, so let's see how much we can
    test without big headaches.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到测试并发应用程序可能很困难。通过正确的机制，仍然可以完成，因此让我们看看在没有大麻烦的情况下我们可以测试多少。
- en: Testing subscriber
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试订阅者
- en: 'Starting with subscribers, which seem to have a more encapsulated functionality,
    the first subscriber must print incoming messages from the publisher to an `io.Writer`
    interface. We have mentioned that the subscriber has an interface with two methods,
    `Notify(interface{}) error` and the `Close()` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从订阅者开始，它似乎具有更加封装的功能，第一个订阅者必须将来自发布者的传入消息打印到`io.Writer`接口。我们已经提到订阅者具有一个接口，其中包含两种方法，`Notify(interface{})
    error`和`Close()`方法：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'OK. This is going to be our `writer_sub.go` file. Create the corresponding
    test file, called the `writer_sub_test.go` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。这将是我们的`writer_sub.go`文件。创建相应的测试文件，称为`writer_sub_test.go`文件：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, the first problem we have is that the functionality prints to the `stdout`,
    so there''s no return value to check. We can solve it in three ways:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们面临的第一个问题是功能打印到`stdout`，因此没有返回值可供检查。我们可以用三种方式解决它：
- en: Capturing the `stdout` method.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获`stdout`方法。
- en: Injecting an `io.Writer` interface to print to it. This is the preferred solution,
    as it makes the code more manageable.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入一个`io.Writer`接口进行打印。这是首选解决方案，因为它使代码更易管理。
- en: Redirecting the `stdout` method to a different file.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`stdout`方法重定向到不同的文件。
- en: 'We''ll take the second approach. Redirection is also a possibility. The `os.Stdout`
    is a pointer to an `os.File` type, so it involves replacing this file with one
    we control, and reading from it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用第二种方法。重定向也是一种可能性。`os.Stdout`是指向`os.File`类型的指针，因此它涉及用我们控制的文件替换此文件，并从中读取：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `NewWriterSubscriber` subscriber isn''t defined yet. It must help in the
    creation of this particular subscriber, returning a type that satisfies the `Subscriber`
    interface, so let''s quickly declare it on the `writer_sub.go` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewWriterSubscriber`订阅者尚未定义。它必须帮助创建特定的订阅者，返回一个满足`Subscriber`接口的类型，因此让我们快速在`writer_sub.go`文件中声明它：'
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Ideally, it must accept an ID and an `io.Writer` interface as the destination
    for its writes. In this case, we need a custom `io.Writer` interface for our test,
    so we''ll create a `mockWriter` on the `writer_sub_test.go` file for it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，它必须接受一个ID和一个`io.Writer`接口作为其写入的目的地。在这种情况下，我们需要一个自定义的`io.Writer`接口进行测试，因此我们将在`writer_sub_test.go`文件中为其创建一个`mockWriter`：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `mockWriter` structure will accept a `testingFunc` as one of its fields.
    This `testingFunc` field accepts a string that represents the bytes written to
    the `mockWriter` structure. To implement an `io.Writer` interface, we need to
    define a `Write([]byte) (int, error)` method. In our definition, we pass the contents
    of `p` as a string (remember that we always need to return the bytes read and
    an error, or not, on every `Write` method). This approach delegates the definition
    of `testingFunc` to the scope of the test.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`mockWriter`结构将接受`testingFunc`作为其字段之一。这个`testingFunc`字段接受一个代表写入到`mockWriter`结构的字节的字符串。为了实现`io.Writer`接口，我们需要定义一个`Write([]byte)
    (int, error)`方法。在我们的定义中，我们将`p`的内容作为字符串传递（请记住，我们总是需要在每个`Write`方法中返回读取的字节和错误，或者不需要返回）。这种方法将`testingFunc`的定义委托给测试的范围。'
- en: 'We are going to call the `Notify` method on the `Subcriber` interface, which
    must write on the `io.Writer` interface like the `mockWriter` structure. So, we''ll
    define the `testingFunc` of a `mockWriter` structure before calling the `Notify`
    method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `Subcriber` 接口上调用 `Notify` 方法，它必须像 `mockWriter` 结构一样写入 `io.Writer` 接口。因此，在调用
    `Notify` 方法之前，我们将定义 `mockWriter` 结构的 `testingFunc`：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will send the `Hello` message. This also means that whatever the `Subscriber`
    interface does, it must eventually print the `Hello` message on the provided `io.Writer`
    interface.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发送 `Hello` 消息。这也意味着无论 `Subscriber` 接口做什么，它最终都必须在提供的 `io.Writer` 接口上打印 `Hello`
    消息。
- en: So if, eventually, we receive a string on the testing function, we'll need to
    synchronize with the `Subscriber` interface to avoid race conditions on tests.
    That's why we use so much `WaitGroup`. It's a very handy and easy-to-use type
    to handle this scenario. One `Notify` method call will need to wait for one call
    to the `Done()` method, so we call the `Add(1)` method (with one unit).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果最终我们在测试函数中收到一个字符串，我们将需要与 `Subscriber` 接口同步，以避免测试中的竞争条件。这就是为什么我们使用了这么多的
    `WaitGroup`。这是一种非常方便和易于使用的类型，用于处理这种情况。一个 `Notify` 方法调用将需要等待一个 `Done()` 方法的调用，因此我们调用
    `Add(1)` 方法（一个单位）。
- en: Ideally, the `NewWriterSubscriber` function must return an interface, so we
    need to type assert it to the type we are working with during the test, in this
    case, the `stdoutPrinter` method. I have omitted error checking when doing the
    casting on purpose, just to make things easier. Once we have a `writerSubscriber`
    type, we can access its `Write` field to replace it with the `mockWriter` structure.
    We could have directly passed an `io.Writer` interface on the `NewWriterSubscriber`
    function, but we wouldn't cover the scenario where a nil object is passed and
    it sets the `os.Stdout` instance to a default value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，`NewWriterSubscriber` 函数必须返回一个接口，因此我们需要对我们在测试中使用的类型进行类型断言，即 `stdoutPrinter`
    方法。我故意在进行转换时省略了错误检查，只是为了简化事情。一旦我们有了 `writerSubscriber` 类型，我们就可以访问其 `Write` 字段，将其替换为
    `mockWriter` 结构。我们本可以直接在 `NewWriterSubscriber` 函数上传递一个 `io.Writer` 接口，但这样我们就无法覆盖传递空对象并将
    `os.Stdout` 实例设置为默认值的情况。
- en: So, the testing function will eventually receive a string containing what was
    written by the subscriber. We just need to check if the received string, the one
    that the `Subscriber` interface will receive, prints the word `Hello` at some
    point and nothing better that `strings.Contains` function for it. Everything is
    defined under the scope of the testing function, so we can use the value of the
    `t` object to also signal that the test has failed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试函数最终将接收一个包含订阅者写入内容的字符串。我们只需要检查接收到的字符串，即 `Subscriber` 接口将接收到的字符串，是否在某个时刻打印了单词
    `Hello`，而 `strings.Contains` 函数最适合这种情况。一切都在测试函数的范围内定义，因此我们可以使用 `t` 对象的值来表示测试失败。
- en: 'Once we have done the checking, we must call to the `Done()` method to signal
    that we have already tested the expected result:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了检查，我们必须调用 `Done()` 方法来表示我们已经测试了预期的结果：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We must actually call the `Notify` and `Wait` methods for the call to the `Done`
    method to check that everything was correct.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上必须调用 `Notify` 和 `Wait` 方法，以便调用 `Done` 方法来检查一切是否正确。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Did you realize that we have defined the behavior on tests more or less in reverse?
    This is very common in concurrent apps. It can be confusing sometimes, as it becomes
    difficult to know what a function could be doing if we can't follow calls linearly,
    but you get used to it quite quickly. Instead of thinking "it does this, then
    this, then that," it's more like "this will be called when executing that." This
    is also because the order of execution in a concurrent application is unknown
    until some point, unless we use synchronization primitives (such as WaitGroups
    and channels) to pause execution at certain moments.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否意识到我们在测试中定义了行为，更多或更少是相反的？这在并发应用程序中非常常见。有时可能会令人困惑，因为如果我们无法线性地跟踪调用，就很难知道函数可能在做什么，但您会很快习惯。与其思考“它这样做，然后这样做，然后那样做”，不如思考“在执行那个时会调用这个”。这也是因为在并发应用程序中，执行顺序在某一点之前是未知的，除非我们使用同步原语（如
    WaitGroups 和通道）在某些时刻暂停执行。
- en: 'Let''s execute the test for this type now:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们执行此类型的测试：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It has exited fast but it has failed. Actually, the call to the `Done()` method
    has not been executed, so it would be nice to change the last part of our test
    to this instead:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它退出得很快，但失败了。实际上，`Done()` 方法的调用尚未执行，因此最好将我们测试的最后部分更改为这样：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, it doesn't stop execution because we are calling the `Error` function instead
    of the `Fatal` function, but we call the `Done()` method and the test ends where
    we prefer it to end, after the `Wait()` method is called. You can try to run the
    tests again, but the output will be the same.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它不会停止执行，因为我们调用 `Error` 函数而不是 `Fatal` 函数，但我们调用 `Done()` 方法，测试在我们希望的位置结束，即在调用
    `Wait()` 方法之后。您可以尝试再次运行测试，但输出将是相同的。
- en: Testing publisher
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试发布者
- en: 'We have already seen a `Publisher` interface and the type that will satisfy
    which was the `publisher` type. The only thing we know for sure is that it will
    need some way to store subscribers, so it will at least have a `Subscribers` slice:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 `Publisher` 接口和将满足其条件的类型，即 `publisher` 类型。我们唯一确定的是它将需要一些存储订阅者的方式，因此它至少会有一个
    `Subscribers` 切片：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To test the `publisher` type, we will also need a mock for the `Subscriber`
    interface:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 `publisher` 类型，我们还需要一个 `Subscriber` 接口的模拟：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `mockSubscriber` type must implement the `Subscriber` interface, so it must
    have a `Close()` and a `Notify(interface{}) error` method. We can embed an existing
    type that implements it, such as,  the `writerSubscriber`, and override just the
    method that is interesting for us, but we will need to define both, so we won't
    embed anything.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`mockSubscriber` 类型必须实现 `Subscriber` 接口，因此它必须有 `Close()` 和 `Notify(interface{})
    error` 方法。我们可以嵌入一个已实现它的现有类型，比如 `writerSubscriber`，并且只覆盖我们感兴趣的方法，但我们需要定义两者，所以我们不会嵌入任何东西。'
- en: 'So, we need to override the `Notify` and `Close` methods in this case to call
    the testing functions stored on the fields of the `mockSubscriber` type:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，我们需要重写`Notify`和`Close`方法，以调用`mockSubscriber`类型字段上存储的测试函数。
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'First of all, we will be sending messages through channels directly, this could
    lead to potential unwanted deadlocks so the first thing to define is a panic handler
    for cases such as, sending to close channels or no Goroutines listening on a channel.
    The message we will send to subscribers is `Hello`. So, each subscriber that has
    been received using the channel returned by the `AddSubscriberCh` method must
    receive this message. We will also use a *New* function to create Publishers,
    called `NewPublisher`. Change the `publisher.go` file now to write it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将直接通过通道发送消息，这可能会导致潜在的意外死锁，因此首先要定义一个用于这种情况的panic处理程序，比如，向关闭的通道发送消息或没有Goroutines在通道上监听。我们将发送给订阅者的消息是`Hello`。因此，通过使用`AddSubscriberCh`方法返回的通道接收到的每个订阅者都必须接收到这条消息。我们还将使用一个*New*函数来创建发布者，称为`NewPublisher`。现在更改`publisher.go`文件来编写它。
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we''ll define the `mockSubscriber` to add it to the publisher list of known
    subscribers. Back to the `publisher_test.go` file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义`mockSubscriber`，并将其添加到已知订阅者列表中。回到`publisher_test.go`文件。
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As usual, we start with a WaitGroup. First, testing the function in our subscriber
    defers a call to the `Done()` method at the end of its execution. Then it needs
    to type cast `msg` variable because it's coming as an interface. Remember that
    this way, we can use the `Publisher` interface with many types by introducing
    the overhead of the type assertion. This is done on line `s, ok := msg.(string)`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们从一个WaitGroup开始。首先，在我们的订阅者中测试函数会在执行结束时延迟调用`Done()`方法。然后它需要对`msg`变量进行类型转换，因为它是作为接口传递的。记住，这样一来，我们可以通过引入类型断言的开销，使用`Publisher`接口与许多类型。这是在第`s,
    ok := msg.(string)`行完成的。
- en: 'Once we have type cast `msg` to a string, `s`, we just need to check if the
    value received in the subscriber is the same as the value we sent, or fail the
    test if not:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将`msg`强制转换为字符串`s`，我们只需要检查订阅者接收到的值是否与我们发送的值相同，如果不同则测试失败。
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We add the `mockSubscriber` type using the `AddSubscriberCh` method. We publish
    our message just after getting ready, by adding one to the `WaitGroup`, and just
    before setting the `WaitGroup` to wait so that the test doesn't continue until
    the `mockSubscriber` type calls the `Done()` method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`AddSubscriberCh`方法添加`mockSubscriber`类型。在准备就绪后，我们通过将`WaitGroup`加一来发布我们的消息，并在将`WaitGroup`设置为等待之前发布消息，这样测试就不会继续进行，直到`mockSubscriber`类型调用`Done()`方法。
- en: 'Also, we need to check if the number of the `Subscriber` interface has grown
    after calling the `AddSubscriberCh` method, so we''ll need to get the concrete
    instance of publisher on the test:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要检查在调用`AddSubscriberCh`方法后`Subscriber`接口的数量是否增加，因此我们需要在测试中获取发布者的具体实例。
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Type assertion is our friend today! Once we have the concrete type, we can
    access the underlying slice of subscribers for the `Publisher` interface. The
    number of subscribers must be 1 after calling the `AddSubscriberCh` method once,
    or the test will fail. The next step is to check just the opposite--when we remove
    a `Subscriber` interface, it must be taken from this list:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言是我们今天的朋友！一旦我们有了具体类型，我们就可以访问`Publisher`接口的基础订阅者切片。调用`AddSubscriberCh`方法后，订阅者的数量必须为1，否则测试将失败。下一步是检查相反的情况--当我们移除一个`Subscriber`接口时，它必须从这个列表中被移除。
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The final step in our test is to stop the publisher so no more messages can
    be sent and all the Goroutines are stopped.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试的最后一步是停止发布者，这样就不能再发送消息，所有的Goroutines都会停止。
- en: 'The test is finished, but we can''t run tests until the `publisher` type has
    all the methods implemented; this must be the final result:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 测试已经完成，但在`publisher`类型实现了所有方法之前我们无法运行测试；这必须是最终结果。
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With this empty implementation, nothing good can happen when running the tests:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个空实现，当运行测试时就不会发生什么好事。
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Yes it has failed but, it's not a controlled fail at all. This was done on purpose
    to show a couple of things to be careful of in Go. First of all, the error produced
    in this test is a **fatal** error, which usually points to a bug in the code.
    This is important because while a **panic** error can be recovered, you cannot
    do the same with a fatal error.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它失败了，但这根本不是一个受控的失败。这是故意做的，以展示在Go中需要注意的一些事情。首先，这个测试产生的错误是一个**fatal**错误，通常指向代码中的一个bug。这很重要，因为虽然**panic**错误可以被恢复，但对于致命错误却不能做同样的事情。
- en: 'In this case, the error is telling us the problem: `goroutine 5 [chan send
    (nil chan)]`, a nil channel so it''s actually a bug in our code. How can we solve
    this? Well, this is also interesting.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，错误告诉我们问题所在：`goroutine 5 [chan send (nil chan)]`，一个`nil`通道，所以这实际上是我们代码中的一个错误。我们该如何解决这个问题呢？这也很有趣。
- en: The fact that we have a `nil` channel is caused by the code we wrote to compile
    unit tests but this particular error won't be raised once the appropriate code
    is written (because we'll never return a nil channel in this case). We could return
    a channel that is never use we cause a fatal error with a deadlock, which wouldn't
    be any progress at all either.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`nil`通道的事实是由我们编写的代码导致的，用于编译单元测试，但一旦编写了适当的代码，就不会引发这种特定的错误（因为在这种情况下我们永远不会返回一个`nil`通道）。我们可以返回一个从未使用的通道，这会导致死锁的致命错误，这也不会有任何进展。
- en: An idiomatic way to solve it would be to return a channel and an error so that
    you can have an error package with a type implementing the `Error` interface that
    returns a specific error such as `NoGoroutinesListening` or `ChannelNotCreated`.
    We have already seen many of this implementations so we'll leave these as an exercise
    to the reader and we will move forward to maintain focus on the concurrent nature
    of the chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方法是返回一个通道和一个错误，这样你就可以有一个错误包，其中包含一个实现了`Error`接口的类型，返回一个特定的错误，比如`NoGoroutinesListening`或`ChannelNotCreated`。我们已经看到了许多这样的实现，所以我们将把这些留给读者作为练习，然后我们将继续保持对本章并发性质的关注。
- en: Nothing surprising there, so we can move to the implementation phase.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么令人惊讶的，所以我们可以进入实施阶段。
- en: Implementation
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: To recall, the `writerSubscriber` must receive messages that it will write on
    a type that satisfies the `io.Writer` interface.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，`writerSubscriber`必须接收它将写入的消息，并将其写入满足`io.Writer`接口的类型。
- en: 'So, where do we start? Well, each subscriber will run its own Goroutine, and
    we have seen that the best method to communicate with a Goroutine is a channel.
    So, we will need a field with a channel in the `Subscriber` type. We can use the
    same approach as in pipelines to end with the `NewWriterSubscriber` function and
    the `writerSubscriber` type:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从哪里开始呢？嗯，每个订阅者将运行自己的Goroutine，而我们已经知道与Goroutine通信的最佳方法是使用通道。因此，我们将需要在`Subscriber`类型中使用一个带有通道的字段。我们可以使用与管道中相同的方法来结束`NewWriterSubscriber`函数和`writerSubscriber`类型：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the first step, if no writer is specified (the `out` argument is nil), the
    default `io.Writer` interface is `stdout`. Then, we create a new pointer to the
    `writerSubscriber` type with the ID passed in the first argument, the value of
    out (`os.Stdout`, or whatever came in the argument if it wasn't nil), and a channel
    called in to maintain the same naming as in previous examples.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，如果没有指定写入器（`out`参数为nil），默认的`io.Writer`接口是`stdout`。然后，我们使用传递给第一个参数的ID、out的值（`os.Stdout`，或者如果不为nil，则是传入参数中的值），以及一个名为in的通道创建了一个新的指向`writerSubscriber`类型的指针，以保持与之前示例中相同的命名。
- en: Then we launch a new Goroutine; this is the launching mechanism we mentioned.
    Like in the pipelines, the subscriber will iterate over the `in` channel every
    time a new message is received and it will format its contents to a string, which
    also contains the ID of the current subscriber.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们启动一个新的Goroutine；这是我们提到的启动机制。就像在管道中一样，订阅者将在每次接收到新消息时迭代`in`通道，并将其内容格式化为一个字符串，其中还包含当前订阅者的ID。
- en: 'As we learned previously, if the `in` channel is closed, the `for range` loop
    will stop and that particular Goroutine will finish, so the only thing we need
    to do in the `Close` method is to actually close the `in` channel:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的那样，如果`in`通道关闭，`for range`循环将停止，那个特定的Goroutine将结束，所以`Close`方法中唯一需要做的事情就是实际关闭`in`通道：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'OK, only the `Notify` method is left; the `Notify` method is a convenient method
    to manage a particular behavior when communicating, and we will use a pattern
    that is common in many calls:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，只剩下`Notify`方法了；`Notify`方法是管理特定行为的便捷方法，我们将使用一个在许多调用中常见的模式：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When communicating with a channel, there are two behavior that we must usually
    control: one is waiting time and the other is when the channel is closed. The
    deferred function actually works for any panicking error that can occur within
    the function. If the Goroutine panics, it will still execute the deferred function
    with the `recover()` method. The `recover()` method returns an interface of whatever
    the error was, so in our case, we set the returning variable error to the formatted
    value returned by `recover` (which is an interface). The `"%#v"` parameter gives
    us most of the information about any type when formatted to a string. The returned
    error will be ugly, but it will contain most of the information we can extract
    about the error. For a closed channel, for example, it will return "send on a
    closed channel". Well, this seems clear enough.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在与通道通信时，通常有两种行为需要控制：一种是等待时间，另一种是通道关闭时的行为。延迟函数实际上适用于函数内部可能发生的任何恐慌错误。如果Goroutine发生恐慌，它仍将使用`recover()`方法执行延迟函数。`recover()`方法返回一个接口，无论错误是什么，所以在我们的情况下，我们将返回变量错误设置为`recover`返回的格式化值（这是一个接口）。`"%#v"`参数在将任何类型格式化为字符串时为我们提供了大部分信息。返回的错误会很丑陋，但它将包含我们可以提取的大部分关于错误的信息。例如，对于关闭的通道，它将返回"send
    on a closed channel"。嗯，这似乎足够清楚了。
- en: 'The second rule is about waiting time. When we send a value over a channel,
    we will be blocked until another Goroutine takes the value from it (it will happen
    the same with a filled buffered channel). We don''t want to get blocked forever,
    so we set a timeout period of one second by using a select handler. In short,
    with select we are saying: either you take the value in less than 1 second or
    I will discard it and return an error.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则是关于等待时间。当我们通过通道发送一个值时，我们将被阻塞，直到另一个Goroutine从中取出该值（填充的缓冲通道也是如此）。我们不希望永远被阻塞，所以我们通过使用select处理程序设置了一秒的超时期。简而言之，使用select我们在说：要么你在1秒内取出值，要么我将丢弃它并返回一个错误。
- en: 'We have the `Close`, `Notify`, and `NewWriterSubscriber` methods, so we can
    try our test again:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`Close`、`Notify`和`NewWriterSubscriber`方法，所以我们可以再次尝试我们的测试：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Much better now. The `Writer` has taken the mock writer we wrote on the test
    and has written to it the value we pass to the Notify method. At the same time,
    close has probably closed the channel effectively, because the `Notify` method
    is returning an error after calling the `Close` method. One thing to mention is
    that we can't check if a channel is closed or not without interacting with it;
    that's why we had to defer the execution of a closure that will check the contents
    of the `recover()` function in the `Notify` method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好多了。`Writer`已经接收了我们在测试中编写的模拟写入器，并向其传递了我们传递给`Notify`方法的值。同时，由于`Notify`方法在调用`Close`方法后返回了一个错误，所以`close`可能已经有效地关闭了通道。需要提到的一件事是，我们无法在不与其交互的情况下检查通道是否关闭；这就是为什么我们必须推迟执行一个将检查`Notify`方法中`recover()`函数的内容的闭包的执行。
- en: Implementing the publisher
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施发布者
- en: OK, the publisher will need also a launching mechanism, but the main problems
    to deal with are race conditions accessing the subscriber list. We can solve this
    issue with a Mutex object from the `sync` package but we have already seen how
    to use this so we will use channels instead.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，发布者还需要一个启动机制，但要处理的主要问题是访问订阅者列表时的竞争条件。我们可以使用`sync`包中的Mutex对象来解决这个问题，但我们已经知道如何使用它，所以我们将改用通道。
- en: 'When using channels, we will need a channel for each action that can be considered
    dangerous--add a subscriber, remove a subscriber, retrieve the list of subscribers
    to `Notify` method them of a message, and a channel to stop all the subscribers.
    We also need a channel for incoming messages:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用通道时，我们将需要为每个可能被视为危险的操作创建一个通道——添加订阅者、移除订阅者、检索订阅者列表以通知`Notify`方法发送消息，以及一个用于停止所有订阅者的通道。我们还需要一个用于传入消息的通道：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Names are self-descriptive but, in short, subscribers maintain the list of subscribers;
    this is the slice that needs multiplexed access. The `addSubCh` instance is the
    channel to communicate with when you want to add a new subscriber; that's why
    it's a channel of subscribers. The same explanation applies to the `removeSubCh`
    channel, but this channel is to remove the subscriber. The `in` channel will handle
    incoming messages that must be broadcast to all subscribers. Finally, the stop
    channel must be called when we want to kill all Goroutines.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 名称是自描述的，但简而言之，订阅者维护订阅者列表；这是需要多路访问的切片。`addSubCh`实例是与之通信的通道，当您想要添加新的订阅者时，就会使用它；这就是为什么它是一个订阅者的通道。相同的解释也适用于`removeSubCh`通道，但这个通道是用来移除订阅者的。`in`通道将处理必须广播给所有订阅者的传入消息。最后，当我们想要终止所有Goroutines时，必须调用stop通道。
- en: 'OK, let''s start with the `AddSubscriberCh`, `RemoveSubscriber` and `PublishingCh`
    methods, which must return the channel to add and remove subscribers and the channel
    to send messages to all of them:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们从`AddSubscriberCh`、`RemoveSubscriber`和`PublishingCh`方法开始，这些方法必须返回通道以添加和移除订阅者以及向所有订阅者发送消息的通道：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `Stop()` function the `stop` channel by closing it. This will effectively
    spread the signal to every listening Goroutine:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stop()`函数通过关闭`stop`通道来停止它。这将有效地向每个正在监听的Goroutine传播信号：'
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Stop` method, the function to stop the publisher and the subscribers, also
    pushes to its respective channel, called stop.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stop`方法，用于停止发布者和订阅者，也会推送到其相应的通道，称为stop。'
- en: You may be wondering why we don't simply leave the channels available so that
    users push directly to this channel instead of using the proxying function. Well,
    the idea is that the user that integrates the library in their app doesn't have
    to deal with the complexity of the concurrent structure associated with the library,
    so they can focus on their business while maximizing performance as much as possible.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道为什么我们不直接保留通道，让用户直接向该通道推送消息，而不使用代理函数。嗯，这样做的想法是，集成库到他们的应用程序中的用户不必处理与库相关的并发结构的复杂性，因此他们可以专注于他们的业务，同时尽可能地提高性能。
- en: Handling channels without race conditions
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理通道而不产生竞争条件。
- en: Until now, we have forwarded data to the channels on the publisher but we haven't
    actually handled any of that data. The launcher mechanism that is going to launch
    a different Goroutine will handle them all.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将数据转发到发布者的通道上，但实际上我们还没有处理任何数据。将启动不同的Goroutine的机制将处理它们所有。
- en: 'We will create a launch method that we will execute by using the `go` keyword
    instead of embedding the whole function inside the `NewPublisher` function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`launch`方法，通过使用`go`关键字来执行它，而不是将整个函数嵌入`NewPublisher`函数中：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`Launch` is a private method and we haven''t tested it. Remember that private
    methods are usually called from public methods (the ones we have tested). Generally,
    if a private method is not called from a public method, it can''t be called at
    all!'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Launch`是一个私有方法，我们还没有测试过它。请记住，私有方法通常是从公共方法（我们已经测试过的方法）中调用的。通常情况下，如果一个私有方法没有从公共方法中调用，它就不能被调用！'
- en: The first thing we notice with this method is that it is an infinite for loop
    that will repeat a select operation between many channels but only one of them
    can be executed each time. The first of these operations is the one that receives
    a new message to publish to subscribers. The `case msg := <- p.in:` code handles
    this incoming operation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法时，我们首先注意到的是一个无限循环，它将在许多通道之间重复执行选择操作，但每次只能执行其中一个。这些操作中的第一个是接收要发布给订阅者的新消息。`case
    msg := <- p.in:` 代码处理这个传入操作。
- en: 'In this case, we are iterating over all subscribers and executing their `Notify`
    method. You may be wondering why we don''t add the `go` keyword in front so that
    the `Notify` method is executed as a different Goroutine and therefore iterates
    much faster. Well, this because we aren''t demultiplexing the actions of receiving
    a message and of closing the message. So, if we launch the subscriber in a new
    Goroutine and it is closed while the message is processed in the `Notify` method,
    we''ll have a race condition where a message will try to be sent within the `Notify`
    method to a closed channel. In fact, we are considering this scenario when we
    develop the `Notify` method but, still, we won''t control the number of Goroutines
    launched if we call the `Notify` method in a new Goroutine each time. For simplicity,
    we just call the `Notify` method, but it is a nice exercise to control the number
    of Goroutines waiting for a return in a `Notify` method execution. By buffering
    the `in` channel in each subscriber, we can also achieve a good solution:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在迭代所有订阅者并执行它们的`Notify`方法。也许你会想知道为什么我们不在前面加上`go`关键字，以便`Notify`方法作为一个不同的Goroutine执行，因此迭代速度更快。嗯，这是因为我们没有对接收消息和关闭消息的操作进行解复用。因此，如果我们在新的Goroutine中启动订阅者，并且在`Notify`方法中处理消息时关闭了它，我们将会出现竞争条件，即消息将尝试在`Notify`方法中发送到一个关闭的通道。事实上，当我们开发`Notify`方法时，我们考虑到了这种情况，但是，如果我们每次在新的Goroutine中调用`Notify`方法，我们就无法控制启动的Goroutines数量。为简单起见，我们只是调用`Notify`方法，但是控制在`Notify`方法执行中等待返回的Goroutines数量是一个很好的练习。通过在每个订阅者中缓冲`in`通道，我们也可以实现一个很好的解决方案：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The next operation is what to do when a value arrives to the channel to add
    subscribers. In this case it''s simple: we update it, appending the new value
    to it. While this case is executed, not other calls can be executed in this selection:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个操作是当一个值到达通道以添加订阅者时该怎么办。在这种情况下很简单：我们更新它，将新值附加到它上。在执行此案例时，不能执行其他调用：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When a value arrives at the remove channel, the operation is a bit more complex
    because we have to search for the subscriber in the slice. We use a *O(N)* approach
    for it, iterating from the beginning until we find it, but the search algorithm
    could be greatly improved. Once we find the corresponding `Subscriber` interface,
    we remove it from the subscribers slice and stop it. One thing to mention is that
    on tests, we are accessing the length of the subscribers slice directly without
    demultiplexing the operation. This is clearly a race condition, but generally,
    it isn't reflected when running the race detector.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值到达移除通道时，操作会变得更加复杂，因为我们必须在切片中搜索订阅者。我们使用了*O(N)*的方法，从开头开始迭代直到找到它，但搜索算法可以得到很大的改进。一旦我们找到相应的`Subscriber`接口，我们就将其从订阅者切片中移除并停止它。需要提到的一件事是，在测试中，我们直接访问订阅者切片的长度，而不进行多路复用操作。这显然是一种竞争条件，但通常在运行竞争检测器时不会反映出来。
- en: 'The solution will be to develop a method just to multiplex calls to get the
    length of the slice, but it won''t belong to the public interface. Again, for
    simplicity, we''ll leave it like this, or this example may become too complex
    to handle:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案将是开发一种方法，只是为了多路复用调用以获取切片的长度，但它不会属于公共接口。再次，为了简单起见，我们将保持现状，否则这个例子可能会变得太复杂而难以处理：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The last operation to demultiplex is the `stop` operation, which must stop all
    Goroutines in the publisher and subscribers. Then we have to iterate through every
    Subscriber stored in the subscribers field to execute their `Close()` method,
    so their Goroutines are closed, too. Finally, if we return this Goroutine, it
    will finish, too.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个需要多路复用的操作是`stop`操作，它必须停止发布者和订阅者中的所有Goroutines。然后，我们必须遍历存储在订阅者字段中的每个订阅者，执行它们的`Close()`方法，以便关闭它们的Goroutines。最后，如果我们返回这个Goroutine，它也会结束。
- en: 'OK, time to execute all tests and see how is it going:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，是时候执行所有测试，看看情况如何：
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Not so bad. All tests have passed successfully and we have our Observer pattern
    ready. While the example can still be improved, it is a great example of how we
    must handle an Observer pattern using channels in Go. As an exercise, we encourage
    you to try the same example using mutexes instead of channels to control access.
    It's a bit easier, and will also give you an insight of how to work with mutexes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错。所有测试都成功通过了，我们的观察者模式已经准备就绪。虽然这个例子仍然可以改进，但它是一个很好的例子，展示了我们如何使用Go中的通道来处理观察者模式。作为练习，我们鼓励您尝试使用互斥锁而不是通道来控制访问，这样做会更容易，也会让您了解如何使用互斥锁。
- en: A few words on the concurrent Observer pattern
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于并发观察者模式的几句话
- en: This example has demonstrated how to take advantage of multi-core CPUs to build
    a concurrent message publisher by implementing the Observer pattern. While the
    example was long, we have tried to show a common pattern when developing concurrent
    apps in Go.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了如何利用多核CPU来构建一个并发消息发布者，通过实现观察者模式。虽然例子很长，但我们试图展示在使用Go开发并发应用程序时的常见模式。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have seen few approaches to develop concurrent structures that can be run
    in parallel. We have tried to show a few ways to solve the same problem, one without
    concurrency primitives and one with them. We have seen how different the publish/subscriber
    example written with a concurrent structure can be compared to the classic one.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些开发并发结构的方法，可以并行运行。我们试图展示解决同一个问题的几种方式，一种是没有并发原语，另一种是有并发原语。我们已经看到了使用并发结构编写的发布/订阅示例与经典示例相比有多么不同。
- en: We have also seen how to build a concurrent operation using a pipeline and we
    have parallelize it by using a worker pool, a very common Go pattern to maximize
    parallelism.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用管道构建并发操作，并通过使用工作池来并行化，这是一种最大化并行性的常见Go模式。
- en: Both examples were simple enough to grasp, while digging as much as possible
    in to the nature of the Go language instead of in the problem itself.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子都足够简单，可以理解，同时尽可能深入了解Go语言的本质，而不是问题本身。
