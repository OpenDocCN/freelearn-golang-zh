["```go\npackage main\n\nimport (\n  \"log\"\n  \"net/http\"\n)\n\nfunc main() {\n\n  http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(`\n      <html>\n        <head>\n          <title>Chat</title>\n        </head>\n        <body>\n          Let's chat!\n        </body>\n      </html>\n    `))\n  })\n  // start the web server\n  if err := http.ListenAndServe(\":8080\", nil); err != nil {\n    log.Fatal(\"ListenAndServe:\", err)\n  }\n}\n```", "```go\n\ngo run main.go\n\n```", "```go\nHello {name}, how are you?\n```", "```go\nHello Laurie, how are you?\n```", "```go\n<html>\n  <head>\n    <title>Chat</title>\n  </head>\n  <body>\n    Let's chat \n(from template)\n\n  </body>\n</html>\n```", "```go\n// templ represents a single template\ntype templateHandler struct {\n  once     sync.Once\n  filename string\n  templ    *template.Template\n}\n// ServeHTTP handles the HTTP request.\nfunc (t *templateHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n  t.once.Do(func() {\n    t.templ = template.Must(template.ParseFiles(filepath.Join(\"templates\", t.filename)))\n  })\n  t.templ.Execute(w, nil)\n}\n```", "```go\nfunc main() {\n  // root\n\nhttp.Handle(\"/\", &templateHandler{filename: \"chat.html\"})\n\n  // start the web server\n  if err := http.ListenAndServe(\":8080\", nil); err != nil {\n    log.Fatal(\"ListenAndServe:\", err)\n  }\n}\n```", "```go\n\ngo build -o {name}\n\n./{name}\n\n```", "```go\n\ngo build -o chat\n\n./chat\n\n```", "```go\npackage main\nimport (\n  \"github.com/gorilla/websocket\"\n)\n// client represents a single chatting user.\ntype client struct {\n  // socket is the web socket for this client.\n  socket *websocket.Conn\n  // send is a channel on which messages are sent.\n  send chan []byte\n  // room is the room this client is chatting in.\n  room *room\n}\n```", "```go\n\ngo get github.com/gorilla/websocket\n\n```", "```go\n\n./client.go:17 undefined: room\n\n```", "```go\npackage main\ntype room struct {\n  // forward is a channel that holds incoming messages\n  // that should be forwarded to the other clients.\n  forward chan []byte\n}\n```", "```go\nfunc (c *client) read() {\n  for {\n    if _, msg, err := c.socket.ReadMessage(); err == nil {\n      c.room.forward <- msg\n    } else {\n      break\n    }\n  }\n  c.socket.Close()\n}\nfunc (c *client) write() {\n  for msg := range c.send {\n    if err := c.socket.WriteMessage(websocket.TextMessage, msg); err != nil {\n      break\n    }\n  }\n  c.socket.Close()\n}\n```", "```go\npackage main\n\ntype room struct {\n\n  // forward is a channel that holds incoming messages\n  // that should be forwarded to the other clients.\n  forward chan []byte\n  // join is a channel for clients wishing to join the room.\n  join chan *client\n  // leave is a channel for clients wishing to leave the room.\n  leave chan *client\n  // clients holds all current clients in this room.\n  clients map[*client]bool\n}\n```", "```go\nfunc (r *room) run() {\n  for {\n    select {\n    case client := <-r.join:\n      // joining\n      r.clients[client] = true\n    case client := <-r.leave:\n      // leaving\n      delete(r.clients, client)\n      close(client.send)\n    case msg := <-r.forward:\n      // forward message to all clients\n      for client := range r.clients {\n        select {\n        case client.send <- msg:\n          // send the message\n        default:\n          // failed to send\n          delete(r.clients, client)\n          close(client.send)\n        }\n      }\n    }\n  }\n}\n```", "```go\nconst (\n  socketBufferSize  = 1024\n  messageBufferSize = 256\n)\nvar upgrader = &websocket.Upgrader{ReadBufferSize: socketBufferSize, WriteBufferSize: socketBufferSize}\nfunc (r *room) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n  socket, err := upgrader.Upgrade(w, req, nil)\n  if err != nil {\n    log.Fatal(\"ServeHTTP:\", err)\n    return\n  }\n  client := &client{\n    socket: socket,\n    send:   make(chan []byte, messageBufferSize),\n    room:   r,\n  }\n  r.join <- client\n  defer func() { r.leave <- client }()\n  go client.write()\n  client.read()\n}\n```", "```go\nr := &room{\n  forward: make(chan []byte),\n  join:    make(chan *client),\n  leave:   make(chan *client),\n  clients: make(map[*client]bool),\n}\n```", "```go\n// newRoom makes a new room that is ready to go.\nfunc newRoom() *room {\n  return &room{\n    forward: make(chan []byte),\n    join:    make(chan *client),\n    leave:   make(chan *client),\n    clients: make(map[*client]bool),\n  }\n}\n```", "```go\nfunc main() {\n  r := newRoom()\n  http.Handle(\"/\", &templateHandler{filename: \"chat.html\"})\n  http.Handle(\"/room\", r)\n  // get the room going\n  go r.run()\n  // start the web server\n  if err := http.ListenAndServe(\":8080\", nil); err != nil {\n    log.Fatal(\"ListenAndServe:\", err)\n  }\n}\n```", "```go\n<html>\n  <head>\n    <title>Chat</title>\n    <style>\n      input { display: block; }\n      ul    { list-style: none; }\n    </style>\n  </head>\n  <body>\n    <ul id=\"messages\"></ul>\n    <form id=\"chatbox\">\n      <textarea></textarea>\n      <input type=\"submit\" value=\"Send\" />\n       </form>  </body>\n</html>\n```", "```go\n    <script src=\"img/jquery.min.js\"></script>\n    <script>\n      $(function(){\n        var socket = null;\n        var msgBox = $(\"#chatbox textarea\");\n        var messages = $(\"#messages\");\n        $(\"#chatbox\").submit(function(){\n          if (!msgBox.val()) return false;\n          if (!socket) {\n            alert(\"Error: There is no socket connection.\");\n            return false;\n          }\n          socket.send(msgBox.val());\n          msgBox.val(\"\");\n          return false;\n        });\n        if (!window[\"WebSocket\"]) {\n          alert(\"Error: Your browser does not support web sockets.\")\n        } else {\n          socket = new WebSocket(\"ws://localhost:8080/room\");\n          socket.onclose = function() {\n            alert(\"Connection has been closed.\");\n          }\n          socket.onmessage = function(e) {\n            messages.append($(\"<li>\").text(e.data));\n          }\n        }\n      });\n    </script>\n```", "```go\nif err := http.ListenAndServe(\"\n:8080\n\n\", nil); err != nil {\n  log.Fatal(\"ListenAndServe:\", err)\n}\n```", "```go\nsocket = new WebSocket(\"ws://\nlocalhost:8080\n\n/room\");\n```", "```go\nfunc main() {  \n\nvar addr = flag.String(\"addr\", \":8080\", \"The addr of the application.\")\n\nflag.Parse() // parse the flags\n\n  r := newRoom()\n  http.Handle(\"/\", &templateHandler{filename: \"chat.html\"})\n  http.Handle(\"/room\", r)\n  // get the room going\n  go r.run()\n  // start the web server\n\nlog.Println(\"Starting web server on\", *addr)\n\n  if err := http.ListenAndServe(\n*addr\n\n, nil); err != nil {\n    log.Fatal(\"ListenAndServe:\", err)\n  }\n}\n```", "```go\nfunc (t *templateHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n  t.once.Do(func() {\n    t.templ = template.Must(template.ParseFiles(filepath.Join(\"templates\", t.filename)))\n  })\n\nt.templ.Execute(w, r)\n\n}\n```", "```go\nsocket = new WebSocket(\"ws://{{.Host}}/room\");\n```", "```go\ngo build -o chat\n./chat -addr=\":3000\"\n```", "```go\npackage trace\n// Tracer is the interface that describes an object capable of\n// tracing events throughout code.\ntype Tracer interface {\n  Trace(...interface{})\n}\n```", "```go\npackage trace\nimport (\n  \"testing\"\n)\nfunc TestNew(t *testing.T) {\n  t.Error(\"We haven't written our test yet\")\n}\n```", "```go\n\ngo test\n\n```", "```go\n\n--- FAIL: TestNew (0.00 seconds)\n\n tracer_test.go:8: We haven't written our test yet\n\nFAIL\n\nexit status 1\n\nFAIL  trace        0.011s\n\n```", "```go\nfunc TestNew(t *testing.T) {\n\n var buf bytes.Buffer\n\n tracer := New(&buf)\n\n if tracer == nil {\n\n t.Error(\"Return from New should not be nil\")\n\n } else {\n\n tracer.Trace(\"Hello trace package.\")\n\n if buf.String() != \"Hello trace package.\\n\" {\n\n t.Errorf(\"Trace should not write '%s'.\", buf.String())\n\n }\n\n }\n\n}\n```", "```go\nif true == true {\n  t.Error(\"True should be true\")\n}\n```", "```go\nfunc New() {}\n```", "```go\n\n./tracer_test.go:11: too many arguments in call to New\n\n./tracer_test.go:11: New(&buf) used as value\n\n```", "```go\nfunc New(w io.Writer) {}\n```", "```go\nfunc New(w io.Writer) Tracer {}\n```", "```go\n\n./tracer.go:13: missing return at end of function\n\n```", "```go\nfunc New(w io.Writer) Tracer {\n  return nil\n}\n```", "```go\n\ntracer_test.go:14: Return from New should not be nil\n\n```", "```go\ngo test -cover\n```", "```go\ntype tracer struct {\n  out io.Writer\n}\n\nfunc (t *tracer) Trace(a ...interface{}) {}\n```", "```go\nfunc New(w io.Writer) Tracer {\n  return &tracer{out: w}\n}\n```", "```go\n\ntracer_test.go:18: Trace should not write ''.\n\n```", "```go\nfunc (t *tracer) Trace(a ...interface{}) {\n  t.out.Write([]byte(fmt.Sprint(a...)))\n  t.out.Write([]byte(\"\\n\"))\n}\n```", "```go\n\ngo test -cover\n\nPASS\n\ncoverage: 100.0% of statements\n\nok    trace        0.011s\n\n```", "```go\ntype room struct {\n  // forward is a channel that holds incoming messages\n  // that should be forwarded to the other clients.\n  forward chan []byte\n  // join is a channel for clients wishing to join the room.\n  join chan *client\n  // leave is a channel for clients wishing to leave the room.\n  leave chan *client\n  // clients holds all current clients in this room.\n  clients map[*client]bool\n\n// tracer will receive trace information of activity\n\n // in the room.\n\n tracer trace.Tracer\n\n}\nfunc (r *room) run() {\n  for {\n    select {\n    case client := <-r.join:\n      // joining\n      r.clients[client] = true\n\nr.tracer.Trace(\"New client joined\")\n\n    case client := <-r.leave:\n      // leaving\n      delete(r.clients, client)\n      close(client.send)\n\nr.tracer.Trace(\"Client left\")\n\n    case msg := <-r.forward:\n      r.tracer.Trace(\"Message received: \", string(msg))\n      // forward message to all clients\n      for client := range r.clients {\n        select {\n        case client.send <- msg:\n          // send the message\n\nr.tracer.Trace(\" -- sent to client\")\n\n        default:\n          // failed to send\n          delete(r.clients, client)\n          close(client.send)\n\nr.tracer.Trace(\" -- failed to send, cleaned up client\")\n\n        }\n      }\n    }\n  }\n}\n```", "```go\nr := newRoom()\nr.tracer = trace.New(os.Stdout)\n```", "```go\n\nNew client joined\n\nNew client joined\n\nMessage received: Hello Chat\n\n -- sent to client\n\n -- sent to client\n\nMessage received: Good morning :)\n\n -- sent to client\n\n -- sent to client\n\nClient left\n\nClient left\n\n```", "```go\nfunc TestOff(t *testing.T) {\n  var silentTracer Tracer = Off()\n  silentTracer.Trace(\"something\")\n}\n```", "```go\ntype nilTracer struct{}\nfunc (t *nilTracer) Trace(a ...interface{}) {}\n// Off creates a Tracer that will ignore calls to Trace.\nfunc Off() Tracer {\n  return &nilTracer{}\n}\n```", "```go\nfunc newRoom() *room {\n  return &room{\n    forward: make(chan []byte),\n    join:    make(chan *client),\n    leave:   make(chan *client),\n    clients: make(map[*client]bool),\n    tracer:  trace.Off(),\n  }\n}\n```"]