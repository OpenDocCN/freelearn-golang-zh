- en: Chapter 1. Chat Application with Web Sockets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。带有Web套接字的聊天应用程序
- en: Go is great for writing high-performance, concurrent server applications and
    tools, and the Web is the perfect medium over which to deliver them. It would
    be difficult these days to find a gadget that is not web-enabled and allows us
    to build a single application that targets almost all platforms and devices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go非常适合编写高性能、并发的服务器应用程序和工具，而Web是传递它们的理想媒介。如今很难找到一个不支持Web的设备，并且允许我们构建一个针对几乎所有平台和设备的单一应用程序。
- en: Our first project will be a web-based chat application that allows multiple
    users to have a real-time conversation right in their web browser. Idiomatic Go
    applications are often composed of many packages, which are organized by having
    code in different folders, and this is also true of the Go standard library. We
    will start by building a simple web server using the `net/http` package, which
    will serve the HTML files. We will then go on to add support for web sockets through
    which our messages will flow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个项目将是一个基于Web的聊天应用程序，允许多个用户在其Web浏览器中进行实时对话。成语化的Go应用程序通常由许多包组成，这些包通过在不同文件夹中放置代码来组织，Go标准库也是如此。我们将首先使用`net/http`包构建一个简单的Web服务器，该服务器将提供HTML文件。然后，我们将继续添加对Web套接字的支持，通过它我们的消息将流动。
- en: In languages such as C#, Java, or Node.js, complex threading code and clever
    use of locks need to be employed in order to keep all clients in sync. As we will
    see, Go helps us enormously with its built-in channels and concurrency paradigms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如C＃，Java或Node.js之类的语言中，需要使用复杂的线程代码和巧妙地使用锁来保持所有客户端同步。正如我们将看到的，Go通过其内置的通道和并发范例极大地帮助了我们。
- en: 'In this chapter, you will learn how to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何：
- en: Use the `net/http` package to serve HTTP requests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`net/http`包来提供HTTP请求
- en: Deliver template-driven content to users' browsers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户的浏览器提供基于模板的内容
- en: Satisfy a Go interface to build our own `http.Handler` types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足Go接口以构建我们自己的`http.Handler`类型
- en: Use Go's goroutines to allow an application to perform multiple tasks concurrently
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Go的goroutines允许应用程序同时执行多个任务
- en: Use channels to share information between running Go routines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通道在运行的Go例程之间共享信息
- en: Upgrade HTTP requests to use modern features such as web sockets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级HTTP请求以使用诸如Web套接字之类的现代功能
- en: Add tracing to the application to better understand its inner workings
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序添加跟踪，以更好地了解其内部工作原理
- en: Write a complete Go package using test-driven development practices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试驱动开发实践编写完整的Go包
- en: Return unexported types through exported interfaces
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过导出的接口返回未导出的类型
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this project can be found at [https://github.com/matryer/goblueprints/tree/master/chapter1/chat](https://github.com/matryer/goblueprints/tree/master/chapter1/chat)
    . The source code was periodically committed so the history in GitHub actually
    follows the flow of this chapter too.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的完整源代码可以在[https://github.com/matryer/goblueprints/tree/master/chapter1/chat](https://github.com/matryer/goblueprints/tree/master/chapter1/chat)找到。源代码定期提交，因此GitHub中的历史实际上也遵循本章的流程。
- en: A simple web server
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的Web服务器
- en: 'The first thing our chat application needs is a web server that has two main
    responsibilities: it must serve the HTML and JavaScript chat clients that run
    in the user''s browser and accept web socket connections to allow the clients
    to communicate.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用程序首先需要一个具有两个主要职责的Web服务器：它必须为在用户浏览器中运行的HTML和JavaScript聊天客户端提供服务，并接受Web套接字连接以允许客户端进行通信。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `GOPATH` environment variable is covered in detail in [Appendix](text00062.html#page
    "Appendix A. Good Practices for a Stable Go Environment") , *Good Practices for
    a Stable Go Environment* . Be sure to read that first if you need help getting
    set up.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOPATH`环境变量在[附录](text00062.html#page "附录 A. 稳定的Go环境的良好实践")中有详细介绍，*稳定的Go环境的良好实践*。如果您需要帮助设置，请务必先阅读。'
- en: 'Create a `main.go` file inside a new folder called `chat` in your `GOPATH`
    and add the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GOPATH`中的新文件夹`chat`中创建一个`main.go`文件，并添加以下代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a complete albeit simple Go program that will:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完整但简单的Go程序，将会：
- en: Listen to the root path using the `net/http` package
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`net/http`包监听根路径
- en: Write out the hardcoded HTML when a request is made
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求被发出时，写出硬编码的HTML
- en: Start a web server on port `:8080` using the `ListenAndServe` method
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ListenAndServe`方法在端口`:8080`上启动Web服务器
- en: The `http.HandleFunc` function maps the path pattern `"/"` to the function we
    pass as the second argument, so when the user hits `http://localhost:8080/` ,
    the function will be executed. The function signature of `func(w http.ResponseWriter,
    r *http.Request)` is a common way of handling HTTP requests throughout the Go
    standard library.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.HandleFunc`函数将路径模式`"/"`映射到我们作为第二个参数传递的函数，因此当用户访问`http://localhost:8080/`时，该函数将被执行。`func(w
    http.ResponseWriter, r *http.Request)`的函数签名是处理整个Go标准库中的HTTP请求的常见方式。'
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We are using `package main` because we want to build and run our program from
    the command line. However, if we were building a reusable chatting package, we
    might choose to use something different, such as `package chat` .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`package main`，因为我们希望从命令行构建和运行我们的程序。然而，如果我们正在构建一个可重用的聊天包，我们可能会选择使用不同的东西，比如`package
    chat`。
- en: 'In a terminal, run the program by navigating to the `main.go` file you just
    created and execute:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，通过导航到您刚创建的`main.go`文件并执行以下命令来运行程序：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Open a browser to `localhost:8080` to see the **Let's chat!** message.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器到`localhost:8080`，看到**让我们聊天！**消息。
- en: Having the HTML code embedded within our Go code like this works, but it is
    pretty ugly and will only get worse as our projects grow. Next, we will see how
    templates can help us clean this up.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样将HTML代码嵌入到我们的Go代码中是有效的，但它非常丑陋，并且随着我们的项目增长，情况只会变得更糟。接下来，我们将看到模板如何帮助我们清理这些内容。
- en: Templates
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: 'Templates allow us to blend generic text with specific text, for instance,
    injecting a user''s name into a welcome message. For example, consider the following
    template:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 模板允许我们将通用文本与特定文本混合在一起，例如，将用户的姓名注入欢迎消息中。例如，考虑以下模板：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We are able to replace the `{name}` text in the preceding template with the
    real name of a person. So if Laurie signs in, she might see:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够用真实的人名替换前面模板中的`{name}`文本。所以如果Laurie登录，她可能会看到：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Go standard library has two main template packages: one called `text/template`
    for text and one called `html/template` for HTML. The `html/template` package
    does the same as the text version except that it understands the context in which
    data will be injected into the template. This is useful because it avoids script
    injection attacks and resolves common issues such as having to encode special
    characters for URLs.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库有两个主要的模板包：一个叫做`text/template`用于文本，另一个叫做`html/template`用于HTML。`html/template`包与文本版本相同，只是它了解数据将被注入模板的上下文。这很有用，因为它避免了脚本注入攻击，并解决了诸如必须对URL编码特殊字符之类的常见问题。
- en: Initially, we just want to move the HTML code from inside our Go code to its
    own file, but won't blend any text just yet. The template packages make loading
    external files very easy, so it's a good choice for us.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们只想将HTML代码从我们的Go代码中移动到自己的文件中，但暂时不混合任何文本。模板包使加载外部文件非常容易，所以这对我们来说是一个不错的选择。
- en: Create a new folder under our `chat` folder called `templates` and create a
    `chat.html` file inside it. We will move the HTML from `main.go` to this file,
    but we will make a minor change to ensure our changes have taken effect.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`chat`文件夹下创建一个名为`templates`的新文件夹，并在其中创建一个名为`chat.html`的文件。我们将HTML从`main.go`移动到这个文件中，但我们将进行一些小的更改，以确保我们的更改已生效。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we have our external HTML file ready to go, but we need a way to compile
    the template and serve it to the user's browser.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用外部HTML文件，但我们需要一种方法来编译模板并将其提供给用户的浏览器。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Compiling a template is a process by which the source template is interpreted
    and prepared for blending with various data, which must happen before a template
    can be used but only needs to happen once.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译模板是一个过程，通过这个过程，源模板被解释并准备好与各种数据混合，这必须在模板可以使用之前发生，但只需要发生一次。
- en: We are going to write our own `struct` type that is responsible for loading,
    compiling, and delivering our template. We will define a new type that will take
    a `filename` string, compile the template once (using the `sync.Once` type), keep
    the reference to the compiled template, and then respond to HTTP requests. You
    will need to import the `text/template` , `path/filepath` , and `sync` packages
    in order to build your code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写自己的`struct`类型，负责加载、编译和传递我们的模板。我们将定义一个新类型，它将接受一个`filename`字符串，一次编译模板（使用`sync.Once`类型），保持对编译模板的引用，然后响应HTTP请求。您需要导入`text/template`、`path/filepath`和`sync`包来构建您的代码。
- en: 'In `main.go` , insert the following code above the `func main()` line:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.go`中，在`func main()`行上面插入以下代码：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Did you know that you could automate the adding and removing of imported packages?
    See [Appendix](text00062.html#page "Appendix A. Good Practices for a Stable Go
    Environment") , *Good Practices for a Stable Go Environment* to learn how to do
    this.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道您可以自动添加和删除导入的包吗？请参阅[附录](text00062.html#page "附录 A. 稳定Go环境的良好实践")，*稳定Go环境的良好实践*，了解如何做到这一点。
- en: The `templateHandler` type has a single method called `ServeHTTP` whose signature
    looks suspiciously like the method we passed to `http.HandleFunc` earlier. This
    method will load the source file, compile the template and execute it, and write
    the output to the specified `http.ResponseWriter` object. Because the `ServeHTTP`
    method satisfies the `http.Handler` interface, we can actually pass it directly
    to `http.Handle` .
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`templateHandler`类型有一个名为`ServeHTTP`的单一方法，其签名看起来很像我们之前传递给`http.HandleFunc`的方法。这个方法将加载源文件，编译模板并执行它，并将输出写入指定的`http.ResponseWriter`对象。因为`ServeHTTP`方法满足`http.Handler`接口，我们实际上可以直接将它传递给`http.Handle`。'
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A quick look at the Go standard library source code, which is located at [http://golang.org/pkg/net/http/#Handler](http://golang.org/pkg/net/http/#Handler)
    , will reveal that the interface definition for `http.Handler` specifies that
    only the `ServeHTTP` method need be present in order for a type to be used to
    serve HTTP requests by the `net/http` package.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看位于[http://golang.org/pkg/net/http/#Handler](http://golang.org/pkg/net/http/#Handler)的Go标准库源代码，将会发现`http.Handler`的接口定义规定了只有`ServeHTTP`方法需要存在，才能使类型用于通过`net/http`包来提供HTTP请求。
- en: Doing things once
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只做一次的事情
- en: We only need to compile the template once, and there are a few different ways
    to approach this in Go. The most obvious is to have a `NewTemplateHandler` function
    that creates the type and calls some initialization code to compile the template.
    If we were sure the function would be called by only one goroutine (probably the
    main one during the setup in the `main` function), this would be a perfectly acceptable
    approach. An alternative, which we have employed in the preceding section, is
    to compile the template once inside the `ServeHTTP` method. The `sync.Once` type
    guarantees that the function we pass as an argument will only be executed once,
    regardless of how many goroutines are calling `ServeHTTP` . This is helpful because
    web servers in Go are automatically concurrent and once our chat application takes
    the world by storm, we could very well expect to have many concurrent calls to
    the `ServeHTTP` method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一次编译模板，Go中有几种不同的方法可以实现这一点。最明显的方法是有一个`NewTemplateHandler`函数来创建类型并调用一些初始化代码来编译模板。如果我们确信该函数只会被一个goroutine调用（可能是`main`函数中的主要函数），那么这将是一个完全可以接受的方法。另一种方法是在`ServeHTTP`方法内部编译模板一次，这是我们在前面的部分中采用的方法。`sync.Once`类型保证我们传递为参数的函数只会被执行一次，不管有多少goroutine在调用`ServeHTTP`。这很有帮助，因为Go中的Web服务器是自动并发的，一旦我们的聊天应用席卷世界，我们很可能会有许多并发调用`ServeHTTP`方法。
- en: Compiling the template inside the `ServeHTTP` method also ensures that our code
    does not waste time doing work before it is definitely needed. This lazy initialization
    approach doesn't save us much in our present case, but in cases where the setup
    tasks are time- and resource-intensive and where the functionality is used less
    frequently, it's easy to see how this approach would come in handy.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ServeHTTP`方法中编译模板还确保我们的代码在绝对需要之前不会浪费时间。这种懒惰的初始化方法在我们目前的情况下并没有节省太多时间，但在设置任务耗时和资源密集的情况下，并且功能使用频率较低的情况下，很容易看出这种方法会派上用场。
- en: Using your own handlers
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自己的处理程序
- en: 'To implement our `templateHandler` type, we need to update the `main` body
    function so that it looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的`templateHandler`类型，我们需要更新`main`主体函数，使其看起来像这样：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `templateHandler` structure is a valid `http.Handler` type so we can pass
    it directly to the `http.Handle` function and ask it to handle requests that match
    the specified pattern. In the preceding code, we created a new object of the type
    `templateHandler` specifying the filename as `chat.html` that we then take the
    address of (using the `&` **address of** operator) and pass it to the `http.Handle`
    function. We do not store a reference to our newly created `templateHandler` type,
    but that's OK because we don't need to refer to it again.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`templateHandler`结构是有效的`http.Handler`类型，因此我们可以直接将其传递给`http.Handle`函数，并要求它处理与指定模式匹配的请求。在前面的代码中，我们创建了一个`templateHandler`类型的新对象，指定文件名为`chat.html`，然后取其地址（使用`&`
    **地址**运算符）并将其传递给`http.Handle`函数。我们不存储对新创建的`templateHandler`类型的引用，但这没关系，因为我们不需要再次引用它。'
- en: In your terminal, exit the program by pressing *Ctrl* + *C* before re-running
    it, then refresh your browser and notice the addition of the (from template) text.
    Now our code is much simpler than an HTML code and free from those ugly blocks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，按下*Ctrl* + *C*退出程序，然后刷新您的浏览器，注意添加了（来自模板）文本。现在我们的代码比HTML代码简单得多，没有那些丑陋的块。
- en: Properly building and executing Go programs
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确构建和执行Go程序
- en: 'Running Go programs using a `go run` command is great when our code is made
    up of a single `main.go` file. However, often we might quickly need to add other
    files. This requires us to properly build the whole package into an executable
    binary before running it. This is simple enough, and from now on, this is how
    you will build and run your programs in a terminal:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`go run`命令运行Go程序时，当我们的代码由单个`main.go`文件组成时非常方便。然而，通常我们可能需要快速添加其他文件。这要求我们在运行之前将整个包正确构建为可执行二进制文件。这很简单，从现在开始，这就是您将在终端中构建和运行程序的方式：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `go build` command creates the output binary using all the `.go` files in
    the specified folder, and the `-o` flag indicates the name of the generated binary.
    You can then just run the program directly by calling it by name.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`go build`命令使用指定文件夹中的所有`.go`文件创建输出二进制文件，`-o`标志指示生成的二进制文件的名称。然后，您只需通过名称调用程序直接运行程序。'
- en: 'For example, in the case of our chat application, we could run:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的聊天应用程序中，我们可以运行：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since we are compiling templates the first time the page is served, we will
    need to restart your web server program every time anything changes in order to
    see the changes take effect.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在首次提供页面时编译模板，因此每次发生更改时，我们都需要重新启动您的Web服务器程序，以查看更改生效。
- en: Modeling a chat room and clients on the server
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上建模聊天室和客户端
- en: All users (clients) of our chat application will automatically be placed in
    one big public room where everyone can chat with everyone else. The `room` type
    will be responsible for managing client connections and routing messages in and
    out, while the `client` type represents the connection to a single client.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们聊天应用程序的所有用户（客户端）将自动放置在一个大的公共房间中，每个人都可以与其他人聊天。`room`类型将负责管理客户端连接并路由消息进出，而`client`类型表示与单个客户端的连接。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Go refers to classes as types and instances of those classes as objects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Go将类称为类型，将这些类的实例称为对象。
- en: To manage our web sockets, we are going to use one of the most powerful aspects
    of the Go community—open source third-party packages. Every day new packages solving
    real-world problems are released, ready for you to use in your own projects and
    even allow you to add features, report and fix bugs, and get support.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理我们的网络套接字，我们将使用Go社区最强大的一个方面——开源第三方包。每天都会发布解决现实问题的新包，供您在自己的项目中使用，甚至允许您添加功能，报告和修复错误，并获得支持。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is often unwise to reinvent the wheel unless you have a very good reason.
    So before embarking on building a new package, it is worth searching for any existing
    projects that might have already solved your very problem. If you find one similar
    project that doesn't quite satisfy your needs, consider contributing to the project
    and adding features. Go has a particularly active open source community (remember
    that Go itself is open source) that is always ready to welcome new faces or avatars.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重新发明轮子通常是不明智的，除非您有非常好的理由。因此，在着手构建新包之前，值得搜索可能已经解决了您的问题的任何现有项目。如果找到一个类似的项目，但不完全满足您的需求，请考虑为该项目添加功能。Go拥有一个特别活跃的开源社区（请记住Go本身也是开源的），随时欢迎新面孔或头像。
- en: We are going to use Gorilla Project's `websocket` package to handle our server-side
    sockets rather than write our own. If you're curious about how it works, head
    over to the project home page on GitHub, [https://github.com/gorilla/websocket](https://github.com/gorilla/websocket)
    , and browse the open source code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Gorilla Project的`websocket`包来处理我们的服务器端套接字，而不是编写我们自己的。如果您对它的工作原理感到好奇，请转到GitHub上的项目主页，[https://github.com/gorilla/websocket](https://github.com/gorilla/websocket)，并浏览开源代码。
- en: Modeling the client
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建模客户端
- en: 'Create a new file called `client.go` alongside `main.go` in the `chat` folder
    and add the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat`文件夹中的`main.go`旁边创建一个名为`client.go`的新文件，并添加以下代码：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, socket will hold a reference to the web socket that will
    allow us to communicate with the client, and the `send` field is a buffered channel
    through which received messages are queued ready to be forwarded to the user's
    browser (via the socket). The `room` field will keep a reference to the room that
    the client is chatting in—this is required so that we can forward messages to
    everyone else in the room.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，套接字将保存一个与客户端通信的网络套接字的引用，`send`字段是一个缓冲通道，通过它接收到的消息排队准备转发到用户的浏览器（通过套接字）。`room`字段将保留客户端正在聊天的房间的引用——这是必需的，以便我们可以将消息转发给房间中的其他所有人。
- en: 'If you try to build this code, you will notice a few errors. You must ensure
    that you have called `go get` to retrieve the `websocket` package, which is as
    easy as opening a terminal and typing the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试构建此代码，您将注意到一些错误。您必须确保已调用`go get`来检索`websocket`包，这很容易，只需打开终端并输入以下内容：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Building the code again will yield another error:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建代码将产生另一个错误：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The problem is that we have referred to a `room` type without defining it anywhere.
    To make the compiler happy, create a file called `room.go` and insert the following
    placeholder code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们引用了一个未定义的`room`类型。为了让编译器满意，创建一个名为`room.go`的文件，并插入以下占位符代码：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will improve this definition later once we know a little more about what
    our room needs to do, but for now, this will allow us to proceed. Later, the `forward`
    channel is what we will use to send the incoming messages to all other clients.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了房间需要做什么，我们将稍后改进这个定义，但现在这将允许我们继续。稍后，`forward`通道将用于将传入的消息发送到所有其他客户端。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can think of channels as an in-memory thread-safe message queue where senders
    pass data and receivers read data in a non-blocking, thread-safe way.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将通道视为内存中的线程安全消息队列，发送者通过非阻塞的线程安全方式传递数据，接收者读取数据。
- en: 'In order for a client to do any work, we must define some methods that will
    do the actual reading and writing to and from the web socket. Adding the following
    code to `client.go` outside (underneath) the `client` struct will add two methods
    called `read` and `write` to the `client` type:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让客户端执行任何工作，我们必须定义一些方法，这些方法将实际读取和写入到网络套接字。将以下代码添加到`client.go`之外（在`client`结构下方）将向`client`类型添加名为`read`和`write`的两个方法：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `read` method allows our client to read from the socket via the `ReadMessage`
    method, continually sending any received messages to the `forward` channel on
    the `room` type. If it encounters an error (such as `'the socket has died'` ),
    the loop will break and the socket will be closed. Similarly, the `write` method
    continually accepts messages from the `send` channel writing everything out of
    the socket via the `WriteMessage` method. If writing to the socket fails, the
    `for` loop is broken and the socket is closed. Build the package again to ensure
    everything compiles.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`方法允许我们的客户端通过`ReadMessage`方法从套接字中读取，不断将接收到的任何消息发送到`room`类型的`forward`通道。如果遇到错误（例如“套接字已断开”），循环将中断并关闭套接字。类似地，`write`方法不断接受`send`通道的消息，通过`WriteMessage`方法将所有内容写入套接字。如果向套接字写入失败，`for`循环将中断并关闭套接字。再次构建包以确保一切都编译。'
- en: Modeling a room
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建模一个房间
- en: 'We need a way for clients to join and leave rooms in order to ensure that the
    `c.room.forward <- msg` code in the preceding section actually forwards the message
    to all the clients. To ensure that we are not trying to access the same data at
    the same time, a sensible approach is to use two channels: one that will add a
    client to the room and another that will remove it. Let''s update our `room.go`
    code to look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法让客户端加入和离开房间，以确保前面部分中的`c.room.forward <- msg`代码实际上将消息转发给所有客户端。为了确保我们不会同时尝试访问相同的数据，一个明智的方法是使用两个通道：一个用于向房间添加客户端，另一个用于将其删除。让我们更新我们的`room.go`代码如下：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have added three fields: two channels and a map. The `join` and `leave`
    channels exist simply to allow us to safely add and remove clients from the `clients`
    map. If we were to access the map directly, it is possible that two Go routines
    running concurrently might try to modify the map at the same time resulting in
    corrupt memory or an unpredictable state.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了三个字段：两个通道和一个映射。`join`和`leave`通道存在的简单目的是允许我们安全地向`clients`映射中添加和删除客户端。如果我们直接访问映射，可能会出现两个同时运行的Go例程同时尝试修改映射，导致内存损坏或不可预测的状态。
- en: Concurrency programming using idiomatic Go
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用符合惯例的Go并发编程
- en: Now we get to use an extremely powerful feature of Go's concurrency offerings—the
    `select` statement. We can use `select` statements whenever we need to synchronize
    or modify shared memory, or take different actions depending on the various activities
    within our channels.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用Go并发提供的一个非常强大的功能——`select`语句。我们可以在需要同步或修改共享内存，或根据通道内的各种活动采取不同的操作时使用`select`语句。
- en: 'Beneath the `room` structure, add the following `run` method that contains
    two of these `select` clauses:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`room`结构下方，添加包含两个`select`子句的`run`方法：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Although this might seem like a lot of code to digest, once we break it down
    a little, we will see that it is fairly simple, although extremely powerful. The
    top `for` loop indicates that this method will run forever, until the program
    is terminated. This might seem like a mistake, but remember, if we run this code
    as a Go routine, it will run in the background, which won''t block the rest of
    our application. The preceding code will keep watching the three channels inside
    our room: `join` , `leave` , and `forward` . If a message is received on any of
    those channels, the `select` statement will run the code for that particular case.
    It is important to remember that it will only run one block of case code at a
    time. This is how we are able to synchronize to ensure that our `r.clients` map
    is only ever modified by one thing at a time.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能看起来是很多代码要消化，但一旦我们稍微分解一下，我们就会发现它其实相当简单，尽管非常强大。顶部的`for`循环表示这个方法将一直运行，直到程序被终止。这可能看起来像是一个错误，但请记住，如果我们将这段代码作为Go例程运行，它将在后台运行，不会阻塞我们应用程序的其余部分。前面的代码将一直监视我们房间内的三个通道：`join`，`leave`和`forward`。如果在这些通道中收到消息，`select`语句将运行特定情况的代码块。重要的是要记住，它一次只会运行一个case代码块。这就是我们能够同步以确保我们的`r.clients`地图一次只能被一件事情修改的方式。
- en: If we receive a message on the `join` channel, we simply update the `r.clients`
    map to keep a reference of the client that has joined the room. Notice that we
    are setting the value to `true` . We are using the map more like a slice, but
    do not have to worry about shrinking the slice as clients come and go through
    time—setting the value to `true` is just a handy, low-memory way of storing the
    reference.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`join`通道上收到消息，我们只需更新`r.clients`地图以保留已加入房间的客户端的引用。请注意，我们将值设置为`true`。我们使用地图更像是一个切片，但不必担心随着时间的推移客户端的增减而收缩切片
    - 将值设置为`true`只是一种方便的、低内存的存储引用的方式。
- en: If we receive a message on the `leave` channel, we simply delete the `client`
    type from the map, and close its `send` channel. Closing a channel has special
    significance in Go, which becomes clear when we look at our final `select` case.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`leave`通道上收到消息，我们只需从地图中删除`client`类型，并关闭其`send`通道。关闭通道在Go语言中具有特殊的意义，当我们看到最终的`select`语句时，这一点就变得很清楚了。
- en: If we receive a message on the `forward` channel, we iterate over all the clients
    and `send` the message down each client's send channel. Then, the `write` method
    of our client type will pick it up and send it down the socket to the browser.
    If the `send` channel is closed, then we know the client is not receiving any
    more messages, and this is where our second `select` clause (specifically the
    default case) takes the action of removing the client from the room and tidying
    things up.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`forward`通道上收到消息，我们会遍历所有客户端，并将消息发送到每个客户端的发送通道。然后，我们的客户端类型的`write`方法将接收并将其发送到浏览器的套接字。如果`send`通道关闭，那么我们知道客户端不再接收任何消息，这就是我们的第二个`select`子句（特别是默认情况）采取的移除客户端并整理事情的操作。
- en: Turning a room into an HTTP handler
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将房间转换为HTTP处理程序
- en: 'Now we are going to turn our `room` type into an `http.Handler` type like we
    did with the template handler earlier. As you will recall, to do this, we must
    simply add a method called `ServeHTTP` with the appropriate signature. Add the
    following code to the bottom of the `room.go` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把我们的`room`类型转换为`http.Handler`类型，就像我们之前对模板处理程序所做的那样。您会记得，为了做到这一点，我们只需添加一个名为`ServeHTTP`的方法，具有适当的签名。将以下代码添加到`room.go`文件的底部：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `ServeHTTP` method means a room can now act as a handler. We will implement
    it shortly, but first let's have a look at what is going on in this snippet of
    code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServeHTTP`方法意味着房间现在可以作为处理程序。我们很快将实现它，但首先让我们看看这段代码中发生了什么。'
- en: In order to use web sockets, we must upgrade the HTTP connection using the `websocket.Upgrader`
    type, which is reusable so we need only create one. Then, when a request comes
    in via the `ServeHTTP` method, we get the socket by calling the `upgrader.Upgrade`
    method. All being well, we then create our client and pass it into the `join`
    channel for the current room. We also defer the leaving operation for when the
    client is finished, which will ensure everything is tidied up after a user goes
    away.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Web套接字，我们必须使用`websocket.Upgrader`类型升级HTTP连接，该类型是可重用的，因此我们只需要创建一个。然后，当请求通过`ServeHTTP`方法进入时，我们通过调用`upgrader.Upgrade`方法获取套接字。一切顺利的话，我们就创建客户端并将其传递到当前房间的`join`通道中。我们还推迟了客户端完成后的离开操作，这将确保用户离开后一切都整理得很好。
- en: The `write` method for the client is then called as a Go routine, as indicated
    by the three characters at the beginning of the line `go` (the word `go` followed
    by a space character). This tells Go to run the method in a different thread or
    goroutine.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，客户端的`write`方法被调用为Go例程，如行首的三个字符所示`go`（单词`go`后跟一个空格字符）。这告诉Go在不同的线程或goroutine中运行该方法。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Compare the amount of code needed to achieve multithreading or concurrency in
    other languages with the three key presses that achieve it in Go, and you will
    see why it has become a favorite among systems developers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 比较在其他语言中实现多线程或并发所需的代码量与在Go中实现它的三个关键按键，您会发现为什么它已经成为系统开发人员中的最爱。
- en: Finally, we call the `read` method in the main thread, which will block operations
    (keeping the connection alive) until it's time to close it. Adding constants at
    the top of the snippet is a good practice for declaring values that would otherwise
    be hardcoded throughout the project. As these grow in number, you might consider
    putting them in a file of their own, or at least at the top of their respective
    files so they remain easy to read and modify.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在主线程中调用`read`方法，它将阻塞操作（保持连接活动），直到关闭连接的时候。在代码片段的顶部添加常量是一个很好的做法，用于声明在整个项目中原本将硬编码的值。随着这些值的增加，您可能会考虑将它们放在自己的文件中，或者至少放在各自文件的顶部，以便保持易读易修改。
- en: Use helper functions to remove complexity
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用辅助函数来减少复杂性
- en: 'Our room is almost ready to use, although in order for it to be of any use,
    the channels and map need to be created. As it is, this could be achieved by asking
    the developer to use the following code to be sure to do this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的房间几乎可以使用了，尽管为了让它有用，需要创建频道和地图。目前，可以通过要求开发者使用以下代码来实现这一点：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Another, slightly more elegant, solution is to instead provide a `newRoom`
    function that does this for us. This removes the need for others to know about
    exactly what needs to be done in order for our room to be useful. Underneath the
    `type room struct` definition, add this function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个稍微更加优雅的解决方案是提供一个`newRoom`函数来代替。这样就不需要其他人知道确切需要做什么才能让我们的房间有用。在`type room struct`的定义下面，添加这个函数：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now the users of our code need only call the `newRoom` function instead of the
    more verbose six lines of code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的代码用户只需要调用`newRoom`函数，而不是更冗长的六行代码。
- en: Creating and using rooms
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用房间
- en: 'Let''s update our `main` function in `main.go` to first create and then run
    a room for everybody to connect to:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`main.go`中的`main`函数，首先创建，然后运行一个房间，让每个人都可以连接到：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We are running the room in a separate Go routine (notice the `go` keyword again)
    so that the chatting operations occur in the background, allowing our main thread
    to run the web server. Our server is now finished and successfully built, but
    remains useless without clients to interact with.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个单独的Go例程中运行房间（再次注意`go`关键字），以便聊天操作在后台进行，使我们的主线程运行Web服务器。我们的服务器现在已经完成并成功构建，但没有客户端进行交互，它仍然是无用的。
- en: Building an HTML and JavaScript chat client
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建HTML和JavaScript聊天客户端
- en: In order for the users of our chat application to interact with the server and
    therefore other users, we need to write some client-side code that makes use of
    the web sockets found in modern browsers. We are already delivering HTML content
    via the template when users hit the root of our application, so we can enhance
    that.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的聊天应用程序的用户与服务器以及其他用户进行交互，我们需要编写一些客户端代码，利用现代浏览器中的Web套接字。当用户访问我们应用程序的根目录时，我们已经通过模板传递HTML内容，所以我们可以增强它。
- en: 'Update the `chat.html` file in the `templates` folder with the following markup:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下标记更新`templates`文件夹中的`chat.html`文件：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding HTML will render a simple web form on the page containing a text
    area and a **Send** button—this is how our users will submit messages to the server.
    The `messages` element in the preceding code will contain the text of the chat
    messages so that all the users can see what is being said. Next, we need to add
    some JavaScript to add some functionality to our page. Underneath the `form` tag,
    above the closing `</body>` tag, insert the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的HTML将在页面上呈现一个简单的网络表单，其中包含一个文本区域和一个“发送”按钮——这是我们的用户将消息提交到服务器的方式。上述代码中的`messages`元素将包含聊天消息的文本，以便所有用户都能看到正在说什么。接下来，我们需要添加一些JavaScript来为我们的页面添加一些功能。在`form`标签下，在闭合的`</body>`标签上面，插入以下代码：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `socket = new WebSocket("ws://localhost:8080/room")` line is where we open
    the socket and add event handlers for two key events: `onclose` and `onmessage`
    . When the socket receives a message, we use jQuery to append the message to the
    list element and thus present it to the user.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket = new WebSocket("ws://localhost:8080/room")`这一行是我们打开套接字并为两个关键事件`onclose`和`onmessage`添加事件处理程序的地方。当套接字接收到消息时，我们使用jQuery将消息附加到列表元素，从而呈现给用户。'
- en: Submitting the HTML form triggers a call to `socket.send` , which is how we
    send messages to the server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 提交HTML表单触发对`socket.send`的调用，这是我们向服务器发送消息的方式。
- en: Build and run the program again to ensure the templates recompile so these changes
    are represented.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建和运行程序，以确保模板重新编译，以便这些更改得到体现。
- en: Navigate to `http://localhost:8080/` in two separate browsers (or two tabs of
    the same browser) and play with the application. You will notice that messages
    sent from one client appear instantly in the other clients.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的浏览器（或同一个浏览器的两个标签）中导航到`http://localhost:8080/`并使用应用程序。您会注意到从一个客户端发送的消息立即出现在其他客户端中。
- en: '![Building an HTML and JavaScript chat client](img/Image00001.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![构建HTML和JavaScript聊天客户端](img/Image00001.jpg)'
- en: Getting more out of templates
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多地利用模板
- en: Currently, we are using templates to deliver static HTML, which is nice because
    it gives us a clean and simple way to separate the client code from the server
    code. However, templates are actually much more powerful, and we are going to
    tweak our application to make some more realistic use of them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在使用模板传递静态HTML，这很好，因为它为我们提供了一种清晰简单的方法来将客户端代码与服务器代码分离。然而，模板实际上更加强大，我们将调整我们的应用程序以更加现实地使用它们。
- en: 'The host address of our application (`:8080` ) is hardcoded in two places at
    the moment. The first instance is in `main.go` where we start the web server:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的主机地址（`:8080`）目前在两个地方都是硬编码的。第一个实例是在`main.go`中启动Web服务器的地方：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The second time it is hardcoded in the JavaScript when we open the socket:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次是在JavaScript中硬编码的，当我们打开套接字时：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our chat application is pretty stubborn if it insists on only running locally
    on port `8080` , so we are going to use command-line flags to make it configurable
    and then use the injection capabilities of templates to make sure our JavaScript
    knows the right host.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用程序非常固执，坚持只在本地端口`8080`上运行，因此我们将使用命令行标志使其可配置，然后使用模板的注入功能确保我们的JavaScript知道正确的主机。
- en: 'Update your `main` function in `main.go` :'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`main.go`中的`main`函数：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You will need to import the `flag` package in order for this code to build.
    The definition for the `addr` variable sets up our flag as a string that defaults
    to `:8080` (with a short description of what the value is intended for). We must
    call `flag.Parse()` that parses the arguments and extracts the appropriate information.
    Then, we can reference the value of the host flag by using `*addr` .
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此代码构建，您需要导入`flag`包。`addr`变量的定义将我们的标志设置为一个默认为`:8080`的字符串（并简要描述了该值的用途）。我们必须调用`flag.Parse()`来解析参数并提取适当的信息。然后，我们可以通过使用`*addr`引用主机标志的值。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The call to `flag.String` returns a type of `*string` , which is to say it returns
    the address of a string variable where the value of the flag is stored. To get
    the value itself (and not the address of the value), we must use the pointer indirection
    operator, `*` .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对`flag.String`的调用返回`*string`类型，也就是说它返回存储标志值的字符串变量的地址。要获取值本身（而不是值的地址），我们必须使用指针间接操作符`*`。
- en: We also added a `log.Println` call to output the address in the terminal so
    we can be sure that our changes have taken effect.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`log.Println`调用，以在终端中输出地址，以确保我们的更改已生效。
- en: 'We are going to modify the `templateHandler` type we wrote so that it passes
    the details of the request as data into the template''s `Execute` method. In `main.go`
    , update the `ServeHTTP` function to pass the request `r` as the `data` argument
    to the `Execute` method:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们编写的`templateHandler`类型，以便将请求的详细信息作为数据传递到模板的`Execute`方法中。在`main.go`中，更新`ServeHTTP`函数，将请求`r`作为`data`参数传递给`Execute`方法：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This tells the template to render itself using data that can be extracted from
    `http.Request` , which happens to include the host address that we need.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉模板使用可以从`http.Request`中提取的数据进行渲染，其中包括我们需要的主机地址。
- en: 'To use the `Host` value of `http.Request` , we can then make use of the special
    template syntax that allows us to inject data. Update the line where we create
    our socket in the `chat.html` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`http.Request`的`Host`值，我们可以利用特殊的模板语法来注入数据。更新我们在`chat.html`文件中创建套接字的行：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The double curly braces represent an annotation and the way we tell our template
    source to inject data. `{{.Host}}` is essentially the equivalent of telling it
    to replace the annotation with the value from `request.Host` (since we passed
    the request `r` object in as data).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 双花括号表示注释，告诉模板源注入数据的方式。`{{.Host}}`本质上等同于告诉它用`request.Host`的值替换注释（因为我们将请求`r`对象作为数据传递）。
- en: Tip
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We have only scratched the surface of the power of the templates built into
    Go's standard library. The `text/template` package documentation is a great place
    to learn more about what you can achieve. You can find out more about it at [http://golang.org/pkg/text/template](http://golang.org/pkg/text/template)
    .
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是初步了解了Go标准库中内置模板的强大功能。`text/template`包的文档是了解更多内容的好地方。您可以在[http://golang.org/pkg/text/template](http://golang.org/pkg/text/template)找到更多信息。
- en: 'Rebuild and run the chat program again, but this time notice that the chatting
    operations no longer produce an error, whichever host we specify:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建并再次运行聊天程序，但是这次请注意，无论我们指定哪个主机，聊天操作都不再产生错误：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: View the source of the page in the browser and notice that `{{.Host}}` has been
    replaced with the actual host of the application. Valid hosts aren't just port
    numbers; you can also specify the IP addresses or other hostnames—provided they
    are allowed in your environment, for example, `-addr="192.168.0.1:3000"` .
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看页面源代码，注意`{{.Host}}`已被实际应用的主机替换。有效的主机不仅仅是端口号；您还可以指定IP地址或其他主机名——只要它们在您的环境中被允许，例如`-addr="192.168.0.1:3000"`。
- en: Tracing code to get a look under the hood
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪代码以深入了解内部情况
- en: The only way we will know that our application is working is by opening two
    or more browsers and using our UI to send messages. In other words, we are manually
    testing our code. This is fine for experimental projects such as our chat application
    or small projects that aren't expected to grow, but if our code is to have a longer
    life or be worked on by more than one person, manual testing of this kind becomes
    a liability. We are not going to tackle **Test-driven Development** ( **TDD**
    ) for our chat program, but we should explore another useful debugging technique
    called **tracing** .
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一知道我们的应用程序是否工作的方法是打开两个或更多浏览器，并使用我们的UI发送消息。换句话说，我们正在手动测试我们的代码。这对于实验性项目（如我们的聊天应用程序）或不希望增长的小项目来说是可以接受的，但是如果我们的代码要有更长的寿命或由多个人共同开发，这种手动测试就成了一种负担。我们不打算为我们的聊天程序解决**测试驱动开发**（**TDD**），但我们应该探索另一种有用的调试技术，称为**跟踪**。
- en: Tracing is a practice by which we log or print key steps in the flow of a program
    to make what is going on under the covers visible. In the previous section, we
    added a `log.Println` call to output the address that the chat program was binding
    to. In this section, we are going to formalize this and write our own complete
    tracing package.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪是一种实践，通过它我们可以记录或打印程序流程中的关键步骤，以使程序内部发生的事情可见。在前一节中，我们添加了一个`log.Println`调用来输出聊天程序绑定到的地址。在本节中，我们将正式化这一过程，并编写我们自己完整的跟踪包。
- en: We are going to explore TDD practices when writing our tracing code because
    it is a perfect example of a package that we are likely to reuse, add to, share,
    and hopefully, even open source.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索TDD实践，因为编写跟踪代码是一个完美的例子，我们很可能会重用、添加、共享，甚至开源。
- en: Writing a package using TDD
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TDD编写包
- en: Packages in Go are organized into folders, with one package per folder. It is
    a build error to have differing package declarations within the same folder because
    all sibling files are expected to contribute to a single package. Go has no concept
    of subpackages, which means nested packages (in nested folders) exist only for
    aesthetic or informational reasons but do not inherit any functionality or visibility
    from super packages. In our chat application, all of our files contributed to
    the `main` package because we wanted to build an executable tool. Our tracing
    package will never be run directly, so it can and should use a different package
    name. We will also need to think about the **Application Programming Interface**
    ( **API** ) of our package, considering how to model a package so that it remains
    as extensible and flexible as possible for users. This includes the fields, functions,
    methods, and types that should be exported (visible to the user) and remain hidden
    for simplicity's sake.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的包被组织到文件夹中，每个文件夹一个包。在同一个文件夹中有不同的包声明会导致构建错误，因为所有同级文件都被期望为单个包做出贡献。Go没有子包的概念，这意味着嵌套包（在嵌套文件夹中）只存在于美学或信息上的原因，但不会继承任何功能或可见性。在我们的聊天应用中，所有文件都属于`main`包，因为我们想要构建一个可执行工具。我们的追踪包永远不会直接运行，因此可以并且应该使用不同的包名。我们还需要考虑我们包的**应用程序编程接口**（**API**），考虑如何建模一个包，使其对用户来说尽可能具有可扩展性和灵活性。这包括应该导出（对用户可见）的字段、函数、方法和类型，以及为简单起见应该保持隐藏的内容。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Go uses capitalization of names to denote which items are exported such that
    names that begin with a capital letter (for example, `Tracer` ) are visible to
    users of a package, and names that begin with a lowercase letter (for example,
    `templateHandler` ) are hidden or private.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用名称的大写来表示哪些项目是导出的，以便以大写字母开头的名称（例如`Tracer`）对包的用户可见，以小写字母开头的名称（例如`templateHandler`）是隐藏或私有的。
- en: Create a new folder called `trace` , which will be the name of our tracing package,
    alongside the `chat` folder.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat`文件夹旁边创建一个名为`trace`的新文件夹，这将是我们追踪包的名称。
- en: 'Before we jump into the code, let''s agree on some design goals for our package
    by which we can measure success:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，让我们就我们包的一些设计目标达成一致，以便衡量成功：
- en: The package should be easy to use
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包应该易于使用
- en: Unit tests should cover the functionality
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该覆盖功能
- en: Users should have the flexibility to replace the tracer with their own implementation
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该有灵活性来用自己的实现替换追踪器
- en: Interfaces
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces in Go are an extremely powerful language feature that allow us to
    define an API without being strict or specific on the implementation details.
    Wherever possible, describing the basic building blocks of your packages using
    interfaces usually ends up paying dividends down the road, and this is where we
    will start for our tracing package.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的接口是一种非常强大的语言特性，它允许我们定义一个API而不严格或具体地定义实现细节。在可能的情况下，使用接口描述包的基本构建块通常会在未来产生回报，这也是我们追踪包的起点。
- en: 'Create a new file called `tracer.go` inside the `trace` folder and write the
    following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trace`文件夹内创建一个名为`tracer.go`的新文件，并写入以下代码：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first thing to notice is that we have defined our package as `trace` .
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们将包定义为`trace`。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While it is a good practice to have the folder name match the package name,
    Go tools do not enforce it, which means you are free to name them differently
    if it makes sense. Remember, when people import your package, they will type the
    name of the folder, and if suddenly a package with a different name is imported,
    it could get confusing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将文件夹名称与包名称匹配是一个好习惯，但Go工具不强制执行这一点，这意味着如果有意义，你可以自由地给它们命名不同的名称。记住，当人们导入你的包时，他们会输入文件夹的名称，如果突然导入了一个不同名称的包，可能会让人困惑。
- en: Our `Tracer` type (the capital `T` means we intend this to be a publicly visible
    type) is an interface that describes a single method called `Trace` . The `...interface{}`
    argument type states that our `Trace` method will accept zero or more arguments
    of any type. You might think that this is redundant since the method should just
    take a single string (we want to just trace out some string of characters, don't
    we?). However, consider functions such as `fmt.Sprint` and `log.Fatal` , both
    of which follow a pattern littered through to Go's standard library that provides
    a helpful shortcut when trying to communicate multiple things in one go. Wherever
    possible, we should follow such patterns and practices because we want our own
    APIs to be familiar and clear to the Go community.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Tracer`类型（大写的`T`表示我们打算将其作为公开可见类型）是一个描述单个名为`Trace`的方法的接口。`...interface{}`参数类型表示我们的`Trace`方法将接受零个或多个任意类型的参数。你可能会认为这是多余的，因为该方法应该只接受一个字符串（我们只想追踪一些字符的字符串，不是吗？）。然而，考虑到`fmt.Sprint`和`log.Fatal`等函数，它们都遵循了Go标准库中的一种模式，提供了一个有用的快捷方式，用于一次性传递多个内容。在可能的情况下，我们应该遵循这样的模式和实践，因为我们希望我们自己的API对Go社区来说是熟悉和清晰的。
- en: Unit tests
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: We promised ourselves we would follow test-driven practices, but interfaces
    are simply definitions that do not provide any implementation and so cannot be
    directly tested. But we are about to write a real implementation of a `Tracer`
    method, and we will indeed write the tests first.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们答应自己要遵循测试驱动的实践，但接口只是定义，不提供任何实现，因此无法直接进行测试。但我们即将编写一个`Tracer`方法的真正实现，并且我们确实会先编写测试。
- en: 'Create a new file called `tracer_test.go` in the `trace` folder and insert
    the following scaffold code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trace`文件夹中创建一个名为`tracer_test.go`的新文件，并插入以下框架代码：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Testing was built into the Go tool chain from the very beginning, making writing
    automatable tests a first-class citizen. The test code lives alongside the production
    code in files suffixed with `_test.go` . The Go tools will treat any function
    that starts with `Test` (taking a single `*testing.T` argument) as a unit test,
    and it will be executed when we run our tests. To run them for this package, navigate
    to the `trace` folder in a terminal and do the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是从一开始就内置在Go工具链中的，使得编写可自动化测试成为一等公民。测试代码与生产代码一起存放在以`_test.go`结尾的文件中。Go工具将把任何以`Test`开头的函数（接受一个`*testing.T`参数）视为单元测试，并在运行测试时执行它们。要为此包运行它们，请在终端中导航到`trace`文件夹并执行以下操作：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will see that our tests fail because of our call to `t.Error` in the body
    of our `TestNew` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到我们的测试失败，因为我们在`TestNew`函数的主体中调用了`t.Error`：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Clearing the terminal before each test run is a great way to make sure you aren't
    confusing previous runs with the most recent one. On Windows, you can use the
    `cls` command; on Unix machines, the `clear` command does the same thing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次测试运行之前清除终端是一个很好的方法，可以确保您不会将之前的运行与最近的运行混淆。在Windows上，您可以使用`cls`命令；在Unix机器上，`clear`命令可以做同样的事情。
- en: 'Obviously, we haven''t properly written our test and we don''t expect it to
    pass yet, so let''s update the `TestNew` function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们没有正确地编写我们的测试，我们也不希望它通过，所以让我们更新`TestNew`函数：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Most packages throughout the book are available from the Go standard library,
    so you can add an `import` statement for the appropriate package in order to access
    the package. Others are external, and that's when you need to use `go get` to
    download them before they can be imported. For this case, you'll need to add `import
    "bytes"` to the top of the file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数包都来自Go标准库，因此您可以添加适当的包的`import`语句以访问该包。其他包是外部的，这时您需要使用`go get`来下载它们，然后才能导入。对于这种情况，您需要在文件顶部添加`import
    "bytes"`。
- en: We have started designing our API by becoming the first user of it. We want
    to be able to capture the output of our tracer in a `bytes.Buffer` so that we
    can then ensure that the string in the buffer matches the expected value. If it
    does not, a call to `t.Errorf` will fail the test. Before that, we check to make
    sure the return from a made-up `New` function is not `nil` ; again, if it is,
    the test will fail because of the call to `t.Error` .
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始通过成为第一个用户来设计我们的API。我们希望能够在`bytes.Buffer`中捕获我们的跟踪器的输出，以便我们可以确保缓冲区中的字符串与预期值匹配。如果不匹配，对`
    t.Errorf`的调用将使测试失败。在此之前，我们检查一下虚构的`New`函数的返回值是否不是`nil`；同样，如果是，测试将因为对` t.Error`的调用而失败。
- en: Red-green testing
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 红绿测试
- en: Running `go test` now actually produces an error; it complains that there is
    no `New` function. We haven't made a mistake here; we are following a practice
    known as red-green testing. Red-green testing proposes that we first write a unit
    test, see it fail (or produce an error), write the minimum amount of code possible
    to make that test pass, and rinse and repeat it again. The key point here being
    that we want to make sure the code we add is actually doing something as well
    as ensuring that the test code we write is testing something meaningful.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`go test`实际上会产生一个错误；它抱怨没有`New`函数。我们没有犯错；我们正在遵循一种被称为红绿测试的实践。红绿测试建议我们首先编写一个单元测试，看到它失败（或产生错误），然后编写尽可能少的代码使该测试通过，并重复这个过程。这里的关键点是我们要确保我们添加的代码实际上正在做一些事情，并确保我们编写的测试代码正在测试一些有意义的东西。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Consider a meaningless test for a minute:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一分钟的无意义测试：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It is logically impossible for true to not be true (if true ever equals false,
    it's time to get a new computer), and so our test is pointless. If a test or claim
    cannot fail, there is no value whatsoever to be found in it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑上不可能让true不等于true（如果true等于false，那么是时候换台新电脑了），因此我们的测试是毫无意义的。如果测试或声明不能失败，那么它就毫无价值。
- en: Replacing `true` with a variable that you expect to be set to `true` under certain
    conditions would mean that such a test can indeed fail (like when the code being
    tested is misbehaving)—at this point, you have a meaningful test that is worth
    contributing to the code base.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将`true`替换为一个您希望在特定条件下设置为`true`的变量，这意味着这样的测试确实可能失败（比如在被测试的代码行为不当时）——在这一点上，您有一个值得为代码库做出贡献的有意义的测试。
- en: 'You can treat the output of `go test` like a to-do list, solving only one problem
    at a time. Right now, the complaint about the missing `New` function is all we
    will address. In the `trace.go` file, let''s add the minimum amount of code possible
    to progress with things; add the following snippet underneath the interface type
    definition:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`go test`的输出视为待办事项列表，一次只解决一个问题。现在，我们只会解决有关缺少`New`函数的投诉。在`trace.go`文件中，让我们添加尽可能少的代码来继续进行；在接口类型定义下面添加以下代码片段：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running `go test` now shows us that things have indeed progressed, albeit not
    very far. We now have two errors:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`go test`会显示事情确实有所进展，尽管进展不是很大。我们现在有两个错误：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first error tells us that we are passing arguments to our `New` function,
    but the `New` function doesn''t accept any. The second error says that we are
    using the return of the `New` function as a value, but that the `New` function
    doesn''t return anything. You might have seen this coming, and indeed as you gain
    more experience writing test-driven code, you will most likely jump over such
    trivial details. However, to properly illustrate the method, we are going to be
    pedantic for a while. Let''s address the first error by updating our `New` function
    to take in the expected argument:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个错误告诉我们，我们正在向我们的`New`函数传递参数，但`New`函数不接受任何参数。第二个错误说我们正在使用`New`函数的返回值作为值，但`New`函数并不返回任何东西。您可能已经预料到了这一点，确实随着您在编写测试驱动的代码方面获得更多经验，您很可能会跳过这样的琐事。但是，为了正确地说明这种方法，我们将要有一段时间的迂腐。让我们通过更新我们的`New`函数来解决第一个错误：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are taking an argument that satisfies the `io.Writer` interface, which means
    that the specified object must have a suitable `Write` method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接收一个满足`io.Writer`接口的参数，这意味着指定的对象必须有一个合适的`Write`方法。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using existing interfaces, especially ones found in the Go standard library,
    is an extremely powerful and often necessary way to ensure that your code is as
    flexible and elegant as possible.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有接口，特别是在Go标准库中找到的接口，是确保您的代码尽可能灵活和优雅的一种极其强大且经常必要的方式。
- en: Accepting `io.Writer` means that the user can decide where the tracing output
    will be written. This output could be the standard output, a file, network socket,
    `bytes.Buffer` as in our test case, or even some custom-made object, provided
    it implements the `Write` method of the `io.Writer` interface
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接受`io.Writer`意味着用户可以决定跟踪输出将写入何处。这个输出可以是标准输出，文件，网络套接字，`bytes.Buffer`，甚至是一些自定义对象，只要它实现了`io.Writer`接口的`Write`方法。
- en: 'Running `go test` again shows us that we have resolved the first error and
    we only need add a return type in order to progress past our second error:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`go test`显示我们已解决第一个错误，我们只需要添加一个返回类型以继续通过第二个错误：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We are stating that our `New` function will return a `Tracer` , but we do not
    return anything, which `go test` happily complains about:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明我们的`New`函数将返回一个`Tracer`，但我们没有返回任何东西，这让`go test`很高兴地抱怨：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Fixing this is easy; we can just return `nil` from the `New` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这很容易；我们可以从`New`函数中返回`nil`：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Of course, our test code has asserted that the return should not be `nil` ,
    so `go test` now gives us a failure message:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的测试代码已经断言返回值不应该是`nil`，所以`go test`现在给我们一个失败消息：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can see how a strict adherence to the red-green principle can get a little
    tedious, but it is vital that we do not jump too far ahead. If we were to write
    a lot of implementation code in one go, we will very likely have code that is
    not covered by a unit test.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到严格遵循红绿原则可能有点乏味，但非常重要的是我们不要跳得太远。如果我们一次写很多实现代码，很可能会有代码没有被单元测试覆盖。
- en: 'The ever-thoughtful core team has even solved this problem for us by providing
    code coverage statistics which we can generate by running the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 体贴的核心团队甚至通过提供代码覆盖率统计数据来解决了这个问题，我们可以通过运行以下命令生成：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Provided that all tests pass, adding the `-cover` flag will tell us how much
    of our code was touched during the execution of the tests. Obviously, the closer
    we get to 100 percent the better.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 只要所有测试通过，添加`-cover`标志将告诉我们在执行测试期间有多少代码被触及。显然，我们越接近100%越好。
- en: Implementing the interface
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现接口
- en: 'To satisfy this test, we need something that we can properly return from the
    `New` method because `Tracer` is only an interface and we have to return something
    real. Let''s add an implementation of a tracer to our `tracer.go` file:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这个测试，我们需要一个可以从`New`方法中正确返回的东西，因为`Tracer`只是一个接口，我们必须返回一些真实的东西。让我们在`tracer.go`文件中添加一个tracer的实现：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our implementation is extremely simple; the `tracer` type has an `io.Writer`
    field called `out` which is where we will write the trace output to. And the `Trace`
    method exactly matches the method required by the `Tracer` interface, although
    it doesn't do anything yet.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现非常简单；`tracer`类型有一个名为`out`的`io.Writer`字段，我们将把跟踪输出写入其中。`Trace`方法与`Tracer`接口所需的方法完全匹配，尽管它目前什么也不做。
- en: 'Now we can finally fix the `New` method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于可以修复`New`方法了：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Running `go test` again shows us that our expectation was not met because nothing
    was written during our call to `Trace` :'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`go test`显示我们的期望没有达到，因为在调用`Trace`时没有写入任何内容：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s update our `Trace` method to write the blended arguments to the specified
    `io.Writer` field:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的`Trace`方法，将混合参数写入指定的`io.Writer`字段：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When the `Trace` method is called, we call `Write` on the `io.Writer` stored
    in the `out` field and use `fmt.Sprint` to format the `a` arguments. We convert
    the string return type from `fmt.Sprint` to `string` and then to `[]byte` because
    that is what is expected by the `io.Writer` interface.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`Trace`方法时，我们在`out`字段中存储的`io.Writer`上调用`Write`，并使用`fmt.Sprint`格式化`a`参数。我们将`fmt.Sprint`的字符串返回类型转换为`string`，然后转换为`[]byte`，因为这是`io.Writer`接口所期望的。
- en: Have we finally satisfied our test?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终满足了我们的测试吗？
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Congratulations! We have successfully passed our test and have `100.0%` test
    coverage. Once we have finished our glass of champagne, we can take a minute to
    consider something very interesting about our implementation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们成功通过了测试，测试覆盖率为`100.0%`。一旦我们喝完香槟，我们可以花一分钟时间考虑一下我们的实现非常有趣的地方。
- en: Unexported types being returned to users
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将未导出的类型返回给用户
- en: The `tracer` struct type we wrote is unexported because it begins with a lowercase
    `t` , so how is it that we are able to return it from the exported `New` function?
    After all, doesn't the user receive the returned object? This is perfectly acceptable
    and valid Go code; the user will only ever see an object that satisfies the `Tracer`
    interface and will never even know about our private `tracer` type. Since they
    only ever interact with the interface anyway, it wouldn't matter if our `tracer`
    implementation exposed other methods or fields; they would never be seen. This
    allows us to keep the public API of our package clean and simple.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的`tracer`结构类型是未导出的，因为它以小写的`t`开头，那么我们如何能够从导出的`New`函数中返回它呢？毕竟，用户会接收到返回的对象吗？这是完全可以接受和有效的Go代码；用户只会看到一个满足`Tracer`接口的对象，甚至不会知道我们私有的`tracer`类型。由于他们只与接口交互，我们的`tracer`实现暴露其他方法或字段也无所谓；它们永远不会被看到。这使我们能够保持包的公共API清晰简单。
- en: This hidden implementation technique is used throughout the Go standard library,
    for example, the `ioutil.NopCloser` method is a function that turns a normal `io.Reader`
    into `io.ReadCloser` whereas the `Close` method does nothing (used for when `io.Reader`
    objects that don't need to be closed are passed into functions that require `io.ReadCloser`
    types). The method returns `io.ReadCloser` as far as the user is concerned, but
    under the hood, there is a secret `nopCloser` type hiding the implementation details.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种隐藏的实现技术在Go标准库中被广泛使用，例如，`ioutil.NopCloser`方法是一个将普通的`io.Reader`转换为`io.ReadCloser`的函数，而`Close`方法什么也不做（用于将不需要关闭的`io.Reader`对象传递给需要`io.ReadCloser`类型的函数）。该方法在用户看来返回`io.ReadCloser`，但在底层，有一个秘密的`nopCloser`类型隐藏了实现细节。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To see this for yourself, browse the Go standard library source code at [http://golang.org/src/pkg/io/ioutil/ioutil.go](http://golang.org/src/pkg/io/ioutil/ioutil.go)
    and search for the `nopCloser` struct.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要亲自看到这一点，请浏览Go标准库源代码[http://golang.org/src/pkg/io/ioutil/ioutil.go](http://golang.org/src/pkg/io/ioutil/ioutil.go)，并搜索`nopCloser`结构。
- en: Using our new trace package
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用我们的新的trace包
- en: Now that we have completed the first version of our `trace` package, we can
    use it in our chat application in order to better understand what is going on
    when users send messages through the user interface.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`trace`包的第一个版本，我们可以在聊天应用程序中使用它，以更好地理解用户通过用户界面发送消息时发生了什么。
- en: In `room.go` , let's import our new package and make some calls to the `Trace`
    method. The path to the `trace` package we just wrote will depend on your `GOPATH`
    environment variable because the import path is relative to the `$GOPATH/src`
    folder. So if you create your `trace` package in `$GOPATH/src/mycode/trace` ,
    then you would need to import `mycode/trace` .
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`room.go`中，让我们导入我们的新包并对`Trace`方法进行一些调用。我们刚刚编写的`trace`包的路径将取决于您的`GOPATH`环境变量，因为导入路径是相对于`$GOPATH/src`文件夹的。因此，如果您在`$GOPATH/src/mycode/trace`中创建了`trace`包，则需要导入`mycode/trace`。
- en: 'Update the `room` type and the `run()` method like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样更新`room`类型和`run()`方法：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We added a `trace.Tracer` field to our `room` type and then made periodic calls
    to the `Trace` method peppered throughout the code. If we run our program and
    try to send messages, you''ll notice that the application panics because the `tracer`
    field is `nil` . We can remedy this for now by making sure we create and assign
    an appropriate object when we create our `room` type. Update the `main.go` file
    to do this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`room`类型中添加了一个`trace.Tracer`字段，然后在整个代码中定期调用`Trace`方法。如果我们运行程序并尝试发送消息，您会注意到应用程序会因为`tracer`字段为`nil`而发生panic。我们可以通过确保在创建`room`类型时创建并分配一个适当的对象来暂时解决这个问题。更新`main.go`文件以执行此操作：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We are using our `New` method to create an object that will send the output
    to the `os.Stdout` standard output pipe (this is a technical way of saying we
    want it to print the output to our terminal).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的`New`方法来创建一个对象，该对象将输出发送到`os.Stdout`标准输出管道（这是一种技术方式，表示我们希望它将输出打印到我们的终端）。
- en: 'Now rebuild and run the program and use two browsers to play with the application,
    and notice that the terminal now has some interesting trace information for us:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新构建并运行程序，并使用两个浏览器玩耍应用程序，注意终端现在有一些有趣的跟踪信息供我们查看：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now we are able to use the debug information to get an insight into what the
    application is doing, which will assist us when developing and supporting our
    project.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够使用调试信息来洞察应用程序的运行情况，这将在开发和支持项目时对我们有所帮助。
- en: Making tracing optional
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使跟踪变为可选
- en: Once the application is released, the sort of tracing information we are generating
    will be pretty useless if it's just printed out to some terminal somewhere, or
    even worse, if it creates a lot of noise for our systems administrators. Also,
    remember that when we don't set a tracer for our `room` type, our code panics,
    which isn't a very user-friendly situation. To resolve these two issues, we are
    going to enhance our `trace` package with a `trace.Off()` method that will return
    an object that satisfies the `Tracer` interface but will not do anything when
    the `Trace` method is called.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序发布，我们生成的跟踪信息将变得非常无用，如果它只是打印到某个终端上，甚至更糟的是，如果它为我们的系统管理员创建了大量噪音。另外，请记住，当我们没有为`room`类型设置跟踪器时，我们的代码会发生panic，这并不是一个非常用户友好的情况。为了解决这两个问题，我们将增强我们的`trace`包，添加一个`trace.Off()`方法，该方法将返回一个满足`Tracer`接口但在调用`Trace`方法时不执行任何操作的对象。
- en: 'Let''s add a test that calls the `Off` function to get a silent tracer before
    making a call to `Trace` to ensure the code doesn''t panic. Since the tracing
    won''t happen, that''s all we can do in our test code. Add the following test
    function to the `tracer_test.go` file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个测试，调用`Off`函数以获取一个静默的tracer，然后调用`Trace`以确保代码不会发生panic。由于跟踪不会发生，这就是我们在测试代码中能做的全部。将以下测试函数添加到`tracer_test.go`文件中：
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To make it pass, add the following code to the `tracer.go` file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其通过，将以下代码添加到`tracer.go`文件中：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Our `nilTracer` struct has defined a `Trace` method that does nothing, and a
    call to the `Off()` method will create a new `nilTracer` struct and return it.
    Notice that our `nilTracer` struct differs from our `tracer` struct in that it
    doesn't take an `io.Writer` ; it doesn't need one because it isn't going to write
    anything.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`nilTracer`结构定义了一个什么也不做的`Trace`方法，调用`Off()`方法将创建一个新的`nilTracer`结构并返回它。请注意，我们的`nilTracer`结构与我们的`tracer`结构不同，它不需要`io.Writer`；因为它不会写任何东西。
- en: 'Now let''s solve our second problem by updating our `newRoom` method in the
    `room.go` file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过更新`room.go`文件中的`newRoom`方法来解决我们的第二个问题：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'By default, our `room` type will be created with a `nilTracer` struct and any
    calls to `Trace` will just be ignored. You can try this out by removing the `r.tracer
    = trace.New(os.Stdout)` line from the `main.go` file: notice that nothing gets
    written to the terminal when you use the application and there is no panic.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的`room`类型将使用`nilTracer`结构创建，并且对`Trace`的任何调用都将被忽略。您可以通过从`main.go`文件中删除`r.tracer
    = trace.New(os.Stdout)`行来尝试这一点：注意当您使用应用程序时没有任何内容被写入终端，并且没有发生恐慌。
- en: Clean package APIs
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清晰的包API
- en: 'A quick glance at the API (in this context, the exposed variables, methods,
    and types) for our `trace` package highlights that a simple and obvious design
    has emerged:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览API（在这种情况下，暴露的变量、方法和类型）我们的`trace`包突出显示了一个简单明显的设计已经出现：
- en: The `New()` method
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New()`方法'
- en: The `Off()` method
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Off()`方法'
- en: The `Tracer` interface
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tracer`接口'
- en: I would be very confident to give this package to a Go programmer without any
    documentation or guidelines, and I'm pretty sure they would know what do to with
    it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常有信心将这个包交给一个没有任何文档或指南的Go程序员，我相信他们会知道如何处理它。
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Go, adding documentation is as simple as adding comments to the line before
    each item. The blog post on the subject is a worthwhile read ([http://blog.golang.org/godoc-documenting-go-code](http://blog.golang.org/godoc-documenting-go-code)
    ), where you can see a copy of the hosted source code for `tracer.go` that is
    an example of how you might annotate the `trace` package. For more information,
    refer to [github.com/matryer/goblueprints/blob/master/chapter1/trace/tracer.go](http://github.com/matryer/goblueprints/blob/master/chapter1/trace/tracer.go)
    .
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，添加文档就像在每个项目的前一行添加注释一样简单。关于这个主题的博客文章是值得一读的（[http://blog.golang.org/godoc-documenting-go-code](http://blog.golang.org/godoc-documenting-go-code)），在那里你可以看到`tracer.go`的托管源代码的副本，这是一个你可能如何注释`trace`包的示例。有关更多信息，请参阅[github.com/matryer/goblueprints/blob/master/chapter1/trace/tracer.go](http://github.com/matryer/goblueprints/blob/master/chapter1/trace/tracer.go)。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we developed a complete concurrent chat application and our
    own simple package to trace the flow of our programs to help us better understand
    what is going on under the hood.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个完整的并发聊天应用程序，以及我们自己简单的包来跟踪程序的流程，以帮助我们更好地理解底层发生了什么。
- en: We used the `net/http` package to quickly build what turned out to be a very
    powerful concurrent HTTP web server. In one particular case, we then upgraded
    the connection to open a web socket between the client and server. This means
    that we can easily and quickly communicate messages to the user's web browser
    without having to write messy polling code. We explored how templates are useful
    to separate the code from the content as well as to allow us to inject data into
    our template source, which let us make the host address configurable. Command-line
    flags helped us give simple configuration control to the people hosting our application
    while also letting us specify sensible defaults.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`net/http`包快速构建了一个非常强大的并发HTTP Web服务器。在一个特定的情况下，我们升级了连接以在客户端和服务器之间打开一个Web套接字。这意味着我们可以轻松快速地向用户的Web浏览器发送消息，而不必编写混乱的轮询代码。我们探讨了模板如何有用地将代码与内容分离，以及允许我们将数据注入到我们的模板源中，这使我们可以使主机地址可配置。命令行标志帮助我们为托管我们的应用程序的人提供简单的配置控制，同时让我们指定合理的默认值。
- en: Our chat application made use of Go's powerful concurrency capabilities that
    allowed us to write clear *threaded* code in just a few lines of idiomatic Go.
    By controlling the coming and going of clients through channels, we were able
    to set synchronization points in our code that prevented us from corrupting memory
    by attempting to modify the same objects at the same time.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用程序利用了Go强大的并发能力，使我们能够用几行惯用的Go代码编写清晰的*线程化*代码。通过通过通道控制客户端的到来和离开，我们能够在代码中设置同步点，防止我们尝试同时修改相同对象而破坏内存。
- en: We learned how interfaces such as `http.Handler` and our own `trace.Tracer`
    allow us to provide disparate implementations without having to touch the code
    that makes use of them, and in some cases, without having to expose even the name
    of the implementation to our users. We saw how just by adding a `ServeHTTP` method
    to our `room` type, we turned our custom room concept into a valid HTTP handler
    object, which managed our web socket connections.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了诸如`http.Handler`和我们自己的`trace.Tracer`这样的接口，使我们能够提供不同的实现，而无需触及使用它们的代码，并且在某些情况下，甚至无需向用户公开实现的名称。我们看到，通过向我们的`room`类型添加`ServeHTTP`方法，我们将我们的自定义房间概念转变为一个有效的HTTP处理程序对象，它管理我们的Web套接字连接。
- en: 'We aren''t actually very far away from being able to properly release our application,
    except for one major oversight: you cannot see who sent each message. We have
    no concept of users or even user names, and for a real chat application, this
    is not acceptable.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们离能够正确发布我们的应用程序并不远，除了一个重大的疏忽：你无法看到谁发送了每条消息。我们没有用户的概念，甚至没有用户名，对于一个真正的聊天应用来说，这是不可接受的。
- en: In the next chapter, we will add the names of the people responding to their
    messages in order to make them feel like they are having a real conversation with
    other humans.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加回复消息的人的名称，以使他们感觉自己正在与其他人进行真正的对话。
