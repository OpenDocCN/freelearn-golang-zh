["```go\none | two\n```", "```go\npackage main\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"math/rand\"\n  \"os\"\n  \"strings\"\n  \"time\"\n)\nconst otherWord = \"*\"\nvar transforms = []string{\n  otherWord,\n  otherWord,\n  otherWord,\n  otherWord,\n  otherWord + \"app\",\n  otherWord + \"site\",\n  otherWord + \"time\",\n  \"get\" + otherWord,\n  \"go\" + otherWord,\n  \"lets \" + otherWord,\n}\nfunc main() {\n  rand.Seed(time.Now().UTC().UnixNano())\n  s := bufio.NewScanner(os.Stdin)\n  for s.Scan() {\n    t := transforms[rand.Intn(len(transforms))]\n    fmt.Println(strings.Replace(t, otherWord, s.Text(), -1))\n  }\n}\n```", "```go\n\ngo build \u2013o sprinkle\n\n./sprinkle\n\n```", "```go\n\nchat\n\ngo chat\n\nchat\n\nlets chat\n\nchat\n\nchat app\n\n```", "```go\n\necho \"chat\" | ./sprinkle\n\n```", "```go\npackage main\nvar tlds = []string{\"com\", \"net\"}\nconst allowedChars = \"abcdefghijklmnopqrstuvwxyz0123456789_-\"\nfunc main() {\n  rand.Seed(time.Now().UTC().UnixNano())\n  s := bufio.NewScanner(os.Stdin)\n  for s.Scan() {\n    text := strings.ToLower(s.Text())\n    var newText []rune\n    for _, r := range text {\n      if unicode.IsSpace(r) {\n        r = '-'\n      }\n      if !strings.ContainsRune(allowedChars, r) {\n        continue\n      }\n      newText = append(newText, r)\n    }\n    fmt.Println(string(newText) + \".\" +        \n                tlds[rand.Intn(len(tlds))])\n  }\n}\n```", "```go\n\ngo build \u2013o domainify\n\n./domainify\n\n```", "```go\n\n./sprinkle/sprinkle | ./domainify/domainify\n\n```", "```go\npackage main\nconst (\n  duplicateVowel bool   = true\n  removeVowel    bool   = false\n) \nfunc randBool() bool {\n  return rand.Intn(2) == 0\n}\nfunc main() {\n  rand.Seed(time.Now().UTC().UnixNano())\n  s := bufio.NewScanner(os.Stdin)\n  for s.Scan() {\n    word := []byte(s.Text())\n    if randBool() {\n      var vI int = -1\n      for i, char := range word {\n        switch char {\n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n          if randBool() {\n            vI = i\n          }\n        }\n      }\n      if vI >= 0 {\n        switch randBool() {\n        case duplicateVowel:\n          word = append(word[:vI+1], word[vI:]...)\n        case removeVowel:\n          word = append(word[:vI], word[vI+1:]...)\n        }\n      }\n    }\n    fmt.Println(string(word))\n  }\n}\n```", "```go\nswitch randBool() {\ncase true:\n  word = append(word[:vI+1], word[vI:]...)\ncase false:\n  word = append(word[:vI], word[vI+1:]...)\n}\n```", "```go\n\ngo build \u2013o coolify\n\n./coolify\n\n```", "```go\n\nblueprnts\n\nbleprints\n\nbluepriints\n\nblueprnts\n\nblueprints\n\nbluprints\n\n```", "```go\n\n./coolify/coolify | ./sprinkle/sprinkle | ./domainify/domainify\n\n```", "```go\nexport BHT_APIKEY=abc123def456ghi789jkl\n```", "```go\n{\n  \"noun\":{\n    \"syn\":[\n      \"passion\",\n      \"beloved\",\n      \"dear\"\n    ]\n  },\n  \"verb\":{\n    \"syn\":[\n      \"love\",\n      \"roll in the hay\",\n      \"make out\"\n    ],\n    \"ant\":[\n      \"hate\"\n    ]\n  }\n}\n```", "```go\npackage thesaurus\nimport (\n  \"encoding/json\"\n  \"errors\"\n  \"net/http\"\n)\ntype BigHugh struct {\n  APIKey string\n}\ntype synonyms struct {\n  Noun *words `json:\"noun\"`\n  Verb *words `json:\"verb\"`\n}\ntype words struct {\n  Syn []string `json:\"syn\"`\n}\nfunc (b *BigHugh) Synonyms(term string) ([]string, error) {\n  var syns []string\n  response, err := http.Get(\"http://words.bighugelabs.com/api/2/\" + b.APIKey + \"/\" + term + \"/json\")\n  if err != nil {\n    return syns, errors.New(\"bighugh: Failed when looking for synonyms for \\\"\" + term + \"\\\"\" + err.Error())\n  }\n  var data synonyms\n  defer response.Body.Close()\n  if err := json.NewDecoder(response.Body).Decode(&data); err != nil {\n    return syns, err\n  }\n  syns = append(syns, data.Noun.Syn...)\n  syns = append(syns, data.Verb.Syn...)\n  return syns, nil\n}\n```", "```go\npackage thesaurus\ntype Thesaurus interface {\n  Synonyms(term string) ([]string, error)\n}\n```", "```go\nfunc main() {\n  apiKey := os.Getenv(\"BHT_APIKEY\")\n  thesaurus := &thesaurus.BigHugh{APIKey: apiKey}\n  s := bufio.NewScanner(os.Stdin)\n  for s.Scan() {\n    word := s.Text()\n    syns, err := thesaurus.Synonyms(word)\n    if err != nil {\n      log.Fatalln(\"Failed when looking for synonyms for \\\"\"+word+\"\\\"\", err)\n    }\n    if len(syns) == 0 {\n      log.Fatalln(\"Couldn't find any synonyms for \\\"\" + word + \"\\\"\")\n    }\n    for _, syn := range syns {\n      fmt.Println(syn)\n    }\n  }\n}\n```", "```go\n\ngo build \u2013o synonyms\n\n./synonyms\n\nchat\n\nconfab\n\nconfabulation\n\nschmooze\n\nNew World chat\n\nOld World chat\n\nconversation\n\nthrush\n\nwood warbler\n\nchew the fat\n\nshoot the breeze\n\nchitchat\n\nchatter\n\n```", "```go\n\n./synonyms/synonyms | ./sprinkle/sprinkle | ./coolify/coolify | ./domainify/domainify\n\n```", "```go\n\ngetcnfab.com\n\nconfabulationtim.com\n\ngetschmoozee.net\n\nschmosee.com\n\nneew-world-chatsite.net\n\noold-world-chatsite.com\n\nconversatin.net\n\nnew-world-warblersit.com\n\ngothrush.net\n\nlets-wood-wrbler.com\n\nchw-the-fat.com\n\n```", "```go\nfunc exists(domain string) (bool, error) {\n  const whoisServer string = \"com.whois-servers.net\"\n  conn, err := net.Dial(\"tcp\", whoisServer+\":43\")\n  if err != nil {\n    return false, err\n  }\n  defer conn.Close()\n  conn.Write([]byte(domain + \"\\r\\n\"))\n  scanner := bufio.NewScanner(conn)\n  for scanner.Scan() {\n    if strings.Contains(strings.ToLower(scanner.Text()), \"no match\") {\n      return false, nil\n    }\n  }\n  return true, nil\n}\n```", "```go\nvar marks = map[bool]string{true: \"\u2714\", false: \"\u00d7\"}\nfunc main() {\n  s := bufio.NewScanner(os.Stdin)\n  for s.Scan() {\n    domain := s.Text()\n    fmt.Print(domain, \" \")\n    exist, err := exists(domain)\n    if err != nil {\n      log.Fatalln(err)\n    }\n    fmt.Println(marks[!exist])\n    time.Sleep(1 * time.Second)\n  }\n}\n```", "```go\n\ngo build \u2013o available\n\n./available\n\n```", "```go\n\npacktpub.com\n\npacktpub.com \n\n\u00d7\n\ngoogle.com\n\ngoogle.com \n\n\u00d7\n\nmadeupdomain1897238746234.net\n\nmadeupdomain1897238746234.net \n\n\u2714\n```", "```go\n\n./synonyms/synonyms | ./sprinkle/sprinkle | ./coolify/coolify | ./domainify/domainify | ./available/available\n\n```", "```go\n#!/bin/bash\necho Building domainfinder...\ngo build -o domainfinder\necho Building synonyms...\ncd ../synonyms\ngo build -o ../domainfinder/lib/synonyms\necho Building available...\ncd ../available\ngo build -o ../domainfinder/lib/available\ncd ../build\necho Building sprinkle...\ncd ../sprinkle\ngo build -o ../domainfinder/lib/sprinkle\ncd ../build\necho Building coolify...\ncd ../coolify\ngo build -o ../domainfinder/lib/coolify\ncd ../build\necho Building domainify...\ncd ../domainify\ngo build -o ../domainfinder/lib/domainify\ncd ../build\necho Done.\n```", "```go\npackage main\nvar cmdChain = []*exec.Cmd{\n  exec.Command(\"lib/synonyms\"),\n  exec.Command(\"lib/sprinkle\"),\n  exec.Command(\"lib/coolify\"),\n  exec.Command(\"lib/domainify\"),\n  exec.Command(\"lib/available\"),\n}\nfunc main() {\n\n  cmdChain[0].Stdin = os.Stdin\n  cmdChain[len(cmdChain)-1].Stdout = os.Stdout\n\n  for i := 0; i < len(cmdChain)-1; i++ {\n    thisCmd := cmdChain[i]\n    nextCmd := cmdChain[i+1]\n    stdout, err := thisCmd.StdoutPipe()\n    if err != nil {\n      log.Fatalln(err)\n    }\n    nextCmd.Stdin = stdout\n  }\n\n  for _, cmd := range cmdChain {\n    if err := cmd.Start(); err != nil {\n      log.Fatalln(err)\n    } else {\n      defer cmd.Process.Kill()\n    }\n  }\n\n  for _, cmd := range cmdChain {\n    if err := cmd.Wait(); err != nil {\n      log.Fatalln(err)\n    }\n  }\n\n}\n```"]