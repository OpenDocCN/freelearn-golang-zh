- en: Chapter 4. Command-line Tools to Find Domain Names
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。用于查找域名的命令行工具
- en: The chat application we built in the previous chapters is ready to take the
    world by storm, but not before we give it a home on the Internet. Before we invite
    our friends to join the conversation, we need to pick a valid, catchy, and available
    domain name that we can point to the server running our Go code. Instead of sitting
    in front of our favorite domain name provider for hours on end trying different
    names, we are going to develop a few command-line tools that will help us find
    the right one. As we do so, we will see how the Go standard library allows us
    to interface with the terminal and other executing applications, as well as explore
    some patterns and practices to build command-line programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中构建的聊天应用程序已经准备好在互联网上大放异彩，但在邀请朋友加入对话之前，我们需要为其在互联网上找一个家。在邀请朋友加入对话之前，我们需要选择一个有效、引人注目且可用的域名，以便将其指向运行我们Go代码的服务器。我们将开发一些命令行工具，而不是在我们喜爱的域名提供商前面花费数小时尝试不同的名称，这些工具将帮助我们找到合适的域名。在这个过程中，我们将看到Go标准库如何允许我们与终端和其他正在执行的应用程序进行交互，以及探索一些构建命令行程序的模式和实践。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到：
- en: How to build complete command-line applications with as little as a single code
    file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用尽可能少的代码文件构建完整的命令行应用程序
- en: How to ensure that the tools we build can be composed with other tools using
    standard streams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保我们构建的工具可以使用标准流与其他工具组合
- en: How to interact with a simple third-party JSON RESTful API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与简单的第三方JSON RESTful API进行交互
- en: How to utilize the standard in and out pipes in Go code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Go代码中利用标准输入和输出管道
- en: How to read from a streaming source one line at a time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从流式源中逐行读取
- en: How to build a WHOIS client to look up domain information
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建WHOIS客户端来查找域信息
- en: How to store and use sensitive or deployment-specific information in environment
    variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何存储和使用敏感或部署特定信息的环境变量
- en: Pipe design for command-line tools
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行工具的管道设计
- en: We are going to build a series of command-line tools that use the standard streams
    (`stdin` and `stdout` ) to communicate with the user and with other tools. Each
    tool will take input line by line via the standard in pipe, process it in some
    way, and then print the output line by line to the standard out pipe for the next
    tool or for the user.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一系列命令行工具，这些工具使用标准流（`stdin`和`stdout`）与用户和其他工具进行通信。每个工具将通过标准输入管道逐行接收输入，以某种方式处理它，然后通过标准输出管道逐行打印输出，以供下一个工具或用户使用。
- en: 'By default, the standard input is connected to the user''s keyboard, and the
    standard output is printed to the terminal from which the command was run; however,
    both can be redirected using redirection metacharacters. It''s possible to throw
    the output away by redirecting it to `NUL` on Windows or `/dev/null` on Unix machines,
    or redirecting it to a file, which will cause the output to be saved to the disk.
    Alternatively, you can pipe (using the `|` pipe character) the output of one program
    into the input of another; it is this feature that we will make use of in order
    to connect our various tools together. For example, you could pipe the output
    from one program to the input of another program in a terminal by using this code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，标准输入连接到用户的键盘，标准输出打印到运行命令的终端；但是，可以使用重定向元字符进行重定向。可以通过将输出重定向到Windows上的“NUL”或Unix机器上的“/dev/null”来丢弃输出，也可以将其重定向到文件，这将导致输出保存到磁盘。或者，您可以使用“|”管道字符将一个程序的输出管道到另一个程序的输入；我们将利用这个特性来连接我们的各种工具。例如，您可以通过以下代码将一个程序的输出管道到终端中的另一个程序的输入：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our tools will work with lines of strings where each line (separated by a linefeed
    character) represents one string. When run without any pipe redirection, we will
    be able to interact directly with the programs using the default in and out, which
    will be useful when testing and debugging our code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具将使用字符串行的形式进行操作，其中每行（由换行符分隔）代表一个字符串。当没有任何管道重定向时，我们将能够直接与程序进行交互，使用默认的输入和输出，这在测试和调试代码时将非常有用。
- en: Five simple programs
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 五个简单的程序
- en: 'In this chapter, we will build five small programs that we will combine together
    at the end. The key features of the programs are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建五个小程序，最后将它们组合在一起。程序的主要特点如下：
- en: '**Sprinkle** : This program will add some web-friendly sprinkle words to increase
    the chances of finding available domain names'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sprinkle**：该程序将添加一些适合网络的词语，以增加找到可用域名的机会'
- en: '**Domainify** : This program will ensure words are acceptable for a domain
    name by removing unacceptable characters and replacing spaces with hyphens and
    adding an appropriate top-level domain (such as `.com` and `.net` ) to the end'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Domainify**：该程序将确保单词适合作为域名，方法是删除不可接受的字符，用连字符替换空格，并在末尾添加适当的顶级域（如“.com”和“.net”）'
- en: '**Coolify** : This program will make a boring old normal word into Web 2.0
    by fiddling around with vowels'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Coolify**：该程序将通过调整元音字母将无聊的普通单词变成Web 2.0'
- en: '**Synonyms** : This program will use a third-party API to find synonyms'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Synonyms**：该程序将使用第三方API查找同义词'
- en: '**Available** : This program will check to see whether the domain is available
    or not using an appropriate WHOIS server'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用**：该程序将使用适当的WHOIS服务器检查域名是否可用'
- en: Five programs might seem like a lot for one chapter, but don't forget how small
    entire programs can be in Go.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 五个程序在一个章节中可能看起来很多，但不要忘记在Go中整个程序可以有多小。
- en: Sprinkle
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sprinkle
- en: Our first program augments incoming words with some sugar terms in order to
    improve the odds of finding available names. Many companies use this approach
    to keep the core messaging consistent while being able to afford the `.com` domain.
    For example, if we pass in the word `chat` , it might pass out `chatapp` ; alternatively,
    if we pass in `talk` , we may get back `talk time` .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个程序通过添加一些糖词来增加找到可用名称的几率。许多公司使用这种方法来保持核心消息一致，同时又能够负担得起`.com`域名。例如，如果我们传入单词`chat`，它可能输出`chatapp`；或者，如果我们传入`talk`，我们可能得到`talk
    time`。
- en: Go's `math/rand` package allows us to break away from the predictability of
    computers to give a chance or opportunity to get involved in our program's process
    and make our solution feel a little more intelligent than it actually is.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Go的`math/rand`包允许我们摆脱计算机的可预测性，为我们的程序过程提供机会或机会，并使我们的解决方案感觉比实际更智能一些。
- en: 'To make our Sprinkle program work, we will:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的Sprinkle程序工作，我们将：
- en: Define an array of transformations using a special constant to indicate where
    the original word will appear
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特殊常量定义转换数组，以指示原始单词将出现在哪里
- en: Use the `bufio` package to scan input from `stdin` and `fmt.Println` to write
    output to `stdout`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bufio`包从`stdin`扫描输入，并使用`fmt.Println`将输出写入`stdout`
- en: Use the `math/rand` package to randomly select which transformation to apply
    to the word, such as appending "app" or prefixing the term with "get"
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`math/rand`包来随机选择要应用于单词的转换，比如在单词后添加"app"或在术语前添加"get"
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: All of our programs will reside in the `$GOPATH/src` directory. For example,
    if your `GOPATH` is `~/Work/projects/go` , you would create your program folders
    in the `~/Work/projects/go/src` folder.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的程序都将驻留在`$GOPATH/src`目录中。例如，如果您的`GOPATH`是`~/Work/projects/go`，您将在`~/Work/projects/go/src`文件夹中创建您的程序文件夹。
- en: 'In the `$GOPATH/src` directory, create a new folder called `sprinkle` and add
    a `main.go` file containing the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$GOPATH/src`目录中，创建一个名为`sprinkle`的新文件夹，并添加一个包含以下代码的`main.go`文件：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From now on, it is assumed that you will sort out the appropriate `import` statements
    yourself. If you need assistance, refer to the tips provided in [Appendix](text00062.html#page
    "Appendix A. Good Practices for a Stable Go Environment") , *Good Practices for
    a Stable Go Environment* .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，假定您将自行解决适当的`import`语句。如果需要帮助，请参考[附录](text00062.html#page "附录 A.稳定的Go环境的良好实践")中提供的提示，*稳定的Go环境的良好实践*。
- en: 'The preceding code represents our complete Sprinkle program. It defines three
    things: a constant, a variable, and the obligatory `main` function, which serves
    as the entry point to Sprinkle. The `otherWord` constant string is a helpful token
    that allows us to specify where the original word should occur in each of our
    possible transformations. It lets us write code such as `otherWord+"extra"` ,
    which makes it clear that, in this particular case, we want to add the word extra
    to the end of the original word.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码代表了我们完整的Sprinkle程序。它定义了三件事：一个常量，一个变量，以及作为Sprinkle入口点的必需的`main`函数。`otherWord`常量字符串是一个有用的标记，允许我们指定原始单词应出现在我们可能的每个转换中的位置。它让我们编写诸如`otherWord+"extra"`的代码，这清楚地表明，在这种特殊情况下，我们想在原始单词的末尾添加单词extra。
- en: The possible transformations are stored in the `transforms` variable that we
    declare as a slice of strings. In the preceding code, we defined a few different
    transformations such as adding `app` to the end of a word or `lets` before it.
    Feel free to add some more in there; the more creative, the better.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的转换存储在我们声明为字符串切片的`transforms`变量中。在前面的代码中，我们定义了一些不同的转换，比如在单词末尾添加`app`或在单词前添加`lets`。随意添加一些更多的转换；越有创意，越好。
- en: In the `main` function, the first thing we do is use the current time as a random
    seed. Computers can't actually generate random numbers, but changing the seed
    number for the random algorithms gives the illusion that it can. We use the current
    time in nanoseconds because it's different each time the program is run (provided
    the system clock isn't being reset before each run).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们首先使用当前时间作为随机种子。计算机实际上无法生成随机数，但更改随机算法的种子数字会产生它可以的幻觉。我们使用纳秒级的当前时间，因为每次运行程序时它都是不同的（前提是系统时钟在每次运行之前没有被重置）。
- en: We then create a `bufio.Scanner` object (called `bufio.NewScanner` ) and tell
    it to read input from `os.Stdin` , which represents the standard in stream. This
    will be a common pattern in our five programs since we are always going to read
    from standard in and write to standard out.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`bufio.Scanner`对象（称为`bufio.NewScanner`），并告诉它从`os.Stdin`读取输入，表示标准输入流。由于我们总是要从标准输入读取并写入标准输出，这将是我们五个程序中的常见模式。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `bufio.Scanner` object actually takes `io.Reader` as its input source, so
    there is a wide range of types that we could use here. If you were writing unit
    tests for this code, you could specify your own `io.Reader` for the scanner to
    read from, removing the need for you to worry about simulating the standard input
    stream.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufio.Scanner`对象实际上将`io.Reader`作为其输入源，因此我们可以在这里使用各种类型。如果您为此代码编写单元测试，可以为扫描器指定自己的`io.Reader`，从中读取，而无需担心模拟标准输入流的需要。'
- en: As the default case, the scanner allows us to read, one at a time, blocks of
    bytes separated by defined delimiters such as a carriage return and linefeed characters.
    We can specify our own split function for the scanner or use one of the options
    built in the standard library. For example, there is `bufio.ScanWords` that scans
    individual words by breaking on whitespace rather than linefeeds. Since our design
    specifies that each line must contain a word (or a short phrase), the default
    line-by-line setting is ideal.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为默认情况，扫描器允许我们逐个读取由定义的分隔符分隔的字节块，例如回车和换行符。我们可以为扫描器指定自己的分割函数，或者使用标准库中内置的选项之一。例如，有`bufio.ScanWords`可以通过在空格上断开而不是换行符上断开来扫描单个单词。由于我们的设计规定每行必须包含一个单词（或短语），默认的逐行设置是理想的。
- en: A call to the `Scan` method tells the scanner to read the next block of bytes
    (the next line) from the input, and returns a `bool` value indicating whether
    it found anything or not. This is how we are able to use it as the condition for
    the `for` loop. While there is content to work on, `Scan` returns `true` and the
    body of the `for` loop is executed, and when `Scan` reaches the end of the input,
    it returns `false` , and the loop is broken. The bytes that have been selected
    are stored in the `Bytes` method of the scanner, and the handy `Text` method that
    we use converts the `[]byte` slice into a string for us.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Scan`方法的调用告诉扫描器读取输入的下一块字节（下一行），并返回一个`bool`值，指示它是否找到了任何内容。这就是我们能够将其用作`for`循环的条件的方式。只要有内容可以处理，`Scan`就会返回`true`，并执行`for`循环的主体，当`Scan`到达输入的末尾时，它返回`false`，循环就会被打破。已选择的字节存储在扫描器的`Bytes`方法中，我们使用的方便的`Text`方法将`[]byte`切片转换为字符串。
- en: Inside the `for` loop (so for each line of input), we use `rand.Intn` to select
    a random item from the `transforms` slice, and use `strings.Replace` to insert
    the original word where the `otherWord` string appears. Finally, we use `fmt.Println`
    to print the output to the default standard output stream.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环内（对于每行输入），我们使用`rand.Intn`从`transforms`切片中选择一个随机项，并使用`strings.Replace`将原始单词插入到`otherWord`字符串出现的位置。最后，我们使用`fmt.Println`将输出打印到默认标准输出流。
- en: 'Let''s build our program and play with it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的程序并玩耍一下：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the program is running, since we haven''t piped any content in, or specified
    a source for it to read from, we will use the default behavior where it reads
    the user input from the terminal. Type in `chat` and hit return. The scanner in
    our code notices the linefeed character at the end of the word and runs the code
    that transforms it, outputting the result. For example, if you type `chat` a few
    times, you might see output like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序运行，由于我们没有输入任何内容，或者指定了一个来源来读取内容，我们将使用默认行为，从终端读取用户输入。输入`chat`并按回车。我们代码中的扫描器注意到单词末尾的换行符，并运行转换代码，输出结果。例如，如果您多次输入`chat`，您可能会看到类似的输出：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Sprinkle never exits (meaning the `Scan` method never returns `false` to break
    the loop) because the terminal is still running; in normal execution, the in pipe
    will be closed by whatever program is generating the input. To stop the program,
    hit *Ctrl* + *C* .
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Sprinkle永远不会退出（意味着`Scan`方法永远不会返回`false`来中断循环），因为终端仍在运行；在正常执行中，输入管道将被生成输入的任何程序关闭。要停止程序，请按*Ctrl*
    + *C*。
- en: 'Before we move on, let''s try running Sprinkle specifying a different input
    source, we are going to use the `echo` command to generate some content, and pipe
    it into our Sprinkle program using the pipe character:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们尝试运行Sprinkle，指定一个不同的输入源，我们将使用`echo`命令生成一些内容，并使用管道字符将其输入到我们的Sprinkle程序中：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The program will randomly transform the word, print it out, and exit since the
    `echo` command generates only one line of input before terminating and closing
    the pipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将随机转换单词，打印出来，然后退出，因为`echo`命令在终止和关闭管道之前只生成一行输入。
- en: We have successfully completed our first program, which has a very simple but
    useful function, as we will see.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功完成了我们的第一个程序，它有一个非常简单但有用的功能，我们将会看到。
- en: Exercise – configurable transformations
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习-可配置的转换
- en: As an extra assignment, rather than hardcoding the `transformations` array as
    we have done, see if you can externalize it into a text file or database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的任务，不要像我们所做的那样将`transformations`数组硬编码，看看是否可以将其外部化到文本文件或数据库中。
- en: Domainify
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Domainify
- en: 'Some of the words that output from Sprinkle contain spaces and perhaps other
    characters that are not allowed in domains, so we are going to write a program,
    called Domainify, that converts a line of text into an acceptable domain segment
    and add an appropriate **Top-level Domain** ( **TLD** ) to the end. Alongside
    the `sprinkle` folder, create a new one called `domainify` , and add a `main.go`
    file with the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从Sprinkle输出的一些单词包含空格和其他在域名中不允许的字符，因此我们将编写一个名为Domainify的程序，将一行文本转换为可接受的域段，并在末尾添加适当的**顶级域**（**TLD**）。在`sprinkle`文件夹旁边，创建一个名为`domainify`的新文件夹，并添加一个带有以下代码的`main.go`文件：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will notice a few similarities between the Domainify and Sprinkle programs:
    we set the random seed using `rand.Seed` , generate a `NewScanner` method wrapping
    the `os.Stdin` reader, and scan each line until there is no more input.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到Domainify和Sprinkle程序之间的一些相似之处：我们使用`rand.Seed`设置随机种子，使用`NewScanner`方法包装`os.Stdin`读取器，并扫描每一行，直到没有更多的输入。
- en: We then convert the text to lowercase and build up a new slice of `rune` types
    called `newText` . The `rune` types consist only of characters that appear in
    the `allowedChars` string, which `strings.ContainsRune` lets us know. If `rune`
    is a space that we determine by calling `unicode.IsSpace` , we replace it with
    a hyphen, which is an acceptable practice in domain names.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将文本转换为小写，并构建一个名为`newText`的`rune`类型的新切片。`rune`类型仅包含出现在`allowedChars`字符串中的字符，`strings.ContainsRune`让我们知道。如果`rune`是一个空格，我们通过调用`unicode.IsSpace`来确定，我们将其替换为连字符，这在域名中是可以接受的做法。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ranging over a string returns the index of each character and a `rune` type,
    which is a numerical value (specifically `int32` ) representing the character
    itself. For more information about runes, characters, and strings, refer to [http://blog.golang.org/strings](http://blog.golang.org/strings)
    .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串上进行范围循环会返回每个字符的索引和`rune`类型，这是一个表示字符本身的数值（具体是`int32`）。有关符文、字符和字符串的更多信息，请参阅[http://blog.golang.org/strings](http://blog.golang.org/strings)。
- en: Finally, we convert `newText` from a `[]rune` slice to a string and add either
    `.com` or `.net` to the end before printing it out using `fmt.Println` .
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`newText`从`[]rune`切片转换为字符串，并在打印之前在末尾添加`.com`或`.net`。
- en: 'Build and run Domainify:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行Domainify：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Type in some of these options to see how `domainify` reacts:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一些选项，看看`domainify`的反应如何：
- en: '`Monkey`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Monkey`'
- en: '`Hello Domainify`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hello Domainify`'
- en: '`"What''s up?"`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"What''s up?"`'
- en: '`One (two) three!`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`One (two) three!`'
- en: You can see that, for example, `One (two) three!` might yield `one-two-three.com`
    .
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`One (two) three!`可能产生`one-two-three.com`。
- en: 'We are now going to compose Sprinkle and Domainify to see them work together.
    In your terminal, navigate to the parent folder (probably `$GOPATH/src` ) of `sprinkle`
    and `domainify` , and run the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将组合Sprinkle和Domainify以使它们一起工作。在您的终端中，导航到`sprinkle`和`domainify`的父文件夹（可能是`$GOPATH/src`），并运行以下命令：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we ran the Sprinkle program and piped the output into the Domainify program.
    By default, `sprinkle` uses the terminal as the input and `domanify` outputs to
    the terminal. Try typing in `chat` a few times again, and notice the output is
    similar to what Sprinkle was outputting previously, except now the words are acceptable
    for domain names. It is this piping between programs that allows us to compose
    command-line tools together.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行了Sprinkle程序并将输出导入Domainify程序。默认情况下，`sprinkle`使用终端作为输入，`domanify`输出到终端。再次尝试多次输入`chat`，注意输出与之前Sprinkle输出的类似，只是现在这些单词适合作为域名。正是这种程序之间的管道传输使我们能够组合命令行工具。
- en: Exercise – making top-level domains configurable
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习-使顶级域名可配置
- en: Only supporting `.com` and `.net` top-level domains is fairly limiting. As an
    additional assignment, see if you can accept a list of TLDs via a command-line
    flag.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 仅支持`.com`和`.net`顶级域名相当受限。作为额外的任务，看看是否可以通过命令行标志接受TLD列表。
- en: Coolify
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Coolify
- en: Often domain names for common words such as `chat` are already taken and a common
    solution is to play around with the vowels in the words. For example, we might
    remove the `a` leaving `cht` (which is actually less likely to be available),
    or add an `a` to produce `chaat` . While this clearly has no actual effect on
    coolness, it has become a popular, albeit slightly dated, way to secure domain
    names that still sound like the original word.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像`chat`这样的常见单词的域名已经被占用，一个常见的解决方案是对单词中的元音进行处理。例如，我们可能删除`a`得到`cht`（实际上更不太可能可用），或者添加一个`a`得到`chaat`。虽然这显然对酷度没有实际影响，但它已经成为一种流行的，尽管略显过时的方式来获得仍然听起来像原始单词的域名。
- en: Our third program, Coolify, will allow us to play with the vowels of words that
    come in via the input, and write the modified versions to the output.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个程序Coolify将允许我们处理通过输入的单词的元音，并将修改后的版本写入输出。
- en: 'Create a new folder called `coolify` alongside `sprinkle` and `domainify` ,
    and create the `main.go` code file with the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sprinkle`和`domainify`旁边创建一个名为`coolify`的新文件夹，并创建带有以下代码的`main.go`代码文件：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While the preceding Coolify code looks very similar to the codes of Sprinkle
    and Domainify, it is slightly more complicated. At the very top of the code we
    declare two constants, `duplicateVowel` and `removeVowel` , that help make Coolify
    code more readable. The `switch` statement decides whether we duplicate or remove
    a vowel. Also, using these constants, we are able to express our intent very clearly,
    rather than using just `true` or `false` .
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的Coolify代码看起来与Sprinkle和Domainify的代码非常相似，但它稍微复杂一些。在代码的顶部，我们声明了两个常量，`duplicateVowel`和`removeVowel`，这有助于使Coolify代码更易读。`switch`语句决定我们是复制还是删除元音。此外，使用这些常量，我们能够非常清楚地表达我们的意图，而不仅仅使用`true`或`false`。
- en: We then define the `randBool` helper function that just randomly returns `true`
    or `false` by asking the `rand` package to generate a random number, and checking
    whether if that number comes out as zero. It will be either `0` or `1` , so there's
    a 50/50 chance of it being `true` .
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义`randBool`辅助函数，它只是通过要求`rand`包生成一个随机数，然后检查该数字是否为零来随机返回`true`或`false`。它将是`0`或`1`，因此它有50/50的机会成为`true`。
- en: The `main` function for Coolify starts the same way as the `main` functions
    for Sprinkle and Domainify—by setting the `rand.Seed` method and creating a scanner
    of the standard input stream before executing the loop body for each line of input.
    We call `randBool` first to decide whether we are even going to mutate a word
    or not, so Coolify will only affect half of the words passed through it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Coolify的`main`函数的开始方式与Sprinkle和Domainify的`main`函数相同——通过设置`rand.Seed`方法并在执行循环体之前创建标准输入流的扫描器来执行每行输入的循环体。我们首先调用`randBool`来决定是否要改变一个单词，因此Coolify只会影响通过其中的一半单词。
- en: We then iterate over each rune in the string and look for a vowel. If our `randBool`
    method returns `true` , we keep the index of the vowel character in the `vI` variable.
    If not, we keep looking through the string for another vowel, which allows us
    to randomly select a vowel from the words rather than always modifying the same
    one.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们遍历字符串中的每个符文，并寻找元音。如果我们的`randBool`方法返回`true`，我们将元音字符的索引保留在`vI`变量中。如果不是，我们将继续在字符串中寻找另一个元音，这样我们就可以随机选择单词中的元音，而不总是修改相同的元音。
- en: Once we have selected a vowel, we then use `randBool` again to randomly decide
    what action to take.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了一个元音，我们再次使用`randBool`来随机决定要采取什么行动。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This is where the helpful constants come in; consider the following alternative
    switch statement:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是有用的常量发挥作用的地方；考虑以下备用的switch语句：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code snippet, it's difficult to tell what is going on because
    `true` and `false` don't express any context. On the other hand, using `duplicateVowel`
    and `removeVowel` tells anyone reading the code what we mean by the result of
    `randBool` .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，很难判断发生了什么，因为`true`和`false`没有表达任何上下文。另一方面，使用`duplicateVowel`和`removeVowel`告诉任何阅读代码的人我们通过`randBool`的结果的意图。
- en: 'The three dots following the slices cause each item to pass as a separate argument
    to the `append` function. This is an idiomatic way of appending one slice to another.
    Inside the `switch` case, we do some slice manipulation to either duplicate the
    vowel or remove it altogether. We are reslicing our `[]byte` slice and using the
    `append` function to build a new one made up of sections of the original word.
    The following diagram shows which sections of the string we access in our code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 切片后面的三个点使每个项目作为单独的参数传递给`append`函数。这是一种将一个切片附加到另一个切片的成语方式。在`switch`情况下，我们对切片进行一些操作，以便复制元音或完全删除它。我们重新切片我们的`[]byte`切片，并使用`append`函数构建一个由原始单词的部分组成的新单词。以下图表显示了我们在代码中访问字符串的哪些部分：
- en: '![Coolify](img/Image00010.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Coolify](img/Image00010.jpg)'
- en: 'If we take the value `blueprints` as an example word, and assume that our code
    selected the first `e` character as the vowel (so that `vI` is `3` ), we can see
    what each new slice of word represents in this table:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以`blueprints`作为示例单词的值，并假设我们的代码选择第一个`e`字符作为元音（所以`vI`是`3`），我们可以看到单词的每个新切片在这个表中代表什么：
- en: '| Code | Value | Description |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `word[:vI+1]` | `blue` | Describes a slice from the beginning of the word
    slice to the selected vowel. The `+1` is required because the value following
    the colon does not include the specified index; rather it slices up to that value.
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `word[:vI+1]` | `blue` | 描述了从单词切片的开头到所选元音的切片。`+1`是必需的，因为冒号后面的值不包括指定的索引；它切片直到该值。'
- en: '| `word[vI:]` | `eprints` | Describes a slice starting at and including the
    selected vowel to the end of the slice. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `word[vI:]` | `eprints` | 描述了从所选元音开始并包括切片到切片的末尾。'
- en: '| `word[:vI]` | `blu` | Describes a slice from the beginning of the word slice
    up to, but not including, the selected vowel. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `word[:vI]` | `blu` | 描述了从单词切片的开头到所选元音之前的切片。'
- en: '| `word[vI+1:]` | `prints` | Describes a slice from the item following the
    selected vowel to the end of the slice. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `word[vI+1:]` | `prints` | 描述了从所选元音后的项目到切片的末尾。'
- en: After we modify the word, we print it out using `fmt.Println` .
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 修改单词后，我们使用`fmt.Println`将其打印出来。
- en: 'Let''s build Coolify and play with it to see what it can do:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建Coolify并玩一下，看看它能做什么：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When Coolify is running, try typing `blueprints` to see what sort of modifications
    it comes up with:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当Coolify运行时，尝试输入`blueprints`，看看它会做出什么样的修改：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s see how Coolify plays with Sprinkle and Domainify by adding their names
    to our pipe chain. In the terminal, navigate back (using the `cd` command) to
    the parent folder and run the following commands:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Coolify如何与Sprinkle和Domainify一起玩，通过将它们的名称添加到我们的管道链中。在终端中，使用`cd`命令返回到父文件夹，并运行以下命令：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will first spice up a word with extra pieces and make it cooler by tweaking
    the vowels before finally transforming it into a valid domain name. Play around
    by typing in a few words and seeing what suggestions our code makes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将用额外的部分来调整一个单词，通过调整元音字母使其更酷，最后将其转换为有效的域名。尝试输入一些单词，看看我们的代码会做出什么建议。
- en: Synonyms
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同义词
- en: So far, our programs have only modified words, but to really bring our solution
    to life, we need to be able to integrate a third-party API that provides word
    synonyms. This allows us to suggest different domain names while retaining the
    original meaning. Unlike Sprinkle and Domainify, Synonyms will write out more
    than one response for each word given to it. Our architecture of piping programs
    together means this is no problem; in fact we do not even have to worry about
    it since each of the three programs is capable of reading multiple lines from
    the input source.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的程序只修改了单词，但要真正使我们的解决方案生动起来，我们需要能够集成一个提供单词同义词的第三方API。这使我们能够在保留原始含义的同时建议不同的域名。与Sprinkle和Domainify不同，同义词将为每个给定的单词写出多个响应。我们将这三个程序连接在一起的架构意味着这不是问题；事实上，我们甚至不必担心，因为这三个程序都能够从输入源中读取多行。
- en: The Big Hugh Thesaurus at [bighughlabs.com](http://bighughlabs.com) has a very
    clean and simple API that allows us to make a single HTTP `GET` request in order
    to look up synonyms.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[bighughlabs.com](http://bighughlabs.com)的Big Hugh Thesaurus有一个非常干净简单的API，允许我们进行一次HTTP
    `GET`请求来查找同义词。'
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If in the future the API we are using changes or disappears (after all, this
    is the Internet!), you will find some options at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    .
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将来我们使用的API发生变化或消失（毕竟，这是互联网！），您可以在[https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)找到一些选项。
- en: Before you can use the Big Hugh Thesaurus, you'll need an API key, which you
    can get by signing up to the service at [http://words.bighugelabs.com/](http://words.bighugelabs.com/)
    .
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Big Hugh Thesaurus之前，您需要一个API密钥，您可以通过在[http://words.bighugelabs.com/](http://words.bighugelabs.com/)注册该服务来获取。
- en: Using environment variables for configuration
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用环境变量进行配置
- en: Your API key is a sensitive piece of configuration information that you won't
    want to share with others. We could store it as `const` in our code, but that
    would not only mean we couldn't share our code without sharing our key (not good,
    especially if you love open source projects), but also, and perhaps more importantly,
    you would have to recompile your project if the key expires or if you want to
    use a different one.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API密钥是一项敏感的配置信息，您不希望与他人分享。我们可以将其存储为代码中的`const`，但这不仅意味着我们不能在不分享密钥的情况下分享我们的代码（尤其是如果您喜欢开源项目），而且，也许更重要的是，如果密钥过期或者您想使用其他密钥，您将不得不重新编译您的项目。
- en: A better solution is using an environment variable to store the key, as this
    will allow you to easily change it if you need to. You could also have different
    keys for different deployments; perhaps you have one key for development or testing
    and another for production. This way, you can set a specific key for a particular
    execution of code, so you can easily switch keys without having to change your
    system-level settings. Either way, different operating systems deal with environment
    variables in similar ways, so they are a perfect choice if you are writing cross-platform
    code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是使用环境变量来存储密钥，因为这样可以让您在需要时轻松更改它。您还可以为不同的部署设置不同的密钥；也许您在开发或测试中有一个密钥，而在生产中有另一个密钥。这样，您可以为代码的特定执行设置一个特定的密钥，这样您可以轻松地在不必更改系统级设置的情况下切换密钥。无论如何，不同的操作系统以类似的方式处理环境变量，因此如果您正在编写跨平台代码，它们是一个完美的选择。
- en: Create a new environment variable called `BHT_APIKEY` and set your API key as
    its value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`BHT_APIKEY`的新环境变量，并将您的API密钥设置为其值。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For machines running a bash shell, you can modify your `~/.bashrc` file or
    similar to include `export` commands such as:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行bash shell的计算机，您可以修改您的`~/.bashrc`文件或类似文件，包括`export`命令，例如：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On Windows machines, you can navigate to the properties of your computer and
    look for **Environment Variables** in the **Advanced** section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows计算机上，您可以转到计算机的属性并在**高级**部分中查找**环境变量**。
- en: Consuming a web API
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消费web API
- en: 'Making a request for [http://words.bighugelabs.com/apisample.php?v=2&format=json](http://words.bighugelabs.com/apisample.php?v=2&format=json)
    in a web browser shows us what the structure of JSON response data looks like
    when finding synonyms for the word love:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web浏览器中请求[http://words.bighugelabs.com/apisample.php?v=2&format=json](http://words.bighugelabs.com/apisample.php?v=2&format=json)会显示我们在查找单词love的同义词时JSON响应数据的结构。
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The real API returns a lot more actual words than what is printed here, but
    the structure is the important thing. It represents an object where the keys describe
    the types of words (verbs, nouns, and so on) and values are objects that contain
    arrays of strings keyed on `syn` or `ant` (for synonym and antonym respectively);
    it is the synonyms we are interested in.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的API返回的实际单词比这里打印的要多得多，但结构才是重要的。它表示一个对象，其中键描述了单词类型（动词、名词等），值是包含在`syn`或`ant`（分别表示同义词和反义词）上的字符串数组的对象；这就是我们感兴趣的同义词。
- en: 'To turn this JSON string data into something we can use in our code, we must
    decode it into structures of our own using capabilities found in the `encoding/json`
    package. Because we''re writing something that could be useful outside the scope
    of our project, we will consume the API in a reusable package rather than directly
    in our program code. Create a new folder called `thesaurus` alongside your other
    program folders (in `$GOPATH/src` ) and insert the following code into a new `bighugh.go`
    file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个JSON字符串数据转换成我们在代码中可以使用的东西，我们必须使用`encoding/json`包中的功能将其解码为我们自己的结构。因为我们正在编写的东西可能在我们项目的范围之外有用，所以我们将在一个可重用的包中消费API，而不是直接在我们的程序代码中。在`$GOPATH/src`中的其他程序文件夹旁边创建一个名为`thesaurus`的新文件夹，并将以下代码插入到一个新的`bighugh.go`文件中：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, the `BigHugh` type we define houses the necessary API
    key and provides the `Synonyms` method that will be responsible for doing the
    work of accessing the endpoint, parsing the response, and returning the results.
    The most interesting parts of this code are the `synonyms` and `words` structures.
    They describe the JSON response format in Go terms, namely an object containing
    noun and verb objects, which in turn contain a slice of strings in a variable
    called `Syn` . The tags (strings in backticks following each field definition)
    tell the `encoding/json` package which fields to map to which variables; this
    is required since we have given them different names.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们定义的`BigHugh`类型包含必要的API密钥，并提供了`Synonyms`方法，该方法将负责访问端点、解析响应并返回结果。这段代码最有趣的部分是`synonyms`和`words`结构。它们用Go术语描述了JSON响应格式，即包含名词和动词对象的对象，这些对象又包含一个名为`Syn`的字符串切片。标签（在每个字段定义后面的反引号中的字符串）告诉`encoding/json`包将哪些字段映射到哪些变量；这是必需的，因为我们给它们赋予了不同的名称。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Typically, JSON keys have lowercase names, but we have to use capitalized names
    in our structures so that the `encoding/json` package knows that the fields exist.
    If we didn't, the package would simply ignore the fields. However, the types themselves
    (`synonyms` and `words` ) do not need to be exported.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，JSON键具有小写名称，但我们必须在我们的结构中使用大写名称，以便`encoding/json`包知道这些字段存在。如果我们不这样做，包将简单地忽略这些字段。但是，类型本身（`synonyms`和`words`）不需要被导出。
- en: The `Synonyms` method takes a `term` argument and uses `http.Get` to make a
    web request to the API endpoint in which the URL contains not only the API key
    value, but also the `term` value itself. If the web request fails for some reason,
    we will make a call to `log.Fatalln` , which writes the error out to the standard
    error stream and exits the program with a non-zero exit code (actually an exit
    code of `1` )—this indicates that an error has occurred.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Synonyms`方法接受一个`term`参数，并使用`http.Get`向API端点发出web请求，其中URL不仅包含API密钥值，还包含`term`值本身。如果由于某种原因web请求失败，我们将调用`log.Fatalln`，它会将错误写入标准错误流并以非零退出代码（实际上是`1`的退出代码）退出程序，表示发生了错误。'
- en: If the web request is successful, we pass the response body (another `io.Reader`
    ) to the `json.NewDecoder` method and ask it to decode the bytes into the `data`
    variable that is of our `synonyms` type. We defer the closing of the response
    body in order to keep memory clean before using Go's built-in `append` function
    to concatenate both `noun` and `verb` synonyms to the `syns` slice that we then
    return.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果web请求成功，我们将响应主体（另一个`io.Reader`）传递给`json.NewDecoder`方法，并要求它将字节解码为我们的`synonyms`类型的`data`变量。我们推迟关闭响应主体，以便在使用Go的内置`append`函数将`noun`和`verb`的同义词连接到我们然后返回的`syns`切片之前保持内存清洁。
- en: 'Although we have implemented the `BigHugh` thesaurus, it isn''t the only option
    out there, and we can express this by adding a `Thesaurus` interface to our package.
    In the `thesaurus` folder, create a new file called `thesaurus.go` , and add the
    following interface definition to the file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经实现了`BigHugh`词库，但这并不是唯一的选择，我们可以通过为我们的包添加`Thesaurus`接口来表达这一点。在`thesaurus`文件夹中，创建一个名为`thesaurus.go`的新文件，并将以下接口定义添加到文件中：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This simple interface just describes a method that takes a `term` string and
    returns either a slice of strings containing the synonyms, or an error (if something
    goes wrong). Our `BigHugh` structure already implements this interface, but now
    other users could add interchangeable implementations for other services, such
    as [Dictionary.com](http://Dictionary.com) or the Merriam-Webster Online service.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的接口只是描述了一个接受`term`字符串并返回包含同义词的字符串切片或错误（如果出现问题）的方法。我们的`BigHugh`结构已经实现了这个接口，但现在其他用户可以为其他服务添加可互换的实现，比如[Dictionary.com](http://Dictionary.com)或Merriam-Webster在线服务。
- en: 'Next we are going to use this new package in a program. Change directory in
    terminal by backing up a level to `$GOPATH/src` , create a new folder called `synonyms`
    , and insert the following code into a new `main.go` file you will place in that
    folder:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将在一个程序中使用这个新的包。通过在终端中返回到`$GOPATH/src`，创建一个名为`synonyms`的新文件夹，并将以下代码插入到一个新的`main.go`文件中，然后将该文件放入该文件夹中：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you manage your imports again, you will have written a complete program
    capable of looking up synonyms for words by integrating the Big Huge Thesaurus
    API.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次管理你的导入时，你将编写一个完整的程序，能够通过集成Big Huge Thesaurus API来查找单词的同义词。
- en: In the preceding code, the first thing our `main` function does is get the `BHT_APIKEY`
    environment variable value via the `os.Getenv` call. To bullet proof your code,
    you might consider double-checking to ensure this value is properly set, and report
    an error if it is not. For now, we will assume that everything is configured properly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们的`main`函数首先要做的事情是通过`os.Getenv`调用获取`BHT_APIKEY`环境变量的值。为了使你的代码更加健壮，你可能需要再次检查以确保这个值被正确设置，并在没有设置时报告错误。现在，我们将假设一切都配置正确。
- en: Next, the preceding code starts to look a little familiar since it scans each
    line of input again from `os.Stdin` and calls the `Synonyms` method to get a list
    of replacement words.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，前面的代码开始看起来有点熟悉，因为它再次从`os.Stdin`扫描每一行输入，并调用`Synonyms`方法来获取替换词列表。
- en: 'Let''s build a program and see what kind of synonyms the API comes back with
    when we input the word `chat` :'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个程序，看看当我们输入单词`chat`时，API返回了什么样的同义词：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The results you get will most likely differ from what we have listed here since
    we're hitting a live API, but the important aspect here is that when we give a
    word or term as input to the program, it returns a list of synonyms as output,
    one per line.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的结果很可能与我们在这里列出的结果不同，因为我们正在使用实时API，但这里重要的一点是，当我们将一个词或术语作为程序的输入时，它会返回一个同义词列表作为输出，每行一个。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Try chaining your programs together in various orders to see what result you
    get. Regardless, we will do this together later in the chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以不同的顺序将你的程序链接在一起，看看你得到什么结果。无论如何，我们将在本章后面一起做这件事。
- en: Getting domain suggestions
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取域名建议
- en: 'By composing the four programs we have built so far in this chapter, we already
    have a useful tool for suggesting domain names. All we have to do now is run the
    programs while piping the output into input in the appropriate way. In a terminal,
    navigate to the parent folder and run the following single line:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合我们在本章中迄今为止构建的四个程序，我们已经有了一个有用的工具来建议域名。现在我们所要做的就是运行这些程序，同时以适当的方式将输出导入输入。在终端中，导航到父文件夹并运行以下单行命令：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because the `synonyms` program is first in our list, it will receive the input
    from the terminal (whatever the user decides to type in). Similarly, because `domainify`
    is last in the chain, it will print its output to the terminal for the user to
    see. At each step, the lines of words will be piped through the other programs,
    giving them each a chance to do their magic.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`synonyms`程序在我们的列表中排在第一位，它将接收来自终端的输入（无论用户决定输入什么）。同样，因为`domainify`是链中的最后一个，它将把输出打印到终端供用户查看。在每一步，单词行将通过其他程序进行传输，使它们有机会发挥魔力。
- en: 'Type in some words to see some domain suggestions, for example, if you type
    `chat` and hit return, you might see:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一些单词来看一些域名建议，例如，如果你输入`chat`并回车，你可能会看到：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The number of suggestions you get will actually depend on the number of synonyms,
    since it is the only program that generates more lines of output than we give
    it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的建议数量实际上取决于同义词的数量，因为它是唯一一个生成比我们给它的输出更多行的程序。
- en: We still haven't solved our biggest problem—the fact that we have no idea whether
    the suggested domain names are actually available or not, so we still have to
    sit and type each of them into a website. In the next section, we will address
    this issue.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然没有解决我们最大的问题——我们不知道建议的域名是否真的可用，所以我们仍然需要坐下来，把它们每一个输入到一个网站中。在下一节中，我们将解决这个问题。
- en: Available
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用
- en: Our final program, Available, will connect to a WHOIS server to ask for details
    about domains passed into it—of course, if no details are returned, we can safely
    assume that the domain is available for purchase. Unfortunately, the WHOIS specification
    (see [http://tools.ietf.org/html/rfc3912](http://tools.ietf.org/html/rfc3912)
    ) is very small and contains no information about how a WHOIS server should reply
    when you ask it for details about a domain. This means programmatically parsing
    the response becomes a messy endeavor. To address this issue for now, we will
    integrate with only a single WHOIS server that we can be sure will have `No match`
    somewhere in the response when it has no records for the domain.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终程序Available将连接到WHOIS服务器，询问传入的域名的详细信息——当然，如果没有返回任何详细信息，我们可以安全地假设该域名可以购买。不幸的是，WHOIS规范（参见[http://tools.ietf.org/html/rfc3912](http://tools.ietf.org/html/rfc3912)）非常简单，没有提供关于当你询问域名的详细信息时，WHOIS服务器应该如何回复的信息。这意味着以编程方式解析响应变得非常混乱。为了暂时解决这个问题，我们将只集成一个我们可以确定在响应中有“无匹配”（No
    match）的单个WHOIS服务器，当它没有该域名的记录时。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A more robust solution might be to have a WHOIS interface with well-defined
    structures for the details, and perhaps an error message for the cases when the
    domain doesn't exist—with different implementations for different WHOIS servers.
    As you can imagine, it's quite a project; perfect for an open source effort.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更健壮的解决方案可能是使用具有明确定义结构的WHOIS接口来获取详细信息，也许在域名不存在的情况下提供错误消息，针对不同的WHOIS服务器有不同的实现。正如你所能想象的，这是一个相当大的项目；非常适合开源项目。
- en: 'Create a new folder called `available` alongside the others in `$GOPATH/src`
    and add a `main.go` file in it containing the following function code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$GOPATH/src`目录旁边创建一个名为`available`的新文件夹，并在其中添加一个名为`main.go`的文件，其中包含以下函数代码：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `exists` function implements what little there is in the WHOIS specification
    by opening a connection to port `43` on the specified `whoisServer` instance with
    a call to `net.Dial` . We then defer the closing of the connection, which means
    that however the function exits (successfully or with an error, or even a panic),
    `Close()` will still be called on the connection `conn` . Once the connection
    is open, we simply write the domain followed by `\r\n` (the carriage return and
    line feed characters). This is all the specification tells us, so we are on our
    own from now on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`exists`函数通过打开到指定`whoisServer`实例的端口`43`的连接来实现WHOIS规范中的一点内容，使用`net.Dial`进行调用。然后我们推迟关闭连接，这意味着无论函数如何退出（成功或出现错误，甚至是恐慌），都将在连接`conn`上调用`Close()`。连接打开后，我们只需写入域名，然后跟着`\r\n`（回车和换行字符）。这就是规范告诉我们的全部内容，所以从现在开始我们就要自己动手了。'
- en: Essentially, we are looking for some mention of no match in the response, and
    that is how we will decide whether a domain exists or not (`exists` in this case
    is actually just asking the WHOIS server if it has a record for the domain we
    specified). We use our favorite `bufio.Scanner` method to help us iterate over
    the lines in the response. Passing the connection into `NewScanner` works because
    `net.Conn` is actually an `io.Reader` too. We use `strings.ToLower` so we don't
    have to worry about case sensitivity, and `strings.Contains` to see if any of
    the lines contains the no match text. If it does, we return `false` (since the
    domain doesn't exist), otherwise we return `true` .
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们正在寻找响应中是否提到了“无匹配”的内容，这就是我们决定域名是否存在的方式（在这种情况下，`exists`实际上只是询问WHOIS服务器是否有我们指定的域名的记录）。我们使用我们喜欢的`bufio.Scanner`方法来帮助我们迭代响应中的行。将连接传递给`NewScanner`是可行的，因为`net.Conn`实际上也是一个`io.Reader`。我们使用`strings.ToLower`，这样我们就不必担心大小写敏感性，使用`strings.Contains`来查看任何行是否包含“无匹配”文本。如果是，我们返回`false`（因为域名不存在），否则我们返回`true`。
- en: The `com.whois-servers.net` WHOIS service supports domain names for `.com` and
    `.net` , which is why the Domainify program only adds these types of domains.
    If you used a server that had WHOIS information for a wider selection of domains,
    you could add support for additional TLDs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`com.whois-servers.net` WHOIS服务支持`.com`和`.net`的域名，这就是为什么Domainify程序只添加这些类型的域名。如果你使用的服务器对更广泛的域名提供了WHOIS信息，你可以添加对其他顶级域的支持。'
- en: Let's add a `main` function that uses our `exists` function to check to see
    whether the incoming domains are available or not. The check mark and cross mark
    symbols in the following code are optional—if your terminal doesn't support them
    you are free to substitute them with simple `Yes` and `No` strings.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个`main`函数，使用我们的`exists`函数来检查传入的域名是否可用。以下代码中的勾号和叉号符号是可选的——如果你的终端不支持它们，你可以自由地用简单的`Yes`和`No`字符串替换它们。
- en: 'Add the following code to `main.go` :'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.go`中：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code for the `main` function, we simply iterate over each line
    coming in via `os.Stdin` , printing out the domain with `fmt.Print` (but not `fmt.Println`
    , as we do not want the linefeed yet), calling our `exists` function to see whether
    the domain exists or not, and printing out the result with `fmt.Println` (because
    we *do* want a linefeed at the end).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的前面代码中，我们只是迭代通过`os.Stdin`传入的每一行，用`fmt.Print`打印出域名（但不是`fmt.Println`，因为我们不想要换行），调用我们的`exists`函数来查看域名是否存在，然后用`fmt.Println`打印出结果（因为我们*确实*希望在最后有一个换行）。
- en: Finally, we use `time.Sleep` to tell the process to do nothing for `1` second
    in order to make sure we take it easy on the WHOIS server.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`time.Sleep`告诉进程在1秒内什么都不做，以确保我们对WHOIS服务器轻松一些。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Most WHOIS servers will be limited in various ways in order to prevent you from
    taking up too much resources. So slowing things down is a sensible way to make
    sure we don't make the remote servers angry.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数WHOIS服务器都会以各种方式限制，以防止你占用过多资源。因此，减慢速度是确保我们不会惹恼远程服务器的明智方式。
- en: Consider what this also means for unit tests. If a unit test was actually making
    real requests to a remote WHOIS server, every time your tests run, you will be
    clocking up stats against your IP address. A much better approach would be to
    stub the WHOIS server to simulate real responses.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下这对单元测试意味着什么。如果一个单元测试实际上是在向远程WHOIS服务器发出真实请求，每次测试运行时，您都会在您的IP地址上累积统计数据。一个更好的方法是对WHOIS服务器进行存根，以模拟真实的响应。
- en: The `marks` map at the top of the preceding code is a nice way to map the Boolean
    response from `exists` to human-readable text, allowing us to just print the response
    in a single line using `fmt.Println(marks[!exist])` . We are saying not exist
    because our program is checking whether the domain is available or not (logically
    the opposite of whether it exists in the WHOIS server or not).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的顶部的“marks”映射是将“exists”的布尔响应映射到人类可读的文本的一种好方法，这样我们只需使用“fmt.Println(marks[!exist])”在一行中打印响应。我们说不存在是因为我们的程序正在检查域名是否可用（逻辑上与是否存在于WHOIS服务器中相反）。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can use the check and cross characters in our code happily because all Go
    code files are UTF-8 compliant—the best way to actually get these characters is
    to search the Web for them, and use copy and paste to bring them into code; else
    there are platform-dependent ways to get such special characters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的代码中愉快地使用检查和叉字符，因为所有的Go代码文件都符合UTF-8标准——实际上获得这些字符的最好方法是在网上搜索它们，然后使用复制和粘贴将它们带入代码；否则，还有一些依赖于平台的方法来获得这样的特殊字符。
- en: 'After fixing the `import` statements for the `main.go` file, we can try out
    Available to see whether domain names are available or not:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 修复“main.go”文件的“import”语句后，我们可以尝试运行Available，看看域名是否可用：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once Available is running, type in some domain names:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Available正在运行，输入一些域名：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, for domains that are obviously not available, we get our little
    cross mark, but when we make up a domain name using random numbers, we see that
    it is indeed available.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，对于显然不可用的域名，我们得到了一个小叉号，但是当我们使用随机数字编造一个域名时，我们发现它确实是可用的。
- en: 读累了记得休息一会哦~
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Composing all five programs
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合所有五个程序
- en: 'Now that we have completed all five of our programs, it''s time to put them
    all together so that we can use our tool to find an available domain name for
    our chat application. The simplest way to do this is to use the technique we have
    been using throughout this chapter: using pipes in a terminal to connect the output
    and input.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的所有五个程序，是时候把它们全部放在一起，这样我们就可以使用我们的工具为我们的聊天应用程序找到一个可用的域名。这样做的最简单方法是使用我们在本章中一直在使用的技术：在终端中使用管道连接输出和输入。
- en: 'In the terminal, navigate to the parent folder of the five programs and run
    the following single line of code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，导航到这五个程序的父文件夹，并运行以下单行代码：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the programs are running, type in a starting word and see how it generates
    suggestions before checking their availability.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行后，输入一个起始词，看它如何生成建议，然后再检查它们的可用性。
- en: 'For example, typing in `chat` might cause the programs to take the following
    actions:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，输入“chat”可能会导致程序执行以下操作：
- en: 'The word `chat` goes into `synonyms` and out comes a series of synonyms:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单词“chat”进入“synonyms”，然后出来一系列的同义词：
- en: '`confab`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “confab”
- en: '`confabulation`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “confabulation”
- en: '`schmooze`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “schmooze”
- en: 'The synonyms flow into `sprinkle` where they are augmented with web-friendly
    prefixes and suffixes such as:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同义词流入“sprinkle”，在那里它们会被增加上网友好的前缀和后缀，比如：
- en: '`confabapp`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “confabapp”
- en: '`goconfabulation`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “goconfabulation”
- en: '`schmooze time`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “schmooze time”
- en: 'These new words flow into `coolify` , where the vowels are potentially tweaked:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些新词汇流入“coolify”，其中元音可能会被调整：
- en: '`confabaapp`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “confabaapp”
- en: '`goconfabulatioon`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “goconfabulatioon”
- en: '`schmoooze time`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “schmoooze time”
- en: 'The modified words then flow into `domainify` where they are turned into valid
    domain names:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改后的词汇流入“domainify”，在那里它们被转换成有效的域名：
- en: '`confabaapp.com`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “confabaapp.com”
- en: '`goconfabulatioon.net`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “goconfabulatioon.net”
- en: '`schmooze-time.com`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “schmooze-time.com”
- en: 'Finally, the domain names flow into `available` where they are checked against
    the WHOIS server to see whether somebody has already taken the domain or not:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，域名流入“available”，在那里它们被检查是否已经被某人注册了：
- en: '`confabaapp.com` ×'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “confabaapp.com” ×
- en: '`goconfabulatioon.net` ✔'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “goconfabulatioon.net” ✔
- en: '`schmooze-time.com` ✔'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “schmooze-time.com” ✔
- en: One program to rule them all
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一款程序统治所有
- en: Running our solution by piping programs together is an elegant architecture,
    but it doesn't have a very elegant interface. Specifically, whenever we want to
    run our solution, we have to type the long messy line where each program is listed
    separated by pipe characters. In this section, we are going to write a Go program
    that uses the `os/exec` package to run each subprogram while piping the output
    from one into the input of the next as per our design.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将程序连接在一起来运行我们的解决方案是一种优雅的架构，但它并没有一个非常优雅的界面。具体来说，每当我们想要运行我们的解决方案时，我们都必须输入一个长长的混乱的行，其中每个程序都被列在一起，用管道字符分隔。在本节中，我们将编写一个Go程序，使用“os/exec”包来运行每个子程序，同时按照我们的设计将一个程序的输出传递到下一个程序的输入。
- en: Create a new folder called `domainfinder` alongside the other five programs,
    and create another new folder called `lib` inside that folder. The `lib` folder
    is where we will keep builds of our subprograms, but we don't want to be copying
    and pasting them every time we make a change. Instead, we will write a script
    that builds the subprograms and copies the binaries to the `lib` folder for us.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他五个程序旁边创建一个名为“domainfinder”的新文件夹，并在其中创建另一个名为“lib”的新文件夹。“lib”文件夹是我们将保存子程序构建的地方，但我们不想每次进行更改时都复制和粘贴它们。相反，我们将编写一个脚本，用于构建子程序并将二进制文件复制到“lib”文件夹中。
- en: 'Create a new file called `build.sh` on Unix machines or `build.bat` for Windows
    and insert the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix机器上创建一个名为“build.sh”的新文件，或者在Windows上创建一个名为“build.bat”的文件，并插入以下代码：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding script simply builds all of our subprograms (including `domainfinder`
    , which we are yet to write) telling `go build` to place them in our `lib` folder.
    Be sure to give the new script execution rights by doing `chmod +x build.sh` ,
    or something similar. Run this script from a terminal and look inside the `lib`
    folder to ensure that it has indeed placed the binaries for our subprograms in
    there.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本只是构建了我们所有的子程序（包括我们尚未编写的`domainfinder`），告诉`go build`将它们放在我们的`lib`文件夹中。确保通过执行`chmod
    +x build.sh`或类似的操作赋予新脚本执行权限。从终端运行此脚本，并查看`lib`文件夹，确保它确实将我们的子程序的二进制文件放在那里。
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't worry about the `no buildable Go source files` error for now, it's just
    Go telling us that the `domainfinder` program doesn't have any `.go` files to
    build.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要担心`no buildable Go source files`错误，这只是Go告诉我们`domainfinder`程序没有任何`.go`文件可供构建。
- en: 'Create a new file called `main.go` inside `domainfinder` and insert the following
    code in the file:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在`domainfinder`内创建一个名为`main.go`的新文件，并在文件中插入以下代码：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `os/exec` package gives us everything we need to work with running external
    programs or commands from within Go programs. First, our `cmdChain` slice contains
    `*exec.Cmd` commands in the order in which we want to join them together.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`os/exec`包为我们提供了一切我们需要从Go程序内部运行外部程序或命令的东西。首先，我们的`cmdChain`切片按照我们想要将它们连接在一起的顺序包含了`*exec.Cmd`命令。'
- en: At the top of the `main` function, we tie the `Stdin` (standard in stream) of
    the first program to the `os.Stdin` stream for this program, and the `Stdout`
    (standard out stream) of the last program to the `os.Stdout` stream for this program.
    This means that, like before, we will be taking input through the standard input
    stream and writing output to the standard output stream.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的顶部，我们将第一个程序的`Stdin`（标准输入流）绑定到此程序的`os.Stdin`流，将最后一个程序的`Stdout`（标准输出流）绑定到此程序的`os.Stdout`流。这意味着，就像以前一样，我们将通过标准输入流接收输入，并将输出写入标准输出流。
- en: Our next block of code is where we join the subprograms together by iterating
    over each item and setting its `Stdin` to the `Stdout` of the program before it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个代码块是通过迭代每个项目并将其`Stdin`设置为其前一个程序的`Stdout`来将子程序连接在一起的地方。
- en: 'The following table shows each program, with a description of where it gets
    its input from, and where its output goes:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了每个程序，以及它从哪里获取输入，以及它的输出去哪里：
- en: '| Program | Input (Stdin) | Output (Stdout) |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 程序 | 输入（Stdin） | 输出（Stdout） |'
- en: '| --- | --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `synonyms` | The same `Stdin` as `domainfinder` | `sprinkle` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `synonyms` | 与`domainfinder`相同的`Stdin` | `sprinkle` |'
- en: '| `sprinkle` | `synonyms` | `coolify` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `sprinkle` | `synonyms` | `coolify` |'
- en: '| `coolify` | `sprinkle` | `domainify` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `coolify` | `sprinkle` | `domainify` |'
- en: '| `domainify` | `coolify` | `available` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `domainify` | `coolify` | `available` |'
- en: '| `available` | `domainify` | The same `Stdout` as `domainfinder` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `available` | `domainify` | 与`domainfinder`相同的`Stdout` |'
- en: We then iterate over each command calling the `Start` method, which runs the
    program in the background (as opposed to the `Run` method which will block our
    code until the subprogram exits—which of course is no good since we have to run
    five programs at the same time). If anything goes wrong, we bail with `log.Fatalln`
    , but if the program starts successfully, we then defer a call to kill the process.
    This helps us ensure the subprograms exit when our `main` function exits, which
    will be when the `domainfinder` program ends.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们迭代每个命令调用`Start`方法，该方法在后台运行程序（与`Run`方法相反，后者将阻塞我们的代码，直到子程序退出——这当然是不好的，因为我们必须同时运行五个程序）。如果出现任何问题，我们将使用`log.Fatalln`退出，但如果程序成功启动，我们将推迟调用杀死进程。这有助于确保子程序在我们的`main`函数退出时退出，这将是`domainfinder`程序结束时。
- en: Once all of the programs are running, we then iterate over every command again
    and wait for it to finish. This is to ensure that `domainfinder` doesn't exit
    early and kill off all the subprograms too soon.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有程序都在运行，我们就会再次迭代每个命令，并等待其完成。这是为了确保`domainfinder`不会提前退出并过早终止所有子程序。
- en: Run the `build.sh` or `build.bat` script again and notice that the `domainfinder`
    program has the same behavior as we have seen before, with a much more elegant
    interface.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`build.sh`或`build.bat`脚本，并注意`domainfinder`程序具有与我们之前看到的相同行为，但界面更加优雅。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how five small command-line programs can, when composed
    together, produce powerful results while remaining modular. We avoided tightly
    coupling our programs so they are still useful in their own right. For example,
    we can use our available program just to check if domain names we manually enter
    are available or not, or we can use our `synonyms` program just as a command-line
    thesaurus.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了五个小的命令行程序如何在组合在一起时产生强大的结果，同时保持模块化。我们避免了紧密耦合我们的程序，因此它们仍然可以单独使用。例如，我们可以使用我们的可用程序来检查手动输入的域名是否可用，或者我们可以将我们的`synonyms`程序仅用作命令行同义词词典。
- en: We learned how standard streams could be used to build different flows of these
    types of programs, and how redirection of the standard input and the standard
    output lets us play around with different flows very easily.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用标准流来构建这些类型的程序的不同流，以及如何重定向标准输入和标准输出让我们非常容易地玩弄不同的流。
- en: We learned how simple it is in Go to consume a JSON RESTful APIs web service
    when we needed to get synonyms from the Big Hugh Thesaurus. We kept it simple
    at first by coding it inline and later refactoring the code to abstract the `Thesaurus`
    type into its own package, which is ready to share. We also consumed a non-HTTP
    API when we opened a connection to the WHOIS server and wrote data over raw TCP.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了在Go中消耗JSON RESTful API web服务是多么简单，当我们需要从Big Hugh Thesaurus获取同义词时。一开始我们保持简单，通过内联编码来编写代码，后来重构代码将`Thesaurus`类型抽象成自己的包，可以共享。当我们打开到WHOIS服务器的连接并通过原始TCP写入数据时，我们还使用了非HTTP
    API。
- en: We saw how the `math/rand` package can bring a little variety and unpredictability,
    by allowing us to use pseudo random numbers and decisions in our code, which meant
    that each time we run our program, we get different results.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了`math/rand`包如何通过允许我们在代码中使用伪随机数和决策，为我们带来了一些变化和不可预测性，这意味着每次运行程序时，我们都会得到不同的结果。
- en: Finally, we built our `domainfinder` super program that composes all the subprograms
    together giving our solution a simple, clean, and elegant interface.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们构建了我们的`domainfinder`超级程序，将所有子程序组合在一起，为我们的解决方案提供了简单、干净和优雅的界面。
