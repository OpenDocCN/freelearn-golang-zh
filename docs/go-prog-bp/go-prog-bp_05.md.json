["```go\n{\n  \"_id\": \"???\",\n  \"title\": \"Poll title\",\n  \"options\": [\"one\", \"two\", \"three\"],\n  \"results\": {\n    \"one\": 100,\n    \"two\": 200,\n    \"three\": 300\n  }\n}\n```", "```go\n\nbrew install nsq\n\n```", "```go\n\nnsqlookupd v0.2.27 (built w/go1.3)\n\nTCP: listening on [::]:4160\n\nHTTP: listening on [::]:4161\n\n```", "```go\n\ngo get github.com/bitly/go-nsq\n\n```", "```go\n{\"name\":\"Mat\",\"lang\":\"en\",\"points\":57}\n{\"name\":\"Laurie\",\"position\":\"Scrum Master\"}\n{\"position\":\"Traditional Manager\",\"exists\":false}\n```", "```go\n\ngo get gopkg.in/mgo.v2\n\n```", "```go\n\nnsqlookupd\n\n```", "```go\n\nnsqd --lookupd-tcp-address=localhost:4160\n\n```", "```go\n\nmongod --dbpath ./db\n\n```", "```go\npackage main\nfunc main(){}\n```", "```go\n#!/bin/bash\nexport SP_TWITTER_KEY=yCwwKKnuBnUBrelyTN...\nexport SP_TWITTER_SECRET=6on0YRYniT1sI3f...\nexport SP_TWITTER_ACCESSTOKEN=2427-13677...\nexport SP_TWITTER_ACCESSSECRET=SpnZf336u...\n```", "```go\nvar conn net.Conn\nfunc dial(netw, addr string) (net.Conn, error) {\n  if conn != nil {\n    conn.Close()\n    conn = nil\n  }\n  netc, err := net.DialTimeout(netw, addr, 5*time.Second)\n  if err != nil {\n    return nil, err\n  }\n  conn = netc\n  return netc, nil\n}\n```", "```go\nvar reader io.ReadCloser\nfunc closeConn() {\n  if conn != nil {\n    conn.Close()\n  }\n  if reader != nil {\n    reader.Close()\n  }\n}\n```", "```go\nvar (\n  authClient *oauth.Client\n  creds *oauth.Credentials\n)\nfunc setupTwitterAuth() {\n  var ts struct {\n    ConsumerKey    string `env:\"SP_TWITTER_KEY,required\"`\n    ConsumerSecret string `env:\"SP_TWITTER_SECRET,required\"`\n    AccessToken    string `env:\"SP_TWITTER_ACCESSTOKEN,required\"`\n    AccessSecret   string `env:\"SP_TWITTER_ACCESSSECRET,required\"`\n  }\n  if err := envdecode.Decode(&ts); err != nil {\n    log.Fatalln(err)\n  }\n  creds = &oauth.Credentials{\n    Token:  ts.AccessToken,\n    Secret: ts.AccessSecret,\n  }\n  authClient = &oauth.Client{\n    Credentials: oauth.Credentials{\n      Token:  ts.ConsumerKey,\n      Secret: ts.ConsumerSecret,\n    },\n  }\n}\n```", "```go\nvar (\n  authSetupOnce sync.Once\n  httpClient    *http.Client\n)\nfunc makeRequest(req *http.Request, params url.Values) (*http.Response, error) {\n  authSetupOnce.Do(func() {\n    setupTwitterAuth()\n    httpClient = &http.Client{\n      Transport: &http.Transport{\n        Dial: dial,\n      },\n    }\n  })\n  formEnc := params.Encode()\n  req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n  req.Header.Set(\"Content-Length\", strconv.Itoa(len(formEnc)))\n  req.Header.Set(\"Authorization\", authClient.AuthorizationHeader(creds, \"POST\", req.URL, params))\n  return httpClient.Do(req)\n}\n```", "```go\nvar db *mgo.Session\nfunc dialdb() error {\n  var err error\n  log.Println(\"dialing mongodb: localhost\")\n  db, err = mgo.Dial(\"localhost\")\n  return err\n}\nfunc closedb() {\n  db.Close()\n  log.Println(\"closed database connection\")\n}\n```", "```go\ntype poll struct {\n  Options []string\n}\nfunc loadOptions() ([]string, error) {\n  var options []string\n  iter := db.DB(\"ballots\").C(\"polls\").Find(nil).Iter()\n  var p poll\n  for iter.Next(&p) {\n    options = append(options, p.Options...)\n  }\n  iter.Close()\n  return options, iter.Err()\n}\n```", "```go\nquery := col.Find(q).Sort(\"field\").Limit(10).Skip(10)\n```", "```go\ntype tweet struct {\n  Text string\n}\n```", "```go\nfunc readFromTwitter(votes chan<- string) {\n  options, err := loadOptions()\n  if err != nil {\n    log.Println(\"failed to load options:\", err)\n    return\n  }\n  u, err := url.Parse(\"https://stream.twitter.com/1.1/statuses/filter.json\")\n  if err != nil {\n    log.Println(\"creating filter request failed:\", err)\n    return\n  }\n  query := make(url.Values)\n  query.Set(\"track\", strings.Join(options, \",\"))\n  req, err := http.NewRequest(\"POST\", u.String(), strings.NewReader(query.Encode()))\n  if err != nil {\n    log.Println(\"creating filter request failed:\", err)\n    return\n  }\n  resp, err := makeRequest(req, query)\n  if err != nil {\n    log.Println(\"making request failed:\", err)\n    return\n  }\n  reader := resp.Body\n  decoder := json.NewDecoder(reader)\n  for {\n    var tweet tweet\n    if err := decoder.Decode(&tweet); err != nil {\n      break\n    }\n    for _, option := range options {\n      if strings.Contains(\n        strings.ToLower(tweet.Text),\n        strings.ToLower(option),\n      ) {\n        log.Println(\"vote:\", option)\n        votes <- option\n      }\n    }\n  }\n}\n```", "```go\nfmt.Println(reflect.TypeOf(true).Size())\n= 1\n```", "```go\nfmt.Println(reflect.TypeOf(struct{}{}).Size())\n= 0\n```", "```go\nfunc startTwitterStream(stopchan <-chan struct{}, votes chan<- string) <-chan struct{} {\n  stoppedchan := make(chan struct{}, 1)\n  go func() {\n    defer func() {\n      stoppedchan <- struct{}{}\n    }()\n    for {\n      select {\n      case <-stopchan:\n        log.Println(\"stopping Twitter...\")\n        return\n      default:\n        log.Println(\"Querying Twitter...\")\n        readFromTwitter(votes)\n        log.Println(\"  (waiting)\")\n        time.Sleep(10 * time.Second) // wait before reconnecting\n      }\n    }\n  }()\n  return stoppedchan\n}\n```", "```go\nfunc publishVotes(votes <-chan string) <-chan struct{} {\n  stopchan := make(chan struct{}, 1)\n  pub, _ := nsq.NewProducer(\"localhost:4150\", nsq.NewConfig())\n  go func() {\n    for vote := range votes {\n      pub.Publish(\"votes\", []byte(vote)) // publish vote\n    }\n    log.Println(\"Publisher: Stopping\")\n    pub.Stop()\n    log.Println(\"Publisher: Stopped\")\n    stopchan <- struct{}{}\n  }()\n  return stopchan\n}\n```", "```go\nvar stoplock sync.Mutex\nstop := false\nstopChan := make(chan struct{}, 1)\nsignalChan := make(chan os.Signal, 1)\ngo func() { \n  <-signalChan\n  stoplock.Lock()\n  stop = true\n  stoplock.Unlock()\n  log.Println(\"Stopping...\")\n  stopChan <- struct{}{}\n  closeConn()\n}()\nsignal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)\n```", "```go\nif err := dialdb(); err != nil {\n  log.Fatalln(\"failed to dial MongoDB:\", err)\n}\ndefer closedb()\n```", "```go\n// start things\nvotes := make(chan string) // chan for votes\npublisherStoppedChan := publishVotes(votes)\ntwitterStoppedChan := startTwitterStream(stopChan, votes)\ngo func() {\n  for {\n    time.Sleep(1 * time.Minute)\n    closeConn()\n    stoplock.Lock()\n    if stop {\n      stoplock.Unlock()\n      break\n    }\n    stoplock.Unlock()\n  }\n}()\n<-twitterStoppedChan\nclose(votes)\n<-publisherStoppedChan\n```", "```go\n\n> use ballots\n\nswitched to db ballots\n\n> db.polls.insert({\"title\":\"Test poll\",\"options\":[\"happy\",\"sad\",\"fail\",\"win\"]})\n\n```", "```go\n\nnsq_tail --topic=\"votes\" --lookupd-http-address=localhost:4161\n\n```", "```go\n\ngo build \u2013o twittervotes\n\n./twittervotes\n\n```", "```go\npackage main\nimport (\n  \"flag\"\n  \"fmt\"\n  \"os\"\n)\nvar fatalErr error\nfunc fatal(e error) {\n  fmt.Println(e)\n  flag.PrintDefaults()\n  fatalErr = e\n}\nfunc main() {\n  defer func() {\n    if fatalErr != nil {\n      os.Exit(1)\n    }\n  }()\n}\n```", "```go\nlog.Println(\"Connecting to database...\")\ndb, err := mgo.Dial(\"localhost\")\nif err != nil {\n  fatal(err)\n  return\n}\ndefer func() {\n  log.Println(\"Closing database connection...\")\n  db.Close()\n}()\npollData := db.DB(\"ballots\").C(\"polls\")\n```", "```go\nvar counts map[string]int\nvar countsLock sync.Mutex\n```", "```go\nlog.Println(\"Connecting to nsq...\")\nq, err := nsq.NewConsumer(\"votes\", \"counter\", nsq.NewConfig())\nif err != nil {\n  fatal(err)\n  return\n}\n```", "```go\nq.AddHandler(nsq.HandlerFunc(func(m *nsq.Message) error {\n  countsLock.Lock()\n  defer countsLock.Unlock()\n  if counts == nil {\n    counts = make(map[string]int)\n  }\n  vote := string(m.Body)\n  counts[vote]++\n  return nil\n}))\n```", "```go\nif err := q.ConnectToNSQLookupd(\"localhost:4161\"); err != nil {\n  fatal(err)\n  return\n}\n```", "```go\nlog.Println(\"Waiting for votes on nsq...\")\nvar updater *time.Timer\nupdater = time.AfterFunc(updateDuration, func() {\n  countsLock.Lock()\n  defer countsLock.Unlock()\n  if len(counts) == 0 {\n    log.Println(\"No new votes, skipping database update\")\n  } else {\n    log.Println(\"Updating database...\")\n    log.Println(counts)\n    ok := true\n    for option, count := range counts {\n      sel := bson.M{\"options\": bson.M{\"$in\": []string{option}}}\n      up := bson.M{\"$inc\": bson.M{\"results.\" + option: count}}\n      if _, err := pollData.UpdateAll(sel, up); err != nil {\n        log.Println(\"failed to update:\", err)\n        ok = false\n      }\n    }\n    if ok {\n      log.Println(\"Finished updating database...\")\n      counts = nil // reset counts\n    }\n  }\n  updater.Reset(updateDuration)\n})\n```", "```go\n{\n  \"options\": {\n    \"$in\": [\"happy\"]\n  }\n}\n```", "```go\n{\n  \"$inc\": {\n    \"results.happy\": 3\n  }\n}\n```", "```go\nconst updateDuration = 1 * time.Second\n```", "```go\ntermChan := make(chan os.Signal, 1)\nsignal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP)\nfor {\n  select {\n  case <-termChan:\n    updater.Stop()\n    q.Stop()\n  case <-q.StopChan:\n    // finished\n    return\n  }\n}\n```", "```go\n\nnsqlookupd\n\nnsqd --lookupd-tcp-address=127.0.0.1:4160\n\nmongod --dbpath ./db\n\n```", "```go\n\ngo build -o counter\n\n./counter\n\n```", "```go\n\nNo new votes, skipping database update\n\nUpdating database...\n\nmap[win:2 happy:2 fail:1]\n\nFinished updating database...\n\nNo new votes, skipping database update\n\nUpdating database...\n\nmap[win:3]\n\nFinished updating database...\n\n```", "```go\n\nmongo\n\n```", "```go\n\n> use ballots\n\nswitched to db ballots\n\n```", "```go\n\n> db.polls.find().pretty()\n\n{\n\n \"_id\" : ObjectId(\"53e2a3afffbff195c2e09a02\"),\n\n \"options\" : [\n\n \"happy\",\"sad\",\"fail\",\"win\"\n\n ],\n\n \"results\" : {\n\n \"fail\" : 159, \"win\" : 711,\n\n \"happy\" : 233, \"sad\" : 166,\n\n },\n\n \"title\" : \"Test poll\"\n\n}\n\n```"]