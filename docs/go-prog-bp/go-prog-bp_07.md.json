["```go\nGET /journeys\n```", "```go\n[\n  {\n    name: \"Romantic\",\n    journey: \"park|bar|movie_theater|restaurant|florist\"\n  },\n  {\n    name: \"Shopping\",\n    journey: \"department_store|clothing_store|jewelry_store\"\n  }\n]\n```", "```go\nGET /recommendations?\n     lat=1&lng=2&journey=bar|cafe&radius=10&cost=$...$$$$$\n```", "```go\n[\n  {\n    icon: \"http://maps.gstatic.com/mapfiles/place_api/icons/cafe-71.png\",\n    lat: 51.519583, lng: -0.146251,\n    vicinity: \"63 New Cavendish St, London\",\n    name: \"Asia House\",\n    photos: [{\n      url: \"https://maps.googleapis.com/maps/api/place/photo?maxwidth=400&photoreference=CnRnAAAAyLRN\"\n     }]\n  }, ...\n]\n```", "```go\npackage meander\ntype j struct {\n  Name       string\n  PlaceTypes []string\n}\nvar Journeys = []interface{}{\n  &j{Name: \"Romantic\", PlaceTypes: []string{\"park\", \"bar\", \"movie_theater\", \"restaurant\", \"florist\", \"taxi_stand\"}},\n  &j{Name: \"Shopping\", PlaceTypes: []string{\"department_store\", \"cafe\", \"clothing_store\", \"jewelry_store\", \"shoe_store\"}},\n  &j{Name: \"Night Out\", PlaceTypes: []string{\"bar\", \"casino\", \"food\", \"bar\", \"night_club\", \"bar\", \"bar\", \"hospital\"}},\n  &j{Name: \"Culture\", PlaceTypes: []string{\"museum\", \"cafe\", \"cemetery\", \"library\", \"art_gallery\"}},\n  &j{Name: \"Pamper\", PlaceTypes: []string{\"hair_care\", \"beauty_salon\", \"cafe\", \"spa\"}},\n}\n```", "```go\npackage main\nfunc main() {\n  runtime.GOMAXPROCS(runtime.NumCPU())\n  //meander.APIKey = \"TODO\"\n  http.HandleFunc(\"/journeys\", func(w http.ResponseWriter, r *http.Request) {\n    respond(w, r, meander.Journeys)\n  })\n  http.ListenAndServe(\":8080\", http.DefaultServeMux)\n}\nfunc respond(w http.ResponseWriter, r *http.Request, data []interface{}) error {\n  return json.NewEncoder(w).Encode(data)\n}\n```", "```go\n\ngo run main.go \n\n```", "```go\n[{\n  Name: \"Romantic\",\n  PlaceTypes: [\n    \"park\",\n    \"bar\",\n    \"movie_theater\",\n    \"restaurant\",\n    \"florist\",\n    \"taxi_stand\"\n  ]\n}]\n```", "```go\npackage meander\ntype Facade interface {\n  Public() interface{}\n}\nfunc Public(o interface{}) interface{} {\n  if p, ok := o.(Facade); ok {\n    return p.Public()\n  }\n  return o\n}\n```", "```go\nfunc (j *j) Public() interface{} {\n  return map[string]interface{}{\n    \"name\":    j.Name,\n    \"journey\": strings.Join(j.PlaceTypes, \"|\"),\n  }\n}\n```", "```go\nfunc respond(w http.ResponseWriter, r *http.Request, data []interface{}) error {\n  publicData := make([]interface{}, len(data))\n  for i, d := range data {\n    publicData[i] = meander.Public(d)\n  }\n  return json.NewEncoder(w).Encode(publicData)\n}\n```", "```go\n[{\n  journey: \"park|bar|movie_theater|restaurant|florist|taxi_stand\",\n  name: \"Romantic\"\n}, ...]\n```", "```go\npackage meander\ntype Place struct {\n  *googleGeometry `json:\"geometry\"`\n  Name            string         `json:\"name\"`\n  Icon            string         `json:\"icon\"`\n  Photos          []*googlePhoto `json:\"photos\"`\n  Vicinity        string         `json:\"vicinity\"`\n}\ntype googleResponse struct {\n  Results []*Place `json:\"results\"`\n}\ntype googleGeometry struct {\n  *googleLocation `json:\"location\"`\n}\ntype googleLocation struct {\n  Lat float64 `json:\"lat\"`\n  Lng float64 `json:\"lng\"`\n}\ntype googlePhoto struct {\n  PhotoRef string `json:\"photo_reference\"`\n  URL      string `json:\"url\"`\n}\n```", "```go\nfunc (p *Place) Public() interface{} {\n  return map[string]interface{}{\n    \"name\":     p.Name,\n    \"icon\":     p.Icon,\n    \"photos\":   p.Photos,\n    \"vicinity\": p.Vicinity,\n    \"lat\":      p.Lat,\n    \"lng\":      p.Lng,\n  }\n}\n```", "```go\nvar APIKey string\n```", "```go\npackage meander\ntype Cost int8\nconst (\n  _ Cost = iota\n  Cost1\n  Cost2\n  Cost3\n  Cost4\n  Cost5\n)\n```", "```go\npackage meander_test\nimport (\n  \"testing\"\n  \"github.com/cheekybits/is\"\n  \"path/to/meander\"\n)\nfunc TestCostValues(t *testing.T) {\n  is := is.New(t)\n  is.Equal(int(meander.Cost1), 1)\n  is.Equal(int(meander.Cost2), 2)\n  is.Equal(int(meander.Cost3), 3)\n  is.Equal(int(meander.Cost4), 4)\n  is.Equal(int(meander.Cost5), 5)\n}\n```", "```go\nfunc TestCostString(t *testing.T) {\n  is := is.New(t)\n  is.Equal(meander.Cost1.String(), \"$\")\n  is.Equal(meander.Cost2.String(), \"$$\")\n  is.Equal(meander.Cost3.String(), \"$$$\")\n  is.Equal(meander.Cost4.String(), \"$$$$\")\n  is.Equal(meander.Cost5.String(), \"$$$$$\")\n}\n```", "```go\nvar costStrings = map[string]Cost{\n  \"$\":     Cost1,\n  \"$$\":    Cost2,\n  \"$$$\":   Cost3,\n  \"$$$$\":  Cost4,\n  \"$$$$$\": Cost5,\n}\nfunc (l Cost) String() string {\n  for s, v := range costStrings {\n    if l == v {\n      return s\n    }\n  }\n  return \"invalid\"\n}\n```", "```go\nfunc TestParseCost(t *testing.T) {\n  is := is.New(t)\n  is.Equal(meander.Cost1, meander.ParseCost(\"$\"))\n  is.Equal(meander.Cost2, meander.ParseCost(\"$$\"))\n  is.Equal(meander.Cost3, meander.ParseCost(\"$$$\"))\n  is.Equal(meander.Cost4, meander.ParseCost(\"$$$$\"))\n  is.Equal(meander.Cost5, meander.ParseCost(\"$$$$$\"))\n}\n```", "```go\nfunc ParseCost(s string) Cost {\n  return costStrings[s]\n}\n```", "```go\nfunc TestParseCostRange(t *testing.T) {\n  is := is.New(t)\n  var l *meander.CostRange\n  l = meander.ParseCostRange(\"$$...$$$\")\n  is.Equal(l.From, meander.Cost2)\n  is.Equal(l.To, meander.Cost3)\n  l = meander.ParseCostRange(\"$...$$$$$\")\n  is.Equal(l.From, meander.Cost1)\n  is.Equal(l.To, meander.Cost5)\n}\nfunc TestCostRangeString(t *testing.T) {\n  is := is.New(t)\n  is.Equal(\"$$...$$$$\", (&meander.CostRange{\n    From: meander.Cost2,\n    To:   meander.Cost4,\n  }).String())\n}\n```", "```go\ntype CostRange struct {\n  From Cost\n  To   Cost\n}\nfunc (r CostRange) String() string {\n  return r.From.String() + \"...\" + r.To.String()\n}\nfunc ParseCostRange(s string) *CostRange {\n  segs := strings.Split(s, \"...\")\n  return &CostRange{\n    From: ParseCost(segs[0]),\n    To:   ParseCost(segs[1]),\n  }\n}\n```", "```go\ntype Query struct {\n  Lat          float64\n  Lng          float64\n  Journey      []string\n  Radius       int\n  CostRangeStr string\n}\n```", "```go\nfunc (q *Query) find(types string) (*googleResponse, error) {\n  u := \"https://maps.googleapis.com/maps/api/place/nearbysearch/json\"\n  vals := make(url.Values)\n  vals.Set(\"location\", fmt.Sprintf(\"%g,%g\", q.Lat, q.Lng))\n  vals.Set(\"radius\", fmt.Sprintf(\"%d\", q.Radius))\n  vals.Set(\"types\", types)\n  vals.Set(\"key\", APIKey)\n  if len(q.CostRangeStr) > 0 {\n    r := ParseCostRange(q.CostRangeStr)\n    vals.Set(\"minprice\", fmt.Sprintf(\"%d\", int(r.From)-1))\n    vals.Set(\"maxprice\", fmt.Sprintf(\"%d\", int(r.To)-1))\n  }\n  res, err := http.Get(u + \"?\" + vals.Encode())\n  if err != nil {\n    return nil, err\n  }\n  defer res.Body.Close()\n  var response googleResponse\n  if err := json.NewDecoder(res.Body).Decode(&response); err != nil {\n    return nil, err\n  }\n  return &response, nil\n}\n```", "```go\n// Run runs the query concurrently, and returns the results.\nfunc (q *Query) Run() []interface{} {\n  rand.Seed(time.Now().UnixNano())\n  var w sync.WaitGroup\n  var l sync.Mutex\n  places := make([]interface{}, len(q.Journey))\n  for i, r := range q.Journey {\n    w.Add(1)\n    go func(types string, i int) {\n      defer w.Done()\n      response, err := q.find(types)\n      if err != nil {\n        log.Println(\"Failed to find places:\", err)\n        return\n      }\n      if len(response.Results) == 0 {\n        log.Println(\"No places found for\", types)\n        return\n      }\n      for _, result := range response.Results {\n        for _, photo := range result.Photos {\n          photo.URL = \"https://maps.googleapis.com/maps/api/place/photo?\" +\n            \"maxwidth=1000&photoreference=\" + photo.PhotoRef + \"&key=\" + APIKey\n        }\n      }\n      randI := rand.Intn(len(response.Results))\n      l.Lock()\n      places[i] = response.Results[randI]\n      l.Unlock()\n    }(r, i)\n  }\n  w.Wait() // wait for everything to finish\n  return places\n}\n```", "```go\nhttp.HandleFunc(\"/recommendations\", func(w http.ResponseWriter, r *http.Request) {\n  q := &meander.Query{\n    Journey: strings.Split(r.URL.Query().Get(\"journey\"), \"|\"),\n  }\n  q.Lat, _ = strconv.ParseFloat(r.URL.Query().Get(\"lat\"), 64)\n  q.Lng, _ = strconv.ParseFloat(r.URL.Query().Get(\"lng\"), 64)\n  q.Radius, _ = strconv.Atoi(r.URL.Query().Get(\"radius\"))\n  q.CostRangeStr = r.URL.Query().Get(\"cost\")\n  places := q.Run()\n  respond(w, r, places)\n})\n```", "```go\nfunc cors(f http.HandlerFunc) http.HandlerFunc {\n  return func(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n    f(w, r)\n  }\n}\n```", "```go\nfunc main() {\n  runtime.GOMAXPROCS(runtime.NumCPU())\n  meander.APIKey = \"YOUR_API_KEY\"\n  http.HandleFunc(\"/journeys\", cors(func(w http.ResponseWriter, r *http.Request) {\n    respond(w, r, meander.Journeys)\n  }))\n  http.HandleFunc(\"/recommendations\", cors(func(w http.ResponseWriter, r *http.Request) {\n    q := &meander.Query{\n      Journey: strings.Split(r.URL.Query().Get(\"journey\"), \"|\"),\n    }\n    q.Lat, _ = strconv.ParseFloat(r.URL.Query().Get(\"lat\"), 64)\n    q.Lng, _ = strconv.ParseFloat(r.URL.Query().Get(\"lng\"), 64)\n    q.Radius, _ = strconv.Atoi(r.URL.Query().Get(\"radius\"))\n    q.CostRangeStr = r.URL.Query().Get(\"cost\")\n    places := q.Run()\n    respond(w, r, places)\n  }))\n  http.ListenAndServe(\":8080\", http.DefaultServeMux)\n}\n```", "```go\n\ngo build \u2013o meanderapi\n\n./meanderapi\n\n```", "```go\nhttp://localhost:8080/recommendations?\n  lat=51.520707&lng=-0.153809&radius=5000&\n  journey=cafe|bar|casino|restaurant&\n  cost=$...$$$\n```", "```go\n\ngo build \u2013o meanderweb\n\n./meanderweb\n\n```"]