- en: Chapter 7. Random Recommendations Web Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。随机推荐网络服务
- en: 'The concept behind the project that we will build in this chapter is a simple
    one: we want users to be able to generate random recommendations for things to
    do in specific geographical locations based on a predefined set of journey types
    that we will expose through the API. We will give our project the codename Meander.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的概念是简单的：我们希望用户能够根据我们将通过API公开的预定义旅行类型，在特定地理位置生成随机推荐的活动。我们将给我们的项目起名为Meander。
- en: Often on projects in the real world, you are responsible for the full stack;
    somebody else builds the website, a different person still might write the iOS
    app, and maybe an outsourced company builds the desktop version. On more successful
    API projects, you might not even know who the consumers of your API are, especially
    if it's a public API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的项目中，你通常需要负责整个技术栈；有人建立网站，另一个人可能编写iOS应用，也许外包公司建立桌面版本。在更成功的API项目中，你甚至可能不知道你的API的消费者是谁，特别是如果它是一个公共API。
- en: In this chapter, we will simulate this reality by designing and agreeing a minimal
    API design with a fictional partner up front before going on to implement the
    API. Once we have finished our side of the project, we will download a user interface
    built by our teammates to see the two work together to produce the final application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过与虚构合作伙伴事先设计和达成最小API设计来模拟这一现实，然后再实施API。一旦我们完成了项目的一部分，我们将下载由我们的队友构建的用户界面，看看它们如何一起工作，产生最终的应用程序。
- en: 'In this chapter, you will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将：
- en: Learn to express the general goals of a project using short and simple Agile
    user stories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会使用简短而简单的敏捷用户故事来表达项目的一般目标
- en: Discover that you can agree a meeting point in a project by agreeing on the
    design of an API, which allows many people to work in parallel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现你可以通过达成API设计来约定项目的会议点，这样可以让许多人并行工作。
- en: See how early versions of code can actually have data fixtures written in code
    and compiled into the program, allowing us to change the implementation later
    without touching the interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看早期版本的代码实际上可以在代码中编写数据固定装置并编译到程序中，这样我们可以稍后更改实现而不触及接口
- en: Learn a strategy that allows structs (and other types) to represent a public
    version of themselves for cases when we want to hide or transform internal representations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一种策略，允许结构体（和其他类型）代表它们的公共版本，以便在我们想要隐藏或转换内部表示时使用
- en: Learn to use embedded structs to represent nested data, while keeping the interface
    of our types simple
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会使用嵌入结构体来表示嵌套数据，同时保持我们类型的接口简单
- en: Learn to use `http.Get` to make external API requests, specifically to the Google
    Places API, with no code bloat
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会使用`http.Get`来进行外部API请求，特别是Google Places API，而不会有代码膨胀
- en: Learn to effectively implement enumerators in Go, even though they aren't really
    a language feature
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会在Go中有效地实现枚举器，尽管它们实际上不是一种语言特性
- en: Experience a real-world example of TDD
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 体验TDD的真实例子
- en: See how the `math/rand` package makes it easy to select an item from a slice
    at random
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看`math/rand`包如何轻松地从切片中随机选择一个项目
- en: Learn an easy way to grab data from the URL parameters of the `http.Request`
    type
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会从`http.Request`类型的URL参数中轻松获取数据
- en: Project overview
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: Following Agile methodologies, let's write two user stories that describe the
    functionality of our project. User stories shouldn't be comprehensive documents
    describing the entire set of features of an application; rather small cards are
    perfect for not only describing what the user is trying to do, but why. Also,
    we should do this without trying to design the whole system up front or delve
    too deep into implementation details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循敏捷方法，让我们写两个用户故事来描述我们项目的功能。用户故事不应该是描述应用程序整套功能的全面文档；小卡片不仅适合描述用户试图做什么，还适合描述为什么。此外，我们应该在不试图事先设计整个系统或深入实现细节的情况下完成这一点。
- en: 'First we need a story about seeing the different journey types from which our
    users may select:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个关于看到我们的用户可以选择的不同旅行类型的故事：
- en: '| **As a** | traveler |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **作为** | 旅行者 |'
- en: '| **I want** | to see the different types of journeys I can get recommendations
    for |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **我想** | 看到我可以获得推荐的不同旅行类型 |'
- en: '| **So that** | I can decide what kind of evening to take my partner on |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **以便** | 我可以决定带我的伴侣去哪种类型的晚上 |'
- en: 'Secondly, we need a story about providing random recommendations for a selected
    journey type:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要一个关于为选定的旅行类型提供随机推荐的故事：
- en: '| **As a** | traveler |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **作为** | 旅行者 |'
- en: '| **I want** | to see a random recommendation for my selected journey type
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **我想** | 看到我选择的旅行类型的随机推荐 |'
- en: '| **So that** | I know where to go, and what the evening will entail |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **以便** | 我知道去哪里，晚上会是什么样子 |'
- en: These two stories represent the two core capabilities that our API needs to
    provide, and actually ends up representing two endpoints.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个故事代表了我们的API需要提供的两个核心功能，并最终代表了两个端点。
- en: In order to discover places around specified locations, we are going to make
    use of the Google Places API, which allows us to search for listings of businesses
    with given types, such as `bar` , `café` , or `movie_theater` . We will then use
    Go's `math/rand` package to pick from those places at random, building up a complete
    journey for our users.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发现指定位置周围的地方，我们将使用Google Places API，它允许我们搜索具有给定类型的企业列表，比如`酒吧`，`咖啡馆`或`电影院`。然后我们将使用Go的`math/rand`包随机选择这些地方，为我们的用户建立完整的旅程。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The Google Places API supports many business types; see [https://developers.google.com/places/documentation/supported_types](https://developers.google.com/places/documentation/supported_types)
    for the complete list.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Google Places API支持许多业务类型；请参阅[https://developers.google.com/places/documentation/supported_types](https://developers.google.com/places/documentation/supported_types)获取完整列表。
- en: Project design specifics
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目设计细节
- en: In order to turn our stories into an interactive application, we are going to
    provide two JSON endpoints; one to deliver the kinds of journeys users will be
    able to select in the application, and another to actually generate the random
    recommendations for the selected journey type.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的故事转化为一个交互式应用程序，我们将提供两个JSON端点；一个用于提供用户可以在应用程序中选择的旅程类型，另一个用于实际生成所选旅程类型的随机推荐。
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The above call should return a list such as the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述调用应返回以下列表：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `name` field is a human-readable label for the type of recommendations
    the app generates, and the `journey` field is a pipe-separated list of supported
    journey types. It is the journey value that we will pass, as a URL parameter,
    into our other endpoint, which generates the actual recommendations:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`字段是应用程序生成的推荐类型的可读标签，`journey`字段是支持的旅程类型的管道分隔列表。我们将传递旅程值作为URL参数到我们的另一个端点，该端点生成实际的推荐：'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This endpoint is responsible for querying the Google Places API and generating
    the recommendations before returning an array of place objects. We will use the
    parameters in the URL to control the kind of query to make as per the HTTP specification.
    The `lat` and `lng` parameters, representing latitude and longitude, respectively,
    tell our API where in the world we want recommendations from, and the `radius`
    parameter represents the distance in meters around the point in which we are interested
    in. The `cost` value is a human-readable way of representing the price range for
    places that the API returns. It is made up of two values: a lower and upper range
    separated by three dots. The number of dollar characters represents the price
    level, with `$` being the most affordable and `$$$$$` being the most expensive.
    Using this pattern, a value of `$...$$` would represent very low cost recommendations,
    where `$$$$...$$$$$` would represent a pretty expensive experience.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点负责查询Google Places API并在返回地点对象数组之前生成推荐。我们将使用URL中的参数来控制查询的类型，根据HTTP规范。`lat`和`lng`参数分别表示纬度和经度，告诉我们的API我们想要从世界的哪个地方获得推荐，`radius`参数表示我们感兴趣的点周围的米数距离。`cost`值是表示API返回的地点价格范围的一种可读方式。它由两个值组成：用三个点分隔的较低和较高范围。美元符号的数量表示价格水平，`$`是最实惠的，`$$$$$`是最昂贵的。使用这种模式，`$...$$`的值将表示非常低成本的推荐，而`$$$$...$$$$$`将表示相当昂贵的体验。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Some programmers might insist the cost range is represented by numerical values,
    but since our API is going to be consumed by people, why not make things a little
    more interesting?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员可能会坚持用数值表示成本范围，但由于我们的API将被人们使用，为什么不让事情变得更有趣呢？
- en: 'An example payload for this call might look something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个调用的示例负载可能看起来像这样：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The array returned contains a place object representing a random recommendation
    for each segment in the journey, in the appropriate order. The preceding example
    is a café in London. The data fields are fairly self-explanatory; the `lat` and
    `lng` fields represent the location of the place (they're short for latitude and
    longitude), the `name` and `vicinity` fields tell us what and where the business
    is, and the `photos` array gives us a list of relevant photographs from Google's
    servers. The `vicinity` and `icon` fields will help us deliver a richer experience
    to our users.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数组包含代表旅程中每个段的随机推荐的地点对象，按适当的顺序。上面的示例是伦敦的一家咖啡馆。数据字段相当不言自明；`lat`和`lng`字段表示地点的位置（它们是纬度和经度的缩写），`name`和`vicinity`字段告诉我们业务是什么和在哪里，`photos`数组给出了来自Google服务器的相关照片列表。`vicinity`和`icon`字段将帮助我们为用户提供更丰富的体验。
- en: Representing data in code
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中表示数据
- en: 'We are first going to expose the journeys that users can select from, so create
    a new folder called `meander` in `GOPATH` , and add the following `journeys.go`
    code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要公开用户可以选择的旅程，因此在`GOPATH`中创建一个名为`meander`的新文件夹，并添加以下`journeys.go`代码：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we define an internal type called `j` inside the `meander` package, which
    we then use to describe the journeys by creating instances of them inside the
    `Journeys` slice. This approach is an ultra-simple way of representing data in
    the code, without building in a dependency on an external data store.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`meander`包内定义了一个名为`j`的内部类型，然后我们使用它来通过在`Journeys`切片内创建它们的实例来描述旅程。这种方法是在代码中以一种超简单的方式表示数据，而不会构建对外部数据存储的依赖。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As an additional assignment, why not see if you can keep `golint` happy throughout
    this process? Every time you add some code, run `golint` for the packages and
    satisfy any suggestions that emerge. It cares a lot about exported items having
    no documentation, so adding simple comments in the correct format will keep it
    happy. To learn more about `golint` , see [https://github.com/golang/lint](https://github.com/golang/lint)
    .
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的任务，为什么不看看您是否可以在整个过程中让`golint`保持愉快？每次添加一些代码时，运行`golint`来检查包并满足任何建议。它非常关心没有文档的导出项，因此以正确格式添加简单注释将使其保持愉快。要了解有关`golint`的更多信息，请参阅[https://github.com/golang/lint](https://github.com/golang/lint)。
- en: Of course, this would likely evolve into just that later, maybe even with the
    ability for users to create and share their own journeys. Since we are exposing
    our data via an API, we are free to change the internal implementation without
    affecting the interface, so this approach is great for a version 1.0.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这可能会在以后演变成这样，甚至可能让用户创建和分享自己的旅程。由于我们通过API公开我们的数据，我们可以自由更改内部实现而不影响接口，因此这种方法非常适合1.0版本。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We are using a slice of type `[]interface{}` because we will later implement
    a general way of exposing public data regardless of actual types.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`[]interface{}`类型的切片，因为我们将稍后实现一种通用的方式来公开公共数据，而不考虑实际类型。
- en: A romantic journey consists of a visit first to a park, then a bar, a movie
    theater, then a restaurant, before a visit to a florist, and finally a taxi ride
    home; you get the general idea. Feel free to get creative and add others by consulting
    the supported types in the Google Places API.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一次浪漫的旅程包括首先访问公园，然后是酒吧，电影院，然后是餐厅，然后是花店，最后是乘坐出租车回家；你可以得到一个大致的想法。随意发挥创意，并通过查阅Google
    Places API中支持的类型来添加其他类型。
- en: You might have noticed that since we are containing our code inside a package
    called `meander` (rather than `main` ), our code can never be run as a tool like
    the other APIs we have written so far. Create a new folder called `cmd` inside
    `meander` ; this will house the actual command-line tool that exposes the `meander`
    package's capabilities via an HTTP endpoint.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，由于我们将代码包含在名为`meander`（而不是`main`）的包中，我们的代码永远无法像我们迄今为止编写的其他API一样作为工具运行。在`meander`内创建一个名为`cmd`的新文件夹；这将容纳通过HTTP端点公开`meander`包功能的实际命令行工具。
- en: 'Inside the `cmd` folder, add the following code to the `main.go` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cmd`文件夹中，将以下代码添加到`main.go`文件中：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will recognize this as a simple API endpoint program, mapping to the `/journeys`
    endpoint.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您会认出这是一个简单的API端点程序，映射到`/journeys`端点。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You'll have to import the `encoding/json` , `net/http` , and `runtime` packages,
    along with the `meander` package you created earlier.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您将不得不导入`encoding/json`，`net/http`和`runtime`包，以及您之前创建的`meander`包。
- en: The `runtime.GOMAXPROCS` call sets the maximum number of CPUs that our program
    can use, and we tell it to use them all. We then set the value of `APIKey` in
    the `meander` package (which is commented out for now, since we have yet to implement
    it) before calling the familiar `HandleFunc` function on the `net/http` package
    to bind our endpoint, which then just responds with the `meander.Journeys` variable.
    We borrow the abstract responding concept from the previous chapter by providing
    a `respond` function that encodes the specified data to the `http.ResponseWriter`
    type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime.GOMAXPROCS`调用设置了我们的程序可以使用的CPU的最大数量，并告诉它使用所有CPU。然后我们在`meander`包中设置了`APIKey`的值（目前已注释掉，因为我们还没有实现它），然后在`net/http`包上调用熟悉的`HandleFunc`函数来绑定我们的端点，然后只是响应`meander.Journeys`变量。我们从上一章借用了抽象响应的概念，提供了一个`respond`函数，将指定的数据编码到`http.ResponseWriter`类型中。'
- en: 'Let''s run our API program by navigating to the `cmd` folder in a terminal
    and using `go run` . We don''t need to build this into an executable file at this
    stage since it''s just a single file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在终端中导航到`cmd`文件夹并使用`go run`来运行我们的API程序。在这个阶段，我们不需要将其构建成可执行文件，因为它只是一个单独的文件：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Hit the `http://localhost:8080/journeys` endpoint, and notice that our `Journeys`
    data payload is served, which looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://localhost:8080/journeys`端点，注意我们提供的`Journeys`数据负载，它看起来像这样：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is perfectly acceptable, but there is one major flaw: it exposes internals
    about our implementation. If we changed the `PlaceTypes` field name to `Types`
    , our API would change and it''s important that we avoid this.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全可以接受的，但有一个主要缺陷：它暴露了我们实现的内部信息。如果我们将`PlaceTypes`字段名称更改为`Types`，我们的API将发生变化，我们应该避免这种情况。
- en: Projects evolve and change over time, especially successful ones, and as developers
    we should do what we can to protect our customers from the impact of the evolution.
    Abstracting interfaces is a great way to do this, as is taking ownership of the
    public-facing view of our data objects.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 项目随着时间的推移会不断发展和变化，尤其是成功的项目，作为开发人员，我们应该尽力保护我们的客户免受演变的影响。抽象接口是实现这一点的好方法，以及拥有数据对象的公共视图的所有权。
- en: Public views of Go structs
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go结构体的公共视图
- en: 'In order to control the public view of structs in Go, we need to invent a way
    to allow individual `journey` types to tell us how they want to be exposed. In
    the `meander` folder, create a new file called `public.go` , and add the following
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制Go中结构体的公共视图，我们需要发明一种方法，允许单独的`journey`类型告诉我们它们希望如何暴露。在`meander`文件夹中，创建一个名为`public.go`的新文件，并添加以下代码：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Facade` interface exposes a single `Public` method, which will return the
    public view of a struct. The `Public` function takes any object and checks to
    see whether it implements the `Facade` interface (does it have a `Public() interface{}`
    method?); and if it is implemented, calls the method and returns the result—otherwise
    it just returns the original object untouched. This allows us to pass anything
    through the `Public` function before writing the result to the `ResponseWriter`
    object, allowing individual structs to control their public appearance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Facade`接口公开了一个`Public`方法，该方法将返回结构体的公共视图。`Public`函数接受任何对象并检查它是否实现了`Facade`接口（它是否有一个`Public()
    interface{}`方法？）；如果实现了，就调用该方法并返回结果，否则就原样返回对象。这允许我们在将结果写入`ResponseWriter`对象之前通过`Public`函数传递任何内容，从而允许单独的结构体控制它们的公共外观。'
- en: 'Let''s implement a `Public` method for our `j` type by adding the following
    code to `journeys.go` :'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`journeys.go`中添加以下代码来为我们的`j`类型实现一个`Public`方法：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The public view of our `j` type joins the `PlaceTypes` field into a single string
    separated by the pipe character, as per our API design.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`j`类型的公共视图将`PlaceTypes`字段连接成一个由管道字符分隔的字符串，按照我们的API设计。
- en: 'Head back to `cmd/main.go` and replace the `respond` method with one that makes
    use of our new `Public` function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`cmd/main.go`，用使用我们的新`Public`函数替换`respond`方法：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here we iterate over the data slice calling the `meander.Public` function for
    each item, building the results into a new slice of the same size. In the case
    of our `j` type, its `Public` method will be called to serve the public view of
    the data, rather than the default view. In a terminal, navigate to the `cmd` folder
    again and run `go run main.go` before hitting `http://localhost:8080/journeys`
    again. Notice that the same data has now changed to a new structure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历数据切片，为每个项目调用`meander.Public`函数，将结果构建到一个相同大小的新切片中。对于我们的`j`类型，它的`Public`方法将被调用以提供数据的公共视图，而不是默认视图。在终端中，再次导航到`cmd`文件夹，并在运行`http://localhost:8080/journeys`之前再次运行`go
    run main.go`。注意，相同的数据现在已更改为新结构：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Generating random recommendations
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机推荐
- en: 'In order to obtain the places from which our code will randomly build up recommendations,
    we need to query the Google Places API. In the `meander` folder, add the following
    `query.go` file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取我们的代码将随机构建推荐的地点，我们需要查询Google Places API。在`meander`文件夹中，添加以下`query.go`文件：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code defines the structures we will need to parse the JSON response from
    the Google Places API into usable objects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了我们需要解析来自Google Places API的JSON响应的结构，以便将其转换为可用的对象。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Head over to the Google Places API documentation for an example of the response
    we are expecting. See [http://developers.google.com/places/documentation/search](http://developers.google.com/places/documentation/search)
    .
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 转到Google Places API文档，查看我们期望的响应示例。请参阅[http://developers.google.com/places/documentation/search](http://developers.google.com/places/documentation/search)。
- en: Most of the preceding code will be obvious, but it's worth noticing that the
    `Place` type embeds the `googleGeometry` type, which allows us to represent the
    nested data as per the API, while essentially flattening it in our code. We do
    the same with `googleLocation` inside `googleGeometry` , which means that we will
    be able to access the `Lat` and `Lng` values directly on a `Place` object, even
    though they're technically nested in other structures.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分前面的代码都是显而易见的，但值得注意的是`Place`类型嵌入了`googleGeometry`类型，这允许我们根据API表示嵌套数据，同时在我们的代码中实质上将其展平。我们在`googleGeometry`内部也是这样做的，这意味着我们将能够直接在`Place`对象上访问`Lat`和`Lng`值，即使它们在技术上是嵌套在其他结构中的。
- en: 'Because we want to control how a `Place` object appears publically, let''s
    give this type the following `Public` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想要控制`Place`对象如何公开显示，让我们给这个类型添加以下`Public`方法：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember to run `golint` on this code to see which comments need to be added
    to the exported items.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在这段代码上运行`golint`，看看哪些注释需要添加到导出的项目中。
- en: Google Places API key
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Places API密钥
- en: Like with most APIs, we will need an API key in order to access the remote services.
    Head over to the Google APIs Console, sign in with a Google account, and create
    a key for the Google Places API. For more detailed instructions, see the documentation
    on Google's developer website.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数API一样，我们需要一个API密钥才能访问远程服务。转到Google API控制台，使用Google账户登录，并为Google Places API创建一个密钥。有关更详细的说明，请参阅Google开发者网站上的文档。
- en: 'Once you have your key, let''s make a variable inside the `meander` package
    that can hold it. At the top of `query.go` , add the following definition:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了密钥，让我们在`meander`包中创建一个可以保存它的变量。在`query.go`的顶部，添加以下定义：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now nip back into `main.go` , remove the double slash `//` from the `APIKey`
    line, and replace the `TODO` value with the actual key provided by the Google
    APIs console.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在返回到`main.go`，从`APIKey`行中删除双斜杠`//`，并用Google API控制台提供的实际密钥替换`TODO`值。
- en: Enumerators in Go
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go中的枚举器
- en: To handle the various cost ranges for our API, it makes sense to use an enumerator
    (or **enum** ) to denote the various values and to handle conversions to and from
    string representations. Go doesn't explicitly provide enumerators, but there is
    a neat way of implementing them, which we will explore in this section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理我们API的各种成本范围，使用枚举器（或**enum**）来表示各种值并处理到和从字符串表示的转换是有意义的。Go并没有明确提供枚举器，但有一种巧妙的实现方法，我们将在本节中探讨。
- en: 'A simple flexible checklist for writing enumerators in Go is:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Go中编写枚举器的一个简单灵活的检查表是：
- en: Define a new type, based on a primitive integer type
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个基于原始整数类型的新类型
- en: Use that type whenever you need users to specify one of the appropriate values
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要用户指定适当值之一时使用该类型
- en: Use the `iota` keyword to set the values in a `const` block, disregarding the
    first zero value
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`iota`关键字在`const`块中设置值，忽略第一个零值
- en: Implement a map of sensible string representations to the values of your enumerator
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个合理的字符串表示到枚举器值的映射
- en: Implement a `String` method on the type that returns the appropriate string
    representation from the map
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型上实现一个`String`方法，从映射中返回适当的字符串表示
- en: Implement a `ParseType` function that converts from a string to your type using
    the map
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个`ParseType`函数，使用映射从字符串转换为您的类型
- en: 'Now we will write an enumerator to represent the cost levels in our API. Create
    a new file called `cost_level.go` inside the `meander` folder and add the following
    code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个枚举器来表示我们API中的成本级别。在`meander`文件夹中创建一个名为`cost_level.go`的新文件，并添加以下代码：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we define the type of our enumerator, which we have called `Cost` , and
    since we only need to represent a few values, we have based it on an `int8` range.
    For enumerators where we need larger values, you are free to use any of the integer
    types that work with `iota` . The `Cost` type is now a real type in its own right,
    and we can use it wherever we need to represent one of the supported values—for
    example, we can specify a `Cost` type as an argument in functions, or use it as
    the type for a field in a struct.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了我们的枚举器的类型，我们称之为`Cost`，由于我们只需要表示一些值，所以我们基于`int8`范围进行了定义。对于我们需要更大值的枚举器，您可以自由地使用任何与`iota`一起使用的整数类型。`Cost`类型现在是一个真正的类型，我们可以在需要表示支持的值之一的地方使用它，例如，我们可以在函数的参数中指定`Cost`类型，或者将其用作结构中字段的类型。
- en: We then define a list of constants of that type, and use the `iota` keyword
    to indicate that we want incrementing values for the constants. By disregarding
    the first `iota` value (which is always zero), we indicate that one of the specified
    constants must be explicitly used, rather than the zero value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了该类型的常量列表，并使用`iota`关键字指示我们希望为常量获得递增的值。通过忽略第一个`iota`值（始终为零），我们指示必须显式使用指定的常量之一，而不是零值。
- en: To provide a string representation of our enumerator, we need only add a `String`
    method to the `Cost` type. This is a useful exercise even if you don't need to
    use the strings in your code, because whenever you use the print calls from the
    Go standard library (such as `fmt.Println` ), the numerical values will be used
    by default. Often those values are meaningless and will require you to look them
    up, and even count the lines to determine the numerical value for each item.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供我们的枚举器的字符串表示，我们只需要为`Cost`类型添加一个`String`方法。即使您不需要在代码中使用字符串，这也是一个有用的练习，因为每当您使用Go标准库的打印调用（如`fmt.Println`）时，默认情况下将使用数字值。这些值通常是没有意义的，并且需要您查找它们，甚至计算每个项目的数值。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the `String()` method in Go, see the `Stringer` and
    `GoStringer` interfaces in the `fmt` package at [http://golang.org/pkg/fmt/#Stringer](http://golang.org/pkg/fmt/#Stringer)
    .
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Go中`String()`方法的更多信息，请参阅`fmt`包中的`Stringer`和`GoStringer`接口，网址为[http://golang.org/pkg/fmt/#Stringer](http://golang.org/pkg/fmt/#Stringer)。
- en: Test-driven enumerator
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试驱动的枚举器
- en: To be sure that our enumerator code is working correctly, we are going to write
    unit tests that make some assertions about expected behavior.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的枚举器代码正常工作，我们将编写单元测试，对预期行为进行一些断言。
- en: 'Alongside `cost_level.go` , add a new file called `cost_level_test.go` , and
    add the following unit test:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cost_level.go`旁边，添加一个名为`cost_level_test.go`的新文件，并添加以下单元测试：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will need to run `go get` to get the CheekyBits' `is` package (from [github.com/cheekybits/is](http://github.com/cheekybits/is)
    ).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要运行`go get`来获取CheekyBits的`is`包（从[github.com/cheekybits/is](http://github.com/cheekybits/is)）。
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `is` package is an alternative testing helper package, but this one is ultra-simple
    and deliberately bare-bones. You get to pick your favorite when you write your
    own projects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`包是一个替代测试助手包，但这个包非常简单，故意是最基本的。在编写自己的项目时，您可以选择自己喜欢的包。'
- en: Normally, we wouldn't worry about the actual integer value of constants in our
    enumerator, but since the Google Places API uses numerical values to represent
    the same thing, we need to care about the values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会担心枚举中常量的实际整数值，但由于Google Places API使用数字值来表示相同的事物，我们需要关心这些值。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might have noticed something strange about this test file that breaks from
    convention. Although it is inside the `meander` folder, it is not a part of the
    `meander` package; rather it's in `meander_test` .
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到这个测试文件与传统不同之处。虽然它在`meander`文件夹中，但它不是`meander`包的一部分；而是在`meander_test`中。
- en: In Go, this is an error in every case except for tests. Because we are putting
    our test code into its own package, it means that we no longer have access to
    the internals of the `meander` package—notice how we have to use the package prefix.
    This may seem like a disadvantage, but in fact it allows us to be sure that we
    are testing the package as though we were a real user of it. We may only call
    exported methods and only have visibility into exported types; just like our users.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，这在除了测试之外的每种情况下都是错误的。因为我们将测试代码放入自己的包中，这意味着我们不再可以访问`meander`包的内部-请注意我们必须使用包前缀。这可能看起来像一个缺点，但实际上它允许我们确保我们测试包时就像我们是真正的用户一样。我们只能调用导出的方法，并且只能看到导出的类型；就像我们的用户一样。
- en: Run the tests by running `go test` in a terminal, and notice that it passes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端中运行`go test`来运行测试，并注意它是否通过。
- en: 'Let''s add another test to make assertions about the string representations
    for each `Cost` constant. In `cost_level_test.go` , add the following unit test:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个测试，对每个`Cost`常量的字符串表示进行断言。在`cost_level_test.go`中，添加以下单元测试：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This test asserts that calling the `String` method for each constant yields
    the expected value. Running these tests will of course fail, because we haven't
    yet implemented the `String` method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试断言调用每个常量的`String`方法会产生预期的值。当然，运行这些测试会失败，因为我们还没有实现`String`方法。
- en: 'Underneath the `Cost` constants, add the following map and the `String` method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cost`常量下面，添加以下映射和`String`方法：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `map[string]Cost` variable maps the cost values to the string representation,
    and the `String` method iterates over the map to return the appropriate value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`map[string]Cost`变量将成本值映射到字符串表示形式，`String`方法遍历映射以返回适当的值。'
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In our case, a simple return `strings.Repeat("$", int(l))` would work just as
    well (and wins because it's simpler code), but it often won't, therefore this
    section explores the general approach.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，一个简单的返回`strings.Repeat("$", int(l))`也可以很好地工作（并且因为它是更简单的代码而胜出），但通常不会，因此本节探讨了一般方法。
- en: Now if we were to print out the `Cost3` value, we would actually see `$$$` ,
    which is much more useful than numerical vales. However, since we do want to use
    these strings in our API, we are also going to add a `ParseCost` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们要打印`Cost3`的值，我们实际上会看到`$$$`，这比数字值更有用。然而，由于我们确实想在API中使用这些字符串，我们还将添加一个`ParseCost`方法。
- en: 'In `cost_value_test.go` , add the following unit test:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cost_value_test.go`中，添加以下单元测试：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we assert that calling `ParseCost` will in fact yield the appropriate value
    depending on the input string.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们断言调用`ParseCost`实际上会根据输入字符串产生适当的值。
- en: 'In `cost_value.go` , add the following implementation code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cost_value.go`中，添加以下实现代码：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Parsing a `Cost` string is very simple since this is how our map is laid out.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 解析`Cost`字符串非常简单，因为这就是我们的映射布局。
- en: 'As we need to represent a range of cost values, let''s imagine a `CostRange`
    type, and write the tests out for how we intend to use it. Add the following tests
    to `cost_value_test.go` :'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要表示一系列成本值，让我们想象一个`CostRange`类型，并为我们打算如何使用它编写测试。将以下测试添加到`cost_value_test.go`中：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We specify that passing in a string with two dollar characters first, followed
    by three dots and then three dollar characters should create a new `meander.CostRange`
    type that has `From` set to `meander.Cost2` , and `To` set to `meander.Cost3`
    . The second test does the reverse by testing that the `CostRange.String` method
    returns the appropriate value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定传入一个以两个美元符号开头的字符串，然后是三个点，然后是三个美元符号，应该创建一个新的`meander.CostRange`类型，其中`From`设置为`meander.Cost2`，`To`设置为`meander.Cost3`。第二个测试通过测试`CostRange.String`方法返回适当的值来执行相反的操作。
- en: 'To make our tests pass, add the following `CostRange` type and associated `String`
    and `ParseString` functions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的测试通过，添加以下`CostRange`类型和相关的`String`和`ParseString`函数：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This allows us to convert a string such as `$...$$$$$` to a structure that contains
    two `Cost` values; a `From` and `To` set and vice versa.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够将诸如`$...$$$$$`之类的字符串转换为包含两个`Cost`值的结构；`From`和`To`设置，反之亦然。
- en: Querying the Google Places API
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询Google Places API
- en: 'Now that we are capable of representing the results of the API, we need a way
    to represent and initiate the actual query. Add the following structure to `query.go`
    :'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够表示API的结果，我们需要一种方法来表示和初始化实际查询。将以下结构添加到`query.go`中：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This structure contains all the information we will need to build up the query,
    all of which will actually come from the URL parameters in the requests from the
    client. Next, add the following `find` method, which will be responsible for making
    the actual request to Google''s servers:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构包含了我们构建查询所需的所有信息，所有这些信息实际上都来自客户端请求的URL参数。接下来，添加以下`find`方法，它将负责向Google的服务器发出实际请求：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First we build the request URL as per the Google Places API specification, by
    appending the `url.Values` encoded string of the data for `lat` , `lng` , `radius`
    , and of course the `APIKey` values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们按照Google Places API规范构建请求URL，通过附加`url.Values`编码的`lat`、`lng`、`radius`和`APIKey`值的数据字符串。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `url.Values` type is actually a `map[string][]string` type, which is why
    we use `make` rather than `new` .
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`url.Values`类型实际上是`map[string][]string`类型，这就是为什么我们使用`make`而不是`new`。'
- en: The `types` value we specify as an argument represents the kind of business
    to look for. If there is a `CostRangeStr` , we parse it and set the `minprice`
    and `maxprice` values, before finally calling `http.Get` to actually make the
    request. If the request is successful, we defer the closing of the response body
    and use a `json.Decoder` method to decode the JSON that comes back from the API
    into our `googleResponse` type.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定的`types`值作为参数表示要查找的业务类型。如果有`CostRangeStr`，我们解析它并设置`minprice`和`maxprice`值，最后调用`http.Get`来实际发出请求。如果请求成功，我们推迟关闭响应主体，并使用`json.Decoder`方法将从API返回的JSON解码为我们的`googleResponse`类型。
- en: Building recommendations
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立推荐
- en: 'Next we need to write a method that will allow us to make many calls to find,
    for the different steps in a journey. Underneath the `find` method, add the following
    `Run` method to the `Query` struct:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一个方法，允许我们对不同旅程步骤进行多次调用。在`find`方法下面，添加以下`Run`方法到`Query`结构：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first thing we do is set the random seed to the current time in nanoseconds
    past since January 1, 1970 UTC. This ensures that every time we call the `Run`
    method and use the `rand` package, the results will be different. If we didn't
    do this, our code would suggest the same recommendations every time, which defeats
    the object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将随机种子设置为自1970年1月1日UTC以来的纳秒时间。这确保每次我们调用`Run`方法并使用`rand`包时，结果都会不同。如果我们不这样做，我们的代码将每次都建议相同的推荐，这就失去了意义。
- en: Since we need to make many requests to Google—and since we want to make sure
    this is as quick as possible—we are going to run all the queries at the same time
    by making concurrent calls to our `Query.find` method. So we next create a `sync.WaitGroup`
    method, and a map to hold the selected places along with a `sync.Mutex` method
    to allow many go routines to access the map concurrently.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要向Google发出许多请求，并且希望尽快完成，我们将通过并发调用我们的`Query.find`方法同时运行所有查询。因此，我们接下来创建一个`sync.WaitGroup`方法，并创建一个地图来保存选定的地点以及一个`sync.Mutex`方法，以允许许多go例程同时访问地图。
- en: We then iterate over each item in the `Journey` slice, which might be `bar`
    , `cafe` , `movie_theater` . For each item, we add `1` to the `WaitGroup` object,
    and call a goroutine. Inside the routine, we first defer the `w.Done` call informing
    the `WaitGroup` object that this request has completed, before calling our `find`
    method to make the actual request. Assuming no errors occurred, and it was indeed
    able to find some places, we iterate over the results and build up a usable URL
    for any photos that might be present. According to the Google Places API, we are
    given a `photoreference` key, which we can use in another API call to get the
    actual image. To save our clients from having to have knowledge of the Google
    Places API at all, we build the complete URL for them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们迭代`Journey`切片中的每个项目，可能是`bar`、`cafe`、`movie_theater`。对于每个项目，我们向`WaitGroup`对象添加`1`，并调用一个goroutine。在例程内部，我们首先推迟`w.Done`调用，通知`WaitGroup`对象该请求已完成，然后调用我们的`find`方法进行实际请求。假设没有发生错误，并且确实能够找到一些地方，我们会遍历结果并构建出可用于任何可能存在的照片的URL。根据Google
    Places API，我们会得到一个`photoreference`键，我们可以在另一个API调用中使用它来获取实际的图像。为了使我们的客户不必完全了解Google
    Places API，我们为他们构建完整的URL。
- en: We then lock the map locker and with a call to `rand.Intn` , pick one of the
    options at random and insert it into the right position in the `places` slice,
    before unlocking the `sync.Mutex` method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们锁定地图锁，并通过调用`rand.Intn`随机选择其中一个选项，并将其插入到`places`切片的正确位置，然后解锁`sync.Mutex`方法。
- en: Finally, we wait for all goroutines to complete with a call to `w.Wait` , before
    returning the places.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们等待所有goroutine完成，通过调用`w.Wait`，然后返回地点。
- en: Handlers that use query parameters
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用查询参数的处理程序
- en: 'Now we need to wire up our `/recommendations` call, so head back to `main.go`
    in the `cmd` folder, and add the following code inside the `main` function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要连接我们的`/recommendations`调用，因此返回`cmd`文件夹中的`main.go`，并在`main`函数内添加以下代码：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This handler is responsible for preparing the `meander.Query` object and calling
    its `Run` method, before responding with the results. The `http.Request` type's
    URL value exposes the `Query` data that provides a `Get` method that, in turn,
    looks up a value for a given key.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序负责准备`meander.Query`对象并调用其`Run`方法，然后用结果进行响应。`http.Request`类型的URL值公开了提供`Get`方法的`Query`数据，该方法反过来查找给定键的值。
- en: The journey string is translated from the `bar|cafe|movie_theater` format to
    a slice of strings, by splitting on the pipe character. Then a few calls to functions
    in the `strconv` package turn the string latitude, longitude, and radius values
    into numerical types.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 旅程字符串是从`bar|cafe|movie_theater`格式转换为字符串切片，通过在管道字符上进行分割。然后，对`strconv`包中的函数进行几次调用，将字符串纬度、经度和半径值转换为数值类型。
- en: CORS
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CORS
- en: The final piece of the first version of our API will be to implement CORS as
    we did in the previous chapter. See if you can solve this problem yourself before
    reading on to the solution in the next section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API第一个版本的最后一部分将是实现CORS，就像我们在上一章中所做的那样。在阅读下一节中的解决方案之前，看看你能否自己解决这个问题。
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are going to tackle this yourself, remember that your aim is to set the
    `Access-Control-Allow-Origin` response header to `*` . Also consider the `http.HandlerFunc`
    wrapping we did in the previous chapter. The best place for this code is probably
    in the `cmd` program, since that is what exposes the functionality through an
    HTTP endpoint.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要自己解决这个问题，请记住，您的目标是将`Access-Control-Allow-Origin`响应标头设置为`*`。还考虑我们在上一章中所做的`http.HandlerFunc`包装。这段代码的最佳位置可能是在`cmd`程序中，因为它通过HTTP端点公开了功能。
- en: 'In `main.go` , add the following `cors` function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.go`中，添加以下`cors`函数：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This familiar pattern takes in an `http.HandlerFunc` type and returns a new
    one that sets the appropriate header before calling the passed-in function. Now
    we can modify our code to make sure the `cors` function gets called for both of
    our endpoints. Update the appropriate lines in the `main` function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种熟悉的模式接受一个`http.HandlerFunc`类型，并返回一个在调用传入的函数之前设置适当标头的新函数。现在我们可以修改我们的代码，以确保`cors`函数被调用我们的两个端点。更新`main`函数中的适当行：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now calls to our API will be allowed from any domain without a cross-origin
    error occurring.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对我们的API的调用将允许来自任何域的调用，而不会发生跨域错误。
- en: Testing our API
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的API
- en: Now that we are ready to test our API, head to a console and navigate to the
    `cmd` folder. Because our program imports the `meander` package, building the
    program will automatically build our `meander` package too.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备测试我们的API，前往控制台并导航到`cmd`文件夹。因为我们的程序导入了`meander`包，构建程序将自动构建我们的`meander`包。
- en: 'Build and run the program:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行程序：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To see meaningful results from our API, let's take a minute to find your actual
    latitude and longitude. Head over to [http://mygeoposition.com/](http://mygeoposition.com/)
    and use the web tools to get the `x,y` values for a location you are familiar
    with.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的API中看到有意义的结果，让我们花一分钟找到您实际的纬度和经度。转到[http://mygeoposition.com/](http://mygeoposition.com/)并使用Web工具获取您熟悉的位置的`x,y`值。
- en: 'Or pick from these popular cities:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或者从这些热门城市中选择：
- en: 'London, England: `51.520707 x 0.153809`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英格兰伦敦：`51.520707 x 0.153809`
- en: 'New York, USA: `40.7127840 x -74.0059410`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美国纽约：`40.7127840 x -74.0059410`
- en: 'Tokyo, Japan: `35.6894870 x 139.6917060`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日本东京：`35.6894870 x 139.6917060`
- en: 'San Francisco, USA: `37.7749290 x -122.4194160`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美国旧金山：`37.7749290 x -122.4194160`
- en: 'Now open a web browser and access the `/recommendations` endpoint with some
    appropriate values for the fields:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开一个Web浏览器，并使用一些适当的值访问`/recommendations`端点：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following screenshot shows what a sample recommendation around London might
    look like:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了伦敦周围的一个示例推荐的样子：
- en: '![Testing our API](img/Image00013.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的API](img/Image00013.jpg)'
- en: Feel free to play around with the values in the URL to see how powerful the
    simple API is by trying various journey strings, tweaking the locations, and trying
    different cost range value strings.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随意在URL中玩弄值，尝试不同的旅程字符串，调整位置，并尝试不同的成本范围值字符串，以查看简单API的强大之处。
- en: Web application
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web应用程序
- en: We are going to download a complete web application built to the same API specifications,
    and point it at our implementation to see it come to life before our eyes. Head
    over to [https://github.com/matryer/goblueprints/tree/master/chapter7/meanderweb](https://github.com/matryer/goblueprints/tree/master/chapter7/meanderweb)
    and download the `meanderweb` project into your `GOPATH` .
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将下载一个完整的Web应用程序，该应用程序构建到相同的API规范，并将其指向我们的实现，以便在我们眼前看到它变得生动。转到[https://github.com/matryer/goblueprints/tree/master/chapter7/meanderweb](https://github.com/matryer/goblueprints/tree/master/chapter7/meanderweb)并将`meanderweb`项目下载到您的`GOPATH`中。
- en: 'In a terminal, navigate to the `meanderweb` folder, and build and run it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，导航到`meanderweb`文件夹，并构建和运行它：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will start a website running on `localhost:8081` , which is hardcoded to
    look for the API running at `localhost:8080` . Because we added the CORS support,
    this won't be a problem despite them running on different domains.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个在`localhost:8081`上运行的网站，它被硬编码为查找在`localhost:8080`上运行的API。因为我们添加了CORS支持，尽管它们在不同的域上运行，这不会成为问题。
- en: Open a browser to `http://localhost:8081/` and interact with the application,
    while somebody else built the UI it would be pretty useless without the API that
    we built powering it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器，访问`http://localhost:8081/`并与应用程序交互，虽然其他人构建了UI，但没有我们构建的API支持它将会非常无用。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built an API that consumes and abstracts the Google Places
    API to provide a fun and interesting way of letting users plan their days and
    evenings.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个API，它消耗和抽象了Google Places API，以提供一个有趣而有趣的方式让用户规划他们的白天和夜晚。
- en: We started by writing some simple and short user stories that described at a
    really high level what we wanted to achieve, without trying to design the implementation
    up front. In order to parallelize the project, we agreed the meeting point of
    the project as the API design, and we built towards it (as would our partners).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始写一些简单而简短的用户故事，以高层次描述我们想要实现的目标，而不是试图提前设计实现。为了并行化项目，我们同意将项目的会议点作为API设计，并朝着这个目标构建（就像我们的合作伙伴一样）。
- en: We embedded data directly in code, avoiding the need to investigate, design,
    and implement a data store in the early stages of a project. By caring instead
    about how that data is accessed (via the API endpoint), we allowed our future
    selves to completely change how and where the data is stored, without breaking
    any apps that have been written to our API.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接在代码中嵌入数据，避免在项目的早期阶段进行数据存储的调查、设计和实施。我们关心的是数据如何被访问（通过API端点），这样我们就可以完全改变数据存储的方式和位置，而不会影响到已经编写为我们的API的应用程序。
- en: We implemented the `Facade` interface, which allows our structs and other types
    to provide public representations of them, without revealing messy or sensitive
    details about our implementation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了`Facade`接口，允许我们的结构体和其他类型提供它们的公共表示，而不会透露关于我们实现的混乱或敏感细节。
- en: Our foray into enumerators gave us a useful starting point to build enumerated
    types, even though there is no official support for them in the language. The
    `iota` keyword that we used lets us specify constants of our own numerical type,
    with incrementing values. The common `String` method that we implemented showed
    us how to make sure our enumerated types don't become obscure numbers in our logs.
    At the same time, we also saw a real-world example of TDD, and red/green programming
    where we wrote unit tests that first fail, but which we then go on to make pass
    by writing the implementation code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对枚举器的探索为我们提供了一个有用的起点，用于构建枚举类型，尽管语言中没有官方支持。我们使用的`iota`关键字让我们能够指定我们自己的数值类型的常量，并递增值。我们实现的常见`String`方法向我们展示了如何确保我们的枚举类型不会成为日志中的晦涩数字。与此同时，我们还看到了TDD的一个现实例子，以及红/绿编程，我们首先编写会失败的单元测试，然后通过编写实现代码使其通过。
- en: 读累了记得休息一会哦~
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
