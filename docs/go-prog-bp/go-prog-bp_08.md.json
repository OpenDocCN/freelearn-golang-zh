["```go\n/backup - package\n/backup/cmds/backup \u2013 user interaction tool\n/backup/cmds/backupd \u2013 worker daemon\n```", "```go\npackage backup\n\ntype Archiver interface {\n  Archive(src, dest string) error\n}\n```", "```go\ntype zipper struct{}\n```", "```go\n// Zip is an Archiver that zips and unzips files.\nvar ZIP Archiver = (*zipper)(nil)\n```", "```go\n\n./archiver.go:10: cannot use (*zipper)(nil) (type *zipper) as type Archiver in assignment:\n\n *zipper does not implement Archiver (missing Archive method)\n\n```", "```go\nvar _ Interface = (*Implementation)(nil)\n```", "```go\nfunc (z *zipper) Archive(src, dest string) error {\n  if err := os.MkdirAll(filepath.Dir(dest), 0777); err != nil {\n    return err\n  }\n  out, err := os.Create(dest)\n  if err != nil {\n    return err\n  }\n  defer out.Close()\n  w := zip.NewWriter(out)\n  defer w.Close()\n  return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {\n    if info.IsDir() {\n      return nil // skip\n    }\n    if err != nil {\n      return err\n    }\n    in, err := os.Open(path)\n    if err != nil {\n      return err\n    }\n    defer in.Close()\n    f, err := w.Create(path)\n    if err != nil {\n      return err\n    }\n    io.Copy(f, in)\n    return nil\n  })\n}\n```", "```go\ntype FileInfo interface {\n  Name() string       // base name of the file\n  Size() int64        // length in bytes for regular files; \n                         system-dependent for others\n  Mode() FileMode     // file mode bits\n  ModTime() time.Time // modification time\n  IsDir() bool        // abbreviation for Mode().IsDir()\n  Sys() interface{}   // underlying data source (can return nil)\n}\n```", "```go\npackage backup\nimport (\n  \"crypto/md5\"\n  \"fmt\"\n  \"io\"\n  \"os\"\n  \"path/filepath\"\n)\nfunc DirHash(path string) (string, error) {\n  hash := md5.New()\n  err := filepath.Walk(path, func(path string, info os.FileInfo, err error) error {\n    if err != nil {\n      return err\n    }\n    io.WriteString(hash, path)\n    fmt.Fprintf(hash, \"%v\", info.IsDir())\n    fmt.Fprintf(hash, \"%v\", info.ModTime())\n    fmt.Fprintf(hash, \"%v\", info.Mode())\n    fmt.Fprintf(hash, \"%v\", info.Name())\n    fmt.Fprintf(hash, \"%v\", info.Size())\n    return nil\n  })\n  if err != nil {\n    return \"\", err\n  }\n  return fmt.Sprintf(\"%x\", hash.Sum(nil)), nil\n}\n```", "```go\ntype Monitor struct {\n  Paths       map[string]string\n  Archiver    Archiver\n  Destination string\n}\n```", "```go\nfunc (m *Monitor) Now() (int, error) {\n  var counter int\n  for path, lastHash := range m.Paths {\n    newHash, err := DirHash(path)\n    if err != nil {\n      return 0, err\n    }\n    if newHash != lastHash {\n      err := m.act(path)\n      if err != nil {\n        return counter, err\n      }\n      m.Paths[path] = newHash // update the hash\n      counter++\n    }\n  }\n  return counter, nil\n}\n```", "```go\nm.act undefined (type *Monitor has no field or method act)\n```", "```go\nfunc (m *Monitor) act(path string) error {\n  dirname := filepath.Base(path)\n  filename := fmt.Sprintf(\"%d.zip\", time.Now().UnixNano())\n  return m.Archiver.Archive(path, filepath.Join(m.Destination, dirname, filename))\n}\n```", "```go\ntype Archiver interface {\n\nDestFmt() string\n\n  Archive(src, dest string) error\n}\n```", "```go\nfunc (z *zipper) DestFmt() string {\n  return \"%d.zip\"\n}\n```", "```go\nfunc (m *Monitor) act(path string) error {\n  dirname := filepath.Base(path)\n  filename := fmt.Sprintf(m.Archiver.DestFmt(), time.Now().UnixNano())\n  return m.Archiver.Archive(path, filepath.Join(m.Destination, dirname, filename))\n}\n```", "```go\nfunc main() {\n  var fatalErr error\n  defer func() {\n    if fatalErr != nil {\n      flag.PrintDefaults()\n      log.Fatalln(fatalErr)\n    }\n  }()\n  var (\n    dbpath = flag.String(\"db\", \"./backupdata\", \"path to database directory\")\n  )\n  flag.Parse()\n  args := flag.Args()\n  if len(args) < 1 {\n    fatalErr = errors.New(\"invalid usage; must specify command\")\n    return\n  }\n}\n```", "```go\ndb, err := filedb.Dial(*dbpath)\nif err != nil {\n  fatalErr = err\n  return\n}\ndefer db.Close()\ncol, err := db.C(\"paths\")\nif err != nil {\n  fatalErr = err\n  return\n}\n```", "```go\ntype path struct {\n  Path string\n  Hash string\n}\n```", "```go\n\n    backup -db=/path/to/db add {path} [paths...]\n\n    ```", "```go\n\n    backup -db=/path/to/db remove {path} [paths...]\n\n    ```", "```go\n\n    backup -db=/path/to/db list\n\n    ```", "```go\nswitch strings.ToLower(args[0]) {\ncase \"list\":\ncase \"add\":\ncase \"remove\":\n}\n```", "```go\nvar path path\ncol.ForEach(func(i int, data []byte) bool {\n  err := json.Unmarshal(data, &path)\n  if err != nil {\n    fatalErr = err\n    return false\n  }\n  fmt.Printf(\"= %s\\n\", path)\n  return false\n})\n```", "```go\nfunc (p path) String() string {\n  return fmt.Sprintf(\"%s [%s]\", p.Path, p.Hash)\n}\n```", "```go\nif len(args[1:]) == 0 {\n  fatalErr = errors.New(\"must specify path to add\")\n  return\n}\nfor _, p := range args[1:] {\n  path := &path{Path: p, Hash: \"Not yet archived\"}\n  if err := col.InsertJSON(path); err != nil {\n    fatalErr = err\n    return\n  }\n  fmt.Printf(\"+ %s\\n\", path)\n}\n```", "```go\nvar path path\ncol.RemoveEach(func(i int, data []byte) (bool, bool) {\n  err := json.Unmarshal(data, &path)\n  if err != nil {\n    fatalErr = err\n    return false, true\n  }\n  for _, p := range args[1:] {\n    if path.Path == p {\n      fmt.Printf(\"- %s\\n\", path)\n      return true, false\n    }\n  }\n  return false, false\n})\n```", "```go\n\ngo build -o backup\n\n```", "```go\n\n./backup -db=./backupdata add ./test ./test2\n\n```", "```go\n\n+ ./test [Not yet archived]\n\n+ ./test2 [Not yet archived]\n\n```", "```go\n\n./backup -db=./backupdata add ./test3\n\n```", "```go\n\n./backup -db=./backupdata list\n\n```", "```go\n\n= ./test [Not yet archived]\n\n= ./test2 [Not yet archived]\n\n= ./test3 [Not yet archived]\n\n```", "```go\n\n./backup -db=./backupdata remove ./test3\n\n./backup -db=./backupdata list\n\n```", "```go\n\n+ ./test [Not yet archived]\n\n+ ./test2 [Not yet archived]\n\n```", "```go\nfunc main() {\n  var fatalErr error\n  defer func() {\n    if fatalErr != nil {\n      log.Fatalln(fatalErr)\n    }\n  }()\n  var (\n    interval = flag.Int(\"interval\", 10, \"interval between checks (seconds)\")\n    archive  = flag.String(\"archive\", \"archive\", \"path to archive location\")\n    dbpath   = flag.String(\"db\", \"./db\", \"path to filedb database\")\n  )\n  flag.Parse()\n}\n```", "```go\nm := &backup.Monitor{\n  Destination: *archive,\n  Archiver:    backup.ZIP,\n  Paths:       make(map[string]string),\n}\n```", "```go\ndb, err := filedb.Dial(*dbpath)\nif err != nil {\n  fatalErr = err\n  return\n}\ndefer db.Close()\ncol, err := db.C(\"paths\")\nif err != nil {\n  fatalErr = err\n  return\n}\n```", "```go\ntype path struct {\n  Path string\n  Hash string\n}\n```", "```go\nvar path path\ncol.ForEach(func(_ int, data []byte) bool {\n  if err := json.Unmarshal(data, &path); err != nil {\n    fatalErr = err\n    return true\n  }\n  m.Paths[path.Path] = path.Hash\n  return false // carry on\n})\nif fatalErr != nil {\n  return\n}\nif len(m.Paths) < 1 {\n  fatalErr = errors.New(\"no paths - use backup tool to add at least one\")\n  return\n}\n```", "```go\nfor {}\n```", "```go\ncheck(m, col)\nsignalChan := make(chan os.Signal, 1)\nsignal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)\nfor {\n  select {\n  case <-time.After(time.Duration(*interval) * time.Second):\n    check(m, col)\n  case <-signalChan:\n    // stop\n    fmt.Println()\n    log.Printf(\"Stopping...\")\n    goto stop\n  }\n}\nstop:\n```", "```go\nfunc check(m *backup.Monitor, col *filedb.C) {\n  log.Println(\"Checking...\")\n  counter, err := m.Now()\n  if err != nil {\n    log.Fatalln(\"failed to backup:\", err)\n  }\n  if counter > 0 {\n    log.Printf(\"  Archived %d directories\\n\", counter)\n    // update hashes\n    var path path\n    col.SelectEach(func(_ int, data []byte) (bool, []byte, bool) {\n      if err := json.Unmarshal(data, &path); err != nil {\n        log.Println(\"failed to unmarshal data (skipping):\", err)\n        return true, data, false\n      }\n      path.Hash, _ = m.Paths[path.Path]\n      newdata, err := json.Marshal(&path)\n      if err != nil {\n        log.Println(\"failed to marshal data (skipping):\", err)\n        return true, data, false\n      }\n      return true, newdata, false\n    })\n  } else {\n    log.Println(\"  No changes\")\n  }\n}\n```", "```go\n\n./backup -db=\"./backupdata\" list\n\n```", "```go\n\n= ./test [Not yet archived]\n\n= ./test2 [Not yet archived]\n\n```", "```go\n\ngo build -o backupd\n\n```", "```go\n\n./backupd -db=\"../backup/backupdata/\" -archive=\"./archive\" -interval=5\n\n```", "```go\n\nChecking...\n\nArchived 2 directories\n\n```", "```go\n\nChecking...\n\n No changes\n\nChecking...\n\n No changes\n\n```"]