["```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\ntype Reader interface {\n        Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n        Write(p []byte) (n int, err error)\n}\n```", "```go\ntype Seeker interface {\n        Seek(offset int64, whence int) (int64, error)\n}\n\ntype ReadSeeker interface {\n        Reader\n        Seeker\n}\n```", "```go\nfunc Pipe() (*PipeReader, *PipeWriter)\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter1/interfaces \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter1/interfaces    \n```", "```go\n        package interfaces\n\n        import (\n                \"fmt\"\n                \"io\"\n                \"os\"\n        )\n\n        // Copy copies data from in to out first directly,\n        // then using a buffer. It also writes to stdout\n        func Copy(in io.ReadSeeker, out io.Writer) error {\n                // we write to out, but also Stdout\n                w := io.MultiWriter(out, os.Stdout)\n\n                // a standard copy, this can be dangerous if there's a \n                // lot of data in in\n                if _, err := io.Copy(w, in); err != nil {\n                    return err\n                }\n\n                in.Seek(0, 0)\n\n                // buffered write using 64 byte chunks\n                buf := make([]byte, 64)\n                if _, err := io.CopyBuffer(w, in, buf); err != nil {\n                    return err\n                }\n\n                // lets print a new line\n                fmt.Println()\n\n                return nil\n        }\n```", "```go\n        package interfaces\n\n        import (\n                \"io\"\n                \"os\"\n        )\n\n        // PipeExample helps give some more examples of using io  \n        //interfaces\n        func PipeExample() error {\n                // the pipe reader and pipe writer implement\n                // io.Reader and io.Writer\n                r, w := io.Pipe()\n\n                // this needs to be run in a separate go routine\n                // as it will block waiting for the reader\n                // close at the end for cleanup\n                go func() {\n                    // for now we'll write something basic,\n                    // this could also be used to encode json\n                    // base64 encode, etc.\n                    w.Write([]byte(\"test\\n\"))\n                    w.Close()\n                }()\n\n                if _, err := io.Copy(os.Stdout, r); err != nil {\n                    return err\n                }\n                return nil\n        }\n```", "```go\n        package main\n\n        import (\n             \"bytes\"\n             \"fmt\"\n\n             \"github.com/PacktPublishing/\n              Go-Programming-Cookbook-Second-Edition/\n              chapter1/bytestrings\"\n        )\n\n        func main() {\n                in := bytes.NewReader([]byte(\"example\"))\n                out := &bytes.Buffer{}\n                fmt.Print(\"stdout on Copy = \")\n                if err := interfaces.Copy(in, out); err != nil {\n                        panic(err)\n                }\n\n                fmt.Println(\"out bytes buffer =\", out.String())\n\n                fmt.Print(\"stdout on PipeExample = \")\n                if err := interfaces.PipeExample(); err != nil {\n                        panic(err)\n                }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run .\nstdout on Copy = exampleexample\nout bytes buffer = exampleexample\nstdout on PipeExample = test\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter1/bytestrings \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter1/bytestrings    \n```", "```go\n        package bytestrings\n\n        import (\n                \"bytes\"\n                \"io\"\n                \"io/ioutil\"\n        )\n\n        // Buffer demonstrates some tricks for initializing bytes    \n        //Buffers\n        // These buffers implement an io.Reader interface\n        func Buffer(rawString string) *bytes.Buffer {\n\n                // we'll start with a string encoded into raw bytes\n                rawBytes := []byte(rawString)\n\n                // there are a number of ways to create a buffer from \n                // the raw bytes or from the original string\n                var b = new(bytes.Buffer)\n                b.Write(rawBytes)\n\n                // alternatively\n                b = bytes.NewBuffer(rawBytes)\n\n                // and avoiding the initial byte array altogether\n                b = bytes.NewBufferString(rawString)\n\n                return b\n        }\n\n        // ToString is an example of taking an io.Reader and consuming \n        // it all, then returning a string\n        func toString(r io.Reader) (string, error) {\n                b, err := ioutil.ReadAll(r)\n                if err != nil {\n                    return \"\", err\n                }\n                return string(b), nil\n        }\n```", "```go\n        package bytestrings\n\n        import (\n                \"bufio\"\n                \"bytes\"\n                \"fmt\"\n        )\n\n        // WorkWithBuffer will make use of the buffer created by the\n        // Buffer function\n        func WorkWithBuffer() error {\n                rawString := \"it's easy to encode unicode into a byte \n                              array\"\n\n                b := Buffer(rawString)\n\n                // we can quickly convert a buffer back into byes with\n                // b.Bytes() or a string with b.String()\n                fmt.Println(b.String())\n\n                // because this is an io Reader we can make use of  \n                // generic io reader functions such as\n                s, err := toString(b)\n                if err != nil {\n                    return err\n                }\n                fmt.Println(s)\n\n                // we can also take our bytes and create a bytes reader\n                // these readers implement io.Reader, io.ReaderAt, \n                // io.WriterTo, io.Seeker, io.ByteScanner, and \n                // io.RuneScanner interfaces\n                reader := bytes.NewReader([]byte(rawString))\n\n                // we can also plug it into a scanner that allows \n                // buffered reading and tokenzation\n                scanner := bufio.NewScanner(reader)\n                scanner.Split(bufio.ScanWords)\n\n                // iterate over all of the scan events\n                for scanner.Scan() {\n                    fmt.Print(scanner.Text())\n                }\n\n                return nil\n        }\n```", "```go\n        package bytestrings\n\n        import (\n                \"fmt\"\n                \"io\"\n                \"os\"\n                \"strings\"\n        )\n\n        // SearchString shows a number of methods\n        // for searching a string\n        func SearchString() {\n                s := \"this is a test\"\n\n                // returns true because s contains\n                // the word this\n                fmt.Println(strings.Contains(s, \"this\"))\n\n                // returns true because s contains the letter a\n                // would also match if it contained b or c\n                fmt.Println(strings.ContainsAny(s, \"abc\"))\n\n                // returns true because s starts with this\n                fmt.Println(strings.HasPrefix(s, \"this\"))\n\n                // returns true because s ends with this\n                fmt.Println(strings.HasSuffix(s, \"test\"))\n                }\n\n        // ModifyString modifies a string in a number of ways\n        func ModifyString() {\n                s := \"simple string\"\n\n                // prints [simple string]\n                fmt.Println(strings.Split(s, \" \"))\n\n                // prints \"Simple String\"\n                fmt.Println(strings.Title(s))\n\n                // prints \"simple string\"; all trailing and\n                // leading white space is removed\n                s = \" simple string \"\n                fmt.Println(strings.TrimSpace(s))\n        }\n\n        // StringReader demonstrates how to create\n        // an io.Reader interface quickly with a string\n        func StringReader() {\n                s := \"simple stringn\"\n                r := strings.NewReader(s)\n\n                // prints s on Stdout\n                io.Copy(os.Stdout, r)\n        }\n```", "```go\n        package main\n\n        import \"github.com/PacktPublishing/\n                Go-Programming-Cookbook-Second-Edition/\n                chapter1/bytestrings\"\n\n        func main() {\n                err := bytestrings.WorkWithBuffer()\n                if err != nil {\n                        panic(err)\n                }\n\n                // each of these print to stdout\n                bytestrings.SearchString()\n                bytestrings.ModifyString()\n                bytestrings.StringReader() \n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run .\nit's easy to encode unicode into a byte array ??\nit's easy to encode unicode into a byte array ??\nit'seasytoencodeunicodeintoabytearray??true\ntrue\ntrue\ntrue\n[simple string]\nSimple String\nsimple string\nsimple string\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter1/filedirs \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter1/filedirs    \n```", "```go\n        package filedirs\n\n        import (\n                \"errors\"\n                \"io\"\n                \"os\"\n        )\n\n        // Operate manipulates files and directories\n        func Operate() error {\n                // this 0755 is similar to what you'd see with Chown\n                // on a command line this will create a director \n                // /tmp/example, you may also use an absolute path \n                // instead of a relative one\n                if err := os.Mkdir(\"example_dir\", os.FileMode(0755)); \n                err !=  nil {\n                        return err\n                }\n\n                // go to the /tmp directory\n                if err := os.Chdir(\"example_dir\"); err != nil {\n                        return err\n                }\n\n                // f is a generic file object\n                // it also implements multiple interfaces\n                // and can be used as a reader or writer\n                // if the correct bits are set when opening\n                f, err := os.Create(\"test.txt\")\n                if err != nil {\n                        return err\n                }\n\n                // we write a known-length value to the file and \n                // validate that it wrote correctly\n                value := []byte(\"hellon\")\n                count, err := f.Write(value)\n                if err != nil {\n                        return err\n                }\n                if count != len(value) {\n                        return errors.New(\"incorrect length returned \n                        from write\")\n                }\n\n                if err := f.Close(); err != nil {\n                        return err\n                }\n\n                // read the file\n                f, err = os.Open(\"test.txt\")\n                if err != nil {\n                        return err\n                }\n\n                io.Copy(os.Stdout, f)\n\n                if err := f.Close(); err != nil {\n                        return err\n                }\n\n                // go to the /tmp directory\n                if err := os.Chdir(\"..\"); err != nil {\n                        return err\n                }\n\n                // cleanup, os.RemoveAll can be dangerous if you\n                // point at the wrong directory, use user input,\n                // and especially if you run as root\n                if err := os.RemoveAll(\"example_dir\"); err != nil {\n                        return err\n                }\n\n                return nil\n        }\n```", "```go\n        package filedirs\n\n        import (\n                \"bytes\"\n                \"io\"\n                \"os\"\n                \"strings\"\n        )\n\n        // Capitalizer opens a file, reads the contents,\n        // then writes those contents to a second file\n                func Capitalizer(f1 *os.File, f2 *os.File) error {\n                if _, err := f1.Seek(0, io.SeekStart); err != nil {\n                        return err\n                }\n\n                var tmp = new(bytes.Buffer)\n\n                if _, err := io.Copy(tmp, f1); err != nil {\n                        return err\n                }\n\n                s := strings.ToUpper(tmp.String())\n\n                if _, err := io.Copy(f2, strings.NewReader(s)); err != \n                nil {\n                        return err\n                }\n                return nil\n        }\n\n        // CapitalizerExample creates two files, writes to one\n        //then calls Capitalizer() on both\n        func CapitalizerExample() error {\n                f1, err := os.Create(\"file1.txt\")\n                if err != nil {\n                        return err\n                }\n\n                if _, err := f1.Write([]byte(`this file contains a \n                number of words and new lines`)); err != nil {\n                        return err\n                }\n\n                f2, err := os.Create(\"file2.txt\")\n                if err != nil {\n                        return err\n                }\n\n                if err := Capitalizer(f1, f2); err != nil {\n                        return err\n                }\n\n                if err := os.Remove(\"file1.txt\"); err != nil {\n                        return err\n                }\n\n                if err := os.Remove(\"file2.txt\"); err != nil {\n                        return err\n                }\n\n                return nil\n        }\n```", "```go\n        package main\n\n        import \"github.com/PacktPublishing/\n                Go-Programming-Cookbook-Second-Edition/\n                chapter1/filedirs\"\n\n        func main() {\n                if err := filedirs.Operate(); err != nil {\n                        panic(err)\n                }\n\n                if err := filedirs.CapitalizerExample(); err != nil {\n                        panic(err)\n                }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run . \nhello\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter1/csvformat \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter1/csvformat    \n```", "```go\n        package csvformat\n\n        import (\n                \"bytes\"\n                \"encoding/csv\"\n                \"fmt\"\n                \"io\"\n                \"strconv\"\n        )\n\n        // Movie will hold our parsed CSV\n        type Movie struct {\n                Title string\n                Director string\n                Year int\n        }\n\n        // ReadCSV gives shows some examples of processing CSV\n        // that is passed in as an io.Reader\n        func ReadCSV(b io.Reader) ([]Movie, error) {\n\n                r := csv.NewReader(b)\n\n                // These are some optional configuration options\n                r.Comma = ';'\n                r.Comment = '-'\n\n                var movies []Movie\n\n                // grab and ignore the header for now\n                // we may also want to use this for a dictionary key or\n                // some other form of lookup\n                _, err := r.Read()\n                if err != nil && err != io.EOF {\n                        return nil, err\n                }\n\n                // loop until it's all processed\n                for {\n                        record, err := r.Read()\n                        if err == io.EOF {\n                                break\n                        } else if err != nil {\n                                return nil, err\n                        }\n\n                        year, err := strconv.ParseInt(record[2], 10, \n                        64)\n                        if err != nil {\n                                return nil, err\n                        }\n\n                        m := Movie{record[0], record[1], int(year)}\n                        movies = append(movies, m)\n                }\n                return movies, nil\n        }\n```", "```go\n        // AddMoviesFromText uses the CSV parser with a string\n        func AddMoviesFromText() error {\n                // this is an example of us taking a string, converting\n                // it into a buffer, and reading it \n                // with the csv package\n                in := `\n                - first our headers\n                movie title;director;year released\n\n                - then some data\n                Guardians of the Galaxy Vol. 2;James Gunn;2017\n                Star Wars: Episode VIII;Rian Johnson;2017\n                `\n\n                b := bytes.NewBufferString(in)\n                m, err := ReadCSV(b)\n                if err != nil {\n                        return err\n                }\n                fmt.Printf(\"%#vn\", m)\n                return nil\n        }\n```", "```go\n        package csvformat\n\n        import (\n                \"bytes\"\n                \"encoding/csv\"\n                \"io\"\n                \"os\"\n        )\n\n        // A Book has an Author and Title\n        type Book struct {\n                Author string\n                Title string\n        }\n\n        // Books is a named type for an array of books\n        type Books []Book\n\n        // ToCSV takes a set of Books and writes to an io.Writer\n        // it returns any errors\n        func (books *Books) ToCSV(w io.Writer) error {\n                n := csv.NewWriter(w)\n                err := n.Write([]string{\"Author\", \"Title\"})\n                if err != nil {\n                        return err\n                }\n                for _, book := range *books {\n                        err := n.Write([]string{book.Author, \n                        book.Title})\n                        if err != nil {\n                                return err\n                        }\n                }\n\n                n.Flush()\n                return n.Error()\n        }\n```", "```go\n        // WriteCSVOutput initializes a set of books\n        // and writes the to os.Stdout\n        func WriteCSVOutput() error {\n                b := Books{\n                        Book{\n                                Author: \"F Scott Fitzgerald\",\n                                Title: \"The Great Gatsby\",\n                        },\n                        Book{\n                                Author: \"J D Salinger\",\n                                Title: \"The Catcher in the Rye\",\n                        },\n                }\n\n                return b.ToCSV(os.Stdout)\n        }\n\n        // WriteCSVBuffer returns a buffer csv for\n        // a set of books\n        func WriteCSVBuffer() (*bytes.Buffer, error) {\n                b := Books{\n                        Book{\n                                Author: \"F Scott Fitzgerald\",\n                                Title: \"The Great Gatsby\",\n                        },\n                        Book{\n                                Author: \"J D Salinger\",\n                                Title: \"The Catcher in the Rye\",\n                        },\n                }\n\n                w := &bytes.Buffer{}\n                err := b.ToCSV(w)\n                return w, err\n        }\n```", "```go\n        package main\n\n        import (\n                \"fmt\"\n\n                \"github.com/PacktPublishing/\n                 Go-Programming-Cookbook-Second-Edition/\n                 chapter1/csvformat\"\n        )\n\n        func main() {\n                if err := csvformat.AddMoviesFromText(); err != nil {\n                        panic(err)\n                }\n\n                if err := csvformat.WriteCSVOutput(); err != nil {\n                        panic(err)\n                }\n\n                buffer, err := csvformat.WriteCSVBuffer()\n                if err != nil {\n                        panic(err)\n                }\n\n                fmt.Println(\"Buffer = \", buffer.String())\n        }\n```", "```go\n$ go build\n$ ./example\n```", "```go\n$ go run . \n[]csvformat.Movie{csvformat.Movie{Title:\"Guardians of the \nGalaxy Vol. 2\", Director:\"James Gunn\", Year:2017},         \ncsvformat.Movie{Title:\"Star Wars: Episode VIII\", Director:\"Rian \nJohnson\", Year:2017}}\nAuthor,Title\nF Scott Fitzgerald,The Great Gatsby\nJ D Salinger,The Catcher in the Rye\nBuffer = Author,Title\nF Scott Fitzgerald,The Great Gatsby\nJ D Salinger,The Catcher in the Rye\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter1/tempfiles \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter1/tempfiles    \n```", "```go\n        package tempfiles\n\n        import (\n                \"fmt\"\n                \"io/ioutil\"\n                \"os\"\n        )\n\n        // WorkWithTemp will give some basic patterns for working\n        // with temporary files and directories\n        func WorkWithTemp() error {\n                // If you need a temporary place to store files with \n                // the same name ie. template1-10.html a temp directory \n                //  is a good way to approach it, the first argument \n                // being blank means it will use create the directory                \n                // in the location returned by \n                // os.TempDir()\n                t, err := ioutil.TempDir(\"\", \"tmp\")\n                if err != nil {\n                        return err\n                }\n\n                // This will delete everything inside the temp file \n                // when this function exits if you want to do this \n                //  later, be sure to return the directory name to the \n                // calling function\n                defer os.RemoveAll(t)\n\n                // the directory must exist to create the tempfile\n                // created. t is an *os.File object.\n                tf, err := ioutil.TempFile(t, \"tmp\")\n                if err != nil {\n                        return err\n                }\n\n                fmt.Println(tf.Name())\n\n                // normally we'd delete the temporary file here, but \n                // because we're placing it in a temp directory, it \n                // gets cleaned up by the earlier defer\n\n                return nil\n        }\n```", "```go\n        package main\n\n        import \"github.com/PacktPublishing/\n                Go-Programming-Cookbook-Second-Edition/\n                chapter1/tempfiles\"\n\n        func main() {\n                if err := tempfiles.WorkWithTemp(); err != nil {\n                        panic(err)\n                }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run . \n/var/folders/kd/ygq5l_0d1xq1lzk_c7htft900000gn/T\n/tmp764135258/tmp588787953\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter1/templates \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter1/templates    \n```", "```go\n        package templates\n\n        import (\n                \"os\"\n                \"strings\"\n                \"text/template\"\n        )\n\n        const sampleTemplate = `\n                This template demonstrates printing a {{ .Variable | \n                printf \"%#v\" }}.\n\n                {{if .Condition}}\n                If condition is set, we'll print this\n                {{else}}\n                Otherwise, we'll print this instead\n                {{end}}\n\n                Next we'll iterate over an array of strings:\n                {{range $index, $item := .Items}}\n                {{$index}}: {{$item}}\n                {{end}}\n\n                We can also easily import other functions like \n                strings.Split\n                then immediately used the array created as a result:\n                {{ range $index, $item := split .Words \",\"}}\n                {{$index}}: {{$item}}\n                {{end}}\n\n                Blocks are a way to embed templates into one another\n                {{ block \"block_example\" .}}\n                No Block defined!\n                {{end}}\n\n                {{/*\n                This is a way\n                to insert a multi-line comment\n                */}}\n`\n\n        const secondTemplate = `\n                {{ define \"block_example\" }}\n                {{.OtherVariable}}\n                {{end}}\n`\n```", "```go\n        // RunTemplate initializes a template and demonstrates a \n        // variety of template helper functions\n        func RunTemplate() error {\n                data := struct {\n                        Condition bool\n                        Variable string\n                        Items []string\n                        Words string\n                        OtherVariable string\n                }{\n                        Condition: true,\n                        Variable: \"variable\",\n                        Items: []string{\"item1\", \"item2\", \"item3\"},\n                        Words: \n                        \"another_item1,another_item2,another_item3\",\n                        OtherVariable: \"I'm defined in a second \n                        template!\",\n                }\n\n                funcmap := template.FuncMap{\n                        \"split\": strings.Split,\n                }\n\n                // these can also be chained\n                t := template.New(\"example\")\n                t = t.Funcs(funcmap)\n\n                // We could use Must instead to panic on error\n                // template.Must(t.Parse(sampleTemplate))\n                t, err := t.Parse(sampleTemplate)\n                if err != nil {\n                        return err\n                }\n\n                // to demonstrate blocks we'll create another template\n                // by cloning the first template, then parsing a second\n                t2, err := t.Clone()\n                if err != nil {\n                        return err\n                }\n\n                t2, err = t2.Parse(secondTemplate)\n                if err != nil {\n                        return err\n                }\n\n                // write the template to stdout and populate it\n                // with data\n                err = t2.Execute(os.Stdout, &data)\n                if err != nil {\n                        return err\n                }\n\n                return nil\n        }\n```", "```go\n        package templates\n\n        import (\n                \"io/ioutil\"\n                \"os\"\n                \"path/filepath\"\n                \"text/template\"\n        )\n\n        //CreateTemplate will create a template file that contains data\n        func CreateTemplate(path string, data string) error {\n                return ioutil.WriteFile(path, []byte(data), \n                os.FileMode(0755))\n        }\n\n        // InitTemplates sets up templates from a directory\n        func InitTemplates() error {\n                tempdir, err := ioutil.TempDir(\"\", \"temp\")\n                if err != nil {\n                        return err\n                }\n                defer os.RemoveAll(tempdir)\n\n                err = CreateTemplate(filepath.Join(tempdir, \"t1.tmpl\"), \n                `Template 1! {{ .Var1 }}\n                {{ block \"template2\" .}} {{end}}\n                {{ block \"template3\" .}} {{end}}\n                `)\n                if err != nil {\n                        return err\n                }\n\n                err = CreateTemplate(filepath.Join(tempdir, \"t2.tmpl\"), \n                `{{ define \"template2\"}}Template 2! {{ .Var2 }}{{end}}\n                `)\n                if err != nil {\n                        return err\n                }\n\n                err = CreateTemplate(filepath.Join(tempdir, \"t3.tmpl\"), \n                `{{ define \"template3\"}}Template 3! {{ .Var3 }}{{end}}\n                `)\n                if err != nil {\n                        return err\n                }\n\n                pattern := filepath.Join(tempdir, \"*.tmpl\")\n\n                // Parse glob will combine all the files that match \n                // glob and combine them into a single template\n                tmpl, err := template.ParseGlob(pattern)\n                if err != nil {\n                        return err\n                }\n\n                // Execute can also work with a map instead\n                // of a struct\n                tmpl.Execute(os.Stdout, map[string]string{\n                        \"Var1\": \"Var1!!\",\n                        \"Var2\": \"Var2!!\",\n                        \"Var3\": \"Var3!!\",\n                 })\n\n                 return nil\n        }\n```", "```go\n        package templates\n\n        import (\n                \"fmt\"\n                \"html/template\"\n                \"os\"\n        )\n\n        // HTMLDifferences highlights some of the differences\n        // between html/template and text/template\n        func HTMLDifferences() error {\n                t := template.New(\"html\")\n                t, err := t.Parse(\"<h1>Hello! {{.Name}}</h1>n\")\n                if err != nil {\n                        return err\n         }\n\n                // html/template auto-escapes unsafe operations like \n                // javascript injection this is contextually aware and \n                // will behave differently\n                // depending on where a variable is rendered\n                err = t.Execute(os.Stdout, map[string]string{\"Name\": \"                 \n                      <script>alert('Can you see me?')</script>\"})\n                if err != nil {\n                        return err\n                }\n\n                // you can also manually call the escapers\n                fmt.Println(template.JSEscaper(`example         \n                <example@example.com>`))\n                fmt.Println(template.HTMLEscaper(`example \n                <example@example.com>`))\n                fmt.Println(template.URLQueryEscaper(`example \n                <example@example.com>`))\n\n                return nil\n        }\n```", "```go\n        package main\n\n        import \"github.com/PacktPublishing/\n                Go-Programming-Cookbook-Second-Edition/\n                chapter1/templates\"\n\n        func main() {\n                if err := templates.RunTemplate(); err != nil {\n                        panic(err)\n                }\n\n                if err := templates.InitTemplates(); err != nil {\n                        panic(err)\n                }\n\n                if err := templates.HTMLDifferences(); err != nil {\n                        panic(err)\n                }\n        }\n```", "```go\n$ go build $ ./example\n```"]