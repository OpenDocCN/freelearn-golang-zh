["```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/flags \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/flags    \n```", "```go\n        package main\n\n        import (\n             \"flag\"\n             \"fmt\"\n        )\n\n        // Config will be the holder for our flags\n        type Config struct {\n             subject string\n             isAwesome bool\n             howAwesome int\n             countTheWays CountTheWays\n        }\n\n        // Setup initializes a config from flags that\n        // are passed in\n        func (c *Config) Setup() {\n            // you can set a flag directly like so:\n            // var someVar = flag.String(\"flag_name\", \"default_val\",           \n            // \"description\")\n            // but in practice putting it in a struct is generally \n            // better longhand\n            flag.StringVar(&c.subject, \"subject\", \"\", \"subject is a           \n            string, it defaults to empty\")\n            // shorthand\n            flag.StringVar(&c.subject, \"s\", \"\", \"subject is a string, \n            it defaults to empty (shorthand)\")\n\n           flag.BoolVar(&c.isAwesome, \"isawesome\", false, \"is it \n           awesome or what?\")\n           flag.IntVar(&c.howAwesome, \"howawesome\", 10, \"how awesome \n           out of 10?\")\n\n           // custom variable type\n           flag.Var(&c.countTheWays, \"c\", \"comma separated list of \n           integers\")\n        }\n\n        // GetMessage uses all of the internal\n        // config vars and returns a sentence\n        func (c *Config) GetMessage() string {\n            msg := c.subject\n            if c.isAwesome {\n                msg += \" is awesome\"\n            } else {\n                msg += \" is NOT awesome\"\n            }\n\n            msg = fmt.Sprintf(\"%s with a certainty of %d out of 10\\. Let \n            me count the ways %s\", msg, c.howAwesome, \n            c.countTheWays.String())\n            return msg\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"strconv\"\n            \"strings\"\n        )\n\n        // CountTheWays is a custom type that\n        // we'll read a flag into\n        type CountTheWays []int\n\n        func (c *CountTheWays) String() string {\n            result := \"\"\n            for _, v := range *c {\n                if len(result) > 0 {\n                    result += \" ... \"\n                }\n                result += fmt.Sprint(v)\n            }\n            return result\n        }\n\n        // Set will be used by the flag package\n        func (c *CountTheWays) Set(value string) error {\n            values := strings.Split(value, \",\")\n\n            for _, v := range values {\n                i, err := strconv.Atoi(v)\n                if err != nil {\n                    return err\n                }\n                *c = append(*c, i)\n            }\n\n            return nil\n        }\n```", "```go\n$ go mod tidy\n```", "```go\n        package main\n\n        import (\n            \"flag\"\n            \"fmt\"\n        )\n\n        func main() {\n            // initialize our setup\n            c := Config{}\n            c.Setup()\n\n            // generally call this from main\n            flag.Parse()\n\n            fmt.Println(c.GetMessage())\n        }\n```", "```go\n$ go build $ ./flags -h\n```", "```go\n$ go build \n$ ./flags -h \nUsage of ./flags:\n-c value\ncomma separated list of integers\n-howawesome int\nhow awesome out of 10? (default 10)\n-isawesome\nis it awesome or what? (default false)\n-s string\nsubject is a string, it defaults to empty (shorthand)\n-subject string\nsubject is a string, it defaults to empty\n$ ./flags -s Go -isawesome -howawesome 10 -c 1,2,3 \nGo is awesome with a certainty of 10 out of 10\\. Let me count \nthe ways 1 ... 2 ... 3\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/cmdargs \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/cmdargs   \n```", "```go\n        package main\n        import (\n            \"flag\"\n            \"fmt\"\n            \"os\"\n        )\n        const version = \"1.0.0\"\n        const usage = `Usage:\n        %s [command]\n        Commands:\n            Greet\n            Version\n        `\n        const greetUsage = `Usage:\n        %s greet name [flag]\n        Positional Arguments:\n            name\n                the name to greet\n        Flags:\n        `\n        // MenuConf holds all the levels\n        // for a nested cmd line argument\n        type MenuConf struct {\n            Goodbye bool\n        }\n        // SetupMenu initializes the base flags\n        func (m *MenuConf) SetupMenu() *flag.FlagSet {\n            menu := flag.NewFlagSet(\"menu\", flag.ExitOnError)\n            menu.Usage = func() {\n                fmt.Printf(usage, os.Args[0])\n                menu.PrintDefaults()\n            }\n            return menu\n        }\n        // GetSubMenu return a flag set for a submenu\n        func (m *MenuConf) GetSubMenu() *flag.FlagSet {\n            submenu := flag.NewFlagSet(\"submenu\", flag.ExitOnError)\n            submenu.BoolVar(&m.Goodbye, \"goodbye\", false, \"Say goodbye \n            instead of hello\")\n            submenu.Usage = func() {\n                fmt.Printf(greetUsage, os.Args[0])\n                submenu.PrintDefaults()\n            }\n            return submenu\n        }\n        // Greet will be invoked by the greet command\n        func (m *MenuConf) Greet(name string) {\n            if m.Goodbye {\n                fmt.Println(\"Goodbye \" + name + \"!\")\n            } else {\n                fmt.Println(\"Hello \" + name + \"!\")\n            }\n        }\n        // Version prints the current version that is\n        // stored as a const\n        func (m *MenuConf) Version() {\n            fmt.Println(\"Version: \" + version)\n        }\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n  \"strings\"\n)\n\nfunc main() {\n  c := MenuConf{}\n  menu := c.SetupMenu()\n\n  if err := menu.Parse(os.Args[1:]); err != nil {\n    fmt.Printf(\"Error parsing params %s, error: %v\", os.Args[1:], err)\n    return\n  }\n\n  // we use arguments to switch between commands\n  // flags are also an argument\n  if len(os.Args) > 1 {\n    // we don't care about case\n    switch strings.ToLower(os.Args[1]) {\n    case \"version\":\n      c.Version()\n    case \"greet\":\n      f := c.GetSubMenu()\n      if len(os.Args) < 3 {\n        f.Usage()\n        return\n      }\n      if len(os.Args) > 3 {\n        if err := f.Parse(os.Args[3:]); err != nil {\n          fmt.Fprintf(os.Stderr, \"Error parsing params %s, error: %v\", os.Args[3:], err)\n          return\n        }\n\n      }\n      c.Greet(os.Args[2])\n\n    default:\n      fmt.Println(\"Invalid command\")\n      menu.Usage()\n      return\n    }\n  } else {\n    menu.Usage()\n    return\n  }\n}\n```", "```go\n$ ./cmdargs -h \nUsage:\n\n./cmdargs [command]\n\nCommands:\nGreet\nVersion\n\n$./cmdargs version\nVersion: 1.0.0\n\n$./cmdargs greet\nUsage:\n\n./cmdargs greet name [flag]\n\nPositional Arguments:\n name\n the name to greet\n\nFlags:\n -goodbye\n Say goodbye instead of hello\n\n$./cmdargs greet reader\nHello reader!\n\n$./cmdargs greet reader -goodbye\nGoodbye reader!\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/envvar \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/envvar   \n```", "```go\n        package envvar\n\n        import (\n            \"encoding/json\"\n            \"os\"\n\n            \"github.com/kelseyhightower/envconfig\"\n            \"github.com/pkg/errors\"\n        )\n\n        // LoadConfig will load files optionally from the json file \n        // stored at path, then will override those values based on the \n        // envconfig struct tags. The envPrefix is how we prefix our \n        // environment variables.\n        func LoadConfig(path, envPrefix string, config interface{}) \n        error {\n            if path != \"\" {\n               err := LoadFile(path, config)\n               if err != nil {\n                   return errors.Wrap(err, \"error loading config from \n                   file\")\n               }\n            }\n            err := envconfig.Process(envPrefix, config)\n            return errors.Wrap(err, \"error loading config from env\")\n        }\n\n        // LoadFile unmarshalls a json file into a config struct\n        func LoadFile(path string, config interface{}) error {\n            configFile, err := os.Open(path)\n            if err != nil {\n                return errors.Wrap(err, \"failed to read config file\")\n         }\n         defer configFile.Close()\n\n         decoder := json.NewDecoder(configFile)\n         if err = decoder.Decode(config); err != nil {\n             return errors.Wrap(err, \"failed to decode config file\")\n         }\n         return nil\n        }\n```", "```go\n        package main\n\n        import (\n            \"bytes\"\n            \"fmt\"\n            \"io/ioutil\"\n            \"os\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter2/envvar\"\n        )\n\n        // Config will hold the config we\n        // capture from a json file and env vars\n        type Config struct {\n            Version string `json:\"version\" required:\"true\"`\n            IsSafe bool `json:\"is_safe\" default:\"true\"`\n            Secret string `json:\"secret\"`\n        }\n\n        func main() {\n            var err error\n\n            // create a temporary file to hold\n            // an example json file\n            tf, err := ioutil.TempFile(\"\", \"tmp\")\n            if err != nil {\n                panic(err)\n            }\n            defer tf.Close()\n            defer os.Remove(tf.Name())\n\n            // create a json file to hold\n            // our secrets\n            secrets := `{\n                \"secret\": \"so so secret\"\n            }`\n\n            if _, err =   \n            tf.Write(bytes.NewBufferString(secrets).Bytes()); \n            err != nil {\n                panic(err)\n            }\n\n            // We can easily set environment variables\n            // as needed\n            if err = os.Setenv(\"EXAMPLE_VERSION\", \"1.0.0\"); err != nil \n            {\n                panic(err)\n            }\n            if err = os.Setenv(\"EXAMPLE_ISSAFE\", \"false\"); err != nil {\n                panic(err)\n            }\n\n            c := Config{}\n            if err = envvar.LoadConfig(tf.Name(), \"EXAMPLE\", &c);\n            err != nil {\n                panic(err)\n            }\n\n            fmt.Println(\"secrets file contains =\", secrets)\n\n            // We can also read them\n            fmt.Println(\"EXAMPLE_VERSION =\", \n            os.Getenv(\"EXAMPLE_VERSION\"))\n            fmt.Println(\"EXAMPLE_ISSAFE =\", \n            os.Getenv(\"EXAMPLE_ISSAFE\"))\n\n            // The final config is a mix of json and environment\n            // variables\n            fmt.Printf(\"Final Config: %#v\\n\", c)\n        }\n```", "```go\ngo build ./example\n```", "```go\n$ go run main.go\nsecrets file contains = {\n\"secret\": \"so so secret\"\n}\nEXAMPLE_VERSION = 1.0.0\nEXAMPLE_ISSAFE = false\nFinal Config: main.Config{Version:\"1.0.0\", IsSafe:false, \nSecret:\"so so secret\"}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/confformat \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/confformat   \n```", "```go\n        package confformat\n\n        import (\n            \"bytes\"\n\n            \"github.com/BurntSushi/toml\"\n        )\n\n        // TOMLData is our common data struct\n        // with TOML struct tags\n        type TOMLData struct {\n            Name string `toml:\"name\"`\n            Age int `toml:\"age\"`\n        }\n\n        // ToTOML dumps the TOMLData struct to\n        // a TOML format bytes.Buffer\n        func (t *TOMLData) ToTOML() (*bytes.Buffer, error) {\n            b := &bytes.Buffer{}\n            encoder := toml.NewEncoder(b)\n\n            if err := encoder.Encode(t); err != nil {\n                return nil, err\n            }\n            return b, nil\n        }\n\n        // Decode will decode into TOMLData\n        func (t *TOMLData) Decode(data []byte) (toml.MetaData, error) {\n            return toml.Decode(string(data), t)\n        }\n```", "```go\n        package confformat\n\n        import (\n            \"bytes\"\n\n            \"github.com/go-yaml/yaml\"\n        )\n\n        // YAMLData is our common data struct\n        // with YAML struct tags\n        type YAMLData struct {\n            Name string `yaml:\"name\"`\n            Age int `yaml:\"age\"`\n        }\n\n        // ToYAML dumps the YAMLData struct to\n        // a YAML format bytes.Buffer\n        func (t *YAMLData) ToYAML() (*bytes.Buffer, error) {\n            d, err := yaml.Marshal(t)\n            if err != nil {\n                return nil, err\n            }\n\n            b := bytes.NewBuffer(d)\n\n            return b, nil\n        }\n\n        // Decode will decode into TOMLData\n        func (t *YAMLData) Decode(data []byte) error {\n            return yaml.Unmarshal(data, t)\n        }\n```", "```go\n        package confformat\n\n        import (\n            \"bytes\"\n            \"encoding/json\"\n            \"fmt\"\n        )\n\n        // JSONData is our common data struct\n        // with JSON struct tags\n        type JSONData struct {\n            Name string `json:\"name\"`\n            Age int `json:\"age\"`\n        }\n\n        // ToJSON dumps the JSONData struct to\n        // a JSON format bytes.Buffer\n        func (t *JSONData) ToJSON() (*bytes.Buffer, error) {\n            d, err := json.Marshal(t)\n            if err != nil {\n                return nil, err\n            }\n\n            b := bytes.NewBuffer(d)\n\n            return b, nil\n        }\n\n        // Decode will decode into JSONData\n        func (t *JSONData) Decode(data []byte) error {\n            return json.Unmarshal(data, t)\n        }\n\n        // OtherJSONExamples shows ways to use types\n        // beyond structs and other useful functions\n        func OtherJSONExamples() error {\n            res := make(map[string]string)\n            err := json.Unmarshal([]byte(`{\"key\": \"value\"}`), &res)\n            if err != nil {\n                return err\n            }\n\n            fmt.Println(\"We can unmarshal into a map instead of a \n            struct:\", res)\n\n            b := bytes.NewReader([]byte(`{\"key2\": \"value2\"}`))\n            decoder := json.NewDecoder(b)\n\n            if err := decoder.Decode(&res); err != nil {\n                return err\n            }\n\n            fmt.Println(\"we can also use decoders/encoders to work with \n            streams:\", res)\n\n            return nil\n        }\n```", "```go\n        package confformat\n\n        import \"fmt\"\n\n        // MarshalAll takes some data stored in structs\n        // and converts them to the various data formats\n        func MarshalAll() error {\n            t := TOMLData{\n                Name: \"Name1\",\n                Age: 20,\n            }\n\n            j := JSONData{\n                Name: \"Name2\",\n                Age: 30,\n            }\n\n            y := YAMLData{\n                Name: \"Name3\",\n                Age: 40,\n            }\n\n            tomlRes, err := t.ToTOML()\n            if err != nil {\n                return err\n            }\n\n            fmt.Println(\"TOML Marshal =\", tomlRes.String())\n\n            jsonRes, err := j.ToJSON()\n            if err != nil {\n                return err\n            }\n\n            fmt.Println(\"JSON Marshal=\", jsonRes.String())\n\n            yamlRes, err := y.ToYAML()\n            if err != nil {\n                return err\n            }\n\n            fmt.Println(\"YAML Marshal =\", yamlRes.String())\n                return nil\n        }\n```", "```go\n        package confformat\n        import \"fmt\"\n        const (\n            exampleTOML = `name=\"Example1\"\n        age=99\n            `\n            exampleJSON = `{\"name\":\"Example2\",\"age\":98}`\n            exampleYAML = `name: Example3\n        age: 97 \n            `\n        )\n        // UnmarshalAll takes data in various formats\n        // and converts them into structs\n        func UnmarshalAll() error {\n            t := TOMLData{}\n            j := JSONData{}\n            y := YAMLData{}\n            if _, err := t.Decode([]byte(exampleTOML)); err != nil {\n                return err\n            }\n            fmt.Println(\"TOML Unmarshal =\", t)\n\n            if err := j.Decode([]byte(exampleJSON)); err != nil {\n                return err\n            }\n            fmt.Println(\"JSON Unmarshal =\", j)\n\n            if err := y.Decode([]byte(exampleYAML)); err != nil {\n                return err\n            }\n            fmt.Println(\"Yaml Unmarshal =\", y)\n                return nil\n            }\n```", "```go\n        package main\n\n        import \"github.com/PacktPublishing/\n                Go-Programming-Cookbook-Second-Edition/\n                chapter2/confformat\"\n\n        func main() {\n            if err := confformat.MarshalAll(); err != nil {\n                panic(err)\n            }\n\n            if err := confformat.UnmarshalAll(); err != nil {\n                panic(err)\n            }\n\n            if err := confformat.OtherJSONExamples(); err != nil {\n                panic(err)\n            }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nTOML Marshal = name = \"Name1\"\nage = 20\n\nJSON Marshal= {\"name\":\"Name2\",\"age\":30}\nYAML Marshal = name: Name3\nage: 40\n\nTOML Unmarshal = {Example1 99}\nJSON Unmarshal = {Example2 98}\nYaml Unmarshal = {Example3 97}\nWe can unmarshal into a map instead of a struct: map[key:value]\nwe can also use decoders/encoders to work with streams: \nmap[key:value key2:value2]\n```", "```go\n$ echo \"test case\" | wc -l\n 1\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/pipes\n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/pipes   \n```", "```go\n        package main\n\n        import (\n            \"bufio\"\n            \"fmt\"\n            \"io\"\n            \"os\"\n        )\n\n        // WordCount takes a file and returns a map\n        // with each word as a key and it's number of\n        // appearances as a value\n        func WordCount(f io.Reader) map[string]int {\n            result := make(map[string]int)\n\n            // make a scanner to work on the file\n            // io.Reader interface\n            scanner := bufio.NewScanner(f)\n            scanner.Split(bufio.ScanWords)\n\n            for scanner.Scan() {\n                result[scanner.Text()]++\n            }\n\n            if err := scanner.Err(); err != nil {\n                fmt.Fprintln(os.Stderr, \"reading input:\", err)\n            }\n\n            return result\n        }\n\n        func main() {\n            fmt.Printf(\"string: number_of_occurrences\\n\\n\")\n            for key, value := range WordCount(os.Stdin) {\n                fmt.Printf(\"%s: %d\\n\", key, value)\n            }\n        }\n```", "```go\n$ go build echo \"some string\" | ./pipes\n```", "```go\n$ echo \"test case\" | go run pipes.go\nstring: number_of_occurrences\n\ntest: 1\ncase: 1\n\n$ echo \"test case test\" | go run pipes.go\nstring: number_of_occurrences\n\ntest: 2\ncase: 1\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/signals \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/signals   \n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"os\"\n            \"os/signal\"\n            \"syscall\"\n        )\n\n        // CatchSig sets up a listener for\n        // SIGINT interrupts\n        func CatchSig(ch chan os.Signal, done chan bool) {\n            // block on waiting for a signal\n            sig := <-ch\n            // print it when it's received\n            fmt.Println(\"nsig received:\", sig)\n\n            // we can set up handlers for all types of\n            // sigs here\n            switch sig {\n            case syscall.SIGINT:\n                fmt.Println(\"handling a SIGINT now!\")\n            case syscall.SIGTERM:\n                fmt.Println(\"handling a SIGTERM in an entirely \n                different way!\")\n            default:\n                fmt.Println(\"unexpected signal received\")\n            }\n\n            // terminate\n            done <- true\n        }\n\n        func main() {\n            // initialize our channels\n            signals := make(chan os.Signal)\n            done := make(chan bool)\n\n            // hook them up to the signals lib\n            signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)\n\n            // if a signal is caught by this go routine\n            // it will write to done\n            go CatchSig(signals, done)\n\n            fmt.Println(\"Press ctrl-c to terminate...\")\n            // the program blocks until someone writes to done\n            <-done\n            fmt.Println(\"Done!\")\n\n        }\n```", "```go\n$ go build $ ./signals\n```", "```go\n$./signals\nPress ctrl-c to terminate...\n^C\nsig received: interrupt\nhandling a SIGINT now!\nDone!\n```", "```go\n$./signals\nPress ctrl-c to terminate...\n\n# in a separate terminal\n$ ps -ef | grep signals\n501 30777 26360 0 5:00PM ttys000 0:00.00 ./signals\n\n$ kill -SIGTERM 30777\n\n# in the original terminal\n\nsig received: terminated\nhandling a SIGTERM in an entirely different way!\nDone!\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/ansicolor \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter2/ansicolor   \n```", "```go\n        package ansicolor\n\n        import \"fmt\"\n\n        //Color of text\n        type Color int\n\n        const (\n            // ColorNone is default\n            ColorNone = iota\n            // Red colored text\n            Red\n            // Green colored text\n            Green\n            // Yellow colored text\n            Yellow\n            // Blue colored text\n            Blue\n            // Magenta colored text\n            Magenta\n            // Cyan colored text\n            Cyan\n            // White colored text\n            White\n            // Black colored text\n            Black Color = -1\n        )\n\n        // ColorText holds a string and its color\n        type ColorText struct {\n            TextColor Color\n            Text      string\n        }\n\n        func (r *ColorText) String() string {\n            if r.TextColor == ColorNone {\n                return r.Text\n            }\n\n            value := 30\n            if r.TextColor != Black {\n                value += int(r.TextColor)\n            }\n            return fmt.Sprintf(\"33[0;%dm%s33[0m\", value, r.Text)\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter2/ansicolor\"\n        )\n\n        func main() {\n            r := ansicolor.ColorText{\n                TextColor: ansicolor.Red,\n                Text:      \"I'm red!\",\n            }\n\n            fmt.Println(r.String())\n\n            r.TextColor = ansicolor.Green\n            r.Text = \"Now I'm green!\"\n\n            fmt.Println(r.String())\n\n            r.TextColor = ansicolor.ColorNone\n            r.Text = \"Back to normal...\"\n\n            fmt.Println(r.String())\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nI'm red!\nNow I'm green!\nBack to normal...\n```"]