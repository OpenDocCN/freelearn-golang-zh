["```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\ntype A int\n```", "```go\nvar a A = 1\nfmt.Println(int(a))\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/dataconv \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/dataconv    \n```", "```go\n        package dataconv\n\n        import \"fmt\"\n\n        // ShowConv demonstrates some type conversion\n        func ShowConv() {\n            // int\n            var a = 24\n\n            // float 64\n            var b = 2.0\n\n            // convert the int to a float64 for this calculation\n            c := float64(a) * b\n            fmt.Println(c)\n\n            // fmt.Sprintf is a good way to convert to strings\n            precision := fmt.Sprintf(\"%.2f\", b)\n\n            // print the value and the type\n            fmt.Printf(\"%s - %T\\n\", precision, precision)\n        }\n```", "```go\n        package dataconv\n\n        import (\n            \"fmt\"\n            \"strconv\"\n        )\n\n        // Strconv demonstrates some strconv\n        // functions\n        func Strconv() error {\n            //strconv is a good way to convert to and from strings\n            s := \"1234\"\n            // we can specify the base (10) and precision\n            // 64 bit\n            res, err := strconv.ParseInt(s, 10, 64)\n            if err != nil {\n                return err\n          }\n\n          fmt.Println(res)\n\n          // lets try hex\n          res, err = strconv.ParseInt(\"FF\", 16, 64)\n          if err != nil {\n              return err\n          }\n\n          fmt.Println(res)\n\n          // we can do other useful things like:\n          val, err := strconv.ParseBool(\"true\")\n          if err != nil {\n              return err\n          }\n\n          fmt.Println(val)\n\n          return nil\n        }\n```", "```go\n        package dataconv\n\n        import \"fmt\"\n\n        // CheckType will print based on the\n        // interface type\n        func CheckType(s interface{}) {\n            switch s.(type) {\n            case string:\n                fmt.Println(\"It's a string!\")\n            case int:\n                fmt.Println(\"It's an int!\")\n            default:\n                fmt.Println(\"not sure what it is...\")\n            }\n        }\n\n        // Interfaces demonstrates casting\n        // from anonymous interfaces to types\n        func Interfaces() {\n            CheckType(\"test\")\n            CheckType(1)\n            CheckType(false)\n\n            var i interface{}\n            i = \"test\"\n\n            // manually check an interface\n            if val, ok := i.(string); ok {\n                fmt.Println(\"val is\", val)\n            }\n\n            // this one should fail\n            if _, ok := i.(int); !ok {\n                fmt.Println(\"uh oh! glad we handled this\")\n            }\n        }\n```", "```go\n        package main\n\n        import \"github.com/PacktPublishing/\n                Go-Programming-Cookbook-Second-Edition/\n                chapter3/dataconv\"\n\n        func main() {\n            dataconv.ShowConv()\n            if err := dataconv.Strconv(); err != nil {\n                panic(err)\n            }\n            dataconv.Interfaces()\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\n48\n2.00 - string\n1234\n255\ntrue\nIt's a string!\nIt's an int!\nnot sure what it is...\nval is test\nuh oh! glad we handled this\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/math \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/math    \n```", "```go\n        package math\n\n        import \"math/big\"\n\n        // global to memoize fib\n        var memoize map[int]*big.Int\n\n        func init() {\n            // initialize the map\n            memoize = make(map[int]*big.Int)\n        }\n\n        // Fib prints the nth digit of the fibonacci sequence\n        // it will return 1 for anything < 0 as well...\n        // it's calculated recursively and use big.Int since\n        // int64 will quickly overflow\n        func Fib(n int) *big.Int {\n            if n < 0 {\n                return big.NewInt(1)\n            }\n\n            // base case\n            if n < 2 {\n                memoize[n] = big.NewInt(1)\n            }\n\n            // check if we stored it before\n            // if so return with no calculation\n            if val, ok := memoize[n]; ok {\n                return val\n            }\n\n            // initialize map then add previous 2 fib values\n            memoize[n] = big.NewInt(0)\n            memoize[n].Add(memoize[n], Fib(n-1))\n            memoize[n].Add(memoize[n], Fib(n-2))\n\n            // return result\n            return memoize[n]\n        }\n```", "```go\npackage math\n\nimport (\n  \"fmt\"\n  \"math\"\n)\n\n// Examples demonstrates some of the functions\n// in the math package\nfunc Examples() {\n  //sqrt Examples\n  i := 25\n\n  // i is an int, so convert\n  result := math.Sqrt(float64(i))\n\n  // sqrt of 25 == 5\n  fmt.Println(result)\n\n  // ceil rounds up\n  result = math.Ceil(9.5)\n  fmt.Println(result)\n\n  // floor rounds down\n  result = math.Floor(9.5)\n  fmt.Println(result)\n\n  // math also stores some consts:\n  fmt.Println(\"Pi:\", math.Pi, \"E:\", math.E)\n}\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter3/math\"\n        )\n\n        func main() {\n            math.Examples()\n\n            for i := 0; i < 10; i++ {\n                fmt.Printf(\"%v \", math.Fib(i))\n            }\n            fmt.Println()\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\n5\n10\n9\nPi: 3.141592653589793 E: 2.718281828459045\n1 1 2 3 5 8 13 21 34 55\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/currency \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/currency    \n```", "```go\n        package currency\n\n        import (\n            \"errors\"\n            \"strconv\"\n            \"strings\"\n        )\n\n        // ConvertStringDollarsToPennies takes a dollar amount\n        // as a string, i.e. 1.00, 55.12 etc and converts it\n        // into an int64\n        func ConvertStringDollarsToPennies(amount string) (int64, \n        error) {\n            // check if amount can convert to a valid float\n            _, err := strconv.ParseFloat(amount, 64)\n            if err != nil {\n                return 0, err\n            }\n\n            // split the value on \".\"\n            groups := strings.Split(amount, \".\")\n\n            // if there is no . result will still be\n            // captured here\n            result := groups[0]\n\n            // base string\n            r := \"\"\n\n            // handle the data after the \".\"\n            if len(groups) == 2 {\n                if len(groups[1]) != 2 {\n                    return 0, errors.New(\"invalid cents\")\n                }\n                r = groups[1]\n            }\n\n            // pad with 0, this will be\n            // 2 0's if there was no .\n            for len(r) < 2 {\n                r += \"0\"\n            }\n\n            result += r\n\n            // convert it to an int\n            return strconv.ParseInt(result, 10, 64)\n        }\n```", "```go\n        package currency\n\n        import (\n            \"strconv\"\n        )\n\n        // ConvertPenniesToDollarString takes a penny amount as \n        // an int64 and returns a dollar string representation\n        func ConvertPenniesToDollarString(amount int64) string {\n            // parse the pennies as a base 10 int\n            result := strconv.FormatInt(amount, 10)\n\n            // check if negative, will set it back later\n            negative := false\n            if result[0] == '-' {\n                result = result[1:]\n                negative = true\n            }\n\n            // left pad with 0 if we're passed in value < 100\n            for len(result) < 3 {\n                result = \"0\" + result\n            }\n            length := len(result)\n\n            // add in the decimal\n            result = result[0:length-2] + \".\" + result[length-2:]\n\n            // from the negative we stored earlier!\n            if negative {\n                result = \"-\" + result\n            }\n\n            return result\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter3/currency\"\n        )\n\n        func main() {\n            // start with our user input\n            // of fifteen dollars and 93 cents\n            userInput := \"15.93\"\n\n            pennies, err := \n            currency.ConvertStringDollarsToPennies(userInput)\n            if err != nil {\n                panic(err)\n            }\n\n            fmt.Printf(\"User input converted to %d pennies\\n\", pennies)\n\n            // adding 15 cents\n            pennies += 15\n\n            dollars := currency.ConvertPenniesToDollarString(pennies)\n\n            fmt.Printf(\"Added 15 cents, new values is %s dollars\\n\", \n            dollars)\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nUser input converted to 1593 pennies\nAdded 15 cents, new values is 16.08 dollars\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/nulls \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/nulls    \n```", "```go\n        package nulls\n\n        import (\n            \"encoding/json\"\n            \"fmt\"\n        )\n\n        // json that has name but not age\n        const (\n            jsonBlob = `{\"name\": \"Aaron\"}`\n            fulljsonBlob = `{\"name\":\"Aaron\", \"age\":0}`\n        )\n\n        // Example is a basic struct with age\n        // and name fields\n        type Example struct {\n            Age int `json:\"age,omitempty\"`\n            Name string `json:\"name\"`\n        }\n\n        // BaseEncoding shows encoding and\n        // decoding with normal types\n        func BaseEncoding() error {\n            e := Example{}\n\n            // note that no age = 0 age\n            if err := json.Unmarshal([]byte(jsonBlob), &e); err != nil \n            {\n                return err\n            }\n            fmt.Printf(\"Regular Unmarshal, no age: %+v\\n\", e)\n\n            value, err := json.Marshal(&e)\n            if err != nil {\n                return err\n            }\n            fmt.Println(\"Regular Marshal, with no age:\", string(value))\n\n            if err := json.Unmarshal([]byte(fulljsonBlob), &e);\n            err != nil {\n                return err\n            }\n            fmt.Printf(\"Regular Unmarshal, with age = 0: %+v\\n\", e)\n\n            value, err = json.Marshal(&e)\n            if err != nil {\n                return err\n            }\n            fmt.Println(\"Regular Marshal, with age = 0:\", \n            string(value))\n\n            return nil\n        }\n```", "```go\n        package nulls\n\n        import (\n            \"encoding/json\"\n            \"fmt\"\n        )\n\n        // ExamplePointer is the same, but\n        // uses a *Int\n        type ExamplePointer struct {\n            Age *int `json:\"age,omitempty\"`\n            Name string `json:\"name\"`\n        }\n\n        // PointerEncoding shows methods for\n        // dealing with nil/omitted values\n        func PointerEncoding() error {\n\n            // note that no age = nil age\n            e := ExamplePointer{}\n            if err := json.Unmarshal([]byte(jsonBlob), &e); err != nil \n            {\n                return err\n            }\n            fmt.Printf(\"Pointer Unmarshal, no age: %+v\\n\", e)\n\n            value, err := json.Marshal(&e)\n            if err != nil {\n                return err\n            }\n            fmt.Println(\"Pointer Marshal, with no age:\", string(value))\n\n            if err := json.Unmarshal([]byte(fulljsonBlob), &e);\n            err != nil {\n                return err\n            }\n            fmt.Printf(\"Pointer Unmarshal, with age = 0: %+v\\n\", e)\n\n            value, err = json.Marshal(&e)\n            if err != nil {\n                return err\n            }\n            fmt.Println(\"Pointer Marshal, with age = 0:\",\n            string(value))\n\n            return nil\n        }\n```", "```go\n        package nulls\n\n        import (\n            \"database/sql\"\n            \"encoding/json\"\n            \"fmt\"\n        )\n\n        type nullInt64 sql.NullInt64\n\n        // ExampleNullInt is the same, but\n        // uses a sql.NullInt64\n        type ExampleNullInt struct {\n            Age *nullInt64 `json:\"age,omitempty\"`\n            Name string `json:\"name\"`\n        }\n\n        func (v *nullInt64) MarshalJSON() ([]byte, error) {\n            if v.Valid {\n                return json.Marshal(v.Int64)\n            }\n            return json.Marshal(nil)\n        }\n\n        func (v *nullInt64) UnmarshalJSON(b []byte) error {\n            v.Valid = false\n            if b != nil {\n                v.Valid = true\n                return json.Unmarshal(b, &v.Int64)\n            }\n            return nil\n        }\n\n        // NullEncoding shows an alternative method\n        // for dealing with nil/omitted values\n        func NullEncoding() error {\n            e := ExampleNullInt{}\n\n            // note that no means an invalid value\n            if err := json.Unmarshal([]byte(jsonBlob), &e); err != nil \n            {\n                return err\n            }\n            fmt.Printf(\"nullInt64 Unmarshal, no age: %+v\\n\", e)\n\n            value, err := json.Marshal(&e)\n            if err != nil {\n                return err\n            }\n            fmt.Println(\"nullInt64 Marshal, with no age:\",\n            string(value))\n\n            if err := json.Unmarshal([]byte(fulljsonBlob), &e);\n            err != nil {\n                return err\n            }\n            fmt.Printf(\"nullInt64 Unmarshal, with age = 0: %+v\\n\", e)\n\n            value, err = json.Marshal(&e)\n            if err != nil {\n                return err\n            }\n            fmt.Println(\"nullInt64 Marshal, with age = 0:\",\n            string(value))\n\n            return nil\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter3/nulls\"\n        )\n\n        func main() {\n            if err := nulls.BaseEncoding(); err != nil {\n                panic(err)\n            }\n            fmt.Println()\n\n            if err := nulls.PointerEncoding(); err != nil {\n                panic(err)\n            }\n            fmt.Println()\n\n            if err := nulls.NullEncoding(); err != nil {\n                panic(err)\n            }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nRegular Unmarshal, no age: {Age:0 Name:Aaron}\nRegular Marshal, with no age: {\"name\":\"Aaron\"}\nRegular Unmarshal, with age = 0: {Age:0 Name:Aaron}\nRegular Marshal, with age = 0: {\"name\":\"Aaron\"}\n\nPointer Unmarshal, no age: {Age:<nil> Name:Aaron}\nPointer Marshal, with no age: {\"name\":\"Aaron\"}\nPointer Unmarshal, with age = 0: {Age:0xc42000a610 Name:Aaron}\nPointer Marshal, with age = 0: {\"age\":0,\"name\":\"Aaron\"}\n\nnullInt64 Unmarshal, no age: {Age:<nil> Name:Aaron}\nnullInt64 Marshal, with no age: {\"name\":\"Aaron\"}\nnullInt64 Unmarshal, with age = 0: {Age:0xc42000a750 \nName:Aaron}\nnullInt64 Marshal, with age = 0: {\"age\":0,\"name\":\"Aaron\"}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/encoding \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/encoding    \n```", "```go\n        package encoding\n\n        import (\n            \"bytes\"\n            \"encoding/gob\"\n            \"fmt\"\n        )\n\n        // pos stores the x, y position\n        // for Object\n        type pos struct {\n            X      int\n            Y      int\n            Object string\n        }\n\n        // GobExample demonstrates using\n        // the gob package\n        func GobExample() error {\n            buffer := bytes.Buffer{}\n\n            p := pos{\n                X:      10,\n                Y:      15,\n                Object: \"wrench\",\n            }\n\n            // note that if p was an interface\n            // we'd have to call gob.Register first\n\n            e := gob.NewEncoder(&buffer)\n            if err := e.Encode(&p); err != nil {\n                return err\n            }\n\n            // note this is a binary format so it wont print well\n            fmt.Println(\"Gob Encoded valued length: \", \n            len(buffer.Bytes()))\n\n            p2 := pos{}\n            d := gob.NewDecoder(&buffer)\n            if err := d.Decode(&p2); err != nil {\n                return err\n            }\n\n            fmt.Println(\"Gob Decode value: \", p2)\n\n            return nil\n        }\n```", "```go\n        package encoding\n\n        import (\n            \"bytes\"\n            \"encoding/base64\"\n            \"fmt\"\n            \"io/ioutil\"\n        )\n\n        // Base64Example demonstrates using\n        // the base64 package\n        func Base64Example() error {\n            // base64 is useful for cases where\n            // you can't support binary formats\n            // it operates on bytes/strings\n\n            // using helper functions and URL encoding\n            value := base64.URLEncoding.EncodeToString([]byte(\"encoding \n            some data!\"))\n            fmt.Println(\"With EncodeToString and URLEncoding: \", value)\n\n            // decode the first value\n            decoded, err := base64.URLEncoding.DecodeString(value)\n            if err != nil {\n                return err\n            }\n            fmt.Println(\"With DecodeToString and URLEncoding: \", \n            string(decoded))\n\n            return nil\n        }\n\n        // Base64ExampleEncoder shows similar examples\n        // with encoders/decoders\n        func Base64ExampleEncoder() error {\n            // using encoder/ decoder\n            buffer := bytes.Buffer{}\n\n            // encode into the buffer\n            encoder := base64.NewEncoder(base64.StdEncoding, &buffer)\n\n            if _, err := encoder.Write([]byte(\"encoding some other \n            data\")); err != nil {\n                return err\n            }\n\n            // be sure to close\n            if err := encoder.Close(); err != nil {\n                return err\n            }\n\n            fmt.Println(\"Using encoder and StdEncoding: \", \n            buffer.String())\n\n            decoder := base64.NewDecoder(base64.StdEncoding, &buffer)\n            results, err := ioutil.ReadAll(decoder)\n            if err != nil {\n                return err\n            }\n\n            fmt.Println(\"Using decoder and StdEncoding: \", \n            string(results))\n\n            return nil\n        }\n```", "```go\n        package main\n\n        import (\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter3/encoding\"\n        )\n\n        func main() {\n            if err := encoding.Base64Example(); err != nil {\n                panic(err)\n            }\n\n            if err := encoding.Base64ExampleEncoder(); err != nil {\n                panic(err)\n            }\n\n            if err := encoding.GobExample(); err != nil {\n                panic(err)\n            }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nWith EncodeToString and URLEncoding: \nZW5jb2Rpbmcgc29tZSBkYXRhIQ==\nWith DecodeToString and URLEncoding: encoding some data!\nUsing encoder and StdEncoding: ZW5jb2Rpbmcgc29tZSBvdGhlciBkYXRh\nUsing decoder and StdEncoding: encoding some other data\nGob Encoded valued length: 57\nGob Decode value: {10 15 wrench}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/tags \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/tags    \n```", "```go\n        package tags\n\n        import \"reflect\"\n\n        // SerializeStructStrings converts a struct\n        // to our custom serialization format\n        // it honors serialize struct tags for string types\n        func SerializeStructStrings(s interface{}) (string, error) {\n            result := \"\"\n\n            // reflect the interface into\n            // a type\n            r := reflect.TypeOf(s)\n            value := reflect.ValueOf(s)\n\n            // if a pointer to a struct is passed\n            // in, handle it appropriately\n            if r.Kind() == reflect.Ptr {\n                r = r.Elem()\n                value = value.Elem()\n            }\n\n            // loop over all of the fields\n            for i := 0; i < r.NumField(); i++ {\n                field := r.Field(i)\n                // struct tag found\n                key := field.Name\n                if serialize, ok := field.Tag.Lookup(\"serialize\"); ok {\n                    // ignore \"-\" otherwise that whole value\n                    // becomes the serialize 'key'\n                    if serialize == \"-\" {\n                        continue\n                    }\n                    key = serialize\n                }\n\n                switch value.Field(i).Kind() {\n                // this recipe only supports strings!\n                case reflect.String:\n                    result += key + \":\" + value.Field(i).String() + \";\"\n                    // by default skip it\n                default:\n                    continue\n               }\n            }\n            return result, nil\n        }\n```", "```go\n        package tags\n\n        import (\n            \"errors\"\n            \"reflect\"\n            \"strings\"\n        )\n\n        // DeSerializeStructStrings converts a serialized\n        // string using our custom serialization format\n        // to a struct\n        func DeSerializeStructStrings(s string, res interface{}) error          \n        {\n            r := reflect.TypeOf(res)\n\n            // we're setting using a pointer so\n            // it must always be a pointer passed\n            // in\n            if r.Kind() != reflect.Ptr {\n                return errors.New(\"res must be a pointer\")\n            }\n\n            // dereference the pointer\n            r = r.Elem()\n            value := reflect.ValueOf(res).Elem()\n\n            // split our serialization string into\n            // a map\n            vals := strings.Split(s, \";\")\n            valMap := make(map[string]string)\n            for _, v := range vals {\n                keyval := strings.Split(v, \":\")\n                if len(keyval) != 2 {\n                    continue\n                }\n                valMap[keyval[0]] = keyval[1]\n            }\n\n            // iterate over fields\n            for i := 0; i < r.NumField(); i++ {\n                field := r.Field(i)\n\n               // check if in the serialize set\n               if serialize, ok := field.Tag.Lookup(\"serialize\"); ok {\n                   // ignore \"-\" otherwise that whole value\n                   // becomes the serialize 'key'\n                   if serialize == \"-\" {\n                       continue\n                   }\n                   // is it in the map\n                   if val, ok := valMap[serialize]; ok {\n                       value.Field(i).SetString(val)\n                   }\n               } else if val, ok := valMap[field.Name]; ok {\n                   // is our field name in the map instead?\n                   value.Field(i).SetString(val)\n               }\n            }\n            return nil\n        }\n```", "```go\n        package tags\n\n        import \"fmt\"\n\n        // Person is a struct that stores a persons\n        // name, city, state, and a misc attribute\n        type Person struct {\n            Name string `serialize:\"name\"`\n            City string `serialize:\"city\"`\n            State string\n             Misc string `serialize:\"-\"`\n             Year int `serialize:\"year\"`\n        }\n\n        // EmptyStruct demonstrates serialize\n        // and deserialize for an Empty struct\n        // with tags\n        func EmptyStruct() error {\n            p := Person{}\n\n            res, err := SerializeStructStrings(&p)\n            if err != nil {\n                return err\n            }\n            fmt.Printf(\"Empty struct: %#v\\n\", p)\n            fmt.Println(\"Serialize Results:\", res)\n\n            newP := Person{}\n            if err := DeSerializeStructStrings(res, &newP); err != nil \n            {\n                return err\n            }\n            fmt.Printf(\"Deserialize results: %#v\\n\", newP)\n                return nil\n            }\n\n           // FullStruct demonstrates serialize\n           // and deserialize for an Full struct\n           // with tags\n           func FullStruct() error {\n               p := Person{\n                   Name: \"Aaron\",\n                   City: \"Seattle\",\n                   State: \"WA\",\n                   Misc: \"some fact\",\n                   Year: 2017,\n               }\n               res, err := SerializeStructStrings(&p)\n               if err != nil {\n                   return err\n               }\n               fmt.Printf(\"Full struct: %#v\\n\", p)\n               fmt.Println(\"Serialize Results:\", res)\n\n               newP := Person{}\n               if err := DeSerializeStructStrings(res, &newP);\n               err != nil {\n                   return err\n               }\n               fmt.Printf(\"Deserialize results: %#v\\n\", newP)\n               return nil\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter3/tags\"\n        )\n\n        func main() {\n\n            if err := tags.EmptyStruct(); err != nil {\n                panic(err)\n            }\n\n            fmt.Println()\n\n            if err := tags.FullStruct(); err != nil {\n                panic(err)\n            }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nEmpty struct: tags.Person{Name:\"\", City:\"\", State:\"\", Misc:\"\", \nYear:0}\nSerialize Results: name:;city:;State:;\nDeserialize results: tags.Person{Name:\"\", City:\"\", State:\"\", \nMisc:\"\", Year:0}\n\nFull struct: tags.Person{Name:\"Aaron\", City:\"Seattle\", \nState:\"WA\", Misc:\"some fact\", Year:2017}\nSerialize Results: name:Aaron;city:Seattle;State:WA;\nDeserialize results: tags.Person{Name:\"Aaron\", City:\"Seattle\",         \nState:\"WA\", Misc:\"\", Year:0}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/collections \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter3/collections    \n```", "```go\n        package collections\n\n        // WorkWith is the struct we'll\n        // be implementing collections for\n        type WorkWith struct {\n            Data    string\n            Version int\n        }\n\n        // Filter is a functional filter. It takes a list of\n        // WorkWith and a WorkWith Function that returns a bool\n        // for each \"true\" element we return it to the resultant\n        // list\n        func Filter(ws []WorkWith, f func(w WorkWith) bool) []WorkWith \n        {\n            // depending on results, smalles size for result\n            // is len == 0\n            result := make([]WorkWith, 0)\n            for _, w := range ws {\n                if f(w) {\n                    result = append(result, w)\n                }\n            }\n            return result\n        }\n\n        // Map is a functional map. It takes a list of\n        // WorkWith and a WorkWith Function that takes a WorkWith\n        // and returns a modified WorkWith. The end result is\n        // a list of modified WorkWiths\n        func Map(ws []WorkWith, f func(w WorkWith) WorkWith) []WorkWith \n        {\n            // the result should always be the same\n            // length\n            result := make([]WorkWith, len(ws))\n\n            for pos, w := range ws {\n                newW := f(w)\n                result[pos] = newW\n            }\n            return result\n        }\n```", "```go\n        package collections\n\n        import \"strings\"\n\n        // LowerCaseData does a ToLower to the\n        // Data string of a WorkWith\n        func LowerCaseData(w WorkWith) WorkWith {\n            w.Data = strings.ToLower(w.Data)\n            return w\n        }\n\n        // IncrementVersion increments a WorkWiths\n        // Version\n        func IncrementVersion(w WorkWith) WorkWith {\n            w.Version++\n            return w\n        }\n\n        // OldVersion returns a closures\n        // that validates the version is greater than\n        // the specified amount\n        func OldVersion(v int) func(w WorkWith) bool {\n            return func(w WorkWith) bool {\n                return w.Version >= v\n            }\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter3/collections\"\n        )\n\n        func main() {\n            ws := []collections.WorkWith{\n                collections.WorkWith{\"Example\", 1},\n                collections.WorkWith{\"Example 2\", 2},\n            }\n\n            fmt.Printf(\"Initial list: %#v\\n\", ws)\n\n            // first lower case the list\n            ws = collections.Map(ws, collections.LowerCaseData)\n            fmt.Printf(\"After LowerCaseData Map: %#v\\n\", ws)\n\n            // next increment all versions\n            ws = collections.Map(ws, collections.IncrementVersion)\n            fmt.Printf(\"After IncrementVersion Map: %#v\\n\", ws)\n\n            // lastly remove all versions older than 3\n            ws = collections.Filter(ws, collections.OldVersion(3))\n            fmt.Printf(\"After OldVersion Filter: %#v\\n\", ws)\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nInitial list:         \n[]collections.WorkWith{collections.WorkWith{Data:\"Example\", \nVersion:1}, collections.WorkWith{Data:\"Example 2\", Version:2}}\nAfter LowerCaseData Map:         \n[]collections.WorkWith{collections.WorkWith{Data:\"example\", \nVersion:1}, collections.WorkWith{Data:\"example 2\", Version:2}}\nAfter IncrementVersion Map: \n[]collections.WorkWith{collections.WorkWith{Data:\"example\", \nVersion:2}, collections.WorkWith{Data:\"example 2\", Version:3}}\nAfter OldVersion Filter: \n[]collections.WorkWith{collections.WorkWith{Data:\"example 2\",        \nVersion:3}}\n```"]