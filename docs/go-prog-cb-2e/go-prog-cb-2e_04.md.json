["```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\ntype Error interface{\n  Error() string\n}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/basicerrors \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/basicerrors    \n```", "```go\npackage basicerrors\n\nimport (\n  \"errors\"\n  \"fmt\"\n)\n\n// ErrorValue is a way to make a package level\n// error to check against. I.e. if err == ErrorValue\nvar ErrorValue = errors.New(\"this is a typed error\")\n\n// TypedError is a way to make an error type\n// you can do err.(type) == ErrorValue\ntype TypedError struct {\n  error\n}\n\n//BasicErrors demonstrates some ways to create errors\nfunc BasicErrors() {\n  err := errors.New(\"this is a quick and easy way to create an error\")\n  fmt.Println(\"errors.New: \", err)\n\n  err = fmt.Errorf(\"an error occurred: %s\", \"something\")\n  fmt.Println(\"fmt.Errorf: \", err)\n\n  err = ErrorValue\n  fmt.Println(\"value error: \", err)\n\n  err = TypedError{errors.New(\"typed error\")}\n  fmt.Println(\"typed error: \", err)\n\n}\n```", "```go\npackage basicerrors\n\nimport (\n  \"fmt\"\n)\n\n// CustomError is a struct that will implement\n// the Error() interface\ntype CustomError struct {\n  Result string\n}\n\nfunc (c CustomError) Error() string {\n  return fmt.Sprintf(\"there was an error; %s was the result\", c.Result)\n}\n\n// SomeFunc returns an error\nfunc SomeFunc() error {\n  c := CustomError{Result: \"this\"}\n  return c\n}\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter4/basicerrors\"\n        )\n\n        func main() {\n            basicerrors.BasicErrors()\n\n            err := basicerrors.SomeFunc()\n            fmt.Println(\"custom error: \", err)\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nerrors.New: this is a quick and easy way to create an error\nfmt.Errorf: an error occurred: something\ntyped error: this is a typed error\ncustom error: there was an error; this was the result\n```", "```go\n// this wont work if you wrapped it \n// in a standard way. that is,\n// fmt.Errorf(\"custom error: %s\", err.Error())\nif err == Package.ErrorNamed{\n  //handle this error in a specific way\n}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/errwrap \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/errwrap    \n```", "```go\n        package errwrap\n\n        import (\n            \"fmt\"\n\n            \"github.com/pkg/errors\"\n        )\n\n        // WrappedError demonstrates error wrapping and\n        // annotating an error\n        func WrappedError(e error) error {\n            return errors.Wrap(e, \"An error occurred in WrappedError\")\n        }\n\n        // ErrorTyped is a error we can check against\n        type ErrorTyped struct{\n            error\n        }\n\n        // Wrap shows what happens when we wrap an error\n        func Wrap() {\n            e := errors.New(\"standard error\")\n\n            fmt.Println(\"Regular Error - \", WrappedError(e))\n\n            fmt.Println(\"Typed Error - \", \n            WrappedError(ErrorTyped{errors.New(\"typed error\")}))\n\n            fmt.Println(\"Nil -\", WrappedError(nil))\n\n        }\n```", "```go\n        package errwrap\n\n        import (\n            \"fmt\"\n\n            \"github.com/pkg/errors\"\n        )\n\n        // Unwrap will unwrap an error and do\n        // type assertion to it\n        func Unwrap() {\n\n            err := error(ErrorTyped{errors.New(\"an error occurred\")})\n            err = errors.Wrap(err, \"wrapped\")\n\n            fmt.Println(\"wrapped error: \", err)\n\n            // we can handle many error types\n            switch errors.Cause(err).(type) {\n            case ErrorTyped:\n                fmt.Println(\"a typed error occurred: \", err)\n            default:\n                fmt.Println(\"an unknown error occurred\")\n            }\n        }\n\n        // StackTrace will print all the stack for\n        // the error\n        func StackTrace() {\n            err := error(ErrorTyped{errors.New(\"an error occurred\")})\n            err = errors.Wrap(err, \"wrapped\")\n\n            fmt.Printf(\"%+v\\n\", err)\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter4/errwrap\"\n        )\n\n        func main() {\n            errwrap.Wrap()\n            fmt.Println()\n            errwrap.Unwrap()\n            fmt.Println()\n            errwrap.StackTrace()\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nRegular Error - An error occurred in WrappedError: standard \nerror\nTyped Error - An error occurred in WrappedError: typed error\nNil - <nil>\n\nwrapped error: wrapped: an error occurred\na typed error occurred: wrapped: an error occurred\n\nan error occurred\ngithub.com/PacktPublishing/Go-Programming-Cookbook-Second- \nEdition/chapter4/errwrap.StackTrace\n/Users/lothamer/go/src/github.com/agtorre/go-\ncookbook/chapter4/errwrap/unwrap.go:30\nmain.main\n/tmp/go/src/github.com/agtorre/go-\ncookbook/chapter4/errwrap/example/main.go:14\n```", "```go\nfunc RetError() error{\n err := ThisReturnsAnError()\n return errors.Wrap(err, \"This only does something if err != nil\")\n}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/log \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/log    \n```", "```go\n        package log\n\n        import (\n            \"bytes\"\n            \"fmt\"\n            \"log\"\n        )\n\n        // Log uses the setup logger\n        func Log() {\n            // we'll configure the logger to write\n            // to a bytes.Buffer\n            buf := bytes.Buffer{}\n\n            // second argument is the prefix last argument is about \n            // options you combine them with a logical or.\n            logger := log.New(&buf, \"logger: \",\n            log.Lshortfile|log.Ldate)\n\n            logger.Println(\"test\")\n\n            logger.SetPrefix(\"new logger: \")\n\n            logger.Printf(\"you can also add args(%v) and use Fatalln to \n            log and crash\", true)\n\n            fmt.Println(buf.String())\n        }\n```", "```go\n        package log\n\n        import \"github.com/pkg/errors\"\n        import \"log\"\n\n        // OriginalError returns the error original error\n        func OriginalError() error {\n            return errors.New(\"error occurred\")\n        }\n\n        // PassThroughError calls OriginalError and\n        // forwards the error along after wrapping.\n        func PassThroughError() error {\n            err := OriginalError()\n            // no need to check error\n            // since this works with nil\n            return errors.Wrap(err, \"in passthrougherror\")\n        }\n\n        // FinalDestination deals with the error\n        // and doesn't forward it\n        func FinalDestination() {\n            err := PassThroughError()\n            if err != nil {\n                // we log because an unexpected error occurred!\n               log.Printf(\"an error occurred: %s\\n\", err.Error())\n               return\n            }\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter4/log\"\n        )\n\n        func main() {\n            fmt.Println(\"basic logging and modification of logger:\")\n            log.Log()\n            fmt.Println(\"logging 'handled' errors:\")\n            log.FinalDestination()\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nbasic logging and modification of logger:\nlogger: 2017/02/05 log.go:19: test\nnew logger: 2017/02/05 log.go:23: you can also add args(true) \nand use Fataln to log and crash\n\nlogging 'handled' errors:\n2017/02/05 18:36:11 an error occurred: in passthrougherror: \nerror occurred\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/structured \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/structured    \n```", "```go\n        package structured\n\n        import \"github.com/sirupsen/logrus\"\n\n        // Hook will implement the logrus\n        // hook interface\n        type Hook struct {\n            id string\n        }\n\n        // Fire will trigger whenever you log\n        func (hook *Hook) Fire(entry *logrus.Entry) error {\n            entry.Data[\"id\"] = hook.id\n            return nil\n        }\n\n        // Levels is what levels this hook will fire on\n        func (hook *Hook) Levels() []logrus.Level {\n            return logrus.AllLevels\n        }\n\n        // Logrus demonstrates some basic logrus functionality\n        func Logrus() {\n            // we're emitting in json format\n            logrus.SetFormatter(&logrus.TextFormatter{})\n            logrus.SetLevel(logrus.InfoLevel)\n            logrus.AddHook(&Hook{\"123\"})\n\n            fields := logrus.Fields{}\n            fields[\"success\"] = true\n            fields[\"complex_struct\"] = struct {\n                Event string\n                When string\n            }{\"Something happened\", \"Just now\"}\n\n            x := logrus.WithFields(fields)\n            x.Warn(\"warning!\")\n            x.Error(\"error!\")\n        }\n```", "```go\n        package structured\n\n        import (\n            \"errors\"\n            \"os\"\n\n            \"github.com/apex/log\"\n            \"github.com/apex/log/handlers/text\"\n        )\n\n        // ThrowError throws an error that we'll trace\n        func ThrowError() error {\n            err := errors.New(\"a crazy failure\")\n            log.WithField(\"id\", \"123\").Trace(\"ThrowError\").Stop(&err)\n            return err\n        }\n\n        // CustomHandler splits to two streams\n        type CustomHandler struct {\n            id string\n            handler log.Handler\n        }\n\n        // HandleLog adds a hook and does the emitting\n        func (h *CustomHandler) HandleLog(e *log.Entry) error {\n            e.WithField(\"id\", h.id)\n            return h.handler.HandleLog(e)\n        }\n\n        // Apex has a number of useful tricks\n        func Apex() {\n            log.SetHandler(&CustomHandler{\"123\", text.New(os.Stdout)})\n            err := ThrowError()\n\n            //With error convenience function\n            log.WithError(err).Error(\"an error occurred\")\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter4/structured\"\n        )\n\n        func main() {\n            fmt.Println(\"Logrus:\")\n            structured.Logrus()\n\n            fmt.Println()\n            fmt.Println(\"Apex:\")\n            structured.Apex()\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nLogrus:\nWARN[0000] warning! complex_struct={Something happened Just now} \nid=123 success=true\nERRO[0000] error! complex_struct={Something happened Just now} \nid=123 success=true\n\nApex:\nINFO[0000] ThrowError id=123\nERROR[0000] ThrowError duration=133ns error=a crazy failure \nid=123\nERROR[0000] an error occurred error=a crazy failure\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/context \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/context    \n```", "```go\n        package context\n\n        import (\n            \"context\"\n\n            \"github.com/apex/log\"\n        )\n\n        type key int\n\n        // logFields is a key we use\n        // for our context logging\n        const logFields key = 0\n\n        func getFields(ctx context.Context) *log.Fields {\n            fields, ok := ctx.Value(logFields).(*log.Fields)\n            if !ok {\n                f := make(log.Fields)\n                fields = &f\n            }\n            return fields\n        }\n\n        // FromContext takes an entry and a context\n        // then returns an entry populated from the context object\n        func FromContext(ctx context.Context, l log.Interface) \n        (context.Context, *log.Entry) {\n            fields := getFields(ctx)\n            e := l.WithFields(fields)\n            ctx = context.WithValue(ctx, logFields, fields)\n            return ctx, e\n        }\n\n        // WithField adds a log field to the context\n        func WithField(ctx context.Context, key string, value \n           interface{}) context.Context {\n               return WithFields(ctx, log.Fields{key: value})\n        }\n\n        // WithFields adds many log fields to the context\n        func WithFields(ctx context.Context, fields log.Fielder) \n        context.Context {\n            f := getFields(ctx)\n            for key, val := range fields.Fields() {\n                (*f)[key] = val\n            }\n            ctx = context.WithValue(ctx, logFields, f)\n            return ctx\n        }\n```", "```go\n        package context\n\n        import (\n            \"context\"\n            \"os\"\n\n            \"github.com/apex/log\"\n            \"github.com/apex/log/handlers/text\"\n        )\n\n        // Initialize calls 3 functions to set up, then\n        // logs before terminating\n        func Initialize() {\n            // set basic log up\n            log.SetHandler(text.New(os.Stdout))\n            // initialize our context\n            ctx := context.Background()\n            // create a logger and link it to\n            // the context\n            ctx, e := FromContext(ctx, log.Log)\n\n            // set a field\n            ctx = WithField(ctx, \"id\", \"123\")\n            e.Info(\"starting\")\n            gatherName(ctx)\n            e.Info(\"after gatherName\")\n            gatherLocation(ctx)\n            e.Info(\"after gatherLocation\")\n           }\n\n           func gatherName(ctx context.Context) {\n               ctx = WithField(ctx, \"name\", \"Go Cookbook\")\n           }\n\n           func gatherLocation(ctx context.Context) {\n               ctx = WithFields(ctx, log.Fields{\"city\": \"Seattle\", \n               \"state\": \"WA\"})\n        }\n```", "```go\n        package main\n\n        import \"github.com/PacktPublishing/\n                Go-Programming-Cookbook-Second-Edition/\n                chapter4/context\"\n\n        func main() {\n            context.Initialize()\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nINFO[0000] starting id=123\nINFO[0000] after gatherName id=123 name=Go Cookbook\nINFO[0000] after gatherLocation city=Seattle id=123 name=Go \nCookbook state=WA\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/global \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/global    \n```", "```go\n        package global\n\n        import (\n            \"errors\"\n            \"os\"\n            \"sync\"\n\n            \"github.com/sirupsen/logrus\"\n        )\n\n        // we make our global package level\n        // variable lower case\n        var (\n            log *logrus.Logger\n            initLog sync.Once\n        )\n\n        // Init sets up the logger initially\n        // if run multiple times, it returns\n        // an error\n        func Init() error {\n            err := errors.New(\"already initialized\")\n            initLog.Do(func() {\n                err = nil\n                log = logrus.New()\n                log.Formatter = &logrus.JSONFormatter{}\n                log.Out = os.Stdout\n                log.Level = logrus.DebugLevel\n            })\n            return err\n        }\n\n        // SetLog sets the log\n        func SetLog(l *logrus.Logger) {\n            log = l\n        }\n\n        // WithField exports the logs withfield connected\n        // to our global log\n        func WithField(key string, value interface{}) *logrus.Entry {\n            return log.WithField(key, value)\n        }\n\n        // Debug exports the logs Debug connected\n        // to our global log\n        func Debug(args ...interface{}) {\n            log.Debug(args...)\n        }\n```", "```go\n        package global\n\n        // UseLog demonstrates using our global\n        // log\n        func UseLog() error {\n            if err := Init(); err != nil {\n               return err\n         }\n\n         // if we were in another package these would be\n         // global.WithField and\n         // global.Debug\n         WithField(\"key\", \"value\").Debug(\"hello\")\n         Debug(\"test\")\n\n         return nil\n        }\n```", "```go\n        package main\n\n        import \"github.com/PacktPublishing/\n                Go-Programming-Cookbook-Second-Edition/\n                chapter4/global\"\n\n        func main() {\n            if err := global.UseLog(); err != nil {\n                panic(err)\n            }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\n{\"key\":\"value\",\"level\":\"debug\",\"msg\":\"hello\",\"time\":\"2017-02-\n12T19:22:50-08:00\"}\n{\"level\":\"debug\",\"msg\":\"test\",\"time\":\"2017-02-12T19:22:50-\n08:00\"}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/panic \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter4/panic    \n```", "```go\n        package panic\n\n        import (\n            \"fmt\"\n            \"strconv\"\n        )\n\n        // Panic panics with a divide by zero\n        func Panic() {\n            zero, err := strconv.ParseInt(\"0\", 10, 64)\n            if err != nil {\n                panic(err)\n            }\n\n            a := 1 / zero\n            fmt.Println(\"we'll never get here\", a)\n        }\n\n        // Catcher calls Panic\n        func Catcher() {\n            defer func() {\n                if r := recover(); r != nil {\n                    fmt.Println(\"panic occurred:\", r)\n                }\n            }()\n            Panic()\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter4/panic\"\n        )\n\n        func main() {\n            fmt.Println(\"before panic\")\n            panic.Catcher()\n            fmt.Println(\"after panic\")\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nbefore panic\npanic occurred: runtime error: integer divide by zero\nafter panic\n```"]