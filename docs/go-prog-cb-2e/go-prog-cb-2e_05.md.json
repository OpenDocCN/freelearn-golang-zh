["```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/tcp \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/tcp    \n```", "```go\npackage main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"net\"\n  \"strings\"\n)\n\nconst addr = \"localhost:8888\"\n\nfunc echoBackCapitalized(conn net.Conn) {\n  // set up a reader on conn (an io.Reader)\n  reader := bufio.NewReader(conn)\n\n  // grab the first line of data encountered\n  data, err := reader.ReadString('\\n')\n  if err != nil {\n    fmt.Printf(\"error reading data: %s\\n\", err.Error())\n    return\n  }\n  // print then send back the data\n  fmt.Printf(\"Received: %s\", data)\n  conn.Write([]byte(strings.ToUpper(data)))\n  // close up the finished connection\n  conn.Close()\n}\n\nfunc main() {\n  ln, err := net.Listen(\"tcp\", addr)\n  if err != nil {\n    panic(err)\n  }\n  defer ln.Close()\n  fmt.Printf(\"listening on: %s\\n\", addr)\n  for {\n    conn, err := ln.Accept()\n    if err != nil {\n      fmt.Printf(\"encountered an error accepting connection: %s\\n\", \n                  err.Error())\n      // if there's an error try again\n      continue\n    }\n    // handle this asynchronously\n    // potentially a good use-case\n    // for a worker pool\n    go echoBackCapitalized(conn)\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"net\"\n  \"os\"\n)\n\nconst addr = \"localhost:8888\"\n\nfunc main() {\n  reader := bufio.NewReader(os.Stdin)\n  for {\n    // grab a string input from the clie\n    fmt.Printf(\"Enter some text: \")\n    data, err := reader.ReadString('\\n')\n    if err != nil {\n      fmt.Printf(\"encountered an error reading input: %s\\n\", \n                  err.Error())\n      continue\n    }\n    // connect to the addr\n    conn, err := net.Dial(\"tcp\", addr)\n    if err != nil {\n      fmt.Printf(\"encountered an error connecting: %s\\n\", \n                  err.Error())\n    }\n\n    // write the data to the connection\n    fmt.Fprintf(conn, data)\n\n    // read back the response\n    status, err := bufio.NewReader(conn).ReadString('\\n')\n    if err != nil {\n      fmt.Printf(\"encountered an error reading response: %s\\n\", \n                  err.Error())\n    }\n    fmt.Printf(\"Received back: %s\", status)\n    // close up the finished connection\n    conn.Close()\n  }\n}\n```", "```go\n$ go run ./server\nlistening on: localhost:8888\n```", "```go\n$ go run ./client \nEnter some text:\n```", "```go\n$ go run ./client \nEnter some text: this is a test\nReceived back: THIS IS A TEST\nEnter some text: \n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/udp \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/udp    \n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"net\"\n  \"sync\"\n  \"time\"\n)\n\ntype connections struct {\n  addrs map[string]*net.UDPAddr\n  // lock for modifying the map\n  mu sync.Mutex\n}\n\nfunc broadcast(conn *net.UDPConn, conns *connections) {\n  count := 0\n  for {\n    count++\n    conns.mu.Lock()\n    // loop over known addresses\n    for _, retAddr := range conns.addrs {\n\n      // send a message to them all\n      msg := fmt.Sprintf(\"Sent %d\", count)\n      if _, err := conn.WriteToUDP([]byte(msg), retAddr); err != nil {\n        fmt.Printf(\"error encountered: %s\", err.Error())\n        continue\n      }\n\n    }\n    conns.mu.Unlock()\n    time.Sleep(1 * time.Second)\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"net\"\n)\n\nconst addr = \"localhost:8888\"\n\nfunc main() {\n  conns := &connections{\n    addrs: make(map[string]*net.UDPAddr),\n  }\n\n  fmt.Printf(\"serving on %s\\n\", addr)\n\n  // construct a udp addr\n  addr, err := net.ResolveUDPAddr(\"udp\", addr)\n  if err != nil {\n    panic(err)\n  }\n\n  // listen on our specified addr\n  conn, err := net.ListenUDP(\"udp\", addr)\n  if err != nil {\n    panic(err)\n  }\n  // cleanup\n  defer conn.Close()\n\n  // async send messages to all known clients\n  go broadcast(conn, conns)\n\n  msg := make([]byte, 1024)\n  for {\n    // receive a message to gather the ip address\n    // and port to send back to\n    _, retAddr, err := conn.ReadFromUDP(msg)\n    if err != nil {\n      continue\n    }\n\n    //store it in a map\n    conns.mu.Lock()\n    conns.addrs[retAddr.String()] = retAddr\n    conns.mu.Unlock()\n    fmt.Printf(\"%s connected\\n\", retAddr)\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"net\"\n)\n\nconst addr = \"localhost:8888\"\n\nfunc main() {\n  fmt.Printf(\"client for server url: %s\\n\", addr)\n\n  addr, err := net.ResolveUDPAddr(\"udp\", addr)\n  if err != nil {\n    panic(err)\n  }\n\n  conn, err := net.DialUDP(\"udp\", nil, addr)\n  if err != nil {\n    panic(err)\n  }\n  defer conn.Close()\n\n  msg := make([]byte, 512)\n  n, err := conn.Write([]byte(\"connected\"))\n  if err != nil {\n    panic(err)\n  }\n  for {\n    n, err = conn.Read(msg)\n    if err != nil {\n      continue\n    }\n    fmt.Printf(\"%s\\n\", string(msg[:n]))\n  }\n}\n```", "```go\n$ go run ./server\nserving on localhost:8888\n```", "```go\n$ go run ./client \nclient for server url: localhost:8888\nSent 3\nSent 4\nSent 5\n```", "```go\n$ go run ./server \nserving on localhost:8888\n127.0.0.1:64242 connected\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/dns \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/dns\n```", "```go\npackage dns\n\nimport (\n  \"fmt\"\n  \"net\"\n\n  \"github.com/pkg/errors\"\n)\n\n// Lookup holds the DNS information we care about\ntype Lookup struct {\n  cname string\n  hosts []string\n}\n\n// We can use this to print the lookup object\nfunc (d *Lookup) String() string {\n  result := \"\"\n  for _, host := range d.hosts {\n    result += fmt.Sprintf(\"%s IN A %s\\n\", d.cname, host)\n  }\n  return result\n}\n\n// LookupAddress returns a DNSLookup consisting of a cname and host\n// for a given address\nfunc LookupAddress(address string) (*Lookup, error) {\n  cname, err := net.LookupCNAME(address)\n  if err != nil {\n    return nil, errors.Wrap(err, \"error looking up CNAME\")\n  }\n  hosts, err := net.LookupHost(address)\n  if err != nil {\n    return nil, errors.Wrap(err, \"error looking up HOST\")\n  }\n\n  return &Lookup{cname: cname, hosts: hosts}, nil\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  \"github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/dns\"\n)\n\nfunc main() {\n  if len(os.Args) < 2 {\n    fmt.Printf(\"Usage: %s <address>\\n\", os.Args[0])\n    os.Exit(1)\n  }\n  address := os.Args[1]\n  lookup, err := dns.LookupAddress(address)\n  if err != nil {\n    log.Panicf(\"failed to lookup: %s\", err.Error())\n  }\n  fmt.Println(lookup)\n}\n```", "```go\n$ go build $ ./example golang.org\n```", "```go\n$ go run main.go golang.org\ngolang.org. IN A 172.217.5.17\ngolang.org. IN A 2607:f8b0:4009:809::2011\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/websocket \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/websocket    \n```", "```go\npackage main\n\nimport (\n  \"log\"\n  \"net/http\"\n\n  \"github.com/gorilla/websocket\"\n)\n\n// upgrader takes an http connection and converts it\n// to a websocket one, we're using some recommended\n// basic buffer sizes\nvar upgrader = websocket.Upgrader{\n  ReadBufferSize: 1024,\n  WriteBufferSize: 1024,\n}\n\nfunc wsHandler(w http.ResponseWriter, r *http.Request) {\n  // upgrade the connection\n  conn, err := upgrader.Upgrade(w, r, nil)\n  if err != nil {\n    log.Println(\"failed to upgrade connection: \", err)\n    return\n  }\n  for {\n    // read and echo back messages in a loop\n    messageType, p, err := conn.ReadMessage()\n    if err != nil {\n      log.Println(\"failed to read message: \", err)\n      return\n    }\n    log.Printf(\"received from client: %#v\", string(p))\n    if err := conn.WriteMessage(messageType, p); err != nil {\n      log.Println(\"failed to write message: \", err)\n      return\n    }\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n)\n\nfunc main() {\n  fmt.Println(\"Listening on port :8000\")\n // we mount our single handler on port localhost:8000 to handle all\n  // requests\n  log.Panic(http.ListenAndServe(\"localhost:8000\", http.HandlerFunc(wsHandler)))\n}\n```", "```go\npackage main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"log\"\n  \"os\"\n  \"strings\"\n\n  \"github.com/gorilla/websocket\"\n)\n\nfunc process(c *websocket.Conn) {\n  reader := bufio.NewReader(os.Stdin)\n  for {\n    fmt.Printf(\"Enter some text: \")\n    // this will block ctrl-c, to exit press it then hit enter\n    // or kill from another location\n    data, err := reader.ReadString('\\n')\n    if err != nil {\n      log.Println(\"failed to read stdin\", err)\n    }\n\n    // trim off the space from reading the string\n    data = strings.TrimSpace(data)\n\n    // write the message as a byte across the websocket\n    err = c.WriteMessage(websocket.TextMessage, []byte(data))\n    if err != nil {\n      log.Println(\"failed to write message:\", err)\n      return\n    }\n\n    // this is an echo server, so we can always read after the write\n    _, message, err := c.ReadMessage()\n    if err != nil {\n      log.Println(\"failed to read:\", err)\n      return\n    }\n    log.Printf(\"received back from server: %#v\\n\", string(message))\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"log\"\n  \"os\"\n  \"os/signal\"\n\n  \"github.com/gorilla/websocket\"\n)\n\n// catchSig cleans up our websocket conenction if we kill the program\n// with a ctrl-c\nfunc catchSig(ch chan os.Signal, c *websocket.Conn) {\n  // block on waiting for a signal\n  <-ch\n  err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n  if err != nil {\n    log.Println(\"write close:\", err)\n  }\n  return\n}\n\nfunc main() {\n  // connect the os signal to our channel\n  interrupt := make(chan os.Signal, 1)\n  signal.Notify(interrupt, os.Interrupt)\n\n  // use the ws:// Scheme to connect to the websocket\n  u := \"ws://localhost:8000/\"\n  log.Printf(\"connecting to %s\", u)\n\n  c, _, err := websocket.DefaultDialer.Dial(u, nil)\n  if err != nil {\n    log.Fatal(\"dial:\", err)\n  }\n  defer c.Close()\n\n  // dispatch our signal catcher\n  go catchSig(interrupt, c)\n\n  process(c)\n}\n```", "```go\n$ go run ./server\nListening on port :8000\n```", "```go\n$ go run ./client\n2019/05/26 11:53:20 connecting to ws://localhost:8000/\nEnter some text: \n```", "```go\n$ go run ./client\n2019/05/26 11:53:20 connecting to ws://localhost:8000/\nEnter some text: test\n2019/05/26 11:53:22 received back from server: \"test\"\nEnter some text: \n```", "```go\n$ go run ./server\nListening on port :8000\n2019/05/26 11:53:22 received from client: \"test\"\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/rpc \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/rpc    \n```", "```go\npackage tweak\n\nimport (\n  \"strings\"\n)\n\n// StringTweaker is a type of string\n// that can reverse itself\ntype StringTweaker struct{}\n\n// Args are a list of options for how to tweak\n// the string\ntype Args struct {\n  String string\n  ToUpper bool\n  Reverse bool\n}\n\n// Tweak conforms to the RPC library which require:\n// - the method's type is exported.\n// - the method is exported.\n// - the method has two arguments, both exported (or builtin) types.\n// - the method's second argument is a pointer.\n// - the method has return type error.\nfunc (s StringTweaker) Tweak(args *Args, resp *string) error {\n\n  result := string(args.String)\n  if args.ToUpper {\n    result = strings.ToUpper(result)\n  }\n  if args.Reverse {\n    runes := []rune(result)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n      runes[i], runes[j] = runes[j], runes[i]\n    }\n    result = string(runes)\n\n  }\n  *resp = result\n  return nil\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"net\"\n  \"net/http\"\n  \"net/rpc\"\n\n  \"github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/rpc/tweak\"\n)\n\nfunc main() {\n  s := new(tweak.StringTweaker)\n  if err := rpc.Register(s); err != nil {\n    log.Fatal(\"failed to register:\", err)\n  }\n\n  rpc.HandleHTTP()\n\n  l, err := net.Listen(\"tcp\", \":1234\")\n  if err != nil {\n    log.Fatal(\"listen error:\", err)\n  }\n\n  fmt.Println(\"listening on :1234\")\n  log.Panic(http.Serve(l, nil))\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"net/rpc\"\n\n  \"github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/rpc/tweak\"\n)\n\nfunc main() {\n  client, err := rpc.DialHTTP(\"tcp\", \"localhost:1234\")\n  if err != nil {\n    log.Fatal(\"error dialing:\", err)\n  }\n\n  args := tweak.Args{\n    String: \"this string should be uppercase and reversed\",\n    ToUpper: true,\n    Reverse: true,\n  }\n  var result string\n  err = client.Call(\"StringTweaker.Tweak\", args, &result)\n  if err != nil {\n    log.Fatal(\"client call with error:\", err)\n  }\n  fmt.Printf(\"the result is: %s\", result)\n}\n```", "```go\n$ go run ./server\nListening on :1234\n```", "```go\n$ go run ./client\nthe result is: DESREVER DNA ESACREPPU EB DLUOHS GNIRTS SIHT\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/mail \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter5/mail\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"net/mail\"\n  \"strings\"\n)\n\n// extract header info and print it nicely\nfunc printHeaderInfo(header mail.Header) {\n\n  // this works because we know it's a single address\n  // otherwise use ParseAddressList\n  toAddress, err := mail.ParseAddress(header.Get(\"To\"))\n  if err == nil {\n    fmt.Printf(\"To: %s <%s>\\n\", toAddress.Name, toAddress.Address)\n  }\n  fromAddress, err := mail.ParseAddress(header.Get(\"From\"))\n  if err == nil {\n    fmt.Printf(\"From: %s <%s>\\n\", fromAddress.Name, \n                fromAddress.Address)\n  }\n\n  fmt.Println(\"Subject:\", header.Get(\"Subject\"))\n\n  // this works for a valid RFC5322 date\n  // it does a header.Get(\"Date\"), then a\n  // mail.ParseDate(that_result)\n  if date, err := header.Date(); err == nil {\n    fmt.Println(\"Date:\", date)\n  }\n\n  fmt.Println(strings.Repeat(\"=\", 40))\n  fmt.Println()\n}\n```", "```go\npackage main\n\nimport (\n  \"io\"\n  \"log\"\n  \"net/mail\"\n  \"os\"\n  \"strings\"\n)\n\n// an example email message\nconst msg string = `Date: Thu, 24 Jul 2019 08:00:00 -0700\nFrom: Aaron <fake_sender@example.com>\nTo: Reader <fake_receiver@example.com>\nSubject: Gophercon 2019 is going to be awesome!\n\nFeel free to share my book with others if you're attending.\nThis recipe can be used to process and parse email information.\n`\n\nfunc main() {\n  r := strings.NewReader(msg)\n  m, err := mail.ReadMessage(r)\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  printHeaderInfo(m.Header)\n\n  // after printing the header, dump the body to stdout\n  if _, err := io.Copy(os.Stdout, m.Body); err != nil {\n    log.Fatal(err)\n  }\n}\n```", "```go\n$ go build $ ./mail \n```", "```go\n$ go run .\nTo: Reader <fake_receiver@example.com>\nFrom: Aaron <fake_sender@example.com>\nSubject: Gophercon 2019 is going to be awesome!\nDate: 2019-07-24 08:00:00 -0700 -0700\n========================================\n\nFeel free to share my book with others if you're attending.\nThis recipe can be used to process and parse email information. \n```"]