["```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/client \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/client \n```", "```go\n        package client\n\n        import (\n            \"crypto/tls\"\n            \"net/http\"\n        )\n\n        // Setup configures our client and redefines\n        // the global DefaultClient\n        func Setup(isSecure, nop bool) *http.Client {\n            c := http.DefaultClient\n\n            // Sometimes for testing, we want to\n            // turn off SSL verification\n            if !isSecure {\n                c.Transport = &http.Transport{\n                TLSClientConfig: &tls.Config{\n                    InsecureSkipVerify: false,\n                },\n            }\n        }\n        if nop {\n            c.Transport = &NopTransport{}\n        }\n        http.DefaultClient = c\n        return c\n        }\n\n        // NopTransport is a No-Op Transport\n        type NopTransport struct {\n        }\n\n        // RoundTrip Implements RoundTripper interface\n        func (n *NopTransport) RoundTrip(*http.Request) \n        (*http.Response, error) {\n            // note this is an unitialized Response\n            // if you're looking at headers etc\n            return &http.Response{StatusCode: http.StatusTeapot}, nil\n        }\n```", "```go\n        package client\n\n        import (\n            \"fmt\"\n            \"net/http\"\n        )\n\n        // DoOps takes a client, then fetches\n        // google.com\n        func DoOps(c *http.Client) error {\n            resp, err := c.Get(\"http://www.google.com\")\n            if err != nil {\n                return err\n            }\n            fmt.Println(\"results of DoOps:\", resp.StatusCode)\n\n            return nil\n        }\n\n        // DefaultGetGolang uses the default client\n        // to get golang.org\n        func DefaultGetGolang() error {\n            resp, err := http.Get(\"https://www.golang.org\")\n            if err != nil {\n                return err\n            }\n            fmt.Println(\"results of DefaultGetGolang:\", \n            resp.StatusCode)\n            return nil\n        }\n```", "```go\n        package client\n\n        import (\n            \"fmt\"\n            \"net/http\"\n        )\n\n        // Controller embeds an http.Client\n        // and uses it internally\n        type Controller struct {\n            *http.Client\n        }\n\n        // DoOps with a controller object\n        func (c *Controller) DoOps() error {\n            resp, err := c.Client.Get(\"http://www.google.com\")\n            if err != nil {\n                return err\n            }\n            fmt.Println(\"results of client.DoOps\", resp.StatusCode)\n            return nil\n        }\n```", "```go\n        package main\n\n        import \"github.com/PacktPublishing/\n                Go-Programming-Cookbook-Second-Edition/\n                chapter7/client\"\n\n        func main() {\n            // secure and op!\n            cli := client.Setup(true, false)\n\n            if err := client.DefaultGetGolang(); err != nil {\n                panic(err)\n            }\n\n            if err := client.DoOps(cli); err != nil {\n                panic(err)\n            }\n\n            c := client.Controller{Client: cli}\n            if err := c.DoOps(); err != nil {\n                panic(err)\n            }\n\n            // secure and noop\n            // also modifies default\n            client.Setup(true, true)\n\n            if err := client.DefaultGetGolang(); err != nil {\n                panic(err)\n            }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nresults of DefaultGetGolang: 200\nresults of DoOps: 200\nresults of client.DoOps 200\nresults of DefaultGetGolang: 418\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/rest \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/rest \n```", "```go\n        package rest\n\n        import \"net/http\"\n\n        // APIClient is our custom client\n        type APIClient struct {\n            *http.Client\n        }\n\n        // NewAPIClient constructor initializes the client with our\n        // custom Transport\n        func NewAPIClient(username, password string) *APIClient {\n            t := http.Transport{}\n            return &APIClient{\n                Client: &http.Client{\n                    Transport: &APITransport{\n                        Transport: &t,\n                        username: username,\n                        password: password,\n                    },\n                },\n            }\n        }\n\n        // GetGoogle is an API Call - we abstract away\n        // the REST aspects\n        func (c *APIClient) GetGoogle() (int, error) {\n            resp, err := c.Get(\"http://www.google.com\")\n            if err != nil {\n                return 0, err\n            }\n            return resp.StatusCode, nil\n        }\n```", "```go\n        package rest\n\n        import \"net/http\"\n\n        // APITransport does a SetBasicAuth\n        // for every request\n        type APITransport struct {\n            *http.Transport\n            username, password string\n        }\n\n        // RoundTrip does the basic auth before deferring to the\n        // default transport\n        func (t *APITransport) RoundTrip(req *http.Request) \n        (*http.Response, error) {\n            req.SetBasicAuth(t.username, t.password)\n            return t.Transport.RoundTrip(req)\n        }\n```", "```go\n        package rest\n\n        import \"fmt\"\n\n        // Exec creates an API Client and uses its\n        // GetGoogle method, then prints the result\n        func Exec() error {\n            c := NewAPIClient(\"username\", \"password\")\n\n            StatusCode, err := c.GetGoogle()\n            if err != nil {\n                return err\n            }\n            fmt.Println(\"Result of GetGoogle:\", StatusCode)\n            return nil\n        }\n```", "```go\n        package main\n\n        import \"github.com/PacktPublishing/\n                Go-Programming-Cookbook-Second-Edition/\n                chapter7/rest\"\n\n        func main() {\n            if err := rest.Exec(); err != nil {\n                panic(err)\n            }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nResult of GetGoogle: 200\n```", "```go\ntype API interface{\n  GetUsers() (Users, error)\n  CreateUser(User) error\n  UpdateUser(User) error\n  DeleteUser(User)\n}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/async \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/async \n```", "```go\n        package async\n\n        import \"net/http\"\n\n        // NewClient creates a new client and \n        // sets its appropriate channels\n        func NewClient(client *http.Client, bufferSize int) *Client {\n            respch := make(chan *http.Response, bufferSize)\n            errch := make(chan error, bufferSize)\n            return &Client{\n                Client: client,\n                Resp: respch,\n                Err: errch,\n            }\n        }\n\n        // Client stores a client and has two channels to aggregate\n        // responses and errors\n        type Client struct {\n            *http.Client\n            Resp chan *http.Response\n            Err chan error\n        }\n\n        // AsyncGet performs a Get then returns\n        // the resp/error to the appropriate channel\n        func (c *Client) AsyncGet(url string) {\n            resp, err := c.Get(url)\n            if err != nil {\n                c.Err <- err\n                return\n            }\n            c.Resp <- resp\n        }\n```", "```go\n        package async\n\n        // FetchAll grabs a list of urls\n        func FetchAll(urls []string, c *Client) {\n            for _, url := range urls {\n                go c.AsyncGet(url)\n            }\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net/http\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/chapter7/async\"\n        )\n\n        func main() {\n            urls := []string{\n                \"https://www.google.com\",\n                \"https://golang.org\",\n                \"https://www.github.com\",\n            }\n            c := async.NewClient(http.DefaultClient, len(urls))\n            async.FetchAll(urls, c)\n\n            for i := 0; i < len(urls); i++ {\n                select {\n                    case resp := <-c.Resp:\n                    fmt.Printf(\"Status received for %s: %d\\n\", \n                    resp.Request.URL, resp.StatusCode)\n                    case err := <-c.Err:\n                   fmt.Printf(\"Error received: %s\\n\", err)\n                }\n            }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nStatus received for https://www.google.com: 200\nStatus received for https://golang.org: 200\nStatus received for https://github.com/: 200\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/oauthcli \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/oauthcli \n```", "```go\n        package oauthcli\n\n        import (\n            \"context\"\n            \"fmt\"\n            \"os\"\n\n            \"golang.org/x/oauth2\"\n            \"golang.org/x/oauth2/github\"\n        )\n\n        // Setup return an oauth2Config configured to talk\n        // to github, you need environment variables set\n        // for your id and secret\n        func Setup() *oauth2.Config {\n            return &oauth2.Config{\n                ClientID: os.Getenv(\"GITHUB_CLIENT\"),\n                ClientSecret: os.Getenv(\"GITHUB_SECRET\"),\n                Scopes: []string{\"repo\", \"user\"},\n                Endpoint: github.Endpoint,\n            }\n        }\n\n        // GetToken retrieves a github oauth2 token\n        func GetToken(ctx context.Context, conf *oauth2.Config) \n        (*oauth2.Token, error) {\n            url := conf.AuthCodeURL(\"state\")\n            fmt.Printf(\"Type the following url into your browser and \n            follow the directions on screen: %v\\n\", url)\n            fmt.Println(\"Paste the code returned in the redirect URL \n            and hit Enter:\")\n\n            var code string\n            if _, err := fmt.Scan(&code); err != nil {\n                return nil, err\n            }\n            return conf.Exchange(ctx, code)\n        }\n```", "```go\n        package oauthcli\n\n        import (\n            \"fmt\"\n            \"net/http\"\n        )\n\n        // GetUsers uses an initialized oauth2 client to get\n        // information about a user\n        func GetUser(client *http.Client) error {\n            url := fmt.Sprintf(\"https://api.github.com/user\")\n\n            resp, err := client.Get(url)\n            if err != nil {\n                return err\n            }\n            defer resp.Body.Close()\n            fmt.Println(\"Status Code from\", url, \":\", resp.StatusCode)\n            io.Copy(os.Stdout, resp.Body)\n            return nil\n        }\n```", "```go\n        package main\n\n        import (\n            \"context\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter7/oauthcli\"\n        )\n\n        func main() {\n            ctx := context.Background()\n            conf := oauthcli.Setup()\n\n            tok, err := oauthcli.GetToken(ctx, conf)\n            if err != nil {\n                panic(err)\n            }\n            client := conf.Client(ctx, tok)\n\n            if err := oauthcli.GetUser(client); err != nil {\n                panic(err)\n            }\n\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nVisit the URL for the auth dialog: \nhttps://github.com/login/oauth/authorize?\naccess_type=offline&client_id=\n<your_id>&response_type=code&scope=repo+user&state=state\nPaste the code returned in the redirect URL and hit Enter:\n<your_code>\nStatus Code from https://api.github.com/user: 200\n{<json_payload>}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/oauthstore \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/oauthstore \n```", "```go\n        package oauthstore\n\n        import (\n            \"context\"\n            \"net/http\"\n\n            \"golang.org/x/oauth2\"\n        )\n\n        // Config wraps the default oauth2.Config\n        // and adds our storage\n        type Config struct {\n            *oauth2.Config\n            Storage\n        }\n\n        // Exchange stores a token after retrieval\n        func (c *Config) Exchange(ctx context.Context, code string)     \n        (*oauth2.Token, error) {\n            token, err := c.Config.Exchange(ctx, code)\n            if err != nil {\n                return nil, err\n            }\n            if err := c.Storage.SetToken(token); err != nil {\n                return nil, err\n            }\n            return token, nil\n        }\n\n        // TokenSource can be passed a token which\n        // is stored, or when a new one is retrieved,\n        // that's stored\n        func (c *Config) TokenSource(ctx context.Context, t \n        *oauth2.Token) oauth2.TokenSource {\n            return StorageTokenSource(ctx, c, t)\n        }\n\n        // Client is attached to our TokenSource\n        func (c *Config) Client(ctx context.Context, t *oauth2.Token) \n        *http.Client {\n            return oauth2.NewClient(ctx, c.TokenSource(ctx, t))\n        }\n```", "```go\n        package oauthstore\n\n        import (\n            \"context\"\n\n            \"golang.org/x/oauth2\"\n        )\n\n        type storageTokenSource struct {\n            *Config\n            oauth2.TokenSource\n        }\n\n        // Token satisfies the TokenSource interface\n        func (s *storageTokenSource) Token() (*oauth2.Token, error) {\n            if token, err := s.Config.Storage.GetToken(); err == nil && \n            token.Valid() {\n                return token, err\n            }\n            token, err := s.TokenSource.Token()\n            if err != nil {\n                return token, err\n            }\n            if err := s.Config.Storage.SetToken(token); err != nil {\n                return nil, err\n            }\n            return token, nil\n        }\n\n        // StorageTokenSource will be used by out configs TokenSource\n        // function\n        func StorageTokenSource(ctx context.Context, c *Config, t \n        *oauth2.Token) oauth2.TokenSource {\n            if t == nil || !t.Valid() {\n                if tok, err := c.Storage.GetToken(); err == nil {\n                   t = tok\n                }\n            }\n            ts := c.Config.TokenSource(ctx, t)\n            return &storageTokenSource{c, ts}\n        }\n```", "```go\n        package oauthstore\n\n        import (\n            \"context\"\n            \"fmt\"\n\n            \"golang.org/x/oauth2\"\n        )\n\n        // Storage is our generic storage interface\n        type Storage interface {\n            GetToken() (*oauth2.Token, error)\n            SetToken(*oauth2.Token) error\n        }\n\n        // GetToken retrieves a github oauth2 token\n        func GetToken(ctx context.Context, conf Config) (*oauth2.Token, \n        error) {\n            token, err := conf.Storage.GetToken()\n            if err == nil && token.Valid() {\n                return token, err\n            }\n            url := conf.AuthCodeURL(\"state\")\n            fmt.Printf(\"Type the following url into your browser and \n            follow the directions on screen: %v\\n\", url)\n            fmt.Println(\"Paste the code returned in the redirect URL \n            and hit Enter:\")\n\n            var code string\n            if _, err := fmt.Scan(&code); err != nil {\n                return nil, err\n            }\n            return conf.Exchange(ctx, code)\n        }\n```", "```go\n        package oauthstore\n\n        import (\n            \"encoding/json\"\n            \"errors\"\n            \"os\"\n            \"sync\"\n\n            \"golang.org/x/oauth2\"\n        )\n\n        // FileStorage satisfies our storage interface\n        type FileStorage struct {\n            Path string\n            mu sync.RWMutex\n        }\n\n        // GetToken retrieves a token from a file\n        func (f *FileStorage) GetToken() (*oauth2.Token, error) {\n            f.mu.RLock()\n            defer f.mu.RUnlock()\n            in, err := os.Open(f.Path)\n            if err != nil {\n                return nil, err\n            }\n            defer in.Close()\n            var t *oauth2.Token\n            data := json.NewDecoder(in)\n            return t, data.Decode(&t)\n        }\n\n        // SetToken creates, truncates, then stores a token\n        // in a file\n        func (f *FileStorage) SetToken(t *oauth2.Token) error {\n            if t == nil || !t.Valid() {\n                return errors.New(\"bad token\")\n            }\n\n            f.mu.Lock()\n            defer f.mu.Unlock()\n            out, err := os.OpenFile(f.Path, \n            os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)\n            if err != nil {\n                return err\n            }\n            defer out.Close()\n            data, err := json.Marshal(&t)\n            if err != nil {\n                return err\n            }\n\n            _, err = out.Write(data)\n            return err\n        }\n```", "```go\n        package main\n\n        import (\n            \"context\"\n            \"io\"\n            \"os\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter7/oauthstore\"\n\n            \"golang.org/x/oauth2\"\n            \"golang.org/x/oauth2/github\"\n        )\n\n        func main() {\n            conf := oauthstore.Config{\n                Config: &oauth2.Config{\n                    ClientID: os.Getenv(\"GITHUB_CLIENT\"),\n                    ClientSecret: os.Getenv(\"GITHUB_SECRET\"),\n                    Scopes: []string{\"repo\", \"user\"},\n                    Endpoint: github.Endpoint,\n                },\n                Storage: &oauthstore.FileStorage{Path: \"token.txt\"},\n            }\n            ctx := context.Background()\n            token, err := oauthstore.GetToken(ctx, conf)\n            if err != nil {\n                panic(err)\n            }\n\n            cli := conf.Client(ctx, token)\n            resp, err := cli.Get(\"https://api.github.com/user\")\n            if err != nil {\n                panic(err)\n            }\n            defer resp.Body.Close()\n            io.Copy(os.Stdout, resp.Body)\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nVisit the URL for the auth dialog: \nhttps://github.com/login/oauth/authorize?\naccess_type=offline&client_id=\n<your_id>&response_type=code&scope=repo+user&state=state\nPaste the code returned in the redirect URL and hit Enter:\n<your_code>\n{<json_payload>}\n\n$ go run main.go\n{<json_payload>}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/decorator \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/decorator \n```", "```go\n        package decorator\n\n        import (\n            \"log\"\n            \"net/http\"\n            \"os\"\n        )\n\n        // Setup initializes our ClientInterface\n        func Setup() *http.Client {\n            c := http.Client{}\n\n            t := Decorate(&http.Transport{},\n                Logger(log.New(os.Stdout, \"\", 0)),\n                BasicAuth(\"username\", \"password\"),\n            )\n            c.Transport = t\n            return &c\n        }\n```", "```go\n        package decorator\n\n        import \"net/http\"\n\n        // TransportFunc implements the RountTripper interface\n        type TransportFunc func(*http.Request) (*http.Response, error)\n\n        // RoundTrip just calls the original function\n        func (tf TransportFunc) RoundTrip(r *http.Request) \n        (*http.Response, error) {\n            return tf(r)\n        }\n\n        // Decorator is a convenience function to represent our\n        // middleware inner function\n        type Decorator func(http.RoundTripper) http.RoundTripper\n\n        // Decorate is a helper to wrap all the middleware\n        func Decorate(t http.RoundTripper, rts ...Decorator) \n        http.RoundTripper {\n            decorated := t\n            for _, rt := range rts {\n                decorated = rt(decorated)\n            }\n            return decorated\n        }\n```", "```go\n        package decorator\n\n        import (\n            \"log\"\n            \"net/http\"\n            \"time\"\n        )\n\n        // Logger is one of our 'middleware' decorators\n        func Logger(l *log.Logger) Decorator {\n            return func(c http.RoundTripper) http.RoundTripper {\n                return TransportFunc(func(r *http.Request) \n                (*http.Response, error) {\n                   start := time.Now()\n                   l.Printf(\"started request to %s at %s\", r.URL,     \n                   start.Format(\"2006-01-02 15:04:05\"))\n                   resp, err := c.RoundTrip(r)\n                   l.Printf(\"completed request to %s in %s\", r.URL, \n                   time.Since(start))\n                   return resp, err\n                })\n            }\n        }\n\n        // BasicAuth is another of our 'middleware' decorators\n        func BasicAuth(username, password string) Decorator {\n            return func(c http.RoundTripper) http.RoundTripper {\n                return TransportFunc(func(r *http.Request) \n                (*http.Response, error) {\n                    r.SetBasicAuth(username, password)\n                    resp, err := c.RoundTrip(r)\n                    return resp, err\n                })\n            }\n        }\n```", "```go\n        package decorator\n\n        import \"fmt\"\n\n        // Exec creates a client, calls google.com\n        // then prints the response\n        func Exec() error {\n            c := Setup()\n\n            resp, err := c.Get(\"https://www.google.com\")\n            if err != nil {\n                return err\n            }\n            fmt.Println(\"Response code:\", resp.StatusCode)\n            return nil\n        }\n```", "```go\n        package main\n\n        import \"github.com/PacktPublishing/\n                Go-Programming-Cookbook-Second-Edition/\n                chapter7/decorator\"\n\n        func main() {\n            if err := decorator.Exec(); err != nil {\n                panic(err)\n            }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nstarted request to https://www.google.com at 2017-01-01 13:38:42\ncompleted request to https://www.google.com in 194.013054ms\nResponse code: 200\n```", "```go\nDecorate(RoundTripper, Middleware1, Middleware2, etc)\n\nvs\n\nvar t RoundTripper\nt = Middleware1(t)\nt = Middleware2(t)\netc\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/grpc \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/grpc \n```", "```go\n        syntax = \"proto3\";\n\n        package greeter;\n\n        service GreeterService{\n            rpc Greet(GreetRequest) returns (GreetResponse) {}\n        }\n\n        message GreetRequest {\n            string greeting = 1;\n            string name = 2;\n        }\n\n        message GreetResponse{\n            string response = 1;\n        }\n```", "```go\n$ protoc --go_out=plugins=grpc:. greeter/greeter.proto\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter7/grpc/greeter\"\n            \"golang.org/x/net/context\"\n        )\n\n        // Greeter implements the interface\n        // generated by protoc\n        type Greeter struct {\n            Exclaim bool\n        }\n\n        // Greet implements grpc Greet\n        func (g *Greeter) Greet(ctx context.Context, r \n        *greeter.GreetRequest) (*greeter.GreetResponse, error) {\n            msg := fmt.Sprintf(\"%s %s\", r.GetGreeting(), r.GetName())\n            if g.Exclaim {\n                msg += \"!\"\n            } else {\n                msg += \".\"\n            }\n            return &greeter.GreetResponse{Response: msg}, nil\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter7/grpc/greeter\"\n            \"google.golang.org/grpc\"\n        )\n\n        func main() {\n            grpcServer := grpc.NewServer()\n            greeter.RegisterGreeterServiceServer(grpcServer, \n            &Greeter{Exclaim: true})\n            lis, err := net.Listen(\"tcp\", \":4444\")\n            if err != nil {\n                panic(err)\n            }\n            fmt.Println(\"Listening on port :4444\")\n            grpcServer.Serve(lis)\n        }\n```", "```go\n        package main\n\n        import (\n            \"context\"\n            \"fmt\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter7/grpc/greeter\"\n            \"google.golang.org/grpc\"\n        )\n\n        func main() {\n            conn, err := grpc.Dial(\":4444\", grpc.WithInsecure())\n            if err != nil {\n                panic(err)\n            }\n            defer conn.Close()\n\n            client := greeter.NewGreeterServiceClient(conn)\n\n            ctx := context.Background()\n            req := greeter.GreetRequest{Greeting: \"Hello\", Name: \n            \"Reader\"}\n            resp, err := client.Greet(ctx, &req)\n            if err != nil {\n                panic(err)\n            }\n            fmt.Println(resp)\n\n            req.Greeting = \"Goodbye\"\n            resp, err = client.Greet(ctx, &req)\n            if err != nil {\n                panic(err)\n            }\n            fmt.Println(resp)\n        }\n```", "```go\n$ go run ./server\nListening on port :4444\n```", "```go\n$ go run ./client\nresponse:\"Hello Reader!\" \nresponse:\"Goodbye Reader!\"\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/twirp \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/twirp \n```", "```go\n        syntax = \"proto3\";\n\n        package greeter;\n\n        service GreeterService{\n            rpc Greet(GreetRequest) returns (GreetResponse) {}\n        }\n\n        message GreetRequest {\n            string greeting = 1;\n            string name = 2;\n        }\n\n        message GreetResponse{\n            string response = 1;\n        }\n```", "```go\n$ protoc --proto_path=$GOPATH/src:. --twirp_out=. --go_out=. ./rpc/greeter/greeter.proto\n```", "```go\npackage main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/PacktPublishing/\n   Go-Programming-Cookbook-Second-Edition/\n   chapter7/twirp/rpc/greeter\"\n)\n\n// Greeter implements the interface\n// generated by protoc\ntype Greeter struct {\n  Exclaim bool\n}\n\n// Greet implements twirp Greet\nfunc (g *Greeter) Greet(ctx context.Context, r *greeter.GreetRequest) (*greeter.GreetResponse, error) {\n  msg := fmt.Sprintf(\"%s %s\", r.GetGreeting(), r.GetName())\n  if g.Exclaim {\n    msg += \"!\"\n  } else {\n    msg += \".\"\n  }\n  return &greeter.GreetResponse{Response: msg}, nil\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"net/http\"\n\n  \"github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/twirp/rpc/greeter\"\n)\n\nfunc main() {\n  server := &Greeter{}\n  twirpHandler := greeter.NewGreeterServiceServer(server, nil)\n\n  fmt.Println(\"Listening on port :4444\")\n  http.ListenAndServe(\":4444\", twirpHandler)\n}\n```", "```go\npackage main\n\nimport (\n  \"context\"\n  \"fmt\"\n  \"net/http\"\n\n  \"github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter7/twirp/rpc/greeter\"\n)\n\nfunc main() {\n  // you can put in a custom client for tighter controls on timeouts etc.\n  client := greeter.NewGreeterServiceProtobufClient(\"http://localhost:4444\", &http.Client{})\n\n  ctx := context.Background()\n  req := greeter.GreetRequest{Greeting: \"Hello\", Name: \"Reader\"}\n  resp, err := client.Greet(ctx, &req)\n  if err != nil {\n    panic(err)\n  }\n  fmt.Println(resp)\n\n  req.Greeting = \"Goodbye\"\n  resp, err = client.Greet(ctx, &req)\n  if err != nil {\n    panic(err)\n  }\n  fmt.Println(resp)\n}\n```", "```go\n$ go run ./server\nListening on port :4444\n```", "```go\n$ go run ./client\nresponse:\"Hello Reader.\" \nresponse:\"Goodbye Reader.\"\n```", "```go\n$ curl --request \"POST\" \\ \n --location \"http://localhost:4444/twirp/greeter.GreeterService/Greet\" \\\n --header \"Content-Type:application/json\" \\\n --data '{\"greeting\": \"Greetings to\", \"name\":\"you\"}' \n\n{\"response\":\"Greetings to you.\"}\n```"]