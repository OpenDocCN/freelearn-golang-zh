["```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\n// HandlerFunc implements the Handler interface\ntype HandlerFunc func(http.ResponseWriter, *http.Request)\n\ntype Handler interface {\n    ServeHTTP(http.ResponseWriter, *http.Request)\n}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/handlers \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/handlers    \n```", "```go\n        package handlers\n\n        import (\n            \"fmt\"\n            \"net/http\"\n        )\n\n        // HelloHandler takes a GET parameter \"name\" and responds\n        // with Hello <name>! in plaintext\n        func HelloHandler(w http.ResponseWriter, r *http.Request) {\n            w.Header().Set(\"Content-Type\", \"text/plain\")\n            if r.Method != http.MethodGet {\n                w.WriteHeader(http.StatusMethodNotAllowed)\n                return\n            }\n            name := r.URL.Query().Get(\"name\")\n\n            w.WriteHeader(http.StatusOK)\n            w.Write([]byte(fmt.Sprintf(\"Hello %s!\", name)))\n        }\n```", "```go\n        package handlers\n\n        import (\n            \"encoding/json\"\n            \"net/http\"\n        )\n\n        // GreetingResponse is the JSON Response that\n        // GreetingHandler returns\n        type GreetingResponse struct {\n            Payload struct {\n                Greeting string `json:\"greeting,omitempty\"`\n                Name string `json:\"name,omitempty\"`\n                Error string `json:\"error,omitempty\"`\n            } `json:\"payload\"`\n            Successful bool `json:\"successful\"`\n        }\n\n        // GreetingHandler returns a GreetingResponse which either has \n        // errors or a useful payload\n        func GreetingHandler(w http.ResponseWriter, r *http.Request) {\n            w.Header().Set(\"Content-Type\", \"application/json\")\n            if r.Method != http.MethodPost {\n                w.WriteHeader(http.StatusMethodNotAllowed)\n                return\n            }\n            var gr GreetingResponse\n            if err := r.ParseForm(); err != nil {\n                gr.Payload.Error = \"bad request\"\n                if payload, err := json.Marshal(gr); err == nil {\n                    w.Write(payload)\n                }  else if err != nil {\n                    w.WriteHeader(http.StatusInternalServerError)\n                }\n            }\n            name := r.FormValue(\"name\")\n            greeting := r.FormValue(\"greeting\")\n\n            w.WriteHeader(http.StatusOK)\n            gr.Successful = true\n            gr.Payload.Name = name\n            gr.Payload.Greeting = greeting\n            if payload, err := json.Marshal(gr); err == nil {\n               w.Write(payload)\n            }\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net/http\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             $ chapter8/handlers\"\n        )\n\n        func main() {\n            http.HandleFunc(\"/name\", handlers.HelloHandler)\n            http.HandleFunc(\"/greeting\", handlers.GreetingHandler)\n            fmt.Println(\"Listening on port :3333\")\n            err := http.ListenAndServe(\":3333\", nil)\n            panic(err)\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nListening on port :3333\n```", "```go\n$ curl \"http://localhost:3333/name?name=Reader\" -X GET $ curl \"http://localhost:3333/greeting\" -X POST -d  \n 'name=Reader;greeting=Goodbye'\n```", "```go\n$ curl \"http://localhost:3333/name?name=Reader\" -X GET \nHello Reader!\n\n$ curl \"http://localhost:3333/greeting\" -X POST -d 'name=Reader;greeting=Goodbye' \n{\"payload\":{\"greeting\":\"Goodbye\",\"name\":\"Reader\"},\"successful\":true}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/controllers \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/controllers    \n```", "```go\n        package controllers\n\n        // Controller passes state to our handlers\n        type Controller struct {\n            storage Storage\n        }\n\n        // New is a Controller 'constructor'\n        func New(storage Storage) *Controller {\n            return &Controller{\n                storage: storage,\n            }\n        }\n\n        // Payload is our common response\n        type Payload struct {\n            Value string `json:\"value\"`\n        }\n```", "```go\n        package controllers\n\n        // Storage Interface Supports Get and Put\n        // of a single value\n        type Storage interface {\n            Get() string\n            Put(string)\n        }\n\n        // MemStorage implements Storage\n        type MemStorage struct {\n            value string\n        }\n\n        // Get our in-memory value\n        func (m *MemStorage) Get() string {\n            return m.value\n        }\n\n        // Put our in-memory value\n        func (m *MemStorage) Put(s string) {\n            m.value = s\n        }\n```", "```go\n        package controllers\n\n        import (\n            \"encoding/json\"\n            \"net/http\"\n        )\n\n        // SetValue modifies the underlying storage of the controller \n        // object\n        func (c *Controller) SetValue(w http.ResponseWriter, r \n        *http.Request) {\n            if r.Method != http.MethodPost {\n                w.WriteHeader(http.StatusMethodNotAllowed)\n                return\n            }\n            if err := r.ParseForm(); err != nil {\n                w.WriteHeader(http.StatusInternalServerError)\n                return\n            }\n            value := r.FormValue(\"value\")\n            c.storage.Put(value)\n            w.WriteHeader(http.StatusOK)\n            p := Payload{Value: value}\n            if payload, err := json.Marshal(p); err == nil {\n                w.Write(payload)\n            } else if err != nil {\n                w.WriteHeader(http.StatusInternalServerError)\n            }\n\n        }\n```", "```go\n        package controllers\n\n        import (\n            \"encoding/json\"\n            \"net/http\"\n        )\n\n        // GetValue is a closure that wraps a HandlerFunc, if \n        // UseDefault is true value will always be \"default\" else it'll \n        // be whatever is stored in storage\n        func (c *Controller) GetValue(UseDefault bool) http.HandlerFunc \n        {\n            return func(w http.ResponseWriter, r *http.Request) {\n                w.Header().Set(\"Content-Type\", \"application/json\")\n                if r.Method != http.MethodGet {\n                    w.WriteHeader(http.StatusMethodNotAllowed)\n                    return\n                }\n                value := \"default\"\n                if !UseDefault {\n                    value = c.storage.Get()\n                }\n                w.WriteHeader(http.StatusOK)\n                p := Payload{Value: value}\n                if payload, err := json.Marshal(p); err == nil {\n                    w.Write(payload)\n                }\n            }\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net/http\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter8/controllers\"\n        )\n\n        func main() {\n            storage := controllers.MemStorage{}\n            c := controllers.New(&storage)\n            http.HandleFunc(\"/get\", c.GetValue(false))\n            http.HandleFunc(\"/get/default\", c.GetValue(true))\n            http.HandleFunc(\"/set\", c.SetValue)\n\n            fmt.Println(\"Listening on port :3333\")\n            err := http.ListenAndServe(\":3333\", nil)\n            panic(err)\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nListening on port :3333\n```", "```go\n$ curl \"http://localhost:3333/set\" -X POST -d \"value=value\" \n$ curl \"http://localhost:3333/get\" -X GET \n$ curl \"http://localhost:3333/get/default\" -X GET\n```", "```go\n$ curl \"http://localhost:3333/set\" -X POST -d \"value=value\"\n{\"value\":\"value\"}\n\n$ curl \"http://localhost:3333/get\" -X GET \n{\"value\":\"value\"}\n\n$ curl \"http://localhost:3333/get/default\" -X GET \n{\"value\":\"default\"}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/validation \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/validation    \n```", "```go\n        package validation\n\n        // Controller holds our validation functions\n        type Controller struct {\n            ValidatePayload func(p *Payload) error\n        }\n\n        // New initializes a controller with our\n        // local validation, it can be overwritten\n        func New() *Controller {\n            return &Controller{\n                ValidatePayload: ValidatePayload,\n            }\n        }\n```", "```go\n        package validation\n\n        import \"errors\"\n\n        // Verror is an error that occurs\n        // during validation, we can\n        // return this to a user\n        type Verror struct {\n            error\n        }\n\n        // Payload is the value we\n        // process\n        type Payload struct {\n            Name string `json:\"name\"`\n            Age int `json:\"age\"`\n        }\n\n        // ValidatePayload is 1 implementation of\n        // the closure in our controller\n        func ValidatePayload(p *Payload) error {\n            if p.Name == \"\" {\n                return Verror{errors.New(\"name is required\")}\n            }\n\n            if p.Age <= 0 || p.Age >= 120 {\n                return Verror{errors.New(\"age is required and must be a \n                value greater than 0 and less than 120\")}\n            }\n            return nil\n        }\n```", "```go\n        package validation\n\n        import (\n            \"encoding/json\"\n            \"fmt\"\n            \"net/http\"\n        )\n\n        // Process is a handler that validates a post payload\n        func (c *Controller) Process(w http.ResponseWriter, r \n        *http.Request) {\n            if r.Method != http.MethodPost {\n                w.WriteHeader(http.StatusMethodNotAllowed)\n                return\n            }\n\n            decoder := json.NewDecoder(r.Body)\n            defer r.Body.Close()\n            var p Payload\n\n            if err := decoder.Decode(&p); err != nil {\n                fmt.Println(err)\n                w.WriteHeader(http.StatusBadRequest)\n                return\n            }\n\n            if err := c.ValidatePayload(&p); err != nil {\n                switch err.(type) {\n                case Verror:\n                    w.WriteHeader(http.StatusBadRequest)\n                    // pass the Verror along\n                    w.Write([]byte(err.Error()))\n                    return\n                default:\n                    w.WriteHeader(http.StatusInternalServerError)\n                    return\n                }\n            }\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net/http\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter8/validation\"\n        )\n\n        func main() {\n            c := validation.New()\n            http.HandleFunc(\"/\", c.Process)\n            fmt.Println(\"Listening on port :3333\")\n            err := http.ListenAndServe(\":3333\", nil)\n            panic(err)\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nListening on port :3333\n```", "```go\n$ curl \"http://localhost:3333/\" -X POST -d '{}' $ curl \"http://localhost:3333/\" -X POST -d '{\"name\":\"test\"}' $ curl \"http://localhost:3333/\" -X POST -d '{\"name\":\"test\",\n  \"age\": 5}' -v\n```", "```go\n$ curl \"http://localhost:3333/\" -X POST -d '{}'\nname is required\n\n$ curl \"http://localhost:3333/\" -X POST -d '{\"name\":\"test\"}'\nage is required and must be a value greater than 0 and \nless than 120\n\n$ curl \"http://localhost:3333/\" -X POST -d '{\"name\":\"test\",\n\"age\": 5}' -v\n\n<lots of output, should contain a 200 OK status code>\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/negotiate \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/negotiate    \n```", "```go\n        package negotiate\n\n        import (\n            \"net/http\"\n\n            \"github.com/unrolled/render\"\n        )\n\n        // Negotiator wraps render and does\n        // some switching on ContentType\n        type Negotiator struct {\n            ContentType string\n            *render.Render\n        }\n\n        // GetNegotiator takes a request, and figures\n        // out the ContentType from the Content-Type header\n        func GetNegotiator(r *http.Request) *Negotiator {\n            contentType := r.Header.Get(\"Content-Type\")\n\n            return &Negotiator{\n                ContentType: contentType,\n                Render: render.New(),\n            }\n        }\n```", "```go\n        package negotiate\n\n        import \"io\"\n        import \"github.com/unrolled/render\"\n\n        // Respond switches on Content Type to determine\n        // the response\n        func (n *Negotiator) Respond(w io.Writer, status int, v \n        interface{}) {\n            switch n.ContentType {\n                case render.ContentJSON:\n                    n.Render.JSON(w, status, v)\n                case render.ContentXML:\n                    n.Render.XML(w, status, v)\n                default:\n                    n.Render.JSON(w, status, v)\n                }\n        }\n```", "```go\n        package negotiate\n\n        import (\n            \"encoding/xml\"\n            \"net/http\"\n        )\n\n        // Payload defines it's layout in xml and json\n        type Payload struct {\n            XMLName xml.Name `xml:\"payload\" json:\"-\"`\n            Status string `xml:\"status\" json:\"status\"`\n        }\n\n        // Handler gets a negotiator using the request,\n        // then renders a Payload\n        func Handler(w http.ResponseWriter, r *http.Request) {\n            n := GetNegotiator(r)\n\n            n.Respond(w, http.StatusOK, &Payload{Status:       \n            \"Successful!\"})\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net/http\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter8/negotiate\"\n        )\n\n        func main() {\n            http.HandleFunc(\"/\", negotiate.Handler)\n            fmt.Println(\"Listening on port :3333\")\n            err := http.ListenAndServe(\":3333\", nil)\n            panic(err)\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nListening on port :3333\n```", "```go\n$ curl \"http://localhost:3333\" -H \"Content-Type: text/xml\" $ curl \"http://localhost:3333\" -H \"Content-Type: application/json\"\n```", "```go\n$ curl \"http://localhost:3333\" -H \"Content-Type: text/xml\"\n<payload><status>Successful!</status></payload> \n$ curl \"http://localhost:3333\" -H \"Content-Type: application/json\"\n{\"status\":\"Successful!\"}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/middleware \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/middleware    \n```", "```go\n        package middleware\n\n        import (\n            \"log\"\n            \"net/http\"\n            \"time\"\n        )\n\n        // Middleware is what all middleware functions will return\n        type Middleware func(http.HandlerFunc) http.HandlerFunc\n\n        // ApplyMiddleware will apply all middleware, the last \n        // arguments will be the\n        // outer wrap for context passing purposes\n        func ApplyMiddleware(h http.HandlerFunc, middleware \n        ...Middleware) http.HandlerFunc {\n            applied := h\n            for _, m := range middleware {\n                applied = m(applied)\n            }\n            return applied\n        }\n\n        // Logger logs requests, this will use an id passed in via\n        // SetID()\n        func Logger(l *log.Logger) Middleware {\n            return func(next http.HandlerFunc) http.HandlerFunc {\n                return func(w http.ResponseWriter, r *http.Request) {\n                    start := time.Now()\n                    l.Printf(\"started request to %s with id %s\", r.URL, \n                    GetID(r.Context()))\n                    next(w, r)\n                    l.Printf(\"completed request to %s with id %s in\n                    %s\", r.URL, GetID(r.Context()), time.Since(start))\n                }\n            }\n        }\n```", "```go\n        package middleware\n\n        import (\n            \"context\"\n            \"net/http\"\n            \"strconv\"\n        )\n\n        // ContextID is our type to retrieve our context\n        // objects\n        type ContextID int\n\n        // ID is the only ID we've defined\n        const ID ContextID = 0\n\n        // SetID updates context with the id then\n        // increments it\n        func SetID(start int64) Middleware {\n            return func(next http.HandlerFunc) http.HandlerFunc {\n                return func(w http.ResponseWriter, r *http.Request) {\n                    ctx := context.WithValue(r.Context(), ID, \n                    strconv.FormatInt(start, 10))\n                    start++\n                    r = r.WithContext(ctx)\n                    next(w, r)\n                }\n            }\n        }\n\n        // GetID grabs an ID from a context if set\n        // otherwise it returns an empty string\n        func GetID(ctx context.Context) string {\n            if val, ok := ctx.Value(ID).(string); ok {\n                return val\n            }\n            return \"\"\n        }\n```", "```go\n        package middleware\n\n        import (\n            \"net/http\"\n        )\n\n        // Handler is very basic\n        func Handler(w http.ResponseWriter, r *http.Request) {\n            w.WriteHeader(http.StatusOK)\n            w.Write([]byte(\"success\"))\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"log\"\n            \"net/http\"\n            \"os\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter8/middleware\"\n        )\n\n        func main() {\n            // We apply from bottom up\n            h := middleware.ApplyMiddleware(\n            middleware.Handler,\n            middleware.Logger(log.New(os.Stdout, \"\", 0)),\n            middleware.SetID(100),\n            ) \n            http.HandleFunc(\"/\", h)\n            fmt.Println(\"Listening on port :3333\")\n            err := http.ListenAndServe(\":3333\", nil)\n            panic(err)\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nListening on port :3333\n```", "```go\n$ curl http://localhost:3333\n```", "```go\n$ curl http://localhost:3333\nsuccess\n\n$ curl http://localhost:3333\nsuccess\n\n$ curl http://localhost:3333\nsuccess\n```", "```go\nListening on port :3333\nstarted request to / with id 100\ncompleted request to / with id 100 in 52.284\u00b5s\nstarted request to / with id 101\ncompleted request to / with id 101 in 40.273\u00b5s\nstarted request to / with id 102\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/proxy \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/proxy    \n```", "```go\n        package proxy\n\n        import (\n            \"log\"\n            \"net/http\"\n        )\n\n        // Proxy holds our configured client\n        // and BaseURL to proxy to\n        type Proxy struct {\n            Client *http.Client\n            BaseURL string\n        }\n\n        // ServeHTTP means that proxy implements the Handler interface\n        // It manipulates the request, forwards it to BaseURL, then \n        // returns the response\n        func (p *Proxy) ServeHTTP(w http.ResponseWriter, r \n        *http.Request) {\n            if err := p.ProcessRequest(r); err != nil {\n                log.Printf(\"error occurred during process request: %s\", \n                err.Error())\n                w.WriteHeader(http.StatusBadRequest)\n                return\n            }\n\n            resp, err := p.Client.Do(r)\n            if err != nil {\n                log.Printf(\"error occurred during client operation: \n                %s\", err.Error())\n                w.WriteHeader(http.StatusInternalServerError)\n                return\n            }\n            defer resp.Body.Close()\n            CopyResponse(w, resp)\n        }\n```", "```go\n        package proxy\n\n        import (\n            \"bytes\"\n            \"net/http\"\n            \"net/url\"\n        )\n\n        // ProcessRequest modifies the request in accordnance\n        // with Proxy settings\n        func (p *Proxy) ProcessRequest(r *http.Request) error {\n            proxyURLRaw := p.BaseURL + r.URL.String()\n\n            proxyURL, err := url.Parse(proxyURLRaw)\n            if err != nil {\n                return err\n            }\n            r.URL = proxyURL\n            r.Host = proxyURL.Host\n            r.RequestURI = \"\"\n            return nil\n        }\n\n        // CopyResponse takes the client response and writes everything\n        // to the ResponseWriter in the original handler\n        func CopyResponse(w http.ResponseWriter, resp *http.Response) {\n            var out bytes.Buffer\n            out.ReadFrom(resp.Body)\n\n            for key, values := range resp.Header {\n                for _, value := range values {\n                w.Header().Add(key, value)\n                }\n            }\n\n            w.WriteHeader(resp.StatusCode)\n            w.Write(out.Bytes())\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net/http\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter8/proxy\"\n        )\n\n        func main() {\n            p := &proxy.Proxy{\n                Client: http.DefaultClient,\n                BaseURL: \"https://www.golang.org\",\n            }\n            http.Handle(\"/\", p)\n            fmt.Println(\"Listening on port :3333\")\n            err := http.ListenAndServe(\":3333\", nil)\n            panic(err)\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nListening on port :3333\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/grpcjson \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter8/grpcjson    \n```", "```go\n        syntax = \"proto3\";\n\n        package keyvalue;\n\n        service KeyValue{\n            rpc Set(SetKeyValueRequest) returns (KeyValueResponse){}\n            rpc Get(GetKeyValueRequest) returns (KeyValueResponse){}\n        }\n\n        message SetKeyValueRequest {\n            string key = 1;\n            string value = 2;\n        }\n\n        message GetKeyValueRequest{\n            string key = 1;\n        }\n\n        message KeyValueResponse{\n            string success = 1;\n            string value = 2;\n        }\n```", "```go\n$ protoc --go_out=plugins=grpc:. keyvalue.proto\n```", "```go\n        package internal\n\n        import (\n            \"golang.org/x/net/context\"\n            \"sync\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter8/grpcjson/keyvalue\"\n            \"google.golang.org/grpc\"\n            \"google.golang.org/grpc/codes\"\n        )\n\n        // KeyValue is a struct that holds a map\n        type KeyValue struct {\n            mutex sync.RWMutex\n            m map[string]string\n        }\n\n        // NewKeyValue initializes the KeyValue struct and its map\n        func NewKeyValue() *KeyValue {\n            return &KeyValue{\n                m: make(map[string]string),\n            }\n        }\n\n        // Set sets a value to a key, then returns the value\n        func (k *KeyValue) Set(ctx context.Context, r \n        *keyvalue.SetKeyValueRequest) (*keyvalue.KeyValueResponse, \n        error) {\n            k.mutex.Lock()\n            k.m[r.GetKey()] = r.GetValue()\n            k.mutex.Unlock()\n            return &keyvalue.KeyValueResponse{Value: r.GetValue()}, nil\n        }\n\n        // Get gets a value given a key, or say not found if \n        // it doesn't exist\n        func (k *KeyValue) Get(ctx context.Context, r \n        *keyvalue.GetKeyValueRequest) (*keyvalue.KeyValueResponse, \n        error) {\n            k.mutex.RLock()\n            defer k.mutex.RUnlock()\n            val, ok := k.m[r.GetKey()]\n            if !ok {\n                return nil, grpc.Errorf(codes.NotFound, \"key not set\")\n            }\n            return &keyvalue.KeyValueResponse{Value: val}, nil\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter8/grpcjson/internal\"\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter8/grpcjson/keyvalue\"\n            \"google.golang.org/grpc\"\n        )\n\n        func main() {\n            grpcServer := grpc.NewServer()\n            keyvalue.RegisterKeyValueServer(grpcServer, \n            internal.NewKeyValue())\n            lis, err := net.Listen(\"tcp\", \":4444\")\n            if err != nil {\n                panic(err)\n            }\n            fmt.Println(\"Listening on port :4444\")\n            grpcServer.Serve(lis)\n        }\n```", "```go\n        package main\n\n        import (\n            \"encoding/json\"\n            \"net/http\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter8/grpcjson/internal\"\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter8/grpcjson/keyvalue\"\n            \"github.com/apex/log\"\n        )\n\n        // Controller holds an internal KeyValueObject\n        type Controller struct {\n            *internal.KeyValue\n        }\n\n        // SetHandler wraps our GRPC Set\n        func (c *Controller) SetHandler(w http.ResponseWriter, r \n        *http.Request) {\n            var kv keyvalue.SetKeyValueRequest\n\n            decoder := json.NewDecoder(r.Body)\n            if err := decoder.Decode(&kv); err != nil {\n                log.Errorf(\"failed to decode: %s\", err.Error())\n                w.WriteHeader(http.StatusBadRequest)\n                return\n            }\n\n            gresp, err := c.Set(r.Context(), &kv)\n            if err != nil {\n                log.Errorf(\"failed to set: %s\", err.Error())\n                w.WriteHeader(http.StatusInternalServerError)\n                return\n            }\n\n            resp, err := json.Marshal(gresp)\n            if err != nil {\n                log.Errorf(\"failed to marshal: %s\", err.Error())\n                w.WriteHeader(http.StatusInternalServerError)\n                return\n            }\n            w.WriteHeader(http.StatusOK)\n            w.Write(resp)\n        }\n```", "```go\n        package main\n\n        import (\n            \"encoding/json\"\n            \"net/http\"\n\n            \"google.golang.org/grpc\"\n            \"google.golang.org/grpc/codes\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter8/grpcjson/keyvalue\"\n            \"github.com/apex/log\"\n        )\n\n        // GetHandler wraps our RPC Get call\n        func (c *Controller) GetHandler(w http.ResponseWriter, r \n        *http.Request) {\n            key := r.URL.Query().Get(\"key\")\n            kv := keyvalue.GetKeyValueRequest{Key: key}\n\n            gresp, err := c.Get(r.Context(), &kv)\n            if err != nil {\n                if grpc.Code(err) == codes.NotFound {\n                    w.WriteHeader(http.StatusNotFound)\n                    return\n                }\n                log.Errorf(\"failed to get: %s\", err.Error())\n                w.WriteHeader(http.StatusInternalServerError)\n                return\n            }\n\n            w.WriteHeader(http.StatusOK)\n            resp, err := json.Marshal(gresp)\n            if err != nil {\n                log.Errorf(\"failed to marshal: %s\", err.Error())\n                w.WriteHeader(http.StatusInternalServerError)\n                return\n            }\n            w.Write(resp)\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net/http\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter8/grpcjson/internal\"\n        )\n\n        func main() {\n            c := Controller{KeyValue: internal.NewKeyValue()}\n            http.HandleFunc(\"/set\", c.SetHandler)\n            http.HandleFunc(\"/get\", c.GetHandler)\n\n            fmt.Println(\"Listening on port :3333\")\n            err := http.ListenAndServe(\":3333\", nil)\n            panic(err)\n        }\n```", "```go\n$ go run ./http\nListening on port :3333\n```", "```go\n$ curl \"http://localhost:3333/set\" -d '{\"key\":\"test\", \n \"value\":\"123\"}' -v $ curl \"http://localhost:3333/get?key=badtest\" -v $ curl \"http://localhost:3333/get?key=test\" -v\n```", "```go\n$ curl \"http://localhost:3333/set\" -d '{\"key\":\"test\", \n\"value\":\"123\"}' -v\n{\"value\":\"123\"}\n\n$ curl \"http://localhost:3333/get?key=badtest\" -v \n<should return a 404>\n\n$ curl \"http://localhost:3333/get?key=test\" -v \n{\"value\":\"123\"}\n```"]