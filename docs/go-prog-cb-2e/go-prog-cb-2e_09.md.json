["```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter9/mocking \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter9/mocking    \n```", "```go\n        package mocking\n\n        // DoStuffer is a simple interface\n        type DoStuffer interface {\n            DoStuff(input string) error\n        }\n```", "```go\n        package mocking\n\n        import \"reflect\"\n\n        // Restorer holds a function that can be used\n        // to restore some previous state.\n        type Restorer func()\n\n        // Restore restores some previous state.\n        func (r Restorer) Restore() {\n            r()\n        }\n\n        // Patch sets the value pointed to by the given destination to \n        // the given value, and returns a function to restore it to its \n        // original value. The value must be assignable to the element \n        //type of the destination.\n        func Patch(dest, value interface{}) Restorer {\n            destv := reflect.ValueOf(dest).Elem()\n            oldv := reflect.New(destv.Type()).Elem()\n            oldv.Set(destv)\n            valuev := reflect.ValueOf(value)\n            if !valuev.IsValid() {\n                // This isn't quite right when the destination type is \n                // not nilable, but it's better than the complex \n                // alternative.\n                valuev = reflect.Zero(destv.Type())\n            }\n            destv.Set(valuev)\n            return func() {\n                destv.Set(oldv)\n            }\n        }\n```", "```go\n        package mocking\n        import \"errors\"\n        var ThrowError = func() error {\n            return errors.New(\"always fails\")\n        }\n\n        func DoSomeStuff(d DoStuffer) error {\n\n            if err := d.DoStuff(\"test\"); err != nil {\n                return err\n            }\n\n            if err := ThrowError(); err != nil {\n                return err\n            }\n\n            return nil\n        }\n```", "```go\n        package mocking\n        type MockDoStuffer struct {\n            // closure to assist with mocking\n            MockDoStuff func(input string) error\n        }\n        func (m *MockDoStuffer) DoStuff(input string) error {\n            if m.MockDoStuff != nil {\n                return m.MockDoStuff(input)\n            }\n            // if we don't mock, return a common case\n            return nil\n        }\n```", "```go\n        package mocking\n        import (\n            \"errors\"\n            \"testing\"\n        )\n\n        func TestDoSomeStuff(t *testing.T) {\n            tests := []struct {\n                name       string\n                DoStuff    error\n                ThrowError error\n                wantErr    bool\n            }{\n                {\"base-case\", nil, nil, false},\n                {\"DoStuff error\", errors.New(\"failed\"), nil, true},\n                {\"ThrowError error\", nil, errors.New(\"failed\"), true},\n            }\n            for _, tt := range tests {\n                t.Run(tt.name, func(t *testing.T) {\n                    // An example of mocking an interface\n                    // with our mock struct\n                    d := MockDoStuffer{}\n                    d.MockDoStuff = func(string) error {\n                    return tt.DoStuff }\n\n                   // mocking a function that is declared as a variable\n                   // will not work for func A(),\n                   // must be var A = func()\n                   defer Patch(&ThrowError, func() error { return \n                   tt.ThrowError }).Restore()\n\n                  if err := DoSomeStuff(&d); (err != nil) != tt.wantErr \n                  {\n                      t.Errorf(\"DoSomeStuff() error = %v, \n                      wantErr %v\", err, tt.wantErr)\n                  }\n                })\n            }\n        }\n```", "```go\n$go test\nPASS\nok github.com/PacktPublishing/Go-Programming-Cookbook-Second-\nEdition/chapter9/mocking 0.006s \n```", "```go\n// Whatever package you wanna patch\nimport \"github.com/package\" \n\n// This is patchable using the method described in this recipe\nvar packageDoSomething = package.DoSomething\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter9/mockgen \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter9/mockgen    \n```", "```go\n        package mockgen\n\n        // GetSetter implements get a set of a\n        // key value pair\n        type GetSetter interface {\n            Set(key, val string) error\n            Get(key string) (string, error)\n        }\n```", "```go\n        package mockgen\n\n        // Controller is a struct demonstrating\n        // one way to initialize interfaces\n        type Controller struct {\n            GetSetter\n        }\n\n        // GetThenSet checks if a value is set. If not\n        // it sets it.\n        func (c *Controller) GetThenSet(key, value string) error {\n            val, err := c.Get(key)\n            if err != nil {\n                return err\n            }\n\n            if val != value {\n                return c.Set(key, value)\n            }\n            return nil\n        }\n```", "```go\n        package mockgen\n\n        import (\n            \"errors\"\n            \"testing\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter9/mockgen/internal\"\n            \"github.com/golang/mock/gomock\"\n        )\n\n        func TestExample(t *testing.T) {\n            ctrl := gomock.NewController(t)\n            defer ctrl.Finish()\n\n            mockGetSetter := internal.NewMockGetSetter(ctrl)\n\n            var k string\n            mockGetSetter.EXPECT().Get(\"we can put anything \n            here!\").Do(func(key string) {\n                k = key\n            }).Return(\"\", nil)\n\n            customError := errors.New(\"failed this time\")\n\n            mockGetSetter.EXPECT().Get(gomock.Any()).Return(\"\", \n            customError)\n\n            if _, err := mockGetSetter.Get(\"we can put anything \n            here!\"); err != nil {\n                t.Errorf(\"got %#v; want %#v\", err, nil)\n            }\n            if k != \"we can put anything here!\" {\n                t.Errorf(\"bad key\")\n            }\n\n            if _, err := mockGetSetter.Get(\"key\"); err == nil {\n                t.Errorf(\"got %#v; want %#v\", err, customError)\n            }\n        }\n```", "```go\n        package mockgen\n\n        import (\n            \"errors\"\n            \"testing\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter9/mockgen/internal\"\n            \"github.com/golang/mock/gomock\"\n        )\n\n        func TestController_Set(t *testing.T) {\n            tests := []struct {\n                name string\n                getReturnVal string\n                getReturnErr error\n                setReturnErr error\n                wantErr bool\n            }{\n                {\"get error\", \"value\", errors.New(\"failed\"), nil, \n                true},\n                {\"value match\", \"value\", nil, nil, false},\n                {\"no errors\", \"not set\", nil, nil, false},\n                {\"set error\", \"not set\", nil, errors.New(\"failed\"),\n                true},\n            }\n            for _, tt := range tests {\n                t.Run(tt.name, func(t *testing.T) {\n                    ctrl := gomock.NewController(t)\n                    defer ctrl.Finish()\n\n                    mockGetSetter := internal.NewMockGetSetter(ctrl)\n                    mockGetSetter.EXPECT().Get(\"key\").AnyTimes()\n                    .Return(tt.getReturnVal, tt.getReturnErr)\n                    mockGetSetter.EXPECT().Set(\"key\", \n                    gomock.Any()).AnyTimes().Return(tt.setReturnErr)\n\n                    c := &Controller{\n                        GetSetter: mockGetSetter,\n                    }\n                    if err := c.GetThenSet(\"key\", \"value\"); (err != \n                    nil) != tt.wantErr {\n                        t.Errorf(\"Controller.Set() error = %v, wantErr \n                        %v\", err, tt.wantErr)\n                    }\n                })\n             }\n        }\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter9/coverage \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter9/coverage    \n```", "```go\n        package main\n\n        import \"errors\"\n\n        // Coverage is a simple function with some branching conditions\n        func Coverage(condition bool) error {\n            if condition {\n                return errors.New(\"condition was set\")\n            }\n            return nil\n        }\n```", "```go\n        package main\n\n        import \"testing\"\n\n        func TestCoverage(t *testing.T) {\n            type args struct {\n                condition bool\n            }\n            tests := []struct {\n                name string\n                args args\n                wantErr bool\n            }{\n                // TODO: Add test cases.\n            }\n            for _, tt := range tests {\n                t.Run(tt.name, func(t *testing.T) {\n                    if err := Coverage(tt.args.condition); (err != nil) \n                    != tt.wantErr {\n                        t.Errorf(\"Coverage() error = %v, wantErr %v\", \n                        err, tt.wantErr)\n                    }\n                })\n            }\n        }\n```", "```go\n        {\"no condition\", args{true}, true},\n```", "```go\n$ go test -cover \nPASS\ncoverage: 66.7% of statements\nok github.com/PacktPublishing/Go-Programming-Cookbook-Second-\nEdition/chapter9/coverage 0.007s\n```", "```go\n        {\"condition\", args{false}, false},\n```", "```go\n$ go test -cover \nPASS\ncoverage: 100.0% of statements\nok github.com/PacktPublishing/Go-Programming-Cookbook-Second-\nEdition/chapter9/coverage 0.007s\n```", "```go\n$ go test -coverprofile=cover.out \n$ go tool cover -html=cover.out -o coverage.html\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter9/tools \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter9/tools\n```", "```go\n        package tools\n\n        import (\n            \"fmt\"\n        )\n\n        func example() error {\n            fmt.Println(\"in example\")\n            return nil\n        }\n\n        var example2 = func() int {\n            fmt.Println(\"in example2\")\n            return 10\n        }\n```", "```go\n        package tools\n\n        import (\n            \"errors\"\n            \"fmt\"\n        )\n\n        type c struct {\n            Branch bool\n        }\n\n        func (c *c) example3() error {\n            fmt.Println(\"in example3\")\n            if c.Branch {\n                fmt.Println(\"branching code!\")\n                return errors.New(\"bad branch\")\n            }\n            return nil\n        }\n```", "```go\n        package tools\n\n        import (\n            \"testing\"\n\n            . \"github.com/smartystreets/goconvey/convey\"\n        )\n\n        func Test_example(t *testing.T) {\n            tests := []struct {\n                name string\n            }{\n                {\"base-case\"},\n            }\n            for _, tt := range tests {\n                Convey(tt.name, t, func() {\n                    res := example()\n                    So(res, ShouldBeNil)\n                })\n            }\n        }\n\n        func Test_example2(t *testing.T) {\n            tests := []struct {\n                name string\n            }{\n                {\"base-case\"},\n            }\n            for _, tt := range tests {\n                Convey(tt.name, t, func() {\n                    res := example2()\n                    So(res, ShouldBeGreaterThanOrEqualTo, 1)\n                })\n            }\n        }\n```", "```go\n        package tools\n\n        import (\n            \"testing\"\n\n            . \"github.com/smartystreets/goconvey/convey\"\n        )\n\n        func Test_c_example3(t *testing.T) {\n            type fields struct {\n                Branch bool\n            }\n            tests := []struct {\n                name string\n                fields fields\n                wantErr bool\n            }{\n                {\"no branch\", fields{false}, false},\n                {\"branch\", fields{true}, true},\n            }\n            for _, tt := range tests {\n                Convey(tt.name, t, func() {\n                    c := &c{\n                        Branch: tt.fields.Branch,\n                    }\n                    So((c.example3() != nil), ShouldEqual, tt.wantErr)\n                })\n            }\n        }\n```", "```go\n$ gocov test | gocov report\nok github.com/PacktPublishing/Go-Programming-Cookbook-Second-\nEdition/chapter9/tools 0.006s \ncoverage: 100.0% of statements\n\ngithub.com/PacktPublishing/Go-Programming-Cookbook-Second-\nEdition/chapter9/tools/struct.go \nc.example3 100.00% (5/5)\ngithub.com/PacktPublishing/Go-Programming-Cookbook-Second-\nEdition/chapter9/tools/funcs.go example \n100.00% (2/2)\ngithub.com/PacktPublishing/Go-Programming-Cookbook-Second-\nEdition/chapter9/tools/funcs.go @12:16 \n100.00% (2/2)\ngithub.com/PacktPublishing/Go-Programming-Cookbook-Second-\nEdition/chapter9/tools ---------- \n100.00% (9/9)\n\nTotal Coverage: 100.00% (9/9)\n```", "```go\nConvey(\"Outer loop\", t, func(){\n    a := 1\n    Convey(\"Inner loop\", t, func() {\n        a = 2\n    })\n    Convey (\"Inner loop2\", t, func(){\n        fmt.Println(a)\n     })\n})\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter9/bdd \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter9/bdd\n```", "```go\n        package bdd\n\n        import (\n            \"encoding/json\"\n            \"fmt\"\n            \"net/http\"\n        )\n\n        // HandlerRequest will be json decoded\n        // into by Handler\n        type HandlerRequest struct {\n            Name string `json:\"name\"`\n        }\n\n        // Handler takes a request and renders a response\n        func Handler(w http.ResponseWriter, r *http.Request) {\n            w.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n            if r.Method != http.MethodPost {\n                w.WriteHeader(http.StatusMethodNotAllowed)\n                return\n            }\n\n            dec := json.NewDecoder(r.Body)\n            var req HandlerRequest\n            if err := dec.Decode(&req); err != nil {\n                w.WriteHeader(http.StatusBadRequest)\n                return\n            }\n\n            w.WriteHeader(http.StatusOK)\n            w.Write([]byte(fmt.Sprintf(\"BDD testing %s\", req.Name)))\n        }\n```", "```go\n        Feature: Bad Method\n         Scenario: Good request\n         Given we create a HandlerRequest payload with:\n            | reader |\n            | coder |\n            | other |\n         And we POST the HandlerRequest to /hello\n         Then the response code should be 200\n         And the response body should be:\n            | BDD testing reader |\n            | BDD testing coder |\n            | BDD testing other |\n```", "```go\n$ godog\n.\n1 scenarios (1 undefined)\n4 steps (4 undefined)\n89.062\u00b5s\n.\n```", "```go\n        package bdd\n\n        import (\n            \"bytes\"\n            \"encoding/json\"\n            \"fmt\"\n            \"net/http/httptest\"\n\n            \"github.com/DATA-DOG/godog\"\n            \"github.com/DATA-DOG/godog/gherkin\"\n        )\n\n        var payloads []HandlerRequest\n        var resps []*httptest.ResponseRecorder\n\n        func weCreateAHandlerRequestPayloadWith(arg1 \n        *gherkin.DataTable) error {\n            for _, row := range arg1.Rows {\n                h := HandlerRequest{\n                    Name: row.Cells[0].Value,\n                }\n                payloads = append(payloads, h)\n            }\n            return nil\n        }\n\n        func wePOSTTheHandlerRequestToHello() error {\n            for _, p := range payloads {\n                v, err := json.Marshal(p)\n                if err != nil {\n                    return err\n                }\n                w := httptest.NewRecorder()\n                r := httptest.NewRequest(\"POST\", \"/hello\", \n                bytes.NewBuffer(v))\n\n                Handler(w, r)\n                resps = append(resps, w)\n            }\n            return nil\n        }\n```", "```go\n$ godog\n.\n1 scenarios (1 pending)\n4 steps (2 passed, 1 pending, 1 skipped)\n.\n```", "```go\n        func theResponseCodeShouldBe(arg1 int) error {\n            for _, r := range resps {\n                if got, want := r.Code, arg1; got != want {\n                    return fmt.Errorf(\"got: %d; want %d\", got, want)\n                }\n            }\n            return nil\n        }\n\n        func theResponseBodyShouldBe(arg1 *gherkin.DataTable) error {\n            for c, row := range arg1.Rows {\n                b := bytes.Buffer{}\n                b.ReadFrom(resps[c].Body)\n                if got, want := b.String(), row.Cells[0].Value;\n                got != want \n                {\n                    return fmt.Errorf(\"got: %s; want %s\", got, want)\n                }\n            }\n            return nil\n        }\n\n        func FeatureContext(s *godog.Suite) {\n            s.Step(`^we create a HandlerRequest payload with:$`, \n            weCreateAHandlerRequestPayloadWith)\n            s.Step(`^we POST the HandlerRequest to /hello$`, \n            wePOSTTheHandlerRequestToHello)\n            s.Step(`^the response code should be (d+)$`, \n            theResponseCodeShouldBe)\n            s.Step(`^the response body should be:$`, \n            theResponseBodyShouldBe)\n        }\n```", "```go\n$ godog \n.\n1 scenarios (1 passed)\n4 steps (4 passed)\n552.605\u00b5s\n.\n```"]