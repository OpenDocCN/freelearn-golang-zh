["```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/discovery \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/discovery    \n```", "```go\n        package discovery\n\n        import \"github.com/hashicorp/consul/api\"\n\n        // Client exposes api methods we care\n        // about\n        type Client interface {\n            Register(tags []string) error\n            Service(service, tag string) ([]*api.ServiceEntry,  \n            *api.QueryMeta, error)\n        }\n\n        type client struct {\n            client *api.Client\n            address string\n            name string\n            port int\n        }\n\n        //NewClient iniitalizes a consul client\n        func NewClient(config *api.Config, address, name string, port         \n        int) (Client, error) {\n            c, err := api.NewClient(config)\n            if err != nil {\n                return nil, err\n            }\n            cli := &client{\n                client: c,\n                name: name,\n                address: address,\n                port: port,\n            }\n            return cli, nil\n        }\n```", "```go\n        package discovery\n\n        import \"github.com/hashicorp/consul/api\"\n\n        // Register adds our service to consul\n        func (c *client) Register(tags []string) error {\n            reg := &api.AgentServiceRegistration{\n                ID: c.name,\n                Name: c.name,\n                Port: c.port,\n                Address: c.address,\n                Tags: tags,\n            }\n            return c.client.Agent().ServiceRegister(reg)\n        }\n\n        // Service return a service\n        func (c *client) Service(service, tag string) \n        ([]*api.ServiceEntry, *api.QueryMeta, error) {\n            return c.client.Health().Service(service, tag, false, \n            nil)\n        }\n```", "```go\npackage discovery\n\nimport \"fmt\"\n\n// Exec creates a consul entry then queries it\nfunc Exec(cli Client) error {\n  if err := cli.Register([]string{\"Go\", \"Awesome\"}); err != nil {\n    return err\n  }\n\n  entries, _, err := cli.Service(\"discovery\", \"Go\")\n  if err != nil {\n    return err\n  }\n  for _, entry := range entries {\n    fmt.Printf(\"%#v\\n\", entry.Service)\n  }\n\n  return nil\n}\n```", "```go\n        package main\n\n        import \"github.com/PacktPublishing/\n                Go-Programming-Cookbook-Second-Edition/\n                chapter11/discovery\"\n\n        func main() {\n            if err := discovery.Exec(); err != nil {\n                panic(err)\n            }\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\n&api.AgentService{ID:\"discovery\", Service:\"discovery\", Tags:    \n[]string{\"Go\", \"Awesome\"}, Port:8080, Address:\"localhost\",     \nEnableTagOverride:false, CreateIndex:0x23, ModifyIndex:0x23}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/consensus \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/consensus    \n```", "```go\n        package consensus\n\n        type state string\n\n        const (\n            first state = \"first\"\n            second = \"second\"\n            third = \"third\"\n        )\n\n        var allowedState map[state][]state\n\n        func init() {\n            // setup valid states\n            allowedState = make(map[state][]state)\n            allowedState[first] = []state{second, third}\n            allowedState[second] = []state{third}\n            allowedState[third] = []state{first}\n        }\n\n        // CanTransition checks if a new state is valid\n        func (s *state) CanTransition(next state) bool {\n            for _, n := range allowedState[*s] {\n                if n == next {\n                    return true\n                }\n            }\n            return false\n        }\n\n        // Transition will move a state to the next\n        // state if able\n        func (s *state) Transition(next state) {\n            if s.CanTransition(next) {\n                *s = next\n            }\n        }\n```", "```go\npackage consensus\n\nimport (\n  \"fmt\"\n\n  \"github.com/hashicorp/raft\"\n)\n\n// keep a map of rafts for later\nvar rafts map[raft.ServerAddress]*raft.Raft\n\nfunc init() {\n  rafts = make(map[raft.ServerAddress]*raft.Raft)\n}\n\n// raftSet stores all the setup material we need\ntype raftSet struct {\n  Config *raft.Config\n  Store *raft.InmemStore\n  SnapShotStore raft.SnapshotStore\n  FSM *FSM\n  Transport raft.LoopbackTransport\n  Configuration raft.Configuration\n}\n\n// generate n raft sets to bootstrap the raft cluster\nfunc getRaftSet(num int) []*raftSet {\n  rs := make([]*raftSet, num)\n  servers := make([]raft.Server, num)\n  for i := 0; i < num; i++ {\n    addr := raft.ServerAddress(fmt.Sprint(i))\n    _, transport := raft.NewInmemTransport(addr)\n    servers[i] = raft.Server{\n      Suffrage: raft.Voter,\n      ID: raft.ServerID(addr),\n      Address: addr,\n    }\n    config := raft.DefaultConfig()\n    config.LocalID = raft.ServerID(addr)\n\n    rs[i] = &raftSet{\n      Config: config,\n      Store: raft.NewInmemStore(),\n      SnapShotStore: raft.NewInmemSnapshotStore(),\n      FSM: NewFSM(),\n      Transport: transport,\n    }\n  }\n\n  // configuration needs to be consistent between\n  // services and so we need the full serverlist in this\n  // case\n  for _, r := range rs {\n    r.Configuration = raft.Configuration{Servers: servers}\n  }\n\n  return rs\n}\n```", "```go\npackage consensus\n\nimport (\n  \"github.com/hashicorp/raft\"\n)\n\n// Config creates num in-memory raft\n// nodes and connects them\nfunc Config(num int) {\n\n  // create n \"raft-sets\" consisting of\n  // everything needed to represent a node\n  rs := getRaftSet(num)\n\n  //connect all of the transports\n  for _, r1 := range rs {\n    for _, r2 := range rs {\n      r1.Transport.Connect(r2.Transport.LocalAddr(), r2.Transport)\n    }\n  }\n\n  // for each node, bootstrap then connect\n  for _, r := range rs {\n    if err := raft.BootstrapCluster(r.Config, r.Store, r.Store, r.SnapShotStore, r.Transport, r.Configuration); err != nil {\n      panic(err)\n    }\n    raft, err := raft.NewRaft(r.Config, r.FSM, r.Store, r.Store, r.SnapShotStore, r.Transport)\n    if err != nil {\n      panic(err)\n    }\n    rafts[r.Transport.LocalAddr()] = raft\n  }\n}\n```", "```go\n        package consensus\n\n        import (\n            \"io\"\n\n            \"github.com/hashicorp/raft\"\n        )\n\n        // FSM implements the raft FSM interface\n        // and holds a state\n        type FSM struct {\n            state state\n        }\n\n        // NewFSM creates a new FSM with\n        // start state of \"first\"\n        func NewFSM() *FSM {\n            return &FSM{state: first}\n        }\n\n        // Apply updates our FSM\n        func (f *FSM) Apply(r *raft.Log) interface{} {\n            f.state.Transition(state(r.Data))\n            return string(f.state)\n        }\n\n        // Snapshot needed to satisfy the raft FSM interface\n        func (f *FSM) Snapshot() (raft.FSMSnapshot, error) {\n            return nil, nil\n        }\n\n        // Restore needed to satisfy the raft FSM interface\n        func (f *FSM) Restore(io.ReadCloser) error {\n            return nil\n        }\n```", "```go\npackage consensus\n\nimport (\n  \"net/http\"\n  \"time\"\n)\n\n// Handler grabs the get param ?next= and tries\n// to transition to the state contained there\nfunc Handler(w http.ResponseWriter, r *http.Request) {\n  r.ParseForm()\n  state := r.FormValue(\"next\")\n  for address, raft := range rafts {\n    if address != raft.Leader() {\n      continue\n    }\n\n    result := raft.Apply([]byte(state), 1*time.Second)\n    if result.Error() != nil {\n      w.WriteHeader(http.StatusBadRequest)\n      return\n    }\n    newState, ok := result.Response().(string)\n    if !ok {\n      w.WriteHeader(http.StatusInternalServerError)\n      return\n    }\n\n    if newState != state {\n      w.WriteHeader(http.StatusBadRequest)\n      w.Write([]byte(\"invalid transition\"))\n      return\n    }\n    w.WriteHeader(http.StatusOK)\n    w.Write([]byte(newState))\n    return\n  }\n}\n```", "```go\n        package main\n\n        import (\n            \"net/http\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter11/consensus\"\n        )\n\n        func main() {\n            consensus.Config(3)\n\n            http.HandleFunc(\"/\", consensus.Handler)\n            err := http.ListenAndServe(\":3333\", nil)\n            panic(err)\n        }\n```", "```go\n$ go build\n$ ./example\n```", "```go\n$ go run main.go\n2019/05/04 21:06:46 [INFO] raft: Initial configuration (index=1): [{Suffrage:Voter ID:0 Address:0} {Suffrage:Voter ID:1 Address:1} {Suffrage:Voter ID:2 Address:2}]\n2019/05/04 21:06:46 [INFO] raft: Initial configuration (index=1): [{Suffrage:Voter ID:0 Address:0} {Suffrage:Voter ID:1 Address:1} {Suffrage:Voter ID:2 Address:2}]\n2019/05/04 21:06:46 [INFO] raft: Node at 0 [Follower] entering Follower state (Leader: \"\")\n2019/05/04 21:06:46 [INFO] raft: Node at 1 [Follower] entering Follower state (Leader: \"\")\n2019/05/04 21:06:46 [INFO] raft: Initial configuration (index=1): [{Suffrage:Voter ID:0 Address:0} {Suffrage:Voter ID:1 Address:1} {Suffrage:Voter ID:2 Address:2}]\n2019/05/04 21:06:46 [INFO] raft: Node at 2 [Follower] entering Follower state (Leader: \"\")\n2019/05/04 21:06:47 [WARN] raft: Heartbeat timeout from \"\" reached, starting election\n2019/05/04 21:06:47 [INFO] raft: Node at 0 [Candidate] entering Candidate state in term 2\n2019/05/04 21:06:47 [DEBUG] raft: Votes needed: 2\n2019/05/04 21:06:47 [DEBUG] raft: Vote granted from 0 in term 2\\. Tally: 1\n2019/05/04 21:06:47 [DEBUG] raft: Vote granted from 1 in term 2\\. Tally: 2\n2019/05/04 21:06:47 [INFO] raft: Election won. Tally: 2\n2019/05/04 21:06:47 [INFO] raft: Node at 0 [Leader] entering Leader state\n2019/05/04 21:06:47 [INFO] raft: Added peer 1, starting replication\n2019/05/04 21:06:47 [INFO] raft: Added peer 2, starting replication\n2019/05/04 21:06:47 [INFO] raft: pipelining replication to peer {Voter 1 1}\n2019/05/04 21:06:47 [INFO] raft: pipelining replication to peer {Voter 2 2}\n```", "```go\n$ curl \"http://localhost:3333/?next=second\" \nsecond\n\n$ curl \"http://localhost:3333/?next=third\" \nthird\n\n$ curl \"http://localhost:3333/?next=second\" \ninvalid transition\n\n$ curl \"http://localhost:3333/?next=first\" \nfirst\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/docker \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/docker    \n```", "```go\n        FROM alpine\n\n        ADD ./example/example /example\n        EXPOSE 8000\n        ENTRYPOINT /example \n```", "```go\n        #!/usr/bin/env bash\n\n        pushd example\n        env GOOS=linux go build -ldflags \"-X main.version=1.0 -X     \n        main.builddate=$(date +%s)\"\n        popd\n        docker build . -t example\n        docker run -d -p 8000:8000 example \n```", "```go\n        package docker\n\n        import (\n            \"encoding/json\"\n            \"net/http\"\n            \"time\"\n        )\n\n        // VersionInfo holds artifacts passed in\n        // at build time\n        type VersionInfo struct {\n            Version string\n            BuildDate time.Time\n            Uptime time.Duration\n        }\n\n        // VersionHandler writes the latest version info\n        func VersionHandler(v *VersionInfo) http.HandlerFunc {\n            t := time.Now()\n            return func(w http.ResponseWriter, r *http.Request) {\n                v.Uptime = time.Since(t)\n                vers, err := json.Marshal(v)\n                    if err != nil {\n                        w.WriteHeader\n                        (http.StatusInternalServerError)\n                        return\n                    }\n                    w.WriteHeader(http.StatusOK)\n                    w.Write(vers)\n            }\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net/http\"\n            \"strconv\"\n            \"time\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter11/docker\"\n        )\n\n        // these are set at build time\n        var (\n            version string\n            builddate string\n            )\n\n            var versioninfo docker.VersionInfo\n\n            func init() {\n                // parse buildtime variables\n                versioninfo.Version = version\n                i, err := strconv.ParseInt(builddate, 10, 64)\n                    if err != nil {\n                        panic(err)\n                    }\n                    tm := time.Unix(i, 0)\n                    versioninfo.BuildDate = tm\n            }\n\n            func main() {\n            http.HandleFunc(\"/version\",     \n            docker.VersionHandler(&versioninfo))\n            fmt.Printf(\"version %s listening on :8000\\n\",   \n            versioninfo.Version)\n            panic(http.ListenAndServe(\":8000\", nil))\n        }\n```", "```go\n$ bash setup.sh\n```", "```go\n$ bash setup.sh\n~/go/src/github.com/PacktPublishing/Go-Programming-Cookbook-\nSecond-Edition/chapter11/docker/example   \n~/go/src/github.com/PacktPublishing/Go-Programming-Cookbook-\nSecond-Edition/chapter11/docker\n~/go/src/github.com/PacktPublishing/Go-Programming-Cookbook-   \nSecond-Edition/chapter11/docker\nSending build context to Docker daemon 6.031 MB\nStep 1/4 : FROM alpine\n ---> 4a415e366388\nStep 2/4 : ADD ./example/example /example\n ---> de34c3c5451e\nRemoving intermediate container bdcd9c4f4381\nStep 3/4 : EXPOSE 8000\n ---> Running in 188f450d4e7b\n ---> 35d1a2652b43\nRemoving intermediate container 188f450d4e7b\nStep 4/4 : ENTRYPOINT /example\n ---> Running in cf0af4f48c3a\n ---> 3d737fc4e6e2\nRemoving intermediate container cf0af4f48c3a\nSuccessfully built 3d737fc4e6e2\nb390ef429fbd6e7ff87058dc82e15c3e7a8b2e\n69a601892700d1d434e9e8e43b\n```", "```go\n$ docker ps\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\nb390ef429fbd example \"/bin/sh -c /example\" 22 seconds ago Up 23    \nseconds 0.0.0.0:8000->8000/tcp optimistic_wescoff\n\n$ curl localhost:8000/version\n{\"Version\":\"1.0\",\"BuildDate\":\"2017-04-   \n30T21:55:56Z\",\"Uptime\":48132111264}\n\n$docker kill optimistic_wescoff # grab from first output\noptimistic_wescoff\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/orchestrate \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/orchestrate    \n```", "```go\nFROM golang:1.12.4-alpine3.9\n\nENV GOPATH /code/\nADD . /code/src/github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/docker\nWORKDIR /code/src/github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/docker/example\nRUN GO111MODULE=on GOPROXY=off go build -mod=vendor\n\nENTRYPOINT /code/src/github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/docker/example/example\n```", "```go\n        version: '2'\n        services:\n         app:\n         build: .\n         mongodb:\n         image: \"mongo:latest\"\n```", "```go\npackage mongodb\n\nimport (\n  \"context\"\n  \"fmt\"\n  \"time\"\n\n  \"github.com/mongodb/mongo-go-driver/mongo\"\n  \"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\n// Setup initializes a mongo client\nfunc Setup(ctx context.Context, address string) (*mongo.Client, error) {\n  ctx, cancel := context.WithTimeout(ctx, 1*time.Second)\n  defer cancel()\n\n  fmt.Println(address)\n  client, err := mongo.NewClient(options.Client().ApplyURI(address))\n  if err != nil {\n    return nil, err\n  }\n\n  if err := client.Connect(ctx); err != nil {\n    return nil, err\n  }\n  return client, nil\n}\n\n```", "```go\npackage mongodb\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/mongodb/mongo-go-driver/bson\"\n)\n\n// State is our data model\ntype State struct {\n  Name string `bson:\"name\"`\n  Population int `bson:\"pop\"`\n}\n\n// Exec creates then queries an Example\nfunc Exec(address string) error {\n  ctx := context.Background()\n  db, err := Setup(ctx, address)\n  if err != nil {\n    return err\n  }\n\n  conn := db.Database(\"gocookbook\").Collection(\"example\")\n\n  vals := []interface{}{&State{\"Washington\", 7062000}, &State{\"Oregon\", 3970000}}\n\n  // we can inserts many rows at once\n  if _, err := conn.InsertMany(ctx, vals); err != nil {\n    return err\n  }\n\n  var s State\n  if err := conn.FindOne(ctx, bson.M{\"name\": \"Washington\"}).Decode(&s); err != nil {\n    return err\n  }\n\n  if err := conn.Drop(ctx); err != nil {\n    return err\n  }\n\n  fmt.Printf(\"State: %#v\\n\", s)\n  return nil\n}\n```", "```go\npackage main\n\nimport mongodb \"github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/orchestrate\"\n\nfunc main() {\n  if err := mongodb.Exec(\"mongodb://mongodb:27017\"); err != nil {\n    panic(err)\n  }\n}\n```", "```go\n$ docker logs orchestrate_app_1\nState: docker.State{Name:\"Washington\", Population:7062000}\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/monitoring \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/monitoring    \n```", "```go\n        FROM golang:1.12.4-alpine3.9\n\n        ENV GOPATH /code/\n        ADD . /code/src/github.com/agtorre/go-\n        cookbook/chapter11/monitoring\n        WORKDIR /code/src/github.com/agtorre/go-\n        cookbook/chapter11/monitoring\n        RUN GO111MODULE=on GOPROXY=off go build -mod=vendor\n\n        ENTRYPOINT /code/src/github.com/agtorre/go-\n        cookbook/chapter11/monitoring/monitoring\n```", "```go\n        version: '2'\n        services:\n         app:\n         build: .\n         prometheus:\n         ports: \n         - 9090:9090\n         volumes: \n         - ./prometheus.yml:/etc/prometheus/prometheus.yml\n         image: \"prom/prometheus\"\n```", "```go\n        package main\n\n        import (\n            \"net/http\"\n\n            \"github.com/prometheus/client_golang/prometheus/promhttp\"\n        )\n\n        func main() {\n            http.Handle(\"/metrics\", promhttp.Handler())\n            panic(http.ListenAndServe(\":80\", nil))\n        }\n```", "```go\n        global:\n         scrape_interval: 15s # By default, scrape targets every 15 \n         seconds.\n\n        # A scrape configuration containing exactly one endpoint to \n        scrape:\n        # Here it's Prometheus itself.\n        scrape_configs:\n         # The job name is added as a label `job=<job_name>` to any \n         timeseries scraped from this config.\n         - job_name: 'app'\n\n         # Override the global default and scrape targets from this job          \n         every 5 seconds.\n         scrape_interval: 5s\n\n         static_configs:\n         - targets: ['app:80']\n```", "```go\n$ docker-compose up\nStarting monitoring_prometheus_1 ... done\nStarting monitoring_app_1 ... done\nAttaching to monitoring_app_1, monitoring_prometheus_1\nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Starting prometheus (version=1.6.1, branch=master, revision=4666df502c0e239ed4aa1d80abbbfb54f61b23c3)\" source=\"main.go:88\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Build context (go=go1.8.1, user=root@7e45fa0366a7, date=20170419-14:32:22)\" source=\"main.go:89\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Loading configuration file /etc/prometheus/prometheus.yml\" source=\"main.go:251\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Loading series map and head chunks...\" source=\"storage.go:421\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=warning msg=\"Persistence layer appears dirty.\" source=\"persistence.go:846\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=warning msg=\"Starting crash recovery. Prometheus is inoperational until complete.\" source=\"crashrecovery.go:40\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=warning msg=\"To avoid crash recovery in the future, shut down Prometheus with SIGTERM or a HTTP POST to /-/quit.\" source=\"crashrecovery.go:41\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Scanning files.\" source=\"crashrecovery.go:55\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"File scan complete. 43 series found.\" source=\"crashrecovery.go:83\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Checking for series without series file.\" source=\"crashrecovery.go:85\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Check for series without series file complete.\" source=\"crashrecovery.go:131\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Cleaning up archive indexes.\" source=\"crashrecovery.go:411\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Clean-up of archive indexes complete.\" source=\"crashrecovery.go:504\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Rebuilding label indexes.\" source=\"crashrecovery.go:512\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Indexing metrics in memory.\" source=\"crashrecovery.go:513\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Indexing archived metrics.\" source=\"crashrecovery.go:521\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"All requests for rebuilding the label indexes queued. (Actual processing may lag behind.)\" source=\"crashrecovery.go:540\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=warning msg=\"Crash recovery complete.\" source=\"crashrecovery.go:153\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"43 series loaded.\" source=\"storage.go:432\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Starting target manager...\" source=\"targetmanager.go:61\" \nprometheus_1 | time=\"2019-05-05T03:10:25Z\" level=info msg=\"Listening on :9090\" source=\"web.go:259\" \n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/metrics \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter11/metrics    \n```", "```go\n        package metrics\n\n        import (\n            \"net/http\"\n            \"time\"\n\n            metrics \"github.com/rcrowley/go-metrics\"\n        )\n\n        // CounterHandler will update a counter each time it's called\n        func CounterHandler(w http.ResponseWriter, r *http.Request) {\n            c := metrics.GetOrRegisterCounter(\"counterhandler.counter\", \n            nil)\n            c.Inc(1)\n\n            w.WriteHeader(http.StatusOK)\n            w.Write([]byte(\"success\"))\n        }\n\n        // TimerHandler records the duration required to compelete\n        func TimerHandler(w http.ResponseWriter, r *http.Request) {\n            currt := time.Now()\n            t := metrics.GetOrRegisterTimer(\"timerhandler.timer\", nil)\n\n            w.WriteHeader(http.StatusOK)\n            w.Write([]byte(\"success\"))\n            t.UpdateSince(currt)\n        }\n```", "```go\n        package metrics\n\n        import (\n            \"net/http\"\n\n            gometrics \"github.com/rcrowley/go-metrics\"\n        )\n\n        // ReportHandler will emit the current metrics in json format\n        func ReportHandler(w http.ResponseWriter, r *http.Request) {\n\n            w.WriteHeader(http.StatusOK)\n\n            t := gometrics.GetOrRegisterTimer(\n            \"reporthandler.writemetrics\", nil)\n            t.Time(func() {\n                gometrics.WriteJSONOnce(gometrics.DefaultRegistry, w)\n            })\n        }\n```", "```go\n        package main\n\n        import (\n            \"net/http\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter11/metrics\"\n        )\n\n        func main() {\n            // handler to populate metrics\n            http.HandleFunc(\"/counter\", metrics.CounterHandler)\n            http.HandleFunc(\"/timer\", metrics.TimerHandler)\n            http.HandleFunc(\"/report\", metrics.ReportHandler)\n            fmt.Println(\"listening on :8080\")\n            panic(http.ListenAndServe(\":8080\", nil))\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nlistening on :8080\n```", "```go\n$ curl localhost:8080/counter \nsuccess\n\n$ curl localhost:8080/timer \nsuccess\n\n$ curl localhost:8080/report \n{\"counterhandler.counter\":{\"count\":1},\n\"reporthandler.writemetrics\":      {\"15m.rate\":0,\"1m.rate\":0,\"5m.rate\":0,\"75%\":0,\"95%\":0,\"99%\":0,\"99.9%\":0,\"count\":0,\"max\":0,\"mean\":0,\"mean.rate\":0,\"median\":0,\"min\":0,\"stddev\":0},\"timerhandler.timer\":{\"15m.rate\":0.0011080303990206543,\"1m.rate\":0.015991117074135343,\"5m.rate\":0.0033057092356765017,\"75%\":60485,\"95%\":60485,\"99%\":60485,\"99.9%\":60485,\"count\":1,\"max\":60485,\"mean\":60485,\"mean.rate\":1.1334543719787356,\"median\":60485,\"min\":60485,\"stddev\":0}}\n```"]