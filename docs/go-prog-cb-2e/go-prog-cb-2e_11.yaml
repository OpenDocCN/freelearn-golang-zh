- en: Distributed Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式系统
- en: Sometimes, application-level parallelism is not enough, and things that seem
    simple in development can become complex during deployment. Distributed systems
    provide a number of challenges that aren't found when developing on a single machine.
    These applications have added complexity for things such as monitoring, writing
    applications that require strong consistency guarantees, and service discovery.
    In addition, you must always be mindful of single points of failure, such as a
    database, otherwise your distributed applications can fail when this single component
    fails.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用级并行性是不够的，开发中看起来简单的事情在部署过程中可能变得复杂。分布式系统在开发单台机器时找不到的一些挑战。这些应用程序增加了一些复杂性，比如监控、编写需要强一致性保证的应用程序和服务发现。此外，你必须时刻注意单点故障，比如数据库，否则你的分布式应用在这个单一组件失败时也会失败。
- en: This chapter will explore methods of managing distributed data, orchestration,
    containerization, metrics, and monitoring. These will become part of your toolbox
    for writing and maintaining microservices and large distributed applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨管理分布式数据、编排、容器化、指标和监控的方法。这些将成为你编写和维护微服务和大型分布式应用程序的工具箱的一部分。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Using service discovery with Consul
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Consul进行服务发现
- en: Implementing basic consensus using Raft
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Raft实现基本共识
- en: Using containerization with Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker进行容器化
- en: Orchestration and deployment strategies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排和部署策略
- en: Monitoring applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控应用程序
- en: Collecting metrics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集指标
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow all the recipes in this chapter, configure your environment according
    to these steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的所有配方，根据以下步骤配置你的环境：
- en: Download and install Go 1.12.6 or above on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install).
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://golang.org/doc/install](https://golang.org/doc/install)在你的操作系统上下载并安装Go
    1.12.6或更高版本。
- en: Install Consul from [https://www.consul.io/intro/getting-started/install.html](https://www.consul.io/intro/getting-started/install.html).
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.consul.io/intro/getting-started/install.html](https://www.consul.io/intro/getting-started/install.html)安装Consul。
- en: Open a Terminal or console application and create and navigate to a project
    directory such as `~/projects/go-programming-cookbook`. All the code will be run
    and modified from this directory.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端或控制台应用程序，并创建并进入一个项目目录，比如`~/projects/go-programming-cookbook`。所有的代码都将在这个目录中运行和修改。
- en: 'Clone the latest code into `~/projects/go-programming-cookbook-original` and
    (optionally) work from that directory rather than typing in the examples manually:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最新的代码克隆到`~/projects/go-programming-cookbook-original`，（可选）从该目录中工作，而不是手动输入示例。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using service discovery with Consul
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Consul进行服务发现
- en: When using the microservice approach to applications, you end up with a lot
    of servers listening on a variety of IPs, domains, and ports. These IP addresses
    will vary by environment (staging versus production), and it can be tricky to
    keep them static for configuration between services. You also want to know when
    a machine or service is down or unreachable due to a network partition. A network
    partition occurs when two parts of the network cannot reach each other. For example,
    if a switch fails between two data centers, then the services within one datacenter
    cannot reach services in the other datacenter. Consul is a tool that provides
    a lot of functionality, but here, we'll explore registering services with Consul
    and querying them from our other services.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用微服务方法来开发应用程序时，你最终会得到很多服务器监听各种IP、域和端口。这些IP地址会因环境（测试与生产）而异，并且在服务之间保持静态以进行配置可能会很棘手。你还想知道何时一台机器或服务因网络分区而宕机或不可达。网络分区发生在网络的两个部分无法相互到达时。例如，如果两个数据中心之间的交换机失败，那么一个数据中心内的服务就无法到达另一个数据中心内的服务。Consul是一个提供了很多功能的工具，但在这里，我们将探索如何使用Consul注册服务并从其他服务中查询它们。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/discovery` and
    navigate to it.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter11/discovery`的新目录并进入。
- en: 'Run the following command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个名为`go.mod`的文件，其中包含以下内容：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/discovery`,
    or use this as an opportunity to write some of your own code!
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`~/projects/go-programming-cookbook-original/chapter11/discovery`复制测试，或者利用这个机会编写一些你自己的代码！
- en: 'Create a file called `client.go` with the following content:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`client.go`的文件，内容如下：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a file called `operations.go` with the following content:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`operations.go`的文件，内容如下：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a file called `exec.go` with the following content:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`exec.go`的文件，内容如下：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录并进入。
- en: 'Create a file named `main.go` with the following content:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，内容如下：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Start Consul in a separate Terminal using the `consul agent -dev -node=localhost`
    command.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`consul agent -dev -node=localhost`命令在一个单独的终端中启动Consul。
- en: Run the `go run main.go` command.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`命令。
- en: 'You may also run the following commands:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以运行以下命令：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能会被更新，顶级配方目录中现在应该存在`go.sum`文件。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，返回上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Consul provides a robust Go API library. It can feel daunting when you're starting
    for the first time, but this recipe shows how you might approach wrapping it.
    Configuring Consul further is beyond the scope of this recipe; this shows the
    basics of registering a service and querying for other services when given a key
    and tag.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Consul提供了一个强大的Go API库。当您第一次开始时，可能会感到令人生畏，但这个配方展示了您可能如何封装它。进一步配置Consul超出了此配方的范围；这显示了注册服务和在给定密钥和标签时查询其他服务的基础知识。
- en: It would be possible to use this to register new microservices at startup time,
    query for all dependent services, and deregister at shutdown. You may also want
    to cache this information so that you're not hitting Consul for every request,
    but this recipe provides the basic tools that you can expand upon. The Consul
    agent also makes these repeated requests fast and efficient ([https://www.consul.io/intro/getting-started/agent.html](https://www.consul.io/intro/getting-started/agent.html)).
    Once you've s
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用此功能在启动时注册新的微服务，查询所有依赖服务，并在关闭时注销。您可能还希望缓存此信息，以便不必为每个请求访问Consul，但此配方提供了您可以扩展的基本工具。Consul代理还使这些重复请求变得快速和高效（[https://www.consul.io/intro/getting-started/agent.html](https://www.consul.io/intro/getting-started/agent.html)）。一旦您
- en: Implementing basic consensus using Raft
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Raft实现基本共识
- en: Raft is a consensus algorithm. It allows distributed systems to keep a shared
    and managed state ([https://raft.github.io/](https://raft.github.io/)). Setting
    up a Raft system is complex in many ways – for one, you need consensus for an
    election to occur and succeed. This can be difficult to bootstrap when you're
    working with multiple nodes and can be difficult to get started. It is possible
    to run a basic cluster on a single node/leader. However, if you want redundancy,
    at least three nodes are needed to prevent data loss in the case of a single node
    failure. This concept is known as quorum, where you must maintain (*n*/2)+1 available
    nodes to ensure new logs can be committed to the Raft cluster. Basically, if you
    can maintain quorum, the cluster remains healthy and usable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Raft是一种共识算法。它允许分布式系统保持共享和受控状态（[https://raft.github.io/](https://raft.github.io/)）。建立Raft系统在许多方面都很复杂-首先，您需要共识才能进行选举并成功。当您使用多个节点时，这可能很难引导，并且可能很难开始。在单个节点/领导者上可以运行基本集群。但是，如果您需要冗余性，至少需要三个节点，以防止单个节点故障导致数据丢失。这个概念被称为法定人数，您必须维护(*n*/2)+1个可用节点，以确保可以将新日志提交到Raft集群。基本上，如果您可以维持法定人数，集群将保持健康和可用。
- en: This recipe implements a basic in-memory Raft cluster, constructs a state machine
    that can transition between certain allowed states, and connects the distributed
    state machine to a web handler that can trigger the transition. This can be useful
    when you're implementing the base finite state machine interface that Raft requires,
    or when testing. This recipe uses [https://github.com/hashicorp/raft](https://github.com/hashicorp/raft)
    for the base Raft implementation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方实现了一个基本的内存Raft集群，构建了一个可以在某些允许的状态之间转换的状态机，并将分布式状态机连接到可以触发转换的Web处理程序。在实现Raft所需的基本有限状态机接口或进行测试时，这可能非常有用。此配方使用[https://github.com/hashicorp/raft](https://github.com/hashicorp/raft)作为基本Raft实现。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps cover writing and running your application:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤涵盖了编写和运行应用程序：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/consensus` and
    navigate to it.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter11/consensus`的新目录并转到该目录。
- en: 'Run the following command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个名为`go.mod`的文件，其中包含以下内容：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/consensus`,
    or use this as an opportunity to write some of your own code!
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`~/projects/go-programming-cookbook-original/chapter11/consensus`中的测试，或者利用这个机会编写一些自己的代码！
- en: 'Create a file called `state.go` with the following content:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`state.go`的文件，其中包含以下内容：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a file called `raftset.go` with the following content:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`raftset.go`的文件，其中包含以下内容：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a file called `config.go` with the following content:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`config.go`的文件，其中包含以下内容：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a file called `fsm.go` with the following content:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fsm.go`的文件，其中包含以下内容：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a file called `handler.go` with the following content:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`handler.go`的文件，其中包含以下内容：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录并转到该目录。
- en: 'Create a file named `main.go` with the following content:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，其中包含以下内容：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the `go run main.go` command. Alternatively, you may also run the following
    commands:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`命令。或者，您也可以运行以下命令：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should now see the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该看到以下输出：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In a separate Terminal, run the following command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端中，运行以下命令：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能会更新，`go.sum`文件现在应该存在于顶级配方目录中。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您复制或编写了自己的测试，请返回到上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the application starts, we initialize multiple Raft objects. These each
    have their own address and transport. The `InmemTransport{}` function also provides
    a method for connecting the other transports, and is called `Connect()`. Once
    these connections are established, the Raft cluster holds an election. When communicating
    in a Raft cluster, clients must communicate with the leader. In our case, one
    handler can talk to all of the nodes, so the handler is responsible for having
    the `Raft` leader's `call Apply()` object. This in turn runs `apply()` on all
    of the other nodes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，我们初始化多个Raft对象。每个对象都有自己的地址和传输方式。`InmemTransport{}`函数还提供了一个连接其他传输方式的方法，称为`Connect()`。一旦建立了这些连接，Raft集群就会进行选举。在Raft集群中通信时，客户端必须与领导者通信。在我们的情况下，一个处理程序可以与所有节点通信，因此处理程序负责拥有`Raft`领导者的`call
    Apply()`对象。这反过来又在所有其他节点上运行`apply()`。
- en: The `InmemTransport{}` function simplifies the election and bootstrapping process
    by allowing everything to reside in memory. In practice, this isn't very helpful,
    except for testing and proof of concepts, since Goroutines can freely access shared
    memory. A more production-minded implementation would use something like an HTTP
    Transport such that service instances can communicate across machines. This may
    require some additional bookkeeping or service discovery as the service instances
    have to listen and serve as well as have the ability discover and establish connections
    with one another.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`InmemTransport{}`函数通过允许所有内容驻留在内存中来简化选举和引导过程。在实践中，除了测试和概念验证之外，这并不是很有帮助，因为Goroutines可以自由访问共享内存。一个更适合生产的实现会使用类似HTTP传输的东西，这样服务实例可以跨机器通信。这可能需要一些额外的簿记或服务发现，因为服务实例必须监听和提供服务，同时还必须能够发现并建立彼此的连接。'
- en: Using containerization with Docker
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker进行容器化
- en: Docker is a container technology for packaging and shipping applications. Other
    advantages include portability, since a container will run the same way regardless
    of the host OS. It provides a lot of the advantages of a virtual machine, but
    in a more lightweight container. It's possible to limit the resource consumption
    of individual containers and sandbox your environment. It can be extremely useful
    to have a common environment for your applications locally and when you ship your
    code to production. Docker is written in Go and is open source, so it's simple
    to take advantage of the client and libraries. This recipe will set up a Docker
    container for a basic Go application, store some version information about the
    container, and demonstrate hitting a handler from a Docker endpoint.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一种用于打包和运输应用程序的容器技术。其他优势包括可移植性，因为容器无论在哪个主机操作系统上都会以相同的方式运行。它提供了虚拟机的许多优势，但是以更轻量的容器形式。可以限制单个容器的资源消耗并隔离您的环境。在本地为应用程序和在生产环境中部署代码时，拥有一个共同的环境非常有用。Docker是用Go语言编写的，是开源的，因此很容易利用客户端和库。这个配方将为一个基本的Go应用程序设置一个Docker容器，存储一些关于容器的版本信息，并演示如何从Docker端点访问处理程序。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置您的环境：
- en: Refer to the *Technical requirements* section in this chapter for steps to configure
    your environment.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考本章的*技术要求*部分，配置环境的步骤。
- en: Install Docker from [https://docs.docker.com/install](https://docs.docker.com/install/).
    This will also include Docker Compose.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://docs.docker.com/install](https://docs.docker.com/install)安装Docker。这也将包括Docker
    Compose。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行应用程序的过程：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/docker` and
    navigate to it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter11/docker`的新目录，并进入该目录。
- en: 'Run the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个名为`go.mod`的文件，其中包含以下内容：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/docker`,
    or use this as an opportunity to write some of your own code!
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`~/projects/go-programming-cookbook-original/chapter11/docker`复制测试，或者利用这个机会编写一些自己的代码！
- en: 'Create a file called `dockerfile` with the following content:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`dockerfile`的文件，内容如下：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a file called `setup.sh` with the following content:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`setup.sh`的文件，内容如下：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a file called `version.go` with the following content:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`version.go`的文件，内容如下：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录并进入。
- en: 'Create a `main.go` file with the following content:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，内容如下：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Navigate back to the starting directory.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航回起始目录。
- en: 'Run the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should now see the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该会看到以下输出：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the following commands:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能会更新，`go.sum`文件现在应该存在于顶层配方目录中。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您复制或编写了自己的测试，请返回上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe created a script that compiles the Go binary for the Linux architecture
    and sets a variety of private variables in `main.go`. These variables are used
    to return version information on a version endpoint. Once the binary is compiled,
    a Docker container is created that contains the binary. This allows us to use
    very small container images since the Go runtime is self-contained in the binary.
    We then run the container while exposing the port on which the container is listening
    for HTTP traffic. Lastly, we `curl` the port on localhost and see our version
    information returned.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例创建了一个脚本，用于为Linux架构编译Go二进制文件，并在`main.go`中设置各种私有变量。这些变量用于在版本端点上返回版本信息。一旦编译了二进制文件，就会创建一个包含二进制文件的Docker容器。这允许我们使用非常小的容器映像，因为Go运行时在二进制文件中是自包含的。然后我们运行容器，同时暴露容器监听HTTP流量的端口。最后，我们在本地主机上`curl`端口，并看到我们的版本信息返回。
- en: Orchestration and deployment strategies
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编排和部署策略
- en: Docker makes orchestration and deployment much simpler. In this recipe, we'll
    set up a connection to MongoDB and then insert a document and query it all from
    Docker containers. This recipe will set up the same environment as the *Using
    NoSQL with MongoDB and mgo* recipe from [Chapter 6](43f5a4d2-84e0-47a5-ada0-3b221d08ddd3.xhtml),
    *All about Databases and Storage*, but will run the application and environment
    inside of containers and will use Docker Compose to orchestrate and connect to
    them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使编排和部署变得更加简单。在这个示例中，我们将建立与MongoDB的连接，然后从Docker容器中插入文档并查询它。这个示例将设置与[第6章](43f5a4d2-84e0-47a5-ada0-3b221d08ddd3.xhtml)中*使用NoSQL与MongoDB和mgo*配方相同的环境，*关于数据库和存储的一切*，但将应用程序和环境运行在容器内，并使用Docker
    Compose进行编排和连接。
- en: This can later be used in conjunction with Docker Swarm, an integrated Docker
    tool that allows you to manage a cluster, create and deploy nodes that can be
    scaled up or down easily, and manage load balancing ([https://docs.docker.com/engine/swarm/](https://docs.docker.com/engine/swarm/)).
    Another good example of container orchestration is Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)),
    a container orchestration framework written by Google using the Go programming
    language.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以与Docker Swarm一起使用，Docker Swarm是一个集成的Docker工具，允许您管理集群，创建和部署可以轻松扩展或缩减的节点，并管理负载平衡（[https://docs.docker.com/engine/swarm/](https://docs.docker.com/engine/swarm/)）。另一个很好的容器编排示例是Kubernetes（[https://kubernetes.io/](https://kubernetes.io/)），这是一个由Google使用Go编程语言编写的容器编排框架。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'The following steps cover writing and running your application:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤涵盖了编写和运行应用程序：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/orchestrate` and
    navigate to it.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter11/orchestrate`的新目录，并导航到该目录。
- en: 'Run the following command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个名为`go.mod`的文件，其中包含以下内容：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/orchestrate`,
    or use this as an opportunity to write some of your own code!
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`~/projects/go-programming-cookbook-original/chapter11/orchestrate`复制测试，或者利用这个机会编写一些自己的代码！
- en: 'Create a file called `Dockerfile` with the following content:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Dockerfile`的文件，内容如下：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a file called `docker-compose.yml` with the following content:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`docker-compose.yml`的文件，内容如下：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a file called `config.go` with the following content:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`config.go`的文件，内容如下：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a file called `exec.go` with the following content:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`exec.go`的文件，内容如下：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录，并导航到该目录。
- en: 'Create a `main.go` file with the following content:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main.go`文件，内容如下：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Navigate back to the starting directory.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到起始目录。
- en: Run the `go mod vendor` command.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go mod vendor`命令。
- en: Run the `docker-compose up -d` command.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker-compose up -d`命令。
- en: 'Run the `docker logs orchestrate_app_1` command. You should now see the following
    output:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker logs orchestrate_app_1`命令。现在应该看到以下输出：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能会被更新，顶级配方目录中现在应该存在`go.sum`文件。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您复制或编写了自己的测试，请返回到上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This configuration is good for local development. Once the `docker-compose up`
    command is run, the local directory is rebuilt, Docker establishes a connection
    to a MongoDB instance using the latest version, and begins operating against it.
    This recipe uses the go mod vendor for dependency management. As a result, we
    disable the `go mod cache` and tell the `go build` command to use the vendor directory
    we created.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置适用于本地开发。一旦运行`docker-compose up`命令，本地目录将被重建，Docker将使用最新版本与MongoDB实例建立连接，并开始对其进行操作。此示例使用go
    mod vendor进行依赖管理。因此，我们禁用`go mod cache`并告诉`go build`命令使用我们创建的vendor目录。
- en: This can provide a good baseline when starting on apps that require connections
    to external services; all of the recipes in [Chapter 6](43f5a4d2-84e0-47a5-ada0-3b221d08ddd3.xhtml),
    *All about Databases and Storage*, can make use of this approach rather than creating
    a local instance of the database. For production, you probably won't want to run
    your data storage behind a Docker container, but you'll also generally have static
    host names for configuration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以为需要连接到外部服务的应用程序提供一个良好的基线；[第6章](43f5a4d2-84e0-47a5-ada0-3b221d08ddd3.xhtml)中的所有配方，*关于数据库和存储的一切*，都可以使用这种方法，而不是创建数据库的本地实例。对于生产环境，您可能不希望在Docker容器后面运行数据存储，但通常也会有静态主机名用于配置。
- en: Monitoring applications
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控应用程序
- en: There are a variety of ways to monitor Go applications. One of the easiest ways
    is to set up Prometheus, a monitoring application written in Go ([https://prometheus.io](https://prometheus.io)).
    This is an application that polls an endpoint based on your configuration file
    and collects a lot of information about your app, including the number of Goroutines,
    memory usage, and much more. This app will use the techniques from the previous
    recipe to set up a Docker environment to host Prometheus and connect to it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以监视Go应用程序。其中最简单的方法之一是设置Prometheus，这是一个用Go编写的监视应用程序（[https://prometheus.io](https://prometheus.io)）。这是一个根据您的配置文件轮询端点并收集有关您的应用程序的大量信息的应用程序，包括Goroutines的数量、内存使用情况等等。这个应用程序将使用上一个教程中的技术来设置一个Docker环境来托管Prometheus并连接到它。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'The following steps cover writing and running your application:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤涵盖了编写和运行您的应用程序：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/monitoring` and
    navigate to it.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter11/monitoring`的新目录，并转到该目录。
- en: 'Run the following command:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个名为`go.mod`的文件，其中包含以下内容：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/monitoring`,
    or use this as an opportunity to write some of your own code!
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`~/projects/go-programming-cookbook-original/chapter11/monitoring`复制测试，或者利用这个机会编写一些自己的代码！
- en: 'Create a file called `Dockerfile` with the following content:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Dockerfile`的文件，内容如下：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a file called `docker-compose.yml` with the following content:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`docker-compose.yml`的文件，内容如下：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a file called `main.go` with the following content:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，内容如下：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a file called `prometheus.yml` with the following content:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`prometheus.yml`的文件，内容如下：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Run the `go mod vendor` command.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go mod vendor`命令。
- en: 'Run the `docker-compose up`  command. You should now see the following output:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker-compose up`命令。现在您应该看到以下输出：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能已更新，并且顶级配方目录中现在应该存在`go.sum`文件。'
- en: Navigate your browser to `http://localhost:9090/`. You should see a variety
    of metrics related to your app!
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中导航到`http://localhost:9090/`。您应该看到与您的应用程序相关的各种指标！
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe creates a simple handler in Go that exports stats about the running
    application to prometheus using the prometheus go client. We connect our application
    to a prometheus server that is running in docker and handle the network connection
    and startup using docker-compose. Settings for how often to collect data, which
    port the application is serving on, and the name of the app are all specified
    in the `prometheus.yml` file. Once both containers start, the prometheus server
    begins harvesting and monitoring the app on the specified port. It also exposes
    a web interface which we visit in the browser to see more information about our
    app.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程在Go中创建了一个简单的处理程序，使用prometheus go客户端将有关正在运行的应用程序的统计信息导出到prometheus。我们将我们的应用程序连接到在docker中运行的prometheus服务器，并使用docker-compose处理网络连接和启动。收集数据的频率、应用程序提供服务的端口以及应用程序的名称都在`prometheus.yml`文件中指定。一旦两个容器都启动，prometheus服务器就开始在指定的端口上收集和监控应用程序。它还公开了一个Web界面，我们可以在浏览器中访问以查看有关我们的应用程序的更多信息。
- en: The Prometheus client handler will return a variety of stats about your application
    to a Prometheus server. This allows you to point multiple Prometheus servers at
    an app, without the need to reconfigure or deploy the app. Most of these stats
    are generic and beneficial for things such as detecting memory leaks. A lot of
    other solutions require you to periodically send information to a server instead.
    The next recipe, *Collecting metrics*, will demonstrate how to ship custom metrics
    to the Prometheus server.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus客户端处理程序将向Prometheus服务器返回有关您的应用程序的各种统计信息。这使您可以将多个Prometheus服务器指向一个应用程序，而无需重新配置或部署该应用程序。其中大多数统计信息是通用的，并且对于诸如检测内存泄漏之类的事情非常有益。许多其他解决方案要求您定期向服务器发送信息。下一个教程，*收集指标*，将演示如何将自定义指标发送到Prometheus服务器。
- en: Collecting metrics
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集指标
- en: In addition to general information about your app, it can be helpful to emit
    metrics that are app-specific. For example, we might want to collect timing data
    or keep track of the number of times an event occurs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关于您的应用程序的一般信息之外，发出特定于应用程序的指标也可能有所帮助。例如，我们可能希望收集定时数据或跟踪事件发生的次数。
- en: This recipe will use the `github.com/rcrowley/go-metrics` package to collect
    metrics and expose them via an endpoint. There are various exporter tools that
    you can use to export metrics to places such as Prometheus and InfluxDB, which
    are also written in Go.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将使用`github.com/rcrowley/go-metrics`包来收集指标并通过一个端点公开它们。有各种导出工具可以用来将指标导出到诸如Prometheus和InfluxDB之类的地方，这些工具也是用Go编写的。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置您的环境：
- en: Refer to the *Technical requirements* section in this chapter for steps to configure
    your environment.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅本章的*技术要求*部分，了解配置环境的步骤。
- en: Run the `go get github.com/rcrowley/go-metrics` command.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go get github.com/rcrowley/go-metrics`命令。
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'These steps cover writing and running your application:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行您的应用程序：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/metrics` and
    navigate to it.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter11/metrics`的新目录，并转到该目录。
- en: 'Run the following command:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个名为`go.mod`的文件，其中包含以下内容：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/metrics`,
    or use this as an opportunity to write some of your own code!
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`~/projects/go-programming-cookbook-original/chapter11/metrics`复制测试，或者利用这个机会编写一些自己的代码！
- en: 'Create a file called `handler.go` with the following content:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`handler.go`的文件，内容如下：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a file called `report.go` with the following content:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`report.go`的文件，内容如下：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录并进入。
- en: 'Create a file named `main.go` :'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run `go run main.go`. Alternatively, you may also run the following command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`。或者，您也可以运行以下命令：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You should now see the following output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该看到以下输出：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the following commands from a separate shell:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从单独的shell中运行以下命令：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Try hitting all the endpoints a few more times to see how they change.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试多次访问所有端点，看看它们如何变化。
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能会被更新，而`go.sum`文件现在应该存在于顶层的配方目录中。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您复制或编写了自己的测试，请返回上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `gometrics` keeps all of your metrics in a registry. Once it's set up, you
    can use any of the metric emit options, such as `counter` or `timer`, and it will
    store this update in the registry. There are multiple exporters that will export
    metrics to third-party tools. In our case, we set up a handler that emits all
    the metrics in JSON format.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`gometrics`将所有度量标准保存在注册表中。一旦设置好，您可以使用任何度量发射选项，比如`counter`或`timer`，它将把这个更新存储在注册表中。有多个导出器将度量标准导出到第三方工具。在我们的情况下，我们设置了一个以JSON格式发射所有度量标准的处理程序。'
- en: We set up three handlers—one that increments a counter, one that records the
    time to exit the handler, and one that prints a report (while also incrementing
    an additional counter). The `GetOrRegister` functions are useful for atomically
    getting or creating a metric emitter if it doesn't currently exist in a thread-safe
    way. Alternatively, you can register everything once in advance.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了三个处理程序——一个用于增加计数器，一个用于记录退出处理程序的时间，以及一个用于打印报告（同时还增加了一个额外的计数器）。`GetOrRegister`函数对于以线程安全的方式原子地获取或创建度量发射器非常有用。或者，您可以提前注册所有内容。
