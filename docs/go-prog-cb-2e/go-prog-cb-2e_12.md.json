["```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter12/goflow \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter12/goflow   \n```", "```go\npackage goflow\n\nimport (\n  \"encoding/base64\"\n  \"fmt\"\n)\n\n// Encoder base64 encodes all input\ntype Encoder struct {\n  Val <-chan string\n  Res chan<- string\n}\n\n// Process does the encoding then pushes the result onto Res\nfunc (e *Encoder) Process() {\n  for val := range e.Val {\n    encoded := base64.StdEncoding.EncodeToString([]byte(val))\n    e.Res <- fmt.Sprintf(\"%s => %s\", val, encoded)\n  }\n}\n\n// Printer is a component for printing to stdout\ntype Printer struct {\n  Line <-chan string\n}\n\n// Process Prints the current line received\nfunc (p *Printer) Process() {\n  for line := range p.Line {\n    fmt.Println(line)\n  }\n}\n```", "```go\npackage goflow\n\nimport (\n  \"github.com/trustmaster/goflow\"\n)\n\n// NewEncodingApp wires together the components\nfunc NewEncodingApp() *goflow.Graph {\n  e := goflow.NewGraph()\n\n  // define component types\n  e.Add(\"encoder\", new(Encoder))\n  e.Add(\"printer\", new(Printer))\n\n  // connect the components using channels\n  e.Connect(\"encoder\", \"Res\", \"printer\", \"Line\")\n\n  // map the in channel to Val, which is\n  // tied to OnVal function\n  e.MapInPort(\"In\", \"encoder\", \"Val\")\n\n  return e\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/PacktPublishing/\n   Go-Programming-Cookbook-Second-Edition/chapter12/goflow\"\n  flow \"github.com/trustmaster/goflow\"\n)\n\nfunc main() {\n\n  net := goflow.NewEncodingApp()\n\n  in := make(chan string)\n  net.SetInPort(\"In\", in)\n\n  wait := flow.Run(net)\n\n  for i := 0; i < 20; i++ {\n    in <- fmt.Sprint(\"Message\", i)\n  }\n\n  close(in)\n  <-wait\n}\n\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nMessage6 => TWVzc2FnZTY=\nMessage5 => TWVzc2FnZTU=\nMessage1 => TWVzc2FnZTE=\nMessage0 => TWVzc2FnZTA=\nMessage4 => TWVzc2FnZTQ=\nMessage8 => TWVzc2FnZTg=\nMessage2 => TWVzc2FnZTI=\nMessage3 => TWVzc2FnZTM=\nMessage7 => TWVzc2FnZTc=\nMessage10 => TWVzc2FnZTEw\nMessage9 => TWVzc2FnZTk=\nMessage12 => TWVzc2FnZTEy\nMessage11 => TWVzc2FnZTEx\nMessage14 => TWVzc2FnZTE0\nMessage13 => TWVzc2FnZTEz\nMessage16 => TWVzc2FnZTE2\nMessage15 => TWVzc2FnZTE1\nMessage18 => TWVzc2FnZTE4\nMessage17 => TWVzc2FnZTE3\nMessage19 => TWVzc2FnZTE5\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter12/synckafka \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter12/synckafka   \n```", "```go\n        package main\n\n        import (\n            \"log\"\n\n            sarama \"github.com/Shopify/sarama\"\n        )\n\n        func main() {\n            consumer, err := \n            sarama.NewConsumer([]string{\"localhost:9092\"}, nil)\n            if err != nil {\n                panic(err)\n            }\n            defer consumer.Close()\n\n            partitionConsumer, err := \n\n           consumer.ConsumePartition(\"example\", 0, \n            sarama.OffsetNewest)\n            if err != nil {\n                panic(err)\n            }\n            defer partitionConsumer.Close()\n\n            for {\n                msg := <-partitionConsumer.Messages()\n                log.Printf(\"Consumed message: \\\"%s\\\" at offset: %d\\n\", \n                msg.Value, msg.Offset)\n            }\n        }\n```", "```go\n        package main\n\n        import (\n\n           \"fmt\"\n           \"log\"\n\n            sarama \"github.com/Shopify/sarama\"\n        )\n\n        func sendMessage(producer sarama.SyncProducer, value string) {\n            msg := &sarama.ProducerMessage{Topic: \"example\", Value: \n            sarama.StringEncoder(value)}\n            partition, offset, err := producer.SendMessage(msg)\n            if err != nil {\n\n               log.Printf(\"FAILED to send message: %s\\n\", err)\n                return\n            }\n            log.Printf(\"> message sent to partition %d at offset %d\\n\", \n            partition, offset)\n        }\n\n        func main() {\n            producer, err := \n            sarama.NewSyncProducer([]string{\"localhost:9092\"}, nil)\n            if err != nil {\n                panic(err)\n            }\n            defer producer.Close()\n\n            for i := 0; i < 10; i++ {\n                sendMessage(producer, fmt.Sprintf(\"Message %d\", i))\n            }\n        }\n```", "```go\n$ go run ./producer \n2017/05/07 11:50:38 > message sent to partition 0 at offset 0\n2017/05/07 11:50:38 > message sent to partition 0 at offset 1\n2017/05/07 11:50:38 > message sent to partition 0 at offset 2\n2017/05/07 11:50:38 > message sent to partition 0 at offset 3\n2017/05/07 11:50:38 > message sent to partition 0 at offset 4\n2017/05/07 11:50:38 > message sent to partition 0 at offset 5\n2017/05/07 11:50:38 > message sent to partition 0 at offset 6\n2017/05/07 11:50:38 > message sent to partition 0 at offset 7\n2017/05/07 11:50:38 > message sent to partition 0 at offset 8\n2017/05/07 11:50:38 > message sent to partition 0 at offset 9\n```", "```go\n$ go run ./consumer\n2017/05/07 11:50:38 Consumed message: \"Message 0\" at offset: 0\n2017/05/07 11:50:38 Consumed message: \"Message 1\" at offset: 1\n2017/05/07 11:50:38 Consumed message: \"Message 2\" at offset: 2\n2017/05/07 11:50:38 Consumed message: \"Message 3\" at offset: 3\n2017/05/07 11:50:38 Consumed message: \"Message 4\" at offset: 4\n2017/05/07 11:50:38 Consumed message: \"Message 5\" at offset: 5\n2017/05/07 11:50:38 Consumed message: \"Message 6\" at offset: 6\n2017/05/07 11:50:38 Consumed message: \"Message 7\" at offset: 7\n2017/05/07 11:50:38 Consumed message: \"Message 8\" at offset: 8\n2017/05/07 11:50:38 Consumed message: \"Message 9\" at offset: 9\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter12/asynckafka \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter12/asynckafka   \n```", "```go\n        package main\n\n        import (\n            \"log\"\n\n            sarama \"github.com/Shopify/sarama\"\n        )\n\n        // Process response grabs results and errors from a producer\n        // asynchronously\n        func ProcessResponse(producer sarama.AsyncProducer) {\n            for {\n                select {\n                    case result := <-producer.Successes():\n                    log.Printf(\"> message: \\\"%s\\\" sent to partition \n                    %d at offset %d\\n\", result.Value, \n                    result.Partition, result.Offset)\n                    case err := <-producer.Errors():\n                    log.Println(\"Failed to produce message\", err)\n                }\n            }\n        }\n```", "```go\n        package main\n\n        import (\n            \"net/http\"\n\n            sarama \"github.com/Shopify/sarama\"\n        )\n\n        // KafkaController allows us to attach a producer\n        // to our handlers\n        type KafkaController struct {\n            producer sarama.AsyncProducer\n        }\n\n        // Handler grabs a message from a GET parama and\n        // send it to the kafka queue asynchronously\n        func (c *KafkaController) Handler(w http.ResponseWriter, r \n        *http.Request) {\n            if err := r.ParseForm(); err != nil {\n                w.WriteHeader(http.StatusBadRequest)\n                return\n            }\n\n            msg := r.FormValue(\"msg\")\n            if msg == \"\" {\n                w.WriteHeader(http.StatusBadRequest)\n                w.Write([]byte(\"msg must be set\"))\n                return\n            }\n            c.producer.Input() <- &sarama.ProducerMessage{Topic: \n            \"example\", Key: nil, Value: \n            sarama.StringEncoder(msg)}\n            w.WriteHeader(http.StatusOK)\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"net/http\"\n\n            sarama \"github.com/Shopify/sarama\"\n        )\n\n        func main() {\n            config := sarama.NewConfig()\n            config.Producer.Return.Successes = true\n            config.Producer.Return.Errors = true\n            producer, err := \n            sarama.NewAsyncProducer([]string{\"localhost:9092\"}, config)\n            if err != nil {\n                panic(err)\n            }\n            defer producer.AsyncClose()\n\n            go ProcessResponse(producer)\n\n            c := KafkaController{producer}\n            http.HandleFunc(\"/\", c.Handler)\n            fmt.Println(\"Listening on port :3333\")\n            panic(http.ListenAndServe(\":3333\", nil))\n        }\n```", "```go\n$ curl \"http://localhost:3333/?msg=this\"      \n$ curl \"http://localhost:3333/?msg=is\" \n$ curl \"http://localhost:3333/?msg=an\" \n$ curl \"http://localhost:3333/?msg=example\" \n```", "```go\n$ go run ./producer\nListening on port :3333\n2017/05/07 13:52:54 > message: \"this\" sent to partition 0 at offset 0\n2017/05/07 13:53:25 > message: \"is\" sent to partition 0 at offset 1\n2017/05/07 13:53:27 > message: \"an\" sent to partition 0 at offset 2\n2017/05/07 13:53:29 > message: \"example\" sent to partition 0 at offset 3\n```", "```go\n$ go run ./consumer\n2017/05/07 13:52:54 Consumed message: \"this\" at offset: 0\n2017/05/07 13:53:25 Consumed message: \"is\" at offset: 1\n2017/05/07 13:53:27 Consumed message: \"an\" at offset: 2\n2017/05/07 13:53:29 Consumed message: \"example\" at offset: 3\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter12/kafkaflow \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter12/kafkaflow   \n```", "```go\npackage kafkaflow\n\nimport (\n  \"fmt\"\n  \"strings\"\n\n  flow \"github.com/trustmaster/goflow\"\n)\n\n// Upper upper cases the incoming\n// stream\ntype Upper struct {\n  Val <-chan string\n  Res chan<- string\n}\n\n// Process loops over the input values and writes the upper\n// case string version of them to Res\nfunc (e *Upper) Process() {\n  for val := range e.Val {\n    e.Res <- strings.ToUpper(val)\n  }\n}\n\n// Printer is a component for printing to stdout\ntype Printer struct {\n  flow.Component\n  Line <-chan string\n}\n\n// Process Prints the current line received\nfunc (p *Printer) Process() {\n  for line := range p.Line {\n    fmt.Println(line)\n  }\n}\n```", "```go\npackage kafkaflow\n\nimport \"github.com/trustmaster/goflow\"\n\n// NewUpperApp wires together the components\nfunc NewUpperApp() *goflow.Graph {\n  u := goflow.NewGraph()\n\n  u.Add(\"upper\", new(Upper))\n  u.Add(\"printer\", new(Printer))\n\n  u.Connect(\"upper\", \"Res\", \"printer\", \"Line\")\n  u.MapInPort(\"In\", \"upper\", \"Val\")\n\n  return u\n}\n```", "```go\npackage main\n\nimport (\n  \"github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter12/kafkaflow\"\n  sarama \"github.com/Shopify/sarama\"\n  flow \"github.com/trustmaster/goflow\"\n)\n\nfunc main() {\n  consumer, err := sarama.NewConsumer([]string{\"localhost:9092\"}, nil)\n  if err != nil {\n    panic(err)\n  }\n  defer consumer.Close()\n\n  partitionConsumer, err := consumer.ConsumePartition(\"example\", 0, sarama.OffsetNewest)\n  if err != nil {\n    panic(err)\n  }\n  defer partitionConsumer.Close()\n\n  net := kafkaflow.NewUpperApp()\n\n  in := make(chan string)\n  net.SetInPort(\"In\", in)\n\n  wait := flow.Run(net)\n  defer func() {\n    close(in)\n    <-wait\n  }()\n\n  for {\n    msg := <-partitionConsumer.Messages()\n    in <- string(msg.Value)\n  }\n\n}\n```", "```go\n$ go run ./producer \n2017/05/07 18:24:12 > message \"Message 0\" sent to partition 0 at offset 0\n2017/05/07 18:24:12 > message \"Message 1\" sent to partition 0 at offset 1\n2017/05/07 18:24:12 > message \"Message 2\" sent to partition 0 at offset 2\n2017/05/07 18:24:12 > message \"Message 3\" sent to partition 0 at offset 3\n2017/05/07 18:24:12 > message \"Message 4\" sent to partition 0 at offset 4\n2017/05/07 18:24:12 > message \"Message 5\" sent to partition 0 at offset 5\n2017/05/07 18:24:12 > message \"Message 6\" sent to partition 0 at offset 6\n2017/05/07 18:24:12 > message \"Message 7\" sent to partition 0 at offset 7\n2017/05/07 18:24:12 > message \"Message 8\" sent to partition 0 at offset 8\n2017/05/07 18:24:12 > message \"Message 9\" sent to partition 0 at offset 9\n```", "```go\n$ go run ./consumer\nMESSAGE 0\nMESSAGE 1\nMESSAGE 2\nMESSAGE 3\nMESSAGE 4\nMESSAGE 5\nMESSAGE 6\nMESSAGE 7\nMESSAGE 8\nMESSAGE 9\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter12/graphql \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter12/graphql   \n```", "```go\n        package cards\n\n        // Card represents a standard playing\n        // card\n        type Card struct {\n            Value string\n            Suit string\n        }\n\n        var cards []Card\n\n        func init() {\n            cards = []Card{\n                {\"A\", \"Spades\"}, {\"2\", \"Spades\"}, {\"3\", \"Spades\"},\n                {\"4\", \"Spades\"}, {\"5\", \"Spades\"}, {\"6\", \"Spades\"},\n                {\"7\", \"Spades\"}, {\"8\", \"Spades\"}, {\"9\", \"Spades\"},\n                {\"10\", \"Spades\"}, {\"J\", \"Spades\"}, {\"Q\", \"Spades\"},\n                {\"K\", \"Spades\"},\n                {\"A\", \"Hearts\"}, {\"2\", \"Hearts\"}, {\"3\", \"Hearts\"},\n                {\"4\", \"Hearts\"}, {\"5\", \"Hearts\"}, {\"6\", \"Hearts\"},\n                {\"7\", \"Hearts\"}, {\"8\", \"Hearts\"}, {\"9\", \"Hearts\"},\n                {\"10\", \"Hearts\"}, {\"J\", \"Hearts\"}, {\"Q\", \"Hearts\"},\n                {\"K\", \"Hearts\"},\n                {\"A\", \"Clubs\"}, {\"2\", \"Clubs\"}, {\"3\", \"Clubs\"},\n                {\"4\", \"Clubs\"}, {\"5\", \"Clubs\"}, {\"6\", \"Clubs\"},\n                {\"7\", \"Clubs\"}, {\"8\", \"Clubs\"}, {\"9\", \"Clubs\"},\n                {\"10\", \"Clubs\"}, {\"J\", \"Clubs\"}, {\"Q\", \"Clubs\"},\n                {\"K\", \"Clubs\"},\n                {\"A\", \"Diamonds\"}, {\"2\", \"Diamonds\"}, {\"3\", \n                \"Diamonds\"},\n                {\"4\", \"Diamonds\"}, {\"5\", \"Diamonds\"}, {\"6\", \n                \"Diamonds\"},\n                {\"7\", \"Diamonds\"}, {\"8\", \"Diamonds\"}, {\"9\", \n                \"Diamonds\"},\n                {\"10\", \"Diamonds\"}, {\"J\", \"Diamonds\"}, {\"Q\", \n                \"Diamonds\"},\n                {\"K\", \"Diamonds\"},\n            }\n        }\n```", "```go\n        package cards\n\n        import \"github.com/graphql-go/graphql\"\n\n        // CardType returns our card graphql object\n        func CardType() *graphql.Object {\n            cardType := graphql.NewObject(graphql.ObjectConfig{\n                Name: \"Card\",\n                Description: \"A Playing Card\",\n                Fields: graphql.Fields{\n                    \"value\": &graphql.Field{\n                        Type: graphql.String,\n                        Description: \"Ace through King\",\n                        Resolve: func(p graphql.ResolveParams) \n                        (interface{}, error) {\n                            if card, ok := p.Source.(Card); ok {\n                                return card.Value, nil\n                            }\n                            return nil, nil\n                        },\n                    },\n                    \"suit\": &graphql.Field{\n                        Type: graphql.String,\n                        Description: \"Hearts, Diamonds, Clubs, Spades\",\n                        Resolve: func(p graphql.ResolveParams) \n                        (interface{}, error) {\n                            if card, ok := p.Source.(Card); ok {\n                                return card.Suit, nil\n                            }\n                            return nil, nil\n                        },\n                    },\n                },\n            })\n            return cardType\n        }\n```", "```go\n        package cards\n\n        import (\n            \"strings\"\n\n            \"github.com/graphql-go/graphql\"\n        )\n\n        // Resolve handles filtering cards\n        // by suit and value\n        func Resolve(p graphql.ResolveParams) (interface{}, error) {\n            finalCards := []Card{}\n            suit, suitOK := p.Args[\"suit\"].(string)\n            suit = strings.ToLower(suit)\n\n            value, valueOK := p.Args[\"value\"].(string)\n            value = strings.ToLower(value)\n\n            for _, card := range cards {\n                if suitOK && suit != strings.ToLower(card.Suit) {\n                    continue\n                }\n                if valueOK && value != strings.ToLower(card.Value) {\n                    continue\n                }\n\n                finalCards = append(finalCards, card)\n            }\n            return finalCards, nil\n        }\n```", "```go\n        package cards\n\n        import \"github.com/graphql-go/graphql\"\n\n        // Setup prepares and returns our card\n        // schema\n        func Setup() (graphql.Schema, error) {\n            cardType := CardType()\n\n            // Schema\n            fields := graphql.Fields{\n                \"cards\": &graphql.Field{\n                    Type: graphql.NewList(cardType),\n                    Args: graphql.FieldConfigArgument{\n                        \"suit\": &graphql.ArgumentConfig{\n                            Description: \"Filter cards by card suit \n                            (hearts, clubs, diamonds, spades)\",\n                            Type: graphql.String,\n                        },\n                        \"value\": &graphql.ArgumentConfig{\n                            Description: \"Filter cards by card \n                            value (A-K)\",\n                            Type: graphql.String,\n                        },\n                    },\n                    Resolve: Resolve,\n                },\n            }\n\n            rootQuery := graphql.ObjectConfig{Name: \"RootQuery\", \n            Fields: fields}\n            schemaConfig := graphql.SchemaConfig{Query: \n            graphql.NewObject(rootQuery)}\n            schema, err := graphql.NewSchema(schemaConfig)\n\n            return schema, err\n        }\n```", "```go\n        package main\n\n        import (\n            \"encoding/json\"\n            \"fmt\"\n            \"log\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter12/graphql/cards\"\n            \"github.com/graphql-go/graphql\"\n        )\n\n        func main() {\n            // grab our schema\n            schema, err := cards.Setup()\n            if err != nil {\n                panic(err)\n            }\n\n            // Query\n            query := `\n            {\n                cards(value: \"A\"){\n                    value\n                    suit\n                }\n            }`\n\n            params := graphql.Params{Schema: schema, RequestString: \n            query}\n            r := graphql.Do(params)\n            if len(r.Errors) > 0 {\n                log.Fatalf(\"failed to execute graphql operation, \n                errors: %+v\", r.Errors)\n            }\n            rJSON, err := json.MarshalIndent(r, \"\", \" \")\n            if err != nil {\n                panic(err)\n            }\n            fmt.Printf(\"%s \\n\", rJSON)\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\n{\n \"data\": {\n \"cards\": [\n {\n \"suit\": \"Spades\",\n \"value\": \"A\"\n },\n {\n \"suit\": \"Hearts\",\n \"value\": \"A\"\n },\n {\n \"suit\": \"Clubs\",\n \"value\": \"A\"\n },\n {\n \"suit\": \"Diamonds\",\n \"value\": \"A\"\n }\n ]\n }\n} \n```"]