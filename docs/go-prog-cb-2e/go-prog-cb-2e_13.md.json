["```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter13/lambda \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter13/lambda\n```", "```go\n        [default]\n        aws_access_key_id = xxxxxxxx\n        aws_secret_access_key = xxxxxxxxxxxxxxxxxxxxxxxx\n```", "```go\n        export AWS_REGION=us-west-2\n```", "```go\n$ apex init \n\nEnter the name of your project. It should be machine-friendly, as this is used to prefix your functions in Lambda.\n\nProject name: go-cookbook\n\nEnter an optional description of your project.\n\nProject description: Demonstrating Apex with the Go Cookbook\n\n[+] creating IAM go-cookbook_lambda_function role\n[+] creating IAM go-cookbook_lambda_logs policy\n[+] attaching policy to lambda_function role.\n[+] creating ./project.json\n[+] creating ./functions\n\nSetup complete, deploy those functions!\n\n$ apex deploy\n```", "```go\npackage main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/aws/aws-lambda-go/lambda\"\n)\n\n// Message is the input to the function and\n// includes a Name\ntype Message struct {\n  Name string `json:\"name\"`\n}\n\n// Response is sent back and contains a greeting\n// string\ntype Response struct {\n  Greeting string `json:\"greeting\"`\n}\n\n// HandleRequest will be called when the lambda function is invoked\n// it takes a Message and returns a Response that contains a greeting\nfunc HandleRequest(ctx context.Context, m Message) (Response, error) {\n  return Response{Greeting: fmt.Sprintf(\"Hello, %s\", m.Name)}, nil\n}\n\nfunc main() {\n  lambda.Start(HandleRequest)\n}\n```", "```go\npackage main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/aws/aws-lambda-go/lambda\"\n)\n\n// Message is the input to the function and\n// includes a FirstName and LastName\ntype Message struct {\n  FirstName string `json:\"first_name\"`\n  LastName string `json:\"last_name\"`\n}\n\n// Response is sent back and contains a greeting\n// string\ntype Response struct {\n  Greeting string `json:\"greeting\"`\n}\n\n// HandleRequest will be called when the lambda function is invoked\n// it takes a Message and returns a Response that contains a greeting\n// this greeting contains the first and last name specified\nfunc HandleRequest(ctx context.Context, m Message) (Response, error) {\n  return Response{Greeting: fmt.Sprintf(\"Hello, %s %s\", m.FirstName, m.LastName)}, nil\n}\n\nfunc main() {\n  lambda.Start(HandleRequest)\n}\n```", "```go\n$ apex deploy \n\u2022 creating function env= function=greeter2\n\u2022 creating function env= function=greeter1\n\u2022 created alias current env= function=greeter2 version=4\n\u2022 function created env= function=greeter2 name=go-cookbook_greeter2 version=1\n\u2022 created alias current env= function=greeter1 version=5\n\u2022 function created env= function=greeter1 name=go-cookbook_greeter1 version=1\n```", "```go\n$ echo '{\"name\": \"Reader\"}' | apex invoke greeter1 {\"greeting\":\"Hello, Reader\"}\n\n$ echo '{\"first_name\": \"Go\", \"last_name\": \"Coders\"}' | apex invoke greeter2 {\"greeting\":\"Hello, Go Coders\"}\n```", "```go\n$ apex logs greeter2\napex logs greeter2\n/aws/lambda/go-cookbook_greeter2 START RequestId: 7c0f9129-3830-11e7-8755-75aeb52a51b9 Version: 1\n/aws/lambda/go-cookbook_greeter2 END RequestId: 7c0f9129-3830-11e7-8755-75aeb52a51b9\n/aws/lambda/go-cookbook_greeter2 REPORT RequestId: 7c0f9129-3830-11e7-8755-75aeb52a51b9 Duration: 93.84 ms Billed Duration: 100 ms \nMemory Size: 128 MB Max Memory Used: 19 MB \n```", "```go\n$ apex delete\nThe following will be deleted:\n\n- greeter1 - greeter2\n\nAre you sure? (yes/no) yes\n\u2022 deleting env= function=greeter\n\u2022 function deleted env= function=greeter\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter13/logging \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter13/logging\n```", "```go\n        [default]\n        aws_access_key_id = xxxxxxxx\n        aws_secret_access_key = xxxxxxxxxxxxxxxxxxxxxxxx\n```", "```go\n        export AWS_REGION=us-west-2\n```", "```go\n$ apex init \n\nEnter the name of your project. It should be machine-friendly, as this is used to prefix your functions in Lambda.\n\nProject name: logging \n\nEnter an optional description of your project.\n\nProject description: An example of apex logging and metrics\n\n[+] creating IAM logging_lambda_function role\n[+] creating IAM logging_lambda_logs policy\n[+] attaching policy to lambda_function role.\n[+] creating ./project.json\n[+] creating ./functions\n\nSetup complete, deploy those functions!\n\n$ apex deploy\n```", "```go\npackage main\n\nimport (\n  \"context\"\n  \"os\"\n\n  \"github.com/apex/log\"\n  \"github.com/apex/log/handlers/text\"\n  \"github.com/aws/aws-lambda-go/lambda\"\n)\n\n// Input takes in a secret\ntype Input struct {\n  Secret string `json:\"secret\"`\n}\n\n// HandleRequest will be called when the Lambda function is invoked\n// it takes an input and checks if it matches our super secret value\nfunc HandleRequest(ctx context.Context, input Input) (string, error) {\n  log.SetHandler(text.New(os.Stderr))\n\n  log.WithField(\"secret\", input.Secret).Info(\"secret guessed\")\n\n  if input.Secret == \"klaatu barada nikto\" {\n    return \"secret guessed!\", nil\n  }\n  return \"try again\", nil\n}\n\nfunc main() {\n  lambda.Start(HandleRequest)\n}\n```", "```go\n$ apex deploy\n\u2022 creating function env= function=secret\n\u2022 created alias current env= function=secret version=1\n\u2022 function created env= function=secret name=logging_secret version=1\n```", "```go\n$ echo '{\"secret\": \"open sesame\"}' | apex invoke secret\n\"try again\"\n\n$ echo '{\"secret\": \"klaatu barada nikto\"}' | apex invoke secret\n\"secret guessed!\"\n```", "```go\n$ apex logs secret\n/aws/lambda/logging_secret START RequestId: cfa6f655-3834-11e7-b99d-89998a7f39dd Version: 1\n/aws/lambda/logging_secret INFO[0000] secret guessed secret=open sesame\n/aws/lambda/logging_secret END RequestId: cfa6f655-3834-11e7-b99d-89998a7f39dd\n/aws/lambda/logging_secret REPORT RequestId: cfa6f655-3834-11e7-b99d-89998a7f39dd Duration: 52.23 ms Billed Duration: 100 ms Memory Size: 128 MB Max Memory Used: 19 MB \n/aws/lambda/logging_secret START RequestId: d74ea688-3834-11e7-aa4e-d592c1fbc35f Version: 1\n/aws/lambda/logging_secret INFO[0012] secret guessed secret=klaatu barada nikto\n/aws/lambda/logging_secret END RequestId: d74ea688-3834-11e7-aa4e-d592c1fbc35f\n/aws/lambda/logging_secret REPORT RequestId: d74ea688-3834-11e7-aa4e-d592c1fbc35f Duration: 7.43 ms Billed Duration: 100 ms \nMemory Size: 128 MB Max Memory Used: 19 MB \n```", "```go\n$ apex metrics secret \n\nsecret\ntotal cost: $0.00\ninvocations: 0 ($0.00)\nduration: 0s ($0.00)\nthrottles: 0\nerrors: 0\nmemory: 128\n```", "```go\n$ apex delete\nAre you sure? (yes/no) yes\n\u2022 deleting env= function=secret\n\u2022 function deleted env= function=secret\n```", "```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter13/appengine \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter13/appengine\n```", "```go\nruntime: go112\n\nmanual_scaling:\n  instances: 1\n\n#[START env_variables]\nenv_variables:\n  GCLOUD_DATASET_ID: go-cookbook\n#[END env_variables]\n```", "```go\n        package main\n\n        import (\n            \"context\"\n            \"time\"\n\n            \"cloud.google.com/go/datastore\"\n        )\n\n        // Message is the object we store\n        type Message struct {\n            Timestamp time.Time\n            Message string\n        }\n\n        func (c *Controller) storeMessage(ctx context.Context, message \n        string) error {\n            m := &amp;amp;Message{\n                Timestamp: time.Now(),\n                Message: message,\n            }\n\n            k := datastore.IncompleteKey(\"Message\", nil)\n            _, err := c.store.Put(ctx, k, m)\n            return err\n        }\n\n        func (c *Controller) queryMessages(ctx context.Context, limit \n        int) ([]*Message, error) {\n            q := datastore.NewQuery(\"Message\").\n            Order(\"-Timestamp\").\n            Limit(limit)\n\n            messages := make([]*Message, 0)\n            _, err := c.store.GetAll(ctx, q, &amp;amp;messages)\n            return messages, err\n        }\n```", "```go\n        package main\n\n        import (\n            \"context\"\n            \"fmt\"\n            \"log\"\n            \"net/http\"\n\n            \"cloud.google.com/go/datastore\"\n        )\n\n        // Controller holds our storage and other\n        // state\n        type Controller struct {\n            store *datastore.Client\n        }\n\n        func (c *Controller) handle(w http.ResponseWriter, r \n        *http.Request) {\n            if r.Method != http.MethodGet {\n                http.Error(w, \"invalid method\", \n                http.StatusMethodNotAllowed)\n                return\n            }\n\n            ctx := context.Background()\n\n            // store the new message\n            r.ParseForm()\n            if message := r.FormValue(\"message\"); message != \"\" {\n                if err := c.storeMessage(ctx, message); err != nil {\n                    log.Printf(\"could not store message: %v\", err)\n                    http.Error(w, \"could not store \n                    message\", \n                    http.StatusInternalServerError)\n                    return\n                }\n            }\n\n            // get the current messages and display them\n            fmt.Fprintln(w, \"Messages:\")\n            messages, err := c.queryMessages(ctx, 10)\n            if err != nil {\n                log.Printf(\"could not get messages: %v\", err)\n                http.Error(w, \"could not get messages\", \n                http.StatusInternalServerError)\n                return\n            }\n\n            for _, message := range messages {\n                fmt.Fprintln(w, message.Message)\n            }\n        }\n```", "```go\n        package main\n\n        import (\n            \"log\"\n            \"net/http\"\n            \"os\"\n\n            \"cloud.google.com/go/datastore\"\n            \"golang.org/x/net/context\"\n            \"google.golang.org/appengine\"\n        )\n\n        func main() {\n            ctx := context.Background()\n            log.SetOutput(os.Stderr)\n\n            // Set this in app.yaml when running in production.\n            projectID := os.Getenv(\"GCLOUD_DATASET_ID\")\n\n            datastoreClient, err := datastore.NewClient(ctx, projectID)\n            if err != nil {\n                log.Fatal(err)\n            }\n\n            c := Controller{datastoreClient}\n\n            http.HandleFunc(\"/\", c.handle)\n\n            port := os.Getenv(\"PORT\")\n            if port == \"\" {\n                port = \"8080\"\n                log.Printf(\"Defaulting to port %s\", port)\n            }\n\n            log.Printf(\"Listening on port %s\", port)\n            log.Fatal(http.ListenAndServe(fmt.Sprintf(\":%s\", port), nil))\n        }\n```", "```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter13/firebase \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter13/firebase\n```", "```go\npackage firebase\n\nimport (\n  \"context\"\n\n  \"cloud.google.com/go/firestore\"\n  \"github.com/pkg/errors\"\n)\n\n// Client Interface for mocking\ntype Client interface {\n  Get(ctx context.Context, key string) (interface{}, error)\n  Set(ctx context.Context, key string, value interface{}) error\n  Close() error\n}\n\n// firestore.Client implements Close()\n// we create Get and Set\ntype firebaseClient struct {\n  *firestore.Client\n  collection string\n}\n\nfunc (f *firebaseClient) Get(ctx context.Context, key string) (interface{}, error) {\n  data, err := f.Collection(f.collection).Doc(key).Get(ctx)\n  if err != nil {\n    return nil, errors.Wrap(err, \"get failed\")\n  }\n  return data.Data(), nil\n}\n\nfunc (f *firebaseClient) Set(ctx context.Context, key string, value interface{}) error {\n  set := make(map[string]interface{})\n  set[key] = value\n  _, err := f.Collection(f.collection).Doc(key).Set(ctx, set)\n  return errors.Wrap(err, \"set failed\")\n}\n```", "```go\npackage firebase\n\nimport (\n  \"context\"\n\n  firebase \"firebase.google.com/go\"\n  \"github.com/pkg/errors\"\n  \"google.golang.org/api/option\"\n)\n\n// Authenticate grabs oauth scopes using a generated\n// service_account.json file from\n// https://console.firebase.google.com/project/go-cookbook/settings/serviceaccounts/adminsdk\nfunc Authenticate(ctx context.Context, collection string) (Client, error) {\n\n  opt := option.WithCredentialsFile(\"/tmp/service_account.json\")\n  app, err := firebase.NewApp(ctx, nil, opt)\n  if err != nil {\n    return nil, errors.Wrap(err, \"error initializing app\")\n  }\n\n  client, err := app.Firestore(ctx)\n  if err != nil {\n    return nil, errors.Wrap(err, \"failed to intialize filestore\")\n  }\n  return &amp;amp;firebaseClient{Client: client, collection: collection}, nil\n}\n```", "```go\npackage main\n\nimport (\n  \"context\"\n  \"fmt\"\n  \"log\"\n\n  \"github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter13/firebase\"\n)\n\nfunc main() {\n  ctx := context.Background()\n  c, err := firebase.Authenticate(ctx, \"collection\")\n  if err != nil {\n    log.Fatalf(\"error initializing client: %v\", err)\n  }\n  defer c.Close()\n\n  if err := c.Set(ctx, \"key\", []string{\"val1\", \"val2\"}); err != nil {\n    log.Fatalf(err.Error())\n  }\n\n  res, err := c.Get(ctx, \"key\")\n  if err != nil {\n    log.Fatalf(err.Error())\n  }\n  fmt.Println(res)\n\n  if err := c.Set(ctx, \"key2\", []string{\"val3\", \"val4\"}); err != nil {\n    log.Fatalf(err.Error())\n  }\n\n  res, err = c.Get(ctx, \"key2\")\n  if err != nil {\n    log.Fatalf(err.Error())\n  }\n  fmt.Println(res)\n}\n```", "```go\n$ go run main.go \n[val1 val2]\n[val3 val4]\n```"]