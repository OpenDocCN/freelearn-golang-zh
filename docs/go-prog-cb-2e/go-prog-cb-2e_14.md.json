["```go\n$ git clone git@github.com:PacktPublishing/Go-Programming-Cookbook-Second-Edition.git go-programming-cookbook-original\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter14/pprof \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter14/pprof   \n```", "```go\n        package crypto\n\n        import (\n            \"net/http\"\n\n            \"golang.org/x/crypto/bcrypt\"\n        )\n\n        // GuessHandler checks if ?message=password\n        func GuessHandler(w http.ResponseWriter, r *http.Request) {\n            if err := r.ParseForm(); err != nil{\n               // if we can't parse the form\n               // we'll assume it is malformed\n               w.WriteHeader(http.StatusBadRequest)\n               w.Write([]byte(\"error reading guess\"))\n               return\n            }\n\n            msg := r.FormValue(\"message\")\n\n            // \"password\"\n            real := \n            []byte(\"$2a$10$2ovnPWuIjMx2S0HvCxP/mutzdsGhyt8rq/\n            JqnJg/6OyC3B0APMGlK\")\n\n            if err := bcrypt.CompareHashAndPassword(real, []byte(msg)); \n            err != nil {\n                w.WriteHeader(http.StatusBadRequest)\n                w.Write([]byte(\"try again\"))\n                return\n            }\n\n            w.WriteHeader(http.StatusOK)\n            w.Write([]byte(\"you got it\"))\n            return\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"log\"\n            \"net/http\"\n            _ \"net/http/pprof\"\n\n            \"github.com/PacktPublishing/\n             Go-Programming-Cookbook-Second-Edition/\n             chapter14/pprof/crypto\"\n        )\n\n        func main() {\n\n            http.HandleFunc(\"/guess\", crypto.GuessHandler)\n            fmt.Println(\"server started at localhost:8080\")\n            log.Panic(http.ListenAndServe(\"localhost:8080\", nil))\n        }\n```", "```go\n$ go build $ ./example\n```", "```go\n$ go run main.go\nserver started at localhost:8080\n```", "```go\n$ go tool pprof http://localhost:8080/debug/pprof/profile\n```", "```go\n$ curl \"http://localhost:8080/guess?message=test\"\ntry again\n\n$curl \"http://localhost:8080/guess?message=password\" \nyou got it\n\n.\n.\n.\n.\n\n$curl \"http://localhost:8080/guess?message=password\" \nyou got it  \n```", "```go\n(pprof) top 10\n930ms of 930ms total ( 100%)\nShowing top 10 nodes out of 15 (cum >= 930ms)\nflat flat% sum% cum cum%\n870ms 93.55% 93.55% 870ms 93.55% \ngolang.org/x/crypto/blowfish.encryptBlock\n30ms 3.23% 96.77% 900ms 96.77% \ngolang.org/x/crypto/blowfish.ExpandKey\n30ms 3.23% 100% 30ms 3.23% runtime.memclrNoHeapPointers\n0 0% 100% 930ms 100% github.com/agtorre/go-\ncookbook/chapter13/pprof/crypto.GuessHandler\n0 0% 100% 930ms 100% \ngolang.org/x/crypto/bcrypt.CompareHashAndPassword\n0 0% 100% 30ms 3.23% golang.org/x/crypto/bcrypt.base64Encode\n0 0% 100% 930ms 100% golang.org/x/crypto/bcrypt.bcrypt\n0 0% 100% 900ms 96.77% \ngolang.org/x/crypto/bcrypt.expensiveBlowfishSetup\n0 0% 100% 930ms 100% net/http.(*ServeMux).ServeHTTP\n0 0% 100% 930ms 100% net/http.(*conn).serve\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter14/bench \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter14/bench   \n```", "```go\n        package bench\n\n        import \"sync\"\n\n        // Counter uses a sync.RWMutex to safely\n        // modify a value\n        type Counter struct {\n            value int64\n            mu *sync.RWMutex\n        }\n\n        // Add increments the counter\n        func (c *Counter) Add(amount int64) {\n            c.mu.Lock()\n            c.value += amount\n            c.mu.Unlock()\n        }\n\n        // Read returns the current counter amount\n        func (c *Counter) Read() int64 {\n            c.mu.RLock()\n            defer c.mu.RUnlock()\n            return c.value\n        }\n```", "```go\n        package bench\n\n        import \"sync/atomic\"\n\n        // AtomicCounter implements an atmoic lock\n        // using the atomic package\n        type AtomicCounter struct {\n            value int64\n        }\n\n        // Add increments the counter\n        func (c *AtomicCounter) Add(amount int64) {\n            atomic.AddInt64(&c.value, amount)\n        }\n\n        // Read returns the current counter amount\n        func (c *AtomicCounter) Read() int64 {\n            var result int64\n            result = atomic.LoadInt64(&c.value)\n            return result\n        }\n```", "```go\n        package bench\n\n        import \"testing\"\n\n        func BenchmarkCounterAdd(b *testing.B) {\n            c := Counter{0, &sync.RWMutex{}}\n            for n := 0; n < b.N; n++ {\n                c.Add(1)\n            }\n        }\n\n        func BenchmarkCounterRead(b *testing.B) {\n            c := Counter{0, &sync.RWMutex{}}\n            for n := 0; n < b.N; n++ {\n                c.Read()\n            }\n        }\n\n        func BenchmarkCounterAddRead(b *testing.B) {\n            c := Counter{0, &sync.RWMutex{}}\n            b.RunParallel(func(pb *testing.PB) {\n                for pb.Next() {\n                    c.Add(1)\n                    c.Read()\n                }\n            })\n        }\n```", "```go\n        package bench\n\n        import \"testing\"\n\n        func BenchmarkAtomicCounterAdd(b *testing.B) {\n            c := AtomicCounter{0}\n            for n := 0; n < b.N; n++ {\n                c.Add(1)\n            }\n        }\n\n        func BenchmarkAtomicCounterRead(b *testing.B) {\n            c := AtomicCounter{0}\n            for n := 0; n < b.N; n++ {\n                c.Read()\n            }\n        }\n\n        func BenchmarkAtomicCounterAddRead(b *testing.B) {\n            c := AtomicCounter{0}\n            b.RunParallel(func(pb *testing.PB) {\n                for pb.Next() {\n                    c.Add(1)\n                    c.Read()\n                }\n            })\n        }\n```", "```go\n$ go test -bench . \nBenchmarkAtomicCounterAdd-4 200000000 8.38 ns/op\nBenchmarkAtomicCounterRead-4 1000000000 2.09 ns/op\nBenchmarkAtomicCounterAddRead-4 50000000 24.5 ns/op\nBenchmarkCounterAdd-4 50000000 34.8 ns/op\nBenchmarkCounterRead-4 20000000 66.0 ns/op\nBenchmarkCounterAddRead-4 10000000 146 ns/op\nPASS\nok github.com/PacktPublishing/Go-Programming-Cookbook-Second-\nEdition/chapter14/bench 10.919s\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter14/tuning \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter14/tuning   \n```", "```go\n        package tuning\n\n        func concat(vals ...string) string {\n            finalVal := \"\"\n            for i := 0; i < len(vals); i++ {\n                finalVal += vals[i]\n                if i != len(vals)-1 {\n                    finalVal += \" \"\n                }\n            }\n            return finalVal\n        }\n```", "```go\n        package tuning\n\n        import \"strings\"\n\n        func join(vals ...string) string {\n            c := strings.Join(vals, \" \")\n            return c\n        }\n```", "```go\n        package tuning\n\n        import \"testing\"\n\n        func Benchmark_concat(b *testing.B) {\n            b.Run(\"one\", func(b *testing.B) {\n                one := []string{\"1\"}\n                for i := 0; i < b.N; i++ {\n                    concat(one...)\n                }\n            })\n            b.Run(\"five\", func(b *testing.B) {\n                five := []string{\"1\", \"2\", \"3\", \"4\", \"5\"}\n                for i := 0; i < b.N; i++ {\n                    concat(five...)\n                }\n            })\n\n            b.Run(\"ten\", func(b *testing.B) {\n                ten := []string{\"1\", \"2\", \"3\", \"4\", \"5\",\n                \"6\", \"7\", \"8\", \"9\", \"10\"}\n                for i := 0; i < b.N; i++ {\n                    concat(ten...)\n                }\n            })\n        }\n```", "```go\n        package tuning\n\n        import \"testing\"\n\n        func Benchmark_join(b *testing.B) {\n            b.Run(\"one\", func(b *testing.B) {\n                one := []string{\"1\"}\n                for i := 0; i < b.N; i++ {\n                    join(one...)\n                }\n            })\n            b.Run(\"five\", func(b *testing.B) {\n                five := []string{\"1\", \"2\", \"3\", \"4\", \"5\"}\n                for i := 0; i < b.N; i++ {\n                    join(five...)\n                }\n            })\n\n            b.Run(\"ten\", func(b *testing.B) {\n                ten := []string{\"1\", \"2\", \"3\", \"4\", \"5\",\n                \"6\", \"7\", \"8\", \"9\", \"10\"}\n                    for i := 0; i < b.N; i++ {\n                        join(ten...)\n                    }\n            })\n        }\n```", "```go\n$ GOMAXPROCS=1 go test -bench=. -benchmem -benchtime=1s\nBenchmark_concat/one 100000000 13.6 ns/op 0 B/op 0 allocs/op\nBenchmark_concat/five 5000000 386 ns/op 48 B/op 8 allocs/op\nBenchmark_concat/ten 2000000 992 ns/op 256 B/op 18 allocs/op\nBenchmark_join/one 200000000 6.30 ns/op 0 B/op 0 allocs/op\nBenchmark_join/five 10000000 124 ns/op 32 B/op 2 allocs/op\nBenchmark_join/ten 10000000 183 ns/op 64 B/op 2 allocs/op\nPASS\nok github.com/PacktPublishing/Go-Programming-Cookbook-Second-\nEdition/chapter14/tuning 12.003s\n```", "```go\n$ go mod init github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter14/fastweb \n```", "```go\nmodule github.com/PacktPublishing/Go-Programming-Cookbook-Second-Edition/chapter14/fastweb   \n```", "```go\n        package main\n\n        import (\n            \"sync\"\n        )\n\n        var items []string\n        var mu *sync.RWMutex\n\n        func init() {\n            mu = &sync.RWMutex{}\n        }\n\n        // AddItem adds an item to our list\n        // in a thread-safe way\n        func AddItem(item string) {\n            mu.Lock()\n            items = append(items, item)\n            mu.Unlock()\n        }\n\n        // ReadItems returns our list of items\n        // in a thread-safe way\n        func ReadItems() []string {\n            mu.RLock()\n            defer mu.RUnlock()\n            return items\n        }\n```", "```go\n        package main\n\n        import (\n            \"encoding/json\"\n\n            \"github.com/valyala/fasthttp\"\n        )\n\n        // GetItems will return our items object\n        func GetItems(ctx *fasthttp.RequestCtx) {\n            enc := json.NewEncoder(ctx)\n            items := ReadItems()\n            enc.Encode(&items)\n            ctx.SetStatusCode(fasthttp.StatusOK)\n        }\n\n        // AddItems modifies our array\n        func AddItems(ctx *fasthttp.RequestCtx) {\n            item, ok := ctx.UserValue(\"item\").(string)\n            if !ok {\n                ctx.SetStatusCode(fasthttp.StatusBadRequest)\n                return\n            }\n\n            AddItem(item)\n            ctx.SetStatusCode(fasthttp.StatusOK)\n        }\n```", "```go\n        package main\n\n        import (\n            \"fmt\"\n            \"log\"\n\n            \"github.com/buaazp/fasthttprouter\"\n            \"github.com/valyala/fasthttp\"\n        )\n\n        func main() {\n            router := fasthttprouter.New()\n            router.GET(\"/item\", GetItems)\n            router.POST(\"/item/:item\", AddItems)\n\n            fmt.Println(\"server starting on localhost:8080\")\n            log.Fatal(fasthttp.ListenAndServe(\"localhost:8080\", \n            router.Handler))\n        }\n```", "```go\n$ ./fastweb\nserver starting on localhost:8080\n```", "```go\n$ curl \"http://localhost:8080/item/hi\" -X POST \n\n$ curl \"http://localhost:8080/item/how\" -X POST \n\n$ curl \"http://localhost:8080/item/are\" -X POST \n\n$ curl \"http://localhost:8080/item/you\" -X POST \n\n$ curl \"http://localhost:8080/item\" -X GET \n[\"hi\",\"how\", \"are\", \"you\"]\n```"]