["```go\n        package main\n        import (\n          \"log\"\n          \"runtime\"\n        )\n        const info = `\n          Application %s starting.\n          The binary was build by GO: %s`\n\n        func main() {\n          log.Printf(info, \"Example\", runtime.Version())\n        }\n\n```", "```go\n        package main\n        import (\n          \"fmt\"\n          \"os\"\n        )\n\n        func main() {\n\n          args := os.Args\n\n          // This call will print\n          // all command line arguments.\n          fmt.Println(args)\n\n          // The first argument, zero item from slice,\n          // is the name of the called binary.\n          programName := args[0]\n          fmt.Printf(\"The binary name is: %s \\n\", programName)\n\n          // The rest of the arguments could be obtained\n          // by omitting the first argument.\n          otherArgs := args[1:]\n          fmt.Println(otherArgs)\n\n          for idx, arg := range otherArgs {\n            fmt.Printf(\"Arg %d = %s \\n\", idx, arg)\n          }\n        }\n```", "```go\n        package main\n        import (\n          \"flag\"\n          \"fmt\"\n          \"log\"\n          \"os\"\n          \"strings\"\n        )\n\n        // Custom type need to implement\n        // flag.Value interface to be able to\n        // use it in flag.Var function.\n        type ArrayValue []string\n\n        func (s *ArrayValue) String() string {\n          return fmt.Sprintf(\"%v\", *s)\n        }\n\n        func (a *ArrayValue) Set(s string) error {\n          *a = strings.Split(s, \",\")\n          return nil\n        }\n\n        func main() {\n\n          // Extracting flag values with methods returning pointers\n          retry := flag.Int(\"retry\", -1, \"Defines max retry count\")\n\n          // Read the flag using the XXXVar function.\n          // In this case the variable must be defined\n          // prior to the flag.\n          var logPrefix string\n          flag.StringVar(&logPrefix, \"prefix\", \"\", \"Logger prefix\")\n\n          var arr ArrayValue\n          flag.Var(&arr, \"array\", \"Input array to iterate through.\")\n\n          // Execute the flag.Parse function, to\n          // read the flags to defined variables.\n          // Without this call the flag\n          // variables remain empty.\n          flag.Parse()\n\n          // Sample logic not related to flags\n          logger := log.New(os.Stdout, logPrefix, log.Ldate)\n\n          retryCount := 0\n          for retryCount < *retry {\n            logger.Println(\"Retrying connection\")\n            logger.Printf(\"Sending array %v\\n\", arr)\n            retryCount++\n          }\n        }\n```", "```go\n        package main\n\n        import (\n          \"log\"\n          \"os\"\n        )\n\n        func main() {\n          connStr := os.Getenv(\"DB_CONN\")\n          log.Printf(\"Connection string: %s\\n\", connStr)\n        }\n```", "```go\n        package main\n\n        import (\n          \"log\"\n          \"os\"\n        )\n\n        func main() {\n\n          key := \"DB_CONN\"\n\n          connStr, ex := os.LookupEnv(key)\n          if !ex {\n            log.Printf(\"The env variable %s is not set.\\n\", key)\n          }\n          fmt.Println(connStr)\n        }\n```", "```go\n        package main\n        import (\n          \"log\"\n          \"os\"\n        )\n\n        func main() {\n\n          key := \"DB_CONN\"\n          // Set the environmental variable.\n          os.Setenv(key, \"postgres://as:as@example.com/pg?\n                          sslmode=verify-full\")\n          val := GetEnvDefault(key, \"postgres://as:as@localhost/pg?\n                                     sslmode=verify-full\")\n          log.Println(\"The value is :\" + val)\n\n          os.Unsetenv(key)\n          val = GetEnvDefault(key, \"postgres://as:as@127.0.0.1/pg?\n                                    sslmode=verify-full\")\n          log.Println(\"The default value is :\" + val)\n\n        }\n\n        func GetEnvDefault(key, defVal string) string {\n          val, ex := os.LookupEnv(key)\n          if !ex {\n            return defVal\n          }\n          return val\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"os\"\n          \"path/filepath\"\n        )\n\n        func main() {\n          ex, err := os.Executable()\n          if err != nil {\n            panic(err)\n          }\n\n          // Path to executable file\n          fmt.Println(ex)\n\n          // Resolve the direcotry\n          // of the executable\n          exPath := filepath.Dir(ex)\n          fmt.Println(\"Executable path :\" + exPath)\n\n          // Use EvalSymlinks to get\n          // the real path.\n          realPath, err := filepath.EvalSymlinks(exPath)\n          if err != nil {\n            panic(err)\n          }\n          fmt.Println(\"Symlink evaluated:\" + realPath)\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"os\"\n          \"os/exec\"\n          \"strconv\"\n        )\n\n        func main() {\n\n          pid := os.Getpid()\n          fmt.Printf(\"Process PID: %d \\n\", pid)\n\n          prc := exec.Command(\"ps\", \"-p\", strconv.Itoa(pid), \"-v\")\n          out, err := prc.Output()\n          if err != nil {\n            panic(err)\n          }\n\n          fmt.Println(string(out))\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"os\"\n          \"os/signal\"\n          \"syscall\"\n        )\n\n        func main() {\n\n          // Create the channel where the received\n          // signal would be sent. The Notify\n          // will not block when the signal\n          // is sent and the channel is not ready.\n          // So it is better to\n          // create buffered channel.\n          sChan := make(chan os.Signal, 1)\n\n          // Notify will catch the\n          // given signals and send\n          // the os.Signal value\n          // through the sChan.\n          // If no signal specified in \n          // argument, all signals are matched.\n          signal.Notify(sChan,\n            syscall.SIGHUP,\n            syscall.SIGINT,\n            syscall.SIGTERM,\n            syscall.SIGQUIT)\n\n          // Create channel to wait till the\n          // signal is handled.\n          exitChan := make(chan int)\n          go func() {\n            signal := <-sChan\n            switch signal {\n              case syscall.SIGHUP:\n                fmt.Println(\"The calling terminal has been closed\")\n                exitChan <- 0\n\n              case syscall.SIGINT:\n                fmt.Println(\"The process has been interrupted by CTRL+C\")\n                exitChan <- 1\n\n              case syscall.SIGTERM:\n                fmt.Println(\"kill SIGTERM was executed for process\")\n                exitChan <- 1\n\n              case syscall.SIGQUIT:\n                fmt.Println(\"kill SIGQUIT was executed for process\")\n                exitChan <- 1\n            }\n          }()\n\n          code := <-exitChan\n          os.Exit(code)\n        }\n```", "```go\n        package main\n\n        import (\n          \"bytes\"\n          \"fmt\"\n          \"os/exec\"\n        )\n\n        func main() {\n\n          prc := exec.Command(\"ls\", \"-a\")\n          out := bytes.NewBuffer([]byte{})\n          prc.Stdout = out\n          err := prc.Run()\n          if err != nil {\n            fmt.Println(err)\n          }\n\n          if prc.ProcessState.Success() {\n            fmt.Println(\"Process run successfully with output:\\n\")\n            fmt.Println(out.String())\n          }\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"os/exec\"\n        )\n\n        func main() {\n\n          prc := exec.Command(\"ls\", \"-a\")\n          err := prc.Start()\n          if err != nil {\n            fmt.Println(err)\n          }\n\n          prc.Wait()\n\n          if prc.ProcessState.Success() {\n            fmt.Println(\"Process run successfully with output:\\n\")\n            fmt.Println(out.String())\n          }\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"os/exec\"\n          \"runtime\"\n        )\n\n        func main() {\n\n          var cmd string\n          if runtime.GOOS == \"windows\" {\n            cmd = \"timeout\"\n          } else {\n            cmd = \"sleep\"\n          }\n          proc := exec.Command(cmd, \"1\")\n          proc.Start()\n\n          // No process state is returned\n          // till the process finish.\n          fmt.Printf(\"Process state for running process: %v\\n\",\n                     proc.ProcessState)\n\n          // The PID could be obtain\n          // event for the running process\n          fmt.Printf(\"PID of running process: %d\\n\\n\", \n                     proc.Process.Pid)\n        }\n```", "```go\n        func main() {\n\n          var cmd string\n          if runtime.GOOS == \"windows\" {\n            cmd = \"timeout\"\n          } else {\n            cmd = \"sleep\"\n          }\n\n          proc := exec.Command(cmd, \"1\")\n          proc.Start()\n\n          // Wait function will\n          // wait till the process ends.\n          proc.Wait()\n\n          // After the process terminates\n          // the *os.ProcessState contains\n          // simple information\n          // about the process run\n          fmt.Printf(\"PID: %d\\n\", proc.ProcessState.Pid())\n          fmt.Printf(\"Process took: %dms\\n\", \n                     proc.ProcessState.SystemTime()/time.Microsecond)\n          fmt.Printf(\"Exited sucessfuly : %t\\n\",\n                     proc.ProcessState.Success())\n        }\n```", "```go\n       package main\n\n       import (\n         \"fmt\"\n         \"os/exec\"\n         \"runtime\"\n       )\n\n       func main() {\n\n         var cmd string\n\n         if runtime.GOOS == \"windows\" {\n           cmd = \"dir\"\n         } else {\n           cmd = \"ls\"\n         }\n\n         proc := exec.Command(cmd)\n\n         // Output will run the process\n         // terminates and returns the standard\n         // output in a byte slice.\n         buff, err := proc.Output()\n\n         if err != nil {\n           panic(err)\n         }\n\n         // The output of child\n         // process in form\n         // of byte slice\n         // printed as string\n         fmt.Println(string(buff))\n\n       }\n```", "```go\n        package main\n\n        import (\n          \"bytes\"\n          \"fmt\"\n          \"os/exec\"\n          \"runtime\"\n        )\n\n        func main() {\n\n          var cmd string\n\n          if runtime.GOOS == \"windows\" {\n            cmd = \"dir\"\n          } else {\n            cmd = \"ls\"\n          }\n\n          proc := exec.Command(cmd)\n\n          buf := bytes.NewBuffer([]byte{})\n\n          // The buffer which implements\n          // io.Writer interface is assigned to\n          // Stdout of the process\n          proc.Stdout = buf\n\n          // To avoid race conditions\n          // in this example. We wait till\n          // the process exit.\n          proc.Run()\n\n          // The process writes the output to\n          // to buffer and we use the bytes\n          // to print the output.\n          fmt.Println(string(buf.Bytes()))\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"bufio\"\n          \"context\"\n          \"fmt\"\n          \"os/exec\"\n          \"time\"\n        )\n\n        func main() {\n          cmd := \"ping\"\n          timeout := 2 * time.Second\n\n          // The command line tool\n          // \"ping\" is executed for\n          // 2 seconds\n          ctx, _ := context.WithTimeout(context.TODO(), timeout)\n          proc := exec.CommandContext(ctx, cmd, \"example.com\")\n\n          // The process output is obtained\n          // in form of io.ReadCloser. The underlying\n          // implementation use the os.Pipe\n          stdout, _ := proc.StdoutPipe()\n          defer stdout.Close()\n\n          // Start the process\n          proc.Start()\n\n          // For more comfortable reading the\n          // bufio.Scanner is used.\n          // The read call is blocking.\n          s := bufio.NewScanner(stdout)\n          for s.Scan() {\n            fmt.Println(s.Text())\n          }\n        }\n```", "```go\n        package main\n\n        import (\n          \"bufio\"\n          \"fmt\"\n          \"os\"\n        )\n\n        func main() {\n          sc := bufio.NewScanner(os.Stdin)\n\n          for sc.Scan() {\n            fmt.Println(sc.Text())\n          }\n        }\n```", "```go\n        package main\n\n        import (\n          \"bufio\"\n          \"fmt\"\n          \"io\"\n          \"os/exec\"\n          \"time\"\n        )\n\n        func main() {\n          cmd := []string{\"go\", \"run\", \"sample.go\"}\n\n          // The command line tool\n          // \"ping\" is executed for\n          // 2 seconds\n          proc := exec.Command(cmd[0], cmd[1], cmd[2])\n\n          // The process input is obtained\n          // in form of io.WriteCloser. The underlying\n          // implementation use the os.Pipe\n          stdin, _ := proc.StdinPipe()\n          defer stdin.Close()\n\n          // For debugging purposes we watch the\n          // output of the executed process\n          stdout, _ := proc.StdoutPipe()\n          defer stdout.Close()\n\n          go func() {\n            s := bufio.NewScanner(stdout)\n            for s.Scan() {\n              fmt.Println(\"Program says:\" + s.Text())\n            }\n          }()\n\n          // Start the process\n          proc.Start()\n\n          // Now the following lines\n          // are written to child\n          // process standard input\n          fmt.Println(\"Writing input\")\n          io.WriteString(stdin, \"Hello\\n\")\n          io.WriteString(stdin, \"Golang\\n\")\n          io.WriteString(stdin, \"is awesome\\n\")\n\n          time.Sleep(time.Second * 2)\n\n          proc.Process.Kill()\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"io\"\n          \"log\"\n          \"os\"\n          \"os/signal\"\n          \"syscall\"\n          \"time\"\n        )\n\n        var writer *os.File\n\n        func main() {\n\n          // The file is opened as\n          // a log file to write into.\n          // This way we represent the resources\n          // allocation.\n          var err error\n          writer, err = os.OpenFile(fmt.Sprintf(\"test_%d.log\",\n                time.Now().Unix()), os.O_RDWR|os.O_CREATE, os.ModePerm)\n          if err != nil {\n            panic(err)\n          }\n\n          // The code is running in a goroutine\n          // independently. So in case the program is\n          // terminated from outside, we need to\n          // let the goroutine know via the closeChan\n          closeChan := make(chan bool)\n          go func() {\n            for {\n              time.Sleep(time.Second)\n              select {\n                case <-closeChan:\n                  log.Println(\"Goroutine closing\")\n                  return\n                default:\n                  log.Println(\"Writing to log\")\n                  io.WriteString(writer, fmt.Sprintf(\"Logging access\n                                 %s\\n\", time.Now().String()))\n              }  \n\n            }\n          }()\n\n          sigChan := make(chan os.Signal, 1)\n          signal.Notify(sigChan,\n            syscall.SIGTERM,\n            syscall.SIGQUIT,\n            syscall.SIGINT)\n\n          // This is blocking read from\n          // sigChan where the Notify function sends\n          // the signal.\n          <-sigChan\n\n          // After the signal is received\n          // all the code behind the read from channel could be\n          // considered as a cleanup.\n          // CLEANUP SECTION\n          close(closeChan)\n          releaseAllResources()\n          fmt.Println(\"The application shut down gracefully\")\n        }\n\n        func releaseAllResources() {\n          io.WriteString(writer, \"Application releasing \n                         all resources\\n\")\n          writer.Close()\n        }\n```", "```go\n        package main\n\n        import (\n          \"encoding/json\"\n          \"fmt\"\n          \"os\"\n        )\n\n        type Client struct {\n          consulIP string\n          connString string\n        }\n\n        func (c *Client) String() string {\n          return fmt.Sprintf(\"ConsulIP: %s , Connection String: %s\",\n                             c.consulIP, c.connString)\n        }\n\n        var defaultClient = Client{\n          consulIP: \"localhost:9000\",\n          connString: \"postgres://localhost:5432\",\n        }\n\n        // ConfigFunc works as a type to be used\n        // in functional options\n        type ConfigFunc func(opt *Client)\n\n        // FromFile func returns the ConfigFunc\n        // type. So this way it could read the configuration\n        // from the json.\n        func FromFile(path string) ConfigFunc {\n          return func(opt *Client) {\n            f, err := os.Open(path)\n            if err != nil {\n              panic(err)\n            }\n            defer f.Close()\n            decoder := json.NewDecoder(f)\n\n            fop := struct {\n              ConsulIP string `json:\"consul_ip\"`\n            }{}\n            err = decoder.Decode(&fop)\n            if err != nil {\n              panic(err)\n            }\n            opt.consulIP = fop.ConsulIP\n          }\n        }\n\n        // FromEnv reads the configuration\n        // from the environmental variables\n        // and combines them with existing ones.\n        func FromEnv() ConfigFunc {\n          return func(opt *Client) {\n            connStr, exist := os.LookupEnv(\"CONN_DB\")\n            if exist {\n              opt.connString = connStr\n            }\n          }\n        }\n\n        func NewClient(opts ...ConfigFunc) *Client {\n          client := defaultClient\n          for _, val := range opts {\n            val(&client)\n          }\n          return &client\n        }\n\n        func main() {\n          client := NewClient(FromFile(\"config.json\"), FromEnv())\n          fmt.Println(client.String())\n        }\n```", "```go\n        {\n          \"consul_ip\":\"127.0.0.1\"\n        }\n```"]