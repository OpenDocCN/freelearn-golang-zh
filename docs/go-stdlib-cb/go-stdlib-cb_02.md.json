["```go\n        package main\n\n        import (\n          \"fmt\"\n          \"strings\"\n        )\n\n        const refString = \"Mary had a little lamb\"\n\n        func main() {\n\n          lookFor := \"lamb\"\n          contain := strings.Contains(refString, lookFor)\n          fmt.Printf(\"The \\\"%s\\\" contains \\\"%s\\\": %t \\n\", refString,\n                     lookFor, contain)\n\n          lookFor = \"wolf\"\n          contain = strings.Contains(refString, lookFor)\n          fmt.Printf(\"The \\\"%s\\\" contains \\\"%s\\\": %t \\n\", refString,\n                     lookFor, contain)\n\n          startsWith := \"Mary\"\n          starts := strings.HasPrefix(refString, startsWith)\n          fmt.Printf(\"The \\\"%s\\\" starts with \\\"%s\\\": %t \\n\", refString, \n                     startsWith, starts)\n\n          endWith := \"lamb\"\n          ends := strings.HasSuffix(refString, endWith)\n          fmt.Printf(\"The \\\"%s\\\" ends with \\\"%s\\\": %t \\n\", refString,\n                     endWith, ends)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"strings\"\n        )\n\n        const refString = \"Mary had a little lamb\"\n\n        func main() {\n\n          words := strings.Fields(refString)\n          for idx, word := range words {\n            fmt.Printf(\"Word %d is: %s\\n\", idx, word)\n          }\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"strings\"\n        )\n\n        const refString = \"Mary_had a little_lamb\"\n\n        func main() {\n\n          words := strings.Split(refString, \"_\")\n          for idx, word := range words {\n            fmt.Printf(\"Word %d is: %s\\n\", idx, word)\n          }\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"strings\"\n         )\n\n         const refString = \"Mary*had,a%little_lamb\"\n\n         func main() {\n\n           // The splitFunc is called for each\n           // rune in a string. If the rune\n           // equals any of character in a \"*%,_\"\n           // the refString is split.\n           splitFunc := func(r rune) bool {\n             return strings.ContainsRune(\"*%,_\", r)\n           }\n\n           words := strings.FieldsFunc(refString, splitFunc)\n           for idx, word := range words {\n             fmt.Printf(\"Word %d is: %s\\n\", idx, word)\n           }\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"regexp\"\n        )\n\n        const refString = \"Mary*had,a%little_lamb\"\n\n        func main() {\n\n          words := regexp.MustCompile(\"[*,%_]{1}\").Split(refString, -1)\n          for idx, word := range words {\n            fmt.Printf(\"Word %d is: %s\\n\", idx, word)\n          }\n\n        }\n```", "```go\n'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP). \n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"strings\"\n        )\n\n        const selectBase = \"SELECT * FROM user WHERE %s \"\n\n        var refStringSlice = []string{\n          \" FIRST_NAME = 'Jack' \",\n          \" INSURANCE_NO = 333444555 \",\n          \" EFFECTIVE_FROM = SYSDATE \"}\n\n        func main() {\n\n          sentence := strings.Join(refStringSlice, \"AND\")\n          fmt.Printf(selectBase+\"\\n\", sentence)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"strings\"\n        )\n\n        const selectBase = \"SELECT * FROM user WHERE \"\n\n        var refStringSlice = []string{\n          \" FIRST_NAME = 'Jack' \",\n          \" INSURANCE_NO = 333444555 \",\n          \" EFFECTIVE_FROM = SYSDATE \"}\n\n        type JoinFunc func(piece string) string\n\n        func main() {\n\n          jF := func(p string) string {\n            if strings.Contains(p, \"INSURANCE\") {\n              return \"OR\"\n            }\n\n            return \"AND\"\n          }\n          result := JoinWithFunc(refStringSlice, jF)\n          fmt.Println(selectBase + result)\n        }\n\n         func JoinWithFunc(refStringSlice []string,\n                           joinFunc JoinFunc) string {\n           concatenate := refStringSlice[0]\n           for _, val := range refStringSlice[1:] {\n             concatenate = concatenate + joinFunc(val) + val\n           }\n           return concatenate\n        }\n```", "```go\n       package main\n\n       import (\n         \"bytes\"\n         \"fmt\"\n       )\n\n       func main() {\n         strings := []string{\"This \", \"is \", \"even \",\n                             \"more \", \"performant \"}\n          buffer := bytes.Buffer{}\n          for _, val := range strings {\n            buffer.WriteString(val)\n          }\n\n           fmt.Println(buffer.String())\n         }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n        )\n\n        func main() {\n\n          strings := []string{\"This \", \"is \", \"even \",\n                              \"more \", \"performant \"}\n\n          bs := make([]byte, 100)\n          bl := 0\n\n          for _, val := range strings {\n            bl += copy(bs[bl:], []byte(val))\n          }\n\n          fmt.Println(string(bs[:]))\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"bytes\"\n          \"testing\"\n        )\n\n        const testString = \"test\"\n\n        func BenchmarkConcat(b *testing.B) {\n          var str string\n          b.ResetTimer()\n          for n := 0; n < b.N; n++ {\n            str += testString\n          }\n          b.StopTimer()\n        }\n\n        func BenchmarkBuffer(b *testing.B) {\n          var buffer bytes.Buffer\n\n          b.ResetTimer()\n          for n := 0; n < b.N; n++ {\n            buffer.WriteString(testString)\n          }\n          b.StopTimer()\n        }\n\n        func BenchmarkCopy(b *testing.B) {\n          bs := make([]byte, b.N)\n          bl := 0\n\n          b.ResetTimer()\n          for n := 0; n < b.N; n++ {\n            bl += copy(bs[bl:], testString)\n          }\n          b.StopTimer()\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"os\"\n          \"text/tabwriter\"\n        )\n\n        func main() {\n\n          w := tabwriter.NewWriter(os.Stdout, 15, 0, 1, ' ',\n                                   tabwriter.AlignRight)\n          fmt.Fprintln(w, \"username\\tfirstname\\tlastname\\t\")\n          fmt.Fprintln(w, \"sohlich\\tRadomir\\tSohlich\\t\")\n          fmt.Fprintln(w, \"novak\\tJohn\\tSmith\\t\")\n          w.Flush()\n\n        }\n```", "```go\n        package main\n\n        import (\n         \"fmt\"\n         \"strings\"\n        )\n\n        const refString = \"Mary had a little lamb\"\n        const refStringTwo = \"lamb lamb lamb lamb\"\n\n        func main() {\n          out := strings.Replace(refString, \"lamb\", \"wolf\", -1)\n          fmt.Println(out)\n\n          out = strings.Replace(refStringTwo, \"lamb\", \"wolf\", 2)\n          fmt.Println(out)\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"strings\"\n        )\n\n        const refString = \"Mary had a little lamb\"\n\n        func main() {\n          replacer := strings.NewReplacer(\"lamb\", \"wolf\", \"Mary\", \"Jack\")\n          out := replacer.Replace(refString)\n          fmt.Println(out)\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"regexp\"\n        )\n\n        const refString = \"Mary had a little lamb\"\n\n        func main() {\n          regex := regexp.MustCompile(\"l[a-z]+\")\n          out := regex.ReplaceAllString(refString, \"replacement\")\n          fmt.Println(out)\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"regexp\"\n        )\n\n        const refString = `[{ \\\"email\\\": \\\"email@example.com\\\" \\\n                             \"phone\\\": 555467890},\n                            { \\\"email\\\": \\\"other@domain.com\\\" \\\n                             \"phone\\\": 555467890}]`\n\n        func main() {\n\n          // This pattern is simplified for brevity\n          emailRegexp := regexp.MustCompile(\"[a-zA-Z0-9]{1,}\n                                             @[a-zA-Z0-9]{1,}\\\\.[a-z]{1,}\")\n          first := emailRegexp.FindString(refString)\n          fmt.Println(\"First: \")\n          fmt.Println(first)\n\n          all := emailRegexp.FindAllString(refString, -1)\n          fmt.Println(\"All: \")\n          for _, val := range all {\n            fmt.Println(val)\n          }\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"io/ioutil\"\n          \"os\"\n          \"strings\"\n\n          \"golang.org/x/text/encoding/charmap\"\n        )\n\n        func main() {\n\n          // Open windows-1250 file.\n          f, err := os.Open(\"win1250.txt\")\n          if err != nil {\n            panic(err)\n          }\n          defer f.Close()\n\n          // Read all in raw form.\n          b, err := ioutil.ReadAll(f)\n          if err != nil {\n            panic(err)\n          }\n          content := string(b)\n\n          fmt.Println(\"Without decode: \" + content)\n\n          // Decode to unicode\n          decoder := charmap.Windows1250.NewDecoder()\n          reader := decoder.Reader(strings.NewReader(content))\n          b, err = ioutil.ReadAll(reader)\n          if err != nil {\n            panic(err)\n          }\n          fmt.Println(\"Decoded: \" + string(b))\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"io\"\n          \"os\"\n\n          \"golang.org/x/text/encoding/charmap\"\n        )\n\n        func main() {\n\n          f, err := os.OpenFile(\"out.txt\", os.O_CREATE|os.O_RDWR,\n                                os.ModePerm|os.ModeAppend)\n          if err != nil {\n            panic(err)\n          }\n          defer f.Close()\n\n          // Decode to unicode\n          encoder := charmap.Windows1250.NewEncoder()\n          writer := encoder.Writer(f)\n          io.WriteString(writer, \"Gda\u0144sk\")\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"strings\"\n          \"unicode\"\n        )\n\n        const email = \"ExamPle@domain.com\"\n        const name = \"isaac newton\"\n        const upc = \"upc\"\n        const i = \"i\"\n\n        const snakeCase = \"first_name\"\n\n        func main() {\n\n          // For comparing the user input\n          // sometimes it is better to\n          // compare the input in a same\n          // case.\n          input := \"Example@domain.com\"\n          input = strings.ToLower(input)\n          emailToCompare := strings.ToLower(email)\n          matches := input == emailToCompare\n          fmt.Printf(\"Email matches: %t\\n\", matches)\n\n          upcCode := strings.ToUpper(upc)\n          fmt.Println(\"UPPER case: \" + upcCode)\n\n          // This digraph has different upper case and\n          // title case.\n          str := \"\u01f3\"\n          fmt.Printf(\"%s in upper: %s and title: %s \\n\", str,\n                     strings.ToUpper(str), strings.ToTitle(str))\n\n          // Use of XXXSpecial function\n          title := strings.ToTitle(i)\n          titleTurk := strings.ToTitleSpecial(unicode.TurkishCase, i)\n          if title != titleTurk {\n            fmt.Printf(\"ToTitle is defferent: %#U vs. %#U \\n\",\n                       title[0], []rune(titleTurk)[0])\n          }\n\n          // In some cases the input\n          // needs to be corrected in case.\n          correctNameCase := strings.Title(name)\n          fmt.Println(\"Corrected name: \" + correctNameCase)\n\n          // Converting the snake case\n          // to camel case with use of\n          // Title and ToLower functions.\n          firstNameCamel := toCamelCase(snakeCase)\n          fmt.Println(\"Camel case: \" + firstNameCamel)\n\n        }\n\n        func toCamelCase(input string) string {\n          titleSpace := strings.Title(strings.Replace(input, \"_\", \" \", -1))\n          camel := strings.Replace(titleSpace, \" \", \"\", -1)\n          return strings.ToLower(camel[:1]) + camel[1:]\n        }\n```", "```go\n        \"Name\",\"Surname\",\"Age\"\n        # this is comment in data\n        \"John\",\"Mnemonic\",20\n        Maria,Tone,21\n```", "```go\n        package main\n\n        import (\n          \"encoding/csv\"\n          \"fmt\"\n          \"os\"\n        )\n\n        func main() {\n\n          file, err := os.Open(\"data.csv\")\n          if err != nil {\n            panic(err)\n          }\n          defer file.Close()\n\n          reader := csv.NewReader(file)\n          reader.FieldsPerRecord = 3\n          reader.Comment = '#'\n\n          for {\n            record, e := reader.Read()\n            if e != nil {\n              fmt.Println(e)\n              break\n            }\n            fmt.Println(record)\n          }\n        }\n```", "```go\n       Name;Surname;Age\n       \"John\";Mnemonic;20\n       \"Maria\";Tone;21\n```", "```go\n       package main\n\n       import (\n         \"encoding/csv\"\n         \"fmt\"\n         \"os\"\n       )\n\n       func main() {\n\n         file, err := os.Open(\"data_uncommon.csv\")\n         if err != nil {\n           panic(err)\n         }\n         defer file.Close()\n\n         reader := csv.NewReader(file)\n         reader.Comma = ';'\n\n         for {\n           record, e := reader.Read()\n           if e != nil {\n             fmt.Println(e)\n             break\n           }\n           fmt.Println(record)\n         }\n       }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"math\"\n          \"regexp\"\n          \"strconv\"\n          \"strings\"\n        )\n\n        func main() {\n\n          stringToTrim := \"\\t\\t\\n Go \\tis\\t Awesome \\t\\t\"\n          trimResult := strings.TrimSpace(stringToTrim)\n          fmt.Println(trimResult)\n\n          stringWithSpaces := \"\\t\\t\\n Go \\tis\\n Awesome \\t\\t\"\n          r := regexp.MustCompile(\"\\\\s+\")\n          replace := r.ReplaceAllString(stringWithSpaces, \" \")\n          fmt.Println(replace)\n\n          needSpace := \"need space\"\n          fmt.Println(pad(needSpace, 14, \"CENTER\"))\n          fmt.Println(pad(needSpace, 14, \"LEFT\"))\n        }\n\n        func pad(input string, padLen int, align string) string {\n          inputLen := len(input)\n\n          if inputLen >= padLen {\n            return input\n          }\n\n          repeat := padLen - inputLen\n          var output string\n          switch align {\n            case \"RIGHT\":\n              output = fmt.Sprintf(\"% \"+strconv.Itoa(-padLen)+\"s\", input)\n            case \"LEFT\":\n              output = fmt.Sprintf(\"% \"+strconv.Itoa(padLen)+\"s\", input)\n            case \"CENTER\":\n              bothRepeat := float64(repeat) / float64(2)\n              left := int(math.Floor(bothRepeat)) + inputLen\n              right := int(math.Ceil(bothRepeat))\n              output = fmt.Sprintf(\"% \"+strconv.Itoa(left)+\"s% \n                                   \"+strconv.Itoa(right)+\"s\", input, \"\")\n          }\n          return output\n        }\n```", "```go\nstringToTrim := \"\\t\\t\\n Go \\tis\\t Awesome \\t\\t\"\nstringToTrim = strings.TrimSpace(stringToTrim)\n```", "```go\nr := regexp.MustCompile(\"\\\\s+\")\nreplace := r.ReplaceAllString(stringToTrim, \" \")\n```", "```go\n         package main\n\n         import (\n           \"fmt\"\n           \"strconv\"\n           \"strings\"\n           \"unicode\"\n         )\n\n         func main() {\n\n           text := \"Hi! Go is awesome.\"\n           text = Indent(text, 6)\n           fmt.Println(text)\n\n           text = Unindent(text, 3)\n           fmt.Println(text)\n\n           text = Unindent(text, 10)\n           fmt.Println(text)\n\n           text = IndentByRune(text, 10, '.')\n           fmt.Println(text)\n\n         }\n\n         // Indent indenting the input by given indent and rune\n         func IndentByRune(input string, indent int, r rune) string {\n           return strings.Repeat(string(r), indent) + input\n         }\n\n         // Indent indenting the input by given indent\n         func Indent(input string, indent int) string {\n           padding := indent + len(input)\n           return fmt.Sprintf(\"% \"+strconv.Itoa(padding)+\"s\", input)\n         }\n\n         // Unindent unindenting the input string. In case the\n         // input is indented by less than \"indent\" spaces\n         // the min of this both is removed.\n         func Unindent(input string, indent int) string {\n\n           count := 0\n           for _, val := range input {\n             if unicode.IsSpace(val) {\n               count++\n             }\n             if count == indent || !unicode.IsSpace(val) {\n               break\n             }\n           }\n\n           return input[count:]\n         }\n```"]