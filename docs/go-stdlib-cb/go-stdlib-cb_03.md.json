["```go\n        package main\n\n        import (\n          \"fmt\"\n          \"strconv\"\n        )\n\n        const bin = \"00001\"\n        const hex = \"2f\"\n        const intString = \"12\"\n        const floatString = \"12.3\"\n\n        func main() {\n\n          // Decimals\n          res, err := strconv.Atoi(intString)\n          if err != nil {\n            panic(err)\n          }\n          fmt.Printf(\"Parsed integer: %d\\n\", res)\n\n          // Parsing hexadecimals\n          res64, err := strconv.ParseInt(hex, 16, 32)\n          if err != nil {\n            panic(err)\n          }\n          fmt.Printf(\"Parsed hexadecima: %d\\n\", res64)\n\n          // Parsing binary values\n          resBin, err := strconv.ParseInt(bin, 2, 32)\n          if err != nil {\n            panic(err)\n          }\n          fmt.Printf(\"Parsed bin: %d\\n\", resBin)\n\n          // Parsing floating-points\n          resFloat, err := strconv.ParseFloat(floatString, 32)\n          if err != nil {\n            panic(err)\n          }\n          fmt.Printf(\"Parsed float: %.5f\\n\", resFloat)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"math\"\n        )\n\n        const da = 0.29999999999999998889776975374843459576368331909180\n        const db = 0.3\n\n        func main() {\n\n          daStr := fmt.Sprintf(\"%.10f\", da)\n          dbStr := fmt.Sprintf(\"%.10f\", db)\n\n          fmt.Printf(\"Strings %s = %s equals: %v \\n\", daStr,\n                     dbStr, dbStr == daStr)\n          fmt.Printf(\"Number equals: %v \\n\", db == da)\n\n          // As the precision of float representation\n          // is limited. For the float comparison it is\n          // better to use comparison with some tolerance.\n          fmt.Printf(\"Number equals with TOLERANCE: %v \\n\", \n                     equals(da, db))\n\n        }\n\n        const TOLERANCE = 1e-8\n        // Equals compares the floating-point numbers\n        // with tolerance 1e-8\n        func equals(numA, numB float64) bool {\n          delta := math.Abs(numA - numB)\n          if delta < TOLERANCE {\n            return true\n          }\n          return false\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"math/big\"\n        )\n\n        var da float64 = 0.299999992\n        var db float64 = 0.299999991\n\n        var prec uint = 32\n        var prec2 uint = 16\n\n        func main() {\n\n          fmt.Printf(\"Comparing float64 with '==' equals: %v\\n\", da == db)\n\n          daB := big.NewFloat(da).SetPrec(prec)\n          dbB := big.NewFloat(db).SetPrec(prec)\n\n          fmt.Printf(\"A: %v \\n\", daB)\n          fmt.Printf(\"B: %v \\n\", dbB)\n          fmt.Printf(\"Comparing big.Float with precision: %d : %v\\n\",\n                     prec, daB.Cmp(dbB) == 0)\n\n          daB = big.NewFloat(da).SetPrec(prec2)\n          dbB = big.NewFloat(db).SetPrec(prec2)\n\n          fmt.Printf(\"A: %v \\n\", daB)\n          fmt.Printf(\"B: %v \\n\", dbB)\n          fmt.Printf(\"Comparing big.Float with precision: %d : %v\\n\",\n                     prec2, daB.Cmp(dbB) == 0)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"math\"\n        )\n\n        var valA float64 = 3.55554444\n\n        func main() {\n\n          // Bad assumption on rounding\n          // the number by casting it to\n          // integer.\n          intVal := int(valA)\n          fmt.Printf(\"Bad rounding by casting to int: %v\\n\", intVal)\n\n          fRound := Round(valA)\n          fmt.Printf(\"Rounding by custom function: %v\\n\", fRound)\n\n        }\n\n        // Round returns the nearest integer.\n        func Round(x float64) float64 {\n          t := math.Trunc(x)\n          if math.Abs(x-t) >= 0.5 {\n            return t + math.Copysign(1, x)\n          }\n          return t\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"math/big\"\n        )\n\n        const PI = `3.1415926535897932384626433832795028841971693\n                    993751058209749445923078164062862089986280348253\n                    421170679821480865132823066470938446095505822317\n                    253594081284811174502841027019385211055596446229\n                    4895493038196`\n        const diameter = 3.0\n        const precision = 400\n\n        func main() {\n\n          pi, _ := new(big.Float).SetPrec(precision).SetString(PI)\n          d := new(big.Float).SetPrec(precision).SetFloat64(diameter)\n\n          circumference := new(big.Float).Mul(pi, d)\n\n          pi64, _ := pi.Float64()\n          fmt.Printf(\"Circumference big.Float = %.400f\\n\",\n                     circumference)\n          fmt.Printf(\"Circumference float64 = %.400f\\n\", pi64*diameter)\n\n          sum := new(big.Float).Add(pi, pi)\n          fmt.Printf(\"Sum = %.400f\\n\", sum)\n\n          diff := new(big.Float).Sub(pi, pi)\n          fmt.Printf(\"Diff = %.400f\\n\", diff)\n\n          quo := new(big.Float).Quo(pi, pi)\n          fmt.Printf(\"Quocient = %.400f\\n\", quo)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n        )\n\n        var integer int64 = 32500\n        var floatNum float64 = 22000.456\n\n        func main() {\n\n          // Common way how to print the decimal\n          // number\n          fmt.Printf(\"%d \\n\", integer)\n\n          // Always show the sign\n          fmt.Printf(\"%+d \\n\", integer)\n\n          // Print in other base X -16, o-8, b -2, d - 10\n          fmt.Printf(\"%X \\n\", integer)\n          fmt.Printf(\"%#X \\n\", integer)\n\n          // Padding with leading zeros\n          fmt.Printf(\"%010d \\n\", integer)\n\n          // Left padding with spaces\n          fmt.Printf(\"% 10d \\n\", integer)\n\n          // Right padding\n          fmt.Printf(\"% -10d \\n\", integer)\n\n          // Print floating\n          // point number\n          fmt.Printf(\"%f \\n\", floatNum)\n\n          // Floating-point number\n          // with limited precision = 5\n          fmt.Printf(\"%.5f \\n\", floatNum)\n\n          // Floating-point number\n          // in scientific notation\n          fmt.Printf(\"%e \\n\", floatNum)\n\n          // Floating-point number\n          // %e for large exponents\n          // or %f otherwise\n          fmt.Printf(\"%g \\n\", floatNum)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"golang.org/x/text/language\"\n          \"golang.org/x/text/message\"\n        )\n\n        const num = 100000.5678\n\n        func main() {\n          p := message.NewPrinter(language.English)\n          p.Printf(\" %.2f \\n\", num)\n\n          p = message.NewPrinter(language.German)\n          p.Printf(\" %.2f \\n\", num)\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"strconv\"\n        )\n\n        const bin = \"10111\"\n        const hex = \"1A\"\n        const oct = \"12\"\n        const dec = \"10\"\n        const floatNum = 16.123557\n\n        func main() {\n\n          // Converts binary value into hex\n          v, _ := ConvertInt(bin, 2, 16)\n          fmt.Printf(\"Binary value %s converted to hex: %s\\n\", bin, v)\n\n          // Converts hex value into dec\n          v, _ = ConvertInt(hex, 16, 10)\n          fmt.Printf(\"Hex value %s converted to dec: %s\\n\", hex, v)\n\n          // Converts oct value into hex\n          v, _ = ConvertInt(oct, 8, 16)\n          fmt.Printf(\"Oct value %s converted to hex: %s\\n\", oct, v)\n\n          // Converts dec value into oct\n          v, _ = ConvertInt(dec, 10, 8)\n          fmt.Printf(\"Dec value %s converted to oct: %s\\n\", dec, v)\n\n          //... analogically any other conversion\n          // could be done.\n\n        }\n\n        // ConvertInt converts the given string value of base\n        // to defined toBase.\n        func ConvertInt(val string, base, toBase int) (string, error) {\n          i, err := strconv.ParseInt(val, base, 64)\n          if err != nil {\n            return \"\", err\n          }\n          return strconv.FormatInt(i, toBase), nil\n        }\n```", "```go\n        package main\n\n        import (\n          \"golang.org/x/text/feature/plural\"\n          \"golang.org/x/text/language\"\n          \"golang.org/x/text/message\"\n        )\n\n        func main() {\n\n          message.Set(language.English, \"%d items to do\",\n            plural.Selectf(1, \"%d\", \"=0\", \"no items to do\",\n              plural.One, \"one item to do\",\n              \"<100\", \"%[1]d items to do\",\n              plural.Other, \"lot of items to do\",\n          ))\n\n          message.Set(language.English, \"The average is %.2f\",\n            plural.Selectf(1, \"%.2f\",\n              \"<1\", \"The average is zero\",\n              \"=1\", \"The average is one\",\n              plural.Other, \"The average is %[1]f \",\n          ))\n\n          prt := message.NewPrinter(language.English)\n          prt.Printf(\"%d items to do\", 0)\n          prt.Println()\n          prt.Printf(\"%d items to do\", 1)\n          prt.Println()\n          prt.Printf(\"%d items to do\", 10)\n          prt.Println()\n          prt.Printf(\"%d items to do\", 1000)\n          prt.Println()\n\n          prt.Printf(\"The average is %.2f\", 0.8)\n          prt.Println()\n          prt.Printf(\"The average is %.2f\", 1.0)\n          prt.Println()\n          prt.Printf(\"The average is %.2f\", 10.0)\n          prt.Println()\n\n        }\n```", "```go\n        package main\n\n        import (\n          crypto \"crypto/rand\"\n          \"fmt\"\n          \"math/big\"\n          \"math/rand\"\n        )\n\n        func main() {\n\n          sec1 := rand.New(rand.NewSource(10))\n          sec2 := rand.New(rand.NewSource(10))\n          for i := 0; i < 5; i++ {\n            rnd1 := sec1.Int()\n            rnd2 := sec2.Int()\n            if rnd1 != rnd2 {\n              fmt.Println(\"Rand generated non-equal sequence\")\n              break\n            } else {\n              fmt.Printf(\"Math/Rand1: %d , Math/Rand2: %d\\n\", rnd1, rnd2)\n            }\n          }\n\n          for i := 0; i < 5; i++ {\n            safeNum := NewCryptoRand()\n            safeNum2 := NewCryptoRand()\n            if safeNum == safeNum2 {\n              fmt.Println(\"Crypto generated equal numbers\")\n              break\n            } else {\n              fmt.Printf(\"Crypto/Rand1: %d , Crypto/Rand2: %d\\n\",\n                         safeNum, safeNum2)\n            }\n          }\n        }\n\n        func NewCryptoRand() int64 {\n          safeNum, err := crypto.Int(crypto.Reader, big.NewInt(100234))\n          if err != nil {\n            panic(err)\n          }\n          return safeNum.Int64()\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"math/cmplx\"\n        )\n\n        func main() {\n\n          // complex numbers are\n          // defined as real and imaginary\n          // part defined by float64\n          a := complex(2, 3)\n\n          fmt.Printf(\"Real part: %f \\n\", real(a))\n          fmt.Printf(\"Complex part: %f \\n\", imag(a))\n\n          b := complex(6, 4)\n\n          // All common\n          // operators are useful\n          c := a - b\n          fmt.Printf(\"Difference : %v\\n\", c)\n          c = a + b\n          fmt.Printf(\"Sum : %v\\n\", c)\n          c = a * b\n          fmt.Printf(\"Product : %v\\n\", c)\n          c = a / b\n          fmt.Printf(\"Product : %v\\n\", c)\n\n          conjugate := cmplx.Conj(a)\n          fmt.Println(\"Complex number a's conjugate : \", conjugate)\n\n          cos := cmplx.Cos(b)\n          fmt.Println(\"Cosine of b : \", cos)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"math\"\n        )\n\n        type Radian float64\n\n        func (rad Radian) ToDegrees() Degree {\n          return Degree(float64(rad) * (180.0 / math.Pi))\n        }\n\n        func (rad Radian) Float64() float64 {\n          return float64(rad)\n        }\n\n        type Degree float64\n\n        func (deg Degree) ToRadians() Radian {\n          return Radian(float64(deg) * (math.Pi / 180.0))\n        }\n\n        func (deg Degree) Float64() float64 {\n          return float64(deg)\n        }\n\n        func main() {\n\n          val := radiansToDegrees(1)\n          fmt.Printf(\"One radian is : %.4f degrees\\n\", val)\n\n          val2 := degreesToRadians(val)\n          fmt.Printf(\"%.4f degrees is %.4f rad\\n\", val, val2)\n\n          // Conversion as part\n          // of type methods\n          val = Radian(1).ToDegrees().Float64()\n          fmt.Printf(\"Degrees: %.4f degrees\\n\", val)\n\n          val = Degree(val).ToRadians().Float64()\n          fmt.Printf(\"Rad: %.4f radians\\n\", val)\n        }\n\n        func degreesToRadians(deg float64) float64 {\n          return deg * (math.Pi / 180.0)\n        }\n\n        func radiansToDegrees(rad float64) float64 {\n          return rad * (180.0 / math.Pi)\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"math\"\n        )\n\n        func main() {\n\n          ln := math.Log(math.E)\n          fmt.Printf(\"Ln(E) = %.4f\\n\", ln)\n\n          log10 := math.Log10(-100)\n          fmt.Printf(\"Log10(10) = %.4f\\n\", log10)\n\n          log2 := math.Log2(2)\n          fmt.Printf(\"Log2(2) = %.4f\\n\", log2)\n\n          log_3_6 := Log(3, 6)\n          fmt.Printf(\"Log3(6) = %.4f\\n\", log_3_6)\n\n        }\n\n        // Log computes the logarithm of\n        // base > 1 and x greater 0\n        func Log(base, x float64) float64 {\n          return math.Log(x) / math.Log(base)\n        }\n```", "```go\n        This is content to check\n```", "```go\n        package main\n\n        import (\n          \"crypto/md5\"\n          \"fmt\"\n          \"io\"\n          \"os\"\n        )\n\n        var content = \"This is content to check\"\n\n        func main() {\n\n          checksum := MD5(content)\n          checksum2 := FileMD5(\"content.dat\")\n\n          fmt.Printf(\"Checksum 1: %s\\n\", checksum)\n          fmt.Printf(\"Checksum 2: %s\\n\", checksum2)\n          if checksum == checksum2 {\n            fmt.Println(\"Content matches!!!\")\n          }\n\n        }\n\n        // MD5 creates the md5\n        // hash for given content encoded in\n        // hex string\n        func MD5(data string) string {\n          h := md5.Sum([]byte(data))\n          return fmt.Sprintf(\"%x\", h)\n        }\n\n        // FileMD5 creates hex encoded md5 hash\n        // of file content\n        func FileMD5(path string) string {\n          h := md5.New()\n          f, err := os.Open(path)\n          if err != nil {\n            panic(err)\n          }\n          defer f.Close()\n          _, err = io.Copy(h, f)\n          if err != nil {\n            panic(err)\n          }\n          return fmt.Sprintf(\"%x\", h.Sum(nil))\n        }\n```", "```go\n        package main\n\n        import (\n          \"crypto\"\n        )\n\n        func main() {\n          crypto.SHA1.New()\n        }\n```"]