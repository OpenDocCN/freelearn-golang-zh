["```go\n        package main\n\n        import (\n          \"fmt\"\n          \"time\"\n        )\n\n        func main() {\n          today := time.Now()\n          fmt.Println(today)\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"time\"\n        )\n\n        func main() {\n          tTime := time.Date(2017, time.March, 5, 8, 5, 2, 0, time.Local)\n\n          // The formatting is done\n          // with use of reference value\n          // Jan 2 15:04:05 2006 MST\n          fmt.Printf(\"tTime is: %s\\n\", tTime.Format(\"2006/1/2\"))\n\n          fmt.Printf(\"The time is: %s\\n\", tTime.Format(\"15:04\"))\n\n          //The predefined formats could\n          // be used\n          fmt.Printf(\"The time is: %s\\n\", tTime.Format(time.RFC1123))\n\n          // The formatting supports space padding\n          //only for days in Go version 1.9.2\n          fmt.Printf(\"tTime is: %s\\n\", tTime.Format(\"2006/1/_2\"))\n\n          // The zero padding is done by adding 0\n          fmt.Printf(\"tTime is: %s\\n\", tTime.Format(\"2006/01/02\"))\n\n          //The fraction with leading zeros use 0s\n          fmt.Printf(\"tTime is: %s\\n\", tTime.Format(\"15:04:05.00\"))\n\n          //The fraction without leading zeros use 9s\n          fmt.Printf(\"tTime is: %s\\n\", tTime.Format(\"15:04:05.999\"))\n\n          // Append format appends the formatted time to given\n          // buffer\n          fmt.Println(string(tTime.AppendFormat([]byte(\"The time \n                             is up: \"), \"03:04PM\")))\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"time\"\n        )\n\n        func main() {\n\n          // If timezone is not defined\n          // than Parse function returns\n          // the time in UTC timezone.\n          t, err := time.Parse(\"2/1/2006\", \"31/7/2015\")\n          if err != nil {\n            panic(err)\n          }\n          fmt.Println(t)\n\n          // If timezone is given than it is parsed\n          // in given timezone\n          t, err = time.Parse(\"2/1/2006 3:04 PM MST\", \n                              \"31/7/2015 1:25 AM DST\")\n          if err != nil {\n            panic(err)\n          }\n          fmt.Println(t)\n\n          // Note that the ParseInLocation\n          // parses the time in given location, if the\n          // string does not contain time zone definition\n          t, err = time.ParseInLocation(\"2/1/2006 3:04 PM \", \n                        \"31/7/2015 1:25 AM \", time.Local)\n          if err != nil {\n            panic(err)\n          }\n          fmt.Println(t)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"time\"\n        )\n\n        func main() {\n\n          // Set the epoch from int64\n          t := time.Unix(0, 0)\n          fmt.Println(t)\n\n          // Get the epoch\n          // from Time instance\n          epoch := t.Unix()\n          fmt.Println(epoch)\n\n          // Current epoch time\n          apochNow := time.Now().Unix()\n          fmt.Printf(\"Epoch time in seconds: %d\\n\", apochNow)\n\n          apochNano := time.Now().UnixNano()\n          fmt.Printf(\"Epoch time in nano-seconds: %d\\n\", apochNano)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"time\"\n        )\n\n        func main() {\n          t := time.Date(2017, 11, 29, 21, 0, 0, 0, time.Local)\n          fmt.Printf(\"Extracting units from: %v\\n\", t)\n\n          dOfMonth := t.Day()\n          weekDay := t.Weekday()\n          month := t.Month()\n\n          fmt.Printf(\"The %dth day of %v is %v\\n\", dOfMonth,\n                     month, weekDay)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"time\"\n        )\n\n        func main() {\n\n          l, err := time.LoadLocation(\"Europe/Vienna\")\n          if err != nil {\n            panic(err)\n          }\n          t := time.Date(2017, 11, 30, 11, 10, 20, 0, l)\n          fmt.Printf(\"Default date is: %v\\n\", t)\n\n          // Add 3 days\n          r1 := t.Add(72 * time.Hour)\n          fmt.Printf(\"Default date +3HRS is: %v\\n\", r1)\n\n          // Subtract 3 days\n          r1 = t.Add(-72 * time.Hour)\n          fmt.Printf(\"Default date -3HRS is: %v\\n\", r1)\n\n          // More comfortable api\n          // to add days/months/years\n          r1 = t.AddDate(1, 3, 2)\n          fmt.Printf(\"Default date +1YR +3MTH +2D is: %v\\n\", r1)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"time\"\n        )\n\n        func main() {\n\n          l, err := time.LoadLocation(\"Europe/Vienna\")\n          if err != nil {\n            panic(err)\n          }\n          t := time.Date(2000, 1, 1, 0, 0, 0, 0, l)\n          t2 := time.Date(2000, 1, 3, 0, 0, 0, 0, l)\n          fmt.Printf(\"First Default date is %v\\n\", t)\n          fmt.Printf(\"Second Default date is %v\\n\", t2)\n\n          dur := t2.Sub(t)\n          fmt.Printf(\"The duration between t and t2 is %v\\n\", dur)\n\n          dur = time.Since(t)\n          fmt.Printf(\"The duration between now and t is %v\\n\", dur)\n\n          dur = time.Until(t)\n          fmt.Printf(\"The duration between t and now is %v\\n\", dur)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"time\"\n        )\n\n        func main() {\n          eur, err := time.LoadLocation(\"Europe/Vienna\")\n          if err != nil {\n            panic(err)\n          }\n\n          t := time.Date(2000, 1, 1, 0, 0, 0, 0, eur)\n          fmt.Printf(\"Original Time: %v\\n\", t)\n\n          phx, err := time.LoadLocation(\"America/Phoenix\")\n          if err != nil {\n            panic(err)\n          }\n\n          t2 := t.In(phx)\n          fmt.Printf(\"Converted Time: %v\\n\", t2)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"os\"\n          \"os/signal\"\n          \"time\"\n       )\n\n       func main() {\n\n         c := make(chan os.Signal, 1)\n         signal.Notify(c)\n\n         ticker := time.NewTicker(time.Second)\n         stop := make(chan bool)\n\n         go func() {\n           defer func() { stop <- true }()\n           for {\n             select {\n               case <-ticker.C:\n                 fmt.Println(\"Tick\")\n               case <-stop:\n                 fmt.Println(\"Goroutine closing\")\n                 return\n             }\n           }\n         }()\n\n         // Block until\n         // the signal is received\n         <-c\n         ticker.Stop()\n\n         // Stop the goroutine\n         stop <- true\n         // Wait until the\n         <-stop\n         fmt.Println(\"Application stopped\")\n       }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"sync\"\n          \"time\"\n        )\n\n        func main() {\n\n          t := time.NewTimer(3 * time.Second)\n\n          fmt.Printf(\"Start waiting at %v\\n\", \n                     time.Now().Format(time.UnixDate))\n          <-t.C\n          fmt.Printf(\"Code executed at %v\\n\", \n                     time.Now().Format(time.UnixDate))\n\n          wg := &sync.WaitGroup{}\n          wg.Add(1)\n          fmt.Printf(\"Start waiting for AfterFunc at %v\\n\", \n                     time.Now().Format(time.UnixDate))\n          time.AfterFunc(3*time.Second, func() {\n          fmt.Printf(\"Code executed for AfterFunc at %v\\n\", \n                     time.Now().Format(time.UnixDate))\n          wg.Done()\n        })\n\n        wg.Wait()\n\n        fmt.Printf(\"Waiting on time.After at %v\\n\", \n                   time.Now().Format(time.UnixDate))\n        <-time.After(3 * time.Second)\n        fmt.Printf(\"Code resumed at %v\\n\", \n                   time.Now().Format(time.UnixDate))\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"time\"\n        )\n\n        func main() {\n\n          to := time.After(3 * time.Second)\n          list := make([]string, 0)\n          done := make(chan bool, 1)\n\n          fmt.Println(\"Starting to insert items\")\n          go func() {\n            defer fmt.Println(\"Exiting goroutine\")\n            for {\n              select {\n                case <-to:\n                  fmt.Println(\"The time is up\")\n                  done <- true\n                  return\n                default:\n                  list = append(list, time.Now().String())\n              }\n            }\n          }()\n\n          <-done\n          fmt.Printf(\"Managed to insert %d items\\n\", len(list))\n        }\n```", "```go\n        package main\n\n        import (\n          \"encoding/json\"\n          \"fmt\"\n          \"time\"\n        )\n\n        func main() {\n\n          eur, err := time.LoadLocation(\"Europe/Vienna\")\n          if err != nil {\n            panic(err)\n          }\n          t := time.Date(2017, 11, 20, 11, 20, 10, 0, eur)\n\n          // json.Marshaler interface\n          b, err := t.MarshalJSON()\n          if err != nil {\n            panic(err)\n          }\n          fmt.Println(\"Serialized as RFC 3339:\", string(b))\n          t2 := time.Time{}\n          t2.UnmarshalJSON(b)\n          fmt.Println(\"Deserialized from RFC 3339:\", t2)\n\n          // Serialize as epoch\n          epoch := t.Unix()\n          fmt.Println(\"Serialized as Epoch:\", epoch)\n\n          // Deserialize epoch\n          jsonStr := fmt.Sprintf(\"{ \\\"created\\\":%d }\", epoch)\n          data := struct {\n            Created int64 `json:\"created\"`\n          }{}\n          json.Unmarshal([]byte(jsonStr), &data)\n          deserialized := time.Unix(data.Created, 0)\n          fmt.Println(\"Deserialized from Epoch:\", deserialized)\n\n        }\n```"]