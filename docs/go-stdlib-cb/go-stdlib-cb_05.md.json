["```go\n        package main\n\n        import (\n          \"fmt\"\n        )\n\n        func main() {\n\n          var name string\n          fmt.Println(\"What is your name?\")\n          fmt.Scanf(\"%s\\n\", &name)\n\n          var age int\n          fmt.Println(\"What is your age?\")\n          fmt.Scanf(\"%d\\n\", &age)\n\n          fmt.Printf(\"Hello %s, your age is %d\\n\", name, age)\n\n       }\n```", "```go\n        package main\n\n        import (\n          \"bufio\"\n          \"fmt\"\n          \"os\"\n        )\n\n        func main() {\n\n          // The Scanner is able to\n          // scan input by lines\n          sc := bufio.NewScanner(os.Stdin)\n\n          for sc.Scan() {\n            txt := sc.Text()\n            fmt.Printf(\"Echo: %s\\n\", txt)\n          }\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"os\"\n        )\n\n        func main() {\n\n         for {\n           data := make([]byte, 8)\n           n, err := os.Stdin.Read(data)\n           if err == nil && n > 0 {\n             process(data)\n           } else {\n             break\n           }\n         }\n\n       }\n\n       func process(data []byte) {\n         fmt.Printf(\"Received: %X %s\\n\", data, string(data))\n       }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"io\"\n          \"os\"\n         )\n\n         func main() {\n\n           // Simply write string\n           io.WriteString(os.Stdout,\n           \"This is string to standard output.\\n\")\n\n           io.WriteString(os.Stderr,\n           \"This is string to standard error output.\\n\")\n\n           // Stdout/err implements\n           // writer interface\n           buf := []byte{0xAF, 0xFF, 0xFE}\n           for i := 0; i < 200; i++ {\n             if _, e := os.Stdout.Write(buf); e != nil {\n               panic(e)\n             }\n           }\n\n           // The fmt package\n           // could be used too\n           fmt.Fprintln(os.Stdout, \"\\n\")\n         }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"io\"\n          \"io/ioutil\"\n          \"os\"\n        )\n\n        func main() {\n\n          f, err := os.Open(\"temp/file.txt\")\n          if err != nil {\n            panic(err)\n          }\n\n          c, err := ioutil.ReadAll(f)\n          if err != nil {\n            panic(err)\n          }\n\n          fmt.Printf(\"### File content ###\\n%s\\n\", string(c))\n          f.Close()\n\n          f, err = os.OpenFile(\"temp/test.txt\", os.O_CREATE|os.O_RDWR,\n                               os.ModePerm)\n          if err != nil {\n            panic(err)\n          }\n          io.WriteString(f, \"Test string\")\n          f.Close()\n\n        }\n```", "```go\n        package main\n\n        import \"os\"\n        import \"bufio\"\n\n        import \"bytes\"\n        import \"fmt\"\n        import \"io/ioutil\"\n\n        func main() {\n\n          fmt.Println(\"### Read as reader ###\")\n          f, err := os.Open(\"temp/file.txt\")\n          if err != nil {\n            panic(err)\n          }\n          defer f.Close()\n\n          // Read the\n          // file with reader\n          wr := bytes.Buffer{}\n          sc := bufio.NewScanner(f)\n          for sc.Scan() {\n            wr.WriteString(sc.Text())\n          }\n          fmt.Println(wr.String())\n\n          fmt.Println(\"### ReadFile ###\")\n          // for smaller files\n          fContent, err := ioutil.ReadFile(\"temp/file.txt\")\n          if err != nil {\n            panic(err)\n          }\n          fmt.Println(string(fContent))\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"io/ioutil\"\n          \"os\"\n\n          \"golang.org/x/text/encoding/charmap\"\n        )\n\n        func main() {\n\n          // Write the string\n          // encoded to Windows-1252\n          encoder := charmap.Windows1252.NewEncoder()\n          s, e := encoder.String(\"This is sample text with runes \u0160\")\n          if e != nil {\n            panic(e)\n          }\n          ioutil.WriteFile(\"example.txt\", []byte(s), os.ModePerm)\n\n          // Decode to UTF-8\n          f, e := os.Open(\"example.txt\")\n          if e != nil {\n            panic(e)\n          }\n          defer f.Close()\n          decoder := charmap.Windows1252.NewDecoder()\n          reader := decoder.Reader(f)\n          b, err := ioutil.ReadAll(reader)\n          if err != nil {\n            panic(err)\n          }\n          fmt.Println(string(b))\n        }\n```", "```go\n 123.Jun.......Wong......\n 12..Novak.....Jurgen....\n 10..Thomas....Sohlich...\n```", "```go\n        package main\n\n        import (\n          \"errors\"\n          \"fmt\"\n          \"os\"\n        )\n\n        const lineLegth = 25\n\n        func main() {\n\n          f, e := os.OpenFile(\"flatfile.txt\", os.O_RDWR|os.O_CREATE,\n                              os.ModePerm)\n          if e != nil {\n            panic(e)\n          }\n          defer f.Close()\n\n          fmt.Println(readRecords(2, \"last\", f))\n          if err := writeRecord(2, \"first\", \"Radomir\", f); err != nil {\n            panic(err)\n          }\n          fmt.Println(readRecords(2, \"first\", f))\n          if err := writeRecord(10, \"first\", \"Andrew\", f); err != nil {\n            panic(err)\n          }\n          fmt.Println(readRecords(10, \"first\", f))\n          fmt.Println(readLine(2, f))\n        }\n\n        func readLine(line int, f *os.File) (string, error) {\n          lineBuffer := make([]byte, 24)\n          f.Seek(int64(line*lineLegth), 0)\n          _, err := f.Read(lineBuffer)\n          return string(lineBuffer), err\n        }\n\n        func writeRecord(line int, column, dataStr string, f *os.File) \n        error {\n          definedLen := 10\n          position := int64(line * lineLegth)\n          switch column {\n            case \"id\":\n              definedLen = 4\n            case \"first\":\n              position += 4\n            case \"last\":\n              position += 14\n           default:\n             return errors.New(\"Column not defined\")\n          }\n\n          if len([]byte(dataStr)) > definedLen {\n            return fmt.Errorf(\"Maximum length for '%s' is %d\", \n                              column, definedLen)\n          }\n\n          data := make([]byte, definedLen)\n          for i := range data {\n            data[i] = '.'\n          }\n          copy(data, []byte(dataStr))\n          _, err := f.WriteAt(data, position)\n          return err\n        }\n\n        func readRecords(line int, column string, f *os.File) \n                        (string, error) {\n          lineBuffer := make([]byte, 24)\n          f.ReadAt(lineBuffer, int64(line*lineLegth))\n          var retVal string\n          switch column {\n            case \"id\":\n              return string(lineBuffer[:3]), nil\n            case \"first\":\n              return string(lineBuffer[4:13]), nil\n            case \"last\":\n              return string(lineBuffer[14:23]), nil\n          }\n\n          return retVal, errors.New(\"Column not defined\")\n        }\n```", "```go\n        package main\n\n        import (\n          \"bytes\"\n          \"encoding/binary\"\n          \"fmt\"\n        )\n\n        func main() {\n          // Writing binary values\n          buf := bytes.NewBuffer([]byte{})\n          if err := binary.Write(buf, binary.BigEndian, 1.004); \n          err != nil {\n            panic(err)\n          }\n          if err := binary.Write(buf, binary.BigEndian,\n                   []byte(\"Hello\")); err != nil {\n            panic(err)\n          }\n\n          // Reading the written values\n          var num float64\n          if err := binary.Read(buf, binary.BigEndian, &num); \n          err != nil {\n            panic(err)\n          }\n          fmt.Printf(\"float64: %.3f\\n\", num)\n          greeting := make([]byte, 5)\n          if err := binary.Read(buf, binary.BigEndian, &greeting);\n          err != nil {\n            panic(err)\n          }\n          fmt.Printf(\"string: %s\\n\", string(greeting))\n        }\n```", "```go\n        package main\n\n        import \"io\"\n        import \"bytes\"\n        import \"os\"\n        import \"fmt\"\n\n        func main() {\n\n          buf := bytes.NewBuffer([]byte{})\n          f, err := os.OpenFile(\"sample.txt\", os.O_CREATE|os.O_RDWR,\n                                os.ModePerm)\n          if err != nil {\n            panic(err)\n          }\n          wr := io.MultiWriter(buf, f)\n          _, err = io.WriteString(wr, \"Hello, Go is awesome!\")\n          if err != nil {\n            panic(err)\n          }\n\n          fmt.Println(\"Content of buffer: \" + buf.String())\n        }\n```", "```go\n Hello, Go is awesome!\n```", "```go\n        package main\n\n        import (\n          \"io\"\n          \"log\"\n          \"os\"\n          \"os/exec\"\n        )\n\n        func main() {\n          pReader, pWriter := io.Pipe()\n\n          cmd := exec.Command(\"echo\", \"Hello Go!\\nThis is example\")\n          cmd.Stdout = pWriter\n\n          go func() {\n            defer pReader.Close()\n            if _, err := io.Copy(os.Stdout, pReader); err != nil {\n              log.Fatal(err)\n            }\n          }()\n\n          if err := cmd.Run(); err != nil {\n            log.Fatal(err)\n          }\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"bytes\"\n          \"encoding/gob\"\n          \"fmt\"\n        )\n\n        type User struct {\n          FirstName string\n          LastName string\n          Age int\n          Active bool\n        }\n\n        func (u User) String() string {\n          return fmt.Sprintf(`{\"FirstName\":%s,\"LastName\":%s,\n                               \"Age\":%d,\"Active\":%v }`,\n          u.FirstName, u.LastName, u.Age, u.Active)\n        }\n\n        type SimpleUser struct {\n          FirstName string\n          LastName string\n        }\n\n        func (u SimpleUser) String() string {\n          return fmt.Sprintf(`{\"FirstName\":%s,\"LastName\":%s}`,\n          u.FirstName, u.LastName)\n        }\n\n        func main() {\n\n          var buff bytes.Buffer\n\n          // Encode value\n          enc := gob.NewEncoder(&buff)\n          user := User{\n            \"Radomir\",\n            \"Sohlich\",\n            30,\n            true,\n          }\n          enc.Encode(user)\n          fmt.Printf(\"%X\\n\", buff.Bytes())\n\n          // Decode value\n          out := User{}\n          dec := gob.NewDecoder(&buff)\n          dec.Decode(&out)\n          fmt.Println(out.String())\n\n          enc.Encode(user)\n          out2 := SimpleUser{}\n          dec.Decode(&out2)\n          fmt.Println(out2.String())\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"archive/zip\"\n          \"bytes\"\n          \"fmt\"\n          \"io\"\n          \"io/ioutil\"\n          \"log\"\n          \"os\"\n        )\n\n        func main() {\n\n          var buff bytes.Buffer\n\n          // Compress content\n          zipW := zip.NewWriter(&buff)\n          f, err := zipW.Create(\"newfile.txt\")\n          if err != nil {\n            panic(err)\n          }\n          _, err = f.Write([]byte(\"This is my file content\"))\n          if err != nil {\n            panic(err)\n          }\n          err = zipW.Close()\n          if err != nil {\n            panic(err)\n          }\n\n          //Write output to file\n          err = ioutil.WriteFile(\"data.zip\", buff.Bytes(), os.ModePerm)\n          if err != nil {\n            panic(err)\n          }\n\n          // Decompress the content\n          zipR, err := zip.OpenReader(\"data.zip\")\n          if err != nil {\n            panic(err)\n          }\n\n          for _, file := range zipR.File {\n            fmt.Println(\"File \" + file.Name + \" contains:\")\n            r, err := file.Open()\n            if err != nil {\n              log.Fatal(err)\n            }\n            _, err = io.Copy(os.Stdout, r)\n            if err != nil {\n              panic(err)\n            }\n            err = r.Close()\n            if err != nil {\n              panic(err)\n            }\n            fmt.Println()\n          }\n\n        }\n```", "```go\n        <?xml version=\"1.0\"?>\n        <catalog>\n          <book id=\"bk101\">\n            <author>Gambardella, Matthew</author>\n            <title>XML Developer's Guide</title>\n            <genre>Computer</genre>\n            <price>44.95</price>\n            <publish_date>2000-10-01</publish_date>\n            <description>An in-depth look at creating applications \n             with XML.</description>\n          </book>\n          <book id=\"bk112\">\n            <author>Galos, Mike</author>\n            <title>Visual Studio 7: A Comprehensive Guide</title>\n            <genre>Computer</genre>\n            <price>49.95</price>\n            <publish_date>2001-04-16</publish_date>\n            <description>Microsoft Visual Studio 7 is explored\n             in depth, looking at how Visual Basic, Visual C++, C#,\n             and ASP+ are integrated into a comprehensive development\n             environment.</description>\n          </book>\n        </catalog>\n```", "```go\n        package main\n\n        import (\n          \"encoding/xml\"\n          \"fmt\"\n          \"os\"\n        )\n\n        type Book struct {\n          Title string `xml:\"title\"`\n          Author string `xml:\"author\"`\n        }\n\n        func main() {\n\n          f, err := os.Open(\"data.xml\")\n          if err != nil {\n            panic(err)\n          }\n          defer f.Close()\n          decoder := xml.NewDecoder(f)\n\n          // Read the book one by one\n          books := make([]Book, 0)\n          for {\n            tok, _ := decoder.Token()\n            if tok == nil {\n              break\n            }\n            switch tp := tok.(type) {\n              case xml.StartElement:\n                if tp.Name.Local == \"book\" {\n                  // Decode the element to struct\n                  var b Book\n                  decoder.DecodeElement(&b, &tp)\n                  books = append(books, b)\n                }\n            }\n          }\n          fmt.Println(books)\n        }\n```", "```go\n        package main\n\n        import (\n          \"encoding/json\"\n          \"fmt\"\n          \"strings\"\n        )\n\n        const js = `\n          [\n            {\n              \"name\":\"Axel\",\n              \"lastname\":\"Fooley\"\n            },\n            {\n              \"name\":\"Tim\",\n              \"lastname\":\"Burton\"\n            },\n            {\n              \"name\":\"Tim\",\n              \"lastname\":\"Burton\"\n        `\n\n        type User struct {\n          Name string `json:\"name\"`\n          LastName string `json:\"lastname\"`\n        }\n\n        func main() {\n\n          userSlice := make([]User, 0)\n          r := strings.NewReader(js)\n          dec := json.NewDecoder(r)\n          for {\n            tok, err := dec.Token()\n            if err != nil {\n              break\n            }\n            if tok == nil {\n              break\n            }\n            switch tp := tok.(type) {\n              case json.Delim:\n                str := tp.String()\n                if str == \"[\" || str == \"{\" {\n                  for dec.More() {\n                    u := User{}\n                    err := dec.Decode(&u)\n                    if err == nil {\n                      userSlice = append(userSlice, u)\n                    } else {\n                      break\n                    }\n                  }\n                }\n              }\n            }\n\n            fmt.Println(userSlice)\n          }\n```"]