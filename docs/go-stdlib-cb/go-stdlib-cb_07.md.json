["```go\n        package main\n\n        import (\n          \"fmt\"\n          \"net\"\n        )\n\n        func main() {\n\n          // Get all network interfaces\n          interfaces, err := net.Interfaces()\n          if err != nil {\n            panic(err)\n          }\n\n          for _, interf := range interfaces {\n            // Resolve addresses\n            // for each interface\n            addrs, err := interf.Addrs()\n            if err != nil {\n              panic(err)\n            }\n            fmt.Println(interf.Name)\n            for _, add := range addrs {\n              if ip, ok := add.(*net.IPNet); ok {\n                fmt.Printf(\"\\t%v\\n\", ip)\n              }\n            }\n\n          }\n        }\n```", "```go\n        package main\n\n        import (\n          \"bufio\"\n          \"context\"\n          \"fmt\"\n          \"io\"\n          \"net\"\n          \"net/http\"\n          \"time\"\n        )\n\n        type StringServer string\n\n        func (s StringServer) ServeHTTP(rw http.ResponseWriter,\n                                        req *http.Request) {\n          rw.Write([]byte(string(s)))\n        }\n\n        func createServer(addr string) http.Server {\n          return http.Server{\n            Addr: addr,\n            Handler: StringServer(\"HELLO GOPHER!\\n\"),\n          }\n       }\n\n       const addr = \"localhost:7070\"\n\n       func main() {\n         s := createServer(addr)\n         go s.ListenAndServe()\n\n         // Connect with plain TCP\n         conn, err := net.Dial(\"tcp\", addr)\n         if err != nil {\n           panic(err)\n         }\n         defer conn.Close()\n\n         _, err = io.WriteString(conn, \"GET / HTTP/1.1\\r\\nHost:\n                                 localhost:7070\\r\\n\\r\\n\")\n         if err != nil {\n           panic(err)\n         }\n\n         scanner := bufio.NewScanner(conn)\n         conn.SetReadDeadline(time.Now().Add(time.Second))\n         for scanner.Scan() {\n           fmt.Println(scanner.Text())\n         }\n\n         ctx, _ := context.WithTimeout(context.Background(),\n                                       5*time.Second)\n         s.Shutdown(ctx)\n\n       }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"net\"\n        )\n\n        func main() {\n\n          // Resolve by IP\n          addrs, err := net.LookupAddr(\"127.0.0.1\")\n          if err != nil {\n            panic(err)\n          }\n\n          for _, addr := range addrs {\n            fmt.Println(addr)\n          }\n\n          //Resolve by address\n          ips, err := net.LookupIP(\"localhost\")\n          if err != nil {\n            panic(err)\n          }\n\n          for _, ip := range ips {\n            fmt.Println(ip.String())\n          }\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"io/ioutil\"\n          \"net/http\"\n          \"net/url\"\n          \"strings\"\n        )\n\n        type StringServer string\n\n        func (s StringServer) ServeHTTP(rw http.ResponseWriter,\n                                        req *http.Request) {\n          req.ParseForm()\n          fmt.Printf(\"Received form data: %v\\n\", req.Form)\n          rw.Write([]byte(string(s)))\n        } \n\n        func createServer(addr string) http.Server {\n          return http.Server{\n            Addr: addr,\n            Handler: StringServer(\"Hello world\"),\n          }\n        }\n\n        const addr = \"localhost:7070\"\n\n        func main() {\n          s := createServer(addr)\n          go s.ListenAndServe()\n\n          useRequest()\n          simplePost()\n\n        }\n\n        func simplePost() {\n          res, err := http.Post(\"http://localhost:7070\",\n                          \"application/x-www-form-urlencoded\",\n                          strings.NewReader(\"name=Radek&surname=Sohlich\"))\n          if err != nil {\n            panic(err)\n          }\n\n          data, err := ioutil.ReadAll(res.Body)\n          if err != nil {\n            panic(err)\n          }\n          res.Body.Close()\n          fmt.Println(\"Response from server:\" + string(data))\n        }\n\n        func useRequest() {\n\n          hc := http.Client{}\n          form := url.Values{}\n          form.Add(\"name\", \"Radek\")\n          form.Add(\"surname\", \"Sohlich\")\n\n          req, err := http.NewRequest(\"POST\",\n                        \"http://localhost:7070\",\n                        strings.NewReader(form.Encode()))\n                        req.Header.Add(\"Content-Type\",\n                        \"application/x-www-form-urlencoded\")\n\n          res, err := hc.Do(req)\n\n          if err != nil {\n            panic(err)\n          }\n\n          data, err := ioutil.ReadAll(res.Body)\n          if err != nil {\n            panic(err)\n          }\n          res.Body.Close()\n          fmt.Println(\"Response from server:\" + string(data))\n        }\n```", "```go\n        package main\n\n        import (\n          \"encoding/json\"\n          \"fmt\"\n          \"net/url\"\n        )\n\n        func main() {\n\n          u := &url.URL{}\n          u.Scheme = \"http\"\n          u.Host = \"localhost\"\n          u.Path = \"index.html\"\n          u.RawQuery = \"id=1&name=John\"\n          u.User = url.UserPassword(\"admin\", \"1234\")\n\n          fmt.Printf(\"Assembled URL:\\n%v\\n\\n\\n\", u)\n\n          parsedURL, err := url.Parse(u.String())\n          if err != nil {\n            panic(err)\n          }\n          jsonURL, err := json.Marshal(parsedURL)\n          if err != nil {\n            panic(err)\n          }\n          fmt.Println(\"Parsed URL:\")\n          fmt.Println(string(jsonURL))\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"io/ioutil\"\n          \"net/http\"\n          \"net/url\"\n          \"strings\"\n        )\n\n        type StringServer string\n\n        func (s StringServer) ServeHTTP(rw http.ResponseWriter,\n                                        req *http.Request) {\n          req.ParseForm()\n          fmt.Printf(\"Received form data: %v\\n\", req.Form)\n          fmt.Printf(\"Received header: %v\\n\", req.Header)\n          rw.Write([]byte(string(s)))\n        }\n\n        func createServer(addr string) http.Server {\n          return http.Server{\n            Addr: addr,\n            Handler: StringServer(\"Hello world\"),\n          }\n        } \n\n        const addr = \"localhost:7070\"\n\n        func main() {\n          s := createServer(addr)\n          go s.ListenAndServe()\n\n          form := url.Values{}\n          form.Set(\"id\", \"5\")\n          form.Set(\"name\", \"Wolfgang\")\n\n          req, err := http.NewRequest(http.MethodPost,\n                              \"http://localhost:7070\",\n                              strings.NewReader(form.Encode()))\n\n          if err != nil {\n            panic(err)\n          }\n          req.Header.Set(\"Content-Type\",\n                         \"application/x-www-form-urlencoded\")\n\n          res, err := http.DefaultClient.Do(req)\n          if err != nil {\n            panic(err)\n          }\n          data, err := ioutil.ReadAll(res.Body)\n          if err != nil {\n            panic(err)\n          }\n          res.Body.Close()\n          fmt.Println(\"Response from server:\" + string(data))\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"net/http\"\n        )\n\n        func main() {\n\n          header := http.Header{}\n\n          // Using the header as slice\n          header.Set(\"Auth-X\", \"abcdef1234\")\n          header.Add(\"Auth-X\", \"defghijkl\")\n          fmt.Println(header)\n\n          // retrieving slice of values in header\n          resSlice := header[\"Auth-X\"]\n          fmt.Println(resSlice)\n\n          // get the first value\n          resFirst := header.Get(\"Auth-X\")\n          fmt.Println(resFirst)\n\n          // replace all existing values with\n          // this one\n          header.Set(\"Auth-X\", \"newvalue\")\n          fmt.Println(header)\n\n          // Remove header\n          header.Del(\"Auth-X\")\n          fmt.Println(header)\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"net/http\"\n        )\n\n        const addr = \"localhost:7070\"\n\n        type RedirecServer struct {\n          redirectCount int\n        }\n\n        func (s *RedirecServer) ServeHTTP(rw http.ResponseWriter,\n                                          req *http.Request) {\n          s.redirectCount++\n          fmt.Println(\"Received header: \" + \n                      req.Header.Get(\"Known-redirects\"))\n          http.Redirect(rw, req, fmt.Sprintf(\"/redirect%d\",\n                        s.redirectCount), http.StatusTemporaryRedirect)\n        }\n\n        func main() {\n          s := http.Server{\n            Addr: addr,\n            Handler: &RedirecServer{0},\n          }\n          go s.ListenAndServe()\n\n          client := http.Client{}\n          redirectCount := 0\n\n          // If the count of redirects is reached\n          // than return error.\n          client.CheckRedirect = func(req *http.Request, \n                                 via []*http.Request) error {\n            fmt.Println(\"Redirected\")\n            if redirectCount > 2 {\n              return fmt.Errorf(\"Too many redirects\")\n            }\n            req.Header.Set(\"Known-redirects\", fmt.Sprintf(\"%d\",\n                           redirectCount))\n            redirectCount++\n            for _, prReq := range via {\n              fmt.Printf(\"Previous request: %v\\n\", prReq.URL)\n            }\n            return nil\n          }\n\n          _, err := client.Get(\"http://\" + addr)\n          if err != nil {\n            panic(err)\n          }\n        }\n```", "```go\n        package main\n\n        import (\n          \"encoding/json\"\n          \"fmt\"\n          \"io\"\n          \"io/ioutil\"\n          \"net/http\"\n          \"strconv\"\n          \"strings\"\n        )\n\n        const addr = \"localhost:7070\"\n\n        type City struct {\n          ID string\n          Name string `json:\"name\"`\n          Location string `json:\"location\"`\n        }\n\n        func (c City) toJson() string {\n          return fmt.Sprintf(`{\"name\":\"%s\",\"location\":\"%s\"}`,\n                             c.Name, c.Location)\n        }\n\n        func main() {\n          s := createServer(addr)\n          go s.ListenAndServe()\n\n          cities, err := getCities()\n          if err != nil {\n            panic(err)\n          }\n          fmt.Printf(\"Retrived cities: %v\\n\", cities)\n\n          city, err := saveCity(City{\"\", \"Paris\", \"France\"})\n          if err != nil {\n            panic(err)\n          }\n          fmt.Printf(\"Saved city: %v\\n\", city)\n\n        }\n\n        func saveCity(city City) (City, error) {\n          r, err := http.Post(\"http://\"+addr+\"/cities\",\n                              \"application/json\",\n                               strings.NewReader(city.toJson()))\n          if err != nil {\n            return City{}, err\n          }\n          defer r.Body.Close()\n          return decodeCity(r.Body)\n        }\n\n        func getCities() ([]City, error) {\n          r, err := http.Get(\"http://\" + addr + \"/cities\")\n          if err != nil {\n            return nil, err\n          }\n          defer r.Body.Close()\n          return decodeCities(r.Body)\n        }\n\n        func decodeCity(r io.Reader) (City, error) {\n          city := City{}\n          dec := json.NewDecoder(r)\n          err := dec.Decode(&city)\n          return city, err\n        }\n\n       func decodeCities(r io.Reader) ([]City, error) {\n         cities := []City{}\n         dec := json.NewDecoder(r)\n         err := dec.Decode(&cities)\n         return cities, err\n       }\n\n       func createServer(addr string) http.Server {\n         cities := []City{City{\"1\", \"Prague\", \"Czechia\"},\n                          City{\"2\", \"Bratislava\", \"Slovakia\"}}\n         mux := http.NewServeMux()\n         mux.HandleFunc(\"/cities\", func(w http.ResponseWriter,\n                                        r *http.Request) {\n           enc := json.NewEncoder(w)\n           if r.Method == http.MethodGet {\n             enc.Encode(cities)\n           } else if r.Method == http.MethodPost {\n             data, err := ioutil.ReadAll(r.Body)\n             if err != nil {\n               http.Error(w, err.Error(), 500)\n             }\n             r.Body.Close()\n             city := City{}\n             json.Unmarshal(data, &city)\n             city.ID = strconv.Itoa(len(cities) + 1)\n             cities = append(cities, city)\n             enc.Encode(city)\n           }\n\n         })\n         return http.Server{\n           Addr: addr,\n           Handler: mux,\n         }\n       }\n```", "```go\n        package main\n\n        import (\n          \"crypto/tls\"\n          \"fmt\"\n          \"net/smtp\"\n        )\n\n        func main() {\n\n          var email string\n          fmt.Println(\"Enter username for smtp: \")\n          fmt.Scanln(&email)\n\n          var pass string\n          fmt.Println(\"Enter password for smtp: \")\n          fmt.Scanln(&pass)\n\n          auth := smtp.PlainAuth(\"\", email, pass, \"smtp.gmail.com\")\n\n          c, err := smtp.Dial(\"smtp.gmail.com:587\")\n          if err != nil {\n            panic(err)\n          }\n          defer c.Close()\n          config := &tls.Config{ServerName: \"smtp.gmail.com\"}\n\n          if err = c.StartTLS(config); err != nil {\n            panic(err)\n          }\n\n          if err = c.Auth(auth); err != nil {\n            panic(err)\n          }\n\n          if err = c.Mail(email); err != nil {\n            panic(err)\n          }\n          if err = c.Rcpt(email); err != nil {\n            panic(err)\n          }\n\n          w, err := c.Data()\n          if err != nil {\n            panic(err)\n          }\n\n          msg := []byte(\"Hello this is content\")\n          if _, err := w.Write(msg); err != nil {\n            panic(err)\n          }\n\n          err = w.Close()\n          if err != nil {\n            panic(err)\n          }\n          err = c.Quit()\n\n          if err != nil {\n            panic(err)\n          }\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"log\"\n          \"net\"\n          \"net/rpc\"\n          \"net/rpc/jsonrpc\"\n        )\n\n        type Args struct {\n          A, B int\n        }\n\n        type Result int\n\n        type RpcServer struct{}\n\n        func (t RpcServer) Add(args *Args, result *Result) error {\n          log.Printf(\"Adding %d to %d\\n\", args.A, args.B)\n          *result = Result(args.A + args.B)\n          return nil\n        } \n\n        const addr = \":7070\"\n\n        func main() {\n          go createServer(addr)\n          client, err := jsonrpc.Dial(\"tcp\", addr)\n          if err != nil {\n            panic(err)\n          }\n          defer client.Close()\n          args := &Args{\n            A: 2,\n            B: 3,\n          }\n          var result Result\n          err = client.Call(\"RpcServer.Add\", args, &result)\n          if err != nil {\n            log.Fatalf(\"error in RpcServer\", err)\n          }\n          log.Printf(\"%d+%d=%d\\n\", args.A, args.B, result)\n        }\n\n        func createServer(addr string) {\n          server := rpc.NewServer()\n          err := server.Register(RpcServer{})\n          if err != nil {\n            panic(err)\n          }\n          l, e := net.Listen(\"tcp\", addr)\n          if e != nil {\n            log.Fatalf(\"Couldn't start listening on %s errors: %s\",\n                       addr, e)\n          }\n          for {\n            conn, err := l.Accept()\n            if err != nil {\n              log.Fatal(err)\n            }\n            go server.ServeCodec(jsonrpc.NewServerCodec(conn))\n          }\n        }\n```"]