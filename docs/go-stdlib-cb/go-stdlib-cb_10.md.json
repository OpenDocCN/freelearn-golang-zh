["```go\n        package main\n\n        import (\n          \"fmt\"\n          \"sync\"\n        )\n\n        var names = []string{\"Alan\", \"Joe\", \"Jack\", \"Ben\",\n                             \"Ellen\", \"Lisa\", \"Carl\", \"Steve\",\n                             \"Anton\", \"Yo\"}\n\n        type SyncList struct {\n          m sync.Mutex\n          slice []interface{}\n        }\n\n        func NewSyncList(cap int) *SyncList {\n          return &SyncList{\n            sync.Mutex{},\n            make([]interface{}, cap),\n          }\n        }\n\n        func (l *SyncList) Load(i int) interface{} {\n          l.m.Lock()\n          defer l.m.Unlock()\n          return l.slice[i]\n        }\n\n        func (l *SyncList) Append(val interface{}) {\n          l.m.Lock()\n          defer l.m.Unlock()\n          l.slice = append(l.slice, val)\n        }\n\n        func (l *SyncList) Store(i int, val interface{}) {\n          l.m.Lock()\n          defer l.m.Unlock()\n          l.slice[i] = val\n        }\n\n        func main() {\n\n          l := NewSyncList(0)\n          wg := &sync.WaitGroup{}\n          wg.Add(10)\n          for i := 0; i < 10; i++ {\n            go func(idx int) {\n              l.Append(names[idx])\n              wg.Done()\n            }(i)\n          }\n          wg.Wait()\n\n          for i := 0; i < 10; i++ {\n            fmt.Printf(\"Val: %v stored at idx: %d\\n\", l.Load(i), i)\n          }\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"sync\"\n        )\n\n        var names = []string{\"Alan\", \"Joe\", \"Jack\", \"Ben\",\n                             \"Ellen\", \"Lisa\", \"Carl\", \"Steve\",\n                             \"Anton\", \"Yo\"}\n\n        func main() {\n\n          m := sync.Map{}\n          wg := &sync.WaitGroup{}\n          wg.Add(10)\n          for i := 0; i < 10; i++ {\n            go func(idx int) {\n              m.Store(fmt.Sprintf(\"%d\", idx), names[idx])\n              wg.Done()\n            }(i)\n          }\n          wg.Wait()\n\n          v, ok := m.Load(\"1\")\n          if ok {\n            fmt.Printf(\"For Load key: 1 got %v\\n\", v)\n          }\n\n          v, ok = m.LoadOrStore(\"11\", \"Tim\")\n          if !ok {\n            fmt.Printf(\"Key 11 missing stored val: %v\\n\", v)\n          }\n\n          m.Range(func(k, v interface{}) bool {\n            key, _ := k.(string)\n            t, _ := v.(string)\n            fmt.Printf(\"For index %v got %v\\n\", key, t)\n            return true\n          })\n\n        }\n```", "```go\n        package main\n\n        import (\n          \"fmt\"\n          \"sync\"\n        )\n\n        var names = []interface{}{\"Alan\", \"Joe\", \"Jack\", \"Ben\",\n                                  \"Ellen\", \"Lisa\", \"Carl\", \"Steve\",\n                                  \"Anton\", \"Yo\"}\n\n        type Source struct {\n          m *sync.Mutex\n          o *sync.Once\n          data []interface{}\n        }\n\n        func (s *Source) Pop() (interface{}, error) {\n          s.m.Lock()\n          defer s.m.Unlock()\n          s.o.Do(func() {\n            s.data = names\n            fmt.Println(\"Data has been loaded.\")\n          })\n          if len(s.data) > 0 {\n            res := s.data[0]\n            s.data = s.data[1:]\n            return res, nil\n          }\n          return nil, fmt.Errorf(\"No data available\")\n        }\n\n        func main() {\n\n          s := &Source{&sync.Mutex{}, &sync.Once{}, nil}\n          wg := &sync.WaitGroup{}\n          wg.Add(10)\n          for i := 0; i < 10; i++ {\n            go func(idx int) {\n              // This code block is done only once\n              if val, err := s.Pop(); err == nil {\n                fmt.Printf(\"Pop %d returned: %s\\n\", idx, val)\n              }\n              wg.Done()\n            }(i)\n          }\n          wg.Wait()\n        }\n```", "```go\n        package main\n\n        import \"sync\"\n        import \"fmt\"\n        import \"time\"\n\n        type Worker struct {\n          id string\n        }\n\n        func (w *Worker) String() string {\n          return w.id\n        }\n\n        var globalCounter = 0\n\n        var pool = sync.Pool{\n          New: func() interface{} {\n            res := &Worker{fmt.Sprintf(\"%d\", globalCounter)}\n            globalCounter++\n            return res\n          },\n        }\n\n        func main() {\n          wg := &sync.WaitGroup{}\n          wg.Add(10)\n          for i := 0; i < 10; i++ {\n            go func(idx int) {\n              // This code block is done only once\n              w := pool.Get().(*Worker)\n              fmt.Println(\"Got worker ID: \" + w.String())\n              time.Sleep(time.Second)\n              pool.Put(w)\n              wg.Done()\n            }(i)\n          }\n          wg.Wait()\n        }\n```", "```go\n        package main\n\n        import \"sync\"\n        import \"fmt\"\n\n        func main() {\n          wg := &sync.WaitGroup{}\n          for i := 0; i < 10; i++ {\n            wg.Add(1)\n            go func(idx int) {\n              // Do some work\n              defer wg.Done()\n              fmt.Printf(\"Exiting %d\\n\", idx)\n            }(i)\n          }\n          wg.Wait()\n          fmt.Println(\"All done.\")\n        }\n```", "```go\n        package main\n\n        import (\n          \"context\"\n          \"fmt\"\n          \"sync\"\n          \"time\"\n        )\n\n        type SearchSrc struct {\n          ID string\n          Delay int\n        }\n\n        func (s *SearchSrc) Search(ctx context.Context) <-chan string {\n          out := make(chan string)\n          go func() {\n            time.Sleep(time.Duration(s.Delay) * time.Second)\n            select {\n              case out <- \"Result \" + s.ID:\n              case <-ctx.Done():\n              fmt.Println(\"Search received Done()\")\n            }\n            close(out)\n            fmt.Println(\"Search finished for ID: \" + s.ID)\n          }()\n          return out\n        }\n\n        func main() {\n\n          ctx, cancel := context.WithCancel(context.Background())\n\n          src1 := &SearchSrc{\"1\", 2}\n          src2 := &SearchSrc{\"2\", 6}\n\n          r1 := src1.Search(ctx)\n          r2 := src2.Search(ctx)\n\n          out := merge(ctx, r1, r2)\n\n          for firstResult := range out {\n            cancel()\n            fmt.Println(\"First result is: \" + firstResult)\n          }\n        }\n\n        func merge(ctx context.Context, results ...<-chan string)\n                   <-chan string {\n          wg := sync.WaitGroup{}\n          out := make(chan string)\n\n          output := func(c <-chan string) {\n            defer wg.Done()\n            select {\n              case <-ctx.Done():\n                fmt.Println(\"Received ctx.Done()\")\n              case res := <-c:\n              out <- res\n            }\n          }\n\n          wg.Add(len(results))\n          for _, c := range results {\n            go output(c)\n          }\n\n          go func() {\n            wg.Wait()\n            close(out)\n          }()\n          return out\n        }\n```", "```go\n        package main\n\n        import (\n          \"bufio\"\n          \"context\"\n          \"fmt\"\n          \"log\"\n          \"strings\"\n\n          \"golang.org/x/sync/errgroup\"\n        )\n\n        const data = `line one\n        line two with more words\n        error: This is erroneous line`\n\n        func main() {\n          log.Printf(\"Application %s starting.\", \"Error Detection\")\n          scanner := bufio.NewScanner(strings.NewReader(data))\n          scanner.Split(bufio.ScanLines)\n\n          // For each line fire a goroutine\n          g, _ := errgroup.WithContext(context.Background())\n          for scanner.Scan() {\n            row := scanner.Text()\n            g.Go(func() error {\n              return func(s string) error {\n                if strings.Contains(s, \"error:\") {\n                  return fmt.Errorf(s)\n                }\n                return nil\n              }(row)\n            })\n          }\n\n          // Wait until the goroutines finish\n          if err := g.Wait(); err != nil {\n            fmt.Println(\"Error while waiting: \" + err.Error())\n          }\n\n        }\n```"]