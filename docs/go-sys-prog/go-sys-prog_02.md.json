["```go\n$ go run hw.go\nHello World!  \n```", "```go\n$ go build hw.go\n$ file hw\nhw: Mach-O 64-bit executable x86_64\n```", "```go\n$ go run hw.go\n# command-line-arguments\n./hw.go:3: imported and not used: \"fmt\"\n./hw.go:7: undefined: mt in mt.Println\n```", "```go\n$ go run hw.go\n# command-line-arguments\nruntime.main_main f: relocation target main.main not defined\nruntime.main_main f: undefined: \"main.main\"\n```", "```go\n$ cat hw.gocat \npackage main\n\nimport \"fmt\"\n\nfunc main()\n{\n      fmt.Println(\"Hello World!\")\n}\n$ go run hw.go\n# command-line-arguments\n./hw.go:6: syntax error: unexpected semicolon or newline before {\n\n```", "```go\n$ gofmt hw.go\nhw.go:6:1: expected declaration, found '{'\n\n```", "```go\n$ go run afile.go\n# command-line-arguments\n./afile.go:4: imported and not used: \"net\"\n```", "```go\n$ ls -l hw\n-rwxr-xr-x  1 mtsouk  staff  1628192 Feb  9 22:29 hw\n$ file hw\nhw: Mach-O 64-bit executable x86_64  \n```", "```go\n$ go versiongo \ngo version go1.3.3 linux/amd64\n$ go build hw.go\n$ ls -l hw\n-rwxr-xr-x 1 mtsouk mtsouk 1823712 Feb 18 17:35 hw\n$ file hw\nhw: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped\n\n```", "```go\n$ strip hw\n$ ls -l hw\n-rwxr-xr-x  1 mtsouk  staff  1540096 Feb 18 17:41 hw\n```", "```go\n$ ls -l hw\n-rwxr-xr-x 1 mtsouk mtsouk 1823712 Feb 18 17:35 hw\n$ CGO_ENABLED=0 go build -ldflags \"-s\" -a hw.go\n$ ls -l hw\n-rwxr-xr-x 1 mtsouk mtsouk 1328032 Feb 18 17:44 hw\n$ file hw\nhw: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped\n```", "```go\n$ go help environment\n```", "```go\n$ go env NAME  \n```", "```go\npackage main \n\nimport \"fmt\" \nimport \"os\" \n\nfunc main() { \n   arguments := os.Args \n   for i := 0; i < len(arguments); i++ { \n         fmt.Println(arguments[i]) \n   } \n} \n```", "```go\nimport ( \n   \"fmt\" \n   \"os\" \n)\n```", "```go\n$ ./cla 1 2 three\n./cla\n1\n2\nthree\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"strconv\" \n) \n```", "```go\nfunc main() { \n   arguments := os.Args \n   sum := 0 \n   for i := 1; i < len(arguments); i++ { \n         temp, _ := strconv.Atoi(arguments[i]) \n         sum = sum + temp \n   } \n   fmt.Println(\"Sum:\", sum) \n} \n```", "```go\n$ go run addCLA.go 1 2 -1 -3\nSum: -1\n$ go run addCLA.go\nSum: 0\n```", "```go\n$ go run addCLA.go !\nSum: 0\n$ go run addCLA.go ! -@\nSum: 0\n$ go run addCLA.go ! -@ 1 2\nSum: 3\n```", "```go\n$ touch aFile\n$ rm -i aFile\nremove aFile? y\n$ touch aFile\n$ touch ../aFile\n$ mv -i ../aFile .\noverwrite ./aFile? (y/n [n]) y\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"strings\" \n) \n\nfunc main() { \n   arguments := os.Args \n   minusI := false \n   for i := 0; i < len(arguments); i++ { \n         if strings.Compare(arguments[i], \"-i\") == 0 { \n               minusI = true \n               break \n         } \n   } \n\n   if minusI { \n         fmt.Println(\"Got the -i parameter!\") \n         fmt.Print(\"y/n: \") \n         var answer string \n         fmt.Scanln(&answer) \n         fmt.Println(\"You entered:\", answer) \n   } else { \n         fmt.Println(\"The -i parameter is not set\") \n   } \n} \n```", "```go\n$ go run parameter.go\nThe -i parameter is not set\n$ go run parameter.go -i\nGot the -i parameter!\ny/n: y\nYou entered: y\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n) \n\nfunc unnamedMinMax(x, y int) (int, int) { \n   if x > y { \n         min := y \n         max := x \n         return min, max \n   } else { \n         min := x \n         max := y \n         return min, max \n   } \n} \n```", "```go\nfunc minMax(x, y int) (min, max int) { \n   if x > y { \n         min = y \n         max = x \n   } else { \n         min = x \n         max = y \n   } \n   return min, max \n} \n```", "```go\nfunc namedMinMax(x, y int) (min, max int) { \n   if x > y { \n         min = y \n         max = x \n   } else { \n         min = x \n         max = y \n   } \n   return \n} \n```", "```go\nfunc sort(x, y int) (int, int) { \n   if x > y { \n         return x, y \n   } else { \n         return y, x \n   } \n} \n```", "```go\n func main() {\n   y := 4 \n   square := func(s int) int { \n         return s * s \n   } \n   fmt.Println(\"The square of\", y, \"is\", square(y)) \n\n   square = func(s int) int { \n         return s + s \n   } \n   fmt.Println(\"The square of\", y, \"is\", square(y)) \n```", "```go\n   fmt.Println(minMax(15, 6)) \n   fmt.Println(namedMinMax(15, 6)) \n   min, max := namedMinMax(12, -1) \n   fmt.Println(min, max) \n} \n```", "```go\n$ go run functions.go\nThe square of 4 is 16\nThe square of 4 is 8\n6 15\n6 15\n-1 12\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n) \n\nfunc a1() { \n   for i := 0; i < 3; i++ { \n         defer fmt.Print(i, \" \") \n   } \n} \n```", "```go\nfunc a2() { \n   for i := 0; i < 3; i++ { \n         defer func() { fmt.Print(i, \" \") }() \n   } \n} \n```", "```go\nfunc a3() { \n   for i := 0; i < 3; i++ { \n         defer func(n int) { fmt.Print(n, \" \") }(i) \n   } \n} \n```", "```go\nfunc main() { \n   a1() \n   fmt.Println() \n   a2() \n   fmt.Println() \n   a3() \n   fmt.Println() \n} \n```", "```go\n$ go run defer.go\n2 1 0\n3 3 3\n2 1 0\n```", "```go\nfunc withPointer(x *int) { \n   *x = *x * *x \n} \n\ntype complex struct { \n   x, y int \n} \n\nfunc newComplex(x, y int) *complex { \n   return &complex{x, y} \n} \n```", "```go\nfunc main() { \n   x := -2 \n   withPointer(&x) \n   fmt.Println(x) \n\n   w := newComplex(4, -5) \n   fmt.Println(*w) \n   fmt.Println(w) \n} \n```", "```go\n$ go run pointers.go\n4\n{4 -5}\n&{4 -5} \n```", "```go\nmyArray := [4]int{1, 2, 4, -4} \n```", "```go\ntwoD := [3][3]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}} \nthreeD := [2][2][2]int{{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}} \n```", "```go\nmyArray[0] \ntwoD[1][2] = 15 \nthreeD[0][1][1] = -1\n\n```", "```go\n$ go run arrays.go\n1 2 4 -4\n0 2 -2 6 7 8\n1 2 3 4 5 15 7 8 9\n[[1 2] [3 -1]] [[5 6] [7 8]]\n```", "```go\npackage main \n\nimport \"fmt\" \n\nfunc main() { \n   myArray := [4]int{1, 2, 4, -4} \n   threeD := [2][2][2]int{{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}} \n   fmt.Println(\"myArray[-1]:\", myArray[-1])\n   fmt.Println(\"myArray[10]:\", myArray[10]) \n   fmt.Println(\"threeD[-1][20][0]:\", threeD[-1][20][0]) \n} \n```", "```go\n$ go run breakMe.go\n# command-line-arguments\n./breakMe.go:8: invalid array index -1 (index must be non-negative)\n./breakMe.go:9: invalid array index 10 (out of bounds for 4-element array)\n./breakMe.go:10: invalid array index -1 (index must be non-negative)\n./breakMe.go:10: invalid array index 20 (out of bounds for 2-element array)\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n) \n\nfunc change(x []int) { \n   x[3] = -2 \n} \n\nfunc printSlice(x []int) { \n   for _, number := range x {\n\n         fmt.Printf(\"%d \", number) \n   } \n   fmt.Println() \n} \n```", "```go\nfunc main() { \n   aSlice := []int{-1, 4, 5, 0, 7, 9} \n   fmt.Printf(\"Before change: \") \n   printSlice(aSlice) \n   change(aSlice) \n   fmt.Printf(\"After change: \") \n   printSlice(aSlice) \n```", "```go\n   fmt.Printf(\"Before. Cap: %d, length: %d\\n\", cap(aSlice), len(aSlice)) \n   aSlice = append(aSlice, -100) \n   fmt.Printf(\"After. Cap: %d, length: %d\\n\", cap(aSlice), len(aSlice)) \n   printSlice(aSlice) \n   anotherSlice := make([]int, 4) \n   fmt.Printf(\"A new slice with 4 elements: \") \n   printSlice(anotherSlice) \n} \n```", "```go\n$ go run slices.go \nBefore change: -1 4 5 0 7 9 \nAfter change: -1 4 5 -2 7 9 \nBefore. Cap: 6, length: 6 \nAfter. Cap: 12, length: 7 \n-1 4 5 -2 7 9 -100 \nA new slice with 4 elements: 0 0 0 0 \n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n) \n\nfunc main() { \n\n```", "```go\n   aMap := make(map[string]int) \n```", "```go\n   aMap[\"Mon\"] = 0 \n   aMap[\"Tue\"] = 1 \n   aMap[\"Wed\"] = 2 \n   aMap[\"Thu\"] = 3 \n   aMap[\"Fri\"] = 4 \n   aMap[\"Sat\"] = 5 \n   aMap[\"Sun\"] = 6 \n```", "```go\n   fmt.Printf(\"Sunday is the %dth day of the week.\\n\", aMap[\"Sun\"]) \n\n```", "```go\n   _, ok := aMap[\"Tuesday\"] \n   if ok { \n         fmt.Printf(\"The Tuesday key exists!\\n\") \n   } else { \n         fmt.Printf(\"The Tuesday key does not exist!\\n\") \n   } \n```", "```go\n   count := 0 \n   for key, _ := range aMap { \n         count++ \n         fmt.Printf(\"%s \", key) \n   } \n   fmt.Printf(\"\\n\") \n   fmt.Printf(\"The aMap has %d elements\\n\", count) \n```", "```go\n   count = 0 \n   delete(aMap, \"Fri\") \n   for _, _ = range aMap { \n         count++ \n   } \n   fmt.Printf(\"The aMap has now %d elements\\n\", count) \n```", "```go\n   anotherMap := map[string]int{ \n         \"One\":   1, \n         \"Two\":   2, \n         \"Three\": 3, \n         \"Four\":  4, \n   } \n   anotherMap[\"Five\"] = 5 \n   count = 0 \n   for _, _ = range anotherMap { \n         count++ \n   } \n   fmt.Printf(\"anotherMap has %d elements\\n\", count) \n} \n```", "```go\n$ go run maps.go\nSunday is the 6th day of the week.\nThe Tuesday key does not exist!\nWed Thu Fri Sat Sun Mon Tue\nThe aMap has 7 elements\nThe aMap has now 6 elements\nanotherMap has 5 elements\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"strconv\" \n) \n\nfunc main() { \n```", "```go\nanArray := [4]int{1, -2, 14, 0} \naMap := make(map[string]int) \n\nlength := len(anArray) \nfor i := 0; i < length; i++ { \n   fmt.Printf(\"%s \", strconv.Itoa(i)) \n   aMap[strconv.Itoa(i)] = anArray[i] \n} \n```", "```go\nfor key, value := range aMap {\n    fmt.Printf(\"%s: %d\\n\", key, value) \n   } \n} \n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"reflect\" \n) \n\nfunc main() { \n\n   type message struct {\n         X     int \n         Y     int \n         Label string \n   } \n```", "```go\n   p1 := message{23, 12, \"A Message\"} \n   p2 := message{} \n   p2.Label = \"Message 2\" \n\n   s1 := reflect.ValueOf(&p1).Elem() \n   s2 := reflect.ValueOf(&p2).Elem() \n   fmt.Println(\"S2= \", s2) \n```", "```go\n   typeOfT := s1.Type() \n   fmt.Println(\"P1=\", p1) \n   fmt.Println(\"P2=\", p2) \n\n   for i := 0; i < s1.NumField(); i++ {\n         f := s1.Field(i)\n\n         fmt.Printf(\"%d: %s \", i, typeOfT.Field(i).Name) \n         fmt.Printf(\"%s = %v\\n\", f.Type(), f.Interface()) \n   } \n\n} \n```", "```go\n$ go run dataStructures.go\nS2=  {0 0 Message 2}\nP1= {23 12 A Message}\nP2= {0 0 Message 2}\n0: X int = 23\n1: Y int = 12\n2: Label string = A Message\n```", "```go\npanic: reflect.Value.Interface: cannot return value obtained from unexported field or method\n\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n) \n\ntype coordinates interface { \n   xaxis() int \n   yaxis() int \n} \n\ntype point2D struct { \n   X int \n   Y int \n} \n```", "```go\nfunc (s point2D) xaxis() int { \n   return s.X \n} \n\nfunc (s point2D) yaxis() int { \n   return s.Y \n} \n\nfunc findCoordinates(a coordinates) { \n   fmt.Println(\"X:\", a.xaxis(), \"Y:\", a.yaxis()) \n} \n\ntype coordinate int \n\nfunc (s coordinate) xaxis() int { \n   return int(s) \n} \n\nfunc (s coordinate) yaxis() int { \n   return 0 \n} \n```", "```go\nfunc main() { \n\n   x := point2D{X: -1, Y: 12}\n   fmt.Println(x) \n   findCoordinates(x) \n\n   y := coordinate(10) \n   findCoordinates(y) \n} \n```", "```go\n$ go run interfaces.go\n{-1 12}\nX: -1 Y: 12\nX: 10 Y: 0\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"math/rand\" \n   \"os\" \n   \"strconv\" \n   \"time\" \n) \n```", "```go\nfunc random(min, max int) int { \n   return rand.Intn(max-min) + min \n} \n```", "```go\nfunc main() { \n   MIN := 0 \n   MAX := 0 \n   TOTAL := 0 \n   if len(os.Args) > 3 { \n         MIN, _ = strconv.Atoi(os.Args[1]) \n         MAX, _ = strconv.Atoi(os.Args[2]) \n         TOTAL, _ = strconv.Atoi(os.Args[3]) \n   } else { \n         fmt.Println(\"Usage:\", os.Args[0], \"MIX MAX TOTAL\") \n         os.Exit(-1) \n   } \n\n   rand.Seed(time.Now().Unix()) \n   for i := 0; i < TOTAL; i++ { \n         myrand := random(MIN, MAX) \n         fmt.Print(myrand) \n         fmt.Print(\" \") \n   } \n   fmt.Println() \n} \n```", "```go\n$ go run random.go 12 32 20\n29 27 20 23 22 28 13 16 22 26 12 29 22 30 15 19 26 24 20 29\n\n```"]