["```go\ntemp, _ := strconv.Atoi(arguments[i]) \n```", "```go\nif err == io.EOF {\n\n    // Do something \n} \n```", "```go\npackage main \n\nimport ( \n   \"errors\" \n   \"fmt\" \n   \"log\" \n) \n\nfunc division(x, y int) (int, error, error) { \n   if y == 0 { \n         return 0, nil, errors.New(\"Cannot divide by zero!\") \n   } \n   if x%y != 0 { \n         remainder := errors.New(\"There is a remainder!\") \n         return x / y, remainder, nil \n   } else { \n         return x / y, nil, nil \n   } \n\n} \n```", "```go\nfunc main() { \n   result, rem, err := division(2, 2) \n   if err != nil { \n         log.Fatal(err) \n   } else { \n         fmt.Println(\"The result is\", result) \n   } \n\n   if rem != nil { \n         fmt.Println(rem) \n   } \n```", "```go\n   result, rem, err = division(12, 5) \n   if err != nil { \n         log.Fatal(err) \n   } else { \n         fmt.Println(\"The result is\", result) \n   } \n\n   if rem != nil { \n         fmt.Println(rem) \n   } \n\n   result, rem, err = division(2, 0) \n   if err != nil { \n         log.Fatal(err) \n   } else { \n         fmt.Println(\"The result is\", result) \n   } \n\n   if rem != nil { \n         fmt.Println(rem) \n   } \n} \n```", "```go\n$ go run funErr.go\nThe result is 1\nThe result is 2\nThere is a remainder!\n2017/03/07 07:39:19 Cannot divide by zero!\nexit status 1\n```", "```go\npackage main \n\nimport ( \n   \"log\" \n) \n\nfunc main() { \n   x := 1 \n   log.Printf(\"log.Print() function: %d\", x) \n   x = x + 1 \n   log.Printf(\"log.Print() function: %d\", x) \n   x = x + 1 \n   log.Panicf(\"log.Panicf() function: %d\", x) \n   x = x + 1 \n   log.Printf(\"log.Print() function: %d\", x) \n} \n```", "```go\n$ go run logging.go\n2017/03/10 16:51:56 log.Print() function: 1\n2017/03/10 16:51:56 log.Print() function: 2\n2017/03/10 16:51:56 log.Panicf() function: 3\npanic: log.Panicf() function: 3\n\ngoroutine 1 [running]:\nlog.Panicf(0x10b78d0, 0x19, 0xc42003df48, 0x1, 0x1)\n      /usr/local/Cellar/go/1.8/libexec/src/log/log.go:329 +0xda\nmain.main()\n      /Users/mtsouk/ch3/code/logging.go:14 +0x1af\nexit status 2\n```", "```go\n$ diff addCLAImproved.go addCLA.go\n13,18c13,14\n<           temp, err := strconv.Atoi(arguments[i])\n<           if err == nil {\n<                 sum = sum + temp\n<           } else {\n<                 fmt.Println(\"Ignoring\", arguments[i])\n<           }\n---\n>           temp, _ := strconv.Atoi(arguments[i])\n>           sum = sum + temp\n```", "```go\n$ go run addCLAImproved.go\nSum: 0\n$ go run addCLAImproved.go 1 2 -3\nSum: 0\n$ go run addCLAImproved.go 1 a 2 b 3.2 @\nIgnoring a\nIgnoring b\nIgnoring 3.2\nIgnoring @\nSum: 3\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"regexp\" \n) \n```", "```go\nfunc main() { \nmatch, _ := regexp.MatchString(\"Mihalis\", \"Mihalis Tsoukalos\") \n   fmt.Println(match) \n   match, _ = regexp.MatchString(\"Tsoukalos\", \"Mihalis tsoukalos\") \n   fmt.Println(match) \n```", "```go\n   parse, err := regexp.Compile(\"[Mm]ihalis\") \n```", "```go\n   if err != nil { \n         fmt.Printf(\"Error compiling RE: %s\\n\", err) \n   } else { \n         fmt.Println(parse.MatchString(\"Mihalis Tsoukalos\")) \n         fmt.Println(parse.MatchString(\"mihalis Tsoukalos\")) \n         fmt.Println(parse.MatchString(\"M ihalis Tsoukalos\")) \n         fmt.Println(parse.ReplaceAllString(\"mihalis Mihalis\", \"MIHALIS\")) \n   } \n} \n```", "```go\n$ go run regExp.go\ntrue\nfalse\ntrue\ntrue\nfalse\nMIHALIS MIHALIS\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"strings\" \n) \n\nfunc main() { \n   var s [3]string \n   s[0] = \"1 2 3\" \n   s[1] = \"11 12 13 14 15 16\" \n   s[2] = \"-1 2 -3 -4 -5 6\" \n```", "```go\n   column := 2 \n\n   for i := 0; i < len(s); i++ { \n         data := strings.Fields(s[i]) \n         if len(data) >= column { \n               fmt.Println((data[column-1])) \n         } \n   } \n} \n```", "```go\n$ go run readColumn.go\n2\n12\n2\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"strconv\" \n   \"strings\" \n) \n\nfunc main() { \n   var s [3]string \n   s[0] = \"1 b 3\" \n   s[1] = \"11 a 1 14 1 1\" \n   s[2] = \"-1 2 -3 -4 -5\" \n```", "```go\n   arguments := os.Args \n   column, err := strconv.Atoi(arguments[1]) \n   if err != nil { \n         fmt.Println(\"Error reading argument\") \n         os.Exit(-1) \n   } \n   if column == 0 { \n         fmt.Println(\"Invalid column\") \n         os.Exit(1) \n   } \n```", "```go\n   sum := 0 \n   for i := 0; i < len(s); i++ { \n         data := strings.Fields(s[i]) \n         if len(data) >= column { \n               temp, err := strconv.Atoi(data[column-1]) \n               if err == nil { \n                     sum = sum + temp \n               } else { \n                     fmt.Printf(\"Invalid argument: %s\\n\", data[column-1]) \n               } \n         } else { \n               fmt.Println(\"Invalid column!\") \n         } \n   } \n   fmt.Printf(\"Sum: %d\\n\", sum) \n} \n```", "```go\n$ go run summary.go 0\nInvalid column\nexit status 1\n$ go run summary.go 2\nInvalid argument: b\nInvalid argument: a\nSum: 2\n$ go run summary.go 1\nSum: 11\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"strings\" \n) \n\nfunc main() { \n\n   var s [3]string \n   s[0] = \"1 b 3 1 a a b\" \n   s[1] = \"11 a 1 1 1 1 a a\" \n   s[2] = \"-1 b 1 -4 a 1\" \n```", "```go\n   counts := make(map[string]int) \n\n   for i := 0; i < len(s); i++ { \n         data := strings.Fields(s[i]) \n         for _, word := range data { \n               _, ok := counts[word] \n               if ok { \n                     counts[word] = counts[word] + 1 \n               } else { \n                     counts[word] = 1 \n               } \n         } \n   } \n```", "```go\n   for key, _ := range counts {\n\n         fmt.Printf(\"%s -> %d \\n\", key, counts[key]) \n   } \n} \n```", "```go\n$ go run occurrences.go | sort -n -r -t\\  -k3,3\n1 -> 8\na -> 6\nb -> 3\n3 -> 1\n11 -> 1\n-4 -> 1\n-1 -> 1\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"regexp\" \n) \n```", "```go\nfunc main() { \n\n   var s [3]string \n   s[0] = \"1 b 3\" \n   s[1] = \"11 a B 14 1 1\" \n   s[2] = \"b 2 -3 B -5\" \n\n   parse, err := regexp.Compile(\"[bB]\")\n\n   if err != nil { \n         fmt.Printf(\"Error compiling RE: %s\\n\", err) \n         os.Exit(-1) \n   } \n```", "```go\n   for i := 0; i < len(s); i++ { \n         temp := parse.ReplaceAllString(s[i], \"C\") \n         fmt.Println(temp) \n   } \n} \n```", "```go\n$ go run findReplace.go\n1 C 3\n11 a C 14 1 1\nC 2 -3 C -5\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"reflect\" \n) \n```", "```go\nfunc main() { \n\n   type t1 int \n   type t2 int \n\n   x1 := t1(1) \n   x2 := t2(1) \n   x3 := 1 \n```", "```go\n   st1 := reflect.ValueOf(&x1).Elem() \n   st2 := reflect.ValueOf(&x2).Elem() \n   st3 := reflect.ValueOf(&x3).Elem() \n\n   typeOfX1 := st1.Type() \n   typeOfX2 := st2.Type() \n   typeOfX3 := st3.Type() \n\n   fmt.Printf(\"X1 Type: %s\\n\", typeOfX1) \n   fmt.Printf(\"X2 Type: %s\\n\", typeOfX2) \n   fmt.Printf(\"X3 Type: %s\\n\", typeOfX3) \n```", "```go\n   type aStructure struct { \n         X    uint \n         Y    float64 \n         Text string \n   } \n\n   x4 := aStructure{123, 3.14, \"A Structure\"} \n   st4 := reflect.ValueOf(&x4).Elem() \n   typeOfX4 := st4.Type() \n\n   fmt.Printf(\"X4 Type: %s\\n\", typeOfX4) \n   fmt.Printf(\"The fields of %s are:\\n\", typeOfX4) \n\n   for i := 0; i < st4.NumField(); i++ { \n         fmt.Printf(\"%d: Field name: %s \", i, typeOfX4.Field(i).Name) \n         fmt.Printf(\"Type: %s \", st4.Field(i).Type()) \n         fmt.Printf(\"and Value: %v\\n\", st4.Field(i).Interface()) \n   } \n} \n```", "```go\n$ go run reflection.go\nX1 Type: main.t1\nX2 Type: main.t2\nX3 Type: int\nX4 Type: main.aStructure\nThe fields of main.aStructure are:\n0: Field name: X Type: uint and Value: 123\n1: Field name: Y Type: float64 and Value: 3.14\n2: Field name: Text Type: string and Value: A Structure\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"unsafe\" \n) \n\nfunc main() { \n   var value int64 = 5\n\n   var p1 = &value \n   var p2 = (*int32)(unsafe.Pointer(p1)) \n```", "```go\n   fmt.Println(\"*p1: \", *p1) \n   fmt.Println(\"*p2: \", *p2) \n   *p1 = 312121321321213212 \n   fmt.Println(value) \n   fmt.Println(\"*p2: \", *p2) \n   *p1 = 31212132 \n   fmt.Println(value) \n   fmt.Println(\"*p2: \", *p2) \n} \n```", "```go\n$ go run unsafe.go\n*p1:  5\n*p2:  5\n312121321321213212\n*p2:  606940444\n31212132\n*p2:  31212132\n```", "```go\n$ strace ./addCLAImproved 1 2 2>&1 | grep write\nwrite(1, \"Sum: 3\\n\", 7Sum: 3\n```", "```go\n$ strace ./addCLAImproved 1 a b 2>&1 | grep write\nwrite(1, \"Ignoring a\\n\", 11Ignoring a\nwrite(1, \"Ignoring b\\n\", 11Ignoring b\nwrite(1, \"Sum: 1\\n\", 7Sum: 1\n```", "```go\n$ sudo dtruss -c ./addCLAImproved 2000 2>&1 | grep write\n```", "```go\n$ sudo dtruss -c ./addCLAImproved 2000\nCALL                                        COUNT\n__pthread_sigmask                               1\nexit                                            1\ngetpid                                          1\nioctl                                           1\nissetugid                                       1\nread                                            1\nthread_selfid                                   1\nulock_wake                                      1\nbsdthread_register                              2\nclose                                           2\ncsops                                           2\nopen                                            2\nselect                                          2\nsysctl                                          3\nmmap                                            7\nmprotect                                        8\nstat64                                         41\nwrite                                          83\n```", "```go\n$ sudo dtruss ./addCLAImproved 1 2 2>&1 | grep -i write\ndtrace: error on enabled probe ID 2132 (ID 156: syscall::write:return): invalid kernel access in action #12 at DIF offset 92\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n) \n\nfunc x() int {\n\n   return -1 \n   fmt.Println(\"Exiting x()\") \n   return -1 \n} \n\nfunc y() int { \n   return -1 \n   fmt.Println(\"Exiting y()\") \n   return -1 \n} \n```", "```go\nfunc main() { \n   fmt.Println(x()) \n   fmt.Println(\"Exiting program...\") \n} \n```", "```go\n$ go tool vet cannotReach.go\ncannotReach.go:9: unreachable code\ncannotReach.go:14: unreachable code\n\n```"]