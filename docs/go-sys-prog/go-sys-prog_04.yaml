- en: Go Packages, Algorithms, and Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go包、算法和数据结构
- en: The main topics of this chapter will be Go packages, algorithms, and data structures.
    If you combine all of these, you will end up with a complete program because Go
    programs come in packages that contain algorithms that deal with data structures.
    These packages include both the ones that come with Go and the ones that you create
    on your own in order to manipulate your data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要主题将是Go包、算法和数据结构。如果您将所有这些结合起来，您将得到一个完整的程序，因为Go程序以包的形式提供，其中包含处理数据的算法。这些包包括Go自带的包和您自己创建的包，以便操作您的数据。
- en: 'Hence, in this chapter, you will learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，您将学习以下内容：
- en: The Big O notation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大O符号
- en: Two sorting algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种排序算法
- en: The `sort.Slice()` function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort.Slice()`函数'
- en: Linked lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表
- en: Trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树
- en: Creating your own hash table data structure in Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中创建自己的哈希表数据结构
- en: Go packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go包
- en: '**Garbage collection** (**GC**) in Go'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中的垃圾回收（GC）
- en: About algorithms
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于算法
- en: Knowing about algorithms and the way they work will definitely help you when
    you have to manipulate lots of data. Additionally, if you choose to use the wrong
    algorithm for a given job, you might slow down the entire process and make your
    software unusable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 了解算法及其工作方式肯定会在您需要处理大量数据时帮助您。此外，如果您选择对于特定工作使用错误的算法，可能会减慢整个过程并使您的软件无法使用。
- en: Traditional Unix command-line utilities such as `awk(1)`, `sed(1)`, `vi(1)`,
    `tar(1)`, and `cp(1)` are great examples of how good algorithms can help, and
    these utilities can work with files that are much bigger than the memory of a
    machine. This was extremely important in the early Unix days because the total
    amount of RAM on a Unix machine then was about 64K or even less!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的Unix命令行实用程序，如`awk(1)`、`sed(1)`、`vi(1)`、`tar(1)`和`cp(1)`，是好算法如何帮助的很好的例子，这些实用程序可以处理比机器内存大得多的文件。这在早期的Unix时代非常重要，因为当时Unix机器上的总RAM量大约为64K甚至更少！
- en: The Big O notation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大O符号
- en: The **Big O** **notation** is used for describing the complexity of an algorithm,
    which is directly related to its performance. The efficiency of an algorithm is
    judged by its computation complexity, which mainly has to do with the number of
    times the algorithm needs to access its input data to do its job. Usually, you
    would want to know about the worst-case scenario and the average situation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**大O符号**用于描述算法的复杂性，这与其性能直接相关。算法的效率是通过其计算复杂性来判断的，这主要与算法需要访问其输入数据的次数有关。通常，您会想了解最坏情况和平均情况。'
- en: So, an O(n) algorithm, where n is the size of the input, is considered better
    than an O(n²) algorithm, which is better than an O(n³) algorithm. However, the
    worst algorithms are the ones with an O(n!) running time because this makes them
    almost unusable for inputs with more than 300 elements. Note that the Big O notation
    is more about estimating and not about giving an exact value. Therefore, it is
    largely used as a comparative value and not an absolute value.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，O(n)算法（其中n是输入的大小）被认为比O(n²)算法更好，后者又比O(n³)算法更好。然而，最糟糕的算法是具有O(n!)运行时间的算法，因为这使得它们几乎无法用于超过300个元素的输入。请注意，大O符号更多地是关于估计而不是给出精确值。因此，它主要用作比较值而不是绝对值。
- en: Also, most Go lookup operations in built-in types, such as finding the value
    of a map key or accessing an array element, have a constant time, which is represented
    by O(1). This means that built-in types are generally faster than custom types
    and that you should usually prefer them unless you want full control over what
    is going on behind the scenes. Additionally, not all data structures are created
    equal. Generally speaking, array operations are faster than map operations, whereas
    maps are more versatile than arrays!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数内置类型的Go查找操作，比如查找地图键的值或访问数组元素，都具有常数时间，用O(1)表示。这意味着内置类型通常比自定义类型更快，通常应该优先选择它们，除非你想完全控制后台发生的事情。另外，并非所有数据结构都是平等的。一般来说，数组操作比地图操作更快，而地图比数组更灵活！
- en: Sorting algorithms
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序算法
- en: 'The most common category of algorithm has to deal with sorting data, that is,
    placing it in a given order. The two most famous sorting algorithms are the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的算法类别涉及对数据进行排序，即将其放置在给定顺序中。最著名的两种排序算法如下：
- en: '**Quicksort**: This is considered one of the fastest sorting algorithms. The
    average time that quicksort takes to sort its data is O (n log n), but this can
    grow up to O(n²) in the worst-case scenario, which mainly has to do with the way
    the data is presented for processing.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速排序**：这被认为是最快的排序算法之一。快速排序对其数据进行排序所需的平均时间为O(n log n)，但在最坏情况下可能增长到O(n²)，这主要与数据呈现方式有关。'
- en: '**Bubble sort**: This algorithm is pretty easy to implement with an O(n²) average
    complexity. If you want to start learning about sorting, start with bubble sort
    before looking into the more difficult to develop algorithms.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冒泡排序**：这个算法非常容易实现，平均复杂度为O(n²)。如果您想开始学习排序，可以先从冒泡排序开始，然后再研究更难开发的算法。'
- en: Although every algorithm has its disadvantages, if you do not have lots of data,
    the algorithm is not really important as long as it does the job.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每种算法都有其缺点，但如果您没有大量数据，那么只要它能完成工作，算法就不是真正重要的。
- en: What you should remember is, the way Go implements sorting internally cannot
    be controlled by the developer and it can change in the future; so, if you want
    to have full control over sorting, you should write your own implementation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该记住的是，Go内部实现排序的方式无法由开发人员控制，并且将来可能会发生变化；因此，如果您想完全控制排序，应该编写自己的实现。
- en: The sort.Slice() function
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sort.Slice()函数
- en: This section will illustrate the use of the `sort.Slice()` function that first
    came with Go version 1.8\. The use of the function will be illustrated in `sortSlice.go`,
    which will be presented in three parts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将说明首次出现在Go版本1.8中的`sort.Slice()`函数的用法。该函数的用法将在`sortSlice.go`中进行说明，该文件将分为三部分呈现。
- en: 'The first part is the expected preamble of the program and the definition of
    a new structure type, given as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是程序的预期序言和新结构类型的定义，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you might expect, you have to import the `sort` package to be able to use
    its `Slice()` function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的，您必须导入`sort`包才能使用其`Slice()`函数。
- en: 'The second part contains the definition of a slice, which has four elements:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含了切片的定义，其中包含四个元素：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Therefore, in the first part, you declared a slice of structure that will be
    sorted in two ways in the rest of the program, which contains the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第一部分中，您声明了一个结构的切片，该切片将在程序的其余部分中以两种方式进行排序，其中包含以下代码：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code contains all the magic: you only have to define the way you want
    to `sort` your `slice` and the rest is done by Go. The `sort.Slice()` function
    takes the anonymous sorting function as one of its arguments; the other argument
    is the name of the `slice` variable you want to `sort`. Note that the sorted slice
    is saved in the `slice` variable.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了所有的魔法：您只需定义您想要对`slice`进行`sort`的方式，Go就会完成其余工作。`sort.Slice()`函数将匿名排序函数作为其参数之一；另一个参数是您想要`sort`的`slice`变量的名称。请注意，排序后的切片保存在`slice`变量中。
- en: 'Executing `sortSlice.go` will generate the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`sortSlice.go`将生成以下输出：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, you can easily `sort` in ascending or descending order by just
    changing a single character in the Go code!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以通过在Go代码中更改一个字符来轻松地按升序或降序进行`sort`！
- en: 'Also, if your Go version does not support `sort.Slice()`, you will get an error
    message similar to the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您的Go版本不支持`sort.Slice()`，您将收到类似以下的错误消息：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Linked lists in Go
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的链表
- en: 'A **linked list** is a structure with a finite set of elements where each element
    uses at least two memory locations: one for storing the data and the other for
    a pointer that links the current element to the next one in the sequence of elements
    that make the linked list. The biggest advantages of linked lists are that they
    are easy to understand and implement, and generic enough to be used in many different
    situations and model many different kinds of data.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**链表**是具有有限元素集的结构，其中每个元素使用至少两个内存位置：一个用于存储数据，另一个用于将当前元素链接到构成链表的元素序列中的下一个元素的指针。链表的最大优势是易于理解和实现，并且足够通用，可用于许多不同情况并模拟许多不同类型的数据。'
- en: The first element of a linked list is called the **head**, whereas the last
    element of a list is often called the **tail**. The first thing you should do
    when defining a linked list is to keep the head of the list in a separate variable
    because the head is the only thing that you need to access the entire linked list.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 链表的第一个元素称为**头部**，而列表的最后一个元素通常称为**尾部**。定义链表时，首先要做的是将列表的头部保留在单独的变量中，因为头部是您需要访问整个链表的唯一内容。
- en: Note that if you lose the pointer to the first node of a single linked list,
    there is no possible way to find it again.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果丢失单链表的第一个节点的指针，将无法再次找到它。
- en: 'The following figure shows the graphical representation of a linked list and
    a doubly linked list. Doubly linked lists are more flexible, but require more
    housekeeping:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了链表和双向链表的图形表示。双向链表更灵活，但需要更多的维护：
- en: '![](img/834e20cc-7099-4649-b740-da9fa61fbd3d.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/834e20cc-7099-4649-b740-da9fa61fbd3d.png)'
- en: The graphical representation of a linked list and a doubly linked list
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 链表和双向链表的图形表示
- en: So, in this section, we will present a simple implementation of a linked list
    in Go saved in `linkedList.go`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，我们将介绍在`linkedList.go`中保存的Go中链表的简单实现。
- en: When creating your own data structures, the single most important element is
    the definition of the node, which is usually implemented using a structure.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建自己的数据结构时，最重要的元素是节点的定义，通常使用结构来实现。
- en: The code of `linkedList.go` will be presented in four parts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`linkedList.go`的代码将分为四部分呈现。'
- en: 'The first part is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second part contains the following Go code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you define the structure that will hold each element of the list and a
    function that allows you to add a new node to the list. In order to avoid duplicate
    entries, you should check whether a value already exists in the list or not. Note
    that `addNode()` is a recursive function because it calls itself and that this
    approach might be a little slower and require more memory than iterating.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您定义了将保存列表中每个元素的结构以及允许您向列表添加新节点的函数。为了避免重复条目，您应该检查值是否已经存在于列表中。请注意，`addNode()`是一个递归函数，因为它调用自身，这种方法可能比迭代稍慢，需要更多的内存。
- en: 'The third part of the code is the `traverse()` function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第三部分是`traverse()`函数：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `for` loop implements the iterative approach for visiting all the nodes
    in a linked list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环实现了访问链表中所有节点的迭代方法。'
- en: 'The last part is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分如下：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For the first time in this book, you see the use of a global variable that is
    not a constant. Global variables can be accessed and changed from anywhere in
    a program, which makes their use both practical and dangerous for that reason.
    The reason for using a global variable, which is named `root`, to hold the `root`
    of the linked list is to show whether the linked list is empty or not. This happens
    because integer values in Go are initialized as `0`; so `new(Node)` is in fact
    `{0 <nil>}`, which makes it impossible to tell whether the head of the list is
    nil or not without passing an extra variable to each function that manipulates
    the linked list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中首次看到不是常量的全局变量的使用。全局变量可以从程序的任何地方访问和更改，这使得它们的使用既实用又危险。使用名为`root`的全局变量来保存链表的`root`是为了显示链表是否为空。这是因为在Go中，整数值被初始化为`0`；因此`new(Node)`实际上是`{0
    <nil>}`，这使得在不传递额外变量给每个操作链表的函数的情况下，无法判断列表的头部是否为空。
- en: 'Executing `linkedList.go` will generate the following output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`linkedList.go`将生成以下输出：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Trees in Go
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的树
- en: 'A **graph** is a finite and nonempty set of vertices and edges. A **directed
    graph** is a graph whose edges have a direction associated with them. A **directed
    acyclic graph** is a directed graph with no cycles in it. A **tree** is a directed
    acyclic graph that satisfies three more principles: firstly, it has a root node:
    the entry point to the tree; secondly, every vertex, except the root, has one
    and only one entry point; and thirdly, there is a path that connects the root
    with each vertex and belongs to the tree.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**图**是一个有限且非空的顶点和边的集合。**有向图**是一个边带有方向的图。**有向无环图**是一个没有循环的有向图。**树**是一个满足三个原则的有向无环图：首先，它有一个根节点：树的入口点；其次，除了根之外，每个顶点只有一个入口点；第三，存在一条连接根和每个顶点的路径，并且属于树。'
- en: As a result, the root is the first node of the tree. Each node can be connected
    to one or more nodes depending on the tree type. If each node leads to one and
    only one other node, then the tree is a linked list!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根是树的第一个节点。每个节点可以连接到一个或多个节点，具体取决于树的类型。如果每个节点只指向一个其他节点，那么树就是一个链表！
- en: 'The most commonly used type of tree is called a binary tree because each node
    can have up to two children. The following figure shows a graphical representation
    of a binary tree''s data structure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的树类型是二叉树，因为每个节点最多可以有两个子节点。下图显示了二叉树数据结构的图形表示：
- en: '![](img/4f4a000e-6fe7-4025-81f3-ff52adfbd59f.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f4a000e-6fe7-4025-81f3-ff52adfbd59f.png)'
- en: A binary tree
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树
- en: The presented code will only show you how to create a binary tree and how to
    traverse it in order to print all of its elements as proof that Go can be used
    for creating a tree data structure. Therefore, it will not implement the full
    functionality of a binary tree, which also includes deleting a tree node and balancing
    a tree.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现的代码只会向您展示如何创建二叉树以及如何遍历它以打印出所有元素，以证明Go可以用于创建树数据结构。因此，它不会实现二叉树的完整功能，其中还包括删除树节点和平衡树。
- en: The code of `tree.go` will be presented in three parts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree.go`的代码将分为三部分呈现。'
- en: 'The first part is the expected preamble as well as the definition of the node,
    as given here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是预期的序言以及节点的定义，如下所示：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The second part contains functions that allow you to traverse a tree in order
    to print all of its elements, create a tree with randomly generated numbers, and
    insert a node into it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含允许您遍历树以打印所有元素、使用随机生成的数字创建树以及将节点插入其中的函数：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second `if` statement of `insert()` checks whether a value already exists
    in the tree, in order to not add it again. The third `if` statement identifies
    whether the new element will be on the left or right-hand side of the current
    node.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()`的第二个`if`语句检查树中是否已经存在值，以免重复添加。第三个`if`语句标识新元素将位于当前节点的左侧还是右侧。'
- en: 'The last part is the implementation of the `main()` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是`main()`函数的实现：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Executing `tree.go` will generate the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`tree.go`将生成以下输出：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Please note that as the values of the nodes of the tree are generated randomly,
    the output of the program will be different each time you run it. If you want
    to get the same elements all the time, then use a constant for the seed value
    in the `create()` function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于树的节点的值是随机生成的，程序的输出每次运行时都会不同。如果您希望始终获得相同的元素，则在`create()`函数中使用种子值的常量。
- en: Developing a hash table in Go
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中开发哈希表
- en: Strictly speaking, a **hash table** is a data structure that stores one or more
    key and value pairs and uses the `hashFunction` of the key to compute an index
    into an array of buckets or slots, from which the correct value can be retrieved.
    Ideally, the `hashFunction` should assign each key to a unique bucket, provided
    that you have the required number of buckets.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，**哈希表**是一种数据结构，它存储一个或多个键值对，并使用键的`hashFunction`计算出数组中的桶或槽的索引，从中可以检索到正确的值。理想情况下，`hashFunction`应该将每个键分配到一个唯一的桶中，前提是您有所需数量的桶。
- en: 'A good `hashFunction` must be able to produce a uniform distribution of hash
    values because it is inefficient to have unused buckets or big differences in
    the cardinalities of the buckets. Additionally, the `hashFunction` should work
    consistently and output the same hash value for identical keys because otherwise
    it would be impossible to find the information you want! If you think that hash
    tables are not that useful, handy, or clever, you should consider the following:
    when a hash table has *n* keys and *k* buckets, its search speed goes from O (n)
    for a linear search to O (n/k)! Although the improvement might look small, you
    should realize that for a hash array with only 20 slots, the search time would
    be reduced by 20 times! This makes hash tables good for applications such as dictionaries
    or any other analogous application where you have to search lots of data. Although
    using lots of buckets increases the complexity and the memory usage of your program,
    there are times when it is worth it.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的`hashFunction`必须能够产生均匀分布的哈希值，因为拥有未使用的桶或桶的基数差异很大是低效的。此外，`hashFunction`应该能够一致地工作，并为相同的键输出相同的哈希值，否则将无法找到所需的信息！如果你认为哈希表并不那么有用、方便或聪明，你应该考虑以下：当哈希表有*n*个键和*k*个桶时，其搜索速度从线性搜索的O(n)变为O(n/k)!虽然改进看起来很小，但你应该意识到，对于只有20个插槽的哈希数组，搜索时间将减少20倍！这使得哈希表非常适用于诸如字典或任何其他类似的应用程序，其中需要搜索大量数据。尽管使用大量桶会增加程序的复杂性和内存使用量，但有时这是值得的。
- en: 'The following figure shows the graphical representation of a simple hash table
    with 10 buckets. It is not difficult to understand that the `hashFunction` is
    the modulo operator:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个具有10个桶的简单哈希表的图形表示。很容易理解`hashFunction`是取模运算符：
- en: '![](img/30731fad-6b66-43d1-8e49-25ae564255a1.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30731fad-6b66-43d1-8e49-25ae564255a1.png)'
- en: A simple hash table
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的哈希表
- en: Although the presented version of a hash table uses numbers because they are
    a little easier to implement and understand, you can use any data type you want
    as long as you can find an appropriate `hashFunction` to process your input. The
    source code of `hash.go` will be presented in three parts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所呈现的哈希表版本使用数字，因为它们更容易实现和理解，但只要你能找到合适的`hashFunction`来处理输入，你可以使用任何数据类型。`hash.go`的源代码将分为三部分呈现。
- en: 'The first one is the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是以下内容：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Node struct` definition is taken from the implementation of the linked
    list you saw earlier. The reason for using a map for the `Table` variable instead
    of a slice is that the index of a slice can only be a natural number, whereas
    the key of a map can be anything.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node struct`的定义取自您之前看到的链表的实现。使用`map`变量的`Table`而不是切片的原因是，切片的索引只能是自然数，而`map`的键可以是任何东西。'
- en: 'The second part contains the following Go code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note here that the `traverse()` function is using the Go code from `linkedList.go`
    in order to traverse the elements of each bucket in the hash table. Additionally,
    note that the `insert` function does not check whether or not a value already
    exists in the hash table in order to save book space, but this is not usually
    the case. Also, for reasons of speed and simplicity, new elements are inserted
    at the beginning of each list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`traverse()`函数使用`linkedList.go`中的Go代码来遍历哈希表中每个桶的元素。另外，请注意，`insert`函数不会检查值是否已经存在于哈希表中，以节省空间，但通常情况下并非如此。另外，出于速度和简单性的考虑，新元素被插入到每个列表的开头。
- en: 'The last part contains the implementation of the `main()` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分包含了`main()`函数的实现：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Executing `hash.go` will generate the following output, which proves that the
    hash table is working as expected:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`hash.go`将生成以下输出，证明哈希表按预期工作：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you execute `hash.go` multiple times, you will see that the order the lines
    are printed in will vary. This happens because the output of `range hash.Table`
    found in the `traverse()` function cannot be predicted, which happens because
    Go has an unspecified return order for hashes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次执行`hash.go`，你会发现打印行的顺序会变化。这是因为`traverse()`函数中`range hash.Table`的输出是无法预测的，这是因为Go对哈希的返回顺序没有指定。
- en: About Go packages
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Go包
- en: Packages are for grouping related functions and constants so that you can transfer
    them easily and use them in your own Go programs. As a result, apart from the
    main package, packages are not autonomous programs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 包用于将相关函数和常量分组，以便您可以轻松地传输它们并在自己的Go程序中使用。因此，除了主包之外，包不是独立的程序。
- en: 'There exist many useful Go packages that come with each Go distribution including
    the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Go发行版都附带许多有用的Go包，包括以下内容：
- en: 'The `net` package: This supports portable TCP and UDP connections'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net`包：这支持可移植的TCP和UDP连接'
- en: 'The `http` package: This is a part of the net package and offers HTTP server
    and client implementations'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http`包：这是net包的一部分，提供了HTTP服务器和客户端的实现'
- en: 'The `math` package: This provides mathematical functions and constants'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`math`包：这提供了数学函数和常量'
- en: 'The `io` package: This deals with primitive input and output operations'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io`包：这处理原始的输入和输出操作'
- en: 'The `os` package: This gives you a portable interface to the operating system
    functionality'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os`包：这为您提供了一个便携式的操作系统功能接口'
- en: 'The `time` package: This allows you to work with times and dates'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`包：这允许您处理时间和日期'
- en: For the full list of standard Go packages refer to [https://golang.org/pkg/](https://golang.org/pkg/).
    I strongly advise you to look into all the packages that come with Go before you
    start developing your own functions and packages because there is a realistic
    chance that the functionality you are looking for is already available in a standard
    Go package.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有关标准Go包的完整列表，请参阅[https://golang.org/pkg/](https://golang.org/pkg/)。我强烈建议您在开始开发自己的函数和包之前，先了解Go提供的所有包，因为你要寻找的功能很可能已经包含在标准Go包中。
- en: Using standard Go packages
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准Go包
- en: You probably already know how to use the standard Go packages. However, what
    you may not be aware of is the fact that some packages have a structure. So, for
    example, the `net` package has several sub directories, named `http`, `mail`,
    `rpc`, `smtp`, `textproto`, and `url`, which should be imported as `net/http`,
    `net/mail`, `net/rpc`, `net/smtp`, `net/textproto`, and `net/url`, respectively.
    Go groups packages when this makes sense, but these packages could have also been
    isolated packages if they were grouped for distribution instead of functionality.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经知道如何使用标准的Go包。但是，您可能不知道的是，一些包有一个结构。例如，`net`包有几个子目录，命名为`http`、`mail`、`rpc`、`smtp`、`textproto`和`url`，应该分别导入为`net/http`、`net/mail`、`net/rpc`、`net/smtp`、`net/textproto`和`net/url`。Go在这些情况下对包进行分组，但是如果它们是为了分发而不是功能而分组，这些包也可以是独立的包。
- en: You can find information about a Go standard package with the help of the `godoc`
    utility. So, if you are looking for information about the `net` package, you should
    execute `godoc net`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`godoc`实用程序查找有关Go标准包的信息。因此，如果您正在寻找有关`net`包的信息，您应该执行`godoc net`。
- en: Creating your own packages
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的包
- en: Packages make the design, implementation, and maintenance of large software
    systems easier and simpler. Moreover, they allow multiple programmers to work
    on the same project without any overlapping. So, if you find yourselves using
    the same functions all the time, you should seriously consider including them
    in your own Go packages.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 包使得大型软件系统的设计、实现和维护更加简单和容易。此外，它们允许多个程序员在同一个项目上工作而不会发生重叠。因此，如果您发现自己一直在使用相同的函数，您应该认真考虑将它们包含在您自己的Go包中。
- en: The source code of a Go package, which can contain multiple files, can be found
    within a single directory, which is named after the package with the exception
    of the main package, which can have any name.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Go包的源代码，可以包含多个文件，可以在一个目录中找到，该目录以包的名称命名，除了主包，主包可以有任何名称。
- en: The Go code of the `aSimplePackage.go` file, which will be developed in this
    section, will be presented in two parts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中将开发的`aSimplePackage.go`文件的Go代码将分为两部分呈现。
- en: 'The first part is the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是以下内容：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is nothing special here; you just have to define the name of the package
    and include the necessary import statements because a package can depend on other
    packages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的；您只需定义包的名称并包含必要的导入语句，因为一个包可以依赖于其他包。
- en: 'The second part contains the following Go code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, the `aSimplePackage` package offers two functions and one constant.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`aSimplePackage`包提供了两个函数和一个常量。
- en: 'After you finish writing the code of `aSimplePackage.go`, you should execute
    the following commands in order to be able to use the package in other Go programs
    or packages:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完成`aSimplePackage.go`的代码编写后，您应该执行以下命令，以便能够在其他Go程序或包中使用该包：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You should perform all these actions for every Go package you create, apart
    from the first two `mkdir` commands, which should only be executed once.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前两个`mkdir`命令，您应该为您创建的每个Go包执行所有这些操作，这两个命令只需要执行一次。
- en: 'As you can see, each package needs its own directory inside `~/go/src`. After
    executing the aforementioned commands, the `go tool` will automatically generate
    an `ar(1)` archive of the Go package you have just compiled in the `pkg` directory:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个包都需要在`~/go/src`目录下有自己的文件夹。在执行上述命令后，`go tool`将自动生成一个Go包的`ar(1)`存档文件，该文件刚刚在`pkg`目录中编译完成：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although you are now ready to use the `aSimplePackage` package, you cannot see
    the functionality of the package without having an autonomous program.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您现在已经准备好使用`aSimplePackage`包，但是没有一个独立的程序，您无法看到包的功能。
- en: Private variables and functions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有变量和函数
- en: Private variables and functions are different from public ones in that they
    can be used and called only internally in a package. Controlling `which` functions
    and variables are public or not is also known as encapsulation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 私有变量和函数与公共变量和函数不同，它们只能在包内部使用和调用。控制哪些函数和变量是公共的或不公共的也被称为封装。
- en: Go follows a simple rule which states that functions, variables, types, and
    so on that begin with an uppercase letter are public, whereas functions, variables,
    types, and so on that begin with a lowercase letter are private. However, this
    rule does not affect package names.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Go遵循一个简单的规则，即以大写字母开头的函数、变量、类型等都是公共的，而以小写字母开头的函数、变量、类型等都是私有的。但是，这个规则不影响包名。
- en: You should understand now why the `fmt.Printf()` function is named as it is,
    instead of `fmt.printf()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该明白为什么`fmt.Printf()`函数的命名是这样的，而不是`fmt.printf()`。
- en: 'To illustrate this, we will make some changes to the `aSimplePackage.go` module
    and add one private variable and one private function. The name of the new separate
    package will be `anotherPackage.go`. You can see the changes made to it using
    the `diff(1)` command-line utility:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们将对`aSimplePackage.go`模块进行一些更改，并添加一个私有变量和一个私有函数。新的独立包的名称将是`anotherPackage.go`。您可以使用`diff(1)`命令行实用程序查看对其所做的更改：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The init() function
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: init()函数
- en: 'Every Go package can have a function named `init()` that is automatically executed
    at the beginning of the execution. So, let''s add the following `init()` function
    to the code of the `anotherPackage.go` package:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Go包都可以有一个名为`init()`的函数，在执行开始时自动执行。因此，让我们在`anotherPackage.go`包的代码中添加以下`init()`函数：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The current implementation of the `init()` function is naive and does nothing
    special. However, there are times when you want to perform important initializations
    before you start using a package such as opening database and network connections:
    in these relatively rare cases the `init()` function is invaluable.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`函数的当前实现是简单的，没有特殊操作。但是，有时您希望在开始使用包之前执行重要的初始化操作，例如打开数据库和网络连接：在这些相对罕见的情况下，`init()`函数是非常宝贵的。'
- en: Using your own Go packages
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用您自己的Go包
- en: This subsection will show you how to use the `aSimplePackage` and `anotherPackage`
    packages in your own Go programs by presenting two small Go programs named `usePackage.go`
    and `privateFail.go`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将向你展示如何在你自己的Go程序中使用`aSimplePackage`和`anotherPackage`包，通过展示两个名为`usePackage.go`和`privateFail.go`的小型Go程序。
- en: 'In order to use the `aSimplePackage` package that resides under the `GOPATH`
    directory from another Go program, you will need to write the following Go code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`GOPATH`目录下的`aSimplePackage`包，你需要在另一个Go程序中编写以下Go代码：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'First of all, if `aSimplePackage` is not already compiled and located at the
    expected location, the compilation process will fail with an error message similar
    to the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果`aSimplePackage`尚未编译并位于预期位置，编译过程将失败，并显示类似以下的错误消息：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, if `aSimplePackage` is available, `usePackage.go` will be executed
    just fine:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`aSimplePackage`可用，`usePackage.go`将会被成功执行：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s see the Go code of the other small program that uses `anotherPackage`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个使用`anotherPackage`的小程序的Go代码：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you try to call a private function or use a private variable from `anotherPackage`,
    your Go program `privateFail.go` will fail to run with the following error message:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试从`anotherPackage`调用私有函数或使用私有变量，你的Go程序`privateFail.go`将无法运行，并显示以下错误消息：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I really like showing error messages because most books try to hide them as
    if they were not there. When I was learning Go, it took me about 3 hours of debugging
    until I found that the reason for an error message I could not explain was the
    name of a variable!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢显示错误消息，因为大多数书籍都试图隐藏它们，好像它们不存在一样。当我学习Go时，我花了大约3个小时的调试，直到我发现一个我无法解释的错误消息的原因是一个变量的名字！
- en: 'However, if you remove the call to the private variable from `privateFail.go`,
    the program will be executed without errors. Additionally, you will see that the
    `init()` function actually gets executed automatically:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你从`privateFail.go`中删除对私有变量的调用，程序将在没有错误的情况下执行。此外，你会看到`init()`函数实际上会自动执行：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using external Go packages
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部Go包
- en: Sometimes packages are available on the internet and you would prefer to use
    them by specifying their internet address. One such example is the Go `MySQL`
    driver that can be found at `github.com/go-sql-driver/mysql`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，包可以在互联网上找到，并且你希望通过指定它们的互联网地址来使用它们。一个这样的例子是Go的`MySQL`驱动程序，可以在`github.com/go-sql-driver/mysql`找到。
- en: 'Look at the following Go code, which is saved as `useMySQL.go`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下的Go代码，保存为`useMySQL.go`：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The use of `_` as the package identifier will make the compiler ignore the
    fact that the package is not being used: the only sensible reason for bypassing
    the compiler is when you have an `init` function in your unused package that you
    want to be executed. The other sensible reason is for illustrating a Go concept!'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`_`作为包标识符将使编译器忽略包未被使用的事实：绕过编译器的唯一合理理由是当你的未使用包中有一个你想要执行的`init`函数时。另一个合理的理由是为了说明一个Go概念！
- en: 'If you try to execute `useMySQL.go`, the compilation process will fail:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试执行`useMySQL.go`，编译过程将失败：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to compile `useMySQL.go`, you should first perform the following steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译`useMySQL.go`，你应该首先执行以下步骤：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After successfully downloading the required package, the contents of the `~/go`
    directory verify that the desired Go package has been downloaded:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 成功下载所需的包后，`~/go`目录的内容将验证所需的Go包已被下载：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The go clean command
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: go clean命令
- en: 'There will be times when you are developing a big Go program that uses lots
    of nonstandard Go packages and you want to start the compilation process from
    the beginning. Go allows you to clean up the files of a package in order to recreate
    it later. The following command cleans up a package without affecting the code
    of the package:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你正在开发一个使用大量非标准Go包的大型Go程序，并且希望从头开始编译过程。Go允许你清理一个包的文件，以便稍后重新创建它。以下命令清理一个包，而不影响包的代码：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similarly, you can also clean up a package that you have downloaded from the
    internet, which also requires the use of its full path:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以清理从互联网下载的包，这也需要使用其完整路径：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Please note that the `go clean` command is also particularly useful when you
    want to transfer your projects to another machine without including unnecessary
    files.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你想将项目转移到另一台机器上而不包括不必要的文件时，`go clean`命令也特别有用。
- en: Garbage collection
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: In this section, we will briefly talk about how Go deals with GC, which tries
    to free unused memory efficiently. The Go code of `garbageCol.go` can be presented
    in two parts.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要讨论Go如何处理GC，它试图高效地释放未使用的内存。`garbageCol.go`的Go代码可以分为两部分。
- en: 'The first part is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Every time you want to read the latest memory statistics, you should make a
    call to the `runtime.ReadMemStats()` function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想要读取最新的内存统计信息时，你应该调用`runtime.ReadMemStats()`函数。
- en: 'The second part, which contains the implementation of the `main()` function,
    has the following Go code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含了`main()`函数的实现，其中包含以下Go代码：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, you try to obtain large amounts of memory in order to trigger the use
    of the garbage collector.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你尝试获取大量内存，以触发垃圾收集器的使用。
- en: 'Executing `garbageCol.go` generates the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`garbageCol.go`会生成以下输出：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, the output presents information about properties related to the memory
    used by the `garbageCol.go` program. If you want to get an even more detailed
    output, you can execute `garbageCol.go`, as shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输出呈现了与`garbageCol.go`程序使用的内存相关的属性信息。如果你想获得更详细的输出，可以执行`garbageCol.go`，如下所示：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This version of the command will give you information in the following format:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的版本将以以下格式给出信息：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `95->95->0 MB` part contains information about the various heap sizes that
    also show how well or how badly the garbage collector is doing. The first value
    is the heap size when the GC starts, whereas the middle value shows the heap size
    when the GC ends. The third value is the size of the live heap.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`95->95->0 MB` 部分包含有关各种堆大小的信息，还显示了垃圾收集器的表现如何。第一个值是 GC 开始时的堆大小，而中间值显示了 GC 结束时的堆大小。第三个值是活动堆的大小。'
- en: Your environment
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的环境
- en: 'In this section, we will show how to find out things about your environment
    using the `runtime` package: this can be useful when you have to take certain
    actions depending on the OS and the Go version you are using.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何使用 `runtime` 包查找有关您的环境的信息：当您必须根据操作系统和您使用的 Go 版本采取某些操作时，这可能很有用。
- en: 'The use of the `runtime` package for finding out about your environment is
    straightforward and is illustrated in `runTime.go`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `runtime` 包查找有关您的环境的信息是直接的，并在 `runTime.go` 中有所说明：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As long as you know what you want to call from the runtime package, you can
    get the information you desire. The last `fmt.Println()` command here displays
    information about **goroutines**: you will learn more about goroutines in [Chapter
    9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)*,* *Goroutines - Basic Features*.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您知道要从 runtime 包中调用什么，就可以获取所需的信息。这里的最后一个 `fmt.Println()` 命令显示有关 **goroutines**
    的信息：您将在[第 9 章](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)*,* *Goroutines - Basic
    Features* 中了解更多关于 goroutines 的信息。
- en: 'Executing `runTime.go` on a macOS machine generates the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 机器上执行 `runTime.go` 会生成以下输出：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Executing `runTime.go` on a Linux machine that uses an older Go version gives
    the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用旧版 Go 的 Linux 机器上执行 `runTime.go` 会得到以下结果：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Go gets updated frequently!
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 经常更新！
- en: 'As I came to the end of writing this chapter, Go was updated a little. So,
    I decided to include this information in this book in order to give a better sense
    of how often Go gets updated:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在写完本章的最后，Go 进行了一点更新。因此，我决定在本书中包含这些信息，以便更好地了解 Go 的更新频率：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Exercises
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Visit the documentation of the runtime package.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 runtime 包的文档。
- en: Create your own structure, make a slice and use the `sort.Slice()` to sort the
    elements of the slice you created.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您自己的结构，创建一个切片，并使用 `sort.Slice()` 对您创建的切片的元素进行排序。
- en: Implement the quicksort algorithm in Go and sort some randomly-generated numeric
    data.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Go 中实现快速排序算法，并对一些随机生成的数字数据进行排序。
- en: Implement a doubly linked list.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个双向链表。
- en: The implementation of `tree.go` is far from complete! Try to implement a function
    that checks whether a value can be found in the tree and another function that
    allows you to delete a tree node.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tree.go` 的实现远未完成！尝试实现一个检查树中是否可以找到值的函数，以及一个允许您删除树节点的函数。'
- en: Similarly, the implementation of the `linkedList.go` file is also incomplete.
    Try to implement a function for deleting a node and another one for inserting
    a node somewhere inside the linked list.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`linkedList.go` 文件的实现也是不完整的。尝试实现一个用于删除节点的函数，以及另一个用于在链表中某个位置插入节点的函数。
- en: Once again, the hash table implementation of `hash.go` is incomplete as it allows
    duplicate entries. So, implement a function that searches the hash table for a
    key before inserting it.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，`hash.go` 的哈希表实现是不完整的，因为它允许重复条目。因此，在插入之前，实现一个在哈希表中搜索键的函数。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned many things related to algorithms and data structures.
    You also learned how to use existing Go packages and how to develop your own Go
    packages. This chapter also talked about garbage collection in Go and how to find
    information about your environment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了许多与算法和数据结构相关的知识。您还学会了如何使用现有的 Go 包以及如何开发自己的 Go 包。本章还讨论了 Go 中的垃圾收集以及如何查找有关您的环境的信息。
- en: In the next chapter, we will start talking about systems programming and present
    even more Go code. More precisely, [Chapter 5](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml),
    *Files and Directories*, will talk about how to work with files and directories
    in Go, how to painlessly traverse directory structures, and how to process command-line
    arguments using the `flag` package. But more importantly, we will start developing
    Go versions of various Unix command-line utilities.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始讨论系统编程，并呈现更多的 Go 代码。更确切地说，[第 5 章](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml)，*文件和目录*，将讨论如何在
    Go 中处理文件和目录，如何轻松地遍历目录结构，以及如何使用 `flag` 包处理命令行参数。但更重要的是，我们将开始开发各种 Unix 命令行实用程序的
    Go 版本。
