["```go\npackage main \n\nimport ( \n   \"flag\" \n   \"fmt\" \n) \n```", "```go\nfunc main() { \n   minusO := flag.Bool(\"o\", false, \"o\") \n   minusC := flag.Bool(\"c\", false, \"c\") \n   minusK := flag.Int(\"k\", 0, \"an int\") \n\n   flag.Parse() \n```", "```go\n   fmt.Println(\"-o:\", *minusO) \n   fmt.Println(\"-c:\", *minusC) \n   fmt.Println(\"-K:\", *minusK) \n\n   for index, val := range flag.Args() { \n         fmt.Println(index, \":\", val) \n   } \n} \n```", "```go\n$ go run usingFlag.go\n-o: false\n-c: false\n-K: 0\n$ go run usingFlag.go -o a b\n-o: true\n-c: false\n-K: 0\n0 : a\n1 : b\n```", "```go\n$ ./usingFlag -k\nflag needs an argument: -k\nUsage of ./usingFlag:\n  -c  c\n  -k int\n      an int\n  -o  o $ ./usingFlag -k=abc invalid value \"abc\" for flag -k: strconv.ParseInt: parsing \"abc\": invalid syntax\nUsage of ./usingFlag:\n  -c  c\n  -k int\n      an int\n  -o  o\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"path/filepath\" \n) \n\nfunc main() { \n   arguments := os.Args \n   if len(arguments) == 1 { \n         fmt.Println(\"Please provide an argument!\") \n         os.Exit(1) \n   } \n   filename := arguments[1] \n```", "```go\n   fileinfo, err := os.Lstat(fil /etcename) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n\n   if fileinfo.Mode()&os.ModeSymlink != 0 { \n         fmt.Println(filename, \"is a symbolic link\") \n         realpath, err := filepath.EvalSymlinks(filename) \n         if err == nil { \n               fmt.Println(\"Path:\", realpath) \n         } \n   } \n\n}\n```", "```go\n$ go run symbLink.go /etc\n/etc is a symbolic link\nPath: /private/etc\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"path/filepath\" \n) \n\nfunc main() { \n   arguments := os.Args \n\n   pwd, err := os.Getwd() \n   if err == nil { \n         fmt.Println(pwd) \n   } else { \n         fmt.Println(\"Error:\", err) \n   } \n```", "```go\n   if len(arguments) == 1 { \n         return \n   } \n\n   if arguments[1] != \"-P\" { \n         return \n   } \n\n   fileinfo, err := os.Lstat(pwd) \n   if fileinfo.Mode()&os.ModeSymlink != 0 { \n         realpath, err := filepath.EvalSymlinks(pwd) \n         if err == nil { \n               fmt.Println(realpath) \n         } \n   } \n} \n```", "```go\n$ go run pwd.go\n/Users/mtsouk/Desktop/goBook/ch/ch5/code\n```", "```go\n$ go run pwd.go\n/tmp\n$ go run pwd.go -P\n/tmp\n/private/tmp\n```", "```go\n$ echo $PATH\n/home/mtsouk/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games\n$ which ls\n/home/mtsouk/bin/ls\ncode$ which -a ls\n/home/mtsouk/bin/ls\n/bin/ls\n```", "```go\n$ which -s ls $ echo $?\n0\n```", "```go\npackage main \n\nimport ( \n   \"flag\" \n   \"fmt\" \n   \"os\" \n   \"strings\" \n) \n```", "```go\nfunc main() { \n   minusA := flag.Bool(\"a\", false, \"a\") \n   minusS := flag.Bool(\"s\", false, \"s\") \n\n   flag.Parse() \n   flags := flag.Args() \n   if len(flags) == 0 { \n         fmt.Println(\"Please provide an argument!\") \n         os.Exit(1) \n   } \n   file := flags[0] \n   fountIt := false \n```", "```go\n   path := os.Getenv(\"PATH\") \n   pathSlice := strings.Split(path, \":\") \n   for _, directory := range pathSlice { \n         fullPath := directory + \"/\" + file \n```", "```go\n         fileInfo, err := os.Stat(fullPath) \n         if err == nil { \n               mode := fileInfo.Mode() \n               if mode.IsRegular() { \n                     if mode&0111 != 0 { \n                           fountIt = true \n                           if *minusS == true { \n                                 os.Exit(0) \n                           } \n                           if *minusA == true {\n\n                                 fmt.Println(fullPath) \n                           } else { \n                                 fmt.Println(fullPath) \n                                 os.Exit(0) \n                           } \n                     } \n               } \n         } \n   } \n   if fountIt == false { \n         os.Exit(1) \n   } \n} \n```", "```go\n$ go run which.go ls\n/home/mtsouk/bin/ls\n$ go run which.go -s ls\n$ echo $?\n0\n$ go run which.go -s ls123123\nexit status 1\n$ echo $?\n1\n$ go run which.go -a ls\n/home/mtsouk/bin/ls\n/bin/ls\n```", "```go\n$ ls -l /bin/ls\n-rwxr-xr-x  1 root  wheel  38624 Mar 23 01:57 /bin/ls\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n) \n\nfunc main() { \n   arguments := os.Args \n   if len(arguments) == 1 { \n         fmt.Println(\"Please provide an argument!\") \n         os.Exit(1) \n   } \n\n   file := arguments[1] \n```", "```go\n   info, err := os.Stat(file) \n   if err != nil { \n         fmt.Println(\"Error:\", err) \n         os.Exit(1) \n   } \n   mode := info.Mode() \n   fmt.Print(file, \": \", mode, \"\\n\") \n} \n```", "```go\n$ go run permissions.go /bin/ls\n/bin/ls: -rwxr-xr-x\n$ go run permissions.go /usr\n/usr: drwxr-xr-x\n$ go run permissions.go /us\nError: stat /us: no such file or directory\nexit status 1\n```", "```go\npackage main \nimport ( \n   \"fmt\" \n   \"os\" \n) \n\nfunc main() { \n   arguments := os.Args \n   if len(arguments) == 1 { \n         fmt.Println(\"Please provide an argument!\") \n         os.Exit(1) \n   } \n\n   file := arguments[1] \n   err := os.Remove(file) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n} \n```", "```go\n$ go run rm.go 123\nremove 123: no such file or directory\n$ ls -l /tmp/AlTest1.err\n-rw-r--r--  1 root  wheel  1278 Apr 17 20:13 /tmp/AlTest1.err\n$ go run rm.go /tmp/AlTest1.err\nremove /tmp/AlTest1.err: permission denied\n$ go run rm.go test\nremove test: directory not empty\n```", "```go\npackage main \n\nimport ( \n   \"flag\" \n   \"fmt\" \n   \"os\" \n   \"path/filepath\" \n) \n\nfunc main() { \n   minusOverwrite := flag.Bool(\"overwrite\", false, \"overwrite\") \n\n   flag.Parse() \n   flags := flag.Args() \n\n   if len(flags) < 2 { \n         fmt.Println(\"Please provide two arguments!\") \n         os.Exit(1) \n   } \n```", "```go\n   source := flags[0] \n   destination := flags[1] \n   fileInfo, err := os.Stat(source) \n   if err == nil { \n         mode := fileInfo.Mode() \n         if mode.IsRegular() == false { \n               fmt.Println(\"Sorry, we only support regular files as source!\") \n               os.Exit(1) \n         } \n   } else { \n         fmt.Println(\"Error reading:\", source) \n         os.Exit(1) \n   } \n```", "```go\n   newDestination := destination \n   destInfo, err := os.Stat(destination) \n   if err == nil { \n         mode := destInfo.Mode() \n         if mode.IsDir() { \n               justTheName := filepath.Base(source) \n               newDestination = destination + \"/\" + justTheName \n         } \n   } \n```", "```go\n   destination = newDestination \n   destInfo, err = os.Stat(destination) \n   if err == nil { \n         if *minusOverwrite == false { \n               fmt.Println(\"Destination file already exists!\") \n               os.Exit(1) \n         } \n   } \n\n   err = os.Rename(source, destination) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n} \n```", "```go\n$ touch newFILE\n$ ./rename newFILE regExpFind.go\nDestination file already exists!\n$ ./rename -overwrite newFILE regExpFind.go\n$\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"path/filepath\" \n) \n```", "```go\nfunc walkFunction(path string, info os.FileInfo, err error) error { \n   _, err = os.Stat(path) \n   if err != nil { \n         return err \n   } \n\n   fmt.Println(path) \n   return nil \n} \n```", "```go\nfunc main() { \n   arguments := os.Args \n   if len(arguments) == 1 { \n         fmt.Println(\"Not enough arguments!\") \n         os.Exit(1) \n   } \n\n   Path := arguments[1] \n   err := filepath.Walk(Path, walkFunction) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n} \n```", "```go\n$ go run traverse.go ~/code/C/cUNL\n/home/mtsouk/code/C/cUNL\n/home/mtsouk/code/C/cUNL/gpp\n/home/mtsouk/code/C/cUNL/gpp.c\n/home/mtsouk/code/C/cUNL/sizeofint\n/home/mtsouk/code/C/cUNL/sizeofint.c\n/home/mtsouk/code/C/cUNL/speed\n/home/mtsouk/code/C/cUNL/speed.c\n/home/mtsouk/code/C/cUNL/swap\n/home/mtsouk/code/C/cUNL/swap.c\n```", "```go\nfunc walkFunction(path string, info os.FileInfo, err error) error { \n   fileInfo, err := os.Stat(path) \n   if err != nil { \n         return err \n   } \n\n   mode := fileInfo.Mode() \n   if mode.IsDir() { \n         fmt.Println(path) \n   } \n   return nil \n} \n```", "```go\n$ go run traverseDir.go ~/code\n/home/mtsouk/code\n/home/mtsouk/code/C\n/home/mtsouk/code/C/cUNL\n/home/mtsouk/code/C/example\n/home/mtsouk/code/C/sysProg\n/home/mtsouk/code/C/system\n/home/mtsouk/code/Haskell\n/home/mtsouk/code/aLink\n/home/mtsouk/code/perl\n/home/mtsouk/code/python  \n```", "```go\npackage main \n\nimport ( \n   \"flag\" \n   \"fmt\" \n   \"os\" \n   \"path/filepath\" \n) \n```", "```go\nfunc walkFunction(path string, info os.FileInfo, err error) error { \n\n   fileInfo, err := os.Stat(path) \n   if err != nil { \n         return err \n   } \n\n   mode := fileInfo.Mode() \n   if mode.IsDir() || mode.IsRegular() { \n         fmt.Println(path) \n   } \n   return nil \n} \n```", "```go\nfunc main() { \n   flag.Parse() \n   flags := flag.Args() \n\n   if len(flags) == 0 { \n         fmt.Println(\"Not enough arguments!\") \n         os.Exit(1) \n   } \n\n   Path := flags[0]\n\n   err := filepath.Walk(Path, walkFunction) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n} \n```", "```go\n$ go run find.go ~/code/C/cUNL\n/home/mtsouk/code/C/cUNL\n/home/mtsouk/code/C/cUNL/gpp\n/home/mtsouk/code/C/cUNL/gpp.c\n/home/mtsouk/code/C/cUNL/sizeofint\n/home/mtsouk/code/C/cUNL/sizeofint.c\n/home/mtsouk/code/C/cUNL/speed\n/home/mtsouk/code/C/cUNL/speed.c\n/home/mtsouk/code/C/cUNL/swap\n/home/mtsouk/code/C/cUNL/swap.c\n```", "```go\npackage main \n\nimport ( \n   \"flag\" \n   \"fmt\" \n   \"os\" \n   \"path/filepath\" \n) \n\nfunc main() { \n\n   minusS := flag.Bool(\"s\", false, \"Sockets\") \n   minusP := flag.Bool(\"p\", false, \"Pipes\") \n   minusSL := flag.Bool(\"sl\", false, \"Symbolic Links\") \n   minusD := flag.Bool(\"d\", false, \"Directories\") \n   minusF := flag.Bool(\"f\", false, \"Files\") \n\n   flag.Parse() \n   flags := flag.Args() \n\n   printAll := false \n   if *minusS && *minusP && *minusSL && *minusD && *minusF { \n         printAll = true \n   } \n\n   if !(*minusS || *minusP || *minusSL || *minusD || *minusF) { \n         printAll = true \n   } \n\n   if len(flags) == 0 { \n         fmt.Println(\"Not enough arguments!\") \n         os.Exit(1) \n   } \n\n   Path := flags[0] \n```", "```go\n   walkFunction := func(path string, info os.FileInfo, err error) error { \n         fileInfo, err := os.Stat(path) \n         if err != nil { \n               return err \n         } \n\n         if printAll { \n               fmt.Println(path) \n               return nil \n         } \n\n         mode := fileInfo.Mode() \n         if mode.IsRegular() && *minusF { \n               fmt.Println(path) \n               return nil \n         } \n\n         if mode.IsDir() && *minusD { \n               fmt.Println(path) \n               return nil \n         } \n\n         fileInfo, _ = os.Lstat(path)\n\n         if fileInfo.Mode()&os.ModeSymlink != 0 { \n               if *minusSL { \n                     fmt.Println(path) \n                     return nil \n               } \n         } \n\n         if fileInfo.Mode()&os.ModeNamedPipe != 0 { \n               if *minusP { \n                     fmt.Println(path) \n                     return nil \n               } \n         } \n\n         if fileInfo.Mode()&os.ModeSocket != 0 { \n               if *minusS { \n                     fmt.Println(path) \n                     return nil \n               } \n         } \n\n         return nil \n   } \n```", "```go\n   err := filepath.Walk(Path, walkFunction) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n} \n```", "```go\n$ go run improvedFind.go -d ~/code/C\n/home/mtsouk/code/C\n/home/mtsouk/code/C/cUNL\n/home/mtsouk/code/C/example\n/home/mtsouk/code/C/sysProg\n/home/mtsouk/code/C/system\n$ go run improvedFind.go -sl ~/code\n/home/mtsouk/code/aLink\n```", "```go\n$ diff excludeFind.go improvedFind.go\n10,19d9\n< func excludeNames(name string, exclude string) bool {`\n<     if exclude == \"\" {\n<           return false\n<     }\n<     if filepath.Base(name) == exclude {\n<           return true\n<     }\n<     return false\n< }\n<\n27d16\n<     minusX := flag.String(\"x\", \"\", \"Files\")\n54,57d42\n<           if excludeNames(path, *minusX) {\n<                 return nil\n<           }\n<\n```", "```go\n$ go run excludeFind.go -x=dT.py ~/code/python\n/home/mtsouk/code/python\n/home/mtsouk/code/python/dataFile.txt\n/home/mtsouk/code/python/python\n$ go run excludeFind.go ~/code/python\n/home/mtsouk/code/python\n/home/mtsouk/code/python/dT.py\n/home/mtsouk/code/python/dataFile.txt\n/home/mtsouk/code/python/python\n```", "```go\n$ diff finalFind.go excludeFind.go\n8d7\n<     \"strings\"\n21,34d19\n< func excludeExtensions(name string, extension string) bool {\n<     if extension == \"\" {\n<           return false\n<     }\n<     basename := filepath.Base(name)\n<     s := strings.Split(basename, \".\")\n<     length := len(s)\n<     basenameExtension := s[length-1]\n<     if basenameExtension == extension {\n<           return true\n<     }\n<     return false\n< }\n<\n43d27\n<     minusEXT := flag.String(\"ext\", \"\", \"Extensions\")\n74,77d57\n<           if excludeExtensions(path, *minusEXT) {\n<                 return nil\n<           }\n< \n```", "```go\n$ go run finalFind.go -ext=py ~/code/python\n/home/mtsouk/code/python\n/home/mtsouk/code/python/dataFile.txt\n/home/mtsouk/code/python/python\n$ go run finalFind.go ~/code/python\n/home/mtsouk/code/python\n/home/mtsouk/code/python/dT.py\n/home/mtsouk/code/python/dataFile.txt\n/home/mtsouk/code/python/python\n```", "```go\n$ diff regExpFind.go finalFind.go\n8d7\n<     \"regexp\"\n36,44d34\n< func regularExpression(path, regExp string) bool {\n<     if regExp == \"\" {\n<           return true\n<     }\n<     r, _ := regexp.Compile(regExp)\n<     matched := r.MatchString(path)\n<     return matched\n< }\n<\n54d43\n<     minusRE := flag.String(\"re\", \"\", \"Regular Expression\")\n71a61\n>\n75,78d64\n<           if regularExpression(path, *minusRE) == false {\n<                 return nil\n<           }\n< \n```", "```go\n$ go run regExpFind.go -re=anotherPackage /Users/mtsouk/go\n/Users/mtsouk/go/pkg/darwin_amd64/anotherPackage.a\n/Users/mtsouk/go/src/anotherPackage\n/Users/mtsouk/go/src/anotherPackage/anotherPackage.go\n$ go run regExpFind.go -ext=go -re=anotherPackage /Users/mtsouk/go\n/Users/mtsouk/go/pkg/darwin_amd64/anotherPackage.a\n/Users/mtsouk/go/src/anotherPackage \n```", "```go\n$ go run regExpFind.go /Users/mtsouk/go | grep anotherPackage\n/Users/mtsouk/go/pkg/darwin_amd64/anotherPackage.a\n/Users/mtsouk/go/src/anotherPackage\n/Users/mtsouk/go/src/anotherPackage/anotherPackage.go\n```", "```go\npackage main \n\nimport ( \n   \"flag\" \n   \"fmt\" \n   \"os\" \n   \"path/filepath\" \n   \"strings\" \n) \n```", "```go\nfunc main() { \n   minusTEST := flag.Bool(\"test\", false, \"Test run!\") \n\n   flag.Parse() \n   flags := flag.Args() \n\n   if len(flags) == 0 || len(flags) == 1 { \n         fmt.Println(\"Not enough arguments!\") \n         os.Exit(1) \n   } \n\n   Path := flags[0] \n   NewPath := flags[1] \n\n   permissions := os.ModePerm \n   _, err := os.Stat(NewPath) \n   if os.IsNotExist(err) { \n         os.MkdirAll(NewPath, permissions) \n   } else { \n         fmt.Println(NewPath, \"already exists - quitting...\") \n         os.Exit(1) \n   } \n```", "```go\n   walkFunction := func(currentPath string, info os.FileInfo, err error) error { \n         fileInfo, _ := os.Lstat(currentPath) \n         if fileInfo.Mode()&os.ModeSymlink != 0 { \n               fmt.Println(\"Skipping\", currentPath) \n               return nil \n         } \n\n         fileInfo, err = os.Stat(currentPath) \n         if err != nil { \n               fmt.Println(\"*\", err) \n               return err \n         } \n\n         mode := fileInfo.Mode() \n         if mode.IsDir() { \n               tempPath := strings.Replace(currentPath, Path, \"\", 1) \n               pathToCreate := NewPath + \"/\" + filepath.Base(Path) + tempPath \n\n               if *minusTEST { \n                     fmt.Println(\":\", pathToCreate) \n                     return nil \n               } \n\n               _, err := os.Stat(pathToCreate) \n               if os.IsNotExist(err) { \n                     os.MkdirAll(pathToCreate, permissions) \n               } else { \n                     fmt.Println(\"Did not create\", pathToCreate, \":\", err) \n               } \n         } \n         return nil \n   } \n```", "```go\n   err = filepath.Walk(Path, walkFunction) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n} \n```", "```go\n$ go run cpStructure.go ~/code /tmp/newCode\nSkipping /home/mtsouk/code/aLink\n$ ls -l /home/mtsouk/code/aLink\nlrwxrwxrwx 1 mtsouk mtsouk 14 Apr 21 18:10 /home/mtsouk/code/aLink -> /usr/local/bin \n```"]