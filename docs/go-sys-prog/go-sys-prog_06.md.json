["```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"io/ioutil\" \n   \"os\" \n) \n```", "```go\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Println(\"Please provide a filename\") \n         os.Exit(1) \n   } \n   filename := os.Args[1] \n\n   aByteSlice := []byte(\"Mihalis Tsoukalos!\\n\") \n   ioutil.WriteFile(filename, aByteSlice, 0644) \n```", "```go\n   f, err := os.Open(filename) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n   defer f.Close() \n\n   anotherByteSlice := make([]byte, 100) \n   n, err := f.Read(anotherByteSlice) \n   fmt.Printf(\"Read %d bytes: %s\", n, anotherByteSlice)\n\n} \n```", "```go\n$ go run byteSlice.go usingByteSlices\nRead 19 bytes: Mihalis Tsoukalos!\n```", "```go\n$ wc usingByteSlices\n   1   2  19 usingByteSlices\n```", "```go\npackage main \n\nimport ( \n   \"bytes\" \n   \"encoding/binary\" \n   \"fmt\" \n   \"os\" \n   \"strconv\" \n) \n\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Println(\"Please provide an integer\") \n         os.Exit(1) \n   } \n   aNumber, _ := strconv.ParseInt(os.Args[1], 10, 64) \n```", "```go\n   buf := new(bytes.Buffer) \n   err := binary.Write(buf, binary.LittleEndian, aNumber) \n   if err != nil { \n         fmt.Println(\"Little Endian:\", err) \n   } \n\n   fmt.Printf(\"%d is %x in Little Endian\\n\", aNumber, buf) \n   buf.Reset() \n   err = binary.Write(buf, binary.BigEndian, aNumber)\n\n   if err != nil { \n         fmt.Println(\"Big Endian:\", err) \n   } \n   fmt.Printf(\"And %x in Big Endian\\n\", buf) \n} \n```", "```go\n$ go run readBinary.go 1\n1 is 0100000000000000 in Little Endian\nAnd 0000000000000001 in Big Endian\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"io\" \n   \"os\" \n) \n```", "```go\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Println(\"Please provide a filename\") \n         os.Exit(1) \n   } \n\n   filename := os.Args[1] \n   f, err := os.Open(filename) \n   if err != nil { \n         fmt.Printf(\"error opening %s: %s\", filename, err) \n         os.Exit(1) \n   } \n   defer f.Close() \n```", "```go\n   buf := make([]byte, 8) \n   if _, err := io.ReadFull(f, buf); err != nil { \n         if err == io.EOF { \n               err = io.ErrUnexpectedEOF \n         } \n   } \n   io.WriteString(os.Stdout, string(buf)) \n   fmt.Println() \n} \n```", "```go\n$ go run usingIO.go usingByteSlices\nMihalis\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"os\" \n) \n```", "```go\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Println(\"Please provide a filename\") \n         os.Exit(1) \n   } \n\n   filename := os.Args[1] \n```", "```go\n   f, err := os.Open(filename) \n   if err != nil { \n         fmt.Printf(\"error opening %s: %s\", filename, err) \n         os.Exit(1) \n   } \n   defer f.Close() \n\n   scanner := bufio.NewScanner(f) \n```", "```go\n   for scanner.Scan() { \n         line := scanner.Text() \n\n         if scanner.Err() != nil { \n               fmt.Printf(\"error reading file %s\", err) \n               os.Exit(1) \n         } \n         fmt.Println(line) \n   } \n}\n\n```", "```go\n$ go run bufIO.go inputFile | wc\n      11      12      62\n$ wc inputFile\n      11      12      62 inputFile\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n) \n```", "```go\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Println(\"Please provide a filename\") \n         os.Exit(1) \n   } \n\n   filename := os.Args[1] \n   destination, err := os.Create(filename) \n   if err != nil { \n         fmt.Println(\"os.Create:\", err) \n         os.Exit(1) \n   } \n   defer destination.Close() \n```", "```go\n   fmt.Fprintf(destination, \"[%s]: \", filename) \n   fmt.Fprintf(destination, \"Using fmt.Fprintf in %s\\n\", filename) \n} \n```", "```go\n$ go run fmtF.go test\n$ cat test\n[test]: Using fmt.Fprintf in test \n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"io\" \n   \"os\" \n) \n```", "```go\nfunc countChars(r io.Reader) int { \n   buf := make([]byte, 16) \n   total := 0 \n   for { \n         n, err := r.Read(buf) \n         if err != nil && err != io.EOF { \n               return 0 \n         } \n         if err == io.EOF { \n               break \n         } \n         total = total + n \n   } \n   return total \n} \n```", "```go\nfunc writeNumberOfChars(w io.Writer, x int) { \n   fmt.Fprintf(w, \"%d\\n\", x) \n} \n```", "```go\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Println(\"Please provide a filename\") \n         os.Exit(1) \n   } \n\n   filename := os.Args[1] \n   _, err := os.Stat(filename)\n\n   if err != nil { \n         fmt.Printf(\"Error on file %s: %s\\n\", filename, err) \n         os.Exit(1) \n   } \n\n   f, err := os.Open(filename) \n   if err != nil { \n         fmt.Println(\"Cannot open file:\", err) \n         os.Exit(-1) \n   } \n   defer f.Close() \n\n   chars := countChars(f) \n   filename = filename + \".Count\" \n   f, err = os.Create(filename) \n   if err != nil { \n         fmt.Println(\"os.Create:\", err) \n         os.Exit(1) \n   } \n   defer f.Close() \n   writeNumberOfChars(f, chars) \n} \n```", "```go\n$ go run readerWriter.go /tmp/swtag.log\n$ wc /tmp/swtag.log\n     119     635    7780 /tmp/swtag.log\n$ cat /tmp/swtag.log.Count\n7780\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"flag\" \n   \"fmt\" \n   \"io\" \n   \"os\" \n   \"strings\" \n) \n```", "```go\nfunc main() { \n   minusCOL := flag.Int(\"COL\", 1, \"Column\") \n   flag.Parse() \n   flags := flag.Args() \n\n   if len(flags) == 0 { \n         fmt.Printf(\"usage: readColumn <file1> [<file2> [... <fileN]]\\n\") \n         os.Exit(1) \n   } \n\n   column := *minusCOL \n\n   if column < 0 { \n         fmt.Println(\"Invalid Column number!\") \n         os.Exit(1) \n   } \n```", "```go\n   for _, filename := range flags { \n         fmt.Println(\"\\t\\t\", filename) \n         f, err := os.Open(filename) \n         if err != nil { \n               fmt.Printf(\"error opening file %s\", err) \n               continue \n         } \n         defer f.Close() \n\n         r := bufio.NewReader(f)\n\n         for { \n               line, err := r.ReadString('\\n') \n\n               if err == io.EOF { \n                     break \n               } else if err != nil { \n                     fmt.Printf(\"error reading file %s\", err) \n               } \n\n               data := strings.Fields(line) \n               if len(data) >= column { \n                     fmt.Println((data[column-1])) \n               } \n         } \n   } \n} \n```", "```go\n$ go run readColumn.go -COL=3 pF.data isThereAFile up.data\n            pF.data\n            isThereAFile\nerror opening file open isThereAFile: no such file or directory\n            up.data\n0.05\n0.05\n0.05\n0.05\n0.05\n0.05\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"io\" \n   \"os\" \n) \n```", "```go\nfunc Copy(src, dst string) (int64, error) { \n   sourceFileStat, err := os.Stat(src) \n   if err != nil { \n         return 0, err \n   } \n\n   if !sourceFileStat.Mode().IsRegular() { \n         return 0, fmt.Errorf(\"%s is not a regular file\", src) \n   } \n\n   source, err := os.Open(src) \n   if err != nil { \n         return 0, err \n   } \n   defer source.Close() \n\n   destination, err := os.Create(dst) \n   if err != nil { \n         return 0, err \n   } \n   defer destination.Close() \n   nBytes, err := io.Copy(destination, source) \n   return nBytes, err \n\n}\n\n```", "```go\nfunc main() { \n   if len(os.Args) != 3 { \n         fmt.Println(\"Please provide two command line arguments!\") \n         os.Exit(1) \n   } \n\n   sourceFile := os.Args[1] \n   destinationFile := os.Args[2] \n   nBytes, err := Copy(sourceFile, destinationFile) \n\n   if err != nil { \n         fmt.Printf(\"The copy operation failed %q\\n\", err) \n   } else { \n         fmt.Printf(\"Copied %d bytes!\\n\", nBytes) \n   } \n} \n```", "```go\n$ go run notGoodCP.go testFile aCopy\nCopied 871 bytes!\n$ diff aCopy testFile\n$ wc testFile aCopy\n      51     127     871 testFile\n      51     127     871 aCopy\n     102     254    1742 total\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"io/ioutil\" \n   \"os\" \n) \n```", "```go\nfunc main() { \n   if len(os.Args) != 3 { \n         fmt.Println(\"Please provide two command line arguments!\") \n         os.Exit(1) \n   } \n\n   sourceFile := os.Args[1] \n   destinationFile := os.Args[2] \n```", "```go\n   input, err := ioutil.ReadFile(sourceFile) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n\n   err = ioutil.WriteFile(destinationFile, input, 0644) \n   if err != nil { \n         fmt.Println(\"Error creating the new file\", destinationFile) \n         fmt.Println(err) \n         os.Exit(1) \n   } \n} \n```", "```go\n$ go run readAll.go testFile aCopy\n$ diff aCopy testFile\n$ ls -l testFile aCopy\n-rw-r--r--  1 mtsouk  staff  871 May  3 21:07 aCopy\n-rw-r--r--@ 1 mtsouk  staff  871 May  3 21:04 testFile\n$ go run readAll.go doesNotExist aCopy\nopen doesNotExist: no such file or directory\nexit status 1\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"io\" \n   \"os\" \n   \"path/filepath\" \n   \"strconv\" \n) \n\nvar BUFFERSIZE int64 \n```", "```go\nfunc Copy(src, dst string, BUFFERSIZE int64) error { \n   sourceFileStat, err := os.Stat(src) \n   if err != nil { \n         return err \n   } \n\n   if !sourceFileStat.Mode().IsRegular() { \n         return fmt.Errorf(\"%s is not a regular file.\", src) \n   } \n\n   source, err := os.Open(src) \n   if err != nil { \n         return err \n   } \n   defer source.Close() \n```", "```go\n   _, err = os.Stat(dst) \n   if err == nil { \n         return fmt.Errorf(\"File %s already exists.\", dst) \n   } \n\n   destination, err := os.Create(dst) \n   if err != nil { \n         return err \n   } \n   defer destination.Close() \n\n   if err != nil { \n         panic(err) \n   } \n\n   buf := make([]byte, BUFFERSIZE) \n   for { \n         n, err := source.Read(buf) \n         if err != nil && err != io.EOF { \n               return err \n         } \n         if n == 0 { \n               break \n         } \n\n         if _, err := destination.Write(buf[:n]); err != nil { \n               return err \n         } \n   } \n   return err \n} \n```", "```go\nfunc main() { \n   if len(os.Args) != 4 { \n         fmt.Printf(\"usage: %s source destination BUFFERSIZE\\n\", \nfilepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n\n   source := os.Args[1] \n   destination := os.Args[2] \n   BUFFERSIZE, _ = strconv.ParseInt(os.Args[3], 10, 64) \n```", "```go\n   fmt.Printf(\"Copying %s to %s\\n\", source, destination) \n   err := Copy(source, destination, BUFFERSIZE) \n   if err != nil { \n         fmt.Printf(\"File copying failed: %q\\n\", err) \n   } \n}\n\n```", "```go\n$ go run cp.go inputFile aCopy 2048\nCopying inputFile to aCopy\n$ diff inputFile aCopy\n```", "```go\n$ go run cp.go A /tmp/myCP 1024\nCopying A to /tmp/myCP\nFile copying failed: \"stat A: no such file or directory\"\n```", "```go\n$ go run cp.go inputFile /tmp/myCP 1024\nCopying inputFile to /tmp/myCP\nFile copying failed: \"open inputFile: permission denied\"\n```", "```go\n$ go run cp.go inputFile /usr/myCP 1024\nCopying inputFile to /usr/myCP\nFile copying failed: \"open /usr/myCP: operation not permitted\"\n```", "```go\n$ go run cp.go inputFile outputFile 1024\nCopying inputFile to outputFile\nFile copying failed: \"File outputFile already exists.\"\n```", "```go\n$dd if=/dev/urandom of=100MB count=100000 bs=1024\n100000+0 records in\n100000+0 records out\n102400000 bytes transferred in 6.800277 secs (15058210 bytes/sec)\n$ dd if=/dev/urandom of=1GB count=1000000 bs=1024\n1000000+0 records in\n1000000+0 records out\n1024000000 bytes transferred in 68.887482 secs (14864820 bytes/sec)\n$ dd if=/dev/urandom of=5GB count=5000000 bs=1024\n5000000+0 records in\n5000000+0 records out\n5120000000 bytes transferred in 339.357738 secs (15087324 bytes/sec)\n$ ls -l 100MB 1GB 5GB\n-rw-r--r--  1 mtsouk  staff   102400000 May  4 10:30 100MB\n-rw-r--r--  1 mtsouk  staff  1024000000 May  4 10:32 1GB\n-rw-r--r--  1 mtsouk  staff  5120000000 May  4 10:38 5GB\n```", "```go\n$ time ./notGoodCP 100MB copy\nCopied 102400000 bytes!\n\nreal  0m0.153s\nuser  0m0.003s\nsys   0m0.084s\n$ time ./notGoodCP 1GB copy\nCopied 1024000000 bytes!\n\nreal  0m1.461s\nuser  0m0.029s\nsys   0m0.833s\n$ time ./notGoodCP 5GB copy\nCopied 5120000000 bytes!\n\nreal  0m12.193s\nuser  0m0.161s\nsys   0m5.251s\n$ time ./readAll 100MB copy\n\nreal  0m0.249s\nuser  0m0.003s\nsys   0m0.138s\n$ time ./readAll 1GB copy\n\nreal  0m3.117s\nuser  0m0.639s\nsys   0m1.644s\n$ time ./readAll 5GB copy\n\nreal  0m28.918s\nuser  0m8.106s\nsys   0m21.364s\n```", "```go\n$ time ./cp 100MB copy 16\nCopying 100MB to copy\n\nreal  0m13.240s\nuser  0m2.699s\nsys   0m10.530s\n$ time ./cp 100MB copy 1024\nCopying 100MB to copy\n\nreal  0m0.386s\nuser  0m0.053s\nsys   0m0.303s\n$ time ./cp 100MB copy 1048576\nCopying 100MB to copy\n\nreal  0m0.135s\nuser  0m0.001s\nsys   0m0.075s\n$ time ./cp 100MB copy 1073741824\nCopying 100MB to copy\n\nreal  0m0.390s\nuser  0m0.011s\nsys   0m0.136s\n```", "```go\n$ time ./cp 1GB copy 16\nCopying 1GB to copy\n\nreal  2m10.054s\nuser  0m26.497s\nsys   1m43.411s\n$ time ./cp 1GB copy 1024\nCopying 1GB to copy\n\nreal  0m3.520s\nuser  0m0.533s\nsys   0m2.944s\n$ time ./cp 1GB copy 1048576\nCopying 1GB to copy\n\nreal  0m1.431s\nuser  0m0.006s\nsys   0m0.749s\n$ time ./cp 1GB copy 1073741824\nCopying 1GB to copy\n\nreal  0m2.033s\nuser  0m0.012s\nsys   0m1.310s\n```", "```go\n$ time ./cp 5GB copy 16\nCopying 5GB to copy\n\nreal  10m41.551s\nuser  2m11.695s\nsys   8m29.248s\n$ time ./cp 5GB copy 1024\nCopying 5GB to copy\n\nreal  0m16.558s\nuser  0m2.415s\nsys   0m13.597s\n$ time ./cp 5GB copy 1048576\nCopying 5GB to copy\n\nreal  0m7.172s\nuser  0m0.028s\nsys   0m3.734s\n$ time ./cp 5GB copy 1073741824\nCopying 5GB to copy\n\nreal  0m8.612s\nuser  0m0.011s\nsys   0m4.536s\n```", "```go\n$ time cp 100MB copy\n\nreal  0m0.274s\nuser  0m0.002s\nsys   0m0.105s\n$ time cp 1GB copy\n\nreal  0m2.735s\nuser  0m0.003s\nsys   0m1.014s\n$ time cp 5GB copy\n\nreal  0m12.199s\nuser  0m0.012s\nsys   0m5.050s\n```", "```go\n$ wc wc.go cp.go\n      68     160    1231 wc.go\n      45     112     755 cp.go\n     113     272    1986 total\n```", "```go\nr := regexp.MustCompile(\"[^\\\\s]+\") \nfor range r.FindAllString(line, -1) { \nnumberOfWords++ \n} \n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"flag\" \n   \"fmt\" \n   \"io\" \n   \"os\" \n   \"regexp\" \n) \n```", "```go\nfunc countLines(filename string) (int, int, int) { \n   var err error \n   var numberOfLines int \n   var numberOfCharacters int \n   var numberOfWords int \n   numberOfLines = 0\n\n   numberOfCharacters = 0 \n   numberOfWords = 0 \n\n   f, err := os.Open(filename) \n   if err != nil { \n         fmt.Printf(\"error opening file %s\", err) \n         os.Exit(1) \n   } \n   defer f.Close() \n\n   r := bufio.NewReader(f) \n   for { \n         line, err := r.ReadString('\\n') \n\n         if err == io.EOF { \n               break \n         } else if err != nil { \n               fmt.Printf(\"error reading file %s\", err)\n                break \n         } \n\n         numberOfLines++ \n         r := regexp.MustCompile(\"[^\\\\s]+\") \n         for range r.FindAllString(line, -1) { \n               numberOfWords++ \n         } \n         numberOfCharacters += len(line) \n   } \n\n   return numberOfLines, numberOfWords, numberOfCharacters \n} \n```", "```go\nfunc main() { \n   minusC := flag.Bool(\"c\", false, \"Characters\") \n   minusW := flag.Bool(\"w\", false, \"Words\") \n   minusL := flag.Bool(\"l\", false, \"Lines\") \n\n   flag.Parse() \n   flags := flag.Args() \n\n   if len(flags) == 0 { \n         fmt.Printf(\"usage: wc <file1> [<file2> [... <fileN]]\\n\") \n         os.Exit(1) \n   } \n\n   totalLines := 0 \n   totalWords := 0 \n   totalCharacters := 0 \n   printAll := false \n\n   for _, filename := range flag.Args() { \n```", "```go\n         numberOfLines, numberOfWords, numberOfCharacters := countLines(filename) \n\n         totalLines = totalLines + numberOfLines \n         totalWords = totalWords + numberOfWords \n         totalCharacters = totalCharacters + numberOfCharacters \n\n         if (*minusC && *minusW && *minusL) || (!*minusC && !*minusW && !*minusL) { \n               fmt.Printf(\"%d\", numberOfLines) \n               fmt.Printf(\"\\t%d\", numberOfWords) \n               fmt.Printf(\"\\t%d\", numberOfCharacters) \n               fmt.Printf(\"\\t%s\\n\", filename) \n               printAll = true \n               continue \n         } \n\n         if *minusL { \n               fmt.Printf(\"%d\", numberOfLines) \n         } \n\n         if *minusW { \n               fmt.Printf(\"\\t%d\", numberOfWords) \n         } \n\n         if *minusC { \n               fmt.Printf(\"\\t%d\", numberOfCharacters) \n         } \n\n         fmt.Printf(\"\\t%s\\n\", filename) \n   } \n```", "```go\n   if (len(flags) != 1) && printAll { \n         fmt.Printf(\"%d\", totalLines) \n         fmt.Printf(\"\\t%d\", totalWords) \n         fmt.Printf(\"\\t%d\", totalCharacters) \n         fmt.Println(\"\\ttotal\") \nreturn \n   } \n\n   if (len(flags) != 1) && *minusL { \n         fmt.Printf(\"%d\", totalLines) \n   } \n\n   if (len(flags) != 1) && *minusW { \n         fmt.Printf(\"\\t%d\", totalWords) \n   } \n\n   if (len(flags) != 1) && *minusC { \n         fmt.Printf(\"\\t%d\", totalCharacters) \n   } \n\n   if len(flags) != 1 { \n         fmt.Printf(\"\\ttotal\\n\") \n   } \n} \n```", "```go\n$ go build wc.go\n$ ls -l wc\n-rwxr-xr-x  1 mtsouk  staff  2264384 Apr 29 21:10 wc\n$ ./wc wc.go sparse.go notGoodCP.go\n120   280   2319  wc.go\n44    98    697   sparse.go\n27    61    418   notGoodCP.go\n191   439   3434  total\n$ ./wc -l wc.go sparse.go\n120   wc.go\n44    sparse.go\n164   total\n$ ./wc -w -l wc.go sparse.go\n120   280   wc.go\n44    98    sparse.go\n164   378   total\n```", "```go\n$ go run wc.go sparse.go\n# command-line-arguments\n./sparse.go:11: main redeclared in this block\n      previous declaration at ./wc.go:49\n$ go run wc.go wc.go\npackage main: case-insensitive file name collision:\n\"wc.go\" and \"wc.go\"\n$ go run wc.go cp.go sparse.go\n# command-line-arguments\n./cp.go:35: main redeclared in this block\n      previous declaration at ./wc.go:49\n./sparse.go:11: main redeclared in this block\n      previous declaration at ./cp.go:35\n```", "```go\n$ go version\ngo version go1.3.3 linux/amd64\n$ go run wc.go\n# command-line-arguments\n./wc.go:40: syntax error: unexpected range, expecting {\n./wc.go:46: non-declaration statement outside function body\n./wc.go:47: syntax error: unexpected }\n```", "```go\n$ file wc\nwc: Mach-O 64-bit executable x86_64\n$ time ./wc *.data\n672320      3361604     9413057     connections.data\n269123      807369      4157790     diskSpace.data\n672040      1344080     8376070     memory.data\n1344533     2689066     5378132     pageFaults.data\n269465      792715      4068250     uptime.data\n3227481     8994834     31393299    total\n\nreal  0m17.467s\nuser  0m22.164s\nsys   0m3.885s\n```", "```go\n$ file `which wc`\n/usr/bin/wc: Mach-O 64-bit executable x86_64\n$ time wc *.data\n672320 3361604 9413057 connections.data\n269123  807369 4157790 diskSpace.data\n672040 1344080 8376070 memory.data\n1344533 2689066 5378132 pageFaults.data\n269465  792715 4068250 uptime.data\n3227481 8994834 31393299 total\n\nreal  0m0.086s\nuser  0m0.076s\nsys   0m0.007s\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"io/ioutil\" \n   \"os\" \n   \"strings\" \n) \n```", "```go\nfunc main() { \n   arguments := os.Args \n   if len(arguments) == 1 { \n         fmt.Println(\"Not enough arguments!\") \n         os.Exit(1) \n   } \n   input := arguments[1] \n```", "```go\n   buf, err := ioutil.ReadFile(input) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n```", "```go\n   in := string(buf) \n   s := bufio.NewScanner(strings.NewReader(in)) \n   s.Split(bufio.ScanRunes) \n\n   for s.Scan() { \n         fmt.Print(s.Text()) \n   } \n} \n```", "```go\n$ go run charByChar.go test\npackage main\n...\n```", "```go\n$ go run charByChar.go test | wc\n      32      54     439\n$ wc test\n      32      54     439 test\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"io\" \n   \"os\" \n   \"path/filepath\" \n   \"strings\" \n) \n```", "```go\nfunc main() { \n   if len(os.Args) != 3 { \n         fmt.Printf(\"Usage: %s [-t|-s] filename!\\n\", filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n   convertTabs := false \n   convertSpaces := false \n   newLine := \"\" \n\n   option := os.Args[1] \n   filename := os.Args[2] \n   if option == \"-t\" { \n         convertTabs = true \n   } else if option == \"-s\" { \n         convertSpaces = true \n   } else { \n         fmt.Println(\"Unknown option!\") \n         os.Exit(1) \n   } \n```", "```go\n   f, err := os.Open(filename) \n   if err != nil { \n         fmt.Printf(\"error opening %s: %s\", filename, err) \n         os.Exit(1) \n   } \n   defer f.Close() \n\n   r := bufio.NewReader(f) \n   for { \n         line, err := r.ReadString('\\n') \n\n         if err == io.EOF { \n               break \n         } else if err != nil { \n               fmt.Printf(\"error reading file %s\", err) \n               os.Exit(1) \n         } \n```", "```go\n         if convertTabs == true { \n               newLine = strings.Replace(line, \"\\t\", \"    \", -1) \n         } else if convertSpaces == true { \n               newLine = strings.Replace(line, \"    \", \"\\t\", -1) \n         } \n\n         fmt.Print(newLine) \n   } \n} \n```", "```go\n$ go run tabSpace.go -t cp.go > convert\n$ wc convert cp.go\n    76     192    1517 convert \n      76     192    1286 cp.go\n     152     384    2803 total\n$ go run tabSpace.go -s convert | wc\n      76     192    1286\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"log\" \n   \"os\" \n   \"path/filepath\" \n   \"strconv\" \n) \n```", "```go\nfunc main() { \n   if len(os.Args) != 3 { \n         fmt.Printf(\"usage: %s SIZE filename\\n\", filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n\n   SIZE, _ := strconv.ParseInt(os.Args[1], 10, 64) \n   filename := os.Args[2] \n\n   _, err := os.Stat(filename) \n   if err == nil { \n         fmt.Printf(\"File %s already exists.\\n\", filename) \n         os.Exit(1) \n   } \n```", "```go\n   fd, err := os.Create(filename) \n   if err != nil { \n         log.Fatal(\"Failed to create output\") \n   } \n\n   _, err = fd.Seek(SIZE-1, 0) \n   if err != nil { \n         fmt.Println(err) \n         log.Fatal(\"Failed to seek\") \n   } \n\n   _, err = fd.Write([]byte{0}) \n   if err != nil { \n         fmt.Println(err) \n         log.Fatal(\"Write operation failed\") \n   } \n\n   err = fd.Close() \n   if err != nil { \n         fmt.Println(err) \n         log.Fatal(\"Failed to close file\") \n   } \n} \n```", "```go\n$ go run sparse.go 1000 test\n$ go run sparse.go 1000 test\nFile test already exists.\nexit status 1\n```", "```go\n$ go run sparse.go 100000 testSparse $ dd if=/dev/urandom  bs=1 count=100000 of=noSparseDD\n100000+0 records in\n100000+0 records out\n100000 bytes (100 kB) copied, 0.152511 s, 656 kB/s\n$ dd if=/dev/urandom seek=100000 bs=1 count=0 of=sparseDD\n0+0 records in\n0+0 records out\n0 bytes (0 B) copied, 0.000159399 s, 0.0 kB/s\n$ ls -l noSparseDD sparseDD testSparse\n-rw-r--r-- 1 mtsouk mtsouk 100000 Apr 29 21:43 noSparseDD\n-rw-r--r-- 1 mtsouk mtsouk 100000 Apr 29 21:43 sparseDD\n-rw-r--r-- 1 mtsouk mtsouk 100000 Apr 29 21:40 testSparse\n```", "```go\n$ ls -ls noSparseDD sparseDD testSparse\n104 -rw-r--r-- 1 mtsouk mtsouk 100000 Apr 29 21:43 noSparseDD\n      0 -rw-r--r-- 1 mtsouk mtsouk 100000 Apr 29 21:43 sparseDD\n      8 -rw-r--r-- 1 mtsouk mtsouk 100000 Apr 29 21:40 testSparse\n```", "```go\npackage main \n\nimport ( \n   \"encoding/csv\" \n   \"fmt\" \n   \"os\" \n) \n```", "```go\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Println(\"Need just one filename!\") \n         os.Exit(-1) \n   } \n\n   filename := os.Args[1] \n   _, err := os.Stat(filename) \n   if err == nil { \n         fmt.Printf(\"File %s already exists.\\n\", filename) \n         os.Exit(1) \n   } \n```", "```go\n   output, err := os.Create(filename) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(-1) \n   } \n   defer output.Close() \n\n   inputData := [][]string{{\"M\", \"T\", \"I.\"}, {\"D\", \"T\", \"I.\"}, \n{\"M\", \"T\", \"D.\"}, {\"V\", \"T\", \"D.\"}, {\"A\", \"T\", \"D.\"}} \n   writer := csv.NewWriter(output) \n   for _, record := range inputData { \n         err := writer.Write(record) \n         if err != nil { \n               fmt.Println(err) \n               os.Exit(-1) \n         } \n   } \n   writer.Flush() \n```", "```go\n   f, err := os.Open(filename) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer f.Close() \n\n   reader := csv.NewReader(f) \n   reader.FieldsPerRecord = -1 \n   allRecords, err := reader.ReadAll() \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n\n   for _, rec := range allRecords { \n         fmt.Printf(\"%s:%s:%s\\n\", rec[0], rec[1], rec[2]) \n   } \n} \n```", "```go\n$ go run records.go recordsDataFile\nM:T:I. \nD:T:I.\nM:T:D.\nV:T:D.\nA:T:D.\n$ ls -l recordsDataFile\n-rw-r--r--  1 mtsouk  staff  35 May  2 19:20 recordsDataFile\n```", "```go\n$ cat recordsDataFile\nM,T,I.\nD,T,I.\nM,T,D.\nV,T,D.\nA,T,D.\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"math/rand\" \n   \"os\" \n   \"sync\" \n   \"time\" \n) \n\nvar mu sync.Mutex \n\nfunc random(min, max int) int { \n   return rand.Intn(max-min) + min \n} \n```", "```go\nfunc writeDataToFile(i int, file *os.File, w *sync.WaitGroup) { \n   mu.Lock() \n   time.Sleep(time.Duration(random(10, 1000)) * time.Millisecond) \n   fmt.Fprintf(file, \"From %d, writing %d\\n\", i, 2*i) \n   fmt.Printf(\"Wrote from %d\\n\", i) \n   w.Done() \nmu.Unlock() \n} \n```", "```go\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Println(\"Please provide one command line argument!\") \n         os.Exit(-1) \n   } \n\n   filename := os.Args[1] \n   number := 3 \n\n   file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n```", "```go\n   var w *sync.WaitGroup = new(sync.WaitGroup) \n   w.Add(number) \n\n   for r := 0; r < number; r++ { \n         go writeDataToFile(r, file, w) \n   } \n\n   w.Wait() \n} \n```", "```go\n$ go run fileLocking.go 123\nWrote from 0\nWrote from 2\nWrote from 1\n$ cat /tmp/swtag.log\nFrom 0, writing 0\nFrom 2, writing 4\nFrom 1, writing 2\n```", "```go\n$ go run fileLocking.go 123\nWrote from 2\nfatal error: all goroutines are asleep - deadlock!\n\ngoroutine 1 [semacquire]:\nsync.runtime_Semacquire(0xc42001024c)\n      /usr/local/Cellar/go/1.8.1/libexec/src/runtime/sema.go:47 +0x34\nsync.(*WaitGroup).Wait(0xc420010240)\n      /usr/local/Cellar/go/1.8.1/libexec/src/sync/waitgroup.go:131 +0x7a\nmain.main()\n     /Users/mtsouk/Desktop/goBook/ch/ch6/code/fileLocking.go:47 +0x172\n\ngoroutine 5 [semacquire]:\nsync.runtime_SemacquireMutex(0x112dcbc)\n     /usr/local/Cellar/go/1.8.1/libexec/src/runtime/sema.go:62 +0x34\nsync.(*Mutex).Lock(0x112dcb8)\n      /usr/local/Cellar/go/1.8.1/libexec/src/sync/mutex.go:87 +0x9d\nmain.writeDataToFile(0x0, 0xc42000c028, 0xc420010240)\n      /Users/mtsouk/Desktop/goBook/ch/ch6/code/fileLocking.go:18 +0x3f\ncreated by main.main\n      /Users/mtsouk/Desktop/goBook/ch/ch6/code/fileLocking.go:44 +0x151\n\ngoroutine 6 [semacquire]:\nsync.runtime_SemacquireMutex(0x112dcbc)\n      /usr/local/Cellar/go/1.8.1/libexec/src/runtime/sema.go:62 +0x34\nsync.(*Mutex).Lock(0x112dcb8)\n      /usr/local/Cellar/go/1.8.1/libexec/src/sync/mutex.go:87 +0x9d\nmain.writeDataToFile(0x1, 0xc42000c028, 0xc420010240)\n      /Users/mtsouk/Desktop/goBook/ch/ch6/code/fileLocking.go:18 +0x3f\ncreated by main.main\n    /Users/mtsouk/Desktop/goBook/ch/ch6/code/fileLocking.go:44 +0x151 exit status 2\n$ cat 123\nFrom 2, writing 4\n```", "```go\npackage main \n\nimport ( \n   \"flag\" \n   \"fmt\" \n   \"math/rand\" \n   \"os\" \n   \"time\" \n) \n```", "```go\nfunc random(min, max int) int { \n   return rand.Intn(max-min) + min \n} \n\nfunc createBytes(buf *[]byte, count int) { \n   if count == 0 { \n         return \n   } \n   for i := 0; i < count; i++ { \n         intByte := byte(random(0, 9)) \n         *buf = append(*buf, intByte) \n   } \n} \n```", "```go\nfunc main() { \n   minusBS := flag.Int(\"bs\", 0, \"Block Size\") \n   minusCOUNT := flag.Int(\"count\", 0, \"Counter\") \n   flag.Parse() \n   flags := flag.Args() \n\n   if len(flags) == 0 { \n         fmt.Println(\"Not enough arguments!\") \n         os.Exit(-1) \n   } \n\n   if *minusBS < 0 || *minusCOUNT < 0 { \n         fmt.Println(\"Count or/and Byte Size < 0!\") \n         os.Exit(-1) \n   } \n\n   filename := flags[0] \n   rand.Seed(time.Now().Unix()) \n\n   _, err := os.Stat(filename) \n   if err == nil { \n         fmt.Printf(\"File %s already exists.\\n\", filename) \n         os.Exit(1) \n   } \n\n   destination, err := os.Create(filename) \n   if err != nil { \n         fmt.Println(\"os.Create:\", err) \n         os.Exit(1) \n   } \n```", "```go\n   buf := make([]byte, *minusBS) \n   buf = nil \n   for i := 0; i < *minusCOUNT; i++ { \n         createBytes(&buf, *minusBS) \n         if _, err := destination.Write(buf); err != nil { \n               fmt.Println(err) \n               os.Exit(-1) \n         } \n         buf = nil \n   } \n} \n```", "```go\n$ time go run ddGo.go -bs=10000 -count=5000 test3\n\nreal  0m1.655s\nuser  0m1.576s\nsys   0m0.104s\n$ ls -l test3\n-rw-r--r--  1 mtsouk  staff  50000000 May  6 15:27 test3\n```", "```go\n$ go run ddGo.go -bs=100 -count=50 test1\n$ go run ddGo.go -bs=100 -count=50 test2\n$ ls -l test1 test2\n-rw-r--r--  1 mtsouk  staff  5000 May  6 15:26 test1\n-rw-r--r--  1 mtsouk  staff  5000 May  6 15:26 test2\n$ diff test1 test2\nBinary files test1 and test2 differ\n```"]