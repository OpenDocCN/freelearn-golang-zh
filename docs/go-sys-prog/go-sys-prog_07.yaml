- en: Working with System Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理系统文件
- en: In the previous chapter, we talked about file input and output in Go, and created
    Go versions of the `wc(1)`, `dd(1)`, and `cp(1)` utilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了在Go中的文件输入和输出，并创建了`wc(1)`、`dd(1)`和`cp(1)`实用程序的Go版本。
- en: While the main subject of this chapter is Unix system files and log files, you
    will also learn many other things, including pattern matching, file permissions,
    working with users and groups, and dealing with dates and times in Go. For all
    these subjects, you will see handy Go codes that will explain the presented techniques,
    and these can be used in your own Go programs without requiring too many changes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章的主要主题是Unix系统文件和日志文件，但你还将学到许多其他内容，包括模式匹配、文件权限、与用户和组的工作，以及在Go中处理日期和时间。对于所有这些主题，你将看到方便的Go代码，这些代码将解释所呈现的技术，并且可以在你自己的Go程序中使用，而不需要太多更改。
- en: 'So, this chapter will talk about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将讨论以下主题：
- en: Appending data to an existing file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向现有文件追加数据
- en: Reading a file and altering each one of its lines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件并修改每一行
- en: Regular expressions and pattern matching in Go
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中进行正则表达式和模式匹配
- en: Sending information to Unix log files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将信息发送到Unix日志文件
- en: Working with dates and times in Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中处理日期和时间
- en: Working with Unix file permissions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理Unix文件权限
- en: Working with user IDs and group IDs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户ID和组ID
- en: Learning more information about files and directories
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解有关文件和目录的更多信息
- en: Processing log files and extracting useful information from them
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理日志文件并从中提取有用信息
- en: Generating difficult to guess passwords using random numbers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用随机数生成难以猜测的密码
- en: Which files are considered system files?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哪些文件被视为系统文件？
- en: Each Unix operation system contains files that are responsible for the configuration
    of the system as well as its various services. Most of these files are located
    in the `/etc` directory. I also like to consider log files as system files, although
    some people might disagree. Usually, most system log files can be found inside
    `/var/log`. However, the log files of the Apache and the nginx web server can
    be found elsewhere, depending on their configuration.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Unix操作系统都包含负责系统配置和各种服务的文件。大多数这些文件位于`/etc`目录中。我也喜欢将日志文件视为系统文件，尽管有些人可能不同意。通常，大多数系统日志文件可以在`/var/log`目录中找到。然而，Apache和nginx
    web服务器的日志文件可能会根据其配置而放在其他位置。
- en: Logging in Go
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中记录
- en: The `log` package provides a general way to log information on your Unix machine,
    whereas the `log/syslog` Go package allows you to send information to the system
    logging service using the logging level and the logging facility you want. Also,
    the `time` package can help you work with dates and times.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`log`包提供了在Unix机器上记录信息的一般方法，而`log/syslog` Go包允许你使用所需的日志级别和日志设施将信息发送到系统日志服务。此外，`time`包可以帮助你处理日期和时间。'
- en: Putting data at the end of a file
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据放在文件末尾
- en: As discussed in [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml), *File
    Input and Output*, in this chapter, we will talk about opening a file for writing
    without destroying its existing data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第6章](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)中所讨论的*文件输入和输出*，在本章中，我们将讨论如何在不破坏现有数据的情况下打开文件进行写入。
- en: 'The Go program that will illustrate the technique, `appendData.go`, will accept
    two command-line arguments: the message you want to append and the name of the
    file that will store the text. This program will be presented in three parts.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将演示技术的Go程序`appendData.go`将接受两个命令行参数：要追加的消息和将存储文本的文件名。这个程序将分为三部分呈现。
- en: 'The first part of `appendData.go` contains the following Go code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`appendData.go`的第一部分包含以下Go代码：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As expected, the first part of the program contains the Go packages that will
    be used in the program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，程序的第一部分包含将在程序中使用的Go包。
- en: 'The second part is the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The desired task is done by the `os.O_APPEND` flag of the `os.OpenFile()` function
    that tells Go to write at the end of the file. Additionally, the `os.O_CREATE`
    flag will make `os.OpenFile()` to create the file if it does not exist, which
    is pretty handy because it saves you from having to write Go code that tests whether
    the file is already there or not.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.OpenFile()`函数的`os.O_APPEND`标志告诉Go在文件末尾进行写入。此外，`os.O_CREATE`标志将使`os.OpenFile()`在文件不存在时创建文件，这非常方便，因为它可以避免你编写测试文件是否已存在的Go代码。'
- en: 'The last part of the program is the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一部分如下：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `fmt.Fprintf()` function is used here in order to write the message to the
    file as plain text. As you can see, `appendData.go` is a relatively small Go program
    that does not contain any surprises.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Fprintf()`函数在这里用于将消息以纯文本形式写入文件。正如你所看到的，`appendData.go`是一个相对较小的Go程序，没有任何意外。'
- en: 'Executing `appendData.go` will create no output, but it will do its job, as
    you can see from the output of the `cat(1)` utility before and after the execution
    of `appendData.go`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`appendData.go`不会产生输出，但它会完成它的工作，你可以从`appendData.go`执行前后的`cat(1)`实用程序的输出中看到这一点：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Altering existing data
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改现有数据
- en: 'This section will teach you how to modify the contents of a file. The program
    that will be developed does a pretty convenient job: it adds a line number in
    front of each line of a text file. This means that you will need to read the input
    file line by line, keep a variable that will hold the line number value, and save
    it using the original name. Additionally, the initial value of the variable that
    holds the line number value can be defined when you start the program. The name
    of the Go program will be `insertLineNumber.go`, and it will be presented in four
    parts.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将教你如何修改文件的内容。将开发的程序将完成一个非常方便的工作：在文本文件的每一行前添加行号。这意味着你需要逐行读取输入文件，保持一个变量来保存行号值，并使用原始名称保存它。此外，保存行号值的变量的初始值可以在启动程序时定义。Go程序的名称将是`insertLineNumber.go`，它将分为四部分呈现。
- en: 'First, you will see the expected preamble:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会看到预期的序言：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second part is mainly the configuration of the `flag` package:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分主要是`flag`包的配置：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `lineNumber` variable is initiated by the value of the `minusINIT` flag.
    Additionally, the utility can process multiple files using a `for` loop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`lineNumber`变量由`minusINIT`标志的值初始化。此外，该实用程序可以使用`for`循环处理多个文件。'
- en: 'The third part of the program is the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分如下：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, `insertLineNumber.go` reads its input file all at once using
    `ioutil.ReadFile()`, which might not be so efficient when processing huge text
    files. However, with today's computers, this should not be a problem. A better
    approach would be to read the input file line by line, write each altered line
    to a temporary file, and then replace the original file with the temporary one.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`insertLineNumber.go`使用`ioutil.ReadFile()`一次性读取其输入文件，当处理大型文本文件时可能效率不高。但是，使用今天的计算机，这不应该是问题。更好的方法是逐行读取输入文件，将每个更改后的行写入临时文件，然后用临时文件替换原始文件。
- en: 'The last part of the utility is the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的最后部分如下：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As the `range` loop will introduce an extra line at the end of the file, you
    have to delete the last line in the lines slice using the `lines[len(lines)-1]
    = ""` statement, which means that the program assumes that all the files it processes
    end with a new line. If your text files do not do that, then you might want to
    change the code of `insertLineNumber.go` or add a new line at the end of your
    text files.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`range`循环会在文件末尾引入额外的一行，因此您必须使用`lines[len(lines)-1] = ""`语句删除行切片中的最后一行，这意味着程序假定它处理的所有文件都以换行符结尾。如果您的文本文件没有这样做，那么您可能需要更改`insertLineNumber.go`的代码或在文本文件末尾添加一个新行。
- en: 'The running of `insertLineNumber.go` generates no visible output apart from
    the filename of each file it processes and the total number of processed lines.
    However, you can see the results of its execution by looking at the contents of
    the files you processed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`insertLineNumber.go`除了处理的每个文件的文件名和处理的总行数之外，不会生成任何可见的输出。但是，您可以通过查看您处理的文件的内容来查看其执行的结果：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you try to process the same input file multiple times, as in the following
    example, an interesting thing will happen:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试多次处理相同的输入文件，如以下示例，将会发生有趣的事情：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: About log files
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于日志文件
- en: This part will teach you how to send information from a Go program to the logging
    service and therefore to system log files. Despite the obvious fact that it is
    good to keep information stored, log files are necessary for server processes
    because there is no other way for a server process to send information to the
    outside world, as it has no Terminal to send any output.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分将教您如何将信息从Go程序发送到日志服务，从而发送到系统日志文件。尽管保留信息很重要，但对于服务器进程来说，日志文件是必需的，因为服务器进程没有其他方式将信息发送到外部世界，因为它没有终端来发送任何输出。
- en: Log files are important and you should not underestimate the value of the information
    stored in them. Log files should be the first place to look for help when strange
    things start happening on a Unix machine.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件很重要，您不应该低估其中存储的信息的价值。当Unix机器上发生奇怪的事情时，日志文件应该是寻求帮助的第一地方。
- en: 'Generally speaking, using a log file is better than displaying the output on
    the screen for two reasons: first, the output does not get lost, as it is stored
    on a file, and second, you can search and process log files using Unix tools,
    such as `grep(1)`, `awk(1)`, and `sed(1)`, which cannot be done when messages
    are printed on a Terminal window.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用日志文件比在屏幕上显示输出更好，原因有两个：首先，输出不会丢失，因为它存储在文件中；其次，您可以使用Unix工具（如`grep(1)`、`awk(1)`和`sed(1)`）搜索和处理日志文件，而在终端窗口上打印消息时无法做到这一点。
- en: About logging
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于日志记录
- en: All Unix machines have a separate server process for logging log files. On macOS
    machines, the name of the process is `syslogd(8)`. On the other hand, most Linux
    machines use `rsyslogd(8)`, which is an improved and more reliable version of
    `syslogd(8)`, which was the original Unix system utility for message logging.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Unix机器都有一个单独的服务器进程用于记录日志文件。在macOS机器上，该进程的名称是`syslogd(8)`。另一方面，大多数Linux机器使用`rsyslogd(8)`，这是`syslogd(8)`的改进和更可靠的版本，后者是用于消息记录的原始Unix系统实用程序。
- en: However, despite the Unix variant you are using, or the name of the server process
    used for logging, logging works the same way on every Unix machine and therefore
    does not affect the Go code that you will write.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论您使用的Unix变体是什么，或者用于记录日志的服务器进程的名称是什么，日志记录在每台Unix机器上的工作方式都是相同的，因此不会影响您将编写的Go代码。
- en: The best way to watch one or more log files is with the help of the `tail(1)`
    utility, followed by the `-f` flag and the name of the log file you want to watch.
    The `-f` flag tells `tail(1)` to wait for additional data. You will need to terminate
    such a `tail(1)` command by pressing *Ctrl* + *C*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 观看一个或多个日志文件的最佳方法是使用`tail(1)`实用程序的帮助，后跟`-f`标志和您想要观看的日志文件的名称。`-f`标志告诉`tail(1)`等待额外的数据。您将需要通过按*Ctrl*
    + *C*来终止这样的`tail(1)`命令。
- en: Logging facilities
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志设施
- en: A logging facility is like a category used for logging information. The value
    of the logging facility part can be any one of *auth*, *authpriv*, *cron*, *daemon*,
    *kern*, *lpr*, *mail*, *mark*, *news*, *syslog*, *user*, *UUCP*, *local0*, *local1*,
    *local2*, *local3*, *local4*, *local5*, *local6*, and *local7*; this is defined
    inside `/etc/syslog.conf`, `/etc/rsyslog.conf`, or another appropriate file depending
    on the server process used for system logging on your Unix machine. This means
    that if a logging facility is not defined and therefore handled, the log messages
    you send to it might get lost.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 日志设施就像用于记录信息的类别。日志设施部分的值可以是`auth`、`authpriv`、`cron`、`daemon`、`kern`、`lpr`、`mail`、`mark`、`news`、`syslog`、`user`、`UUCP`、`local0`、`local1`、`local2`、`local3`、`local4`、`local5`、`local6`和`local7`中的任何一个；这在`/etc/syslog.conf`、`/etc/rsyslog.conf`或其他适当的文件中定义，具体取决于您的Unix机器上用于系统日志记录的服务器进程。这意味着如果未定义和处理日志设施，则您发送到其中的日志消息可能会丢失。
- en: Logging levels
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志级别
- en: A **logging level** or **priority** is a value that specifies the severity of
    the log entry. There exist various logging levels including *debug*, *info*, *notice*,
    *warning*, *err*, *crit*, *alert*, and *emerg,* in reverse order of severity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志级别**或**优先级**是指定日志条目严重性的值。存在各种日志级别，包括*debug*、*info*、*notice*、*warning*、*err*、*crit*、*alert*和*emerg*，按严重性的相反顺序。'
- en: Look at the `/etc/rsyslog.conf` file of a Linux machine to learn more about
    how to control logging facilities and logging levels.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Linux机器的`/etc/rsyslog.conf`文件，了解如何控制日志设施和日志级别。
- en: The syslog Go package
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: syslog Go包
- en: This subsection will present a Go program that works on all Unix machines and
    sends data to the logging service in various ways. The name of the program is
    `useSyslog.go`, and it will be presented in four parts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将介绍一个在所有Unix机器上运行并以各种方式向日志服务发送数据的Go程序。程序的名称是`useSyslog.go`，将分为四个部分。
- en: 'First, you will see the expected preamble:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将看到预期的序言：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You have to use the `log` package for logging and the `log/syslog` package for
    defining the logging facility and the logging level of your program.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须使用`log`包进行日志记录，使用`log/syslog`包定义程序的日志设施和日志级别。
- en: 'The second part is the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `syslog.New()` function call, which returns a writer, tells your program
    where to direct all log messages. The good thing is that you already know how
    to use a writer!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`syslog.New()`函数调用返回一个写入器，告诉您的程序将所有日志消息定向到何处。好消息是您已经知道如何使用写入器！'
- en: Note that the developer should define both the priority and the facility that
    a program uses.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，开发人员应定义程序使用的优先级和设施。
- en: However, even with a defined priority and facility, the `log/syslog` package
    allows you to send direct log messages to other priorities using functions such
    as `sysLog.Crit()`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使有了定义的优先级和设施，`log/syslog`包也允许您使用诸如`sysLog.Crit()`之类的函数将直接日志消息发送到其他优先级。
- en: 'The third part of the program is the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分如下：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This part shows that you can call `syslog.New()` multiple times in the same
    program. Once again, calling the `Emerg()` function allows you to bypass what
    was defined by the `syslog.New()` function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分显示您可以在同一个程序中多次调用`syslog.New()`。再次调用`Emerg()`函数允许您绕过`syslog.New()`函数定义的内容。
- en: 'The last part is the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分如下：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is the only call that uses the logging priority and the logging facility
    that were defined by `syslog.New()`, by directly writing to the `sysLog` writer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是唯一使用由`syslog.New()`定义的日志优先级和日志设施的调用，直接写入`sysLog`写入器。
- en: 'Executing `useLog.go` will generate some output on the screen, but it will
    also write data to the appropriate log files. On a macOS Sierra or a Mac OS X
    machine, you will see the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`useLog.go`将在屏幕上生成一些输出，但也会将数据写入适当的日志文件。在macOS Sierra或Mac OS X机器上，您将看到以下内容：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On a Debian Linux machine, you will see the following results:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian Linux机器上，您将看到以下结果：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output from the two machines shows that the Linux machine has a different
    `syslog` configuration, which is the reason that the messages from `useLog.go`
    were also written to `/var/log/cisco.log`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 两台机器的输出显示，Linux机器具有不同的`syslog`配置，这就是`useLog.go`的消息也被写入`/var/log/cisco.log`的原因。
- en: However, your main concern should not be whether the log messages will be written
    to too many files or not; rather if you will be able to find them or not!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您的主要关注点不应该是日志消息是否会被写入太多文件，而是您是否能够找到它们！
- en: Processing log files
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理日志文件
- en: 'This subsection will process a log file that contains client IP addresses in
    order to create a summary of them. The name of the Go file will be `countIP.go`,
    and it will be presented in four parts. Note that `countIP.go` requires two parameters:
    the name of the log file and the field that contains the desired information.
    As `countIP.go` does not check whether the given field contains an IP address
    or not, it can also be used for other kinds of data if you remove some of its
    code.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将处理一个包含客户端IP地址的日志文件，以创建它们的摘要。Go文件的名称将是`countIP.go`，并将分为四个部分呈现。请注意，`countIP.go`需要两个参数：日志文件的名称和包含所需信息的字段。由于`countIP.go`不检查给定字段是否包含IP地址，因此如果删除其中的一些代码，它也可以用于其他类型的数据。
- en: 'First, you will see the expected preamble of the program:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将看到程序的预期序言：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second part comes with the following Go code, which is the beginning of
    the implementation of the `main()` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分带有以下Go代码，这是`main()`函数实现的开始：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `countIP.go` utility uses the `flag` package and can process multiple files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`countIP.go`实用程序使用`flag`包，可以处理多个文件。'
- en: 'The third part of the program is the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分如下：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each input file is read line by line, whereas the `myIPs` map variable is used
    for holding the count of each IP address.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输入文件都是逐行读取的，而`myIPs`映射变量用于保存每个IP地址的计数。
- en: 'The last part of `countIP.go` is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`countIP.go`的最后一部分如下：'
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is where the magic happens: first, you extract the desired field from
    the working line. Then, you use the `net.ParseIP()` function to make sure that
    you are dealing with a valid IP address: if you want the program to process other
    kinds of data, you should delete the Go code that uses the `net.ParseIP()` function.
    After that, you update the contents of the `myIPs` map based on whether the current
    IP address can be found in the map or not: you saw that code back in [Chapter
    2](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml)*, Writing Programs in Go*. Finally,
    you print the contents of the `myIPs` map on the screen, and you are done!'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是魔术发生的地方：首先，您从工作行中提取所需的字段。然后，您使用`net.ParseIP()`函数确保您正在处理有效的IP地址：如果您希望程序处理其他类型的数据，应删除使用`net.ParseIP()`函数的Go代码。之后，根据当前IP地址是否可以在映射中找到，更新`myIPs`映射的内容：您在[第2章](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml)*，Go编程*中看到了该代码。最后，您在屏幕上打印`myIPs`映射的内容，完成！
- en: 'Executing `countIP.go` generates the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`countIP.go`会生成以下输出：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, it would be better if the output was sorted by the count associated
    with each IP address, which you can easily do with the help of the `sort(1)` Unix
    utility:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果输出按每个IP地址关联的计数排序，将会更好，你可以很容易地通过`sort(1)`Unix实用程序来实现：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you want the first 10 IP addresses, you can filter the previous output with
    the `head(1)` utility as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要前10个IP地址，你可以使用`head(1)`实用程序过滤前面的输出，如下所示：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: File permissions revisited
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件权限重访
- en: 'There are times that we need to find detailed information about the Unix permissions
    of a file. The `filePerm.go` Go utility will teach you how to read the Unix file
    permissions of a file or a directory and print them as a binary number, a decimal
    number, and a string. The program will be presented in three parts. The first
    part is the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要查找文件的Unix权限的详细信息。`filePerm.go` Go实用程序将教你如何读取文件或目录的Unix文件权限，并将其打印为二进制数、十进制数和字符串。该程序将分为三部分。第一部分如下：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The second part is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, you implement two functions that will help you convert a string with nine
    characters that hold the permissions of a file into a binary number. As an example,
    the `rwxr-x---` string will be converted to `111101000`. The initial string is
    extracted from the `os.Stat()` function call.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你实现了两个函数，它们将帮助你将一个包含文件权限的九个字符的字符串转换为一个二进制数。例如，`rwxr-x---`字符串将被转换为`111101000`。初始字符串是从`os.Stat()`函数调用中提取的。
- en: 'The last part contains the following Go code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分包含以下Go代码：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Executing `filePerm.go` will generate the following output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`filePerm.go`将生成以下输出：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Changing file permissions
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改文件权限
- en: 'This section will explain how to change the Unix permissions of a file or a
    directory to the desired value; however, it will not deal with the sticky bit,
    the set user ID bit, or the set group ID bit: not because they are difficult to
    implement, but because you usually do not need any of these when dealing with
    system files.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释如何将文件或目录的Unix权限更改为所需的值；但是，它不会处理粘性位、设置用户ID位或设置组ID位：不是因为它们难以实现，而是因为在处理系统文件时通常不需要这些功能。
- en: The name of the utility will be `setFilePerm.go`, and it will be presented in
    four parts. The new file permissions will be given as a string with nine characters
    such as `rwxrw-rw-`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该实用程序的名称将是`setFilePerm.go`，它将分为四个部分呈现。新的文件权限将以`rwxrw-rw-`等九个字符的字符串形式给出。
- en: 'The first part of `setFilePerm.go` contains the expected preamble Go code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`setFilePerm.go`的第一部分包含了预期的前言Go代码：'
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The second part is the implementation of the `tripletToBinary()` function that
    you saw in the previous section:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是`tripletToBinary()`函数的实现，你在上一节中看到了：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The third part contains the following Go code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含以下Go代码：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, the name of the function is misleading, as it does not return a binary
    number: this is my fault.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数的名称是误导性的，因为它并不返回一个二进制数：这是我的错。
- en: 'The last part contains the following Go code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分包含以下Go代码：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, you get the return value of `convertToBinary()` and convert it to an `os.FileMode()`
    variable in order to use it with the `os.Chmod()` function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你获取`convertToBinary()`的返回值，并将其转换为`os.FileMode()`变量，以便与`os.Chmod()`函数一起使用。
- en: 'Running `setFilePerm.go` generates the following results:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`setFilePerm.go`将生成以下结果：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finding other kinds of information about files
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找文件的其他信息
- en: The most important information about a Unix file is its owner and its group,
    and this section will teach you how to find both of them using Go code. The `findOG.go`
    utility accepts a list of files as its command-line arguments and returns the
    owner and the group of each one of them. Its Go code will be presented in three
    parts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Unix文件的最重要信息是它的所有者和它的组，本节将教你如何使用Go代码找到它们。`findOG.go`实用程序接受文件列表作为其命令行参数，并返回每个文件的所有者和组。它的Go代码将分为三部分。
- en: 'The first part is the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The second part is the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this part, you make a call to the `os.Stat()` function to make sure that
    the file you want to process exists.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你调用`os.Stat()`函数来确保你要处理的文件存在。
- en: 'The last part of `findOG.go` comes with the following Go code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOG.go`的最后一部分带有以下Go代码：'
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Yes, this is the most cryptic code you have seen so far in this book that uses
    the return value of `os.Stat()` to extract the desired information. Additionally,
    it is neither portable, which means that it might not work on your Unix variant,
    nor you can be sure that it will continue to work in forthcoming versions of Go!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是你在本书中迄今为止看到的最神秘的代码，它使用`os.Stat()`的返回值来提取所需的信息。此外，它也不是可移植的，这意味着它可能在你的Unix变体上无法工作，也不能保证它将在Go的未来版本中继续工作！
- en: Sometimes tasks that look easy might take you more time than expected. One of
    these tasks is the `findOG.go` program. This mainly happens because Go does not
    have an easy and portable way to find out the owner and the group of a file. Hopefully,
    this will change in the future.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时看起来很容易的任务可能会花费比预期更多的时间。其中一个任务就是`findOG.go`程序。这主要是因为Go没有一种简单且可移植的方法来找出文件的所有者和组。希望这在未来会有所改变。
- en: 'Executing `findOG.go` on macOS Sierra or Mac OS X will generate the following
    output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS Sierra或Mac OS X上执行`findOG.go`将生成以下输出：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, you can see that the `fileInfo.Sys()` call returns a plethora of information
    from the file in a somehow puzzling format: the information is analogous to the
    information from a C call to `stat(2)`. The first line of output is the contents
    of the `os.Stat.Sys()` call, whereas the second line is the user ID (`501`) of
    the owner of the file and the third line is the group ID (`0`) of the owner of
    the file.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`fileInfo.Sys()`调用以某种令人困惑的格式返回了大量文件信息：这些信息类似于对`stat(2)`的C调用的信息。输出的第一行是`os.Stat.Sys()`调用的内容，而第二行是文件所有者的用户ID（`501`），第三行是文件所有者的组ID（`0`）。
- en: 'Executing `findOG.go` on a Debian Linux machine will generate the following
    output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian Linux机器上执行`findOG.go`将生成以下输出：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The good news here is that `findOG.go` worked on both macOS Sierra and Debian
    Linux, even though macOS Sierra was using Go version 1.8.1 and Debian Linux was
    using Go version 1.3.3!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，`findOG.go`在macOS Sierra和Debian Linux上都可以工作，尽管macOS Sierra使用的是Go版本1.8.1，而Debian
    Linux使用的是Go版本1.3.3！
- en: Most of the presented Go code will be used later in this chapter for the implementation
    of the `userFiles.go` utility.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分呈现的Go代码将在本章后面用于实现`userFiles.go`实用程序。
- en: More pattern matching examples
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多模式匹配示例
- en: This section will present regular expressions that match more difficult patterns
    than the ones you have seen so far in this book. Just remember that regular expressions
    and pattern matching are practical subjects that you should learn by experimenting
    and sometimes failing, not by reading about them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍与本书迄今为止所见模式更困难的正则表达式。只需记住，正则表达式和模式匹配是您应该通过实验和有时失败来学习的实用主题，而不是通过阅读来学习。
- en: If you are very careful with regular expressions in Go, you can easily read
    or change almost all the system files of a Unix system that are in plain text
    format. Just be extra careful when modifying system files!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Go中非常小心地处理正则表达式，您几乎可以读取或更改Unix系统中几乎所有以纯文本格式存在的系统文件。只是在修改系统文件时要特别小心！
- en: A simple pattern matching example
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的模式匹配示例
- en: 'The example of this section will improve the functionality of the `countIP.go`
    utility, by developing a program that automatically detects the field with the
    IP address; therefore, it will not require the user to define the field of each
    log entry that contains the IP address. To make things simpler, the created program
    will only process the first IP address of each line: `findIP.go` takes a single
    command-line argument, which is the name of the log file you want to process.
    The program will be presented in four parts.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例将改进`countIP.go`实用程序的功能，通过开发一个自动检测具有IP地址的字段的程序；因此，它不需要用户定义包含IP地址的每个日志条目的字段。为了简化事情，创建的程序将只处理每行的第一个IP地址：`findIP.go`接受一个命令行参数，即要处理的日志文件的名称。程序将分为四个部分。
- en: 'The first part of `findIP.go` is the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`findIP.go`的第一部分如下：'
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The second part is where most of the magic happens with the help of a function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是在一个函数的帮助下发生大部分魔术的地方：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The regular expression is pretty complex considering that we just want to match
    four decimal numbers in the 0-255 range that are separated by dots, which mainly
    shows that regular expressions can be pretty complicated when you want to be methodical.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们只想匹配由点分隔的0-255范围内的四个十进制数，正则表达式非常复杂，这主要表明当您想要有条不紊地进行时，正则表达式可能非常复杂。
- en: 'But let me explain this to you in more detail. An IP address has four parts
    separated by dots. Each one of these parts can have a value between 0 and 255,
    which means that number 257 is not an acceptable value: this is the main reason
    that the regular expression is so complex. The first case is for numbers between
    250 and 255\. The second case is for numbers between 200 and 249, and the third
    case is for numbers between 100 and 199\. The last case is for catching values
    between 0 and 99.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我更详细地解释一下。IP地址由四部分组成，用点分隔。每个部分的值可以在0到255之间，这意味着数字257不是可接受的值：这是正则表达式如此复杂的主要原因。第一种情况是介于250和255之间的数字。第二种情况是介于200和249之间的数字，第三种情况是介于100和199之间的数字。最后一种情况是捕获0到99之间的值。
- en: 'The third part of `findIP.go` is the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`findIP.go`的第三部分如下：'
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, you read the input log file line by line using `bufio.NewReader()`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用`bufio.NewReader()`逐行读取输入日志文件。
- en: 'The last part has the following Go code, which deals with processing the matches
    of the regular expression:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分包含以下Go代码，用于处理正则表达式的匹配项：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, `findIP.go` executes an additional checking on the IP that was
    found by the function that performed the pattern matching operation, using `net.ParseIP()`;
    this mainly happens because IP addresses are pretty tricky, and it is considered
    good practice to double check them! Additionally, this catches the case where
    `findIP()` returns nothing because a valid IP was not found in the processed line.
    The last thing the program does before exiting is to print the contents of the
    `myIPs` map.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`findIP.go`对由执行模式匹配操作的函数找到的IP执行了额外的检查，使用`net.ParseIP()`；这主要是因为IP地址非常棘手，因此最好是再次检查它们！此外，这会捕获`findIP()`返回空值的情况，因为在处理的行中未找到有效的IP。程序在退出之前做的最后一件事是打印`myIPs`映射的内容。
- en: 'Consider how many incredible and useful utilities you can develop with a small
    amount of Go code: it is really amazing!'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下，您可以用少量的Go代码开发多少令人难以置信和有用的实用程序：这真是令人惊讶！
- en: 'Executing `findIP.go` on a Linux machine in order to process the `/var/log/auth.log`
    log file will create the following output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux机器上执行`findIP.go`以处理`/var/log/auth.log`日志文件将创建以下输出：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can sort the previous output by the number of times an IP was found and
    display the 10 most popular IP addresses, as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按IP被发现的次数对先前的输出进行排序，并显示前10个最受欢迎的IP地址，如下所示：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So, in this case, the `findIP.go` utility is used for checking the security
    of your Linux machine!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，`findIP.go`实用程序用于检查您的Linux机器的安全性！
- en: An advanced example of pattern matching
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配的高级示例
- en: 'In this section, you will learn how to swap the values of two fields of each
    line of a text file, provided they are in the correct format. This mainly happens
    in log files or other text files where you want to scan a line for certain types
    of data, and if the data is found, you might need to do something with them: in
    this case, you will change the place of the two values.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何交换文本文件每行的两个字段的值，前提是它们的格式正确。这主要发生在日志文件或其他文本文件中，您希望扫描某种类型的数据的行，如果找到数据，可能需要对其进行某些操作：在这种情况下，您将更改两个值的位置。
- en: 'The name of the program will be `swapRE.go`, and it will be presented in four
    parts. Once again, the program will read a text file line by line and try to match
    the desired strings before swapping them. The utility will print the contents
    of the new file on the screen; it is the responsibility of the user to save the
    results to a new file. The format of the log entries that `swapRE.go` expects
    to process are similar to the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的名称将是`swapRE.go`，它将分为四个部分。再次，该程序将逐行读取文本文件，并尝试匹配所需的字符串后进行交换。该实用程序将在屏幕上打印新文件的内容；将结果保存到新文件是用户的责任。`swapRE.go`期望处理的日志条目格式类似于以下内容：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The entries from the previous line that the program will swap are [`24/May/2017:06:41:11
    +0300`] and `132953`, which are the date and time and the time it took the browser
    to get the desired information, respectively; the program expects to find this
    at the end of each line. However, the regular expression also checks that the
    date and time are in the correct format and that the last field of each log entry
    is indeed a number.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将交换的上一行条目是[`24/May/2017:06:41:11 +0300`]和`132953`，它们分别是日期和时间以及浏览器获取所需信息所花费的时间；程序期望在每行末尾找到这些内容。但是，正则表达式还检查日期和时间是否以正确的格式以及每个日志条目的最后一个字段是否确实是数字。
- en: As you will see, using regular expressions in Go, can be perplexing sometimes,
    mainly because regular expressions are relatively difficult to build, in general.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将看到的，有时在Go中使用正则表达式可能会令人困惑，主要是因为正则表达式通常相对难以构建。
- en: 'The first part of `swapRE.go` will be the expected preamble:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`swapRE.go`的第一部分将是预期的序言：'
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The second part comes with the following Go code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包括以下Go代码：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There is nothing particularly interesting or new here.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别有趣或新的。
- en: 'The third part is the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分如下：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here is the Go code that allows you to process the input file line by line.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是允许您逐行处理输入文件的Go代码。
- en: 'The last part of `swapRE.go` is the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`swapRE.go`的最后一部分如下：'
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can imagine, complex regular expressions, such as the one presented
    here, are built step by step, not all at once. Even in that case, you may still
    fail many times in the process because even the tiniest mistake in a complex regular
    expression will cause it to not do what you expect: extensive testing is the key
    here!'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以想象的那样，像这里呈现的复杂正则表达式一样，是逐步构建的，而不是一次性完成的。即使在这种情况下，您可能仍然会在过程中多次失败，因为即使在复杂正则表达式中出现最微小的错误也会导致它不符合您的期望：在这里，广泛的测试是关键！
- en: The parentheses used inside a regular expression allow you to reference each
    match afterwards and are very handy when you want to process what you have matched.
    What you want here is to find a `[` character, then two digits that will be the
    day of the month, then a word, which will be the name of the month, and then four
    digits that will be the year. Next, you match anything else until you find a `]`
    character. Then you match all the digits at the end of each line.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式中使用的括号允许您在之后引用每个匹配项，并且在您想要处理已匹配内容时非常方便。在这里，您想要找到一个`[`字符，然后是两位数字，它们将是月份的日期，然后是一个单词，它将是月份的名称，然后是四位数字，它们将是年份。接下来，匹配任何其他内容，直到找到一个`]`字符。然后匹配每行末尾的所有数字。
- en: Note that there might exist alternative ways to write the same regular expression.
    The general advice here is to write it in a way that is clear and that you can
    understand.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可能存在编写相同正则表达式的替代方法。这里的一般建议是以清晰且易于理解的方式编写它。
- en: 'Executing `swapRE.gowith`, a small test log file will generate the following
    output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`swapRE.go`，一个小的测试日志文件将生成以下输出：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Renaming multiple files using regular expressions
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式重命名多个文件
- en: The last section on pattern matching and regular expressions will work on filenames
    and will allow you to rename multiple files. As you can guess, a walk function
    will be used in the program while a regular expression will match the filenames
    you want to rename.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一节关于模式匹配和正则表达式将处理文件名，并允许您重命名多个文件。正如您可以猜到的那样，在程序中将使用walk函数，而正则表达式将匹配您想要重命名的文件名。
- en: When dealing with files, you should be extra careful because you might accidentally
    destroy things! Putting it simply, do not test such utilities on a production
    server.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件时，您应该特别小心，因为您可能会意外地破坏东西！简而言之，不要在生产服务器上测试这样的实用程序。
- en: The name of the utility will be `multipleMV.go`, and it will be presented in
    three parts. What `multipleMV.go` will do is insert a string in front of every
    filename that is a match to the given regular expression.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该实用程序的名称将是`multipleMV.go`，它将分为三个部分。`multipleMV.go`将做的是在与给定正则表达式匹配的每个文件名前插入一个字符串。
- en: 'The first part is the expected preamble:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是预期的序言：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The two global variables save you from having to use many parameters in your
    functions. Additionally, as the signature of the `walk()` function, presented
    in a while, cannot change, it will not be possible to pass them as parameters
    to `walk()`. So, in this case, having two global parameters makes things easier
    and simpler.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个全局变量可以避免在函数中使用许多参数。另外，由于`walk()`函数的签名在一段时间内不会改变，所以无法将它们作为参数传递给`walk()`。因此，在这种情况下，有两个全局参数会使事情变得更容易和简单。
- en: 'The second part contains the following Go code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: All the functionality of the program is embedded in the `walk()` function. After
    a successful match, the new filename is stored in the `newName` variable before
    executing the `os.Rename()` function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的所有功能都嵌入在`walk()`函数中。成功匹配后，新文件名将存储在`newName`变量中，然后执行`os.Rename()`函数。
- en: 'The last part of `multipleMV.go` is the implementation of the `main()` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`multipleMV.go`的最后一部分是`main()`函数的实现：'
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, there is nothing you have not seen before: the only interesting thing
    is the call to `filepath.EvalSymlinks()` in order to not have to deal with symbolic
    links.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，没有什么是你以前没有见过的：唯一有趣的是调用`filepath.EvalSymlinks()`，以便不必处理符号链接。
- en: 'Using `multipleMV.go` is as simple as running the following commands:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `multipleMV.go` 就像运行以下命令一样简单：
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Searching files revisited
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新访问搜索文件
- en: This section will teach you how to find files using criteria such as user ID,
    group ID, and file permissions. Although this section could have been included
    in [Chapter 5](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml), *Files and Directories*,
    I decided to put it here, because there are times when you will want to use this
    kind of information in order to inform a system administrator that there is something
    wrong with the system.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将教你如何使用用户ID、组ID和文件权限等条件来查找文件。尽管这一节本来可以包含在[第5章](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml)
    *文件和目录* 中，但我决定把它放在这里，因为有时你会想要使用这种信息来通知系统管理员系统出了问题。
- en: Finding the user ID of a user
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找用户的用户ID
- en: 'This subsection will present a program that shows the user ID of a user, given
    their username, which is more or less the output of the `id -u` utility:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这一小节将介绍一个程序，它显示给定用户名的用户ID，这或多或少是 `id -u` 实用程序的输出：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The fact that there exists a Go package named `user`, which can be found under
    the `os` package that can help you implement the desired task, should not come
    as surprise to you. The name of the program will be `userID.go`, and it will be
    presented in two parts. If you give no command-line arguments to `userID.go`,
    it will print the user ID of the current user; otherwise, it will print the user
    ID of the given username.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个名为 `user` 的 Go 包，可以在 `os` 包下找到，可以帮助你实现所需的任务，这一点不应该让你感到惊讶。程序的名称将是 `userID.go`，它将分为两部分。如果你没有给
    `userID.go` 传递命令行参数，它将打印当前用户的用户ID；否则，它将打印给定用户名的用户ID。
- en: 'The first part of `userID.go` is the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`userID.go` 的第一部分如下：'
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `os.Getuid()` function returns the user ID of the current user.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Getuid()` 函数返回当前用户的用户ID。'
- en: 'The second part of `userID.go` comes with the following Go code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`userID.go` 的第二部分包含以下 Go 代码：'
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Given a username, the `user.Lookup()` function returns a `user.User` compound
    value. We will only use the `Uid` field of that compound value to find the user
    ID of the given username.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 给定用户名，`user.Lookup()` 函数返回一个 `user.User` 复合值。我们只会使用该复合值的 `Uid` 字段来查找给定用户名的用户ID。
- en: 'Executing `userID.go` will generate the following output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `userID.go` 将生成以下输出：
- en: '[PRE56]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Finding all the groups a user belongs to
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找用户所属的所有组
- en: 'Each user can belong to more than one group: this section will show how to
    find out the list of groups a user belongs to, given their username.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户可以属于多个组：本节将展示如何找出给定用户名的用户属于哪些组的列表。
- en: 'The name of the utility will be `listGroups.go`, and it will be presented in
    four parts. The first part of `listGroups.go` is the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的名称将是 `listGroups.go`，它将分为四部分。`listGroups.go` 的第一部分如下：
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The second part has the following Go code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下 Go 代码：
- en: '[PRE58]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The approach that `listGroups.go` takes when there are no command-line arguments
    is similar to the one found in `userID.go`. However, there is a big difference,
    as this time you do not need the user ID of the current user, but the username
    of the current user; so you call `user.Current()`, which returns a `user.User`
    value.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有命令行参数时，`listGroups.go` 采用的方法与 `userID.go` 中找到的方法类似。然而，有一个很大的区别，这一次你不需要当前用户的用户ID，而是需要当前用户的用户名；所以你调用
    `user.Current()`，它返回一个 `user.User` 值。
- en: 'The third part contains the following Go code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含以下 Go 代码：
- en: '[PRE59]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: So, if a command-line argument is given to the program, it is handled by the
    previous code with the help of the `user.Lookup()` function that also returns
    a `user.User` value.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果给程序传递了命令行参数，它将通过 `user.Lookup()` 函数处理前面的代码，该函数还返回一个 `user.User` 值。
- en: 'The last part contains the following Go code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分包含以下 Go 代码：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here, you get the list of the group IDs that the user: signified by the `u`
    variable: is a member of, by calling the `u.GroupIds()` function. Then, you will
    need a `for` loop to iterate over all the list elements and print them. It should
    be made clear that this list is stored in `u`; that is, a `user.User` value.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过调用 `u.GroupIds()` 函数，你可以获得用户（由 `u` 变量表示）所属的组ID列表。然后，你需要一个 `for` 循环来遍历所有列表元素并打印它们。应该明确指出，这个列表存储在
    `u` 中；也就是说，一个 `user.User` 值。
- en: 'Executing `listGroups.go` will generate the following output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `listGroups.go` 将生成以下输出：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output of `listGroups.go` is much more enriched than the output of both
    the `id -G -n` and `groups` commands:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`listGroups.go` 的输出比 `id -G -n` 和 `groups` 命令的输出要丰富得多：'
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Finding files that belong or do not belong to a given user
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找属于给定用户或不属于给定用户的文件
- en: This subsection will create a Go program that scans a directory tree and presents
    files that belong or do not belong to a given user. The name of the program will
    be `userFiles.go`. In its default mode of operation, `userFiles.go` will display
    all files that belong to a given username; when used with the `-no` flag, it will
    only display the files that do not belong to the given username.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这一小节将创建一个 Go 程序，扫描目录树并显示属于给定用户或不属于给定用户的文件。程序的名称将是 `userFiles.go`。在其默认操作模式下，`userFiles.go`
    将显示所有属于给定用户名的文件；当使用 `-no` 标志时，它将只显示不属于给定用户名的文件。
- en: The code of `userFiles.go` will be presented in four parts.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`userFiles.go` 的代码将分为四部分。'
- en: 'The first one is the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The reason for declaring `INCLUDE` and `uid` as global variables is that you
    want both of them to be accessible from every point of the program. Additionally,
    as the signature of `walkFunction()` cannot change: only its name can change:
    using global variables makes things easier for the developer.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `INCLUDE` 和 `uid` 声明为全局变量的原因是你希望它们都可以从程序的任何地方访问。此外，由于 `walkFunction()` 的签名不能改变：只有它的名称可以改变：使用全局变量对开发人员更方便。
- en: 'The second part comes with the following Go code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下 Go 代码：
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The use of a local variable named `UID` might be a poor choice, given that there
    is a global variable named `uid`! A better name for the global variable would
    have been `gUID`. Note that for an explanation of the way that the call that returns
    the `UID` variable works, you should search for the interfaces and type conversions
    in Go, because talking about it is beyond the scope of this book.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为 `UID` 的局部变量可能是一个不好的选择，因为有一个名为 `uid` 的全局变量！全局变量的更好名称应该是 `gUID`。请注意，关于返回
    `UID` 变量的调用方式的解释，您应该搜索 Go 中的接口和类型转换，因为讨论这个超出了本书的范围。
- en: 'The third part contains the following Go code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含以下 Go 代码：
- en: '[PRE65]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here you can see the implementation of a walk function that will access every
    file and directory in a given directory tree, in order to print the desired filenames
    only.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到一个遍历函数的实现，该函数将访问给定目录树中的每个文件和目录，以便仅打印所需的文件名。
- en: 'The last part of the utility contains the following Go code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的最后部分包含以下 Go 代码：
- en: '[PRE66]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here you deal with the configuration of the `flag` package before calling the
    `filepath.Walk()` function.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `filepath.Walk()` 函数之前，您需要处理 `flag` 包的配置。
- en: 'Executing `userFiles.go` generates the following output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `userFiles.go` 会生成以下输出：
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you do not give any command-line arguments or flags, the `userFiles.go`
    utility will assume that you want to search the current directory for files that
    belong to the current user:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有给出任何命令行参数或标志，`userFiles.go` 实用程序将假定您想要搜索当前目录中属于当前用户的文件：
- en: '[PRE68]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'So, in order to find all the files in the `/srv/www/www.highiso.net` directory
    that do not belong to the `www-data` user, you should execute the following command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了找到 `/srv/www/www.highiso.net` 目录中不属于 `www-data` 用户的所有文件，您应该执行以下命令：
- en: '[PRE69]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Finding files based on their permissions
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据权限查找文件
- en: Now that you know how to find the Unix permissions of a file, you can improve
    the `regExpFind.go` utility from the previous chapter in order to support searching
    based on file permissions; however, in order to avoid presenting a really big
    Go program here without any practical reason, the presented program will be autonomous
    and only support finding files based on their permissions. The name of the new
    utility will be `findPerm.go`, and it will be presented in four parts. The permissions
    will be given in the command line as a string using the format returned by the
    `ls(1)` command (`rwxr-xr--`).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何找到文件的 Unix 权限后，可以改进上一章中的 `regExpFind.go` 实用程序，以支持基于文件权限的搜索；但是，为了避免在这里没有任何实际原因的情况下呈现一个非常大的
    Go 程序，所以呈现的程序将是自主的，并且只支持根据权限查找文件。新实用程序的名称将是 `findPerm.go`，将分为四部分呈现。权限将以 `ls(1)`
    命令返回的格式作为字符串在命令行中给出（`rwxr-xr--`）。
- en: 'The first part of the utility is the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的第一部分如下：
- en: '[PRE70]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `PERMISSIONS` variable is made global in order to be accessible from anywhere
    in the program, and because the signature of `walkFunction()` cannot change.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`PERMISSIONS` 变量是全局的，以便从程序的任何地方访问，并且因为 `walkFunction()` 的签名不能更改。'
- en: 'The second part of `findPerm.go` contains the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`findPerm.go` 的第二部分包含以下代码：'
- en: '[PRE71]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The third part is the implementation of `walkFunction()`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分是 `walkFunction()` 的实现：
- en: '[PRE72]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The last part of `findPerm.go` is the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`findPerm.go` 的最后部分如下：'
- en: '[PRE73]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Executing `findPerm.go` will generate the following output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `findPerm.go` 会生成以下输出：
- en: '[PRE74]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Date and time operations
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期和时间操作
- en: This section will show you how to work with dates and times in Go. This task
    might look insignificant, but it can be very important when you want to synchronize
    things such as log entries and error messages. We will start by illustrating some
    of the functionality of the `time` package.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何在 Go 中处理日期和时间。这项任务可能看起来微不足道，但当您想要同步诸如日志条目和错误消息之类的事物时，它可能非常重要。我们将首先说明
    `time` 包的一些功能。
- en: Playing with dates and times
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转日期和时间
- en: 'This section will present a small Go program named `dateTime.go` that shows
    how to work with times and dates in Go. The code of `dateTime.go` will be presented
    in three parts. The first part is the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍一个名为 `dateTime.go` 的小型 Go 程序，展示了如何在 Go 中处理时间和日期。`dateTime.go` 的代码将分为三部分呈现。第一部分如下：
- en: '[PRE75]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In this part, you can see how you can change a date from one format to another,
    and also, how to find the date and time in a different time zone. The `time.Now()`
    function used at the beginning of the `main()` function returns the current time.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，您可以看到如何将日期从一种格式转换为另一种格式，以及如何在不同时区找到日期和时间。`main()` 函数开头使用的 `time.Now()`
    函数返回当前时间。
- en: 'The second part is the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The list of constants that can be used for creating your own parse format can
    be found at [https://golang.org/src/time/format.go](https://golang.org/src/time/format.go).
    Go does not define the format of a date or a time in a form like DDYYYYMM or %D
    %Y %M as the rest of the programming languages do, but uses its own approach.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [https://golang.org/src/time/format.go](https://golang.org/src/time/format.go)
    找到用于创建自己的解析格式的常量列表。Go 不像其他编程语言那样以 DDYYYYMM 或 %D %Y %M 的形式定义日期或时间的格式，而是使用自己的方法。
- en: 'Here, you see how you can read a string and try to convert it to a valid date,
    both successfully (`d`) and unsuccessfully (`d1`). The problem with the `d1` variable
    is the use of `February` in the `format` string: you should have used `January`
    instead.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到如何读取一个字符串并尝试将其转换为有效的日期，成功地（`d`）和不成功地（`d1`）。`d1` 变量的问题在于 `format` 字符串中使用了
    `February`：您应该改用 `January`。
- en: 'The last part of `dateTime.go` comes with the following Go code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`dateTime.go` 的最后部分带有以下 Go 代码：'
- en: '[PRE77]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This part also shows how to convert a string into a date and a time, provided
    that it is in the expected format.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分还展示了如何将字符串转换为日期和时间，前提是它是预期的格式。
- en: 'Executing `dateTime.go` will generate the following output:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `dateTime.go` 会生成以下输出：
- en: '[PRE78]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Reformatting the times in a log file
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新格式化日志文件中的时间
- en: This section will show how to implement a program that reads a log file that
    contains date and time information, in order to convert the time format found
    in each log entry. This operation might be needed when you have log files from
    different servers that are in several time zones, and you want to synchronize
    their times in order to create reports from their data or store them into a database
    to process them some other time.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示如何实现一个程序，该程序读取包含日期和时间信息的日志文件，以便转换每个日志条目中找到的时间格式。当您有来自不同时区的不同服务器的日志文件，并且希望同步它们的时间以便从它们的数据创建报告或将它们存储到数据库中以便以后处理它们时，可能需要执行此操作。
- en: The name of the presented program will be `dateTimeLog.go`, and it will be presented
    in four parts.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现的程序的名称将是`dateTimeLog.go`，并且将分为四个部分。
- en: 'The first part is the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE79]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The second part contains the following Go code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE80]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, you just configure the `flag` package and open the input file for reading.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您只需配置`flag`包并打开输入文件以进行读取。
- en: 'The third part of the program is the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分如下：
- en: '[PRE81]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here you read the input file line by line.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您逐行读取输入文件。
- en: 'The last part is the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分如下：
- en: '[PRE82]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The general idea here is that once you have a match, you parse the date and
    time you found using `time.Parse()` and then convert it to the desired format
    using the `time.Format()` function. Also, you replace the initial match with the
    output of the `time.Format()` function before you print it using `strings.Replace()`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本思想是，一旦找到匹配项，就使用`time.Parse()`解析找到的日期和时间，然后使用`time.Format()`函数将其转换为所需的格式。此外，在使用`strings.Replace()`打印之前，您将初始匹配项替换为`time.Format()`函数的输出。
- en: 'Executing `dateTimeLog.go` will generate the following output:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`dateTimeLog.go`将生成以下输出：
- en: '[PRE83]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Rotating log files
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转日志文件
- en: Log files tend to get bigger and bigger all the time because data is written
    to them all the time; it would be good to have a technique for rotating them.
    This section will present such a technique. The name of the Go program will be
    `rotateLog.go`, and it will be presented in three parts. Note that for a process
    to rotate a log file, the process must be the one that opened that log file for
    writing. Trying to rotate a log that you do not own might create problems on your
    Unix machine, and should be avoided!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件由于不断写入数据而不断变得越来越大；最好有一种旋转它们的技术。本节将介绍这样的技术。Go程序的名称将是`rotateLog.go`，并且将分为三个部分。请注意，要旋转日志文件，进程必须是打开该日志文件进行写入的进程。尝试旋转您不拥有的日志可能会在您的Unix机器上创建问题，应该避免！
- en: 'What you will also see here is another technique where you use your own log
    file for storing your log entries, with the help of `log.SetOutput()`: after a
    successful call to `log.SetOutput()`, each function call to `log.Print()` will
    make the output go to the log file used as the parameter of `log.SetOutput()`.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您还将看到另一种技术，即使用自己的日志文件存储日志条目，借助`log.SetOutput()`的帮助：成功调用`log.SetOutput()`后，对`log.Print()`的每个函数调用都将使输出转到用作`log.SetOutput()`参数的日志文件。
- en: 'The first part of `rotateLog.go` is the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotateLog.go`的第一部分如下：'
- en: '[PRE84]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Using hard coded variables that define when the program will stop is considered
    good practice: this happens because you do not have any other way to tell `rotateLog.go`
    to stop. However, if you use the functionality of the `rotateLog.go` utility in
    a compiled program, then such variables should be given as command-line arguments,
    because you should not have to recompile the program in order to change the way
    the program behaves!'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用硬编码变量来定义程序何时停止被认为是一种良好的做法：这是因为您没有其他方法告诉`rotateLog.go`停止。但是，如果您在编译的程序中使用`rotateLog.go`实用程序的功能，则此类变量应作为命令行参数给出，因为您不应该重新编译程序以更改程序的行为方式！
- en: 'The second part of `rotateLog.go` is the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotateLog.go`的第二部分如下：'
- en: '[PRE85]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, you define the Go function named `rotateLogFile()` for rotating the desired
    log file, which is the most important part of the program. The `setUpLogFile()`
    function helps you restart the log file after you rotate it. What is also illustrated
    here is the use of `log.SetOutput()` to tell the program where to write the log
    entries. Note that you should open your log file using `os.OpenFile()`, because
    `os.Open()` will not work for `log.SetOutput()`, and `os.Open()` does open files
    for writing!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您定义了名为`rotateLogFile()`的Go函数，用于旋转所需的日志文件，这是程序的最重要部分。`setUpLogFile()`函数在旋转日志文件后帮助您重新启动日志文件。这里还展示了使用`log.SetOutput()`告诉程序在哪里写入日志条目。请注意，您应该使用`os.OpenFile()`打开日志文件，因为`os.Open()`对于`log.SetOutput()`不起作用，而`os.Open()`会打开文件进行写入！
- en: 'The last part is the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分如下：
- en: '[PRE86]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In this part, the `main()` function keeps writing data to a log file while counting
    the number of entries that have been written so far. When the defined number of
    entries have been reached (`ENTRIESPERLOGFILE`), the `main()` function will call
    the `rotateLogFile()` function, which will do the dirty work for us. On a real
    program, you will most likely not need to call `time.Sleep()` to delay the execution
    of the program. For this particular program, `time.Sleep()` will give you time
    to examine your log file using `tail -f`, should you choose to do so.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，`main()`函数在计算到目前为止已写入的条目数的同时继续向日志文件写入数据。当达到定义的条目数（`ENTRIESPERLOGFILE`）时，`main()`函数将调用`rotateLogFile()`函数，该函数将为我们完成繁重的工作。在真实的程序中，您很可能不需要调用`time.Sleep()`来延迟程序的执行。对于这个特定的程序，`time.Sleep()`将为您提供时间来使用`tail
    -f`检查日志文件，如果您选择这样做的话。
- en: 'Running `rotateLog.go` will generate the following output on the screen and
    inside the `/tmp` directory:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`rotateLog.go`将在屏幕上和`/tmp`目录中生成以下输出：
- en: '[PRE87]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[Chapter 8](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml),*Processes and Signals*,
    will present a much better approach on log rotating that will be based on Unix
    signals.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)，*进程和信号*，将介绍基于Unix信号的日志旋转的更好方法。'
- en: Creating good random passwords
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建好的随机密码
- en: This section will illustrate how to create good random passwords in Go, in order
    to protect the security of your Unix machines. The main reason for including it
    here instead of another chapter is because the presented Go program will use the
    `/dev/random` device, which is a file defined by your Unix system, for getting
    the seed of the random number generator.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将说明如何在Go中创建良好的随机密码，以保护您的Unix机器的安全。将其包含在这里的主要原因是，所呈现的Go程序将使用您的Unix系统定义的`/dev/random`设备来获取随机数生成器的种子。
- en: 'The name of the Go program will be `goodPass.go`, and it will require just
    one optional parameter, which will be the length of the generated password: the
    default size of the generated password will be 10 characters. Additionally, the
    program will generate ASCII characters starting from `!` up to `z`. The ASCII
    code of the exclamation mark is 33, whereas the ASCII code of small z is 122.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序的名称将是`goodPass.go`，它将只需要一个可选参数，即生成的密码的长度：生成的密码的默认大小将为10个字符。此外，该程序将生成ASCII字符，从`!`到`z`。感叹号的ASCII码是33，而小写z的ASCII码是122。
- en: 'The first part of `goodPass.go` is the required preamble:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`goodPass.go`的第一部分是必需的序言：'
- en: '[PRE88]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The second part of the program is as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二部分如下：
- en: '[PRE89]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: You have already seen the `random()` function back in [Chapter 2](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml)*,*
    *Writing Programs in Go*, so there is nothing particularly interesting here.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在[第2章](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml)中看到了`random()`函数，所以这里没有什么特别有趣的地方。
- en: 'The third part of `goodPass.go` is where the implementation of the `main()`
    function begins:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`goodPass.go`的第三部分是`main()`函数的实现开始的地方：'
- en: '[PRE90]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here, apart from reading the command-line argument, you also open the `/dev/random`
    device for reading, which happens by calling the `binary.Read()` function and
    storing what you read in the `seed` variable. The reason for using `binary.Read()`
    is that you need to specify the byte order used (`binary.LittleEndian`) and that
    you need to build an int64 instead of a series of bytes. This is an example of
    having to read from a binary file into Go types.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，除了读取命令行参数之外，您还打开了`/dev/random`设备进行读取，这是通过调用`binary.Read()`函数并将读取的内容存储在`seed`变量中实现的。使用`binary.Read()`的原因是您需要指定使用的字节顺序（`binary.LittleEndian`），并且您需要构建一个int64而不是一系列字节。这是一个从二进制文件读取到Go类型的示例。
- en: 'The last part of the program contains the following Go code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分包含以下Go代码：
- en: '[PRE91]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: As you can see, Go has a strange way of dealing with ASCII characters because
    Go supports Unicode characters by default. However, you can still convert an integer
    number into an ASCII character as can be seen in the way you define the `newChar`
    variable.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Go处理ASCII字符的方式很奇怪，因为Go默认支持Unicode字符。但是，您仍然可以将整数转换为ASCII字符，如您在定义`newChar`变量的方式所示。
- en: 'Executing `goodPass.go` will generate the following output:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`goodPass.go`将生成以下输出：
- en: '[PRE92]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Another Go update
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一个Go更新
- en: 'As I was writing this chapter, Go got updated. The following output shows the
    related information:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在我写这一章的时候，Go得到了更新。以下输出显示了相关信息：
- en: '[PRE93]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Exercises
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Find and read the documentation of the `time` package.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找并阅读`time`包的文档。
- en: Try to change the Go code of `userFiles.go` in order to support multiple users.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试更改`userFiles.go`的Go代码，以支持多个用户。
- en: Change the Go code of `insertLineNumber.go` in order to read the input file
    line by line, write each line to a temporary file, and then, replace the original
    file with the temporary one. If you do not know how and where to create a temporary
    file, you can use a random number generator to get a temporary filename and the
    `/tmp` directory to temporarily save it.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`insertLineNumber.go`的Go代码，以便逐行读取输入文件，将每行写入临时文件，然后用临时文件替换原始文件。如果您不知道如何在哪里创建临时文件，可以使用随机数生成器获取临时文件名和`/tmp`目录进行临时保存。
- en: Make the necessary changes to `multipleMV.go` in order to print the files that
    are a match to the given regular expression without actually renaming them.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`multipleMV.go`进行必要的更改，以便打印与给定正则表达式匹配的文件，而不实际重命名它们。
- en: Try to create a regular expression that matches `PNG` files and use it to process
    the contents of a log file.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试创建一个匹配`PNG`文件的正则表达式，并使用它来处理日志文件的内容。
- en: Create a regular expression that catches a date and a time string in order to
    print just the date part and delete the time part.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个正则表达式，以捕获日期和时间字符串，以便仅打印日期部分并删除时间部分。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about many things, including working with log files,
    dealing with Unix file permissions, users, and groups, creating regular expressions,
    and processing text files.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们谈到了许多内容，包括处理日志文件，处理Unix文件权限，用户和组，创建正则表达式以及处理文本文件。
- en: In the next chapter, we will talk about Unix signals, which allow you to communicate
    with a running program from the outside world, in an asynchronous way. Furthermore,
    we will tell you how to plot in Go.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Unix信号，它允许您以异步方式与运行中的程序进行通信。此外，我们将告诉您如何在Go中绘图。
- en: f
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: f
