["```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"os/exec\" \n   \"syscall\" \n) \n```", "```go\nfunc main() { \n\n   PS, err := exec.LookPath(\"ps\") \n   if err != nil { \n         fmt.Println(err) \n   } \nfmt.Println(PS) \n\n   command := []string{\"ps\", \"-a\", \"-x\"} \n   env := os.Environ() \n   err = syscall.Exec(PS, command, env) \n```", "```go\n   if err != nil { \n         fmt.Println(err) \n   } \n} \n```", "```go\n$ go run listProcess.go | head -3\n/bin/ps\n  PID TTY           TIME CMD\n    1 ??         0:30.72 /sbin/launchd\nsignal: broken pipe\n```", "```go\n$ kill -l\n1) SIGHUP   2) SIGINT        3) SIGQUIT   4) SIGILL\n5) SIGTRAP  6) SIGABRT       7) SIGEMT    8) SIGFPE\n9) SIGKILL 10) SIGBUS        11) SIGSEGV 12) SIGSYS\n13) SIGPIPE 14) SIGALRM       15) SIGTERM 16) SIGURG\n17) SIGSTOP 18) SIGTSTP       19) SIGCONT 20) SIGCHLD\n21) SIGTTIN 22) SIGTTOU       23) SIGIO   24) SIGXCPU\n25) SIGXFSZ 26) SIGVTALRM     27) SIGPROF 28) SIGWINCH\n29) SIGINFO 30) SIGUSR1       31) SIGUSR2\n```", "```go\n$ kill -l\n 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP\n 6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR1\n11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM\n16) SIGSTKFLT     17) SIGCHLD \n18) SIGCONT       19) SIGSTOP 20) SIGTSTP\n21) SIGTTIN       22) SIGTTOU \n23) SIGURG        24) SIGXCPU 25) SIGXFSZ\n26) SIGVTALRM     27) SIGPROF 28) SIGWINCH \n29) SIGIO         30) SIGPWR\n31) SIGSYS        34) SIGRTMIN \n35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3\n38) SIGRTMIN+4    39) SIGRTMIN+5 \n40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8\n43) SIGRTMIN+9    44) SIGRTMIN+10 \n45) SIGRTMIN+11   46) SIGRTMIN+12   47) SIGRTMIN+13\n48) SIGRTMIN+14   49) SIGRTMIN+15 \n50) SIGRTMAX-14   51) SIGRTMAX-13   52) SIGRTMAX-12\n53) SIGRTMAX-11   54) SIGRTMAX-10 \n55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7\n58) SIGRTMAX-6    59) SIGRTMAX-5 \n60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2\n63) SIGRTMAX-1    64) SIGRTMAX\n```", "```go\n$ kill 2908\n-bash: kill: (2908) - Operation not permitted\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"os/signal\" \n   \"syscall\" \n   \"time\" \n) \n\nfunc handleSignal(signal os.Signal) { \n   fmt.Println(\"Got\", signal) \n} \n```", "```go\nfunc main() { \n   sigs := make(chan os.Signal, 1) \n   signal.Notify(sigs, os.Interrupt, syscall.SIGTERM) \n   go func() { \n         for { \n               sig := <-sigs \n               fmt.Println(sig) \n               handleSignal(sig) \n         } \n   }() \n```", "```go\n   for { \n         fmt.Printf(\".\") \n         time.Sleep(10 * time.Second) \n   } \n} \n```", "```go\n$ ./h1s\n......................^Cinterrupt\nGot interrupt\n^Cinterrupt\nGot interrupt\n.Hangup: 1\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"os/signal\" \n   \"syscall\" \n   \"time\" \n) \n```", "```go\nfunc handleSignal(signal os.Signal) { \n   fmt.Println(\"* Got:\", signal) \n} \n\nfunc main() { \n   sigs := make(chan os.Signal, 1) \n   signal.Notify(sigs, os.Interrupt, syscall.SIGTERM, syscall.SIGHUP) \n```", "```go\n   go func() { \n         for { \n               sig := <-sigs \n               switch sig { \n               case os.Interrupt: \n                     handleSignal(sig) \n               case syscall.SIGTERM: \n                     handleSignal(sig) \n               case syscall.SIGHUP: \n                     fmt.Println(\"Got:\", sig) \n                     os.Exit(-1) \n               } \n         } \n   }() \n```", "```go\n   for { \n         fmt.Printf(\".\") \n         time.Sleep(10 * time.Second) \n   } \n}\n```", "```go\n$ go build h2s.go\n$ ./h2s\n..* Got: interrupt\n* Got: terminated\n.Got: hangup\n.Killed: 9\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"os/signal\" \n   \"syscall\" \n   \"time\" \n) \n\nfunc handleSignal(signal os.Signal) { \n   fmt.Println(\"* Got:\", signal) \n} \n```", "```go\nfunc main() { \n   sigs := make(chan os.Signal, 1) \n   signal.Notify(sigs) \n   go func() { \n         for { \n               sig := <-sigs \n               switch sig { \n               case os.Interrupt: \n                     handleSignal(sig) \n               case syscall.SIGTERM: \n                     handleSignal(sig) \n                     os.Exit(-1) \n               case syscall.SIGUSR1: \n                     handleSignal(sig) \n               default: \n                     fmt.Println(\"Ignoring:\", sig) \n               } \n         } \n   }() \n```", "```go\n   for { \n         fmt.Printf(\".\") \n         time.Sleep(10 * time.Second) \n   } \n} \n```", "```go\n$ ./catchAll\n.Ignoring: hangup\n.......................................* Got: interrupt\n* Got: user defined signal 1\n.Ignoring: user defined signal 2\nIgnoring: hangup\n.* Got: terminated\n$\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"log\" \n   \"os\" \n   \"os/signal\" \n   \"strconv\" \n   \"syscall\" \n   \"time\" \n) \n\nvar TOTALWRITES int = 0 \nvar openLogFile os.File \n```", "```go\nfunc rotateLogFile(filename string) error { \n   openLogFile.Close() \n   os.Rename(filename, filename+\".\"+strconv.Itoa(TOTALWRITES)) \n   err := setUpLogFile(filename) \n   return err \n} \n\nfunc setUpLogFile(filename string) error { \n   openLogFile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644) \n   if err != nil { \n         return err \n   } \n   log.SetOutput(openLogFile) \n   return nil \n} \n```", "```go\nfunc main() { \n   filename := \"/tmp/myLog.log\" \n   err := setUpLogFile(filename) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(-1) \n   } \n\n   sigs := make(chan os.Signal, 1) \n   signal.Notify(sigs) \n```", "```go\n   go func() { \n         for { \n               sig := <-sigs \n               switch sig { \n               case os.Interrupt: \n                     rotateLogFile(filename) \n                     TOTALWRITES++ \n               case syscall.SIGTERM: \n                     log.Println(\"Got:\", sig) \n                     openLogFile.Close() \n                     TOTALWRITES++ \n                     fmt.Println(\"Wrote\", TOTALWRITES, \"log entries in total!\") \n                     os.Exit(-1) \n               default: \n                     log.Println(\"Got:\", sig) \n                     TOTALWRITES++ \n               } \n         } \n   }() \n\n   for { \n         time.Sleep(10 * time.Second) \n   } \n} \n```", "```go\n$ diff rotateLog.go rotateSignals.go\n6a7\n>     \"os/signal\"\n7a9\n>     \"syscall\"\n12,13d13\n< var ENTRIESPERLOGFILE int = 100\n< var WHENTOSTOP int = 230\n33d32\n<     numberOfLogEntries := 0\n41,51c40,59\n<     for {\n<           log.Println(numberOfLogEntries, \"This is a test log entry\")\n<           numberOfLogEntries++\n<           TOTALWRITES++\n<           if numberOfLogEntries > ENTRIESPERLOGFILE {\n<                 _ = rotateLogFile(filename)\n<                 numberOfLogEntries = 0\n<           }\n<           if TOTALWRITES > WHENTOSTOP {\n<                 _ = rotateLogFile(filename)\n<                 break\n---\n>     sigs := make(chan os.Signal, 1)\n>     signal.Notify(sigs)\n>\n>     go func() {\n>           for {\n>                 sig := <-sigs\n>                 switch sig {\n>                 case os.Interrupt:\n>                       rotateLogFile(filename)\n>                       TOTALWRITES++\n>                 case syscall.SIGTERM:\n>                       log.Println(\"Got:\", sig)\n>                       openLogFile.Close()\n>                       TOTALWRITES++\n>                       fmt.Println(\"Wrote\", TOTALWRITES, \"log entries in total!\")\n>                       os.Exit(-1)\n>                 default:\n>                       log.Println(\"Got:\", sig)\n>                       TOTALWRITES++\n>                 }\n53c61,64\n<           time.Sleep(time.Second)\n---\n>     }()\n>\n>     for {\n>           time.Sleep(10 * time.Second)\n55d65\n<     fmt.Println(\"Wrote\", TOTALWRITES, \"log entries!\")\n```", "```go\n$ cat /tmp/myLog.log\n2017/06/03 14:53:33 Got: user defined signal 1\n2017/06/03 14:54:08 Got: user defined signal 1\n2017/06/03 14:54:12 Got: user defined signal 2\n2017/06/03 14:54:19 Got: terminated\n```", "```go\n$ ls -l /tmp/myLog.log*\n-rw-r--r--  1 mtsouk  wheel  177 Jun  3 14:54 /tmp/myLog.log\n-rw-r--r--  1 mtsouk  wheel  106 Jun  3 13:42 /tmp/myLog.log.0\n```", "```go\n$ cp FileToCopy /tmp/copy\nFileToCopy -> /tmp/copy  26%\nFileToCopy -> /tmp/copy  29%\nFileToCopy -> /tmp/copy  31%\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"io\" \n   \"os\" \n   \"os/signal\" \n   \"path/filepath\" \n   \"strconv\" \n   \"syscall\" \n) \n\nvar BUFFERSIZE int64 \nvar FILESIZE int64 \nvar BYTESWRITTEN int64 \n```", "```go\nfunc Copy(src, dst string, BUFFERSIZE int64) error { \n   sourceFileStat, err := os.Stat(src) \n   if err != nil { \n         return err \n   } \n\n   FILESIZE = sourceFileStat.Size() \n\n   if !sourceFileStat.Mode().IsRegular() { \n         return fmt.Errorf(\"%s is not a regular file.\", src) \n   } \n\n   source, err := os.Open(src) \n   if err != nil { \n         return err \n   } \n   defer source.Close() \n\n   _, err = os.Stat(dst) \n   if err == nil { \n         return fmt.Errorf(\"File %s already exists.\", dst) \n   } \n\n   destination, err := os.Create(dst) \n   if err != nil { \n         return err \n   } \n   defer destination.Close() \n\n   if err != nil { \n         panic(err) \n   } \n\n   buf := make([]byte, BUFFERSIZE) \n   for { \n         n, err := source.Read(buf) \n         if err != nil && err != io.EOF { \n               return err \n         } \n         if n == 0 { \n               break \n         } \n         if _, err := destination.Write(buf[:n]); err != nil { \n               return err \n         } \n         BYTESWRITTEN = BYTESWRITTEN + int64(n) \n   } \n   return err \n} \n```", "```go\nfunc progressInfo() { \n   progress := float64(BYTESWRITTEN) / float64(FILESIZE) * 100 \n   fmt.Printf(\"Progress: %.2f%%\\n\", progress) \n} \n\nfunc main() { \n   if len(os.Args) != 4 { \n         fmt.Printf(\"usage: %s source destination BUFFERSIZE\\n\", filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n\n   source := os.Args[1] \n   destination := os.Args[2] \n   BUFFERSIZE, _ = strconv.ParseInt(os.Args[3], 10, 64) \n   BYTESWRITTEN = 0 \n\n   sigs := make(chan os.Signal, 1) \n   signal.Notify(sigs) \n```", "```go\n   go func() { \n         for {\n               sig := <-sigs \n               switch sig { \n               case syscall.SIGINFO:\n                     progressInfo() \n               default: \n                     fmt.Println(\"Ignored:\", sig) \n               } \n         } \n   }() \n\n   fmt.Printf(\"Copying %s to %s\\n\", source, destination) \n   err := Copy(source, destination, BUFFERSIZE) \n   if err != nil { \n         fmt.Printf(\"File copying failed: %q\\n\", err) \n   } \n} \n```", "```go\n$ ./cpSignal FileToCopy /tmp/copy 2\nCopying FileToCopy to /tmp/copy\nIgnored: user defined signal 1\nProgress: 21.83%\n^CIgnored: interrupt\nProgress: 29.78%\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"image\" \n   \"image/color\" \n   \"image/png\" \n   \"io\" \n   \"os\" \n   \"path/filepath\" \n   \"regexp\" \n   \"strconv\" \n) \n\nvar m *image.NRGBA\nvar x int \nvar y int \nvar barWidth int \n```", "```go\nfunc findIP(input string) string { \n   partIP := \"(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\" \n   grammar := partIP + \"\\\\.\" + partIP + \"\\\\.\" + partIP + \"\\\\.\" + partIP \n   matchMe := regexp.MustCompile(grammar) \n   return matchMe.FindString(input) \n} \n\nfunc plotBar(width int, height int, color color.RGBA) { \n   xx := 0\n   for xx < barWidth { \n         yy := 0 \n         for yy < height { \n               m.Set(xx+width, y-yy, color) \n               yy = yy + 1 \n         } \n         xx = xx + 1 \n   } \n} \n```", "```go\nfunc getColor(x int) color.RGBA { \n   switch {\n\n   case x == 0: \n         return color.RGBA{0, 0, 255, 255} \n   case x == 1: \n         return color.RGBA{255, 0, 0, 255} \n   case x == 2: \n         return color.RGBA{0, 255, 0, 255} \n   case x == 3: \n         return color.RGBA{255, 255, 0, 255} \n   case x == 4: \n         return color.RGBA{255, 0, 255, 255} \n   case x == 5: \n         return color.RGBA{0, 255, 255, 255} \n   case x == 6: \n         return color.RGBA{255, 100, 100, 255} \n   case x == 7: \n         return color.RGBA{100, 100, 255, 255} \n   case x == 8: \n         return color.RGBA{100, 255, 255, 255} \n   case x == 9: \n         return color.RGBA{255, 255, 255, 255} \n   } \n   return color.RGBA{0, 0, 0, 255} \n} \n```", "```go\nfunc main() { \n   var data []int \n   arguments := os.Args \n   if len(arguments) < 4 { \n         fmt.Printf(\"%s X Y IP input\\n\", filepath.Base(arguments[0])) \n         os.Exit(0) \n   } \n\n   x, _ = strconv.Atoi(arguments[1]) \n   y, _ = strconv.Atoi(arguments[2]) \n   WANTED := arguments[3] \n   fmt.Println(\"Image size:\", x, y) \n```", "```go\n   for _, filename := range arguments[4:] { \n         count := 0 \n         fmt.Println(filename) \n         f, err := os.Open(filename) \n         if err != nil { \n               fmt.Fprintf(os.Stderr, \"Error: %s\\n\", err) \n               continue \n         } \n         defer f.Close() \n\n         r := bufio.NewReader(f) \n         for { \n               line, err := r.ReadString('\\n') \n               if err == io.EOF { \n                     break \n               } \n\nif err != nil { \n                fmt.Fprintf(os.Stderr, \"Error in file: %s\\n\", err) \n                     continue \n               } \n               ip := findIP(line) \n               if ip == WANTED { \n                     count++\n\n               } \n         } \n         data = append(data, count) \n   } \n```", "```go\n   fmt.Println(\"Slice length:\", len(data)) \n   if len(data)*2 > x { \n         fmt.Println(\"Image size (x) too small!\") \n         os.Exit(-1) \n   } \n\n   maxValue := data[0] \n   for _, temp := range data { \n         if maxValue < temp { \n               maxValue = temp \n         } \n   } \n\n   if maxValue > y { \n         fmt.Println(\"Image size (y) too small!\") \n         os.Exit(-1) \n   } \n   fmt.Println(\"maxValue:\", maxValue) \n   barHeighPerUnit := int(y / maxValue) \n   fmt.Println(\"barHeighPerUnit:\", barHeighPerUnit) \n   PNGfile := WANTED + \".png\" \n   OUTPUT, err := os.OpenFile(PNGfile, os.O_CREATE|os.O_WRONLY, 0644) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(-1) \n   } \n   m = image.NewNRGBA(image.Rectangle{Min: image.Point{0, 0}, Max: image.Point{x, y}}) \n```", "```go\n   i := 0 \n   barWidth = int(x / len(data)) \n   fmt.Println(\"barWidth:\", barWidth) \n   for _, v := range data { \n         c := getColor(v % 10) \n         yy := v * barHeighPerUnit \n         plotBar(barWidth*i, yy, c) \n         fmt.Println(\"plotBar\", barWidth*i, yy) \n         i = i + 1 \n   } \n   png.Encode(OUTPUT, m) \n} \n```", "```go\n$ go run plotIP.go 1300 1500 127.0.0.1 /tmp/log.*\nImage size: 1300 1500\n/tmp/log.1\n/tmp/log.2\n/tmp/log.3\nSlice length: 3\nmaxValue: 1500\nbarHeighPerUnit: 1\nbarWidth: 433\nplotBar 0 1500\nplotBar 433 1228\nplotBar 866 532\n$  ls -l 127.0.0.1.png\n-rw-r--r-- 1 mtsouk mtsouk 11023 Jun  5 18:36 127.0.0.1.png\n```", "```go\n$ go run plotIP.go 130 150 127.0.0.1 doNOTExist 2> err\nImage size: 130 150\ndoNOTExist\nSlice length: 0\n$ cat err\nError: open doNOTExist: no such file or directory\npanic: runtime error: index out of range\n\ngoroutine 1 [running]:\nmain.main()\n     /Users/mtsouk/Desktop/goBook/ch/ch8/code/plotIP.go:112 +0x12de\nexit status 2\n```", "```go\n$ go run plotIP.go 1300 1500 127.0.0.1 doNOTExist 2>/dev/null\nImage size: 1300 1500\ndoNOTExist\nSlice length: 0  \n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"os\" \n) \n```", "```go\nfunc main() { \n   filename := \"\" \n   var f *os.File \n   arguments := os.Args \n   if len(arguments) == 1 { \n         f = os.Stdin \n   } else { \n         filename = arguments[1] \n         fileHandler, err := os.Open(filename) \n         if err != nil { \n               fmt.Printf(\"error opening %s: %s\", filename, err) \n               os.Exit(1) \n         } \n         f = fileHandler \n   } \n   defer f.Close() \n```", "```go\n   scanner := bufio.NewScanner(f) \n   for scanner.Scan() { \n         fmt.Println(\">\", scanner.Text()) \n   } \n} \n```", "```go\n$ cat /tmp/testfile\n1\n2\n$ go run readSTDIN.go /tmp/testFile\n> 1\n> 2\n$ cat /tmp/testFile | go run readSTDIN.go\n> 1\n> 2\n$ go run readSTDIN.go\n3\n> 3\n2\n> 2\n1\n> 1\n```", "```go\npackage main \n\nimport ( \n   \"io\" \n   \"os\" \n) \n```", "```go\nfunc main() { \n   myString := \"\" \n   arguments := os.Args \n   if len(arguments) == 1 { \n         myString = \"You did not give an argument!\" \n   } else { \n         myString = arguments[1] \n   } \n```", "```go\n   io.WriteString(os.Stdout, myString) \n   io.WriteString(os.Stdout, \"\\n\") \n} \n```", "```go\n$ go run writeSTDOUT.go 123456\n123456\n$ go run writeSTDOUT.go\nYou do not give an argument!\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"io\" \n   \"os\" \n) \n```", "```go\nfunc catFile(filename string) error { \n   f, err := os.Open(filename) \n   if err != nil { \n         return err \n   } \n   defer f.Close() \n   scanner := bufio.NewScanner(f) \n   for scanner.Scan() { \n         fmt.Println(scanner.Text()) \n   } \n   return nil \n} \n```", "```go\nfunc main() { \n   filename := \"\" \n   arguments := os.Args \n   if len(arguments) == 1 { \n         io.Copy(os.Stdout, os.Stdin) \n         os.Exit(0) \n   } \n\n   filename = arguments[1] \n   err := catFile(filename) \n   if err != nil { \n         fmt.Println(err) \n   } \n} \n```", "```go\n$ go run cat.go /tmp/testFile  |  go run cat.go\n1\n2\n$ go run cat.go\nMihalis\nMihalis\nTsoukalos\nTsoukalos $ echo \"Mihalis Tsoukalos\" | go run cat.go\nMihalis Tsoukalos\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"io\" \n   \"os\" \n   \"path/filepath\" \n   \"regexp\" \n) \n```", "```go\nfunc findIP(input string) string { \n   partIP := \"(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\" \n   grammar := partIP + \"\\\\.\" + partIP + \"\\\\.\" + partIP + \"\\\\.\" + partIP \n   matchMe := regexp.MustCompile(grammar) \n   return matchMe.FindString(input) \n} \n```", "```go\nfunc main() { \n   arguments := os.Args \n   if len(arguments) < 3 { \n         fmt.Printf(\"%s IP <files>\\n\", filepath.Base(os.Args[0])) \n         os.Exit(-1) \n   } \n\n   WANTED := arguments[1] \n   for _, filename := range arguments[2:] { \n         count := 0 \n         buf := []byte(filename)\n         io.WriteString(os.Stdout, string(buf)) \n         f, err := os.Open(filename) \n         if err != nil { \n               fmt.Fprintf(os.Stderr, \"Error: %s\\n\", err) \n               continue \n         } \n         defer f.Close() \n```", "```go\n         r := bufio.NewReader(f) \n         for { \n               line, err := r.ReadString('\\n') \n               if err == io.EOF { \n                     break \n               } else if err != nil { \n                     fmt.Fprintf(os.Stderr, \"Error in file: %s\\n\", err) \n                     continue \n               } \n\n               ip := findIP(line) \n               if ip == WANTED { \n                     count = count + 1 \n               } \n         } \n         buf = []byte(strconv.Itoa(count))\n         io.WriteString(os.Stdout, \" \") \n         io.WriteString(os.Stdout, string(buf)) \n         io.WriteString(os.Stdout, \"\\n\") \n   } \n} \n```", "```go\n$ ./extractData 127.0.0.1 access.log{,.1}\naccess.log 3099\naccess.log.1 6333\n```", "```go\n$ ./extractData 127.0.0.1 access.log{,.1} | awk '{print $2}'\n3099\n6333\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"image\" \n   \"image/color\" \n   \"image/png\" \n   \"os\" \n   \"path/filepath\" \n   \"strconv\" \n) \n\nvar m *image.NRGBA \nvar x int \nvar y int \nvar barWidth int \n```", "```go\nfunc plotBar(width int, height int, color color.RGBA) { \n   xx := 0\n   for xx < barWidth { \n         yy := 0 \n         for yy < height { \n               m.Set(xx+width, y-yy, color) \n               yy = yy + 1 \n         } \n         xx = xx + 1 \n   } \n} \n```", "```go\nfunc getColor(x int) color.RGBA { \n   switch {\n   case x == 0: \n         return color.RGBA{0, 0, 255, 255} \n   case x == 1: \n         return color.RGBA{255, 0, 0, 255} \n   case x == 2: \n         return color.RGBA{0, 255, 0, 255} \n   case x == 3: \n         return color.RGBA{255, 255, 0, 255} \n   case x == 4: \n         return color.RGBA{255, 0, 255, 255} \n   case x == 5: \n         return color.RGBA{0, 255, 255, 255} \n   case x == 6: \n         return color.RGBA{255, 100, 100, 255} \n   case x == 7: \n         return color.RGBA{100, 100, 255, 255} \n   case x == 8: \n         return color.RGBA{100, 255, 255, 255} \n   case x == 9: \n         return color.RGBA{255, 255, 255, 255} \n   } \n   return color.RGBA{0, 0, 0, 255} \n} \n```", "```go\nfunc main() { \n   var data []int \n   var f *os.File \n   arguments := os.Args \n   if len(arguments) < 3 { \n         fmt.Printf(\"%s X Y input\\n\", filepath.Base(arguments[0])) \n         os.Exit(0) \n   } \n\n   if len(arguments) == 3 { \n         f = os.Stdin \n   } else { \n         filename := arguments[3] \n         fTemp, err := os.Open(filename) \n         if err != nil { \n               fmt.Println(err) \n               os.Exit(0) \n         } \n         f = fTemp \n   } \n   defer f.Close() \n\n   x, _ = strconv.Atoi(arguments[1]) \n   y, _ = strconv.Atoi(arguments[2]) \n   fmt.Println(\"Image size:\", x, y) \n```", "```go\n   scanner := bufio.NewScanner(f) \n   for scanner.Scan() { \n         value, err := strconv.Atoi(scanner.Text()) \n         if err == nil { \n               data = append(data, value) \n         } else { \n               fmt.Println(\"Error:\", value) \n         } \n   } \n\n   fmt.Println(\"Slice length:\", len(data)) \n   if len(data)*2 > x { \n         fmt.Println(\"Image size (x) too small!\") \n         os.Exit(-1) \n   } \n\n   maxValue := data[0] \n   for _, temp := range data { \n         if maxValue < temp { \n               maxValue = temp \n         } \n   } \n\n   if maxValue > y { \n         fmt.Println(\"Image size (y) too small!\") \n         os.Exit(-1) \n   } \n   fmt.Println(\"maxValue:\", maxValue) \n   barHeighPerUnit := int(y / maxValue) \n   fmt.Println(\"barHeighPerUnit:\", barHeighPerUnit) \n```", "```go\n   PNGfile := arguments[1] + \"x\" + arguments[2] + \".png\" \n   OUTPUT, err := os.OpenFile(PNGfile, os.O_CREATE|os.O_WRONLY, 0644) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(-1) \n   } \n   m = image.NewNRGBA(image.Rectangle{Min: image.Point{0, 0}, Max: image.Point{x, y}}) \n\n   i := 0 \n   barWidth = int(x / len(data)) \n   fmt.Println(\"barWidth:\", barWidth) \n   for _, v := range data { \n         c := getColor(v % 10) \n         yy := v * barHeighPerUnit \n         plotBar(barWidth*i, yy, c) \n         fmt.Println(\"plotBar\", barWidth*i, yy) \n         i = i + 1 \n   } \n\n   png.Encode(OUTPUT, m) \n} \n```", "```go\n$ ./extractData.go 127.0.0.1 access.log{,.1} | awk '{print $2}' | ./plotData 6000 6500\nImage size: 6000 6500\nSlice length: 2\nmaxValue: 6333\nbarHeighPerUnit: 1\nbarWidth: 3000\nplotBar 0 3129\nplotBar 3000 6333\n$ ls -l 6000x6500.png\n-rw-r--r-- 1 mtsouk mtsouk 164915 Jun  5 18:25 6000x6500.png\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"io\" \n   \"net\" \n   \"strconv\" \n   \"time\" \n) \n```", "```go\nfunc readSocket(r io.Reader) { \n   buf := make([]byte, 1024) \n   for { \n         n, _ := r.Read(buf[:]) \n         fmt.Print(\"Read: \", string(buf[0:n])) \n   } \n} \n```", "```go\nfunc main() { \n   c, _ := net.Dial(\"unix\", \"/tmp/aSocket.sock\") \n   defer c.Close() \n\n   go readSocket(c) \n   n := 0 \n   for { \n         message := []byte(\"Hi there: \" + strconv.Itoa(n) + \"\\n\") \n         _, _ = c.Write(message) \n         time.Sleep(5 * time.Second) \n         n = n + 1 \n   } \n} \n```", "```go\n$ go run readUNIX.go\nRead: Hi there: 0\nRead: Hi there: 1\n```", "```go\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x10cfe77]\n\ngoroutine 1 [running]:\nmain.main()\n      /Users/mtsouk/Desktop/goBook/ch/ch8/code/readUNIX.go:21 +0x67\nexit status 2\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n) \n\nfunc main() { \n\n   // Present prompt \n\n   // Read a line \n\n   // Get the first word of the line \n\n   // If it is a built-in shell command, execute the command \n\n   // otherwise, echo the command \n\n} \n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"os\" \n   \"strings\" \n) \n\nvar VERSION string = \"0.2\" \n```", "```go\nfunc main() { \n   scanner := bufio.NewScanner(os.Stdin) \n   fmt.Print(\"> \") \n   for scanner.Scan() { \n\n         line := scanner.Text() \n         words := strings.Split(line, \" \") \n         command := words[0] \n```", "```go\n         switch command { \n         case \"exit\": \n               fmt.Println(\"Exiting...\") \n               os.Exit(0) \n         case \"version\": \n               fmt.Println(VERSION) \n         default: \n               fmt.Println(line) \n         } \n\n         fmt.Print(\"> \") \n   } \n} \n```", "```go\n$ go run UNIXshell.go\n> version\n0.2\n> ls -l\nls -l\n> exit\nExiting...\n```", "```go\n$ date\nThu May 25 06:30:53 EEST 2017\n$ go version\ngo version go1.8.3 darwin/amd64\n```"]