["```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"time\" \n) \n\nfunc namedFunction() { \n   time.Sleep(10000 * time.Microsecond) \n   fmt.Println(\"Printing from namedFunction!\") \n} \n```", "```go\nfunc main() { \n   fmt.Println(\"Chapter 09 - Goroutines.\") \n   go namedFunction() \n```", "```go\n   go func() { \n         fmt.Println(\"An anonymous function!\") \n   }() \n\n   time.Sleep(10000 * time.Microsecond) \n   fmt.Println(\"Exiting...\") \n} \n```", "```go\n$ go run aGoroutine.go\nChapter 09 - Goroutines.\nPrinting from namedFunction!\nExiting... \n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"time\" \n) \n```", "```go\nfunc main() { \n   fmt.Println(\"Chapter 09 - Goroutines.\") \n\n   for i := 0; i < 10; i++ { \n         go func(x int) { \n               time.Sleep(10) \n               fmt.Printf(\"%d \", x) \n         }(i) \n   } \n```", "```go\n   time.Sleep(10000) \n   fmt.Println(\"Exiting...\") \n} \n```", "```go\n$ go run moreGoroutines.go\nChapter 09 - Goroutines.\n1 7 Exiting...\n2 3\n```", "```go\n$ go run moreGoroutines.go\nChapter 09 - Goroutines.\nExiting...\n$ go run moreGoroutines.go\nChapter 09 - Goroutines.\n3 1 0 9 2 Exiting...\n4 5 6 8 7\n$ go run moreGoroutines.go\nChapter 09 - Goroutines.\n2 0 1 8 7 3 6 5 Exiting...\n4\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"sync\" \n) \n```", "```go\nfunc main() { \n   fmt.Println(\"Waiting for Goroutines!\") \n\n   var waitGroup sync.WaitGroup \n   waitGroup.Add(10) \n```", "```go\n   var i int64 \n   for i = 0; i < 10; i++ { \n\n         go func(x int64) { \n               defer waitGroup.Done() \n               fmt.Printf(\"%d \", x) \n         }(i) \n   } \n```", "```go\n   waitGroup.Wait() \n   fmt.Println(\"\\nExiting...\") \n} \n```", "```go\n$ go run waitGR.go\nWaiting for Goroutines!\n9 0 5 6 7 8 2 1 3 4\nExiting...\n$ go run waitGR.go\nWaiting for Goroutines!\n9 0 5 6 7 8 3 1 2 4\nExiting...\n$ go run waitGR.go\nWaiting for Goroutines!\n9 5 6 7 8 1 0 2 3 4\nExiting...\n```", "```go\nWaiting for Goroutines!\nfatal error: all goroutines are asleep - deadlock!\n\ngoroutine 1 [semacquire]:\nsync.runtime_Semacquire(0xc42000e28c)\n      /usr/local/Cellar/go/1.8.3/libexec/src/runtime/sema.go:47 +0x34\nsync.(*WaitGroup).Wait(0xc42000e280)\n      /usr/local/Cellar/go/1.8.3/libexec/src/sync/waitgroup.go:131 +0x7a\nmain.main()\n      /Users/mtsouk/ch/ch9/code/waitGR.go:22 +0x13c\nexit status 2\n9 0 1 2 6 7 8 3 4 5\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"path/filepath\" \n   \"strconv\" \n   \"sync\" \n) \n```", "```go\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Printf(\"usage: %s integer\\n\",filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n\n   numGR, _ := strconv.ParseInt(os.Args[1], 10, 64) \n   fmt.Printf(\"Going to create %d goroutines.\\n\", numGR) \n   var waitGroup sync.WaitGroup \n\n   var i int64 \n   for i = 0; i < numGR; i++ { \n         waitGroup.Add(1) \n```", "```go\n         go func(x int64) { \n               defer waitGroup.Done() \n               fmt.Printf(\" %d \", x) \n         }(i) \n   } \n```", "```go\n   waitGroup.Wait() \n   fmt.Println(\"\\nExiting...\") \n} \n```", "```go\n$ go run dynamicGR.go 15\nGoing to create 15 goroutines.\n 0  2  4  1  3  5  14  10  8  9  12  11  6  13  7\nExiting...\n$ go run dynamicGR.go 15\nGoing to create 15 goroutines.\n 5  3  14  4  10  6  7  11  8  9  12  2  13  1  0\nExiting...\n$ go run dynamicGR.go 15\nGoing to create 15 goroutines.\n 4  2  3  6  5  10  9  7  0  12  11  1  14  13  8\nExiting...\n```", "```go\n# command-line-arguments\n./writeChannel.go:13: invalid operation: <-c (receive from send-only type chan<- int)\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"time\" \n) \n```", "```go\nfunc writeChannel(c chan<- int, x int) { \n   fmt.Println(x) \n   c <- x \n   close(c) \n   fmt.Println(x) \n} \n```", "```go\nfunc main() { \n   c := make(chan int) \n   go writeChannel(c, 10) \n   time.Sleep(2 * time.Second) \n} \n```", "```go\n $ go run writeChannel.go\n 10\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"time\" \n) \n```", "```go\nfunc writeChannel(c chan<- int, x int) { \n   fmt.Println(x) \n   c <- x \n   close(c) \n   fmt.Println(x) \n} \n```", "```go\nfunc main() { \n   c := make(chan int) \n   go writeChannel(c, 10) \n   time.Sleep(2 * time.Second) \n   fmt.Println(\"Read:\", <-c) \n   time.Sleep(2 * time.Second) \n```", "```go\n   _, ok := <-c \n   if ok { \n         fmt.Println(\"Channel is open!\") \n   } else { \n         fmt.Println(\"Channel is closed!\") \n   } \n} \n```", "```go\n$ go run readChannel.go\n10\nRead: 10\n10\nChannel is closed!\n$ go run readChannel.go\n10\n10\nRead: 10\nChannel is closed!\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"path/filepath\" \n   \"strconv\" \n) \n```", "```go\nfunc genNumbers(min, max int64, out chan<- int64) { \n\n   var i int64 \n   for i = min; i <= max; i++ { \n         out <- i \n   } \n   close(out) \n} \n```", "```go\nfunc findSquares(out chan<- int64, in <-chan int64) { \n   for x := range in { \n         out <- x * x \n   } \n   close(out) \n} \n```", "```go\nfunc calcSum(in <-chan int64) { \n   var sum int64 \n   sum = 0 \n   for x2 := range in { \n         sum = sum + x2 \n   } \n   fmt.Printf(\"The sum of squares is %d\\n\", sum) \n} \n```", "```go\nfunc main() { \n   if len(os.Args) != 3 { \n         fmt.Printf(\"usage: %s n1 n2\\n\", filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n   n1, _ := strconv.ParseInt(os.Args[1], 10, 64) \n   n2, _ := strconv.ParseInt(os.Args[2], 10, 64) \n\n   if n1 > n2 { \n         fmt.Printf(\"%d should be smaller than %d\\n\", n1, n2) \n         os.Exit(10) \n   } \n\n   naturals := make(chan int64) \n   squares := make(chan int64) \n   go genNumbers(n1, n2, naturals) \n   go findSquares(squares, naturals) \n   calcSum(squares) \n} \n```", "```go\n$ go run pipelines.go\nusage: pipelines n1 n2\nexit status 1\n$ go run pipelines.go 3 2\n3 should be smaller than 2\nexit status 10\n$ go run pipelines.go 3 20\nThe sum of squares is 2865\n$ go run pipelines.go 1 20\nThe sum of squares is 2870\n$ go run pipelines.go 20 20\nThe sum of squares is 400\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"io\" \n   \"os\" \n   \"path/filepath\" \n   \"regexp\" \n   \"sync\" \n) \n```", "```go\nfunc count(filename string) { \n   var err error \n   var numberOfLines int = 0 \n   var numberOfCharacters int = 0 \n   var numberOfWords int = 0 \n\n   f, err := os.Open(filename) \n   if err != nil { \n         fmt.Printf(\"%s\\n\", err) \n         return \n   } \n   defer f.Close() \n\n   r := bufio.NewReader(f) \n   for { \n         line, err := r.ReadString('\\n') \n\n         if err == io.EOF { \n               break \n         } else if err != nil { \n               fmt.Printf(\"error reading file %s\\n\", err) \n         } \n         numberOfLines++ \n         r := regexp.MustCompile(\"[^\\\\s]+\") \n         for range r.FindAllString(line, -1) { \n               numberOfWords++ \n         } \n         numberOfCharacters += len(line) \n   } \n\n   fmt.Printf(\"\\t%d\\t\", numberOfLines) \n   fmt.Printf(\"%d\\t\", numberOfWords) \n   fmt.Printf(\"%d\\t\", numberOfCharacters) \n   fmt.Printf(\"%s\\n\", filename) \n} \n```", "```go\nfunc main() { \n   if len(os.Args) == 1 { \n         fmt.Printf(\"usage: %s <file1> [<file2> [... <fileN]]\\n\", \n               filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n```", "```go\n   var waitGroup sync.WaitGroup \n   for _, filename := range os.Args[1:] { \n         waitGroup.Add(1) \n         go func(filename string) { \n               count(filename) \n               defer waitGroup.Done() \n         }(filename) \n   } \n   waitGroup.Wait() \n} \n```", "```go\n$ go run dWC.go /tmp/swtag.log /tmp/swtag.log doesnotExist\nopen doesnotExist: no such file or directory\n          48    275   3571  /tmp/swtag.log\n          48    275   3571  /tmp/swtag.log\n\n```", "```go\n$ go run dWC.go /tmp/swtag.log /tmp/swtag.log | awk '{sum1+=$1; sum2+=$2; sum3+=$3} END {print \"\\t\", sum1, \"\\t\", sum2, \"\\t\", sum3}'\n       96    550   7142\n\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"io\" \n   \"os\" \n   \"path/filepath\" \n   \"regexp\" \n) \n\ntype File struct { \n   Filename   string \n   Lines      int \n   Words      int \n   Characters int \n   Error      error \n} \n```", "```go\nfunc process(files []string, out chan<- File) { \n   for _, filename := range files { \n         var fileToProcess File \n         fileToProcess.Filename = filename \n         fileToProcess.Lines = 0 \n         fileToProcess.Words = 0 \n         fileToProcess.Characters = 0 \n         out <- fileToProcess \n   } \n   close(out) \n} \n```", "```go\nfunc count(in <-chan File, out chan<- File) { \n   for y := range in { \n         filename := y.Filename \n         f, err := os.Open(filename) \n         if err != nil { \n               y.Error = err \n               out <- y \n               continue \n         } \n         defer f.Close() \n         r := bufio.NewReader(f) \n         for { \n               line, err := r.ReadString('\\n') \n               if err == io.EOF { \n                     break \n               } else if err != nil { \n                     fmt.Printf(\"error reading file %s\", err) \n                     y.Error = err \n                     out <- y \n                     continue \n               } \n               y.Lines = y.Lines + 1 \n               r := regexp.MustCompile(\"[^\\\\s]+\") \n               for range r.FindAllString(line, -1) { \n                     y.Words = y.Words + 1 \n               } \n               y.Characters = y.Characters + len(line) \n         } \n         out <- y \n   } \n   close(out) \n} \n```", "```go\nfatal error: all goroutines are asleep - deadlock!\n```", "```go\nfunc calculate(in <-chan File) { \n   var totalWords int = 0 \n   var totalLines int = 0 \n   var totalChars int = 0 \n   for x := range in { \n         totalWords = totalWords + x.Words \n         totalLines = totalLines + x.Lines \n         totalChars = totalChars + x.Characters \n         if x.Error == nil { \n               fmt.Printf(\"\\t%d\\t\", x.Lines) \n               fmt.Printf(\"%d\\t\", x.Words) \n               fmt.Printf(\"%d\\t\", x.Characters) \n               fmt.Printf(\"%s\\n\", x.Filename) \n         } \n   } \n\n   fmt.Printf(\"\\t%d\\t\", totalLines) \n   fmt.Printf(\"%d\\t\", totalWords) \n   fmt.Printf(\"%d\\ttotal\\n\", totalChars) \n} \n```", "```go\nfunc main() { \n   if len(os.Args) == 1 { \n         fmt.Printf(\"usage: %s <file1> [<file2> [... <fileN]]\\n\", \n               filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n\n   files := make(chan File)\n   values := make(chan File) \n\n   go process(os.Args[1:], files) \n   go count(files, values) \n   calculate(values) \n} \n```", "```go\n$ go run dWCtotal.go /tmp/swtag.log\n      48    275   3571  /tmp/swtag.log\n      48    275   3571  total\n$ go run dWCtotal.go /tmp/swtag.log /tmp/swtag.log doesNotExist\n      48    275   3571  /tmp/swtag.log\n      48    275   3571  /tmp/swtag.log\n      96    550   7142  total\n```", "```go\n$ wc /tmp/*.data\n  712804 3564024 9979897 /tmp/connections.data\n  285316  855948 4400685 /tmp/diskSpace.data\n  712523 1425046 8916670 /tmp/memory.data\n 1425500 2851000 5702000 /tmp/pageFaults.data\n  285658  840622 4313833 /tmp/uptime.data\n 3421801 9536640 33313085 total\n\n```", "```go\n$ time wc /tmp/*.data /tmp/*.data\n$ time wc /tmp/uptime.data /tmp/pageFaults.data\n$ time ./dWC /tmp/*.data /tmp/*.data\n$ time ./dWC /tmp/uptime.data /tmp/pageFaults.data\n$ time ./dWCtotal /tmp/*.data /tmp/*.data\n$ time ./dWCtotal /tmp/uptime.data /tmp/pageFaults.data\n$ time ./wc /tmp/uptime.data /tmp/pageFaults.data\n$ time ./wc /tmp/*.data /tmp/*.data\n```"]