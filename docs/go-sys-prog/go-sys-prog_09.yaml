- en: Goroutines - Basic Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines - 基本特性
- en: In the previous chapter, you learned about Unix signal handling as well as adding
    support for pipes and creating graphical images in Go.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了Unix信号处理，以及在Go中添加管道支持和创建图形图像。
- en: The subject of this really important chapter is goroutines. Go uses goroutines
    and **channels** in order to program concurrent applications in its own way while
    providing support for traditional concurrency techniques. Everything in Go is
    executed using goroutines; when a program starts its execution, its single goroutine
    automatically calls the  `main()` function in order to begin the actual execution
    of the program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常重要的章节的主题是goroutines。Go使用goroutines和**通道**来以自己的方式编写并发应用程序，同时提供对传统并发技术的支持。Go中的所有内容都使用goroutines执行；当程序开始执行时，其单个goroutine会自动调用`main()`函数，以开始程序的实际执行。
- en: In this chapter, we will present the easy parts of goroutines using easy to
    follow code examples. However, in [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*,*
    *Goroutines - Advanced Features*, that is coming next, we will talk about more
    important and advanced techniques related to goroutines and channels; so, make
    sure that you fully understand this chapter before reading the next one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍goroutines的简单部分，并提供易于遵循的代码示例。然而，在接下来的[第10章](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*，*
    *Goroutines - 高级特性*中，我们将讨论与goroutines和通道相关的更重要和高级的技术，因此，请确保在阅读下一章之前充分理解本章。
- en: 'Therefore, this chapter will tell you about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将告诉您以下内容：
- en: Creating goroutines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建goroutines
- en: Synchronizing goroutines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步goroutines
- en: About channels and how to use them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于通道以及如何使用它们
- en: Reading and writing to channels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入通道
- en: Creating and using pipelines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用管道
- en: Changing the Go code of the `wc.go` utility from [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml),
    *File Input and Output*, in order to use goroutines in the new implementation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改`wc.go`实用程序的Go代码，以便在新实现中使用goroutines
- en: Improving the goroutine version of `wc.go` even further
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步改进`wc.go`的goroutine版本
- en: About goroutines
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于goroutines
- en: A **goroutine** is the minimum Go entity that can be executed concurrently.
    Note that the use of the word *minimum* is very important here because goroutines
    are not autonomous entities. Goroutines live in threads that live in Unix processes.
    Putting it simply, processes can be autonomous and exist on their own, whereas
    both goroutines and threads cannot. So, in order to create a goroutine, you will
    need to have a process with at least one thread. The good thing is that goroutines
    are lighter than threads, which are lighter than processes. Everything in Go is
    executed using goroutines, which makes perfect sense since Go is a concurrent
    programming language by design. As you have just learned, when a Go program starts
    its execution, its single goroutine calls the `main()` function, which starts
    the actual program execution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**goroutine**是可以并发执行的最小Go实体。请注意，这里使用“最小”一词非常重要，因为goroutines不是自主实体。Goroutines存在于Unix进程中的线程中。简单来说，进程可以是自主的并独立存在，而goroutines和线程都不行。因此，要创建goroutine，您需要至少有一个带有线程的进程。好处是goroutines比线程轻，线程比进程轻。Go中的所有内容都使用goroutines执行，这是合理的，因为Go是一种并发编程语言。正如您刚刚了解的那样，当Go程序开始执行时，它的单个goroutine调用`main()`函数，从而启动实际的程序执行。'
- en: You can define a new goroutine using the `go` keyword followed by a function
    name or the full definition of an anonymous function. The `go` keyword starts
    the function argument to it in a new goroutine and allows the invoking function
    to continue on by itself.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`go`关键字后跟函数名或匿名函数的完整定义来定义新的goroutine。`go`关键字在新的goroutine中启动函数参数，并允许调用函数自行继续。
- en: However, as you will see, you cannot control or make any assumptions about the
    order your goroutines are going to get executed because this depends on the scheduler
    of the operating system as well as the load of the operating system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如您将看到的，您无法控制或做出任何关于goroutines将以何种顺序执行的假设，因为这取决于操作系统的调度程序以及操作系统的负载。
- en: Concurrency and parallelism
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和并行
- en: A very common misconception is that **concurrency** and **parallelism** refer
    to the same thing, which is far from true! Parallelism is the simultaneous execution
    of multiple things, whereas concurrency is a way of structuring your components
    so that they can be independently executed when possible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的误解是**并发**和**并行**指的是同一件事，这与事实相去甚远！并行是多个事物同时执行，而并发是一种构造组件的方式，使它们在可能的情况下可以独立执行。
- en: 'Only when you build things concurrently you can safely execute them in parallel:
    when and if your operating system and your hardware permit it. The Erlang programming
    language did this a long time ago, long before CPUs had multiple cores and computers
    had lots of RAM.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在并发构建时，您才能安全地并行执行它们：当且如果您的操作系统和硬件允许。很久以前，Erlang编程语言就已经做到了这一点，早在CPU拥有多个核心和计算机拥有大量RAM之前。
- en: In a valid concurrent design, adding concurrent entities makes the whole system
    run faster because more things can run in parallel. So, the desired parallelism
    comes from a better concurrent expression and implementation of the problem. The
    developer is responsible for taking concurrency into account during the design
    phase of a system and benefit from a potential parallel execution of the components
    of the system. So, the developer should not think about parallelism, but about
    breaking things into independent components that solve the initial problem when
    combined.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在有效的并发设计中，添加并发实体使整个系统运行更快，因为更多的事情可以并行运行。因此，期望的并行性来自于对问题的更好并发表达和实现。开发人员在系统设计阶段负责考虑并发，并从系统组件的潜在并行执行中受益。因此，开发人员不应该考虑并行性，而应该考虑将事物分解为独立组件，这些组件在组合时解决最初的问题。
- en: Even if you cannot run your functions in parallel on a Unix machine, a valid
    concurrent design will still improve the design and the maintainability of your
    programs. In other words, concurrency is better than parallelism!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在Unix机器上无法并行运行函数，有效的并发设计仍将改善程序的设计和可维护性。换句话说，并发比并行更好！
- en: The sync Go packages
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步Go包
- en: The `sync` Go package contains functions that can help you synchronize goroutines;
    the most important functions of `sync` are `sync.Add`, `sync.Done`, and `sync.Wait`.
    The synchronization of goroutines is a mandatory task for every programmer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync` Go包包含可以帮助您同步goroutines的函数；`sync`的最重要的函数是`sync.Add`、`sync.Done`和`sync.Wait`。对于每个程序员来说，同步goroutines是一项必不可少的任务。'
- en: Note that the synchronization of goroutines has nothing to do with shared variables
    and shared state. Shared variables and shared state have to do with the method
    you want to use for performing concurrent interactions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，goroutines的同步与共享变量和共享状态无关。共享变量和共享状态与您希望用于执行并发交互的方法有关。
- en: A simple example
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的例子
- en: 'In this subsection, we will present a simple program that creates two goroutines.
    The name of the sample program will be `aGoroutine.go` and will be presented in
    three parts; the first part is the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一小节中，我们将介绍一个简单的程序，它创建了两个goroutines。示例程序的名称将是`aGoroutine.go`，将分为三个部分；第一部分如下：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Apart from the expected `package` and `import` statements, you can see the implementation
    of a function named `namedFunction()` that sleeps for a while before printing
    a message on the screen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预期的`package`和`import`语句之外，您还可以看到一个名为`namedFunction()`的函数的实现，在打印屏幕上的消息之前会休眠一段时间。
- en: 'The second part of `aGoroutine.go` contains the following Go code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`aGoroutine.go`的第二部分包含以下Go代码：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, you create a goroutine that executes the `namedFunction()` function.
    The last part of this naive program is the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了一个执行`namedFunction()`函数的goroutine。这个天真程序的最后部分如下：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, you create another goroutine that executes an anonymous function that
    contains a single `fmt.Println()` statement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了另一个goroutine，它执行一个包含单个`fmt.Println()`语句的匿名函数。
- en: As you can see, goroutines that run this way are totally isolated from each
    other and cannot exchange any kind of data, which is not always the operational
    style that is desired.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，以这种方式运行的goroutines是完全隔离的，彼此之间无法交换任何类型的数据，这并不总是所期望的操作风格。
- en: If you forget to call the `time.Sleep()` function in the `main()` function,
    or if `time.Sleep()` sleeps for a small amount of time, then `main()` will finish
    too early and the two goroutines will not have enough time to start and therefore
    finish their jobs; as a result, you will not see all the expected output on your
    screen!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您忘记在`main()`函数中调用`time.Sleep()`函数，或者`time.Sleep()`睡眠了很短的时间，那么`main()`将会过早地结束，两个goroutines将没有足够的时间开始和完成它们的工作；结果，您将无法在屏幕上看到所有预期的输出！
- en: 'Executing `aGoroutine.go` will generate the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`aGoroutine.go`将生成以下输出：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating multiple goroutines
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多个goroutines
- en: This subsection will show you how to create many goroutines and the problems
    that arise from having to handle more goroutines. The name of the program will
    be `moreGoroutines.go` and will be presented in three parts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这一小节将向您展示如何创建许多goroutines以及处理更多goroutines所带来的问题。程序的名称将是`moreGoroutines.go`，将分为三个部分。
- en: 'The first part of `moreGoroutines.go` is the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`moreGoroutines.go`的第一部分如下：'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second part of the program has the following Go code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二部分包含以下Go代码：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time, the anonymous function takes a parameter named `x`, which has the
    value of the `i` variable. The `for` loop that uses the `i` variable creates ten
    goroutines, one by one.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，匿名函数接受一个名为`x`的参数，其值为变量`i`。使用变量`i`的`for`循环依次创建十个goroutines。
- en: 'The last part of the program is the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分如下：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once again, if you put a smaller value as the parameter to `time.Sleep()`, you
    will see different results when you execute the program.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果您将较小的值作为`time.Sleep()`的参数，当您执行程序时将会看到不同的结果。
- en: 'Executing `moreGoroutines.go` will generate a somehow strange output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`moreGoroutines.go`将生成一个有些奇怪的输出：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, the big surprise comes when you execute `moreGoroutines.go` multiple
    times:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您多次执行`moreGoroutines.go`时，大惊喜来了：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, all previous outputs of the program are different from the first
    one! So, not only the output is not coordinated and there is not always enough
    time for all goroutines to get executed; you cannot be sure about the order the
    goroutines will get executed. However, although you cannot do anything about the
    latter problem because the order that goroutines get executed depends on various
    parameters that the developer cannot control, the next subsection will teach you
    how to synchronize goroutines and give them enough time to finish without having
    to call `time.Sleep()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，程序的所有先前输出都与第一个不同！因此，输出不仅不协调，而且并不总是有足够的时间让所有goroutines执行；您无法确定goroutines将以何种顺序执行。然而，尽管您无法解决后一个问题，因为goroutines的执行顺序取决于开发人员无法控制的各种参数，下一小节将教您如何同步goroutines并为它们提供足够的时间完成，而无需调用`time.Sleep()`。
- en: Waiting for goroutines to finish their jobs
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待goroutines完成它们的工作
- en: 'This subsection will demonstrate to you the correct way to make a calling function
    that wait for its goroutines to finish their jobs. The name of the program will
    be `waitGR.go` and will be presented in four parts; the first part is the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这一小节将向您演示正确的方法来创建一个等待其goroutines完成工作的调用函数。程序的名称将是`waitGR.go`，将分为四个部分；第一部分如下：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is nothing special here apart from the absence of the `time` package and
    the addition of the `sync` package.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`time`包的缺失和`sync`包的添加之外，这里没有什么特别的。
- en: 'The second part has the following Go code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, you create a new variable with a type of `sync.WaitGroup`, which waits
    for a group of goroutines to finish. The number of goroutines that belong to that
    group is defined by one or multiple calls to the `sync.Add()` function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了一个新变量，类型为`sync.WaitGroup`，它等待一组goroutines完成。属于该组的goroutines的数量由一个或多个对`sync.Add()`函数的调用定义。
- en: Calling `sync.Add()` before the Go statement in order to prevent race conditions
    is important.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语句之前调用`sync.Add()`以防止竞争条件是很重要的。
- en: Additionally, the `sync.Add(10)` call tells our program that we will wait for
    ten goroutines to finish.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`sync.Add(10)`的调用告诉我们的程序，我们将等待十个goroutines完成。
- en: 'The third part of the program is the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分如下：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, you create the desired number of goroutines using a `for` loop, but you
    could have used multiple sequential Go statements. When each goroutine finishes
    its job, the `sync.Done()` function is executed: the use of the `defer` keyword
    right after the function definition tells the anonymous function to automatically
    call `sync.Done()` just before it finishes.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用`for`循环创建所需数量的goroutines，但也可以使用多个顺序的Go语句。当每个goroutine完成其工作时，将执行`sync.Done()`函数：在函数定义之后立即使用`defer`关键字告诉匿名函数在完成之前自动调用`sync.Done()`。
- en: 'The last part of `waitGR.go` is the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitGR.go`的最后一部分如下：'
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The good thing here is that there is no need to call `time.Sleep()` because
    `sync.Wait()` does the necessary waiting for us.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的好处是不需要调用`time.Sleep()`，因为`sync.Wait()`会为我们做必要的等待。
- en: 'Once again, it should be noted here that you should not make any assumptions
    about the order the goroutines will get executed in which is also verified by
    the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次应该注意的是，您不应该对goroutines的执行顺序做任何假设，这也由以下输出验证：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you call `waitGroup.Add()` more times than needed, you will get the following
    error message when you execute `waitGR.go`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您调用`waitGroup.Add()`的次数超过所需次数，当执行`waitGR.go`时，将收到以下错误消息：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This happens because when you tell your program to wait for n+1 goroutines by
    calling `sync.Add(1)` n+1 times, your program cannot have only n goroutines (or
    less)! Putting it simply, this will make `sync.Wait()` to wait indefinitely for
    one or more goroutines to call `sync.Done()` without any luck, which is obviously
    a deadlock situation that prevents your program from finishing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当您告诉程序通过调用`sync.Add(1)` n+1次来等待n+1个goroutines时，您的程序不能只有n个goroutines（或更少）！简单地说，这将使`sync.Wait()`无限期地等待一个或多个goroutines调用`sync.Done()`而没有任何运气，这显然是一个死锁的情况，阻止您的程序完成。
- en: Creating a dynamic number of goroutines
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动态数量的goroutines
- en: 'This time, the number of goroutines that will be created will be given as a
    command-line argument: the name of the program will be `dynamicGR.go` and will
    be presented in four parts.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，将作为命令行参数给出要创建的goroutines的数量：程序的名称将是`dynamicGR.go`，并将分为四个部分。
- en: 'The first part of `dynamicGR.go` is the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamicGR.go`的第一部分如下：'
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The second part of `dynamicGR.go` contains the following Go code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamicGR.go`的第二部分包含以下Go代码：'
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the `waitGroup.Add(1)` statement is called just before you create
    a new goroutine.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`waitGroup.Add(1)`语句是在创建新的goroutine之前调用的。
- en: 'The third part of the Go code of `dynamicGR.go` is the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamicGR.go`的Go代码的第三部分如下：'
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding part, each simplistic goroutine is created.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，创建了每个简单的goroutine。
- en: 'The last part of the program is the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一部分如下：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, you just tell the program to wait for all goroutines to finish using the
    `waitGroup.Wait()` statement.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您只需告诉程序使用`waitGroup.Wait()`语句等待所有goroutines完成。
- en: 'The execution of `dynamicGR.go` requires an integer parameter, which is the
    number of goroutines you want to create:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`dynamicGR.go`需要一个整数参数，这是您想要创建的goroutines的数量：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can imagine, the more goroutines you want to create, the more diverse
    outputs you will have because there is no way to control the order that the goroutines
    of a program are going to be executed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以想象，您想要创建的goroutines越多，输出就会越多样化，因为没有办法控制程序的goroutines执行顺序。
- en: About channels
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于通道
- en: A **channel**, putting it simply, is a communication mechanism that allows goroutines
    to exchange data. However, some rules exist here. First, each channel allows the
    exchange of a particular data type, which is also called the **element type**
    of the channel, and second, for a channel to operate properly, you will need to
    use some Go code to receive what is sent via the channel.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**通道**，简单地说，是一种通信机制，允许goroutines交换数据。但是，这里存在一些规则。首先，每个通道允许特定数据类型的交换，这也称为通道的**元素类型**，其次，为了使通道正常运行，您需要使用一些Go代码来接收通过通道发送的内容。'
- en: You should declare a new channel using the `chan` keyword and you can close
    a channel using the `close()` function. Additionally, as each channel has its
    own type, the developer should define it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用`chan`关键字声明一个新的通道，并且可以使用`close()`函数关闭一个通道。此外，由于每个通道都有自己的类型，开发人员应该定义它。
- en: 'Last, a very important detail: when you are using a channel as a function parameter,
    you can specify its direction, that is, whether it will be used for writing or
    reading. In my opinion, if you know the purpose of a channel in advance, use this
    capability because it will make your program more robust as well as safer: otherwise,
    just do not define the purpose of the channel function parameter. As a result,
    if you declare that a channel function parameter will be used for reading only
    and you try to write to it, you will get an error message that will most likely
    save you from nasty bugs.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个非常重要的细节：当您将通道用作函数参数时，可以指定其方向，即它将用于写入还是读取。在我看来，如果您事先知道通道的目的，请使用此功能，因为它将使您的程序更健壮，更安全：否则，只需不定义通道函数参数的目的。因此，如果您声明通道函数参数仅用于读取，并尝试向其写入，您将收到一个错误消息，这很可能会使您免受讨厌的错误。
- en: 'The error message you will get when you try to read from a write channel will
    be similar to the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试从写通道中读取时，你将得到以下类似的错误消息：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Writing to a channel
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向通道写入
- en: In this subsection, you will learn how to write to a channel. The presented
    program will be called `writeChannel.go` and you will see it in three parts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，你将学习如何向通道写入。所呈现的程序将被称为`writeChannel.go`，并分为三个部分。
- en: 'The first part has the expected preamble:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分包含了预期的序言：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can understand, the use of channels does not require any extra Go packages.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所理解的，使用通道不需要任何额外的Go包。
- en: 'The second part of `writeChannel.go` is the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeChannel.go`的第二部分如下：'
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although the `writeChannel()` function writes to the channel, the data will
    be lost because currently nobody reads the channel in the program.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`writeChannel()`函数向通道写入数据，但由于当前没有人从程序中读取通道，数据将丢失。
- en: 'The last part of the program contains the following Go code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一部分包含以下Go代码：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, you can see the definition of a channel variable named `c` with the help
    of the `chan` keyword that is used for the `int` data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到使用`chan`关键字定义了一个名为`c`的通道变量，用于`int`数据。
- en: 'Executing `writeChannel.go` will create the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`writeChannel.go`将创建以下输出：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is not what you expected to see! The cause of this unpredicted output
    is that the second `fmt.Println(x)` statement was not executed. The reason for
    this is pretty simple: the `c <- x` statement is blocking the execution of the
    rest of the `writeChannel()` function because nobody is reading from the `c` channel.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是你期望看到的！这个意外的输出的原因是第二个`fmt.Println(x)`语句没有被执行。原因很简单：`c <- x`语句阻塞了`writeChannel()`函数的其余部分的执行，因为没有人从`c`通道中读取。
- en: Reading from a channel
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从通道中读取
- en: This subsection will improve the Go code of `writeChannel.go` by allowing you
    to read from a channel. The presented program will be called `readChannel.go`
    and be presented in four parts.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将通过允许你从通道中读取来改进`writeChannel.go`的Go代码。所呈现的程序将被称为`readChannel.go`，并分为四个部分呈现。
- en: 'The first part is the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second part of `readChannel.go` has the following Go code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`readChannel.go`的第二部分包含以下Go代码：'
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once again, note that if nobody collects the data written to a channel, the
    function that sent it will stall while waiting for someone to read its data. However,
    in [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*,* *Goroutines - Advanced
    Features*, you will see a very pretty solution to this problem.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，如果没有人收集写入通道的数据，发送数据的函数将在等待有人读取其数据时停滞。然而，在[第10章](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*，*
    *Goroutines - Advanced Features*中，你将看到这个问题的一个非常好的解决方案。
- en: 'The third part has the following Go code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含以下Go代码：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, the `<-c` statement in the `fmt.Println()` function is used for reading
    a single value from the channel: the same statement can be used for storing the
    value of a channel into a variable. However, if you do not store the value you
    read from a channel, it will be lost.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fmt.Println()`函数中的`<-c`语句用于从通道中读取单个值：相同的语句也可以用于将通道的值存储到变量中。然而，如果你不存储从通道中读取的值，它将会丢失。
- en: 'The last part of `readChannel.go` is the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`readChannel.go`的最后一部分如下：'
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, you see a technique that allows you to find out whether the channel that
    you want to read from is closed or not. However, if the channel was open, the
    presented Go code will discard the read value of the channel because of the use
    of the `_` character in the assignment.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你看到了一种技术，可以让你知道你想要从中读取的通道是否已关闭。然而，如果通道是打开的，所呈现的Go代码将因为在赋值中使用了`_`字符而丢弃通道的读取值。
- en: 'Executing `readChannel.go` will create the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`readChannel.go`将创建以下输出：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Explaining h1s.go
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释h1s.go
- en: In [Chapter 8](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)*,* *Processes and
    Signals*, you saw how Go handles Unix signals using many examples including `h1s.go`.
    However, now that you understand more about goroutines and channels, it is time
    to explain the Go code of `h1s.go` a little more.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)*，* *Processes and Signals*中，你看到了Go如何使用许多示例处理Unix信号，包括`h1s.go`。然而，现在你更了解goroutines和通道，是时候更详细地解释一下`h1s.go`的Go代码了。
- en: As you already know that `h1s.go` uses channels and goroutines, it should be
    clear now that the anonymous function that is executed as a goroutine reads from
    the `sigs` channel using an infinite `for` loop. This means that each time there
    is a signal that interests us, the goroutine will read it from the `sigs` channel
    and handle it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经知道的，`h1s.go`使用通道和goroutines，现在应该清楚了，作为goroutine执行的匿名函数使用无限的`for`循环从`sigs`通道读取。这意味着每次有我们感兴趣的信号时，goroutine都会从`sigs`通道中读取并处理它。
- en: Pipelines
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: 'Go programs rarely use a single channel. One very common technique that uses
    multiple channels is called a **pipeline**. So, a pipeline is a method for connecting
    goroutines so that the output of a goroutine becomes the input of another with
    the help of channels. The benefits of using pipelines are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序很少使用单个通道。一个非常常见的使用多个通道的技术称为**pipeline**。因此，pipeline是一种连接goroutines的方法，使得一个goroutine的输出成为另一个goroutine的输入，借助通道。使用pipeline的好处如下：
- en: One of the benefits you get from using pipelines is that there is a constant
    flow in your program because nobody waits for everything to be completed in order
    to start the execution of goroutines and channels of the program
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pipeline的好处之一是程序中有一个恒定的流动，因为没有人等待所有事情都完成才开始执行程序的goroutines和通道
- en: Additionally, you are using less variables and therefore less memory space because
    you do not have to save everything
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，你使用的变量更少，因此占用的内存空间也更少，因为你不必保存所有东西。
- en: Last, the use of pipelines simplifies the design of the program and improves
    its maintainability
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用管道简化了程序的设计并提高了可维护性
- en: 'The code of `pipelines.go`, which works with a pipeline of integers, will be
    presented in five parts; the first part is the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipelines.go`的代码将以五个部分呈现；第一部分如下：'
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second part contains the following Go code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, you define a function that takes three arguments: two integers and one
    output channel. The output channel will be used for writing data that will be
    read in another function: this is how a pipeline is created.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您定义了一个函数，它接受三个参数：两个整数和一个输出通道。输出通道将用于写入将在另一个函数中读取的数据：这就是创建管道的方式。
- en: 'The third part of the program is the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分如下：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This time, the function takes two arguments that are both channels. However,
    `out` is an output channel, whereas `in` is an input channel used for reading
    data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，函数接受两个都是通道的参数。但是，`out`是一个输出通道，而`in`是一个用于读取数据的输入通道。
- en: 'The fourth part contains the definition of another function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分包含另一个函数的定义：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The last function of `pipelines.go` takes just one argument, which is a channel
    used for reading data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipelines.go`的最后一个函数只接受一个用于读取数据的通道作为参数。'
- en: 'The last part of `pipelines.go` is the implementation of the `main()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipelines.go`的最后一部分是`main()`函数的实现：'
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, the `main()` function firstly reads its two command-line arguments and
    creates the necessary channel variables (`naturals` and `squares`). Then, it calls
    the functions of the pipeline: note that the last function of the channel is not
    being executed as a goroutine.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`main()`函数首先读取其两个命令行参数并创建必要的通道变量（`naturals`和`squares`）。然后，它调用管道的函数：请注意，通道的最后一个函数不会作为goroutine执行。
- en: 'The following figure shows a graphical representation of the pipeline used
    in `pipelines.go` in order to the way this particular pipeline works:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了`pipelines.go`中使用的管道的图形表示，以说明特定管道的工作方式：
- en: '![](img/e6d2874d-12a1-4441-b5a1-f2af5c0056fe.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6d2874d-12a1-4441-b5a1-f2af5c0056fe.png)'
- en: A graphical representation of the pipeline structure used in pipelines.go
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: pipelines.go中使用的管道结构的图形表示
- en: 'Running `pipelines.go` generates the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`pipelines.go`将生成以下输出：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A better version of wc.go
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: wc.go的更好版本
- en: As we talked about in [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*,*
    *File Input and Output*, in this chapter, you will learn how to create a version
    of `wc.go` that uses goroutines. The name of the new utility will be `dWC.go`
    and will be presented in four parts. Note that the current version of `dWC.go`
    considers each command-line argument as a file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)中讨论的，在本章中，您将学习如何创建一个使用goroutines的`wc.go`的版本。新实用程序的名称将是`dWC.go`，将分为四个部分。请注意，`dWC.go`的当前版本将每个命令行参数都视为一个文件。
- en: 'The first part of the utility is the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的第一部分如下：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The second part has the following Go code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `count()` function does all the processing without returning any information
    to the `main()` function: it just prints the lines, words, and characters of its
    input file and exits. Although the current implementation of the `count()` function
    does the desired job, it is not the correct way to design a program because there
    is no way to control its output of the program.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`函数完成所有处理，而不向`main()`函数返回任何信息：它只是打印其输入文件的行数、单词数和字符数，然后退出。尽管`count()`函数的当前实现完成了所需的工作，但这并不是设计程序的正确方式，因为无法控制程序的输出。'
- en: 'The third part of the utility is the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的第三部分如下：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The last part of `dWC.go` is the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`dWC.go`的最后一部分如下：'
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, each input file is being processed by a different goroutine.
    As expected, you cannot make any assumptions about the order the input files will
    be processed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每个输入文件都由不同的goroutine处理。如预期的那样，您无法对输入文件的处理顺序做出任何假设。
- en: 'Executing `dWC.go` will generate the following output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`dWC.go`将生成以下输出：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, you can see that although the `doesnotExist` filename is the last command-line
    argument, it is the first one in the output of `dWC.go`!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到，尽管`doesnotExist`文件名是最后一个命令行参数，但它是`dWC.go`输出中的第一个命令行参数！
- en: Although `dWC.go` uses goroutines, there is no cleverness in it because goroutines
    run without communicating with each other and without performing any other tasks.
    Additionally, the output might get scrambled because there is no guarantee that
    the `fmt.Printf()` statements of the `count()` function will not get interrupted.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`dWC.go`使用了goroutines，但其中并没有巧妙之处，因为goroutines在没有相互通信和执行任何其他任务的情况下运行。此外，输出可能会混乱，因为无法保证`count()`函数的`fmt.Printf()`语句不会被中断。
- en: As a result, the forthcoming section as well as some of the techniques that
    will be presented in [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*,*
    *Goroutines - Advanced Features*, will improve `dWC.go`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即将呈现的部分以及将在[第10章](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)中呈现的一些技术，即*Goroutines
    - 高级特性*，将改进`dWC.go`。
- en: Calculating totals
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算总数
- en: 'The current version of `dWC.go` cannot calculate totals, which can be easily
    solved by processing the output of `dWC.go` with `awk`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`dWC.go`的当前版本无法计算总数，可以通过使用`awk`处理`dWC.go`的输出来轻松解决：'
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Still, this is far from being perfect and elegant!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这离完美和优雅还有很大差距！
- en: The main reason that the current version of `dWC.go` cannot calculate totals
    is that its goroutines have no way of communicating with each other. This can
    be easily solved with the help of channels and pipelines. The new version of `dWC.go`
    will be called `dWCtotal.go` and will be presented in five parts.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`dWC.go`的当前版本无法计算总数的主要原因是其goroutines无法相互通信。这可以通过通道和管道的帮助轻松解决。新版本的`dWC.go`将被称为`dWCtotal.go`，将分为五个部分呈现。'
- en: 'The first part of `dWCtotal.go` is the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`dWCtotal.go`的第一部分如下：'
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, a new `struct` type is defined. The new structure is called `File` and
    has four fields and an additional field for keeping error messages. This is the
    correct way for a pipeline to circulate multiple values. One might argue that
    a better name for the `File` structure would have been `Counts`, `Results`, `FileCounts`,
    or `FileResults`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，定义了一个新的`struct`类型。新结构称为`File`，有四个字段和一个额外的字段用于保存错误消息。这是管道循环多个值的正确方式。有人可能会认为`File`结构的更好名称应该是`Counts`、`Results`、`FileCounts`或`FileResults`。
- en: 'The second part of the program is the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二部分如下：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: A better name of the `process()` function would have been `beginProcess()` or
    `processResults()`. You can try to make that change on your own throughout the
    `dWCtotal.go` program.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`process()`函数的更好名称应该是`beginProcess()`或`processResults()`。您可以尝试在整个`dWCtotal.go`程序中自行进行更改。'
- en: 'The third part of `dWCtotal.go` has the following Go code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`dWCtotal.go`的第三部分包含以下Go代码：'
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Although the `count()` function still calculates the counts, it does not print
    them. It just sends the counts of lines, words, and characters as well as the
    filename to another channel using a `struct` variable of the `File` type.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`count()`函数仍然计算计数，但它不会打印它们。它只是使用`File`类型的`struct`变量将行数、单词数、字符数以及文件名发送到另一个通道。
- en: 'There exists one very important detail here, which is the last statement of
    the `count()` function: in order to properly end a pipeline, you should close
    all involved channels, starting from the first one. Otherwise, the execution of
    the program will fail with an error message similar to the following one:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常重要的细节，就是`count()`函数的最后一条语句：为了正确结束管道，您应该关闭所有涉及的通道，从第一个开始。否则，程序的执行将以类似以下的错误消息失败：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: However, as far as closing the channels of a pipeline is concerned, you should
    also be careful about closing channels too early, especially when there are splits
    in a pipeline.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就关闭管道的管道而言，您还应该注意不要过早关闭通道，特别是在管道中存在分支时。
- en: 'The fourth part of the program contains the following Go code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第四部分包含以下Go代码：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There is nothing special here: the `calculate()` function does the dirty job
    of printing the output of the program.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的：`calculate()`函数负责打印程序的输出。
- en: 'The last part of `dWCtotal.go` is the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`dWCtotal.go`的最后部分如下：'
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Since the `files` channel is only used for passing around filenames, it could
    have been a `string` channel instead of a `File` channel. However, this way the
    code is more consistent.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`files`通道仅用于传递文件名，它本可以是一个`string`通道，而不是一个`File`通道。但是，这样代码更一致。
- en: 'Now `dWCtotal.go` automatically generates totals even if it has to process
    just one file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`dWCtotal.go`即使只处理一个文件也会自动生成总数：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that both `dWCtotal.go` and `dWC.go` implement the same core functionality,
    which is counting the words, characters, and lines of a file: it is the way the
    information is handled that is different because `dWCtotal.go` uses a pipeline
    and not isolated goroutines.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`dWCtotal.go`和`dWC.go`都实现了相同的核心功能，即计算文件的单词、字符和行数：不同之处在于信息处理的方式不同，因为`dWCtotal.go`使用了管道而不是孤立的goroutines。
- en: '[Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*,* *Goroutines - Advanced
    Features*, will use other techniques to implement the functionality of `dWCtotal.go`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)*，* *Goroutines - Advanced
    Features*，将使用其他技术来实现`dWCtotal.go`的功能。'
- en: Doing some benchmarking
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行一些基准测试
- en: 'In this section, we will compare the performance of `wc.go` from [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*,*
    *File Input and Output**,* with the performance of `wc(1)`, `dWC.go` and `dWCtotal.go`.
    In order for the results to be more accurate, all three utilities will process
    relatively big files:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将比较[第6章](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*，* *文件输入和输出*中的`wc.go`与`wc(1)`、`dWC.go`和`dWCtotal.go`的性能。为了使结果更准确，所有三个实用程序将处理相对较大的文件：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'So, the `time(1)` utility will measure the following commands:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`time(1)`实用程序将测量以下命令：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following figure shows a graphical representation of the real field from
    the output of the `time(1)` utility when used to measure the aforementioned commands:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了使用`time(1)`实用程序测量上述命令时的实际领域的图形表示：
- en: '![](img/de995173-8729-4a8b-8960-775d6436074c.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de995173-8729-4a8b-8960-775d6436074c.png)'
- en: Plotting the real field of the time(1) utility
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制`time(1)`实用程序的实际领域
- en: The original `wc(1)` utility is by far the fastest of all. Additionally, `dWC.go`
    is faster than both `dWCtotal.go` and `wc.go`. Apart from `dWC.go`, the remaining
    two Go versions have the same performance.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`wc(1)`实用程序是迄今为止最快的。此外，`dWC.go`比`dWCtotal.go`和`wc.go`都要快。除了`dWC.go`，其余两个Go版本的性能相同。
- en: Exercises
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Create a pipeline that reads text files, finds the number of occurrences of
    a given word, and calculates the total number of occurrences of the word in all
    files.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个管道，读取文本文件，找到给定单词的出现次数，并计算所有文件中该单词的总出现次数。
- en: Try to make `dWCtotal.go` faster.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试让`dWCtotal.go`更快。
- en: Create a simple Go program that plays ping pong using channels. You should define
    the total number of pings and pongs using a command-line argument.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的Go程序，使用通道进行乒乓球比赛。您应该使用命令行参数定义乒乓球的总数。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we talked about creating and synchronizing goroutines as well
    as about creating and using pipelines and channels to allow goroutines to communicate
    with each other. Additionally, we developed two versions of the `wc(1)` utility
    that use goroutines to process their input files.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了创建和同步goroutines，以及创建和使用管道和通道，以使goroutines能够相互通信。此外，我们开发了两个使用goroutines处理其输入文件的`wc(1)`实用程序的版本。
- en: Make sure that you fully understand the concepts of this chapter before continuing
    with the next chapter because in the next chapter, we will talk about more advanced
    features related to goroutines and channels including shared memory, buffered
    channels, the `select` keyword, the `GOMAXPROCS` environment variable, and signal
    channels.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一章之前，请确保您充分理解本章的概念，因为在下一章中，我们将讨论与goroutines和通道相关的更高级特性，包括共享内存、缓冲通道、`select`关键字、`GOMAXPROCS`环境变量和信号通道。
