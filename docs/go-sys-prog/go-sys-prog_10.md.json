["```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"math/rand\" \n   \"os\" \n   \"path/filepath\" \n   \"strconv\" \n   \"time\" \n) \n```", "```go\nfunc createNumber(max int, randomNumberChannel chan<- int, finishedChannel chan bool) { \n   for { \n         select { \n         case randomNumberChannel <- rand.Intn(max): \n         case x := <-finishedChannel: \n               if x { \n                     close(finishedChannel) \n                     close(randomNumberChannel) \n                     return \n               } \n         } \n   } \n}\n\n```", "```go\nfunc main() { \n   rand.Seed(time.Now().Unix()) \n   randomNumberChannel := make(chan int) \n   finishedChannel := make(chan bool) \n\n   if len(os.Args) != 3 { \n         fmt.Printf(\"usage: %s count max\\n\", filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n\n   n1, _ := strconv.ParseInt(os.Args[1], 10, 64) \n   count := int(n1) \n   n2, _ := strconv.ParseInt(os.Args[2], 10, 64) \n   max := int(n2) \n\n   fmt.Printf(\"Going to create %d random numbers.\\n\", count) \n```", "```go\n   go createNumber(max, randomNumberChannel, finishedChannel) \n   for i := 0; i < count; i++ { \n         fmt.Printf(\"%d \", <-randomNumberChannel) \n   } \n\n   finishedChannel <- false \n   fmt.Println() \n   _, ok := <-randomNumberChannel \n   if ok { \n         fmt.Println(\"Channel is open!\") \n   } else { \n         fmt.Println(\"Channel is closed!\") \n   } \n```", "```go\n   finishedChannel <- true\n   _, ok = <-randomNumberChannel \n   if ok { \n         fmt.Println(\"Channel is open!\") \n   } else { \n         fmt.Println(\"Channel is closed!\") \n   } \n} \n```", "```go\n$ go run useSelect.go 2 100\nGoing to create 2 random numbers.\n19 74\nChannel is open!\nChannel is closed!\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"time\" \n) \n\nfunc A(a, b chan struct{}) { \n   <-a \n   fmt.Println(\"A!\") \n   time.Sleep(time.Second) \n   close(b) \n} \n```", "```go\nfunc B(b, c chan struct{}) { \n   <-b \n   fmt.Println(\"B!\") \n   close(c) \n} \n```", "```go\nfunc C(a chan struct{}) { \n   <-a \n   fmt.Println(\"C!\") \n} \n```", "```go\nfunc main() { \n   x := make(chan struct{}) \n   y := make(chan struct{}) \n   z := make(chan struct{})\n\n```", "```go\n   go A(x, y) \n   go C(z) \n   go B(y, z) \n   go C(z) \n\n   close(x) \n   time.Sleep(2 * time.Second) \n} \n```", "```go\n$ go run signalChannel.go\nA!\nB!\nC!\nC!\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n) \n```", "```go\nfunc main() { \n   numbers := make(chan int, 5) \n```", "```go\n   counter := 10 \n   for i := 0; i < counter; i++ { \n         select { \n         case numbers <- i: \n         default: \n               fmt.Println(\"Not enough space for\", i) \n         } \n   } \n```", "```go\n   for i := 0; i < counter*2; i++ { \n         select { \n         case num := <-numbers: \n               fmt.Println(num) \n         default:\n               fmt.Println(\"Nothing more to be done!\")    \n               break \n         } \n   } \n} \n```", "```go\n$ go run bufChannels.go\nNot enough space for 5\nNot enough space for 6\nNot enough space for 7\nNot enough space for 8\nNot enough space for 9\n0\n1\n2\n3\n4\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\nNothing more to be done!\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"time\" \n) \n```", "```go\nfunc main() { \n   c1 := make(chan string) \n   go func() { \n         time.Sleep(time.Second * 3) \n         c1 <- \"c1 OK\" \n   }() \n```", "```go\n   select { \n   case res := <-c1: \n         fmt.Println(res) \n   case <-time.After(time.Second * 1): \n         fmt.Println(\"timeout c1\") \n   } \n```", "```go\n   c2 := make(chan string) \n   go func() { \n         time.Sleep(time.Second * 3) \n         c2 <- \"c2 OK\" \n   }() \n\n   select { \n   case res := <-c2: \n         fmt.Println(res) \n   case <-time.After(time.Second * 4): \n         fmt.Println(\"timeout c2\") \n   } \n} \n```", "```go\n$ go run timeOuts.go\ntimeout c1\nc2 OK\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"sync\" \n   \"time\" \n) \n```", "```go\nfunc timeout(w *sync.WaitGroup, t time.Duration) bool { \n   temp := make(chan int) \n   go func() { \n         defer close(temp) \n         w.Wait() \n   }() \n\n   select { \n   case <-temp: \n         return false \n   case <-time.After(t): \n         return true \n   } \n} \n```", "```go\nfunc main() { \n   var w sync.WaitGroup \n   w.Add(1) \n\n   t := 2 * time.Second \n   fmt.Printf(\"Timeout period is %s\\n\", t) \n\n   if timeout(&w, t) { \n         fmt.Println(\"Timed out!\") \n   } else { \n         fmt.Println(\"OK!\") \n   } \n```", "```go\n   w.Done() \n   if timeout(&w, t) { \n         fmt.Println(\"Timed out!\") \n   } else { \n         fmt.Println(\"OK!\") \n   } \n} \n```", "```go\n$ go run timeoutWait.go\nTimeout period is 2s\nTimed out!\nOK!\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n) \n\nvar numbers = []int{0, -1, 2, 3, -4, 5, 6, -7, 8, 9, 10} \n```", "```go\nfunc f1(cc chan chan int, finished chan struct{}) { \n   c := make(chan int) \n   cc <- c \n   defer close(c) \n\n   total := 0 \n   i := 0 \n   for { \n         select { \n         case c <- numbers[i]: \n               i = i + 1 \n               i = i % len(numbers) \n               total = total + 1 \n         case <-finished: \n               c <- total \n               return \n         } \n   } \n} \n```", "```go\nfunc main() { \n   c1 := make(chan chan int) \n   f := make(chan struct{}) \n\n   go f1(c1, f) \n   data := <-c1 \n```", "```go\n   i := 0 \n   for integer := range data { \n         fmt.Printf(\"%d \", integer) \n         i = i + 1 \n         if i == 100 { \n               close(f) \n         } \n   } \n   fmt.Println() \n} \n```", "```go\n$ go run cOfC.go\n0 -1 2 3 -4 5 6 -7 8 9 10 0 -1 2 3 -4 5 6 -7 8 9 10 0 -1 2 3 -4 5 6 -7 8 9 10 0 -1 2 3 -4 5 6 -7 8 9 10 0 -1 2 3 -4 5 6 -7 8 9 10 0 -1 2 3 -4 5 6 -7 8 9 10 0 -1 2 3 -4 5 6 -7 8 9 10 0 -1 2 3 -4 5 6 -7 8 9 10 0 -1 2 3 -4 5 6 -7 8 9 10 0 100\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"math/rand\" \n   \"time\" \n) \n```", "```go\nfunc addIntegers(c chan int) { \n   sum := 0 \n   t := time.NewTimer(time.Second) \n\n   for { \n         select { \n         case input := <-c: \n               sum = sum + input \n         case <-t.C: \n               c = nil \n               fmt.Println(sum) \n         } \n   } \n} \n```", "```go\nfunc sendIntegers(c chan int) { \n   for { \n         c <- rand.Intn(100) \n   } \n} \n```", "```go\nfunc main() { \n   c := make(chan int) \n   go addIntegers(c) \n   go sendIntegers(c) \n   time.Sleep(2 * time.Second) \n} \n```", "```go\n$ go run nilChannel.go\n162674704\n$ go run nilChannel.go\n165021841\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"math/rand\" \n   \"sync\" \n   \"time\" \n) \n```", "```go\nvar readValue = make(chan int) \nvar writeValue = make(chan int) \n\nfunc SetValue(newValue int) { \n   writeValue <- newValue \n} \n\nfunc ReadValue() int { \n   return <-readValue \n} \n```", "```go\nfunc monitor() { \n   var value int \n   for { \n         select { \n         case newValue := <-writeValue: \n               value = newValue \n               fmt.Printf(\"%d \", value) \n         case readValue <- value: \n         } \n   } \n} \n```", "```go\nfunc main() { \n   rand.Seed(time.Now().Unix()) \n   go monitor() \n   var waitGroup sync.WaitGroup \n\n   for r := 0; r < 20; r++ { \n         waitGroup.Add(1) \n         go func() { \n               defer waitGroup.Done() \n               SetValue(rand.Intn(100)) \n         }() \n   } \n```", "```go\n   waitGroup.Wait() \n   fmt.Printf(\"\\nLast value: %d\\n\", ReadValue()) \n} \n```", "```go\n$ go run sharedMem.go\n33 45 67 93 33 37 23 85 87 23 58 61 9 57 20 61 73 99 42 99\nLast value: 99\n$ go run sharedMem.go\n71 66 58 83 55 30 61 73 94 19 63 97 12 87 59 38 48 81 98 49\nLast value: 49\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"path/filepath\" \n   \"strconv\" \n   \"sync\" \n) \n```", "```go\nvar aMutex sync.Mutex \nvar sharedVariable string = \"\" \n\nfunc addDot() { \n   aMutex.Lock() \n   sharedVariable = sharedVariable + \".\" \n   aMutex.Unlock() \n} \n```", "```go\nfunc read() string { \n   aMutex.Lock() \n   a := sharedVariable \n   aMutex.Unlock() \n   return a \n} \n```", "```go\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Printf(\"usage: %s n\\n\", filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n\n   numGR, _ := strconv.ParseInt(os.Args[1], 10, 64) \n   var waitGroup sync.WaitGroup \n```", "```go\n   var i int64 \n   for i = 0; i < numGR; i++ { \n         waitGroup.Add(1) \n         go func() { \n               defer waitGroup.Done() \n               addDot() \n         }() \n   } \n   waitGroup.Wait() \n   fmt.Printf(\"-> %s\\n\", read()) \n   fmt.Printf(\"Length: %d\\n\", len(read())) \n} \n```", "```go\n$ go run mutexSimple.go 20\n-> ....................\nLength: 20\n$ go run mutexSimple.go 30\n-> ..............................\nLength: 30\n```", "```go\ntype RWMutex struct { \n   w           Mutex \n   writerSem   uint32 \n   readerSem   uint32  \n   readerCount int32 \n   readerWait  int32 \n}                \n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"sync\" \n   \"time\" \n) \n\nvar Password = secret{counter: 1, password: \"myPassword\"} \n\ntype secret struct { \n   sync.RWMutex \n   counter  int \n   password string \n} \n```", "```go\nfunc Change(c *secret, pass string) { \n   c.Lock() \n   fmt.Println(\"LChange\") \n   time.Sleep(20 * time.Second) \n   c.counter = c.counter + 1 \n   c.password = pass \n   c.Unlock() \n} \n```", "```go\nfunc Show(c *secret) string { \n   fmt.Println(\"LShow\") \n   time.Sleep(time.Second)\n\n   c.RLock() \n   defer c.RUnlock() \n   return c.password \n} \n\nfunc Counts(c secret) int { \n   c.RLock() \n   defer c.RUnlock() \n   return c.counter \n} \n```", "```go\nfunc main() { \n   fmt.Println(\"Pass:\", Show(&Password)) \n   for i := 0; i < 5; i++ { \n         go func() { \n               fmt.Println(\"Go Pass:\", Show(&Password)) \n         }() \n   } \n```", "```go\n   go func() { \n         Change(&Password, \"123456\") \n   }() \n\n   fmt.Println(\"Pass:\", Show(&Password)) \n   time.Sleep(time.Second) \n   fmt.Println(\"Counter:\", Counts(Password)) \n} \n```", "```go\n$ go run mutexRW.go\nLShow\nPass: myPassword\nLShow\nLShow\nLShow\nLShow\nLShow\nLShow\nLChange\nGo Pass: 123456\nGo Pass: 123456\nPass: 123456\nGo Pass: 123456\nGo Pass: 123456\nGo Pass: 123456\nCounter: 2\n```", "```go\n$ go run mutexRW.go\nLShow\nPass: myPassword\nLShow\nLShow\nLShow\nLShow\nLShow\nLShow\nLChange\nGo Pass: myPassword\nPass: myPassword\nGo Pass: myPassword\nGo Pass: myPassword\nGo Pass: myPassword\nGo Pass: myPassword\nCounter: 1\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"io\" \n   \"os\" \n   \"path/filepath\" \n   \"regexp\" \n) \n\ntype File struct { \n   Filename   string \n   Lines      int \n   Words      int \n   Characters int \n   Error      error \n} \n```", "```go\nfunc monitor(values <-chan File, count int) { \n   var totalWords int = 0 \n   var totalLines int = 0 \n   var totalChars int = 0 \n   for i := 0; i < count; i++ { \n         x := <-values \n         totalWords = totalWords + x.Words \n         totalLines = totalLines + x.Lines \n         totalChars = totalChars + x.Characters \n         if x.Error == nil { \n               fmt.Printf(\"\\t%d\\t\", x.Lines) \n               fmt.Printf(\"%d\\t\", x.Words) \n               fmt.Printf(\"%d\\t\", x.Characters) \n               fmt.Printf(\"%s\\n\", x.Filename) \n         } else { \n               fmt.Printf(\"\\t%s\\n\", x.Error) \n         } \n   } \n   fmt.Printf(\"\\t%d\\t\", totalLines) \n   fmt.Printf(\"%d\\t\", totalWords) \n   fmt.Printf(\"%d\\ttotal\\n\", totalChars) \n} \n```", "```go\nfunc count(filename string, out chan<- File) { \n   var err error \n   var nLines int = 0 \n   var nChars int = 0 \n   var nWords int = 0 \n\n   f, err := os.Open(filename) \n   defer f.Close() \n   if err != nil { \n         newValue := File{ \nFilename: filename, \nLines: 0, \nCharacters: 0, \nWords: 0, \nError: err } \n         out <- newValue \n         return \n   } \n\n   r := bufio.NewReader(f) \n   for { \n         line, err := r.ReadString('\\n') \n\n         if err == io.EOF { \n               break \n         } else if err != nil { \n               fmt.Printf(\"error reading file %s\\n\", err) \n         } \n         nLines++ \n         r := regexp.MustCompile(\"[^\\\\s]+\") \n         for range r.FindAllString(line, -1) { \n               nWords++ \n         } \n         nChars += len(line) \n   } \n   newValue := File { \nFilename: filename, \nLines: nLines, \nCharacters: nChars, \nWords: nWords, \nError: nil }\n\n   out <- newValue\n\n} \n```", "```go\nfunc main() { \n   if len(os.Args) == 1 { \n         fmt.Printf(\"usage: %s <file1> [<file2> [... <fileN]]\\n\", \n               filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n\n   values := make(chan File, len(os.Args[1:])) \n```", "```go\n   for _, filename := range os.Args[1:] {\n         go func(filename string) { \n               count(filename, values) \n         }(filename) \n   } \n   monitor(values, len(os.Args[1:])) \n} \n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"io\" \n   \"os\" \n   \"path/filepath\" \n   \"regexp\" \n   \"sync\" \n) \n\ntype File struct { \n   Filename   string \n   Lines      int \n   Words      int \n   Characters int \n   Error      error \n} \n\nvar aM sync.Mutex \nvar values = make([]File, 0) \n```", "```go\nfunc count(filename string) { \n   var err error \n   var nLines int = 0 \n   var nChars int = 0 \n   var nWords int = 0 \n\n   f, err := os.Open(filename) \n   defer f.Close() \n   if err != nil { \n         newValue := File{Filename: filename, Lines: 0, Characters: 0, Words: 0, Error: err} \n         aM.Lock() \n         values = append(values, newValue) \n         aM.Unlock() \n         return \n   } \n\n   r := bufio.NewReader(f) \n   for { \n         line, err := r.ReadString('\\n') \n\n         if err == io.EOF { \n               break \n         } else if err != nil { \n               fmt.Printf(\"error reading file %s\\n\", err) \n         } \n         nLines++ \n         r := regexp.MustCompile(\"[^\\\\s]+\") \n         for range r.FindAllString(line, -1) { \n               nWords++ \n         } \n         nChars += len(line) \n   } \n\n   newValue := File{Filename: filename, Lines: nLines, Characters: nChars, Words: nWords, Error: nil} \n   aM.Lock() \n   values = append(values, newValue) \n   aM.Unlock() \n} \n```", "```go\nfunc main() { \n   if len(os.Args) == 1 { \n         fmt.Printf(\"usage: %s <file1> [<file2> [... <fileN]]\\n\", \n               filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n```", "```go\n   var waitGroup sync.WaitGroup \n   for _, filename := range os.Args[1:] { \n         waitGroup.Add(1) \n         go func(filename string) { \n               defer waitGroup.Done() \n               count(filename) \n         }(filename) \n   } \n\n   waitGroup.Wait()\n```", "```go\n   var totalWords int = 0 \n   var totalLines int = 0 \n   var totalChars int = 0 \n   for _, x := range values { \n         totalWords = totalWords + x.Words \n         totalLines = totalLines + x.Lines \n         totalChars = totalChars + x.Characters \n         if x.Error == nil { \n               fmt.Printf(\"\\t%d\\t\", x.Lines) \n               fmt.Printf(\"%d\\t\", x.Words) \n               fmt.Printf(\"%d\\t\", x.Characters) \n               fmt.Printf(\"%s\\n\", x.Filename) \n         } \n   } \n   fmt.Printf(\"\\t%d\\t\", totalLines) \n   fmt.Printf(\"%d\\t\", totalWords) \n   fmt.Printf(\"%d\\ttotal\\n\", totalChars) \n}\n```", "```go\n$ time go run WCshared.go /tmp/*.data /tmp/*.data\nreal  0m31.836s\nuser  0m31.659s\nsys   0m0.165s\n$ time go run WCbuffered.go /tmp/*.data /tmp/*.data\nreal  0m31.823s\nuser  0m31.656s\nsys   0m0.171s\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"os\" \n   \"path/filepath\" \n   \"strconv\" \n   \"sync\" \n) \n```", "```go\nfunc main() { \n   arguments := os.Args \n   if len(arguments) != 2 { \n         fmt.Printf(\"usage: %s number\\n\", filepath.Base(arguments[0])) \n         os.Exit(1) \n   } \n   numGR, _ := strconv.ParseInt(os.Args[1], 10, 64) \n   var waitGroup sync.WaitGroup \n   var i int64 \n```", "```go\n   for i = 0; i < numGR; i++ { \n         waitGroup.Add(1) \n         go func() { \n               defer waitGroup.Done() \n               fmt.Printf(\"%d \", i) \n         }() \n   } \n```", "```go\n   waitGroup.Wait() \n   fmt.Println(\"\\nExiting...\") \n} \n```", "```go\n$ go run -race rd.go 10 ================== WARNING: DATA RACE\nRead at 0x00c420074168 by goroutine 6:\n  main.main.func1()\n      /Users/mtsouk/Desktop/goBook/ch/ch10/code/rd.go:25 +0x6c\n\nPrevious write at 0x00c420074168 by main goroutine:\n  main.main()\n      /Users/mtsouk/Desktop/goBook/ch/ch10/code/rd.go:21 +0x30c\n\nGoroutine 6 (running) created at:\n  main.main()\n      /Users/mtsouk/Desktop/goBook/ch/ch10/code/rd.go:26 +0x2e2\n==================\n==================\nWARNING: DATA RACE\nRead at 0x00c420074168 by goroutine 7:\n main.main.func1()\n     /Users/mtsouk/Desktop/goBook/ch/ch10/code/rd.go:25 +0x6c\n\nPrevious write at 0x00c420074168 by main goroutine:\n main.main()\n     /Users/mtsouk/Desktop/goBook/ch/ch10/code/rd.go:21 +0x30c\n\nGoroutine 7 (running) created at:\n  main.main()\n      /Users/mtsouk/Desktop/goBook/ch/ch10/code/rd.go:26 +0x2e2\n==================\n2 3 4 4 5 6 7 8 9 10\nExiting...\nFound 2 data race(s)\nexit status 66 \n```", "```go\n$ go run rd.go 10\n10 10 10 10 10 10 10 10 10 10\nExiting...\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"runtime\" \n) \n\nfunc getGOMAXPROCS() int {\n   return runtime.GOMAXPROCS(0) \n} \n```", "```go\nfunc main() { \n   fmt.Printf(\"GOMAXPROCS: %d\\n\", getGOMAXPROCS()) \n} \n```", "```go\n$ go run goMaxProcs.go \nGOMAXPROCS: 8 \n```", "```go\n$ go version \ngo version go1.3.3 linux/amd64 \n$ go run goMaxProcs.go \nGOMAXPROCS: 1 \n```", "```go\n$ export GOMAXPROCS=80; go run goMaxProcs.go \nGOMAXPROCS: 80 \n```", "```go\n$ export GOMAXPROCS=800; go run goMaxProcs.go \nGOMAXPROCS: 256 \n```", "```go\n$ export GOMAXPROCS=8; time go run dWC.go /tmp/*.data\n\nreal  0m10.826s\nuser  0m31.542s\nsys   0m5.043s\n$ export GOMAXPROCS=1; time go run dWC.go /tmp/*.data\n\nreal  0m15.362s\nuser  0m15.253s\nsys   0m0.103s\n$ time go run wc.go /tmp/*.data\n\nreal  0m15.158sexit\nuser  0m15.023s\nsys   0m0.120s\n```"]