["```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"io\" \n   \"net/http\" \n   \"os\" \n   \"path/filepath\" \n) \n```", "```go\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Printf(\"Usage: %s URL\\n\", filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n\n   URL :=os.Args[1] \n   data, err := http.Get(URL) \n```", "```go\n   if err != nil { \n         fmt.Println(err) \n         os.Exit(100) \n   } else { \n```", "```go\n         defer data.Body.Close() \n         _, err := io.Copy(os.Stdout, data.Body) \n         if err != nil { \n               fmt.Println(err) \n               os.Exit(100) \n         } \n   } \n}\n```", "```go\n$ go run getURL.go http://www.mtsoukalos.eu/ | head\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML+RDFa 1.0//EN\"\n  \"http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd\">\n<html xml:lang=\"en\" version=\"XHTML+RDFa 1.0\" dir=\"ltr\"\nxmlns:content=http://purl.org/rss/1.0/modules/content/\n. . .\n</script>\n</body>\n</html>\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"io\" \n   \"net\" \n   \"net/http\" \n   \"os\" \n   \"path/filepath\" \n   \"time\" \n) \n\nvar timeout = time.Duration(time.Second) \n```", "```go\nfunc Timeout(network, host string) (net.Conn, error) { \n   conn, err := net.DialTimeout(network, host, timeout) \n   if err != nil { \n         return nil, err \n   } \n   conn.SetDeadline(time.Now().Add(timeout)) \n   return conn, nil \n} \n```", "```go\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Printf(\"Usage: %s URL\\n\", filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n\n   URL :=os.Args[1] \n```", "```go\n   t := http.Transport{ \n         Dial: Timeout, \n   } \n\n   client := http.Client{ \n         Transport: &t, \n   } \n   data, err := client.Get(URL) \n```", "```go\n   if err != nil { \n         fmt.Println(err) \n         os.Exit(100) \n   } else { \n         deferdata.Body.Close() \n         _, err := io.Copy(os.Stdout, data.Body) \n         if err != nil { \n               fmt.Println(err) \n               os.Exit(100) \n         } \n   } \n} \n```", "```go\n$ go run timeoutHTTP.go http://localhost:8001\nGet http://localhost:8001: read tcp [::1]:58018->[::1]:8001: i/o timeout\nexit status 100\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"net/http\" \n   \"net/http/httputil\" \n   \"net/url\" \n   \"os\" \n   \"path/filepath\" \n   \"strings\" \n) \n```", "```go\nfunc main() { \n   if len(os.Args) != 2 { \n         fmt.Printf(\"Usage: %s URL\\n\", filepath.Base(os.Args[0])) \n         os.Exit(1) \n   } \n\n   URL, err :=url.Parse(os.Args[1]) \n   if err != nil { \n         fmt.Println(\"Parse:\", err) \n         os.Exit(100) \n   } \n```", "```go\n   c := &http.Client{} \n\n   request, err := http.NewRequest(\"GET\", URL.String(), nil) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(100) \n   } \n\n   httpData, err := c.Do(request) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(100) \n   } \n```", "```go\n   fmt.Println(\"Status code:\", httpData.Status) \n   header, _ := httputil.DumpResponse(httpData, false) \n   fmt.Print(string(header)) \n\n   contentType := httpData.Header.Get(\"Content-Type\") \n   characterSet := strings.SplitAfter(contentType, \"charset=\") \n   fmt.Println(\"Character Set:\", characterSet[1]) \n\n   if httpData.ContentLength == -1 { \n         fmt.Println(\"ContentLength in unknown!\") \n   } else { \n         fmt.Println(\"ContentLength:\", httpData.ContentLength) \n   } \n```", "```go\n   length := 0 \n   var buffer [1024]byte\n\n   r := httpData.Body \n   for { \n         n, err := r.Read(buffer[0:]) \n         if err != nil { \n               fmt.Println(err) \n               break \n         } \n         length = length + n \n   } \n   fmt.Println(\"Response data length:\", length) \n} \n```", "```go\n$ go run webClient.go invalid\nGet invalid: unsupported protocol scheme \"\"\nexit status 100\n$ go run webClient.go https://www.mtsoukalos.eu/\nGet https://www.mtsoukalos.eu/: dial tcp 109.74.193.253:443: getsockopt: connection refused\nexit status 100\n$ go run webClient.go http://www.mtsoukalos.eu/\nStatus code: 200 OK\nHTTP/1.1 200 OK\nAccept-Ranges: bytes\nAge: 0\nCache-Control: no-cache, must-revalidate\nConnection: keep-alive\nContent-Language: en\nContent-Type: text/html; charset=utf-8\nDate: Mon, 10 Jul 2017 07:29:48 GMT\nExpires: Sun, 19 Nov 1978 05:00:00 GMT\nServer: Apache/2.4.10 (Debian) PHP/5.6.30-0+deb8u1 mod_wsgi/4.3.0 Python/2.7.9\nVary: Accept-Encoding\nVia: 1.1 varnish-v4\nX-Content-Type-Options: nosniff\nX-Frame-Options: SAMEORIGIN\nX-Generator: Drupal 7 (http://drupal.org)\nX-Powered-By: PHP/5.6.30-0+deb8u1\nX-Varnish: 6922264\n\nCharacter Set: utf-8\nContentLength in unknown!\nEOF\nResponse data length: 50176\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"net/http\" \n   \"os\" \n) \n```", "```go\nfunc myHandler(w http.ResponseWriter, r *http.Request) { \n   fmt.Fprintf(w, \"Serving: %s\\n\", r.URL.Path) \n   fmt.Printf(\"Served: %s\\n\", r.Host) \n} \n```", "```go\nfunc main() { \n   PORT := \":8001\" \n   arguments := os.Args \n   if len(arguments) == 1 { \n         fmt.Println(\"Using default port number: \", PORT) \n   } else { \n         PORT = \":\" + arguments[1] \n   } \n```", "```go\n   http.HandleFunc(\"/\", myHandler) \n   err := http.ListenAndServe(PORT, nil) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(10) \n   } \n} \n```", "```go\n$ go run webServer.go\nUsing default port number:  :8001 \nServed: localhost:8001 Served: localhost:8001\nServed: localhost:8001\n```", "```go\n$ go run getURL.go http://localhost:8001/\nServing: /\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"net/http\" \n   \"time\" \n) \n```", "```go\nfunc about(w http.ResponseWriter, r *http.Request) { \n   fmt.Fprintf(w, \"This is the /about page at %s\\n\", r.URL.Path) \n   fmt.Printf(\"Served: %s\\n\", r.Host) \n} \n\nfunc cv(w http.ResponseWriter, r *http.Request) { \n   fmt.Fprintf(w, \"This is the /CV page at %s\\n\", r.URL.Path) \n   fmt.Printf(\"Served: %s\\n\", r.Host) \n} \n\nfunc timeHandler(w http.ResponseWriter, r *http.Request) { \n   currentTime := time.Now().Format(time.RFC1123) \n   title := currentTime \n   Body := \"The current time is:\" \n   fmt.Fprintf(w, \"<h1 align=\\\"center\\\">%s</h1><h2 align=\\\"center\\\">%s</h2>\", Body, title) \n   fmt.Printf(\"Served: %s for %s\\n\", r.URL.Path, r.Host) \n} \n```", "```go\nfunc home(w http.ResponseWriter, r *http.Request) { \n   ifr.URL.Path == \"/\" { \n         fmt.Fprintf(w, \"Welcome to my home page!\\n\") \n   } else { \n         fmt.Fprintf(w, \"Unknown page: %s from %s\\n\", r.URL.Path, r.Host) \n   } \n   fmt.Printf(\"Served: %s for %s\\n\", r.URL.Path, r.Host) \n} \n```", "```go\nfunc main() { \n   m := http.NewServeMux() \n   m.HandleFunc(\"/about\", about) \n   m.HandleFunc(\"/CV\", cv) \n   m.HandleFunc(\"/time\", timeHandler) \n   m.HandleFunc(\"/\", home) \n\n   http.ListenAndServe(\":8001\", m) \n} \n```", "```go\n$ go run serveMux.go Served: / for localhost:8001 Served: /123 for localhost:8001\nServed: localhost:8001\nServed: /cv for localhost:8001\n```", "```go\n$ wget -qO- http://localhost:8001/CV\nThis is the /CV page at /CV\n$ wget -qO- http://localhost:8001/cv\nUnknown page: /cv from localhost:8001\n$ wget -qO- http://localhost:8001/time\n<h1 align=\"center\">The current time is:</h1><h2 align=\"center\">Mon, 10 Jul 2017 13:13:27 EEST</h2>\n$ wget -qO- http://localhost:8001/time/\nUnknown page: /time/ from localhost:8001\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"html/template\" \n   \"net/http\" \n   \"os\" \n   \"strings\" \n) \n\ntype Entry struct { \n   WebSite string \n   WebName string \n   Quality string \n} \n\nvar filename string \n```", "```go\nfunc dynamicContent(w http.ResponseWriter, r *http.Request) { \n   var Data []Entry \n   var f *os.File \n   if filename == \"\" { \n         f = os.Stdin \n   } else { \n         fileHandler, err := os.Open(filename) \n         if err != nil { \n               fmt.Printf(\"error opening %s: %s\", filename, err) \n               os.Exit(1) \n         } \n         f = fileHandler \n   } \n   defer f.Close() \n   scanner := bufio.NewScanner(f) \n   myT := template.Must(template.ParseGlob(\"template.gohtml\")) \n```", "```go\n       for scanner.Scan() { \n\n         parts := strings.Fields(scanner.Text()) \n         if len(parts) == 3 { \n               temp := Entry{WebSite: parts[0], WebName: parts[1], Quality: parts[2]} \n               Data = append(Data, temp) \n         } \n   } \n\n   fmt.Println(\"Serving\", r.Host, \"for\", r.URL.Path) \n   myT.ExecuteTemplate(w, \"template.gohtml\", Data) \n} \n```", "```go\nfunc staticPage(w http.ResponseWriter, r *http.Request) { \n   fmt.Println(\"Serving\", r.Host, \"for\", r.URL.Path) \n   myT := template.Must(template.ParseGlob(\"static.gohtml\")) \n   myT.ExecuteTemplate(w, \"static.gohtml\", nil) \n} \n```", "```go\nfunc main() { \n   arguments := os.Args \n\n   if len(arguments) == 1 { \n         filename = \"\" \n   } else { \n         filename = arguments[1] \n   } \n```", "```go\n   http.HandleFunc(\"/static\", staticPage) \n   http.HandleFunc(\"/dynamic\", dynamicContent) \n   http.ListenAndServe(\":8001\", nil) \n} \n```", "```go\n<!doctype html> \n<htmllang=\"en\"> \n<head> \n   <meta charset=\"UTF-8\"> \n   <title>Using Go HTML Templates</title> \n   <style> \n         html { \n               font-size: 16px; \n         } \n         table, th, td { \n         border: 3px solid gray; \n         } \n   </style> \n</head> \n<body> \n\n<h2 alight=\"center\">Presenting Dynamic content!</h2> \n\n<table> \n   <thead> \n         <tr> \n               <th>Web Site</th> \n               <th>Quality</th> \n         </tr> \n   </thead> \n   <tbody> \n{{ range . }} \n<tr> \n   <td><a href=\"{{ .WebSite }}\">{{ .WebName }}</a></td> \n   <td> {{ .Quality }} </td> \n</tr> \n{{ end }} \n   </tbody> \n</table> \n\n</body> \n</html> \n```", "```go\n<!doctype html> \n<htmllang=\"en\"> \n<head> \n   <meta charset=\"UTF-8\"> \n   <title>A Static HTML Template</title> \n</head> \n<body> \n\n<H1>Hello there!</H1> \n\n</body> \n</html> \n```", "```go\n$ go run template.go /tmp/sites.html\nServing localhost:8001 for /dynamic\nServing localhost:8001 for /static\n```", "```go\n{ \"name\":\"Mihalis\", \n\"surname\":\"Tsoukalos\",\n\"country\":\"Greece\" }\n```", "```go\npackage main \n\nimport ( \n   \"encoding/json\" \n   \"fmt\" \n   \"os\" \n) \n\ntype Record struct { \n   Name    string \n   Surname string \n   Tel     []Telephone \n} \n\ntype Telephone struct { \n   Mobile bool \n   Number string \n} \n```", "```go\nfuncsaveToJSON(filename string, key interface{}) { \n   out, err := os.Create(filename) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n\n   encodeJSON := json.NewEncoder(out) \n   err = encodeJSON.Encode(key) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n\n   out.Close() \n} \n```", "```go\nfunc main() { \n   arguments := os.Args \n   if len(arguments) == 1 { \n         fmt.Println(\"Please provide a filename!\") \n         os.Exit(100) \n   } \n\n   filename := arguments[1] \n```", "```go\n   myRecord := Record{ \n         Name:    \"Mihalis\", \n         Surname: \"Tsoukalos\", \n         Tel: []Telephone{Telephone{Mobile: true, Number: \"1234-567\"}, \n               Telephone{Mobile: true, Number: \"1234-abcd\"}, \n               Telephone{Mobile: false, Number: \"abcc-567\"}, \n         }} \n\n   saveToJSON(filename, myRecord) \n} \n```", "```go\n$ go run writeJSON.go /tmp/SavedFile\n```", "```go\n$ cat /tmp/SavedFile\n{\"Name\":\"Mihalis\",\"Surname\":\"Tsoukalos\",\"Tel\":[{\"Mobile\":true,\"Number\":\"1234-567\"},{\"Mobile\":true,\"Number\":\"1234-abcd\"},{\"Mobile\":false,\"Number\":\"abcc-567\"}]}\n```", "```go\npackage main \n\nimport ( \n   \"encoding/json\" \n   \"fmt\" \n   \"os\" \n) \n\ntype Record struct { \n   Name    string \n   Surname string \n   Tel     []Telephone \n} \n\ntype Telephone struct { \n   Mobile bool \n   Number string \n} \n```", "```go\nfuncloadFromJSON(filename string, key interface{}) error { \n   in, err := os.Open(filename) \n   if err != nil { \n         return err \n   } \n\n   decodeJSON := json.NewDecoder(in) \n   err = decodeJSON.Decode(key) \n   if err != nil { \n         return err \n   } \n   in.Close() \n   return nil \n} \n```", "```go\nfunc main() { \n   arguments := os.Args \n   iflen(arguments) == 1 { \n         fmt.Println(\"Please provide a filename!\") \n         os.Exit(100) \n   } \n\n   filename := arguments[1] \n```", "```go\n   var myRecord Record \n   err := loadFromJSON(filename, &myRecord) \n   if err == nil { \n         fmt.Println(myRecord) \n   } else { \n         fmt.Println(err) \n   } \n} \n```", "```go\n$ go run readJSON.go /tmp/SavedFile\n{Mihalis Tsoukalos [{true 1234-567} {true 1234-abcd} {false abcc-567}]}\n```", "```go\npackage main \n\nimport ( \n   \"encoding/json\" \n   \"fmt\" \n   \"os\" \n) \n\ntype Record struct { \n   Name    string \n   Surname string \n   Tel     []Telephone \n} \n\ntype Telephone struct { \n   Mobile bool \n   Number string \n} \n```", "```go\nfunc main() { \n   myRecord := Record{ \n         Name:    \"Mihalis\", \n         Surname: \"Tsoukalos\", \n         Tel: []Telephone{Telephone{Mobile: true, Number: \"1234-567\"}, \n               Telephone{Mobile: true, Number: \"1234-abcd\"}, \n               Telephone{Mobile: false, Number: \"abcc-567\"}, \n         }} \n```", "```go\n   rec, err := json.Marshal(&myRecord) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(100) \n   } \n   fmt.Println(string(rec)) \n```", "```go\n   var unRec Record \n   err1 := json.Unmarshal(rec, &unRec) \n   if err1 != nil { \n         fmt.Println(err1) \n         os.Exit(100) \n   } \n   fmt.Println(unRec) \n} \n```", "```go\n$ go run marUnmar.go\n{\"Name\":\"Mihalis\",\"Surname\":\"Tsoukalos\",\"Tel\":[{\"Mobile\":true,\"Number\":\"1234-567\"},{\"Mobile\":true,\"Number\":\"1234-abcd\"},{\"Mobile\":false,\"Number\":\"abcc-567\"}]}\n{Mihalis Tsoukalos [{true 1234-567} {true 1234-abcd} {false abcc-567}]}\n```", "```go\n$ mongo\nMongoDB shell version v3.4.5\nconnecting to: mongodb://127.0.0.1:27017\n2017-07-06T19:37:38.291+0300 W NETWORK  [thread1] Failed to connect to 127.0.0.1:27017, in(checking socket for error after poll), reason: Connection refused\n2017-07-06T19:37:38.291+0300 E QUERY    [thread1] Error: couldn't connect to server 127.0.0.1:27017, connection attempt failed :\nconnect@src/mongo/shell/mongo.js:237:13\n@(connect):1:6\nexception: connect failed\n```", "```go\n$ mongo\nMongoDB shell version: 2.4.10\nconnecting to: test\n>\n```", "```go\n>use go;\nswitched to db go\n>db.someData.insert({x:0, y:1})\n>db.someData.insert({x:1, y:2})\n>db.someData.insert({x:2, y:3})\n>db.someData.count()\n3\n```", "```go\n>db.someData.find()\n{ \"_id\" : ObjectId(\"595e84cd63883cb3fe7f42f3\"), \"x\" : 0, \"y\" : 1 }\n{ \"_id\" : ObjectId(\"595e84d263883cb3fe7f42f4\"), \"x\" : 1, \"y\" : 2 }\n{ \"_id\" : ObjectId(\"595e84d663883cb3fe7f42f5\"), \"x\" : 2, \"y\" : 3 }\n```", "```go\n>show databases;\nLXF   0.203125GB\ngo    0.0625GB\nlocal 0.078125GB\n```", "```go\n>db.getCollectionNames()\n[ \"someData\", \"system.indexes\" ]\n```", "```go\n>db.someData.remove()\n>show collections\nsomeData\nsystem.indexes\n```", "```go\n>db.someData.drop()\ntrue\n>show collections\nsystem.indexes\n```", "```go\n$ go get labix.org/v2/mgo\n$ go get labix.org/v2/mgo/bson\n```", "```go\n$ go run testMongo.go\ntestMongo.go:5:2: cannot find package \"labix.org/v2/mgo\" in any of:\n      /usr/local/Cellar/go/1.8.3/libexec/src/labix.org/v2/mgo (from $GOROOT)\n      /Users/mtsouk/go/src/labix.org/v2/mgo (from $GOPATH)\ntestMongo.go:6:2: cannot find package \"labix.org/v2/mgo/bson\" in any of:\n      /usr/local/Cellar/go/1.8.3/libexec/src/labix.org/v2/mgo/bson (from $GOROOT)\n      /Users/mtsouk/go/src/labix.org/v2/mgo/bson (from $GOPATH)\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"labix.org/v2/mgo\" \n   \"labix.org/v2/mgo/bson\" \n   \"os\" \n   \"time\" \n) \n\ntype Record struct { \n   Xvalueint \n   Yvalueint \n} \n```", "```go\nfunc main() { \n   mongoDBDialInfo := &mgo.DialInfo{ \n         Addrs:   []string{\"127.0.0.1:27017\"}, \n         Timeout: 20 * time.Second, \n   } \n\n   session, err := mgo.DialWithInfo(mongoDBDialInfo) \n   if err != nil { \n         fmt.Printf(\"DialWithInfo: %s\\n\", err) \n         os.Exit(100) \n   } \n   session.SetMode(mgo.Monotonic, true) \n\n   collection := session.DB(\"goDriver\").C(\"someData\") \n```", "```go\n   err = collection.Insert(&Record{1, 0}) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(100) \n   } \n\n   err = collection.Insert(&Record{-1, 0}) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(100) \n   } \n```", "```go\n   var recs []Record \n   err = collection.Find(bson.M{\"yvalue\": 0}).All(&recs) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(100) \n   } \n\n   for x, y := range recs { \n         fmt.Println(x, y) \n   } \n   fmt.Println(\"Found:\", len(recs), \"results!\") \n} \n```", "```go\n$ go run testMongo.go\n0 {1 0}\n1 {-1 0}\nFound: 2 results!\n```", "```go\n$ mongo\nMongoDB shell version v3.4.5\nconnecting to: mongodb://127.0.0.1:27017\nMongoDB server version: 3.4.5\n>use goDriver\nswitched to db goDriver\n>show collections\nsomeData\n>db.someData.find()\n{ \"_id\" : ObjectId(\"595f88593fb7048f4846e555\"), \"xvalue\" : 1, \"yvalue\" : 0 }\n{ \"_id\" : ObjectId(\"595f88593fb7048f4846e557\"), \"xvalue\" : -1, \"yvalue\" : 0 }\n>\n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"html/template\" \n   \"labix.org/v2/mgo\" \n   \"net/http\" \n   \"os\" \n   \"time\" \n) \n\nvar DatabaseName string \nvar collectionName string \n\ntype Document struct { \n   P1 int \n   P2 int \n   P3 int \n   P4 int \n   P5 int \n}\n\n```", "```go\nfunc content(w http.ResponseWriter, r *http.Request) { \n   var Data []Document \n   myT := template.Must(template.ParseGlob(\"mongoDB.gohtml\")) \n\n   mongoDBDialInfo := &mgo.DialInfo{ \n         Addrs:   []string{\"127.0.0.1:27017\"}, \n         Timeout: 20 * time.Second, \n   } \n\n   session, err := mgo.DialWithInfo(mongoDBDialInfo) \n   if err != nil { \n         fmt.Printf(\"DialWithInfo: %s\\n\", err) \n         return \n   } \n   session.SetMode(mgo.Monotonic, true) \n   c := session.DB(DatabaseName).C(collectionName) \n\n   err = c.Find(nil).All(&Data) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n\n   fmt.Println(\"Found:\", len(Data), \"results!\") \n   myT.ExecuteTemplate(w, \"mongoDB.gohtml\", Data) \n} \n```", "```go\nfunc main() { \n   arguments := os.Args \n\n   iflen(arguments) <= 2 { \n         fmt.Println(\"Please provide a Database and a Collection!\") \n         os.Exit(100) \n   } else { \n         DatabaseName = arguments[1] \n         collectionName = arguments[2] \n   } \n\n   http.HandleFunc(\"/\", content) \n   http.ListenAndServe(\":8001\", nil) \n} \n```", "```go\n$ go run showMongo.go goDriver Numbers\nFound: 0 results!\nFound: 10 results!\nFound: 14 results!\n```", "```go\n>db.Numbers.findOne() \n{ \n      \"_id\" : ObjectId(\"596530aeaab5252f5c1ab100\"),\n      \"p1\" : -10,\n      \"p2\" : -20,\n      \"p3\" : 100,\n      \"p4\" : -1000,\n      \"p5\" : 10000\n}\n```", "```go\npackage main \n\nimport ( \n   \"database/sql\"  \n   \"fmt\" \n   _ \"github.com/go-sql-driver/mysql\" \n   \"os\" \n   \"text/template\" \n)\n\n```", "```go\n$ go get github.com/go-sql-driver/mysql\n```", "```go\nfunc main() { \n   var username string \n   var password string \n\n   arguments := os.Args \n   if len(arguments) == 3 { \n         username = arguments[1] \n         password = arguments[2] \n   } else { \n         fmt.Println(\"programName Username Password!\") \n         os.Exit(100) \n   } \n```", "```go\n   connectString := username + \":\" + password + \"@unix(/tmp/mysql.sock)/information_schema\" \n   db, err := sql.Open(\"mysql\", connectString) \n\n   rows, err := db.Query(\"SELECT DISTINCT(TABLE_SCHEMA) FROM TABLES;\") \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(100) \n   } \n```", "```go\n   var DATABASES []string \n   for rows.Next() { \n         var databaseName string \n         err := rows.Scan(&databaseName) \n         if err != nil { \n               fmt.Println(err) \n               os.Exit(100) \n         } \n         DATABASES = append(DATABASES, databaseName) \n   } \n   db.Close()\n\n```", "```go\n   t := template.Must(template.New(\"t1\").Parse(` \n   {{range $k := .}} {{ printf \"\\tDatabase Name: %s\" $k}} \n   {{end}} \n   `)) \n   t.Execute(os.Stdout, DATABASES) \n   fmt.Println() \n} \n```", "```go\n$ go run showMySQL.go root 12345\n\n    Database Name: information_schema\n    Database Name: mysql\n    Database Name: performance_schema\n    Database Name: sys\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"net/http\" \n   \"net/url\" \n   \"os\" \n   \"regexp\" \n) \n\ntype Data struct { \n   URL     string \n   Keyword string \n   Times   int \n   Error   error \n} \n```", "```go\nfunc monitor(values <-chan Data, count int) { \n   fori := 0; i< count; i++ { \n         x := <-values \n         if x.Error == nil { \n               fmt.Printf(\"\\t%s\\t\", x.Keyword) \n               fmt.Printf(\"\\t%d\\t in\\t%s\\n\", x.Times, x.URL) \n         } else { \n               fmt.Printf(\"\\t%s\\n\", x.Error) \n         } \n   } \n} \n```", "```go\nfunc processPage(myUrl, keyword string, out chan<- Data) { \n   var err error \n   times := 0 \n\n   URL, err :=url.Parse(myUrl) \n   if err != nil { \n         out<- Data{URL: myUrl, Keyword: keyword, Times: 0, Error: err} \n         return \n   } \n\n   c := &http.Client{} \n   request, err := http.NewRequest(\"GET\", URL.String(), nil) \n   if err != nil { \n         out<- Data{URL: myUrl, Keyword: keyword, Times: 0, Error: err} \n         return \n   } \n\n   httpData, err := c.Do(request) \n   if err != nil { \n         out<- Data{URL: myUrl, Keyword: keyword, Times: 0, Error: err} \n         return \n   } \n\n   bodyHTML := \"\"\n\n   var buffer [1024]byte \n   reader := httpData.Body \n   for { \n         n, err := reader.Read(buffer[0:]) \n         if err != nil { \n               break \n         } \n         bodyHTML = bodyHTML + string(buffer[0:n]) \n   } \n\n   regExpr := keyword\n\n   r := regexp.MustCompile(regExpr) \n   matches := r.FindAllString(bodyHTML, -1) \n   times = times + len(matches) \n\n   newValue := Data{URL: myUrl, Keyword: keyword, Times: times, Error: nil} \n   out<- newValue \n} \n```", "```go\nfunc main() { \n   filename := \"\" \n   var f *os.File \n   var keyword string \n\n   arguments := os.Args \n   iflen(arguments) == 1 { \n         fmt.Println(\"Not enough arguments!\") \n         os.Exit(-1) \n   } \n\n   iflen(arguments) == 2 { \n         f = os.Stdin \n         keyword = arguments[1] \n   } else { \n         keyword = arguments[1] \n         filename = arguments[2] \n         fileHandler, err := os.Open(filename) \n         if err != nil { \n               fmt.Printf(\"error opening %s: %s\", filename, err) \n               os.Exit(1) \n         } \n         f = fileHandler \n   } \n\n   deferf.Close() \n```", "```go\n   values := make(chan Data, len(os.Args[1:])) \n\n   scanner := bufio.NewScanner(f) \n   count := 0 \n   forscanner.Scan() { \n         count = count + 1 \n         gofunc(URL string) { \n               processPage(URL, keyword, values) \n         }(scanner.Text()) \n   } \n\n   monitor(values, count) \n} \n```", "```go\n$ go run findKeyword.go Tsoukalos /tmp/sites.html\n  Get http://really.doesnotexist.com: dial tcp: lookup really.doesnotexist.com: no such host\n  Tsoukalos         8      in   http://www.highiso.net/\n  Tsoukalos         4      in   http://www.mtsoukalos.eu/\n  Tsoukalos         3      in   https://www.packtpub.com/networking-and-servers/go-systems-programming\n  Tsoukalos         0      in   http://cnn.com/\n  Tsoukalos         0      in   http://doesnotexist.com\n```"]