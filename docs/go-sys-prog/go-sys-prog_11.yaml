- en: Writing Web Applications in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中编写Web应用程序
- en: In the previous chapter, we discussed many advanced topics related to goroutines
    and channels as well as shared memory and mutexes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了许多与goroutines和通道相关的高级主题，以及共享内存和互斥锁。
- en: The main subject of this chapter is the development of web applications in Go.
    However, this chapter will also talk about how to interact with two popular databases
    in your Go programs. The Go standard library provides packages that can help you
    develop web applications using higher level functions, which means that you can
    do complex things such as reading web pages by just calling a couple of Go functions
    with the right arguments. Although this kind of programming hides the complexity
    behind a request and offers less control over the details, it allows you to develop
    difficult applications using fewer lines of code, which also results in having
    fewer bugs in your programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要内容是在Go中开发Web应用程序。然而，本章还将讨论如何在Go程序中与两个流行的数据库进行交互。Go标准库提供了可以帮助你使用更高级函数开发Web应用程序的包，这意味着你可以通过调用几个带有正确参数的Go函数来做复杂的事情，比如读取网页。虽然这种编程方式隐藏了请求背后的复杂性，并且对细节的控制较少，但它允许你使用更少的代码开发复杂的应用程序，这也导致程序中的错误更少。
- en: 'However, as this book is about systems programming, this chapter will not go
    into too much depth: you might consider the presented information as a good starting
    point for anyone who wants to learn about web development in Go.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于本书是关于系统编程的，本章不会深入讨论：你可以将所呈现的信息视为任何想学习在Go中进行Web开发的人的良好起点。
- en: 'More specifically, this chapter will talk about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，本章将讨论以下主题：
- en: Creating a Go utility for MySQL database administrators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为MySQL数据库管理员创建一个Go实用程序
- en: Administering a MongoDB database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理MongoDB数据库
- en: Using the Go MongoDB driver to talk to a MongoDB database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Go MongoDB驱动程序与MongoDB数据库通信
- en: Creating a web server in Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中创建Web服务器
- en: Creating a web client in Go
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中创建Web客户端
- en: The `http.ServeMux` type
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.ServeMux`类型'
- en: Dealing with JSON data in Go
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理Go中的JSON数据
- en: The `net/http` package
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http`包'
- en: The `html/template` Go standard package
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html/template` Go标准包'
- en: Developing a command-line utility that searches web pages for a given keyword
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个在给定关键字中搜索网页的命令行实用程序
- en: What is a web application?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Web应用程序？
- en: A web application is a client-server software application where the client part
    runs on a web browser. Web applications include webmail, instant messaging services,
    and online stores.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序是一个客户端-服务器软件应用程序，其中客户端部分在Web浏览器上运行。Web应用程序包括网络邮件、即时通讯服务和在线商店。
- en: About the net/http Go package
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于net/http Go包
- en: The hero of this chapter will be the `net/http` package that can help you write
    web applications in Go. However, if you are interested in dealing with TCP/IP
    connections at a lower level, then you should go to [Chapter 12](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml),
    *Network Programming*, which talks about developing TCP/IP applications using
    lower level function calls.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主角将是`net/http`包，它可以帮助你在Go中编写Web应用程序。然而，如果你对在较低级别处理TCP/IP连接感兴趣，那么你应该去[第12章](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml)，*网络编程*，它讨论使用较低级别函数调用开发TCP/IP应用程序。
- en: The `net/http` package offers a built-in web server as well as a built-in web
    client that are both pretty powerful. The `http.Get()` method can be used for
    making HTTP and HTTPS requests, whereas the `http.ListenAndServe()` function can
    be used for creating naive web servers by specifying the IP address and the TCP
    port the server will listen to, as well as the functions that will handle incoming
    requests.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包提供了一个内置的Web服务器和一个内置的Web客户端，它们都非常强大。`http.Get()`方法可用于发出HTTP和HTTPS请求，而`http.ListenAndServe()`函数可用于通过指定服务器将监听的IP地址和TCP端口以及处理传入请求的函数来创建简单的Web服务器。'
- en: Another very convenient package is `html/template`, which is part of the Go
    standard library and allows you to generate an HTML output using Go HTML template
    files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常方便的包是`html/template`，它是Go标准库的一部分，允许你使用Go HTML模板文件生成HTML输出。
- en: Developing web clients
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中开发Web客户端
- en: In this section, you will learn how to develop web clients in Go and how to
    time out a web connection that takes too long to finish.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何在Go中开发Web客户端，以及如何超时处理需要太长时间才能完成的Web连接。
- en: Fetching a single URL
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取单个URL
- en: 'In this subsection, you will learn how to read a single web page with the help
    of the `http.Get()` function, which is going to be demonstrated in the `getURL.go`
    program. The utility will be presented in four parts; the first part of the program
    is the expected preamble:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，你将学习如何使用`http.Get()`函数读取单个网页，这将在`getURL.go`程序中进行演示。该实用程序将分为四个部分；程序的第一部分是预期的序言：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Although there is nothing new here, you might find impressive the fact that
    you will use Go packages that are related to file input and output operations
    even though you are reading data from the internet. The explanation for this is
    pretty simple: Go has a uniform interface for reading and writing data regardless
    of the medium it is in.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里没有什么新东西，但你可能会发现令人印象深刻的是，即使你从互联网读取数据，你也会使用与文件输入和输出操作相关的Go包。这背后的解释非常简单：Go具有统一的接口，用于读取和写入数据，无论数据所在的介质如何。
- en: 'The second part of `getURL.go` has the following Go code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`getURL.go`的第二部分包含以下Go代码：'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The URL you want to fetch is given as a command-line argument to the program.
    Additionally, you can see the call to `http.Get()`, which does all the dirty work!
    What `http.Get()` returns is a `Response` variable, which in reality is a Go structure
    with various properties and methods.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你想获取的URL作为程序的命令行参数给出。此外，你可以看到对`http.Get()`的调用，它完成了所有的脏活！`http.Get()`返回的是一个`Response`变量，实际上是一个具有各种属性和方法的Go结构。
- en: 'The third part is the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分如下：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If there is an error after calling `http.Get()`, this is the place to check
    for it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`http.Get()`后如果出现错误，这是检查错误的地方。
- en: 'The fourth part contains the following Go code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分包含以下Go代码：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the data of `URL` is written in standard output using `os.Stdout`,
    which is the preferred way for printing data on the screen. Additionally, the
    data is saved in the `Body` property of the return value of the `http.Get()` call.
    However, not all HTTP requests are simple. If the response streams a video or
    something similar, it would make sense to be able to read it one piece at a time
    instead of getting all of it in a single data piece. You can do that with `io.Reader`
    and the `Body` part of the response.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`URL`的数据是使用`os.Stdout`写入标准输出的，这是在屏幕上打印数据的首选方式。此外，数据保存在`http.Get()`调用的返回值的`Body`属性中。然而，并非所有的HTTP请求都是简单的。如果响应流式传输视频或类似内容，逐段读取它而不是一次性获取所有内容是有意义的。您可以使用`io.Reader`和响应的`Body`部分来实现这一点。
- en: 'Executing `getURL.go` will generate the following raw results, which is what
    a web browser would have gotten and rendered:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`getURL.go`将生成以下原始结果，这就是Web浏览器将获得并呈现的内容：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Generally speaking, although `getURL.go` does the desired job, the way it works
    is not so sophisticated because it gives you no flexibility or a way to be creative.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，虽然`getURL.go`可以完成所需的工作，但它的工作方式并不那么复杂，因为它不提供灵活性或创造性的方式。
- en: Setting a timeout
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置超时
- en: In this subsection, you will learn how to set a timeout for a `http.Get()` request.
    For reasons of simplicity, it will be based on the Go code of `getURL.go`. The
    name of the program will be `timeoutHTTP.go` and will be presented in five parts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，您将学习如何为`http.Get()`请求设置超时。出于简单起见，它将基于`getURL.go`的Go代码。程序的名称将是`timeoutHTTP.go`，并将以五个部分的形式呈现。
- en: 'The first part of the program is the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分如下：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, you declare the desired timeout period, which is 1 second, as a global
    parameter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将所需的超时时间声明为全局参数，即1秒。
- en: 'The second part of `timeoutHTTP.go` has the following Go code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeoutHTTP.go`的第二部分包含以下Go代码：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, you define two types of timeouts, the first one is defined with `net.DialTimeout()`
    and is for the time it will take your client to connect to the server. The second
    one is the read/write timeout, which has to do with the time you want to wait
    to get a response from the web server after connecting to it: this is defined
    with the call to the `conn.SetDeadline()` function.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您定义了两种类型的超时，第一种是使用`net.DialTimeout()`定义的，用于客户端连接到服务器所需的时间。第二种是读/写超时，与连接到Web服务器后等待获取响应的时间有关：这是使用`conn.SetDeadline()`函数定义的。
- en: 'The third part of the presented program is the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现程序的第三部分如下：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The fourth portion of the program is the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第四部分如下：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, you define the desired parameters of the connection using an `http.Transport`
    variable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用`http.Transport`变量定义连接的所需参数。
- en: 'The last part of the program contains the following Go code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分包含以下Go代码：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This part of the program is all about error handling!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的这一部分都是关于错误处理的！
- en: 'Executing `timeoutHTTP.go` will generate the following output in case of a
    timeout:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`timeoutHTTP.go`将在超时的情况下生成以下输出：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The simplest way to deliberately create a timeout during a web connection is
    to call the `time.Sleep()` function in the handler function of a web server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 故意在Web连接期间创建超时的最简单方法是在Web服务器的处理程序函数中调用`time.Sleep()`函数。
- en: Developing better web clients
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发更好的网络客户端
- en: Although `getURL.go` does the required job pretty quickly and without writing
    too much Go code, it is in a way not adaptable or informative. It just prints
    a bunch of raw HTML code without any other information and without the capability
    of dividing the HTML code into its logical parts. Therefore, `getURL.go` needs
    to be improved!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`getURL.go`可以很快地完成所需的工作，并且不需要编写太多的Go代码，但它在某种程度上不够灵活或信息丰富。它只是打印一堆原始的HTML代码，没有其他信息，也没有将HTML代码分成逻辑部分的能力。因此，需要改进`getURL.go`！
- en: The name of the new utility will be `webClient.go` and will be presented to
    you in five segments of Go code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 新实用程序的名称将是`webClient.go`，并将以五个Go代码段的形式呈现给您。
- en: 'The first part of the utility is the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该实用程序的第一部分如下：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The second part of the Go code from `webClient.go` is the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`webClient.go`中的Go代码的第二部分如下：'
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only new thing here is the use of the `url.Parse()` function that creates
    a `URL` structure from a URL that is given as a string to it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新内容是使用`url.Parse()`函数，它从给定的字符串创建一个`URL`结构。
- en: 'The third part of `webClient.go` has the following Go code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`webClient.go`的第三部分包含以下Go代码：'
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this Go code, you first create an `http.Client` variable. Then, you construct
    a `GET` HTTP request using `http.NewRequest()`. Last, you send the HTTP request
    using the `Do()` function, which returns the actual response data saved in the
    `httpData` variable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段Go代码中，您首先创建一个`http.Client`变量。然后，您使用`http.NewRequest()`构造一个`GET` HTTP请求。最后，您使用`Do()`函数发送HTTP请求，该函数返回保存在`httpData`变量中的实际响应数据。
- en: 'The fourth code part of the utility is the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该实用程序的第四部分代码如下：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, you find the status code of the HTTP request using the `Status` property.
    Then, you do a little digging into the `Header` part of the response in order
    to find the character set of the response. Last, you check the value of the `ContentLength`
    property, which equals `-1` for dynamic pages: this means that you do not know
    the page size in advance.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用`Status`属性找到HTTP请求的状态代码。然后，您可以对响应的`Header`部分进行一些挖掘，以找到响应的字符集。最后，您可以检查`ContentLength`属性的值，对于动态页面，它等于`-1`：这意味着您事先不知道页面的大小。
- en: 'The last part of the program has the following Go code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分包含以下Go代码：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, you find the length of the response by reading from the `Body` reader
    and counting its data. If you want to print the contents of the response, this
    is the right place to do it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您通过从`Body`读取器中读取数据并计算其数据长度来找到响应的长度。如果要打印响应的内容，这是正确的位置。
- en: 'Executing `webClient.go` will create the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`webClient.go`将创建以下输出：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A small web server
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个小型的web服务器
- en: 'Enough with the web clients: in this section, you will learn how to develop
    web servers in Go!'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 够了，关于Web客户端的内容：在本节中，您将学习如何在Go中开发Web服务器！
- en: 'The Go code for the implementation of a naive web server can be found in `webServer.go`,
    and this will be presented in four parts; the first part is the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`webServer.go`中找到一个简单Web服务器实现的Go代码，并且将以四部分呈现；第一部分如下：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second part is where things start to get tricky and strange:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是事情开始变得棘手和奇怪的地方：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is a kind of function that handles HTTP requests: the function takes two
    arguments, a `http.ResponseWriter` variable and a pointer to an `http.Request`
    variable. The first argument will be used for constructing the HTTP response,
    whereas the `http.Request` variable holds the details of the HTTP request that
    was received by the server, including the requested URL and the IP address of
    the client.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种处理HTTP请求的函数：该函数接受两个参数，一个`http.ResponseWriter`变量和一个指向`http.Request`变量的指针。第一个参数将用于构造HTTP响应，而`http.Request`变量保存了服务器接收到的HTTP请求的详细信息，包括请求的URL和客户端的IP地址。
- en: 'The third part of `webServer.go` has the following Go code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`webServer.go`的第三部分包含以下Go代码：'
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, you just deal with the port number of the web server: the default port
    number is `8001`, unless there is a command-line argument.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您只需处理web服务器的端口号：默认端口号是`8001`，除非有命令行参数。
- en: 'The last chunk of Go code for `webServer.go` is the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`webServer.go`的最后一部分Go代码如下：'
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `http.HandleFunc()` call defines the name of the handler function (`myHandler`)
    as well as the URLs that it will support: you can call `http.HandleFunc()` multiple
    times. The current handler supports `/URL`, which in Go matches all URLs!'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.HandleFunc()`调用定义了处理程序函数的名称（`myHandler`）以及它将支持的URL：您可以多次调用`http.HandleFunc()`。当前处理程序支持`/URL`，在Go中匹配所有URL！'
- en: After you are done with the `http.HandleFunc()` calls, you are ready to call
    `http.ListenAndServe()` and start waiting for incoming connections! If you do
    not specify an IP address in the `http.ListenAndServe()` function call, then the
    web server will listen to all configured network interfaces of the machine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成`http.HandleFunc()`调用后，您可以准备调用`http.ListenAndServe()`并开始等待传入的连接！如果在`http.ListenAndServe()`函数调用中未指定IP地址，则Web服务器将侦听计算机的所有配置的网络接口。
- en: 'Executing `webServer.go` will generate no output, unless you try to fetch some
    data from it: in this case, it will print logging information on your Terminal,
    which will show the server name (`localhost`) and port number (`8001`) of the
    request, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`webServer.go`将不会生成任何输出，除非您尝试从中获取一些数据：在这种情况下，它将在您的终端上打印日志信息，显示请求的服务器名称（`localhost`）和端口号（`8001`），如下所示：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following screenshot shows three outputs of `webServer.go` on a web browser:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在Web浏览器上`webServer.go`的三个输出：
- en: '![](img/92cc0e7a-c289-4559-ae6f-6fc6e9d42ad3.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92cc0e7a-c289-4559-ae6f-6fc6e9d42ad3.png)'
- en: Using webServer.go
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用webServer.go
- en: 'However, if you use a command-line utility such as `wget(1)` or `getURL.go`
    instead of a web browser, you will get the following output when you try to connect
    to the Go web server:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您使用`wget(1)`或`getURL.go`等命令行实用程序而不是Web浏览器，当您尝试连接到Go Web服务器时，您将获得以下输出：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The biggest advantage you get from custom made web servers is security because
    they are really difficult to hack when developed with security as well as easier
    customization in mind.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您从自定义的web服务器中获得的最大优势是安全性，因为当以安全性以及更容易的定制为目标开发时，它们真的很难被黑客攻击。
- en: The next subsection will show how to create web servers using `http.ServeMux`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将展示如何使用`http.ServeMux`创建Web服务器。
- en: The http.ServeMux type
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: http.ServeMux类型
- en: In this subsection, you will learn how to use the `http.ServeMux` type in order
    to improve the way your Go web server will operate. Putting it simply, `http.ServeMux`
    is a HTTP request router.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，您将学习如何使用`http.ServeMux`类型来改进Go Web服务器的操作方式。简单地说，`http.ServeMux`是一个HTTP请求路由器。
- en: Using http.ServeMux
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用http.ServeMux
- en: The web server implementation of this section will support multiple paths with
    the help of `http.ServeMux`, which will be illustrated in the `serveMux.go` program
    that will be displayed in four parts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的Web服务器实现将使用`http.ServeMux`来支持多个路径，这将在将显示为四部分的`serveMux.go`程序中进行说明。
- en: 'The first part of the program is the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分如下：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The second part of `serveMux.go` has the following Go code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`serveMux.go`的第二部分包含以下Go代码：'
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, you have the implementation of three HTTP handler functions. The first
    two display a static page, whereas the third one displays the current time, which
    is a dynamic text.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您有三个HTTP处理程序函数的实现。前两个显示静态页面，而第三个显示当前时间，这是一个动态文本。
- en: 'The third part of the program is the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分如下：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `home()` handler function will have to make sure that it is actually serving
    `/Path`, because `/Path` catches everything!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`home()`处理程序函数将必须确保它实际上正在服务于`/Path`，因为`/Path`会捕捉一切！'
- en: 'The last part of `serveMux.go` contains the following Go code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`serveMux.go`的最后部分包含以下Go代码：'
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, you define the paths that your web server will support. Note that paths
    are case sensitive and that the last path in the preceding code catches everything.
    This means that if you put `m.HandleFunc("/", home)` first, you will not be able
    to match anything else. Putting it simply, the order of the `m.HandleFunc()` statements
    matters. Also, note that if you want to support both `/about` and `/about/`, you
    should have both `m.HandleFunc("/about", about)` and `m.HandleFunc("/about/",
    about)`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您定义了您的Web服务器将支持的路径。请注意，路径区分大小写，并且在前面的代码中最后一个路径会捕捉一切。这意味着如果您首先放置`m.HandleFunc("/",
    home)`，您将无法匹配其他任何内容。简单地说，`m.HandleFunc()`语句的顺序很重要。还要注意，如果您想同时支持`/about`和`/about/`，您应该同时拥有`m.HandleFunc("/about",
    about)`和`m.HandleFunc("/about/", about)`。
- en: 'Running `serveMux.go` will generate the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`serveMux.go`将生成以下输出：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following screenshot shows the various kinds of outputs generated by `serveMux.go`
    on a web browser: note that the browser output is not related to the preceding
    output from the `go run serveMux.go` command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`serveMux.go`在Web浏览器上生成的各种输出类型：请注意，浏览器输出与`go run serveMux.go`命令之前的输出无关：
- en: '![](img/67d1c2e9-8fd4-4134-8ae7-f992fdb8d0d7.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67d1c2e9-8fd4-4134-8ae7-f992fdb8d0d7.png)'
- en: Using serveMux.go
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用serveMux.go
- en: 'If you use `wget(1)` instead of a web browser, you will get the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`wget(1)`而不是Web浏览器，你将得到以下输出：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So, `http.HandleFunc()` is the default call in the library that will be used
    for first time implementations, whereas the `HandleFunc()` function of `http.NewServeMux()`
    is for everything else. Putting it simply, it is better to use the `http.NewServeMux()`
    version instead of the default one except in the simplest of cases.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`http.HandleFunc()`是库中默认调用的函数，将用于首次实现，而`http.NewServeMux()`的`HandleFunc()`函数则用于其他情况。简单来说，除了在最简单的情况下，最好使用`http.NewServeMux()`版本而不是默认版本。
- en: The html/template package
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: html/template包
- en: '**Templates** are mainly used for separating the formatting and data parts
    of the output. Note that a Go template can be either a file or string: the general
    idea is to use strings for smaller templates and files for bigger ones.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板**主要用于分离输出的格式和数据部分。请注意，Go模板可以是文件或字符串：一般的想法是对较小的模板使用字符串，对较大的模板使用文件。'
- en: In this section, we will talk about the `html/template` package by showing an
    example, which can be found in the `template.go` file and will be presented in
    six parts. The general idea behind `template.go` is that you are reading a text
    file with records that you want to present in HTML format. Given that the name
    of the package is `html/template`, a better name for the program would have been
    `genHTML.go` or `genTemplate.go`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个示例来讨论`html/template`包，该示例可以在`template.go`文件中找到，并将分为六部分呈现。`template.go`背后的一般思想是，你正在读取一个包含你想要以HTML格式呈现的记录的文本文件。鉴于包的名称是`html/template`，程序的更好名称应该是`genHTML.go`或`genTemplate.go`。
- en: There is also the `text/template` package, which is more useful for creating
    plain text output. However, you cannot import both `text/template` and `html/template`
    on the same Go program without taking some extra steps to disambiguate them because
    the two packages have the same package name (`template`). The key distinction
    between the two packages is that `html/template` does sanitization of the data
    input for HTML injection, which means that it is more secure.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`text/template`包，更适用于创建纯文本输出。但是，你不能在同一个Go程序中导入`text/template`和`html/template`，除非采取一些额外的步骤来消除歧义，因为这两个包具有相同的包名（`template`）。这两个包之间的关键区别在于，`html/template`对HTML注入的数据进行了消毒处理，这意味着它更安全。
- en: 'The first part of the source file is the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件的第一部分如下：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The definition of the structure is really important because this is how your
    data is going to be passed to the `template` file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 结构的定义非常重要，因为这是数据传递到`template`文件的方式。
- en: 'The second part of `template.go` has the following Go code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`template.go`的第二部分包含以下Go代码：'
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `template.ParseGlob()` function is used for reading the external template
    file, which can have any file extension you want. Using the `.gohtml` extension
    might make your life simpler when you are looking for Go template files in your
    projects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`template.ParseGlob()`函数用于读取外部模板文件，它可以有任何你想要的文件扩展名。在项目中查找Go模板文件时，使用`.gohtml`扩展名可能会让你的生活更简单。'
- en: Although I personally prefer the `.gohtml` extension for Go template files,
    `.tpl` is a pretty common extension that is widely used. You can choose whichever
    you like.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我个人更喜欢使用`.gohtml`扩展名来命名Go模板文件，但`.tpl`是一个非常常见的扩展名，被广泛使用。你可以选择你喜欢的任何一个。
- en: 'The third chunk of code from `template.go` is the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`template.go`的第三部分代码如下：'
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The third parameter to the `ExecuteTemplate()` function is the data you want
    to process. In this case, you pass a slice of records to it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteTemplate()`函数的第三个参数是你要处理的数据。在这种情况下，你将一个记录的切片传递给它。'
- en: 'The fourth part of the program is the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第四部分如下：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function displays a static HTML page, which we are just going to pass through
    the template engine with the `nil` data, which is signified by the third argument
    of the `ExecuteTemplate()` function. If you have the same function handling different
    pieces of data, you may end up with cases where there is nothing to render, but
    keep it there for common code structure.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数显示一个静态的HTML页面，我们将通过模板引擎传递`nil`数据，这由`ExecuteTemplate()`函数的第三个参数表示。如果你有相同的函数处理不同的数据片段，可能会出现没有内容可渲染的情况，但保留它是为了保持通用的代码结构。
- en: 'The fifth part of `template.go` contains the following Go code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`template.go`的第五部分包含以下Go代码：'
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The last chunk of Go code from `template.go` is where you define the supported
    paths and start the web server using port number `8001`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`template.go`中的最后一部分Go代码是你定义支持的路径并使用端口号`8001`启动Web服务器的地方：'
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The contents of the `template.gohtml` file are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`template.gohtml`文件的内容如下：'
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The dot (`.`) character represents the current data being processed: to put
    it simply, the dot (`.`) character is a variable. The `{{ range . }}` statement
    is equivalent to a `for` loop that visits all the elements of the input slice,
    which are structures in this case. You can access the fields of each structure
    as `.WebSite`, `.WebName`, and `.Quality`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 句点（`.`）字符代表当前正在处理的数据：简单来说，句点（`.`）字符是一个变量。`{{ range . }}`语句相当于一个`for`循环，遍历输入切片的所有元素，在这种情况下是结构。你可以访问每个结构的字段，如`.WebSite`、`.WebName`和`.Quality`。
- en: 'The contents of the `static.gohtml` file are the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`static.gohtml`文件的内容如下：'
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you execute `template.go`, you will get the following output on the screen:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行`template.go`，你将在屏幕上看到以下输出：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The following screenshot shows the two outputs of `template.go` as displayed
    on a web browser. The `sites.html` file has three columns, which are the URL,
    the name and the quality and can have multiple lines. The good thing here is that
    if you change the contents of the `/tmp/sites.html` file and reload the web page,
    you will see the updated contents!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了`template.go`的两个输出，显示在Web浏览器上。`sites.html`文件有三列，分别是URL、名称和质量，可以有多行。好处在于，如果更改`/tmp/sites.html`文件的内容并重新加载网页，您将看到更新后的内容！
- en: '![](img/31188a00-51f7-4535-9f6b-2ce30fca63c9.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31188a00-51f7-4535-9f6b-2ce30fca63c9.png)'
- en: Using template.go
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用template.go
- en: About JSON
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于JSON
- en: '**JSON** stands for JavaScript Object Notation. This is a text-based format
    designed as an easy and light way to pass information between JavaScript systems.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**代表JavaScript对象表示法。这是一种基于文本的格式，旨在作为在JavaScript系统之间传递信息的一种简单轻便的方式。'
- en: 'A simple JSON document has the following format:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的JSON文档具有以下格式：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding JSON document has three fields named `name`, `surname`, and `country`.
    Each field has a single value.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的JSON文档有三个字段，分别命名为`name`、`surname`和`country`。每个字段都有一个单一值。
- en: However, JSON documents can have more complex structures with multiple depth
    levels.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JSON文档可以具有更复杂的结构，具有多个深度级别。
- en: Before seeing some code, I think that it would be very useful to talk about
    the `encoding/json` Go package first. The `encoding/json` package offers the `Encode()`
    and `Decode()` functions that allow the conversion of a Go object into a JSON
    document and vice versa. Additionally, the `encoding/json` package offers the
    `Marshal()` and `Unmarshal()` functions that work similarly to `Encode()` and
    `Decode()` and are based on the `Encode()` and `Decode()` methods.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在看一些代码之前，我认为首先讨论`encoding/json` Go包将非常有用。`encoding/json`包提供了`Encode()`和`Decode()`函数，允许将Go对象转换为JSON文档，反之亦然。此外，`encoding/json`包还提供了`Marshal()`和`Unmarshal()`函数，其工作方式类似于`Encode()`和`Decode()`，并且基于`Encode()`和`Decode()`方法。
- en: The main difference between `Marshal()-Unmarshal()` and `Encode()-Decode()`
    is that the former functions work on single objects, whereas the latter functions
    can work on multiple objects as well as streams of bytes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Marshal()-Unmarshal()`和`Encode()-Decode()`之间的主要区别在于前者函数适用于单个对象，而后者函数可以处理多个对象以及字节流。'
- en: 'Last, the `encoding/json` Go package includes two interfaces named `Marshaler`
    and `Unmarshaler`: each one of them requires the implementation of a single method,
    named `MarshalJSON()` and `UnmarshalJSON()`, respectively. These two interfaces
    allow you to perform custom JSON **Marshalling** and **Unmarshalling** in Go.
    Unfortunately, those two interfaces will not be covered in this book.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`encoding/json` Go包包括两个名为`Marshaler`和`Unmarshaler`的接口：它们每个都需要实现一个单一方法，分别命名为`MarshalJSON()`和`UnmarshalJSON()`。这两个接口允许您在Go中执行自定义JSON
    **编组**和**解组**。不幸的是，这两个接口将不在本书中介绍。
- en: Saving JSON data
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存JSON数据
- en: This subsection will teach you how to convert regular data into JSON format
    in order to send it over a network connection. The Go code of this subsection
    will be saved as `writeJSON.go` and will be presented in four parts.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将教您如何将常规数据转换为JSON格式，以便通过网络连接发送。本小节的Go代码将保存为`writeJSON.go`，并将分为四个部分呈现。
- en: 'The first chunk of Go code is the expected preamble of the program as well
    as the definition of two new `struct` types named `Record` and `Telephone`, respectively:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Go代码的第一部分是程序的预期序文，以及分别命名为`Record`和`Telephone`的两个新`struct`类型的定义：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note that only the members of a structure that begin with an uppercase letter
    will be in the JSON output because members that begin with a lowercase letter
    are considered private: in this case, all members of `Record` and `Telephone`
    structures are public and will get exported.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，结构的成员只有以大写字母开头的成员才会出现在JSON输出中，因为以小写字母开头的成员被视为私有：在这种情况下，`Record`和`Telephone`结构的所有成员都是公共的，并将被导出。
- en: 'The second part is the definition of a function named `saveToJSON()`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是定义名为`saveToJSON()`的函数：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `saveToJSON()` function does all the work for us as it creates a JSON encoder
    variable named `encodeJSON`, which is associated with a filename, which is where
    the data is going to be saved. Then, the call to `Encode()` saves the data of
    the record to the associated filename and we are done! As you will see in the
    next section, a similar process will help you read a JSON file and convert it
    into a Go variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveToJSON()`函数为我们完成所有工作，因为它创建了一个名为`encodeJSON`的JSON编码器变量，它与文件名相关联，数据将保存在那里。然后，调用`Encode()`将记录的数据保存到相关的文件名，我们就完成了！正如您将在下一节中看到的那样，类似的过程将帮助您读取JSON文件并将其转换为Go变量。'
- en: 'The third part of the program has the following Go code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分具有以下Go代码：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There is nothing special here: you just get the first command-line argument
    of the program.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的：您只需获取程序的第一个命令行参数。
- en: 'The last part of the utility is the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该实用程序的最后一部分如下：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we do two things. The first is defining a new `Record` variable and filling
    it with data. The second is the call to `saveToJSON()` for saving the `myRecord`
    variable in the JSON format to the selected file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们做了两件事。第一件事是定义一个新的`Record`变量并填充它的数据。第二件事是调用`saveToJSON()`将`myRecord`变量以JSON格式保存到所选文件中。
- en: 'Executing `writeJSON.go` will generate the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`writeJSON.go`将生成以下输出：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After that, the contents of `/tmp/SavedFile` will be the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`/tmp/SavedFile`的内容将如下所示：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Sending JSON data over a network requires the use of the net Go standard package
    that will be discussed in the next chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络发送JSON数据需要使用net Go标准包，这将在下一章中讨论。
- en: Parsing JSON data
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析JSON数据
- en: This subsection will illustrate how to read a JSON record and convert it into
    one Go variable that you can use in your own programs. The name of the presented
    program will be `readJSON.go` and will be shown to you in four parts.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将说明如何读取JSON记录并将其转换为一个可以在您自己的程序中使用的Go变量。所呈现的程序的名称将是`readJSON.go`，并将分为四个部分呈现给您。
- en: 'The first part of the utility is identical to the first part of the `writeJSON.go`
    utility:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该实用程序的第一部分与`writeJSON.go`实用程序的第一部分相同：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The second part of the Go code is the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Go代码的第二部分如下：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, you define a new function named `loadFromJSON()` that is used for decoding
    a JSON file according to a data structure that is given as the second argument
    to it. You first call the `json.NewDecoder()` function to create a new JSON decode
    variable that is associated with a file, and then you call the `Decode()` function
    for actually decoding the contents of the file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您定义了一个名为`loadFromJSON()`的新函数，用于根据作为第二个参数给出的数据结构解码JSON文件。您首先调用`json.NewDecoder()`函数创建一个与文件关联的新JSON解码变量，然后调用`Decode()`函数来实际解码文件的内容。
- en: 'The third part of `readJSON.go` has the following Go code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`readJSON.go`的第三部分包含以下Go代码：'
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The last part of the program is the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分如下：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you run `readJSON.go`, you will get the following output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`readJSON.go`，将得到以下输出：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Reading your JSON data from a network will be discussed in the next chapter,
    as JSON records do not differ from any other kind of data transferred over a network.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络读取JSON数据将在下一章讨论，因为JSON记录在网络上传输时与任何其他类型的数据没有区别。
- en: Using Marshal() and Unmarshal()
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Marshal()和Unmarshal()
- en: In this subsection, you will see how to use `Marshal()` and `Unmarshal()` in
    order to implement the functionality of `readJSON.go` and `writeJSON.go`. The
    Go code that illustrates the `Marshal()` and `Unmarshal()` functions can be found
    in `marUnmar.go`, and this will be presented in four parts.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，您将看到如何使用`Marshal()`和`Unmarshal()`来实现`readJSON.go`和`writeJSON.go`的功能。展示`Marshal()`和`Unmarshal()`函数的Go代码可以在`marUnmar.go`中找到，并将分为四部分呈现。
- en: 'The first part of `marUnmar.go` is the expected preamble:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`marUnmar.go`的第一部分是预期的序言：'
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The second part of the program contains the following Go code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二部分包含以下Go代码：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the same record that is used in the `writeJSON.go` program. Therefore,
    so far there is nothing special.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在`writeJSON.go`程序中使用的相同记录。因此，到目前为止没有什么特别的。
- en: 'The third part of `marUnmar.go` is where the marshalling happens:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`marUnmar.go`的第三部分是编组发生的地方：'
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that `json.Marshal()` requires a pointer for passing data to it even if
    the value is a map, array, or slice.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`json.Marshal()`需要一个指针来传递数据，即使值是一个map、数组或切片。
- en: 'The last part of the program contains the following Go code that performs the
    unmarshalling operation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分包含以下执行解组操作的Go代码：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see from the code, `json.Unmarshal()` requires the use of a pointer
    for saving the data even if the value is a map, array, or slice.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，`json.Unmarshal()`需要使用指针来保存数据，即使值是一个map、数组或切片。
- en: 'Executing `marUnmar.go` will create the following output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`marUnmar.go`将创建以下输出：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As you can see, the `Marshal()` and `Unmarshal()` functions cannot help you
    store your data into a file: you will need to implement that on your own.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Marshal()`和`Unmarshal()`函数无法帮助您将数据存储到文件中：您需要自己实现。
- en: Using MongoDB
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB
- en: A relational database is a structured collection of data that is strictly organized
    into tables. The dominant language for querying databases is SQL. NoSQL databases,
    such as **MongoDB**, do not use SQL, but various other query languages and do
    not have a strict structure in their tables, which are called **collections**
    in the NoSQL terminology.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库是严格组织成表的结构化数据的集合。查询数据库的主要语言是SQL。NoSQL数据库，如**MongoDB**，不使用SQL，而是使用各种其他查询语言，并且在其表中没有严格的结构，这在NoSQL术语中称为**集合**。
- en: You can categorize NoSQL databases according to their data model as Document,
    Key-Value, Graph, and Column-family. MongoDB is the most popular document-oriented
    NoSQL database that is appropriate for use in web applications.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据其数据模型将NoSQL数据库分类为文档、键值、图形和列族。MongoDB是最流行的面向文档的NoSQL数据库，适用于Web应用程序。
- en: Document databases were not made for dealing with Microsoft Word documents,
    but for storing semistructured data.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 文档数据库并不是用来处理Microsoft Word文档的，而是用来存储半结构化数据的。
- en: Basic MongoDB administration
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的MongoDB管理
- en: If you want to use MongoDB on your Go applications, it would be very practical
    to know how to perform some basic administrative tasks on a MongoDB database.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在Go应用程序中使用MongoDB，了解如何在MongoDB数据库上执行一些基本的管理任务将非常实用。
- en: 'Most of the tasks presented in this section will be performed from the Mongo
    shell, which starts by executing the `mongo` command. If no MongoDB instance is
    running on your Unix machine, you will get the following output:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中介绍的大多数任务将从Mongo shell执行，该shell通过执行`mongo`命令启动。如果您的Unix机器上没有运行MongoDB实例，将得到以下输出：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The previous output tells us two things:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出告诉我们两件事：
- en: The default TCP port number for the MongoDB server process is `27017`
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB服务器进程的默认TCP端口号为`27017`
- en: The mongo executable tries to connect to the `127.0.0.1` IP address, which is
    the IP address of the local machine
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mongo可执行文件尝试连接到`127.0.0.1` IP地址，这是本地机器的IP地址
- en: 'In order to execute the following commands, you should start a MongoDB server
    instance on your local machine. Once the MongoDB server process is up and running,
    executing `mongo` will create the following output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行以下命令，您应该在本地机器上启动一个MongoDB服务器实例。一旦MongoDB服务器进程启动并运行，执行`mongo`将创建以下输出：
- en: '[PRE56]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following commands will show you how to create a new MongoDB database and
    a new MongoDB collection, and how to insert some documents in to that collection:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将向您展示如何创建一个新的MongoDB数据库和一个新的MongoDB集合，以及如何向该集合插入一些文档：
- en: '[PRE57]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Once you try to insert a document into a collection using `db.someData.insert()`,
    the collection (`someData`) will be automatically created if it does not already
    exist. The last command counts the number of records stored into the `someData`
    collection of the current database.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您尝试使用`db.someData.insert()`将文档插入到集合中，如果该集合（`someData`）不存在，它将被自动创建。最后一个命令计算了当前数据库的`someData`集合中存储的记录数。
- en: MongoDB will not inform you about any typographical errors you might have. Putting
    it simply, if you mistype the name of a database or a collection, MongoDB will
    create a totally new database or a new collection while you are trying to find
    out what went wrong! Additionally, if you put more, less, or different fields
    on a document and try to save it, MongoDB will not complain!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB不会通知您可能存在的任何拼写错误。简单地说，如果您错误地输入了数据库或集合的名称，MongoDB将在您试图找出问题所在时创建一个全新的数据库或新集合！此外，如果您在文档中放入更多、更少或不同的字段并尝试保存它，MongoDB也不会抱怨！
- en: 'You can find the records of a collection using the `find()` function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`find()`函数找到集合的记录：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can find the list of databases on a running MongoDB instance as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按如下方式找到运行中的MongoDB实例上的数据库列表：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Similarly, you can find the names of the collections stored in the current
    MongoDB database as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以按如下方式找到当前MongoDB数据库中存储的集合的名称：
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can delete all the records of a MongoDB collection as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按如下方式删除MongoDB集合的所有记录：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Last, you can delete an entire collection, including its records, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以按如下方式删除整个集合，包括其中的记录：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The preceding information will get you going for now, but if you want to learn
    more about MongoDB, you should visit the documentation site of MongoDB at [https://docs.mongodb.com/](https://docs.mongodb.com/).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述信息暂时可以帮助您入门，但如果您想了解更多关于MongoDB的信息，您应该访问MongoDB的文档网站[https://docs.mongodb.com/](https://docs.mongodb.com/)。
- en: Using the MongoDB Go driver
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB Go驱动程序
- en: In order to use MongoDB in your Go programs, you should first have the MongoDB
    Go driver installed on your Unix machine. The name of the MongoDB Go driver is
    `mgo` and you can learn more information about the MongoDB Go driver by visiting
    [https://github.com/go-mgo/mgo](https://github.com/go-mgo/mgo), [https://labix.org/mgo](https://labix.org/mgo),
    and [https://docs.mongodb.com/ecosystem/drivers/go/](https://docs.mongodb.com/ecosystem/drivers/go/).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的Go程序中使用MongoDB，您应该首先在您的Unix机器上安装MongoDB Go驱动程序。MongoDB Go驱动程序的名称是`mgo`，您可以通过访问[https://github.com/go-mgo/mgo](https://github.com/go-mgo/mgo)、[https://labix.org/mgo](https://labix.org/mgo)和[https://docs.mongodb.com/ecosystem/drivers/go/](https://docs.mongodb.com/ecosystem/drivers/go/)了解更多关于MongoDB
    Go驱动程序的信息。
- en: 'As the driver is not part of the standard Go library, you should first download
    the required packages using the following two commands:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于驱动程序不是Go标准库的一部分，您应该首先使用以下两个命令下载所需的软件包：
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After that, you will be free to use it in your own Go utilities. If you try
    to execute the program without having the two packages on your Unix system, you
    will get an error message similar to the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将可以在自己的Go实用程序中使用它。如果您尝试在Unix系统上执行该程序而没有这两个软件包，您将收到类似以下的错误消息：
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that you might need to install Bazaar on your Unix system in order to execute
    the two `go get` commands. You can get more information about the Bazaar version
    control system at [https://bazaar.canonical.com/](https://bazaar.canonical.com/).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可能需要在您的Unix系统上安装Bazaar才能执行这两个`go get`命令。您可以在[https://bazaar.canonical.com/](https://bazaar.canonical.com/)获取有关Bazaar版本控制系统的更多信息。
- en: 'So, you should first try to run a simple Go program that connects to a MongoDB
    database, creates a new database and a new collection, and adds new documents
    to it in order to make sure that everything works as expected: the name of the
    program will be `testMongo.go` and will be presented in four parts.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您应该首先尝试运行一个简单的Go程序，该程序连接到MongoDB数据库，创建一个新的数据库和一个新的集合，并向其中添加新的文档，以确保一切都按预期工作：程序的名称将是`testMongo.go`，并将分为四个部分呈现。
- en: 'The first part of the program is the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分如下：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, you see the use of the Go MongoDB driver in the import block. Additionally,
    you see the definition of a new Go structure named `Record` that will hold the
    data of each MongoDB document.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到在导入块中使用了Go MongoDB驱动程序。此外，您还可以看到定义了一个名为`Record`的新Go结构，它将保存每个MongoDB文档的数据。
- en: 'The second part of `testMongo.go` has the following Go code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`testMongo.go`的第二部分包含以下Go代码：'
- en: '[PRE66]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now the `collection` variable will be used for dealing with the `someData`
    collection of the `goDriver` database: a better name for the database would have
    been `myDB`. Note that there was not a `goDriver` database in the MongoDB instance
    before running the Go program; this also means that neither the `someData` collection
    was there.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`collection`变量将用于处理`goDriver`数据库的`someData`集合：数据库的更好名称应该是`myDB`。请注意，在运行Go程序之前，MongoDB实例中没有`goDriver`数据库；这也意味着`someData`集合也不存在。
- en: 'The third part of the program is the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分如下：
- en: '[PRE67]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, you insert two documents to the MongoDB database using the `Insert()`
    function.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用`Insert()`函数将两个文档插入到MongoDB数据库中。
- en: 'The last portion of `testMongo.go` contains the following Go code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`testMongo.go`的最后一部分包含以下Go代码：'
- en: '[PRE68]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you do not know the number of documents that you will get from the `Find()`
    query, you should use a slice of records for storing them.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您不知道从`Find()`查询中会得到多少文档，因此您应该使用记录的切片来存储它们。
- en: Additionally, note that you should put the `yvalue` field in lowercase in the
    `Find()` function because MongoDB will automatically convert the fields of the
    `Record` structure in lowercase when you are storing them!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，当您存储时，您应该在`Find()`函数中将`yvalue`字段小写，因为MongoDB在存储时会自动将`Record`结构的字段转换为小写！
- en: 'Now, execute `testMongo.go`, as shown here:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照这里所示执行`testMongo.go`：
- en: '[PRE69]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note that if you execute `testMongo.go` multiple times, you will find the same
    documents inserted multiple times into the `someData` collection. However, MongoDB
    will not have any problems differentiating between all these documents because
    the key of each document is the `_id` field, which is automatically inserted by
    MongoDB each time you insert a new document to a collection.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果多次执行`testMongo.go`，您会发现相同的文档多次插入到`someData`集合中。但是，MongoDB不会有任何问题区分所有这些文档，因为每个文档的键是`_id`字段，这是由MongoDB自动插入的，每次您向集合插入新文档时都会插入。
- en: 'After that, connect to your MongoDB instance using the `MongoDB` shell command
    to make sure that everything worked as expected:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用`MongoDB` shell命令连接到MongoDB实例，以确保一切按预期工作：
- en: '[PRE70]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, it is important to understand that MongoDB documents are presented in
    JSON format, which you already know how to handle in Go.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，重要的是要理解MongoDB文档以JSON格式呈现，这是您已经知道如何在Go中处理的。
- en: Also, note that the Go MongoDB driver has many more capabilities than the ones
    presented here. Unfortunately, talking more about it is beyond the scope of this
    book, but you can learn more by visiting [https://github.com/go-mgo/mgo](https://github.com/go-mgo/mgo),
    [https://labix.org/mgo](https://labix.org/mgo), and [https://docs.mongodb.com/ecosystem/drivers/go/](https://docs.mongodb.com/ecosystem/drivers/go/).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，Go MongoDB驱动程序具有比此处介绍的更多功能。不幸的是，更多讨论超出了本书的范围，但您可以通过访问[https://github.com/go-mgo/mgo](https://github.com/go-mgo/mgo)，[https://labix.org/mgo](https://labix.org/mgo)和[https://docs.mongodb.com/ecosystem/drivers/go/](https://docs.mongodb.com/ecosystem/drivers/go/)来了解更多信息。
- en: Creating a Go application that displays MongoDB data
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个显示MongoDB数据的Go应用程序
- en: The name of the utility will be `showMongo.go` and it will be presented in three
    parts. The utility will connect to a MongoDB instance, read a collection, and
    display the documents of the collection as a web page. Note that `showMongo.go`
    is based on the Go code of `template.go`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的名称将是`showMongo.go`，它将分为三部分呈现。该实用程序将连接到MongoDB实例，读取一个集合，并将集合的文档显示为网页。请注意，`showMongo.go`基于`template.go`的Go代码。
- en: 'The first part of the web application is the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的第一部分如下：
- en: '[PRE71]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You should know in advance the structure of the MongoDB documents that you will
    retrieve because the field names are hard coded in the `struct` type and need
    to match.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该提前了解要检索的MongoDB文档的结构，因为字段名称在`struct`类型中是硬编码的，并且需要匹配。
- en: 'The second part of the program is the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二部分如下：
- en: '[PRE72]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As before, you connect to MongoDB using `mgo.DialWithInfo()` with the parameters
    that were defined in the `mgo.DialInfo` structure.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，使用在`mgo.DialInfo`结构中定义的参数，使用`mgo.DialWithInfo()`连接到MongoDB。
- en: 'The last part of the web application is the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的最后部分如下：
- en: '[PRE73]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The contents of `MongoDB.gohtml` are similar to the contents of `template.gohtml`
    and will not be presented here. You can refer to *The html/template package* section
    for the contents of `template.gohtml`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`MongoDB.gohtml`的内容与`template.gohtml`的内容类似，这里不会呈现。您可以参考*html/template包*部分了解`template.gohtml`的内容。'
- en: 'The execution of `showMongo.go` will not display the actual data on the screen:
    you will need to use a web browser for that:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`showMongo.go`不会在屏幕上显示实际数据：您需要使用Web浏览器进行查看：
- en: '[PRE74]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The good thing is that if the data of the collections is changed, you will
    not need to recompile your Go code in order to see the changes: you will just
    need to reload the web page.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 好处是，如果集合的数据发生了变化，您无需重新编译Go代码即可查看更改：您只需要重新加载网页。
- en: 'The following screenshot shows the output of `showMongo.go` as displayed on
    a web browser:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在Web浏览器上显示的`showMongo.go`的输出：
- en: '![](img/a11f9a8c-3fc3-414b-83a7-ecffd7aca8de.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a11f9a8c-3fc3-414b-83a7-ecffd7aca8de.png)'
- en: Using showMongo.go
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用showMongo.go
- en: 'Note that the `Numbers` collection contains the following documents:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Numbers`集合包含以下文档：
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Have in mind that extra data in the MongoDB structure that does not have corresponding
    fields in the Go structure is ignored.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，MongoDB结构中的额外数据，如果在Go结构中没有相应的字段，则会被忽略。
- en: Creating an application that displays MySQL data
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个显示MySQL数据的应用程序
- en: In this subsection, we will present a Go utility that executes a query on a
    MySQL table. The name of the new command-line utility will be `showMySQL.go` and
    will be presented in five parts.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将介绍一个在MySQL表上执行查询的Go实用程序。新的命令行实用程序的名称将是`showMySQL.go`，将分为五部分呈现。
- en: Note that `showMySQL.go` will use the `database/sql` package that provides a
    generic SQL interface to relational databases for querying the MySQL database.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`showMySQL.go`将使用`database/sql`包，该包为查询MySQL数据库提供了通用的SQL接口。
- en: 'The presented utility requires two parameters: a username with administrative
    privileges and its password.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 所提供的实用程序需要两个参数：具有管理权限的用户名及其密码。
- en: 'The first part of `showMySQL.go` is the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`showMySQL.go`的第一部分如下：'
- en: '[PRE76]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: There is a small change here, as `showMySQL.go` uses `text/template` instead
    of `html/template`. Note that the drivers that conform to the `database/sql` interface
    are never really referenced directly in your code, but they still need to be initialized
    and imported. The `_` character in front of `"github.com/go-sql-driver/mysql"`
    does this by telling Go to ignore the fact that the `"github.com/go-sql-driver/mysql"`
    package is not actually used in the code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小变化，因为`showMySQL.go`使用`text/template`而不是`html/template`。请注意，符合`database/sql`接口的驱动程序在代码中实际上从未直接引用，但它们仍然需要被初始化和导入。通过在`"github.com/go-sql-driver/mysql"`前面加上`_`字符，Go会忽略`"github.com/go-sql-driver/mysql"`包实际上未在代码中使用的事实。
- en: 'You will also need to download the MySQL Go driver:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要下载MySQL Go驱动程序：
- en: '[PRE77]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The second part of the utility has the following Go code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的第二部分包含以下Go代码：
- en: '[PRE78]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The third chunk of Go code from `showMySQL.go` is the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`showMySQL.go`的第三个Go代码块如下：
- en: '[PRE79]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, you manually construct the connection string to MySQL. For reasons of
    security, a default MySQL installation works with a socket (`/tmp/mysql.sock`)
    instead of a network connection. The name of the database that will be used is
    the last part of the connection string (`information_schema`).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您手动构建了到MySQL的连接字符串。出于安全原因，默认的MySQL安装使用套接字(`/tmp/mysql.sock`)而不是网络连接。将使用的数据库名称是连接字符串的最后一部分(`information_schema`)。
- en: You will most likely have to adjust these parameters for your own database.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您很可能需要调整这些参数以适应自己的数据库。
- en: 'The fourth part of `showMySQL.go` is the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`showMySQL.go`的第四部分如下：'
- en: '[PRE80]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `Next()` function iterates over all the records returned from the `select`
    query and returns them one by one with the help of the `for` loop.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`Next()`函数遍历从`select`查询返回的所有记录，并借助`for`循环逐个返回它们。'
- en: 'The last part of the program is the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一部分如下：
- en: '[PRE81]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This time, instead of presenting the data as a web page, you will receive it
    as plain text. Additionally, as the text template is small, it is defined in line
    with the help of the `t` variable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，您将以纯文本形式接收数据，而不是以网页形式呈现数据。此外，由于文本模板很小，因此可以使用`t`变量的帮助在一行中定义它。
- en: Is the use of the template necessary here? Of course not! But it is good to
    learn how to define Go templates without using an external template file.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是否需要使用模板？当然不需要！但是学习如何定义Go模板而不使用外部模板文件是很好的。
- en: 'Therefore, the output of `showMySQL.go` will be similar to the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`showMySQL.go`的输出将类似于以下内容：
- en: '[PRE82]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The preceding output shows information about the available databases for the
    current MySQL instance, which is a great way to get information about a MySQL
    database without having to connect using the MySQL client.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示了当前MySQL实例的可用数据库信息，这是一种在不使用MySQL客户端连接的情况下获取MySQL数据库信息的好方法。
- en: A handy command-line utility
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个方便的命令行实用程序
- en: In this section, we will develop a handy command-line utility that reads a number
    of web pages, which can be found in a text file or read from standard input, and
    returns the number of times a given keyword was found in these web pages. In order
    to be faster, the utility will use goroutines to get the desired data and a monitoring
    process to gather the data and present it on the screen. The name of the utility
    will be `findKeyword.go` and will be presented in five parts.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个方便的命令行实用程序，该实用程序读取一些网页，这些网页可以在文本文件中找到或从标准输入中读取，并返回在这些网页中找到给定关键字的次数。为了更快，该实用程序将使用goroutines来获取所需的数据，并使用监控进程来收集数据并在屏幕上呈现。该实用程序的名称将是`findKeyword.go`，并将分为五个部分进行介绍。
- en: 'The first part of the utility is the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的第一部分如下：
- en: '[PRE83]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `Data struct` type will be used for passing information between channels.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data struct`类型将用于在通道之间传递信息。'
- en: 'The second part of `findKeyword.go` has the following Go code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`findKeyword.go`的第二部分包含以下Go代码：'
- en: '[PRE84]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `monitor()` function is where all the information is collected and printed
    on the screen.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`monitor()`函数是收集和在屏幕上打印所有信息的地方。'
- en: 'The third part is the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分如下：
- en: '[PRE85]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, you can see the implementation of the `processPage()` function that is
    executed in a goroutine. If the `Error` field of the `Data` structure is not `nil`,
    then there was an error somewhere.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到`processPage()`函数的实现，该函数在goroutine中执行。如果`Data`结构的`Error`字段不是`nil`，则表示出现了错误。
- en: The reason for using the `bodyHTML` variable to save the entire contents of
    a URL is for not having a keyword split between two consecutive calls to `reader.Read()`.
    After that, a regular expression (`r`) is used for searching the `bodyHTML` variable
    for the desired keyword.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bodyHTML`变量保存URL的整个内容是为了避免关键字在两次连续调用`reader.Read()`之间被分割。之后，使用正则表达式(`r`)在`bodyHTML`变量中搜索所需的关键字。
- en: 'The fourth part contains the following Go code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分包含以下Go代码：
- en: '[PRE86]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'As you can see, `findKeyword.go` expects its input from a text file or from
    standard input, which is the common Unix practice: this technique was first illustrated
    back in [Chapter 8](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)*,* *Processes
    and Signals*, in the *Reading from standard input* section.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`findKeyword.go` 期望从文本文件或标准输入中获取输入，这是常见的Unix做法：这种技术最早在[第8章](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)中的*进程和信号*部分进行了说明。
- en: 'The last chunk of Go code for `findKeyword.go` is the following:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`findKeyword.go`的最后一部分Go代码如下：'
- en: '[PRE87]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'There is nothing special here: you just start the desired goroutines and the
    `monitor()` function to take care of them.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的：您只需启动所需的goroutines和`monitor()`函数来管理它们。
- en: 'Executing `findKeyword.go` will create the following output:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`findKeyword.go`将创建以下输出：
- en: '[PRE88]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The funny thing here is that the `doesnotexist.com` domain does actually exist!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`doesnotexist.com`域实际上是存在的！
- en: Exercises
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Download and install MongoDB on your Unix machine.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Unix机器上下载并安装MongoDB。
- en: Visit the documentation page of the `net/http` Go standard package at [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/).
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`net/http` Go标准包的文档页面，网址为[https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/)。
- en: Visit the documentation page of the `html/template` Go standard package at [https://golang.org/pkg/html/template/](https://golang.org/pkg/html/template/).
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`html/template` Go标准包的文档页面，网址为[https://golang.org/pkg/html/template/](https://golang.org/pkg/html/template/)。
- en: Change the Go code of `getURL.go` in order to make it able to fetch multiple
    web pages.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`getURL.go`的Go代码，以使其能够获取多个网页。
- en: Read the documentation of the `encoding/json` package that can be found at [https://golang.org/pkg/encoding/json/](https://golang.org/pkg/encoding/json/).
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读`encoding/json`包的文档，网址为[https://golang.org/pkg/encoding/json/](https://golang.org/pkg/encoding/json/)。
- en: Visit the MongoDB site at [https://www.mongodb.org/](https://www.mongodb.org/).
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问MongoDB网站，网址为[https://www.mongodb.org/](https://www.mongodb.org/)。
- en: Learn how to use `text/template` by developing your own example.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过开发自己的示例来学习如何使用`text/template`。
- en: Change the Go code of `findKeyword.go` in order to be able to search multiple
    keywords.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`findKeyword.go`的Go代码，以便能够搜索多个关键字。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we talked about web development in Go including parsing, marshalling
    and unmarshalling JSON data, interacting with a MongoDB database; reading data
    from a MySQL database; creating web servers in Go; creating web clients in Go;
    and using the `http.ServeMux` type.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Go中的Web开发，包括解析、编组和解组JSON数据，与MongoDB数据库交互；从MySQL数据库读取数据；在Go中创建Web服务器；在Go中创建Web客户端；以及使用`http.ServeMux`类型。
- en: In the next chapter, we will talk about network programming in Go, which includes
    creating TCP and UDP clients and servers using low level commands. We will also
    teach you how to develop an RCP client and an RCP server in Go. If you love developing
    TCP/IP applications, then the last chapter of this book is for you!
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Go中的网络编程，其中包括使用低级命令创建TCP和UDP客户端和服务器。我们还将教你如何在Go中开发RCP客户端和RCP服务器。如果你喜欢开发TCP/IP应用程序，那么本书的最后一章就是为你准备的！
