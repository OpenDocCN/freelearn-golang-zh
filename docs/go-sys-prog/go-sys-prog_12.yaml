- en: Network Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络编程
- en: In the previous chapter, we talked about developing web applications, talking
    to databases, and dealing with JSON data in Go.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了在Go中开发Web应用程序、与数据库通信以及处理JSON数据。
- en: 'The topic of this chapter is the development of Go applications that work over
    TCP/IP networks. In addition, you will learn how to create TCP and UDP clients
    and servers. The central Go package of this chapter will be the `net` package:
    most of its functions are quite low level and require a good knowledge of TCP/IP
    and its family of protocols.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题是开发在TCP/IP网络上运行的Go应用程序。此外，您还将学习如何创建TCP和UDP客户端和服务器。本章的核心Go包将是`net`包：它的大多数函数都是相当低级的，需要对TCP/IP及其协议家族有很好的了解。
- en: However, have in mind that network programming is a huge theme that cannot be
    covered in a single chapter. This chapter will give you the foundational directions
    for how to create TCP/IP applications in Go.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，网络编程是一个庞大的主题，无法在单独的一章中涵盖。本章将为您提供如何在Go中创建TCP/IP应用程序的基本方向。
- en: 'More analytically, this chapter will talk about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，本章将讨论以下主题：
- en: How TCP/IP operates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP/IP的操作方式
- en: The `net` Go standard package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go标准包`net`
- en: Developing TCP clients and servers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发TCP客户端和服务器
- en: Programing UDP clients and servers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程UDP客户端和服务器
- en: Developing an RPC client
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发RPC客户端
- en: Implementing an RPC server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现RPC服务器
- en: The Wireshark and `tshark(1)` network traffic analyzers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wireshark和`tshark(1)`网络流量分析器
- en: Unix sockets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix套接字
- en: Performing DNS lookups from Go programs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Go程序执行DNS查找
- en: About network programming
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于网络编程
- en: '**Network programming** is the development of applications that can operate
    over computer networks using TCP/IP, which is the dominant networking protocol.
    Therefore, without knowing the way TCP/IP and its protocols work, you cannot create
    network applications and develop TCP/IP servers.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络编程**是开发可以使用TCP/IP在计算机网络上运行的应用程序。因此，如果不了解TCP/IP及其协议的工作方式，就无法创建网络应用程序和开发TCP/IP服务器。'
- en: The best two advices that I can give to developers of network applications,
    are to know the theory behind the task they want to perform and to know that networks
    fail all the time for several reasons. The nastiest types of network failures
    have to do with malfunctioning or misconfigured DNS servers, because such problems
    are challenging to find and difficult to correct.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以给网络应用程序开发人员的最好的两个建议是了解他们想要执行的任务背后的理论，并且知道网络由于多种原因而经常失败。网络故障中最恶劣的类型与故障或配置错误的DNS服务器有关，因为这类问题很难找到并且难以纠正。
- en: About TCP/IP
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于TCP/IP
- en: '**TCP/IP** is a family of protocols that help the internet to operate. Its
    name comes from its two most well-known protocols: **TCP** and **IP**.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP/IP**是一组协议，帮助互联网运行。它的名称来自其两个最著名的协议：**TCP**和**IP**。'
- en: Every device that uses TCP/IP must have an IP address, which should be unique
    at least to its local network. It also needs a **network mask** (used for dividing
    big IP networks into smaller networks) that is related to its current network,
    one or more **DNS servers** (used for translating an IP address to a human-memorable
    format and vice versa) and, if you want to communicate with devices beyond your
    local network, the IP address of a device that will act as the **default gateway**
    (a network device that TCP/IP sends a network packet to when it cannot find where
    else to send it).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个使用TCP/IP的设备必须具有IP地址，至少在其本地网络中是唯一的。它还需要一个与当前网络相关的**网络掩码**（用于将大型IP网络划分为较小的网络），一个或多个**DNS服务器**（用于将IP地址转换为人类可记忆的格式，反之亦然），以及如果要与本地网络之外的设备通信，则需要一个将充当**默认网关**（当TCP/IP找不到其他发送位置时，将网络数据包发送到的网络设备）的设备的IP地址。
- en: Each TCP/IP service, which in reality is a Unix process, listens to a port number
    that is unique to each machine. Note that port numbers 0-1023 are restricted and
    can only be used by the root user, so it is better to avoid using them and choose
    something else, provided that it is not already in use by a different process.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个TCP/IP服务实际上是一个Unix进程，监听一个对每台机器都是唯一的端口号。请注意，端口号0-1023受限制，只能由root用户使用，因此最好避免使用它们，并选择其他内容，前提是它尚未被不同进程使用。
- en: About TCP
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于TCP
- en: '**TCP** stands for **Transmission** **Control** **Protocol**. TCP software
    transmits data between machines using segments, which are called TCP **packets**.
    The main characteristic of TCP is that it is a reliable protocol, which means
    that it attempts to make sure that a packet was delivered. If there is no proof
    of a packet delivery, TCP resends that particular packet. Among other things,
    a TCP packet can be used for establishing connections, transferring data, sending
    acknowledgments, and closing connections.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP**代表**传输** **控制** **协议**。TCP软件使用称为TCP **数据包**的段在机器之间传输数据。TCP的主要特点是它是一种可靠的协议，这意味着它试图确保数据包已传送。如果没有数据包传送的证据，TCP会重新发送该特定数据包。除其他事项外，TCP数据包可用于建立连接、传输数据、发送确认和关闭连接。'
- en: When a TCP connection is established between two machines, a full duplex virtual
    circuit, similar to the telephone call, is created between these two machines.
    The two machines constantly communicate to make sure that data are sent and received
    correctly. If the connection fails for some reason, the two machines try to find
    the problem and report to the relevant application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当两台机器之间建立TCP连接时，类似于电话呼叫的全双工虚拟电路将在这两台机器之间创建。这两台机器不断通信以确保数据正确发送和接收。如果由于某种原因连接失败，这两台机器会尝试找到问题并向相关应用程序报告。
- en: TCP assigns a sequence number to each transmitted packet and expects a positive
    acknowledgment (ACK) from the receiving TCP stack. If the ACK is not received
    within a timeout interval, the data is retransmitted as the original packet is
    considered undelivered. The receiving TCP stack uses the sequence numbers to rearrange
    the segments when they arrive out of order, which also eliminates duplicate segments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TCP为每个传输的数据包分配一个序列号，并期望接收TCP堆栈的正面确认（ACK）。如果在超时间隔内未收到ACK，则数据将被重新传输，因为原始数据包被视为未传递。当数据包以无序方式到达时，接收TCP堆栈使用序列号重新排列段，这也消除了重复的段。
- en: The TCP header of each packet includes **source port and destination port**
    fields. These two fields plus the source and destination IP addresses are combined
    to uniquely identify each TCP connection. The TCP header also includes a 6-bit
    flags field that is used to relay control information between TCP peers. The possible
    flags include SYN, FIN, RESET, PUSH, URG, and ACK. The SYN and ACK flags are used
    for the initial TCP 3-way handshake. The RESET flag signifies that the receiver
    wants to abort the connection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据包的TCP头包括**源端口和目标端口**字段。这两个字段加上源和目标IP地址被组合在一起，以唯一标识每个TCP连接。TCP头还包括一个6位标志字段，用于在TCP对等方之间传递控制信息。可能的标志包括SYN，FIN，RESET，PUSH，URG和ACK。SYN和ACK标志用于初始TCP
    3次握手。RESET标志表示接收方希望中止连接。
- en: The TCP handshake!
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP握手！
- en: When a connection is initiated, the client sends a TCP SYN packet to the server.
    The TCP header also includes a sequence number field that has an arbitrary value
    in the SYN packet. The server sends back a TCP [SYN, ACK] packet, which includes
    the sequence number of the opposite direction and an acknowledgment of the previous
    sequence number. Finally, in order to truly establish the TCP connection, the
    client sends a TCP ACK packet in order to acknowledge the sequence number of the
    server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当建立连接时，客户端向服务器发送TCP SYN数据包。TCP头还包括一个序列号字段，在SYN数据包中具有任意值。服务器发送回一个TCP [SYN，ACK]数据包，其中包括相反方向的序列号和对先前序列号的确认。最后，为了真正建立TCP连接，客户端发送TCP
    ACK数据包以确认服务器的序列号。
- en: Although all these actions take place automatically, it is good to know what
    is happening behind the scenes!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有这些操作都是自动进行的，但了解幕后发生的事情是很好的！
- en: About UDP and IP
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于UDP和IP
- en: '**IP** stands for **Internet Protocol**. The main characteristic of IP is that
    it is not a reliable protocol by nature. IP encapsulates the data that travels
    in a TCP/IP network because it is responsible for delivering packets from the
    source host to the destination host according to the IP addresses. IP has to find
    an addressing method to effectively send the packet to its destination. Although
    there exist dedicated devices called routers that perform IP routing, every TCP/IP
    device has to perform some basic routing.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP**代表**Internet Protocol**。IP的主要特点是它本质上不是一种可靠的协议。IP封装了在TCP/IP网络中传输的数据，因为它负责根据IP地址将数据包从源主机传递到目标主机。IP必须找到一种寻址方法，以有效地将数据包发送到其目的地。尽管存在称为路由器的专用设备来执行IP路由，但每个TCP/IP设备都必须执行一些基本路由。'
- en: '**UDP** (short for **User Datagram Protocol**) is based on IP, which means
    that it is also unreliable. Generally speaking, UDP is simpler than TCP mainly
    because UDP is not reliable by design. As a result, UDP messages can be lost,
    duplicated, or arrive out of order. Furthermore, packets can arrive faster than
    the recipient can process them. So, UDP is used when speed is more important than
    reliability! An example for this is live video and audio applications where catching
    up is way more important than buffering and not losing any data.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP**（**用户数据报协议**的缩写）基于IP，这意味着它也是不可靠的。一般来说，UDP比TCP简单，主要是因为UDP本身设计上就不可靠。因此，UDP消息可能会丢失、重复或无序到达。此外，数据包可能比接收方处理它们的速度更快。因此，当速度比可靠性更重要时，使用UDP！一个例子是实时视频和音频应用程序，其中追赶速度比缓冲和不丢失任何数据更重要！'
- en: So, when you do not need too many network packets to transfer the desired information,
    using a protocol that is based on IP might be more efficient than using TCP, even
    if you have to retransmit a network packet, because there is no traffic overhead
    from the TCP handshake.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您不需要太多的网络数据包来传输所需的信息时，使用基于IP的协议可能比使用TCP更有效，即使您必须重新传输网络数据包，因为没有来自TCP握手的流量开销。
- en: About Wireshark and tshark
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Wireshark和tshark
- en: '**Wireshark** is a graphical application for analyzing network traffic of almost
    any kind. Nevertheless, there are times that you need something lighter that you
    can execute remotely without a graphical user interface. In such situations, you
    can use `tshark`, which is the command-line version of Wireshark.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wireshark**是一款用于分析几乎任何类型的网络流量的图形应用程序。然而，有时您需要一些更轻便的东西，可以在没有图形用户界面的情况下远程执行。在这种情况下，您可以使用`tshark`，这是Wireshark的命令行版本。'
- en: In order to help you find the network data you really want, Wireshark and `tshark`
    have support for capture filters and display filters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您找到真正想要的网络数据，Wireshark和`tshark`支持捕获过滤器和显示过滤器。
- en: 'Capture filters are the filters that are applied during network data capturing;
    therefore, they make Wireshark discard network traffic that does not match the
    filter. Display filters are the filters that are applied after packet capturing;
    therefore, they just hide some network traffic without deleting it: you can always
    disable a display filter and get your hidden data back. Generally speaking, display
    filters are considered more useful and versatile than capture filters because,
    normally, you do not know in advance what you will capture or want to examine.
    Nevertheless, applying filters at capture time can save you time and disk space
    and that is the main reason for using them.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获过滤器是在网络数据捕获过程中应用的过滤器；因此，它们使Wireshark丢弃不符合过滤条件的网络流量。显示过滤器是在数据包捕获后应用的过滤器；因此，它们只是隐藏一些网络流量而不是删除它：您可以随时禁用显示过滤器并恢复隐藏的数据。一般来说，显示过滤器被认为比捕获过滤器更有用和更灵活，因为通常情况下，您事先不知道要捕获或要检查什么。然而，在捕获时应用过滤器可以节省时间和磁盘空间，这是使用它们的主要原因。
- en: 'The following screenshot shows the traffic of a TCP handshake in more detail
    as captured by Wireshark. The client IP address is `10.0.2.15` and the destination
    IP address is `80.244.178.150`. Additionally, a simple display filter (`tcp &&
    !http`) makes Wireshark display fewer packets and makes the output less cluttered
    and therefore easier to read:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了Wireshark捕获的TCP握手流量的更详细信息。客户端IP地址为`10.0.2.15`，目标IP地址为`80.244.178.150`。此外，简单的显示过滤器(`tcp
    && !http`)使Wireshark显示更少的数据包，并使输出更清晰，因此更容易阅读：
- en: '![](img/4cd7d321-edd4-4d49-8713-bc9cea9535f6.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cd7d321-edd4-4d49-8713-bc9cea9535f6.png)'
- en: The TCP handshake!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: TCP握手！
- en: 'The same information can be seen in text format using `tshark(1)`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`tshark(1)`以文本格式查看相同的信息：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `-r` parameter followed by an existing filename allows you to replay a previously
    captured data file on your screen, whereas a more complex display filter, which
    is defined after the `-Y` parameter, does the rest of the job!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`-r`参数后跟一个现有的文件名，允许您在屏幕上重放先前捕获的数据文件，而更复杂的显示过滤器在`-Y`参数之后定义，完成其余工作！'
- en: You can learn more about Wireshark at [https://www.wireshark.org/](https://www.wireshark.org/)
    and by looking at its documentation at [https://www.wireshark.org/docs/](https://www.wireshark.org/docs/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.wireshark.org/](https://www.wireshark.org/)了解更多关于Wireshark的信息，并通过查看其文档[https://www.wireshark.org/docs/](https://www.wireshark.org/docs/)。
- en: About the netcat utility
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于netcat实用程序
- en: 'There are times that you will need to test a TCP/IP client or a TCP/IP server:
    the `netcat(1)` utility can help you with that by playing the role of the client
    or server in a TCP or UDP application.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要测试TCP/IP客户端或TCP/IP服务器：`netcat(1)`实用程序可以通过在TCP或UDP应用程序中扮演客户端或服务器的角色来帮助您。
- en: 'You can use `netcat(1)` as a client for a TCP service that runs on a machine
    with the `192.168.1.123` IP address and listens to port number `1234`, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`netcat(1)`作为TCP服务的客户端，该服务在具有`192.168.1.123` IP地址的计算机上运行，并侦听端口号`1234`，如下所示：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similarly, you can use `netcat(1)` as a client for a UDP service that runs
    on a Unix machine named `amachine.com` and listens to port number `2345`, as shown
    here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用`netcat(1)`作为运行在名为`amachine.com`的Unix机器上并侦听端口号`2345`的UDP服务的客户端，如下所示：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `-l` option tells `netcat(1)` to listen for incoming connections, which
    makes `netcat(1)` to act as a TCP or UDP server. If you try to use `netcat(1)`
    as a server with a port that is already in use, you will get the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`-l`选项告诉`netcat(1)`监听传入连接，这使`netcat(1)`充当TCP或UDP服务器。如果尝试使用`netcat(1)`作为具有已在使用的端口的服务器，则将获得以下输出：'
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The net Go standard package
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: net Go标准包
- en: The most useful Go package for creating TCP/IP applications is the `net` Go
    standard package. The `net.Dial()` function is used for connecting to a network
    as a client, and the `net.Listen()` function is used for accepting connections
    as a server. The first parameter of both functions is the network type, but this
    is where the similarities end.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建TCP/IP应用程序的最有用的Go包是`net` Go标准包。`net.Dial()`函数用于作为客户端连接到网络，`net.Listen()`函数用于作为服务器接受连接。这两个函数的第一个参数都是网络类型，但相似之处就到此为止了。
- en: For the `net.Dial()` function, the network type can be one of tcp, tcp4 (IPv4-only),
    tcp6 (IPv6-only), udp, udp4 (IPv4-only), udp6 (IPv6-only), ip, ip4 (IPv4-only),
    ip6 (IPv6-only), Unix, Unixgram, or Unixpacket. For the `net.Listen()` function,
    the first parameter can be one of tcp, tcp4, tcp6, Unix, or Unixpacket.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`net.Dial()`函数，网络类型可以是tcp、tcp4（仅限IPv4）、tcp6（仅限IPv6）、udp、udp4（仅限IPv4）、udp6（仅限IPv6）、ip、ip4（仅限IPv4）、ip6（仅限IPv6）、Unix、Unixgram或Unixpacket。对于`net.Listen()`函数，第一个参数可以是tcp、tcp4、tcp6、Unix或Unixpacket。
- en: The return value of the `net.Dial()` function is of the `net.Conn` interface
    type, which implements the `io.Reader` and `io.Writer` interfaces! This means
    that you already know how to access the variables of the `net.Conn` interface!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Dial()`函数的返回值是`net.Conn`接口类型，该接口实现了`io.Reader`和`io.Writer`接口！这意味着您已经知道如何访问`net.Conn`接口的变量！'
- en: So, although the way you create a network connection is different from the way
    you create a text file, their access methods are the same because the `net.Conn`
    interface implements the `io.Reader` and `io.Writer interfaces`. Therefore, as
    network connections are treated as files, you might need to review [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*,*
    *File Input and Output*, at this moment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管创建网络连接的方式与创建文本文件的方式不同，但它们的访问方法是相同的，因为`net.Conn`接口实现了`io.Reader`和`io.Writer`接口。因此，由于网络连接被视为文件，您可能需要在此时查看[第6章](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*，*
    *文件输入和输出*。
- en: Unix sockets revisited
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix套接字重温
- en: Back in [Chapter 8](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)*,* *Processes
    and Signals*, we talked a little about Unix sockets and presented a small Go program
    that was acting as a Unix socket client. This section will also create a Unix
    socket server to make things even clearer. However, the Go code of the Unix socket
    client will be also explained here in more detail and will be enriched with error
    handling code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第8章](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)*，* *进程和信号*，我们简要讨论了Unix套接字，并介绍了一个作为Unix套接字客户端的小型Go程序。本节还将创建一个Unix套接字服务器，以便更清楚地说明问题。但是，Unix套接字客户端的Go代码也将在此处更详细地解释，并丰富了错误处理代码。
- en: A Unix socket server
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个Unix套接字服务器
- en: The Unix socket server will act as an Echo server, which means that it will
    send the received message back to the client. The name of the program will be
    `socketServer.go` and it will be presented to you in four parts.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Unix套接字服务器将充当Echo服务器，这意味着它将将接收到的消息发送回客户端。程序的名称将是`socketServer.go`，将分为四部分介绍给您。
- en: 'The first part of `socketServer.go` is the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`socketServer.go`的第一部分如下：'
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second part of the Unix socket server is the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Unix套接字服务器的第二部分如下：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is where the function that serves incoming connections is implemented.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现服务传入连接的函数所在之处。
- en: 'The third portion of the program has the following Go code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分包含以下Go代码：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you can see the use of the `net.Listen()` function with the `unix` argument
    for creating the desired socket file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到使用`net.Listen()`函数和`unix`参数创建所需的套接字文件。
- en: 'Finally, the last part contains the following Go code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一部分包含以下Go代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, each connection is first handled by the `Accept()` function
    and served by its own goroutine.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个连接首先由`Accept()`函数处理，并由其自己的goroutine提供服务。
- en: 'When `socketServer.go` serves a client, it generates the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当`socketServer.go`为客户端提供服务时，它会生成以下输出：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you cannot create the desired socket file, for instance, if it already exists,
    you will get an error message similar to the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法创建所需的套接字文件，例如，如果它已经存在，您将收到类似以下的错误消息：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A Unix socket client
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个Unix套接字客户端
- en: The name of the Unix socket client program is `socketClient.go` and will be
    presented in four parts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Unix套接字客户端程序的名称是`socketClient.go`，将分为四部分介绍。
- en: 'The first part of the utility contains the expected preamble:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的第一部分包含了预期的序言：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is nothing special here, just the required Go packages. The second portion
    contains the definition of a Go function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的，只是所需的Go包。第二部分包含了一个Go函数的定义：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `readSocket()` function reads the data from a socket file using `Read()`.
    Note that, although `socketClient.go` just reads from the socket file, the socket
    is bisectional, which means that you can also write to it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`readSocket()`函数使用`Read()`从套接字文件中读取数据。请注意，尽管`socketClient.go`只是从套接字文件中读取数据，但套接字是双向的，这意味着您也可以向其写入数据。'
- en: 'The third part has the following Go code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含以下Go代码：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `net.Dial()` function with the right first argument allows you to connect
    to the socket file before you try to read from it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的第一个参数的`net.Dial()`函数允许您在尝试从中读取之前连接到套接字文件。
- en: 'The last part of `socketClient.go` is the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`socketClient.go`的最后一部分如下：'
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In order to use `socketClient.go`, you must have another program dealing with
    the Unix socket file, which, in this case will be `socketServer.go`. So, if `socketServer.go`
    is already running, you will get the following output from `socketClient.go`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`socketClient.go`，您必须有另一个处理Unix套接字文件的程序，在本例中将是`socketServer.go`。因此，如果`socketServer.go`已经在运行，您将从`socketClient.go`获得以下输出：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you do not have enough Unix file permissions to read the desired socket
    file, then `socketClient.go` will fail with the following error message:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有足够的Unix文件权限来读取所需的套接字文件，那么`socketClient.go`将失败，并显示以下错误消息：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similarly, if the socket file you want to read does not exist, `socketClient.go`
    will fail with the following error message:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您要读取的套接字文件不存在，`socketClient.go`将失败，并显示以下错误消息：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Performing DNS lookups
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行DNS查找
- en: There exist many types of DNS lookups, but two of them are the most popular.
    In the first type, you want to go from an IP address to a domain name and in the
    second type you want to go from a domain name to an IP address.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多类型的DNS查找，但其中两种最受欢迎。在第一种类型中，您希望从IP地址转到域名，而在第二种类型中，您希望从域名转到IP地址。
- en: 'The following output shows an example of the first type of DNS lookup:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了第一种类型的DNS查找的示例：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following output shows three examples of the second type of DNS lookup:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了第二种类型的DNS查找的三个示例：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you just saw in the aforementioned examples, an IP address can serve many
    hosts and a host name can have many IP addresses.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上述示例中所看到的，一个IP地址可以为多个主机提供服务，一个主机名可以有多个IP地址。
- en: The Go standard library provides the `net.LookupHost()` and `net.LookupAddr()`
    functions that can answer DNS queries for you. However, none of them allow you
    to define the DNS server you want to query. While using standard Go libraries
    is ideal, there exist external Go libraries that allow you to choose the DNS server
    you desire, which is mainly required when troubleshooting DNS configurations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库提供了`net.LookupHost()`和`net.LookupAddr()`函数，可以为您回答DNS查询。但是，它们都不允许您定义要查询的DNS服务器。虽然使用标准的Go库是理想的，但存在外部的Go库，允许您选择所需的DNS服务器，这在排除DNS配置问题时是非常重要的。
- en: Using an IP address as input
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IP地址作为输入
- en: The name of the Go utility that will return the hostname of an IP address will
    be `lookIP.go` and will be presented in three parts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回IP地址的主机名的Go实用程序的名称将是`lookIP.go`，将分为三部分介绍。
- en: 'The first part is the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second part has the following Go code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `net.ParseIP()` function allows you to verify the validity of the given
    IP address and is pretty handy for catching illegal IP addresses such as `288.8.8.8`
    and `8.288.8.8`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.ParseIP()`函数允许您验证给定IP地址的有效性，并且对于捕获诸如`288.8.8.8`和`8.288.8.8`之类的非法IP地址非常方便。'
- en: 'The last part of the utility is the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的最后部分如下：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, the `net.LookupAddr()` function returns a string slice with
    the list of names that match the given IP address.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`net.LookupAddr()`函数返回一个字符串切片，其中包含与给定IP地址匹配的名称列表。
- en: 'Executing `lookIP.go` will generate the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`lookIP.go`将生成以下输出：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can validate the output of `dnsLookup.go` using `host(1)` or `dig(1)`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`host(1)`或`dig(1)`验证`dnsLookup.go`的输出：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using a host name as input
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主机名作为输入
- en: 'The name of this DNS utility will be `lookHost.go` and will be presented in
    three parts. The first part of the `lookHost.go` utility is the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此DNS实用程序的名称将是`lookHost.go`，并将分为三部分呈现。`lookHost.go`实用程序的第一部分如下：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second part of the program has the following Go code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二部分有以下Go代码：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Similarly, the `net.LookupHost()` function also returns a string slice with
    the desired information.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`net.LookupHost()`函数也返回一个包含所需信息的字符串切片。
- en: 'The third part of the program has the following code, which is for error checking
    and printing the output of `net.LookupHost()`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分包含以下代码，用于错误检查和打印`net.LookupHost()`的输出：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Executing `lookHost.go` will generate the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`lookHost.go`将生成以下输出：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first line of the output is the IPv6 address, whereas the second output
    line is the IPv4 address of `www.google.com`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行是IPv6地址，而第二行输出是`www.google.com`的IPv4地址。
- en: 'You can verify the operation of `lookHost.go` by comparing its output with
    the output of the `host(1)` utility:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将其输出与`host(1)`实用程序的输出进行比较来验证`lookHost.go`的操作：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Getting NS records for a domain
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取域的NS记录
- en: This subsection will present an additional kind of DNS lookup that returns the
    domain name servers for a given domain. This is very handy for troubleshooting
    DNS-related problems and finding out the status of a domain. The presented program
    will be named `lookNS.go` and will be presented in three parts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将介绍另一种返回给定域的域名服务器的DNS查找。这对于解决与DNS相关的问题并了解域的状态非常方便。所呈现的程序将被命名为`lookNS.go`，并将分为三部分呈现。
- en: 'The first part of the utility is the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的第一部分如下：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The second part has the following Go code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分有以下Go代码：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `net.LookupNS()` function does all the work for us by returning a slice
    of `NS` elements.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.LookupNS()`函数通过返回`NS`元素的切片为我们完成所有工作。'
- en: 'The last part of the code is mainly for printing the results:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分主要用于打印结果：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Executing `lookNS.go` will generate the following output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`lookNS.go`将生成以下输出：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The reason that the following query will fail is that `www.mtsoukalos.eu` is
    not a domain but a single host, which means that it has no `NS` records associated
    with it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询失败的原因是`www.mtsoukalos.eu`不是一个域，而是一个单个主机，这意味着它没有与之关联的`NS`记录：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can use the `host(1)` utility to verify the previous output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`host(1)`实用程序验证先前的输出：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Developing a simple TCP server
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个简单的TCP服务器
- en: 'This section will develop a TCP server that implements the **Echo** service.
    The Echo service is usually implemented using the UDP protocol due to its simplicity,
    but it can also be implemented with TCP. The Echo service usually uses port number
    `7`, but our implementation will use other port numbers:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将开发一个实现**Echo**服务的TCP服务器。Echo服务通常使用UDP协议实现，因为它简单，但也可以使用TCP实现。Echo服务通常使用端口号`7`，但我们的实现将使用其他端口号：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `TCPserver.go` file will hold the Go code of this section and will be presented
    in six parts. For reasons of simplicity, each connection is handled inside the
    `main()` function without calling a separate function. However, this is not the
    recommended practice.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPserver.go`文件将保存本节的Go代码，并将分为六部分呈现。出于简单起见，每个连接都在`main()`函数中处理，而不调用单独的函数。但是，这不是推荐的做法。'
- en: 'The first part contains the expected preamble:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分包含预期的序言：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The second part of the TCP server is the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: TCP服务器的第二部分如下：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The third part of `TCPserver.go` contains the following Go code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPserver.go`的第三部分包含以下Go代码：'
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What is important to remember here is that `net.Listen()` returns a `Listener`
    variable, which is a generic network listener for stream-oriented protocols. Additionally,
    the `Listen()` function can support more formats: check the documentation of the
    `net` package to find more information about that.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要记住的重要一点是，`net.Listen()`返回一个`Listener`变量，这是一个用于面向流的协议的通用网络监听器。此外，`Listen()`函数可以支持更多格式：查看`net`包的文档以获取更多信息。
- en: 'The fourth part of the TCP server has the following Go code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: TCP服务器的第四部分有以下Go代码：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Only after a successful call to `Accept()`, the TCP server can start interacting
    with TCP clients. Nonetheless, the current version of `TCPserver.go` has a very
    serious shortcoming: it can only serve a single TCP client, the first one that
    will connect to it.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在成功调用`Accept()`之后，TCP服务器才能开始与TCP客户端交互。尽管如此，当前版本的`TCPserver.go`有一个非常严重的缺点：它只能为单个TCP客户端提供服务，即连接到它的第一个客户端。
- en: 'The fifth portion of the `TCPserver.go` code is the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPserver.go`代码的第五部分如下：'
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, you read data from your client using `bufio.NewReader().ReadString()`.
    The aforementioned call allows you to read your input line by line. Additionally,
    the `for` loop allows you to keep reading data from the TCP client for as long
    as you wish.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用`bufio.NewReader().ReadString()`从客户端读取数据。上述调用允许您逐行读取输入。此外，`for`循环允许您从TCP客户端持续读取数据，直到您希望停止为止。
- en: 'The last part of the Echo TCP server is the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Echo TCP服务器的最后部分如下：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The current version of `TCPserver.go` stops when it receives the `STOP` string
    as input. Although TCP servers do not usually terminate in that style, this is
    a pretty handy way to terminate a TCP server process that will only serve a single
    client!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的`TCPserver.go`在接收到`STOP`字符串作为输入时停止。虽然TCP服务器通常不会以这种方式终止，但这是终止仅为单个客户端提供服务的TCP服务器进程的一种非常方便的方式！
- en: 'Next, we will test `TCPserver.go` with `netcat(1)`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`netcat(1)`测试`TCPserver.go`：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `netcat(1)` part is the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`netcat(1)`部分如下：'
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the first and third lines are our input, whereas the second and fourth
    lines are the responses from the Echo server.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一行和第三行是我们的输入，而第二行和第四行是Echo服务器的响应。
- en: 'If you try to use an improper port number, `TCPserver.go` will generate the
    following error message and exit:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试使用不正确的端口号，`TCPserver.go`将生成以下错误消息并退出：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Developing a simple TCP client
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个简单的TCP客户端
- en: 'In this section, we will develop a TCP client named `TCPclient.go`. The port
    number the client will try to connect to as well as the server address will be
    given as command-line arguments to the program. The Go code of the TCP client
    will be presented in five parts; the first part is the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个名为`TCPclient.go`的TCP客户端。客户端将尝试连接的端口号以及服务器地址将作为程序的命令行参数给出。TCP客户端的Go代码将分为五个部分进行介绍；第一部分如下：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The second part of `TCPclient.go` is the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPclient.go`的第二部分如下：'
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The third part of `TCPclient.go` has the following Go code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPclient.go`的第三部分包含以下Go代码：'
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once again, you use the `net.Dial()` function to try to connect to the desired
    port of the desired TCP server.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您使用`net.Dial()`函数尝试连接到所需TCP服务器的所需端口。
- en: 'The fourth part of the TCP client is the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: TCP客户端的第四部分如下：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, you read data from the user that you will send to the TCP server using
    `fmt.Fprintf()`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您从用户那里读取数据，然后使用`fmt.Fprintf()`将其发送到TCP服务器。
- en: 'The last part of `TCPclient.go` is the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPclient.go`的最后部分如下：'
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this part, you get data from the TCP server using `bufio.NewReader().ReadString()`.
    The reason for using the `strings.TrimSpace()` function is to remove any spaces
    and newline characters from the variable you want to compare with the static string
    (`STOP`).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，您将使用`bufio.NewReader().ReadString()`从TCP服务器获取数据。使用`strings.TrimSpace()`函数的原因是从要与静态字符串（`STOP`）进行比较的变量中删除任何空格和换行符。
- en: 'So, now it is time to verify that `TCPclient.go` works as expected using it
    to connect to `TCPserver.go`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在是时候验证`TCPclient.go`是否按预期工作，使用它连接到`TCPserver.go`：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If no process listens to the specified TCP port at the specified host, then
    you will get an error message similar to the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在指定的主机上指定的TCP端口没有进程在监听，那么您将收到类似以下的错误消息：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Using other functions for the TCP server
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他函数来实现TCP服务器
- en: In this subsection, we will develop the functionality of `TCPserver.go` using
    some slightly different functions. The name of the new TCP server will be `TCPs.go`
    and will be presented in four parts.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小节中，我们将使用一些略有不同的函数来开发`TCPserver.go`的功能。新的TCP服务器的名称将是`TCPs.go`，将分为四个部分进行介绍。
- en: 'The first part of `TCPs.go` is the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPs.go`的第一部分如下：'
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The second part of the TCP server is the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: TCP服务器的第二部分如下：
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: So far, there are no differences from the code of `TCPserver.go`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，与`TCPserver.go`的代码没有区别。
- en: 'The differences start in the third part of `TCPs.go`, which is the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在`TCPs.go`的第三部分开始，如下：
- en: '[PRE54]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, you use the `net.ResolveTCPAddr()` and `net.ListenTCP()` functions. Is
    this version better than `TCPserver.go`? Not really. But the Go code might look
    a little clearer and this is a big advantage for some people. Additionally, `net.ListenTCP()`
    returns a `TCPListener` value that when used with `net.AcceptTCP()` instead of
    `net.Accept()` will return `TCPConn`, which offers more methods that allow you
    to change more socket options.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用`net.ResolveTCPAddr()`和`net.ListenTCP()`函数。这个版本比`TCPserver.go`更好吗？实际上并不是。但是Go代码可能看起来更清晰一些，这对一些人来说是一个很大的优势。另外，`net.ListenTCP()`返回一个`TCPListener`值，当与`net.Accept()`而不是`net.Accept()`一起使用时，将返回`TCPConn`，它提供了更多的方法，允许您更改更多的套接字选项。
- en: 'The last part of `TCPs.go` has the following Go code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPs.go`的最后部分包含以下Go代码：'
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There is nothing special here. You still use `Accept()` to get and process client
    requests. However, this version uses `Read()` to get the client data all at once,
    which is great when you do not have to process lots of input.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的。您仍然使用`Accept()`来获取和处理客户端请求。但是，这个版本使用`Read()`一次性获取客户端数据，这在您不必处理大量输入时非常方便。
- en: The operation of `TCPs.go` is the same with the operation of `TCPserver.go`,
    so it will not be shown here.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPs.go`的操作与`TCPserver.go`的操作相同，因此这里不会展示。'
- en: 'If you try to create a TCP server using an invalid port number, `TCPs.go` will
    generate an informative error message, as shown here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试使用无效的端口号创建TCP服务器，`TCPs.go`将生成如下信息的错误消息：
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Using alternative functions for the TCP client
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用替代函数来实现TCP客户端
- en: Once again, we will implement `TCPclient.go` using some slightly different functions
    that are provided by the `net` Go standard package. The name of the new version
    will be `TCPc.go` and will be shown in four code segments.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用一些略有不同的函数来实现`TCPclient.go`，这些函数由`net` Go标准包提供。新版本的名称将是`TCPc.go`，将分为四个代码段进行展示。
- en: 'The first part is the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE57]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The second code segment of the program is the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二个代码段如下：
- en: '[PRE58]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This time, we will send a static message to the TCP server.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将向TCP服务器发送一个静态消息。
- en: 'The third part of `TCPc.go` is the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPc.go`的第三部分如下：'
- en: '[PRE59]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this part, you see the use of `net.ResolveTCPAddr()` and `net.DialTCP()`,
    which is where the differences between `TCPc.go` and `TCPclient.go` exist.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，您将看到`net.ResolveTCPAddr()`和`net.DialTCP()`的使用，这是`TCPc.go`和`TCPclient.go`之间的区别所在。
- en: 'The last part of the TCP client is the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: TCP客户端的最后部分如下：
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You might ask if you can use `TCPc.go` with `TCPserver.go` or `TCPs.go` with
    `TCPclient.go`. The answer is a definitive *yes* because the implementation and
    the function names have nothing to do with the actual TCP/IP operations that take
    place.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问是否可以将`TCPc.go`与`TCPserver.go`或`TCPs.go`与`TCPclient.go`一起使用。答案是肯定的，因为实现和函数名称与实际进行的TCP/IP操作无关。
- en: Developing a simple UDP server
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个简单的UDP服务器
- en: This section will also develop an Echo server. However, this time the Echo server
    will use the UDP protocol. The name of the program will be `UDPserver.go` and
    will be presented to you in five parts.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本节还将开发一个Echo服务器。但是，这次Echo服务器将使用UDP协议。程序的名称将是`UDPserver.go`，并将分为五个部分呈现给您。
- en: 'The first part contains the expected preamble:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分包含了预期的序言：
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The second part is the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The third part of `UDPserver.go` is the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`UDPserver.go`的第三部分如下：'
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The UDP approach is similar to the TCP approach: you just call functions with
    different names.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: UDP方法与TCP方法类似：只需调用不同名称的函数。
- en: 'The fourth part of the program has the following Go code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第四部分包含以下Go代码：
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the UDP case, you use `ReadFromUDP()` to read from a UDP connection and `WriteToUDP()`
    to write to an UDP connection. Additionally, the UDP connection does not need
    to call a function similar to `net.Accept()`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在UDP情况下，您使用`ReadFromUDP()`从UDP连接读取数据，并使用`WriteToUDP()`向UDP连接写入数据。此外，UDP连接不需要调用类似于`net.Accept()`的函数。
- en: 'The last part of the UDP server is the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: UDP服务器的最后一部分如下：
- en: '[PRE65]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Once again, we will test `UDPserver.go` with `netcat(1)`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`netcat(1)`测试`UDPserver.go`：
- en: '[PRE66]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Developing a simple UDP client
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个简单的UDP客户端
- en: In this section, we will develop a UDP client, which we will name `UDPclient.go`
    and present in five parts.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个UDP客户端，我们将命名为`UDPclient.go`并分为五个部分。
- en: 'As you will see, the code differences between the Go code of `UDPclient.go`
    and `TCPc.go` are basically the differences in the names of the functions used:
    the general idea is exactly the same.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将看到的，`UDPclient.go`和`TCPc.go`的Go代码之间的代码差异基本上是所使用函数名称的差异：总体思路是完全相同的。
- en: 'The first part of the UDP client is the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: UDP客户端的第一部分如下：
- en: '[PRE67]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The second part of the utility contains the following Go code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的第二部分包含以下Go代码：
- en: '[PRE68]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The third part of `UDPclient.go` has the following Go code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`UDPclient.go`的第三部分如下：'
- en: '[PRE69]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Nothing special here: just the use of `net.ResolveUDPAddr()` and `net.DialUDP()`
    to connect to the UDP server.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的：只是使用`net.ResolveUDPAddr()`和`net.DialUDP()`来连接到UDP服务器。
- en: 'The fourth part of the UDP client is the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: UDP客户端的第四部分如下：
- en: '[PRE70]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This time, you send your data to the UDP server using `Write()`, although you
    will read from the UDP server using `ReadFromUDP()`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，您将使用`Write()`将数据发送到UDP服务器，尽管您将使用`ReadFromUDP()`从UDP服务器读取数据。
- en: 'The last part of `UDPclient.go` is the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`UDPclient.go`的最后一部分如下：'
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As we have `UDPserver.go` and we know that it works, we can test the operation
    of `UDPclient.go` using `UDPserver.go`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有`UDPserver.go`并且知道它可以工作，我们可以使用`UDPserver.go`来测试`UDPclient.go`的操作：
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If you execute `UDPclient.go` without a UDP server listening to the desired
    port, you will get the following output, which does not clearly state that it
    could not connect to an UDP server: it just shows an empty reply:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在没有UDP服务器监听所需端口的情况下执行`UDPclient.go`，您将获得以下输出，其中并未明确说明它无法连接到UDP服务器：它只显示了一个空回复：
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: A concurrent TCP server
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个并发的TCP服务器
- en: 'In this section, you will learn how to develop a concurrent TCP server: each
    client connection will be assigned to a new goroutine that will serve the client
    request. Note that although TCP clients initially connect to the same port, they
    are served using a different port number than the main port number of the server:
    this is automatically handled by TCP and is the way TCP works.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何开发一个并发的TCP服务器：每个客户端连接将被分配给一个新的goroutine来为客户端请求提供服务。请注意，尽管TCP客户端最初连接到相同的端口，但它们使用的端口号与服务器的主端口号不同：这是由TCP自动处理的，也是TCP的工作方式。
- en: Although creating a concurrent UDP server is also a possibility, it might not
    be absolutely necessary due to the way UDP works. However, if you have a really
    busy UDP service, then you might consider developing a concurrent UDP server.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建一个并发的UDP服务器也是可能的，但由于UDP的工作方式，这可能并不是绝对必要的。但是，如果您有一个非常繁忙的UDP服务，那么您可能需要考虑开发一个并发的UDP服务器。
- en: The name of the program will be `concTCP.go` and will be presented in five parts.
    The good thing is that once you define a function to handle incoming connections,
    all you need is to execute that function as a goroutine, and the rest will be
    handled by Go!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的名称将是`concTCP.go`，并将分为五个部分呈现。好处是，一旦您定义了一个处理传入连接的函数，您所需要做的就是将该函数作为goroutine执行，其余的工作将由Go处理！
- en: 'The first part of `concTCP.go` is the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`concTCP.go`的第一部分如下：'
- en: '[PRE74]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The second part of the concurrent TCP server is the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 并发TCP服务器的第二部分如下：
- en: '[PRE75]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here is the implementation of the function that handles each TCP request. The
    time delay at the end of it is used for giving you the necessary time to connect
    with another TCP client and prove that `concTCP.go` can serve multiple TCP clients.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理每个TCP请求的函数的实现。最后的时间延迟用于给您足够的时间与另一个TCP客户端连接并证明`concTCP.go`可以为多个TCP客户端提供服务。
- en: 'The third part of the program contains the following Go code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分包含以下Go代码：
- en: '[PRE76]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The fourth part of `concTCP.go` has the following Go code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`concTCP.go`的第四部分包含以下Go代码：'
- en: '[PRE77]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: So far, there is nothing special in the `main()` function because although `concTCP.go`
    will handle multiple requests, it only needs a single call to `net.Listen()`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`main()`函数中没有什么特别的，因为尽管`concTCP.go`将处理多个请求，但它只需要一次调用`net.Listen()`。
- en: 'The last chunk of Go code is the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分Go代码如下：
- en: '[PRE78]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: All the differences in the way `concTCP.go` processes its requests can be found
    in the last lines of Go code. Each time the program accepts a new network request
    using `Accept()`, a new goroutine gets started and `concTCP.go` is immediately
    ready to accept more requests. Note that in order to terminate `concTCP.go`, you
    will have to press *Ctrl* + *C* because the `STOP` keyword is used for terminating
    each goroutine of the program.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`concTCP.go`处理其请求的所有差异都可以在Go代码的最后几行找到。每次程序使用`Accept()`接受新的网络请求时，都会启动一个新的goroutine，并且`concTCP.go`立即准备好接受更多的请求。请注意，为了终止`concTCP.go`，您将需要按下*Ctrl*
    + *C*，因为`STOP`关键字用于终止程序的每个goroutine。'
- en: 'Executing `concTCP.go` and connecting to it using various TCP clients, will
    generate the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`concTCP.go`并使用各种TCP客户端连接到它，将生成以下输出：
- en: '[PRE79]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Remote procedure call (RPC)
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程过程调用（RPC）
- en: '**Remote Procedure Call** (**RPC**) is a client-server mechanism for interprocess
    communication. Note that the RPC client and the RPC server communicate using TCP/IP,
    which means that they can exist in different machines.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程过程调用**（**RPC**）是一种用于进程间通信的客户端-服务器机制。请注意，RPC客户端和RPC服务器使用TCP/IP进行通信，这意味着它们可以存在于不同的机器上。'
- en: In order to develop the implementation of an RPC client or RPC server, you will
    need to follow some steps and call some functions in a given way. Neither of the
    two implementations is difficult; you just have to follow certain steps.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发RPC客户端或RPC服务器的实现，您需要按照一定的步骤调用一些函数。这两种实现都不难；您只需要遵循一定的步骤。
- en: Also, visit the documentation page of the `net/rpc` Go standard package that
    can be found at `https://golang.org/pkg/net/rpc/`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请访问`https://golang.org/pkg/net/rpc/`上可以找到的`net/rpc` Go标准包的文档页面。
- en: Note that the presented RPC example will use TCP for client-server interaction.
    However, you can also use HTTP for client-server communication.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所呈现的RPC示例将使用TCP进行客户端-服务器交互。但是，您也可以使用HTTP进行客户端-服务器通信。
- en: An RPC server
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个RPC服务器
- en: 'This subsection will present an RPC server named `RPCserver.go`. As you will
    see in the preamble of the `RPCserver.go` program, the RPC server imports a package
    named `sharedRPC`, which is implemented in the `sharedRPC.go` file: the name of
    the package is arbitrary. Its contents are the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将介绍一个名为`RPCserver.go`的RPC服务器。正如您将在`RPCserver.go`程序的前言中看到的那样，RPC服务器导入了一个名为`sharedRPC`的包，该包在`sharedRPC.go`文件中实现：包的名称是任意的。其内容如下：
- en: '[PRE80]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: So, here you define a new structure that holds the signs and the values of two
    unsigned integers and a new interface named `MyInterface`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，您定义了一个新的结构，其中包含两个无符号整数的符号和值，并定义了一个名为`MyInterface`的新接口。
- en: 'Then, you should install `sharedRPC.go`, which means that you should execute
    the following commands before you try to use the `sharedRPC` package in your programs:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您应该安装`sharedRPC.go`，这意味着您应该在尝试在程序中使用`sharedRPC`包之前执行以下命令：
- en: '[PRE81]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If you are on a macOS machine (`darwin_amd64`) and you want to make sure that
    everything is OK, you can execute the following two commands:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS机器（`darwin_amd64`）并且希望确保一切正常，您可以执行以下两个命令：
- en: '[PRE82]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'What you really must keep in mind is that, at the end of the day, what is being
    exchanged between an RPC server and an RPC client are function names and their
    arguments. Only the functions defined in the interface of `sharedRPC.go` can be
    used in an RPC interaction: the RPC server will need to implement the functions
    of the `MyInterface` interface. The Go code of `RPCserver.go` will be presented
    in five parts; the first part of the RPC server has the expected preamble, which
    also includes the `sharedRPC` package we made:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您真正需要记住的是，归根结底，RPC服务器和RPC客户端之间交换的是函数名称及其参数。只有在`sharedRPC.go`接口中定义的函数才能在RPC交互中使用：RPC服务器将需要实现`MyInterface`接口的函数。`RPCserver.go`的Go代码将分为五部分呈现；RPC服务器的第一部分具有预期的前言，其中还包括我们制作的`sharedRPC`包：
- en: '[PRE83]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The second part of `RPCserver.go` is the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPCserver.go`的第二部分如下：'
- en: '[PRE84]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Here is the implementation of the first function that will be offered to the
    RPC clients: you can have as many functions as you want, provided that they are
    included in the interface.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将要提供给RPC客户端的第一个函数的实现：您可以拥有尽可能多的函数，只要它们包含在接口中。
- en: 'The third part of `RPCserver.go` has the following Go code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPCserver.go`的第三部分包含以下Go代码：'
- en: '[PRE85]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This is the second function that is offered to the RPC clients by this RPC server.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是RPC服务器向RPC客户端提供的第二个函数。
- en: 'The fourth part of `RPCserver.go` contains the following Go code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPCserver.go`的第四部分包含以下Go代码：'
- en: '[PRE86]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As our RPC server uses TCP, you need to make calls to `net.ResolveTCPAddr()`
    and `net.ListenTCP()`. However, you will first need to call `rpc.Register()` in
    order to be able to serve the desired interface.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的RPC服务器使用TCP，您需要调用`net.ResolveTCPAddr()`和`net.ListenTCP()`来进行调用。但是，您首先需要调用`rpc.Register()`以便能够提供所需的接口。
- en: 'The last part of the program is the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分如下：
- en: '[PRE87]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here, you accept a new TCP connection using `Accept()` as usual, but you serve
    it using `rpc.ServeConn()`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以像往常一样使用`Accept()`接受新的TCP连接，但是使用`rpc.ServeConn()`来提供服务。
- en: You will have to wait for the next section and the development of the RPC client
    in order to test the operation of `RPCserver.go`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要等待下一节和RPC客户端的开发，以便测试`RPCserver.go`的操作。
- en: An RPC client
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个RPC客户端
- en: 'In this section, we will develop an RPC client named `RPCclient.go`. The Go
    code of `RPCclient.go` will be presented in five parts; the first part is the
    following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个名为`RPCclient.go`的RPC客户端。`RPCclient.go`的Go代码将分为五部分呈现；第一部分如下：
- en: '[PRE88]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note the use of the `sharedRPC` package in the RPC client.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意RPC客户端中`sharedRPC`包的使用。
- en: 'The second part of `RPCclient.go` is the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPCclient.go`的第二部分如下：'
- en: '[PRE89]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The third part of the program has the following Go code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分包含以下Go代码：
- en: '[PRE90]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As the `MyInts` structure is defined in `sharedRPC.go`, you need to use it as
    `sharedRPC.MyInts` in the RPC client. Moreover, you call `rpc.Dial()` to connect
    to the RPC server instead of `net.Dial()`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`MyInts`结构在`sharedRPC.go`中定义，因此您需要在RPC客户端中将其用作`sharedRPC.MyInts`。此外，您调用`rpc.Dial()`来连接到RPC服务器，而不是`net.Dial()`。
- en: 'The fourth part of the RPC client contains the following Go code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: RPC客户端的第四部分包含以下Go代码：
- en: '[PRE91]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Here, you use the `Call()` function to execute the desired function in the RPC
    server. The result of the `MyInterface.Add()` function is stored in the `reply`
    variable, which was previously declared.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用`Call()`函数来执行RPC服务器中的所需函数。`MyInterface.Add()`函数的结果存储在先前声明的`reply`变量中。
- en: 'The last part of `RPCclient.go` is the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPCclient.go`的最后部分如下：'
- en: '[PRE92]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Here, you do the same thing as before for executing the `MyInterface.Subtract()`
    function.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您执行`MyInterface.Subtract()`函数的方式与之前相同。
- en: 'As you can guess, you cannot test the RPC client without having an RCP server
    and vice versa: `netcat(1)` cannot be used for RPC.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以猜到的，您无法在没有RCP服务器的情况下测试RPC客户端，反之亦然：`netcat(1)`不能用于RPC。
- en: 'First, you will need to start the `RPCserver.go` process:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要启动`RPCserver.go`进程：
- en: '[PRE93]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Then, you will execute the `RPCclient.go` program:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将执行`RPCclient.go`程序：
- en: '[PRE94]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If the `RPCserver.go` process is not running and you try to execute `RPCclient.go`,
    you will get the following error message:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`RPCserver.go`进程没有运行，而您尝试执行`RPCclient.go`，您将收到以下错误消息：
- en: '[PRE95]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Of course, RPC is not for adding integers or natural numbers, but for doing
    much more complex operations that you want to control from a central point.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，RPC不是用于添加整数或自然数，而是用于执行更复杂的操作，您希望从一个中心点进行控制。
- en: Exercises
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Read the documentation of the net package in order to find out about its list
    of available functions at [https://golang.org/pkg/net/](https://golang.org/pkg/net/).
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读net包的文档，以了解其可用函数列表：[https://golang.org/pkg/net/](https://golang.org/pkg/net/)。
- en: 'Wireshark is a great tool for analyzing network traffic of any kind: try to
    use it more.'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Wireshark是分析任何类型网络流量的好工具：尝试更多地使用它。
- en: Change the code of `socketClient.go` in order to read the input from the user.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`socketClient.go`的代码，以便从用户那里读取输入。
- en: Change the code of `socketServer.go` in order to return a random number to the
    client.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`socketServer.go`的代码，以便向客户端返回一个随机数。
- en: Change the code of `TCPserver.go` in order to stop when it receives a given
    Unix signal from the user.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`TCPserver.go`的代码，以便在接收到用户给定的Unix信号时停止。
- en: Change the Go code of `concTCP.go` in order to keep track of the number of clients
    it has served and print that number before exiting.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`concTCP.go`的Go代码，以便跟踪它服务过的客户端数量，并在退出之前打印该数字。
- en: Add a `quit()` function to `RPCserver.go` that does what its name implies.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`RPCserver.go`添加一个`quit()`函数，执行其名称所暗示的操作。
- en: Develop your own RPC example.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发您自己的RPC示例。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced you to TCP/IP, and we talked about developing
    TCP and UDP servers and clients in Go and about creating RPC clients and servers.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了TCP/IP，并讨论了如何在Go中开发TCP和UDP服务器和客户端，以及创建RPC客户端和服务器。
- en: At this point, there is no next chapter because this is the last chapter of
    this book! Congratulations for reading the whole book! You are now ready to start
    developing useful Unix command-line utilities in Go; so, go ahead and start programming
    your own tools immediately!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，没有下一章，因为这是本书的最后一章！恭喜您阅读了整本书！您现在已经准备好开始在Go中开发有用的Unix命令行实用程序了；所以，继续并立即开始编程您自己的工具！
