["```go\n$ mkdir templates && cd templates && touch first-template.html\n```", "```go\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>First Template</title>\n    <link rel=\"stylesheet\" href=\"/static/stylesheets/main.css\">\n  </head>\n  <body>\n    <h1>Hello {{.Name}}!</h1>\n    Your Id is {{.Id}}\n  </body>\n</html>\n```", "```go\nimport \n(\n  \"fmt\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype Person struct \n{\n  Id   string\n  Name string\n}\nfunc renderTemplate(w http.ResponseWriter, r *http.Request) \n{\n  person := Person{Id: \"1\", Name: \"Foo\"}\n  parsedTemplate, _ := template.ParseFiles(\"templates/\n  first-template.html\")\n  err := parsedTemplate.Execute(w, person)\n  if err != nil \n  {\n    log.Printf(\"Error occurred while executing the template\n    or writing its output : \", err)\n    return\n  }\n}\nfunc main() \n{\n  http.HandleFunc(\"/\", renderTemplate)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run first-template.go\n```", "```go\n$ curl -X GET http://localhost:8080\n```", "```go\n$ mkdir static && cd static && mkdir css && cd css && touch main.css\n```", "```go\nbody {color: #00008B}\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype Person struct \n{\n  Name string\n  Age string\n}\nfunc renderTemplate(w http.ResponseWriter, r *http.Request) \n{\n  person := Person{Id: \"1\", Name: \"Foo\"}\n  parsedTemplate, _ := template.ParseFiles(\"templates/\n  first-template.html\")\n  err := parsedTemplate.Execute(w, person)\n  if err != nil \n  {\n    log.Printf(\"Error occurred while executing the template \n    or writing its output : \", err)\n    return\n  }\n}\nfunc main() \n{\n  fileServer := http.FileServer(http.Dir(\"static\"))\n  http.Handle(\"/static/\", http.StripPrefix(\"/static/\", fileServer))\n  http.HandleFunc(\"/\", renderTemplate)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>First Template</title>\n    <link rel=\"stylesheet\" href=\"/static/css/main.css\">\n  </head>\n  <body>\n    <h1>Hello {{.Name}}!</h1>\n    Your Id is {{.Id}}\n  </body>\n</html>\n```", "```go\n$ go run serve-static-files.go\n```", "```go\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype Person struct \n{\n  Id string\n  Name string\n}\nfunc renderTemplate(w http.ResponseWriter, r *http.Request) \n{\n  person := Person{Id: \"1\", Name: \"Foo\"}\n  parsedTemplate, _ := template.ParseFiles(\"templates/\n  first-template.html\")\n  err := parsedTemplate.Execute(w, person)\n  if err != nil \n  {\n    log.Printf(\"Error occurred while executing the template \n    or writing its output : \", err)\n    return\n  }\n}\nfunc main() \n{\n  router := mux.NewRouter()\n  router.HandleFunc(\"/\", renderTemplate).Methods(\"GET\")\n  router.PathPrefix(\"/\").Handler(http.StripPrefix(\"/static\",\n  http.FileServer(http.Dir(\"static/\"))))\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run serve-static-files-gorilla-mux.go\n```", "```go\n$ mkdir templates && cd templates && touch login-form.html\n```", "```go\n<html>\n  <head>\n    <title>First Form</title>\n  </head>\n  <body>\n    <h1>Login</h1>\n    <form method=\"post\" action=\"/login\">\n      <label for=\"username\">Username</label>\n      <input type=\"text\" id=\"username\" name=\"username\">\n      <label for=\"password\">Password</label>\n      <input type=\"password\" id=\"password\" name=\"password\">\n      <button type=\"submit\">Login</button>\n    </form>\n  </body>\n</html>\n```", "```go\npackage main\nimport \n(\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\nfunc login(w http.ResponseWriter, r *http.Request) \n{\n  parsedTemplate, _ := template.ParseFiles(\"templates/\n  login-form.html\")\n  parsedTemplate.Execute(w, nil)\n}\nfunc main() \n{\n  http.HandleFunc(\"/\", login)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run html-form.go\n```", "```go\n$ go get github.com/gorilla/schema\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/schema\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype User struct \n{\n  Username string\n  Password string\n}\nfunc readForm(r *http.Request) *User \n{\n  r.ParseForm()\n  user := new(User)\n  decoder := schema.NewDecoder()\n  decodeErr := decoder.Decode(user, r.PostForm)\n  if decodeErr != nil \n  {\n    log.Printf(\"error mapping parsed form data to struct : \",\n    decodeErr)\n  }\n  return user\n}\nfunc login(w http.ResponseWriter, r *http.Request) \n{\n  if r.Method == \"GET\" \n  {\n    parsedTemplate, _ := template.ParseFiles(\"templates/\n    login-form.html\")\n    parsedTemplate.Execute(w, nil)\n  } \n  else \n  {\n    user := readForm(r)\n    fmt.Fprintf(w, \"Hello \"+user.Username+\"!\")\n  }\n}\nfunc main() \n{\n  http.HandleFunc(\"/\", login)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run html-form-read.go\n```", "```go\ntype User struct \n{\n  Username string\n  Password string\n}\n```", "```go\nfunc readForm(r *http.Request) *User {\n r.ParseForm()\n user := new(User)\n decoder := schema.NewDecoder()\n decodeErr := decoder.Decode(user, r.PostForm)\n if decodeErr != nil {\n log.Printf(\"error mapping parsed form data to struct : \", decodeErr)\n }\n return user\n }\n```", "```go\nfunc login(w http.ResponseWriter, r *http.Request) \n{\n  if r.Method == \"GET\" \n  {\n    parsedTemplate, _ := template.ParseFiles(\"templates/\n    login-form.html\")\n    parsedTemplate.Execute(w, nil)\n  } \n  else \n  {\n    user := readForm(r)\n    fmt.Fprintf(w, \"Hello \"+user.Username+\"!\")\n  }\n}\n```", "```go\n$ go get github.com/asaskevich/govalidator\n$ go get github.com/gorilla/schema\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"github.com/asaskevich/govalidator\"\n  \"github.com/gorilla/schema\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  USERNAME_ERROR_MESSAGE = \"Please enter a valid Username\"\n  PASSWORD_ERROR_MESSAGE = \"Please enter a valid Password\"\n  GENERIC_ERROR_MESSAGE = \"Validation Error\"\n)\ntype User struct \n{\n  Username string `valid:\"alpha,required\"`\n  Password string `valid:\"alpha,required\"`\n}\nfunc readForm(r *http.Request) *User \n{\n  r.ParseForm()\n  user := new(User)\n  decoder := schema.NewDecoder()\n  decodeErr := decoder.Decode(user, r.PostForm)\n  if decodeErr != nil \n  {\n    log.Printf(\"error mapping parsed form data to struct : \",\n    decodeErr)\n  }\n  return user\n}\nfunc validateUser(w http.ResponseWriter, r *http.Request, user *User) (bool, string) \n{\n  valid, validationError := govalidator.ValidateStruct(user)\n  if !valid \n  {\n    usernameError := govalidator.ErrorByField(validationError,\n    \"Username\")\n    passwordError := govalidator.ErrorByField(validationError,\n    \"Password\")\n    if usernameError != \"\" \n    {\n      log.Printf(\"username validation error : \", usernameError)\n      return valid, USERNAME_ERROR_MESSAGE\n    }\n    if passwordError != \"\" \n    {\n      log.Printf(\"password validation error : \", passwordError)\n      return valid, PASSWORD_ERROR_MESSAGE\n    }\n  }\n  return valid, GENERIC_ERROR_MESSAGE\n}\nfunc login(w http.ResponseWriter, r *http.Request) \n{\n  if r.Method == \"GET\" \n  {\n    parsedTemplate, _ := template.ParseFiles(\"templates/\n    login-form.html\")\n    parsedTemplate.Execute(w, nil)\n  } \n  else \n  {\n    user := readForm(r)\n    valid, validationErrorMessage := validateUser(w, r, user)\n    if !valid \n    {\n      fmt.Fprintf(w, validationErrorMessage)\n      return\n    }\n    fmt.Fprintf(w, \"Hello \"+user.Username+\"!\")\n  }\n}\nfunc main() \n{\n  http.HandleFunc(\"/\", login)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run html-form-validation.go\n```", "```go\n$ curl --data \"username=Foo&password=password\" http://localhost:8080/\n```", "```go\ntype User struct \n{\n  Username string `valid:\"alpha,required\"`\n  Password string \n  valid:\"alpha,required\"\n}\n```", "```go\n$ mkdir templates && cd templates && touch upload-file.html\n```", "```go\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>File Upload</title>\n  </head>\n  <body>\n    <form action=\"/upload\" method=\"post\" enctype=\"multipart/\n    form-data\">\n      <label for=\"file\">File:</label>\n      <input type=\"file\" name=\"file\" id=\"file\">\n      <input type=\"submit\" name=\"submit\" value=\"Submit\">\n    </form>\n  </body>\n</html>\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"html/template\"\n  \"io\"\n  \"log\"\n  \"net/http\"\n  \"os\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\nfunc fileHandler(w http.ResponseWriter, r *http.Request) \n{\n  file, header, err := r.FormFile(\"file\")\n  if err != nil \n  {\n    log.Printf(\"error getting a file for the provided form key : \",\n    err)\n    return\n  }\n  defer file.Close()\n  out, pathError := os.Create(\"/tmp/uploadedFile\")\n  if pathError != nil \n  {\n    log.Printf(\"error creating a file for writing : \", pathError)\n    return\n  }\n  defer out.Close()\n  _, copyFileError := io.Copy(out, file)\n  if copyFileError != nil \n  {\n    log.Printf(\"error occurred while file copy : \", copyFileError)\n  }\n  fmt.Fprintf(w, \"File uploaded successfully : \"+header.Filename)\n}\nfunc index(w http.ResponseWriter, r *http.Request) \n{\n  parsedTemplate, _ := template.ParseFiles(\"templates/\n  upload-file.html\")\n  parsedTemplate.Execute(w, nil)\n}\nfunc main() \n{\n  http.HandleFunc(\"/\", index)\n  http.HandleFunc(\"/upload\", fileHandler)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run upload-file.go\n```"]