["```go\n$ go get github.com/gorilla/sessions\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/sessions\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\nvar store *sessions.CookieStore\nfunc init() \n{\n  store = sessions.NewCookieStore([]byte(\"secret-key\"))\n}\nfunc home(w http.ResponseWriter, r *http.Request) \n{\n  session, _ := store.Get(r, \"session-name\")\n  var authenticated interface{} = session.Values[\"authenticated\"]\n  if authenticated != nil \n  {\n    isAuthenticated := session.Values[\"authenticated\"].(bool)\n    if !isAuthenticated \n    {\n      http.Error(w, \"You are unauthorized to view the page\",\n      http.StatusForbidden)\n      return\n    }\n    fmt.Fprintln(w, \"Home Page\")\n  } \n  else \n  {\n    http.Error(w, \"You are unauthorized to view the page\",\n    http.StatusForbidden)\n    return\n  }\n}\nfunc login(w http.ResponseWriter, r *http.Request) \n{\n  session, _ := store.Get(r, \"session-name\")\n  session.Values[\"authenticated\"] = true\n  session.Save(r, w)\n  fmt.Fprintln(w, \"You have successfully logged in.\")\n}\nfunc logout(w http.ResponseWriter, r *http.Request) \n{\n  session, _ := store.Get(r, \"session-name\")\n  session.Values[\"authenticated\"] = false\n  session.Save(r, w)\n  fmt.Fprintln(w, \"You have successfully logged out.\")\n}\nfunc main() \n{\n  http.HandleFunc(\"/home\", home)\n  http.HandleFunc(\"/login\", login)\n  http.HandleFunc(\"/logout\", logout)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-session.go\n```", "```go\n$ curl -X GET http://localhost:8080/home\n```", "```go\n$ curl -X GET -i http://localhost:8080/login\n```", "```go\n$ curl --cookie \"session-name=MTUyMzEwMTI3NXxEdi1CQkFFQ180SUFBUkFCRUFBQUpmLUNBQUVHYzNSeWFXNW5EQThBRFdGMWRHaGxiblJwWTJGMFpXUUVZbTl2YkFJQ0FBRT18ou7Zxn3qSbqHHiajubn23Eiv8a348AhPl8RN3uTRM4M=;\" http://localhost:8080/home\n```", "```go\n$ go get gopkg.in/boj/redistore.v1\n$ go get github.com/gorilla/sessions\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/sessions\"\n  redisStore \"gopkg.in/boj/redistore.v1\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\nvar store *redisStore.RediStore\nvar err error\nfunc init() \n{\n  store, err = redisStore.NewRediStore(10, \"tcp\", \":6379\", \"\",\n  []byte(\"secret-key\"))\n  if err != nil \n  {\n    log.Fatal(\"error getting redis store : \", err)\n  }\n}\nfunc home(w http.ResponseWriter, r *http.Request) \n{\n  session, _ := store.Get(r, \"session-name\")\n  var authenticated interface{} = session.Values[\"authenticated\"]\n  if authenticated != nil \n  {\n    isAuthenticated := session.Values[\"authenticated\"].(bool)\n    if !isAuthenticated \n    {\n      http.Error(w, \"You are unauthorized to view the page\",\n      http.StatusForbidden)\n      return\n    }\n    fmt.Fprintln(w, \"Home Page\")\n  } \n  else \n  {\n    http.Error(w, \"You are unauthorized to view the page\",\n    http.StatusForbidden)\n    return\n  }\n}\nfunc login(w http.ResponseWriter, r *http.Request) \n{\n  session, _ := store.Get(r, \"session-name\")\n  session.Values[\"authenticated\"] = true\n  if err = sessions.Save(r, w); err != nil \n  {\n    log.Fatalf(\"Error saving session: %v\", err)\n  }\n  fmt.Fprintln(w, \"You have successfully logged in.\")\n}\nfunc logout(w http.ResponseWriter, r *http.Request) \n{\n  session, _ := store.Get(r, \"session-name\")\n  session.Values[\"authenticated\"] = false\n  session.Save(r, w)\n  fmt.Fprintln(w, \"You have successfully logged out.\")\n}\nfunc main() \n{\n  http.HandleFunc(\"/home\", home)\n  http.HandleFunc(\"/login\", login)\n  http.HandleFunc(\"/logout\", logout)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  defer store.Close()\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-session-redis.go\n```", "```go\n$ curl -X GET http://localhost:8080/home\n```", "```go\n$ curl -X GET -i http://localhost:8080/login\n```", "```go\n$ curl --cookie \"session-name=MTUyMzEwNDUyM3xOd3dBTkV4T1JrdzNURFkyUkVWWlQxWklUekpKVUVOWE1saFRUMHBHVTB4T1RGVXlSRU5RVkZWWk5VeFNWVmRPVVZSQk4wTk1RMUU9fAlGgLGU-OHxoP78xzEHMoiuY0Q4rrbsXfajSS6HiJAm;\" http://localhost:8080/home\n```", "```go\n$ go get github.com/gorilla/securecookie\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/securecookie\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\nvar cookieHandler *securecookie.SecureCookie\nfunc init() \n{\n  cookieHandler = securecookie.New(securecookie.\n  GenerateRandomKey(64),\n  securecookie.GenerateRandomKey(32))\n}\nfunc createCookie(w http.ResponseWriter, r *http.Request) \n{\n  value := map[string]string\n  {\n    \"username\": \"Foo\",\n  }\n  base64Encoded, err := cookieHandler.Encode(\"key\", value)\n  if err == nil \n  {\n    cookie := &http.Cookie\n    {\n      Name: \"first-cookie\",\n      Value: base64Encoded,\n      Path: \"/\",\n    }\n    http.SetCookie(w, cookie)\n  }\n  w.Write([]byte(fmt.Sprintf(\"Cookie created.\")))\n}\nfunc readCookie(w http.ResponseWriter, r *http.Request) \n{\n  log.Printf(\"Reading Cookie..\")\n  cookie, err := r.Cookie(\"first-cookie\")\n  if cookie != nil && err == nil \n  {\n    value := make(map[string]string)\n    if err = cookieHandler.Decode(\"key\", cookie.Value, &value); \n    err == nil \n    {\n      w.Write([]byte(fmt.Sprintf(\"Hello %v \\n\", \n      value[\"username\"])))\n    }\n  } \n  else \n  {\n    log.Printf(\"Cookie not found..\")\n    w.Write([]byte(fmt.Sprint(\"Hello\")))\n  }\n}\n\nfunc main() \n{\n  http.HandleFunc(\"/create\", createCookie)\n  http.HandleFunc(\"/read\", readCookie)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-cookie.go\n```", "```go\n$ go get github.com/patrickmn/go-cache\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"time\"\n  \"github.com/patrickmn/go-cache\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\nvar newCache *cache.Cache\nfunc init() \n{\n  newCache = cache.New(5*time.Minute, 10*time.Minute)\n  newCache.Set(\"foo\", \"bar\", cache.DefaultExpiration)\n}\nfunc getFromCache(w http.ResponseWriter, r *http.Request) \n{\n  foo, found := newCache.Get(\"foo\")\n  if found \n  {\n    log.Print(\"Key Found in Cache with value as :: \", \n    foo.(string))\n    fmt.Fprintf(w, \"Hello \"+foo.(string))\n  } \n  else \n  {\n    log.Print(\"Key Not Found in Cache :: \", \"foo\")\n    fmt.Fprintf(w, \"Key Not Found in Cache\")\n  }\n}\nfunc main() \n{\n  http.HandleFunc(\"/\", getFromCache)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-caching.go\n```", "```go\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"errors\"\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"strings\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype NameNotFoundError struct \n{\n  Code int\n  Err error\n}\nfunc (nameNotFoundError NameNotFoundError) Error() string \n{\n  return nameNotFoundError.Err.Error()\n}\ntype WrapperHandler func(http.ResponseWriter, *http.Request) \nerror\nfunc (wrapperHandler WrapperHandler) ServeHTTP(w http.\nResponseWriter, r *http.Request) \n{\n  err := wrapperHandler(w, r)\n  if err != nil \n  {\n    switch e := err.(type) \n    {\n      case NameNotFoundError:\n      log.Printf(\"HTTP %s - %d\", e.Err, e.Code)\n      http.Error(w, e.Err.Error(), e.Code)\n      default:\n      http.Error(w, http.StatusText(http.\n      StatusInternalServerError),\n      http.StatusInternalServerError)\n    }\n  }\n}\nfunc getName(w http.ResponseWriter, r *http.Request) error \n{\n  vars := mux.Vars(r)\n  name := vars[\"name\"]\n  if strings.EqualFold(name, \"foo\") \n  {\n    fmt.Fprintf(w, \"Hello \"+name)\n    return nil\n  } \n  else \n  {\n    return NameNotFoundError{500, errors.New(\"Name Not Found\")}\n  }\n}\nfunc main() \n{\n  router := mux.NewRouter()\n  router.Handle(\"/employee/get/{name}\",\n  WrapperHandler(getName)).Methods(\"GET\")\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-error-handling.go\n```", "```go\ntype NameNotFoundError struct \n{\n  Code int\n  Err error\n}\n```", "```go\nfunc (nameNotFoundError NameNotFoundError) Error() string \n{\n  return nameNotFoundError.Err.Error()\n}\n```", "```go\nif err != nil \n{\n  switch e := err.(type) \n  {\n    case NameNotFoundError:\n    log.Printf(\"HTTP %s - %d\", e.Err, e.Code)\n    http.Error(w, e.Err.Error(), e.Code)\n    default:\n    http.Error(w, http.StatusText(http.\n    StatusInternalServerError),\n    http.StatusInternalServerError)\n  }\n}\n```", "```go\n$ go get github.com/gorilla/mux\n$ go get github.com/gorilla/securecookie\n```", "```go\n$ mkdir templates && cd templates && touch home.html\n```", "```go\n<html>\n  <head>\n    <title></title>\n  </head>\n  <body>\n    <h1>Welcome {{.userName}}!</h1>\n    <form method=\"post\" action=\"/logout\">\n      <button type=\"submit\">Logout</button>\n    </form>\n  </body>\n</html>\n```", "```go\npackage main\nimport \n(\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/mux\"\n  \"github.com/gorilla/securecookie\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\nvar cookieHandler = securecookie.New\n(\n  securecookie.GenerateRandomKey(64),\n  securecookie.GenerateRandomKey(32)\n)\nfunc getUserName(request *http.Request) (userName string) \n{\n  cookie, err := request.Cookie(\"session\")\n  if err == nil \n  {\n    cookieValue := make(map[string]string)\n    err = cookieHandler.Decode(\"session\", cookie.Value,\n    &cookieValue)\n    if err == nil \n    {\n      userName = cookieValue[\"username\"]\n    }\n  }\n  return userName\n}\nfunc setSession(userName string, response http.ResponseWriter) \n{\n  value := map[string]string\n  {\n    \"username\": userName,\n  }\n  encoded, err := cookieHandler.Encode(\"session\", value)\n  if err == nil \n  {\n    cookie := &http.Cookie\n    {\n      Name: \"session\",\n      Value: encoded,\n      Path: \"/\",\n    }\n    http.SetCookie(response, cookie)\n  }\n}\nfunc clearSession(response http.ResponseWriter) \n{\n  cookie := &http.Cookie\n  {\n    Name: \"session\",\n    Value: \"\",\n    Path: \"/\",\n    MaxAge: -1,\n  }\n  http.SetCookie(response, cookie)\n}\nfunc login(response http.ResponseWriter, request *http.Request) \n{\n  username := request.FormValue(\"username\")\n  password := request.FormValue(\"password\")\n  target := \"/\"\n  if username != \"\" && password != \"\" \n  {\n    setSession(username, response)\n    target = \"/home\"\n  }\n  http.Redirect(response, request, target, 302)\n}\nfunc logout(response http.ResponseWriter, request *http.Request) \n{\n  clearSession(response)\n  http.Redirect(response, request, \"/\", 302)\n}\nfunc loginPage(w http.ResponseWriter, r *http.Request) \n{\n  parsedTemplate, _ := template.ParseFiles(\"templates/\n  login-form.html\")\n  parsedTemplate.Execute(w, nil)\n}\nfunc homePage(response http.ResponseWriter, request *http.Request) \n{\n  userName := getUserName(request)\n  if userName != \"\" \n  {\n    data := map[string]interface{}\n    {\n      \"userName\": userName,\n    }\n    parsedTemplate, _ := template.ParseFiles(\"templates/home.html\")\n    parsedTemplate.Execute(response, data)\n  } \n  else \n  {\n    http.Redirect(response, request, \"/\", 302)\n  }\n}\nfunc main() \n{\n  var router = mux.NewRouter()\n  router.HandleFunc(\"/\", loginPage)\n  router.HandleFunc(\"/home\", homePage)\n  router.HandleFunc(\"/login\", login).Methods(\"POST\")\n  router.HandleFunc(\"/logout\", logout).Methods(\"POST\")\n  http.Handle(\"/\", router)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run html-form-login-logout.go\n```"]