["```go\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype Route struct \n{\n  Name string\n  Method string\n  Pattern string\n  HandlerFunc http.HandlerFunc\n}\ntype Routes []Route\nvar routes = Routes\n{\n  Route\n  {\n    \"getEmployees\",\n    \"GET\",\n    \"/employees\",\n    getEmployees,\n  },\n  Route\n  {\n    \"getEmployee\",\n    \"GET\",\n    \"/employee/{id}\",\n    getEmployee,\n  },\n}\ntype Employee struct \n{\n  Id string `json:\"id\"`\n  FirstName string `json:\"firstName\"`\n  LastName string `json:\"lastName\"`\n}\ntype Employees []Employee\nvar employees []Employee\nfunc init() \n{\n  employees = Employees\n  {\n    Employee{Id: \"1\", FirstName: \"Foo\", LastName: \"Bar\"},\n    Employee{Id: \"2\", FirstName: \"Baz\", LastName: \"Qux\"},\n  }\n}\nfunc getEmployees(w http.ResponseWriter, r *http.Request) \n{\n  json.NewEncoder(w).Encode(employees)\n}\nfunc getEmployee(w http.ResponseWriter, r *http.Request) \n{\n  vars := mux.Vars(r)\n  id := vars[\"id\"]\n  for _, employee := range employees \n  {\n    if employee.Id == id \n    {\n      if err := json.NewEncoder(w).Encode(employee); err != nil \n      {\n        log.Print(\"error getting requested employee :: \", err)\n      }\n    }\n  }\n}\nfunc AddRoutes(router *mux.Router) *mux.Router \n{\n  for _, route := range routes \n  {\n    router.\n    Methods(route.Method).\n    Path(route.Pattern).\n    Name(route.Name).\n    Handler(route.HandlerFunc)\n  }\n  return router\n}\nfunc main() \n{\n  muxRouter := mux.NewRouter().StrictSlash(true)\n  router := AddRoutes(muxRouter)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-rest-get.go\n```", "```go\n$ curl -X GET http://localhost:8080/employees\n[{\"id\":\"1\",\"firstName\":\"Foo\",\"lastName\":\"Bar\"},{\"id\":\"2\",\"firstName\":\"Baz\",\"lastName\":\"Qux\"}]\n```", "```go\n$ curl -X GET http://localhost:8080/employee/1\n {\"id\":\"1\",\"firstName\":\"Foo\",\"lastName\":\"Bar\"}\n```", "```go\nvar routes = Routes\n{\n  Route\n  {\n    \"getEmployees\",\n    \"GET\",\n    \"/employees\",\n    getEmployees,\n  },\n  Route\n  {\n    \"getEmployee\",\n    \"GET\",\n    \"/employee/{id}\",\n    getEmployee,\n  },\n}\n```", "```go\nfunc init() \n{\n  employees = Employees \n  {\n    Employee{Id: \"1\", FirstName: \"Foo\", LastName: \"Bar\"},\n    Employee{Id: \"2\", FirstName: \"Baz\", LastName: \"Qux\"},\n  }\n}\n```", "```go\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype Route struct \n{\n  Name string\n  Method string\n  Pattern string\n  HandlerFunc http.HandlerFunc\n}\ntype Routes []Route\nvar routes = Routes\n{\n  Route\n  {\n    \"getEmployees\",\n    \"GET\",\n    \"/employees\",\n    getEmployees,\n  },\n  Route\n  {\n    \"addEmployee\",\n    \"POST\",\n    \"/employee/add\",\n    addEmployee,\n  },\n}\ntype Employee struct \n{\n  Id string `json:\"id\"`\n  FirstName string `json:\"firstName\"`\n  LastName string `json:\"lastName\"`\n}\ntype Employees []Employee\nvar employees []Employee\nfunc init() \n{\n  employees = Employees\n  {\n    Employee{Id: \"1\", FirstName: \"Foo\", LastName: \"Bar\"},\n    Employee{Id: \"2\", FirstName: \"Baz\", LastName: \"Qux\"},\n  }\n}\nfunc getEmployees(w http.ResponseWriter, r *http.Request) \n{\n  json.NewEncoder(w).Encode(employees)\n}\nfunc addEmployee(w http.ResponseWriter, r *http.Request) \n{\n  employee := Employee{}\n  err := json.NewDecoder(r.Body).Decode(&employee)\n  if err != nil \n  {\n    log.Print(\"error occurred while decoding employee \n    data :: \", err)\n    return\n  }\n  log.Printf(\"adding employee id :: %s with firstName \n  as :: %s and lastName as :: %s \", employee.Id, \n  employee.FirstName, employee.LastName)\n  employees = append(employees, Employee{Id: employee.Id, \n  FirstName: employee.FirstName, LastName: employee.LastName})\n  json.NewEncoder(w).Encode(employees)\n}\nfunc AddRoutes(router *mux.Router) *mux.Router \n{\n  for _, route := range routes \n  {\n    router.\n    Methods(route.Method).\n    Path(route.Pattern).\n    Name(route.Name).\n    Handler(route.HandlerFunc)\n  }\n  return router\n}\nfunc main() \n{\n  muxRouter := mux.NewRouter().StrictSlash(true)\n  router := AddRoutes(muxRouter)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-rest-post.go\n```", "```go\n$ curl -H \"Content-Type: application/json\" -X POST -d '{\"Id\":\"3\", \"firstName\":\"Quux\", \"lastName\":\"Corge\"}' http://localhost:8080/employee/add\n```", "```go\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype Route struct \n{\n  Name string\n  Method string\n  Pattern string\n  HandlerFunc http.HandlerFunc\n}\ntype Routes []Route\nvar routes = Routes\n{\n  Route\n  {\n    \"getEmployees\",\n    \"GET\",\n    \"/employees\",\n    getEmployees,\n  },\n  Route\n  {\n    \"addEmployee\",\n    \"POST\",\n    \"/employee/add\",\n    addEmployee,\n  },\n  Route\n  {\n    \"updateEmployee\",\n    \"PUT\",\n    \"/employee/update\",\n    updateEmployee,\n  },\n}\ntype Employee struct \n{\n  Id string `json:\"id\"`\n  FirstName string `json:\"firstName\"`\n  LastName string `json:\"lastName\"`\n}\ntype Employees []Employee\nvar employees []Employee\nfunc init() \n{\n  employees = Employees\n  {\n    Employee{Id: \"1\", FirstName: \"Foo\", LastName: \"Bar\"},\n    Employee{Id: \"2\", FirstName: \"Baz\", LastName: \"Qux\"},\n  }\n}\nfunc getEmployees(w http.ResponseWriter, r *http.Request) \n{\n  json.NewEncoder(w).Encode(employees)\n}\nfunc updateEmployee(w http.ResponseWriter, r *http.Request) \n{\n  employee := Employee{}\n  err := json.NewDecoder(r.Body).Decode(&employee)\n  if err != nil \n  {\n    log.Print(\"error occurred while decoding employee \n    data :: \", err)\n    return\n  }\n  var isUpsert = true\n  for idx, emp := range employees \n  {\n    if emp.Id == employee.Id \n    {\n      isUpsert = false\n      log.Printf(\"updating employee id :: %s with \n      firstName as :: %s and lastName as:: %s \", \n      employee.Id, employee.FirstName, employee.LastName)\n      employees[idx].FirstName = employee.FirstName\n      employees[idx].LastName = employee.LastName\n      break\n    }\n  }\n  if isUpsert \n  {\n    log.Printf(\"upserting employee id :: %s with \n    firstName as :: %s and lastName as:: %s \", \n    employee.Id, employee.FirstName, employee.LastName)\n    employees = append(employees, Employee{Id: employee.Id,\n    FirstName: employee.FirstName, LastName: employee.LastName})\n  }\n  json.NewEncoder(w).Encode(employees)\n}\nfunc addEmployee(w http.ResponseWriter, r *http.Request) \n{\n  employee := Employee{}\n  err := json.NewDecoder(r.Body).Decode(&employee)\n  if err != nil \n  {\n    log.Print(\"error occurred while decoding employee \n    data :: \", err)\n    return\n  }\n  log.Printf(\"adding employee id :: %s with firstName \n  as :: %s and lastName as :: %s \", employee.Id, \n  employee.FirstName, employee.LastName)\n  employees = append(employees, Employee{Id: employee.Id, \n  FirstName: employee.FirstName, LastName: employee.LastName})\n  json.NewEncoder(w).Encode(employees)\n}\nfunc AddRoutes(router *mux.Router) *mux.Router \n{\n  for _, route := range routes \n  {\n    router.\n    Methods(route.Method).\n    Path(route.Pattern).\n    Name(route.Name).\n    Handler(route.HandlerFunc)\n  }\n  return router\n}\nfunc main() \n{\n  muxRouter := mux.NewRouter().StrictSlash(true)\n  router := AddRoutes(muxRouter)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-rest-put.go\n```", "```go\n$ curl -H \"Content-Type: application/json\" -X PUT -d '{\"Id\":\"1\", \"firstName\":\"Grault\", \"lastName\":\"Garply\"}' http://localhost:8080/employee/update\n```", "```go\n$ curl -H \"Content-Type: application/json\" -X PUT -d '{\"Id\":\"3\", \"firstName\":\"Quux\", \"lastName\":\"Corge\"}' http://localhost:8080/employee/update\n```", "```go\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype Route struct \n{\n  Name string\n  Method string\n  Pattern string\n  HandlerFunc http.HandlerFunc\n}\ntype Routes []Route\nvar routes = Routes\n{\n  Route\n  {\n    \"getEmployees\",\n    \"GET\",\n    \"/employees\",\n    getEmployees,\n  },\n  Route\n  {\n    \"addEmployee\",\n    \"POST\",\n    \"/employee/add/\",\n    addEmployee,\n  },\n  Route\n  {\n    \"deleteEmployee\",\n    \"DELETE\",\n    \"/employee/delete\",\n    deleteEmployee,\n  },\n}\ntype Employee struct \n{\n  Id string `json:\"id\"`\n  FirstName string `json:\"firstName\"`\n  LastName string `json:\"lastName\"`\n}\ntype Employees []Employee\nvar employees []Employee\nfunc init() \n{\n  employees = Employees\n  {\n    Employee{Id: \"1\", FirstName: \"Foo\", LastName: \"Bar\"},\n    Employee{Id: \"2\", FirstName: \"Baz\", LastName: \"Qux\"},\n  }\n}\nfunc getEmployees(w http.ResponseWriter, r *http.Request) \n{\n  json.NewEncoder(w).Encode(employees)\n}\nfunc deleteEmployee(w http.ResponseWriter, r *http.Request) \n{\n  employee := Employee{}\n  err := json.NewDecoder(r.Body).Decode(&employee)\n  if err != nil \n  {\n    log.Print(\"error occurred while decoding employee \n    data :: \", err)\n    return\n  }\n  log.Printf(\"deleting employee id :: %s with firstName \n  as :: %s and lastName as :: %s \", employee.Id, \n  employee.FirstName, employee.LastName)\n  index := GetIndex(employee.Id)\n  employees = append(employees[:index], employees[index+1:]...)\n  json.NewEncoder(w).Encode(employees)\n}\nfunc GetIndex(id string) int \n{\n  for i := 0; i < len(employees); i++ \n  {\n    if employees[i].Id == id \n    {\n      return i\n    }\n  }\n  return -1\n}\nfunc addEmployee(w http.ResponseWriter, r *http.Request) \n{\n  employee := Employee{}\n  err := json.NewDecoder(r.Body).Decode(&employee)\n  if err != nil \n  {\n    log.Print(\"error occurred while decoding employee \n    data :: \", err)\n    return\n  }\n  log.Printf(\"adding employee id :: %s with firstName \n  as :: %s and lastName as :: %s \", employee.Id, \n  employee.FirstName, employee.LastName)\n  employees = append(employees, Employee{Id: employee.Id, \n  FirstName: employee.FirstName, LastName: employee.LastName})\n  json.NewEncoder(w).Encode(employees)\n}\nfunc AddRoutes(router *mux.Router) *mux.Router \n{\n  for _, route := range routes \n  {\n    router.\n    Methods(route.Method).\n    Path(route.Pattern).\n    Name(route.Name).\n    Handler(route.HandlerFunc)\n  }\n  return router\n}\nfunc main() \n{\n  muxRouter := mux.NewRouter().StrictSlash(true)\n  router := AddRoutes(muxRouter)\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-rest-delete.go\n```", "```go\n$ curl -H \"Content-Type: application/json\" -X DELETE -d '{\"Id\":\"1\", \"firstName\": \"Foo\", \"lastName\": \"Bar\"}' http://localhost:8080/employee/delete\n```", "```go\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"strings\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype Route struct \n{\n  Name string\n  Method string\n  Pattern string\n  HandlerFunc http.HandlerFunc\n}\ntype Routes []Route\nvar routes = Routes\n{\n  Route\n  {\n    \"getEmployees\",\n    \"GET\",\n    \"/employees\",\n    getEmployees,\n  },\n}\ntype Employee struct \n{\n  Id string `json:\"id\"`\n  FirstName string `json:\"firstName\"`\n  LastName string `json:\"lastName\"`\n}\ntype Employees []Employee\nvar employees []Employee\nvar employeesV1 []Employee\nvar employeesV2 []Employee\nfunc init() \n{\n  employees = Employees\n  {\n    Employee{Id: \"1\", FirstName: \"Foo\", LastName: \"Bar\"},\n  }\n  employeesV1 = Employees\n  {\n    Employee{Id: \"1\", FirstName: \"Foo\", LastName: \"Bar\"},\n    Employee{Id: \"2\", FirstName: \"Baz\", LastName: \"Qux\"},\n  }\n  employeesV2 = Employees\n  {\n    Employee{Id: \"1\", FirstName: \"Baz\", LastName: \"Qux\"},\n    Employee{Id: \"2\", FirstName: \"Quux\", LastName: \"Quuz\"},\n  }\n}\nfunc getEmployees(w http.ResponseWriter, r *http.Request) \n{\n  if strings.HasPrefix(r.URL.Path, \"/v1\") \n  {\n    json.NewEncoder(w).Encode(employeesV1)\n  } \n  else if strings.HasPrefix(r.URL.Path, \"/v2\") \n  {\n    json.NewEncoder(w).Encode(employeesV2)\n  } \n  else \n  {\n    json.NewEncoder(w).Encode(employees)\n  }\n}\nfunc AddRoutes(router *mux.Router) *mux.Router \n{\n  for _, route := range routes \n  {\n    router.\n    Methods(route.Method).\n    Path(route.Pattern).\n    Name(route.Name).\n    Handler(route.HandlerFunc)\n  }\n  return router\n}\nfunc main() \n{\n  muxRouter := mux.NewRouter().StrictSlash(true)\n  router := AddRoutes(muxRouter)\n  // v1\n  AddRoutes(muxRouter.PathPrefix(\"/v1\").Subrouter())\n  // v2\n  AddRoutes(muxRouter.PathPrefix(\"/v2\").Subrouter())\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-rest-versioning.go\n```", "```go\n$ curl -X GET http://localhost:8080/v1/employees\n[{\"id\":\"1\",\"firstName\":\"Foo\",\"lastName\":\"Bar\"},{\"id\":\"2\",\"firstName\":\"Baz\",\"lastName\":\"Qux\"}]\n```", "```go\n$ curl -X GET http://localhost:8080/v2/employees\n [{\"id\":\"1\",\"firstName\":\"Baz\",\"lastName\":\"Qux\"},{\"id\":\"2\",\"firstName\":\"Quux\",\"lastName\":\"Quuz\"}]\n```", "```go\n$ curl -X GET http://localhost:8080/employees\n [{\"id\":\"1\",\"firstName\":\"Foo\",\"lastName\":\"Bar\"}]\n```", "```go\n$ go run http-rest-get.go\n```", "```go\n$ curl -X GET http://localhost:8080/employees\n```", "```go\n[{\"id\":\"1\",\"firstName\":\"Foo\",\"lastName\":\"Bar\"},{\"id\":\"2\",\"firstName\":\"Baz\",\"lastName\":\"Qux\"}]\n```", "```go\n$ go get github.com/gorilla/mux\n$ go get -u gopkg.in/resty.v1\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/mux\"\n  resty \"gopkg.in/resty.v1\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8090\"\n)\nconst WEB_SERVICE_HOST string = \"http://localhost:8080\"\ntype Employee struct \n{\n  Id string `json:\"id\"`\n  FirstName string `json:\"firstName\"`\n  LastName string `json:\"lastName\"`\n}\nfunc getEmployees(w http.ResponseWriter, r *http.Request) \n{\n  response, err := resty.R().Get(WEB_SERVICE_HOST + \n  \"/employees\")\n  if err != nil \n  {\n    log.Print(\"error getting data from the web service :: \", err)\n    return\n  }\n  printOutput(response, err)\n  fmt.Fprintf(w, response.String())\n}\nfunc addEmployee(w http.ResponseWriter, r *http.Request) \n{\n  employee := Employee{}\n  decodingErr := json.NewDecoder(r.Body).Decode(&employee)\n  if decodingErr != nil \n  {\n    log.Print(\"error occurred while decoding employee \n    data :: \", decodingErr)\n    return\n  }\n  log.Printf(\"adding employee id :: %s with firstName \n  as :: %s and lastName as :: %s \", employee.Id, \n  employee.FirstName, employee.LastName)\n  response, err := resty.R().\n  SetHeader(\"Content-Type\", \"application/json\").\n  SetBody(Employee{Id: employee.Id, FirstName: \n  employee.FirstName, LastName: employee.LastName}).\n  Post(WEB_SERVICE_HOST + \"/employee/add\")\n  if err != nil \n  {\n    log.Print(\"error occurred while adding employee :: \", err)\n    return\n  }\n  printOutput(response, err)\n  fmt.Fprintf(w, response.String())\n}\nfunc updateEmployee(w http.ResponseWriter, r *http.Request) \n{\n  employee := Employee{}\n  decodingErr := json.NewDecoder(r.Body).Decode(&employee)\n  if decodingErr != nil \n  {\n    log.Print(\"error occurred while decoding employee \n    data :: \", decodingErr)\n    return\n  }\n  log.Printf(\"updating employee id :: %s with firstName \n  as :: %s and lastName as :: %s \", employee.Id, \n  employee.FirstName, employee.LastName)\n  response, err := resty.R().\n  SetBody(Employee{Id: employee.Id, FirstName: \n  employee.FirstName, LastName: employee.LastName}).\n  Put(WEB_SERVICE_HOST + \"/employee/update\")\n  if err != nil \n  {\n    log.Print(\"error occurred while updating employee :: \", err)\n    return\n  }\n  printOutput(response, err)\n  fmt.Fprintf(w, response.String())\n}\nfunc deleteEmployee(w http.ResponseWriter, r *http.Request) \n{\n  employee := Employee{}\n  decodingErr := json.NewDecoder(r.Body).Decode(&employee)\n  if decodingErr != nil \n  {\n    log.Print(\"error occurred while decoding employee \n    data :: \", decodingErr)\n    return\n  }\n  log.Printf(\"deleting employee id :: %s with firstName \n  as :: %s and lastName as :: %s \", employee.Id, \n  employee.FirstName, employee.LastName)\n  response, err := resty.R().\n  SetBody(Employee{Id: employee.Id, FirstName: \n  employee.FirstName, LastName: employee.LastName}).\n  Delete(WEB_SERVICE_HOST + \"/employee/delete\")\n  if err != nil \n  {\n    log.Print(\"error occurred while deleting employee :: \", err)\n    return\n  }\n  printOutput(response, err)\n  fmt.Fprintf(w, response.String())\n}\nfunc printOutput(resp *resty.Response, err error) \n{\n  log.Println(resp, err)\n}\nfunc main() \n{\n  router := mux.NewRouter().StrictSlash(false)\n  router.HandleFunc(\"/employees\", getEmployees).Methods(\"GET\")\n  employee := router.PathPrefix(\"/employee\").Subrouter()\n  employee.HandleFunc(\"/add\", addEmployee).Methods(\"POST\")\n  employee.HandleFunc(\"/update\", updateEmployee).Methods(\"PUT\")\n  employee.HandleFunc(\"/delete\", deleteEmployee).Methods(\"DELETE\")\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-rest-client.go\n```", "```go\n$ curl -X GET http://localhost:8090/employees\n [{\"id\":\"1\",\"firstName\":\"Foo\",\"lastName\":\"Bar\"},{\"id\":\"2\",\"firstName\":\"Baz\",\"lastName\":\"Qux\"}]\n```", "```go\n$ go run http-rest-post.go\n```", "```go\n$ curl -H \"Content-Type: application/json\" -X POST -d '{\"Id\":\"3\", \"firstName\":\"Quux\", \"lastName\":\"Corge\"}' http://localhost:8090/employee/add [{\"id\":\"1\",\"firstName\":\"Foo\",\"lastName\":\"Bar\"},{\"id\":\"2\",\"firstName\":\"Baz\",\"lastName\":\"Qux\"},{\"id\":\"3\",\"firstName\":\"Quux\",\"lastName\":\"Corge\"}]\n```", "```go\n$ npm install -g @angular/cli\n```", "```go\n$ ng new angularjs-client\n```", "```go\n$ cd angularjs-client && touch server.go\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype Route struct \n{\n  Name string\n  Method string\n  Pattern string\n  HandlerFunc http.HandlerFunc\n}\ntype Routes []Route\nvar routes = Routes\n{\n  Route\n  {\n    \"getEmployees\",\n    \"GET\",\n    \"/employees\",\n    getEmployees,\n  },\n  Route\n  {\n    \"addEmployee\",\n    \"POST\",\n    \"/employee/add\",\n    addEmployee,\n  },\n}\ntype Employee struct \n{\n  Id string `json:\"id\"`\n  FirstName string `json:\"firstName\"`\n  LastName string `json:\"lastName\"`\n}\ntype Employees []Employee\nvar employees []Employee\nfunc init() \n{\n  employees = Employees\n  {\n    Employee{Id: \"1\", FirstName: \"Foo\", LastName: \"Bar\"},\n    Employee{Id: \"2\", FirstName: \"Baz\", LastName: \"Qux\"},\n  }\n}\nfunc getEmployees(w http.ResponseWriter, r *http.Request) \n{\n  json.NewEncoder(w).Encode(employees)\n}\nfunc addEmployee(w http.ResponseWriter, r *http.Request) \n{\n  employee := Employee{}\n  err := json.NewDecoder(r.Body).Decode(&employee)\n  if err != nil \n  {\n    log.Print(\"error occurred while decoding employee \n    data :: \", err)\n    return\n  }\n  log.Printf(\"adding employee id :: %s with firstName \n  as :: %s and lastName as :: %s \", employee.Id, \n  employee.FirstName, employee.LastName)\n  employees = append(employees, Employee{Id: employee.Id, \n  FirstName: employee.FirstName, LastName: employee.LastName})\n  json.NewEncoder(w).Encode(employees)\n}\nfunc AddRoutes(router *mux.Router) *mux.Router \n{\n  for _, route := range routes \n  {\n    router.\n    Methods(route.Method).\n    Path(route.Pattern).\n    Name(route.Name).\n    Handler(route.HandlerFunc)\n  }\n  return router\n}\nfunc main() \n{\n  muxRouter := mux.NewRouter().StrictSlash(true)\n  router := AddRoutes(muxRouter)\n  router.PathPrefix(\"/\").Handler(http.FileServer\n  (http.Dir(\"./dist/\")))\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ cd src/app/ && mkdir models && mkdir services && cd models && touch employee.ts && cd ../services && touch employee.service.ts\n```", "```go\nexport class Employee \n{\n  constructor\n  (\n    public id: string,\n    public firstName: string,\n    public lastName: string\n  ) {}\n}\n```", "```go\nimport { Injectable } from '@angular/core';\nimport { Http, Response, Headers, RequestOptions } from '@angular/http';\nimport { Observable } from 'rxjs/Rx';\nimport { Employee } from \"app/models/employee\";\n\n@Injectable()\nexport class EmployeeService \n{\n  constructor(private http: Http) { }\n  getEmployees(): Observable<Employee[]> \n  {\n    return this.http.get(\"http://localhost:8080/employees\")\n    .map((res: Response) => res.json())\n    .catch((error: any) => Observable.throw(error.json().\n    error || 'Server error'));\n  }\n  addEmployee(employee: Employee): Observable<Employee> \n  {\n    let headers = new Headers({ 'Content-Type': \n    'application/json' });\n    let options = new RequestOptions({ headers: headers });\n    return this.http.post(\"http://localhost:8080/employee\n    /add\", employee, options)\n    .map(this.extractData)\n    .catch(this.handleErrorObservable);\n  }\n  private extractData(res: Response) \n  {\n    let body = res.json();\n    return body || {};\n  }\n  private handleErrorObservable(error: Response | any) \n  {\n    console.error(error.message || error);\n    return Observable.throw(error.message || error);\n  }\n}\n```", "```go\n<div class = \"container\" style=\"padding:5px\">\n  <form>\n    <div class = \"form-group\">\n      <label for = \"id\">ID</label>\n      <input type = \"text\" class = \"form-control\" id = \"id\" \n      required [(ngModel)] = \"employee.id\" name = \"id\">\n    </div>\n    <div class = \"form-group\">\n      <label for = \"firstName\">FirstName</label>\n      <input type = \"text\" class = \"form-control\" id = \n      \"firstName\" [(ngModel)] = \"employee.firstName\" name =\n      \"firstName\">\n    </div>\n    <div class = \"form-group\">\n      <label for = \"lastName\">LastName</label>\n      <input type = \"text\" class = \"form-control\" id = \n      \"lastName\" [(ngModel)] = \"employee.lastName\" name =\n      \"lastName\">\n    </div>\n    <div>\n      <button (click)=\"addEmployee()\">Add</button>\n    </div>\n  </form>\n</div>\n<table>\n  <thead>\n    <th>ID</th>\n    <th>FirstName</th>\n    <th>LastName</th>\n  </thead>\n  <tbody>\n    <tr *ngFor=\"let employee of employees\">\n      <td>{{employee.id}}</td>\n      <td>{{employee.firstName}}</td>\n      <td>{{employee.lastName}}</td>\n    </tr>\n  </tbody>\n</table>\n```", "```go\nimport { Component, OnInit } from '@angular/core';\nimport { EmployeeService } from \"app/services/employee.service\";\nimport { Employee } from './models/employee';\n\n@Component\n({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n})\nexport class AppComponent implements OnInit \n{\n  title = 'app';\n  employee = new Employee('', '', '');\n  employees;\n  constructor(private employeeService: EmployeeService) { }\n  ngOnInit(): void \n  {\n    this.getEmployees();\n  }\n  getEmployees(): void \n  {\n    this.employeeService.getEmployees()\n    .subscribe(employees => this.employees = employees);\n  }\n  addEmployee(): void \n  {\n    this.employeeService.addEmployee(this.employee)\n    .subscribe\n    (\n      employee => \n      {\n        this.getEmployees();\n        this.reset();\n      }\n    );\n  }\n  private reset() \n  {\n    this.employee.id = null;\n    this.employee.firstName = null;\n    this.employee.lastName = null;\n  }\n}\n```", "```go\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { HttpModule } from '@angular/http';\nimport { AppComponent } from './app.component';\nimport { EmployeeService } from \"app/services/employee.service\";\nimport { FormsModule } from '@angular/forms';\n\n@NgModule\n({\n declarations: \n [\n   AppComponent\n ],\n imports: \n [\n   BrowserModule, HttpModule, FormsModule\n ],\n providers: [EmployeeService],\n bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```", "```go\n$ ng build\n$ go run server.go\n```", "```go\n$ mkdir reactjs-client && cd reactjs-client && touch server.go\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype Route struct \n{\n  Name string\n  Method string\n  Pattern string\n  HandlerFunc http.HandlerFunc\n}\ntype Routes []Route\nvar routes = Routes\n{\n  Route\n  {\n    \"getEmployees\",\n    \"GET\",\n    \"/employees\",\n    getEmployees,\n  },\n  Route\n  {\n    \"addEmployee\",\n    \"POST\",\n    \"/employee/add\",\n    addEmployee,\n  },\n}\ntype Employee struct \n{\n  Id string `json:\"id\"`\n  FirstName string `json:\"firstName\"`\n  LastName string `json:\"lastName\"`\n}\ntype Employees []Employee\nvar employees []Employee\nfunc init() \n{\n  employees = Employees\n  {\n    Employee{Id: \"1\", FirstName: \"Foo\", LastName: \"Bar\"},\n    Employee{Id: \"2\", FirstName: \"Baz\", LastName: \"Qux\"},\n  }\n}\nfunc getEmployees(w http.ResponseWriter, r *http.Request) \n{\n  json.NewEncoder(w).Encode(employees)\n}\nfunc addEmployee(w http.ResponseWriter, r *http.Request) \n{\n  employee := Employee{}\n  err := json.NewDecoder(r.Body).Decode(&employee)\n  if err != nil \n  {\n    log.Print(\"error occurred while decoding employee \n    data :: \", err)\n    return\n  }\n  log.Printf(\"adding employee id :: %s with firstName \n  as :: %s and lastName as :: %s \", employee.Id, \n  employee.FirstName, employee.LastName)\n  employees = append(employees, Employee{Id: employee.Id, \n  FirstName: employee.FirstName, LastName: employee.LastName})\n  json.NewEncoder(w).Encode(employees)\n}\nfunc AddRoutes(router *mux.Router) *mux.Router \n{\n  for _, route := range routes \n  {\n    router.\n    Methods(route.Method).\n    Path(route.Pattern).\n    Name(route.Name).\n    Handler(route.HandlerFunc)\n  }\n  return router\n}\nfunc main() \n{\n  muxRouter := mux.NewRouter().StrictSlash(true)\n  router := AddRoutes(muxRouter)\n  router.PathPrefix(\"/\").Handler(http.FileServer\n  (http.Dir(\"./assets/\")))\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ mkdir assets && cd assets && touch index.html\n```", "```go\n<html>\n  <head lang=\"en\">\n    <meta charset=\"UTF-8\" />\n    <title>ReactJS Client</title>\n  </head> \n  <body>\n    <div id=\"react\"></div>\n    <script src=\"img/script.js\"></script>\n```", "```go\n  </body>\n</html>\n```", "```go\n$ cd reactjs-client && touch npm init\n```", "```go\n{\n  \"name\": \"reactjs-client\",\n  \"version\": \"1.0.0\",\n  \"description\": \"ReactJs Client\",\n  \"keywords\": \n  [\n    \"react\"\n  ],\n  \"author\": \"Arpit Aggarwal\",\n  \"dependencies\": \n  {\n    \"axios\": \"^0.18.0\",\n    \"react\": \"^16.2.0\",\n    \"react-dom\": \"^16.2.0\",\n    \"react-router-dom\": \"^4.2.2\",\n    \"webpack\": \"^4.2.0\",\n    \"webpack-cli\": \"^2.0.9\",\n    \"lodash\": \"^4.17.5\"\n  },\n  \"scripts\": \n  {\n    \"build\": \"webpack\",\n    \"watch\": \"webpack --watch -d\"\n  },\n  \"devDependencies\": \n  {\n    \"babel-core\": \"^6.18.2\",\n    \"babel-loader\": \"^7.1.4\",\n    \"babel-polyfill\": \"^6.16.0\",\n    \"babel-preset-es2015\": \"^6.18.0\",\n    \"babel-preset-react\": \"^6.16.0\"\n  }\n}\n```", "```go\n$ cd reactjs-client && touch webpack.config.js\n```", "```go\nvar path = require('path');\nmodule.exports = \n{\n  resolve: \n  {\n    extensions: ['.js', '.jsx']\n  },\n  mode: 'development',\n  entry: './app/main.js',\n  cache: true,\n  output: \n  {\n    path: __dirname,\n    filename: './assets/script.js'\n  },\n  module: \n  {\n    rules: \n    [\n      {\n        test: path.join(__dirname, '.'),\n        exclude: /(node_modules)/,\n        loader: 'babel-loader',\n        query: \n        {\n          cacheDirectory: true,\n          presets: ['es2015', 'react']\n        }\n      }\n    ]\n  }\n};\n```", "```go\n$ cd reactjs-client && mkdir app && cd app && touch main.js\n```", "```go\n'use strict';\nconst React = require('react');\nconst ReactDOM = require('react-dom')\nimport EmployeeApp from './components/employee-app.jsx'\nReactDOM.render\n(\n  <EmployeeApp />,\n  document.getElementById('react')\n)\n```", "```go\n$ cd reactjs-client && mkdir components && cd components && touch react-app.jsx employee-list.jsx employee.jsx add-employee.jsx\n```", "```go\n'use strict';\nconst React = require('react');\nvar axios = require('axios');\nimport EmployeeList from './employee-list.jsx'\nimport AddEmployee from './add-employee.jsx'\nexport default class EmployeeApp extends React.Component \n{\n  constructor(props) \n  {\n    super(props);\n    this.state = {employees: []};\n    this.addEmployee = this.addEmployee.bind(this);\n    this.Axios = axios.create\n    (\n      {\n        headers: {'content-type': 'application/json'}\n      }\n    );\n  }\n  componentDidMount() \n  {\n    let _this = this;\n    this.Axios.get('/employees')\n    .then\n    (\n      function (response) \n      {\n        _this.setState({employees: response.data});\n      }\n    )\n    .catch(function (error) { });\n  }\n  addEmployee(employeeName)\n  {\n    let _this = this;\n    this.Axios.post\n    (\n      '/employee/add', \n      {\n        firstName: employeeName\n      }\n    )\n    .then\n    (\n      function (response) \n      {\n        _this.setState({employees: response.data});\n      }\n    )\n    .catch(function (error) { });\n    }\n    render() \n    {\n      return \n      (\n        <div>\n          <AddEmployee addEmployee={this.addEmployee}/>\n          <EmployeeList employees={this.state.employees}/>\n        </div>\n      )\n   }\n}\n```", "```go\nconst React = require('react');\nexport default class Employee extends React.Component\n{\n  render() \n  {\n    return \n    (\n      <tr>\n        <td>{this.props.employee.firstName}</td>\n      </tr>\n    )\n  }\n}\n\n```", "```go\nconst React = require('react');\nimport Employee from './employee.jsx'\nexport default class EmployeeList extends React.Component\n{\n  render() \n  {\n    var employees = this.props.employees.map\n    (\n      (employee, i) =>\n      <Employee key={i} employee={employee}/>\n    );\n    return \n    (\n      <table>\n        <tbody>\n          <tr>\n            <th>FirstName</th>\n          </tr>\n          {employees}\n        </tbody>\n      </table>\n    )\n  }\n}\n```", "```go\nimport React, { Component, PropTypes } from 'react'\nexport default class AddEmployee extends React.Component \n{\n  render()\n  {\n    return \n    (\n      <div>\n        <input type = 'text' ref = 'input' />\n        <button onClick = {(e) => this.handleClick(e)}>\n          Add\n        </button>\n      </div>\n    )\n  }\n  handleClick(e) \n  {\n    const node = this.refs.input\n    const text = node.value.trim()\n    this.props.addEmployee(text)\n    node.value = ''\n  }\n}\n```", "```go\n$ npm install\n$ npm run build\n```", "```go\n$ go run server.go\n```", "```go\n$ curl -X GET http://localhost:8080/employees\n```", "```go\n[{\"id\":\"1\",\"firstName\":\"Foo\",\"lastName\":\"Bar\"},{\"id\":\"2\",\"firstName\":\"Baz\",\"lastName\":\"Qux\"},{\"id\":\"\",\"firstName\":\"Arpit\",\"lastName\":\"\"}]\n```", "```go\n$ mkdir vuejs-client && cd vuejs-client && touch server.go\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype Route struct \n{\n  Name string\n  Method string\n  Pattern string\n  HandlerFunc http.HandlerFunc\n}\ntype Routes []Route\nvar routes = Routes\n{\n  Route\n  {\n    \"getEmployees\",\n    \"GET\",\n    \"/employees\",\n    getEmployees,\n  },\n  Route\n  {\n    \"addEmployee\",\n    \"POST\",\n    \"/employee/add\",\n    addEmployee,\n  },\n}\ntype Employee struct \n{\n  Id string `json:\"id\"`\n  FirstName string `json:\"firstName\"`\n  LastName string `json:\"lastName\"`\n}\ntype Employees []Employee\nvar employees []Employee\nfunc init() \n{\n  employees = Employees\n  {\n    Employee{Id: \"1\", FirstName: \"Foo\", LastName: \"Bar\"},\n    Employee{Id: \"2\", FirstName: \"Baz\", LastName: \"Qux\"},\n  }\n}\nfunc getEmployees(w http.ResponseWriter, r *http.Request) \n{\n  json.NewEncoder(w).Encode(employees)\n}\nfunc addEmployee(w http.ResponseWriter, r *http.Request) \n{\n  employee := Employee{}\n  err := json.NewDecoder(r.Body).Decode(&employee)\n  if err != nil \n  {\n    log.Print(\"error occurred while decoding employee \n    data :: \", err)\n    return\n  }\n  log.Printf(\"adding employee id :: %s with firstName \n  as :: %s and lastName as :: %s \", employee.Id, \n  employee.FirstName, employee.LastName)\n  employees = append(employees, Employee{Id: employee.Id, \n  FirstName: employee.FirstName, LastName: employee.LastName})\n  json.NewEncoder(w).Encode(employees)\n}\nfunc AddRoutes(router *mux.Router) *mux.Router \n{\n  for _, route := range routes \n  {\n    router.\n    Methods(route.Method).\n    Path(route.Pattern).\n    Name(route.Name).\n    Handler(route.HandlerFunc)\n  }\n  return router\n}\nfunc main() \n{\n  muxRouter := mux.NewRouter().StrictSlash(true)\n  router := AddRoutes(muxRouter)\n  router.PathPrefix(\"/\").Handler(http.FileServer\n  (http.Dir(\"./assets/\")))\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ mkdir assets && cd assets && touch index.html && touch main.js\n```", "```go\n<html>\n  <head>\n    <title>VueJs Client</title>\n    <script type = \"text/javascript\" src = \"https://cdnjs.\n    cloudflare.com/ajax/libs/vue/2.4.0/vue.js\"></script>\n    <script type = \"text/javascript\" src=\"img/vue-resource@1.5.0\"></script>\n  </head>\n  <body>\n    <div id = \"form\">\n      <h1>{{ message }}</h1>\n      <table>\n        <tr>\n          <td><label for=\"id\">Id</label></td>\n          <td><input type=\"text\" value=\"\" v-model=\"id\"/></td>\n        </tr>\n        <tr>\n          <td><label for=\"firstName\">FirstName</label></td>\n          <td><input type=\"text\" value=\"\" v-model=\"firstName\"/>\n          <td>\n        </tr>\n        <tr>\n          <td><label for=\"lastName\">LastName</label></td>\n          <td> <input type=\"text\" value=\"\" v-model=\"lastName\" />\n          </td>\n        </tr>\n        <tr>\n          <td><a href=\"#\" class=\"btn\" @click=\"addEmployee\">Add\n          </a></td>\n        </tr>\n      </table>\n    </div>\n    <script type = \"text/javascript\" src = \"main.js\"></script>\n  </body>\n</html>\n```", "```go\nvar vue_det = new Vue\n({\n el: '#form',\n data: \n {\n   message: 'Employee Dashboard',\n   id: '',\n   firstName:'',\n   lastName:''\n },\n methods: \n {\n   addEmployee: function() \n   {\n     this.$http.post\n     (\n       '/employee/add', \n       {\n         id: this.id,\n         firstName:this.firstName,\n         lastName:this.lastName\n       }\n     )\n     .then\n     (\n       response => \n       {\n         console.log(response);\n       }, \n       error => \n       {\n         console.error(error);\n       }\n     );\n   }\n }\n});\n```", "```go\n$ go run server.go\n```", "```go\n$ curl -X GET http://localhost:8080/employees\n```", "```go\n[{\"id\":\"1\",\"firstName\":\"Foo\",\"lastName\":\"Bar\"},{\"id\":\"2\",\"firstName\":\"Baz\",\"lastName\":\"Qux\"},{\"id\":\"5\",\"firstName\":\"Arpit\",\"lastName\":\"Aggarwal\"}]\n```"]