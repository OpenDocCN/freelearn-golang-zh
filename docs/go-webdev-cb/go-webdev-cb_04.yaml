- en: Writing and Consuming RESTful Web Services in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中编写和使用RESTful Web服务
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Creating your first HTTP GET method
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个HTTP GET方法
- en: Creating your first HTTP POST method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个HTTP POST方法
- en: Creating your first HTTP PUT method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个HTTP PUT方法
- en: Creating your first HTTP DELETE method
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个HTTP DELETE方法
- en: Versioning your REST API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的REST API进行版本控制
- en: Creating your first REST client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个REST客户端
- en: Creating your first AngularJS client
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个AngularJS客户端
- en: Creating your first ReactJS client
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个ReactJS客户端
- en: Creating your first VueJS client
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个VueJS客户端
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Whenever we build a web application that encapsulates logic that could be helpful
    to other related applications, we will often also write and consume web services.
    This is because they expose functionality over a network, which is accessible
    through the HTTP protocol, making an application a single source of truth.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们构建一个封装了对其他相关应用有帮助的逻辑的Web应用程序时，我们通常也会编写和使用Web服务。这是因为它们通过网络公开功能，可以通过HTTP协议访问，使应用程序成为唯一的真相来源。
- en: In this chapter, we will write a RESTful API that supports `GET`, `POST`, `PUT`,
    and `DELETE` HTTP methods, and then we will learn how we can version the REST
    API, which is very helpful when we are creating APIs consumed publicly. We will
    finish up with writing the REST client to consume them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个支持`GET`，`POST`，`PUT`和`DELETE` HTTP方法的RESTful API，然后我们将学习如何对REST
    API进行版本控制，这在我们创建公开使用的API时非常有帮助。最后，我们将编写REST客户端来消耗它们。
- en: Creating your first HTTP GET method
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个HTTP GET方法
- en: While writing web applications, we often have to expose our services to the
    client or to the UI so that they can consume a piece of code running on a different
    system. Exposing the service can be done with HTTP protocol methods. Out of the
    many HTTP methods, we will be learning to implement the HTTP `GET` method in this
    recipe.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Web应用程序时，我们经常需要将我们的服务暴露给客户端或UI，以便它们可以消耗在不同系统上运行的代码。通过HTTP协议方法可以暴露服务。在许多HTTP方法中，我们将学习在本教程中实现HTTP
    `GET`方法。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install the `github.com/gorilla/mux` package using the `go get` command, as
    follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/gorilla/mux`包，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create `http-rest-get.go` where we will define two routes—`/employees` and
    `/employee/{id}` along with their handlers. The former writes the static array
    of employees and the latter writes employee details for the provided ID to an
    HTTP response stream, as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-rest-get.go`，在其中我们将定义两个路由—`/employees`和`/employee/{id}`以及它们的处理程序。前者写入员工的静态数组，后者将为提供的ID写入相应ID的员工详情到HTTP响应流，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the program with the following command:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we run the program, the HTTP server will start locally listening on port `8080`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`上启动。
- en: 'Next, executing a `GET` request from the command line as follows will give
    you a list of all the employees:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从命令行执行`GET`请求如下将给你一个员工列表：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, executing a `GET` request for a particular employee ID from the command
    line as follows, will give you the employee details for the corresponding ID:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，从命令行执行`GET`请求获取特定员工ID，将为你提供相应ID的员工详情：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s understand the program we have written:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们编写的程序：
- en: We used `import ("encoding/json" "log" "net/http" "strconv" "github.com/gorilla/mux")`.
    Here, we imported `github.com/gorilla/mux` to create a `Gorilla Mux Router`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了`import ("encoding/json" "log" "net/http" "strconv" "github.com/gorilla/mux")`。在这里，我们导入了`github.com/gorilla/mux`来创建一个`Gorilla
    Mux Router`。
- en: Next, we declared the `Route` struct type with four fields—`Name`, `Method`,
    `Pattern`, and `HandlerFunc`, where `Name` represents the name of an HTTP method,
    `Method` represents the HTTP method type which can be `GET`, `POST`, `PUT`, `DELETE`,
    and so on, `Pattern` represents the URL path, and `HandlerFunc` represents the
    HTTP handler.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们声明了`Route`结构类型，具有四个字段—`Name`，`Method`，`Pattern`和`HandlerFunc`，其中`Name`表示HTTP方法的名称，`Method`表示HTTP方法类型，可以是`GET`，`POST`，`PUT`，`DELETE`等，`Pattern`表示URL路径，`HandlerFunc`表示HTTP处理程序。
- en: 'Next, we defined two routes for the `GET` request, as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为`GET`请求定义了两个路由，如下：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we defined a static `Employees` array, as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个静态的`Employees`数组，如下：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, we defined two handlers—`getEmployees` and `getEmployee` where the former
    just marshals a static array of employees and writes it to an HTTP response stream,
    and the latter gets the employee ID from an HTTP request variable, fetches the
    employee for the corresponding ID from the array, marshals the object, and writes
    it to an HTTP response stream.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了两个处理程序—`getEmployees`和`getEmployee`，前者只是将员工的静态数组编组并将其写入HTTP响应流，后者从HTTP请求变量获取员工ID，从数组中获取相应ID的员工，编组对象，并将其写入HTTP响应流。
- en: Following the handlers, we defined an `AddRoutes` function, which iterates over
    the routes array we defined, adds it to the `gorilla/mux` router, and returns
    the `Router` object.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理程序之后，我们定义了一个`AddRoutes`函数，它遍历我们定义的路由数组，将其添加到`gorilla/mux`路由器，并返回`Router`对象。
- en: Finally, we defined `main()` where we create a `gorilla/mux` router instance
    using the `NewRouter()` handler with the trailing slash behavior for new routes
    as true, which means the application will always see the path as specified in
    the route. For example, if the route path is `/path/`, accessing `/path` will
    redirect to the former and vice versa.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了`main()`，在其中使用`NewRouter()`处理程序创建了一个`gorilla/mux`路由器实例，对于新路由的尾部斜杠行为为true，这意味着应用程序将始终将路径视为路由中指定的路径。例如，如果路由路径是`/path/`，访问`/path`将重定向到前者，反之亦然。
- en: Creating your first HTTP POST method
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个HTTP POST方法
- en: Whenever we have to send data to the server either through an asynchronous call
    or through an HTML form, then we go with the HTTP `POST` method implementation,
    which we will cover in this recipe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要通过异步调用或HTML表单将数据发送到服务器时，我们使用HTTP `POST`方法的实现，这将在本教程中介绍。
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install the `github.com/gorilla/mux` package using the `go get` command, as
    follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装`github.com/gorilla/mux`包，如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create `http-rest-post.go` where we will define an additional route that supports
    the HTTP `POST` method and a handler that adds an employee to the initial static
    array of employees and writes the updated list to an HTTP response stream, as
    follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-rest-post.go`，在其中我们将定义一个支持HTTP `POST`方法的附加路由和一个处理程序，该处理程序将员工添加到初始静态数组的员工，并将更新后的列表写入HTTP响应流，如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the program with the following command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，HTTP服务器将在本地监听端口`8080`。
- en: 'Next, executing a `POST` request from the command line as follows will add
    an employee to the list with `ID` as `3` and return the list of employees as a
    response:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令从命令行执行`POST`请求将员工添加到具有`ID`为`3`的列表，并将员工列表作为响应返回：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is shown in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以下截图中看到：
- en: '![](img/50fb9970-5845-4bfe-b5b9-a9145541375d.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50fb9970-5845-4bfe-b5b9-a9145541375d.png)'
- en: 'Let’s understand the change we introduced in this recipe:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解本节中引入的更改：
- en: First, we added another route with the name `addEmployee` that executes the
    `addEmployee` handler for every `POST` request for the URL pattern `/employee/add`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加了另一个名为`addEmployee`的路由，该路由为URL模式`/employee/add`的每个`POST`请求执行`addEmployee`处理程序。
- en: Then, we defined an `addEmployee` handler, which basically decodes the employee
    data that comes as part of a `POST` request using the `NewDecoder` handler of
    the built-in `encoding/json` package of Go, appends it to the initial static array
    of an employee, and writes it to an HTTP response stream.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个`addEmployee`处理程序，它基本上解码了作为`POST`请求的一部分传递的员工数据，使用Go的内置`encoding/json`包的`NewDecoder`处理程序将其附加到员工的初始静态数组，并将其写入HTTP响应流。
- en: Creating your first HTTP PUT method
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个HTTP PUT方法
- en: Whenever we want to update a record that we have created earlier or want to
    create a new record if it does not exist, often termed an **Upsert,** then we
    go with the HTTP `PUT` method implementation, which we will cover in this recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要更新我们之前创建的记录或者如果记录不存在则创建新记录，通常称为**Upsert**，我们就会使用HTTP `PUT`方法的实现，我们将在本节中介绍。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'Install the `github.com/gorilla/mux` package using the `go get` command, as
    follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/gorilla/mux`包，如下所示：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create `http-rest-put.go` where we will define an additional route that supports
    the HTTP `PUT` method and a handler that either updates the employee details for
    the provided ID or adds an employee to the initial static array of employees;
    if the ID does not exist, marshal it to the JSON, and write it to an HTTP response
    stream, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-rest-put.go`，在其中我们将定义一个支持HTTP `PUT`方法的附加路由和一个处理程序，该处理程序要么更新提供的ID的员工详细信息，要么将员工添加到初始静态数组的员工；如果ID不存在，则将其编组为JSON，并将其写入HTTP响应流，如下所示：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the program with the following command:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，HTTP服务器将在本地监听端口`8080`。
- en: 'Next, executing a `PUT` request from the command line as follows, will update
    the `firstName` and the `lastName` for an employee with ID `1`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令从命令行执行`PUT`请求，将为具有ID `1`的员工更新`firstName`和`lastName`：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This can be seen in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以下截图中看到：
- en: '![](img/35526607-03fd-4d3b-80a1-77bcdf89de43.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35526607-03fd-4d3b-80a1-77bcdf89de43.png)'
- en: 'If we execute a `PUT` request for an employee with ID `3` from the command
    line as follows, it will add another employee to the array, as there is no employee
    with ID 3, demonstrating the upsert scenario:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从命令行执行`PUT`请求，为具有ID `3`的员工添加另一个员工到数组中，因为没有ID为3的员工，这演示了upsert场景：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This can be seen in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以下截图中看到：
- en: '![](img/e7a429b0-4bb7-4fc3-a4f1-ab29b4540853.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7a429b0-4bb7-4fc3-a4f1-ab29b4540853.png)'
- en: 'Let’s understand the change we introduced in this recipe:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解本节中引入的更改：
- en: First, we added another route with the name `updateEmployee`, which executes
    the `updateEmployee` handler for every `PUT` request for the URL pattern `/employee/update`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加了另一个名为`updateEmployee`的路由，该路由为URL模式`/employee/update`的每个`PUT`请求执行`updateEmployee`处理程序。
- en: Then, we defined an `updateEmployee` handler, which basically decodes the employee
    data that comes as part of a `PUT` request using the `NewDecoder` handler of the
    built-in `encoding/json` package of Go, iterates over the employees array to know
    whether the employee ID requested exists in the initial static array of employees,
    which we may also term as an UPDATE or UPSERT scenario, performs the required
    action, and writes the response to an HTTP response stream.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个`updateEmployee`处理程序，它基本上解码了作为`PUT`请求的一部分传递的员工数据，使用Go的内置`encoding/json`包的`NewDecoder`处理程序迭代员工数组以了解员工ID请求是否存在于员工的初始静态数组中，我们也可以称之为UPDATE或UPSERT场景，执行所需的操作，并将响应写入HTTP响应流。
- en: Creating your first HTTP DELETE method
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个HTTP DELETE方法
- en: Whenever we want to remove a record that is no longer required then we go with
    the HTTP `DELETE` method implementation, which we will cover in this recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要删除不再需要的记录时，我们就会使用HTTP `DELETE`方法的实现，我们将在本节中介绍。
- en: How to do it…
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Install the `github.com/gorilla/mux` package, using the `go get` command, as
    follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/gorilla/mux`包，如下所示：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create `http-rest-delete.go` where we will define a route that supports the
    HTTP `DELETE` method and a handler that deletes the employee details for the provided
    ID from the static array of employees, marshals the array to JSON, and writes
    it to an HTTP response stream, as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-rest-delete.go`，在其中我们将定义一个支持HTTP `DELETE`方法的路由和一个处理程序，该处理程序从员工的静态数组中删除提供的ID的员工详细信息，将数组编组为JSON，并将其写入HTTP响应流，如下所示：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the program with the following command:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Next, executing a `DELETE` request from the command line as follows, will delete
    an employee with ID 1 and give us the updated list of employees:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从命令行执行`DELETE`请求，将删除ID为1的员工，并给我们更新后的员工列表：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This can be seen in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以下截图中看到：
- en: '![](img/6b9b0cfe-75e6-46f0-97da-eec53d4eb18f.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b9b0cfe-75e6-46f0-97da-eec53d4eb18f.png)'
- en: 'Let’s understand the change we introduced in this recipe:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们在这个示例中引入的更改：
- en: First, we added another route with the name `deleteEmployee`, which executes
    the `deleteEmployee` handler for every `DELETE` request for the URL pattern `/employee/delete`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加了另一个名为`deleteEmployee`的路由，它为URL模式`/employee/delete`的每个`DELETE`请求执行`deleteEmployee`处理程序。
- en: Then, we defined a `deleteEmployee` handler, which basically decodes the employee
    data that comes as part of a `DELETE` request using the `NewDecoder` handler of
    the built-in `encoding/json` package of Go, gets the index of the requested employee
    using the `GetIndex` helper function, deletes the employee, and writes the updated
    array as JSON to an HTTP response stream.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个`deleteEmployee`处理程序，基本上是使用Go内置的`encoding/json`包的`NewDecoder`处理程序解码作为`DELETE`请求的一部分传入的员工数据，使用`GetIndex`辅助函数获取请求的员工的索引，删除员工，并将更新后的数组以JSON格式写入HTTP响应流。
- en: Versioning your REST API
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对REST API进行版本控制
- en: When you create a RESTful API to serve an internal client, you probably don't
    have to worry about versioning your API. Taking things a step further, if you
    have control over all the clients that access your API, the same may be true.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个RESTful API来为内部客户端提供服务时，您可能不必担心对API进行版本控制。更进一步，如果您可以控制访问您的API的所有客户端，情况可能是一样的。
- en: However, in a case where you have a public API or an API where you do not have
    control over every client using it, versioning of your API may be required, as
    businesses need to evolve, which we will be covering in this recipe.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在您有一个公共API或者您无法控制每个使用它的客户端的API的情况下，可能需要对API进行版本控制，因为业务需要不断发展，我们将在这个示例中进行介绍。
- en: How to do it…
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install the `github.com/gorilla/mux` package, using the `go get` command, as
    follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/gorilla/mux`包，如下所示：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create `http-rest-versioning.go` where we will define two versions of the same
    URL path that support the HTTP `GET` method, with one having `v1` as a prefix
    and the other one with `v2` as a prefix in the route, as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-rest-versioning.go`，在其中我们将定义支持HTTP `GET`方法的相同URL路径的两个版本，其中一个具有`v1`作为前缀，另一个具有`v2`作为前缀，如下所示：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the program with the following command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Next, executing a `GET` request with the path prefix as `/v1` from the command
    line as follows, will give you a list of one set of employees:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从命令行执行带有路径前缀为`/v1`的`GET`请求，将给您一个员工列表：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, executing a `GET` request with path prefix as `/v2` will give you a list
    of another set of employees, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用路径前缀为`/v2`执行`GET`请求将给您另一组员工的列表，如下所示：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Sometimes, while designing the REST URL, we prefer to return the default data
    if the client queries the endpoint without specifying the version in the URL path.
    To incorporate it, we have modified the `getEmployees` handler to check for the
    prefix in the URL and act accordingly. So, executing a `GET` request without the
    path prefix from the command line as follows, will give you a list with a single
    record, which we can call the default or initial response of the REST endpoint
    called:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在设计REST URL时，如果客户端在不指定URL路径中的版本的情况下查询端点，我们更倾向于返回默认数据。为了实现这一点，我们修改了`getEmployees`处理程序，以检查URL中的前缀并相应地采取行动。因此，从命令行执行不带路径前缀的`GET`请求，将给您一个带有单个记录的列表，我们可以称之为REST端点的默认或初始响应：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s understand the change we introduced in this recipe:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们在这个示例中引入的更改：
- en: First, we defined a single route with the name `getEmployees`, which executes
    a `getEmployees` handler for every `GET` request for the URL pattern `/employees`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个名为`getEmployees`的单一路由，它为URL模式`/employees`的每个`GET`请求执行`getEmployees`处理程序。
- en: Then, we created three arrays, namely `employees`, `employeesV1`, and `employeesV2`,
    which are returned as a response to an HTTP `GET` call for the URL patterns `/employees`,
    `/v1/employees`, and `/v2/employees` respectively.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建了三个数组，分别是`employees`，`employeesV1`和`employeesV2`，它们作为对URL模式`/employees`，`/v1/employees`和`/v2/employees`的HTTP
    `GET`调用的响应返回。
- en: Next, we have defined a `getEmployees` handler where we check for the prefix
    in the URL path and perform an action based on it.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`getEmployees`处理程序，在其中我们检查URL路径中的前缀，并根据其执行操作。
- en: Then, we defined an `AddRoutes` helper function, which iterates over the routes
    array we defined, adds it to the `gorilla/mux` router, and returns the `Router`
    object.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个`AddRoutes`辅助函数，它遍历我们定义的路由数组，将其添加到`gorilla/mux`路由器中，并返回`Router`对象。
- en: Finally, we defined `main()` where we create a `gorilla/mux` router instance
    using the `NewRouter()` handler with the trailing slash behavior for new routes
    as true, and add routes to it calling the `AddRoutes` helper function passing
    the default router and two subrouters, one with the prefix as `v1` and the other
    with the prefix as `v2`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了`main()`，在其中我们使用`NewRouter()`处理程序创建一个带有尾部斜杠行为为true的`gorilla/mux`路由器实例，并通过调用`AddRoutes`辅助函数将路由添加到其中，传递默认路由器和两个子路由器，一个带有前缀`v1`，另一个带有前缀`v2`。
- en: Creating your first REST client
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个REST客户端
- en: Today, most applications that communicate with servers use RESTful services.
    Based on our needs, we consume these services through JavaScript, jQuery, or through
    a REST client.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数与服务器通信的应用程序都使用RESTful服务。根据我们的需求，我们通过JavaScript、jQuery或REST客户端来消费这些服务。
- en: In this recipe, we will write a REST client using the `https://gopkg.in/resty.v1`
    package, which itself is inspired by the Ruby rest client to consume the RESTful services.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用`https://gopkg.in/resty.v1`包编写一个REST客户端，该包本身受到Ruby rest客户端的启发，用于消耗RESTful服务。
- en: Getting ready…
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: 'Run `http-rest-get.go`, which we created in one of our previous recipes, in
    a separate terminal, executing the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个单独的终端中运行我们在之前的食谱中创建的`http-rest-get.go`，执行以下命令：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See the *Creating your first HTTP GET method* recipe.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 参见*创建您的第一个HTTP GET方法*食谱。
- en: 'Verify whether the `/employees` service is running locally on port `8080` by
    executing the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令验证`/employees`服务是否在本地端口`8080`上运行：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This should return the following response:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回以下响应：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Install the `github.com/gorilla/mux` and `gopkg.in/resty.v1` packages using
    the `go get` command, as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/gorilla/mux`和`gopkg.in/resty.v1`包，如下所示：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create `http-rest-client.go` where we will define handlers that call `resty`
    handlers, such as `GET`, `POST`, `PUT`, and `DELETE`, get the response from the
    REST service, and write it to an HTTP response stream, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-rest-client.go`，在其中我们将定义调用`resty`处理程序的处理程序，如`GET`、`POST`、`PUT`和`DELETE`，从REST服务获取响应，并将其写入HTTP响应流，如下所示：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the program with the following command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8090`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8090`。
- en: 'Next, executing a `GET` request to the REST client from the command line as
    follows will give you a list of all the employees from the service:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过执行以下命令向REST客户端发送`GET`请求，将会得到来自服务的所有员工的列表：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similarly, run `http-rest-post.go`, which we created in one of our previous
    recipes, in a separate terminal by executing the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，在一个单独的终端中运行我们在之前的食谱中创建的`http-rest-post.go`，执行以下命令：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Execute a `POST` request to the REST client from the command line, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行执行`POST`请求到REST客户端，如下所示：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will add an employee to the initial static list and return an updated
    list of the employees, which will look as shown in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向初始静态列表添加一个员工，并返回更新后的员工列表，如下截图所示：
- en: '![](img/e91da249-f9ae-42b1-ba53-391407df8998.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e91da249-f9ae-42b1-ba53-391407df8998.png)'
- en: 'Let’s understand the program we have written:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们编写的程序：
- en: Using `import ("encoding/json" "fmt" "log" "net/http" "github.com/gorilla/mux"
    resty “gopkg.in/resty.v1")`, we imported `github.com/gorilla/mux` to create a
    `Gorilla Mux Router` and `gopkg.in/resty.v1` with the package alias as `resty`,
    which is a REST client of Go, having various handlers to consume the RESTful web
    service.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`import ("encoding/json" "fmt" "log" "net/http" "github.com/gorilla/mux" resty
    “gopkg.in/resty.v1")`，我们导入了`github.com/gorilla/mux`来创建`Gorilla Mux Router`，并使用包别名`resty`导入了`gopkg.in/resty.v1`，它是Go的REST客户端，具有各种处理程序来消耗RESTful
    web服务。
- en: Using `const WEB_SERVICE_HOST string = "http://localhost:8080"`, we declared
    the complete URL of the RESTful web service host.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`const WEB_SERVICE_HOST string = "http://localhost:8080"`，我们声明了RESTful web服务主机的完整URL。
- en: Depending on the project size, you can move the `WEB_SERVICE_HOST` string to
    the constants file or to the properties file, helping you to override its value
    at runtime.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目大小，您可以将`WEB_SERVICE_HOST`字符串移动到常量文件或属性文件中，以帮助您在运行时覆盖其值。
- en: Next, we defined a `getEmployees` handler where we create a new `resty` request
    object calling its `R()` handler, call the `Get` method, which performs the HTTP `GET` request,
    gets the response, and writes it to an HTTP response.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`getEmployees`处理程序，在其中我们创建一个新的`resty`请求对象调用其`R()`处理程序，调用`Get`方法，执行HTTP
    `GET`请求，获取响应，并将其写入HTTP响应。
- en: Similarly, we defined three more handlers that do the `POST`, `PUT`, and `DELETE`
    requests to the RESTful service and a `main()` where we create a `gorilla/mux`
    router instance and register the `/employees` URL path with the `getEmployees`
    handler and `/employee/add`, `/employee/update`, and  `/employee/delete` with
    the `addEmployee`, `updateEmployee`, and `deleteEmployee` handlers, respectively.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们定义了另外三个处理程序，用于向RESTful服务发送`POST`、`PUT`和`DELETE`请求，以及一个`main()`，在其中我们创建了一个`gorilla/mux`路由器实例，并使用`getEmployees`处理程序注册了`/employees`
    URL路径，以及使用`addEmployee`、`updateEmployee`和`deleteEmployee`处理程序分别注册了`/employee/add`、`/employee/update`和`/employee/delete`。
- en: Creating your first AngularJS Client
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个AngularJS客户端
- en: AngularJS is an open source JavaScript Model-View-Whatever (MVW) framework,
    which lets us build well-structured, easily testable and maintainable browser-based
    applications.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS是一个开源的JavaScript Model-View-Whatever（MVW）框架，它让我们能够构建结构良好、易于测试和易于维护的基于浏览器的应用程序。
- en: In this recipe, we will learn to create an AngularJS with TypeScript 2 client to
    send a `POST` request to the HTTP server running locally.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习创建一个AngularJS与TypeScript 2客户端，向本地运行的HTTP服务器发送`POST`请求。
- en: Getting ready…
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: As we have already created an HTTP server that accepts both `GET` and `POST`
    requests in one of our previous recipes, we will be using the same code base as
    our HTTP server.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在之前的食谱中创建了一个接受`GET`和`POST`请求的HTTP服务器，我们将使用相同的代码库作为我们的HTTP服务器。
- en: 'Also, this recipe assumes you have Angular2 CLI installed on your machine.
    If not, install it by executing the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此处的食谱假设您的机器上已安装了Angular2 CLI。如果没有，请执行以下命令进行安装：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: See the *Creating your first HTTP POST method* recipe.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 参见*创建您的第一个HTTP POST方法*食谱。
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a new project and skeleton application by executing the following command:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令创建一个新项目和骨架应用程序：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Move to the `angularjs-client` directory and create `server.go` by executing
    the following command:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到`angularjs-client`目录，并通过执行以下命令创建`server.go`：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Copy the following code to `server.go`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码复制到`server.go`中：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Move to the `angularjs-client` directory and create `models/employee.ts` and
    `service/employee.service.ts` by executing the following command:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到`angularjs-client`目录，并通过执行以下命令创建`models/employee.ts`和`service/employee.service.ts`：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Copy the following code to `angularjs-client/src/app/models/employee.ts`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码复制到`angularjs-client/src/app/models/employee.ts`中：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Copy the following code to `angularjs-client/src/app/services
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码复制到`angularjs-client/src/app/services`中
- en: '/employee.service.ts`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '/employee.service.ts`:'
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Replace the code of `angularjs-client/src/app/app.component.html` with the
    following:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换`angularjs-client/src/app/app.component.html`的代码：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Replace the code of `angularjs-client/src/app/app.component.ts` with the following:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换`angularjs-client/src/app/app.component.ts`的代码：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Replace the code of `angularjs-client/src/app/app.module.ts` with the following:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换`angularjs-client/src/app/app.module.ts`的代码：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With everything in place, the directory structure should look like the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，目录结构应如下所示：
- en: '![](img/b8fa1211-122f-4c01-ae7a-7b7041b79476.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8fa1211-122f-4c01-ae7a-7b7041b79476.png)'
- en: 'Move to the `angularjs-client` directory and execute the following commands
    to build the project artifacts and run the program:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到`angularjs-client`目录并执行以下命令来构建项目构件并运行程序：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works…
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Once we run the program, the HTTP server will start locally listening on port `8080`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Browsing to `http://localhost:8080` will show us the AngularJS client page,
    which has an HTML form with Id, FirstName, and LastName fields, as shown in the
    following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost:8080`将显示AngularJS客户端页面，其中有一个带有Id、FirstName和LastName字段的HTML表单，如下图所示：
- en: '![](img/203d5e4b-c4f3-4b47-aac8-31bf7bdeda08.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/203d5e4b-c4f3-4b47-aac8-31bf7bdeda08.png)'
- en: 'Clicking on the Add button after filling in the form will send a `POST` request
    to an HTTP server running on port `8080`. Once a request is processed by the server
    it will return a list of all the static employees along with the newly added one,
    and display it in a browser, as shown in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写表单后点击“Add”按钮将向运行在端口`8080`上的HTTP服务器发送一个`POST`请求。一旦服务器处理了请求，它将返回所有静态员工的列表以及新添加的员工，并在浏览器中显示，如下图所示：
- en: '![](img/d2c666e9-0b1c-4b91-8376-a454e565541e.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2c666e9-0b1c-4b91-8376-a454e565541e.png)'
- en: List of all the static employees along with the newly added one
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所有静态员工的列表以及新添加的员工
- en: Creating your first ReactJS client
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个ReactJS客户端
- en: ReactJS is a declarative JavaScript library that helps in building user interfaces
    efficiently. Because it works on the concept of virtual DOM it improves application
    performance, since JavaScript virtual DOM is faster than the regular DOM.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS是一个声明式的JavaScript库，有助于高效构建用户界面。因为它基于虚拟DOM的概念工作，它提高了应用程序的性能，因为JavaScript虚拟DOM比常规DOM更快。
- en: In this recipe, we will learn to create a ReactJS client to send a `POST` request
    to the HTTP server running locally.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习创建一个ReactJS客户端来向本地运行的HTTP服务器发送`POST`请求。
- en: Getting ready…
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: As we have already created an HTTP server that accepts both `GET` and `POST` HTTP
    requests in our previous recipe, we will be using the same code base as our HTTP
    server.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在之前的教程中创建了一个接受`GET`和`POST` HTTP请求的HTTP服务器，我们将使用相同的代码库作为我们的HTTP服务器。
- en: Also, this recipe assumes you have `npm` installed on your machine and you have
    basic knowledge of `npm` and `webpack`, which is a JavaScript Module bundler.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本教程假设您已在您的机器上安装了`npm`，并且对`npm`和`webpack`有基本的了解，它是一个JavaScript模块打包工具。
- en: See the *Creating your first HTTP POST method* recipe.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 参见*创建你的第一个HTTP POST方法*教程。
- en: How to do it…
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a `reactjs-client` directory where we will keep all our ReactJS source
    files and an HTTP server, as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`reactjs-client`目录，我们将在其中保存所有我们的ReactJS源文件和一个HTTP服务器，如下所示：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Copy the following code to `server.go`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码复制到`server.go`中：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create another directory with the name `assets` where all our frontend code
    files, such as `.html`, `.js`, `.css`, and `images` will be kept, as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`assets`的目录，其中将保存所有我们的前端代码文件，如`.html`、`.js`、`.css`和`images`，如下所示：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Copy the following content to `index.html`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容复制到`index.html`中：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Move to the `reactjs-client` directory and execute `npm init` to create `package.json`
    where we specify all the dependencies required to build our react client such
    as `React`, `React DOM`, `Webpack`, `Babel Loader`, `Babel Core`, `Babel Preset:
    ES2015`, and `Babel Preset: React`, as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '移动到`reactjs-client`目录并执行`npm init`来创建`package.json`，在其中我们指定构建我们的react客户端所需的所有依赖项，如`React`、`React
    DOM`、`Webpack`、`Babel Loader`、`Babel Core`、`Babel Preset: ES2015`和`Babel Preset:
    React`，如下所示：'
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Replace the content of `package.json` with the following content:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换`package.json`的内容：
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create `webpack.config.js` where we will configure `webpack`, as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`webpack.config.js`，在其中我们将配置`webpack`，如下所示：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Copy the following content to `webpack.config.js`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容复制到`webpack.config.js`中：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create an entry point for the `webpack`, which is `reactjs-client/app/main.js` by
    executing the following commands:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令为`webpack`创建入口点，即`reactjs-client/app/main.js`：
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Copy the following content to `main.js`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容复制到`main.js`中：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Define `ReactApp` along with its child components by executing the following
    commands:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令定义`ReactApp`以及它的子组件：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Copy the following content to `reactjs-client/app/components/employee-app.jsx`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容复制到`reactjs-client/app/components/employee-app.jsx`中：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Copy the following content to `reactjs-client/app/components/employee.jsx`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容复制到`reactjs-client/app/components/employee.jsx`中：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Copy the following content to `reactjs-client/app/components/employee-list.jsx`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容复制到`reactjs-client/app/components/employee-list.jsx`中：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Copy the following content to `reactjs-client/app/components/add-employee.jsx`**:**
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容复制到`reactjs-client/app/components/add-employee.jsx`中：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'With everything in place, the directory structure should look like the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，目录结构应如下所示：
- en: '![](img/50c0bf0f-cdbe-4833-bf8d-99c9a104973b.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50c0bf0f-cdbe-4833-bf8d-99c9a104973b.png)'
- en: Directory structure
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 目录结构
- en: 'Move to the `reactjs-client` directory and execute the following commands to
    install `node modules` and build `webpack`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到`reactjs-client`目录并执行以下命令来安装`node modules`和构建`webpack`：
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Run the program with the following command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE63]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works…
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Browsing to `http://localhost:8080` will show us the ReactJS client page, as
    shown in the following screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost:8080`将会显示我们的VueJS客户端页面，如下截图所示：
- en: '![](img/f00b32c2-acbb-4ab3-a636-89add88479d7.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f00b32c2-acbb-4ab3-a636-89add88479d7.png)'
- en: ReactJS client page
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS客户端页面
- en: 'Clicking on the Add button after filling in the textbox will send a `POST`
    request to the HTTP server running on port `8080`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写文本框后点击添加按钮将会向运行在端口`8080`上的HTTP服务器发送一个`POST`请求：
- en: '![](img/1584d5e4-c3e7-42e3-a70e-e61ccea90f6e.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1584d5e4-c3e7-42e3-a70e-e61ccea90f6e.png)'
- en: Click on the Add button after filling in the textbox
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写文本框后点击添加按钮
- en: 'Next, executing a `GET` request from the command line as follows will give
    you a list of all the static employees:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从命令行执行一个`GET`请求将会给你一个所有静态员工的列表：
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This will be alongside the newly added one, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会和新添加的员工一起显示如下：
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Creating your first VueJS client
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个VueJS客户端
- en: Being open source, VueJS is one of the incrementally adoptable and progressive
    JavaScript frameworks that companies are adopting to build their frontend or client-facing
    user interfaces for the web.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开源项目，VueJS是逐步可采用和渐进式的JavaScript框架之一，公司正在采用它来构建他们的前端或面向客户的用户界面。
- en: In this recipe, we will learn to create a client in VueJS, which adds an employee
    sending an HTTP `POST` request to the HTTP server running locally.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习在VueJS中创建一个客户端，通过向本地运行的HTTP服务器发送一个HTTP `POST`请求来添加一个员工。
- en: Getting ready…
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好…
- en: As we have already created an HTTP server that accepts both `GET` and `POST`
    requests in one of our previous recipes, we will be using the same code base as
    our HTTP server.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在之前的教程中创建了一个接受`GET`和`POST`请求的HTTP服务器，我们将使用相同的代码库作为我们的HTTP服务器。
- en: See the *Creating your first HTTP POST method* recipe.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 参见*创建你的第一个HTTP POST方法*教程。
- en: How to do it…
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a `vuejs-client` directory where we will keep all our VueJS source files
    and an HTTP server, as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`vuejs-client`目录，我们将在其中保存所有VueJS源文件和一个HTTP服务器，如下所示：
- en: '[PRE66]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Copy the following code to `server.go`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码复制到`server.go`中：
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create another directory with the name `assets` where all our frontend code
    files such as `.html`, `.js`, `.css`, and `images` will be kept, as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`assets`的目录，其中将保存所有我们的前端代码文件，如`.html`、`.js`、`.css`和`images`，如下所示：
- en: '[PRE68]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Copy the following content to `index.html`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容复制到`index.html`中：
- en: '[PRE69]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Copy the following content to `main.js`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容复制到`main.js`中：
- en: '[PRE70]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'With everything in place, the directory structure should look like the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，目录结构应该如下所示：
- en: '![](img/9f55a822-3ed2-4737-9a32-67a78d767f14.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f55a822-3ed2-4737-9a32-67a78d767f14.png)'
- en: Directory structure
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 目录结构
- en: 'Run the program with the following command:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下命令运行程序：
- en: '[PRE71]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works…
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Browsing to `http://localhost:8080` will show us the VueJS client page, which
    has an HTML form with Id, FirstName, and LastName fields, as shown in the following
    screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost:8080`将会显示我们的VueJS客户端页面，其中有一个包含Id、FirstName和LastName字段的HTML表单，如下截图所示：
- en: '![](img/6ca52730-9d1a-41ab-9232-ce31c5b2b145.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ca52730-9d1a-41ab-9232-ce31c5b2b145.png)'
- en: VueJS client page
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: VueJS客户端页面
- en: 'Clicking on the Add button after filling in the form will send a `POST` request
    to the HTTP server running on port `8080`, as shown in the following screenshot:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写表单后点击添加按钮将会向运行在端口`8080`上的HTTP服务器发送一个`POST`请求，如下截图所示：
- en: '![](img/2787ecca-7f98-4c93-8b51-27a5ef3a79eb.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2787ecca-7f98-4c93-8b51-27a5ef3a79eb.png)'
- en: Click on the Add button after filling in the form
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写表单后点击添加按钮
- en: 'Next, executing a `GET` request from the command line as follows, will give
    you a list of all the static employees:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从命令行执行一个`GET`请求，将会给你一个所有静态员工的列表：
- en: '[PRE72]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This will be alongside the newly added one as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会和新添加的员工一起显示如下：
- en: '[PRE73]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
