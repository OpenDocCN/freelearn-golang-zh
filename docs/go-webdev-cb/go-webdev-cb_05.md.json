["```go\n$ ps -ef | grep 3306\n```", "```go\n$ go get github.com/go-sql-driver/mysql\n```", "```go\npackage main\nimport \n(\n  \"database/sql\"\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"github.com/go-sql-driver/mysql\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  DRIVER_NAME = \"mysql\"\n  DATA_SOURCE_NAME = \"root:password@/mydb\"\n)\nvar db *sql.DB\nvar connectionError error\nfunc init() \n{\n  db, connectionError = sql.Open(DRIVER_NAME, DATA_SOURCE_NAME)\n  if connectionError != nil \n  {\n    log.Fatal(\"error connecting to database :: \", connectionError)\n  }\n}\nfunc getCurrentDb(w http.ResponseWriter, r *http.Request) \n{\n  rows, err := db.Query(\"SELECT DATABASE() as db\")\n  if err != nil \n  {\n    log.Print(\"error executing query :: \", err)\n    return\n  }\n  var db string\n  for rows.Next() \n  {\n    rows.Scan(&db)\n  }\n  fmt.Fprintf(w, \"Current Database is :: %s\", db)\n}\nfunc main() \n{\n  http.HandleFunc(\"/\", getCurrentDb)\n  defer db.Close()\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run connect-mysql.go\n```", "```go\n$ go get github.com/go-sql-driver/mysql\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"database/sql\"\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"strconv\"\n  \"github.com/go-sql-driver/mysql\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  DRIVER_NAME = \"mysql\"\n  DATA_SOURCE_NAME = \"root:password@/mydb\"\n)\nvar db *sql.DB\nvar connectionError error\nfunc init() \n{\n  db, connectionError = sql.Open(DRIVER_NAME, DATA_SOURCE_NAME)\n  if connectionError != nil \n  {\n    log.Fatal(\"error connecting to database : \", connectionError)\n  }\n}\nfunc createRecord(w http.ResponseWriter, r *http.Request) \n{\n  vals := r.URL.Query()\n  name, ok := vals[\"name\"]\n  if ok \n  {\n    log.Print(\"going to insert record in database for name : \",\n    name[0])\n    stmt, err := db.Prepare(\"INSERT employee SET name=?\")\n    if err != nil \n    {\n      log.Print(\"error preparing query :: \", err)\n      return\n    }\n    result, err := stmt.Exec(name[0])\n    if err != nil \n    {\n      log.Print(\"error executing query :: \", err)\n      return\n    }\n    id, err := result.LastInsertId()\n    fmt.Fprintf(w, \"Last Inserted Record Id is :: %s\",\n    strconv.FormatInt(id, 10))\n  } \n  else \n  {\n    fmt.Fprintf(w, \"Error occurred while creating record in \n    database for name :: %s\", name[0])\n  }\n}\nfunc main() \n{\n  router := mux.NewRouter()\n  router.HandleFunc(\"/employee/create\", createRecord).\n  Methods(\"POST\")\n  defer db.Close()\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run create-record-mysql.go\n```", "```go\n$ curl -X POST http://localhost:8080/employee/create?name=foo\nLast created record id is :: 1\n```", "```go\n$ go get github.com/go-sql-driver/mysql\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"database/sql\" \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"github.com/go-sql-driver/mysql\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  DRIVER_NAME = \"mysql\"\n  DATA_SOURCE_NAME = \"root:password@/mydb\"\n)\nvar db *sql.DB\nvar connectionError error\nfunc init() \n{\n  db, connectionError = sql.Open(DRIVER_NAME, DATA_SOURCE_NAME)\n  if connectionError != nil \n  {\n    log.Fatal(\"error connecting to database :: \", connectionError)\n  }\n}\ntype Employee struct \n{\n  Id int `json:\"uid\"`\n  Name string `json:\"name\"`\n}\nfunc readRecords(w http.ResponseWriter, r *http.Request) \n{\n  log.Print(\"reading records from database\")\n  rows, err := db.Query(\"SELECT * FROM employee\")\n  if err != nil \n  {\n    log.Print(\"error occurred while executing select \n    query :: \",err)\n    return\n  }\n  employees := []Employee{}\n  for rows.Next() \n  {\n    var uid int\n    var name string\n    err = rows.Scan(&uid, &name)\n    employee := Employee{Id: uid, Name: name}\n    employees = append(employees, employee)\n  }\n  json.NewEncoder(w).Encode(employees)\n}\nfunc main() \n{\n  router := mux.NewRouter()\n  router.HandleFunc(\"/employees\", readRecords).Methods(\"GET\")\n  defer db.Close()\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run read-record-mysql.go\n```", "```go\n$ go get github.com/go-sql-driver/mysql\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"database/sql\"\n  \"fmt\"\n  \"log\"\n  \"net/http\" \n  \"github.com/go-sql-driver/mysql\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  DRIVER_NAME = \"mysql\"\n  DATA_SOURCE_NAME = \"root:password@/mydb\"\n)\nvar db *sql.DB\nvar connectionError error \nfunc init() \n{\n  db, connectionError = sql.Open(DRIVER_NAME, DATA_SOURCE_NAME)\n  if connectionError != nil \n  {\n    log.Fatal(\"error connecting to database :: \", connectionError)\n  }\n}\ntype Employee struct \n{\n  Id   int    `json:\"uid\"`\n  Name string `json:\"name\"`\n}\nfunc updateRecord(w http.ResponseWriter, r *http.Request) \n{\n  vars := mux.Vars(r)\n  id := vars[\"id\"]\n  vals := r.URL.Query()\n  name, ok := vals[\"name\"]\n  if ok \n  {\n    log.Print(\"going to update record in database \n    for id :: \", id)\n    stmt, err := db.Prepare(\"UPDATE employee SET name=? \n    where uid=?\")\n    if err != nil \n    {\n      log.Print(\"error occurred while preparing query :: \", err)\n      return\n    }\n    result, err := stmt.Exec(name[0], id)\n    if err != nil \n    {\n      log.Print(\"error occurred while executing query :: \", err)\n      return\n    }\n    rowsAffected, err := result.RowsAffected()\n    fmt.Fprintf(w, \"Number of rows updated in database \n    are :: %d\",rowsAffected)\n  } \n  else \n  {\n    fmt.Fprintf(w, \"Error occurred while updating record in \n    database for id :: %s\", id)\n  }\n}\nfunc main() \n{\n  router := mux.NewRouter()\n  router.HandleFunc(\"/employee/update/{id}\",\n  updateRecord).Methods(\"PUT\")\n  defer db.Close()\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run update-record-mysql.go\n```", "```go\n$ curl -X PUT http://localhost:8080/employee/update/1?name\\=bar\nNumber of rows updated in database are :: 1\n```", "```go\n$ go get github.com/go-sql-driver/mysql\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"database/sql\"\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"github.com/go-sql-driver/mysql\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  DRIVER_NAME = \"mysql\"\n  DATA_SOURCE_NAME = \"root:password@/mydb\"\n)\nvar db *sql.DB\nvar connectionError error\nfunc init() \n{\n  db, connectionError = sql.Open(DRIVER_NAME, DATA_SOURCE_NAME)\n  if connectionError != nil \n  {\n    log.Fatal(\"error connecting to database :: \", connectionError)\n  }\n}\nfunc deleteRecord(w http.ResponseWriter, r *http.Request) \n{\n  vals := r.URL.Query()\n  name, ok := vals[\"name\"]\n  if ok \n  {\n    log.Print(\"going to delete record in database for \n    name :: \", name[0])\n    stmt, err := db.Prepare(\"DELETE from employee where name=?\")\n    if err != nil \n    {\n      log.Print(\"error occurred while preparing query :: \", err)\n      return\n    }\n    result, err := stmt.Exec(name[0])\n    if err != nil \n    {\n      log.Print(\"error occurred while executing query :: \", err)\n      return\n    }\n    rowsAffected, err := result.RowsAffected()\n    fmt.Fprintf(w, \"Number of rows deleted in database are :: %d\",\n    rowsAffected)\n  } \n  else \n  {\n    fmt.Fprintf(w, \"Error occurred while deleting record in \n    database for name %s\", name[0])\n  }\n}\nfunc main() \n{\n  router := mux.NewRouter()\n  router.HandleFunc(\"/employee/delete\",\n  deleteRecord).Methods(\"DELETE\")\n  defer db.Close()\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run delete-record-mysql.go\n```", "```go\n$ curl -X DELETE http://localhost:8080/employee/delete?name\\=bar\nNumber of rows deleted in database are :: 1\n```", "```go\n$ mongo\n```", "```go\n$ go get gopkg.in/mgo.v\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"strings\"\n  mgo \"gopkg.in/mgo.v2\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  MONGO_DB_URL = \"127.0.0.1\"\n)\nvar session *mgo.Session\nvar connectionError error\nfunc init() \n{\n  session, connectionError = mgo.Dial(MONGO_DB_URL)\n  if connectionError != nil \n  {\n    log.Fatal(\"error connecting to database :: \", connectionError)\n  }\n  session.SetMode(mgo.Monotonic, true)\n}\nfunc getDbNames(w http.ResponseWriter, r *http.Request) \n{\n  db, err := session.DatabaseNames()\n  if err != nil \n  {\n    log.Print(\"error getting database names :: \", err)\n    return\n  }\n  fmt.Fprintf(w, \"Databases names are :: %s\", strings.Join\n  (db, \", \"))\n}\nfunc main() \n{\n  http.HandleFunc(\"/\", getDbNames)\n  defer session.Close()\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run connect-mongodb.go\n```", "```go\n$ go get gopkg.in/mgo.v2\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"strconv\"\n  \"github.com/gorilla/mux\"\n  mgo \"gopkg.in/mgo.v2\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  MONGO_DB_URL = \"127.0.0.1\"\n)\nvar session *mgo.Session\nvar connectionError error\ntype Employee struct \n{\n  Id int `json:\"uid\"`\n  Name string `json:\"name\"`\n}\nfunc init() \n{\n  session, connectionError = mgo.Dial(MONGO_DB_URL)\n  if connectionError != nil \n  {\n    log.Fatal(\"error connecting to database :: \", connectionError)\n  }\n  session.SetMode(mgo.Monotonic, true)\n}\nfunc createDocument(w http.ResponseWriter, r *http.Request) \n{\n  vals := r.URL.Query()\n  name, nameOk := vals[\"name\"]\n  id, idOk := vals[\"id\"]\n  if nameOk && idOk \n  {\n    employeeId, err := strconv.Atoi(id[0])\n    if err != nil \n    {\n      log.Print(\"error converting string id to int :: \", err)\n      return\n    }\n    log.Print(\"going to insert document in database for name \n    :: \", name[0])\n    collection := session.DB(\"mydb\").C(\"employee\")\n    err = collection.Insert(&Employee{employeeId, name[0]})\n    if err != nil \n    {\n      log.Print(\"error occurred while inserting document in \n      database :: \", err)\n      return\n    }\n    fmt.Fprintf(w, \"Last created document id is :: %s\", id[0])\n  } \n  else \n  {\n    fmt.Fprintf(w, \"Error occurred while creating document in\n    database for name :: %s\", name[0])\n  }\n}\nfunc main() \n{\n  router := mux.NewRouter()\n  router.HandleFunc(\"/employee/create\",\n  createDocument).Methods(\"POST\")\n  defer session.Close()\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run create-record-mongodb.go\n```", "```go\n$ curl -X POST http://localhost:8080/employee/create?name=foo\\&id=1\nLast created document id is :: 1\n```", "```go\n$ go get gopkg.in/mgo.v2\n$ go get gopkg.in/mgo.v2/bson\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/mux\"\n  mgo \"gopkg.in/mgo.v2\"\n  \"gopkg.in/mgo.v2/bson\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  MONGO_DB_URL = \"127.0.0.1\"\n)\nvar session *mgo.Session\nvar connectionError error\nfunc init() \n{\n  session, connectionError = mgo.Dial(MONGO_DB_URL)\n  if connectionError != nil \n  {\n    log.Fatal(\"error connecting to database :: \", connectionError)\n  }\n  session.SetMode(mgo.Monotonic, true)\n}\ntype Employee struct \n{\n  Id int `json:\"uid\"`\n  Name string `json:\"name\"`\n}\nfunc readDocuments(w http.ResponseWriter, r *http.Request) \n{\n  log.Print(\"reading documents from database\")\n  var employees []Employee\n  collection := session.DB(\"mydb\").C(\"employee\")\n  err := collection.Find(bson.M{}).All(&employees)\n  if err != nil \n  {\n    log.Print(\"error occurred while reading documents from \n    database :: \", err)\n    return\n  }\n  json.NewEncoder(w).Encode(employees)\n}\nfunc main() \n{\n  router := mux.NewRouter()\n  router.HandleFunc(\"/employees\", readDocuments).Methods(\"GET\")\n  defer session.Close()\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run read-record-mongodb.go\n```", "```go\n$ go get gopkg.in/mgo.v2\n$ go get gopkg.in/mgo.v2/bson\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"strconv\"\n  \"github.com/gorilla/mux\"\n  mgo \"gopkg.in/mgo.v2\"\n  \"gopkg.in/mgo.v2/bson\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  MONGO_DB_URL = \"127.0.0.1\"\n)\nvar session *mgo.Session\nvar connectionError error\ntype Employee struct \n{\n  Id int `json:\"uid\"`\n  Name string `json:\"name\"`\n}\nfunc init() \n{\n  session, connectionError = mgo.Dial(MONGO_DB_URL)\n  if connectionError != nil \n  {\n    log.Fatal(\"error connecting to database :: \", \n    connectionError)\n  }\n  session.SetMode(mgo.Monotonic, true)\n}\nfunc updateDocument(w http.ResponseWriter, r *http.Request) \n{\n  vars := mux.Vars(r)\n  id := vars[\"id\"]\n  vals := r.URL.Query()\n  name, ok := vals[\"name\"]\n  if ok \n  {\n    employeeId, err := strconv.Atoi(id)\n    if err != nil \n    {\n      log.Print(\"error converting string id to int :: \", err)\n      return\n    }\n    log.Print(\"going to update document in database \n    for id :: \", id)\n    collection := session.DB(\"mydb\").C(\"employee\")\n    var changeInfo *mgo.ChangeInfo\n    changeInfo, err = collection.Upsert(bson.M{\"id\": employeeId},\n    &Employee{employeeId, name[0]})\n    if err != nil \n    {\n      log.Print(\"error occurred while updating record in \n      database :: \", err)\n      return\n    }\n    fmt.Fprintf(w, \"Number of documents updated in database \n    are :: %d\", changeInfo.Updated)\n  } \n  else \n  {\n    fmt.Fprintf(w, \"Error occurred while updating document\n    in database for id :: %s\", id)\n  }\n}\nfunc main() \n{\n  router := mux.NewRouter()\n  router.HandleFunc(\"/employee/update/{id}\",\n  updateDocument).Methods(\"PUT\")\n  defer session.Close()\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run update-record-mongodb.go\n```", "```go\n$ curl -X PUT http://localhost:8080/employee/update/1\\?name\\=bar\nNumber of documents updated in database are :: 1\n```", "```go\n$ go get gopkg.in/mgo.v2\n$ go get gopkg.in/mgo.v2/bson\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/mux\"\n  mgo \"gopkg.in/mgo.v2\"\n  \"gopkg.in/mgo.v2/bson\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  MONGO_DB_URL = \"127.0.0.1\"\n)\nvar session *mgo.Session\nvar connectionError error\ntype Employee struct \n{\n  Id int `json:\"uid\"`\n  Name string `json:\"name\"`\n}\nfunc init() \n{\n  session, connectionError = mgo.Dial(MONGO_DB_URL)\n  if connectionError != nil \n  {\n    log.Fatal(\"error connecting to database :: \", \n    connectionError)\n  }\n  session.SetMode(mgo.Monotonic, true)\n}\nfunc deleteDocument(w http.ResponseWriter, r *http.Request) \n{\n  vals := r.URL.Query()\n  name, ok := vals[\"name\"]\n  if ok \n  {\n    log.Print(\"going to delete document in database for \n    name :: \", name[0])\n    collection := session.DB(\"mydb\").C(\"employee\")\n    removeErr := collection.Remove(bson.M{\"name\": name[0]})\n    if removeErr != nil \n    {\n      log.Print(\"error removing document from \n      database :: \", removeErr)\n      return\n    }\n    fmt.Fprintf(w, \"Document with name %s is deleted from \n    database\", name[0])\n  } \n  else \n  {\n    fmt.Fprintf(w, \"Error occurred while deleting document \n    in database for name :: %s\", name[0])\n  }\n}\nfunc main() \n{\n  router := mux.NewRouter()\n  router.HandleFunc(\"/employee/delete\",\n  deleteDocument).Methods(\"DELETE\")\n  defer session.Close()\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT, router)\n  if err != nil \n  {\n    log.Fatal(\"error starting http server :: \", err)\n    return\n  }\n}\n```", "```go\n$ go run delete-record-mongodb.go\n```", "```go\n$ curl -X DELETE http://localhost:8080/employee/delete?name\\=bar\nDocument with name bar is deleted from database\n```"]