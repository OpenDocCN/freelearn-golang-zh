- en: Working with SQL and NoSQL Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQL和NoSQL数据库
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Integrating MySQL and Go
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成MySQL和Go
- en: Creating your first record in MySQL
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MySQL中创建您的第一条记录
- en: Reading records from MySQL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从MySQL中读取记录
- en: Updating your first record in MySQL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新您的第一条记录在MySQL中
- en: Deleting your first record from MySQL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从MySQL中删除您的第一条记录
- en: Integrating MongoDB and Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成MongoDB和Go
- en: Creating your first document in MongoDB
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MongoDB中创建您的第一个文档
- en: Reading documents from MongoDB
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从MongoDB中读取文档
- en: Updating your first document in MongoDB
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MongoDB中更新您的第一个文档
- en: Deleting your first document from MongoDB
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从MongoDB中删除您的第一个文档
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Whenever we want to persist data we always look forward to saving it in databases,
    which are mainly divided into two categories—**SQL** and **NoSQL**. There are
    a number of databases under each category that can be used depending on the business
    use case because each one has different characteristics and serves a different
    purpose.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要持久保存数据时，我们总是期待将其保存在数据库中，主要分为两类——**SQL**和**NoSQL**。每个类别下都有许多可以根据业务用例使用的数据库，因为每个数据库都具有不同的特性并且服务于不同的目的。
- en: In this chapter, we will integrate a Go web application with the most famous
    open source databases—**MySQL** and **MongoDB** and learn to perform CRUD operations
    on them. As we will use MySQL and MongoDB, I assume both of the databases are
    installed and running on your local machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把Go Web应用程序与最著名的开源数据库——**MySQL**和**MongoDB**集成，并学习在它们上执行CRUD操作。由于我们将使用MySQL和MongoDB，我假设这两个数据库都已安装并在您的本地机器上运行。
- en: Integrating MySQL and Go
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成MySQL和Go
- en: Let's assume you are a developer and want to save your application data in a
    MySQL database. As a first step, you have to establish a connection between your
    application and MySQL, which we will cover in this recipe.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您是一名开发人员，并且希望将应用程序数据保存在MySQL数据库中。作为第一步，您必须在应用程序和MySQL之间建立连接，我们将在本示例中介绍。
- en: Getting ready…
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: 'Verify whether MySQL is installed and running locally on port `3306` by executing
    the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令验证本地端口`3306`上是否安装并运行了MySQL：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should return the following response:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回以下响应：
- en: '![](img/53efed06-d9a0-4f73-b865-85ba8e619fb7.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53efed06-d9a0-4f73-b865-85ba8e619fb7.png)'
- en: 'Also, log into the MySQL database and create a mydb database, executing the
    commands as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还要登录到MySQL数据库并创建一个mydb数据库，执行如下截图中显示的命令：
- en: '![](img/04132684-d375-44e4-88cc-dd91026a9a36.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04132684-d375-44e4-88cc-dd91026a9a36.png)'
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install the `github.com/go-sql-driver/mysql` package, using the `go get` command,
    as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/go-sql-driver/mysql`包，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create `connect-mysql.go`. Then we connect to the MySQL database and perform
    a `SELECT` query to get the current database name, as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`connect-mysql.go`。然后我们连接到MySQL数据库并执行`SELECT`查询以获取当前数据库名称，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the program with the following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Browsing to `http://localhost:8080/` will return you the current database name,
    as shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost:8080/`将返回当前数据库名称，如下截图所示：
- en: '![](img/ec5b9a53-7f99-40b2-91f4-d38bc84233d3.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec5b9a53-7f99-40b2-91f4-d38bc84233d3.png)'
- en: 'Let’s understand the program we have written:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们编写的程序：
- en: Using `import ( "database/sql" "fmt" "log" "net/http" _ "github.com/go-sql-driver/mysql")`,
    we imported `github.com/go-sql-driver/mysql` for its side effects or initialization,
    using the underscore in front of an import statement explicitly.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`import ("database/sql" "fmt" "log" "net/http" _ "github.com/go-sql-driver/mysql")`，我们导入了`github.com/go-sql-driver/mysql`以进行副作用或初始化，使用下划线在导入语句前面明确表示。
- en: Using `var db *sql.DB`, we declared a private `DB` instance.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`var db *sql.DB`，我们声明了一个私有的`DB`实例。
- en: Depending on the project size, you can declare a DB instance globally, inject
    it as a dependency using handlers, or put the connection pool pointer into `x/net/context`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目大小，您可以全局声明一个DB实例，使用处理程序将其注入为依赖项，或将连接池指针放入`x/net/context`中。
- en: Next, we defined an `init()` function where we connect to the database passing
    the database driver name and data source to it.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`init()`函数，在其中我们连接到数据库并将数据库驱动程序名称和数据源传递给它。
- en: Then, we defined a `getCurrentDb` handler, which basically performs a select
    query on the database to get the current database name, iterates over the records,
    copies its value into the variable, and eventually writes it to an HTTP response
    stream.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个`getCurrentDb`处理程序，基本上在数据库上执行选择查询以获取当前数据库名称，遍历记录，将其值复制到变量中，最终将其写入HTTP响应流。
- en: Creating your first record in MySQL
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MySQL中创建您的第一条记录
- en: Creating or saving a record in a database requires us to write SQL queries and
    execute them, implement **object-relational mapping** (**ORM**), or implement
    data-mapping techniques.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中创建或保存记录需要我们编写SQL查询并执行它们，实现**对象关系映射**（**ORM**），或实现数据映射技术。
- en: In this recipe, we will be writing a SQL query and executing it using the `database/sql`
    package to create a record. To achieve this, you can also implement ORM using
    any library from a number of third-party libraries available in Go, such as `https://github.com/jinzhu/gorm`,
    `https://github.com/go-gorp/gorp`, and `https://github.com/jirfag/go-queryset`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个SQL查询，并使用`database/sql`包执行它来创建一条记录。为了实现这一点，您还可以使用Go中许多第三方库中可用的任何库来实现ORM，例如`https://github.com/jinzhu/gorm`，`https://github.com/go-gorp/gorp`和`https://github.com/jirfag/go-queryset`。
- en: Getting ready…
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: As we have already established a connection with the MySQL database in our previous
    recipe, we will just extend it to create a record executing a SQL query.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在上一个示例中已经与MySQL数据库建立了连接，我们将扩展它以执行SQL查询来创建一条记录。
- en: 'Before creating a record, we have to create a table in the MySQL database,
    which we will do by executing the commands shown in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建记录之前，我们必须在MySQL数据库中创建一个表，我们将通过执行以下截图中显示的命令来完成：
- en: '![](img/0cf3005e-2549-4802-b109-2d2c18bc9a27.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cf3005e-2549-4802-b109-2d2c18bc9a27.png)'
- en: How to do it…
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'Install the `github.com/go-sql-driver/mysql` and `github.com/gorilla/mux` packages,
    using the `go get` command, as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/go-sql-driver/mysql`和`github.com/gorilla/mux`包，如下所示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create `create-record-mysql.go`. Then we connect to the MySQL database and
    perform an INSERT query to create an employee record, as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`create-record-mysql.go`。然后我们连接到MySQL数据库并执行INSERT查询以创建员工记录，如下所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the program with the following command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，HTTP服务器将在本地监听端口`8080`。
- en: 'Executing a `POST` request to create an employee record from the command line
    as follows will give you the ID of the last record created:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行执行`POST`请求以创建员工记录，将会给出最后创建的记录的ID：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s understand the program we have written:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解我们编写的程序：
- en: Using `import ("database/sql" "fmt" "log" "net/http" "strconv" _ "github.com/go-sql-driver/mysql"
    "github.com/gorilla/mux")`, we imported `github.com/gorilla/mux` to create a Gorilla
    Mux Router and initialized the Go MySQL driver, importing the `github.com/go-sql-driver/mysql`
    package.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`import ("database/sql" "fmt" "log" "net/http" "strconv" _ "github.com/go-sql-driver/mysql"
    "github.com/gorilla/mux")`，我们导入了`github.com/gorilla/mux`来创建一个Gorilla Mux路由器，并初始化了Go
    MySQL驱动，导入了`github.com/go-sql-driver/mysql`包。
- en: Next, we defined a `createRecord` handler, which fetches the name from the request,
    assigns it to the local variable name, prepares an `INSERT` statement with a name
    placeholder that will be replaced dynamically with the name, executes the statement,
    and eventually writes the last created ID to an HTTP response stream.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`createRecord`处理程序，它从请求中获取姓名，将其分配给本地变量名，准备一个带有姓名占位符的`INSERT`语句，该占位符将动态替换为姓名，执行该语句，并最终将最后创建的ID写入HTTP响应流。
- en: Reading records from MySQL
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从MySQL中读取记录
- en: In the previous recipe, we created an employee record in the MySQL database.
    Now, in this recipe, we will learn how we can read it by executing a SQL query.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们在MySQL数据库中创建了一个员工记录。现在，在这个示例中，我们将学习如何通过执行SQL查询来读取它。
- en: How to do it…
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'Install the `github.com/go-sql-driver/mysql` and `github.com/gorilla/mux` packages
    using the `go get` command, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/go-sql-driver/mysql`和`github.com/gorilla/mux`包，如下所示：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create `read-record-mysql.go` where we connect to the MySQL database, perform
    a `SELECT` query to get all the employees from the database, iterate over the
    records, copy its value into the struct, add all of them to a list, and write
    it to an HTTP response stream, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`read-record-mysql.go`，在其中我们连接到MySQL数据库，执行`SELECT`查询以获取数据库中的所有员工，遍历记录，将其值复制到结构体中，将所有记录添加到列表中，并将其写入HTTP响应流，如下所示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the program with the following command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Once we run the program, the HTTP server will start locally listening on port `8080`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，HTTP服务器将在本地监听端口`8080`。
- en: 'Browsing to `http://localhost:8080/employees` will list all the records from
    the employee table as shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost:8080/employees`将列出员工表中的所有记录，如下截图所示：
- en: '![](img/c289af02-53f5-42d2-8b78-582b369e93fa.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c289af02-53f5-42d2-8b78-582b369e93fa.png)'
- en: 'Let’s look at the program we have written:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们编写的程序：
- en: Using `import ( "database/sql" "encoding/json" "log" "net/http" _ "github.com/go-sql-driver/mysql"
    "github.com/gorilla/mux")`, we imported an additional package, `encoding/json`,
    which helps in marshalling the Go data structure to `JSON`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`import ("database/sql" "encoding/json" "log" "net/http" _ "github.com/go-sql-driver/mysql"
    "github.com/gorilla/mux")`，我们导入了一个额外的包`encoding/json`，它有助于将Go数据结构编组为`JSON`。
- en: Next, we declared the Go data structure `Person`, which has `Id` and `Name`
    fields.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们声明了Go数据结构`Person`，它具有`Id`和`Name`字段。
- en: Do remember that the field name should begin with a capital letter in the type
    definition or there could be errors.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在类型定义中字段名称应以大写字母开头，否则可能会出现错误。
- en: Next, we defined a `readRecords` handler, which queries the database to get
    all the records from the employee table, iterates over the records, copies its
    value into the struct, adds all the records to a list, marshals the object list
    to JSON, and writes it to an HTTP response stream.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`readRecords`处理程序，它查询数据库以获取员工表中的所有记录，遍历记录，将其值复制到结构体中，将所有记录添加到列表中，将对象列表编组为JSON，并将其写入HTTP响应流。
- en: Updating your first record in MySQL
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MySQL中更新您的第一个记录
- en: Consider a scenario where you have created a record for an employee in a database
    with all its details, such as name, department, address, and so on, and after
    some time the employee changes departments. In that case, we have to update their
    department in a database so that their details are in sync all across the organization,
    which can be achieved using a `SQL UPDATE` statement, and in this recipe we will
    learn how we can implement it in Go.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个情景，你在数据库中创建了一个员工的记录，包括姓名、部门、地址等所有细节，一段时间后员工更换了部门。在这种情况下，我们必须在数据库中更新他们的部门，以便他们的详细信息在整个组织中保持同步，这可以通过`SQL
    UPDATE`语句实现，在这个示例中，我们将学习如何在Go中实现它。
- en: How to do it…
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'Install the `github.com/go-sql-driver/mysql` and `github.com/gorilla/mux` packages,
    using the `go get` command, as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/go-sql-driver/mysql`和`github.com/gorilla/mux`包，如下所示：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create `update-record-mysql.go`. Then we connect to the MySQL database, update
    the name of an employee for an ID, and write the number of records updated in
    a database to an HTTP response stream, as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`update-record-mysql.go`。然后我们连接到MySQL数据库，更新员工的姓名，然后将更新的记录数量写入数据库到HTTP响应流中，如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the program with the following command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Next, executing a `PUT` request from the command line to update an employee
    record with the ID as `1` will give you the number of records updated in the database
    as a response:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从命令行执行`PUT`请求以更新ID为`1`的员工记录将给出数据库中更新的记录数作为响应：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s look at the program we have written:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们编写的程序：
- en: We defined an `updateRecord` handler, which gets the ID to be updated in the
    database as a URL path variable path, and the new name as the request variable,
    prepares an `update` statement with a name and UID as a placeholder, which will
    be replaced dynamically, executes the statement, gets the number of rows updated
    as a result of its execution, and writes it to an HTTP response stream.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`updateRecord`处理程序，它以URL路径变量路径中要更新的ID和请求变量中的新名称作为输入，准备一个带有名称和UID占位符的`update`语句，该占位符将动态替换，执行该语句，获取执行结果中更新的行数，并将其写入HTTP响应流。
- en: Next, we registered an `updateRecord` handler to be called for the URL pattern `/employee/update/{id}` for
    every `PUT` request with the `gorilla/mux` router and closed the database using
    the `defer db.Close()` statement once we return from the `main()` function.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们注册了一个`updateRecord`处理程序，用于处理`gorilla/mux`路由器中`/employee/update/{id}`的URL模式的每个`PUT`请求，并在从`main()`函数返回时使用`defer
    db.Close()`语句关闭数据库。
- en: Deleting your first record from MySQL
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从MySQL中删除您的第一条记录
- en: Consider a scenario where an employee has left the organization and you want
    to revoke their details from the database. In that case, we can use the `SQL DELETE`
    statement, which we will be covering in this recipe.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个情景，员工已经离开组织，您想要从数据库中撤销他们的详细信息。在这种情况下，我们可以使用`SQL DELETE`语句，我们将在本教程中介绍。
- en: How to do it…
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Install the `github.com/go-sql-driver/mysql` and `github.com/gorilla/mux` packages,
    using the `go get` command, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/go-sql-driver/mysql`和`github.com/gorilla/mux`包，如下所示：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create `delete-record-mysql.go`. Then we connect to the MySQL database, delete
    the name of an employee from the database, and write the number of records deleted
    from a database to an HTTP response stream, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`delete-record-mysql.go`。然后我们连接到MySQL数据库，从数据库中删除员工的名称，并将从数据库中删除的记录数写入HTTP响应流，如下所示：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the program with the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Next, executing a `DELETE` request from the command line to delete an employee
    with the name as `bar` will give you the number of records deleted from the database:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从命令行执行`DELETE`请求以删除名称为`bar`的员工将给出从数据库中删除的记录数：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s look at the program we have written:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们编写的程序：
- en: We defined a `deleteRecord` handler, which gets the name to be deleted from
    the database as the request variable, prepares a `DELETE` statement with a name
    as a placeholder, which will be replaced dynamically, executes the statement,
    gets the count of rows deleted as a result of its execution, and writes it to
    an HTTP response stream.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`deleteRecord`处理程序，它以请求变量中要从数据库中删除的名称作为输入，准备一个带有名称占位符的`DELETE`语句，该占位符将动态替换，执行该语句，获取执行结果中删除的行数，并将其写入HTTP响应流。
- en: Next, we registered a `deleteRecord` handler to be called for the URL pattern `/employee/delete`
    for every `DELETE` request with `gorilla/mux` router and closed the database using
    the `defer db.Close()` statement once we returned from the `main()` function.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们注册了一个`deleteRecord`处理程序，用于处理`gorilla/mux`路由器中`/employee/delete`的URL模式的每个`DELETE`请求，并在从`main()`函数返回时使用`defer
    db.Close()`语句关闭数据库。
- en: Integrating MongoDB and Go
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成MongoDB和Go
- en: Whenever you want to persist data in a MongoDB database, the first step you
    have to take is to establish a connection between the database and your web application,
    which we will be covering in this recipe using one of the most famous and commonly
    used MongoDB drivers for Go - `gopkg.in/mgo.v2`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您想要在MongoDB数据库中持久保存数据时，您必须采取的第一步是在数据库和您的Web应用程序之间建立连接，在本教程中，我们将使用Go中最著名和常用的MongoDB驱动程序之一`gopkg.in/mgo.v2`。
- en: Getting ready…
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: 'Verify whether `MongoDB` is installed and running locally on port `27017` by
    executing the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令验证`MongoDB`是否安装并在本地端口`27017`上运行：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should return the following response:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回以下响应：
- en: '![](img/063c04f9-4a03-455a-b1f7-723eba8828e7.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/063c04f9-4a03-455a-b1f7-723eba8828e7.png)'
- en: How to do it…
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Install the `gopkg.in/mgo.v` package, using the `go get` command, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`gopkg.in/mgo.v`包，如下所示：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create `connect-mongodb.go`. Then we connect to the `MongoDB` database, get
    all the database names from the cluster, and write them to an HTTP response stream,
    as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`connect-mongodb.go`。然后我们连接到`MongoDB`数据库，从集群中获取所有数据库名称，并将它们写入HTTP响应流，如下所示：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the program with the following command:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Browsing to `http://localhost:8080/` will list you the name of all the databases
    that exist in the MongoDB cluster and will look as shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost:8080/`将列出MongoDB集群中存在的所有数据库的名称，并显示如下屏幕截图所示：
- en: '![](img/d3f544b8-eaf5-4716-8018-51e858236b81.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3f544b8-eaf5-4716-8018-51e858236b81.png)'
- en: 'Let’s look at the program we have written:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们编写的程序：
- en: Using `import ( "fmt" "log" "net/http" "strings" mgo
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`import（"fmt" "log" "net/http" "strings" mgo
- en: '"gopkg.in/mgo.v2" )`, we imported `gopkg.in/mgo.v2` with the package alias
    name as `mgo`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '"gopkg.in/mgo.v2"）`，我们导入了`gopkg.in/mgo.v2`并使用`mgo`作为包别名。'
- en: Using `var session *mgo.Session`, we declared the private MongoDB `Session`
    instance, which acts as a communication session with the database.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`var session *mgo.Session`，我们声明了私有的MongoDB`Session`实例，它作为与数据库的通信会话。
- en: Using `var connectionError error`, we declared a private `error` object.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`var connectionError error`，我们声明了一个私有的`error`对象。
- en: Next, we defined the `init()` function, where we connected to MongoDB, passing
    the host as `127.0.0.1`, which means both MongoDB and the application are running
    on the same machine at port `27017`, optionally switching the session to a monotonic
    behavior so that the read data will be consistent across sequential queries in
    the same session, and modifications made within the session will be observed in
    the queries that follow.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`init()`函数，在这里我们连接到MongoDB，传递主机为`127.0.0.1`，这意味着MongoDB和应用程序都在同一台机器上的端口`27017`上运行，可选择将会话切换到单调行为，以便在同一会话中的顺序查询中读取的数据将是一致的，并且在会话中进行的修改将在随后的查询中被观察到。
- en: If your MongoDB is running on a port other than `27017`, then you have to pass
    both the host and port separated by a colon, as: `mgo.Dial("localhost:27018")`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的MongoDB运行在除`27017`之外的端口上，那么你必须传递主机和端口，用冒号分隔，如：`mgo.Dial("localhost:27018")`。
- en: Next, we defined a `getDbNames` handler, which basically gets all the database
    names from the MongoDB cluster and writes them to an HTTP response stream as a
    comma-separated string.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`getDbNames`处理程序，它基本上从MongoDB集群中获取所有数据库名称，并将它们作为逗号分隔的字符串写入HTTP响应流。
- en: Creating your first document in MongoDB
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MongoDB中创建你的第一个文档
- en: In this recipe, we will learn how we can create a BSON document (a binary-encoded
    serialization of JSON-like documents) in a database, using a MongoDB driver for
    Go ([gopkg.in/mgo.v2](http://gopkg.in/mgo.v2)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在数据库中创建一个BSON文档（JSON样式文档的二进制编码序列化），使用Go的MongoDB驱动程序（[gopkg.in/mgo.v2](http://gopkg.in/mgo.v2)）。
- en: How to do it…
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install the `gopkg.in/mgo.v2` and `github.com/gorilla/mux` packages, using
    the `go get` command, as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令，安装`gopkg.in/mgo.v2`和`github.com/gorilla/mux`包：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create `create-record-mongodb.go`. Then we connect to the MongoDB database,
    create an employee document with two fields—ID and name—and write the last created
    document ID to an HTTP response stream, as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`create-record-mongodb.go`。然后我们连接到MongoDB数据库，创建一个包含两个字段（ID和姓名）的员工文档，并将最后创建的文档ID写入HTTP响应流，如下所示：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the program with the following command:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Next, executing a `POST` request to create an employee document from the command
    line as follows will give you the ID of the document created in MongoDB:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，执行以下命令行中的`POST`请求来创建一个员工文档将会给你在MongoDB中创建的文档的ID：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s look at the program we have written:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们编写的程序：
- en: Using `import ( "fmt" "log" "net/http" "strconv" "github.com/gorilla/mux" mgo
    "gopkg.in/mgo.v2")`, we imported `github.com/gorilla/mux` to create a Gorilla
    Mux Router and `gopkg.in/mgo.v2` with the package alias name as `mgo`, which will
    act as a MongoDB driver.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`import ("fmt" "log" "net/http" "strconv" "github.com/gorilla/mux" mgo "gopkg.in/mgo.v2")`，我们导入了`github.com/gorilla/mux`来创建一个Gorilla
    Mux路由器，以及`gopkg.in/mgo.v2`，包别名为`mgo`，它将作为MongoDB驱动程序。
- en: Next, we defined a `createDocument` handler, which fetches the name and ID of
    an employee from the HTTP request. Because request variables are of type `string`,
    we converted the variable ID of `string` type to `int` type. Then, we get the
    employee collection from MongoDB and call the `collection.Insert` handler to save
    an instance of the `Employee` struct type in the database.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`createDocument`处理程序，它从HTTP请求中获取员工的姓名和ID。因为请求变量的类型是`string`，我们将`string`类型的变量ID转换为`int`类型。然后，我们从MongoDB获取员工集合，并调用`collection.Insert`处理程序将`Employee`结构类型的实例保存到数据库中。
- en: Reading documents from MongoDB
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从MongoDB中读取文档
- en: In the previous recipe, we created a BSON document in MongoDB. Now, in this
    recipe, we will learn how to read it using the `gopkg.in/mgo.v2/bson` package,
    which helps to query the MongoDB collection.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们在MongoDB中创建了一个BSON文档。现在，在这个示例中，我们将学习如何使用`gopkg.in/mgo.v2/bson`包来读取它，该包有助于查询MongoDB集合。
- en: How to do it…
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install the `gopkg.in/mgo.v2`, `gopkg.in/mgo.v2/bson`, and `github.com/gorilla/mux`
    packages, using the `go get` command, as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令，安装`gopkg.in/mgo.v2`、`gopkg.in/mgo.v2/bson`和`github.com/gorilla/mux`包：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create `read-record-mongodb.go`. Then we connect to the MongoDB database, read
    all the documents from an employee collection, marshal the list to JSON, and write
    it to an HTTP response stream, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`read-record-mongodb.go`。然后我们连接到MongoDB数据库，读取员工集合中的所有文档，将列表编组为JSON，并将其写入HTTP响应流，如下所示：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the program with the following command:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Next, browsing to `http://localhost:8080/employees` will give you the list
    of all employees from the MongoDB employee collection:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，浏览到`http://localhost:8080/employees`将会给你MongoDB员工集合中所有员工的列表：
- en: '![](img/76fe5abd-4e48-4d30-aa23-d97d15b85a61.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76fe5abd-4e48-4d30-aa23-d97d15b85a61.png)'
- en: 'Let’s look at the changes we introduced in the program:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们在程序中引入的更改：
- en: Using `import ( "encoding/json" "log" "net/http" "github.com/gorilla/mux" mgo
    "gopkg.in/mgo.v2" "gopkg.in/mgo.v2/bson")`, we imported an additional `gopkg.in/mgo.v2/bson`
    package, which is a BSON specification for Go, and the `encoding/json` package,
    which we used to marshal the object list, which we got from MongoDB, to `JSON`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`import ("encoding/json" "log" "net/http" "github.com/gorilla/mux" mgo "gopkg.in/mgo.v2"
    "gopkg.in/mgo.v2/bson")`，我们导入了额外的`gopkg.in/mgo.v2/bson`包，它是Go的BSON规范，以及`encoding/json`包，我们用它来将我们从MongoDB获取的对象列表编组为`JSON`。
- en: Next, we defined a `readDocuments` handler, where we first get the employee
    collection from MongoDB, query for all the documents inside it, iterate over the
    documents to map it to an array of the `Employee` struct, and, finally, marshal
    it to `JSON`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`readDocuments`处理程序，在这里我们首先从MongoDB获取员工集合，查询其中的所有文档，遍历文档将其映射到`Employee`结构的数组中，最后将其编组为`JSON`。
- en: Updating your first document in MongoDB
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MongoDB中更新您的第一个文档
- en: Once a BSON document is created we may need to update some of its fields. In
    that case, we have to execute `update/upsert` queries on the MongoDB collection,
    which we will be covering in this recipe.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个BSON文档，我们可能需要更新其中的一些字段。在这种情况下，我们必须在MongoDB集合上执行`update/upsert`查询，这将在本教程中介绍。
- en: How to do it…
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Install the `gopkg.in/mgo.v2`, `gopkg.in/mgo.v2/bson`, and `github.com/gorilla/mux`
    packages, using the `go get` command, as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`gopkg.in/mgo.v2`、`gopkg.in/mgo.v2/bson`和`github.com/gorilla/mux`包，如下所示：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create `update-record-mongodb.go`. Then we connect to the MongoDB database,
    update the name of an employee for an ID, and write the number of records updated
    in MongoDB to an HTTP response stream, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`update-record-mongodb.go`。然后我们连接到MongoDB数据库，更新ID的员工的名称，并将在HTTP响应流中写入在MongoDB中更新的记录数量，如下所示：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the program with the following command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Next, executing a `PUT` request to `UPDATE` an employee document from the command
    line as follows will give you the number of documents updated in MongoDB:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过命令行执行`PUT`请求来更新员工文档，如下所示，将会给出在MongoDB中更新的文档数量：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s look at the program we have written:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们写的程序：
- en: We defined an `updateDocument` handler, which gets the ID to be updated in MongoDB
    as a URL path variable and the new name as the HTTP request variable. As request
    variables are of string type, we have converted the variable ID of `string` type
    to `int` type. Then, we get the employee collection from MongoDB and call the
    `collection.Upsert` handler to insert if not present, or update an employee document
    with a new name for the supplied ID.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`updateDocument`处理程序，它从URL路径变量中获取要在MongoDB中更新的ID和作为HTTP请求变量的新名称。由于请求变量是字符串类型，我们将`string`类型的变量ID转换为`int`类型。然后，我们从MongoDB获取员工集合，并调用`collection.Upsert`处理程序，以插入（如果不存在）或更新具有新名称的员工文档的ID。
- en: Next, we registered an `updateDocument` handler to be called for the URL pattern `/employee/update/{id}` for
    every `PUT` request with `gorilla/mux` router and close the MongoDB session, using
    the `defer session.Close()` statement once we return from the `main()` function.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们注册了一个`updateDocument`处理程序，用于处理`/employee/update/{id}`的URL模式，对于每个使用`gorilla/mux`路由器的`PUT`请求，并在我们从`main()`函数返回时使用`defer
    session.Close()`语句关闭MongoDB会话。
- en: Deleting your first document from MongoDB
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从MongoDB中删除您的第一个文档
- en: Whenever we want to clean up the database or delete the documents that are no
    longer needed, we can easily remove them using a MongoDB driver for Go ([gopkg.in/mgo.v2](http://gopkg.in/mgo.v2)),
    which we will be covering in this recipe.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要清理数据库或删除不再需要的文档时，我们可以使用Go的MongoDB驱动程序（[gopkg.in/mgo.v2](http://gopkg.in/mgo.v2)）轻松地删除它们，这将在本教程中介绍。
- en: How to do it…
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Install the `gopkg.in/mgo.v2`, `gopkg.in/mgo.v2/bson`, and `github.com/gorilla/mux`
    packages, using the `go get` command, as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`gopkg.in/mgo.v2`、`gopkg.in/mgo.v2/bson`和`github.com/gorilla/mux`包，如下所示：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create `delete-record-mongodb.go`. Then we connect to MongoDB, get the name
    of an employee to be deleted from the database as an HTTP request variable, get
    the named collection, and remove the document, as follows:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`delete-record-mongodb.go`。然后我们连接到MongoDB，从数据库中获取要删除的员工的名称作为HTTP请求变量，获取命名集合，并按如下方式删除文档：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the program with the following command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works…
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Next, executing a `DELETE` request to delete a BSON document from the command
    line as follows will give you the name of the document deleted from the database:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过命令行执行`DELETE`请求来删除BSON文档，如下所示，将会给出从数据库中删除的文档的名称：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s look at the program we have written:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们写的程序：
- en: We defined a `deleteDocument` handler, which gets the name to be deleted from
    MongoDB as the request variable, gets the employee collection from MongoDB, and
    calls the `collection.Remove` handler to remove a document for a given name.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`deleteDocument`处理程序，它从MongoDB获取要删除的名称作为请求变量，从MongoDB获取员工集合，并调用`collection.Remove`处理程序来删除给定名称的文档。
- en: Then, we registered a `deleteDocument` handler to be called for the URL pattern `/employee/delete` for
    every `DELETE` request with a `gorilla/mux` router, and closed the MongoDB session, using
    the `defer session.Close()` statement once we returned from the `main()` function.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们注册了一个`deleteDocument`处理程序，用于处理`/employee/delete`的URL模式，对于每个使用`gorilla/mux`路由器的`DELETE`请求，并在我们从`main()`函数返回时使用`defer
    session.Close()`语句关闭MongoDB会话。
