["```go\n$ openssl\nOpenSSL> exit\n```", "```go\n$ openssl req -newkey rsa:2048 -nodes -keyout domain.key -out domain.csr -subj \"/C=IN/ST=Mumbai/L=Andheri East/O=Packt/CN=packtpub.com\"\n```", "```go\n$ openssl req -key domain.key -new -x509 -days 365 -out domain.crt -subj \"/C=IN/ST=Mumbai/L=Andheri East/O=Packt/CN=packtpub.com\"\n```", "```go\nopenssl req -key domain.key -new -x509 -days 365 -out domain.crt -subj \"/C=IN/ST=Mumbai/L=Andheri East/O=Packt/CN=packtpub.com\"\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8443\"\n  HTTPS_CERTIFICATE = \"domain.crt\"\n  DOMAIN_PRIVATE_KEY = \"domain.key\"\n)\nfunc helloWorld(w http.ResponseWriter, r *http.Request) \n{\n  fmt.Fprintf(w, \"Hello World!\")\n}\nfunc main() \n{\n  http.HandleFunc(\"/\", helloWorld)\n  err := http.ListenAndServeTLS(CONN_HOST+\":\"+CONN_PORT,\n  HTTPS_CERTIFICATE, DOMAIN_PRIVATE_KEY, nil)\n  if err != nil \n  {\n    log.Fatal(\"error starting https server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run https-server.go\n```", "```go\n$ curl -X GET https://localhost:8443/ --insecure\n Hello World!\n```", "```go\n$ go get github.com/gorilla/mux\n$ go get github.com/gorilla/handlers\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"os\"\n  \"github.com/gorilla/handlers\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n)\ntype Employee struct \n{\n  Id int `json:\"id\"`\n  FirstName string `json:\"firstName\"`\n  LastName string `json:\"lastName\"`\n}\ntype Employees []Employee\nvar employees []Employee\nfunc init() \n{\n  employees = Employees\n  {\n    Employee{Id: 1, FirstName: \"Foo\", LastName: \"Bar\"},\n    Employee{Id: 2, FirstName: \"Baz\", LastName: \"Qux\"},\n  }\n}\nfunc getStatus(w http.ResponseWriter, r *http.Request) \n{\n  w.Write([]byte(\"API is up and running\"))\n}\nfunc getEmployees(w http.ResponseWriter, r *http.Request) \n{\n  json.NewEncoder(w).Encode(employees)\n}\nfunc getToken(w http.ResponseWriter, r *http.Request) \n{ \n  w.Write([]byte(\"Not Implemented\"))\n}\nfunc main() \n{\n  router := mux.NewRouter().StrictSlash(true)\n  router.HandleFunc(\"/status\", getStatus).Methods(\"GET\")\n  router.HandleFunc(\"/get-token\", getToken).Methods(\"GET\")\n  router.HandleFunc(\"/employees\", getEmployees).Methods(\"GET\")\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT,\n  handlers.LoggingHandler(os.Stdout, router))\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-rest-api.go\n```", "```go\n$ curl -X GET http://localhost:8080/status\n API is up and running\n```", "```go\n$ curl -X GET http://localhost:8080/employees\n [{\"id\":1,\"firstName\":\"Foo\",\"lastName\":\"Bar\"},{\"id\":2,\"firstName\":\"Baz\",\"lastName\":\"Qux\"}]\n```", "```go\n$ curl -X GET http://localhost:8080/get-token\n```", "```go\n$ go get github.com/dgrijalva/jwt-go\n$ go get github.com/gorilla/handlers\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"os\"\n  \"time\"\n  jwt \"github.com/dgrijalva/jwt-go\"\n  \"github.com/gorilla/handlers\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  CLAIM_ISSUER = \"Packt\"\n  CLAIM_EXPIRY_IN_HOURS = 24\n)\ntype Employee struct \n{\n  Id int `json:\"id\"`\n  FirstName string `json:\"firstName\"`\n  LastName string `json:\"lastName\"`\n}\ntype Employees []Employee\nvar employees []Employee\nfunc init() \n{\n  employees = Employees\n  {\n    Employee{Id: 1, FirstName: \"Foo\", LastName: \"Bar\"},\n    Employee{Id: 2, FirstName: \"Baz\", LastName: \"Qux\"},\n  }\n}\nvar signature = []byte(\"secret\")\nfunc getToken(w http.ResponseWriter, r *http.Request) \n{\n  claims := &jwt.StandardClaims\n  {\n    ExpiresAt: time.Now().Add(time.Hour *\n    CLAIM_EXPIRY_IN_HOURS).Unix(),\n    Issuer: CLAIM_ISSUER,\n  }\n  token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n  tokenString, _ := token.SignedString(signature)\n  w.Write([]byte(tokenString))\n}\nfunc getStatus(w http.ResponseWriter, r *http.Request) \n{\n  w.Write([]byte(\"API is up and running\"))\n}\nfunc getEmployees(w http.ResponseWriter, r *http.Request) \n{\n  json.NewEncoder(w).Encode(employees)\n}\nfunc main() \n{\n  muxRouter := mux.NewRouter().StrictSlash(true)\n  muxRouter.HandleFunc(\"/status\", getStatus).Methods(\"GET\")\n  muxRouter.HandleFunc(\"/get-token\", getToken).Methods(\"GET\")\n  muxRouter.HandleFunc(\"/employees\", getEmployees).Methods(\"GET\")\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT,\n  handlers.LoggingHandler(os.Stdout, muxRouter))\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run create-jwt.go\n```", "```go\n$ curl -X GET http://localhost:8080/status\n API is up and running\n```", "```go\n$ curl -X GET http://localhost:8080/employees\n [{\"id\":1,\"firstName\":\"Foo\",\"lastName\":\"Bar\"},{\"id\":2,\"firstName\":\"Baz\",\"lastName\":\"Qux\"}]\n```", "```go\n$ curl -X GET http://localhost:8080/get-token\n```", "```go\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MTM1MDY4ODEsImlzcyI6IlBhY2t0In0.95vuiR7lpWt4AIBDasBzOffL_Xv78_J9rcrKkeqSW08\n```", "```go\n$ go get github.com/auth0/go-jwt-middleware\n$ go get github.com/dgrijalva/jwt-go\n$ go get github.com/gorilla/handlers\n$ go get github.com/gorilla/mux\n```", "```go\npackage main\nimport \n(\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n  \"os\"\n  \"time\"\n  jwtmiddleware \"github.com/auth0/go-jwt-middleware\"\n  jwt \"github.com/dgrijalva/jwt-go\"\n  \"github.com/gorilla/handlers\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8080\"\n  CLAIM_ISSUER = \"Packt\"\n  CLAIM_EXPIRY_IN_HOURS = 24\n)\ntype Employee struct \n{\n  Id int `json:\"id\"`\n  FirstName string `json:\"firstName\"`\n  LastName string `json:\"lastName\"`\n}\ntype Employees []Employee\nvar employees []Employee\nfunc init() \n{\n  employees = Employees\n  {\n    Employee{Id: 1, FirstName: \"Foo\", LastName: \"Bar\"},\n    Employee{Id: 2, FirstName: \"Baz\", LastName: \"Qux\"},\n  }\n}\nvar signature = []byte(\"secret\")\nvar jwtMiddleware = jwtmiddleware.New\n(\n  jwtmiddleware.Options\n  {\n    ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) \n    {\n      return signature, nil\n    },\n    SigningMethod: jwt.SigningMethodHS256,\n  }\n)\nfunc getToken(w http.ResponseWriter, r *http.Request) \n{\n  claims := &jwt.StandardClaims\n  {\n    ExpiresAt: time.Now().Add(time.Hour *\n    CLAIM_EXPIRY_IN_HOURS).Unix(),\n    Issuer: CLAIM_ISSUER,\n  }\n  token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n  tokenString, _ := token.SignedString(signature)\n  w.Write([]byte(tokenString))\n}\nfunc getStatus(w http.ResponseWriter, r *http.Request) \n{\n  w.Write([]byte(\"API is up and running\"))\n}\nfunc getEmployees(w http.ResponseWriter, r *http.Request) \n{\n  json.NewEncoder(w).Encode(employees)\n}\nfunc main() \n{\n  muxRouter := mux.NewRouter().StrictSlash(true)\n  muxRouter.HandleFunc(\"/status\", getStatus).Methods(\"GET\")\n  muxRouter.HandleFunc(\"/get-token\", getToken).Methods(\"GET\")\n  muxRouter.Handle(\"/employees\", jwtMiddleware.Handler\n  (http.HandlerFunc(getEmployees))).Methods(\"GET\")\n  err := http.ListenAndServe(CONN_HOST+\":\"+CONN_PORT,\n  handlers.LoggingHandler(os.Stdout, muxRouter))\n  if err != nil \n  {\n    log.Fatal(\"error starting http server : \", err)\n    return\n  }\n}\n```", "```go\n$ go run http-rest-api-secured.go\n```", "```go\n$ curl -X GET http://localhost:8080/status\n API is up and running\n```", "```go\n$ curl -X GET http://localhost:8080/employees\n Required authorization token not found\n```", "```go\n$ curl -X GET http://localhost:8080/get-token\n\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MTM1MTI2NTksImlzcyI6IlBhY2t0In0.2r_q_82erdOmt862ofluiMGr3O5x5_c0_sMyW7Pi5XE\n```", "```go\n$ curl -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MTM1MTI2NTksImlzcyI6IlBhY2t0In0.2r_q_82erdOmt862ofluiMGr3O5x5_c0_sMyW7Pi5XE\" http://localhost:8080/employees\n```", "```go\n[{\"id\":1,\"firstName\":\"Foo\",\"lastName\":\"Bar\"},{\"id\":2,\"firstName\":\"Baz\",\"lastName\":\"Qux\"}]\n```", "```go\n$ go get github.com/gorilla/csrf\n$ go get github.com/gorilla/mux\n```", "```go\n<html>\n  <head>\n    <title>Sign Up!</title>\n  </head>\n  <body>\n    <form method=\"POST\" action=\"/post\" accept-charset=\"UTF-8\">\n      <input type=\"text\" name=\"name\">\n      <input type=\"text\" name=\"email\">\n      {{ .csrfField }}\n      <input type=\"submit\" value=\"Sign up!\">\n    </form>\n  </body>\n</html>\n```", "```go\npackage main\nimport \n(\n  \"fmt\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"github.com/gorilla/csrf\"\n  \"github.com/gorilla/mux\"\n)\nconst \n(\n  CONN_HOST = \"localhost\"\n  CONN_PORT = \"8443\"\n  HTTPS_CERTIFICATE = \"domain.crt\"\n  DOMAIN_PRIVATE_KEY = \"domain.key\"\n)\nvar AUTH_KEY = []byte(\"authentication-key\")\nfunc signUp(w http.ResponseWriter, r *http.Request) \n{\n  parsedTemplate, _ := template.ParseFiles(\"sign-up.html\")\n  err := parsedTemplate.Execute\n  (\n    w, map[string]interface{}\n    {\n      csrf.TemplateTag: csrf.TemplateField(r),\n    }\n  )\n  if err != nil \n  {\n    log.Printf(\"Error occurred while executing the \n    template : \", err)\n    return\n  }\n}\nfunc post(w http.ResponseWriter, r *http.Request) \n{\n  err := r.ParseForm()\n  if err != nil \n  {\n    log.Print(\"error occurred while parsing form \", err)\n  }\n  name := r.FormValue(\"name\")\n  fmt.Fprintf(w, \"Hi %s\", name)\n}\nfunc main() \n{\n  muxRouter := mux.NewRouter().StrictSlash(true)\n  muxRouter.HandleFunc(\"/signup\", signUp)\n  muxRouter.HandleFunc(\"/post\", post)\n  http.ListenAndServeTLS(CONN_HOST+\":\"+CONN_PORT, \n  HTTPS_CERTIFICATE, DOMAIN_PRIVATE_KEY, csrf.Protect\n  (AUTH_KEY)(muxRouter))\n}\n```", "```go\n$ go run prevent-csrf.go\n```", "```go\n$ curl -X POST --data \"name=Foo&email=aggarwalarpit.89@gmail.com\" https://localhost:8443/post --insecure\n```", "```go\n$ curl -i -X GET https://localhost:8443/signup --insecure\n```", "```go\n$ curl -X POST --data \"name=Foo&email=aggarwalarpit.89@gmail.com\" -H \"X-CSRF-Token: M9gqV7rRcXERvSJVRSYprcMzwtFmjEHKXRm6C8cDC4EjTLIt4OiNzVrHfYNB12nEx280rrKs8fqOgvfcJgQiFA==\" --cookie \"_gorilla_csrf=MTUyMzQzMjg0OXxJa1ZLVTFsbGJHODFMMHg0VEdWc0wxZENVRVpCWVZGU1l6bHVMMVZKVEVGM01EVjBUakVyUlVoTFdsVTlJZ289fJI5dumuyObaHVp97GN_CiZBCCpnbO0wlIwgSgvHL7-C;\" https://localhost:8443/post --insecure\n\nHi Foo\n```"]