["```go\n// Saver persists the supplied bytes\ntype Saver interface {\n  Save(data []byte) error\n}\n\n// SavePerson will validate and persist the supplied person\nfunc SavePerson(person *Person, saver Saver) error {\n  // validate the inputs\n  err := person.validate()\n  if err != nil {\n    return err\n  }\n\n  // encode person to bytes\n  bytes, err := person.encode()\n  if err != nil {\n    return err\n  }\n\n  // save the person and return the result\n  return saver.Save(bytes)\n}\n\n// Person data object\ntype Person struct {\n   Name  string\n   Phone string\n}\n\n// validate the person object\nfunc (p *Person) validate() error {\n   if p.Name == \"\" {\n      return errors.New(\"name missing\")\n   }\n\n   if p.Phone == \"\" {\n      return errors.New(\"phone missing\")\n   }\n\n   return nil\n}\n\n// convert the person into bytes\nfunc (p *Person) encode() ([]byte, error) {\n   return json.Marshal(p)\n}\n```", "```go\n// LoadPerson will load the requested person by ID.\n// Errors include: invalid ID, missing person and failure to load \n// or decode.\nfunc LoadPerson(ID int, decodePerson func(data []byte) *Person) (*Person, error) {\n  // validate the input\n  if ID <= 0 {\n    return nil, fmt.Errorf(\"invalid ID '%d' supplied\", ID)\n  }\n\n  // load from storage\n  bytes, err := loadPerson(ID)\n  if err != nil {\n    return nil, err\n  }\n\n  // decode bytes and return\n  return decodePerson(bytes), nil\n}\n```", "```go\nfunc TestSavePerson_happyPath(t *testing.T) {\n   // input\n   in := &Person{\n      Name:  \"Sophia\",\n      Phone: \"0123456789\",\n   }\n\n   // mock the NFS\n   mockNFS := &mockSaver{}\n   mockNFS.On(\"Save\", mock.Anything).Return(nil).Once()\n\n   // Call Save\n   resultErr := SavePerson(in, mockNFS)\n\n   // validate result\n   assert.NoError(t, resultErr)\n   assert.True(t, mockNFS.AssertExpectations(t))\n}\n```", "```go\nfunc TestSavePerson_nfsAlwaysFails(t *testing.T) {\n   // input\n   in := &Person{\n      Name:  \"Sophia\",\n      Phone: \"0123456789\",\n   }\n\n   // mock the NFS\n   mockNFS := &mockSaver{}\n   mockNFS.On(\"Save\", mock.Anything).Return(errors.New(\"save failed\")).Once()\n\n   // Call Save\n   resultErr := SavePerson(in, mockNFS)\n\n   // validate result\n   assert.Error(t, resultErr)\n   assert.True(t, mockNFS.AssertExpectations(t))\n}\n```", "```go\nfunc AppendValue(buffer []byte, in interface{}) []byte{\n   var value []byte\n\n   // convert input to []byte\n   switch concrete := in.(type) {\n   case []byte:\n      value = concrete\n\n   case string:\n      value = []byte(concrete)\n\n   case int64:\n      value = []byte(strconv.FormatInt(concrete, 10))\n\n   case bool:\n      value = []byte(strconv.FormatBool(concrete))\n\n   case float64:\n      value = []byte(strconv.FormatFloat(concrete, 'e', 3, 64))\n   }\n\n   buffer = append(buffer, value...)\n   return buffer\n}\n```", "```go\n// Renderer will render a person to the supplied writer\ntype Renderer struct{}\n\nfunc (r Renderer) render(name, phone string, output io.Writer) {\n  // output the person\n}\n\n// Validator will validate the supplied person has all the \n// required fields\ntype Validator struct{}\n\nfunc (v Validator) validate(name, phone string) error {\n  // validate the person\n  return nil\n}\n\n// Saver will save the supplied person to the DB\ntype Saver struct{}\n\nfunc (s *Saver) Save(db *sql.DB, name, phone string) {\n  // save the person to db\n}\n```", "```go\n// Excessive comments\nfunc outputOrderedPeopleA(in []*Person) {\n  // This code orders people by name.\n  // In cases where the name is the same, it will order by \n  // phone number.\n  // The sort algorithm used is a bubble sort\n  // WARNING: this sort will change the items of the input array\n  for _, p := range in {\n    // ... sort code removed ...\n  }\n\n  outputPeople(in)\n}\n\n// Comments replaced with descriptive names\nfunc outputOrderedPeopleB(in []*Person) {\n  sortPeople(in)\n  outputPeople(in)\n}\n```", "```go\nfor a := float64(0); a < 360; a++ {\n   ra := math.Pi * 2 * a / 360\n   x := r*math.Sin(ra) + v\n   y := r*math.Cos(ra) + v\n   i.Set(int(x), int(y), c)\n}\n```", "```go\npackage config\n\nimport ...\n\n// Config defines the JSON format of the config file\ntype Config struct {\n   // Address is the host and port to bind to.  \n   // Default 0.0.0.0:8080\n   Address string\n\n   // DefaultCurrency is the default currency of the system\n   DefaultCurrency payment.Currency\n}\n\n// Load will load the JSON config from the file supplied\nfunc Load(filename string) (*Config, error) {\n   // TODO: load currency from file\n   return nil, errors.New(\"not implemented yet\")\n}\n```", "```go\npackage payment\n\nimport ...\n\n// Currency is custom type for currency\ntype Currency string\n\n// Processor processes payments\ntype Processor struct {\n   Config *config.Config\n}\n\n// Pay makes a payment in the default currency\nfunc (p *Processor) Pay(amount float64) error {\n   // TODO: implement me\n   return errors.New(\"not implemented yet\")\n}\n```", "```go\ntype PageLoader struct {\n}\n\nfunc (o *PageLoader) LoadPage(url string) ([]byte, error) {\n   b := newFetcher()\n\n   // check cache\n   payload, err := b.cache.Get(url)\n   if err == nil {\n      // found in cache\n      return payload, nil\n   }\n\n   // call upstream\n   resp, err := b.httpClient.Get(url)\n   if err != nil {\n      return nil, err\n   }\n   defer resp.Body.Close()\n\n   // extract data from HTTP response\n   payload, err = ioutil.ReadAll(resp.Body)\n   if err != nil {\n      return nil, err\n   }\n\n   // save to cache asynchronously\n   go func(key string, value []byte) {\n      b.cache.Set(key, value)\n   }(url, payload)\n\n   // return\n   return payload, nil\n}\n\ntype Fetcher struct {\n   httpClient http.Client\n   cache      *Cache\n}\n\n```", "```go\nfunc doSearchWithEnvy(request searchRequest) ([]searchResults, error) {\n   // validate request\n   if request.query == \"\" {\n      return nil, errors.New(\"search term is missing\")\n   }\n   if request.start.IsZero() || request.start.After(time.Now()) {\n      return nil, errors.New(\"start time is missing or invalid\")\n   }\n   if request.end.IsZero() || request.end.Before(request.start) {\n      return nil, errors.New(\"end time is missing or invalid\")\n   }\n\n   return performSearch(request)\n}\n\nfunc doSearchWithoutEnvy(request searchRequest) ([]searchResults, error) {\n   err := request.validate()\n   if err != nil {\n      return nil, err\n   }\n\n   return performSearch(request)\n}\n```"]