["```go\n// Calculator calculates the test coverage for a directory \n// and it's sub-directories\ntype Calculator struct {\n  // coverage data populated by `Calculate()` method\n  data map[string]float64\n}\n\n// Calculate will calculate the coverage\nfunc (c *Calculator) Calculate(path string) error {\n  // run `go test -cover ./[path]/...` and store the results\n  return nil\n}\n\n// Output will print the coverage data to the supplied writer\nfunc (c *Calculator) Output(writer io.Writer) {\n  for path, result := range c.data {\n    fmt.Fprintf(writer, \"%s -> %.1f\\n\", path, result)\n  }\n}\n```", "```go\n// Calculator calculates the test coverage for a directory \n// and it's sub-directories\ntype Calculator struct {\n  // coverage data populated by `Calculate()` method\n  data map[string]float64\n}\n\n// Calculate will calculate the coverage\nfunc (c *Calculator) Calculate(path string) error {\n  // run `go test -cover ./[path]/...` and store the results\n  return nil\n}\n\n// Output will print the coverage data to the supplied writer\nfunc (c Calculator) Output(writer io.Writer) {\n  for path, result := range c.data {\n    fmt.Fprintf(writer, \"%s -> %.1f\\n\", path, result)\n  }\n}\n\n// OutputCSV will print the coverage data to the supplied writer\nfunc (c Calculator) OutputCSV(writer io.Writer) {\n  for path, result := range c.data {\n    fmt.Fprintf(writer, \"%s,%.1f\\n\", path, result)\n  }\n}\n```", "```go\n// Calculator calculates the test coverage for a directory \n// and it's sub-directories\ntype Calculator struct {\n  // coverage data populated by `Calculate()` method\n  data map[string]float64\n}\n\n// Calculate will calculate the coverage\nfunc (c *Calculator) Calculate(path string) error {\n  // run `go test -cover ./[path]/...` and store the results\n  return nil\n}\n\nfunc (c *Calculator) getData() map[string]float64 {\n  // copy and return the map\n  return nil\n}\n\ntype Printer interface {\n  Output(data map[string]float64)\n}\n\ntype DefaultPrinter struct {\n  Writer io.Writer\n}\n\n// Output implements Printer\nfunc (d *DefaultPrinter) Output(data map[string]float64) {\n  for path, result := range data {\n    fmt.Fprintf(d.Writer, \"%s -> %.1f\\n\", path, result)\n  }\n}\n\ntype CSVPrinter struct {\n  Writer io.Writer\n}\n\n// Output implements Printer\nfunc (d *CSVPrinter) Output(data map[string]float64) {\n```", "```go\nfor path, result := range data {\n    fmt.Fprintf(d.Writer, \"%s,%.1f\\n\", path, result)\n  }\n}\n```", "```go\nfunc loadUserHandler(resp http.ResponseWriter, req *http.Request) {\n  err := req.ParseForm()\n  if err != nil {\n    resp.WriteHeader(http.StatusInternalServerError)\n    return\n  }\n  userID, err := strconv.ParseInt(req.Form.Get(\"UserID\"), 10, 64)\n  if err != nil {\n    resp.WriteHeader(http.StatusPreconditionFailed)\n    return\n  }\n\n  row := DB.QueryRow(\"SELECT * FROM Users WHERE ID = ?\", userID)\n\n  person := &Person{}\n  err = row.Scan(&person.ID, &person.Name, &person.Phone)\n  if err != nil {\n    resp.WriteHeader(http.StatusInternalServerError)\n    return\n  }\n\n  encoder := json.NewEncoder(resp)\n  encoder.Encode(person)\n}\n```", "```go\nfunc loadUserHandler(resp http.ResponseWriter, req *http.Request) {\n  userID, err := extractIDFromRequest(req)\n  if err != nil {\n    resp.WriteHeader(http.StatusPreconditionFailed)\n    return\n  }\n\n  person, err := loadPersonByID(userID)\n  if err != nil {\n    resp.WriteHeader(http.StatusInternalServerError)\n    return\n  }\n\n  outputPerson(resp, person)\n}\n```", "```go\nfunc TestLoadUserHandler(t *testing.T) {\n   // build request\n   req := &http.Request{\n      Form: url.Values{},\n   }\n   req.Form.Add(\"UserID\", \"1234\")\n\n   // call function under test\n   resp := httptest.NewRecorder()\n   loadUserHandler(resp, req)\n\n   // validate result\n   assert.Equal(t, http.StatusOK, resp.Code)\n\n   expectedBody := `{\"ID\":1,\"Name\":\"Bob\",\"Phone\":\"0123456789\"}` + \"\\n\"\n   assert.Equal(t, expectedBody, resp.Body.String())\n}\n```", "```go\nfunc BuildOutput(response http.ResponseWriter, format string, person Person) {\n  var err error\n\n  switch format {\n  case \"csv\":\n    err = outputCSV(response, person)\n\n  case \"json\":\n    err = outputJSON(response, person)\n  }\n\n  if err != nil {\n    // output a server error and quit\n    response.WriteHeader(http.StatusInternalServerError)\n    return\n  }\n\n  response.WriteHeader(http.StatusOK)\n}\n```", "```go\nfunc BuildOutput(response http.ResponseWriter, formatter PersonFormatter, person Person) {\n  err := formatter.Format(response, person)\n  if err != nil {\n    // output a server error and quit\n    response.WriteHeader(http.StatusInternalServerError)\n    return\n  }\n\n  response.WriteHeader(http.StatusOK)\n}\n```", "```go\nfunc GetUserHandlerV1(resp http.ResponseWriter, req *http.Request) {\n  // validate inputs\n  err := req.ParseForm()\n  if err != nil {\n    resp.WriteHeader(http.StatusInternalServerError)\n    return\n  }\n  userID, err := strconv.ParseInt(req.Form.Get(\"UserID\"), 10, 64)\n  if err != nil {\n    resp.WriteHeader(http.StatusPreconditionFailed)\n    return\n  }\n\n  user := loadUser(userID)\n  outputUser(resp, user)\n}\n\nfunc DeleteUserHandlerV1(resp http.ResponseWriter, req *http.Request) {\n  // validate inputs\n  err := req.ParseForm()\n  if err != nil {\n    resp.WriteHeader(http.StatusInternalServerError)\n    return\n  }\n  userID, err := strconv.ParseInt(req.Form.Get(\"UserID\"), 10, 64)\n  if err != nil {\n    resp.WriteHeader(http.StatusPreconditionFailed)\n    return\n  }\n\n  deleteUser(userID)\n}\n```", "```go\nfunc GetUserHandlerV2(resp http.ResponseWriter, req *http.Request) {\n  // validate inputs\n  err := req.ParseForm()\n  if err != nil {\n    resp.WriteHeader(http.StatusInternalServerError)\n    return\n  }\n  userID, err := extractUserID(req.Form)\n  if err != nil {\n    resp.WriteHeader(http.StatusPreconditionFailed)\n    return\n  }\n\n  user := loadUser(userID)\n  outputUser(resp, user)\n}\n\nfunc DeleteUserHandlerV2(resp http.ResponseWriter, req *http.Request) {\n  // validate inputs\n  err := req.ParseForm()\n  if err != nil {\n    resp.WriteHeader(http.StatusInternalServerError)\n    return\n  }\n  userID, err := extractUserID(req.Form)\n  if err != nil {\n    resp.WriteHeader(http.StatusPreconditionFailed)\n    return\n  }\n\n  deleteUser(userID)\n}\n```", "```go\ntype rowConverter struct {\n}\n\n// populate the supplied Person from *sql.Row or *sql.Rows object\nfunc (d *rowConverter) populate(in *Person, scan func(dest ...interface{}) error) error {\n  return scan(in.Name, in.Email)\n}\n\ntype LoadPerson struct {\n  // compose the row converter into this loader\n  rowConverter\n}\n\nfunc (loader *LoadPerson) ByID(id int) (Person, error) {\n  row := loader.loadFromDB(id)\n\n  person := Person{}\n  // call the composed \"abstract class\"\n  err := loader.populate(&person, row.Scan)\n\n  return person, err\n}\n\ntype LoadAll struct {\n  // compose the row converter into this loader\n  rowConverter\n}\n\nfunc (loader *LoadPerson) All() ([]Person, error) {\n  rows := loader.loadAllFromDB()\n  defer rows.Close()\n\n  output := []Person{}\n  for rows.Next() {\n    person := Person{}\n\n    // call the composed \"abstract class\"\n    err := loader.populate(&person, rows.Scan)\n    if err != nil {\n      return nil, err\n    }\n  }\n\n  return output, nil\n}\n```", "```go\ntype Handler interface {\n   ServeHTTP(ResponseWriter, *Request)\n}\n```", "```go\n// a HTTP health check handler in long form\ntype healthCheck struct {\n}\n\nfunc (h *healthCheck) ServeHTTP(resp http.ResponseWriter, _ *http.Request) {\n   resp.WriteHeader(http.StatusNoContent)\n}\n\nfunc healthCheckUsage() {\n   http.Handle(\"/health\", &healthCheckLong{})\n}\n```", "```go\n// a HTTP health check handler in short form\nfunc healthCheck(resp http.ResponseWriter, _ *http.Request) {\n  resp.WriteHeader(http.StatusNoContent)\n}\n\nfunc healthCheckUsage() {\n  http.Handle(\"/health\", http.HandlerFunc(healthCheck))\n}\n```", "```go\nfunc Go(vehicle actions) {\n  if sled, ok := vehicle.(*Sled); ok {\n    sled.pushStart()\n  } else {\n    vehicle.startEngine()\n  }\n\n  vehicle.drive()\n}\n\ntype actions interface {\n  drive()\n  startEngine()\n}\n\ntype Vehicle struct {\n}\n\nfunc (v Vehicle) drive() {\n  // TODO: implement\n}\n\nfunc (v Vehicle) startEngine() {\n  // TODO: implement\n}\n\nfunc (v Vehicle) stopEngine() {\n  // TODO: implement\n}\n\ntype Car struct {\n  Vehicle\n}\n\ntype Sled struct {\n  Vehicle\n}\n\nfunc (s Sled) startEngine() {\n  // override so that is does nothing\n}\n\nfunc (s Sled) stopEngine() {\n  // override so that is does nothing\n}\n\nfunc (s Sled) pushStart() {\n  // TODO: implement\n}\n```", "```go\nfunc Go(vehicle actions) {\n   switch concrete := vehicle.(type) {\n   case poweredActions:\n      concrete.startEngine()\n\n   case unpoweredActions:\n      concrete.pushStart()\n   }\n\n   vehicle.drive()\n}\n\ntype actions interface {\n   drive()\n}\n\ntype poweredActions interface {\n   actions\n   startEngine()\n   stopEngine()\n}\n\ntype unpoweredActions interface {\n   actions\n   pushStart()\n}\n\ntype Vehicle struct {\n}\n\nfunc (v Vehicle) drive() {\n   // TODO: implement\n}\n\ntype PoweredVehicle struct {\n   Vehicle\n}\n\nfunc (v PoweredVehicle) startEngine() {\n   // common engine start code\n}\n\ntype Car struct {\n   PoweredVehicle\n}\n\ntype Buggy struct {\n   Vehicle\n}\n\nfunc (b Buggy) pushStart() {\n   // do nothing\n}\n```", "```go\nfunc Go(vehicle actions) {\n  vehicle.start()\n  vehicle.drive()\n}\n\ntype actions interface {\n  start()\n  drive()\n}\n\ntype Car struct {\n  poweredVehicle\n}\n\nfunc (c Car) start() {\n  c.poweredVehicle.startEngine()\n}\n\nfunc (c Car) drive() {\n  // TODO: implement\n}\n\ntype poweredVehicle struct {\n}\n\nfunc (p poweredVehicle) startEngine() {\n  // common engine start code\n}\n\ntype Buggy struct {\n}\n\nfunc (b Buggy) start() {\n  // push start\n}\n\nfunc (b Buggy) drive() {\n  // TODO: implement\n}\n```", "```go\ntype Collection interface {\n   Add(item interface{})\n   Get(index int) interface{}\n}\n\ntype CollectionImpl struct {\n   items []interface{}\n}\n\nfunc (c *CollectionImpl) Add(item interface{}) {\n   c.items = append(c.items, item)\n}\n\nfunc (c *CollectionImpl) Get(index int) interface{} {\n   return c.items[index]\n}\n\ntype ReadOnlyCollection struct {\n   CollectionImpl\n}\n\nfunc (ro *ReadOnlyCollection) Add(item interface{}) {\n   // intentionally does nothing\n}\n```", "```go\ntype ImmutableCollection interface {\n   Get(index int) interface{}\n}\n\ntype MutableCollection interface {\n   ImmutableCollection\n   Add(item interface{})\n}\n\ntype ReadOnlyCollectionV2 struct {\n   items []interface{}\n}\n\nfunc (ro *ReadOnlyCollectionV2) Get(index int) interface{} {\n   return ro.items[index]\n}\n\ntype CollectionImplV2 struct {\n   ReadOnlyCollectionV2\n}\n\nfunc (c *CollectionImplV2) Add(item interface{}) {\n   c.items = append(c.items, item)\n}\n```", "```go\ntype FatDbInterface interface {\n   BatchGetItem(IDs ...int) ([]Item, error)\n   BatchGetItemWithContext(ctx context.Context, IDs ...int) ([]Item, error)\n\n   BatchPutItem(items ...Item) error\n   BatchPutItemWithContext(ctx context.Context, items ...Item) error\n\n   DeleteItem(ID int) error\n   DeleteItemWithContext(ctx context.Context, item Item) error\n\n   GetItem(ID int) (Item, error)\n   GetItemWithContext(ctx context.Context, ID int) (Item, error)\n\n   PutItem(item Item) error\n   PutItemWithContext(ctx context.Context, item Item) error\n\n   Query(query string, args ...interface{}) ([]Item, error)\n   QueryWithContext(ctx context.Context, query string, args ...interface{}) ([]Item, error)\n\n   UpdateItem(item Item) error\n   UpdateItemWithContext(ctx context.Context, item Item) error\n}\n\ntype Cache struct {\n   db FatDbInterface\n}\n\nfunc (c *Cache) Get(key string) interface{} {\n   // code removed\n\n   // load from DB\n   _, _ = c.db.GetItem(42)\n\n   // code removed\n   return nil\n}\n\nfunc (c *Cache) Set(key string, value interface{}) {\n   // code removed\n\n   // save to DB\n   _ = c.db.PutItem(Item{})\n\n   // code removed\n}\n```", "```go\ntype myDB interface {\n   GetItem(ID int) (Item, error)\n   PutItem(item Item) error\n}\n\ntype CacheV2 struct {\n   db myDB\n}\n\nfunc (c *CacheV2) Get(key string) interface{} {\n   // code removed\n\n   // load from DB\n   _, _ = c.db.GetItem(42)\n\n   // code removed\n   return nil\n}\n\nfunc (c *CacheV2) Set(key string, value interface{}) {\n   // code removed\n\n   // save from DB\n   _ = c.db.PutItem(Item{})\n\n   // code removed\n}\n```", "```go\nfunc Encrypt(ctx context.Context, data []byte) ([]byte, error) {\n   // As this operation make take too long, we need to be able to kill it\n   stop := ctx.Done()\n   result := make(chan []byte, 1)\n\n   go func() {\n      defer close(result)\n\n      // pull the encryption key from context\n      keyRaw := ctx.Value(\"encryption-key\")\n      if keyRaw == nil {\n         panic(\"encryption key not found in context\")\n      }\n      key := keyRaw.([]byte)\n\n      // perform encryption\n      ciperText := performEncryption(key, data)\n\n      // signal complete by sending the result\n      result <- ciperText\n   }()\n\n   select {\n   case ciperText := <-result:\n      // happy path\n      return ciperText, nil\n\n   case <-stop:\n      // cancelled\n      return nil, errors.New(\"operation cancelled\")\n   }\n}\n```", "```go\ntype Value interface {\n   Value(key interface{}) interface{}\n}\n\ntype Monitor interface {\n   Done() <-chan struct{}\n}\n\nfunc EncryptV2(keyValue Value, monitor Monitor, data []byte) ([]byte, error) {\n   // As this operation make take too long, we need to be able to kill it\n   stop := monitor.Done()\n   result := make(chan []byte, 1)\n\n   go func() {\n      defer close(result)\n\n      // pull the encryption key from Value\n      keyRaw := keyValue.Value(\"encryption-key\")\n      if keyRaw == nil {\n         panic(\"encryption key not found in context\")\n      }\n      key := keyRaw.([]byte)\n\n      // perform encryption\n      ciperText := performEncryption(key, data)\n\n      // signal complete by sending the result\n      result <- ciperText\n   }()\n\n   select {\n   case ciperText := <-result:\n      // happy path\n      return ciperText, nil\n\n   case <-stop:\n      // cancelled\n      return nil, errors.New(\"operation cancelled\")\n   }\n}\n```", "```go\n// create a context\nctx, cancel := context.WithCancel(context.Background())\ndefer cancel()\n\n// store the key\nctx = context.WithValue(ctx, \"encryption-key\", \"-secret-\")\n\n// call the function\n_, _ = EncryptV2(ctx, ctx, []byte(\"my data\"))\n```", "```go\ntype Talker interface {\n   SayHello() string\n}\n\ntype Dog struct{}\n\n// The method implicitly implements the Talker interface\nfunc (d Dog) SayHello() string {\n   return \"Woof!\"\n}\n\nfunc Speak() {\n   var talker Talker\n   talker = Dog{}\n\n   fmt.Print(talker.SayHello())\n}\n```", "```go\n// Stringer is implemented by any value that has a String method, which \n// defines the \u201cnative\u201d format for that value. The String method is used \n// to print values passed as an operand to any format that accepts a \n// string or to an unformatted printer such as Print.\ntype Stringer interface {\n    String() string\n}\n```", "```go\nfunc main() {\n  kitty := Cat{}\n\n  fmt.Printf(\"Kitty %s\", kitty)\n}\n\ntype Cat struct{}\n\n// Implicitly implement the fmt.Stringer interface\nfunc (c Cat) String() string {\n  return \"Meow!\"\n}\n```"]