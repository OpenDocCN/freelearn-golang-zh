["```go\nfunc NotSoSimple(ID int64, name string, age int, registered bool) string {\n  out := &bytes.Buffer{}\n  out.WriteString(strconv.FormatInt(ID, 10))\n  out.WriteString(\"-\")\n  out.WriteString(strings.Replace(name, \" \", \"_\", -1))\n  out.WriteString(\"-\")\n  out.WriteString(strconv.Itoa(age))\n  out.WriteString(\"-\")\n  out.WriteString(strconv.FormatBool(registered))\n  return out.String()\n}\n```", "```go\nfunc Simpler(ID int64, name string, age int, registered bool) string {\n  nameWithNoSpaces := strings.Replace(name, \" \", \"_\", -1)\n  return fmt.Sprintf(\"%d-%s-%d-%t\", ID, nameWithNoSpaces, age, registered)\n}\n```", "```go\ntype myGetter interface {\n  Get(url string) (*http.Response, error)\n}\n\nfunc TooAbstract(getter myGetter, url string) ([]byte, error) {\n  resp, err := getter.Get(url)\n  if err != nil {\n    return nil, err\n  }\n  defer resp.Body.Close()\n\n  return ioutil.ReadAll(resp.Body)\n}\n```", "```go\nfunc CommonConcept(url string) ([]byte, error) {\n  resp, err := http.Get(url)\n  if err != nil {\n    return nil, err\n  }\n  defer resp.Body.Close()\n\n  return ioutil.ReadAll(resp.Body)\n}\n```", "```go\nNewPet(\"Fido\", true)\n```", "```go\nNewDog(\"Fido\")\n```", "```go\ntype WideFormatter interface {\n  ToCSV(pets []Pet) ([]byte, error)\n  ToGOB(pets []Pet) ([]byte, error)\n  ToJSON(pets []Pet) ([]byte, error)\n}\n```", "```go\ntype ThinFormatter interface {\n  Format(pets []Pet) ([]byte, error)\n}\n\ntype CSVFormatter struct {}\n\nfunc (f CSVFormatter) Format(pets []Pet) ([]byte, error) {\n  // convert slice of pets to CSV\n}\n```", "```go\n// PetFetcher searches the data store for pets whose name matches\n// the search string.\n// Limit is optional (default is 100). Offset is optional (default 0).\n// sortBy is optional (default name). sortAscending is optional\nfunc PetFetcher(search string, limit int, offset int, sortBy string, sortAscending bool) []Pet {\n  return []Pet{}\n}\n```", "```go\nresults := PetFetcher(\"Fido\", 0, 0, \"\", true)\n```", "```go\ntype Loader interface {\n  Load(ID int) (*Pet, error)\n}\n\nfunc TestLoadAndPrint_happyPath(t *testing.T) {\n  result := &bytes.Buffer{}\n  LoadAndPrint(&happyPathLoader{}, 1, result)\n  assert.Contains(t, result.String(), \"Pet named\")\n}\n\nfunc TestLoadAndPrint_notFound(t *testing.T) {\n  result := &bytes.Buffer{}\n  LoadAndPrint(&missingLoader{}, 1, result)\n  assert.Contains(t, result.String(), \"no such pet\")\n}\n\nfunc TestLoadAndPrint_error(t *testing.T) {\n  result := &bytes.Buffer{}\n  LoadAndPrint(&errorLoader{}, 1, result)\n  assert.Contains(t, result.String(), \"failed to load\")\n}\n\nfunc LoadAndPrint(loader Loader, ID int, dest io.Writer) {\n  loadedPet, err := loader.Load(ID)\n  if err != nil {\n    fmt.Fprintf(dest, \"failed to load pet with ID %d. err: %s\", ID, err)\n    return\n  }\n\n  if loadedPet == nil {\n    fmt.Fprintf(dest, \"no such pet found\")\n    return\n  }\n\n  fmt.Fprintf(dest, \"Pet named %s loaded\", loadedPet.Name)\n}\n```", "```go\nfunc NewPet(name string) *Pet {\n   return &Pet{\n      Name: name,\n   }\n}\n\nfunc TestLanguageFeatures(t *testing.T) {\n   petFish := NewPet(\"Goldie\")\n   assert.IsType(t, &Pet{}, petFish)\n}\n```", "```go\nfunc concat(a, b string) string {\n   return a + b\n}\n\nfunc TestTooSimple(t *testing.T) {\n   a := \"Hello \"\n   b := \"World\"\n   expected := \"Hello World\"\n\n   assert.Equal(t, expected, concat(a, b))\n}\n```", "```go\ntype PetSaver struct{}\n\n// save the supplied pet and return the ID\nfunc (p PetSaver) Save(pet Pet) (int, error) {\n   err := p.validate(pet)\n   if err != nil {\n      return 0, err\n   }\n\n   result, err := p.save(pet)\n   if err != nil {\n      return 0, err\n   }\n\n   return p.extractID(result)\n}\n\n// ensure the pet record is complete\nfunc (p PetSaver) validate(pet Pet) (error) {\n   return nil\n}\n\n// save to the datastore\nfunc (p PetSaver) save(pet Pet) (sql.Result, error) {\n   return nil, nil\n}\n\n// extract the ID from the result\nfunc (p PetSaver) extractID(result sql.Result) (int, error) {\n   return 0, nil\n}\n```", "```go\nfunc TestRound_down(t *testing.T) {\n   in := float64(1.1)\n   expected := 1\n\n   result := Round(in)\n   assert.Equal(t, expected, result)\n}\n\nfunc TestRound_up(t *testing.T) {\n   in := float64(3.7)\n   expected := 4\n\n   result := Round(in)\n   assert.Equal(t, expected, result)\n}\n\nfunc TestRound_noChange(t *testing.T) {\n   in := float64(6.0)\n   expected := 6\n\n   result := Round(in)\n   assert.Equal(t, expected, result)\n}\n```", "```go\nfunc TestRound(t *testing.T) {\n   scenarios := []struct {\n      desc     string\n      in       float64\n      expected int\n   }{\n      {\n         desc:     \"round down\",\n         in:       1.1,\n         expected: 1,\n      },\n      {\n         desc:     \"round up\",\n         in:       3.7,\n         expected: 4,\n      },\n      {\n         desc:     \"unchanged\",\n         in:       6.0,\n         expected: 6,\n      },\n   }\n\n   for _, scenario := range scenarios {\n      in := float64(scenario.in)\n\n      result := Round(in)\n      assert.Equal(t, scenario.expected, result)\n   }\n}\n```", "```go\ntype PersonLoader interface {\n   Load(ID int) (*Person, error)\n}\n```", "```go\n// Stubbed implementation of PersonLoader\ntype PersonLoaderStub struct {\n   Person *Person\n   Error error\n}\n\nfunc (p *PersonLoaderStub) Load(ID int) (*Person, error) {\n   return p.Person, p.Error\n}\n```", "```go\nfunc TestLoadPersonName(t *testing.T) {\n   // this value does not matter as the stub ignores it\n   fakeID := 1\n\n   scenarios := []struct {\n      desc         string\n      loaderStub   *PersonLoaderStub\n      expectedName string\n      expectErr    bool\n   }{\n      {\n         desc: \"happy path\",\n         loaderStub: &PersonLoaderStub{\n            Person: &Person{Name: \"Sophia\"},\n         },\n         expectedName: \"Sophia\",\n         expectErr:    false,\n      },\n      {\n         desc: \"input error\",\n         loaderStub: &PersonLoaderStub{\n            Error: ErrNotFound,\n         },\n         expectedName: \"\",\n         expectErr:    true,\n      },\n      {\n         desc: \"system error path\",\n         loaderStub: &PersonLoaderStub{\n            Error: errors.New(\"something failed\"),\n         },\n         expectedName: \"\",\n         expectErr:    true,\n      },\n   }\n\n   for _, scenario := range scenarios {\n      result, resultErr := LoadPersonName(scenario.loaderStub, fakeID)\n\n      assert.Equal(t, scenario.expectedName, result, scenario.desc)\n      assert.Equal(t, scenario.expectErr, resultErr != nil, scenario.desc)\n   }\n}\n```", "```go\nfunc WriteAndClose(destination io.WriteCloser, contents string) error {\n   defer destination.Close()\n\n   _, err := destination.Write([]byte(contents))\n   if err != nil {\n      return err\n   }\n\n   return nil \n}\n```", "```go\nfunc PrintAsJSON(destination io.Writer, plant Plant) error {\n   bytes, err := json.Marshal(plant)\n   if err != nil {\n      return err\n   }\n\n   destination.Write(bytes)\n   return nil\n}\n\ntype Plant struct {\n   Name string\n}\n```", "```go\nfunc TestLoadPersonName(t *testing.T) {\n   // this value does not matter as the stub ignores it\n   fakeID := 1\n\n   scenarios := []struct {\n      desc          string\n      configureMock func(stub *PersonLoaderMock)\n      expectedName  string\n      expectErr     bool\n   }{\n      {\n         desc: \"happy path\",\n         configureMock: func(loaderMock *PersonLoaderMock) {\n            loaderMock.On(\"Load\", mock.Anything).\n               Return(&Person{Name: \"Sophia\"}, nil).\n               Once()\n         },\n         expectedName: \"Sophia\",\n         expectErr:    false,\n      },\n      {\n         desc: \"input error\",\n         configureMock: func(loaderMock *PersonLoaderMock) {\n            loaderMock.On(\"Load\", mock.Anything).\n               Return(nil, ErrNotFound).\n               Once()\n         },\n         expectedName: \"\",\n         expectErr:    true,\n      },\n      {\n         desc: \"system error path\",\n         configureMock: func(loaderMock *PersonLoaderMock) {\n            loaderMock.On(\"Load\", mock.Anything).\n               Return(nil, errors.New(\"something failed\")).\n               Once()\n         },\n         expectedName: \"\",\n         expectErr:    true,\n      },\n   }\n\n   for _, scenario := range scenarios {\n      mockLoader := &PersonLoaderMock{}\n      scenario.configureMock(mockLoader)\n\n      result, resultErr := LoadPersonName(mockLoader, fakeID)\n\n      assert.Equal(t, scenario.expectedName, result, scenario.desc)\n      assert.Equal(t, scenario.expectErr, resultErr != nil, scenario.desc)\n      assert.True(t, mockLoader.AssertExpectations(t), scenario.desc)\n   }\n}\n```", "```go\n$ go get github.com/vektra/mockery/.../\n```", "```go\n//go:generate mockery -name PersonLoader -testonly -inpkg -case=underscore\ntype PersonLoader interface {\n   Load(ID int) (*Person, error)\n}\n```", "```go\n$ go generate ./\u2026\n```", "```go\n $ go get github.com/kisielk/godepgraph\n```", "```go\n$ godepgraph github.com/kisielk/godepgraph | dot -Tpng -o godepgraph.png\n```", "```go\n$ godepgraph github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/ch04/acme/ | dot -Tpng -o acme-graph-v1.png\n```", "```go\n$ godepgraph -s github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/ch04/acme/ | dot -Tpng -o acme-graph-v2.png\n```", "```go\n$ godepgraph -s -o github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/ch04/acme/ github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/ch04/acme/ | dot -Tpng -o acme-graph-v3.png\n```"]