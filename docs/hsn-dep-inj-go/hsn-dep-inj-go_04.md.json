["```go\ntype House struct {\n   a string\n   b int\n   t int\n   p float64\n}\n```", "```go\ntype House struct {\n   address string\n   bedrooms int\n   toilets int\n   price float64\n}\n```", "```go\nfunc longMethod(resp http.ResponseWriter, req *http.Request) {\n   err := req.ParseForm()\n   if err != nil {\n      resp.WriteHeader(http.StatusPreconditionFailed)\n      return\n   }\n   userID, err := strconv.ParseInt(req.Form.Get(\"UserID\"), 10, 64)\n   if err != nil {\n      resp.WriteHeader(http.StatusPreconditionFailed)\n      return\n   }\n\n   row := DB.QueryRow(\"SELECT * FROM Users WHERE userID = ?\", userID)\n\n   person := &Person{}\n   err = row.Scan(person.ID, person.Name, person.Phone)\n   if err != nil {\n      resp.WriteHeader(http.StatusInternalServerError)\n      return\n   }\n\n   encoder := json.NewEncoder(resp)\n   err = encoder.Encode(person)\n   if err != nil {\n      resp.WriteHeader(http.StatusInternalServerError)\n      return\n   }\n}\n```", "```go\nfunc TestLongMethod_happyPath(t *testing.T) {\n   // build request\n   request := &http.Request{}\n   request.PostForm = url.Values{}\n   request.PostForm.Add(\"UserID\", \"123\")\n\n   // mock the database\n   var mockDB sqlmock.Sqlmock\n   var err error\n\n   DB, mockDB, err = sqlmock.New()\n   require.NoError(t, err)\n     mockDB.ExpectQuery(\"SELECT .* FROM people WHERE ID = ?\").\n    WithArgs(123).\n    WillReturnRows(\n      sqlmock.NewRows(\n        []string{\"ID\", \"Name\", \"Phone\"}).\n        AddRow(123, \"May\", \"0123456789\"))\n\n   // build response\n   response := httptest.NewRecorder()\n\n   // call method\n   longMethod(response, request)\n\n   // validate response\n   require.Equal(t, http.StatusOK, response.Code)\n\n   // validate the JSON\n   responseBytes, err := ioutil.ReadAll(response.Body)\n   require.NoError(t, err)\n\n   expectedJSON := `{\"ID\":123,\"Name\":\"May\",\"Phone\":\"0123456789\"}` + \"\\n\"\n   assert.Equal(t, expectedJSON, string(responseBytes))\n}\n```", "```go\nfunc shortMethods(resp http.ResponseWriter, req *http.Request) {\n   userID, err := extractUserID(req)\n   if err != nil {\n      resp.WriteHeader(http.StatusInternalServerError)\n      return\n   }\n\n   person, err := loadPerson(userID)\n   if err != nil {\n      resp.WriteHeader(http.StatusInternalServerError)\n      return\n   }\n\n   outputPerson(resp, person)\n}\n\nfunc extractUserID(req *http.Request) (int64, error) {\n   err := req.ParseForm()\n   if err != nil {\n      return 0, err\n   }\n\n   return strconv.ParseInt(req.Form.Get(\"UserID\"), 10, 64)\n}\n\nfunc loadPerson(userID int64) (*Person, error) {\n   row := DB.QueryRow(\"SELECT * FROM people WHERE ID = ?\", userID)\n\n   person := &Person{}\n   err := row.Scan(&person.ID, &person.Name, &person.Phone)\n   if err != nil {\n      return nil, err\n   }\n   return person, nil\n}\n\nfunc outputPerson(resp http.ResponseWriter, person *Person) {\n   encoder := json.NewEncoder(resp)\n   err := encoder.Encode(person)\n   if err != nil {\n      resp.WriteHeader(http.StatusInternalServerError)\n      return\n   }\n}\n```", "```go\nfunc TestGetHandler_ServeHTTP(t *testing.T) {\n   // ensure the test always fails by giving it a timeout\n   ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n   defer cancel()\n\n     // Create and start a server\n  // With out current implementation, we cannot test this handler \n  // without a full server as we need the mux.\n  address, err := startServer(ctx)\n  require.NoError(t, err)\n\n   // build inputs\n   response, err := http.Get(\"http://\" + address + \"/person/1/\")\n\n   // validate outputs\n   require.NoError(t, err)\n   require.Equal(t, http.StatusOK, response.StatusCode)\n\n   expectedPayload := []byte(`{\"id\":1,\"name\":\"John\",\"phone\":\"0123456780\",\"currency\":\"USD\",\"price\":100}` + \"\\n\")\n   payload, _ := ioutil.ReadAll(response.Body)\n   defer response.Body.Close()\n\n   assert.Equal(t, expectedPayload, payload)\n}\n```", "```go\nfunc TestGetter_Do(t *testing.T) {\n   // inputs\n   ID := 1\n   name := \"John\"\n\n   // call method\n   getter := &Getter{}\n   person, err := getter.Do(ID)\n\n   // validate expectations\n   require.NoError(t, err)\n   assert.Equal(t, ID, person.ID)\n   assert.Equal(t, name, person.FullName)\n}\n```", "```go\n// output the supplied person as JSON\nfunc (h *GetHandler) writeJSON(writer io.Writer, person *data.Person) error {\n   return json.NewEncoder(writer).Encode(person)\n}\n```", "```go\n// bind stop channel to context\nctx := context.Background()\n\n// start REST server\nserver := rest.New(config.App.Address)\nserver.Listen(ctx.Done())\n```", "```go\n// Currency is a custom type; used for convenience and code readability\ntype Currency string\n\n// UnmarshalJSON implements json.Unmarshaler\nfunc (c *Currency) UnmarshalJSON(in []byte) error {\n   var s string\n   err := json.Unmarshal(in, &s)\n   if err != nil {\n      return err\n   }\n\n   currency, valid := validCurrencies[s]\n   if !valid {\n      return fmt.Errorf(\"'%s' is not a valid currency\", s)\n   }\n\n   *c = currency\n\n   return nil\n}\n```", "```go\ntype Config struct {\n   DefaultCurrency currency.Currency `json:\"default_currency\"`\n}\n```"]