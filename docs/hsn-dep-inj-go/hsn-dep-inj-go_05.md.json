["```go\nfunc SaveConfig(filename string, cfg *Config) error {\n   // convert to JSON\n   data, err := json.Marshal(cfg)\n   if err != nil {\n      return err\n   }\n\n   // save file\n   err = ioutil.WriteFile(filename, data, 0666)\n   if err != nil {\n      log.Printf(\"failed to save file '%s' with err: %s\", filename, err)\n      return err\n   }\n\n   return nil\n}\n```", "```go\nfunc SaveConfig(filename string, cfg *Config) error {\n   // convert to JSON\n   data, err := json.Marshal(cfg)\n   if err != nil {\n      return err\n   }\n\n   // save file\n   err = writeFile(filename, data, 0666)\n   if err != nil {\n      log.Printf(\"failed to save file '%s' with err: %s\", filename, err)\n      return err\n   }\n\n   return nil\n}\n\n// Custom type that allows us to Monkey Patch\nvar writeFile = ioutil.WriteFile\n```", "```go\nvar writeFile = ioutil.WriteFile\n```", "```go\ntype fileWriter func(filename string, data []byte, perm os.FileMode) error\n\nvar writeFile fileWriter = ioutil.WriteFile\n```", "```go\nfunc SaveConfig(writer fileWriter, filename string, cfg *Config) error {\n   // convert to JSON\n   data, err := json.Marshal(cfg)\n   if err != nil {\n      return err\n   }\n\n   // save file\n   err = writer(filename, data, 0666)\n   if err != nil {\n      log.Printf(\"failed to save file '%s' with err: %s\", filename, err)\n      return err\n   }\n\n   return nil\n}\n\n// This custom type is not strictly needed but it does make the function \n// signature a little cleaner\ntype fileWriter func(filename string, data []byte, perm os.FileMode) error\n```", "```go\ntype ConfigSaver struct {\n   FileWriter func(filename string, data []byte, perm os.FileMode) error\n}\n\nfunc (c ConfigSaver) Save(filename string, cfg *Config) error {\n   // convert to JSON\n   data, err := json.Marshal(cfg)\n   if err != nil {\n      return err\n   }\n\n   // save file\n   err = c.FileWriter(filename, data, 0666)\n   if err != nil {\n      log.Printf(\"failed to save file '%s' with err: %s\", filename, err)\n      return err\n   }\n\n   return nil\n}\n```", "```go\n// A Rand is a source of random numbers.\ntype Rand struct {\n   src Source\n\n   // code removed\n}\n\n// Int returns a non-negative pseudo-random int.\nfunc (r *Rand) Int() int {\n   // code changed for brevity\n   value := r.src.Int63()\n   return int(value)\n}\n\n/*\n * Top-level convenience functions\n */\n\nvar globalRand = New(&lockedSource{})\n\n// Int returns a non-negative pseudo-random int from the default Source.\nfunc Int() int { return globalRand.Int() }\n\n// A Source represents a source of uniformly-distributed\n// pseudo-random int64 values in the range [0, 1<<63).\ntype Source interface {\n   Int63() int64\n\n   // code removed\n}\n```", "```go\nfunc TestInt(t *testing.T) {\n   // monkey patch\n   defer func(original *Rand) {\n      // restore patch after use\n      globalRand = original\n   }(globalRand)\n\n   // swap out for a predictable outcome\n   globalRand = New(&stubSource{})\n   // end monkey patch\n\n   // call the function\n   result := Int()\n   assert.Equal(t, 234, result)\n}\n\n// this is a stubbed implementation of Source that returns a \n// predictable value\ntype stubSource struct {\n}\n\nfunc (s *stubSource) Int63() int64 {\n   return 234\n}\n```", "```go\nfunc TestData_happyPath(t *testing.T) {\n   in := &Person{\n      FullName: \"Jake Blues\",\n      Phone:    \"01234567890\",\n      Currency: \"AUD\",\n      Price:    123.45,\n   }\n\n   // save\n   resultID, err := Save(in)\n   require.Nil(t, err)\n   assert.True(t, resultID > 0)\n\n   // load\n   returned, err := Load(resultID)\n   require.NoError(t, err)\n\n   in.ID = resultID\n   assert.Equal(t, in, returned)\n\n   // load all\n   all, err := LoadAll()\n   require.NoError(t, err)\n   assert.True(t, len(all) > 0)\n}\n```", "```go\nreturned, err := Load(resultID)\nrequire.NoError(t, err)\n```", "```go\nfunc SavePerson(db *sql.DB, in *Person) (int, error) {\n   // perform DB insert\n   query := \"INSERT INTO person (fullname, phone, currency, price) VALUES (?, ?, ?, ?)\"\n   result, err := db.Exec(query, in.FullName, in.Phone, in.Currency, in.Price)\n   if err != nil {\n      return 0, err\n   }\n\n   // retrieve and return the ID of the person created\n   id, err := result.LastInsertId()\n   if err != nil {\n      return 0, err\n   }\n   return int(id), nil\n}\n```", "```go\ntestDb, dbMock, err := sqlmock.New()\nrequire.NoError(t, err)\n```", "```go\nqueryRegex := `\\QINSERT INTO person (fullname, phone, currency, price) VALUES (?, ?, ?, ?)\\E`\n\ndbMock.ExpectExec(queryRegex).WillReturnResult(sqlmock.NewResult(2, 1))\n```", "```go\nresultID, err := SavePerson(testDb, person)\n```", "```go\nrequire.NoError(t, err)\nassert.Equal(t, 2, resultID)\nassert.NoError(t, dbMock.ExpectationsWereMet())\n```", "```go\n// Save will save the supplied person and return the ID of the newly \n// created person or an error.\n// Errors returned are caused by the underlying database or our connection\n// to it.\nfunc Save(in *Person) (int, error) {\n   db, err := getDB()\n   if err != nil {\n      logging.L.Error(\"failed to get DB connection. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   // perform DB insert\n   query := \"INSERT INTO person (fullname, phone, currency, price) VALUES (?, ?, ?, ?)\"\n   result, err := db.Exec(query, in.FullName, in.Phone, in.Currency, in.Price)\n   if err != nil {\n      logging.L.Error(\"failed to save person into DB. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   // retrieve and return the ID of the person created\n   id, err := result.LastInsertId()\n   if err != nil {\n      logging.L.Error(\"failed to retrieve id of last saved person. err: %s\", err)\n      return defaultPersonID, err\n   }\n   return int(id), nil\n}\n```", "```go\n// define a mock db\ntestDb, dbMock, err := sqlmock.New()\ndefer testDb.Close()\n\nrequire.NoError(t, err)\n```", "```go\ndefer func(original sql.DB) {\n   // restore original DB (after test)\n   db = &original\n}(*db)\n\n// replace db for this test\ndb = testDb\n\n```", "```go\nfunc TestSave_happyPath(t *testing.T) {\n   // define a mock db\n   testDb, dbMock, err := sqlmock.New()\n   defer testDb.Close()\n   require.NoError(t, err)\n\n   // configure the mock db\n   queryRegex := convertSQLToRegex(sqlInsert)\n   dbMock.ExpectExec(queryRegex).WillReturnResult(sqlmock.NewResult(2, 1))\n\n   // monkey patching starts here\n   defer func(original sql.DB) {\n      // restore original DB (after test)\n      db = &original\n   }(*db)\n\n   // replace db for this test\n   db = testDb\n   // end of monkey patch\n\n   // inputs\n   in := &Person{\n      FullName: \"Jake Blues\",\n      Phone:    \"01234567890\",\n      Currency: \"AUD\",\n      Price:    123.45,\n   }\n\n   // call function\n   resultID, err := Save(in)\n\n   // validate result\n   require.NoError(t, err)\n   assert.Equal(t, 2, resultID)\n   assert.NoError(t, dbMock.ExpectationsWereMet())\n}\n```", "```go\n// configure the mock db\nqueryRegex := convertSQLToRegex(sqlInsert)\ndbMock.ExpectExec(queryRegex).WillReturnError(errors.New(\"failed to insert\"))\n```", "```go\nrequire.Error(t, err)\nassert.Equal(t, defaultPersonID, resultID)\nassert.NoError(t, dbMock.ExpectationsWereMet())\n```", "```go\nfunc getDB() (*sql.DB, error) {\n   if db == nil {\n      if config.App == nil {\n         return nil, errors.New(\"config is not initialized\")\n      }\n\n      var err error\n      db, err = sql.Open(\"mysql\", config.App.DSN)\n      if err != nil {\n         // if the DB cannot be accessed we are dead\n         panic(err.Error())\n      }\n   }\n\n   return db, nil\n}\n```", "```go\nvar getDB = func() (*sql.DB, error) {\n    // code removed for brevity\n}\n```", "```go\nfunc TestSave_getDBError(t *testing.T) {\n   // monkey patching starts here\n   defer func(original func() (*sql.DB, error)) {\n      // restore original DB (after test)\n      getDB = original\n   }(getDB)\n\n   // replace getDB() function for this test\n   getDB = func() (*sql.DB, error) {\n      return nil, errors.New(\"getDB() failed\")\n   }\n   // end of monkey patch\n\n   // inputs\n   in := &Person{\n      FullName: \"Jake Blues\",\n      Phone:    \"01234567890\",\n      Currency: \"AUD\",\n      Price:    123.45,\n   }\n\n   // call function\n   resultID, err := Save(in)\n   require.Error(t, err)\n   assert.Equal(t, defaultPersonID, resultID)\n}\n```", "```go\nfunc TestLoad_happyPath(t *testing.T) {\n   expectedResult := &Person{\n      ID:       2,\n      FullName: \"Paul\",\n      Phone:    \"0123456789\",\n      Currency: \"CAD\",\n      Price:    23.45,\n   }\n\n   // define a mock db\n   testDb, dbMock, err := sqlmock.New()\n   require.NoError(t, err)\n\n   // configure the mock db\n   queryRegex := convertSQLToRegex(sqlLoadByID)\n   dbMock.ExpectQuery(queryRegex).WillReturnRows(\n      sqlmock.NewRows(strings.Split(sqlAllColumns, \", \")).\n         AddRow(2, \"Paul\", \"0123456789\", \"CAD\", 23.45))\n\n   // monkey patching the database\n   defer func(original sql.DB) {\n      // restore original DB (after test)\n      db = &original\n   }(*db)\n\n   db = testDb\n   // end of monkey patch\n\n   // call function\n   result, err := Load(2)\n\n   // validate results\n   assert.Equal(t, expectedResult, result)\n   assert.NoError(t, err)\n   assert.NoError(t, dbMock.ExpectationsWereMet())\n}\n```", "```go\nfunc TestLoad_tableDrivenTest(t *testing.T) {\n   scenarios := []struct {\n      desc            string\n      configureMockDB func(sqlmock.Sqlmock)\n      expectedResult  *Person\n      expectError     bool\n   }{\n      {\n         desc: \"happy path\",\n         configureMockDB: func(dbMock sqlmock.Sqlmock) {\n            queryRegex := convertSQLToRegex(sqlLoadAll)\n            dbMock.ExpectQuery(queryRegex).WillReturnRows(\n               sqlmock.NewRows(strings.Split(sqlAllColumns, \", \")).\n                  AddRow(2, \"Paul\", \"0123456789\", \"CAD\", 23.45))\n         },\n         expectedResult: &Person{\n            ID:       2,\n            FullName: \"Paul\",\n            Phone:    \"0123456789\",\n            Currency: \"CAD\",\n            Price:    23.45,\n         },\n         expectError: false,\n      },\n      {\n         desc: \"load error\",\n         configureMockDB: func(dbMock sqlmock.Sqlmock) {\n            queryRegex := convertSQLToRegex(sqlLoadAll)\n            dbMock.ExpectQuery(queryRegex).WillReturnError(\n                errors.New(\"something failed\"))\n         },\n         expectedResult: nil,\n         expectError:    true,\n      },\n   }\n\n   for _, scenario := range scenarios {\n      // define a mock db\n      testDb, dbMock, err := sqlmock.New()\n      require.NoError(t, err)\n\n      // configure the mock db\n      scenario.configureMockDB(dbMock)\n\n      // monkey db for this test\n      original := *db\n      db = testDb\n\n      // call function\n      result, err := Load(2)\n\n      // validate results\n      assert.Equal(t, scenario.expectedResult, result, scenario.desc)\n      assert.Equal(t, scenario.expectError, err != nil, scenario.desc)\n      assert.NoError(t, dbMock.ExpectationsWereMet())\n\n      // restore original DB (after test)\n      db = &original\n      testDb.Close()\n   }\n}\n```", "```go\nscenarios := []struct {\n   desc            string\n   configureMockDB func(sqlmock.Sqlmock)\n   expectedResult  *Person\n   expectError     bool\n}{\n```", "```go\n{\n   desc: \"happy path\",\n   configureMockDB: func(dbMock sqlmock.Sqlmock) {\n      queryRegex := convertSQLToRegex(sqlLoadAll)\n      dbMock.ExpectQuery(queryRegex).WillReturnRows(\n         sqlmock.NewRows(strings.Split(sqlAllColumns, \", \")).\n            AddRow(2, \"Paul\", \"0123456789\", \"CAD\", 23.45))\n   },\n   expectedResult: &Person{\n      ID:       2,\n      FullName: \"Paul\",\n      Phone:    \"0123456789\",\n      Currency: \"CAD\",\n      Price:    23.45,\n   },\n   expectError: false,\n},\n{\n  desc: \"load error\",\n  configureMockDB: func(dbMock sqlmock.Sqlmock) {\n    queryRegex := convertSQLToRegex(sqlLoadAll)\n    dbMock.ExpectQuery(queryRegex).WillReturnError(\n        errors.New(\"something failed\"))\n  },\n  expectedResult: nil,\n  expectError: true,\n},\n\n```", "```go\nfor _, scenario := range scenarios {\n   // define a mock db\n   testDb, dbMock, err := sqlmock.New()\n   require.NoError(t, err)\n\n   // configure the mock db\n   scenario.configureMockDB(dbMock)\n\n   // monkey db for this test\n   original := *db\n   db = testDb\n\n   // call function\n   result, err := Load(2)\n\n   // validate results\n   assert.Equal(t, scenario.expectedResult, result, scenario.desc)\n   assert.Equal(t, scenario.expectError, err != nil, scenario.desc)\n   assert.NoError(t, dbMock.ExpectationsWereMet())\n\n   // restore original DB (after test)\n   db = &original\n   testDb.Close()\n}\n```", "```go\n// Getter will attempt to load a person.\n// It can return an error caused by the data layer or \n// when the requested person is not found\ntype Getter struct {\n}\n\n// Do will perform the get\nfunc (g *Getter) Do(ID int) (*data.Person, error) {\n   // load person from the data layer\n   person, err := data.Load(ID)\n   if err != nil {\n      if err == data.ErrNotFound {\n         // By converting the error we are encapsulating the \n         // implementation details from our users.\n         return nil, errPersonNotFound\n      }\n      return nil, err\n   }\n\n   return person, err\n}\n```", "```go\n// Getter will attempt to load a person.\n// It can return an error caused by the data layer or \n// when the requested person is not found\ntype Getter struct {\n}\n\n// Do will perform the get\nfunc (g *Getter) Do(ID int) (*data.Person, error) {\n   // load person from the data layer\n   person, err := loader(ID)\n   if err != nil {\n      if err == data.ErrNotFound {\n         // By converting the error we are hiding the \n         // implementation details from our users.\n         return nil, errPersonNotFound\n      }\n      return nil, err\n   }\n\n   return person, err\n}\n\n// this function as a variable allows us to Monkey Patch during testing\nvar loader = data.Load\n\n```", "```go\nfunc TestGetter_Do_happyPath(t *testing.T) {\n   // inputs\n   ID := 1234\n\n   // monkey patch calls to the data package\n   defer func(original func(ID int) (*data.Person, error)) {\n      // restore original\n      loader = original\n   }(loader)\n\n   // replace method\n   loader = func(ID int) (*data.Person, error) {\n      result := &data.Person{\n         ID:       1234,\n         FullName: \"Doug\",\n      }\n      var resultErr error\n\n      return result, resultErr\n   }\n   // end of monkey patch\n\n   // call method\n   getter := &Getter{}\n   person, err := getter.Do(ID)\n\n   // validate expectations\n   require.NoError(t, err)\n   assert.Equal(t, ID, person.ID)\n   assert.Equal(t, \"Doug\", person.FullName)\n}\n```", "```go\n$ go test -race ./...\n```", "```go\n$ go test -p 1 ./...\n```", "```go\nfunc TestSaveConfig(t *testing.T) {\n   // inputs\n   filename := \"my-config.json\"\n   cfg := &Config{\n      Host: \"localhost\",\n      Port: 1234,\n   }\n\n   // monkey patch the file writer\n   defer func(original func(filename string, data []byte, perm os.FileMode) error) {\n      // restore the original\n      writeFile = original\n   }(writeFile)\n\n   writeFile = func(filename string, data []byte, perm os.FileMode) error {\n      // output error\n      return nil\n   }\n\n   // call the function\n   err := SaveConfig(filename, cfg)\n\n   // validate the result\n   assert.NoError(t, err)\n}\n```", "```go\nfunc TestSaveConfig_refactored(t *testing.T) {\n   // inputs\n   filename := \"my-config.json\"\n   cfg := &Config{\n      Host: \"localhost\",\n      Port: 1234,\n   }\n\n   // monkey patch the file writer\n   defer restoreWriteFile(writeFile)\n\n   writeFile = mockWriteFile(nil)\n\n   // call the function\n   err := SaveConfig(filename, cfg)\n\n   // validate the result\n   assert.NoError(t, err)\n}\n\nfunc mockWriteFile(result error) func(filename string, data []byte, perm os.FileMode) error {\n   return func(filename string, data []byte, perm os.FileMode) error {\n      return result\n   }\n}\n\n// remove the restore function to reduce from 3 lines to 1\nfunc restoreWriteFile(original func(filename string, data []byte, perm os.FileMode) error) {\n   // restore the original\n   writeFile = original\n}\n```"]