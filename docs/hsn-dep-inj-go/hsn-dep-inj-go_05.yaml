- en: Dependency Injection with Monkey Patching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用猴子补丁进行依赖注入
- en: Do you have code that relies on a global variable? Do you have code that is
    dependent on the filesystem? Have you ever tried to test your database error handling
    code?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码是否依赖于全局变量？您的代码是否依赖于文件系统？您是否曾经尝试过测试数据库错误处理代码？
- en: In this chapter, we will examine monkey patching as a way to *swap out* dependencies
    during our tests and test in a manner that is otherwise impossible. It doesn't
    matter if these dependencies are objects or functions. We will apply monkey patching
    to our sample service so that we can decouple our tests from the database; decouple
    the different layers from each other and all without resorting to significant
    refactoring.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究猴子补丁作为一种在测试期间*替换*依赖项的方法，并以一种其他情况下不可能的方式进行测试。无论这些依赖项是对象还是函数，我们都将应用猴子补丁到我们的示例服务中，以便我们可以将测试与数据库解耦；将不同层解耦，并且所有这些都不需要进行重大重构。
- en: In continuing with our pragmatic, skeptical approach, we will also discuss the
    advantages and disadvantages of monkey patching.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续我们务实、怀疑的方法时，我们还将讨论猴子补丁的优缺点。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Monkey magic—an introduction to monkey patching
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 猴子魔术——猴子补丁简介
- en: Advantages of monkey patching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 猴子补丁的优点
- en: Applying monkey patching
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用猴子补丁
- en: Disadvantages of monkey patching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 猴子补丁的缺点
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It would be beneficial to be familiar with the code for our service that we
    introduced in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction
    to ACME registration service*. You might also find it useful to read and run the
    full versions of the code for this chapter, which are available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch05](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉我们在[第4章](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml)中介绍的服务的代码将是有益的，*ACME注册服务简介*。您可能还会发现阅读和运行本章的完整代码版本对您有所帮助，这些代码可在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch05](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch05)中找到。
- en: Instructions to obtain the code and configure the sample service are available
    in the README here [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 获取代码并配置示例服务的说明可在此处的README中找到[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/)。
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch05/acme`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`ch05/acme`中找到我们服务的代码，并已应用本章的更改。
- en: Monkey magic!
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猴子魔术！
- en: Monkey patching is changing a program at runtime, typically by replacing a function
    or variable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 猴子补丁是在运行时改变程序，通常是通过替换函数或变量来实现的。
- en: While this is not a traditional form of **dependency injection** (**DI**), it
    can be used in Go to facilitate testing. In fact, monkey patching can be used
    to test in ways that are otherwise impossible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是传统的**依赖注入**（**DI**）形式，但它可以在Go中用于进行测试。事实上，猴子补丁可以用于以其他方式不可能的方式进行测试。
- en: Let's consider a real-world analogy first. Let's say you want to test the effects
    of a car crash on the human body. You probably wouldn't be volunteering to be
    the human that was in the car during testing. Nor are you allowed to make changes
    to the vehicle to facilitate your testing. But you could swap out (monkey patch)
    the human for a crash test dummy during your test.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们考虑一个现实世界的类比。假设您想测试车祸对人体的影响。您可能不会自愿成为测试期间车内的人。也不允许您对车辆进行更改以便进行测试。但是您可以在测试期间将人类换成碰撞测试假人（猴子补丁）。
- en: The same process holds true for monkey patching in code; the changes only exist
    during the test and in many cases can be applied with little impact on the production
    code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中进行猴子补丁的过程与现实情况相同；更改仅在测试期间存在，并且在许多情况下对生产代码的影响很小。
- en: 'A quick note for those of you familiar with dynamic languages such as Ruby,
    Python, and JavaScript: it is possible to monkey patch individual class methods,
    and in some cases, patch the standard library. Go only offers us the ability to
    patch variables, which can be objects or functions, as we will see in this chapter.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉Ruby、Python和JavaScript等动态语言的人来说，有一个快速说明：可以对单个类方法进行猴子补丁，并在某些情况下对标准库进行补丁。Go只允许我们对变量进行补丁，这可以是对象或函数，正如我们将在本章中看到的。
- en: Advantages of monkey patching
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猴子补丁的优点
- en: Monkey patching as a form of DI is very different from the other methods presented
    in this book in both implementation and effect. As such, there are some situations
    in which monkey patching is either the only option or the only succinct one. 
    Monkey patching's other advantages are detailed in this section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 猴子补丁作为一种DI形式，在实施和效果上与本书中介绍的其他方法非常不同。因此，在某些情况下，猴子补丁是唯一的选择或唯一简洁的选择。猴子补丁的其他优点将在本节详细介绍。
- en: '**DI via monkey patching is cheap to implement**—In this book, we have talked
    a lot about decoupling, which is the idea that separate pieces of our code should
    be kept separate, even though they use/depend on each other. We introduce abstractions
    and inject them into each other. Let''s step back for a moment and consider why
    we want the code decoupled in the first place. It''s not only about making it
    easier to test. It''s also about allowing the code to evolve separately and provide
    us with small groups, mental boxes if you will, with which we can think about
    different parts of the code individually. It is this decoupling or separation
    with which monkey patching can be applied.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过monkey patching进行DI的实现成本低廉**——在这本书中，我们谈论了很多关于解耦的内容，即我们的代码的各个部分应该保持独立，即使它们使用/依赖于彼此。我们引入抽象并将它们注入到彼此中。让我们退后一步，考虑一下为什么我们首先要求代码解耦。这不仅仅是为了更容易测试。它还允许代码单独演变，并为我们提供了小组，可以单独思考代码的不同部分。正是这种解耦或分离，使得monkey
    patching可以应用。'
- en: 'Consider this function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个函数：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'How do we decouple this function from the operating system? Let me put it a
    different way: how do we test how this function behaves when the file is missing?'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这个函数与操作系统解耦？换个说法：当文件丢失时，我们如何测试这个函数的行为？
- en: We could replace the filename with `*os.File` or `io.Writer`, but that just
    pushes the problem somewhere else. We could refactor this function into a struct,
    change the call to `ioutil.WriteFile` into an abstraction, and then mock it. But
    that sounds like a lot of work.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`*os.File`或`io.Writer`替换文件名，但这只是把问题推到了别处。我们可以将这个函数重构为一个结构体，将对`ioutil.WriteFile`的调用改为一个抽象，然后进行模拟。但这听起来像是很多工作。
- en: 'With monkey patching, there is a far cheaper option:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用monkey patching，有一个更便宜的选择：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With one line, we have given ourselves the ability to replace `writeFile()`
    with a mock that will allow us to test both happy path and error scenarios with
    ease.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一行代码，我们就给自己提供了用模拟替换`writeFile()`的能力，这样我们就可以轻松测试正常路径和错误场景。
- en: '**Allows us to mock other packages, without fully understanding its internals**—In
    the previous example, you may have noticed that we are mocking a standard library
    function. Do you know how to make `ioutil.WriteFile()` fail? Sure, we could go
    rooting around in the standard library; while that''s a great way to improve your
    Go skills, it''s not what we get paid for. How `ioutil.WriteFile()` could fail
    is not even significant in this case. What is actually important is how our code
    reacts to errors.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**允许我们模拟其他包，而不完全了解其内部情况**——在前面的例子中，您可能已经注意到我们在模拟一个标准库函数。您知道如何使`ioutil.WriteFile()`失败吗？当然，我们可以在标准库中进行搜索；虽然这是提高Go技能的好方法，但这不是我们得到报酬的方式。在这种情况下，`ioutil.WriteFile()`可能会失败并不重要。真正重要的是我们的代码如何对错误做出反应。'
- en: Monkey patching, like other forms of mocking, offers us the ability to not care
    about the internals of the dependency and yet be able to get it to behave as we
    need it to.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Monkey patching，就像其他形式的模拟一样，为我们提供了不必关心依赖的内部情况，但却能让它按我们需要的方式运行的能力。
- en: I propose that testing *from the outside* is the way to go anyway. Decoupling
    how we think about the dependency ensures that any tests have less knowledge of
    the internals and are not therefore susceptible to changes in implementation or
    environment. Should any changes occur to the internal implementation details of
    `io.WriteFile()`, they cannot break our tests. Our tests are only dependent on
    our code, so their reliability is entirely on us.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议从*外部*进行测试，无论如何都是正确的。解耦我们对依赖的思考方式可以确保任何测试对内部情况的了解更少，因此不容易受到实现或环境变化的影响。如果`io.WriteFile()`的内部实现细节发生任何变化，它们都不会破坏我们的测试。我们的测试只依赖于我们的代码，因此它们的可靠性完全取决于我们自己。
- en: '**DI via monkey patching has minimal impact on existing code**—In the previous
    example, we defined the external dependency as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过monkey patching进行DI对现有代码的影响很小**——在前面的例子中，我们将外部依赖定义如下：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s change this slightly:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微改变一下：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Does this remind you of anything? In this version, we are explicitly defining
    our requirements, just like we did in the *Dependency inversion principle* section
    in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID Design Principles
    for Go*. While this change is entirely superfluous, it does raise some interesting
    questions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你想起了什么吗？在这个版本中，我们明确地定义了我们的需求，就像我们在[第2章](53a15217-38a7-4622-9242-a57fe46335ec.xhtml)中的*Go的SOLID设计原则*部分所做的那样。虽然这种改变完全是多余的，但它确实引发了一些有趣的问题。
- en: 'Let''s double back and examine what kinds of changes we would have to make
    to test our method without monkey patching. The first option would be injecting
    `io.WriteFile` into the function, as shown in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回过头来看看，如果不使用monkey patching来测试我们的方法，我们需要做哪些改变。第一个选择是将`io.WriteFile`注入到函数中，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What is wrong with that? Personally, I have three problems with it. Firstly,
    this is a small, simple function with only one dependency; the function would
    get really ugly really quickly if we had more dependencies. To put it another
    way, the code UX is terrible.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么问题吗？就我个人而言，我对此有三个问题。首先，这是一个小而简单的函数，只有一个依赖项；如果我们有更多的依赖项，这个函数将变得非常丑陋。换句话说，代码的用户体验很糟糕。
- en: Secondly, it breaks the encapsulation (information hiding) of the implementation
    of the function. This might feel like I am taking up a zealot-like argument, but
    I don't think of it this way. Imagine what happens if we refactor the implementation
    of our `SaveConfig()` such that we need to change `io.WriteFile` to something
    else. In that situation, we would have to change every use of our function, potentially
    a lot of changes and therefore a lot of risk.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它会破坏函数实现的封装（信息隐藏）。这可能会让人觉得我在进行狂热的争论，但我并不是这样认为的。想象一下，如果我们重构`SaveConfig()`的实现，以至于我们需要将`io.WriteFile`更改为其他内容。在这种情况下，我们将不得不更改我们函数的每次使用，可能会有很多更改，因此也会有很大的风险。
- en: Lastly, this change is arguably test-induced damage, as we discussed in the *Test-induced
    damage* section of [Chapter 3](26893ac5-a588-4954-943e-0eaf690feb34.xhtml), *Coding
    for User Experience*, as it is a change that only serves to improve testing and
    does not enhance the non-test code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这种改变可以说是测试引起的伤害，正如我们在[第3章](26893ac5-a588-4954-943e-0eaf690feb34.xhtml)的*测试引起的伤害*部分所讨论的，*用户体验编码*，因为这是一种只用于改进测试而不增强非测试代码的改变。
- en: 'Another option that might come to mind is to refactor our function into an
    object and then use a more traditional form of DI, as shown in the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能会想到的选择是将我们的函数重构为一个对象，然后使用更传统的DI形式，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Sadly, this refactor suffers from similar issues as the previous one, not least
    of which is that it has the potential to be a considerable amount of changes.
    As you can see, monkey patching required significantly fewer changes than traditional
    methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，这种重构遭受了与之前相似的问题，其中最重要的是它有可能需要大量的改变。正如你所看到的，monkey patching需要的改变明显比传统方法少得多。
- en: '**DI via monkey patching allows testing of globals and singletons**—You probably
    think I am crazy, Go doesn''t have singletons. Perhaps not in the strictest sense,
    but have you ever read the code for the `math/rand` standard library package ([https://godoc.org/math/rand](https://godoc.org/math/rand))?
    In it, you will find the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过monkey patching进行DI允许测试全局变量和单例** - 你可能会认为我疯了，Go语言没有单例。严格来说可能不是，但你有没有读过`math/rand`标准库包（[https://godoc.org/math/rand](https://godoc.org/math/rand)）的代码？在其中，你会发现以下内容：'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How would you test the `Rand` struct? You could swap the `Source` with a mock
    that returned a predictable, non-random result, easy.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何测试`Rand`结构？你可以用一个返回可预测的非随机结果的模拟来交换`Source`，很容易。
- en: 'Now, how would you test the convenience function `Int()`? It''s not so easy.
    This method, by definition, returns a random value. With monkey patching, however,
    we can, as shown in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你如何测试方便函数`Int()`？这并不容易。这个方法，根据定义，返回一个随机值。然而，通过monkey patching，我们可以，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With monkey patching, we are able to test the usage of the singleton without
    any changes to the client code. To achieve this with other methods, we would have
    to introduce a layer of indirection, which in turn would necessitate changes to
    the client code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过monkey patching，我们能够测试单例的使用，而不需要对客户端代码进行任何更改。通过其他方法实现这一点，我们将不得不引入一层间接，这反过来又需要对客户端代码进行更改。
- en: Applying monkey patching
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用monkey patching
- en: 'Let''s apply monkey patching to our ACME registration service that we introduced
    in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction to ACME
    Registration Service*. One of the many things we would like to improve with our
    service is the test reliability and coverage. In this case, we will be working
    on the `data` package. Currently, we only have one test, and it looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将monkey patching应用到我们在[第4章](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml)中介绍的ACME注册服务上，*ACME注册服务简介*。我们希望通过服务改进许多事情之一是测试的可靠性和覆盖范围。在这种情况下，我们将在`data`包上进行工作。目前，我们只有一个测试，看起来是这样的：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this test, we are performing a save and then loading the newly saved registration
    back using both the `Load()` and `LoadAll()` methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们进行了保存，然后使用`Load()`和`LoadAll()`方法加载新保存的注册。
- en: This code has at least three major issues.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码至少有三个主要问题。
- en: Firstly, we are only testing the *happy path*; we have not tested our error
    handling at all.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只测试*快乐路径*；我们根本没有测试错误处理。
- en: Secondly, the test relies on the database. Some people will argue this is fine,
    and I do not want to add to that debate. In this particular case, the use of a
    live database causes our test of `LoadAll()` to be not very specific, which makes
    our tests less thorough than they could be.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，测试依赖于数据库。有些人会认为这没问题，我不想加入这场辩论。在这种情况下，使用实时数据库会导致我们对`LoadAll()`的测试不够具体，这使得我们的测试不如可能的彻底。
- en: 'Lastly, we are testing all the functions together, rather than in isolation. Consider
    what happens when the following part of the test fails:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们一起测试所有的函数，而不是孤立地测试。考虑当测试的以下部分失败时会发生什么：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Where is the problem? Is `Load()` broken or is `Save()` broken? This is the
    basis for the argument regarding testing in isolation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在哪里？是`Load()`出了问题还是`Save()`出了问题？这是关于孤立测试的论点的基础。
- en: All of the functions in the `data` package depend on a global instance of `*sql.DB`,
    which represents a pool of database connections. We therefore will be monkey patching
    that global variable and introducing a mocked version.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`包中的所有函数都依赖于`*sql.DB`的全局实例，它代表了一个数据库连接池。因此，我们将对该全局变量进行monkey patching，并引入一个模拟版本。'
- en: Introducing SQLMock
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍SQLMock
- en: 'The SQLMock package ([https://github.com/DATA-DOG/go-sqlmock](https://github.com/DATA-DOG/go-sqlmock))
    describes itself as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: SQLMock包（[https://github.com/DATA-DOG/go-sqlmock](https://github.com/DATA-DOG/go-sqlmock)）自述如下：
- en: '"A mock library implementing sql/driver. Which has one and only purpose - to
    simulate any sql driver behavior in tests, without needing a real database connection"'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模拟实现sql/driver的模拟库。它只有一个目的 - 在测试中模拟任何sql driver的行为，而不需要真正的数据库连接
- en: I find SQLMock useful, but often more work than directly using the database.
    Being a pragmatic programmer, I am happy to use either. Typically, the choice
    of which to use is made based on how I want the tests to work. If I want to be
    very precise, have no potential for issues related to existing contents of the
    table, and have no possibility for data races caused by the concurrent usage of
    the table, then I will spend the extra effort to use SQLMock.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现SQLMock很有用，但通常比直接使用数据库更费力。作为一个务实的程序员，我很乐意使用任何一种。通常，选择使用哪种取决于我希望测试如何工作。如果我想要非常精确，没有与表的现有内容相关的问题，并且没有由表的并发使用引起的数据竞争的可能性，那么我会花额外的精力使用SQLMock。
- en: A data race occurs when two or more goroutines access a variable at the same
    time, and at least one of the goroutines is writing to the variable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多goroutines同时访问变量，并且至少有一个goroutine正在写入变量时，就会发生数据竞争。
- en: 'Let''s look at using SQLMock to test. Consider the following function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用SQLMock进行测试。考虑以下函数：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This function takes `*Person` and `*sql.DB` as input, saves the person into
    the database provided, and then returns the ID of the newly created record. This
    function is using a traditional form of DI to pass the database connection pool
    into the function. This allows us an easy way to swap out the real database connection
    with a fake one. Now, let''s build the test. First, we create a mock database
    using SQLMock:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数以`*Person`和`*sql.DB`作为输入，将人保存到提供的数据库中，然后返回新创建记录的ID。这个函数使用传统的DI形式将数据库连接池传递给函数。这使我们可以轻松地用假的数据库连接替换真实的数据库连接。现在，让我们构建测试。首先，我们使用SQLMock创建一个模拟数据库：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we define the query we are expecting as a regular expression and use
    that to configure the mock database. In this case, we are expecting a single `db.Exec`
    call that returns `2`, the ID of the newly created record, and `1`, the affected
    row:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将期望的查询定义为正则表达式，并使用它来配置模拟数据库。在这种情况下，我们期望一个单独的`db.Exec`调用返回`2`，即新创建记录的ID，以及`1`，即受影响的行：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we call the function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们调用这个函数：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And then, we validate the results and the mock''s expectations:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们验证结果和模拟的期望：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have an idea of how we can leverage SQLMock to test our database
    interactions, let's apply it to our ACME registration code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了如何利用SQLMock来测试我们的数据库交互的想法，让我们将其应用到我们的ACME注册代码中。
- en: Monkey patching with SQLMock
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQLMock进行monkey patching
- en: 'Firstly, a quick refresher: currently, the `data` package does not use DI,
    and therefore we cannot pass in the `*sql.DB` like we did in the previous example.
    The function currently looks as shown in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，快速回顾一下：当前的`data`包不使用DI，因此我们无法像前面的例子中那样传入`*sql.DB`。该函数当前的样子如下所示：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We could refactor to this, and perhaps in the future we might, but at the moment
    we have almost no tests on this code and refactoring without tests is a terrible
    idea. You might be thinking something similar to *but if we write tests with monkey
    patching and then refactor to a different style of DI later, then we would have
    to refactor these tests*, and you are right; this example is a little contrived.
    That said, there is nothing wrong with writing tests to provide you with a safety
    net or a high level of confidence now, and then deleting them later. It might
    feel like double work, but it's bound to be both less humiliating than introducing
    regression into a running system that people are relying on, and potentially less
    work that debugging that regression.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构成这样，也许将来我们可能会这样做，但目前我们几乎没有对这段代码进行任何测试，而没有测试进行重构是一个可怕的想法。你可能会想到类似于*但如果我们使用monkey
    patching编写测试，然后将来进行不同风格的DI重构，那么我们将不得不重构这些测试*，你是对的；这个例子有点牵强。也就是说，写测试来为你提供安全保障或高水平的信心，然后以后删除它们是没有错的。这可能会感觉像是在做重复的工作，但这肯定比在一个正在运行且人们依赖的系统中引入回归，以及调试这种回归的工作要少得多。
- en: 'The first thing that jumps out is the SQL. We are going to need almost exactly
    the same string in our tests. So, to make it easier to maintain the code in the
    long term, we are going to convert that to a constant and move it to the top of
    the file. As the test is going to be quite similar to our previous example, let''s
    first examine just the monkey patching. From the previous example, we have the
    following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先引人注目的是SQL。我们几乎需要在我们的测试中使用完全相同的字符串。因此，为了更容易地长期维护代码，我们将其转换为常量，并将其移到文件顶部。由于测试将与我们之前的例子非常相似，让我们首先仅检查monkey
    patching。从之前的例子中，我们有以下内容：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In these lines, we are creating a test instance of `*sql.DB` and a mock to control
    it. Before we can monkey patch our test instance of `*sql.DB`, we first need to
    create a backup of the original one so that we can restore it after the test is
    complete. To do this, we are going to use the `defer` keyword.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行中，我们正在创建`*sql.DB`的测试实例和一个控制它的模拟。在我们可以对`*sql.DB`的测试实例进行monkey patching之前，我们首先需要创建原始实例的备份，以便在测试完成后进行恢复。为此，我们将使用`defer`关键字。
- en: 'For those not familiar with it, `defer` is a function that is run just before
    the current function exits, that is, between executing the `return` statement
    and returning control to the caller of the current function. Another significant
    feature of `defer` is the fact that the arguments are evaluated immediately. The
    combination of these two features allows us to take a copy of the original `sql.DB`
    when `defer` is evaluated and not worry about how or when the current function
    exits, saving us from potentially a lot of copying and pasting of *clean up* code.
    This code looks as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉的人来说，`defer`是一个在当前函数退出之前运行的函数，也就是说，在执行`return`语句和将控制权返回给当前函数的调用者之间。`defer`的另一个重要特性是参数会立即求值。这两个特性的结合允许我们在`defer`求值时复制原始的`sql.DB`，而不用担心当前函数何时或如何退出，从而避免了潜在的大量*清理*代码的复制和粘贴。这段代码如下所示：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With this done, the test looks as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，测试如下所示：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Fantastic, we have our happy path test done. Unfortunately, we've only tested
    7 out of 13 lines of our function; perhaps more importantly, we don't know whether
    our error handling code even works correctly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们已经完成了快乐路径测试。不幸的是，我们只测试了函数中的13行中的7行；也许更重要的是，我们不知道我们的错误处理代码是否正确工作。
- en: Testing error handling
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试错误处理
- en: 'There are three possible errors we need to handle:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种可能的错误需要处理：
- en: The SQL insert could fail
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL插入可能会失败
- en: Failure to get the database
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未能获取数据库
- en: We could fail to retrieve the ID of the inserted record
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能无法检索到插入记录的ID
- en: 'So, how do we test for SQL insert failure? With SQLMock it''s easy: we make
    a copy of the previous test and instead of returning `sql.Result`, we return an
    error, as shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何测试SQL插入失败呢？使用SQLMock很容易：我们复制上一个测试，而不是返回`sql.Result`，我们返回一个错误，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can then change our expectations from a result to an error, as shown in
    the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将我们的期望从结果更改为错误，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Moving on to testing *failure to get the database*, this time SQLMock can''t
    help us, but monkey patching can. Currently, our `getDB()` function looks as shown
    in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是测试*无法获取数据库*，这时SQLMock无法帮助我们，但是可以使用monkey patching。目前，我们的`getDB()`函数如下所示：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s change the function to a variable, as shown in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将函数更改为变量，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have not otherwise changed the implementation of the function. We can now
    monkey patch that variable and the resulting test looks as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有改变函数的实现。现在我们可以对该变量进行monkey patch，得到如下的测试结果：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You may have noticed a high amount of duplication between the happy path and
    error path tests. This is somewhat common in Go tests and is perhaps driven by
    the fact that we are intentionally calling a function repeatedly with different
    inputs or environments, essentially documenting and enforcing a contract of behavior
    for the object we are testing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到正常路径和错误路径测试之间存在大量重复。这在Go语言测试中有些常见，可能是因为我们有意地重复调用一个函数，使用不同的输入或环境，从根本上来说是在为我们测试的对象记录和强制执行行为契约。
- en: Given these fundamental responsibilities, we should be looking to ensure that
    our tests are both easy to read and maintain. To achieve these goals we can apply
    one of my favorite features in Go, table-driven tests ([https://github.com/golang/go/wiki/TableDrivenTests](https://github.com/golang/go/wiki/TableDrivenTests)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些基本职责，我们应该努力确保我们的测试既易于阅读又易于维护。为了实现这些目标，我们可以应用Go语言中我最喜欢的一个特性，即表驱动测试（[https://github.com/golang/go/wiki/TableDrivenTests](https://github.com/golang/go/wiki/TableDrivenTests)）。
- en: Reducing test bloat with table-driven tests
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表驱动测试减少测试膨胀
- en: 'With table-driven tests, we define a slice of scenarios (often the function
    inputs, mock configuration, and our expectations) at the start of the test and
    then a scenario runner, which is typically part of the test that would otherwise
    have been duplicated. Let''s see what this looks like as an example. The happy
    path test for the `Load()` function looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表驱动测试，我们在测试开始时定义一系列场景（通常是函数输入、模拟配置和我们的期望），然后是一个场景运行器，通常是测试的一部分，否则会重复。让我们看一个例子。`Load()`函数的正常路径测试如下所示：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This function has about 11 functional lines (after removing the formatting),
    of which approximately 9 would be almost identical in our test for SQL load failure.
    Converting this to a table-driven test gives us this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数大约有11行功能代码（去除格式化后），其中大约有9行在我们对SQL加载失败的测试中几乎是相同的。将其转换为表驱动测试得到如下结果：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Sorry, there''s a lot going on there, so let''s break this into its separate
    parts:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉，这里有很多内容，让我们把它分成几个部分：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These lines define a slice and an anonymous struct that will be our list of
    scenarios. In this case, our scenario contains the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行定义了一个切片和一个匿名结构，它将是我们的场景列表。在这种情况下，我们的场景包含以下内容：
- en: '**A description**: This is useful for adding to test error messages.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：这对于添加到测试错误消息中很有用。'
- en: '**Mock configuration**: As we are testing how our code reacts to different
    responses from the database, this is where most of the magic happens.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟配置**：由于我们正在测试代码如何对来自数据库的不同响应做出反应，这就是大部分魔法发生的地方。'
- en: '**An expected result**: Fairly standard, given the inputs and environment (that
    is, mock configuration). This is what we want to get back.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预期结果**：相当标准，考虑到输入和环境（即模拟配置）。这是我们想要得到的。'
- en: '**A Boolean to indicate whether we expect an error**: We could use an error
    value here; it would be more precise. However, I prefer to use a custom error,
    which means the output is not constant. I have also found that error messages
    can change over time and therefore the narrowness of the check makes the tests
    brittle. Essentially, I am trading test specificity for durability.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个布尔值，表示我们是否期望出现错误**：我们可以在这里使用错误值；这样会更精确。但是，我更喜欢使用自定义错误，这意味着输出不是常量。我还发现错误消息可能随时间而改变，因此检查的狭窄性使测试变得脆弱。基本上，我在测试的特定性和耐久性之间进行了权衡。'
- en: 'Then we have our scenarios, one per test case:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有我们的场景，每个测试用例一个：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now there''s the test runner, which is basically a loop over all the scenarios:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有测试运行器，基本上是对所有场景的循环：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The contents of this loop are quite similar to the contents of our original
    test. It's often easier to write the happy path test first and then convert it
    to a table-driven test by adding the additional scenarios.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环的内容与我们原始测试的内容非常相似。通常先编写正常路径测试，然后通过添加其他场景将其转换为表驱动测试更容易。
- en: Perhaps the only difference between our test runner and the original function
    is that we are monkey patching. We cannot use `defer` inside a `for` loop as `defer`
    only runs when the function exits; we therefore have to restore the database at
    the end of the loop instead.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们的测试运行器和原始函数之间唯一的区别是我们在进行monkey patch。我们不能在`for`循环中使用`defer`，因为`defer`只有在函数退出时才会运行；因此，我们必须在循环结束时恢复数据库。
- en: The use of table-driven tests here not only reduced the duplication in our test
    code, but it also has two other significant advantages. Firstly, it has distilled
    the tests down to inputs equals outputs, making them very easy to understand and
    very easy to add more scenarios.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用表驱动测试不仅减少了测试代码中的重复，而且还有其他两个重要的优点。首先，它将测试简化为输入等于输出，使它们非常容易理解，也很容易添加更多的场景。
- en: Secondly, the code that is likely to change, namely the function call itself,
    only exists in one place. If that function altered to accept another input or
    return another value, we would have to fix it in one place, compared to once per
    test scenario.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，可能会发生变化的代码，即函数调用本身，只存在一个地方。如果该函数被修改以接受其他输入或返回其他值，我们只需要在一个地方进行修复，而不是每个测试场景一次。
- en: Monkey patching between packages
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包之间的猴子补丁
- en: So far, we have looked at monkey patching a private global variable or function
    for the purposes of testing inside our `data` package. But what happens if we
    want to test other packages? Wouldn't it be nice to decouple the business logic
    layer from the database too? That would certainly stop our business logic layer
    tests from breaking for unrelated events, such as optimizing our SQL queries.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了在我们的`data`包内部进行测试的目的而进行猴子补丁私有全局变量或函数。但是如果我们想测试其他包会发生什么呢？将业务逻辑层与数据库解耦也许是个好主意？这样可以确保我们的业务逻辑层测试不会因为无关的事件（例如优化我们的SQL查询）而出错。
- en: 'Again, we are faced with a dilemma; we could start large-scale refactoring,
    but as we''ve mentioned before, it''s a lot of work and a lot of risk, especially
    without tests to keep us out of trouble. Let''s look at the most straightforward
    business logic package we have, the `get` package:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们面临一个困境；我们可以开始大规模的重构，但正如我们之前提到的，这是一项艰巨的工作，而且风险很大，特别是没有测试来避免麻烦。让我们看看我们拥有的最简单的业务逻辑包，即`get`包：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, this function does very little beyond loading the person from
    the database. You could argue therefore that it does not need to exist; don't
    worry, we will be giving it more responsibility later on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个函数除了从数据库加载人员之外几乎没有做什么。因此，你可以认为它不需要存在；别担心，我们稍后会赋予它更多的责任。
- en: So how do we test this without the database? The first thing that comes to mind
    might be to monkey patch the database pool or the `getDatabase()` function as
    we did before.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在没有数据库的情况下进行测试呢？首先想到的可能是像之前一样对数据库池或`getDatabase()`函数进行猴子补丁。
- en: This would work, but it would be sloppy and pollute the public API for the `data`
    package with things that we don't want production code using, the very definition
    of test-induced damage. It would also do nothing to decouple this package from
    the internal implementation of the `data` package. In fact, it would make it worse.
    Any change to the implementation of the `data` package would likely break our
    test for this package.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是可行的，但会很粗糙，并且会污染`data`包的公共API，这是测试引起的破坏的明显例子。这也不会使该包与`data`包的内部实现解耦。事实上，这会使情况变得更糟。`data`包的实现的任何更改都可能破坏我们对该包的测试。
- en: Another aspect to consider is that we can make any alteration we want because
    the service is small and we own all the code. This is often not the case; the
    package could be owned by another team, it could be part of an external dependency,
    or even part of the standard library. It's better, therefore, to get into the
    habit of keeping our changes local to the package we are working on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的方面是，我们可以进行任何想要的修改，因为这项服务很小，而且我们拥有所有的代码。这通常并非如此；该包可能由另一个团队拥有，它可能是外部依赖的一部分，甚至是标准库的一部分。因此，最好养成的习惯是保持我们的更改局限于我们正在处理的包。
- en: 'With that in mind, we can adopt a trick we looked at briefly in the previous
    section, *Advantages of monkey patching*. Let''s intercept the call from the `get`
    package to the `data` package, as shown in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以采用我们在上一节中简要介绍的一个技巧，即*猴子补丁的优势*。让我们拦截`get`包对`data`包的调用，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can intercept the calls with monkey patching, as shown in the following
    code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过猴子补丁拦截调用，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, our test is not dependent on the database or any internal implementation
    details of the `data` package. While we have not entirely decoupled the packages,
    we have significantly reduced the number of things that must happen correctly
    for the tests in the `get` package to pass. This is arguably one of the points
    of DI by monkey patching, reducing the ways tests could break by reducing the
    dependence on outside factors and increasing the focus of the tests.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的测试不依赖于数据库或`data`包的任何内部实现细节。虽然我们并没有完全解耦这些包，但我们已经大大减少了`get`包中的测试必须正确执行的事项。这可以说是通过猴子补丁实现DI的一个要点，通过减少对外部因素的依赖并增加测试的焦点，减少测试可能出错的方式。
- en: When the magic fades
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当魔法消失时
- en: Earlier in the book, I challenged you to examine each method of DI presented
    in the book with a critical eye. With that in mind, we should consider the potential
    costs of monkey patching.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早些时候，我挑战你以批判的眼光审视本书中提出的每种DI方法。考虑到这一点，我们应该考虑猴子补丁的潜在成本。
- en: '**Data races**—We saw in our examples that monkey patching is the process of
    replacing a global variable with a copy that performs in the way we need it to
    for a particular test. And that is perhaps the biggest problem. Swapping something
    global, and therefore shared, for something specific causes a data race on that
    variable.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据竞争**——我们在示例中看到，猴子补丁是用执行特定测试所需的方式替换全局变量的过程。这也许是最大的问题。用特定的东西替换全局的，因此是共享的，会在该变量上引发数据竞争。'
- en: To understand this data race a little more, we need to understand how Go runs
    tests. By default, tests within a package are executed sequentially. We can reduce
    our test execution time by marking our tests with `t.Parallel()`. With our current
    tests of the `data` package, marking the test as parallel would cause the data
    race to appear, resulting in unpredictable tests.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这种数据竞争，我们需要了解Go如何运行测试。默认情况下，包内的测试是按顺序执行的。我们可以通过在测试中标记`t.Parallel()`来减少测试执行时间。对于我们当前的`data`包测试，将测试标记为并行会导致数据竞争出现，从而导致测试结果不可预测。
- en: Another significant feature of Go testing is that Go executes multiple packages
    in parallel. Like `t.Parallel()`, this can be fantastic for our test execution
    time. With our current code, we are safe from this because we only monkey patched
    within the same package as the tests. If we had monkey patched across package
    boundaries, then the data race would appear.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Go测试的另一个重要特性是，Go可以并行执行多个包。像`t.Parallel()`一样，这对我们的测试执行时间来说可能是很棒的。通过我们当前的代码，我们可以确保安全，因为我们只在与测试相同的包内进行了猴子补丁。如果我们在包边界之间进行了猴子补丁，那么数据竞争就会出现。
- en: 'If your tests are flaky and you suspect a data race, you can try Go''s built-in
    race detection ([https://golang.org/doc/articles/race_detector.html](https://golang.org/doc/articles/race_detector.html))
    with:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的测试不稳定，并且怀疑存在数据竞争，您可以尝试使用Go的内置竞争检测器（[https://golang.org/doc/articles/race_detector.html](https://golang.org/doc/articles/race_detector.html)）：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If that doesn''t find the problem, you can try running all the tests sequentially
    with:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样找不到问题，您可以尝试按顺序运行所有测试：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the tests start passing consistently, then you will need to start digging
    for data races.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试开始一致通过，那么您将需要开始查找数据竞争。
- en: '**Verbose tests**—As you have seen in our tests, the code to monkey patch and
    restore can become rather lengthy. With a little bit of refactoring, it is possible
    to lessen the boilerplate. For example, look at this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细测试**——正如您在我们的测试中所看到的，猴子补丁和恢复的代码可能会变得相当冗长。通过一点重构，可以减少样板代码。例如，看看这个：'
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We could change it to this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其更改为：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After this refactoring, we have far less duplication in the tests, resulting
    in less to maintain, but more importantly, the tests are no longer overshadowed
    by all of the monkey-patching-related code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次重构之后，我们的测试中重复的部分大大减少，从而减少了维护的工作量，但更重要的是，测试不再被所有与猴子补丁相关的代码所掩盖。
- en: '**Obfuscated dependency relationship**—This is not a problem with monkey patching
    itself but with the style of dependency management in general. In traditional
    DI, the dependency is passed in as a parameter, making the relationship explicit
    and visible.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**混淆的依赖关系**——这不是猴子补丁本身的问题，而是一般依赖管理风格的问题。在传统的DI中，依赖关系作为参数传递，使关系显式可见。'
- en: From a user perspective, this lack of parameters can be considered an improvement
    to the UX of the code; after all, fewer inputs typically makes a function easier
    to use. However, when it comes to testing, things get messy quickly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，这种缺乏参数可以被认为是代码UX的改进；毕竟，更少的输入通常会使函数更容易使用。但是，当涉及测试时，事情很快变得混乱。
- en: In our previous example, the `SaveConfig()` function depends on `ioutil.WriteFile()`
    and so mocking that dependency to test `SaveConfig()` seems reasonable. However,
    what happens when we need to test a function that calls `SaveConfig()`?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，“SaveConfig（）”函数依赖于“ioutil.WriteFile（）”，因此对该依赖进行模拟以测试“SaveConfig（）”似乎是合理的。但是，当我们需要测试调用“SaveConfig（）”的函数时会发生什么？
- en: How does the user of `SaveConfig()` know that they need to mock `ioutil.WriteFile()`?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`SaveConfig（）`的用户如何知道他们需要模拟`ioutil.WriteFile（）`？'
- en: Because the relationship is muddled, the knowledge required increases and, incidentally,
    so does the test length; it isn't long before we have half a screen of monkey
    patching of functions at the beginning of every test.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关系混乱，所需的知识增加了，测试长度也相应增加；不久之后，我们在每个测试的开头就会有半屏幕的函数猴子补丁。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how to leverage monkey patching to *swap out* dependencies
    in our tests. With monkey patching, we have tested globals, decoupled packages,
    and removed our dependence on external resources such as databases and the filesystem.
    We've worked through some practical examples while improving our sample service's
    code, and we frankly discussed both the advantages and disadvantages of using
    monkey patching.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何利用猴子补丁来在测试中*替换*依赖关系。通过猴子补丁，我们已经测试了全局变量，解耦了包，并且消除了对数据库和文件系统等外部资源的依赖。我们通过一些实际示例来改进了我们示例服务的代码，并坦率地讨论了使用猴子补丁的优缺点。
- en: In the next chapter, we will look at the second and perhaps the most traditional
    DI technique, dependency injection with constructor injection. With it, we will
    improve our service's code even further.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究第二种，也许是最传统的DI技术，即构造函数注入的依赖注入。通过它，我们将进一步改进我们服务的代码。
- en: Questions
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does monkey patching work?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 猴子补丁是如何工作的？
- en: What are the ideal use cases for monkey patching?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 猴子补丁的理想用例是什么？
- en: How can you use monkey patching to decouple two packages without changing the
    dependency package?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用猴子补丁来解耦两个包而不更改依赖包？
- en: Further reading
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Packt has many other great resources for learning about monkey patching:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Packt还有许多其他关于猴子补丁的学习资源：
- en: '**Mastering JQuery**: [https://www.packtpub.com/mapt/book/web_development/9781785882166/12/ch12lvl1sec100/monkey-patching](https://www.packtpub.com/mapt/book/web_development/9781785882166/12/ch12lvl1sec100/monkey-patching)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**掌握JQuery**：[https://www.packtpub.com/mapt/book/web_development/9781785882166/12/ch12lvl1sec100/monkey-patching](https://www.packtpub.com/mapt/book/web_development/9781785882166/12/ch12lvl1sec100/monkey-patching)'
- en: '**Learn to code with Ruby**: [https://www.packtpub.com/mapt/video/application_development/9781788834063/40761/41000/monkey-patching-ii](https://www.packtpub.com/mapt/video/application_development/9781788834063/40761/41000/monkey-patching-ii)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习使用Ruby编码**：[https://www.packtpub.com/mapt/video/application_development/9781788834063/40761/41000/monkey-patching-ii](https://www.packtpub.com/mapt/video/application_development/9781788834063/40761/41000/monkey-patching-ii)'
