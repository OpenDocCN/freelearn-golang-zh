["```go\n// WelcomeSender sends a Welcome email to new users\ntype WelcomeSender struct {\n   mailer *Mailer\n}\n\nfunc (w *WelcomeSender) Send(to string) error {\n   body := w.buildMessage()\n\n   return w.mailer.Send(to, body)\n}\n```", "```go\nfunc NewWelcomeSender(in *Mailer) (*WelcomeSender, error) {\n   // guard clause\n   if in == nil {\n      return nil, errors.New(\"programmer error: mailer must not provided\")\n   }\n\n   return &WelcomeSender{\n      mailer: in,\n   }, nil\n}\n```", "```go\nfunc NewWelcomeSenderNoGuard(in *Mailer) *WelcomeSender {\n   return &WelcomeSender{\n      mailer: in,\n   }\n}\n```", "```go\n// Mailer sends and receives emails\ntype Mailer struct{\n   Host string\n   Port string\n   Username string\n   Password string\n}\n\nfunc (m *Mailer) Send(to string, body string) error {\n   // send email\n   return nil\n}\n\nfunc (m *Mailer) Receive(address string) (string, error) {\n   // receive email\n   return \"\", nil\n}\n```", "```go\n// Mailer sends and receives emails\ntype MailerInterface interface {\n   Send(to string, body string) error\n   Receive(address string) (string, error)\n}\n```", "```go\ntype Sender interface {\n   Send(to string, body string) error\n}\n\nfunc NewWelcomeSenderV2(in Sender) *WelcomeSenderV2 {\n   return &WelcomeSenderV2{\n      sender: in,\n   }\n}\n```", "```go\ntype Talker interface {\n   Speak() string\n   Shout() string\n}\n\ntype Dog struct{}\n\nfunc (d Dog) Speak() string {\n   return \"Woof!\"\n}\n\nfunc (d Dog) Shout() string {\n   return \"WOOF!\"\n}\n\nfunc SpeakExample() {\n   var talker Talker\n   talker = Dog{}\n\n   fmt.Print(talker.Speak())\n}\n```", "```go\n// WelcomeSender sends a Welcome email to new users\ntype WelcomeSender struct {\n   Mailer *Mailer\n}\n\nfunc (w *WelcomeSender) Send(to string) error {\n   body := w.buildMessage()\n\n   return w.Mailer.Send(to, body)\n}\n```", "```go\nfunc NewWelcomeSender(mailer *Mailer) *WelcomeSender {\n   return &WelcomeSender{\n      mailer: mailer,\n   }\n}\n\n// WelcomeSender sends a Welcome email to new users\ntype WelcomeSender struct {\n   mailer *Mailer\n}\n\nfunc (w *WelcomeSender) Send(to string) error {\n   body := w.buildMessage()\n\n   return w.mailer.Send(to, body)\n}\n```", "```go\ntype Car struct {\n   Engine Engine\n}\n\nfunc (c *Car) Drive() error {\n   if c.Engine == nil {\n      return errors.New(\"engine ie missing\")\n   }\n\n   // use the engine\n   c.Engine.Start()\n   c.Engine.IncreasePower()\n\n   return nil\n}\n\nfunc (c *Car) Stop() error {\n   if c.Engine == nil {\n\n      return errors.New(\"engine ie missing\")\n   }\n\n   // use the engine\n   c.Engine.DecreasePower()\n   c.Engine.Stop()\n\n   return nil\n}\n```", "```go\nfunc NewCar(engine Engine) (*Car, error) {\n  if engine == nil {\n    return nil, errors.New(\"invalid engine supplied\")\n  }\n\n  return &Car{\n    engine: engine,\n  }, nil\n}\n\ntype Car struct {\n   engine Engine\n}\n\nfunc (c *Car) Drive() error {\n   // use the engine\n   c.engine.Start()\n   c.engine.IncreasePower()\n\n   return nil\n}\n\nfunc (c *Car) Stop() error {\n   // use the engine\n   c.engine.DecreasePower()\n   c.engine.Stop()\n\n   return nil\n}\n```", "```go\nfunc (c *Car) FillPetrolTank() error {\n   // use the engine\n   if c.engine.IsRunning() {\n      return errors.New(\"cannot fill the tank while the engine is running\")\n   }\n\n   // fill the tank!\n   return c.fill()\n}\n```", "```go\nfunc (c *Car) FillPetrolTank(engine Engine) error {\n   // use the engine\n   if engine.IsRunning() {\n      return errors.New(\"cannot fill the tank while the engine is running\")\n   }\n\n   // fill the tank!\n   return c.fill()\n}\n```", "```go\nfunc TestRegisterHandler_ServeHTTP(t *testing.T) {\n   // ensure the test always fails by giving it a timeout\n   ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n   defer cancel()\n\n   // Create and start a server\n   // With out current implementation, we cannot test this handler without\n   // a full server as we need the mux.\n   address, err := startServer(ctx)\n   require.NoError(t, err)\n\n   // build inputs\n   validRequest := buildValidRequest()\n   response, err := http.Post(\"http://\"+address+\"/person/register\", \"application/json\", validRequest)\n\n   // validate outputs\n   require.NoError(t, err)\n   require.Equal(t, http.StatusCreated, response.StatusCode)\n   defer response.Body.Close()\n\n   // call should output the location to the new person\n   headerLocation := response.Header.Get(\"Location\")\n   assert.Contains(t, headerLocation, \"/person/\")\n}\n```", "```go\nfunc TestRegisterHandler_ServeHTTP(t *testing.T) {\n   scenarios := []struct {\n      desc           string\n      inRequest      func() *http.Request\n      inModelMock    func() *MockRegisterModel\n      expectedStatus int\n      expectedHeader string\n   }{\n      // scenarios go here\n   }\n\n   for _, s := range scenarios {\n      scenario := s\n      t.Run(scenario.desc, func(t *testing.T) {\n         // test goes here\n      })\n   }\n}\n```", "```go\nfor _, s := range scenarios {\n   scenario := s\n   t.Run(scenario.desc, func(t *testing.T) {\n      // define model layer mock\n      mockRegisterModel := scenario.inModelMock()\n\n      // build handler\n      handler := &RegisterHandler{\n         registerer: mockRegisterModel,\n      }\n\n      // perform request\n      response := httptest.NewRecorder()\n      handler.ServeHTTP(response, scenario.inRequest())\n\n      // validate outputs\n      require.Equal(t, scenario.expectedStatus, response.Code)\n\n      // call should output the location to the new person\n      resultHeader := response.Header().Get(\"Location\")\n      assert.Equal(t, scenario.expectedHeader, resultHeader)\n\n      // validate the mock was used as we expected\n      assert.True(t, mockRegisterModel.AssertExpectations(t))\n   })\n}\n```", "```go\n{\n   desc: \"Happy Path\",\n   inRequest: func() *http.Request {\n      validRequest := buildValidRegisterRequest()\n      request, err := http.NewRequest(\"POST\", \"/person/register\", validRequest)\n      require.NoError(t, err)\n\n      return request\n   },\n   inModelMock: func() *MockRegisterModel {\n      // valid downstream configuration\n      resultID := 1234\n      var resultErr error\n\n      mockRegisterModel := &MockRegisterModel{}\n      mockRegisterModel.On(\"Do\", mock.Anything).Return(resultID, resultErr).Once()\n\n      return mockRegisterModel\n   },\n   expectedStatus: http.StatusCreated,\n   expectedHeader: \"/person/1234/\",\n},\n```", "```go\n{\n   desc: \"Bad Input / User Error\",\n   inRequest: func() *http.Request {\n      invalidRequest := bytes.NewBufferString(`this is not valid JSON`)\n      request, err := http.NewRequest(\"POST\", \"/person/register\", invalidRequest)\n      require.NoError(t, err)\n\n      return request\n   },\n   inModelMock: func() *MockRegisterModel {\n      // Dependency should not be called\n      mockRegisterModel := &MockRegisterModel{}\n      return mockRegisterModel\n   },\n   expectedStatus: http.StatusBadRequest,\n   expectedHeader: \"\",\n},\n\n```", "```go\n{\n   desc: \"Dependency Failure\",\n   inRequest: func() *http.Request {\n      validRequest := buildValidRegisterRequest()\n      request, err := http.NewRequest(\"POST\", \"/person/register\", validRequest)\n      require.NoError(t, err)\n\n      return request\n   },\n   inModelMock: func() *MockRegisterModel {\n      // call to the dependency failed\n      resultErr := errors.New(\"something failed\")\n\n      mockRegisterModel := &MockRegisterModel{}\n      mockRegisterModel.On(\"Do\", mock.Anything).Return(0, resultErr).Once()\n\n      return mockRegisterModel\n   },\n   expectedStatus: http.StatusInternalServerError,\n   expectedHeader: \"\",\n},\n\n```", "```go\n// RegisterHandler is the HTTP handler for the \"Register\" endpoint\n// In this simplified example we are assuming all possible errors \n// are user errors and returning \"bad request\" HTTP 400.\n// There are some programmer errors possible but hopefully these \n// will be caught in testing.\ntype RegisterHandler struct {\n}\n\n// ServeHTTP implements http.Handler\nfunc (h *RegisterHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n   // extract payload from request\n   requestPayload, err := h.extractPayload(request)\n   if err != nil {\n      // output error\n      response.WriteHeader(http.StatusBadRequest)\n      return\n   }\n\n   // register person\n   id, err := h.register(requestPayload)\n   if err != nil {\n      // not need to log here as we can expect other layers to do so\n      response.WriteHeader(http.StatusBadRequest)\n      return\n   }\n\n   // happy path\n   response.Header().Add(\"Location\", fmt.Sprintf(\"/person/%d/\", id))\n   response.WriteHeader(http.StatusCreated)\n}\n\n// extract payload from request\nfunc (h *RegisterHandler) extractPayload(request *http.Request) (*registerRequest, error) {\n   requestPayload := &registerRequest{}\n\n   decoder := json.NewDecoder(request.Body)\n   err := decoder.Decode(requestPayload)\n   if err != nil {\n      return nil, err\n   }\n\n   return requestPayload, nil\n}\n\n// call the logic layer\nfunc (h *RegisterHandler) register(requestPayload *registerRequest) (int, error) {\n   person := &data.Person{\n      FullName: requestPayload.FullName,\n      Phone:    requestPayload.Phone,\n      Currency: requestPayload.Currency,\n   }\n\n   registerer := &register.Registerer{}\n   return registerer.Do(person)\n}\n```", "```go\nregisterer := &register.Registerer{}\n```", "```go\n// RegisterHandler is the HTTP handler for the \"Register\" endpoint\ntype RegisterHandler struct {\n   registerer *register.Registerer\n}\n```", "```go\n// RegisterModel will validate and save a registration\ntype RegisterModel interface {\n   Do(in *data.Person) (int, error)\n}\n\n// RegisterHandler is the HTTP handler for the \"Register\" endpoint\ntype RegisterHandler struct {\n   registerer RegisterModel\n}\n```", "```go\n// NewRegisterHandler is the constructor for RegisterHandler\nfunc NewRegisterHandler(model RegisterModel) *RegisterHandler {\n   return &RegisterHandler{\n      registerer: model,\n   }\n}\n```", "```go\n// New will create and initialize the server\nfunc New(address string) *Server {\n   return &Server{\n      address:         address,\n      handlerGet:      NewGetHandler(&get.Getter{}),\n      handlerList:     NewListHandler(&list.Lister{}),\n      handlerNotFound: notFoundHandler,\n      handlerRegister: NewRegisterHandler(&register.Registerer{}),\n   }\n}\n```", "```go\n// New will create and initialize the server\nfunc New(address string,\n   getModel GetModel,\n   listModel ListModel,\n   registerModel RegisterModel) *Server {\n\n   return &Server{\n      address:         address,\n      handlerGet:      NewGetHandler(getModel),\n      handlerList:     NewListHandler(listModel),\n      handlerNotFound: notFoundHandler,\n      handlerRegister: NewRegisterHandler(registerModel),\n   }\n}\n```", "```go\n// Dealer will shuffle a deck of cards and deal them to the players\nfunc DealCards() (player1 []Card, player2 []Card) {\n   // create a new deck of cards\n   cards := newDeck()\n\n   // shuffle the cards\n   shuffler := &myShuffler{}\n   shuffler.Shuffle(cards)\n\n   // deal\n   player1 = append(player1, cards[0])\n   player2 = append(player2, cards[1])\n\n   player1 = append(player1, cards[2])\n   player2 = append(player2, cards[3])\n   return\n}\n```", "```go\n// FetchRates rates from downstream service\ntype FetchRates struct{}\n\nfunc (f *FetchRates) Fetch() ([]Rate, error) {\n   // build the URL from which to fetch the rates\n   url := downstreamServer + \"/rates\"\n\n   // build request\n   request, err := http.NewRequest(\"GET\", url, nil)\n   if err != nil {\n      return nil, err\n   }\n\n   // fetch rates\n   response, err := http.DefaultClient.Do(request)\n   if err != nil {\n      return nil, err\n   }\n   defer response.Body.Close()\n\n   // read the content of the response\n   data, err := ioutil.ReadAll(response.Body)\n   if err != nil {\n      return nil, err\n   }\n\n   // convert JSON bytes to Go structs\n   out := &downstreamResponse{}\n   err = json.Unmarshal(data, out)\n   if err != nil {\n      return nil, err\n   }\n\n   return out.Rates, nil\n}\n```", "```go\n// NewClient creates and initialises the client\nfunc NewClient(service DepService) Client {\n   return &clientImpl{\n      service: service,\n   }\n}\n\n// Client is the exported API\ntype Client interface {\n   DoSomethingUseful() (bool, error)\n}\n\n// implement Client\ntype clientImpl struct {\n   service DepService\n}\n\nfunc (c *clientImpl) DoSomethingUseful() (bool, error) {\n   // this function does something useful\n   return false, errors.New(\"not implemented\")\n}\n```", "```go\npackage other\n\n// StubClient is a stub implementation of sdk.Client interface\ntype StubClient struct{}\n\n// DoSomethingUseful implements sdk.Client\nfunc (s *StubClient) DoSomethingUseful() (bool, error) {\n   return true, nil\n}\n```", "```go\ntype InnerService struct {\n   innerDep Dependency\n}\n\nfunc NewInnerService(innerDep Dependency) *InnerService {\n   return &InnerService{\n      innerDep: innerDep,\n   }\n}\n\ntype OuterService struct {\n   // composition\n   innerService *InnerService\n\n   outerDep Dependency\n}\n\nfunc NewOuterService(outerDep Dependency, innerDep Dependency) *OuterService {\n   return &OuterService{\n      innerService: NewInnerService(innerDep),\n      outerDep:     outerDep,\n   }\n}\n```"]