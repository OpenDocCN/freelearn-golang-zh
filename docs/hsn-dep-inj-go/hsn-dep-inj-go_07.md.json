["```go\nfmt.Fprint(os.Stdout, \"Hello World\")\n```", "```go\nreq, err := http.NewRequest(\"POST\", \"/login\", body)\n```", "```go\n// Fprint formats using the default formats for its operands and writes \n// to w. It returns the number of bytes written and any write error \n// encountered.\nfunc Fprint(w io.Writer, a ...interface{}) (n int, err error)\n```", "```go\nfunc NewRequest(method, url string, body io.Reader) (*http.Request, error) {\n   // validate method\n   m, err := validateMethod(method)\n   if err != nil {\n      return nil, err\n   }\n\n   // validate URL\n   u, err := validateURL(url)\n   if err != nil {\n      return nil, err\n   }\n\n   // process body (if exists)\n   var b io.ReadCloser\n   if body != nil {\n      // read body\n      b = ioutil.NopCloser(body)\n   }\n\n   // build Request and return\n   req := &http.Request{\n      URL:    u,\n      Method: m,\n      Body:   b,\n   }\n\n   return req, nil\n}\n```", "```go\n// TimeStampWriterV1 will output the supplied message to \n//writer preceded with a timestamp\nfunc TimeStampWriterV1(writer io.Writer, message string) {\n   timestamp := time.Now().Format(time.RFC3339)\n   fmt.Fprintf(writer, \"%s -> %s\", timestamp, message)\n}\n```", "```go\n// TimeStampWriterV2 will output the supplied message to \n//writer preceded with a timestamp\nfunc TimeStampWriterV2(writer io.Writer, message string) error {\n   if writer == nil {\n      return errors.New(\"writer cannot be nil\")\n   }\n\n   timestamp := time.Now().Format(time.RFC3339)\n   fmt.Fprintf(writer,\"%s -> %s\", timestamp, message)\n\n   return nil\n}\n```", "```go\n// TimeStampWriterV3 will output the supplied message to \n//writer preceded with a timestamp\nfunc TimeStampWriterV3(writer io.Writer, message string) {\n   if writer == nil {\n      // default to Standard Out\n      writer = os.Stdout\n   }\n\n   timestamp := time.Now().Format(time.RFC3339)\n   fmt.Fprintf(writer,\"%s -> %s\", timestamp, message)\n}\n```", "```go\nfunc HandlerV1(response http.ResponseWriter, request *http.Request) {\n   garfield := &Animal{\n      Type: \"Cat\",\n      Name: \"Garfield\",\n   }\n\n   // encode as JSON and output\n   encoder := json.NewEncoder(response)\n   err := encoder.Encode(garfield)\n   if err != nil {\n      response.WriteHeader(http.StatusInternalServerError)\n      return\n   }\n\n   response.WriteHeader(http.StatusOK)\n}\n```", "```go\nfunc outputAnimal(response http.ResponseWriter, animal *Animal) {\n   encoder := json.NewEncoder(response)\n   err := encoder.Encode(animal)\n   if err != nil {\n      response.WriteHeader(http.StatusInternalServerError)\n      return\n   }\n\n   // Happy Path\n   response.WriteHeader(http.StatusOK)\n}\n```", "```go\nfunc outputJSON(response http.ResponseWriter, data interface{}) {\n   encoder := json.NewEncoder(response)\n   err := encoder.Encode(data)\n   if err != nil {\n      response.WriteHeader(http.StatusInternalServerError)\n      return\n   }\n\n   // Happy Path\n   response.WriteHeader(http.StatusOK)\n}\n```", "```go\nfunc WriteLog(writer io.Writer, message string) error {\n   _, err := writer.Write([]byte(message))\n   return err\n}\n```", "```go\n// Write to console\nWriteLog(os.Stdout, \"Hello World!\")\n\n// Write to file\nfile, _ := os.Create(\"my-log.log\")\nWriteLog(file, \"Hello World!\")\n\n// Write to TCP connection\ntcpPipe, _ := net.Dial(\"tcp\", \"127.0.0.1:1234\")\nWriteLog(tcpPipe, \"Hello World!\")\n```", "```go\n// LoadOrderHandler is a HTTP handler that loads orders based on the current user and supplied user ID\ntype LoadOrderHandler struct {\n   loader OrderLoader\n}\n\n// ServeHTTP implements http.Handler\nfunc (l *LoadOrderHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n   // extract user from supplied authentication credentials\n   currentUser, err := l.authenticateUser(request)\n   if err != nil {\n      response.WriteHeader(http.StatusUnauthorized)\n      return\n   }\n\n   // extract order ID from request\n   orderID, err := l.extractOrderID(request)\n   if err != nil {\n      response.WriteHeader(http.StatusBadRequest)\n      return\n   }\n\n   // load order using the current user as a request-scoped dependency\n   // (with method injection)\n   order, err := l.loader.loadOrder(currentUser, orderID)\n   if err != nil {\n      response.WriteHeader(http.StatusInternalServerError)\n      return\n   }\n\n   // output order\n   encoder := json.NewEncoder(response)\n   err = encoder.Encode(order)\n   if err != nil {\n      response.WriteHeader(http.StatusInternalServerError)\n      return\n   }\n\n   response.WriteHeader(http.StatusOK)\n}\n```", "```go\n// AuthenticatedLoader will load orders for based on the supplied owner\ntype AuthenticatedLoader struct {\n   // This pool is expensive to create.  \n   // We will want to create it once and then reuse it.\n   db *sql.DB\n}\n\n// load the order from the database based on owner and order ID\nfunc (a *AuthenticatedLoader) loadByOwner(owner Owner, orderID int) (*Order, error) {\n   order, err := a.load(orderID)\n   if err != nil {\n      return nil, err\n   }\n\n   if order.OwnerID != owner.ID() {\n      // Return not found so we do not leak information to hackers\n      return nil, errNotFound\n   }\n\n   // happy path\n   return order, nil\n}\n```", "```go\n// Save will save the supplied person and return the ID of the newly \n// created person or an error.\n// Errors returned are caused by the underlying database or our \n// connection to it.\nfunc Save(in *Person) (int, error) {\n   db, err := getDB()\n   if err != nil {\n      logging.L.Error(\"failed to get DB connection. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   // perform DB insert\n   result, err := db.Exec(sqlInsert, in.FullName, in.Phone, in.Currency, in.Price)\n   if err != nil {\n      logging.L.Error(\"failed to save person into DB. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   // retrieve and return the ID of the person created\n   id, err := result.LastInsertId()\n   if err != nil {\n      logging.L.Error(\"failed to retrieve id of last saved person. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   return int(id), nil\n}\n```", "```go\n// Save will save the supplied person and return the ID of the newly \n// created person or an error.\n// Errors returned are caused by the underlying database or our \n// connection to it.\nfunc Save(ctx context.Context, in *Person) (int, error) {\n   db, err := getDB()\n   if err != nil {\n      logging.L.Error(\"failed to get DB connection. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   // perform DB insert\n   result, err := db.ExecContext(ctx, sqlInsert, in.FullName, in.Phone, in.Currency, in.Price)\n   if err != nil {\n      logging.L.Error(\"failed to save person into DB. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   // retrieve and return the ID of the person created\n   id, err := result.LastInsertId()\n   if err != nil {\n      logging.L.Error(\"failed to retrieve id of last saved person. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   return int(id), nil\n}\n```", "```go\n// save the registration\nfunc (r *Registerer) save(in *data.Person, price float64) (int, error) {\n   person := &data.Person{\n      FullName: in.FullName,\n      Phone:    in.Phone,\n      Currency: in.Currency,\n      Price:    price,\n   }\n   return saver(context.TODO(), person)\n}\n\n// this function as a variable allows us to Monkey Patch during testing\nvar saver = data.Save\n\n```", "```go\n// Converter will convert the base price to the currency supplied\ntype Converter struct{}\n\n// Do will perform the load\nfunc (c *Converter) Do(basePrice float64, currency string) (float64, error) {\n   // load rate from the external API\n   response, err := c.loadRateFromServer(currency)\n   if err != nil {\n      return defaultPrice, err\n   }\n\n   // extract rate from response\n   rate, err := c.extractRate(response, currency)\n   if err != nil {\n      return defaultPrice, err\n   }\n\n   // apply rate and round to 2 decimal places\n   return math.Floor((basePrice/rate)*100) / 100, nil\n}\n\n// load rate from the external API\nfunc (c *Converter) loadRateFromServer(currency string) (*http.Response, error) {\n   // build the request\n   url := fmt.Sprintf(urlFormat,\n      config.App.ExchangeRateBaseURL,\n      config.App.ExchangeRateAPIKey,\n      currency)\n\n   // perform request\n   response, err := http.Get(url)\n   if err != nil {\n      logging.L.Warn(\"[exchange] failed to load. err: %s\", err)\n      return nil, err\n   }\n\n   if response.StatusCode != http.StatusOK {\n      err = fmt.Errorf(\"request failed with code %d\", response.StatusCode)\n      logging.L.Warn(\"[exchange] %s\", err)\n      return nil, err\n   }\n\n   return response, nil\n}\n```", "```go\n// Converter will convert the base price to the currency supplied\ntype Converter struct{}\n\n// Do will perform the load\nfunc (c *Converter) Do(ctx context.Context, basePrice float64, currency string) (float64, error) {\n\n}\n\n// load rate from the external API\nfunc (c *Converter) loadRateFromServer(ctx context.Context, currency string) (*http.Response, error) {\n\n}\n```", "```go\n// load rate from the external API\nfunc (c *Converter) loadRateFromServer(ctx context.Context, currency string) (*http.Response, error) {\n   // build the request\n   url := fmt.Sprintf(urlFormat,\n      config.App.ExchangeRateBaseURL,\n      config.App.ExchangeRateAPIKey,\n      currency)\n\n   // perform request\n   req, err := http.NewRequest(\"GET\", url, nil)\n   if err != nil {\n      logging.L.Warn(\"[exchange] failed to create request. err: %s\", err)\n      return nil, err\n   }\n\n   // replace the default context with our custom one\n   req = req.WithContext(ctx)\n\n   // perform the HTTP request\n   response, err := http.DefaultClient.Do(req)\n   if err != nil {\n      logging.L.Warn(\"[exchange] failed to load. err: %s\", err)\n      return nil, err\n   }\n\n   if response.StatusCode != http.StatusOK {\n      err = fmt.Errorf(\"request failed with code %d\", response.StatusCode)\n      logging.L.Warn(\"[exchange] %s\", err)\n      return nil, err\n   }\n\n   return response, nil\n}\n```", "```go\n// get price in the requested currency\nfunc (r *Registerer) getPrice(ctx context.Context, currency string) (float64, error) {\n   converter := &exchange.Converter{}\n   price, err := converter.Do(ctx, config.App.BasePrice, currency)\n   if err != nil {\n      logging.L.Warn(\"failed to convert the price. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   return price, nil\n}\n\n// save the registration\nfunc (r *Registerer) save(ctx context.Context, in *data.Person, price float64) (int, error) {\n   person := &data.Person{\n      FullName: in.FullName,\n      Phone:    in.Phone,\n      Currency: in.Currency,\n      Price:    price,\n   }\n   return saver(ctx, person)\n}\n```", "```go\ntype Registerer struct {}\n\nfunc (r *Registerer) Do(ctx context.Context, in *data.Person) (int, error) {\n   // validate the request\n   err := r.validateInput(in)\n   if err != nil {\n      logging.L.Warn(\"input validation failed with err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   // get price in the requested currency\n   price, err := r.getPrice(ctx, in.Currency)\n   if err != nil {\n      return defaultPersonID, err\n   }\n\n   // save registration\n   id, err := r.save(ctx, in, price)\n   if err != nil {\n      // no need to log here as we expect the data layer to do so\n      return defaultPersonID, err\n   }\n\n   return id, nil\n}\n\n```", "```go\n// ServeHTTP implements http.Handler\nfunc (h *RegisterHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n   // extract payload from request\n   requestPayload, err := h.extractPayload(request)\n   if err != nil {\n      // output error\n      response.WriteHeader(http.StatusBadRequest)\n      return\n   }\n\n   // call the business logic using the request data and context\n   id, err := h.register(request.Context(), requestPayload)\n   if err != nil {\n      // not need to log here as we can expect other layers to do so\n      response.WriteHeader(http.StatusBadRequest)\n      return\n   }\n\n   // happy path\n   response.Header().Add(\"Location\", fmt.Sprintf(\"/person/%d/\", id))\n   response.WriteHeader(http.StatusCreated)\n}\n```", "```go\n\n// call the logic layer\nfunc (h *RegisterHandler) register(ctx context.Context, requestPayload *registerRequest) (int, error) {\n   person := &data.Person{\n      FullName: requestPayload.FullName,\n      Phone:    requestPayload.Phone,\n      Currency: requestPayload.Currency,\n   }\n\n   return h.registerer.Do(ctx, person)\n}\n```", "```go\n// Save will save the supplied person and return the ID of the newly \n// created person or an error.\n// Errors returned are caused by the underlying database or our \n// connection to it.\nfunc Save(ctx context.Context, in *Person) (int, error) {\n   db, err := getDB()\n   if err != nil {\n      logging.L.Error(\"failed to get DB connection. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   // set latency budget for the database call\n   subCtx, cancel := context.WithTimeout(ctx, 1*time.Second)\n   defer cancel()\n\n   // perform DB insert\n   result, err := db.ExecContext(subCtx, sqlInsert, in.FullName, in.Phone, in.Currency, in.Price)\n   if err != nil {\n      logging.L.Error(\"failed to save person into DB. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   // retrieve and return the ID of the person created\n   id, err := result.LastInsertId()\n   if err != nil {\n      logging.L.Error(\"failed to retrieve id of last saved person. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   return int(id), nil\n}\n```", "```go\n// load rate from the external API\nfunc (c *Converter) loadRateFromServer(ctx context.Context, currency string) (*http.Response, error) {\n   // build the request\n   url := fmt.Sprintf(urlFormat,\n      config.App.ExchangeRateBaseURL,\n      config.App.ExchangeRateAPIKey,\n      currency)\n\n   // perform request\n   req, err := http.NewRequest(\"GET\", url, nil)\n   if err != nil {\n      logging.L.Warn(\"[exchange] failed to create request. err: %s\", err)\n      return nil, err\n   }\n\n   // set latency budget for the upstream call\n   subCtx, cancel := context.WithTimeout(ctx, 1*time.Second)\n   defer cancel()\n\n   // replace the default context with our custom one\n   req = req.WithContext(subCtx)\n\n   // perform the HTTP request\n   response, err := http.DefaultClient.Do(req)\n   if err != nil {\n      logging.L.Warn(\"[exchange] failed to load. err: %s\", err)\n      return nil, err\n   }\n\n   if response.StatusCode != http.StatusOK {\n      err = fmt.Errorf(\"request failed with code %d\", response.StatusCode)\n      logging.L.Warn(\"[exchange] %s\", err)\n      return nil, err\n   }\n\n   return response, nil\n}\n```", "```go\n// ServeHTTP implements http.Handler\nfunc (h *RegisterHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n   // set latency budget for this API\n   subCtx, cancel := context.WithTimeout(request.Context(), 1500 *time.Millisecond)\n   defer cancel()\n\n   // extract payload from request\n   requestPayload, err := h.extractPayload(request)\n   if err != nil {\n      // output error\n      response.WriteHeader(http.StatusBadRequest)\n      return\n   }\n\n   // register person\n   id, err := h.register(subCtx, requestPayload)\n   if err != nil {\n      // not need to log here as we can expect other layers to do so\n      response.WriteHeader(http.StatusBadRequest)\n      return\n   }\n\n   // happy path\n   response.Header().Add(\"Location\", fmt.Sprintf(\"/person/%d/\", id))\n   response.WriteHeader(http.StatusCreated)\n}\n```", "```go\n// Load people from the database\ntype PersonLoader struct {\n}\n\nfunc (d *PersonLoader) Load(db *sql.DB, ID int) (*Person, error) {\n   return nil, errors.New(\"not implemented\")\n}\n\nfunc (d *PersonLoader) LoadAll(db *sql.DB) ([]*Person, error) {\n   return nil, errors.New(\"not implemented\")\n}\n```", "```go\ntype MyPersonLoader interface {\n   Load(ID int) (*Person, error)\n}\n```", "```go\ntype Generator struct{}\n\nfunc (g *Generator) Generate(storage Storage, template io.Reader, destination io.Writer, renderer Renderer, formatter Formatter, params ...interface{}) {\n\n}\n```", "```go\nfunc NewGeneratorV2(storage Storage, renderer Renderer, formatter Formatter) *GeneratorV2 {\n   return &GeneratorV2{\n      storage:   storage,\n      renderer:  renderer,\n      formatter: formatter,\n   }\n}\n\ntype GeneratorV2 struct {\n   storage   Storage\n   renderer  Renderer\n   formatter Formatter\n}\n\nfunc (g *GeneratorV2) Generate(template io.Reader, destination io.Writer, params ...interface{}) {\n\n}\n```"]