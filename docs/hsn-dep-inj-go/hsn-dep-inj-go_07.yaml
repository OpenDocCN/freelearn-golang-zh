- en: Dependency Injection with Method Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法注入的依赖注入
- en: In the previous chapter, we used a constructor to inject our dependencies. Doing
    so simplified our object and the life cycle of its dependencies. But what happens
    when our dependency is different for every request? This is where method injection
    comes in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用构造函数来注入我们的依赖项。这样做简化了我们的对象和其依赖项的生命周期。但是当我们的依赖项对于每个请求都不同的时候会发生什么？这就是方法注入发挥作用的地方。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Method injection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法注入
- en: Advantages of method injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法注入的优势
- en: Applying method injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用方法注入
- en: Disadvantages of method injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法注入的缺点
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It would be beneficial to be familiar with the code for our service, as introduced
    in [Chapter 4](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml), *Introduction to the
    ACME Registration Service*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉我们服务的代码可能会很有益，就像[第4章](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml)中介绍的那样，*ACME注册服务简介*。
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch07](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch07).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会发现阅读并运行本章的完整代码版本很有用，可在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch07](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch07)找到。
- en: Instructions on how to obtain the code and configure the sample service are
    available in the README file, found at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何获取代码和配置示例服务的说明，请参阅README文件，位于[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/)。
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch07/acme`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`ch07/acme`中找到我们的服务代码，并已应用了本章的更改。
- en: Method injection
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法注入
- en: 'Method injection is everywhere. You probably use it every day and you don''t
    even realize it. Have you ever written code like this?:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 方法注入随处可见。你可能每天都在使用它，甚至都没有意识到。你有没有写过这样的代码？：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'How about this?:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这样怎么样？：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is method injection—the passing in of the dependency as a parameter to
    the request.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是方法注入——将依赖项作为参数传递给请求。
- en: 'Let''s examine the previous examples in more detail. The function signature
    for `Fprint()` is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查之前的例子。`Fprint()`的函数签名如下：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the first parameter, `io.Writer`, is a dependency for this function.
    What makes this different from any other function call is the fact that the dependency
    provides an invocation context or data to the function call.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，第一个参数`io.Writer`是这个函数的一个依赖项。这与任何其他函数调用不同的是，依赖项为函数调用提供了调用上下文或数据。
- en: 'In the first example, the dependency was required, as it is being used as the
    output destination. However, dependencies used in method injection are not always
    required. Sometimes the dependency is optional, as we can see in the following
    example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，依赖是必需的，因为它被用作输出目的地。然而，在方法注入中使用的依赖项并不总是必需的。有时，依赖是可选的，就像我们在下面的例子中看到的那样：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is not the actual implementation from the standard library; I have simplified
    it to highlight the critical parts. In the preceding example, `io.Reader` is optional,
    and as such, is protected by a guard clause.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是标准库中的实际实现；我已经简化了它以突出关键部分。在前面的例子中，`io.Reader`是可选的，因此受到守卫条款的保护。
- en: When applying method injection, the dependencies are specific to the current
    invocation, and we will frequently find ourselves needing guard clauses. To help
    us decide whether or not to include guard clauses, let's dive a little deeper
    into our examples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用方法注入时，依赖项是特定于当前调用的，并且我们经常会发现自己需要守卫条款。为了帮助我们决定是否包含守卫条款，让我们深入研究一下我们的例子。
- en: In the `fmt.Fprint()` standard library implementation, there is no guard clause
    on `io.Writer`, meaning that supplying `nil` will cause the function to panic.
    This is because, without `io.Writer`, there is nowhere for the output to go.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fmt.Fprint()`标准库实现中，对`io.Writer`没有守卫条款，这意味着提供`nil`将导致函数发生panic。这是因为没有`io.Writer`，输出就无处可去。
- en: However, in the `http.NewRequest()` implementation, there is a guard clause
    because it is possible to make an HTTP request that does not contain a request
    body.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`http.NewRequest()`的实现中，有一个守卫条款，因为可能发出不包含请求体的HTTP请求。
- en: 'So, what does that mean for the functions that we write? In most cases, we
    should avoid writing code that can cause a crash with a panic. Let''s implement
    a function whose purpose is similar to `Fprint()` and see whether we can avoid
    panics. Here is the first rough implementation (with panic):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，对于我们编写的函数来说意味着什么呢？在大多数情况下，我们应该避免编写可能导致崩溃的代码。让我们实现一个类似于`Fprint()`的函数，并看看是否可以避免崩溃。这是第一个粗糙的实现（带有panic）：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What's the first thing that comes to mind to avoid the panic caused by a `nil`
    writer?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 避免`nil`写入器引起的panic的第一件事是什么？
- en: 'We could add a guard clause and return an error when `io.Writer` is not supplied,
    as shown in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个守卫条款，并在未提供`io.Writer`时返回错误，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While this still looks and feels like regular, valid Go code, we now have an
    error that only happens when we, the programmer, make a mistake. A much better
    option would be a *reasonable default,* as shown in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来和感觉起来仍然像是常规的有效的Go代码，但我们现在有一个只有在我们程序员犯错时才会发生的错误。一个更好的选择是*合理的默认值*，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This technique is called **defensive coding**. The central concept is that *it's
    better to continue working, even with a degraded experience, than to crash*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术称为**防御性编码**。其核心概念是*即使体验降级，也比崩溃更好*。
- en: Although these examples have all been functions, method injection can be used
    with structs in precisely the same way. There is one caveat—do not save the injected
    dependency as a member variable. We are using method injection because the dependency
    provides function invocation context or data. Saving the dependency as a member
    variable causes it to be shared between calls, effectively leaking this context
    between requests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些示例都是函数，但方法注入可以以完全相同的方式与结构体一起使用。有一个警告——不要将注入的依赖保存为成员变量。我们使用方法注入是因为依赖项提供函数调用上下文或数据。将依赖项保存为成员变量会导致它在调用之间共享，从而在请求之间泄漏此上下文。
- en: Advantages of method injection
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法注入的优势
- en: As we saw in the previous section, method injection is used extensively in the
    standard library. It is also extremely useful when you want to write your own
    shared libraries or frameworks. Its usefulness does not stop there.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中看到的，方法注入在标准库中被广泛使用。当您想要编写自己的共享库或框架时，它也非常有用。它的用途并不止于此。
- en: '**It is excellent with functions**—Everybody loves a good function, particularly
    those that follow the *Single responsibility principle* section, as discussed
    in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID Design Principles
    for Go*. They''re simple, stateless, and can be highly reusable. Adding method
    injection to a function will increase its reusability by converting the dependency
    into an abstraction. Consider the following HTTP handler:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**它在函数中表现出色**——每个人都喜欢一个好函数，特别是那些遵循*单一责任原则*部分的函数，如[第2章](53a15217-38a7-4622-9242-a57fe46335ec.xhtml)中所讨论的*Go的SOLID设计原则*。它们简单、无状态，并且可以被高度重用。将方法注入到函数中将通过将依赖项转换为抽象来增加其可重用性。考虑以下HTTP处理程序：'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Nice and simple. It builds a Go object and then writes the contents of the
    object to the response as JSON. It''s not hard to imagine that the next HTTP handler
    we write would also have the same final nine lines. So, let''s extract them to
    a function instead of copying and pasting:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 简单明了。它构建一个Go对象，然后将对象的内容作为JSON写入响应。很容易想象，我们接下来编写的下一个HTTP处理程序也将具有相同的最终九行。因此，让我们将它们提取到一个函数中，而不是复制和粘贴：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now let's examine the inputs to the function; how can we make these more generic
    or abstract?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查函数的输入；我们如何使这些更通用或抽象？
- en: While the JSON encoder only needs `io.Writer` and not the full `http.ResponseWriter`,
    we are also outputting the HTTP status codes. So, that is as good as we can do,
    short of defining our own interface. The second parameter is `*Animal`. In our
    function, what is the minimum we actually need?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JSON编码器只需要`io.Writer`而不是完整的`http.ResponseWriter`，但我们也输出HTTP状态码。因此，除了定义我们自己的接口之外，这是我们能做的最好的了。第二个参数是`*Animal`。在我们的函数中，我们实际上需要的最少是什么？
- en: We are only using `*Animal` as an input to the JSON encoder, and its function
    signature is
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用`*Animal`作为JSON编码器的输入，其函数签名为
- en: '`Encode(v interface{}) error`. So, we can reduce our param to match, giving
    us the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Encode(v interface{}) error`。因此，我们可以减少我们的参数以匹配，得到以下结果：'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Generally, I avoid using `interface{}` as its use leads to the code becoming
    littered with type casts and statements that make it harder to read. In this case,
    however, it's the best (and only) choice.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我避免使用`interface{}`，因为它的使用会导致代码中充斥着类型转换和使代码更难阅读的语句。然而，在这种情况下，这是最好（也是唯一）的选择。
- en: Similar to other *interface segregation principle-*based examples in other chapters,
    it's often best to define the minimal possible interface alongside the function
    or method; alternatively if possible, use the appropriate minimalistic interface
    from the standard library (such as `io.Writer`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他章节中基于*接口隔离原则*的示例类似，最好是在函数或方法旁边定义最小可能的接口；或者如果可能的话，使用标准库中适当的最小接口（如`io.Writer`）。
- en: '**Dependencies act as data**—Because method injection requires the user to
    pass in the dependency with each call, this has some interesting side-effect on
    the relationship between the dependency and the usage. The dependency becomes
    part of the data in the request and can drastically change the results of the
    call. Consider the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖项充当数据**——因为方法注入要求用户在每次调用时传入依赖项，这对依赖项和使用之间的关系产生了一些有趣的副作用。依赖项成为请求中的数据的一部分，并且可以极大地改变调用的结果。考虑以下代码：'
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A very innocuous and straightforward function, but see what happens when we
    supply a few different dependencies:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常无害和直接的函数，但是看看当我们提供一些不同的依赖项时会发生什么：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Dependencies are request-scoped**—These dependencies, by definition, are
    being created and destroyed all of the time. Therefore, they are not good candidates
    for constructor injection or even monkey patching. We could, of course, create
    the object that uses the dependency every request too, but that would neither
    be performant nor always necessary.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖项是请求范围的**——这些依赖项根据定义一直在被创建和销毁。因此，它们不适合构造函数注入甚至猴子补丁。当然，我们可以在每个请求中创建使用依赖项的对象，但这既不高效也不总是必要的。'
- en: 'Let''s look at an HTTP request handler:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个HTTP请求处理程序：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As an HTTP handler, the `ServeHTTP()` method will be called once for every incoming
    HTTP request. `LoadOrderHandler` depends on `OrderLoader`, in which we will inject
    our implementation `AuthenticatedLoader` using constructor injection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为HTTP处理程序，`ServeHTTP()`方法将针对每个传入的HTTP请求调用一次。`LoadOrderHandler`依赖于`OrderLoader`，我们将使用构造函数注入我们的实现`AuthenticatedLoader`。
- en: 'The implementation of `AuthenticatedLoader` can be seen in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthenticatedLoader`的实现可以在以下代码中看到：'
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, `AuthenticatedLoader` depends on a database connection pool;
    this is expensive to create, so we do not want to recreate it with every request.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`AuthenticatedLoader`依赖于数据库连接池；这很昂贵，所以我们不希望在每个请求中重新创建它。
- en: The `loadByOwner()` function accepts `Owner` using method injection. We are
    using method injection here as we expect `Owner` to vary with each request.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadByOwner()`函数接受使用方法注入的`Owner`。我们在这里使用方法注入，因为我们期望`Owner`会随着每个请求而变化。'
- en: This example uses constructor injection for long-lived dependencies and method
    injection for request-scoped ones. In this way, we are not unnecessarily creating
    and destroying objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用构造函数注入长期依赖项和方法注入请求范围的依赖项。这样，我们就不会不必要地创建和销毁对象。
- en: '**Assists with immutability, statelessness, and concurrency**—You might accuse
    me of overselling a little bit here, but after writing some very concurrent Go
    systems, I have found that objects that are stateless and/or immutable are less
    prone to concurrency-related problems. Method injection does not grant these features
    by itself but does make achieving them easier. By passing around the dependency,
    the ownership and scope of use are much clearer. Additionally, we do not need
    to concern ourselves with concurrent access to the dependency, as we would if
    it was a member variable.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**协助不可变性、无状态性和并发性**—你可能会指责我有点夸大其词，但在编写一些非常并发的Go系统之后，我发现无状态和/或不可变的对象不太容易出现与并发相关的问题。方法注入本身并不赋予这些特性，但确实使其更容易实现。通过传递依赖项，所有权和使用范围更加清晰。此外，我们不需要担心对依赖项的并发访问，就像它是成员变量一样。'
- en: Applying method injection
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用方法注入
- en: 'In this section, we are going to improve our ACME registration service by applying
    method injection with perhaps my favorite package in the entire Go standard library,
    the context package. Central to this package is the `Context` interface, which
    describes itself as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过应用方法注入来改进我们的ACME注册服务，也许会用到我最喜欢的Go标准库中的包，上下文包。该包的核心是`Context`接口，它自述如下：
- en: '**A context carries a deadline, cancellation signal, and request-scoped values
    across API boundaries. Its methods are safe for simultaneous use by multiple goroutines**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文在API边界跨越期限、取消信号和请求范围值。它的方法可以同时被多个goroutine安全使用**'
- en: So, why do I love it so much? By applying method injection, with context as
    the dependency, I am able to build my processing logic in such a way that it can
    all be automatically canceled and cleaned up.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我这么喜欢它呢？通过应用方法注入，以上下文作为依赖项，我能够构建我的处理逻辑，以便可以自动取消和清理所有内容。
- en: A quick recap
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速回顾
- en: 'Before we dive into the changes, let''s take a more in-depth look at the registration
    function provided by our sample service, and its interactions with external resources.
    The following diagram outlines the steps that are performed during a single call
    to the register endpoint:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入改变之前，让我们更深入地看一下我们示例服务提供的注册函数及其与外部资源的交互。以下图表概述了在调用注册端点时执行的步骤：
- en: '![](img/5f9cb019-ed60-4dc7-9616-0e5080a68a76.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f9cb019-ed60-4dc7-9616-0e5080a68a76.png)'
- en: 'These interactions are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些交互如下：
- en: User calls the register endpoint.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户调用注册端点。
- en: Our service calls the **Exchange Rate Service**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的服务调用**汇率服务**。
- en: Our service saves the registration into the database.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的服务将注册信息保存到数据库中。
- en: 'Now let''s consider how these interactions could go wrong. Ask yourself the
    following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑这些交互可能出现的问题。问问自己以下问题：
- en: What can fail or become slow?
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会失败或变慢的是什么？
- en: How do I want to react or recover from that failure?
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我希望如何对失败做出反应或恢复？
- en: How are my users going to react to my failure?
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的用户会如何对我的失败做出反应？
- en: 'Considering the interactions in our function, two problems immediately come
    to mind:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们函数中的交互，立即想到两个问题：
- en: '**Calls to the database can fail or become slow:** How can we recover from
    this? We could perform retries, but we have to be very careful about this. Databases
    tend to be more of a finite resource than a web service. As such, retrying requests
    could, in fact, degrade the performance of the database even further.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对数据库的调用可能会失败或变慢：**我们如何从中恢复？我们可以进行重试，但这一点我们必须非常小心。数据库往往更像是有限资源而不是web服务。因此，重试请求实际上可能会进一步降低数据库的性能。'
- en: '**Calls to the exchange rate service can fail or become slow:** How can we
    recover from this? We could automatically retry failed requests. This will reduce
    the occasions where we cannot load an exchange rate. Assuming the business approves,
    we could set up some default rates to use, instead of entirely failing the registration.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对汇率服务的调用可能会失败或变慢：**我们如何从中恢复？我们可以自动重试失败的请求。这将减少我们无法加载汇率的情况。假设业务批准，我们可以设置一些默认汇率来使用，而不是完全失败注册。'
- en: The best change we could make to improve the stability of the system might surprise
    you.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做出的最好的改变来提高系统的稳定性可能会让你感到意外。
- en: We could simply not make the request at all. If we were able to change the registration
    process so that the exchange rate was not needed in this part of the processing,
    then it could never cause us problems.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根本不发出请求。如果我们能够改变注册流程，使得在处理的这一部分不需要汇率，那么它就永远不会给我们带来问题。
- en: Let's assume that none of the aforementioned solutions are available to us in
    our (contrived) example. The only option we are left with is failure. What happens
    if loading the exchange rate takes so long that the user gives up and cancels
    their request? They are likely to assume the registration failed and hopefully
    try again.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们（刻意制造的）例子中，前面提到的解决方案都不可用。我们唯一剩下的选择就是失败。如果加载汇率花费的时间太长，用户放弃并取消他们的请求会发生什么？他们很可能会认为注册失败，希望再次尝试。
- en: With this in mind, our best course of action is to give up waiting for the exchange
    rate and not to process the registration any further. This is a process known
    as **stopping short**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们最好的做法是放弃等待汇率，不再进一步处理注册。这个过程被称为**提前停止**。
- en: Stopping short
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提前停止
- en: Stopping short is the process of discontinuing the processing request (before
    it would otherwise finish) based on an external signal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 提前停止是基于外部信号中止处理请求的过程（在本应完成之前）。
- en: 'In our case, that external signal will be the cancelation of the user''s HTTP
    request. In Go, the `http.Request` object includes a `Context()` method; the following
    is an extract of the documentation for that method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，外部信号将是用户HTTP请求的取消。在Go中，`http.Request`对象包括一个`Context()`方法；以下是该方法文档的摘录：
- en: '**For incoming server requests, the context is canceled when the client''s
    connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP
    method returns**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传入的服务器请求，当客户端的连接关闭时，请求被取消（使用HTTP/2），或者当ServeHTTP方法返回时，上下文被取消。
- en: What does it mean when the request is canceled? Most importantly for us, it
    means that no one is waiting for the response.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求被取消时意味着什么？对我们来说最重要的是，这意味着没有人在等待响应。
- en: If the user has given up listening to the response, it is likely they will consider
    the request failed and will hopefully try again.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户放弃等待响应，他们很可能会认为请求失败，并希望再次尝试。
- en: How we should react to this situation depends on the feature we are implementing,
    but in many cases, mainly features related to loading or fetching data, the most
    effective response is to stop processing the request.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何对这种情况做出反应取决于我们正在实现的功能，但在许多情况下，主要是与加载或获取数据相关的功能，最有效的响应是停止处理请求。
- en: For the register endpoint of our service, this is the option we have chosen.
    We are going to pass `Context` from the request through all of the layers of our
    code using method injection. If the user cancels their request, we will immediately
    stop processing the request.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们服务的注册端点，这是我们选择的选项。我们将通过方法注入从请求中传递`Context`到我们代码的所有层。如果用户取消他们的请求，我们将立即停止处理请求。
- en: Now that we are clear on what we are trying to achieve, let's apply method injection
    to the layers of our service *from the inside out*. We need to start from the
    inside to ensure that our code and tests stay running during the refactor.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们清楚我们要达到什么目标，让我们从内部开始将方法注入到我们服务的层中。我们需要从内部开始，以确保我们的代码和测试在重构过程中保持运行。
- en: Applying method injection to the data package
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将方法注入应用到数据包
- en: A quick reminder, the `data` package is a **data access layer** (**DAL**) that
    provides simplified and abstracted access to the underlying MySQL database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 快速提醒，`data`包是一个提供对底层MySQL数据库的简化和抽象访问的**数据访问层**（**DAL**）。
- en: 'The following is the current code for the `Save()` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Save()`函数的当前代码：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By applying method injection, we get the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用方法注入，我们得到了以下结果：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, we swapped the `Exec()` call for `ExecContext()` but have otherwise
    changed nothing. Because we have changed the function signature, we are also going
    to need to update our usage of this package to the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将`Exec()`调用替换为`ExecContext()`，但其他方面没有改变。因为我们已经改变了函数签名，我们还需要更新对该包的使用如下：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will notice our use of `context.TODO()`; it is used here as a placeholder
    until we can refactor the `save()` method to use method injection as well. After
    updating the tests we broke with the refactor, we can proceed with the next package.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们使用了`context.TODO()`；它在这里被用作占位符，直到我们可以将`save()`方法重构为使用方法注入为止。在更新了我们在重构过程中破坏的测试之后，我们可以继续进行下一个包。
- en: Applying method injection to the exchange package
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将方法注入应用到exchange包
- en: The exchange package is responsible for loading the current currency exchange
    rate (for example, Malaysian Ringgit to Australian Dollars) from an upstream service.
    Similar to the data package, it provides simplified and abstracted access to this
    data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`exchange`包负责从上游服务加载当前的货币兑换率（例如，马来西亚林吉特兑澳大利亚元），与数据包类似，它提供了对这些数据的简化和抽象访问。'
- en: 'The following are the relevant parts of the current code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当前代码的相关部分：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first change is the same as the previous ones. Simple method injection
    on the `Do()` and `loadRateFromServer()` methods, changing these method signatures
    to the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变化与之前的相同。在`Do()`和`loadRateFromServer()`方法上进行简单的方法注入，将这些方法签名更改为以下内容：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Unfortunately, there is no `http.GetWithContext()` method, so we will need
    to build the request and set the context a slightly more verbose way, giving us
    the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有`http.GetWithContext()`方法，所以我们需要以稍微冗长的方式构建请求并设置上下文，得到以下结果：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we did previously, we will also need to use `context.TODO()` in the model
    layer that calls the `exchange` package until we have a chance to change them
    to method injection. With the two *bottom* software layers (the `data` and `exchange`
    packages) complete, we can move on to the next software layer, business layer,
    or model layer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们还需要在调用“exchange”包的模型层中使用`context.TODO()`，直到我们有机会将它们改为方法注入。完成了两个*底层*软件层（`data`和`exchange`包）后，我们可以继续进行下一个软件层、业务层或模型层。
- en: Applying method injection to the model layer (the Get, List, and Register packages)
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将方法注入应用到模型层（Get、List和Register包）
- en: 'Previously, in places where we called the `data` or `exchange` packages, we
    used `context.TODO()` to ensure the code could still compile and that our tests
    continued to do their job. It''s now time to apply method injection to the model
    layer and replace the `context.TODO()` calls with injected context. First, we
    change the `getPrice()` and `save()` methods to accept a context:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，在我们调用`data`或`exchange`包的地方，我们使用`context.TODO()`来确保代码仍然可以编译，并且我们的测试继续发挥作用。现在是时候将方法注入应用到模型层，并用注入的上下文替换`context.TODO()`的调用。首先，我们将`getPrice()`和`save()`方法更改为接受上下文：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then we can update the package''s public API function, `Do()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以更新包的公共API函数`Do()`：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have *rolled up* the `Context` objects passed into the data and `exchange`
    package into a single, injected dependency; a dependency that we can extract from
    the `http.Request` in the REST package.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将传递给数据和`exchange`包的`Context`对象合并为一个单一的注入依赖项；这是一个我们可以从REST包中的`http.Request`中提取的依赖项。
- en: Applying the method injection of context to the REST package
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将上下文的方法注入到REST包中
- en: 'Finally, now for the key changes. First, we extract the context from the request:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在是关键的更改。首先，我们从请求中提取上下文：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then we pass it down to the model:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将其传递给模型：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After what feels like a lot of *too simple* changes, we are done applying method
    injection to all of the layers in our register endpoint.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 经过了许多*太简单*的更改之后，我们已经将方法注入应用到了注册端点的所有层。
- en: Let's examine what we have achieved. Our processing is now tied to the execution
    context of the request. Therefore, when the request is canceled, we will immediately
    stop processing the request.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们取得了什么成就。我们的处理现在与请求的执行上下文相关联。因此，当请求被取消时，我们将立即停止处理该请求。
- en: But why is this important? There are two reasons; the first and most important
    is user expectations. If the user canceled the request, either manually or via
    a timeout, they will see an error. They will conclude that the processing has
    failed. If we continue to process the request and manage to complete it, this
    will go against their expectations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但这为什么重要呢？有两个原因；第一个和最重要的是用户期望。如果用户取消了请求，无论是手动还是通过超时，他们将看到一个错误。他们会得出结论，处理已失败。如果我们继续处理请求并设法完成它，这将违背他们的期望。
- en: The second reason is more pragmatic; when we stop processing the request, we
    reduce the load on our server and our upstream. This freed-up capacity can then
    be used to handle other requests.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因更加务实；当我们停止处理请求时，我们减少了服务器和上游的负载。这种释放的容量随后可以用于处理其他请求。
- en: When it comes to meeting user expectations, there is actually more we can do
    with the context package. We can add latency budgets.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及满足用户期望时，上下文包实际上可以做更多的事情。我们可以添加延迟预算。
- en: Latency budgets
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟预算
- en: As with a lot of IT terms, latency budgets can be used in a multitude of ways.
    In this case, we refer to the maximum time allowed for a call.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多IT术语一样，延迟预算可以以多种方式使用。在这种情况下，我们指的是调用允许的最长时间。
- en: 'Translating that into our current refactoring, it refers to two things:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些转化为我们当前的重构，它涉及两件事：
- en: The maximum time allowed for the upstream (database or exchange rate service)
    call to complete
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许上游（数据库或汇率服务）调用完成的最长时间
- en: The maximum time allowed for our register API to complete
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的注册API允许的最长完成时间
- en: 'You can see how these two things are related. Let''s look at how our API response
    time is made up:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这两件事情是如何相关的。让我们看看我们的API响应时间是如何组成的：
- en: '*API response time = (exchange rate service call + database call + our code)*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*API响应时间 =（汇率服务调用+数据库调用+我们的代码）*'
- en: Assuming the performance of *our code* is mainly consistent, then our service
    quality is directly dependent on the speed of the upstream calls. This is not
    a very comfortable position to be in, so what can we do?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*我们的代码*的性能主要是一致的，那么我们的服务质量直接取决于上游调用的速度。这不是一个非常舒适的位置，那么我们能做什么呢？
- en: In the previous section, we examined these failures and some options, and decided
    that for the moment, we want to fail the request. What is the best failure we
    can offer our user? One that is both timely and informative.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们检查了这些失败和一些选项，并决定暂时要失败请求。我们能为用户提供的最好的失败是什么？一个及时而有信息的失败。
- en: 'To achieve this, we are going to use another feature of the `context.Context`
    interface:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用`context.Context`接口的另一个特性：
- en: '`WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)`'
- en: As you might have guessed, this method sets a timeout on the context. This timeout
    will act as a timer, causing the context to cancel should the latency budget (timeout)
    be exceeded. Then, because we have our stop short already in place, our request
    will cease processing and exit.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，这种方法在上下文中设置了一个超时。这个超时将作为一个计时器，如果超过了延迟预算（超时），上下文将被取消。然后，因为我们已经设置了停止短路，我们的请求将停止处理并退出。
- en: First, let's apply this to our database call. In the next example, we will create
    a *sub-context* from the original context and give it a timeout. As contexts are
    hierarchical, the timeout we are applying will only apply to the sub-context and
    any contexts we create from it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将其应用到我们的数据库调用中。在下一个示例中，我们将从原始上下文中创建一个*子上下文*并为其设置一个超时。由于上下文是分层的，我们应用的超时只适用于子上下文和我们从中创建的任何上下文。
- en: 'In our case, we have decided that the latency budget for calls to the database
    will be 1 second, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们已经决定对数据库的调用的延迟预算为1秒，如下所示：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s apply a latency budget to the exchange service call. To do this,
    we are going to use another feature of the `http.Request`, `Context()` method,
    documented as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将延迟预算应用到交换服务调用中。为此，我们将使用`http.Request`的另一个特性，`Context()`方法，文档如下：
- en: '**For outgoing client requests, the context controls cancellation**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于出站客户端请求，上下文控制取消**'
- en: 'To set the latency budget on our outgoing HTTP request, we will create another
    sub-context, as we did for the database, and then set that context into the request
    with the `WithRequest()` method. After these changes, our code looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的出站HTTP请求上设置延迟预算，我们将创建另一个子上下文，就像我们为数据库做的那样，然后使用`WithRequest()`方法将该上下文设置到请求中。在这些更改之后，我们的代码看起来像这样：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With these changes in place, let''s revisit our API response time formula and
    consider the worst-case scenario – both calls take a fraction under 1 second but
    successfully complete, giving us this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些更改，让我们重新审视我们的API响应时间公式，并考虑最坏的情况-两个调用都花了不到1秒的时间但成功完成，给我们这个：
- en: '*API response time = (~1 second + ~ 1 second + our code)*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*API响应时间 =（~1秒+ ~1秒+我们的代码）*'
- en: This gives us a maximum execution time of about 2 seconds. But what if we decide
    that the maximum response time we will allow ourselves is 1.5 seconds?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个大约2秒的最大执行时间。但是如果我们决定允许自己的最大响应时间是1.5秒呢？
- en: 'Thankfully, we can easily do this too. Earlier, I mentioned that contexts are
    hierarchical. All of our contexts are currently derived from the context in the
    request. While we cannot change the context that is part of the request, we can
    derive a context from it with our API''s latency budget and then pass that down
    to the data and exchange packages. The updated parts of the handler look like
    the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们也可以轻松做到这一点。早些时候，我提到过上下文是分层的。我们所有的上下文当前都是从请求中的上下文派生出来的。虽然我们无法更改作为请求一部分的上下文，但我们可以从中派生出一个具有我们API的延迟预算的上下文，然后将其传递给数据和交换包。处理程序的更新部分如下所示：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After a few simple changes, we have far more control over how our API performs,
    thanks to the context package and a little bit of method injection.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些简单的更改，我们可以更好地控制我们的API的性能，这要归功于上下文包和一点点方法注入。
- en: Disadvantages of method injection
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法注入的缺点
- en: I do not have a long list of disadvantages for you; in fact, I have only two.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有为您列出很长的缺点；事实上，我只有两个。
- en: '**Adding parameters detracts from the UX**—This is a rather big one. Adding
    parameters to a method or function detracts from the UX of the function. As we
    saw in [Chapter 3](26893ac5-a588-4954-943e-0eaf690feb34.xhtml), *Coding for User
    Experience*, a bad UX for a function can negatively impact its usability.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加参数会降低用户体验** - 这是一个相当大的问题。向方法或函数添加参数会降低函数的用户体验。正如我们在[第3章](26893ac5-a588-4954-943e-0eaf690feb34.xhtml)中所看到的，*为用户体验编码*，函数的糟糕用户体验会对其可用性产生负面影响。'
- en: 'Consider the following struct:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下结构：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code works; it gets the job done. But it's annoying to have to pass in
    the database every time. Beyond that, there is no guarantee that the code that
    calls `Load()` also maintains the database pool.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有效，完成了任务。但是每次都必须传入数据库很烦人。除此之外，没有保证调用`Load()`的代码也会维护数据库池。
- en: Another aspect to consider is encapsulation. Does the user of these functions
    need to know that they depend on a database? Put yourself in the place of the
    user of the `Load()` function for a moment. What do you want to do and what do
    you know?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要考虑的方面是封装。这些函数的用户是否需要知道它们依赖于数据库？请试着站在一会儿`Load()`函数的用户的角度。你想做什么，你知道什么？
- en: 'You want to load a person, and you know the ID of that person. You do not know
    (or care) where the data comes from. If you were designing the function for yourself,
    what would it look like:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你想加载一个人，你知道那个人的ID。你不知道（或者不关心）数据来自哪里。如果你为自己设计这个函数，它会是什么样子：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It's succinct and easy to use, and none of the implementation details are leaking.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它简洁易用，没有泄漏任何实现细节。
- en: 'Let''s look at another example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this case, we have so many parameters, it''s hard to separate the data from
    the non-request-scoped dependencies. If we extract those dependencies, we get
    the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有很多参数，很难将数据与非请求范围的依赖项分开。如果我们提取这些依赖项，我们会得到以下结果：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: While the UX is better in the second example, it's still rather cumbersome.
    The code could benefit from a different approach, such as composition.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第二个例子中的用户体验更好，但仍然相当繁琐。代码可以从不同的角度受益，比如组合。
- en: '**Limited applicability**—As we have seen in this chapter, method injection
    is excellent with functions and request-scoped dependencies. While this use case
    does frequently crop up, method injection does not apply well to non-request-scoped
    dependencies, which is the bulk of use cases where we want to use **dependency
    injection** (**DI**).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**适用性有限** - 正如我们在本章中所看到的，方法注入在函数和请求范围的依赖项中表现出色。虽然这种用例确实经常出现，但方法注入并不适用于非请求范围的依赖项，而这是我们想要使用**依赖注入**（**DI**）的大部分用例。'
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have examined DI with method injection, perhaps the most
    ubiquitous of all forms of DI.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了方法注入的DI，这可能是所有形式的DI中最普遍的。
- en: When it comes to extracting dependencies from existing code, for the purposes
    of testing, it might be the method that first comes to mind. Please be careful
    with this, we do not want to introduce *test-induced damage.*
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及从现有代码中提取依赖项以进行测试时，可能会首先想到的就是方法。请小心，我们不想引入*测试引起的损害*。
- en: Adding parameters to an exported API function for the sole purpose of testing
    undoubtedly damages UX code. Thankfully, there are some tricks available to us
    to avoid damaging our API. We can define member functions that only exist in test
    code. We can also use **Just-In-Time** (**JIT**) dependency injection, which we
    will examine in [Chapter 9](60fb3899-8e56-4a9f-95bf-7e3eb70fea4e.xhtml), *Just-in-Time
    Dependency Injection*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试的唯一目的向导出的API函数添加参数无疑会损害UX代码。幸运的是，我们有一些技巧可用来避免损害我们的API。我们可以定义仅存在于测试代码中的成员函数。我们还可以使用**即时**（**JIT**）依赖注入，我们将在[第9章](60fb3899-8e56-4a9f-95bf-7e3eb70fea4e.xhtml)中进行探讨，*即时依赖注入*。
- en: In this chapter, we have looked at the fantastic and powerful `context` package.
    You might be surprised to learn that there is even more value we can extract from
    this package. I encourage you to check out the Go blog ([https://blog.golang.org/context](https://blog.golang.org/context))
    and investigate this package for yourself.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经研究了出色而强大的`context`包。您可能会惊讶地发现，我们可以从这个包中提取更多的价值。我鼓励您查看Go博客（[https://blog.golang.org/context](https://blog.golang.org/context)）并自行调查这个包。
- en: In the next chapter, we are going to apply a specific form of both constructor
    injection and method injection called **DI by config**. With it, we will finally
    untangle the `config` package from being depended on by just about every other
    package in our service, making our packages far more decoupled and increasing
    their reusability potential considerably.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将应用一种特定形式的构造函数注入和方法注入，称为**DI by config**。通过它，我们最终将`config`包从我们服务中几乎每个其他包都依赖的状态中解脱出来，使我们的包更加解耦，并显著提高它们的可重用性。
- en: Questions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the ideal use cases for method injection?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法注入的理想用例是什么？
- en: Why is it important not to save dependencies injected with method injection?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不保存使用方法注入注入的依赖关系很重要？
- en: What happens if we use method injection too much?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们过度使用方法注入会发生什么？
- en: Why is *stopping short* useful to the system as a whole?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么“停止短”对整个系统有用？
- en: How can latency budgets improve the UX for our users?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 延迟预算如何改善用户体验？
