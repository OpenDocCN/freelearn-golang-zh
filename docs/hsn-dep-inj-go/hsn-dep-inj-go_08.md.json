["```go\n// NewLongConstructor is the constructor for MyStruct\nfunc NewLongConstructor(logger Logger, stats Instrumentation, limiter RateLimiter, cache Cache, timeout time.Duration, workers int) *MyStruct {\n return &MyStruct{\n // code removed\n }\n}\n```", "```go\n// NewByConfigConstructor is the constructor for MyStruct\nfunc NewByConfigConstructor(cfg MyConfig, limiter RateLimiter, cache Cache) *MyStruct {\n   return &MyStruct{\n      // code removed\n   }\n}\n```", "```go\nmyFetcher := NewFetcher(cfg, cfg.URL(), cfg.Timeout())\n```", "```go\nfunc TestInjectedConfig(t *testing.T) {\n   // load test config\n   cfg, err := config.LoadFromFile(testConfigLocation)\n   require.NoError(t, err)\n\n   // build and use object\n   obj := NewMyObject(cfg)\n   result, resultErr := obj.Do()\n\n   // validate\n   assert.NotNil(t, result)\n   assert.NoError(t, resultErr)\n}\n```", "```go\nfunc TestConfigInjection(t *testing.T) {\n   // build test config\n   cfg := &TestConfig{}\n\n   // build and use object\n   obj := NewMyObject(cfg)\n   result, resultErr := obj.Do()\n\n   // validate\n   assert.NotNil(t, result)\n   assert.NoError(t, resultErr)\n}\n\n// Simple implementation of the Config interface\ntype TestConfig struct {\n   logger *logging.Logger\n   stats  *stats.Collector\n}\n\nfunc (t *TestConfig) Logger() *logging.Logger {\n   return t.logger\n}\n\nfunc (t *TestConfig) Stats() *stats.Collector {\n   return t.stats\n}\n```", "```go\nfunc NewLongConstructor(logger Logger, stats Instrumentation, limiter RateLimiter, cache Cache, url string, credentials string) *MyStruct {\n   return &MyStruct{\n      // code removed\n   }\n}\n```", "```go\nfunc NewByConfigConstructor(cfg MyConfig, url string, credentials string) *MyStruct {\n   return &MyStruct{\n      // code removed\n   }\n}\n```", "```go\n// Registerer validates the supplied person, calculates the price in \n// the requested currency and saves the result.\n// It will return an error when:\n// -the person object does not include all the fields\n// -the currency is invalid\n// -the exchange rate cannot be loaded\n// -the data layer throws an error.\ntype Registerer struct {\n}\n\n// get price in the requested currency\nfunc (r *Registerer) getPrice(ctx context.Context, currency string) (float64, error) {\n  converter := &exchange.Converter{}\n  price, err := converter.Do(ctx, config.App.BasePrice, currency)\n  if err != nil {\n    logging.L.Warn(\"failed to convert the price. err: %s\", err)\n    return defaultPersonID, err\n  }\n\n  return price, nil\n}\n```", "```go\n// Config is the configuration for the Registerer\ntype Config interface {\n   Logger() *logging.LoggerStdOut\n   BasePrice() float64\n}\n```", "```go\n// Config is the configuration for the Registerer\ntype Config interface {\n  Logger() logging.Logger\n  RegistrationBasePrice() float64\n}\n```", "```go\n// NewRegisterer creates and initializes a Registerer\nfunc NewRegisterer(cfg Config) *Registerer {\n   return &Registerer{\n      cfg: cfg,\n   }\n}\n\n// Config is the configuration for the Registerer\ntype Config interface {\n   Logger() logging.Logger\n   RegistrationBasePrice() float64\n}\n\n// Registerer validates the supplied person, calculates the price in \n// the requested currency and saves the result.\n// It will return an error when:\n// -the person object does not include all the fields\n// -the currency is invalid\n// -the exchange rate cannot be loaded\n// -the data layer throws an error.\ntype Registerer struct {\n   cfg Config\n}\n\n// get price in the requested currency\nfunc (r *Registerer) getPrice(ctx context.Context, currency string) (float64, error) {\n   converter := &exchange.Converter{}\n   price, err := converter.Do(ctx, r.cfg.RegistrationBasePrice(), currency)\n   if err != nil {\n      r.logger().Warn(\"failed to convert the price. err: %s\", err)\n      return defaultPersonID, err\n   }\n\n   return price, nil\n}\n\nfunc (r *Registerer) logger() logging.Logger {\n   return r.cfg.Logger()\n}\n```", "```go\n// Stub implementation of Config\ntype testConfig struct{}\n\n// Logger implement Config\nfunc (t *testConfig) Logger() logging.Logger {\n   return &logging.LoggerStdOut{}\n}\n\n// RegistrationBasePrice implement Config\nfunc (t *testConfig) RegistrationBasePrice() float64 {\n   return 12.34\n}\n```", "```go\nregisterer := &Registerer{\n   cfg: &testConfig{},\n}\n```", "```go\nregisterModel := &register.Registerer{}\n```", "```go\nregisterModel := register.NewRegisterer(config.App)\n```", "```go\n// Logger returns a reference to the singleton logger\nfunc (c *Config) Logger() logging.Logger {\n   if c.logger == nil {\n      c.logger = &logging.LoggerStdOut{}\n   }\n\n   return c.logger\n}\n\n// RegistrationBasePrice returns the base price for registrations\nfunc (c *Config) RegistrationBasePrice() float64 {\n   return c.BasePrice\n}\n```", "```go\n// Load will attempt to load and return a person.\n// It will return ErrNotFound when the requested person does not exist.\n// Any other errors returned are caused by the underlying database \n// or our connection to it.\nfunc Load(ctx context.Context, ID int) (*Person, error) {\n   db, err := getDB()\n   if err != nil {\n      logging.L.Error(\"failed to get DB connection. err: %s\", err)\n      return nil, err\n   }\n\n   // set latency budget for the database call\n   subCtx, cancel := context.WithTimeout(ctx, 1*time.Second)\n   defer cancel()\n\n   // perform DB select\n   row := db.QueryRowContext(subCtx, sqlLoadByID, ID)\n\n   // retrieve columns and populate the person object\n   out, err := populatePerson(row.Scan)\n   if err != nil {\n      if err == sql.ErrNoRows {\n         logging.L.Warn(\"failed to load requested person '%d'. err: %s\", ID, err)\n         return nil, ErrNotFound\n      }\n\n      logging.L.Error(\"failed to convert query result. err: %s\", err)\n      return nil, err\n   }\n   return out, nil\n}\n```", "```go\nvar getDB = func() (*sql.DB, error) {\n   if db == nil {\n      if config.App == nil {\n         return nil, errors.New(\"config is not initialized\")\n      }\n\n      var err error\n      db, err = sql.Open(\"mysql\", config.App.DSN)\n      if err != nil {\n         // if the DB cannot be accessed we are dead\n         panic(err.Error())\n      }\n   }\n\n   return db, nil\n}\n```", "```go\n// Config is the configuration for the data package\ntype Config interface {\n   // Logger returns a reference to the logger\n   Logger() logging.Logger\n\n   // DataDSN returns the data source name\n   DataDSN() string\n}\n```", "```go\n// Load will attempt to load and return a person.\n// It will return ErrNotFound when the requested person does not exist.\n// Any other errors returned are caused by the underlying database \n// or our connection to it.\nfunc Load(ctx context.Context, cfg Config, ID int) (*Person, error) {\n   db, err := getDB(cfg)\n   if err != nil {\n      cfg.Logger().Error(\"failed to get DB connection. err: %s\", err)\n      return nil, err\n   }\n\n   // set latency budget for the database call\n   subCtx, cancel := context.WithTimeout(ctx, 1*time.Second)\n   defer cancel()\n\n   // perform DB select\n   row := db.QueryRowContext(subCtx, sqlLoadByID, ID)\n\n   // retrieve columns and populate the person object\n   out, err := populatePerson(row.Scan)\n   if err != nil {\n      if err == sql.ErrNoRows {\n         cfg.Logger().Warn(\"failed to load requested person '%d'. err: %s\", ID, err)\n         return nil, ErrNotFound\n      }\n\n      cfg.Logger().Error(\"failed to convert query result. err: %s\", err)\n      return nil, err\n   }\n   return out, nil\n}\n\nvar getDB = func(cfg Config) (*sql.DB, error) {\n   if db == nil {\n      var err error\n      db, err = sql.Open(\"mysql\", cfg.DataDSN())\n      if err != nil {\n         // if the DB cannot be accessed we are dead\n         panic(err.Error())\n      }\n   }\n\n   return db, nil\n}\n```", "```go\n// Config is the configuration for Getter\ntype Config interface {\n   Logger() logging.Logger\n   DataDSN() string\n}\n\n// Getter will attempt to load a person.\n// It can return an error caused by the data layer or when the \n// requested person is not found\ntype Getter struct {\n   cfg Config\n}\n\n// Do will perform the get\nfunc (g *Getter) Do(ID int) (*data.Person, error) {\n   // load person from the data layer\n   person, err := loader(context.TODO(), g.cfg, ID)\n   if err != nil {\n      if err == data.ErrNotFound {\n         // By converting the error we are hiding the implementation \n         // details from our users.\n         return nil, errPersonNotFound\n      }\n      return nil, err\n   }\n\n   return person, err\n}\n\n// this function as a variable allows us to Monkey Patch during testing\nvar loader = data.Load\n```", "```go\ntype testConfig struct{}\n\n// ExchangeBaseURL implements Config\nfunc (t *testConfig) ExchangeBaseURL() string {\n   return config.App.ExchangeRateBaseURL\n}\n\n// ExchangeAPIKey implements Config\nfunc (t *testConfig) ExchangeAPIKey() string {\n   return config.App.ExchangeRateAPIKey\n}\n```", "```go\n// Config is the configuration for the Registerer\ntype Config interface {\n   Logger() logging.Logger\n   RegistrationBasePrice() float64\n   DataDSN() string\n}\n```", "```go\n{\n   \"success\":true,\n   \"historical\":true,\n   \"date\":\"2010-11-09\",\n   \"timestamp\":1289347199,\n   \"source\":\"USD\",\n   \"quotes\":{\n      \"USDAUD\":0.989981\n   }\n}\n```", "```go\nfunc TestExternalBoundaryTest(t *testing.T) {\n   // define the config\n   cfg := &testConfig{\n      baseURL: config.App.ExchangeRateBaseURL,\n      apiKey:  config.App.ExchangeRateAPIKey,\n   }\n\n   // create a converter to test\n   converter := NewConverter(cfg)\n\n   // fetch from the server\n   response, err := converter.loadRateFromServer(context.Background(), \"AUD\")\n   require.NotNil(t, response)\n   require.NoError(t, err)\n\n   // parse the response\n   resultRate, err := converter.extractRate(response, \"AUD\")\n   require.NoError(t, err)\n\n   // validate the result\n   assert.True(t, resultRate > 0)\n}\n```", "```go\n// +build external\n```", "```go\ntype happyExchangeRateService struct{}\n\n// ServeHTTP implements http.Handler\nfunc (*happyExchangeRateService) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n  payload := []byte(`\n{\n   \"success\":true,\n   \"historical\":true,\n   \"date\":\"2010-11-09\",\n   \"timestamp\":1289347199,\n   \"source\":\"USD\",\n   \"quotes\":{\n      \"USDAUD\":0.989981\n   }\n}`)\n  response.Write(payload)\n}\n```", "```go\nfunc TestInternalBoundaryTest(t *testing.T) {\n   // start our test server\n   server := httptest.NewServer(&happyExchangeRateService{})\n   defer server.Close()\n\n   // define the config\n   cfg := &testConfig{\n      baseURL: server.URL,\n      apiKey:  \"\",\n   }\n\n   // create a converter to test\n   converter := NewConverter(cfg)\n   resultRate, resultErr := converter.Exchange(context.Background(), 100.00, \"AUD\")\n\n   // validate the result\n   assert.Equal(t, 101.01, resultRate)\n   assert.NoError(t, resultErr)\n}\n```", "```go\ntype PeopleFilterConfig interface {\n   DSN() string\n}\n\nfunc PeopleFilter(cfg PeopleFilterConfig, filter string) ([]Person, error) {\n   // load people\n   loader := &PersonLoader{}\n   people, err := loader.LoadAll(cfg)\n   if err != nil {\n      return nil, err\n   }\n\n   // filter people\n   out := []Person{}\n   for _, person := range people {\n      if strings.Contains(person.Name, filter) {\n         out = append(out, person)\n      }\n   }\n\n   return out, nil\n}\n\ntype PersonLoaderConfig interface {\n   DSN() string\n}\n\ntype PersonLoader struct{}\n\nfunc (p *PersonLoader) LoadAll(cfg PersonLoaderConfig) ([]Person, error) {\n   return nil, errors.New(\"not implemented\")\n}\n```", "```go\ntype Loader interface {\n   LoadAll() ([]Person, error)\n}\n\nfunc PeopleFilter(loader Loader, filter string) ([]Person, error) {\n   // load people\n   people, err := loader.LoadAll()\n   if err != nil {\n      return nil, err\n   }\n\n   // filter people\n   out := []Person{}\n   for _, person := range people {\n      if strings.Contains(person.Name, filter) {\n         out = append(out, person)\n      }\n   }\n\n   return out, nil\n}\n```", "```go\nfunc DoJob(pool WorkerPool, job Job) error {\n   // wait for pool\n   ready := pool.IsReady()\n\n   select {\n   case <-ready:\n      // happy path\n\n   case <-time.After(1 * time.Second):\n      return errors.New(\"timeout waiting for worker pool\")\n   }\n\n   worker := pool.GetWorker()\n   return worker.Do(job)\n}\n```", "```go\nfunc DoJobUpdated(pool WorkerPool, job Job) error {\n   worker := pool.GetWorker()\n   return worker.Do(job)\n}\n```", "```go\n// NewByConfigConstructor is the constructor for MyStruct\nfunc NewByConfigConstructor(cfg MyConfig, limiter RateLimiter, cache Cache) *MyStruct {\n   return &MyStruct{\n   // code removed\n   }\n}\n```", "```go\nfunc NewLayer1Object(config Layer1Config) *Layer1Object {\n   return &Layer1Object{\n      MyConfig:     config,\n      MyDependency: NewLayer2Object(config),\n   }\n}\n\n// Configuration for the Layer 1 Object\ntype Layer1Config interface {\n   Logger() Logger\n}\n\n// Layer 1 Object\ntype Layer1Object struct {\n   MyConfig     Layer1Config\n   MyDependency *Layer2Object\n}\n\n// Configuration for the Layer 2 Object\ntype Layer2Config interface {\n   Logger() Logger\n}\n\n// Layer 2 Object\ntype Layer2Object struct {\n   MyConfig Layer2Config\n}\n\nfunc NewLayer2Object(config Layer2Config) *Layer2Object {\n   return &Layer2Object{\n      MyConfig: config,\n   }\n}\n```"]