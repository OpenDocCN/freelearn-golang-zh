- en: Dependency Injection by Config
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过配置进行依赖注入
- en: In this chapter, we will be looking at **dependency injection** (**DI**) by
    config. Config injection is not a completely different method but an extension
    of both constructor injection and method injection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过配置来看**依赖注入**（**DI**）。配置注入不是一种完全不同的方法，而是构造函数注入和方法注入的扩展。
- en: It intends to address potential issues with those methods, such as excessive
    or repeated injected dependencies, without sacrificing the UX of our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它旨在解决这些方法可能存在的问题，比如过多或重复注入的依赖项，而不牺牲我们代码的用户体验。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Config injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置注入
- en: Advantages of config injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置注入的优点
- en: Applying config injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用配置注入
- en: Disadvantages of config injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置注入的缺点
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It would be beneficial to be familiar with the code for our service as we introduced
    in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction to ACME
    Registration Service*. This chapter also assumes that you have read [Chapter 6](89c75571-2952-40fc-ba19-221b3114461b.xhtml), *Dependency
    Injection with Constructor Injection*, and [Chapter 7](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml), *Dependency
    Injection with Method Injection*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉我们在[第4章](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml)中介绍的服务代码将是有益的，*ACME注册服务简介*。本章还假设您已经阅读了[第6章](89c75571-2952-40fc-ba19-221b3114461b.xhtml)，*构造函数注入的依赖注入*，和[第7章](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml)，*方法注入的依赖注入*。
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, which is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch08](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch08).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会发现阅读和运行本章的完整代码版本很有用，可在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch08](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch08)找到。
- en: Instructions to obtain the code and configure the sample service are available
    in the README here: [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 获取代码并配置示例服务的说明可在此处的README中找到：[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/)
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch08/acme`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`ch08/acme`中找到我们的服务代码，并已应用了本章的更改。
- en: Config injection
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置注入
- en: Config injection is a specific implementation of method and parameter injection.
    With config injection, we combine multiple dependencies and system-level config
    and merge them into a `config` interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 配置注入是方法和参数注入的特定实现。通过配置注入，我们将多个依赖项和系统级配置合并到一个`config`接口中。
- en: 'Consider the following constructor:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下构造函数：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we are injecting multiple dependencies, including a logger,
    instrumentation, rate limiter, cache, and some configuration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在注入多个依赖项，包括记录器、仪器、速率限制器、缓存和一些配置。
- en: It is safe to assume that we would be likely to inject at least the logger and
    the instrumentation into most of our objects in this same project. This results
    in a minimum of two parameters for every constructor. Across an entire system,
    this adds up to a lot of extra typing. It also detracts from the UX of our constructors
    by making them harder to read, and this potentially hides the significant parameters
    among the common ones.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定地假设我们很可能会将记录器和仪器注入到这个项目中的大多数对象中。这导致每个构造函数至少有两个参数。在整个系统中，这将增加大量额外的输入。它还通过使构造函数更难阅读来减少了我们的构造函数的用户体验，并且可能会隐藏重要参数。
- en: Consider for a moment—where are the values for timeout and the number of workers
    that are likely to be defined? They are probably defined from some central source,
    such as a `config` file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下——超时和工作人数的值可能定义在哪里？它们可能是从某个中央来源定义的，比如一个`config`文件。
- en: 'By applying config injection, our example becomes the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用配置注入，我们的示例变成了以下内容：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have merged the common concerns and the configuration together into the config
    definition but left the significant parameters intact. In this manner, the function
    parameters are still informative without having to read the `config` interface
    definition. In a way, we have hidden or encapsulated the common concerns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将常见问题和配置合并到配置定义中，但保留了重要参数。这样，函数参数仍然具有信息性，而无需阅读`config`接口定义。在某种程度上，我们隐藏或封装了常见问题。
- en: There is another usability aspect to consider—the config is now an interface.
    We should think about what kind of object would implement such an interface. Does
    such an object already exist? What are its responsibilities?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑的另一个可用性方面是配置现在是一个接口。我们应该考虑哪种对象会实现这样的接口。这样的对象是否已经存在？它的责任是什么？
- en: Often config comes from a single source and its responsibilities are to load
    the config and provide access to it. Even though we are introducing the config
    interface to decouple from the actual config management, leveraging the fact that
    it's a single source is still convenient.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，配置来自单一来源，其责任是加载配置并提供对其的访问。即使我们引入配置接口以解耦实际的配置管理，利用它是单一来源仍然很方便。
- en: 'Consider the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code indicates that all of the parameters are coming from the same place.
    This is a good indication that they can be merged.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码表明所有参数都来自同一位置。这表明它们可以合并。
- en: If you come from an object-oriented background, you may be familiar with the
    concept of a service locator. Config injection is intentionally very similar.
    Unlike typical service locator usage, however, we are only extracting configuration
    and a few shared dependencies.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自面向对象的背景，你可能熟悉服务定位器的概念。配置注入故意非常相似。然而，与典型的服务定位器用法不同，我们只提取配置和一些共享的依赖项。
- en: Config injection takes this approach to avoid the service locator's *God object* and
    inherent coupling between usage and the God object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 配置注入采用这种方法来避免服务定位器的*上帝对象*和使用与上帝对象之间的耦合。
- en: Advantages of config injection
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置注入的优势
- en: Given that config injection is an expanded form of constructor and method injections,
    the advantages of the other methods also apply here. In this section, we will
    discuss only the additional benefits that are specific to this method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于配置注入是构造函数和方法注入的扩展形式，其他方法的优点在这里也适用。在本节中，我们将仅讨论特定于此方法的附加优点。
- en: '**It''s excellent for decoupling from a config package**—When we have a `config`
    package that loads from a single place, such as a file, then this package tends
    to become a dependency for many of the other packages in the system. When considering
    the *Single responsibility principle* section from [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID
    Design Principles for Go*, we recognize that the more users a package or object
    has, the more resistant and/or difficult it is to change.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**它非常适合与配置包解耦**-当我们有一个从单一位置加载的`config`包时，比如一个文件，那么这个包往往会成为系统中许多其他包的依赖项。考虑到[第2章](53a15217-38a7-4622-9242-a57fe46335ec.xhtml)中的*单一职责原则*部分，我们意识到一个包或对象的用户越多，它就越难以改变。'
- en: With config injection, we are also defining our requirements in a local interface
    and leveraging Go's implicit interfaces and the **dependency inversion principle**
    (**DIP**) to keep the packages decoupled.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置注入，我们还在本地接口中定义我们的需求，并利用Go的隐式接口和**依赖反转原则**（**DIP**）来保持包的解耦。
- en: 'These steps also make it significantly easier to test our structs. Consider
    the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤还使得测试我们的结构体变得更加容易。考虑以下代码：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, see the same code with config injection:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下使用配置注入的相同代码：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Yes, the amount of code is greater. However, we no longer have to manage test
    configuration files, which can often be a pain. Our tests are entirely self-contained
    and should have no concurrency problems, as they might with a global config object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，代码量更大了。然而，我们不再需要管理测试配置文件，这通常会很麻烦。我们的测试是完全自包含的，不应该出现并发问题，就像全局配置对象可能出现的那样。
- en: '**It eases the burden of injecting common concerns—**In the previous example,
    we are using config injection to inject the logging and instrumentation objects.
    Common concerns such as this are an excellent use for config injection as they
    are frequently needed but are not informative regarding the purpose of the function
    itself. They can be considered environmental dependencies. Due to their shared
    nature, another approach would be to turn them into global singletons instead
    of injecting them. Personally, I prefer to inject them as this gives me the opportunity
    to validate their usage. This in itself might feel weird, but in many cases, we
    build system monitoring and alerts from the existence or lack of instrumentation
    data, thereby making instrumentation part of the features or contract of our code
    and something we might want to protect from regression with tests.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**减轻注入常见关注的负担**-在前面的例子中，我们使用配置注入来注入日志记录和仪表对象。这类常见关注是配置注入的一个很好的用例，因为它们经常需要，但并不涉及函数本身的目的。它们可以被视为环境依赖项。由于它们的共享性质，另一种方法是将它们转换为全局单例，而不是注入它们。个人而言，我更喜欢注入它们，因为这给了我验证它们使用的机会。这本身可能感觉奇怪，但在许多情况下，我们从仪表数据的存在或缺失构建系统监控和警报，从而使仪表成为我们代码的特性或契约的一部分，并且可能希望通过测试来防止它们的退化。'
- en: '**It improves usability by reducing parameters**—Similar to the previous advantage,
    applying config injection can enhance the usability of methods, particularly constructors,
    but reduce the number of parameters. Consider the following constructor:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过减少参数来提高可用性**-与前面的优点类似，应用配置注入可以增强方法的可用性，特别是构造函数，同时减少参数的数量。考虑以下构造函数：'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now. take a look at the same constructor with config injection:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下使用配置注入的相同构造函数：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the environmental dependencies removed from the constructor definition,
    we are left with significantly fewer parameters. Even more than that, the only parameters
    that remain are those that are specific to the purpose, hence making the method
    simpler to understand and use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从构造函数定义中移除环境依赖项，我们剩下的参数大大减少了。更重要的是，**唯一**剩下的参数是与目的相关的，因此使得方法更容易理解和使用。
- en: '**Dependency creation can be deferred until use**—Have you ever tried to inject
    a dependency, only to find that it didn''t exist or wasn''t ready yet? Have you
    ever had a dependency that was so expensive to start or run that you wanted to
    create it only when it was absolutely necessary?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖项的创建可以推迟到使用时**-你是否曾经尝试注入一个依赖项，却发现它不存在或尚未准备好？你是否曾经有一个非常昂贵的依赖项，你只想在绝对必要的时候才创建它？'
- en: With config injection, dependency creation, and access only need to be resolved
    at the point of usage and not during injection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置注入，依赖项的创建和访问只需要在使用时解决，而不是在注入时。
- en: Applying config injection
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用配置注入
- en: Previously, I mentioned there were a couple of issues that I really wanted us
    to fix with our ACME registration service. In this section, we are going to use
    config injection to deal with two of them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我提到我们的ACME注册服务有一些问题，我真的希望我们能解决。在这一部分，我们将使用配置注入来处理其中的两个问题。
- en: The first is the fact that many of our packages depend on the `config` and `logging`
    packages, and other than being a substantial single responsibility principle violation,
    this coupling is likely to cause circular dependency problems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是我们的许多包都依赖于`config`和`logging`包，除了是一个重大的单一责任原则违反，这种耦合可能会导致循环依赖问题。
- en: The second is our inability to test our calls to the exchange rate without actually
    calling the upstream service. So far, we have avoided adding any tests to this
    package for fear that our tests would then be affected (in terms of speed and
    stability) by that service.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是我们无法在不实际调用上游服务的情况下测试我们对汇率的调用。到目前为止，我们已经避免在这个包中添加任何测试，因为我们担心我们的测试会受到该服务的影响（在速度和稳定性方面）。
- en: 'First, let''s examine where we are. Our dependency graph currently looks as
    shown in the following diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们现在的情况。我们的依赖图目前如下图所示：
- en: '![](img/d30373a7-5e67-4c58-bb09-275f904f343b.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d30373a7-5e67-4c58-bb09-275f904f343b.png)'
- en: As you can see, we have four packages (`data`, `register`, `exchange`, and `main`) depending
    on the `config` package and five (`data`, `register`, `exchange`, `rest`, and
    `config`) that rely on the `logging` package. What is perhaps worse is how these
    packages depend on the `config` and `logging` packages. Currently, they directly
    access public singletons. This means that when we want to test our logger usage
    or swap out some configuration during testing, we would have to monkey patch and
    this would cause a data race instability in the tests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们有四个包（`data`，`register`，`exchange`和`main`）依赖于`config`包，还有五个（`data`，`register`，`exchange`，`rest`和`config`）依赖于`logging`包。也许更糟糕的是这些包如何依赖于`config`和`logging`包。目前，它们直接访问公共单例。这意味着当我们想要测试我们的记录器使用或在测试期间替换一些配置时，我们将不得不进行猴子补丁，这将导致测试中的数据竞争不稳定性。
- en: To address this, we are going to define one config for each of our objects.
    Each config will include the logger and any other configuration that it needs.
    Then, we replace any direct links to the global variables with references to the
    injected config.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将为我们的每个对象定义一个配置。每个配置将包括记录器和任何其他需要的配置。然后，我们将任何直接链接到全局变量的内容替换为对注入配置的引用。
- en: This will result in a bit of shotgun surgery (a lot of little changes), but
    the code will be a lot better for it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致一些大刀阔斧的手术（许多小的改变），但代码将因此变得更好。
- en: We will go through only one set of changes here; if you wish to see all of them,
    please review the source code for this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会在这里进行一组更改；如果您希望查看所有更改，请查看本章的源代码。
- en: Applying config injection to the model layer
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将配置注入应用到模型层
- en: 'Revisiting our `register` package, we see that it has references to both config
    and logging:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视我们的`register`包，我们看到它引用了`config`和`logging`：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our first step is to define an interface that will supply the dependencies
    we need:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是定义一个接口，它将提供我们需要的依赖项：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Do you see anything wrong with this? The first thing that jumps out is the fact
    that our `Logger()` method returns a pointer to a logger implementation. This
    will work, but it's not very future proof or testable. We could define a `logging`
    interface locally and decouple ourselves entirely from the `logging` package.
    This would mean, however, that we would have to define a `logging` interface in
    most of our packages. Theoretically, this is the best option, but it is not very
    practical. Instead, we could define one `logging` interface and have all of the
    packages depend upon that. While this will mean that we still remained coupled
    to the `logging` package, we will rely on an interface that seldom changes, rather
    than an implementation that is far more likely to change.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有发现什么问题？首先显而易见的是我们的`Logger()`方法返回一个记录器实现的指针。这样可以工作，但不够具有未来性或可测试性。我们可以在本地定义一个`logging`接口，并完全与`logging`包解耦。然而，这意味着我们将不得不在大多数包中定义一个`logging`接口。从理论上讲，这是最好的选择，但实际上并不太实用。相反，我们可以定义一个`logging`接口，并让所有的包都依赖于它。虽然这意味着我们仍然与`logging`包保持耦合，但我们将依赖于一个很少改变的接口，而不是一个更有可能改变的实现。
- en: The second potential issue is the naming of the other method, `BasePrice()`,
    because it's somewhat generic, and a potential source of confusion later on. It
    is also the name of the field in the `Config` struct but Go will not allow us
    to have a member variable and method with the same name, so we will need to change
    that.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个潜在问题是另一个方法`BasePrice()`的命名，因为它有点通用，并且可能会在以后造成混淆。它也是`Config`结构体中的字段名称，但Go不允许我们拥有相同名称的成员变量和方法，所以我们需要更改它。
- en: 'After updating our `config` interface, we have the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 更新我们的`config`接口后，我们有以下内容：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now apply config injection to our `Registerer`, giving us the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将配置注入应用到我们的`Registerer`，得到以下结果：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I have also added a convenience method, `logger()`, to reduce the code from
    `r.cfg.Logger()` to just `r.logger()`. Our service and tests are currently broken,
    so we have more changes to make.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我还添加了一个方便的方法`logger()`，以减少代码从`r.cfg.Logger()`到`r.logger()`。我们的服务和测试目前已经损坏，所以我们还需要做更多的改变。
- en: 'To get the tests going again, we need to define a test configuration and update
    our tests. For our test configuration, we could use mockery and create a mock
    implementation, but we are not interested in validating our config usage or adding
    extra code to all of the tests in this package to configure the mock. Instead,
    we are going to use a stub implementation that returns predictable values. Here
    is our stub test config:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了再次进行测试，我们需要定义一个测试配置并更新我们的测试。对于我们的测试配置，我们可以使用mockery并创建一个模拟实现，但我们不感兴趣验证我们的配置使用或在所有测试中添加额外的代码来配置模拟。相反，我们将使用一个返回可预测值的存根实现。这是我们的存根测试配置：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And add this test config to all of our `Registerer` tests, as shown in the
    following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 并将这个测试配置添加到我们所有的`Registerer`测试中，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our tests are running again, but strangely, while our service compiles, it
    would crash with a `nil` pointer exception if we were to run it. We need to update
    the creation of our `Registerer` from the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试又可以运行了，但奇怪的是，虽然我们的服务编译通过了，但如果我们运行它，它会崩溃并出现`nil`指针异常。我们需要更新我们的`Registerer`的创建方式，从以下方式：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We change it to this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其更改为：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This leads us to the next problem. The `config.App` struct does not implement
    the methods we need. Adding these methods to `config`, we get the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了下一个问题。`config.App`结构体没有实现我们需要的方法。将这些方法添加到`config`，我们得到了以下结果：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With these changes, we have severed the dependency link between the `registration`
    package and the `config` package. In the `Logger()` method we have illustrated
    previously, you can see we are still using the logger as a singleton, but instead
    of being a global public variable, which would be prone to data races, it's now
    inside the `config` object. On the surface, this might not seem like it made any
    difference; however, the data races we were primarily concerned about were during
    testing. Our object now relies on an injected version of the logger and is not
    required to use the global public variable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些改变，我们已经切断了`registration`包和`config`包之间的依赖链接。在我们之前展示的`Logger()`方法中，你可以看到我们仍然将日志记录器作为单例使用，但它不再是一个全局公共变量，这样就不容易出现数据竞争，而是现在在`config`对象内部。表面上，这可能看起来没有任何区别；然而，我们主要关心的数据竞争是在测试期间。我们的对象现在依赖于注入版本的日志记录器，并且不需要使用全局公共变量。
- en: 'Here, we examine our updated dependency graph to see where to go next:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查了我们更新后的依赖图，看看接下来该怎么做：
- en: '![](img/73430c51-07d8-429f-b4bb-5284a9955b5b.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73430c51-07d8-429f-b4bb-5284a9955b5b.png)'
- en: We are down to three links into the `config` package; that is, those from the
    `main`, `data`, and `exchange` packages. The link from the `main` package cannot
    be removed, hence, we can ignore that. So, let's look into the `data` package.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只剩下三个连接到`config`包的链接，即来自`main`、`data`和`exchange`包。来自`main`包的链接无法移除，因此我们可以忽略它。所以，让我们看看`data`包。
- en: Applying config injection to the data package
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将配置注入应用到数据包
- en: 'Our `data` package is currently based on functions, and as such, the changes
    are going to be a little different compared to the previous ones. Here is a typical
    function from the `data` package:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`data`包目前是基于函数的，因此与之前的改变相比，这些改变会有所不同。这是`data`包中的一个典型函数：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this function, we have references to the logger which we want to remove,
    and one configuration that we really need to extract. The config is required by
    the first line of the function from the previous code. Here is the `getDB()` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们引用了我们想要移除的日志记录器，以及我们真正需要提取的一个配置。这个配置是前面代码中函数的第一行需要的。这是`getDB()`函数：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have a reference to the `DSN` to create the database pool. So, what do you
    think our first step should be?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个引用`DSN`来创建数据库池。那么，你认为我们的第一步应该是什么？
- en: 'As with the previous change, let''s first define an interface that includes
    all of the dependencies and configuration that we want to inject:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的改变一样，让我们首先定义一个包括我们想要注入的所有依赖和配置的接口：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s update our functions to inject the `config` interface:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新我们的函数以注入`config`接口：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Unfortunately, this change is going to break a lot of things as `getDB()` is
    called by all of the public functions in the `data` package, which are in turn
    called by the model layer packages. Thankfully, we have enough unit tests to help
    prevent regression while working through the changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个改变会导致很多问题，因为`getDB()`被`data`包中所有公共函数调用，而这些函数又被模型层包调用。幸运的是，我们有足够的单元测试来帮助防止在修改过程中出现回归。
- en: 'I''d like to ask you to stop for a moment and consider this: we are attempting
    to make what should be an insignificant change, but it''s causing a mass of small
    changes. Additionally, we are being forced to add one parameter to every public
    function in this package. How does this make you feel about the decision to build
    this package based on functions? Refactoring away from functions would be no small
    task, but do you think it would be worth it?'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我想请你停下来思考一下：我们试图做的是一个微不足道的改变，但它导致了一大堆小改变。此外，我们被迫在这个包的每个公共函数中添加一个参数。这让你对基于函数构建这个包的决定有什么感觉？从函数中重构不是一件小事，但你认为这样做值得吗？
- en: The changes to the model layer are small, but interesting, thanks to the fact
    that we have already updated the model layer with config injection.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模型层的改变很小，但有趣的是，由于我们已经使用了配置注入，所以这些改变是有意义的。
- en: 'There are only have two small changes to make:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要做两个小改变：
- en: We will add the `DataDSN()` method to our config
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`DataDSN()`方法添加到我们的config
- en: We need to pass the config down to data package via the `loader()` call
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要通过`loader()`调用将配置传递到数据包
- en: 'Here is the code with the changes applied:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用了改变的代码：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Sadly, we need to make these small changes in all of our model layer packages.
    After that is done, our dependency graph now looks as shown in the following diagram:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，我们需要在所有模型层包中进行这些小改变。完成后，我们的依赖图现在如下图所示：
- en: '![](img/25ae83b5-f5b4-4769-8d43-c4541008f54b.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25ae83b5-f5b4-4769-8d43-c4541008f54b.png)'
- en: Fantastic. There is only one unnecessary connection to the `config` package
    left, and it comes from the `exchange` package.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。只剩下一个不必要的连接到`config`包，它来自`exchange`包。
- en: Applying config injection to the exchange package
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将配置注入应用到exchange包
- en: 'We can apply config injection to the `exchange` package as we have with the
    other packages, using the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像对其他包一样，对`exchange`包应用配置注入，使用以下步骤：
- en: Define an interface that includes the dependencies and config that we want to
    inject
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包括我们想要注入的依赖和配置的接口
- en: Define/update the constructor to accept the `config` interface
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义/更新构造函数以接受`config`接口
- en: Save the injected config as a member variable
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将注入的配置保存为成员变量
- en: Change the references (for example, to `config` and `logger`) to point to the
    member variable
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改引用（例如指向`config`和`logger`）以指向成员变量
- en: Update the other layer `config` interfaces to include anything new
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新其他层的`config`接口以包含任何新内容
- en: 'After we have applied config injection to the `exchange` package, an unusual
    situation emerges. Our dependency graph shows that we have removed the link from
    the `exchange` to `config` packages, as can be seen in the following diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对`exchange`包应用配置注入后，出现了一种不寻常的情况。我们的依赖图显示，我们已经从`exchange`到`config`包的链接，如下图所示：
- en: '![](img/408cc23b-7cbb-43f5-8ec6-a07ba2ffd63f.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/408cc23b-7cbb-43f5-8ec6-a07ba2ffd63f.png)'
- en: 'For our tests to remain working, however, we still need to reference the config,
    as shown in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使我们的测试继续工作，我们仍然需要引用配置，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Stepping back for a moment, we notice that the tests we are referring to are
    not tests on the `exchange` package, but for its user, the `register` package.
    This is quite the red flag. We can quickly fix the first part of this problem
    by applying constructor injection to the relationship between these two packages.
    We can then mock or stub the calls to the exchanger.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 退一步看，我们注意到我们所指的测试并不是针对`exchange`包的测试，而是针对其用户`register`包的测试。这是一个很大的警示。我们可以通过在这两个包之间的关系上应用构造函数注入来快速解决这个问题的第一部分。然后我们可以对对外部服务的调用进行模拟或存根。
- en: 'We can also undo some of our earlier changes to the register `Config` interface,
    removing the `exchange` package related methods and bringing us back to this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以撤消对`Config`接口的一些早期更改，删除与`exchange`包相关的方法，并将其还原为以下内容：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This finally allows us to remove the link from our `register` tests to the `config`
    package and, perhaps more importantly, allows us to decouple our test from the
    external exchange rate service.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终使我们能够从我们的`register`测试到`config`包的链接，并且更重要的是，使我们能够将我们的测试与外部汇率服务解耦。
- en: When we started this section, we defined two goals. Firstly, to decouple from
    the `config` package and the `logging` package, and secondly, to be able to test
    without calling the external service. So far, we have managed to decouple from
    the `config` package completely. We have removed the usage of the global public
    logger from all packages except the `config` package, and we have also removed
    our dependence on the external exchange rate service.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始这一部分时，我们定义了两个目标。首先，从`config`包和`logging`包中解耦，并且其次，能够在不调用外部服务的情况下进行测试。到目前为止，我们已经完全解耦了`config`包。我们已经从除`config`包以外的所有包中删除了对全局公共记录器的使用，并且我们还删除了对外部汇率服务的依赖。
- en: Our service still depends on that external service, however, and we have absolutely
    no tests that verify that we call it correctly or that prove the service responds
    as we expect it to. These tests are called **boundary tests**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的服务仍然依赖于该外部服务，但我们绝对没有测试来验证我们是否正确调用它，或者证明服务是否按我们期望的方式响应。这些测试被称为**边界测试**。
- en: Boundary tests
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边界测试
- en: Boundary tests come in two forms, each with their own goal—internal-facing and
    external-facing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 边界测试有两种形式，各自有自己的目标——内部边界和外部边界。
- en: 'Internal-facing boundary tests are designed to validate two things:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 内部边界测试旨在验证两件事：
- en: That our code calls the external service in the way that we expect it to
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码是否按我们期望的方式调用外部服务
- en: That our code reacts to all responses, happy path and errors, from the external
    service in the way that we expect it to
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码对来自外部服务的所有响应（包括正常路径和错误）都做出了我们期望的反应
- en: As such, internal-facing boundary tests do not interact with the external service,
    but rather with a mock or stub implementation of the external service.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，内部边界测试不与外部服务交互，而是与外部服务的模拟或存根实现交互。
- en: External-facing boundary tests are the opposite. They interact with the external
    service and verify that the external service performs as we need it to. Please
    note that they do not validate the external service's API contract, nor does the
    service act as its owner expects it to. Instead, however, they focus only on our
    requirements. External boundary tests are, by nature, going to be slower and less
    reliable than unit tests. As such, we may prefer not to run them all the time.
    We can use Go's build flags to achieve this.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 外部边界测试则相反。它们与外部服务进行交互，并验证外部服务是否按我们需要的方式执行。请注意，它们不验证外部服务的API合同，也不会按照其所有者的期望进行操作。然而，它们只关注我们的需求。外部边界测试通常会比单元测试更慢、更不可靠。因此，我们可能不希望始终运行它们。我们可以使用Go的构建标志来实现这一点。
- en: Let's start by adding external facing boundary tests to our service. We could
    write a test that contains HTTP calls to the external service in the format suggested
    by the service's documentation and then validates the responses. If we were unfamiliar
    with this service and had not yet built the code that calls the service, this
    is also an excellent way to learn about the external service.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先向我们的服务添加外部边界测试。我们可以编写一个测试，其中包含按照服务文档建议的格式对外部服务进行HTTP调用，然后验证响应。如果我们对这项服务不熟悉，并且尚未构建调用该服务的代码，这也是了解外部服务的绝佳方式。
- en: 'In our case, however, we have already written the code, so the faster option
    is to call that code with *live* config. Doing that returns a JSON payload that
    looks similar to the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，我们已经编写了代码，因此更快的选择是使用*live*配置调用该代码。这样做会返回一个类似于以下内容的JSON负载：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While the format of the response is predictable, the `timestamp` and `quotes`
    values will change. So, what can we test? Perhaps, more importantly, what parts
    of the response do we depend on? After closer examination of our code, we realize
    that out of all of the fields in the response, the only one we use is the `quotes`
    map. Additionally, the only thing we require from the external service is that
    the currency we requested exists in that map and the value is of the `float64`
    type. Therefore, by only testing for these specific attributes, our tests will
    be as resilient to changes as possible.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然响应的格式是可预测的，但`timestamp`和`quotes`的值会改变。那么，我们可以测试什么？也许更重要的是，我们依赖响应的哪些部分？在仔细检查我们的代码后，我们意识到在响应中的所有字段中，我们唯一使用的是`quotes`映射。此外，我们从外部服务需要的唯一东西是我们请求的货币存在于该映射中，并且该值是`float64`类型。因此，通过仅测试这些特定属性，我们的测试将尽可能地对更改具有弹性。
- en: 'This gives us a test that looks like the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个看起来像以下代码的测试：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To ensure that this test only runs when we want it to, we put the following
    build tag at the top of the file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这个测试只在我们想要的时候运行，我们在文件顶部放置了以下构建标签：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, that let''s look at internal facing boundary tests. The first step is
    to make ourselves a mock implementation of the external service. We have the resulting
    payload, as mentioned previously. To do this, we will use the `httptest` package
    to create an HTTP server that returns our test payload, like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看内部边界测试。第一步是制作外部服务的模拟实现。我们有先前提到的结果有效负载。为此，我们将使用`httptest`包创建一个返回我们的测试有效负载的HTTP服务器，如下所示：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For now, it returns a fixed response and does nothing to validate the request.
    We can now build our internal-facing boundary test. Unlike the external-facing
    boundary test, the result is now entirely controlled by us and is therefore predictable.
    We can, therefore, test the exact result, as shown in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它返回一个固定的响应，并且不对请求进行验证。我们现在可以构建我们的内部边界测试。与外部边界测试不同，结果现在完全由我们控制，因此是可预测的。因此，我们可以测试确切的结果，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We now have a basic internal facing boundary test. We are able to verify, without
    depending on the external service, that the external service returns the payload
    we expect and we are able to extract and use the result correctly. We can further
    extend our tests to cover more scenarios, including the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个基本的内部边界测试。我们能够验证，而不依赖外部服务，外部服务返回我们期望的有效负载，并且我们能够正确提取和使用结果。我们可以进一步扩展我们的测试，包括以下内容：
- en: A test that verifies our code and returns a sensible error when the external
    service is down or slow
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证我们的代码，并在外部服务宕机或缓慢时返回合理的错误
- en: A test that proves our code returns a sensible error when the external service
    returns an empty or invalid response
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明我们的代码在外部服务返回空或无效响应时返回合理的错误
- en: A test that validates the HTTP request that our code performs
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证我们的代码执行的HTTP请求的测试
- en: With our internal-facing boundary tests in place, we finally have tests on our
    exchange rate code. We have managed to ensure that our code works as intended,
    with tests that are reliable and entirely controlled by us. Additionally, we have
    external boundary tests that we can occasionally run to inform us of any changes
    to the external service that will break our service.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的内部边界测试就位后，我们最终对我们的汇率代码进行了测试。我们已经确保我们的代码按预期工作，并且我们的测试是可靠的，并且完全由我们控制。此外，我们还有外部边界测试，我们可以偶尔运行以通知我们外部服务的任何更改将会破坏我们的服务。
- en: Disadvantages of config injection
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置注入的缺点
- en: As we have seen, config injection can be used with both constructors and functions,
    It is, therefore, possible to build a system with only config injection. Unfortunately,
    config injection does have some disadvantages.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，配置注入可以与构造函数和函数一起使用，因此可以构建一个只使用配置注入的系统。不幸的是，配置注入也有一些缺点。
- en: '**Passing config instead of abstract dependencies leaks implementation details**—Consider
    the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**传递配置而不是抽象依赖项泄漏实现细节** - 考虑以下代码：'
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this example, the `PeopleFilter` function is aware of the fact that `PersonLoader`
    is a database. This might not seem like a big deal, and if the implementation
    strategy never changes, it will have no adverse impact. Should we shift from a
    database to an external service or anything else, however, we would then have
    to change our `PersonLoader` database as well. A more future-proof implementation
    would be as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`PeopleFilter`函数知道`PersonLoader`是一个数据库。这可能看起来不是什么大不了的事，如果实现策略永远不改变，它就不会产生不利影响。然而，如果我们从数据库转移到外部服务或其他任何地方，我们将不得不同时更改我们的`PersonLoader`数据库。一个更具未来性的实现如下：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This implementation is unlikely to require changes should we change where our
    data is loaded from.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变数据加载的位置，这种实现不太可能需要更改。
- en: '**Dependency life cycles are less predictable**—In the advantages, we stated
    that dependency creation can be deferred until use. Your inner critic may have
    rebelled against that assertion, and for a good reason. It is an advantage, but
    it also makes the life cycle of the dependency less predictable. When using constructor
    injection or method injection, the dependency must exist before it is injected.
    Due to this, any issues with the creation or initialization of the dependency
    surfaces at this earlier time. When the dependency is initialized at some unknown
    later point, a couple of issues can arise.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖生命周期不太可预测** - 在优势中，我们说过依赖项的创建可以推迟到使用时。你内心的批评者可能反对这种说法，而且有充分的理由。这是一个优势，但它也使得依赖项的生命周期不太可预测。当使用构造函数注入或方法注入时，依赖项必须在注入之前存在。因此，依赖项的创建或初始化的任何问题都会在此较早的时间出现。当依赖项在某个未知的时间点初始化时，可能会出现一些问题。'
- en: Firstly, if the issue is unrecoverable or causes the system to panic, this would
    mean the system initially seems healthy and then becomes unhealthy or crashes
    unpredictably. This unpredictability can lead to issues that are extremely hard
    to debug.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果问题是无法恢复的或导致系统崩溃，这意味着系统最初看起来健康，然后变得不健康或崩溃不可预测。这种不可预测性可能导致极其难以调试的问题。
- en: 'Secondly, if the initialization of the dependency includes the possibility
    of a delay, we have to be aware of, and account for, any such delay. Consider
    the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果依赖项的初始化包括延迟的可能性，我们必须意识到并考虑任何这样的延迟。考虑以下代码：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now compare this to an implementation that assumes the pool is ready before
    injection:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其与假设池在注入之前已准备就绪的实现进行比较：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What would happen if this function were a part of an endpoint with a latency
    budget? If the startup delay is greater than the latency budget, then the first
    request would always fail.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个函数是端点的一部分，并且具有延迟预算，会发生什么？如果启动延迟大于延迟预算，那么第一个请求将总是失败。
- en: '**Over-use degrades the UX**—While I strongly recommended that you only use
    this pattern for configuration and environmental dependencies such as instrumentation,
    it is possible to apply this pattern in many other places. By pushing the dependencies
    into a `config` interface, however, they become less apparent, and we have a larger
    interface to implement. Let''s re-examine an earlier example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**过度使用会降低用户体验** - 虽然我强烈建议您只在配置和环境依赖项（如仪器）中使用这种模式，但也可以在许多其他地方应用这种模式。但是，通过将依赖项推入`config`接口，它们变得不太明显，并且我们有一个更大的接口要实现。让我们重新审视一个早期的例子：'
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Consider the rate limiter dependency. What happens if we merge that into the
    `Config` interface? It becomes less apparent that this object uses and relies
    on a rate limiter. If every similar function has rate limiting, then this will
    be less of a problem as its usage becomes more environmental.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑速率限制器依赖。如果我们将其合并到`Config`接口中会发生什么？这个对象使用和依赖速率限制器的事实就不太明显了。如果每个类似的函数都有速率限制，那么随着使用变得更加环境化，这将不再是一个问题。
- en: The other less visible aspect is configuration. The configuration of the rate
    limiter is likely not consistent across all usages. This is a problem when all
    of the other dependencies and config are coming from a shared object. We could
    compose the config object and customize the rate limiter returned, but this feels
    like over-engineering.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不太显而易见的方面是配置。速率限制器的配置可能在所有用法中并不一致。当所有其他依赖项和配置都来自共享对象时，这是一个问题。我们可以组合配置对象并自定义返回的速率限制器，但这感觉像是过度设计。
- en: '**Changes can ripple through the software layers** - This issue only applies
    when the config passed through the layers. Consider the following example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**更改可能会在软件层中传播** - 当配置通过层传递时，这个问题才会出现。考虑以下例子：'
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this structure, when we need to add a new configuration or dependency to
    the `Layer2Config` interface, we would also be forced to add it to the `Layer1Config`
    interface. `Layer1Config` would then be in violation of the interface segregation
    principle as discussed in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID
    Design Principles for Go*, which indicates that we might have a problem. Additionally,
    depending on the code's layering and level of reuse, the number of changes could
    be significant. In this case, a better option would be to apply constructor injection
    to inject `Layer2Object` into `Layer1Object`. This would completely decouple the
    objects and remove the need for the layered changes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种结构，当我们需要向`Layer2Config`接口添加新的配置或依赖时，我们也会被迫将其添加到`Layer1Config`接口中。`Layer1Config`将违反接口隔离原则，正如[第2章](53a15217-38a7-4622-9242-a57fe46335ec.xhtml)中讨论的*SOLID设计原则
    for Go*，这表明我们可能会有问题。此外，根据代码的分层和重用级别，更改的数量可能会很大。在这种情况下，更好的选择是应用构造函数注入，将`Layer2Object`注入`Layer1Object`。这将完全解耦对象并消除对分层更改的需求。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have leveraged config injection, an extended version of
    constructor and method injection, to improve the UX of our code, primarily by
    handling the environmental dependencies and config separately from the contextually
    significant dependencies.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们利用了配置注入，这是构造函数和方法注入的扩展版本，以改善我们的代码的用户体验，主要是通过将环境依赖和配置与上下文相关的依赖分开处理。
- en: While applying config injection to our sample service, we have decoupled all
    possible packages from the `config` package, giving it more freedom to evolve
    over time. We also switched most of the logger usage from a global public variable
    to an injected abstract dependency by removing any possibility of a data race
    relating to the logger instance and enabling us to test logger usage without any
    messy monkey patching.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在对我们的示例服务应用配置注入时，我们已经将所有可能的包与`config`包解耦，使其有更多的自由发展。我们还将大部分日志记录器的使用从全局公共变量切换为注入的抽象依赖，从而消除了与日志记录器实例相关的任何数据竞争的可能性，并使我们能够在没有任何混乱的猴子补丁的情况下测试日志记录器的使用。
- en: In the next chapter, we will examine another unusual form of dependency injection,
    called **Just-in-time** (**JIT**) **dependency injection**. With this technique,
    we will reduce the burden associated with dependency creation and injection between
    the layers without sacrificing our ability to test with mocks and stubs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究另一种不寻常的依赖注入形式，称为**即时**（**JIT**）**依赖注入**。通过这种技术，我们将减少与层之间的依赖创建和注入相关的负担，同时不会牺牲使用模拟和存根进行测试的能力。
- en: Questions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does config injection differ from method or constructor injection?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置注入与方法或构造函数注入有何不同？
- en: How do we decide what parameters to move to config injection?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何决定将哪些参数移动到配置注入？
- en: Why don't we inject all dependencies via config injection?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们不通过配置注入注入所有依赖项？
- en: Why do we want to inject environmental dependencies (such as loggers) instead
    of using a global public variable?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们想要注入环境依赖（如日志记录器），而不是使用全局公共变量？
- en: Why are boundary tests important?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 边界测试为什么重要？
- en: What are the ideal use cases for config injection?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置注入的理想使用案例是什么？
