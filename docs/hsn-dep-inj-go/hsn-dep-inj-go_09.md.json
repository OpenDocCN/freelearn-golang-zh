["```go\nfunc NewMyLoadPersonLogic(ds DataSource) *MyLoadPersonLogic {\n   return &MyLoadPersonLogic{\n      dataSource: ds,\n   }\n}\n\ntype MyLoadPersonLogic struct {\n   dataSource DataSource\n}\n\n// Load person by supplied ID\nfunc (m *MyLoadPersonLogic) Load(ID int) (Person, error) {\n   return m.dataSource.Load(ID)\n}\n```", "```go\nfunc NewLoadPersonHandler(logic LoadPersonLogic) *LoadPersonHandler {\n   return &LoadPersonHandler{\n      businessLogic: logic,\n   }\n}\n\ntype LoadPersonHandler struct {\n   businessLogic LoadPersonLogic\n}\n\nfunc (h *LoadPersonHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n   requestedID, err := h.extractInputFromRequest(request)\n\n   output, err := h.businessLogic.Load(requestedID)\n   if err != nil {\n      response.WriteHeader(http.StatusInternalServerError)\n      return\n   }\n\n   h.writeOutput(response, output)\n}\n```", "```go\ntype MyLoadPersonLogicJIT struct {\n   dataSource DataSourceJIT\n}\n\n// Load person by supplied ID\nfunc (m *MyLoadPersonLogicJIT) Load(ID int) (Person, error) {\n   return m.getDataSource().Load(ID)\n}\n\nfunc (m *MyLoadPersonLogicJIT) getDataSource() DataSourceJIT {\n   if m.dataSource == nil {\n      m.dataSource = NewMyDataSourceJIT()\n   }\n\n   return m.dataSource\n}\n```", "```go\nfunc TestMyLoadPersonLogic(t *testing.T) {\n   // setup the mock db\n   mockDB := &mockDB{\n      out: Person{Name: \"Fred\"},\n   }\n\n   // call the object we are testing\n   testObj := NewMyLoadPersonLogic(mockDB)\n   result, resultErr := testObj.Load(123)\n\n   // validate expectations\n   assert.Equal(t, Person{Name: \"Fred\"}, result)\n   assert.Nil(t, resultErr)\n}\n```", "```go\nfunc TestMyLoadPersonLogicJIT(t *testing.T) {\n   // setup the mock db\n   mockDB := &mockDB{\n      out: Person{Name: \"Fred\"},\n   }\n\n   // call the object we are testing\n   testObj := MyLoadPersonLogicJIT{\n      dataSource: mockDB,\n   }\n   result, resultErr := testObj.Load(123)\n\n   // validate expectations\n   assert.Equal(t, Person{Name: \"Fred\"}, result)\n   assert.Nil(t, resultErr)\n}\n```", "```go\nfunc NewGenerator(storage Storage, renderer Renderer, template io.Reader) *Generator {\n   return &Generator{\n      storage:  storage,\n      renderer: renderer,\n      template: template,\n   }\n}\n```", "```go\nfunc NewGenerator(template io.Reader) *Generator {\n   return &Generator{\n      template: template,\n   }\n}\n```", "```go\nfunc (l *LoaderWithoutJIT) Load(ID int) (*Animal, error) {\n   var output *Animal\n   var err error\n\n   // attempt to load from cache\n   if l.OptionalCache != nil {\n      output = l.OptionalCache.Get(ID)\n      if output != nil {\n         // return cached value\n         return output, nil\n      }\n   }\n\n   // load from data store\n   output, err = l.datastore.Load(ID)\n   if err != nil {\n      return nil, err\n   }\n\n   // cache the loaded value\n   if l.OptionalCache != nil {\n      l.OptionalCache.Put(ID, output)\n   }\n\n   // output the result\n   return output, nil\n}\n```", "```go\nfunc (l *LoaderWithJIT) Load(ID int) (*Animal, error) {\n   // attempt to load from cache\n   output := l.cache().Get(ID)\n   if output != nil {\n      // return cached value\n      return output, nil\n   }\n\n   // load from data store\n   output, err := l.datastore.Load(ID)\n   if err != nil {\n      return nil, err\n   }\n\n   // cache the loaded value\n   l.cache().Put(ID, output)\n\n   // output the result\n   return output, nil\n}\n```", "```go\nfunc NewLoader(ds Datastore, cache Cache) *MyLoader {\n   return &MyLoader{\n      ds:    ds,\n      cache: cache,\n   }\n}\n```", "```go\n// Global singleton of connections to our data store\nvar storage UserStorage\n\ntype Saver struct {\n}\n\nfunc (s *Saver) Do(in *User) error {\n   err := s.validate(in)\n   if err != nil {\n      return err\n   }\n\n   return storage.Save(in)\n}\n```", "```go\n// Global singleton of connections to our data store\nvar storage UserStorage\n\ntype Saver struct {\n   storage UserStorage\n}\n\nfunc (s *Saver) Do(in *User) error {\n   err := s.validate(in)\n   if err != nil {\n      return err\n   }\n\n   return s.getStorage().Save(in)\n}\n\n// Just-in-time DI\nfunc (s *Saver) getStorage() UserStorage {\n   if s.storage == nil {\n      s.storage = storage\n   }\n\n   return s.storage\n}\n```", "```go\nfunc TestSaver_Do(t *testing.T) {\n   // input\n   carol := &User{\n      Name:     \"Carol\",\n      Password: \"IamKing\",\n   }\n\n   // mocks/stubs\n   stubStorage := &StubUserStorage{}\n\n   // do call\n   saver := &Saver{\n      storage: stubStorage,\n   }\n   resultErr := saver.Do(carol)\n\n   // validate\n   assert.NotEqual(t, resultErr, \"unexpected error\")\n}\n```", "```go\ntype Car struct {\n   engine Engine\n}\n\nfunc (c *Car) Drive() {\n   c.engine.Start()\n   defer c.engine.Stop()\n\n   c.engine.Drive()\n}\n```", "```go\ntype Car struct {\n   engine Engine\n}\n\nfunc (c *Car) Drive() {\n   engine := c.getEngine()\n\n   engine.Start()\n   defer engine.Stop()\n\n   engine.Drive()\n}\n\nfunc (c *Car) getEngine() Engine {\n   if c.engine == nil {\n      c.engine = newEngine()\n   }\n\n   return c.engine\n}\n```", "```go\n$ cd $GOPATH/src/github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/ch08/\n\n$ export ACME_CONFIG=$GOPATH/src/github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/config.json\n\n$ package-coverage -a -prefix $(go list)/ ./acme/\n```", "```go\n-------------------------------------------------------------------------\n|      Branch     |       Dir       |                                   |\n|   Cov% |  Stmts |   Cov% |  Stmts | Package                           |\n-------------------------------------------------------------------------\n|  65.66 |    265 |   0.00 |      7 | acme/                             |\n|  47.83 |     23 |  47.83 |     23 | acme/internal/config/             |\n|   0.00 |      4 |   0.00 |      4 | acme/internal/logging/            |\n|  73.77 |     61 |  73.77 |     61 | acme/internal/modules/data/       |\n|  61.70 |     47 |  61.70 |     47 | acme/internal/modules/exchange/   |\n|  85.71 |      7 |  85.71 |      7 | acme/internal/modules/get/        |\n|  46.15 |     13 |  46.15 |     13 | acme/internal/modules/list/       |\n|  62.07 |     29 |  62.07 |     29 | acme/internal/modules/register/   |\n|  79.73 |     74 |  79.73 |     74 | acme/internal/rest/               |\n-------------------------------------------------------------------------\n```", "```go\n// Do will perform the get\nfunc (g *Getter) Do(ID int) (*data.Person, error) {\n   // load person from the data layer\n   person, err := loader(context.TODO(), g.cfg, ID)\n   if err != nil {\n      if err == data.ErrNotFound {\n         // By converting the error we are hiding the implementation \n         // details from our users.\n         return nil, errPersonNotFound\n      }\n      return nil, err\n   }\n\n   return person, err\n}\n\n// this function as a variable allows us to Monkey Patch during testing\nvar loader = data.Load\n\n```", "```go\n//go:generate mockery -name=myLoader -case underscore -testonly -inpkg\ntype myLoader interface {\n   Load(ctx context.Context, ID int) (*data.Person, error)\n}\n```", "```go\n// Do will perform the get\nfunc (g *Getter) Do(ID int) (*data.Person, error) {\n   // load person from the data layer\n   person, err := g.getLoader().Load(context.TODO(), ID)\n   if err != nil {\n      if err == data.ErrNotFound {\n         // By converting the error we are hiding the implementation \n         // details from our users.\n         return nil, errPersonNotFound\n      }\n      return nil, err\n   }\n\n   return person, err\n}\n```", "```go\nfunc (g *Getter) getLoader() myLoader {\n   if g.data == nil {\n      // To be determined\n   }\n\n   return g.data\n}\n```", "```go\n// NewDAO will initialize the database connection pool (if not already \n// done) and return a data access object which can be used to interact \n// with the database\nfunc NewDAO(cfg Config) *DAO {\n   // initialize the db connection pool\n   _, _ = getDB(cfg)\n\n   return &DAO{\n      cfg: cfg,\n   }\n}\n\ntype DAO struct {\n   cfg Config\n}\n\n// Load will attempt to load and return a person.\nfunc (d *DAO) Load(ctx context.Context, ID int) (*Person, error) {\n   return Load(ctx, d.cfg, ID)\n}\n```", "```go\nfunc TestGetter_Do_happyPath(t *testing.T) {\n   // inputs\n   ID := 1234\n\n   // configure the mock loader\n   mockResult := &data.Person{\n      ID:       1234,\n      FullName: \"Doug\",\n   }\n   mockLoader := &mockMyLoader{}\n   mockLoader.On(\"Load\", mock.Anything, ID).Return(mockResult, nil).Once()\n\n   // call method\n   getter := &Getter{\n      data: mockLoader,\n   }\n   person, err := getter.Do(ID)\n\n   // validate expectations\n   require.NoError(t, err)\n   assert.Equal(t, ID, person.ID)\n   assert.Equal(t, \"Doug\", person.FullName)\n   assert.True(t, mockLoader.AssertExpectations(t))\n}\n```", "```go\n// QueryTracker is an interface to track query timing\ntype QueryTracker interface {\n   // Track will record/out the time a query took by calculating \n   // time.Now().Sub(start)\n   Track(key string, start time.Time)\n}\n```", "```go\n// NO-OP implementation of QueryTracker\ntype noopTracker struct{}\n\n// Track implements QueryTracker\nfunc (_ *noopTracker) Track(_ string, _ time.Time) {\n   // intentionally does nothing\n}\n```", "```go\n// DAO is a data access object that provides an abstraction over \n// our database interactions.\ntype DAO struct {\n   cfg Config\n\n   // Tracker is an optional query timer\n   Tracker QueryTracker\n}\n```", "```go\nfunc (d *DAO) getTracker() QueryTracker {\n   if d.Tracker == nil {\n      d.Tracker = &noopTracker{}\n   }\n\n   return d.Tracker\n}\n```", "```go\n// track processing time\ndefer d.getTracker().Track(\"LoadAll\", time.Now())\n```", "```go\n// NewLogTracker returns a Tracker that outputs tracking data to log\nfunc NewLogTracker(logger logging.Logger) *LogTracker {\n   return &LogTracker{\n      logger: logger,\n   }\n}\n\n// LogTracker implements QueryTracker and outputs to the supplied logger\ntype LogTracker struct {\n   logger logging.Logger\n}\n\n// Track implements QueryTracker\nfunc (l *LogTracker) Track(key string, start time.Time) {\n   l.logger.Info(\"[%s] Timing: %s\\n\", key, time.Now().Sub(start).String())\n}\n```", "```go\nfunc (l *Lister) getLoader() myLoader {\n   if l.data == nil {\n      l.data = data.NewDAO(l.cfg)\n   }\n\n   return l.data\n}\n```", "```go\nfunc (l *Lister) getLoader() myLoader {\n   if l.data == nil {\n      l.data = data.NewDAO(l.cfg)\n\n      // temporarily add a log tracker\n      l.data.(*data.DAO).Tracker = data.NewLogTracker(l.cfg.Logger())\n   }\n\n   return l.data\n}\n```", "```go\nfunc (l *Sender) Send(ctx context.Context, payload []byte) error {\n   pool := l.getConnectionPool()\n\n   // ensure pool is ready\n   select {\n   case <-pool.IsReady():\n      // happy path\n\n   case <-ctx.Done():\n      // context timed out or was cancelled\n      return errors.New(\"failed to get connection\")\n   }\n\n   // get connection from pool and return afterwards\n   conn := pool.Get()\n   defer l.connectionPool.Release(conn)\n\n   // send and return\n   _, err := conn.Write(payload)\n\n   return err\n}\n```", "```go\nfunc (l *Sender) Send(payload []byte) error {\n   pool := l.getConnectionPool()\n\n   // get connection from pool and return afterwards\n   conn := pool.Get()\n   defer l.connectionPool.Release(conn)\n\n   // send and return\n   _, err := conn.Write(payload)\n\n   return err\n}\n```", "```go\nfunc newConnectionPool() ConnectionPool {\n   pool := &myConnectionPool{}\n\n   // initialize the pool\n   pool.init()\n\n   // return a \"ready to use pool\"\n   return pool\n}\n```", "```go\nfunc (l *Sender) getConnection() ConnectionPool {\n   l.initPoolOnce.Do(func() {\n      l.connectionPool = newConnectionPool()\n   })\n\n   return l.connectionPool\n}\n```"]