- en: Just-in-Time Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚性依赖注入
- en: With *traditional* **dependency injection** (**DI**) methods, the parent or
    calling object supplies the dependencies to the child class. However, there are
    many cases where the dependencies have a single implementation. In these cases,
    a pragmatic approach would be to ask yourself, why inject the dependency at all?
    In this chapter, we will examine **just-in-time** (**JIT**) dependency injection,
    a strategy that gives us many of the benefits of DI, like decoupling and testability,
    without adding parameters to our constructors or methods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*传统* **依赖注入**（**DI**）方法，父对象或调用对象向子类提供依赖项。然而，有许多情况下，依赖项只有一个实现。在这些情况下，一个务实的方法是问自己，为什么要注入依赖项？在本章中，我们将研究**just-in-time**（**JIT**）依赖注入，这是一种策略，它给我们带来了DI的许多好处，如解耦和可测试性，而不需要向我们的构造函数或方法添加参数。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: JIT injection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JIT注入
- en: Advantages of JIT injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JIT注入的优势
- en: Applying JIT injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用JIT注入
- en: Disadvantages of JIT injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JIT注入的缺点
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It would be beneficial to be familiar with the code for our service we introduced
    in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction to the
    ACME Registration Service*. This chapter also assumes that you have read [Chapter
    6](89c75571-2952-40fc-ba19-221b3114461b.xhtml), *Dependency Injection with Constructor
    Injection*, and, to a lesser extent, [Chapter 5](5b999adb-130a-49ed-9294-841c5a1b8181.xhtml), *Dependency
    Injection with Monkey Patching*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉我们在[第4章](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml)中介绍的服务代码可能会有所帮助，*ACME注册服务简介*。本章还假定您已经阅读了[第6章](89c75571-2952-40fc-ba19-221b3114461b.xhtml)，*构造函数注入的依赖注入*，以及在较小程度上，[第5章](5b999adb-130a-49ed-9294-841c5a1b8181.xhtml)，*使用Monkey
    Patching进行依赖注入*。
- en: You might also find it useful to read and run the full version of the code for
    this chapter, which is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch09](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch09).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会发现阅读和运行本章的完整代码版本很有用，该代码版本可在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch09](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch09)上找到。
- en: Instructions to obtain the code and configure the sample service are available
    in the README section here: [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 获取代码并配置示例服务的说明可在此处的README部分找到：[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/)。
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch09/acme`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`ch09/acme`中找到我们的服务代码，其中已经应用了本章的更改。
- en: In this chapter, we will be using mockery ([https://github.com/vektra/mockery](https://github.com/vektra/mockery))
    to generate mock implementations of our interfaces and also introducing a new
    tool called **package coverage** ([https://github.com/corsc/go-tools/tree/master/package-coverage)](https://github.com/corsc/go-tools/tree/master/package-coverage).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用mockery（[https://github.com/vektra/mockery](https://github.com/vektra/mockery)）生成我们接口的模拟实现，并介绍一个名为**package
    coverage**（[https://github.com/corsc/go-tools/tree/master/package-coverage)](https://github.com/corsc/go-tools/tree/master/package-coverage)）的新工具。
- en: JIT injection
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JIT注入
- en: 'Have you ever written an object and injected a dependency that you knew was
    only going to have one implementation? Perhaps you have injected the database
    handling code into the business logic layer, as shown in the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经编写过一个对象，并注入了一个您知道只会有一个实现的依赖项？也许您已经将数据库处理代码注入到业务逻辑层中，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Have you ever added a dependency to your constructor for the sole purpose of
    mocking it out during testing? This is shown in the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经为了在测试期间将其模拟而将依赖项添加到构造函数中？这在以下代码中显示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These kinds of things can feel like unnecessary extra work, and they definitely
    degrade the UX of the code. JIT injection allows us a comfortable middle ground.
    JIT injection is perhaps best explained by working through some examples. Let''s
    take a look at our first example with JIT injection applied:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事情可能会感觉像是不必要的额外工作，它们确实会降低代码的用户体验。 JIT注入为我们提供了一个舒适的中间地带。 JIT注入可能最好通过一些示例来解释。让我们看看我们第一个应用了JIT注入的示例：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we have changed the direct references from `m.dataSource` to
    `m.getDataSource()` by adding a `getter` function, `getDataSource()`. In `getDataSource()`,
    we are performing a simple and efficient check to see whether the dependency already
    exists and when it doesn't, we create it. This is where we get the name *just-in-time
    injection*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经通过添加一个`getter`函数`getDataSource()`，将直接引用从`m.dataSource`更改为`m.getDataSource()`。在`getDataSource()`中，我们执行了一个简单而高效的检查，以查看依赖项是否已经存在，当它不存在时，我们创建它。这就是我们得到*just-in-time注入*名称的地方。
- en: So, if we are not going to inject the dependency, then why do we need the injection?
    The simple answer is testing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们不打算注入依赖项，那么为什么需要注入？简单的答案是测试。
- en: 'In our original example, we were able to *swap out* our dependency with a mock
    implementation during testing, as shown in the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的原始示例中，我们能够在测试期间使用模拟实现*替换*我们的依赖项，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With JIT injection, we can still supply a mock implementation, but instead
    of supplying it via the constructor, we inject it directly into the private member
    variable, like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JIT注入，我们仍然可以提供一个模拟实现，但是不是通过构造函数提供，而是直接将其注入到私有成员变量中，就像这样：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may have also noticed that in this example we dropped the use of a constructor.
    This is not necessary and will not always be the case. Applying JIT injection
    improves the usability of the object by reducing the number of parameters. In
    our example, there were no parameters left so dropping the constructor seemed
    appropriate as well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还注意到，在这个例子中，我们放弃了使用构造函数。这并不是必要的，也不会总是这种情况。应用JIT注入通过减少参数的数量来提高对象的可用性。在我们的例子中，没有剩下的参数，所以放弃构造函数似乎也是合适的。
- en: JIT injection has allowed us to bend the traditional rules of DI by giving the
    object the ability to create its own dependencies when needed. While this is strictly
    speaking a violation of the *Single responsibility principle* section, as discussed
    in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID Design Principles
    for Go*, the improvements in usability are significant.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JIT注入使我们能够打破DI的传统规则，使对象能够在需要时创建自己的依赖关系。虽然严格来说这是违反了*单一责任原则*部分，正如在[第2章](53a15217-38a7-4622-9242-a57fe46335ec.xhtml)中讨论的那样，*Go的SOLID设计原则*，但可用性的改进是显著的。
- en: Advantages of JIT injection
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JIT注入的优势
- en: This method was designed to address some of the pain points of traditional DI.
    The advantages listed here are specific to this method and in contrast to other
    forms of dependency injection. Benefits specific to this method include the following.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法旨在解决传统DI的一些痛点。这里列出的优势是特定于这种方法的，与其他形式的依赖注入形成对比。这种方法的特定优势包括以下内容。
- en: '**Better User Experience (UX) due to fewer inputs**—I know I have raised this
    point a lot, but code that is easier to understand is also easier to maintain
    and extend. When a function has fewer parameters, it''s inherently easier to understand.
    Compare the constructor:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的用户体验（UX）由于更少的输入 - 我知道我已经提到了这一点很多次，但是更容易理解的代码也更容易维护和扩展。当一个函数的参数更少时，它本质上更容易理解。比较构造函数：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With this one:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与这个：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we removed all of the dependencies that had only one live implementation
    and replaced them with JIT injection. Now, users of this function just need to
    supply the one dependency that can change.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们删除了所有只有一个活动实现的依赖项，并用JIT注入替换了它们。现在，这个函数的用户只需要提供一个可能会改变的依赖项。
- en: '**It''s perfect for optional dependencies**—Similar to the previous point regarding
    UX, optional dependencies can bloat a function''s parameter list. Additionally,
    it is not immediately apparent that the dependency is optional. Moving the dependency
    to a public member variable allows users to supply it only when needed. Applying
    JIT injection then allows the object to instantiate a copy of the default dependency.
    This simplifies the code inside the object significantly.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**它非常适合可选依赖项** - 与前面关于UX的观点类似，可选依赖项可能会使函数的参数列表膨胀。此外，依赖项是否是可选的并不是立即显而易见的。将依赖项移动到公共成员变量允许用户仅在需要时提供它。然后应用JIT注入允许对象实例化默认依赖项的副本。这显著简化了对象内部的代码。'
- en: 'Consider the following code, which does not use JIT injection:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下不使用JIT注入的代码：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Applying JIT injection, this becomes the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 应用JIT注入，这变成了以下形式：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The function is now more concise and more straightforward to read. We will discuss
    using JIT injection with optional dependencies more in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数现在更加简洁，更容易阅读。我们将在下一节中更详细地讨论使用JIT注入处理可选依赖项。
- en: '**Better encapsulation of the implementation details**—One of the counter-arguments
    to typical DI (that is, constructor or parameter injection) is that by exposing
    one object''s dependence on another, you are leaking implementation details. Consider
    the following constructor:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好地封装实现细节** - 对典型DI（即构造函数或参数注入）的反驳之一是，通过暴露一个对象对另一个对象的依赖，你泄漏了实现细节。考虑以下构造函数：'
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, put yourself in the position of the user of `MyLoader`, without knowing
    its implementation. Does it matter to you that `MyLoader` uses a database or a
    cache? If you don't have multiple implementations or configurations to use, would
    it be easier just to let the author of `MyLoader` handle it for you?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，把自己放在`MyLoader`的用户的位置上，不知道它的实现。对你来说，`MyLoader`使用数据库还是缓存重要吗？如果你没有多个实现或配置可供使用，让`MyLoader`的作者为你处理会更容易吗？
- en: '**Reduction in test-induced damage**—Another frequent complaint of those against
    DI is that dependencies are added to the constructor for the sole purpose of replacing
    them during testing. This position is well-founded; it''s something you will see
    quite often and one of the more common forms of test-induced damage. JIT injection
    alleviates this by changing the relationship to a private member variable and
    removing it from the public API. This still allows us to replace the dependency
    during testing, but with no public damage.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少测试引起的损害** - 反对DI的人经常抱怨的另一个问题是，依赖项被添加到构造函数中，唯一目的是在测试期间替换它们。这个观点是有根据的；你会经常看到这种情况，也是测试引起的损害的更常见形式之一。JIT注入通过将关系更改为私有成员变量并将其从公共API中移除来缓解了这一问题。这仍然允许我们在测试期间替换依赖项，但不会造成公共损害。'
- en: In case you were wondering, the choice of a private member variable and not
    public is intentional and intentionally limiting. Being private, we are able to
    access and replace the dependency only during testing within the same package.
    Tests outside the package intentionally have no access. The first reason for this
    is encapsulation. We want to hide the implementation details from other packages
    so that they do not become coupled with our package. Any such coupling would make
    it harder to make changes to our implementation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想，选择私有成员变量而不是公共的是有意的，也是有意限制的。私有的话，我们只能在同一个包内的测试期间访问和替换依赖项。包外的测试故意没有访问权限。这样做的第一个原因是封装。我们希望隐藏实现细节，使其他包不与我们的包耦合。任何这样的耦合都会使对我们实现的更改变得更加困难。
- en: The second reason is API pollution. If we made the member variable public, it
    would be accessible not only to the tests but to everyone, thereby opening the
    possibility of unexpected, invalid, or dangerous use of our internals.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是API污染。如果我们将成员变量设为公共的，那么不仅测试可以访问，而且所有人都可以访问，从而打开了意外、无效或危险使用我们内部的可能性。
- en: '**It''s a great alternative to monkey patching**—As you may remember from [Chapter
    5](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml), *Dependency Injection with Monkey
    Patching*, one of the most significant problems with monkey patching is concurrency
    during testing. By patching the single global variable to suit the current test,
    any other test that is using that variable will be impacted and likely broken.
    It is possible to use JIT injection to avoid this problem. Consider the following
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是一个很好的替代方法**——正如你可能还记得[第5章](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml)中所说的，*使用猴子补丁进行依赖注入*，猴子补丁的最大问题之一是测试期间的并发性。通过调整单个全局变量以适应当前测试，任何使用该变量的其他测试都会受到影响，很可能会出错。可以使用JIT注入来避免这个问题。考虑以下代码：'
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As is, the global variable storage is going to need to be monkey patched during
    testing. But look what happens when we apply JIT injection:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，全局变量存储在测试期间需要进行猴子补丁。但是当我们应用JIT注入时会发生什么呢？
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With all access to the global variable now going via `getStorage()`, we are
    able to use JIT injection to *swap out* the `storage` member variable instead
    of monkey patching the global (and shared) variable, as seen in this example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有对全局变量的访问都通过`getStorage()`进行，我们能够使用JIT注入来*替换*`storage`成员变量，而不是对全局（和共享）变量进行猴子补丁，就像这个例子中所示的那样：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the aforementioned test, there are no more data races on the global variable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述测试中，全局变量上不再存在数据竞争。
- en: '**It''s excellent for layering code**—When applying dependency injection to
    an entire project, it is not uncommon to see a large swath of objects being created
    early on in the application''s execution. For example, our minimal example service
    already has four objects being built in `main()`. Four might not sound like a
    lot, but we haven''t applied DI to all our packages, and so far we only have three
    endpoints.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于分层代码来说非常好**——当将依赖注入应用于整个项目时，很常见的是在应用程序执行的早期看到大量对象被创建。例如，我们的最小示例服务已经在`main()`中创建了四个对象。四个听起来可能不多，但我们还没有将DI应用到所有的包，到目前为止我们只有三个端点。'
- en: For our service, we have three layers of code, REST, business logic, and data.
    The relationships between the layers are straightforward. One object in the REST
    layer calls its partner object in the business logic layer, which in turns calls
    the data layer. Other than for testing, we are always injecting the same dependencies.
    Applying JIT injection would allow us to remove these dependencies from the constructors
    and make the code more comfortable to use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的服务，我们有三层代码，REST、业务逻辑和数据。层之间的关系很简单。REST层中的一个对象调用其业务逻辑层的合作对象，然后调用数据层。除了测试之外，我们总是注入相同的依赖项。应用JIT注入将允许我们从构造函数中删除这些依赖项，并使代码更易于使用。
- en: '**Implementation cost is low**—As we saw in the previous monkey patching example,
    applying JIT injection is very easy. Additionally, the changes are confined to
    a tiny area.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现成本低**——正如我们在之前的猴子补丁示例中看到的，应用JIT注入非常容易。此外，更改范围很小。'
- en: 'Similarly, applying JIT injection to code that does not already have any form
    of DI is also cheap. Consider the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于原本没有任何形式的DI的代码应用JIT注入也很便宜。考虑以下代码：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we decide to decouple `Car` from `Engine` then we will only need to define
    the abstracted interaction as an interface and then change all direct access to
    `c.engine` to use a `getter` function, as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定将`Car`与`Engine`解耦，那么我们只需要将抽象交互定义为接口，然后将所有对`c.engine`的直接访问更改为使用`getter`函数，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Consider what the process would have been to apply constructor injection. In
    what kinds of places would we have had to make changes?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下应用构造函数注入的过程。我们需要在哪些地方进行更改？
- en: Applying JIT injection
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用JIT注入
- en: In previous sections, I alluded to the fact that JIT injection can be used with
    private and public dependencies, two very different use cases. In this section,
    we will apply both options to achieve very different results.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我提到了JIT注入可以用于私有和公共依赖项，这是两种非常不同的用例。在本节中，我们将应用这两种选项以实现非常不同的结果。
- en: Unit test coverage
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试覆盖率
- en: In Go, test coverage is calculated by adding a `-cover` flag along with a call
    to a regular call to go test. As this only works for one package at a time, I
    find this inconvenient. So we are going to use a tool that recursively calculates
    test coverage for all the packages in a directory tree. This tool is called **package-coverage**
    and is available from GitHub ([https://github.com/corsc/go-tools/tree/master/package-coverage](https://github.com/corsc/go-tools/tree/master/package-coverage)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，测试覆盖率是通过在调用go test时添加`-cover`标志来计算的。由于这只适用于一个包，我觉得这很不方便。因此，我们将使用一个工具，该工具可以递归计算目录树中所有包的测试覆盖率。这个工具叫做**package-coverage**，可以从GitHub
    ([https://github.com/corsc/go-tools/tree/master/package-coverage](https://github.com/corsc/go-tools/tree/master/package-coverage))
    获取。
- en: 'To calculate the coverage using `package-coverage`, we use the following commands:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`package-coverage`计算覆盖率时，我们使用以下命令：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note: I have intentionally used the code from [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml),
    *Dependency Injection by Config*, so the coverage numbers are before any changes
    we might make in this chapter.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我故意使用了[第8章](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml)中的代码，*通过配置进行依赖注入*，所以覆盖率数字是在我们在本章可能进行的任何更改之前。
- en: 'This gives us the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了以下结果：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, what can we infer from these numbers?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以从这些数字中推断出什么呢？
- en: The code coverage is reasonable. It could be better but other than the big fat
    0 on the `logging` package, almost all the packages have 50% plus.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码覆盖率是合理的。它可能会更好，但除了`logging`包上的0之外，几乎所有包都有50%以上。
- en: The statement (`stmts`) counts are interesting. Statements are roughly equivalent
    to *lines of code*, and therefore the numbers indicate which packages have more
    or less code. We can see that the `rest`, `data`, and `exchange` packages are
    the largest.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语句（`stmts`）计数很有趣。语句大致相当于*代码行*，因此这些数字表明哪些包有更多或更少的代码。我们可以看到`rest`、`data`和`exchange`包是最大的。
- en: We can infer from the amount of code in a package that the more code a package
    has, the more responsibilities and more complexity it has. By extension, the more
    risk this package poses.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从包中的代码量推断出，包含的代码越多，责任和复杂性就越大。因此，这个包带来的风险也就越大。
- en: Given that the two largest, riskiest packages, `rest` and `data`, both have
    good test coverage, we still have nothing that indicates it needs urgent attention.
    But what happens if we consider the test coverage and dependency graph together?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到两个最大的、最具风险的包`rest`和`data`都有很好的测试覆盖率，我们仍然没有任何迫切需要关注的迹象。但是如果我们将测试覆盖率和依赖图结合起来会发生什么呢？
- en: Private dependencies
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有依赖
- en: 'There are many places we could improve our service by applying JIT injection.
    So, how do we decide? Let''s see what our dependency graph has to say:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过应用JIT注入来改进我们的服务的许多地方。那么我们该如何决定呢？让我们看看我们的依赖图有什么说法：
- en: '![](img/aeec3c06-de6a-41e5-89e3-56c80332a557.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aeec3c06-de6a-41e5-89e3-56c80332a557.png)'
- en: There are lots of connections going into the logging package. But we have already
    decoupled that a reasonable amount in [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml),
    *Dependency Injection by Config*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多连接进入日志包。但是我们在[第8章](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml)中已经相当程度地解耦了它，*通过配置进行依赖注入*。
- en: The next package with the most users is the `data` package. We worked on that
    back in [Chapter 5](5b999adb-130a-49ed-9294-841c5a1b8181.xhtml), *Dependency Injection
    with Monkey Patching*, but maybe it's time to revisit it and see if we can improve
    it even more.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个用户最多的包是`data`包。我们在[第5章](5b999adb-130a-49ed-9294-841c5a1b8181.xhtml)中曾经讨论过它，*使用Monkey
    Patching进行依赖注入*，但也许现在是时候重新审视它，看看我们是否可以进一步改进它。
- en: 'Before we decide, I will introduce you to another way to get a sense of the
    health of the code and where our efforts might be best spent: unit test coverage.
    Like the dependency graph, it cannot provide a definitive indicator, but only
    give you a hint.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们做出决定之前，我将向你介绍另一种了解代码健康状况和我们最好花费精力的方法：单元测试覆盖率。与依赖图一样，它不能提供明确的指标，只能给你一些暗示。
- en: Coverage and dependency graph
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖率和依赖图
- en: The dependency graph told us that the `data` package had lots of users. The
    test coverage told us that it was also one of the biggest packages we had. We
    can, therefore, infer that if we wanted to make improvements, this might be the
    right place to start.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖图告诉我们，`data`包有很多用户。测试覆盖率告诉我们，它也是我们拥有的最大的包之一。因此，我们可以推断，如果我们想要做改进，这可能是开始的合适地方。
- en: As you may remember from earlier chapters, the `data` package uses functions
    and a global singleton pool, both of which caused us inconvenience. So, let's
    see if we can use JIT injection to get rid of these pain points.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得之前章节提到的，`data`包使用了函数和全局单例池，这两者都给我们带来了不便。因此，让我们看看是否可以使用JIT注入来摆脱这些痛点。
- en: Chasing away the monkeys
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赶走猴子
- en: 'Here is how the `get` package currently uses the `data` package:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`get`包目前如何使用`data`包的方式：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our first change will be to define an interface that will replace our `loader`
    function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个改变将是定义一个接口，用它来替换我们的`loader`函数：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You may have noticed we dropped the config parameter. By the time we are done,
    we will not have to pass this in with every call. I have also added a `go generate`
    comment, which will create a mock that we will use later.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们删除了配置参数。等我们完成后，我们将不必在每次调用时传递这个参数。我还添加了一个`go generate`注释，它将创建一个我们以后会使用的模拟。
- en: 'Next, we add this dependency as a private member variable and update our `Do()`
    method to use JIT injection:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将将这个依赖作为私有成员变量添加，并更新我们的`Do()`方法以使用JIT注入：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'But what will our JIT injection `getter` method look like? The basic structure
    will be standard, as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们的JIT注入`getter`方法会是什么样子呢？基本结构将是标准的，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because the `data` package was implemented as functions, we currently don't
    have anything that implements our `loader` interface. Our code and unit tests
    are now broken, so we are going to have to fly blind for a little bit while we
    get them working again.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`data`包是以函数实现的，我们目前没有任何实现我们的`loader`接口的东西。我们的代码和单元测试现在都出问题了，所以在我们让它们再次工作之前，我们将不得不盲目行事一段时间。
- en: 'The shortest path to getting our code working again is to define ourselves
    a **data access object** (**DAO**). This will replace the functions in our `data`
    package with a struct and give us something that implements our `myLoader` interface.
    To make the minimum number of changes, we will have the DAO methods call the existing
    functions as shown in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义一个**数据访问对象**（**DAO**），这是让我们的代码再次工作的最短路径。这将用一个结构体替换`data`包中的函数，并给我们一个实现`myLoader`接口的东西。为了尽量减少更改，我们将让DAO方法调用现有的函数，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Even after adding the DAO into our `getLoader()` function, our tests are still
    not restored. Our tests are still using monkey patching so we will need to remove
    that code and replace it with a mock, giving us the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在我们将DAO添加到`getLoader()`函数中后，我们的测试仍然没有恢复。我们的测试仍然使用了Monkey Patching，因此我们需要删除该代码并用一个模拟替换它，得到以下结果：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, our tests are working again. With these refactorings, we have also
    achieved a few other improvements:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的测试又可以工作了。通过这些重构，我们还实现了一些其他的改进：
- en: Our `get` package tests no longer use monkey patching; this means we can be
    sure there are no monkey patching related concurrency issues
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`get`包的测试不再使用Monkey Patching；这意味着我们可以确定没有与Monkey Patching相关的并发问题
- en: Other than the data struct (`data.Person`), the `get` package tests no longer
    use the `data` package
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了数据结构（`data.Person`）之外，`get`包的测试不再使用`data`包
- en: Perhaps most significantly, the `get` package tests no longer require the database
    to be configured
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许最重要的是，`get`包的测试不再需要配置数据库
- en: With our planned changes to the `get` package complete, we can move over to
    the `data` package.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 完成`get`包的计划更改后，我们可以转移到`data`包。
- en: Earlier, we defined a DAO where our `Load()` method called the existing `Load()`
    function. As there are no more users of the `Load()` function, we can simply copy
    the code over and update the corresponding tests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们定义了一个DAO，其中我们的`Load()`方法调用了现有的`Load()`函数。由于`Load()`函数没有更多的用户，我们可以简单地复制代码并更新相应的测试。
- en: After repeating this simple process for the rest of the `data` package and its
    users, we are able to successfully migrate away from a function-based package
    to an object-based one.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在为`data`包及其用户重复这个简单的过程之后，我们成功地迁移到了基于对象的包，而不是基于函数的包。
- en: Optional public dependencies
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选的公共依赖项
- en: So far, we've applied JIT dependency injection to private dependencies with
    the goal of reducing the parameters and making our `data` package more straightforward
    to use.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将JIT依赖注入应用于私有依赖项，目标是减少参数，并使我们的`data`包更加简单易用。
- en: There is another way to use JIT injection—optional public dependencies. These
    dependencies are public as we want users to be able to change them but we do not
    make them, part of the constructor because they are optional. Doing so would detract
    from the UX, especially in cases where the optional dependency is seldom used.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种使用JIT注入的方式——可选的公共依赖项。这些依赖项是公共的，因为我们希望用户能够更改它们，但我们不将它们作为构造函数的一部分，因为它们是可选的。这样做会影响用户体验，特别是在可选依赖项很少使用的情况下。
- en: Imagine we were having a performance problem with the *Load all registrations* endpoint
    of our service and we suspected the problem was related to the responsiveness
    of the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在服务的*加载所有注册*端点遇到性能问题，并且我们怀疑问题与数据库的响应速度有关。
- en: Faced with such a problem, we decide that we need to track how long these queries
    took by adding some instrumentation. To ensure that we are able to turn this tracker
    on and off easily, we could make it an optional dependency.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 面对这样的问题，我们决定需要通过添加一些仪器来跟踪这些查询花费了多长时间。为了确保我们能够轻松地打开和关闭这个跟踪器，我们可以将其作为可选依赖项。
- en: 'Our first step would be to define our `tracker` interface:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步将是定义我们的`tracker`接口：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have a decision to make. The use of `QueryTracker` is optional, and this
    means that users are not guaranteed to have injected the dependency.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做出决定。使用`QueryTracker`是可选的，这意味着用户不能保证已注入依赖项。
- en: To avoid guard clauses wherever `QueryTracker` is used, we are going to introduce
    a NO-OP implementation that can be used when the user did not supply one. A NO-OP
    implementation, sometimes called a **null object**, is an object that implements
    an interface but where all the methods intentionally do nothing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在使用`QueryTracker`时出现守卫子句，我们将引入一个NO-OP实现，当用户没有提供时可以使用。NO-OP实现，有时被称为**空对象**，是一个实现接口但所有方法都故意不执行任何操作的对象。
- en: 'Here is the NO-OP implementation of `QueryTracker`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`QueryTracker`的NO-OP实现：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can introduce it to our DAO as a public member variable:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将其引入到我们的DAO作为一个公共成员变量：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And we can use JIT injection to access the tracker, which defaults to the NO-OP
    version:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用JIT注入来访问默认为NO-OP版本的跟踪器：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that everything is in place, we can add the following lines to the beginning
    of any method we want to track:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切就绪，我们可以在想要跟踪的任何方法的开头添加以下行：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: An interesting thing to note here is the use of `defer`. Basically, `defer`
    has two significant features that we are using here. Firstly, it will be called
    whenever the function exits, allowing us to add the tracker once, instead of next
    to every return statement. Secondly, the parameters of `defer` are determined
    at the time the line is encountered, and not the time they are executed. This
    means the value of `time.Now()` will be called at the start of the function we
    are tracking and not when the `Track()` function returns.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的是`defer`的使用。基本上，`defer`在这里有两个重要的特性。首先，它将在函数退出时被调用，这样我们可以一次添加跟踪器，而不是在每个返回语句旁边添加。其次，`defer`的参数是在遇到该行时确定的，而不是在执行时确定的。这意味着`time.Now()`的值将在我们跟踪的函数开始时调用，而不是在`Track()`函数返回时调用。
- en: 'For our tracker to be of use, we need to provide an implementation other than
    the NO-OP. We could push these values to an external system like StatsD or Graphite,
    but for simplicity we will output the results to the log. The code for this is
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的跟踪器有用，我们需要提供除了NO-OP之外的实现。我们可以将这些值推送到像StatsD或Graphite这样的外部系统，但为了简单起见，我们将结果输出到日志。代码如下：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we can temporarily update our DAO usage from this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以暂时将我们的DAO使用从这个更新为：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And update it to this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新为：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Yes, the line is kind of ugly, but luckily it's only temporary. If we decided
    to make our QueryTracker permanent or found ourselves using it most of the time,
    then we could switch over to constructor injection pretty easily.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这行有点丑，但幸运的是它只是临时的。如果我们决定让我们的QueryTracker永久存在，或者发现自己大部分时间都在使用它，那么我们可以很容易地切换到构造函数注入。
- en: Disadvantages of JIT injection
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JIT注入的缺点
- en: 'While JIT injection can be handy, it cannot be used in all scenarios, and there
    are a few gotchas to be wary of. These include the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JIT注入可能很方便，但并非在所有情况下都可以使用，而且有一些需要注意的地方。其中包括以下内容：
- en: '**Can only be applied to static dependencies**—The first and perhaps most significant
    disadvantage is that this method can only be applied to dependencies that only
    change during testing. We cannot use it to replace parameter injection or config
    injection. This is caused by the fact that dependency instantiation happens inside
    a private method and only on the first attempt to access the variable.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**只能应用于静态依赖项**-第一个，也许是最重要的缺点是，这种方法只能应用于在测试期间只发生变化的依赖项。我们不能用它来替代参数注入或配置注入。这是因为依赖项的实例化发生在私有方法内部，只在第一次尝试访问变量时发生。'
- en: '**Dependency and user life cycles are not separated**—When using constructor
    injection or parameter injection, it''s often safe to assume the dependency being
    injected is fully initialized and ready for use. Any costs or delays, like those
    related to creating resource pools or preloading data, will have already been
    paid. With JIT injection, the dependency is created immediately before the first
    use. As such, any initialization cost has to be paid by that first request. The
    following diagram shows a typical interaction between three objects (a caller,
    a callee, and a data store):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖和用户生命周期没有分开**-当使用构造函数注入或参数注入时，通常可以假定被注入的依赖已经完全初始化并准备就绪。任何成本或延迟，比如与创建资源池或预加载数据相关的成本，都已经支付。使用JIT注入时，依赖项会在第一次使用之前立即创建。因此，任何初始化成本都必须由第一个请求支付。下图显示了三个对象之间的典型交互（调用者、被调用者和数据存储）：'
- en: '![](img/8535fb3c-c845-4c66-bace-3e0bd77e620c.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8535fb3c-c845-4c66-bace-3e0bd77e620c.png)'
- en: 'Now, compare that with the interaction when the data store object is created
    during the call:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将其与在调用期间创建数据存储对象时的交互进行比较：
- en: '![](img/e1e57d5a-3105-447a-bbb5-04443b79754d.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1e57d5a-3105-447a-bbb5-04443b79754d.png)'
- en: You can see the additional time (cost) that is incurred in the second diagram.
    These costs do not happen in most cases as creating objects in Go is fast. However,
    when they do exist, they can cause some unintended or inconvenient behavior during
    application startup.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到第二个图中产生的额外时间（成本）。在大多数情况下，这些成本并不会发生，因为在Go中创建对象很快。但是，当它们存在时，它们可能会在应用程序启动期间导致一些意外或不便的行为。
- en: 'Another downside in cases like the one previously mentioned, where the state
    of the dependency is uncertain, exists in the resulting code. Consider the following
    code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在像前面提到的那种情况下，依赖项的状态不确定，导致生成的代码存在另一个缺点。考虑以下代码：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Compare the previous code with the same code where the dependency is guaranteed
    to be in a *ready* state:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码与保证依赖项处于*就绪*状态的相同代码进行比较：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is only a few lines of code, sure, but it's vastly simpler to read and
    therefore maintain. It was also a lot easier to implement and test.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是几行代码，当然，它要简单得多，因此更易于阅读和维护。它也更容易实现和测试。
- en: '**Potential data and initialization races**—Similar to the previous point,
    this one also revolves around the initialization of the dependency. In this case,
    however, the issues are related to accessing the dependency itself. Let''s return
    to our earlier example of a connection pool but change how the instantiation occurs:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**潜在的数据和初始化竞争**-与前一点类似，这一点也围绕着依赖项的初始化。然而，在这种情况下，问题与访问依赖项本身有关。让我们回到前面关于连接池的例子，但改变实例化的方式：'
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, this constructor of the connection pool will not return until
    after the pool is fully initialized. So, what happens when another call to the
    `getConnectionPool()` occurs while the initialization is happening?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，连接池的构造函数在池完全初始化之前不会返回。那么，在初始化正在进行时再次调用`getConnectionPool()`会发生什么？
- en: 'We could end up creating two connection pools. This diagram shows this interaction:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会创建两个连接池。这张图显示了这种交互：
- en: '![](img/3e44b2f3-dba6-4ff4-9b04-6ab877ba0f3e.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e44b2f3-dba6-4ff4-9b04-6ab877ba0f3e.png)'
- en: So, what happens to the other connection pool? It will be orphaned. All CPU
    spent on creating it is wasted, and it’s even possible that it does not get cleaned
    up properly by the garbage collector; so any resources such as memory, file handles,
    or network ports could be lost.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，另一个连接池会发生什么？它将被遗弃。用于创建它的所有CPU都是浪费的，甚至可能无法被垃圾收集器正确清理；因此，任何资源，如内存、文件句柄或网络端口，都可能丢失。
- en: 'There is a simple way to ensure that this issue is avoided but it comes with
    a very minor cost. We can use the sync package from the `standard` library. There
    are several nice options from this package, but in this case I recommend `Once()`.
    By adding `Once()` to our `getConnectionPool()` method, we get this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种简单的方法可以确保避免这个问题，但它会带来非常小的成本。我们可以使用`standard`库中的sync包。这个包有几个不错的选项，但在这种情况下，我建议使用`Once()`。通过将`Once()`添加到我们的`getConnectionPool()`方法中，我们得到了这个：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are two minor costs associated with this approach. The first is the added
    complexity to the code; it's minor, but it does exist.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个小成本。第一个是代码的复杂性增加；这很小，但确实存在。
- en: The second is that every call to `getConnectionPool()`, of which there could
    be many, will check `Once()` to see whether it is the first call. This is an incredibly
    small cost, but, depending on your performance requirements, it could be inconvenient.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个成本是对`getConnectionPool()`的每次调用，可能有很多次，都会检查`Once()`，看它是否是第一次调用。这是一个非常小的成本，但根据您的性能要求，可能会不方便。
- en: '**Objects are not entirely decoupled**—Throughout this book, we''ve used the
    dependency graph to identify potential issues, particularly regarding the relationships
    between packages, and in some cases the over-dependence on particular packages.
    While we can and should still use the *Dependency inversion principle* section
    from [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID Design Principles
    for Go*, and define our dependency as a local interface, by including the dependency''s
    creation in our code, the dependency graph will still show the relationship between
    our package and the dependency. In a way, our object is still somewhat coupled
    to our dependency.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象并非完全解耦**-在整本书中，我们使用依赖图来识别潜在问题，特别是关于包之间的关系，以及在某些情况下对特定包的过度依赖。虽然我们仍然可以并且应该使用[第2章](53a15217-38a7-4622-9242-a57fe46335ec.xhtml)中的*依赖反转原则*部分，*Go的SOLID设计原则*，并将我们的依赖定义为本地接口，但通过在我们的代码中包含依赖的创建，依赖图仍将显示我们的包与依赖之间的关系。在某种程度上，我们的对象仍然与我们的依赖有些耦合。'
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used JIT injection, a somewhat unusual DI method, to remove
    some of the monkey patching from earlier chapters.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了JIT注入，这是一种不太常见的DI方法，以消除前几章中的一些猴子补丁。
- en: We also used a different form of JIT injection to add an optional dependency,
    without detracting from the UX of our code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了不同形式的JIT注入来添加可选依赖项，而不会影响我们代码的用户体验。
- en: Additionally, we examined how JIT injection can also be used to reduce test-induced
    damage, without sacrificing our ability to use mocks and stubs in our tests.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还研究了JIT注入如何用于减少测试引起的损害，而不牺牲我们在测试中使用模拟和存根的能力。
- en: In the next chapter, we will examine the last DI method in the book, off-the-shelf
    injection. We will discuss the general advantages and disadvantages of adopting
    a DI framework, and for our examples we will use Google's Wire framework.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究本书中的最后一个DI方法，即现成的注入。我们将讨论采用DI框架的一般优缺点，并且在我们的示例中，我们将使用Google的Wire框架。
- en: Questions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does JIT injection differ from constructor injection?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JIT注入与构造函数注入有何不同？
- en: When working with optional dependencies, why is using a NO-OP implementation
    important?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理可选依赖关系时，为什么使用NO-OP实现很重要？
- en: What are the ideal use cases for JIT injection?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JIT注入的理想用例是什么？
