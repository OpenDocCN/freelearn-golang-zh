["```go\n// Provider\nfunc ProvideFetcher() *Fetcher {\n   return &Fetcher{}\n}\n\n// Object being \"provided\"\ntype Fetcher struct {\n}\n\nfunc (f *Fetcher) GoFetch() (string, error) {\n```", "```go\nreturn \"\", errors.New(\"not implemented yet\")\n}\n```", "```go\nfunc ProvideFetcher(cache *Cache) *Fetcher {\n   return &Fetcher{\n      cache: cache,\n   }\n}\n```", "```go\nfunc ProvideCache() (*Cache, error) {\n   cache := &Cache{}\n\n   err := cache.Start()\n   if err != nil {\n      return nil, err\n   }\n\n   return cache, nil\n}\n```", "```go\nfunc initializeServer() (*rest.Server, error) {\n wire.Build(wireSet)\n return nil, nil\n}\n```", "```go\nfunc initializeServer() (*rest.Server, error) {\n   configConfig, err := config.Load()\n   if err != nil {\n      return nil, err\n   }\n   getter := get.NewGetter(configConfig)\n   lister := list.NewLister(configConfig)\n   converter := exchange.NewConverter(configConfig)\n   registerer := register.NewRegisterer(configConfig, converter)\n   server := rest.New(configConfig, getter, lister, registerer)\n   return server, nil\n}\n```", "```go\nfunc initializeServer() (*rest.Server, error) {\n   wire.Build(wireSet)\n   return nil, nil\n}\n```", "```go\nfunc initializeServer() (*rest.Server, error) {\n   wire.Build(\n      // *config.Config\n      config.Load,\n\n      // *exchange.Converter\n      wire.Bind(new(exchange.Config), &config.Config{}),\n      exchange.NewConverter,\n\n      // *get.Getter\n      wire.Bind(new(get.Config), &config.Config{}),\n      get.NewGetter,\n\n      // *list.Lister\n      wire.Bind(new(list.Config), &config.Config{}),\n      list.NewLister,\n\n      // *register.Registerer\n      wire.Bind(new(register.Config), &config.Config{}),\n      wire.Bind(new(register.Exchanger), &exchange.Converter{}),\n      register.NewRegisterer,\n\n      // *rest.Server\n      wire.Bind(new(rest.Config), &config.Config{}),\n      wire.Bind(new(rest.GetModel), &get.Getter{}),\n      wire.Bind(new(rest.ListModel), &list.Lister{}),\n      wire.Bind(new(rest.RegisterModel), &register.Registerer{}),\n      rest.New,\n   )\n\n   return nil, nil\n}\n```", "```go\nfunc main() {\n   // bind stop channel to context\n   ctx := context.Background()\n\n   // build the exchanger\n   exchanger := exchange.NewConverter(config.App)\n\n   // build model layer\n   getModel := get.NewGetter(config.App)\n   listModel := list.NewLister(config.App)\n   registerModel := register.NewRegisterer(config.App, exchanger)\n\n   // start REST server\n   server := rest.New(config.App, getModel, listModel, registerModel)\n   server.Listen(ctx.Done())\n}\n```", "```go\nfunc main() {\n   // bind stop channel to context\n   ctx := context.Background()\n\n   // start REST server\n   server, err := initializeServer()\n   if err != nil {\n      os.Exit(-1)\n   }\n\n   server.Listen(ctx.Done())\n}\n\n```", "```go\nfunc initializeServer() (*rest.Server, error) {\n   wire.Build(wireSet)\n   return nil, nil\n}\n```", "```go\nfunc main() {\n   // bind stop channel to context\n   ctx := context.Background()\n\n   // build DIG container\n   container := BuildContainer()\n\n   // start REST server\n   err := container.Invoke(func(server *rest.Server) {\n      server.Listen(ctx.Done())\n   })\n\n   if err != nil {\n      os.Exit(-1)\n   }\n}\n```", "```go\nfunc NewGetPersonHandler(model *GetPersonModel) *GetPersonHandler {\n   return &GetPersonHandler{\n      model: model,\n   }\n}\n\ntype GetPersonHandler struct {\n   model *GetPersonModel\n}\n\nfunc (g *GetPersonHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n   response.WriteHeader(http.StatusInternalServerError)\n   response.Write([]byte(`not implemented yet`))\n}\n```", "```go\nfunc NewGetPersonModel(db *sql.DB) *GetPersonModel {\n   return &GetPersonModel{\n      db: db,\n   }\n}\n\ntype GetPersonModel struct {\n   db *sql.DB\n}\n\nfunc (g *GetPersonModel) LoadByID(ID int) (*Person, error) {\n   return nil, errors.New(\"not implemented yet\")\n}\n\ntype Person struct {\n   Name string\n}\n```", "```go\nfunc ProvideHandler(model *GetPersonModel) *GetPersonHandler {\n   return &GetPersonHandler{\n      model: model,\n   }\n}\n```", "```go\n// App is the application config\nvar App *Config\n\n// Load returns the config loaded from environment\nfunc init() {\n   filename, found := os.LookupEnv(DefaultEnvVar)\n   if !found {\n      logging.L.Error(\"failed to locate file specified by %s\", DefaultEnvVar)\n      return\n   }\n\n   _ = load(filename)\n}\n\nfunc load(filename string) error {\n   App = &Config{}\n   bytes, err := ioutil.ReadFile(filename)\n   if err != nil {\n      logging.L.Error(\"failed to read config file. err: %s\", err)\n      return err\n   }\n\n   err = json.Unmarshal(bytes, App)\n   if err != nil {\n      logging.L.Error(\"failed to parse config file. err : %s\", err)\n      return err\n   }\n\n   return nil\n}\n```", "```go\n// Load returns the config loaded from environment\nfunc Load() (*Config, error) {\n   filename, found := os.LookupEnv(DefaultEnvVar)\n   if !found {\n      err := fmt.Errorf(\"failed to locate file specified by %s\", DefaultEnvVar)\n      logging.L.Error(err.Error())\n      return nil, err\n   }\n\n   cfg, err := load(filename)\n   if err != nil {\n      logging.L.Error(\"failed to load config with err %s\", err)\n      return nil, err\n   }\n\n   return cfg, nil\n}\n```", "```go\nfunc main() {\n   // bind stop channel to context\n   ctx := context.Background()\n\n   // load config\n   cfg, err := config.Load(config.DefaultEnvVar)\n   if err != nil {\n      os.Exit(-1)\n   }\n\n   // build the exchanger\n   exchanger := exchange.NewConverter(cfg)\n\n   // build model layer\n   getModel := get.NewGetter(cfg)\n   listModel := list.NewLister(cfg)\n   registerModel := register.NewRegisterer(cfg, exchanger)\n\n   // start REST server\n   server := rest.New(cfg, getModel, listModel, registerModel)\n   server.Listen(ctx.Done())\n}\n```", "```go\n//+build myTag\n\npackage main\n\n```", "```go\n$ go build -tags myTag\n```", "```go\n//+build !myTag\n\npackage main\n\n```", "```go\n//+build wireinject\n\npackage main\n\nimport (\n   \"github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/ch10/acme/internal/config\"\n   \"github.com/google/go-cloud/wire\"\n)\n\n// The build tag makes sure the stub is not built in the final build.\n\nfunc initializeConfig() (*config.Config, error) {\n   wire.Build(config.Load)\n   return nil, nil\n}\n```", "```go\n// Code generated by Wire. DO NOT EDIT.\n\n//go:generate wire\n//+build !wireinject\n\npackage main\n\nimport (\n   \"github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/ch10/acme/internal/config\"\n)\n\n// Injectors from wire.go:\n\nfunc initializeConfig() (*config.Config, error) {\n   configConfig, err := config.Load()\n   if err != nil {\n      return nil, err\n   }\n   return configConfig, nil\n}\n```", "```go\nfunc main() {\n   // bind stop channel to context\n   ctx := context.Background()\n\n   // load config\n   cfg, err := initializeConfig()\n   if err != nil {\n      os.Exit(-1)\n   }\n\n   // build the exchanger\n   exchanger := exchange.NewConverter(cfg)\n\n   // build model layer\n   getModel := get.NewGetter(cfg)\n   listModel := list.NewLister(cfg)\n   registerModel := register.NewRegisterer(cfg, exchanger)\n\n   // start REST server\n   server := rest.New(cfg, getModel, listModel, registerModel)\n   server.Listen(ctx.Done())\n}\n```", "```go\n// List of wire enabled objects\nvar wireSet = wire.NewSet(\n   // *config.Config\n   config.Load,\n\n   // *exchange.Converter\n   wire.Bind(new(exchange.Config), &config.Config{}),\n   exchange.NewConverter,\n)\n```", "```go\n// NewConverter creates and initializes the converter\nfunc NewConverter(cfg Config) *Converter {\n   return &Converter{\n      cfg: cfg,\n   }\n}\n```", "```go\nfunc initializeConfig() (*config.Config, error) {\n   wire.Build(wireSet)\n   return nil, nil\n}\n\nfunc initializeExchanger() (*exchange.Converter, error) {\n   wire.Build(wireSet)\n   return nil, nil\n}\n```", "```go\nfunc main() {\n   // bind stop channel to context\n   ctx := context.Background()\n\n   // load config\n   cfg, err := initializeConfig()\n   if err != nil {\n      os.Exit(-1)\n   }\n\n   // build model layer\n   getModel, _ := initializeGetter()\n   listModel, _ := initializeLister()\n   registerModel, _ := initializeRegisterer()\n\n   // start REST server\n   server := rest.New(cfg, getModel, listModel, registerModel)\n   server.Listen(ctx.Done())\n}\n\n// List of wire enabled objects\nvar wireSet = wire.NewSet(\n   // *config.Config\n   config.Load,\n\n   // *exchange.Converter\n   wire.Bind(new(exchange.Config), &config.Config{}),\n   exchange.NewConverter,\n\n   // *get.Getter\n   wire.Bind(new(get.Config), &config.Config{}),\n   get.NewGetter,\n\n   // *list.Lister\n   wire.Bind(new(list.Config), &config.Config{}),\n   list.NewLister,\n\n   // *register.Registerer\n   wire.Bind(new(register.Config), &config.Config{}),\n   wire.Bind(new(register.Exchanger), &exchange.Converter{}),\n   register.NewRegisterer,\n)\n```", "```go\n// List of wire enabled objects\nvar wireSet = wire.NewSet(\n   // lines omitted\n\n   // *rest.Server\n   wire.Bind(new(rest.Config), &config.Config{}),\n   wire.Bind(new(rest.GetModel), &get.Getter{}),\n   wire.Bind(new(rest.ListModel), &list.Lister{}),\n   wire.Bind(new(rest.RegisterModel), &register.Registerer{}),\n   rest.New,\n)\n```", "```go\nfunc initializeServer() (*rest.Server, error) {\n   wire.Build(wireSet)\n   return nil, nil\n}\n```", "```go\nfunc main() {\n   // bind stop channel to context\n   ctx := context.Background()\n\n   // start REST server\n   server, err := initializeServer()\n   if err != nil {\n      os.Exit(-1)\n   }\n\n   server.Listen(ctx.Done())\n}\n```", "```go\nfunc initializeServer() (*rest.Server, error) {\n   configConfig, err := config.Load()\n   if err != nil {\n      return nil, err\n   }\n   getter := get.NewGetter(configConfig)\n   lister := list.NewLister(configConfig)\n   converter := exchange.NewConverter(configConfig)\n   registerer := register.NewRegisterer(configConfig, converter)\n   server := rest.New(configConfig, getter, lister, registerer)\n   return server, nil\n}\n```", "```go\n// load the standard config (from the ENV)\ncfg, err := config.Load()\nrequire.NoError(t, err)\n```", "```go\nfunc getFreePort() (string, error) {\n   for attempt := 0; attempt <= 10; attempt++ {\n      addr := net.JoinHostPort(\"\", \"0\")\n      listener, err := net.Listen(\"tcp\", addr)\n      if err != nil {\n         continue\n      }\n\n      port, err := getPort(listener.Addr())\n      if err != nil {\n         continue\n      }\n\n      // close/free the port\n      tcpListener := listener.(*net.TCPListener)\n      cErr := tcpListener.Close()\n      if cErr == nil {\n         file, fErr := tcpListener.File()\n         if fErr == nil {\n            // ignore any errors cleaning up the file\n            _ = file.Close()\n         }\n         return port, nil\n      }\n   }\n\n   return \"\", errors.New(\"no free ports\")\n}\n```", "```go\n// get a free port (so tests can run concurrently)\nport, err := getFreePort()\nrequire.NoError(t, err)\n\n// override config port with free one\ncfg.Address = net.JoinHostPort(\"0.0.0.0\", port)\n```", "```go\n// start REST server\nserver, err := initializeServer()\nif err != nil {\n   os.Exit(-1)\n}\n\nserver.Listen(ctx.Done())\n```", "```go\nvar wireSetWithoutConfig = wire.NewSet(\n   // *exchange.Converter\n   exchange.NewConverter,\n\n   // *get.Getter\n   get.NewGetter,\n\n   // *list.Lister\n   list.NewLister,\n\n   // *register.Registerer\n   wire.Bind(new(register.Exchanger), &exchange.Converter{}),\n   register.NewRegisterer,\n\n   // *rest.Server\n   wire.Bind(new(rest.GetModel), &get.Getter{}),\n   wire.Bind(new(rest.ListModel), &list.Lister{}),\n   wire.Bind(new(rest.RegisterModel), &register.Registerer{}),\n   rest.New,\n)\n```", "```go\nvar wireSet = wire.NewSet(\n   wireSetWithoutConfig,\n\n   // *config.Config\n   config.Load,\n\n   // *exchange.Converter\n   wire.Bind(new(exchange.Config), &config.Config{}),\n\n   // *get.Getter\n   wire.Bind(new(get.Config), &config.Config{}),\n\n   // *list.Lister\n   wire.Bind(new(list.Config), &config.Config{}),\n\n   // *register.Registerer\n   wire.Bind(new(register.Config), &config.Config{}),\n\n   // *rest.Server\n   wire.Bind(new(rest.Config), &config.Config{}),\n)\n```", "```go\nfunc initializeServerCustomConfig(_ exchange.Config, _ get.Config, _ list.Config, _ register.Config, _ rest.Config) *rest.Server {\n   wire.Build(wireSetWithoutConfig)\n   return nil\n}\n```", "```go\n// start the test server on a random port\ngo func() {\n   // start REST server\n   server := initializeServerCustomConfig(cfg, cfg, cfg, cfg, cfg)\n   server.Listen(ctx.Done())\n}()\n```", "```go\nfunc startTestServer(t *testing.T, ctx context.Context) string {\n   // load the standard config (from the ENV)\n   cfg, err := config.Load()\n   require.NoError(t, err)\n\n   // get a free port (so tests can run concurrently)\n   port, err := getFreePort()\n   require.NoError(t, err)\n\n   // override config port with free one\n   cfg.Address = net.JoinHostPort(\"0.0.0.0\", port)\n\n   // start the test server on a random port\n   go func() {\n      // start REST server\n      server := initializeServerCustomConfig(cfg, cfg, cfg, cfg, cfg)\n      server.Listen(ctx.Done())\n   }()\n\n   // give the server a chance to start\n   <-time.After(100 * time.Millisecond)\n\n   // return the address of the test server\n   return \"http://\" + cfg.Address\n}\n```", "```go\n// start a context with a max execution time\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n\n// start test server\nserverAddress := startTestServer(t, ctx)\n```", "```go\n    // build and send request\n   payload := bytes.NewBufferString(`\n{\n   \"fullName\": \"Bob\",\n   \"phone\": \"0123456789\",\n   \"currency\": \"AUD\"\n}\n`)\n\n   req, err := http.NewRequest(\"POST\", serverAddress+\"/person/register\", payload)\n   require.NoError(t, err)\n\n   resp, err := http.DefaultClient.Do(req)\n   require.NoError(t, err)\n```", "```go\nfunc TestRegister(t *testing.T) {\n   // start a context with a max execution time\n   ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n   defer cancel()\n\n   // start test server\n   serverAddress := startTestServer(t, ctx)\n\n   // build and send request\n   payload := bytes.NewBufferString(`\n{\n   \"fullName\": \"Bob\",\n   \"phone\": \"0123456789\",\n   \"currency\": \"AUD\"\n}\n`)\n\n   req, err := http.NewRequest(\"POST\", serverAddress+\"/person/register\", payload)\n   require.NoError(t, err)\n\n   resp, err := http.DefaultClient.Do(req)\n   require.NoError(t, err)\n\n   // validate expectations\n   assert.Equal(t, http.StatusCreated, resp.StatusCode)\n   assert.NotEmpty(t, resp.Header.Get(\"Location\"))\n}\n```"]