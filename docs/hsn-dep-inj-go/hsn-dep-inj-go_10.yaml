- en: Off-the-Shelf Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现成注入
- en: For our final chapter in this section, we are looking at **dependency injection**
    (**DI**) using a framework. Choosing a DI framework that matches your preferred
    style can make your life significantly easier. Even if you prefer not to use a
    framework, examining how it is implemented and the approach it takes can be informative
    and help you find improvements for your preferred implementation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后一章中，我们将使用框架来进行**依赖注入**（**DI**）。选择与您首选风格相匹配的DI框架可以显著地简化您的生活。即使您不喜欢使用框架，研究它的实现方式和方法也可能会有所帮助，并帮助您找到改进您首选实现的方法。
- en: While there are many frameworks available to us, including Facebook's Inject
    ([https://github.com/facebookgo/inject](https://github.com/facebookgo/inject))
    and Uber's Dig ([https://godoc.org/go.uber.org/dig](https://godoc.org/go.uber.org/dig)),
    for our sample service we are going to use Google's Go Cloud Wire ([https://github.com/google/go-cloud/tree/master/wire](https://github.com/google/go-cloud/tree/master/wire)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多可用的框架，包括Facebook的Inject（[https://github.com/facebookgo/inject](https://github.com/facebookgo/inject)）和Uber的Dig（[https://godoc.org/go.uber.org/dig](https://godoc.org/go.uber.org/dig)），但对于我们的示例服务，我们将使用Google的Go
    Cloud Wire（[https://github.com/google/go-cloud/tree/master/wire](https://github.com/google/go-cloud/tree/master/wire)）。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Off-the-shelf injection with Wire
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Wire进行现成的注入
- en: Advantages of off-the-shelf injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现成注入的优点
- en: Applying off-the-shelf injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用现成的注入
- en: Disadvantages of off-the-shelf injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现成注入的缺点
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It would be beneficial to be familiar with the code for our service, which we
    introduced in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction
    to the ACME Registration Service*. This chapter also assumes that you have read
    [Chapter 6](89c75571-2952-40fc-ba19-221b3114461b.xhtml), *Dependency Injection
    with Constructor Injection*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉我们在[第4章](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml)中介绍的服务代码将是有益的，*ACME注册服务简介*。本章还假设您已经阅读了[第6章](89c75571-2952-40fc-ba19-221b3114461b.xhtml)，*构造函数注入的依赖注入*。
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, which is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch10](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch10).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会发现阅读和运行本章的完整代码版本对您有用，该代码版本可在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch10](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch10)上找到。
- en: Instructions to obtain the code and configure the sample service are available
    in the README here: [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 获取代码并配置示例服务的说明在此处的README中可用：[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/)。
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch10/acme`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`ch10/acme`中找到我们的服务代码，并已应用本章的更改。
- en: Off-the-shelf injection with Wire
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Wire进行现成的注入
- en: The Go Cloud project is an initiative that intends to make it easier for application
    developers to deploy cloud applications on any combination of cloud providers
    seamlessly. The integral part of this project is a code generation-based dependency
    injection tool called **Wire**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Go Cloud项目是一个旨在使应用程序开发人员能够轻松在任何组合的云提供商上部署云应用程序的倡议。该项目的重要部分是基于代码生成的依赖注入工具**Wire**。
- en: Wire is a good fit for our example service as it promotes the use of explicit
    instantiation and discourages the use of global variables; just as we attempted
    to achieve in our refactoring in previous chapters. Additionally, Wire uses code
    generation to avoid any performance penalties or code complexity that can result
    from the use of runtime reflection.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Wire非常适合我们的示例服务，因为它提倡显式实例化，并且不鼓励使用全局变量；正如我们在之前的章节中尝试实现的那样。此外，Wire使用代码生成来避免由于运行时反射而导致的性能损失或代码复杂性。
- en: Perhaps the most useful aspect of Wire for us is its simplicity. After we understand
    a few simple concepts, the code we have to write and the code that is generated
    is reasonably straightforward.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，Wire最有用的方面可能是其简单性。一旦我们理解了一些简单的概念，我们需要编写的代码和生成的代码就会相当简单。
- en: Introducing providers
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入提供者
- en: 'The documentation defines a provider as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 文档将提供者定义如下：
- en: '"*A function that can produce a value*."'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: “*可以生成值的函数*。”
- en: For our purposes, we can put it a different way—a provider returns an instance
    of a dependency.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们可以换一种方式说，提供者返回一个依赖项的实例。
- en: 'The simplest form a provider can take is a *simple no argument function*, as
    shown in the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者可以采用的最简单形式是*简单的无参数函数*，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Providers can also indicate that they require dependencies to be injected by
    having parameters like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者还可以通过具有以下参数的方式指示它们需要注入依赖项：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The dependencies (parameters) of this provider must be provided by other providers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此提供者的依赖项（参数）必须由其他提供者提供。
- en: 'Providers can also indicate that they may fail to initialize by returning an
    error, as shown in the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者还可以通过返回错误来指示可能无法初始化，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is important to note that when a provider returns an error, any injector
    that uses the dependency provided must also return an error.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当提供者返回错误时，使用提供的依赖项的任何注入器也必须返回错误。
- en: Understanding injectors
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解注入器
- en: The second concept integral to Wire is injectors. Injectors are where the magic
    happens. They are functions that we (developers) define that Wire uses as a base
    for its code generation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Wire中的第二个概念是注入器。注入器是魔术发生的地方。它们是我们（开发人员）定义的函数，Wire将其用作代码生成的基础。
- en: 'For example, if we want to have a function that can create an instance of our
    service''s REST server, including initializing and injecting all the required
    dependencies, we can achieve this with the following function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要一个函数，可以创建我们服务的 REST 服务器的实例，包括初始化和注入所有必需的依赖关系，我们可以通过以下函数实现：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That probably feels like a big sell for such a simple function, especially
    as it does not seem to do anything (that is, `returns nil, nil`). But that is
    all we need to write; the code generator will turn it into the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对于这样一个简单的函数来说感觉很大，尤其是因为它似乎没有做任何事情（即 `返回 nil, nil`）。但这就是我们需要写的全部；代码生成器将把它转换成以下内容：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will go into this in more detail in the *Applying* section, but for now there
    are three features of the aforementioned function to remember. Firstly, the generator
    does not care about the implementation of the function, except that the function
    must include a `wire.Build(wireSet)` call. Secondly, the function must return
    the concrete type that we are planning to use. And lastly, if we rely on any providers
    that return an error, then the injector must also return an error.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *应用* 部分更详细地讨论这一点，但现在有三个上述函数的特点要记住。首先，生成器不关心函数的实现，除了函数必须包含一个 `wire.Build(wireSet)`
    调用。其次，函数必须返回我们计划使用的具体类型。最后，如果我们依赖于任何返回错误的提供者，那么注入器也必须返回一个错误。
- en: Adopting provider sets
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用提供者集
- en: 'The last concept that we need to know when using Wire is provider sets. Provider
    sets offer a way to group providers, and this can be helpful when writing injectors.
    Their use is optional; for example, earlier we used a provider set called `wireSet`,
    as shown in the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Wire 时，我们需要了解的最后一个概念是提供者集。提供者集提供了一种将提供者分组的方法，在编写注入器时可以很有帮助。它们的使用是可选的；例如，之前我们使用了一个名为
    `wireSet` 的提供者集，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, we could have passed in all the providers individually, as shown in
    the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以像下面的代码所示，单独传递所有的提供者：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Sadly, the previous example is not contrived. It's taken from our small example
    service.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，前面的例子并不是虚构的。它来自我们的小例子服务。
- en: As you might expect, there are plenty more features in Wire, but at this point
    we have covered enough to get us started.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，Wire 中还有很多更多的功能，但在这一点上，我们已经涵盖了足够让我们开始的内容。
- en: Advantages of off-the-shelf injection
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现成注入的优势
- en: While we have been talking specifically about Wire so far in this chapter, I
    would like to take a moment to discuss the advantages of off-the-shelf injection
    in a more general sense. When evaluating a tool or framework, it's essential to
    cast a critical eye over the advantages, disadvantages, and effects on your code
    that it may have.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然到目前为止在本章中我们一直在讨论 Wire，但我想花点时间讨论现成注入的优势。在评估工具或框架时，审视它可能具有的优势、劣势和对代码的影响是至关重要的。
- en: Some of the possible advantages of off-the-shelf injection include the following.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现成注入的一些可能优势包括以下。
- en: '**A reduction in boilerplate code**—After applying constructor injection to
    a program, it''s common that the `main()` function becomes bloated with the instantiation
    of objects. As the project grows, so does `main()`. While this does not impact
    the performance of the program, it does become inconvenient to maintain.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少样板代码**—将构造函数注入应用到程序后，`main()` 函数通常会因对象的实例化而变得臃肿。随着项目的增长，`main()` 也会增长。虽然这不会影响程序的性能，但维护起来会变得不方便。'
- en: 'Many dependency injection frameworks aim to either remove this code or move
    it elsewhere. As we will see, this is `main()` for our sample service before adopting
    Google Wire:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 许多依赖注入框架的目标要么是删除这些代码，要么是将其移动到其他地方。正如我们将看到的，这是在采用 Google Wire 之前我们示例服务的 `main()`：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And this is `main()` after adopting Google Wire:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在采用 Google Wire 之后的 `main()`：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And all of the related objection creation is reduced to this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有相关的对象创建都被简化为这样：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because Wire is a code generator, we actually end up with more code, but less
    of it was written or maintained by us. Similarly, if we were to use another popular
    DI framework called **Dig**, `main()` would become this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Wire 是一个代码生成器，实际上我们最终会得到更多的代码，但其中更少的代码是由我们编写或维护的。同样，如果我们使用另一个名为 **Dig** 的流行
    DI 框架，`main()` 将变成这样：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we gain a similar reduction in code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在代码上获得了类似的减少。
- en: '**Automatic instantiation order**—Similar to the previous point, as the project
    grows, so does the complexity of the ordering in which dependencies must be created.
    As such, much of the *magic* provided by off-the-shelf injection frameworks is
    focused on removing this complexity. In both the cases of Wire and Dig, providers
    explicitly define their direct dependencies and ignore any requirements of their
    dependencies.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动实例化顺序**—与前面的观点类似，随着项目的增长，依赖项必须创建的顺序复杂性也会增加。因此，现成注入框架提供的许多 *魔法* 都集中在消除这种复杂性上。在
    Wire 和 Dig 的两种情况下，提供者明确定义它们的直接依赖关系，并忽略它们的依赖项的任何要求。'
- en: 'Consider the following example. Let''s say we have an HTTP handler like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。假设我们有一个像这样的 HTTP 处理程序：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, the handler depends on a model, which looks as shown in the
    following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，处理程序依赖于一个模型，看起来像下面的代码所示：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This model depends on `*sql.DB`. However, when we define the provider for our
    handler, it defines only that it requires `*GetPersonModel` and has no knowledge
    of `*sql.DB`, like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型依赖于 `*sql.DB`。然而，当我们为我们的处理程序定义提供者时，它只定义了它需要 `*GetPersonModel`，并不知道 `*sql.DB`，就像这样：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Compared to the alternative of creating the database, injecting it into a model,
    and then injecting the model into the handler, this is much simpler both to write
    and maintain.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建数据库、将其注入模型，然后将模型注入处理程序的替代方案相比，这样做更简单，无论是在编写还是在维护上。
- en: '**Someone has already done the thinking for you**—Perhaps the least obvious
    but most important advantage a good DI framework can offer is the knowledge of
    its creators. The act of creating and maintaining a framework is definitely a
    non-trivial exercise, and it teaches its authors far more about DI than most programmers
    need to know. This knowledge often results in subtle but useful features appearing
    in the framework. For example, in the Dig framework, by default, all dependencies
    are singletons. This design choice results in performance and resource usage improvements
    as well as a more predictable dependency life cycle.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**有人已经为你考虑过了**——也许一个好的DI框架可以提供的最不明显但最重要的优势是其创建者的知识。创建和维护一个框架的行为绝对不是一个微不足道的练习，它教给了它的作者比大多数程序员需要知道的更多关于DI的知识。这种知识通常会导致框架中出现微妙但有用的特性。例如，在Dig框架中，默认情况下，所有依赖关系都是单例的。这种设计选择导致了性能和资源使用的改进，以及更可预测的依赖关系生命周期。'
- en: Applying off-the-shelf injection
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用现成的注入
- en: As I mentioned in the previous section, by adopting Wire we are hoping to see
    a significant reduction in the code and complexity in `main()`. We are also hoping
    to be able to essentially forget about the instantiation order of the dependencies
    by leaving the framework to handle it for us.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在前一节中提到的，通过采用Wire，我们希望在`main()`中看到代码和复杂性显著减少。我们也希望能够基本上忘记依赖关系的实例化顺序，让框架来为我们处理。
- en: Adopting Google Wire
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用Google Wire
- en: 'The first thing we need to do, however, is to get our house in order. Most,
    if not all, of the objects we are going to let Wire handle use our `*config.Config`
    object, and currently it exists as a global singleton, as shown in the following
    code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要做的第一件事是整理好我们的房子。大多数，如果不是全部，我们要让Wire处理的对象都使用我们的`*config.Config`对象，目前它存在为全局单例，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To change this to a form that Wire can use, we need to delete the global instance
    and change the config loading to a function instead of being triggered by `init()`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其改为Wire可以使用的形式，我们需要删除全局实例，并将配置加载更改为一个函数，而不是由`init()`触发。
- en: 'After a quick look at the uses of our global singleton, it shows that only
    `main()` and a few tests in the `config` package refer to the singleton. Thanks
    to all our previous work, this change is going to be rather straightforward. Here
    is the config loader after refactoring:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看我们的全局单例的用法后，可以看到只有`main()`和`config`包中的一些测试引用了这个单例。由于我们之前的所有工作，这个改变将会非常简单。重构后的配置加载器如下：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And here is our updated `main()`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们更新后的`main()`：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have removed the config global, we are ready to start adopting Google
    Wire.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经移除了配置全局变量，我们准备开始采用Google Wire。
- en: We are going to start by adding a new file; we are naming it `wire.go`. It can
    be called anything, but we need a separate file because we are going to use Go
    build tags to separate the code we write in this file from the version generated
    by Wire.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个新文件；我们将其命名为`wire.go`。它可以被称为任何东西，但我们需要一个单独的文件，因为我们将使用Go构建标签来将我们在这个文件中编写的代码与Wire生成的版本分开。
- en: 'In case you are not familiar with build tags, in Go they are comments at the
    top of the file, before the `package` statement, in this form:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉构建标签，在Go中它们是文件顶部的注释，在`package`语句之前，形式如下：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These tags tell the compiler when or when not to include the file during compilation.
    For example, the aforementioned tag tells the compiler to include this file only
    when the build is triggered, like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签告诉编译器何时包含或不包含文件在编译期间。例如，前面提到的标签告诉编译器仅在触发构建时包含此文件，就像这样：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can also use build tags to do the reverse and make a file that is only included
    when the tag is not specified, like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用构建标签来做相反的事情，使一个文件只在未指定标签时包含，就像这样：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Back to `wire.go`, inside this file we are going to define an injector for
    the config that uses our config loader as a provider, as shown in the following
    code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`wire.go`，在这个文件中，我们将定义一个用于配置的注入器，它使用我们的配置加载器作为提供者，如下所示：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's break down the injector a little more. The function signature defines
    a function that returns an instance of `*config.Config` or an error, which is
    the same as `config.Load()` from earlier.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释一下注入器。函数签名定义了一个返回`*config.Config`实例或错误的函数，这与之前的`config.Load()`是一样的。
- en: The first line of the function calls `wire.Build()` and supplies our provider,
    and the second line returns `nil, nil`. In truth, it does not matter what it returns
    as long as it is valid Go code. The code generator in Wire will read the function
    signature and the `wire.Build()` call only.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一行调用了`wire.Build()`并提供了我们的提供者，第二行返回了`nil, nil`。事实上，它返回什么并不重要，只要它是有效的Go代码。Wire中的代码生成器将读取函数签名和`wire.Build()`调用。
- en: 'Next, we open a Terminal and run `wire` in the directory that contains our `wire.go` file.
    Wire will create a new file for us called `wire_gen.go`, which looks as shown
    in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们打开一个终端，并在包含我们的`wire.go`文件的目录中运行`wire`。Wire将为我们创建一个名为`wire_gen.go`的新文件，其内容如下所示：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You will notice that this file also has a build tag, but it is the opposite
    of the one that we wrote earlier. Wire has copied our `initializeConfig()` method
    and *filled in all the details* for us.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个文件也有一个构建标签，但它与我们之前写的相反。Wire已经复制了我们的`initializeConfig()`方法，并为我们*填写了所有的细节*。
- en: So far, the code is pretty simple and likely to be very similar to what we could
    have written ourselves. You might be tempted to feel like we have not really gained
    much so far. I agree. By the time we convert the rest of our objects over, the
    amount of code and complexity Wire will take care of for us will be significantly
    more.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码非常简单，很可能与我们自己编写的代码非常相似。你可能会觉得到目前为止我们并没有真正获得太多。我同意。当我们将其余的对象转换过来时，Wire将为我们处理的代码和复杂性将会显著增加。
- en: 'To complete this set of changes, we update `main()` to use our `initializeConfig()`
    function like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一系列的更改，我们更新`main()`以使用我们的`initializeConfig()`函数，如下所示：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With config handled, we can move on to the next object, `*exchange.Converter`.
    In the previous examples, we did not use a provider set but instead passed our
    provider directly into the `wire.Build()` call. We are about to add another provider
    so now it''s time to get a little more organized. We will, therefore, add a private
    global variable to `main.go` and add our `Config` and `Converter` providers to
    it, as shown in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 处理配置后，我们可以继续下一个对象，`*exchange.Converter`。在先前的示例中，我们没有使用提供程序集，而是直接将我们的提供程序传递给`wire.Build()`调用。我们即将添加另一个提供程序，所以现在是时候更加有条理了。因此，我们将在`main.go`中添加一个私有全局变量，并将我们的`Config`和`Converter`提供程序添加到其中，如下所示：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, I have also added a `wire.Bind()` call. Wire requires us to
    define or map the concrete types that satisfy an interface so that it is able
    to satisfy them during injection. The constructor for `*exchange.Converter` looks
    like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我还添加了一个`wire.Bind()`调用。Wire要求我们定义或映射满足接口的具体类型，以便在注入期间满足它们。`*exchange.Converter`的构造函数如下所示：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you might remember, this constructor uses config injection and a locally
    defined `Config` interface. However, the actual config object that we inject is
    `*config.Config`. Our `wire.Bind()` call tells Wire that where the `exchange.Config` interface is
    needed use `*config.Config`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，这个构造函数使用配置注入和本地定义的`Config`接口。但是，我们注入的实际配置对象是`*config.Config`。我们的`wire.Bind()`调用告诉Wire，在需要`exchange.Config`接口时使用`*config.Config`。
- en: 'With our provider set in place, we can now update our config injector and add
    an injector for the `Converter` as shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的提供程序集，我们现在可以更新我们的配置注入器，并添加一个`Converter`的注入器，如下所示：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It is important to note that while `exchange.NewConverter()` does not return
    an error, our injector must. This is because of our dependence on the config provider,
    which returns an error. This may sound like a pain to remember but don't worry,
    Wire helps us get it right.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，虽然`exchange.NewConverter()`不会返回错误，但我们的注入器必须。这是因为我们依赖于返回错误的配置提供程序。这可能听起来很麻烦，但不用担心，Wire可以帮助我们做到这一点。
- en: Moving on down our list of objects, we will need to do the same for our model
    layer. The injectors are entirely predictable and almost identical to `*exchange.Converter`,
    as are the changes to our provider set.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的对象列表，我们需要对我们的模型层做同样的事情。注入器是完全可预测的，几乎与`*exchange.Converter`完全相同，提供程序集的更改也是如此。
- en: 'Note that `main()` and the provider set after the changes look as shown in
    the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`main()`和更改后的提供程序集如下所示：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are a couple of things of importance. Firstly, our provider set is getting
    rather long. This is probably OK, as the only changes we are making are to add
    more provider and bind statements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件重要的事情。首先，我们的提供程序集变得相当长。这可能没关系，因为我们所做的唯一更改是添加更多的提供程序和绑定语句。
- en: Secondly, we no longer call `initializeExchanger(),` and we have actually deleted
    that injector. The reason we don't need this anymore is Wire is handling the injection
    into the model layer for us.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们不再调用`initializeExchanger()`，我们实际上已经删除了该注入器。我们不再需要这个的原因是Wire正在为我们处理对模型层的注入。
- en: Lastly, for brevity, I have ignored the errors that could be returned from the
    model layer injectors. This is a bad practice, but don't worry, we will be deleting
    these lines soon after our next set of changes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了简洁起见，我忽略了可能从模型层注入器返回的错误。这是一个不好的做法，但不用担心，我们将在下一组更改后很快删除这些行。
- en: After a quick run of Wire and our tests to make sure everything is still working
    as expected, we are ready to move on to our final object, the REST server.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 快速运行Wire和我们的测试以确保一切仍然按预期工作后，我们准备继续进行最后一个对象，即REST服务器。
- en: 'First, we make the following, perhaps predictable, additions to the provider
    set:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们对提供程序集进行了以下可能可预测的添加：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, we define the injector for our REST server in `wire.go` like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们在`wire.go`中为我们的REST服务器定义注入器，如下所示：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can update `main()` to call only the REST server injector like so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新`main()`，只调用REST服务器注入器，如下所示：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With that done, we can delete all of the injectors except `initializeServer()`,
    then run Wire, and we are done!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以删除除`initializeServer()`之外的所有注入器，然后运行Wire，完成！
- en: 'Now might be a good time to examine the code that Wire generated for us:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能是检查Wire为我们生成的代码的好时机：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Does it look familiar? It's incredibly similar to `main()` before we adopted
    wire.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来熟悉吗？这与我们采用wire之前的`main()`非常相似。
- en: Given that our code was already using constructor injection and our service
    is rather small, it's easy to feel like we did a lot of work for minimal gain.
    If we were adopting Wire from the start, this would definitely not feel this way.
    In our particular case, the benefits are more long term. Now that Wire is handling
    the constructor injection and all the complexity related to instantiation and
    instantiation ordering, all extensions to our service will be a whole lot simpler
    and less prone to human error.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们的代码已经在使用构造函数注入，并且我们的服务相当小，很容易感觉我们为了获得最小的收益而做了很多工作。如果我们从一开始就采用Wire，肯定不会有这种感觉。在我们的特定情况下，好处更多是长期的。现在Wire正在处理构造函数注入以及与实例化和实例化顺序相关的所有复杂性，我们的服务的所有扩展将会更加简单，而且更不容易出现人为错误。
- en: API regression tests
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API回归测试
- en: With our conversion to Wire complete, how do we make sure our service still
    works as we expect?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完成Wire转换后，我们如何确保我们的服务仍然按我们的期望工作？
- en: Our only immediate option is to just run the app and try it. This option might
    be OK for right now, but I don't like it as a long-term option, so let's see if
    we can add some automated tests.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一的即时选择是运行应用程序并尝试。这个选择现在可能还可以，但我不喜欢它作为长期选择，所以让我们看看是否可以添加一些自动化测试。
- en: The first question we should be asking ourselves is *what are we testing?* We
    should not need to test Wire itself, we can trust the tool authors to do that.
    In what other ways can things go wrong?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该问自己的第一个问题是*我们在测试什么？*我们不应该需要测试Wire本身，我们可以相信工具的作者会这样做。其他方面可能出现什么问题？
- en: A typical answer would be our use of Wire. If we had misconfigured Wire, it
    would have failed to generate, so that is covered. That leaves us with the app
    itself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的答案可能是我们使用Wire。如果我们配置错误Wire，它将无法生成，所以这个问题已经解决了。这让我们只剩下了应用本身。
- en: To test the app, we need to run it and then make an HTTP call into it, and then
    validate the response is as we expected.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试应用程序，我们需要运行它，然后进行HTTP调用，并验证响应是否符合我们的预期。
- en: The first thing we need to consider is how to start the app, and, perhaps more
    importantly, how to do it in a way that we can have multiple tests running at
    the same time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的第一件事是如何启动应用程序，也许更重要的是，如何以一种可以同时运行多个测试的方式来做到这一点。
- en: At the moment, our config (database connection, HTTP port, and so on) are hardcoded
    in a file on the disk. We could use that, but it includes a fixed HTTP server
    port. On the other hand, hardcoding database credentials in our tests is way worse.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的配置（数据库连接、HTTP端口等）是硬编码在磁盘上的一个文件中的。我们可以使用它，但它包括一个固定的HTTP服务器端口。另一方面，在我们的测试中硬编码数据库凭据要糟糕得多。
- en: 'Let''s use a middle ground. First, let''s load the standard `config` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采取一个折中的方法。首先，让我们加载标准的`config`文件：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s find a free TCP port to which we can bind our server. We can use
    port `0` and allow the system to assign one automatically, as shown in the following
    code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们找一个空闲的TCP端口来绑定我们的服务器。我们可以使用端口`0`，并允许系统自动分配一个，就像下面的代码所示：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now use that free port and replace the address in the `config` file
    with one that uses the free port like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用那个空闲端口，并将`config`文件中的地址替换为使用空闲端口的地址，就像这样：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And now we are stuck. Currently, to create an instance of the server, the code
    looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们陷入了困境。目前，要创建服务器的实例，代码看起来是这样的：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The config is automatically injected, no chance for us to use our custom config.
    Thankfully, Wire can help with this too.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 配置会自动注入，我们没有机会使用我们的自定义配置。幸运的是，Wire也可以帮助解决这个问题。
- en: 'To be able to inject the config in our tests manually, but not modify `main()`,
    we need to split our provider set into two parts. The first part is all the dependencies
    except config:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在我们的测试中手动注入配置，但不修改`main()`，我们需要将我们的提供者集分成两部分。第一部分是除了配置之外的所有依赖项：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And the second includes the first and then adds the config and all the related
    bindings:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个包括第一个，然后添加配置和所有相关的绑定：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next step is to create an injector that takes config as a parameter. In
    our case, it''s a little bit weird as this is caused by our config injection,
    but it looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个以config为参数的注入器。在我们的情况下，这有点奇怪，因为这是由我们的config注入引起的，但它看起来是这样的：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After running Wire, we can now start our test server, as shown in the following
    code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Wire后，我们现在可以启动我们的测试服务器，就像下面的代码所示：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Putting all of it together, we now have a function that creates a server on
    a random port and returns the address of the server, so that our test knows where
    to call. Here is the completed function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一起，我们现在有一个函数，它在一个随机端口上创建一个服务器，并返回服务器的地址，这样我们的测试就知道在哪里调用。以下是完成的函数：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s look at a test. Again, we are going to use the register endpoint
    as an example. Firstly, our test needs to start a test server. In the following
    example, you will also notice that we are defining a context with a timeout. When
    the context is done, via timeout or being canceled, the test server will shut
    down; therefore, this timeout becomes the *maximum execution time* of our test.
    Here is the code to start the server:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个测试。同样，我们将使用注册端点作为示例。首先，我们的测试需要启动一个测试服务器。在下面的示例中，您还会注意到我们正在定义一个带有超时的上下文。当上下文完成时，通过超时或被取消，测试服务器将关闭；因此，这个超时成为了我们测试的*最大执行时间*。以下是启动服务器的代码：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Next, we need to build and send the request. In this case, we've chosen to hardcode
    the payload and the URL. This might seem strange, but it's actually somewhat helpful.
    If the payload or the URL, both of which constitute the API of our service, were
    to change accidentally, these tests would break. Consider, on the other hand,
    if for the URL we used a constant that was also used to configure the server.
    If that constant was changed, the API would change and would break our users.
    Same goes for the payload, we could use the same Go object that is used internally,
    but changes there would also not cause the test to break.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要构建并发送请求。在这种情况下，我们选择了硬编码负载和URL。这可能看起来有点奇怪，但实际上有点帮助。如果负载或URL（这两者都构成我们服务的API）意外更改，这些测试将会失败。另一方面，考虑一下，如果我们使用一个常量来配置服务器的URL。如果那个常量被更改，API将会更改，并且会破坏我们的用户。负载也是一样，我们可以使用内部使用的相同Go对象，但那里的更改也不会导致测试失败。
- en: Yes, this duplication is more work and does make the tests more brittle, both
    of which are not good, but it's better for our tests to break than for us to break
    our users.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这种重复工作更多，确实使测试更加脆弱，这两者都不好，但是我们的测试出问题总比我们的用户出问题要好。
- en: 'The code to build and send the request is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和发送请求的代码如下：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now all that is left is to validate the results. After putting it all together,
    we have this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是验证结果。将所有内容放在一起后，我们有了这个：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That's it. We now have an automated test that ensures our app starts, can be
    called, and responds as we expect. If you are interested, there are tests for
    the other two endpoints in the code for this chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们现在有了一个自动化测试，确保我们的应用程序启动，可以被调用，并且响应如我们所期望的那样。如果您感兴趣，本章的代码中还有另外两个端点的测试。
- en: Disadvantages of off-the-shelf injection
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现成的注入的缺点
- en: As much as framework authors would love for their work to be a silver bullet,
    solving all the world's DI problems, this is sadly not the case; there are some
    costs associated with adopting a framework and reasons that you may choose not
    to use one. These include the following.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管框架作者希望他们的工作成为一种万能解决方案，解决所有世界上的DI问题，但很遗憾，事实并非如此；采用框架是有一些成本的，也有一些原因可能会选择不使用它。这些包括以下内容。
- en: '**Only supports constructor injection**—You may have noticed in this chapter
    that all of the examples used constructor injection. This is not by accident.
    Wire, like many frameworks, only supports constructor injection. We did not have
    to remove our use of other DI methods, but the framework is unable to assist us
    with it.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅支持构造函数注入**-你可能已经注意到在本章中，所有的例子都使用构造函数注入。这并非偶然。与许多框架一样，Wire只支持构造函数注入。我们不必删除其他DI方法的使用，但框架无法帮助我们处理它。'
- en: '**Adoption can be costly**—As you saw in the previous section, the end result
    of adopting a framework can be rather good, but our service is small and we were
    already using DI. If either of these things were not true, we would have been
    in for a lot more refactoring work. And as we have discussed before, the more
    changes we make, the more risk we incur.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**采用可能成本高昂**-正如你在前一节中看到的，采用框架的最终结果可能相当不错，但我们的服务规模较小，而且我们已经在使用DI。如果这两者中有任何一种情况不成立，我们将需要进行大量的重构工作。正如我们之前讨论过的，我们做的改变越多，我们承担的风险就越大。'
- en: These costs and this risk can be mitigated with prior experience with the framework
    and by adopting the framework from early in the project.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成本和风险可以通过具有框架的先前经验以及在项目早期采用框架来减轻。
- en: '**Ideological issues**—This is not a disadvantage per se but more a reason
    you might not want to adopt a framework. In the Go community, you will come across
    a sentiment that frameworks are *not idiomatic* or *in-line with Go''s philosophy*.
    While there has been no official statement or documentation that I could find
    to support this, I believe this is based on the fact that Go''s creators were
    fans and authors of the Unix philosophy, which states *do trivial things in isolation
    and then compose to make things useful*.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**意识形态问题**-这本身并不是一个缺点，而更多的是你可能不想采用框架的原因。在Go社区中，你会遇到一种观点，即框架与Go的哲学不符。虽然我没有找到官方声明或文件支持这一观点，但我相信这是基于Go的创作者是Unix哲学的粉丝和作者，该哲学规定*在隔离中做琐事，然后组合起来使事情有用*。'
- en: Frameworks can be seen to violate this ideology, especially if they become a
    pervasive part of the system as a whole. The frameworks we have mentioned in this
    chapter have a relatively small scope; so as with everything else, I will leave
    you to make your own call.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 框架可能被视为违反这种意识形态，特别是如果它们成为整个系统的普遍部分。我们在本章中提到的框架范围相对较小；所以和其他一切一样，我会让你自己做决定。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed using a DI framework in an attempt to lighten
    the burden of managing and injecting dependencies. We have discussed the advantages
    and disadvantages commonly found in DI frameworks and applied Google's Wire framework
    to our sample service.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用DI框架来减轻管理和注入依赖关系的负担。我们讨论了DI框架中常见的优缺点，并将Google的Wire框架应用到我们的示例服务中。
- en: This was the last DI method we will be discussing, and, in the next chapter,
    we will be taking a completely different tact and looking at reasons not to use
    DI. We will also be looking at situations where applying DI actually makes the
    code worse.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将讨论的最后一个DI方法，在下一章中，我们将采取完全不同的策略，看看不使用DI的原因。我们还将看看应用DI实际上使代码变得更糟的情况。
- en: Questions
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: When adopting a DI framework, what can you expect to gain?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在采用DI框架时，你可以期待获得什么？
- en: When evaluating a DI framework, what kinds of issues should you being looking
    out for?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在评估DI框架时，你应该注意哪些问题？
- en: What are the ideal use cases for adopting off-the-shelf injection?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 采用现成的注入的理想用例是什么？
- en: Why is it important to protect your service from accidental API changes?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么重要保护服务免受意外API更改的影响？
