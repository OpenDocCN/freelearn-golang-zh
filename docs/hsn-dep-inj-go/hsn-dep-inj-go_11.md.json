["```go\nfunc NewMyHandler(logger Logger, stats Instrumentation,\n   parser Parser, formatter Formatter,\n   limiter RateLimiter,\n   cache Cache, db Datastore) *MyHandler {\n\n   return &MyHandler{\n      // code removed\n   }\n}\n\n// MyHandler does something fantastic\ntype MyHandler struct {\n   // code removed\n}\n\nfunc (m *MyHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n   // code removed\n}\n```", "```go\n// Loader is responsible for loading the data\ntype Loader interface {\n   Load(ID int) ([]byte, error)\n}\n```", "```go\nfunc NewMyHandler(config Config,\n   parser Parser, formatter Formatter,\n   limiter RateLimiter,\n   loader Loader) *MyHandler {\n\n   return &MyHandler{\n      // code removed\n   }\n}\n```", "```go\nfunc NewMyHandler(config Config,\n   parser Parser, formatter Formatter,\n   limiter RateLimiter,\n   loader Loader) *MyHandler {\n\n   return &MyHandler{\n      config:    config,\n      parser:    parser,\n      formatter: formatter,\n      limiter:   limiter,\n      loader:    loader,\n   }\n}\n```", "```go\ntype FancyFormatHandler struct {\n   *MyHandler\n}\n```", "```go\nfunc NewFancyFormatHandler(config Config,\n   parser Parser,\n   limiter RateLimiter,\n   loader Loader) *FancyFormatHandler {\n\n   return &FancyFormatHandler{\n      &MyHandler{\n         config:    config,\n         formatter: &FancyFormatter{},\n         parser:    parser,\n         limiter:   limiter,\n         loader:    loader,\n      },\n   }\n}\n```", "```go\ntype Connection interface {\n   QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row\n   QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)\n   ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)\n}\n```", "```go\ntype Row interface {\n   Scan(dest ...interface{}) error\n}\n\ntype Rows interface {\n   Scan(dest ...interface{}) error\n   Close() error\n   Next() bool\n}\n\ntype Result interface {\n   LastInsertId() (int64, error)\n   RowsAffected() (int64, error)\n}\n```", "```go\nfunc TestExample(t *testing.T) {\n   router := http.NewServeMux()\n   router.HandleFunc(\"/health\", func(resp http.ResponseWriter, req *http.Request) {\n      _, _ = resp.Write([]byte(`OK`))\n   })\n\n   // start a server\n   address := \":8080\"\n   go func() {\n      _ = http.ListenAndServe(address, router)\n   }()\n\n   // call the server\n   resp, err := http.Get(\"http://:8080/health\")\n   require.NoError(t, err)\n\n   // validate the response\n   responseBody, err := ioutil.ReadAll(resp.Body)\n   assert.Equal(t, []byte(`OK`), responseBody)\n}\n```", "```go\ntype MyMux interface {\n   Handle(pattern string, handler http.Handler)\n   Handler(req *http.Request) (handler http.Handler, pattern string)\n   ServeHTTP(resp http.ResponseWriter, req *http.Request)\n}\n\n// build HTTP handler routing\nfunc buildRouter(mux MyMux) {\n   mux.Handle(\"/get\", &getEndpoint{})\n   mux.Handle(\"/list\", &listEndpoint{})\n   mux.Handle(\"/save\", &saveEndpoint{})\n}\n```", "```go\nfunc TestBuildRouter(t *testing.T) {\n   // build mock\n   mockRouter := &MockMyMux{}\n   mockRouter.On(\"Handle\", \"/get\", &getEndpoint{}).Once()\n   mockRouter.On(\"Handle\", \"/list\", &listEndpoint{}).Once()\n   mockRouter.On(\"Handle\", \"/save\", &saveEndpoint{}).Once()\n\n   // call function\n   buildRouter(mockRouter)\n\n   // assert expectations\n   assert.True(t, mockRouter.AssertExpectations(t))\n}\n```", "```go\n// build HTTP handler routing\nfunc buildRouter(mux *http.ServeMux) {\n   mux.Handle(\"/get\", &getEndpoint{})\n   mux.Handle(\"/list\", &listEndpoint{})\n   mux.Handle(\"/save\", &saveEndpoint{})\n}\n```", "```go\nfunc extractHandler(router *http.ServeMux, path string) http.Handler {\n   req, _ := http.NewRequest(\"GET\", path, nil)\n   handler, _ := router.Handler(req)\n   return handler\n}\n```", "```go\nfunc TestBuildRouter(t *testing.T) {\n   router := http.NewServeMux()\n\n   // call function\n   buildRouter(router)\n\n   // assertions\n   assert.IsType(t, &getEndpoint{}, extractHandler(router, \"/get\"))\n   assert.IsType(t, &listEndpoint{}, extractHandler(router, \"/list\"))\n   assert.IsType(t, &saveEndpoint{}, extractHandler(router, \"/save\"))\n}\n```", "```go\nfunc NewServiceLocator() *ServiceLocator {\n   return &ServiceLocator{\n      deps: map[string]interface{}{},\n   }\n}\n\ntype ServiceLocator struct {\n   deps map[string]interface{}\n}\n\n// Store or map a dependency to a key\nfunc (s *ServiceLocator) Store(key string, dep interface{}) {\n   s.deps[key] = dep\n}\n\n// Retrieve a dependency by key\nfunc (s *ServiceLocator) Get(key string) interface{} {\n   return s.deps[key]\n}\n```", "```go\n// build a service locator\nlocator := NewServiceLocator()\n\n// load the dependency mappings\nlocator.Store(\"logger\", &myLogger{})\nlocator.Store(\"converter\", &myConverter{})\n```", "```go\nfunc useServiceLocator(locator *ServiceLocator) {\n   // use the locators to get the logger\n   logger := locator.Get(\"logger\").(Logger)\n\n   // use the logger\n   logger.Info(\"Hello World!\")\n}\n```", "```go\nlogger := locator.Get(\"logger\").(Logger)\n```", "```go\n// use the locators to get the logger\nloggerRetrieved := locator.Get(\"logger\")\nif loggerRetrieved == nil {\n   return\n}\nlogger, ok := loggerRetrieved.(Logger)\nif !ok {\n   return\n}\n\n// use the logger\nlogger.Info(\"Hello World!\")\n```", "```go\n// GetHandler is the HTTP handler for the \"Get Person\" endpoint\ntype GetHandler struct {\n   cfg    GetConfig\n   getter GetModel\n}\n\n// ServeHTTP implements http.Handler\nfunc (h *GetHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n   // extract person id from request\n   id, err := h.extractID(request)\n   if err != nil {\n      // output error\n      response.WriteHeader(http.StatusBadRequest)\n      return\n   }\n\n   // attempt get\n   person, err := h.getter.Do(id)\n   if err != nil {\n      // not need to log here as we can expect other layers to do so\n      response.WriteHeader(http.StatusNotFound)\n      return\n   }\n\n   // happy path\n   err = h.writeJSON(response, person)\n   if err != nil {\n      response.WriteHeader(http.StatusInternalServerError)\n   }\n}\n\n// output the supplied person as JSON\nfunc (h *GetHandler) writeJSON(writer io.Writer, person *get.Person) error {\n   output := &getResponseFormat{\n      ID:       person.ID,\n      FullName: person.FullName,\n      Phone:    person.Phone,\n      Currency: person.Currency,\n      Price:    person.Price,\n   }\n\n   return json.NewEncoder(writer).Encode(output)\n}\n```", "```go\n// GetHandler is the HTTP handler for the \"Get Person\" endpoint\ntype GetHandler struct {\n   cfg       GetConfig\n   getter    GetModel\n   formatter Formatter\n}\n\n// ServeHTTP implements http.Handler\nfunc (h *GetHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n   // no changes to this method\n}\n\n// output the supplied person\nfunc (h *GetHandler) buildOutput(writer io.Writer, person *Person) error {\n   output := &getResponseFormat{\n      ID:       person.ID,\n      FullName: person.FullName,\n      Phone:    person.Phone,\n      Currency: person.Currency,\n      Price:    person.Price,\n   }\n\n   // build output payload\n   payload, err := h.formatter.Marshal(output)\n   if err != nil {\n      return err\n   }\n\n   // write payload to response and return\n   _, err = writer.Write(payload)\n   return err\n}\n```", "```go\n// Converter will convert the base price to the currency supplied\ntype Converter struct {\n   cfg Config\n}\n\n// Exchange will perform the conversion\nfunc (c *Converter) Exchange(ctx context.Context, basePrice float64, currency string) (float64, error) {\n   // load rate from the external API\n   response, err := c.loadRateFromServer(ctx, currency)\n   if err != nil {\n      return defaultPrice, err\n   }\n\n   // extract rate from response\n   rate, err := c.extractRate(response, currency)\n   if err != nil {\n      return defaultPrice, err\n   }\n\n   // apply rate and round to 2 decimal places\n   return math.Floor((basePrice/rate)*100) / 100, nil\n}\n\n// load rate from the external API\nfunc (c *Converter) loadRateFromServer(ctx context.Context, currency string) (*http.Response, error) {\n   // build the request\n   url := fmt.Sprintf(urlFormat,\n      c.cfg.ExchangeBaseURL(),\n      c.cfg.ExchangeAPIKey(),\n      currency)\n\n   // perform request\n   req, err := http.NewRequest(\"GET\", url, nil)\n   if err != nil {\n      c.logger().Warn(\"[exchange] failed to create request. err: %s\", err)\n      return nil, err\n   }\n\n   // set latency budget for the upstream call\n   subCtx, cancel := context.WithTimeout(ctx, 1*time.Second)\n   defer cancel()\n\n   // replace the default context with our custom one\n   req = req.WithContext(subCtx)\n\n   // perform the HTTP request\n   response, err := http.DefaultClient.Do(req)\n   if err != nil {\n      c.logger().Warn(\"[exchange] failed to load. err: %s\", err)\n      return nil, err\n   }\n\n   if response.StatusCode != http.StatusOK {\n      err = fmt.Errorf(\"request failed with code %d\", response.StatusCode)\n      c.logger().Warn(\"[exchange] %s\", err)\n      return nil, err\n   }\n\n   return response, nil\n}\n\nfunc (c *Converter) extractRate(response *http.Response, currency string) (float64, error) {\n   defer func() {\n      _ = response.Body.Close()\n   }()\n\n   // extract data from response\n   data, err := c.extractResponse(response)\n   if err != nil {\n      return defaultPrice, err\n   }\n\n   // pull rate from response data\n   rate, found := data.Quotes[\"USD\"+currency]\n   if !found {\n      err = fmt.Errorf(\"response did not include expected currency '%s'\", currency)\n      c.logger().Error(\"[exchange] %s\", err)\n      return defaultPrice, err\n   }\n\n   // happy path\n   return rate, nil\n}\n```", "```go\n// Requester builds and sending HTTP requests\n//go:generate mockery -name=Requester -case underscore -testonly -inpkg -note @generated\ntype Requester interface {\n   doRequest(ctx context.Context, url string) (*http.Response, error)\n}\n```", "```go\n// NewConverter creates and initializes the converter\nfunc NewConverter(cfg Config, requester Requester) *Converter {\n   return &Converter{\n      cfg:       cfg,\n      requester: requester,\n   }\n}\n\n// Converter will convert the base price to the currency supplied\ntype Converter struct {\n   cfg       Config\n   requester Requester\n}\n\n// load rate from the external API\nfunc (c *Converter) loadRateFromServer(ctx context.Context, currency string) (*http.Response, error) {\n   // build the request\n   url := fmt.Sprintf(urlFormat,\n      c.cfg.ExchangeBaseURL(),\n      c.cfg.ExchangeAPIKey(),\n      currency)\n\n   // perform request\n   response, err := c.requester.doRequest(ctx, url)\n   if err != nil {\n      c.logger().Warn(\"[exchange] failed to load. err: %s\", err)\n      return nil, err\n   }\n\n   if response.StatusCode != http.StatusOK {\n      err = fmt.Errorf(\"request failed with code %d\", response.StatusCode)\n      c.logger().Warn(\"[exchange] %s\", err)\n      return nil, err\n   }\n\n   return response, nil\n}\n```", "```go\nfunc TestExchange_invalidResponse(t *testing.T) {\n   // build response\n   response := httptest.NewRecorder()\n   _, err := response.WriteString(`invalid payload`)\n   require.NoError(t, err)\n\n   // configure mock\n   mockRequester := &mockRequester{}\n   mockRequester.On(\"doRequest\", mock.Anything, mock.Anything).Return(response.Result(), nil).Once()\n\n   // inputs\n   ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n   defer cancel()\n\n   basePrice := 12.34\n   currency := \"AUD\"\n\n   // perform call\n   converter := &Converter{\n      requester: mockRequester,\n      cfg:       &testConfig{},\n   }\n   result, resultErr := converter.Exchange(ctx, basePrice, currency)\n\n   // validate response\n   assert.Equal(t, float64(0), result)\n   assert.Error(t, resultErr)\n   assert.True(t, mockRequester.AssertExpectations(t))\n}\n```", "```go\nserver := httptest.NewServer(http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) {\n   payload := []byte(`invalid payload`)\n   response.Write(payload)\n}))\n```", "```go\ncfg := &testConfig{\n   baseURL: server.URL,\n   apiKey:  \"\",\n}\n\nconverter := NewConverter(cfg)\n```", "```go\nresult, resultErr := converter.Exchange(ctx, basePrice, currency)\n\n// validate response\nassert.Equal(t, float64(0), result)\nassert.Error(t, resultErr)\n```"]