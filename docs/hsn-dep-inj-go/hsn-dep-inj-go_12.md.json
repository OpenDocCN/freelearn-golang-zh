["```go\n// Load returns the config loaded from environment\nfunc Load() (*Config, error) {\n   filename, found := os.LookupEnv(DefaultEnvVar)\n   if !found {\n      err := fmt.Errorf(\"failed to locate file specified by %s\", DefaultEnvVar)\n      logging.L.Error(err.Error())\n      return nil, err\n   }\n\n   cfg, err := load(filename)\n   if err != nil {\n      logging.L.Error(\"failed to load config with err %s\", err)\n      return nil, err\n   }\n\n   return cfg, nil\n}\n```", "```go\n// Load returns the config loaded from environment\nfunc Load() (*Config, error) {\n   filename, found := os.LookupEnv(DefaultEnvVar)\n   if !found {\n      err := fmt.Errorf(\"failed to locate file specified by %s\", DefaultEnvVar)\n      fmt.Fprintf(os.Stderr, err.Error())\n      return nil, err\n   }\n\n   cfg, err := load(filename)\n   if err != nil {\n      fmt.Fprintf(os.Stderr, \"failed to load config with err %s\", err)\n      return nil, err\n   }\n\n   return cfg, nil\n}\n```", "```go\nfunc TestLogging(t *testing.T) {\n   // build log recorder\n   recorder := &LogRecorder{}\n\n   // Call struct that uses a logger\n   calculator := &Calculator{\n      logger: recorder,\n   }\n   result := calculator.divide(10, 0)\n\n   // validate expectations, including that the logger was called\n   assert.Equal(t, 0, result)\n   require.Equal(t, 1, len(recorder.Logs))\n   assert.Equal(t, \"cannot divide by 0\", recorder.Logs[0])\n}\n\ntype Calculator struct {\n   logger Logger\n}\n\nfunc (c *Calculator) divide(dividend int, divisor int) int {\n   if divisor == 0 {\n      c.logger.Error(\"cannot divide by 0\")\n      return 0\n   }\n\n   return dividend / divisor\n}\n\n// Logger is our standard interface\ntype Logger interface {\n   Error(message string, args ...interface{})\n}\n\n// LogRecorder implements Logger interface\ntype LogRecorder struct {\n   Logs []string\n}\n\nfunc (l *LogRecorder) Error(message string, args ...interface{}) {\n   // build log message\n   logMessage := fmt.Sprintf(message, args...)\n\n   // record log message\n   l.Logs = append(l.Logs, logMessage)\n}\n```", "```go\n// App is the application config\nvar App *Config\n\n// Config defines the JSON format for the config file\ntype Config struct {\n   // DSN is the data source name (format: https://github.com/go-sql-driver/mysql/#dsn-data-source-name)\n   DSN string\n\n   // Address is the IP address and port to bind this rest to\n   Address string\n\n   // BasePrice is the price of registration\n   BasePrice float64\n\n   // ExchangeRateBaseURL is the server and protocol part of the \n   // URL from which to load the exchange rate\n   ExchangeRateBaseURL string\n\n   // ExchangeRateAPIKey is the API for the exchange rate API\n   ExchangeRateAPIKey string\n}\n```", "```go\n// Config defines the JSON format for the config file\ntype Config struct {\n   // DSN is the data source name (format: https://github.com/go-sql-driver/mysql/#dsn-data-source-name)\n   DSN string\n\n   // Address is the IP address and port to bind this rest to\n   Address string\n\n   // BasePrice is the price of registration\n   BasePrice float64\n\n   // ExchangeRateBaseURL is the server and protocol part of the \n   // URL from which to load the exchange rate\n   ExchangeRateBaseURL string\n\n   // ExchangeRateAPIKey is the API for the exchange rate API\n   ExchangeRateAPIKey string\n\n   // environmental dependencies\n   logger logging.Logger\n}\n\n// Logger returns a reference to the singleton logger\nfunc (c *Config) Logger() logging.Logger {\n   if c.logger == nil {\n      c.logger = &logging.LoggerStdOut{}\n   }\n\n   return c.logger\n}\n\n// RegistrationBasePrice returns the base price for registrations\nfunc (c *Config) RegistrationBasePrice() float64 {\n   return c.BasePrice\n}\n\n// DataDSN returns the DSN\nfunc (c *Config) DataDSN() string {\n   return c.DSN\n}\n\n// ExchangeBaseURL returns the Base URL from which we can load \n// exchange rates\nfunc (c *Config) ExchangeBaseURL() string {\n   return c.ExchangeRateBaseURL\n}\n\n// ExchangeAPIKey returns the DSN\nfunc (c *Config) ExchangeAPIKey() string {\n   return c.ExchangeRateAPIKey\n}\n\n// BindAddress returns the host and port this service should bind to\nfunc (c *Config) BindAddress() string {\n   return c.Address\n}\n```", "```go\nfunc TestGetHandler_ServeHTTP(t *testing.T) {\n   // ensure the test always fails by giving it a timeout\n   ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n   defer cancel()\n\n   // Create and start a server\n   // With out current implementation, we cannot test this handler without \n   // a full server as we need the mux.\n   address, err := startServer(ctx)\n   require.NoError(t, err)\n\n   // build inputs\n   response, err := http.Get(\"http://\" + address + \"/person/1/\")\n\n   // validate outputs\n   require.NoError(t, err)\n   require.Equal(t, http.StatusOK, response.StatusCode)\n\n   expectedPayload := []byte(`{\"id\":1,\"name\":\"John\",\"phone\":\"0123456780\",\"currency\":\"USD\",\"price\":100}` + \"\\n\")\n   payload, _ := ioutil.ReadAll(response.Body)\n   defer response.Body.Close()\n\n   assert.Equal(t, expectedPayload, payload)\n}\n```", "```go\nfunc TestGetHandler_ServeHTTP(t *testing.T) {\n   scenarios := []struct {\n      desc            string\n      inRequest       func() *http.Request\n      inModelMock     func() *MockGetModel\n      expectedStatus  int\n      expectedPayload string\n   }{\n      // scenarios removed\n   }\n\n   for _, s := range scenarios {\n      scenario := s\n      t.Run(scenario.desc, func(t *testing.T) {\n         // define model layer mock\n         mockGetModel := scenario.inModelMock()\n\n         // build handler\n         handler := NewGetHandler(&testConfig{}, mockGetModel)\n\n         // perform request\n         response := httptest.NewRecorder()\n         handler.ServeHTTP(response, scenario.inRequest())\n\n         // validate outputs\n         require.Equal(t, scenario.expectedStatus, response.Code, scenario.desc)\n\n         payload, _ := ioutil.ReadAll(response.Body)\n         assert.Equal(t, scenario.expectedPayload, string(payload), scenario.desc)\n      })\n   }\n}\n```", "```go\ntype MockGetModel struct {\n   mock.Mock\n}\n\nfunc (_m *MockGetModel) Do(ID int) (*Person, error) {\n   outputs := _m.Called(ID)\n\n   if outputs.Get(0) != nil {\n      return outputs.Get(0).(*Person), outputs.Error(1)\n   }\n\n   return nil, outputs.Error(1)\n}\n```", "```go\nfunc TestGetter_Do(t *testing.T) {\n   // inputs\n   ID := 1\n\n   // call method\n   getter := &Getter{}\n   person, err := getter.Do(ID)\n\n   // validate expectations\n   require.NoError(t, err)\n   assert.Equal(t, ID, person.ID)\n   assert.Equal(t, \"John\", person.FullName)\n}\n```", "```go\nfunc TestGetter_Do_noSuchPerson(t *testing.T) {\n   // inputs\n   ID := 5678\n\n   // configure the mock loader\n   mockLoader := &mockMyLoader{}\n   mockLoader.On(\"Load\", mock.Anything, ID).Return(nil, data.ErrNotFound).Once()\n\n   // call method\n   getter := &Getter{\n      data: mockLoader,\n   }\n   person, err := getter.Do(ID)\n\n   // validate expectations\n   require.Equal(t, errPersonNotFound, err)\n   assert.Nil(t, person)\n   assert.True(t, mockLoader.AssertExpectations(t))\n}\n```", "```go\nfunc TestRegisterHandler_ServeHTTP(t *testing.T) {\n   // ensure the test always fails by giving it a timeout\n   ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n   defer cancel()\n\n   // Create and start a server\n   // With out current implementation, we cannot test this handler without \n   // a full server as we need the mux.\n   address, err := startServer(ctx)\n   require.NoError(t, err)\n\n   // build inputs\n   validRequest := buildValidRequest()\n   response, err := http.Post(\"http://\"+address+\"/person/register\", \"application/json\", validRequest)\n\n   // validate outputs\n   require.NoError(t, err)\n   require.Equal(t, http.StatusCreated, response.StatusCode)\n   defer response.Body.Close()\n\n   // call should output the location to the new person\n   headerLocation := response.Header.Get(\"Location\")\n   assert.Contains(t, headerLocation, \"/person/\")\n}\n```", "```go\nfunc TestRegisterHandler_ServeHTTP(t *testing.T) {\n   scenarios := []struct {\n      desc           string\n      inRequest      func() *http.Request\n      inModelMock    func() *MockRegisterModel\n      expectedStatus int\n      expectedHeader string\n   }{\n      // scenarios removed\n   }\n\n   for _, s := range scenarios {\n      scenario := s\n      t.Run(scenario.desc, func(t *testing.T) {\n         // define model layer mock\n         mockRegisterModel := scenario.inModelMock()\n\n         // build handler\n         handler := NewRegisterHandler(mockRegisterModel)\n\n         // perform request\n         response := httptest.NewRecorder()\n         handler.ServeHTTP(response, scenario.inRequest())\n\n         // validate outputs\n         require.Equal(t, scenario.expectedStatus, response.Code)\n\n         // call should output the location to the new person\n         resultHeader := response.Header().Get(\"Location\")\n         assert.Equal(t, scenario.expectedHeader, resultHeader)\n\n         // validate the mock was used as we expected\n         assert.True(t, mockRegisterModel.AssertExpectations(t))\n      })\n   }\n}\n```", "```go\n{\n   desc: \"Happy Path\",\n   inRequest: func() *http.Request {\n      validRequest := buildValidRegisterRequest()\n      request, err := http.NewRequest(\"POST\", \"/person/register\", validRequest)\n      require.NoError(t, err)\n\n      return request\n   },\n   inModelMock: func() *MockRegisterModel {\n      // valid downstream configuration\n      resultID := 1234\n      var resultErr error\n\n      mockRegisterModel := &MockRegisterModel{}\n      mockRegisterModel.On(\"Do\", mock.Anything, mock.Anything).Return(resultID, resultErr).Once()\n\n      return mockRegisterModel\n   },\n   expectedStatus: http.StatusCreated,\n   expectedHeader: \"/person/1234/\",\n},\n\n```", "```go\nfunc TestRegisterer_Do_exchangeError(t *testing.T) {\n   // configure the mocks\n   mockSaver := &mockMySaver{}\n   mockExchanger := &MockExchanger{}\n   mockExchanger.\n      On(\"Exchange\", mock.Anything, mock.Anything, mock.Anything).\n      Return(0.0, errors.New(\"failed to load conversion\")).\n      Once()\n\n   // define context and therefore test timeout\n   ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n   defer cancel()\n\n   // inputs\n   in := &Person{\n      FullName: \"Chang\",\n      Phone:    \"11122233355\",\n      Currency: \"CNY\",\n   }\n\n   // call method\n   registerer := &Registerer{\n      cfg:       &testConfig{},\n      exchanger: mockExchanger,\n      data:      mockSaver,\n   }\n   ID, err := registerer.Do(ctx, in)\n\n   // validate expectations\n   require.Error(t, err)\n   assert.Equal(t, 0, ID)\n   assert.True(t, mockSaver.AssertExpectations(t))\n   assert.True(t, mockExchanger.AssertExpectations(t))\n}\n```", "```go\nfunc TestInternalBoundaryTest(t *testing.T) {\n   // start our test server\n   server := httptest.NewServer(&happyExchangeRateService{})\n   defer server.Close()\n\n   // define the config\n   cfg := &testConfig{\n      baseURL: server.URL,\n      apiKey:  \"\",\n   }\n\n   // create a converter to test\n   converter := NewConverter(cfg)\n   resultRate, resultErr := converter.Exchange(context.Background(), 100.00, \"AUD\")\n\n   // validate the result\n   assert.Equal(t, 158.79, resultRate)\n   assert.NoError(t, resultErr)\n}\n\ntype happyExchangeRateService struct{}\n\n// ServeHTTP implements http.Handler\nfunc (*happyExchangeRateService) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n   payload := []byte(`\n{\n  \"success\":true,\n  \"timestamp\":1535250248,\n  \"base\":\"EUR\",\n  \"date\":\"2018-08-26\",\n  \"rates\": {\n   \"AUD\":1.587884\n  }\n}\n`)\n   response.Write(payload)\n}\n```", "```go\n-------------------------------------------------------------------------\n|      Branch     |       Dir       |                                   |\n|   Cov% |  Stmts |   Cov% |  Stmts | Package                           |\n-------------------------------------------------------------------------\n|  52.94 |    238 |   0.00 |      3 | acme/                             |\n|  73.33 |     15 |  73.33 |     15 | acme/internal/config/             |\n|   0.00 |      4 |   0.00 |      4 | acme/internal/logging/            |\n|  63.33 |     60 |  63.33 |     60 | acme/internal/modules/data/       |\n|   0.00 |     38 |   0.00 |     38 | acme/internal/modules/exchange/   |\n|  50.00 |      6 |  50.00 |      6 | acme/internal/modules/get/        |\n|  25.00 |     12 |  25.00 |     12 | acme/internal/modules/list/       |\n|  64.29 |     28 |  64.29 |     28 | acme/internal/modules/register/   |\n|  73.61 |     72 |  73.61 |     72 | acme/internal/rest/               |\n-------------------------------------------------------------------------\n```", "```go\n-------------------------------------------------------------------------\n|      Branch     |       Dir       |                                   |\n|   Cov% |  Stmts |   Cov% |  Stmts | Package                           |\n-------------------------------------------------------------------------\n|  63.11 |    309 |  30.00 |     20 | acme/                             |\n|  28.57 |     28 |  28.57 |     28 | acme/internal/config/             |\n|   0.00 |      4 |   0.00 |      4 | acme/internal/logging/            |\n|  74.65 |     71 |  74.65 |     71 | acme/internal/modules/data/       |\n|  61.70 |     47 |  61.70 |     47 | acme/internal/modules/exchange/   |\n|  81.82 |     11 |  81.82 |     11 | acme/internal/modules/get/        |\n|  38.10 |     21 |  38.10 |     21 | acme/internal/modules/list/       |\n|  75.76 |     33 |  75.76 |     33 | acme/internal/modules/register/   |\n|  77.03 |     74 |  77.03 |     74 | acme/internal/rest/               |\n-------------------------------------------------------------------------\n```", "```go\n# Change directory to the code for this chapter\n$ cd $GOPATH/src/github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/ch12/\n\n# Set the config location\n$ export ACME_CONFIG=cd $GOPATH/src/github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/config.json\n\n# Calculate coverage\n$ go test ./acme/ -coverprofile=coverage.out\n\n# Render as HTML\n$ go tool cover -html=coverage.out\n```", "```go\n// load rate from the external API\nfunc (c *Converter) loadRateFromServer(ctx context.Context, currency string) (*http.Response, error) {\n   // build the request\n   url := fmt.Sprintf(urlFormat,\n      c.cfg.ExchangeBaseURL(),\n      c.cfg.ExchangeAPIKey(),\n      currency)\n\n   // perform request\n   req, err := http.NewRequest(\"GET\", url, nil)\n   if err != nil {\n      c.logger().Warn(\"[exchange] failed to create request. err: %s\", err) return nil, err\n   }\n\n   // set latency budget for the upstream call\n   subCtx, cancel := context.WithTimeout(ctx, 1*time.Second)\n   defer cancel()\n\n   // replace the default context with our custom one\n   req = req.WithContext(subCtx)\n\n   // perform the HTTP request\n   response, err := http.DefaultClient.Do(req)\n   if err != nil {\n      c.logger().Warn(\"[exchange] failed to load. err: %s\", err)\n return nil, err\n   }\n\n   if response.StatusCode != http.StatusOK {\n      err = fmt.Errorf(\"request failed with code %d\", response.StatusCode)\n c.logger().Warn(\"[exchange] %s\", err)\n return nil, err\n   }\n\n   return response, nil\n}\n```", "```go\nif response.StatusCode != http.StatusOK {\n   err = fmt.Errorf(\"request failed with code %d\", response.StatusCode)\n   c.logger().Warn(\"[exchange] %s\", err)\n   return nil, err\n}\n```", "```go\nreq, err := http.NewRequest(\"GET\", url, nil)\nif err != nil {\n   c.logger().Warn(\"[exchange] failed to create request. err: %s\", err)\n   return nil, err\n}\n```", "```go\nfunc main() {\n   // bind stop channel to context\n   ctx := context.Background()\n\n   // start REST server\n   server := rest.New(config.App.Address)\n   server.Listen(ctx.Done())\n}\n```", "```go\nfunc main() {\n   // bind stop channel to context\n   ctx := context.Background()\n\n   // build the exchanger\n   exchanger := exchange.NewConverter(config.App)\n\n   // build model layer\n   getModel := get.NewGetter(config.App)\n   listModel := list.NewLister(config.App)\n   registerModel := register.NewRegisterer(config.App, exchanger)\n\n   // start REST server\n   server := rest.New(config.App, getModel, listModel, registerModel)\n   server.Listen(ctx.Done())\n}\n```", "```go\nfunc main() {\n   // bind stop channel to context\n   ctx := context.Background()\n\n   // start REST server\n   server, err := initializeServer()\n   if err != nil {\n      os.Exit(-1)\n   }\n\n   server.Listen(ctx.Done())\n}\n```", "```go\n// Getter will attempt to load a person.\ntype Getter struct {\n   cfg  Config\n   data myLoader\n}\n\n// Do will perform the get\nfunc (g *Getter) Do(ID int) (*data.Person, error) {\n   // load person from the data layer\n   person, err := g.getLoader().Load(context.TODO(), ID)\n   if err != nil {\n      if err == data.ErrNotFound {\n         return nil, errPersonNotFound\n      }\n      return nil, err\n   }\n\n   return person, err\n}\n\n// Use JIT DI to lessen the constructor parameters\nfunc (g *Getter) getLoader() myLoader {\n   if g.data == nil {\n      g.data = data.NewDAO(g.cfg)\n   }\n\n   return g.data\n}\n```", "```go\n$ BASE_PKG=github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/ch12/acme\ngodepgraph -s -o $BASE_PKG $BASE_PKG | dot -Tpng -o depgraph.png\n```", "```go\n$ BASE_PKG=github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/ch12/acme\ngodepgraph -s -o $BASE_PKG -p $BASE_PKG/internal/logging $BASE_PKG | dot -Tpng -o depgraph.png\n```", "```go\n// Lister will attempt to load all people in the database.\n// It can return an error caused by the data layer\ntype Lister struct {\n   cfg  Config\n   data myLoader\n}\n\n// Exchange will load the people from the data layer\nfunc (l *Lister) Do() ([]*data.Person, error) {\n   // code removed\n}\n```", "```go\ntype ListModel interface {\n   Do() ([]*data.Person, error)\n}\n```", "```go\n// DAO is a data access object that provides an abstraction over our \n// database interactions.\ntype DAO struct {\n   cfg Config\n\n   db    *sql.DB\n   cache *cache.Cache\n}\n\n// Load will attempt to load and return a person.\n// It will return ErrNotFound when the requested person does not exist.\n// Any other errors returned are caused by the underlying database or \n// our connection to it.\nfunc (d *DAO) Load(ctx context.Context, ID int) (*Person, error) {\n   // load from cache\n   out := d.loadFromCache(ID)\n   if out != nil {\n      return out, nil\n   }\n\n   // load from database\n   row := d.db.QueryRowContext(ctx, sqlLoadByID, ID)\n\n   // retrieve columns and populate the person object\n   out, err := populatePerson(row.Scan)\n   if err != nil {\n      if err == sql.ErrNoRows {\n         d.cfg.Logger().Warn(\"failed to load requested person '%d'. err: %s\", ID, err)\n         return nil, ErrNotFound\n      }\n\n      d.cfg.Logger().Error(\"failed to convert query result. err: %s\", err)\n      return nil, err\n   }\n\n   // save person into the cache\n   d.saveToCache(ID, out)\n\n   return out, nil\n}\n```", "```go\ntype GetHandler struct {\n   getter GetModel\n}\n\n// ServeHTTP implements http.Handler\nfunc (h *GetHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n   // extract person id from request\n   id, err := h.extractID(request)\n   if err != nil {\n      // output error\n      response.WriteHeader(http.StatusBadRequest)\n      return\n   }\n\n   // attempt get\n   person, err := h.getter.Do(id)\n   if err != nil {\n      // not need to log here as we can expect other layers to do so\n      response.WriteHeader(http.StatusNotFound)\n      return\n   }\n\n   // happy path\n   err = h.writeJSON(response, person)\n   if err != nil {\n      // this error should not happen but if it does there is nothing we\n      // can do to recover\n      response.WriteHeader(http.StatusInternalServerError)\n   }\n}\n```"]