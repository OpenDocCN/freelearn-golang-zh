- en: Reviewing Our Progress
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾我们的进展
- en: In this, our final chapter, we will take a look back and compare the state and
    quality of our sample service now, after applying **dependency injection** (**DI**),
    with how it was when we started.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一章中，我们将回顾并比较应用**依赖注入**（**DI**）后，我们的示例服务的状态和质量与我们开始时的情况。
- en: We will be taking a look at the improvements we have made, along with one final
    look at our dependency graph, and will discuss our improvements in test coverage
    and the testability of the service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾我们所做的改进，以及最后一次查看我们的依赖图，并讨论我们在测试覆盖率和服务的可测试性方面的改进。
- en: Finally, we will wrap up this chapter with a brief discussion of what we could
    have done if we had been starting a new service with DI instead of applying it
    to existing code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将以简要讨论结束本章，讨论如果我们从头开始使用DI而不是将其应用于现有代码，我们本可以做些什么。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An overview of the improvements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进概述
- en: A review of the dependency graph
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖图的回顾
- en: A review of test coverage and testability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试覆盖率和可测试性的回顾
- en: Starting a new service with DI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DI开始一个新服务
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It would be beneficial to be familiar with the code for our service, as introduced
    in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction to ACME
    registration service*. This chapter also assumes that you have read [Chapter 5](5b999adb-130a-49ed-9294-841c5a1b8181.xhtml), *Dependency
    Injection with Monkey Patching*, through to [Chapter 10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml), *Off-the-Shelf
    Injection,* on the various DI methods and other various improvements we made along
    the way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉我们服务的代码将是有益的，如[第4章](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml)中介绍的*ACME注册服务简介*。本章还假设您已经阅读了[第5章](5b999adb-130a-49ed-9294-841c5a1b8181.xhtml)中的*使用Monkey
    Patching进行依赖注入*，一直到[第10章](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml)中的*现成的注入*，介绍了我们在这一过程中所做的各种DI方法和其他各种改进。
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, which are available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会发现阅读和运行本章的完整代码版本很有用，这些代码可以在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12)找到。
- en: Instructions for obtaining the code and configuring the sample service are available
    in the README, which can be found at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 获取代码并配置示例服务的说明可在README中找到，该README位于[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/)。
- en: You can find the code for our service, with the changes from this chapter already
    applied, at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12/acme](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12/acme)[.](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12/acme)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12/acme](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12/acme)找到我们服务的代码，其中已经应用了本章的更改。
- en: Overview of the improvements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进概述
- en: Phew, we made it. How do you think we did? Do you think the improvements were
    worth the effort? Let's see.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，我们做到了。您认为我们做得如何？您认为这些改进值得努力吗？让我们看看。
- en: To see how far we have come, we should first recap where we started.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们已经走了多远，我们首先应该回顾我们的起点。
- en: In [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction to
    the ACME Registration Service*, we had a small, simple, working service. It got
    the job done for our users, but it created many inconveniences for those of us
    that had to maintain and extend it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml)中，*ACME注册服务简介*，我们有一个小型、简单、可工作的服务。它为我们的用户完成了工作，但对于我们必须维护和扩展它的人来说，它造成了许多不便。
- en: Global singletons
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局单例
- en: One of the biggest pains was undoubtedly the use of global public singletons.
    At first glance, they seemed to make the code more concise, but they were actually
    making it much harder for us to test.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的痛点之一无疑是使用全局公共单例。乍一看，它们似乎使代码更简洁，但实际上使我们的测试工作变得更加困难。
- en: The use of `init()` functions to create variables meant that we either had to
    use the live versions (that is, on the database) or had to monkey patch the globals,
    which led to potential data races.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`init()`函数创建变量意味着我们要么必须使用实时版本（即数据库上的版本），要么必须对全局变量进行Monkey Patch，这可能导致数据竞争。
- en: We started off with two public globals (`config` and `logger`) and one private
    global (the database connection pool). In [Chapter 5](5b999adb-130a-49ed-9294-841c5a1b8181.xhtml),
    *Dependency Injection with Monkey Patching*, we used monkey patching to give us
    the ability to test the code that relied on the database connection pool singleton.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初有两个公共全局变量（`config`和`logger`）和一个私有全局变量（数据库连接池）。在[第5章](5b999adb-130a-49ed-9294-841c5a1b8181.xhtml)中，*使用Monkey
    Patching进行依赖注入*，我们使用了Monkey Patching来使我们能够测试依赖于数据库连接池单例的代码。
- en: In [Chapter 10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml), *Off-the-Shelf
    Injection*, we finally managed to remove the `config` global, after first removing
    most of the direct access to it during the changes we made in [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml), *Dependency
    Injection by Config*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml)中，*现成的注入*，我们终于成功移除了`config`全局变量，在我们在[第8章](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml)中进行的更改中，首先移除了对它的大部分直接访问，*通过配置进行依赖注入*。
- en: By removing direct access and defining local config interfaces, we were able
    to completely decouple our model and data layers from the config. This means that
    our code is portable, should we ever want to use it in another application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除直接访问并定义本地配置接口，我们能够完全将我们的模型和数据层与配置解耦。这意味着我们的代码是可移植的，如果我们将来想在另一个应用程序中使用它。
- en: Perhaps most importantly, this means that writing tests on this code is now
    far less work, and our tests can all run independently and concurrently. Without
    the link to the global instance, we don't have to monkey patch. Without the dependency
    link, we are left with a smaller, more focused `config` interface, which is much
    easier to mock, stub, and generally understand.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最重要的是，这意味着现在在这段代码上编写测试的工作要少得多，我们的测试可以独立并发地运行。没有与全局实例的链接，我们不必进行猴子补丁。没有依赖链接，我们只剩下一个更小、更专注的`config`接口，更容易模拟、存根和理解。
- en: 'The global `logger` instance managed to survive our many refactorings, but
    the only place it is used is during the `config` loading code. So, let''s remove
    it now. Our `config` loading function currently looks like that shown in the following
    code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 全局`logger`实例设法在我们的许多重构中幸存下来，但它唯一被使用的地方是在`config`加载代码中。因此，现在让我们将其移除。我们当前的`config`加载函数看起来像下面的代码所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It''s pretty safe to say that, if we fail to load the config, our service is
    not going to work. We can, therefore, change our errors to write directly to *standard
    error* directly. Our updated function looks as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以非常肯定地说，如果我们未能加载配置，我们的服务就无法工作。因此，我们可以直接将错误更改为直接写入*标准错误*。我们更新后的函数如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The logger is otherwise *passed in* using config injection. By using config
    injection, we were able to forget about common concerns (such as the `logger`)
    without detracting from the UX of our constructors. We are now also able to easily
    write tests that validate logging without any data race issues. While such tests
    might feel weird, consider this—logs are an output of our system, and we will
    often rely on them when something goes wrong and we need to debug.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，日志记录器是通过配置注入*传递*的。通过使用配置注入，我们能够忘记常见的关注点（如`logger`），而不会影响我们构造函数的用户体验。现在我们也能够轻松编写测试来验证日志记录，而不会出现任何数据竞争问题。虽然这样的测试可能会感觉奇怪，但请考虑一下——日志是我们系统的输出，当出现问题需要调试时，我们经常会依赖于它们。
- en: 'As such, there might be cases when it''s useful to ensure that we are creating
    logs as we expect to and continue to do so, despite any future refactoring. This
    is not something we will want to test often, but when we do, the test itself is
    as simple as the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可能有些情况下，确保我们按预期创建日志并继续这样做是有用的。这不是我们经常想要测试的事情，但当我们这样做时，测试本身就像下面这样简单：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, the global instance of the database connection pool also remains; however,
    unlike `Config` and `Logger`, it is private, so any risks associated with it have
    a limited scope. In fact, by using **just**-**in**-**time** (**JIT**) DI, we were
    able to decouple our model layer tests from the data package entirely, without
    detracting from the UX of the model layer packages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数据库连接池的全局实例仍然存在；然而，与`Config`和`Logger`不同，它是私有的，因此与之相关的任何风险都有限的范围。事实上，通过使用**即时**（**JIT**）DI，我们能够完全将我们的模型层测试与数据包完全解耦，而不会影响模型层包的用户体验。
- en: High coupling with the config package
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与config包的高耦合
- en: 'When we started in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml),
    *Introduction to the ACME Registration Service*, we had not used any interfaces
    at all, and as a result, all of our packages were very tightly coupled with one
    another. Because of this, our packages had a high resistance to change; none more
    so than the `config` package. This was our original `Config` struct and the global
    singleton:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第4章](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml)中开始时，*ACME注册服务简介*，我们根本没有使用任何接口，因此我们所有的包都彼此紧密耦合。因此，我们的包对变化的抵抗力很强；其中最突出的是`config`包。这是我们原来的`Config`结构和全局单例：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the combination of a global singleton, lack of interfaces, and the fact
    that almost every package referenced this package, any change we made to the `Config`
    struct had the potential to break everything. Similarly, if we had decided to
    change the config format from a flat JSON file to a more complicated structure,
    we would have been in for some pretty nasty shotgun surgery.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于全局单例的组合、缺乏接口，以及几乎每个包都引用了这个包，我们对`Config`结构所做的任何更改都有可能导致一切都被破坏。同样地，如果我们决定将配置格式从平面JSON文件更改为更复杂的结构，我们将面临一些非常恶劣的手术。
- en: 'Let''s compare our original `Config` struct with what we have now:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下我们原来的`Config`结构和现在的情况：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As can be seen, we now have a lot more code. However, the extra code mostly
    comprises `getter` functions that implement the various config interfaces of the
    packages. These `getter` functions give us a layer of indirection that allows
    us to change how the config is loaded and stored, without having to impact the
    other packages.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，我们现在有了更多的代码。然而，额外的代码主要包括实现包的各种配置接口的`getter`函数。这些`getter`函数为我们提供了一层间接，使我们能够更改配置的加载和存储方式，而无需影响其他包。
- en: With the introduction of local `Config` interfaces into many of the packages,
    we were able to decouple those packages from our `config` package. While the other
    packages still indirectly use the `config` package, we have gained two benefits.
    Firstly, they can evolve separately. Secondly, the packages all *document* their
    requirements locally, giving us a smaller scope to work with when we are dealing
    with the package. This is especially helpful during testing when we are using
    mocks and stubs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在许多包中引入本地`Config`接口，我们能够将这些包与我们的`config`包解耦。虽然其他包仍然间接使用`config`包，但我们获得了两个好处。首先，它们可以分别发展。其次，这些包都在本地*记录*它们的需求，这使我们在处理包时有了更小的范围。这在测试期间特别有帮助，当我们使用模拟和存根时。
- en: Review of test coverage and testability
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试覆盖率和可测试性的回顾
- en: 'When we introduced our sample service, we identified several issues related
    to testing. The first of these issues was the *lack of isolation*, where tests
    for one layer were also indirectly testing all the layers below it, as shown in
    the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们引入我们的示例服务时，我们发现了与测试相关的几个问题。其中一个问题是*缺乏隔离*，其中一个层的测试也间接测试了所有在它下面的层，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a test in the REST layer, but because it calls the actual model, and
    therefore, the actual data layers, it is effectively testing everything. This
    makes it a reasonable integration test, as it ensures the layers work together
    appropriately. But is a poor unit test, because the layers are not isolated.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是REST层的测试，但因为它调用实际的模型，因此也调用了实际的数据层，它实际上测试了一切。这使它成为一个合理的集成测试，因为它确保各层之间适当地协同工作。但它是一个糟糕的单元测试，因为各层没有被隔离。
- en: 'Our unit test now looks as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试现在如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This test is considered isolated because, instead of relying on the other layers,
    we are relying on an abstraction—in our case, a mock implementation called `*MockGetModel`.
    Let''s take a look at a typical mock implementation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试被认为是隔离的，因为我们不是依赖于其他层，而是依赖于一个抽象——在我们的例子中，是一个名为`*MockGetModel`的模拟实现。让我们看一个典型的模拟实现：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the mock implementation is very simple; definitely simpler than
    the actual implementation of this dependency. Because of this simplicity, we are
    able to trust that it performs as we expect, and therefore, any problems that
    arise in the test will be caused by the actual code and not the mock. This trust
    can be further reinforced by the use of a code generator, such as Mockery (as
    introduced in [Chapter 3](26893ac5-a588-4954-943e-0eaf690feb34.xhtml), *Coding
    for User Experience*), that generates reliable and consistent code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，模拟实现非常简单；绝对比这个依赖的实际实现简单。由于这种简单性，我们能够相信它的表现与我们期望的一样，因此，测试中出现的任何问题都将是由实际代码而不是模拟引起的。通过使用代码生成器（如在[第3章](26893ac5-a588-4954-943e-0eaf690feb34.xhtml)中介绍的Mockery，*用户体验编码*），这种信任可以得到进一步加强，它生成可靠和一致的代码。
- en: 'The mock has also given us the ability to test other scenarios easily. We now
    have tests for the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟还使我们能够轻松测试其他场景。我们现在对以下内容进行了测试：
- en: Happy path
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快乐路径
- en: Missing ID in the request
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求中缺少ID
- en: Invalid ID in the request
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求中的无效ID
- en: Dependency (model layer or below) failure
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖（模型层或更低层）失败
- en: The requested record does not exist
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的记录不存在
- en: Many of these situations were difficult to reliably test without the changes
    we made.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有我们所做的更改的情况下，许多这些情况很难进行可靠的测试。
- en: Now that our test is isolated from the other layers, the test itself has a much
    smaller scope. This means we need to know less; all we need to know is the API
    contract for the layer we are testing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试与其他层隔离，测试本身的范围更小。这意味着我们需要了解的东西更少；我们只需要了解我们正在测试的层的API契约。
- en: In our example, this means that we only need to worry about HTTP concerns such
    as extracting data from the request, outputting the correct status code, and rendering
    the response payload. Additionally, the manner in which the code we are testing
    can fail has been reduced. So, we ended up with less test setup, shorter tests,
    and more scenario coverage.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这意味着我们只需要担心HTTP相关的问题，比如从请求中提取数据，输出正确的状态代码和呈现响应有效负载。此外，我们正在测试的代码可能失败的方式也减少了。因此，我们得到了更少的测试设置，更短的测试和更多的场景覆盖。
- en: 'The second issue related to testing was *duplication of effort*. With the lack
    of isolation, our original tests were often somewhat superfluous. For example,
    the model layer test for the Get endpoint looked like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试相关的第二个问题是*工作重复*。由于缺乏隔离，我们原始的测试通常有些多余。例如，Get端点的模型层测试看起来是这样的：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This looks alright on the surface, but when we consider the fact that this
    test scenario has already been covered by our `REST` package test, we actually
    gain nothing from this test. On the other hand, let''s look at one of the several
    tests we have now:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来表面上没问题，但当我们考虑到这个测试场景已经被我们的`REST`包测试覆盖时，我们实际上从这个测试中得不到任何东西。另一方面，让我们看看我们现在有的几个测试中的一个：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This test is now 100% predictable, as it does not rely on the current state
    of the database. It doesn't test the database, nor how we interact with it, but
    instead tests how we interact with the *data loader* abstraction. This means that
    the data layer implementation is free to evolve or change without needing to revisit
    and update the test. This test also validates that, if we receive an error from
    the data layer, we appropriately transform this error as our API contract expects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试现在是100%可预测的，因为它不依赖于数据库的当前状态。它不测试数据库，也不测试我们如何与数据库交互，而是测试我们如何与*数据加载器*抽象交互。这意味着数据层的实现可以自由地发展或更改，而无需重新审视和更新测试。这个测试还验证了，如果我们从数据层收到错误，我们会如我们的API契约所期望的那样适当地转换这个错误。
- en: We still have tests at both layers, as before, but instead of the tests bringing
    us no value, they now bring significant value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然在两个层上进行测试，但现在，这些测试不再毫无价值，而是带来了重大的价值。
- en: 'Thirdly, another issue we encountered when testing was *test verbosity*. One
    of the many changes we made was the adoption of table-driven tests. The original
    service test for our register endpoint looked as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们在测试中遇到的另一个问题是*测试冗长*。我们所做的许多更改之一是采用表驱动测试。我们注册端点的原始服务测试看起来如下：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And now, consider how it looks in the following code block:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑它在以下代码块中的样子：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I know what you are thinking, the test became more verbose, not less. Yes, this
    individual test did. However, in the originals, if we were to test for another
    scenario, the first step would have been to *copy and paste* almost the entire
    test, leaving us with approximately 10 lines of duplicated code and only a few
    lines that were unique to that test scenario.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么，测试变得更啰嗦了，而不是更简洁。是的，这个单独的测试确实是。然而，在原始测试中，如果我们要测试另一种情况，第一步将是*复制并粘贴*几乎整个测试，留下大约10行重复的代码和只有几行是该测试场景独有的。
- en: 'With our table-driven tests style, we have eight lines of shared code that
    execute for every scenario and are clearly visible as such. Each scenario is neatly
    specified as an object in a slice like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的表驱动测试风格，我们有八行共享代码，每个场景都会执行，并且清晰可见。每个场景都被整洁地指定为切片中的一个对象，如下所示：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For us to add another scenario, all we have to do is add another item to the
    slice. This is both very simple, and quite neat and tidy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需向切片添加另一个项目，就可以添加另一个场景。这既非常简单，又相当整洁。
- en: Lastly, if we ever need to make changes to the tests, perhaps because the API
    contract changed, we now have only one test to fix, instead of many.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们需要对测试进行更改，也许是因为API合同发生了变化，现在我们只需要修复一个测试，而不是很多个。
- en: The fourth issue we encountered was *reliance on our upstream service*. This
    is one of my pet peeves. Tests are supposed to be reliable and predictable, and
    test failures should be an absolute indicator that there is a problem that needs
    fixing. When tests rely on a third party and an internet connection, anything
    could go wrong, and the tests can break for any reason. Thankfully, after our
    changes in [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml), *Dependency
    Injection by Config*, all of our tests, except the external-facing boundary tests,
    now rely on an abstraction and a mock implementation of the upstream service.
    Not only are our tests reliable, but we can now easily test our error-handling
    conditions similar to how we discussed earlier.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的第四个问题是*依赖于我们的上游服务*。这是我非常讨厌的事情之一。测试应该是可靠和可预测的，测试失败应该是存在问题需要修复的绝对指标。当测试依赖于第三方和互联网连接时，任何事情都可能出错，测试可能因任何原因而失败。幸运的是，在我们在[第8章](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml)中的更改之后，除了外部边界测试，我们的所有测试现在都依赖于上游服务的抽象和模拟实现。我们的测试不仅可靠，而且现在可以轻松地测试我们的错误处理条件，类似于我们之前讨论的方式。
- en: 'In the following test, we have removed and mocked calls to the `converter`
    package in order to test what happens to our registrations when we fail to load
    the currency conversion:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下测试中，我们已经删除并模拟了对`converter`包的调用，以测试当我们无法加载货币转换时我们的注册会发生什么：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You might remember that we still have tests in our exchange package. In fact,
    we have two types. We have *internal-facing boundary tests* that call a fake HTTP
    server that we created. These tests ensure that when the server gives a particular
    response, our code reacts as we expect, as shown in the following snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得我们的exchange包中仍然有测试。事实上，我们有两种类型。我们有*内部边界测试*，它们调用我们创建的一个虚假HTTP服务器。这些测试确保当服务器给出特定响应时，我们的代码会如我们所期望的那样做出反应，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: But we also have *external-facing boundary tests*, which still call the upstream
    service. These tests help us validate that the upstream service performs as we
    need it to, in concert with our code. However, to ensure our tests are predictable,
    we do not run the external tests very often. We achieved this by adding a build
    tag to this file, allowing us an easy way to decide when to include the tests.
    Typically, I would only run these tests either when something went wrong, or in
    order to set up a special step in the build pipeline that runs only these tests.
    We could then decide how to proceed after any failures during these tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还有*外部边界测试*，它们仍然调用上游服务。这些测试帮助我们验证上游服务是否按照我们的需求执行，与我们的代码协同工作。但是，为了确保我们的测试是可预测的，我们不经常运行外部测试。我们通过向该文件添加构建标签来实现这一点，从而可以轻松地决定何时包括这些测试。通常情况下，我只会在出现问题时运行这些测试，或者为了设置构建流水线中仅运行这些测试的特殊步骤。然后，我们可以在这些测试期间的任何失败后决定如何继续。
- en: Test coverage
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: 'To talk about raw numbers for a moment, when we started, our service''s test
    coverage looked like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 说到原始数字，当我们开始时，我们服务的测试覆盖率如下：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the test coverage was somewhat low. With the difficulty in writing
    tests and our inability to mock or stub our dependencies, this is not surprising.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，测试覆盖率有些低。由于编写测试的难度以及我们无法模拟或存根我们的依赖关系，这并不奇怪。
- en: 'After our changes, our test coverage is improving:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的更改之后，我们的测试覆盖率正在提高：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While a lot of the changes we made to our service make it easier to test, we
    didn't spend that much time on adding additional tests. The bulk of the improvements
    that we did achieve came from increased scenario coverage, mainly involving being
    able to test the non-happy path code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们对服务进行的大部分更改使得测试变得更容易，但我们并没有花太多时间添加额外的测试。我们所取得的改进主要来自增加了场景覆盖，主要涉及能够测试非正常路径代码。
- en: 'If we wanted to improve the test coverage, the easiest way to find out where
    more tests are needed is to use the standard go tools to calculate the coverage
    and display it as HTML. To do this, we run the following commands in a Terminal:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要提高测试覆盖率，找出需要更多测试的最简单方法是使用标准的go工具来计算覆盖率并将其显示为HTML。为此，我们在终端中运行以下命令：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After running these commands, the coverage will open in your default browser.
    To find potential places to make improvements we then scanning through the files,
    look for blocks of red code. Code highlighted in red indicates a line that was
    not executed during the tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些命令后，覆盖率将在您的默认浏览器中打开。为了找到潜在的改进位置，我们会浏览文件，寻找红色代码块。红色高亮的代码表示在测试期间未执行的行。
- en: It is not pragmatic to remove all the untested lines, especially as some errors
    are close to impossible to trigger—rather, the key is to examine the code and
    decide if it represents a scenario that should be tested.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 删除所有未经测试的代码并不现实，特别是因为有些错误几乎不可能触发——关键是审查代码，决定是否应该对其进行测试。
- en: 'Consider the following example (the lines not covered are bold)—we''ll examine
    it in closer detail now:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例（未覆盖的行用粗体标出）——我们现在将更详细地检查它：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Firstly, let''s talk about these lines:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈这些行：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These lines handle the scenario where the upstream service fails to return HTTP
    `200` (OK). Given the nature of the internet and HTTP services, the scenario has
    a high chance of happening. We should, therefore, construct a test that ensures
    our code handles this situation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行处理了上游服务未能返回HTTP `200`（OK）的情况。考虑到互联网和HTTP服务的性质，这种情况很有可能发生。因此，我们应该构建一个测试来确保我们的代码处理了这种情况。
- en: 'Now, take a look at these lines:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下这些行：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Do you know how `http.NewRequest()` can fail? After digging around in the standard
    library, it appears that it can fail if we specify a valid HTTP method or if the
    URL fails to parse. These are programmer mistakes, and mistakes that we are unlikely
    to make. Even if we did make them, the results would be obvious and caught by
    existing tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道`http.NewRequest()`如何失败吗？在标准库中查找后，似乎它会在我们指定有效的HTTP方法或URL无法解析时失败。这些都是程序员的错误，而且我们不太可能犯这些错误。即使我们犯了，结果也是显而易见的，并且会被现有的测试捕捉到。
- en: Additionally, adding a test for these conditions would be difficult, and almost
    certainly detrimental to the cleanliness of our code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为这些情况添加测试将会很困难，并且几乎肯定会对我们的代码的整洁度产生不利影响。
- en: Lastly, our tests so far suffer from a *lack of end-to-end testing*. At the
    end of [Chapter 10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml), *Off-the-Shelf
    Injection*, we added a small number of end-to-end tests. We initially used these
    tests to validate that Google Wire performed as we expected. In the long term,
    they will serve to protect our API from accidental regression. Changes to our
    service's public API, whether it's the URL, the inputs or the output payloads,
    have a high chance of causing our users' code to break. Changes will sometimes
    be necessary, and in those cases, these tests will also serve a reminder to us
    that we need to take other actions as well, such as informing our users or versioning
    the API.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，到目前为止，我们的测试缺乏*端到端测试*。在[第10章](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml)
    *现成的注入* 结束时，我们添加了少量端到端测试。最初，我们使用这些测试来验证Google Wire的表现是否符合我们的预期。从长远来看，它们将用于保护我们的API免受意外的回归。对我们服务的公共API进行更改，无论是URL、输入还是输出负载，都很有可能导致我们用户的代码出现问题。有时更改是必要的，在这种情况下，这些测试也将提醒我们需要采取其他措施，比如通知我们的用户或对API进行版本控制。
- en: Removing the dependence on upstream service
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消除对上游服务的依赖
- en: In [Chapter 6](89c75571-2952-40fc-ba19-221b3114461b.xhtml), *Dependency Injection
    with Constructor Injection*, we used constructor injection to decouple our model
    layer from the `exchange` package. You may remember that the `exchange` package
    is a thin abstraction over our upstream currency converter service. Not only did
    this ensure that our model layer tests no longer required the upstream service
    to be working in order to pass, but it also gave us the ability to ensure we had
    adequately handled cases where the service was failing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](89c75571-2952-40fc-ba19-221b3114461b.xhtml) *构造函数注入的依赖注入* 中，我们使用构造函数注入来将我们的模型层与`exchange`包解耦。你可能还记得`exchange`包是对我们上游货币转换服务的一个薄抽象。这不仅确保我们的模型层测试不再需要上游服务正常工作才能通过，而且还使我们能够确保我们已充分处理了服务失败的情况。
- en: In [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml), *Dependency Injection
    by Config*, we added boundary tests that further removed our dependence on the
    upstream service by giving us the ability to test the `exchange` package independently
    of the upstream service. After removing all dependence on the upstream service
    from our frequently run unit tests, we added an external-facing boundary that
    tests the external service. However, we protected this test with a build tag,
    giving us the ability to run it selectively and occasionally, thus providing us
    with protection from internet and upstream service issues.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml) *配置的依赖注入* 中，我们添加了边界测试，进一步减少了对上游服务的依赖，使我们能够独立测试`exchange`包，而不依赖上游服务。在我们的频繁运行的单元测试中移除了对上游服务的所有依赖之后，我们添加了一个外部边界来测试外部服务。然而，我们用一个构建标签来保护这个测试，使我们能够有选择地偶尔运行它，从而保护我们免受互联网和上游服务的问题。
- en: Stopping short and latency budgets
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提前停止和延迟预算
- en: In [Chapter 7](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml), *Dependency Injection
    with Method Injection*, we used method injection to introduce the `context` package
    and request-scoped dependencies. By using `context` as a request-scoped dependency,
    we were then able to implement latency budgets and *stopping short*. With these
    in place, we are able to reduce our resource usage during abnormal system behavior.
    For example, if retrieving data (from the upstream currency conversion service
    or the database) is taking so long that the client is no longer waiting for a
    response, we can cancel the request and stop any further processing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml) *方法注入的依赖注入* 中，我们使用方法注入引入了`context`包和请求范围的依赖。通过将`context`用作请求范围的依赖，我们随后能够实现延迟预算和*提前停止*。有了这些，我们能够在异常系统行为期间减少资源使用。例如，如果检索数据（从上游货币转换服务或数据库）花费的时间太长，以至于客户端不再等待响应，我们可以取消请求并停止任何进一步的处理。
- en: Simplified dependency creation
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化依赖创建
- en: 'When we started in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction
    to the ACME Registration Service*, our `main()` function looks rather simple,
    as shown in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第4章](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml) *ACME注册服务简介* 中开始时，我们的`main()`函数看起来相当简单，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After applying several DI methods to our code, by [Chapter 9](60fb3899-8e56-4a9f-95bf-7e3eb70fea4e.xhtml),
    *Just-in-Time Dependency Injection*, our `main()` function had become the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中应用了几种DI方法之后，到了[第9章](60fb3899-8e56-4a9f-95bf-7e3eb70fea4e.xhtml) *即时依赖注入*，我们的`main()`函数变成了以下形式：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, it had become longer and more complicated. This is a common
    complaint regarding DI. So, in [Chapter 10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml),
    *Off-the-Shelf Injection*, we reduced this cost by letting Wire do it for us.
    This brings us back to a nice concise `main()` function, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它变得更长、更复杂了。这是关于DI的一个常见抱怨。因此，在[第10章](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml)中，*现成的注入*，我们通过让Wire为我们完成来减少这种成本。这使我们回到了一个简洁的`main()`函数，如下所示：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similarly, in [Chapter 9](60fb3899-8e56-4a9f-95bf-7e3eb70fea4e.xhtml), *Just-in-Time
    Dependency Injection*, we recognized the fact that there would only ever be one
    live implementation of the data layer, and the only time we would inject anything
    different was during testing. We, therefore, decided not to make the data layer
    a constructor parameter, but instead to use JIT injection, as shown in the following
    code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在[第9章](60fb3899-8e56-4a9f-95bf-7e3eb70fea4e.xhtml)中，*即时依赖注入*，我们意识到数据层只会有一个活动实现，而我们唯一需要注入不同内容的时间是在测试期间。因此，我们决定不将数据层作为构造函数参数，而是使用即时注入，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As can be seen here, this gives us simplified, local dependency creation without
    detracting from the UX of our constructors and without losing our ability to mock
    the data layer during testing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所见，这为我们提供了简化的本地依赖创建，而不会减少我们构造函数的用户体验，也不会在测试期间丢失我们模拟数据层的能力。
- en: Coupling and extensibility
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 耦合和可扩展性
- en: After all our changes, perhaps our most significant win is the decoupling of
    our packages. Wherever possible, our packages define and depend only on local
    interfaces. As a result of this, our unit tests are entirely isolated from other
    packages and validate our usage of our dependencies—the contract between our packages—without
    any dependence on them. This means a minimal scope of knowledge is required when
    working on our packages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有的变化之后，也许我们最重要的胜利是解耦我们的包。在可能的情况下，我们的包只定义并依赖于本地接口。由于这个，我们的单元测试完全与其他包隔离，并验证我们对依赖关系的使用——包之间的契约——而不依赖于它们。这意味着在处理我们的包时需要的知识范围是最小的。
- en: Perhaps more importantly, any changes or extensions we might want to make are
    likely to be contained to a single or small number of packages. For example, if
    we wanted to add a cache in front of our upstream currency conversion service,
    all of the changes would be made only to the `exchange` package. Similarly, if
    we wanted to reuse this package in another service, we could copy or extract it
    and use it without changes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 或许更重要的是，我们可能想要进行的任何更改或扩展都可能只限于一个或少数几个包。例如，如果我们想在上游货币转换服务前添加一个缓存，所有的更改都将只在`exchange`包中进行。同样，如果我们想在另一个服务中重用这个包，我们可以复制或提取它并在不进行任何更改的情况下使用它。
- en: Review of the dependency graph
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖图的审查
- en: 'Throughout this book, we have used the dependency graph as a way to discover
    potential issues. Here is how it looked when we started:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直将依赖图作为发现潜在问题的一种方式。这是我们开始时的样子：
- en: '![](img/deda18e8-1200-451b-9c5e-549f7674c82f.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/deda18e8-1200-451b-9c5e-549f7674c82f.png)'
- en: For a small service with only three endpoints, it's kind of complicated. From
    this graph, we also noticed that there were a lot of arrows pointing to the `data`,
    `config`, and `logging` packages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只有三个端点的小服务来说，它有点复杂。从这个图表中，我们还注意到有很多箭头指向`data`、`config`和`logging`包。
- en: Working under the assumption that more arrows going into or coming out of a
    package meant the more risk, complexity, and coupling, we set about trying to
    reduce these relationships.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在假设更多箭头进入或离开一个包意味着更多的风险、复杂性和耦合的前提下，我们开始尝试减少这些关系。
- en: The highest impact change was our adoption of the config injection, which included
    the definition of local `config` interfaces (as discussed in the previous section).
    This removed all of the arrows going into the config package, except for the one
    from `main()`, which we cannot remove.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的影响是我们采用了配置注入，其中包括本地`config`接口的定义（如前一节所讨论的）。这移除了所有进入config包的箭头，除了来自`main()`的箭头，这个我们无法移除。
- en: Furthermore, during our config injection work, we also removed all the references
    to the global logging instance, and instead injected the logger. This, however,
    did not change the graph. This was due to our decision to re-use the `Logger`
    interface defined in that package.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在我们进行配置注入工作期间，我们还移除了对全局日志实例的所有引用，并改为注入日志记录器。然而，这并没有改变图表。这是因为我们决定重用该包中定义的`Logger`接口。
- en: We could have defined a copy of this interface inside every package and removed
    this coupling, but decided not to, given that the logger definition was probably
    not going to change. Copying the interface everywhere would add code for no gain
    beyond removing arrows from the graph.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以在每个包内定义一个此接口的副本并移除这种耦合，但我们决定不这样做，因为日志记录器的定义可能不会改变。在图中移除箭头之外，复制接口到每个地方只会增加代码而没有任何好处。
- en: 'After all of our refactoring and decoupling work, our dependency graph looks
    like the following diagram:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有重构和解耦工作之后，我们的依赖图看起来像下面的图表：
- en: '![](img/5d2b5a97-95ca-4631-a7e2-1ecdb5f7277e.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d2b5a97-95ca-4631-a7e2-1ecdb5f7277e.png)'
- en: It's better, but sadly, it's still rather messy. To address this and the issue
    regarding the logging interface that we mentioned earlier, I have one more trick
    to show you.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做更好了，但遗憾的是，仍然相当混乱。为了解决这个问题以及我们之前提到的关于日志接口的问题，我还有一个技巧要向你展示。
- en: 'So far, we have been generating the graphs with a command like the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用以下命令生成图表：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can remove the `logging` package from the chart by using Godepgraph''s exclusions
    feature, changing the command to the following form:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用Godepgraph的排除功能来从图表中移除`logging`包，将命令改为以下形式：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This finally gives us the nice clear pyramid of a graph that we had been aiming
    for:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这给我们带来了我们一直追求的清晰的金字塔形图表：
- en: '![](img/dfda7ea1-d6bd-488c-aee5-15a924125867.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfda7ea1-d6bd-488c-aee5-15a924125867.png)'
- en: You might be wondering if we can further flatten the graph by removing the links
    between the `REST` and `model` packages (`get`, `list`, and `register`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们是否可以通过移除`REST`和`model`包之间的链接（`get`、`list`和`register`）来进一步扁平化图形。
- en: We are currently injecting the model code into the `REST` package; however,
    the one remaining link between the two is the output format of the `model` packages.
    Let's take a look at this now.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前正在将模型代码注入到`REST`包中；然而，两者之间仅剩下的链接是`model`包的输出格式。现在让我们来看看这个。
- en: 'Our list model API looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的列表模型API看起来是这样的：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are returning a slice of the `*data.Person` type, which forces our local
    interface in the `REST` package to be defined as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回的是`*data.Person`类型的切片，这迫使我们在`REST`包中定义本地接口如下：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Given that `data.Person` is a **data transfer object** (**DTO**), I am inclined
    to be pragmatic and leave it. We could, of course, remove it. To do so, we would
    need to change our `ListModel` definition to expect a slice of `interface{}`,
    and then define an interface into which we could cast our `*data.Person` when
    we need to use it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于`data.Person`是一个**数据传输对象**（**DTO**），我倾向于务实地保留它。当然，我们可以移除它。要这样做，我们需要改变我们的`ListModel`定义，以期望一个`interface{}`切片，然后定义一个接口，我们可以将我们的`*data.Person`转换成它。
- en: There are two major issues with this. Firstly, it's a lot of extra work that
    only removes one line from the dependency graph, but makes the code messier. Secondly,
    we are effectively bypassing the type system and creating a way for our code to
    fail at runtime, should the return type of our model layer become different from
    the `REST` package's expectations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个主要问题。首先，这需要做很多额外的工作，只是为了从依赖图中删除一行，但会使代码变得更混乱。其次，我们实际上是绕过了类型系统，创建了一种让我们的代码在运行时失败的方式，如果我们的模型层的返回类型与`REST`包的期望不同。
- en: Starting a new service with DI
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DI开始一个新的服务
- en: Throughout this book, we have applied DI to an existing service. While this
    is by far the most common situation we will find ourselves in, sometimes we will
    have the honor of starting a new project from scratch.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经将DI应用到了现有的服务中。虽然这是我们最常见的情况，但有时我们会有幸从头开始启动一个新项目。
- en: So, what could we do differently?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们能做些什么不同的吗？
- en: The user experience
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户体验
- en: 'The first thing we should always do is stop and think about the problem we
    are trying to solve. Go back to the UX discovery survey ([Chapter 3](26893ac5-a588-4954-943e-0eaf690feb34.xhtml),
    *Coding for User Experience*). Ask yourselves the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该做的第一件事是停下来思考我们要解决的问题。回到UX发现调查（[第3章](26893ac5-a588-4954-943e-0eaf690feb34.xhtml)，*为用户体验编码*）。问自己以下问题：
- en: Who are our users?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的用户是谁？
- en: What do our users want to achieve?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的用户想要实现什么？
- en: What are our users capable of?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的用户能做什么？
- en: How do our users expect to use the system we are going to create?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的用户期望如何使用我们即将创建的系统？
- en: Imagine that you were starting the ACME registration service, how would you
    answer these questions?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你要开始ACME注册服务，你会如何回答这些问题？
- en: 'The answers might be something like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 答案可能是以下内容：
- en: '**Who are our users?**—The users of this service will be the mobile application
    and web developers responsible for registration frontends.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的用户是谁？**—这项服务的用户将是负责注册前端的移动应用程序和Web开发人员。'
- en: '**What do our users want to achieve?**—They want to be able to create, view,
    and manage registrations.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的用户想要实现什么？**—他们希望能够创建、查看和管理注册。'
- en: '**What are our users capable of?**—They are familiar with calling HTTP-based
    REST services. They are familiar with passing in and consuming JSON-encoded data.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的用户能做什么？**—他们熟悉调用基于HTTP的REST服务。他们熟悉传递和消费JSON编码的数据。'
- en: '**How do our users expect to use the system we are going to create?**—Given
    their familiarity with JSON and REST, they expect to do everything via HTTP requests.
    With the first, most obvious set of users out of the way, we can move onto the
    second most important group: the development team.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的用户期望如何使用我们即将创建的系统？**—鉴于他们对JSON和REST的熟悉程度，他们希望通过HTTP请求来完成所有操作。第一组最明显的用户已经处理完毕，我们可以转向第二重要的用户群：开发团队。'
- en: '**Who are the users of our code?**—Myself and the rest of the development team.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们代码的用户是谁？**—我和开发团队的其他成员。'
- en: '**What do our users want to achieve?**—We want to build a fast, reliable system
    that is easy to manage and extend.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的用户想要实现什么？**—我们想要构建一个快速、可靠的系统，易于管理和扩展。'
- en: '**What are our users capable of?**—We are also familiar with HTTP, REST, and
    JSON. We are also familiar with MySQL and Go. We are also comfortable with the
    many forms of DI.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的用户能做什么？**—我们也熟悉HTTP、REST和JSON。我们也熟悉MySQL和Go。我们也熟悉DI的许多形式。'
- en: '**How do our users expect to use the code we are going to create?**—We would
    like to use DI to ensure our code is loosely coupled, and easy to test and maintain.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的用户期望如何使用我们即将创建的代码？**—我们希望使用DI来确保我们的代码松耦合，易于测试和维护。'
- en: You can see how by considering our users, we have already started to outline
    our service. We have determined that give that familiarity with HTTP, JSON, and
    REST from both users that this is the best choice for communications. Given the
    developers' familiarity with Go and MySQL, these are going to be the best choices
    concerning implementation technologies.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过考虑我们的用户，你可以看到我们已经开始概述我们的服务。我们已经确定了从用户和开发者对HTTP、JSON和REST的熟悉程度来看，这是通信的最佳选择。鉴于开发人员对Go和MySQL的熟悉程度，这些将是关于实现技术的最佳选择。
- en: Code structure
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码结构
- en: Armed with the framework provided by getting to know our users, we are ready
    to think about implementation and code structure.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解我们的用户提供的框架，我们已经准备好考虑实现和代码结构。
- en: Given we are making a standalone service, we are going to need a `main()` function.
    After that, the next thing I always add is an `internal` folder directly under
    `main()`. This adds a clean boundary between the code for this service and any
    code in the same repository.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在开发一个独立的服务，我们将需要一个`main()`函数。之后，我总是在`main()`下直接添加一个`internal`文件夹。这样可以在此服务的代码和同一存储库中的任何其他代码之间建立清晰的边界。
- en: When you are publishing a package or SDK for others to use, this is an easy
    way to ensure your internal implementation packages do not leak into the public
    API. If your team happens to use a mono-repo or multiple services in one repository,
    then it's a great way to ensure that you do not have package name collisions with
    other teams.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当您发布一个供他人使用的包或SDK时，这是一种简单的方法，可以确保您的内部实现包不会泄漏到公共API中。如果您的团队使用单一存储库或一个存储库中有多个服务，那么这是一种确保您不会与其他团队发生包名称冲突的好方法。
- en: 'The layers we had in our original service were relatively normal, so can reuse
    them here. These layers are shown in the following diagram:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原始服务中的层相对正常，因此可以在此处重用它们。这些层如下图所示：
- en: '![](img/e317a542-b91a-4ae5-9814-0b7f4ea479c1.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e317a542-b91a-4ae5-9814-0b7f4ea479c1.png)'
- en: The main advantage of using this particular set of layers is that each layer
    represents a different aspect required when processing a request. The **REST**
    layer deals only with HTTP-related concerns; specifically, extracting data from
    the requests and rendering the responses. The **Business Logic** layer is where
    the logic from the business resides. It also tends to contain coordination logic
    related to calling the **External Services and Data** layer. The **External Services
    and Data** will handle interaction with external services and systems such as
    databases.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这组特定层的主要优势是，每个层代表处理请求时所需的不同方面。**REST**层仅处理与HTTP相关的问题；具体来说，从请求中提取数据和呈现响应。**业务逻辑**层是业务逻辑所在的地方。它还倾向于包含与调用**外部服务和数据**层相关的协调逻辑。**外部服务和数据**将处理与外部服务和系统（如数据库）的交互。
- en: As you can see, each layer has an entirely separate responsibility and perspective.
    Any system-level changes, such as changing a database or changing from JSON to
    something else, can be handled entirely in one layer and should cause no changes
    to the other layers. The dependency contracts between the layers will be defined
    as interfaces, and this is how we will leverage not only DI, but testing with
    mocks and stubs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每个层都有完全独立的责任和视角。任何系统级的更改，例如更改数据库或从JSON更改为其他格式，都可以完全在一个层中处理，并且不应该对其他层造成任何更改。层之间的依赖关系将被定义为接口，这就是我们将利用的不仅是DI，还有使用模拟和存根进行测试。
- en: As the service grows, our layers will likely consist of many small packages,
    rather than one large package per layer. These small packages will export their
    own public APIs so that other packages in the layer can use them. This does, however,
    deteriorate the encapsulation of the layer. Let's look at an example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 随着服务的增长，我们的层可能会由许多小包组成，而不是每个层一个大包。这些小包将导出它们自己的公共API，以便该层中的其他包可以使用它们。然而，这会破坏层的封装。让我们看一个例子。
- en: 'Let''s assume that we have performance issues with our database and want to
    add a cache so that we can reduce the number of calls we make to it. It might
    look something like that shown in the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的数据库存在性能问题，想要添加缓存以减少对其的调用次数。代码可能看起来像下面所示：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: However, there is no need for the existence of this cache to be visible to the
    **Business Logic** layer. We can make sure that the encapsulation of data layer
    does not leak the `cache` package by adding another `internal` folder under the
    `data` folder.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，**业务逻辑**层无需知道此缓存的存在。我们可以通过在`data`文件夹下添加另一个`internal`文件夹来确保数据层的封装不会泄漏`cache`包。
- en: This change might seem unnecessary, and for small projects, that's a good argument.
    But as the project grows, the little cost of adding an extra `internal` folder
    will pay off and ensure that our encapsulation never leaks.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改变可能看起来是不必要的，对于小项目来说，这是一个很好的论点。但随着项目的增长，添加额外的`internal`文件夹的成本很小，将会得到回报，并确保我们的封装永远不会泄漏。
- en: Cross-cutting concerns
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 横切关注点
- en: We have seen that it's possible to deal with cross-cutting concerns, such as
    logging and configuration, in many different ways. It's advisable to decide on
    a strategy upfront and get your team to agree on it. Monkey patching, constructor
    injection, config injection, and JIT injection are all possible ways to either
    pass around or access config and logging singletons. The choice is entirely up
    to you and your preferences.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到处理横切关注点（如日志和配置）有许多不同的方法。建议提前决定一种策略，并让团队对此达成一致意见。猴子补丁，构造函数注入，配置注入和JIT注入都是传递或访问配置和日志单例的可能方式。选择完全取决于您和您的偏好。
- en: Designing from outside-in
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外部到内部的设计
- en: One of the great things about applying DI from the start of a project is that
    it gives us the ability to defer decisions until we are better informed to make
    them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目开始应用DI的一个很大的好处是，它使我们能够推迟决策，直到我们更好地了解情况。
- en: 'For example, after deciding to implement a HTTP REST service, we can then proceed
    to design our endpoints. When designing our Get endpoint, we could describe it
    like so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在决定实现HTTP REST服务后，我们可以继续设计我们的端点。在设计我们的Get端点时，我们可以这样描述：
- en: '**The get endpoint returns a person object in JSON with the form {"id":1,"name":"John","phone":"0123456789","currency":"USD","price":100}**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**Get端点以JSON格式返回一个人的对象，形式为{"id":1,"name":"John","phone":"0123456789","currency":"USD","price":100}**'
- en: 'You might notice that this only describes what the user needs, and does nothing
    to specify where the data is coming from. We can then actually code our endpoint
    to achieve this exact goal. And it might even look a lot like this, from [Chapter
    10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml), *Off-the-Shelf Injection*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，这只描述了用户的需求，并没有指定数据来自何处。然后我们可以实际编写我们的端点来实现这个确切的目标。它甚至可能看起来很像[第10章](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml)中的*现成注入*：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As `GetModel` is a locally defined abstraction, it also doesn't describe where
    or how the data is stored.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`GetModel`是一个本地定义的抽象，它也没有描述数据存储在哪里或如何存储。
- en: The same process could be applied to our implementation of `GetModel` in the
    business logic layer. It does not need to know how it's being called or where
    the data is stored, it only needs to know that it needs to coordinate the process
    and convert any response from the data layer to the format expected by the REST
    layer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的过程也可以应用到我们在业务逻辑层中对`GetModel`的实现。它不需要知道它是如何被调用的或数据存储在哪里，它只需要知道它需要协调这个过程，并将来自数据层的任何响应转换为REST层期望的格式。
- en: At each step of the way, the scope of the problem is small. The interactions
    with layers below depend on abstractions and the implementations of each layer
    is straightforward.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个步骤中，问题的范围都很小。与下层的交互取决于抽象，每个层的实现都很简单。
- en: And when all the layers of a function are implemented, we can use DI to wire
    it all together.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数的所有层都实现后，我们可以使用DI将它们全部连接起来。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined the state and quality of our sample service after
    applying DI, and contrasted that with its original state, thereby reminding ourselves
    both why we made the changes, and what we gained from making them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们审查了应用DI后我们样本服务的状态和质量，并将其与原始状态进行了对比，从而提醒自己我们为什么做出了这些改变，以及我们从中获得了什么。
- en: We took one final look at our dependency graph to get a visual perspective on
    just how well we managed to decouple our packages.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后再次查看了我们的依赖图，以直观地了解我们成功地将包解耦的程度。
- en: We also saw how our sample service was both significantly easier to test, and
    that our tests were much more focused after making our changes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了在进行改变后，我们的样本服务在测试时更容易，而且我们的测试更加专注。
- en: At the end of the chapter, we also discussed how to approach starting a new
    service and how DI can help with that endeavor too.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们还讨论了如何开始一个新的服务，以及DI如何在这方面提供帮助。
- en: With that, we have finished our examination of DI for Go. Thank you for taking
    the time to read this book—I hope that you have found it both pragmatic and useful.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们完成了对Go语言DI的审查。感谢您抽出时间阅读本书——我希望您觉得它既实用又有用。
- en: Happy coding!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 愉快的编码！
- en: Questions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What was the most important improvement made to our sample service?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的样本服务中最重要的改进是什么？
- en: In our dependency graph, why isn't the data package under `main`?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的依赖图中，为什么数据包不在`main`下面？
- en: What would you do differently if you were starting a new service?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您要启动一个新的服务，您会做些什么不同？
