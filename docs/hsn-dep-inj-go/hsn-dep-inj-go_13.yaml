- en: Assessment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Many of the questions at the ends of the chapters are intentionally thought-provoking,
    and as with many things in programming, the answers often depend on the programmer's
    situation or worldview.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多章节末尾的问题都是故意引发思考的，就像编程中的许多事情一样，答案往往取决于程序员的情况或世界观。
- en: Therefore, the answers following are likely to differ from yours, and that's
    alright. These are my answers and not necessarily the *right* answers for you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，接下来的答案可能与你的不同，这没关系。这是我的答案，不一定是你的“正确”答案。
- en: Chapter 1, Never Stop Aiming for Better
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章，永远不要停止追求更好
- en: '**1\. What is dependency injection?**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 什么是依赖注入？
- en: During this chapter, I defined dependency injection as coding in such a way
    that those resources (that is, functions or structs) we depend on are abstractions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将依赖注入定义为以这样的方式编码，即我们依赖的资源（即函数或结构）是抽象的。
- en: We went on to say that because these dependencies are abstract, changes to them
    do not necessitate changes to our code. The fancy word for this is **decoupling**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着说，因为这些依赖是抽象的，对它们的更改不需要对我们的代码进行更改。这个花哨的词是解耦。
- en: For me, decoupling is really the essential attribute and goal here. When objects
    are decoupled, they are just easier to work with. Easier to extend, refactor,
    reuse, and test. While these are all fantastically important, I also try to be
    pragmatic. In the end, the software will work just the same if it is not decoupled
    and does not use dependency injection. But it will become progressively harder
    to work with and extend.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，解耦实际上是这里的基本属性和目标。当对象解耦时，它们就更容易处理。更容易扩展、重构、重用和测试。虽然这些都非常重要，但我也试图保持务实。最终，如果软件没有解耦并且不使用依赖注入，它仍然会正常工作。但随着时间的推移，它将变得越来越难处理和扩展。
- en: '**2\. What are the four highlighted advantages of dependency injection?**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 依赖注入的四个突出优势是什么？
- en: '**Dependency injection reduces the knowledge required when working on a piece
    of code by expressing dependencies in an abstract or generic manner.** This, for
    me, is about speed. When I jump into a piece of code, especially in a large project,
    it''s easier to understand what a particular section (such as a struct) is doing
    when its dependencies are abstract. Typically, this is because the relationship
    is well described and the interactions clean (in other words, there is no object
    envy).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入通过以抽象或通用的方式表达依赖关系，减少了在处理代码时所需的知识。对我来说，这是关于速度。当我进入一段代码，特别是在一个大项目中，当其依赖关系是抽象的时，更容易理解特定部分（如结构）在做什么。通常，这是因为关系被很好地描述，交互干净（换句话说，没有对象嫉妒）。
- en: '**Dependency injection enables us to test our code in isolation of our dependencies.**
    Similar to the first point, when the dependency is abstract and interactions clean,
    testing the current piece of code by manipulating its interactions with dependencies
    is easy to understand and therefore faster.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入使我们能够在与依赖项隔离的情况下测试我们的代码。与第一点类似，当依赖关系是抽象的且交互干净时，通过操纵其与依赖项的交互来测试当前代码片段是容易理解的，因此更快。
- en: '**Dependency injection enables us to quickly and reliably test situations that
    are otherwise difficult or impossible.** I know, I focus a lot on testing. I am
    not actually zealot on this; it''s purely self-protection and my idea of professionalism.
    When I am writing code for someone else, I want it to be as good as possible (within
    resource constraints). Furthermore, I want it to continue to work the way I intended
    it to. Tests help me to both clarify and document my intent during construction
    and in the future.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入使我们能够快速而可靠地测试那些否则难以或不可能的情况。我知道，我非常注重测试。我并不是一个狂热者；这纯粹是自我保护和我对专业精神的理解。当我为别人编写代码时，我希望它尽可能地好（在资源限制内）。此外，我希望它继续按照我打算的方式工作。测试帮助我在构建过程中和将来澄清和记录我的意图。
- en: '**Dependency injection reduces the impact of extensions or changes.** Sure,
    if a method signature changes, its usages will change. When we rely on our own
    code (such as local interfaces), we at least have a choice in how to react to
    changes.  We can switch to other dependencies; we can add an adapter in between. 
    Regardless of how we deal with it, when our code and tests rely on the unchanged,
    we can be confident that any problems that arise are in the changed portion or
    in the features that it provides.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入减少了扩展或更改的影响。当一个方法签名发生变化时，它的用法也会发生变化。当我们依赖于我们自己的代码（如本地接口）时，我们至少可以选择如何应对变化。我们可以切换到其他依赖项；我们可以在中间添加一个适配器。无论我们如何处理，当我们的代码和测试依赖于未更改的部分时，我们可以确信任何出现的问题都在更改的部分或其提供的功能中。
- en: '**3\. What sorts of issues does it address?**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 它解决了什么样的问题？
- en: The answer to this is essentially the entire section on *code smells,* which
    include code bloat, resistance to change, wasted effort, and tight coupling.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个答案本质上就是关于“代码异味”的整个部分，其中包括代码膨胀、难以改变、浪费的努力和紧密耦合。
- en: '**4\. Why is it important to be skeptical?**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 为什么怀疑是重要的？
- en: In our industry, there is almost always more than one way to solve the problem
    at hand. Similarly, there are almost always many people selling you a *magic bullet* to
    solve all of your problems. Personally, my answer when asked whether a solution
    will work is often *it depends*. It might infuriate those that come to me for
    a simple answer and receive a bunch of questions instead, but there really is
    seldom a definitive answer. In truth, this is likely what keeps me coming back
    for more. There is always something new to learn, some new idea to try, some old
    notion to rediscover. So, I implore you, always listen, always question, and don't
    be afraid to experiment and fail.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的行业中，解决问题的方法几乎总是不止一种。同样，几乎总有很多人向你推销*灵丹妙药*来解决你所有的问题。就我个人而言，当被问及一个解决方案是否有效时，我的答案通常是*这取决于*。这可能会激怒那些寻求简单答案却收到一大堆问题的人，但实际上很少有确定的答案。事实上，这可能是让我不断回头的原因。总有新的东西要学习，新的想法要尝试，旧的概念要重新发现。因此，我恳求你，始终倾听，始终质疑，不要害怕尝试和失败。
- en: '**5\. What does *idiomatic Go* mean to you?**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**5. 对你来说，*惯用的Go*意味着什么？**'
- en: There is absolutely no correct answer to this. Please don't let anyone tell
    you otherwise. If you are consistent among the team you are working on, that is
    enough. If you don't like this style, propose and debate for a better one. While
    many people are resistant to change, far fewer are against better code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对没有正确的答案。请不要让任何人告诉你相反。如果你在团队中保持一致，那就足够了。如果你不喜欢这种风格，提出并辩论一个更好的风格。虽然很多人都抗拒改变，但更少的人反对更好的代码。
- en: Chapter 2, SOLID Design Principles for Go
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章，Go的SOLID设计原则
- en: '**1\. How does the single responsibility principle improve Go code?**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. 单一责任原则如何改进Go代码？**'
- en: By applying the single responsibility principle, the complexity of our code
    is reduced as it is decomposed code into smaller, more concise pieces.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用单一责任原则，我们的代码的复杂性得到了减少，因为它将代码分解为更小、更简洁的部分。
- en: With the smaller, more concise pieces, we gain increases in the potential usability
    of that same code. These smaller pieces are easier to compose into larger systems,
    due to their lighter requirements and more generic nature.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更小、更简洁的部分，我们增加了相同代码的潜在可用性。这些更小的部分更容易组合成更大的系统，因为它们的要求更轻，性质更通用。
- en: The single responsibility principle also makes tests simpler to write and maintain
    because when a piece of code has only one purpose, there is only much less scope
    (and therefore complexity) required to test.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单一责任原则还使得编写和维护测试变得更简单，因为当一段代码只有一个目的时，测试所需的范围（因此复杂性）就会大大减少。
- en: '**2\. How does the open/closed principle improve Go code?**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 开闭原则如何改进Go代码？**'
- en: The open/closed principle helps reduce the risk of additions and extensions
    by encouraging us not to change existing code, particularly exported APIs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 开闭原则有助于通过鼓励我们不改变现有的代码，特别是公开的API，来减少添加和扩展的风险。
- en: The open/closed principle also helps reduce the number of changes needed to
    add or remove a feature. This is particularly prevalent when moving away from
    certain code patterns, such as switch statements. Switch statements are great,
    but they tend to exist in more than one place, and it's easy to miss one instance
    when adding new features.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 开闭原则还有助于减少添加或删除功能所需的更改数量。当摆脱某些代码模式（如switch语句）时，这一点尤为突出。switch语句很棒，但它们往往存在于多个地方，当添加新功能时很容易忽略其中一个实例。
- en: Additionally, when problems do arise, they are easier to find, given that they
    are either in the newly added code or the interactions between it and its usages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一旦出现问题，由于问题要么在新添加的代码中，要么在其与使用之间的交互中，因此更容易找到。
- en: '**3\. How does the Liskov substitution principle improve Go code?**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**3. Liskov替换原则如何改进Go代码？**'
- en: By following the Liskov substitution principle, our code performs consistently
    regardless of the dependencies we are injecting. Violating the Liskov substitution
    principle, on the other hand, leads us to violate the open/closed principle. These
    violations cause our code to have too much knowledge of the implementations, which
    in turn breaks the abstraction of the injected dependencies.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循Liskov替换原则，我们的代码无论注入了什么样的依赖，都能保持一致的表现。另一方面，违反Liskov替换原则会导致违反开闭原则。这些违规行为会导致我们的代码对实现有过多的了解，从而破坏了注入依赖的抽象性。
- en: When implementing interfaces, we can use the Liskov substitution principle's
    focus on *consistent *behavior as a way of detecting code smells related to incorrect
    abstractions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现接口时，我们可以利用Liskov替换原则对*一致行为*的关注作为一种检测与不正确抽象相关的代码异味的方法。
- en: '**4\. How does the interface segregation principle improve Go code?**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**4. 接口隔离原则如何改进Go代码？**'
- en: The interface segregation principle requires us to define thin interfaces and
    explicit inputs. These features allow us to decouple our code from the implementations
    that are fulfilling our dependencies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则要求我们定义薄接口和明确的输入。这些特性使我们能够将我们的代码与实现我们的依赖的实现解耦。
- en: All of this leads to dependency definitions that are concise, easy to understand,
    and convenient to use, particularly when using them with mocks and stubs during
    testing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都导致了简洁、易于理解和方便使用的依赖定义，特别是在测试过程中使用模拟和存根时。
- en: '**5\. How does the dependency inversion principle improve Go code?**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**5. 依赖反转原则如何改进Go代码？**'
- en: The dependency inversion principle forces us to focus on the ownership of the
    abstractions and change their focus from *uses* to *requires*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖反转原则迫使我们关注抽象的所有权，并将其焦点从*使用*转移到*需要*。
- en: It also further decouples our dependency definitions from their implementations.
    As with the interface segregation principle, the result is code that is more straightforward
    and separate, particularly from its users.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它还进一步将我们的依赖定义与其实现解耦。与接口隔离原则一样，结果是代码更加简单和独立，特别是与其用户分离。
- en: Chapter 3, Coding for User Experience
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章，用户体验编码
- en: '**1\. Why is the usability of code important?**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. 代码的可用性为什么重要？**'
- en: Good UX is not nearly as apparent as bad UX. This is because when UX is good,
    it *just works*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的用户体验并不像糟糕的用户体验那么明显。这是因为当用户体验良好时，它*只是有效*。
- en: Typically, the more complicated, obfuscated, or unusual a piece code is, the
    harder it is to understand. The harder code is to follow, the harder it is to
    maintain or extend and the higher the chance of mistakes being made.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，代码越复杂、难以理解、或者不寻常，就越难以理解。代码越难以跟踪，就越难以维护或扩展，出错的可能性就越大。
- en: '**2\. Who benefits the most from code with great UX?**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 谁最能从具有良好用户体验的代码中受益？**'
- en: As programmers, we are both the creators and greatest users of our code; it
    is, therefore, our colleagues and ourselves that benefit most.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们既是代码的创造者，也是最大的用户；因此，最受益的是我们的同事和我们自己。
- en: '**3\. How do you construct good UX?**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**3. 如何构建良好的用户体验？**'
- en: The best UXes are intuitive and natural to their users. The key, therefore,
    is to try to think as your users do. Chances are that the code you write will
    make sense and hopefully be natural to you, but can you say the same for the rest
    of your team?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的用户体验是直观和自然的。因此，关键是要尽量像你的用户一样思考。你写的代码可能对你来说是有意义的，希望对你来说也是自然的，但是你能说对你的团队其他成员也是这样吗？
- en: 'In this chapter, we defined some aspects to keep in mind:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们定义了一些需要牢记的方面：
- en: Start simple, and get complicated only when you must.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单开始，只有在必要时才变得复杂。
- en: Apply just enough abstraction.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用足够的抽象。
- en: Follow industry, team, and language conventions.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循行业、团队和语言的惯例。
- en: Export only what you must.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只导出必要的内容。
- en: Aggressively apply the single responsibility principle.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 积极应用单一职责原则。
- en: 'We also introduced the *UX Discovery Survey* as a way to *get into the minds* of
    your users. The survey consisted of four questions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了*UX发现调查*，作为*深入了解*你的用户的一种方式。调查包括四个问题：
- en: Who is the user?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁是用户？
- en: What are your users capable of?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的用户有什么能力？
- en: Why do users want to use your code?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户为什么想要使用你的代码？
- en: How do your users expect to use it?
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的用户期望如何使用它？
- en: '**4\. What can unit testing do for you?**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**4. 单元测试能为你做什么？**'
- en: In short, many things. It does differ from person to person. Primarily, I use
    tests to give me the confidence to either *go fast* or *take on the big jobs,* depending
    on what is needed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，很多事情。这因人而异。主要是，我使用测试来给我信心，要么*快速前进*，要么*承担重任*，这取决于需要什么。
- en: I also find that tests do an excellent job of documenting the intent of the
    author and are less likely to go stale as comments can.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我还发现测试在记录作者的意图方面做得很好，而且不太可能像注释那样过时。
- en: '**5\. What kind of test scenarios should you consider?**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**5. 你应该考虑哪种测试场景？**'
- en: 'You always want to consider at least three scenarios:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是要考虑至少三种场景：
- en: '**The happy path:** Does your function do what you expect it to do?'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快乐的路径：**你的函数是否做你期望它做的事情？'
- en: '**Input errors:** Predictable errors in usage (particularly inputs)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入错误：**在使用中可预测的错误（特别是输入）'
- en: '**Dependency issues:** Does your code behave when the dependencies fail?'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖问题：**当依赖关系失败时，你的代码是否能正常运行？'
- en: '**6\. How do Table-Driven Tests** (**TDTs**) **help?**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**6. 表驱动测试（TDTs）如何帮助？**'
- en: TDTs are great for reducing the duplication caused by multiple test scenarios
    for the same function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: TDT对减少由同一函数的多个测试场景引起的重复很有帮助。
- en: They are typically more efficient to create than copy/pasting a lot of tests.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通常比复制/粘贴大量测试更有效。
- en: '**7\. How can testing damage your software design?**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**7. 测试如何损害你的软件设计？**'
- en: 'There are many ways that this could happen, and some are quite subjective/personal;
    but, in this chapter, we outlined a few common causes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有很多种方式，有些是相当主观/个人的；但在本章中，我们概述了一些常见的原因：
- en: Parameters, config options, or outputs that only exist because of tests
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有因为测试而存在的参数、配置选项或输出
- en: Parameters that cause or a caused by leaky abstractions
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由测试引起或导致的参数泄漏抽象
- en: Publishing mocks in production code
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产代码中发布模拟
- en: Excessive test coverage
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度的测试覆盖
- en: Chapter 4, Introduction to the ACME Registration Service
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章，ACME注册服务简介
- en: '**1\. Which of the goals defined for our service is most important to you personally?**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. 对我们的服务定义的目标中，哪个对你个人来说最重要？**'
- en: This is subjective, and as such, there is no right answer. Personally, it would
    have to be readability or testability. If the code is easy to read, then I can
    figure it out easier and probably remember more about it as well. On the other
    hand, if it's more testable, then I can leverage that fact to write more tests.
    With more tests in place, I won't have to remember as much and can let the tests
    make sure everything performs as I need it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主观的，因此没有正确答案。就我个人而言，可能是可读性或可测试性。如果代码容易阅读，那么我可以更容易地理解它，可能也能记住更多。另一方面，如果它更容易测试，那么我可以利用这一点来编写更多的测试。有了更多的测试，我就不必记住那么多，可以让测试确保一切都按照我需要的方式执行。
- en: '**2\. Which of the issues outlined seems to be most urgent or important?**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 概述的问题中哪个似乎最紧急或最重要？**'
- en: This is also subjective. It might surprise you, but I would say *lack of isolation
    in tests*. With the tests as they are, every test is somewhat akin to an end-to-end
    test. This means that the test setup is lengthy and when something goes wrong,
    it will be time-consuming to figure out where the problem is.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是主观的。你可能会感到惊讶，但我会说*测试中缺乏隔离性*。随着测试的进行，每个测试都有点类似于端到端测试。这意味着测试设置是冗长的，当出现问题时，找出问题所在将是耗时的。
- en: Chapter 5, Dependency Injection with Monkey Patching
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章，使用Monkey Patching进行依赖注入
- en: '**1\. How does monkey patching work?**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. Monkey Patching是如何工作的？**'
- en: At its most basic level, monkey patching in Go involves swapping out one variable
    for another at runtime. This variable can be an instance of the dependency (in
    the form of a struct) or a function that wraps access to the dependency.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的层面上，Go中的Monkey Patching涉及在运行时交换一个变量为另一个变量。这个变量可以是依赖的实例（以结构体的形式）或者是一个包装对依赖的访问的函数。
- en: At a higher level, monkey patching is about replacing or intercepting access
    to a dependency to replace it with another implementation, typically a stub or
    a mock, to make testing simpler.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高的层面上，猴子补丁是关于替换或拦截对依赖的访问，以将其替换为另一个实现，通常是存根或模拟，以使测试更简单。
- en: '**2\. What are the ideal use cases for monkey patching?**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 猴子补丁的理想用例是什么？**'
- en: 'Monkey patching can be used in a variety of situations, but the most notable
    are the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 猴子补丁可以在各种情况下使用，但最显著的情况包括以下情况：
- en: With code that relies on a singleton
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖于单例的代码
- en: With code that currently has no tests, no dependency injection, and where you
    want to add tests with a minimum of changes
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于当前没有测试、没有依赖注入的代码，并且希望以最少的更改添加测试的情况
- en: To decouple two packages without having to change the dependent package
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不更改依赖包的情况下解耦两个包
- en: '**3\. How can you use monkey patching to decouple two packages without changing
    the dependent package?**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**3. 如何使用猴子补丁来解耦两个包而不更改依赖包？**'
- en: We can introduce a variable of type function that calls the dependency package.
    We can then monkey patch our local variable instead of having to change the dependency.
    In this chapter, we saw that is especially useful for decoupling from code that
    we cannot change (such as the standard library).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引入一个调用依赖包的函数类型的变量。然后，我们可以猴子补丁我们的本地变量，而不必更改依赖。在本章中，我们看到这对于与我们无法更改的代码（如标准库）解耦特别有用。
- en: Chapter 6, Dependency Injection with Constructor Injection
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章，构造函数注入的依赖注入
- en: '**1\. What are the steps we used to adopt constructor injection?**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. 我们用来采用构造函数注入的步骤是什么？**'
- en: We identified the dependency we wanted to extract and eventually inject.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们确定了我们想要提取并最终注入的依赖关系。
- en: We removed the creation of that dependency and promoted it to a member variable.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们删除了该依赖的创建并将其提升为成员变量。
- en: We then defined the abstraction of the dependency as a local interface and changed
    the member variable to use that instead of the real dependency.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将依赖的抽象定义为本地接口，并将成员变量更改为使用该接口而不是真实的依赖。
- en: We then added a constructor with the abstraction of the dependency as a parameter
    so that we could ensure the dependency was always available.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加了一个构造函数，其中包含依赖的抽象作为参数，以便我们可以确保依赖始终可用。
- en: '**2\. What is a guard clause and when would you use it?**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 什么是守卫条款，何时使用它？**'
- en: We defined guard clauses as a piece of code the ensured the dependency was supplied
    (in other words, not nil). In some cases, we used them in our constructors so
    that we could be 100% sure the dependency was provided.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将守卫条款定义为一段代码，确保提供了依赖（换句话说，不是nil）。在某些情况下，我们在构造函数中使用它们，以便我们可以百分之百确定依赖已提供。
- en: '**3\. How does constructor injection affect the life cycle of the dependency?**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**3. 构造函数注入如何影响依赖的生命周期？**'
- en: When dependencies are passed into via the constructor, we are sure that they
    are always available to other methods. As such, there is no risk of nil-pointer
    crashes related to the use of the dependency.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当依赖通过构造函数传入时，我们可以确保它们始终可用于其他方法。因此，与使用依赖相关的nil指针崩溃没有风险。
- en: Additionally, we do not need to litter our methods with guard clauses or other
    sanity checks as any such validation only needs to exist in the constructor.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不需要在方法中添加守卫条款或其他健全性检查，因为任何此类验证只需要存在于构造函数中。
- en: '**4. What are the ideal use cases for constructor injection?**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**4. 构造函数注入的理想用例是什么？**'
- en: 'Constructor injection is useful for many situations, including the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入对许多情况都很有用，包括以下情况：
- en: Where the dependencies that are required
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的依赖
- en: Where the dependencies that are used by most or all of the methods of an object
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被对象的大多数或所有方法使用的依赖
- en: Where there are multiple implementations of a dependency
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个依赖有多个实现时
- en: Where the dependencies do not change between requests
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖在请求之间不会改变的情况
- en: Chapter 7, Dependency Injection with Method Injection
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章，方法注入的依赖注入
- en: '**1\. What are the ideal use cases for method injection?**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. 方法注入的理想用例是什么？**'
- en: 'Method injection is great for the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 方法注入非常适用于以下情况：
- en: Functions, frameworks, and shared libraries
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数、框架和共享库
- en: Requesting scoped dependencies, such as context or user credentials
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求作用域依赖，比如上下文或用户凭据
- en: Stateless objects
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态对象
- en: Dependencies that provide context or data in the request and as such are expected
    to vary between calls.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供请求中的上下文或数据的依赖，因此预计在调用之间会有所变化。
- en: '**2\. Why is it important not to save dependencies injected with method injection?**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 为什么重要的是不保存使用方法注入注入的依赖？**'
- en: Because the dependency is a parameter of the function or method, every call
    will supply a new dependency. While saving the dependency before calling other
    internal methods might seem more straightforward than passing the parameter around
    as a dependency, such practice will cause data races between multiple concurrent
    usages.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为依赖是函数或方法的参数，每次调用都会提供一个新的依赖。虽然在调用其他内部方法之前保存依赖可能比将参数传递为依赖更直接，但这样的做法会导致多个并发使用之间的数据竞争。
- en: '**3\. What happens if we use method injection too much?**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**3. 如果我们过度使用方法注入会发生什么？**'
- en: This question is somewhat subjective and depends on your opinion of both test-induced
    damage and code UX. Personally, I care about UX quite a lot. As such, making a
    function easier to use by reducing parameters is always on my mind (except for
    constructors).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有点主观，取决于你对测试引起的损害和代码UX的看法。就我个人而言，我非常关心UX。因此，通过减少参数使函数更易于使用始终在我脑海中（除了构造函数）。
- en: From a testing perspective, it's far more flexible to have some form of dependency
    injection than to have none. Be pragmatic; you will find a balance that works
    for you.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试的角度来看，有一定形式的依赖注入要比没有更灵活。要务实；你会找到适合你的平衡点。
- en: '**4\. Why is *stopping short* useful to the system as a whole?**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**4. *停止短路*对整个系统有什么用？**'
- en: Being able to stop processing a request when no-one is listening for the response
    is extremely useful. Not only does it bring the system closer to the user's expectations,
    but it reduces the load on the system as a whole. Many resources of the resources
    we are working with are finite, especially databases, and anything we can do to
    complete the processing of a request quicker, even when it ends in failure, is
    advantageous.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在没有人监听响应时停止处理请求是非常有用的。这不仅使系统更接近用户的期望，还减少了整个系统的负载。我们正在处理的许多资源是有限的，特别是数据库，我们可以做的任何事情来更快地完成请求的处理，即使最终以失败告终，也是有利的。
- en: '**5\. How can latency budgets improve UX?**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 延迟预算如何改善用户体验？
- en: Admittedly, latency budgets are a topic I have not heard discussed that often.
    Given the prevalence of APIs in our industry today, perhaps we should discuss
    them more. Their importance is twofold—for triggering *stop short* and for setting
    some bounds or expectations for our users.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，延迟预算是一个我很少听到讨论的话题。鉴于我们行业中API的普遍存在，也许我们应该更多地讨论它们。它们的重要性是双重的——用于触发*停止*和为我们的用户设定一些界限或期望。
- en: When we publish our *maximum execution time* along with our API documentation,
    users will have clear expectations of our *worst-case* performance. Additionally,
    we can use the errors generated by the latency budget to return more informative
    error messages, further enabling the user to make more informed decisions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在API文档中发布我们的*最大执行时间*时，用户将清楚地了解我们的*最坏情况*性能期望。此外，我们可以利用延迟预算生成的错误返回更具信息性的错误消息，进一步使用户能够做出更明智的决定。
- en: Chapter 8, Dependency Injection by Config
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章，通过配置进行依赖注入
- en: '**1\. How does config injection differ from method or constructor injection?**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 配置注入与方法或构造函数注入有何不同？
- en: Config injection is an extended form of method and constructor injection. It
    intends to improve the UX of the code by hiding common and environmental concerns.
    This reduction in parameters makes the methods easier to understand, extend, and
    maintain.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 配置注入是方法和构造函数注入的扩展形式。它旨在通过隐藏常见和环境问题来改善代码的用户体验。减少参数使方法更易于理解、扩展和维护。
- en: '**2\. How do we decide what parameters to move to config injection?**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 我们如何决定将哪些参数移动到配置注入中？
- en: The key point to consider is how the parameter relates to the method or constructor.
    If the dependency is insignificant but necessary, such as loggers and instrumentation,
    then hiding it in the config improves the clarity of the function signature rather
    than detracting from it. Similarly, configuration coming from a config file is
    often necessary but not informative.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的关键点是参数与方法或构造函数的关系。如果依赖关系微不足道但又是必要的，比如记录器和仪器，那么将其隐藏在配置中会提高函数签名的清晰度，而不是削弱它。同样，来自配置文件的配置通常是必要的但不具信息性。
- en: '**3\. Why don''t we inject all dependencies via config injection?**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 为什么我们不通过配置注入来注入所有的依赖关系？
- en: There are two significant issues with merging all the dependencies into one.
    The first is readability. Users of the method/function would have to open the
    definition of the config every time they wished to understand what parameters
    were available. Secondly, as an interface, users would be forced to create and
    maintain an implementation of the interface that could provide all of the parameters.
    While all config may come from the same place, other dependencies likely do not.
    The inclusion of the environmental dependencies is a little cheeky but their existence
    is almost ubiquitous, and their duplication across every constructor would be
    really annoying.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有依赖项合并为一个存在两个重要问题。第一个是可读性。方法/函数的用户必须每次都打开配置定义，才能了解可用的参数。其次，作为接口，用户将被迫创建和维护一个可以提供所有参数的接口实现。虽然所有配置可能来自同一位置，但其他依赖关系可能不是。包括环境依赖有点狡猾，但它们的存在几乎是无处不在的，它们在每个构造函数中的重复将会非常恼人。
- en: '**4\. Why do we want to inject environmental dependencies (such as loggers)
    instead of using a global public variable?**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 为什么我们想要注入环境依赖（如记录器）而不是使用全局公共变量？
- en: As programmers, we like the **Don't Repeat Yourself** (**DRY**) principle. Injecting
    environmental dependencies everywhere is a lot of repeating.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们喜欢**不要重复自己**（**DRY**）原则。在所有地方注入环境依赖是很多重复的。
- en: '**5\. Why are boundary tests important?**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 为什么边界测试很重要？
- en: I hope we can all agree that it's important to test. Part of the value of testing
    is through running the tests repeatedly and detecting regression as soon as possible.
    To minimize the cost of running the tests often, we need the tests to be reasonably
    fast and absolutely reliable. When tests depend on an external system, particularly
    one that we are not responsible for, then we are putting the value of our tests
    at risk.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我们都能同意测试很重要。测试的价值部分来自重复运行测试并尽快检测到回归。为了最小化频繁运行测试的成本，我们需要测试速度相当快且绝对可靠。当测试依赖于外部系统，特别是我们不负责的系统时，我们就会把测试的价值置于风险之中。
- en: Anything can happen to an external system. The owner could break it; the internet/network
    could go down. Internal-facing boundary tests are similar to our unit tests. They
    protect our code from regression. External-facing boundary tests are our automated
    way of documenting and ensuring that the external system does what we need it
    to do.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 外部系统可能发生任何事情。所有者可能会破坏它；互联网/网络可能会中断。面向内部的边界测试类似于我们的单元测试。它们保护我们的代码免受回归的影响。面向外部的边界测试是我们自动化记录和确保外部系统执行我们需要它执行的方式。
- en: '**6\. What are the ideal use cases for config injection?**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 配置注入的理想用例是什么？
- en: Config injection can be used in the same situations as constructor or method
    injection. The key deciding factor is whether the dependencies themselves should
    be combined and somewhat hidden by config injection and how that improves or detracts
    from the UX of the code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 配置注入可以在与构造函数或方法注入相同的情况下使用。关键的决定因素是依赖项本身是否应该通过配置注入进行组合并在一定程度上隐藏，并且这如何改进或减少代码的用户体验。
- en: Chapter 9, Just-in-Time Dependency Injection
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章，即时依赖注入
- en: '**1\. How does Just-in-Time** (**JIT**) **dependency injection differ from
    constructor injection?**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. JIT（即时）依赖注入与构造函数注入有何不同？**'
- en: This depends a lot on how the constructor injection is being used; in particular,
    how many different implementations of the dependency exist. If there is only one
    production implementation of a dependency, then they are functionally equivalent.
    The only difference is UX (that is, whether there is one less dependency to inject
    into the constructor).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很大程度上取决于构造函数注入的使用方式；特别是依赖项有多少不同的实现。如果只有一个依赖项的生产实现，那么它们在功能上是等效的。唯一的区别是用户体验（即，是否有一个更少的依赖项注入到构造函数中）。
- en: If, however, there is more than one production implementation, then JIT dependency
    injection cannot be used.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果有多个生产实现，那么就不能使用JIT依赖注入。
- en: '**2\. When working with optional dependencies, why is using a NO-OP implementation
    important?**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 在处理可选依赖项时，为什么使用NO-OP实现很重要？**'
- en: When a member variable is not set by the constructor, then it is effectively
    optional. We cannot, therefore, be sure that the value has been set and not nil.
    By adding a NO-OP implementation of the optional dependency and automatically
    setting it to the member variable, we are able to assume that the dependency is
    always non-nil and we can forgo the need for guard clauses.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当成员变量没有被构造函数设置时，它实际上是可选的。因此，我们无法确定该值是否已设置且不为nil。通过添加可选依赖项的NO-OP实现并自动将其设置为成员变量，我们可以假定该依赖项始终不为nil，因此我们可以放弃对守卫子句的需求。
- en: '**3\. What are the ideal use cases for JIT injection?**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**3. JIT注入的理想用例是什么？**'
- en: 'JIT injection is ideal for the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: JIT注入非常适合以下情况：
- en: Replacing a dependency that would otherwise have been injected into the constructor
    and of which there is only one production implementation
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换本应注入构造函数的依赖项，且只有一个生产实现
- en: Providing a layer of indirection or abstraction between an object and a global
    singleton, particularly when we want to swap out the global singleton during testing
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象和全局单例之间提供一层间接或抽象，特别是当我们想在测试期间替换全局单例时
- en: Allowing dependencies to be optionally provided by the user
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户选择性地提供依赖项
- en: Chapter 10, Off-the-Shelf Injection
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章，现成的注入
- en: '**1\. When adopting a dependency injection framework, what can you expect to
    gain?**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. 采用依赖注入框架时，可以期待获得什么？**'
- en: 'This, of course, differs significantly between frameworks, but typically, you
    can expect to see the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这在不同的框架之间有很大的不同，但通常，你可以期待看到以下内容：
- en: A reduction in boilerplate code
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少样板代码
- en: Less complexity in setting up and maintaining the dependency creation order
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少设置和维护依赖项创建顺序的复杂性
- en: '**2\. When evaluating a dependency injection framework, what kind of issues
    should you being looking out for?**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 在评估依赖注入框架时，应该注意哪些问题？**'
- en: Beyond the gains mentioned previously, my primary criterion is the effect it
    has on the code; putting it a different way, whether I like how the code looks
    after adopting the framework.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前提到的收益之外，我的主要标准是它对代码的影响；换句话说，我是否喜欢在采用框架后代码的外观。
- en: I would also consider the configurability of the framework itself. Some configuration
    is expected, but too much can lead to a complicated UX.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我还会考虑框架本身的可配置性。一些配置是可以预期的，但太多可能会导致复杂的用户体验。
- en: The last aspect to consider is the health of the framework project. Is it being
    actively maintained? Are reported bugs being responded to? Switching between frameworks
    may not be cheap; it is a good idea to spend a little bit of time ensuring the
    one you choose is right for you in the long term.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要考虑的是框架项目的健康状况。它是否在积极维护？报告的错误是否得到了回应？在不同框架之间切换可能不会很便宜；花点时间确保你选择的框架长期来看是合适的是个好主意。
- en: '**3\. What the ideal use cases for adopting off-the-shelf injection?**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**3. 采用现成的注入的理想用例是什么？**'
- en: Typically, frameworks only support constructor injection. Off-the-shelf injection
    can, therefore, be used in projects that already use constructor injection.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，框架只支持构造函数注入。因此，已经使用构造函数注入的项目可以使用现成的注入。
- en: '** 4\. Why is it important to protect your service from accidental API changes?**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**4. 为什么重要保护服务免受意外API更改的影响？**'
- en: The API of a service is sometimes described as a contract. The word *contract*
    has been carefully chosen as it intends to convey how significant and binding
    the relationship is between the API and its users.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的API有时被描述为一个合同。 *合同* 这个词被精心选择，因为它意在传达API与其用户之间的关系是多么重要和有约束力。
- en: When we publish an API, we do not have control over how our users use our API
    and, perhaps more importantly, we have no control over how their software reacts
    to changes in our API. For us to deliver on our contract, it is imperative that
    we do everything we can to ensure we do not break their software by making unplanned
    changes to our API.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发布API时，我们无法控制用户如何使用我们的API，也许更重要的是，我们无法控制他们的软件对我们API的更改做出反应。为了履行我们的合同，我们必须尽一切努力确保我们不会通过对API的计划外更改来破坏他们的软件。
- en: Chapter 11, Curbing Your Enthusiasm
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章，控制你的热情
- en: '**1\. What form of dependency injection-induced damage do you see most often?**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. 你最常见到的依赖注入引起的损害形式是什么？**'
- en: For me, this is absolutely *excessive parameters*. After learning dependency
    injection and getting excited about it, it's easy to want to abstract and inject
    everything. It tends to make testing a lot easier as the *responsibility* of each
    object decreases. The downside is a lot of objects and too much injection.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这绝对是*过多参数*。学习了依赖注入并对此感到兴奋后，很容易想要抽象和注入所有东西。这往往会使测试变得更容易，因为每个对象的*责任*都减少了。缺点是有很多对象和太多的注入。
- en: If I find myself with too many dependencies, I will try to step back and check
    my object design, looking for single responsibility principle issues in particular.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我发现自己有太多的依赖关系，我会尝试退后一步，检查我的对象设计，特别是寻找单一责任原则方面的问题。
- en: '**2\. Why is it important not to blindly apply dependency injection all the
    time?**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 为什么不应该一味地应用依赖注入？**'
- en: Just because something is *cool* or new, doesn't mean it's the best tool for
    the job. We should always strive to fix the solution to the problem and avoid
    *c**argo cult* programming when we can.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为某些东西很“酷”或者新颖，并不意味着它就是最适合这项工作的工具。我们应该始终努力解决问题的解决方案，并在可以的时候避免“模仿”编程。
- en: '**3\. Does adopting a framework, such as Google Wire, eliminate all forms of
    dependency injection-induced damage?**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**3. 采用Google Wire等框架是否消除了依赖注入引起的所有问题？**'
- en: Sadly, no. Given that it only supports constructor injection, it cannot even
    be applied in all situations. Beyond that, it can make the management of *excessive
    parameters* significantly less painful.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，不是。鉴于它只支持构造函数注入，它甚至不能在所有情况下应用。除此之外，它可以显著减少*过多参数*的管理痛苦。
- en: While that is a good thing, the fact that it alleviates the pain makes it less
    likely that we will feel the need to address the underlying issue.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一件好事，但它减轻了痛苦，这使我们不太可能感到有必要解决潜在的问题。
- en: Chapter 12, Reviewing Our Progress
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章，回顾我们的进展
- en: '**1\. What was the most important improvement made to our sample service?**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. 对我们的示例服务进行的最重要的改进是什么？**'
- en: This is subjective, and as such, there is no right answer. For me, it's either
    the decoupling or the removal of the globals. When the code becomes decoupled,
    it becomes easier for me test and each piece becomes a bite-sized chunk, which
    means it's easy to work on. Basically, I don't have to think too hard or remember
    too much context.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主观的，因此没有正确答案。对我来说，要么是解耦，要么是去除全局变量。当代码解耦时，测试变得更容易，每个部分都变成了一小块，这意味着很容易处理。基本上，我不必费太多心思或记住太多上下文。
- en: As to the globals, I've been bitten by this in the past, particularly the data
    races that happen during testing. I can't stand it when my tests are not reliable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 就全局变量而言，我过去曾受到过这方面的影响，特别是在测试过程中发生的数据竞争。我无法忍受我的测试不可靠。
- en: '**2\. In our dependency graph, why isn''t the data package under main?**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 在我们的依赖图中，为什么数据包不在主包下？**'
- en: We could refactor to make it this way, but at the moment we are using JIT injection
    between the model and data layers. This means the UX of the code is improved,
    but the dependency graph is not as flat as it could be. The data layer is also
    outputting DTOs instead of base data types, so any users will also be using the
    data package.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构成这种方式，但目前我们正在模型和数据层之间使用JIT注入。这意味着代码的用户体验得到了改善，但依赖图并不像它本应该的那样平坦。数据层还输出DTOs而不是基本数据类型，因此任何用户也将使用数据包。
- en: If we were determined to remove this as well, we could make a special package
    for the DTO and then exclude that package from the dependency graph, but that's
    extra work that does not gain us much as this point.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定也要移除这个，我们可以为DTO制作一个特殊的包，然后将该包从依赖图中排除，但这是额外的工作，目前并没有太多好处。
- en: '**3\. What would you do differently if you were starting a new service?**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**3. 如果您要启动一个新的服务，您会做些什么不同？**'
- en: This is subjective, and as such, there is no right answer. After doing the UX
    survey, I would first write enough code to get a web server started, even if this
    was not yet using dependency. I would then design all of the endpoints and implement
    them with hard-coded responses. This would give me the ability to discuss, with
    examples, my deliverables with the users. I would also be able to put in some
    end-to-end tests to prevent any API regression.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主观的，因此没有正确答案。在进行用户体验调查后，我会首先编写足够的代码启动一个Web服务器，即使这时还没有使用依赖。然后我会设计所有的端点，并使用硬编码的响应来实现它们。这将使我能够用示例来与用户讨论我的可交付成果。我还可以进行一些端到端的测试，以防止任何API回归。
- en: My users would then be able to go ahead, with confidence and clarity about my
    API, and I would be able to *fill in the details*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我的用户就可以放心地继续，对我的API有清晰的认识，我也可以填写细节。
