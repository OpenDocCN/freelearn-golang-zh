["```go\npackage hello_test \nimport ( \n    \"fmt\" \n    \"testing\" \n) \nfunc BenchmarkHello(b *testing.B) { // Benchmark definition \n    for i := 0; i < b.N; i++ { \n        fmt.Sprintf(\"Hello High Performance Go\")\n    } \n}\n```", "```go\n$ go test -bench=. -benchtime 2s -count 2 -benchmem -cpu 4\n```", "```go\ngo get golang.org/x/perf/cmd/benchstat\n```", "```go\n[bob@testhost single]$ go test -bench=. -count 5 -cpu 1,2,4 > ~/single.txt\n[bob@testhost multi]$ go test -bench=. -count 5 -cpu 1,2,4 > ~/multi.txt\n[bob@testhost ~]$ benchstat -html -sort -delta single.txt multi.txt > out.html\n```", "```go\npackage main\nimport \"fmt\"\nfunc main() {\n   words := [3]string{\"foo\", \"bar\", \"baz\"}\n   fmt.Println(words[1]) // This references the string in position 1 in the array, \"bar\"\n}\n```", "```go\npackage oone\n\nfunc ThreeWords() string {\n  threewords := [3]string{\"foo\", \"bar\", \"baz\"}\n  return threewords[1]\n}\n\nfunc TenWords() string {\n  tenwords := [10]string{\"foo\", \"bar\", \"baz\", \"qux\", \"grault\", \"waldo\", \"plugh\", \"xyzzy\", \"thud\", \"spam\"}\n  return tenwords[6]\n}\n```", "```go\nfunc Search(n int, f func(int) bool) int {\n  // Define f(-1) == false and f(n) == true.\n  // Invariant: f(i-1) == false, f(j) == true.\n  i, j := 0, n\n  for i < j {\n    h := int(uint(i+j) >> 1) // avoid overflow when computing h\n    // i \u2264 h < j\n    if !f(h) {\n      i = h + 1 // preserves f(i-1) == false\n    } else {\n      j = h // preserves f(j) == true\n    }\n  }\n  // i == j, f(i-1) == false, and f(j) (= f(i)) == true => answer is i.\n  return i\n}\n```", "```go\nfunc quickSort(data Interface, a, b, maxDepth int) {\n  for b-a > 12 { // Use ShellSort for slices <= 12 elements\n    if maxDepth == 0 {\n      heapSort(data, a, b)\n      return\n    }\n    maxDepth--\n    mlo, mhi := doPivot(data, a, b)\n    // Avoiding recursion on the larger subproblem guarantees\n    // a stack depth of at most lg(b-a).\n    if mlo-a < b-mhi {\n      quickSort(data, a, mlo, maxDepth)\n      a = mhi // i.e., quickSort(data, mhi, b)\n    } else {\n      quickSort(data, mhi, b, maxDepth)\n      b = mlo // i.e., quickSort(data, a, mlo)\n    }\n  }\n  if b-a > 1 {\n    // Do ShellSort pass with gap 6\n    // It could be written in this simplified form cause b-a <= 12\n    for i := a + 6; i < b; i++ {\n      if data.Less(i, i-6) {\n        data.Swap(i, i-6)\n      }\n    }\n    insertionSort(data, a, b)\n  }\n}\n```", "```go\nfunc insertionSort(data Interface, a, b int) {\n  for i := a + 1; i < b; i++ {\n    for j := i; j > a && data.Less(j, j-1); j-- {\n      data.Swap(j, j-1)\n    }\n  }\n}\n```", "```go\nfunc heapSort(data Interface, a, b int) {\n  first := a\n  lo := 0\n  hi := b - a\n  // Build heap with greatest element at top.\n  for i := (hi - 1) / 2; i >= 0; i-- {\n    siftDown(data, i, hi, first)\n  }\n  // Pop elements, largest first, into end of data.\n  for i := hi - 1; i >= 0; i-- {\n    data.Swap(first, first+i)\n    siftDown(data, lo, i, first)\n  }\n}\n```", "```go\nfunc stable(data Interface, n int) {\n  blockSize := 20 // must be > 0\n  a, b := 0, blockSize\n  for b <= n {\n    insertionSort(data, a, b)\n    a = b\n    b += blockSize\n  }\n\n  insertionSort(data, a, n)\n  for blockSize < n {\n    a, b = 0, 2*blockSize\n    for b <= n {\n      symMerge(data, a, a+blockSize, b)\n      a = b\n      b += 2 * blockSize\n    }\n\n    if m := a + blockSize; m < n {\n      symMerge(data, a, m, n)\n    }\n    blockSize *= 2\n  }\n}\n```", "```go\nfunc LinearSearch(data []int, searchVal int) bool { \nfor _, key := range data {\n       if key == searchVal {\n           return true\n       }\n   }\n   return false\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc main() {\n    intArray := []int{0, 2, 3, 5, 11, 16, 34}\n    searchNumber := 34\n    sorted := sort.SearchInts(intArray, searchNumber)\n    if sorted < len(intArray) {\n        fmt.Printf(\"Found element %d at array position %d\\n\", searchNumber, sorted)\n    } else {\n        fmt.Printf(\"Element %d not found in array %v\\n\", searchNumber, intArray)\n    }\n}\n```", "```go\nfunc (e *Element) Next() *Element {\nfunc (e *Element) Prev() *Element {\nfunc (l *List) Init() *List {\nfunc New() *List { return new(List).Init() }\nfunc (l *List) Len() int { return l.len }\nfunc (l *List) Front() *Element {\nfunc (l *List) Back() *Element {\nfunc (l *List) lazyInit() {\nfunc (l *List) insert(e, at *Element) *Element {\nfunc (l *List) insertValue(v interface{}, at *Element) *Element {\nfunc (l *List) remove(e *Element) *Element {\nfunc (l *List) move(e, at *Element) *Element {\nfunc (l *List) Remove(e *Element) interface{} {\nfunc (l *List) PushFront(v interface{}) *Element {\nfunc (l *List) PushBack(v interface{}) *Element {\nfunc (l *List) InsertBefore(v interface{}, mark *Element) *Element {\nfunc (l *List) InsertAfter(v interface{}, mark *Element) *Element {\nfunc (l *List) MoveToFront(e *Element) {\nfunc (l *List) MoveToBack(e *Element) {\nfunc (l *List) MoveBefore(e, mark *Element) {\nfunc (l *List) MoveAfter(e, mark *Element) {\nfunc (l *List) PushBackList(other *List) {\nfunc (l *List) PushFrontList(other *List) {\n```"]