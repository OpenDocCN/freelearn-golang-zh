["```go\nfunc HelloGo(){\n  fmt.Println(\"Hello Go\")\n}\n```", "```go\n// Note the trailing () for this anonymous function invocation\nfunc() { \n    fmt.Println(\"Hello Go\")\n}()\n```", "```go\n    fmt.Println(\"Hello Go from an Anonymous Function Assigned to a Variable\")\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc helloGo() {\n    fmt.Println(\"Hello Go from a Function\")\n\n} \n\nfunc main() {   \n    helloGo() \n    func() { fmt.Println(\"Hello Go from an Anonymous Function\") }()\n    var hello func() = func() { fmt.Println(\"Hello Go from an Anonymous Function Variable\") }\n    hello()\n} \n```", "```go\npackage main \nimport \"fmt\" \nfunc incrementCounter() func() int {\n var initializedNumber = 0\n return func() int {\n initializedNumber++\n return initializedNumber\n } \n} \n\nfunc main() {\n n1 := incrementCounter() \n fmt.Println(\"n1 increment counter #1: \", n1()) // First invocation of n1\n fmt.Println(\"n1 increment counter #2: \", n1()) // Notice the second invocation; n1 is called twice, so n1 == 2\n n2 := incrementCounter() // New instance of initializedNumber\n fmt.Println(\"n2 increment counter #1: \", n2()) // n2 is only called once, so n2 == 1\n fmt.Println(\"n1 increment counter #3: \", n1()) // state of n1 is not changed with the n2 calls\n}\n```", "```go\npackage main\nimport (\n \"fmt\"\n \"sort\"\n) \n\nfunc main() {\n input := []string{\"foo\", \"bar\", \"baz\"}\n var result []string\n // closure callback\n func() {\n result = append(input, \"abc\") // Append to the array\n result = append(result, \"def\") // Append to the array again\n sort.Sort(sort.StringSlice(result)) // Sort the larger array\n }() \n fmt.Print(result)\n}\n```", "```go\npackage main\n\nimport (\n \"fmt\"\n \"net/http\"\n) \n\n// Checks for a \"user:admin\" header, proper credentials for the admin path\nfunc adminCheck(h http.Handler) http.HandlerFunc {\n return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n if r.Header.Get(\"user\") != \"admin\" {\n http.Error(w, \"Not Authorized\", 401)\n return\n }\n fmt.Fprintln(w, \"Admin Portal\")\n h.ServeHTTP(w, r)\n }) \n} \n```", "```go\n// Sets a HTTP 418 (I'm a Teapot) status code for the response\nfunc newStatusCode(h http.Handler) http.HandlerFunc {\n return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n w.WriteHeader(http.StatusTeapot)\n h.ServeHTTP(w, r)\n })\n}\n\n// Adds a header, Foo:Bar\nfunc addHeader(h http.Handler) http.HandlerFunc {\n return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n w.Header().Add(\"Foo\", \"Bar\")\n h.ServeHTTP(w, r)\n })\n}\n\n// Writes a HTTP Response\nfunc writeResponse(w http.ResponseWriter, r *http.Request) {\n fmt.Fprintln(w, \"Hello PerfGo!\")\n} \n```", "```go\n// Wrap the middleware together\nfunc main() {\n handler := http.HandlerFunc(writeResponse)\n http.Handle(\"/\", addHeader(newStatusCode(handler)))\n http.Handle(\"/onlyHeader\", addHeader(handler)) \n http.Handle(\"/onlyStatus\", newStatusCode(handler))\n http.Handle(\"/admin\", adminCheck(handler))\n http.ListenAndServe(\":1234\", nil)\n}\n```", "```go\npackage main\n\nimport (\n \"fmt\"\n \"time\"\n) \n\nfunc printSleep(s string) {\n for index, stringVal := range s {\n fmt.Printf(\"%#U at index %d\\n\", stringVal, index)\n time.Sleep(1 * time.Millisecond) // printSleep sleep timer\n } \n} \n\nfunc main() {\n const t time.Duration = 9 \n go printSleep(\"HELLO GOPHERS\")\n time.Sleep(t * time.Millisecond) // Main sleep timer\n fmt.Println(\"sleep complete\")\n} \n```", "```go\ntype hchan struct {\n    qcount   uint           // total data in the queue\n    dataqsiz uint           // size of the circular queue\n    buf      unsafe.Pointer // points to an array of dataqsiz elements\n    elemsize uint16\n    closed   uint32\n    elemtype *_type // element type\n    sendx    uint   // send index\n    recvx    uint   // receive index\n    recvq    waitq  // list of recv waiters\n    sendq    waitq  // list of send waiters\n    // lock protects all fields in hchan, as well as several\n    // fields in sudogs blocked on this channel.\n    //  \n    // Do not change another G's status while holding this lock\n    // (in particular, do not ready a G), as this can deadlock\n    // with stack shrinking.\n    lock mutex\n}\n```", "```go\npackage main\nimport \"fmt\"\n func main() {\n buffered_channel := make(chan string, 2)\n buffered_channel <- \"foo\"\n buffered_channel <- \"bar\"\n\n // Length of channel is 2 because both elements added to channel\n fmt.Println(\"Channel Length After Add: \", len(buffered_channel))\n\n // Pop foo and bar off the stack\n fmt.Println(<-buffered_channel)\n fmt.Println(<-buffered_channel)\n\n // Length of channel is 0 because both elements removed from channel\n fmt.Println(\"Channel Length After Pop: \", len(buffered_channel)) \n\n // Push baz to the stack\n buffered_channel <- \"baz\"\n\n // Store baz as a variable, out\n out := <-buffered_channel\n fmt.Println(out)\n close(buffered_channel)\n}\n```", "```go\npackage main\n func main() {\n ch := make(chan string, 1) \n close(ch)\n ch <- \"foo\"\n}\n```", "```go\npackage main \n func main() {\n ch := make(chan string, 1)\nch <- \"foo\"\nch <- \"bar\"\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\n    bufferedChannel := make(chan int, 3)\n    bufferedChannel <- 1\n    bufferedChannel <- 3\n    bufferedChannel <- 5\n    close(bufferedChannel)                                                                                                                  \n    for i := range bufferedChannel {\n        fmt.Println(i)\n    }   \n} \n\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"sort\"\n)\nfunc sortInts(intArray[] int, done chan bool) {\n    sort.Ints(intArray)\n    fmt.Printf(\"Sorted Array: %v\\n\", intArray)\n    done < -true\n}\n```", "```go\nfunc searchInts(intArray []int, searchNumber int, done chan bool) {\n    sorted := sort.SearchInts(intArray, searchNumber)\n    if sorted < len(intArray) {\n        fmt.Printf(\"Found element %d at array position %d\\n\", searchNumber, sorted)\n    } else {\n        fmt.Printf(\"Element %d not found in array %v\\n\", searchNumber, intArray)\n    }       \n    done <- true\n}        \n```", "```go\nfunc main() {\n    ch := make(chan bool)\n    go func() {\n        s := []int{2, 11, 3, 34, 5, 0, 16} // unsorted\n        fmt.Println(\"Unsorted Array: \", s)\n        searchNumber := 16\n        sortInts(s, ch)\n        searchInts(s, searchNumber, ch)\n    }()\n    <-ch\n}             \n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n) \n\nfunc main() {\n\n    // Make 3 channels\n    ch1 := make(chan string)\n    ch2 := make(chan bool)\n    ch3 := make(chan rune)\n```", "```go\n    // string anonymous function to ch1\n    go func() {\n        ch1 <- \"channels are fun\"\n    }() \n\n    // bool anonymous function to ch2\n    go func() {\n        ch2 <- true\n    }() \n\n    // rune anonymous function to ch3 with 1 second sleep\n    go func() {\n        time.Sleep(1 * time.Second)\n        ch3 <- 'r' \n    }() \n```", "```go\n\n    // select builtin to return values from channels                                                                                        \n    for i := 0; i < 3; i++ {\n        select {\n        case msg1 := <-ch1:\n            fmt.Println(\"Channel 1 message: \", msg1)\n        case msg2 := <-ch2:\n            fmt.Println(\"Channel 2 message: \", msg2)\n        case msg3 := <-ch3:\n            fmt.Println(\"Channel 3 message: \", msg3)\n        }   \n    }   \n}       \n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)       \n\nfunc main() {\n    var out = make([]string, 5)                                                                                                             \n    for i := 0; i < 5; i++ {\n        time.Sleep(100 * time.Millisecond)\n        out[i] = \"This loop is slow\\n\"\n    }   \n    fmt.Println(out)\n}       \n```", "```go\npackage main\n\nimport (\n \"context\"\n \"fmt\"\n \"runtime\"\n \"time\"\n\n \"golang.org/x/sync/semaphore\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    var (\n        sem    = semaphore.NewWeighted(int64(runtime.GOMAXPROCS(0)))\n        result = make([]string, 5)\n    )   \n```", "```go\n\n    for i := range result {\n        if err := sem.Acquire(ctx, 1); err != nil {\n            break\n        }\n        go func(i int) {\n            defer sem.Release(1)\n            time.Sleep(100 * time.Millisecond)\n            result[i] = \"Semaphores are Cool \\n\"\n        }(i)\n    }   \n    if err := sem.Acquire(ctx, int64(runtime.GOMAXPROCS(0))); err != nil {\n        fmt.Println(\"Error acquiring semaphore\")\n    }   \n    fmt.Println(result)\n}    \n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"sync\"\n    \"time\"\n) \n\nfunc retrieve(url string, wg *sync.WaitGroup) {\n    // WaitGroup Counter-- when goroutine is finished\n    defer wg.Done() \n    start := time.Now()\n    res, err := http.Get(url)\n    end := time.Since(start)\n    if err != nil {\n        panic(err)\n    } \n    // print the status code from the response\n    fmt.Println(url, res.StatusCode, end) \n\n} \n```", "```go\nfunc main() {\n    var wg sync.WaitGroup\n    var urls = []string{\"https://godoc.org\", \"https://www.packtpub.com\", \"https://kubernetes.io/\"}\n    for i := range urls {\n        // WaitGroup Counter++ when new goroutine is called\n        wg.Add(1) \n        go retrieve(urls[i], &wg)\n    }\n    // Wait for the collection of goroutines to finish \n    wg.Wait()\n} \n```", "```go\npackage iterators\n\nvar sumLoops int\nfunc simpleLoop(n int) int {\n    for i: = 0; i < n; i++ {\n        sumLoops += i\n    }\n    return sumLoops\n}\n```", "```go\npackage iterators\n\nvar sumCallback int\n\nfunc CallbackLoop(top int) {\n    err: = callbackLoopIterator(top, func(n int) error {\n        sumCallback += n\n        return nil\n    })\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc callbackLoopIterator(top int, callback func(n int) error) error {\n    for i: = 0; i < top; i++{\n        err: = callback(i)\n        if err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```", "```go\npackage iterators\n\nvar sumNext int\n\ntype CounterStruct struct {\n    err error\n    max int\n    cur int\n}\n\nfunc NewCounterIterator(top int) * CounterStruct {\n    var err error\n    return &CounterStruct {\n        err: err,\n        max: top,\n        cur: 0,\n    }\n}\n```", "```go\nfunc(i * CounterStruct) Next() bool {\n    if i.err != nil {\n        return false\n    }\n    i.cur++\n        return i.cur <= i.max\n}\nfunc(i * CounterStruct) Value() int {\n    if i.err != nil || i.cur > i.max {\n        panic(\"Value is not valid after iterator finished\")\n    }\n    return i.cur\n}\nfunc NextLoop(top int) {\n    nextIterator: = NewCounterIterator(top)\n    for nextIterator.Next() {\n        fmt.Print(nextIterator.Value())\n    }\n}\n```", "```go\npackage iterators\n\nvar sumBufferedChan int\n\nfunc BufferedChanLoop(n int) int {\n\n    ch: = make(chan int, n)\n\n        go func() {\n        defer close(ch)\n        for i: = 0;\n        i < n;\n        i++{\n            ch < -i\n        }\n    }()\n\n    for j: = range ch {\n        sumBufferedChan += j\n    }\n    return sumBufferedChan\n}\n```", "```go\npackage iterators\n\nvar sumUnbufferedChan int\n\nfunc UnbufferedChanLoop(n int) int {\n    ch: = make(chan int)\n\n        go func() {\n        defer close(ch)\n        for i: = 0;\n        i < n;\n        i++{\n            ch < -i\n        }\n    }()\n\n    for j: = range ch {\n        sumUnbufferedChan += j\n    }\n    return sumUnbufferedChan\n}\n```", "```go\npackage iterators\n\nimport \"testing\"\n\nfunc benchmarkLoop(i int, b *testing.B) {\n    for n := 0; n < b.N; n++ {\n        simpleLoop(i)\n    } \n}\n\nfunc benchmarkCallback(i int, b *testing.B) {\n    b.ResetTimer()\n    for n := 0; n < b.N; n++ {\n        CallbackLoop(i)\n    } \n}\n```", "```go\nfunc benchmarkNext(i int, b *testing.B) {\n    b.ResetTimer()\n    for n := 0; n < b.N; n++ {\n        NextLoop(i)\n    } \n}\n\nfunc benchmarkBufferedChan(i int, b *testing.B) {\n    b.ResetTimer()\n    for n := 0; n < b.N; n++ {\n        BufferedChanLoop(i)\n    } \n}\n```", "```go\nfunc benchmarkUnbufferedChan(i int, b *testing.B) {\n    b.ResetTimer()\n    for n := 0; n < b.N; n++ {\n        UnbufferedChanLoop(i)\n    }   \n}\n\nfunc BenchmarkLoop10000000(b *testing.B)           { benchmarkLoop(1000000, b) }\nfunc BenchmarkCallback10000000(b *testing.B)       { benchmarkCallback(1000000, b) }\nfunc BenchmarkNext10000000(b *testing.B)           { benchmarkNext(1000000, b) }\nfunc BenchmarkBufferedChan10000000(b *testing.B)   { benchmarkBufferedChan(1000000, b) }\nfunc BenchmarkUnbufferedChan10000000(b *testing.B) { benchmarkUnbufferedChan(1000000, b) }   \n```"]