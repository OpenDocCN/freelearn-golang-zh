- en: Understanding Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并发
- en: Iterators and generators are essential to Go. Utilizing channels and goroutines
    for parallelism and concurrency is idiomatic in Go and is one of the best ways
    to write high-performance, readable code in the language. We are going to first
    talk about some of the basic Go constructs in order to be able to understand how
    to use iterators and generators in the context of Go, followed by deep dives into
    the constructs of the available iterators and generators of the language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器和生成器对于Go至关重要。在Go中使用通道和goroutine进行并行和并发是Go中的惯用法，也是编写高性能、可读性强的代码的最佳方式之一。我们首先将讨论一些基本的Go构造，以便能够理解如何在Go的上下文中使用迭代器和生成器，然后深入探讨语言中可用的迭代器和生成器的构造。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Closures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Goroutines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goroutines
- en: Channels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道
- en: Semaphores
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号量
- en: WaitGroups
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WaitGroups
- en: Iterators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Generators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Being able to understand the basic constructs of the Go language and when and
    where to use the proper iterators and generators is essential to writing performant
    Go.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 能够理解Go语言的基本构造以及何时何地使用适当的迭代器和生成器对于编写高性能的Go语言至关重要。
- en: Understanding closures
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解闭包
- en: One of the most important parts of Go is that it is a language that supports
    first-class functions. First-class functions are functions that have the ability
    to be passed to other functions as variables. They can also be returned from other
    functions. This is important to note because we can use them as closures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言最重要的部分之一是它是一种支持头等函数的语言。头等函数是具有作为变量传递给其他函数的能力的函数。它们也可以从其他函数返回。这一点很重要，因为我们可以将它们用作闭包。
- en: Closures are helpful because they are a great way to keep your code DRY as well
    as helping to isolate your data. Keeping datasets small has been a core tenet
    of this book thus far, and that doesn't change in this chapter (nor any subsequent
    chapter). Being able to isolate the data that you wish to manipulate can help
    you to continue to write performant code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包很有帮助，因为它们是保持代码DRY的好方法，同时有助于隔离数据。到目前为止，保持数据集小是本书的核心原则，这在本章（以及任何后续章节）中都没有改变。能够隔离希望操作的数据可以帮助您继续编写高性能的代码。
- en: Closures keep a local scope and have access to the outer function's scope and
    parameters, as well as global variables. Closures are functions that reference
    variables outside of their body. These functions have the ability to assign values
    to the referenced variables and access those values, so in turn, we can pass closures
    between functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包保持局部作用域，并访问外部函数的作用域和参数，以及全局变量。闭包是引用其主体外部的变量的函数。这些函数有能力为引用的变量分配值并访问这些值，因此我们可以在函数之间传递闭包。
- en: Anonymous functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数
- en: The first step to understanding closures in Go is to understand anonymous functions.
    An anonymous function is created using a variable for the inception of the function.
    They are also functions that don't have a name or identifier, hence the name *anonymous
    functions*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Go中的闭包的第一步是理解匿名函数。使用变量创建匿名函数。它们也是没有名称或标识符的函数，因此称为*匿名函数*。
- en: 'A normal function invocation to print `Hello Go` to the screen would be what
    is shown in the following code block:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Hello Go`打印到屏幕的普通函数调用将是以下代码块中显示的内容：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we could call `HelloGo()` and the function would print a `Hello Go` string.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以调用`HelloGo()`，函数将打印`Hello Go`字符串。
- en: 'If we wanted to instantiate our `HelloGo()` function as an anonymous function,
    we would invoke this as referenced in the following code block:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将`HelloGo()`函数实例化为匿名函数，我们将在以下代码块中引用它：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our preceding anonymous function and the `HelloGo()` function are lexically
    similar.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的匿名函数和`HelloGo()`函数在词法上是相似的。
- en: 'We could also store a function as a variable for use later on, as referenced
    in the following code block:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将函数存储为变量以供以后使用，如下面的代码块所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All three of these things – the `HelloGo()` function, our anonymous function,
    and the function assigned to the `hello` variable – are lexically similar.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个东西——`HelloGo()`函数、我们之前定义的匿名函数和分配给`hello`变量的函数——在词法上是相似的。
- en: After we've assigned this `hello` variable, we could then call this function
    using a simple invocation of `hello()`, where our preceding defined anonymous
    function would be called and `Hello Go` would be printed to the screen in the
    same fashion that it was printed in our previously called anonymous function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分配了这个`hello`变量之后，我们可以通过简单调用`hello()`来调用这个函数，我们之前定义的匿名函数将被调用，并且`Hello Go`将以与之前调用的匿名函数相同的方式打印到屏幕上。
- en: 'We can see how each of these work in the following code block:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码块中看到这些每个是如何工作的：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output from this program shows three print statements, all similar, with
    small differences in print to show how they were returned in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序的输出显示了三个相似的打印语句，略有不同的打印以显示它们如何在以下截图中返回：
- en: '![](img/695a6215-85af-475b-bfc3-4e9110d09d89.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/695a6215-85af-475b-bfc3-4e9110d09d89.png)'
- en: Anonymous functions are a powerful aspect of Go. As we continue this chapter,
    we'll see how we can build on them to make some very useful things.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数是Go语言的一个强大方面。随着我们继续本章，我们将看到如何在它们的基础上构建一些非常有用的东西。
- en: Anonymous functions with respect to closures
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于闭包的匿名函数
- en: 'You may be wondering at this point why it''s prudent to have anonymous functions
    and how they pertain to closures. Once we have our anonymous function, we can
    then utilize a closure in order to reference variables that are declared outside
    of its own definition. We can see this in the code block that follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能想知道为什么具有匿名函数以及它们与闭包有关是明智的。一旦我们有了匿名函数，我们就可以利用闭包来引用在其自身定义之外声明的变量。我们可以在接下来的代码块中看到这一点：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we execute this code, we receive the following resulting output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行此代码时，我们将收到以下结果输出：
- en: '![](img/14480e66-3518-4501-8e4d-0c64fd8e8580.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14480e66-3518-4501-8e4d-0c64fd8e8580.png)'
- en: In this code sample, we can see how closures can help with data isolation. The
    `n1` variable is initialized with the `incrementCounter()` function. This anonymous
    function sets `initializedNumber` to `0` and returns an integer that is an incremented
    count of the `initializedNumber` variable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们可以看到闭包如何帮助数据隔离。`n1`变量使用`incrementCounter()`函数进行初始化。这个匿名函数将`initializedNumber`设置为`0`，并返回一个增加的`initializedNumber`变量的计数。
- en: When we create the `n2` variable, the same process occurs again. A new `incrementCounter`
    anonymous function is called and a new `initializedNumber` variable is returned.
    In our main function, we can note that `n1` and `n2` have separate maintained
    state. We can see that even after the `n1()` function call is invoked for the
    third time. Being able to persist this data between function calls while also
    isolating the data from another call is a powerful part of having anonymous functions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`n2`变量时，同样的过程再次发生。调用一个新的`incrementCounter`匿名函数，并返回一个新的`initializedNumber`变量。在我们的主函数中，我们可以注意到`n1`和`n2`有单独的维护状态。我们可以看到，即使在第三次调用`n1()`函数之后。能够在函数调用之间保持这些数据，同时还将数据与另一个调用隔离开来，这是匿名函数的一个强大部分。
- en: Closures for nesting and deferring work
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于嵌套和延迟工作的闭包
- en: 'Closures are also often a good way to nest and defer work. In the following
    example, we can see a function closure that allows us to nest work:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包也经常用于嵌套和延迟工作。在下面的例子中，我们可以看到一个函数闭包，它允许我们嵌套工作：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we can see that we append to the string slice twice and sort
    the result. We will later see how we can nest an anonymous function in a goroutine
    to help improve performance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到我们两次向字符串切片添加内容并对结果进行排序。我们稍后将看到如何将匿名函数嵌套在goroutine中以帮助提高性能。
- en: HTTP handlers with closures
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用闭包的HTTP处理程序
- en: Closures are also commonly used as middleware in Go HTTP calls. You can wrap
    normal HTTP function calls around a closure in order to add additional information
    to your calls when you need to and reuse middleware for different functions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包在Go的HTTP调用中也经常用作中间件。您可以将普通的HTTP函数调用包装在闭包中，以便在需要时为调用添加额外的信息，并为不同的函数重用中间件。
- en: 'In our example, we''ll set up an HTTP server with four separate routes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将设置一个具有四个独立路由的HTTP服务器：
- en: '`/`: This serves the following:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：这提供以下内容：'
- en: An HTTP response with an HTTP 418 status code (derived from the `newStatusCode`
    middleware).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有HTTP 418状态码的HTTP响应（来自`newStatusCode`中间件）。
- en: A `Foo:Bar` header (derived from the `addHeader` middleware).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Foo:Bar`头部（来自`addHeader`中间件）。
- en: A `Hello PerfGo!` response (derived from the `writeResponse` middleware).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Hello PerfGo!`的响应（来自`writeResponse`中间件）。
- en: '`/onlyHeader`: Serves an HTTP response with only the `Foo:Bar` header added.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/onlyHeader`：提供只添加`Foo:Bar`头部的HTTP响应。'
- en: '`/onlyStatus`:  Serves an HTTP response with only the status code changed.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/onlyStatus`：只提供状态码更改的HTTP响应。'
- en: '`/admin`: Checks for the presence of a user: `admin` header. If present, it
    prints the admin portal information alongside all the normal pertaining values.
    If not present, it returns an unauthorized response.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/admin`：检查用户`admin`头部是否存在。如果存在，它会打印管理员门户信息以及所有相关的普通值。如果不存在，它会返回未经授权的响应。'
- en: 'These examples have been used because they are easy to grok. Using closures
    for Go in HTTP handlers is also convenient because they can do the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例已经被使用，因为它们易于理解。在Go中使用闭包处理HTTP处理程序也很方便，因为它们可以做到以下几点：
- en: Isolate database information from DB calls
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据库信息与数据库调用隔离开来
- en: Perform authorization requests
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行授权请求
- en: Wrap other functions with isolated data (timing information, for example)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用隔离的数据（例如时间信息）包装其他函数
- en: Communicate with other third-party services transparently with acceptable timeouts
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他第三方服务透明地通信，并具有可接受的超时时间
- en: 'The Go *Writing Web Applications* document, located at [[https://golang.org/doc/articles/wiki/](https://golang.org/doc/articles/wiki/)],
    gives a bunch of other prime examples of setting up templating, being able to
    live-edit pages, validating user input, and more. Let''s take a look at our example
    code that shows us closures within a HTTP handler in the following code blocks.
    First, we initialize our packages and create an `adminCheck` function, which helps
    us to determine whether or not a user is authorized to use the system:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 位于[[https://golang.org/doc/articles/wiki/](https://golang.org/doc/articles/wiki/)]的Go
    *编写Web应用程序*文档提供了一堆其他设置模板的主要示例，能够实时编辑页面，验证用户输入等。让我们来看看我们的示例代码，展示了在以下代码块中HTTP处理程序中的闭包。首先，我们初始化我们的包并创建一个`adminCheck`函数，它帮助我们确定用户是否被授权使用系统：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We next set up some other examples, such as serving an HTTP 418 (the `I''m
    a teapot` status code) and adding a `foo:bar` HTTP header and setting a particular
    HTTP response:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置了一些其他示例，比如提供一个HTTP 418（`I'm a teapot`状态码）并添加一个`foo:bar`的HTTP头部，并设置特定的HTTP响应：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Lastly, we wrap it all together with an HTTP handler:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用一个HTTP处理程序将所有内容包装在一起：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our router test examples follow. Here''s the output with a header modification
    and HTTP status code modification:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路由器测试示例如下。这是修改头部和HTTP状态码的输出：
- en: '![](img/ec5a3321-759f-4aaf-933e-166db601b2de.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec5a3321-759f-4aaf-933e-166db601b2de.png)'
- en: 'Here''s the output with just the header modification:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是仅修改头部的输出：
- en: '![](img/7398f36f-3215-4d2b-ac6c-e0f32eb1263a.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7398f36f-3215-4d2b-ac6c-e0f32eb1263a.png)'
- en: 'Here''s the output with just the status modification:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是仅修改状态的输出：
- en: '![](img/f47bb2df-dcbc-4450-8e3c-896d5a51f873.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f47bb2df-dcbc-4450-8e3c-896d5a51f873.png)'
- en: 'Here''s the unauthorized admin output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是未经授权的管理员输出：
- en: '![](img/dab62428-96a3-4228-a69f-713bb72aabb5.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dab62428-96a3-4228-a69f-713bb72aabb5.png)'
- en: 'Here''s the authorized admin output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是授权的管理员输出：
- en: '![](img/36ab738b-e5f3-4a2e-a8d3-f205fac95b2b.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36ab738b-e5f3-4a2e-a8d3-f205fac95b2b.png)'
- en: Being able to add middleware with anonymous functions can help to rapidly iterate
    while keeping code complexity low.  In the next section, we'll explore goroutines.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用匿名函数添加中间件可以帮助快速迭代，同时保持代码复杂性低。在下一节中，我们将探讨goroutines。
- en: Exploring goroutines
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索goroutines
- en: Go is a language designed with concurrency in mind. Concurrency is the ability
    to execute independent processes. Goroutines are a construct in Go that can help
    with concurrency. They are often referred to as *lightweight threads*—for good
    reason. In other languages, threads are handled by the OS. This, in turn, uses
    a larger-sized call stack and usually handles less concurrency with a given memory
    stack size. Goroutines are functions or methods that run within the Go runtime
    concurrently and don't connect to the underlying OS. The scheduler within the
    Go language manages goroutines' life cycles. The system's scheduler has a lot
    of overhead as well, so limiting the number of threads being utilized can help
    to improve performance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种以并发为设计目标的语言。并发是执行独立进程的能力。Goroutines是Go中的一种构造，可以帮助处理并发。它们通常被称为“轻量级线程”，原因是充分的。在其他语言中，线程由操作系统处理。这反过来使用了更大尺寸的调用堆栈，并且通常使用给定内存堆栈大小的并发较少。Goroutines是在Go运行时内并发运行的函数或方法，不连接到底层操作系统。Go语言内的调度器管理goroutines的生命周期。系统的调度器也有很多开销，因此限制正在使用的线程数量可以帮助提高性能。
- en: The Go scheduler
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go调度器
- en: There are a couple of different pieces involved in the management of goroutine
    life cycles by the Go runtime scheduler. The Go scheduler was changed in its second
    iteration, which was derived from a design document written by Dmitry Vyukov,
    released in Go 1.1\. In this design doc, Vyukov discusses the initial Go scheduler
    and how to implement a work-sharing and work-stealing scheduler, as originally
    prescribed by Dr Robert D. Blumofe and Dr. Charles E. Leiserson in an MIT paper
    entitled, *Scheduling Multithreaded Computations by Work Stealing*. The fundamental
    concept behind this paper is to ensure dynamic, multithreaded computation in order
    to ensure that processors are utilized efficiently while maintaining memory requirements.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Go运行时调度器通过几个不同的部分来管理goroutine的生命周期。Go调度器在其第二次迭代中进行了更改，这是根据Dmitry Vyukov撰写的设计文档而得出的，该文档于Go
    1.1中发布。在这份设计文档中，Vyukov讨论了最初的Go调度器以及如何实现工作共享和工作窃取调度器，这是由MIT的Robert D. Blumofe博士和Charles
    E. Leiserson博士在一篇名为《通过工作窃取进行多线程计算的调度》的论文中最初提出的。这篇论文背后的基本概念是确保动态的、多线程的计算，以确保处理器被有效利用同时保持内存需求。
- en: Goroutines only have a stack size of 2 KB on inception. This is one of the reasons
    why goroutines are preferred for a lot of concurrent programming—because it is
    much easier to have tens or hundreds of thousands of goroutines in one program.
    Threads in other languages can take up megabytes of space, making them a lot less
    flexible. If more memory is needed, Go's functions have the ability to allocate
    more memory in another place in available memory space to help the goroutine space
    grow. By default, the runtime gives the new stack twice the amount of memory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines在初始时只有2KB的堆栈大小。这是为什么goroutines被用于大量并发编程的原因之一——因为在一个程序中拥有数万甚至数十万个goroutines要容易得多。其他语言中的线程可能占用数兆字节的空间，使它们不太灵活。如果需要更多内存，Go的函数可以在可用内存空间的其他位置分配更多内存，以帮助goroutine的空间增长。默认情况下，运行时会给新的堆栈分配两倍的内存。
- en: Goroutines block a running thread only on system calls. When this occurs, the
    runtime takes another thread from the scheduler struct. These are used for other
    goroutines that are waiting to be executed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines只有在系统调用时才会阻塞运行的线程。当这种情况发生时，运行时会从调度器结构中取出另一个线程。这些线程用于等待执行的其他goroutines。
- en: 'Work sharing is a process in which a scheduler migrates new threads to other
    processors for work distribution. Work stealing performs a similar action, but
    in which the underutilized processors steal threads from other processors. Following
    the work-stealing pattern in Go has helped to make the Go scheduler much more
    efficient and, in turn, gives higher throughput to the goroutines that run on
    top of the kernel''s scheduler.  Lastly, Go''s scheduler implements spinning threads. 
    Spinning threads will utilize extra CPU cycles over preempting a thread. Threads
    spin in three different ways:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 工作共享是一个过程，其中调度器将新线程迁移到其他处理器以进行工作分配。工作窃取执行类似的操作，但是未被充分利用的处理器从其他处理器窃取线程。在Go中遵循工作窃取模式有助于使Go调度器更加高效，并且反过来为在内核调度器上运行的goroutines提供更高的吞吐量。最后，Go的调度器实现了自旋线程。自旋线程将利用额外的CPU周期而不是抢占线程。线程以三种不同的方式自旋：
- en: When a thread is not attached to a processor.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个线程没有附加到处理器时。
- en: When making a goroutine ready will unblock an OS thread onto an idle processor.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使一个goroutine准备好时，会将一个OS线程解除阻塞到一个空闲的处理器上。
- en: When a thread is running but no goroutines are attached to it.  This idle thread
    will continue to search for runnable goroutines to execute.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个线程正在运行但没有goroutines附加到它时。这个空闲线程将继续搜索可运行的goroutines来执行。
- en: Go scheduler goroutine internals
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go调度器goroutine内部
- en: 'The Go scheduler has three key structures that handle the workload of goroutines:
    the M struct, the P struct, and the G struct.  These three structs work together
    in order to process goroutines in a performant fashion.  Let''s take a look at
    each of these in more depth. If you''d like to take a look at the source code
    for these, it''s available at [https://github.com/golang/go/blob/master/src/runtime/runtime2.go/](https://github.com/golang/go/blob/master/src/runtime/runtime2.go/).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Go调度器有三个关键结构来处理goroutines的工作负载：M结构、P结构和G结构。这三个结构共同工作，以高效的方式处理goroutines。让我们更深入地看看每一个。如果你想查看这些的源代码，可以在[https://github.com/golang/go/blob/master/src/runtime/runtime2.go/](https://github.com/golang/go/blob/master/src/runtime/runtime2.go/)找到。
- en: The M struct
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: M结构
- en: 'The M struct is labeled **M** for **machine**. The M struct is a representation
    of an OS thread. It contains a pointer that points to the runnable goroutine global
    queue (defined by the P struct). M retrieves its work from the P struct. M contains
    the free and waiting goroutines that are ready to be executed. Some notable M
    struct parameters are the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: M结构标记为**M**代表**机器**。M结构是OS线程的表示。它包含一个指针，指向可运行的goroutine全局队列（由P结构定义）。M从P结构中检索其工作。M包含准备执行的空闲和等待的goroutine。一些值得注意的M结构参数如下：
- en: A goroutine that contains a scheduling stack (go)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含调度堆栈的goroutine（go）
- en: '**Thread local storage** (**tls**)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程本地存储**（**tls**）'
- en: A P struct for executing Go code (p)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于执行Go代码的P结构（p）
- en: The P struct
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P结构
- en: 'This struct is labeled **P** for **processor**. The P struct represents a logical
    processor. This is set by `GOMAXPROCS` (which should be equivalent to the number
    of cores available after Go version 1.5). P maintains a queue of all of the goroutines
    (defined by the G struct). When you invoke a new goroutine using the Go executor,
    this new goroutine gets inserted into P''s queue. If P doesn''t have an associated
    M struct, it will allocate a new M. Some notable P struct parameters are the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构标记为**P**代表**处理器**。P结构表示一个逻辑处理器。这是由`GOMAXPROCS`设置的（在Go版本1.5之后应该等于可用核心数）。P维护所有goroutine的队列（由G结构定义）。当您使用Go执行器调用新的goroutine时，这个新的goroutine会被插入到P的队列中。如果P没有关联的M结构，它将分配一个新的M。一些值得注意的P结构参数如下：
- en: The P struct ID (id)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P结构ID（id）
- en: A back link to an associated M struct if applicable (m)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适用，与关联的M结构的后向链接（m）
- en: A pool of available defer structs (deferpool)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用延迟结构的池（deferpool）
- en: The queue of runnable goroutines (runq)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可运行goroutine的队列（runq）
- en: A struct of available Gs (gFree)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用G的结构（gFree）
- en: The G struct
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: G结构
- en: 'This struct is labeled **G** for **goroutine**. The G struct represents the
    stack parameters of a single goroutine. It includes information on a couple of
    different parameters that are important for a goroutine. G structs get created
    for every new goroutine, as well as goroutines for the runtime. Some notable G
    struct parameters are the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构标记为**G**代表**goroutine**。G结构表示单个goroutine的堆栈参数。它包括一些对于goroutine很重要的不同参数的信息。对于每个新的goroutine以及运行时的goroutine，都会创建G结构。一些值得注意的G结构参数如下：
- en: The current value of the stack pointers (`stack.lo` and `stack.hi`)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈指针的当前值（`stack.lo`和`stack.hi`）
- en: The current value of the Go and C stack growth prologues (`stackguard0` and
    `stackguard1`)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go和C堆栈增长序言的当前值（`stackguard0`和`stackguard1`）
- en: The current value of the M struct (m)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M结构的当前值（m）
- en: Goroutines in action
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在执行的goroutine
- en: 'Now that we have a basic understanding of the underlying principles of goroutines,
    we can check them out in action. In the following code block, we will see how to invoke
    a goroutine using the `go` call:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对goroutine的基本原理有了基本的了解，我们可以看到它们的实际应用。在下面的代码块中，我们将看到如何使用`go`调用来调用goroutine：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: During the execution of this function, we only get a partial return of the `printSleep()`
    function wrapped in the goroutine call (printing `HELLO GOPHERS`) before the main
    sleep timer is complete. Why did this happen? If the `main()` goroutine completes,
    it is closed, the program is terminated, and leftover goroutines will not run.
    We were able to get the first nine characters returned because those goroutines
    completed before the main function finished executing. If we change our `const
    t` duration to `14`, we will receive the entire `HELLO GOPHERS` string.  The reason
    behind this is that the `main` function does not get completed before all of the
    goroutines that spawned around `go printSleep()` are executed.  Goroutines are
    powerful only if used correctly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此函数期间，我们只得到了`printSleep()`函数的部分返回（打印`HELLO GOPHERS`），然后主睡眠计时器完成。为什么会发生这种情况？如果`main()`
    goroutine完成，它会关闭，程序终止，并且剩余的goroutine将不会运行。我们能够得到前九个字符的返回，是因为这些goroutine在主函数执行完成之前就已经完成了。如果我们将`const
    t`的持续时间更改为`14`，我们将收到整个`HELLO GOPHERS`字符串。原因是在`main`函数完成之前，`go printSleep()`周围产生的所有goroutine都没有执行。只有在正确使用时，goroutine才是强大的。
- en: Another Go built-in that helps with managing concurrent goroutines is Go channels,
    which is the topic we will cover in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个帮助管理并发goroutine的Go内置功能是Go通道，这是我们将在下一节中讨论的主题。
- en: Introducing channels
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入通道
- en: 'Channels are mechanisms that allow the sending and receiving of values. Channels
    are often used alongside goroutines in order to deliver transfer objects concurrently
    across goroutines. There are two main classifications of channels in Go: unbuffered
    channels and buffered channels.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是允许发送和接收值的机制。通道通常与goroutine一起使用，以便在goroutine之间并发地传递对象。Go中有两种主要类型的通道：无缓冲通道和缓冲通道。
- en: Channel internals
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道内部
- en: 'Channels are invoked using the `make()` Golang built-in, where an `hchan` struct
    is created. The `hchan` struct contains a count of the data in the queue, the
    size of the queue, an array pointer for the buffer, send and receive indices and
    waiters, and a mutex lock. The following code block illustrates this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是使用`make()` Golang内置函数调用的，其中创建了一个`hchan`结构。`hchan`结构包含队列中的数据计数，队列的大小，用于缓冲区的数组指针，发送和接收索引和等待者，以及互斥锁。以下代码块说明了这一点：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code block is referenced from [https://golang.org/src/runtime/chan.go#L32](https://golang.org/src/runtime/chan.go#L32).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块引用自[https://golang.org/src/runtime/chan.go#L32](https://golang.org/src/runtime/chan.go#L32)。
- en: Buffered channels
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: 'Buffered channels are channels that have a bounded size. They are typically
    more performant than their unbounded counterparts. They are useful for retrieving
    values from an explicit number of goroutines that you''ve launched. Because they
    are **FIFO** (**first in first out**) queueing mechanisms, they can effectively
    be used as a fixed-size queueing mechanism, and we can process requests in the
    order in which they came in. Channels are created before they are used by invoking
    the `make()` function. Once a buffered channel is created, it is ready and available
    for use. Buffered channels don''t block on incoming writes if there is still room
    in the channel. It''s important to remember that data flows in the direction of
    the arrow within a channel. In our example (the following code block), we perform
    the following actions:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道是具有有限大小的通道。它们通常比无限大小的通道更高效。它们对于从你启动的一组显式数量的goroutine中检索值非常有用。因为它们是**FIFO**（先进先出）的排队机制，它们可以有效地用作固定大小的排队机制，我们可以按照它们进入的顺序处理请求。通道在使用之前通过调用`make()`函数创建。一旦创建了缓冲通道，它就已经准备好可以使用了。如果通道中仍有空间，缓冲通道不会在接收写入时阻塞。重要的是要记住数据在通道内的箭头方向流动。在我们的示例中（以下代码块），我们执行以下操作：
- en: Write `foo` and `bar` to our `buffered_channel`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`foo`和`bar`写入我们的`buffered_channel`
- en: Check the length of the channel—the length is `2` because we've added two strings
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查通道的长度-长度为`2`，因为我们添加了两个字符串
- en: Pop `foo` and `bar` off the channel
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从通道中弹出`foo`和`bar`
- en: Check the length of the channel—the length is `0` because we've removed both
    strings
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查通道的长度-长度为`0`，因为我们移除了两个字符串
- en: Add `baz` to our channel
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的通道中添加`baz`
- en: Pop `baz` off the channel onto a variable, `out`
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从通道中弹出`baz`到一个变量`out`
- en: Print the resulting `out` variable, which is `baz` (the last element we added
    to the channel)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印结果的`out`变量，它是`baz`（我们添加到通道中的最后一个元素）
- en: Close our buffered channel, indicating no more data is to pass across this channel
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭我们的缓冲通道，表示不再有数据通过这个通道传递
- en: 'Let''s have a look at the following code block:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码块：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code can be found at [https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/3-iterators-and-generators/channels/buffered_channel.go](https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/3-iterators-and-generators/channels/buffered_channel.go).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以在[https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/3-iterators-and-generators/channels/buffered_channel.go](https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/3-iterators-and-generators/channels/buffered_channel.go)找到。
- en: As we can see in our code block example, we are able to push data to the stack
    and pop data from the stack. It's also important to note that the `len()` built-in
    returns the number of elements that are unread (or queued) within the channel
    buffer. Alongside the `len()` built-in, we can also use the `cap()` built-in to
    deduce the total capacity of the buffer. These two built-ins used in conjunction
    can often be used to know the current state of your channel, especially if it's
    not acting the way you expect it to. It is also good to get in the habit of closing
    channels. When you close a channel, you are letting the Go scheduler know that
    there are no more values that will be sent across that channel. It's also important
    to note that if you attempt to write to a closed channel or a channel that has
    no room left in the queue, your program will panic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在代码块示例中看到的，我们能够将数据推送到栈中并从栈中弹出数据。还需要注意的是`len()`内置函数返回通道缓冲区中未读（或排队）的元素数量。除了`len()`内置函数，我们还可以使用`cap()`内置函数来推断缓冲区的总容量。这两个内置函数结合使用通常可以用来了解通道的当前状态，特别是如果它的行为不符合预期。关闭通道也是一个好习惯。当你关闭一个通道时，你告诉Go调度程序不会再有值被发送到该通道。还需要注意的是，如果你尝试向一个关闭的通道或者队列中没有空间的通道写入数据，你的程序会引发panic。
- en: 'The following program panics:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序会引发panic：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ll get the error message shown in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会看到以下的错误消息截图：
- en: '![](img/ac43436f-bb84-4120-aa93-6a018f3680f9.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac43436f-bb84-4120-aa93-6a018f3680f9.png)'
- en: This is because we attempted to pass data (the `foo` string) to a channel (`ch`)
    that was already closed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们试图向一个已经关闭的通道(`ch`)传递数据(`foo`字符串)。
- en: 'The following program also panics:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序也会引发panic：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll see the following error message:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到以下错误消息：
- en: '![](img/388c2dbf-21f0-44a4-bddf-9380ae00be8c.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/388c2dbf-21f0-44a4-bddf-9380ae00be8c.png)'
- en: The program panics because the goroutine will block and wait. This error is
    then detected by the runtime and the program exits.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会因为goroutine会被阻塞而引发panic。这个错误会被运行时检测到，程序退出。
- en: Ranges over channels
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历通道
- en: 'You may want to know all the values present in your buffered channel. We have
    the ability to do this by invoking a `range` built-in over the channel we''d like
    to check.  Our example in the following code block adds three elements to the
    channel, closes the channel, and then writes all the elements from the channel
    using `fmt`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道你的缓冲通道中所有的值。我们可以通过在我们想要检查的通道上调用`range`内置函数来实现这一点。我们在以下代码块的示例中向通道添加了三个元素，关闭了通道，然后使用`fmt`写入了通道中的所有元素：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The resulting output shows us all of the values that live in our buffered channel:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出显示了我们缓冲通道中的所有值：
- en: '![](img/7b342089-1d86-44b5-8cdb-7291667a2a50.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b342089-1d86-44b5-8cdb-7291667a2a50.png)'
- en: A reminder—make sure you close the channel.  If we remove the preceding `close(bufferedChannel)`
    function, we will get a deadlock.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下-确保关闭通道。如果我们删除前面的`close(bufferedChannel)`函数，我们将会遇到死锁。
- en: Unbuffered channels
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无缓冲通道
- en: Unbuffered channels are the default channel configuration in Go. Unbuffered
    channels are flexible because they don't need to have a finite channel size definition.
    They are often best used when the receiver of the data from the channel is slower
    than the sender of the channel of the data. They also block on both read and write,
    as they are synchronous. The sender will block the channel until the receiver
    has received the value. They are often used in conjunction with goroutines to
    ensure that items are processed in the order that they are expected to be processed
    in.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，无缓冲通道是默认的通道配置。无缓冲通道是灵活的，因为它们不需要有一个有限的通道大小定义。当通道的接收者比通道的发送者慢时，它们通常是最佳选择。它们在读取和写入时都会阻塞，因为它们是同步的。发送者将阻塞通道，直到接收者接收到值。它们通常与goroutines一起使用，以确保项目按预期的顺序进行处理。
- en: 'In our following example code blocks, we perform the following actions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的示例代码块中，我们执行以下操作：
- en: Create a Boolean channel to maintain state
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个布尔通道来维护状态
- en: Create an unsorted slice
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个未排序的切片
- en: Sort our slice with the `sortInts()` function
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sortInts()` 函数对我们的切片进行排序
- en: Respond true to our channel so that we can move onto the next part of the function
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应我们的通道，以便我们可以继续函数的下一部分
- en: Search our slice for a given integer
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索我们的切片以查找给定的整数
- en: Respond true to our channel so that our transaction occurring over the channel
    is completed
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应我们的通道，以便我们的通道上的事务完成
- en: Return the channel value so that our Go function is completed
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回通道值，以便我们的 Go 函数完成
- en: 'First, we import our packages and create a function that sorts integers across
    a channel:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入我们的包并创建一个函数，用于在通道中对整数进行排序：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we create a `searchInts` function that searches integers across a channel:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 `searchInts` 函数，用于在通道中搜索整数：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Lastly, we tie them all together in our `main` function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在我们的 `main` 函数中将它们全部绑定在一起：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can see our output from this program in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中看到该程序的输出：
- en: '![](img/dc8e3fa2-936a-4a43-b2d7-06a7d2dcc4a7.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc8e3fa2-936a-4a43-b2d7-06a7d2dcc4a7.png)'
- en: This is a great way to use channels to perform actions concurrently.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用通道并行执行操作的好方法。
- en: Selects
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择
- en: 'Selects are a construct that allow you to combine goroutines and channels in
    a meaningful way. We can multiplex Go functions in order to be able to execute
    a case that occurs when the goroutine is run.  In our example, we create three
    separate channels: a `string` channel, a `bool` channel, and a `rune` channel.
    We next run some anonymous functions in the following code blocks in order to
    populate data in those channels, and use the select built-in to return values
    from the channels.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 选择是一种允许您以有意义的方式结合goroutines和通道的构造。我们可以复用Go函数，以便能够执行goroutine运行时发生的情况。在我们的示例中，我们创建了三个单独的通道：一个
    `string` 通道，一个 `bool` 通道和一个 `rune` 通道。接下来，我们在以下代码块中运行一些匿名函数，以便向这些通道中填充数据，并使用内置的
    select 返回通道中的值。
- en: 'First, we initialize our package and set up three separate channels:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们初始化我们的包并设置三个单独的通道：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We next pass appropriate variables to each of our channels via anonymous functions:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过匿名函数向每个通道传递适当的变量：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lastly, we pass these through with our `select` statement:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过我们的 `select` 语句将它们传递：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The resulting output from this program can be seen in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的结果输出可以在以下截图中看到：
- en: '![](img/1a2b978b-932d-440d-acc9-76e6d3cef53d.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a2b978b-932d-440d-acc9-76e6d3cef53d.png)'
- en: You'll notice that the `rune` anonymous function gets returned last here. This
    is due to the sleep that was inserted into that anonymous function. The `select`
    statements will return values that are passed into the channel randomly if multiples
    are ready, and sequentially when the goroutine results are ready.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这里 `rune` 匿名函数最后返回。这是由于在该匿名函数中插入了休眠。如果多个值准备就绪，`select` 语句将随机返回传递到通道中的值，并在goroutine结果准备就绪时按顺序返回。
- en: In the next section, we will learn what semaphores are.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习什么是信号量。
- en: Introducing semaphores
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入信号量
- en: Semaphores are another method for controlling how goroutines execute parallel
    tasks. Semaphores are convenient because they give us the ability to use a worker
    pool pattern, but we don't need to shut down workers after the work has been completed
    and the workers are idle. The idea of having a weighted semaphore in the Go language
    is relatively new; the sync package implementation of semaphores was implemented
    in early 2017, so it is one of the newest parallel task constructs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是另一种控制goroutines执行并行任务的方法。信号量很方便，因为它们使我们能够使用工作池模式，但我们不需要在工作完成并且工作线程处于空闲状态时关闭工作线程。在
    Go 语言中使用加权信号量的概念相对较新；信号量的 sync 包实现是在2017年初实现的，因此它是最新的并行任务构造之一。
- en: 'If we take the example of a simple loop in the following code block, add 100
    ms of latency to a request, and add an item to an array, we can quickly see that
    the amount of time it takes increases as these tasks are operating in a series:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以以下代码块中的简单循环为例，向请求添加100毫秒的延迟，并向数组添加一个项目，我们很快就会看到随着这些任务按顺序操作，所需的时间增加：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can create a weighted semaphore implementation with the same constructs.
    We can see that in the following code block:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的构造创建一个加权信号量实现。我们可以在以下代码块中看到：
- en: 'First, we initialize our program and set up our semaphore variables:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们初始化程序并设置信号量变量：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we run through our semaphore code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们运行我们的信号量代码：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The difference in execution time between these two functions is quite noticeable
    and can be seen in the following outputs:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数之间的执行时间差异非常明显，可以在以下输出中看到：
- en: '![](img/b4ce5faa-d65a-4c48-ba59-d0c393bd7725.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4ce5faa-d65a-4c48-ba59-d0c393bd7725.png)'
- en: 'The semaphore implementation ran more than twice as fast which is shown in
    the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量实现的运行速度比两倍还要快，如下截图所示：
- en: '![](img/beebc1ba-0328-44b1-8992-00ddff52a5c9.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/beebc1ba-0328-44b1-8992-00ddff52a5c9.png)'
- en: The semaphore implementation ran more than twice as fast. This is with only
    five 100 ms blocking sleeps.  Being able to process things in parallel becomes
    more and more important as your scale continues to grow.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量实现的速度超过两倍。 这是只有五个100毫秒的阻塞睡眠。 随着规模的不断增长，能够并行处理事务变得越来越重要。
- en: In the next section, we will discuss WaitGroups.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论WaitGroups。
- en: Understanding WaitGroups
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解WaitGroups
- en: WaitGroups are commonly used in order to validate the fact that multiple goroutines
    have completed.  We do this in order to make sure we have completed all of the
    concurrent work that we expect to complete.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: WaitGroups通常用于验证多个goroutine是否已完成。 我们这样做是为了确保我们已完成了所有我们期望完成的并发工作。
- en: 'In the example in the following code block, we make requests to four websites
    with a `WaitGroup`.  This `WaitGroup` will wait until all of our requests have
    been completed, and will only finish the `main` function after all of the `WaitGroup` values
    have been returned:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块的示例中，我们使用`WaitGroup`对四个网站进行请求。 这个`WaitGroup`将等到所有的请求都完成后才会完成`main`函数，并且只有在所有的`WaitGroup`值都返回后才会完成：
- en: 'First, we initialize our packages and set up our retrieval function:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们初始化我们的包并设置我们的检索函数：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In our `main` function, we next use our retrieval function within a goroutine
    using WaitGroups:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`main`函数中，我们接下来使用我们的检索函数在一个goroutine中使用WaitGroups：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see from the following output, we receive all the measurements for
    the web requests, their response code, and their respective timings:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下输出中可以看出，我们收到了所有网页请求的测量数据，它们的响应代码和它们各自的时间：
- en: '![](img/c1cffc7b-dea6-45b7-a6b8-033b614b03e3.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1cffc7b-dea6-45b7-a6b8-033b614b03e3.png)'
- en: Very often, we expect all our goroutines to finish. WaitGroups can help us with
    this.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常希望所有的goroutine都能完成。 WaitGroups可以帮助我们做到这一点。
- en: In the next section, we'll discuss the process of iteration.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论迭代的过程。
- en: Iterators and the process of iteration
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器和迭代的过程
- en: 'Iteration is the method of looking through a group of data, usually a list,
    in order to retrieve information from said list. Go has a bunch of different iterator
    patterns, all with benefits and drawbacks:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代是查看一组数据的方法，通常是列表，以便从该列表中检索信息。 Go有许多不同的迭代器模式，都有利有弊：
- en: '| **Iterator** | **Benefit** | **Drawback** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **迭代器** | **优点** | **缺点** |'
- en: '| `for` loop | Simplest implementation | No default concurrency. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `for`循环 | 最简单的实现 | 没有默认并发。 |'
- en: '| Iterator function with a callback | Simple implementation | Unconventional
    styling for Go; difficult to read. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 具有回调的迭代器函数 | 简单的实现 | Go的非常规样式； 难以阅读。 |'
- en: '| Channels | Simple implementation | More expensive computationally than some
    other iterators (with a marginal cost difference). The only iterator that is naturally
    concurrent. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 通道 | 简单的实现 | 在计算上比其他一些迭代器更昂贵（成本差异较小）。 唯一自然并发的迭代器。 |'
- en: '| Stateful iterators | Difficult implementation | A nice caller interface.
    Useful for complex iterators (commonly used in the standard library). |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 有状态的迭代器 | 难以实现 | 良好的调用者接口。 适用于复杂的迭代器（通常在标准库中使用）。 |'
- en: It's important to benchmark all of these against one another in order to validate
    assumptions about how long each one takes. In the following tests, we take sums
    of `0` to `n` and run benchmarks against them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要相互对比所有这些以验证关于每个迭代器需要多长时间的假设。 在以下测试中，我们对它们的和进行了`0`到`n`的求和，并对它们进行了基准测试。
- en: 'The following code block has a simple `for` loop iterator:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块具有简单的`for`循环迭代器：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following code block has a callback iterator:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块具有回调迭代器：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following code blocks will show the  `Next()` incantation. Let''s look
    at it step by step:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块将展示`Next()`的使用。 让我们再一次一步一步地看一下：
- en: 'First, we initialize our package variables and structs.  Next, we create a
    `CounterIterator`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们初始化我们的包变量和结构。 接下来，我们创建一个`CounterIterator`：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is followed by a `Next()` function, a `Value()` function, and a `NextLoop()`
    function:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`Next()`函数，`Value()`函数和`NextLoop()`函数：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The next code block has a buffered channel implementation:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个代码块具有缓冲通道实现：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The next code block has an unbuffered channel implementation:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个代码块具有无缓冲通道实现：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After we compile these all together, we can make a test benchmark. This benchmark
    can be found in the following code blocks. Let's look at it step by step again.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有这些编译在一起后，我们可以进行测试基准。 这些基准测试可以在以下代码块中找到。 让我们再一次一步一步地看一下。
- en: 'First, we initialize our package and set up a simple and callback loop benchmark:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们初始化我们的包并设置一个简单的回调循环基准：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is followed by a next and buffered channel benchmark:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是一个`Next`和缓冲通道基准：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lastly, we set up the unbuffered channel benchmark and create loop functions
    for each of the benchmarks:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们设置了无缓冲通道基准，并为每个基准创建了循环函数：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result of the benchmark can be found in the following screenshot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的结果可以在以下截图中找到：
- en: '![](img/853c9c7a-85e3-436c-b9cf-ac131f448b3c.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/853c9c7a-85e3-436c-b9cf-ac131f448b3c.png)'
- en: The context of these iterator tests is very important. Because we are doing
    simple addition in these tests, a simple construct for iterating is key. If we
    were to add in latency within each call, the concurrent channel iterators would
    perform much better. Concurrency is a powerful thing, especially in the right
    context.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些迭代器测试的上下文非常重要。 因为在这些测试中我们只是做简单的加法，所以迭代的简单构造是关键。 如果我们在每次调用中添加延迟，那么并发通道迭代器的性能将更好。
    并发在合适的上下文中是一件强大的事情。
- en: In the next section, we'll discuss generators.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论生成器。
- en: Briefing on generators
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器简介
- en: A generator is a routine that returns the next sequential value within a loop
    construct. Generators are commonly used to implement iterators and bring in parallelism.
    Goroutines are utilized in Go in order to implement generators. To implement parallelism
    in Go, we can use generators that run in parallel with consumers to produce values.
    They are typically utilized within a looping construct. Generators can also be
    parallelized themselves. This is typically done when it's expensive to generate
    an output and the output can be generated in any order.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是在循环结构中返回下一个顺序值的例程。生成器通常用于实现迭代器并引入并行性。在Go中，Goroutines被用来实现生成器。为了在Go中实现并行性，我们可以使用生成器与消费者并行运行以产生值。它们通常在循环结构中被使用。生成器本身也可以并行化。这通常是在生成输出的成本很高且输出可以以任何顺序生成时才会这样做。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned about many of the basic constructs that are
    used for iterators and generators in Go. Understanding anonymous functions and
    closures helped us to build foundational knowledge about how these functions work. 
    We then learned how goroutines and channels work, and how to implement them fruitfully.
    We also learned about semaphores and WaitGroups, as well as how they play into
    the language. Understanding these skills will help us to parse through information
    in our computer programs in a more effective manner, allowing for more concurrent
    data manipulation. In [Chapter 4](ce982065-5176-4ca4-9346-8bae29d1ccee.xhtml),
    *STL Algorithm Equivalents in Go*, we'll learn about practical implementations
    of the **Standard Templating Library** (**STL**) in Go.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Go中用于迭代器和生成器的许多基本构造。理解匿名函数和闭包帮助我们建立了关于这些函数如何工作的基础知识。然后我们学习了goroutines和channels的工作原理，以及如何有效地实现它们。我们还学习了关于信号量和WaitGroups，以及它们在语言中的作用。理解这些技能将帮助我们以更有效的方式解析计算机程序中的信息，从而实现更多的并发数据操作。在[第4章](ce982065-5176-4ca4-9346-8bae29d1ccee.xhtml)中，*在Go中的STL算法等效实现*，我们将学习如何在Go中实现**标准模板库**（**STL**）的实际应用。
