["```go\npackage main\nimport (\n    \"fmt\"\n    \"sort\"\n)\nfunc main() {\n    intData := []int{3, 1, 2, 5, 6, 4}\n    stringData := []string{\"foo\", \"bar\", \"baz\"}\n    floatData := []float64{1.5, 3.6, 2.5, 10.6}\n```", "```go\n\n    sort.Ints(intData)\n    sort.Strings(stringData)\n    sort.Float64s(floatData)\n    fmt.Println(\"Sorted Integers: \", intData, \"\\nSorted Strings:\n      \", stringData, \"\\nSorted Floats: \", floatData)\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n)\n\nfunc reverse(s []string) []string {\n  for x, y := 0, len(s)-1; x < y; x, y = x+1, y-1 {\n    s[x], s[y] = s[y], s[x]\n  }\n  return s\n}\nfunc main() {\n  s := []string{\"foo\", \"bar\", \"baz\", \"go\", \"stop\"}\n  reversedS := reverse(s)\n  fmt.Println(reversedS)\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc findMinInt(a []int) int {\n  var minInt int = a[0]\n  for _, i := range a {\n    if minInt > i {\n      minInt = i\n    }\n  }\n  return minInt\n\n}\n```", "```go\nfunc findMaxInt(b []int) int {\n  var max int = b[0]\n  for _, i := range b {\n    if max < i {\n      max = i\n    }\n  }\n  return max\n}\n```", "```go\nfunc main() {\n  intData := []int{3, 1, 2, 5, 6, 4}\n  minResult := findMinInt(intData)\n  maxResult := findMaxInt(intData)\n  fmt.Println(\"Minimum value in array: \", minResult)\n  fmt.Println(\"Maximum value in array: \", maxResult)\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"sort\"\n)\n\nfunc main() {\n  data := []int{1, 2, 3, 4, 5, 6}\n  findInt := 2\n  out := sort.Search(len(data), func(i int) bool { return data[i]\n     >= findInt })\n  fmt.Printf(\"Integer %d was found in %d at position %d\\n\",\n     findInt, data, out)\n}\n```", "```go\narrayExample := [5]string{\"foo\", \"bar\", \"baz\", \"go\", \"rules\"}\n```", "```go\nsliceExample := []string{\"slices\", \"are\", \"cool\", \"in\", \"go\"}\n```", "```go\npackage main\n\nimport \"fmt\"\n\n// Remove i indexed item in slice\nfunc remove(s []string, i int) []string {\n  copy(s[i:], s[i+1:])\n  return s[:len(s)-1]\n}\n\nfunc main() {\n  slice := []string{\"foo\", \"bar\", \"baz\"} // create a slice\n  slice = append(slice, \"tri\") // append a slice\n  fmt.Println(\"Appended Slice: \", slice) // print slice [foo, bar baz, tri]\n  slice = remove(slice, 2) // remove slice item #2 (baz)\n  fmt.Println(\"After Removed Item: \", slice) // print slice [foo, bar, tri]\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n\n    \"gopkg.in/karalabe/cookiejar.v1/collections/deque\"\n)\n\nfunc main() {\n    d := deque.New()\n    elements := []string{\"foo\", \"bar\", \"baz\"}\n    for i := range elements {\n        d.PushLeft(elements[i])\n    }\n    fmt.Println(d.PopLeft())  // queue => [\"foo\", \"bar\"]\n    fmt.Println(d.PopRight()) // queue => [\"bar\"]\n    fmt.Println(d.PopLeft())  // queue => empty\n}\n```", "```go\npackage main\n\nimport (\n    \"container/list\"\n    \"fmt\"\n)\n\nfunc main() {\n    ll := list.New()\n    three := ll.PushBack(3)           // stack representation -> [3]\n    four := ll.InsertBefore(4, three) // stack representation -> [4 3]\n    ll.InsertBefore(2, three)         // stack representation ->\n                                      //  [4 2 3]\n    ll.MoveToBack(four)               // stack representation ->\n                                      // [2 3 4]\n    ll.PushFront(1)                   // stack representation ->\n                                      //  [1 2 3 4]\n    listLength := ll.Len()\n    fmt.Printf(\"ll type: %T\\n\", ll)\n    fmt.Println(\"ll length: :\", listLength)\n    for e := ll.Front(); e != nil; e = e.Next() {\n        fmt.Println(e.Value)\n    }\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\ntype SinglyLinkedList struct {\n    head *LinkedListNode\n}\n\ntype LinkedListNode struct {\n    data string\n    next *LinkedListNode\n}\n```", "```go\n\nfunc (ll *SinglyLinkedList) Append(node *LinkedListNode) {\n    if ll.head == nil {\n        ll.head = node\n        return\n    }\n\n    currentNode := ll.head\n    for currentNode.next != nil {\n        currentNode = currentNode.next\n    }\n    currentNode.next = node\n}\n\nfunc main() {\n    ll := &SinglyLinkedList{}\n    ll.Append(&LinkedListNode{data: \"hello\"})\n    ll.Append(&LinkedListNode{data: \"high\"})\n    ll.Append(&LinkedListNode{data: \"performance\"})\n    ll.Append(&LinkedListNode{data: \"go\"})\n\n    for e := ll.head; e != nil; e = e.next {\n        fmt.Println(e.data)\n    }\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\n    var simpleQueue []string\n    simpleQueue = append(simpleQueue, \"Performance \")\n    simpleQueue = append(simpleQueue, \"Go\")\n\n    for len(simpleQueue) > 0 {\n        fmt.Println(simpleQueue[0])   // First element\n        simpleQueue = simpleQueue[1:] // Dequeue\n    }\n    fmt.Println(simpleQueue) //All items are dequeued so result should be []\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n\n    pq \"github.com/jupp0r/go-priority-queue\"\n)\n\nfunc main() {\n    priorityQueue := pq.New()\n    priorityQueue.Insert(\"java\", 1)\n    priorityQueue.Insert(\"golang\", 1)\n    priorityQueue.Insert(\"php\", 2)\n    priorityQueue.UpdatePriority(\"java\", 3)\n    for priorityQueue.Len() > 0 {\n        val, err := priorityQueue.Pop()\n        if err != nil {\n            panic(err)\n        }\n        fmt.Println(val)\n    }\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n\n    stack \"github.com/golang-collections/collections/stack\"\n)\n\nfunc main() {\n    // Create a new stack\n    fmt.Println(\"Creating New Stack\")\n    exstack := stack.New()\n    fmt.Println(\"Pushing 1 to stack\")\n    exstack.Push(1) // push 1 to stack\n    fmt.Println(\"Top of Stack is : \", exstack.Peek())\n    fmt.Println(\"Popping 1 from stack\")\n    exstack.Pop() // remove 1 from stack\n    fmt.Println(\"Stack length is : \", exstack.Len())\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    s := make(map[int]bool)\n\n    for i := 0; i < 5; i++ {\n        s[i] = true\n    }\n\n    delete(s, 4)\n\n    if s[2] {\n        fmt.Println(\"s[2] is set\")\n    }\n    if !s[4] {\n        fmt.Println(\"s[4] was deleted\")\n    }\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n\n    \"github.com/soniakeys/multiset\"\n)\n\nfunc main() {\n    x := multiset.Multiset{\"foo\": 1, \"bar\": 2, \"baz\": 3}\n    fmt.Println(\"x: \", x)\n    // Create a scaled version of x\n    y := multiset.Scale(x, 2)\n    fmt.Println(\"y: \", y)\n    fmt.Print(\"x is a subset of y: \")\n    fmt.Println(multiset.Subset(x, y))\n\n    fmt.Print(\"Cardinality of x: \")\n    fmt.Println(x.Cardinality())\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    m := make(map[int]string)\n    m[1] = \"car\"\n    m[2] = \"train\"\n    m[3] = \"plane\"\n    fmt.Println(\"Full Map:\\t \", m)\n    fmt.Println(\"m[3] value:\\t \", m[3])\n    fmt.Println(\"Length of map:\\t \", len(m))\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n\n    \"github.com/jwangsadinata/go-multimap/slicemultimap\"\n)\n\ntype cars []struct {\n    year  int\n    style string\n}\n\nfunc main() {\n\n    newCars := cars{{2019, \"convertible\"}, {1966, \"fastback\"}, {2019, \"SUV\"}, {1920, \"truck\"}}\n    multimap := slicemultimap.New()\n\n    for _, car := range newCars {\n        multimap.Put(car.year, car.style)\n    }\n\n    for _, style := range multimap.KeySet() {\n        color, _ := multimap.Get(style)\n        fmt.Printf(\"%v: %v\\n\", style, color)\n    }\n}\n```", "```go\npackage main                                                                                                                                \n\nimport (\n    \"fmt\"\n\n    \"github.com/go-functional/core/functor\"\n)\n\nfunc main() {\n    intSlice := []int{1, 3, 5, 7}\n    fmt.Println(\"Int Slice:\\t\", intSlice)\n    intFunctor := functor.LiftIntSlice(intSlice)\n    fmt.Println(\"Lifted Slice:\\t\", intFunctor)\n\n    // Apply a square to our given functor\n    squareFunc := func(i int) int {\n        return i * i \n    }   \n\n    // Apply a mod 3 to our given functor\n    modThreeFunc := func(i int) int {\n        return i % 3 \n    }   \n\n    squared := intFunctor.Map(squareFunc)\n    fmt.Println(\"Squared: \\t\", squared)\n\n    modded := squared.Map(modThreeFunc)\n    fmt.Println(\"Modded: \\t\", modded)\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    for i := 0; i < 5; i++ {\n        fmt.Println(\"Hi Gophers!\")\n    }\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc incrementCounter() func() int {\n    initializedNumber := 0\n    return func() int {\n        initializedNumber++\n        return initializedNumber\n    }   \n}\n\nfunc main() {\n    n1 := incrementCounter()\n    fmt.Println(\"n1 increment counter #1: \", n1())\n    fmt.Println(\"n1 increment counter #2: \", n1())\n    n2 := incrementCounter()\n    fmt.Println(\"n2 increment counter #1: \", n2())\n    fmt.Println(\"n1 increment counter #3: \", n1())\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    stringExample := []string{\"foo\", \"bar\", \"baz\"}\n    for i, out := range stringExample {\n        fmt.Println(i, out)\n    }\n}\n```"]