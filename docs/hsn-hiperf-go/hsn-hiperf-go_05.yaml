- en: STL Algorithm Equivalents in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的STL算法等价物
- en: 'Many programmers coming from other high-performance programming languages,
    particularly C++, understand the concept of the **Standard Templating Library** (**STL**).
    This library provides common programming data structures and functions access
    to a generalized library in order to rapidly iterate and write performant code
    at scale. Go does not have a built-in STL. This chapter will focus on how to utilize
    some of the most common STL practices within Go. The STL has four commonly referenced
    components:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多来自其他高性能编程语言，特别是C++的程序员，了解**标准模板库**（**STL**）的概念。该库提供了常见的编程数据结构和函数访问通用库，以便快速迭代和编写大规模的高性能代码。Go没有内置的STL。本章将重点介绍如何在Go中利用一些最常见的STL实践。STL有四个常见的组件：
- en: Algorithms
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法
- en: Containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Functors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数对象
- en: Iterators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'Being familiar with these topics will help you to write Go code more quickly
    and effectively, utilizing commonly implemented and optimized patterns. In this
    chapter, we are going to learn the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉这些主题将帮助您更快、更有效地编写Go代码，利用常见的实现和优化模式。在本章中，我们将学习以下内容：
- en: How to use STL practices in Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Go中使用STL实践
- en: How to utilize standard programming algorithms with respect to Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Go中利用标准编程算法
- en: How containers store data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器如何存储数据
- en: How functions work in Go
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中函数的工作原理
- en: How to properly use iterators
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何正确使用迭代器
- en: Remember, all of these pieces are still part of our performance puzzle. Knowing
    when to use the right algorithm, container, or functor will help you to write
    better-performing code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，所有这些部分仍然是我们性能拼图的一部分。知道何时使用正确的算法、容器或函数对象将帮助您编写性能更好的代码。
- en: Understanding algorithms in the STL
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解STL中的算法
- en: 'Algorithms in the STL perform functions such as sorting and searching, as well
    as manipulating and counting data. These are called by the `<algorithm>` header
    in C++ and are used on ranges of elements. The groups of objects that are modified
    do not impact the structure of the container they are associated with. The patterns
    outlined in each of the subheadings here use Go''s language structure to implement
    these algorithms. The following types of algorithm will be explained in this section
    of the chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: STL中的算法执行排序、搜索、操作和计数等功能。这些功能由C++中的`<algorithm>`头文件调用，并用于元素范围。被修改的对象组不会影响它们所关联的容器的结构。这里每个小标题中概述的模式使用Go的语言结构来实现这些算法。本章的这一部分将解释以下类型的算法：
- en: Sort
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序
- en: Reverse
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆转
- en: Min and max elements
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小和最大元素
- en: Binary search
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二分搜索
- en: Being able to understand how all of these algorithms work will help you to produce
    performant code when you need to use these techniques to manipulate data structures
    using algorithms.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 能够理解所有这些算法的工作原理将帮助您在需要使用这些技术来操作数据结构时编写性能良好的代码。
- en: Sort
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: 'The **sort** algorithm sorts an array into ascending order. Sort doesn''t require
    new containers to be created, destroyed, or copied—the sort algorithm sorts all
    the elements within their container. We can do this in Go with the standard library
    sort. Go''s standard library sort has helper functions for different data types
    (`IntsAreSorted`, `Float64sAreSorted`, and `StringsAreSorted`) for sorting their
    respective data types. We can implement the sorting algorithm as illustrated in
    the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**sort**算法将数组按升序排序。排序不需要创建、销毁或复制新的容器——排序算法对容器中的所有元素进行排序。我们可以使用Go的标准库sort来实现这一点。Go的标准库sort对不同的数据类型（`IntsAreSorted`、`Float64sAreSorted`和`StringsAreSorted`）有辅助函数来对它们进行排序。我们可以按照以下代码中所示的方式实现排序算法：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code instantiates simple data structures with values. After this, we sort
    each of these data structures using the built-in `sort` functions, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用值实例化简单的数据结构。之后，我们使用内置的`sort`函数对每个数据结构进行排序，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we execute this, we can see that all of our slices have been sorted in order,
    as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个代码时，我们可以看到所有的切片都按顺序排序，如下面的截图所示：
- en: '![](img/f300c9de-491f-4a81-91f3-de0892136d22.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f300c9de-491f-4a81-91f3-de0892136d22.png)'
- en: Integers are sorted low to high, strings are sorted alphabetically, and floats
    are sorted low to high. These are the default sorting methods within the `sort`
    package.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 整数按从低到高排序，字符串按字母顺序排序，浮点数按从低到高排序。这些是`sort`包中的默认排序方法。
- en: Reverse
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转
- en: 'The **reverse** algorithm takes a dataset and reverses the values of the set.
    The Go standard `sort` package does not have a built-in way to reverse slices.
    We can write a trivial `reverse` function in order to reverse the order of our
    dataset, like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**reverse**算法接受一个数据集并反转集合的值。Go标准的`sort`包没有内置的反转切片的方法。我们可以编写一个简单的`reverse`函数来反转我们数据集的顺序，如下所示：'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function iterates through the slice, increments and decrements `x` and
    `y` until they converge, and swaps the elements in the slice, as we can see in
    the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过切片进行迭代，增加和减少`x`和`y`直到它们收敛，并交换切片中的元素，如下面的截图所示：
- en: '![](img/fecb8769-eec6-4e8f-b2a1-cb458c9f6ea3.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fecb8769-eec6-4e8f-b2a1-cb458c9f6ea3.png)'
- en: As we can see, our slice is reversed using the `reverse()` function. Using the
    standard library makes a function that would be difficult to write by hand simple,
    concise, and reusable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的切片使用`reverse()`函数被反转。使用标准库可以使一个难以手动编写的函数变得简单、简洁和可重用。
- en: Min element and max element
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小元素和最大元素
- en: 'We can find the smallest and largest values within a dataset using the `min_element`
    and `max_element` algorithms respectively. We can implement `min_element` and
    `max_element` in Go using a simple iterator:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`min_element`和`max_element`算法在数据集中找到最小和最大值。我们可以使用简单的迭代器在Go中实现`min_element`和`max_element`：
- en: 'First, we''ll write a function to find the smallest integer in the slice:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个函数来找到切片中最小的整数：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we will follow the same process, but will attempt to find the largest
    integer in the slice:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将按照相同的过程，尝试在切片中找到最大的整数：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Lastly, we''ll use these functions to print the resulting minimum and maximum
    values:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用这些函数打印出最终的最小值和最大值：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These functions iterate through a slice of integers and find the minimum and
    maximum values within the slice, as shown in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数遍历整数切片，并在切片中找到最小值和最大值，如下面的屏幕截图所示：
- en: '![](img/7ef9856d-ff05-4ca0-aaf3-d8aa36112563.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ef9856d-ff05-4ca0-aaf3-d8aa36112563.png)'
- en: As you can see from our execution, the minimum and maximum values are found.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的执行结果可以看出，找到了最小值和最大值。
- en: We also have `math.Min` and `math.Max` defined in the Go `math` package. These
    are only used for comparing `float64` data types. Float comparison is not an easy
    task, so the Go designers decided to make the default `Min` and `Max` signature;
    in the `math` library, you should use floats. If Go were to have generics, the
    main function we wrote above could potentially work for different types. This
    is part of the Go language design—keeping things simple and consolidated.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go的`math`包中，我们还有`math.Min`和`math.Max`。这些仅用于比较`float64`数据类型。浮点数比较并不是一件容易的事情，因此Go的设计者决定将默认的`Min`和`Max`签名；在`math`库中，应该使用浮点数。如果Go有泛型，我们上面编写的主要函数可能适用于不同类型。这是Go语言设计的一部分——保持事情简单和集中。
- en: Binary search
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分查找
- en: '**Binary search** is an algorithm that is used to find the location of a specific
    element in a sorted array. It starts by targeting the middle element in the array.
    If there is no match, the algorithm next takes the half of the array that could
    contain the item and uses the middle value to find the target. As we learned in
    [Chapter 2](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml), *Data Structures and
    Algorithms*, binary search is an efficient algorithm at *O* (log *n*). The Go
    standard library `sort` package has a built-in binary search function. We can
    use it like so:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**二分查找**是一种用于在排序数组中查找特定元素位置的算法。它从数组中间元素开始。如果没有匹配，算法接下来取可能包含该项的数组的一半，并使用中间值来找到目标。正如我们在[第2章](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml)中学到的，*数据结构和算法*，二分查找是一个高效的*O*(log
    *n*)算法。Go标准库的`sort`包有一个内置的二分查找函数。我们可以这样使用它：'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The binary search algorithm correctly finds the value of the integer we are
    searching for, `2`, in the position that it is expected to be in (position `1`
    in a zero-indexed slice). We can see the binary search execution in the following
    screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找算法正确地找到了我们正在搜索的整数值`2`，并且在预期位置（在零索引切片中的位置`1`）上。我们可以在以下屏幕截图中看到二分查找的执行：
- en: '![](img/deb1ce15-a3ba-4e03-957f-7c347ea83fa7.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/deb1ce15-a3ba-4e03-957f-7c347ea83fa7.png)'
- en: As a conclusion, the algorithms found in the STL all translate nicely to Go.
    Go's default functions and iterators make it easy to compose simple, reusable
    algorithms. In the next section, we will learn about containers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，STL中的算法都很好地转换到了Go中。Go的默认函数和迭代器使得组合简单、可重用的算法变得容易。在下一节中，我们将学习关于容器的知识。
- en: Understanding containers
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器
- en: 'Containers fall under three separate categories in the STL:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: STL中的容器分为三个独立的类别：
- en: Sequence containers
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列容器
- en: Sequence container adapters
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列容器适配器
- en: Associative containers
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联容器
- en: We are going to cover these three types of containers in the following sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在以下小节中介绍这三种类型的容器。
- en: Sequence containers
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列容器
- en: 'Sequence containers store data elements of a specific type. There are five
    current implementations of sequence containers: `array`, `vector`, `deque`, `list`,
    and `forward_list`. These sequence containers make it easy to reference data in
    a sequential manner. Being able to utilize these sequence containers is a great
    shortcut to writing effective code and reusing modular bits of the standard library.
    We will explore these in the following subsections.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 序列容器存储特定类型的数据元素。目前有五种序列容器的实现：`array`、`vector`、`deque`、`list`和`forward_list`。这些序列容器使得以顺序方式引用数据变得容易。能够利用这些序列容器是编写有效代码和重用标准库中模块化部分的一个很好的捷径。我们将在以下小节中探讨这些内容。
- en: Array
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'An **array** in Go is similar to that of an array in C++. Go''s array structures
    are statically defined during compile time and are not resizable. Arrays are implemented
    in Go in the following manner:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，**数组**类似于C++中的数组。Go的数组结构在编译时静态定义，不可调整大小。数组在Go中的实现方式如下：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This array holds the values of the strings defined in the `arrayExample` variable,
    which is defined as an array.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组保存了在`arrayExample`变量中定义的字符串的值，该变量被定义为一个数组。
- en: Vector
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: 'Go originally had a **vector** implementation, but this was removed very early
    on in the language development (October 11, 2011). It was deemed that slices are
    better (as was the title of the pull request) and slices became the de facto vector
    implementation in Go. We can implement a slice as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Go最初有一个**向量**的实现，但这在语言开发的早期就被移除了（2011年10月11日）。人们认为切片更好（正如拉取请求的标题所说），切片成为了Go中的事实上的向量实现。我们可以这样实现一个切片：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Slices are beneficial because, like vectors in the STL, they can grow or shrink
    based on addition or deletion. In our example, we create a slice, append a value
    to the slice, and remove a value from the slice, as illustrated in the following
    code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 切片很有益，因为它们像STL中的向量一样，可以根据添加或删除而增长或缩小。在我们的示例中，我们创建一个切片，向切片附加一个值，并从切片中移除一个值，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we execute our vector example, we can see our appending and removing in
    action, as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行我们的向量示例时，我们可以看到我们的附加和移除操作，如下面的屏幕截图所示：
- en: '![](img/e76ae808-21bd-4a85-ace9-d0627b4d30ae.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e76ae808-21bd-4a85-ace9-d0627b4d30ae.png)'
- en: We can see that the `tri` element was appended to the end of our slice, and
    we can also see that the `baz` element (element number 3 in the slice) was removed
    based on our `remove()` function call.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`tri`元素被附加到了我们的切片末尾，并且我们还可以看到基于我们的`remove()`函数调用，`baz`元素（切片中的第3个元素）被移除了。
- en: Deque
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双端队列
- en: 'A **deque**, or a double-ended queue, is a container that can be expanded.
    These expansions can occur in the front or the back of the container. Deques are
    often used when the top or the back of a queue needs to be referenced frequently.
    The following code block is a simple implementation of a deque:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**双端队列**是一个可以扩展的容器。这些扩展可以发生在容器的前端或后端。当需要频繁引用队列的顶部或后部时，通常会使用双端队列。以下代码块是双端队列的简单实现：'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `deque` package takes a slice of elements and pushes them onto the queue
    with the `PushLeft` function. Next, we can pop elements off of the left and the
    right of the deque, until our queue is empty. We can see the execution of our
    deque logic in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`deque`包接受一个元素的切片，并使用`PushLeft`函数将它们推送到队列上。接下来，我们可以从双端队列的左侧和右侧弹出元素，直到我们的队列为空。我们可以在以下截图中看到我们双端队列逻辑的执行：'
- en: '![](img/8f7cf55a-1bfc-4ddd-8621-72fdbb477ef1.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f7cf55a-1bfc-4ddd-8621-72fdbb477ef1.png)'
- en: Our results show the output of the manipulation of the deque and how we can
    pull things from either end of the queue. Being able to pull things from either
    end of the queue is advantageous in data manipulation, and this is why a deque
    is a popular data structure choice.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果显示了对双端队列的操作输出以及我们如何可以从队列的任一端取出东西。能够从队列的任一端取出东西在数据操作中是有优势的，这就是为什么双端队列是一种流行的数据结构选择。
- en: List
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'A **list** is Go''s implementation of a doubly linked list. This is built into
    the container/list package in the standard library. We can perform many actions
    using the implementation of a generic doubly linked list, as shown in the following
    code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表**是Go语言中双向链表的实现。这是内置在标准库的container/list包中的。我们可以使用通用双向链表的实现执行许多操作，如下面的代码所示：'
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A doubly linked list is similar to the deque container, but it allows for insertion
    and removal from the middle of the stack if necessary. Doubly linked lists are used much
    more often in practice. We can see the execution of our doubly linked list code
    in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表类似于双端队列容器，但如果需要，它允许在堆栈的中间进行插入和移除。双向链表在实践中使用得更多。我们可以在以下截图中看到我们双向链表代码的执行。
- en: '![](img/a9cac75c-cea0-4d60-a222-dede65b5634b.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9cac75c-cea0-4d60-a222-dede65b5634b.png)'
- en: We can see that all the elements are in the order in which they were coordinated
    on the stack in the output from our program. Linked lists are quintessential to
    programming, as they are a fundamental algorithm that much of today's computer
    science is built on.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有元素在程序输出中按照它们在堆栈上协调的顺序。链表是编程的基本要素，因为它们是当今计算机科学建立在其上的基本算法。
- en: Forward list
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前向列表
- en: 'A **forward list** is an implementation of a singly linked list. A singly linked
    list typically has a smaller memory footprint than a doubly linked list; however,
    iteration through a singly linked list isn''t as good, particularly in the reverse
    direction. Let''s see how to implement a forward list:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**前向列表**是单向链表的实现。单向链表通常比双向链表具有更小的内存占用；然而，通过单向链表进行迭代不太好，特别是在反向方向上。让我们看看如何实现前向列表：'
- en: 'First, we initialize our program and define our structures:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们初始化我们的程序并定义我们的结构：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we create our `Append` function and apply it in our `main` function:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建我们的`Append`函数并在我们的`main`函数中应用它：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see from the resulting output in the following screenshot, all of
    the pieces of data we appended to our singly linked list are accessible:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下截图的输出结果中可以看到，我们附加到我们的单链表的所有数据都是可访问的：
- en: '![](img/eb95afd0-8331-4c4a-a236-2988b3672f40.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb95afd0-8331-4c4a-a236-2988b3672f40.png)'
- en: The initial elements of this data structure are put into the list in the order
    that they were added within the code block. This is expected, as singly linked
    lists are often used in order to keep the order of data within the data structure.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据结构的初始元素按照它们在代码块中添加的顺序放入列表中。这是预期的，因为单向链表通常用于保持数据结构中的数据顺序。
- en: Container adapters
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器适配器
- en: '**Container adapters** take a sequential container and adapt the way it is
    used in order for the original sequential container to function in its intended
    manner. During the investigation of these container adapters, we will learn how
    all of them are created and how they are used from a practical standpoint.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器适配器**接受一个顺序容器并调整它的使用方式，以便原始顺序容器能够按照预期的方式运行。在研究这些容器适配器时，我们将学习它们是如何创建的，以及它们如何从实际的角度使用。'
- en: Queue
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: '**Queues** are containers that follow the **FIFO** queuing method, or **first
    in first out**. This means that we can add things to the container and pull them
    from the other end of the container. We can make the simplest form of a queue
    by appending and dequeueing from a slice, as shown in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**是遵循**FIFO**队列方法或**先进先出**的容器。这意味着我们可以将东西添加到容器中，并从容器的另一端取出它们。我们可以通过向切片附加和出列来制作最简单形式的队列，如下面的代码所示：'
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In our example, we append strings to our `simpleQueue` and then dequeue them
    by removing the first element of the slice:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将字符串附加到我们的`simpleQueue`，然后通过移除切片的第一个元素来出列它们：
- en: '![](img/4019bac0-03c1-48b9-b70d-8bc356bece3f.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4019bac0-03c1-48b9-b70d-8bc356bece3f.png)'
- en: In our output, we can see that we correctly added elements to the queue and
    removed them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的输出中，我们可以看到我们正确地向队列添加了元素并将它们移除。
- en: Priority queue
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列
- en: A **priority queue** is a container that uses a heap to keep a prioritized list
    of the elements within the container. Priority queues are helpful because you
    can order the result set by priority. Priority queues are often used for many
    practical applications, from load balancing web requests to data compression,
    to Dijkstra's algorithm.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先队列**是使用堆来保持容器中元素的优先列表的容器。优先队列很有帮助，因为可以按优先级对结果集进行排序。优先队列通常用于许多实际应用，从负载平衡Web请求到数据压缩，再到Dijkstra算法。'
- en: 'In our priority queue example, we create a new priority queue and insert a
    couple of different programming languages that have a given priority. We start
    with Java being the first priority and then Go becomes the first priority. PHP
    gets added and Java''s priority gets pushed down to 3\. The following code is
    an example of a priority queue. Here, we instantiate the necessary requirements,
    create a new priority queue, insert elements into the priority queue, change the
    priority of those items, and pop items from the stack:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的优先级队列示例中，我们创建了一个新的优先级队列，并插入了几种具有给定优先级的不同编程语言。我们从Java开始，它是第一个优先级，然后Go成为第一个优先级。添加了PHP，Java的优先级被推到3。以下代码是优先级队列的一个示例。在这里，我们实例化了必要的要求，创建了一个新的优先级队列，向其中插入元素，改变了这些项的优先级，并从堆栈中弹出项：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After our execution of this sample code, we can see a proper ordering of the
    languages based on the priority queue values that we have set, as we can see in
    the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们执行这个示例代码之后，我们可以看到基于我们设置的优先级队列值的语言的正确排序，如下所示：
- en: '![](img/fee330b8-41fd-4f84-bf6a-897163106ca2.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fee330b8-41fd-4f84-bf6a-897163106ca2.png)'
- en: Priority queues are a commonly used, important data structure. They are used
    in order to process the most important elements within a data structure first,
    and being able to implement this with STL equivalents helps us to save time and
    effort while being able to prioritize incoming requests.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级队列是一种常用的重要数据结构。它们用于首先处理数据结构中最重要的元素，并且能够使用STL等效实现这一点有助于我们节省时间和精力，同时能够优先处理传入的请求。
- en: Stack
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: 'A **stack** serves the grouping of data using `push` and `pop` to add and remove
    elements from the container. Stacks usually have a **LIFO** (short for **last
    in first out**) order of operation, and the `Peek` operation usually lets you
    see what is on top of the stack without removing it from the stack. Stacks are
    very handy for things that have a bounded set of memory, as they can utilize the allocated memory
    effectively. The following code is a simple implementation of a stack:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈**使用`push`和`pop`来添加和删除容器中的元素，用于对数据进行分组。堆栈通常具有**LIFO**（**后进先出**）的操作顺序，`Peek`操作通常允许您查看堆栈顶部的内容而不将其从堆栈中移除。堆栈非常适用于具有有限内存集的事物，因为它们可以有效地利用分配的内存。以下代码是堆栈的简单实现：'
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can see the output from our program as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从我们的程序输出中看到以下内容：
- en: '![](img/b5668bbc-af83-441e-9686-3cba9578e963.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5668bbc-af83-441e-9686-3cba9578e963.png)'
- en: We can see that our stack operations were executed as expected. Being able to
    use stack manipulation is important in computer science as this is how many low-level
    programming techniques are executed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的堆栈操作按预期执行。能够使用堆栈操作在计算机科学中非常重要，因为这是许多低级编程技术执行的方式。
- en: Associative containers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联容器
- en: '**Associative containers** are containers that implement associative arrays.
    These arrays are ordered and differ only in the constraints placed by the algorithm
    on each of their elements. The STL references associative containers—namely set,
    map, multiset, and multimap. We will explore these in the following sections.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**关联容器**是实现关联数组的容器。这些数组是有序的，只是在算法对它们的每个元素施加的约束上有所不同。STL引用关联容器，即set、map、multiset和multimap。我们将在以下部分探讨这些内容。'
- en: Set
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'A **set** is used to only store keys. Go doesn''t have a set type, so a `map`
    of the type to a Boolean value is used frequently in order to build a set. The
    following code block is an implementation of an STL equivalent set:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**用于仅存储键。Go没有集合类型，因此经常使用`map`类型到布尔值的映射来构建集合。以下代码块是STL等效集合的实现：'
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The resulting output shows that we were able to set and delete the values accordingly:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出显示我们能够设置和删除相应的值：
- en: '![](img/7addd1b1-797a-4329-b59f-542ae2b6fb62.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7addd1b1-797a-4329-b59f-542ae2b6fb62.png)'
- en: We can see from our output that our code can properly manipulate a set, which
    is crucial for common key–value pairings.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的输出中可以看出，我们的代码可以正确地操作集合，这对于常见的键-值对非常重要。
- en: Multiset
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重集
- en: '**Multisets** are unordered sets with a count associated with each element.
    There are lots of convenient bits of manipulation that can be used with multisets,
    such as taking the difference, scaling the set, or checking the cardinality of
    a set.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**多重集**是带有与每个元素关联的计数的无序集合。多重集可以进行许多方便的操作，例如取差集、缩放集合或检查集合的基数。'
- en: 'In our example, we build a multiset `x`, scale it by `2` as a multiset `y`,
    validate that `x` is a subset of `y`, and check the cardinality of `x`. We can
    see an example implementation of a multiset in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们构建了一个多重集`x`，将其缩放为多重集`y`，验证`x`是否是`y`的子集，并检查`x`的基数。我们可以在以下代码中看到多重集的一个示例实现：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we execute this code, we can see `x`, the scaled version of `x`, `y`, the
    validation of `x` as a subset of `y`, and the cardinality calculation of `x`.
    The following is the output from the execution of our multiset code snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行此代码时，我们可以看到`x`，`x`的缩放版本`y`的验证，以及`x`的基数计算。以下是我们多重集代码片段执行的输出：
- en: '![](img/1e1f8c99-6d59-49b1-a0e6-46cec4e2d93a.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e1f8c99-6d59-49b1-a0e6-46cec4e2d93a.png)'
- en: Multisets are useful for set manipulation and are convenient because there can
    be multiple instances of each element. A good practical example of a multiset
    would be a shopping cart—you can add many items to your shopping cart and you
    can have many counts of the same item in your shopping cart.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 多重集对于集合操作非常有用，并且非常方便，因为每个元素可以有多个实例。多重集的一个很好的实际例子是购物车——您可以向购物车中添加许多物品，并且您可以在购物车中拥有同一物品的多个计数。
- en: Map
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: A **map** is a kind of container that is used to store key–value pairs. Go's
    built-in `map` type uses a hash table to store keys and their associated values.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射**是一种用于存储键-值对的容器。Go的内置`map`类型使用哈希表来存储键和它们关联的值。'
- en: 'In Go, instantiating a map is simple, as shown in the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，实例化映射很简单，如下所示：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s have a look at the output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下输出：
- en: '![](img/4851a8a9-75ea-4ead-9a1a-5c545d7e85eb.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4851a8a9-75ea-4ead-9a1a-5c545d7e85eb.png)'
- en: In the preceding execution result, we can see that we can create a map, reference
    a value in a map by using its key, and find the number of elements in our map
    using the `Len()` built-in type.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的执行结果中，我们可以看到我们可以创建一个映射，通过使用它的键引用映射中的值，并使用`Len()`内置类型找到我们映射中的元素数量。
- en: Multimap
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重映射
- en: A **multimap** is a map where one or more values can be returned with a key.
    A practical application of a multimap would be a web query string. Query strings
    can have multiple values assigned to the same key, as we can see with the following
    example URL: `https://www.example.com/?foo=bar&foo=baz&a=b`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**多重映射**是一个可以返回一个或多个值的映射。多重映射的一个实际应用是Web查询字符串。查询字符串可以将多个值分配给相同的键，就像我们在下面的示例URL中看到的那样：`https://www.example.com/?foo=bar&foo=baz&a=b`。'
- en: 'In our example, we are going to create a multimap of cars. Our `car` struct
    has a year and a style associated with each car. We''ll be able to aggregate these
    different types together. The following code snippet is an implementation of a
    multimap:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将创建一个汽车的多重映射。我们的`car`结构体每辆车都有一个年份和一个风格。我们将能够聚合这些不同类型。以下代码片段是一个多重映射的实现：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have multiple versions of cars with a `2019` model year (a convertible and `SUV`).
    In our resulting output, we can see these values aggregated together:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多个版本的汽车，有一个`2019`年的车型（敞篷车和SUV）。在我们的输出结果中，我们可以看到这些值被聚合在一起：
- en: '![](img/c9e210b0-fd35-4fc8-b8f8-9e5d3d55f297.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9e210b0-fd35-4fc8-b8f8-9e5d3d55f297.png)'
- en: Multimaps are useful when you have a one-to-many association that you'd like
    to capture in a map. In the next section, we will look at function objects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在映射中捕获一对多的关联时，多重映射是非常有用的。在下一节中，我们将看看函数对象。
- en: Understanding function objects
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数对象
- en: '**Function objects**, also known as **functors**, are used for generating,
    testing, and operating on data. If you declare an object as a functor, you can
    use that object as one would use a function call. Oftentimes, the algorithms in
    the STL need a parameter to perform their designated tasks. Functors tend to be
    a useful way to assist in performing those tasks. In this section, we will learn
    about the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数对象**，也称为**函子**，用于生成、测试和操作数据。如果将一个对象声明为函子，你可以像使用函数调用一样使用该对象。通常情况下，STL中的算法需要一个参数来执行它们指定的任务。函子往往是一种有用的方式来帮助执行这些任务。在本节中，我们将学习以下内容：'
- en: Functors
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子
- en: Internal and external iterators
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部和外部迭代器
- en: Generators
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Implicit iterators
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式迭代器
- en: Functors
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子
- en: A **functor** is a functional programming paradigm in which a transformation
    is performed on a structure while the structure is preserved.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**函子**是一种函数式编程范式，它在保持结构的同时对结构执行转换。'
- en: 'In our example, we take an integer slice, `intSlice`, and lift the slice into
    a functor. `IntSliceFunctor` is an interface that includes the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们取一个整数切片`intSlice`，并将该切片提升为一个函子。`IntSliceFunctor`是一个包括以下内容的接口：
- en: '`fmt.Stringer`, which defines the string format for the value with its representation.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt.Stringer`，它定义了值的字符串格式及其表示。'
- en: '`Map(fn func(int int) IntSliceFunctor` – this mapping applies `fn` to each
    element in our slice.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map(fn func(int int) IntSliceFunctor` – 这个映射将`fn`应用到我们切片中的每个元素。'
- en: A convenience function, `Ints() []int`, which allows you to get the `int` slice
    the functor holds.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方便的函数，`Ints() []int`，它允许你获取函子持有的`int`切片。
- en: 'After we have our lifted slice, we can perform operations on our newly created
    functor. In our example, we perform a square operation and a modulus three operation.
    The following is an example implementation of a functor:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了我们的提升切片之后，我们可以对我们新创建的函子执行操作。在我们的例子中，我们执行了一个平方操作和一个模三操作。以下是一个函子的示例实现：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'During the execution of this code, we can see that our function manipulation
    with functors worked as expected. We took our initial `intSlice`, lifted it into
    a functor, applied a square to each value with `squareFunc`, and applied `%3`
    to each value with `modThreeFunc`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这段代码时，我们可以看到我们的函子对函数操作的处理符合预期。我们取出了我们的初始`intSlice`，将它提升为一个函子，用`squareFunc`对每个值应用了平方，并用`modThreeFunc`对每个值应用了`%3`：
- en: '![](img/894922cf-f5cd-4fdb-bdc0-3d3673dc0c35.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/894922cf-f5cd-4fdb-bdc0-3d3673dc0c35.png)'
- en: Functors are a very powerful language construct. A functor abstracts a container
    in a way that is easily modifiable. It also allows for a separation of concerns—for
    instance, you can separate iteration logic from calculation logic, functors can
    be parameterized more simply, and functors can also be stateful.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 函子是一种非常强大的语言构造。函子以一种易于修改的方式抽象了一个容器。它还允许关注点的分离——例如，你可以将迭代逻辑与计算逻辑分开，函子可以更简单地进行参数化，函子也可以是有状态的。
- en: Iterators
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'We discussed iterators in [Chapter 3](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml),
    *Understanding Concurrency*. Iterators are objects that allow the traversal of
    lists and other containers. Iterators are often implemented as part of a container''s
    interface, which is an important method for a programmer. These are often split
    into the following categories:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml)中讨论了迭代器，*理解并发*。迭代器是允许遍历列表和其他容器的对象。迭代器通常作为容器接口的一部分实现，这对程序员来说是一个重要的方法。它们通常被分为以下类别：
- en: Internal iterators
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部迭代器
- en: External iterators
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部迭代器
- en: Generators
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Implicit iterators
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式迭代器
- en: We will cover what these categories are in more detail in the following sections.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更详细地讨论这些类别是什么。
- en: Internal iterators
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部迭代器
- en: '**Internal** **iterators** are represented as higher-order functions (often
    utilizing anonymous functions, as we saw in [Chapter 3](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml),
    *Understanding Concurrency*). Higher-order functions take functions as arguments
    and return functions as outputs. Anonymous functions are functions that aren''t
    bound to identifiers.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部迭代器**表示为高阶函数（通常使用匿名函数，正如我们在[第3章](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml)中所见，*理解并发*）。高阶函数将函数作为参数并返回函数作为输出。匿名函数是不绑定标识符的函数。'
- en: Internal iterators often map themselves to applying a function to every element
    in a container. This can be represented by a variable identifier or it can be
    represented anonymously. The authors of the language have mentioned that apply/reduce
    are possible in Go, but shouldn't be used (this is because `for` loops tend to
    be preferred in Go). This pattern follows along with Go's motto of *simple is
    better than clever*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 内部迭代器通常映射到将函数应用于容器中的每个元素。这可以由变量标识符表示，也可以匿名表示。语言的作者曾提到在Go语言中可以使用apply/reduce，但不应该使用（这是因为在Go语言中通常更喜欢使用`for`循环）。这种模式符合Go语言的座右铭*简单胜于巧妙*。
- en: External iterators
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部迭代器
- en: '**External iterators** are used in order to access elements within an object
    and point to the next element in the object (known as element access and traversal,
    respectively). Go uses the `for` loop iterator heavily. The `for` loop is Go''s
    only natural looping construct, and greatly simplifies program construction. A
    `for` loop is as simple as the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 外部迭代器用于访问对象中的元素并指向对象中的下一个元素（分别称为元素访问和遍历）。Go语言大量使用`for`循环迭代器。`for`循环是Go语言唯一的自然循环结构，并极大简化了程序构建。`for`循环就像下面这样简单：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see our output as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的输出如下：
- en: '![](img/12e62017-4ec8-4562-9e54-15c3dac96969.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12e62017-4ec8-4562-9e54-15c3dac96969.png)'
- en: Our `for` loop iterator is simple, but it proves a strong point—sometimes, simplicity
    works as expected for difficult problem sets.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`for`循环迭代器很简单，但证明了一个重要观点——有时，简单对于复杂的问题集也能起到预期的作用。
- en: Generators
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: '**Generators** return the subsequent value in a sequence when a function is
    called. As you can see in the following code block, anonymous functions can be
    used to implement the generator iterator pattern in Go:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器**在调用函数时返回序列中的下一个值。如下面的代码块所示，匿名函数可以用于在Go语言中实现生成器迭代器模式：'
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When `incrementCounter()` is called, the integer represented in the function
    is incremented. Being able to use anonymous functions concurrently in this manner
    is a big draw for a lot of programmers coming to Go from other languages. It gives
    a succinct method for drawing on the concurrency of the language.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`incrementCounter()`时，函数中表示的整数会递增。能够以这种方式并发使用匿名函数对许多从其他语言转到Go语言的程序员来说是一个很大的吸引点。它为利用语言的并发提供了简洁的方法。
- en: Implicit Iterators
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式迭代器
- en: 'An **implicit iterator** gives the programmer an easy way to iterate through
    the elements that are stored within a container. This is often created with a
    built-in range in Go. The built-in range allows you to iterate through your container.
    The following is a code snippet implementing an implicit iterator:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式迭代器**为程序员提供了一种简单的方法来迭代容器中存储的元素。这通常是使用Go语言中的内置range创建的。内置的range允许您遍历容器。以下是实现隐式迭代器的代码片段：'
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can see the resulting output as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到以下结果输出：
- en: '![](img/d46622c2-5514-4696-a784-1fa92aed1b26.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d46622c2-5514-4696-a784-1fa92aed1b26.png)'
- en: This output shows our iteration through the range of our `stringExample` variable.
    The `range` function is a very powerful construct that is concise and easy to
    read.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了我们对`stringExample`变量范围的迭代。`range`函数是一种非常强大的构造，简洁易读。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use STL practices in Go. We also learned
    how to utilize standard programming algorithms with respect to Go, learned about
    how containers store data, learned how functions work in Go, and looked at how
    to use iterators properly. As we continue on our Go performance journey, we should
    always keep these algorithms, containers, functors, and iterators at the forefront
    of our choices for writing code. Doing so will help us to write idiomatic Go quickly
    and concisely. Choosing the proper combination of these STL idioms will help us
    to manipulate the data that we have in our hands faster and more effectively.
    In the next chapter, we will learn how to compute vectors and matrices in Go.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Go语言中使用STL实践。我们还学习了如何利用标准编程算法来处理Go语言，学习了容器如何存储数据，学习了函数在Go语言中的工作原理，并了解了如何正确使用迭代器。在我们继续Go性能之旅时，我们应始终将这些算法、容器、函数和迭代器放在编写代码选择的首要位置。这样做将帮助我们快速而简洁地编写符合惯例的Go代码。选择这些STL习语的正确组合将帮助我们更快、更有效地操作手头的数据。在下一章中，我们将学习如何在Go语言中计算向量和矩阵。
