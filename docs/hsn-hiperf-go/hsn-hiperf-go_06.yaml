- en: Matrix and Vector Computation in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中的矩阵和向量计算
- en: Matrix and vector computation are important in computer science. Vectors can
    hold a group of objects in a dynamic array. They use contiguous storage and can
    be manipulated to accommodate growth. Matrices build on vectors, creating a two-dimensional
    set of vectors. In this chapter, we are going to discuss matrices and vectors
    along with how these two data structures can be used practically to perform much
    of the data manipulation that happens in computer science today. Vectors and matrices
    are building blocks that are commonly used for linear algebra, which is important
    in today's computer science. Processes such as image processing, computer vision,
    and web search all utilize linear algebra to perform their respective actions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵和向量计算在计算机科学中很重要。向量可以在动态数组中保存一组对象。它们使用连续的存储，并且可以被操作以适应增长。矩阵建立在向量的基础上，创建了一个二维向量集。在本章中，我们将讨论矩阵和向量以及这两种数据结构如何实际使用，以执行今天计算机科学中发生的大部分数据操作。向量和矩阵是线性代数的基本组成部分，在今天的计算机科学中非常重要。诸如图像处理、计算机视觉和网络搜索等过程都利用线性代数来执行它们各自的操作。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: '**Basic Linear Algebra Subprograms** (**BLAS**)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本线性代数子程序**（**BLAS**）'
- en: Vectors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量
- en: Matrices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵
- en: Vector and matrix manipulation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量和矩阵操作
- en: Once we are able to tie all of these things together, you will learn how these
    different facets of matrix and vector computation can help drive forward the effective
    manipulation of large groupings of data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够将所有这些东西联系在一起，你将学会如何利用矩阵和向量计算的不同方面来推动大量数据的有效操作。
- en: Introducing Gonum and the Sparse library
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Gonum和Sparse库
- en: One of the most popular libraries in Go for scientific algorithms is the Gonum
    package. The Gonum package ([https://github.com/gonum](https://github.com/gonum))
    provides utilities that assist us in writing effective numerical algorithms using
    Go. This package focuses on creating performant algorithms for use in many different
    applications, and vectors and matrices are core tenets of this package. This library
    was created with performance in mind – the creators saw a problem with fighting
    vectorization in C, so they built this library in order to be able to manipulate
    vectors and matrices more easily in Go. The Sparse library ([https://github.com/james-bowman/sparse](https://github.com/james-bowman/sparse))
    was built on top of the Gonum library in order to handle some of the normal sparse
    matrix operations that happen in machine learning and other parts of scientific
    computing. Using these libraries together is a performant way to manage vectors
    and matrices in Go.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Go中最受欢迎的科学算法库之一是Gonum包。Gonum包（[https://github.com/gonum](https://github.com/gonum)）提供了一些工具，帮助我们使用Go编写有效的数值算法。这个包专注于创建高性能算法，可以在许多不同的应用程序中使用，向量和矩阵是这个包的核心要点。这个库是以性能为目标创建的
    - 创建者们在C中看到了向量化的问题，所以他们建立了这个库，以便更容易地在Go中操作向量和矩阵。Sparse库（[https://github.com/james-bowman/sparse](https://github.com/james-bowman/sparse)）是建立在Gonum库之上的，用于处理在机器学习和科学计算的其他部分中发生的一些正常的稀疏矩阵操作。在Go中使用这些库是一种高性能的方式来管理向量和矩阵。
- en: In the next section, we'll look at what BLAS is.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看BLAS是什么。
- en: Introducing BLAS
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍BLAS
- en: 'A specification called BLAS is commonly used in order to perform linear algebra
    operations. This library was originally created as a FORTRAN library in 1979 and
    has been maintained since then. BLAS has many optimizations for performant manipulation
    of matrices. Because of the depth and breadth of this specification, many languages
    have chosen to use this specification as part of their linear algebra libraries
    within their domain. The Go Sparse library uses a BLAS implementation for its
    linear algebra manipulation. The BLAS specification is composed of three separate
    routines:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: BLAS是一个常用的规范，用于执行线性代数运算。这个库最初是在1979年作为FORTRAN库创建的，并且自那时以来一直得到维护。BLAS对矩阵的高性能操作进行了许多优化。由于这个规范的深度和广度，许多语言选择在其领域内的线性代数库中使用这个规范的一部分。Go
    Sparse库使用了BLAS实现进行线性代数操作。BLAS规范由三个单独的例程组成：
- en: 'Level 1: Vector operations'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别1：向量操作
- en: 'Level 2: Matrix-vector operations'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别2：矩阵-向量操作
- en: 'Level 3: Matrix-matrix operations'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别3：矩阵-矩阵操作
- en: Having these leveled routines helps with the implementation and testing of this
    specification. BLAS has been used in many implementations, from Accelerate (macOS
    and iOS framework) to the Intel **Math Kernel Library** (**MKL**), and has been
    an integral part of linear algebra in applied computer science.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些分级的例程，有助于实现和测试这个规范。BLAS已经在许多实现中使用过，从Accelerate（macOS和iOS框架）到英特尔**数学核心库**（**MKL**），并且已经成为应用计算机科学中线性代数的一个重要部分。
- en: Now, it's time to learn about vectors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候学习关于向量的知识了。
- en: Introducing vectors
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍向量
- en: 'A vector is a one-dimensional array that is often used for storing data. Go
    originally had a container/vector implementation, but this was removed on 18 October
    2011, as slices were deemed more idiomatic for vector use in Go. The functionality
    provided by the built-in slice gives plenty of vector manipulation help. A slice
    would be a row vector, or 1 × m matrix, implementation. A simple row vector looks
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是一种常用于存储数据的一维数组。Go最初有一个容器/向量实现，但在2011年10月18日被移除，因为切片被认为更适合在Go中使用向量。内置切片提供的功能可以提供大量的向量操作帮助。切片将是一个行向量，或者1×m矩阵的实现。一个简单的行向量如下所示：
- en: '![](img/00b322c7-b978-45a4-a681-2f4397aa7199.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00b322c7-b978-45a4-a681-2f4397aa7199.png)'
- en: 'As you can see, we have a 1 × m matrix. To implement a simple row vector in
    Go, we can use a slice representation, like so:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们有一个1×m矩阵。要在Go中实现一个简单的行向量，我们可以使用切片表示，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an easy way to portray a simple row vector using Go's built-in functionality.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种使用Go内置功能来描绘简单行向量的简单方法。
- en: Vector computations
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量计算
- en: 'A column vector is an m x 1 matrix, also known as the transpose of a row vector.
    A matrix transposition is when a matrix is flipped over its diagonal, often denoted
    with a superscript T. We can see an example of a column vector in the following
    image:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列向量是一个m x 1矩阵，也被称为行向量的转置。矩阵转置是指矩阵沿对角线翻转，通常用上标T表示。我们可以在下面的图片中看到一个列向量的例子：
- en: '![](img/a47f76c2-b883-4fba-adc9-1eb32396c694.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47f76c2-b883-4fba-adc9-1eb32396c694.png)'
- en: 'If we want to implement a column vector in Go, we can use the Gonum vector
    package to initialize this vector, as shown in the following code block:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在Go中实现一个列向量，我们可以使用Gonum向量包来初始化这个向量，就像下面的代码块中所示的那样：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will print out a column vector like the one shown in the preceding image.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出一个列向量，就像前面图片中所示的那样。
- en: 'We can also do some neat vector manipulation with the Gonum package. For example,
    in the following code block, we can see how simple it is to double the values
    within a vector. We can add two vectors together using the `AddVec` function,
    thus creating a doubled vector. We also have the `prettyPrintMatrix` convenience
    function to make our matrix easier to read:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用Gonum包对向量进行一些整洁的操作。例如，在下面的代码块中，我们可以看到如何简单地将向量中的值加倍。我们可以使用`AddVec`函数将两个向量相加，从而创建一个加倍的向量。我们还有`prettyPrintMatrix`便利函数，使我们的矩阵更容易阅读：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result of this function, that is, a doubled vector, is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的结果，也就是加倍的向量，如下所示：
- en: '![](img/1b020747-a770-4fb4-ad41-98648242a382.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b020747-a770-4fb4-ad41-98648242a382.png)'
- en: 'The `gonum/mat` package also gives us many other neat helper functions for
    vectors, including the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`gonum/mat`包还为向量提供了许多其他整洁的辅助函数，包括以下内容：'
- en: '`Cap()` gives you the capacity of the vector'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cap()` 给出了向量的容量'
- en: '`Len()` gives you the number of columns within the vector'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Len()` 给出了向量中的列数'
- en: '`IsZero()` validates whether or not a vector is zero-sized'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsZero()` 验证向量是否为零大小'
- en: '`MulVec()` multiplies vectors *a* and *b* and serves the result'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MulVec()`将向量*a*和*b*相乘并返回结果'
- en: '`AtVec()` returns the value within the vector at a given position'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AtVec()`返回向量中给定位置的值'
- en: The vector manipulation functions within the `gonum/mat` package help us to
    easily manipulate vectors into the datasets that we need.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`gonum/mat`包中的向量操作函数帮助我们轻松地将向量操作成我们需要的数据集。'
- en: Now that we are done with vectors, let's look at matrices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了向量，让我们来看看矩阵。
- en: Introducing matrices
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍矩阵
- en: Matrices are two-dimensional arrays, categorized by rows and columns. They are
    important in graphics manipulation and AI; namely, image recognition. Matrices
    are commonly used for graphics since the rows and columns that reside within a
    matrix can correspond to the row and column arrangement of pixels on a screen,
    as well as because we can have the matrix values correspond to a particular color.
    Matrices are also frequently used for digital sound processing as digital audio
    signals are filtered and compressed using Fourier transforms, and matrices help
    with performing these actions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是二维数组，按行和列分类。它们在图形处理和人工智能中很重要；即图像识别。矩阵通常用于图形处理，因为矩阵中的行和列可以对应于屏幕上像素的行和列排列，以及因为我们可以让矩阵的值对应于特定的颜色。矩阵也经常用于数字音频处理，因为数字音频信号使用傅里叶变换进行滤波和压缩，矩阵有助于执行这些操作。
- en: 'Matrices are usually denoted with an *M × N* naming scheme, where *M* is the
    number of rows in the matrix and *N* is the number of columns in the matrix, as
    shown in the following image:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵通常用*M × N*的命名方案表示，其中*M*是矩阵中的行数，*N*是矩阵中的列数，如下图所示：
- en: '![](img/d388ff6d-3fc2-431f-9a5a-f3afa4dd282c.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d388ff6d-3fc2-431f-9a5a-f3afa4dd282c.png)'
- en: The preceding image, for example, is a 3 x 3 matrix. An *M x N* matrix is one
    of the core tenants of linear algebra, so it's important to see its relationship
    here.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面的图片是一个3 x 3的矩阵。*M x N*矩阵是线性代数的核心要素之一，因此在这里看到它的关系是很重要的。
- en: Now, let's see how matrices operate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看矩阵是如何操作的。
- en: Matrix operations
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵操作
- en: 'Matrices are a good way to store a large amount of information in an efficient
    manner, but the manipulation of matrices is where the real value of matrices is
    derived from. The most commonly used matrix manipulation techniques are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是以高效的方式存储大量信息的好方法，但是矩阵的操作是矩阵真正价值的所在。最常用的矩阵操作技术如下：
- en: Matrix addition
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵加法
- en: Matrix scalar multiplication
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵标量乘法
- en: Matrix transposition
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵转置
- en: Matrix multiplication
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: Being able to perform these actions on matrices is important as they can help
    with real-world data manipulation at scale. We will take a look at some of these
    operations, as well as practical applications of them, in the following sections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在矩阵上执行这些操作是很重要的，因为它们可以帮助处理规模化的真实世界数据操作。我们将在接下来的部分中看一些这些操作，以及它们的实际应用。
- en: Matrix addition
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵加法
- en: 'Matrix addition is the method in which we add two matrices together. Perhaps
    we want to find the resulting value of the summation of two 2D sets. If we have
    two matrices of the same size, we can add them together, like so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵加法是将两个矩阵相加的方法。也许我们想要找到两个2D集合的求和结果值。如果我们有两个相同大小的矩阵，我们可以将它们相加，就像这样：
- en: '![](img/8bccb841-8f4e-4dab-8dce-228ef662ba58.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bccb841-8f4e-4dab-8dce-228ef662ba58.png)'
- en: 'We can also represent this in Go code, as shown in the following code block:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用Go代码表示这一点，就像下面的代码块中所示的那样：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result of executing this function is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个函数的结果如下：
- en: '![](img/71bc0301-19cd-4cf0-90da-68a61be2c948.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71bc0301-19cd-4cf0-90da-68a61be2c948.png)'
- en: The result is a depiction of the matrix summation from our code block.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是我们代码块中矩阵求和的描述。
- en: In the next section, we will discuss a practical example of matrix manipulation.
    To demonstrate this example, we will use matrix subtraction.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论矩阵操作的一个实际例子。为了演示这个例子，我们将使用矩阵减法。
- en: A practical example (matrix subtraction)
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个实际的例子（矩阵减法）
- en: 'Suppose you own two restaurants, one in **New York, NY** and one in **Atlanta,
    GA**. You want to figure out what items are selling the best in your restaurants
    each month in order to make sure that you stock the right ingredients in the upcoming
    months. We can utilize matrix subtraction to find the net total number of unit
    sales we had for each restaurant. We need to have the raw data for unit sales
    for each restaurant, as shown in the following tables:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您拥有两家餐厅，一家位于**纽约，纽约**，另一家位于**亚特兰大，乔治亚**。您想要弄清楚每个月在您的餐厅中哪些物品销售最好，以确保您在接下来的几个月中备货正确的原料。我们可以利用矩阵减法找到每家餐厅的单位销售净总数。我们需要每家餐厅的单位销售原始数据，如下表所示：
- en: 'May unit sales:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 五月销量：
- en: '|  | **New York, NY** | **Atlanta, GA** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|  | **纽约，纽约** | **亚特兰大，乔治亚** |'
- en: '| Lobster Bisque | 1,345 | 823 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 龙虾浓汤 | 1,345 | 823 |'
- en: '| House Salad | 346 | 234 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 鲜蔬沙拉 | 346 | 234 |'
- en: '| Ribeye Steak | 843 | 945 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: 肋眼牛排 | 843 | 945
- en: '| Ice Cream Sundae | 442 | 692 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 冰淇淋圣代 | 442 | 692 |'
- en: 'June unit sales:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 六月销量：
- en: '|  | **New York, NY** | **Atlanta, GA** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  | **纽约，纽约** | **亚特兰大，乔治亚** |'
- en: '| Lobster Bisque | 920 | 776 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 龙虾浓汤 | 920 | 776 |'
- en: '| House Salad | 498 | 439 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: 鲜蔬沙拉 | 498 | 439
- en: '| Ribeye Steak | 902 | 1,023 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: 肋眼牛排 | 902 | 1,023
- en: '| Ice Cream Sundae | 663 | 843 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 冰淇淋圣代 | 663 | 843 |'
- en: 'Now, we can find the difference in unit sales between these two months using
    the following matrix subtraction:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下矩阵减法找到这两个月之间的单位销售差异：
- en: '![](img/43b44258-6545-45bf-af7b-ec30fd67ef97.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43b44258-6545-45bf-af7b-ec30fd67ef97.png)'
- en: 'We can perform this same action in Go, as shown in the following code block:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Go中执行相同的操作，如下所示的代码块：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our resulting output gives us the difference in sales for both restaurants
    between May and June, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果输出给出了五月和六月之间两家餐厅的销售差异，如下所示：
- en: '![](img/10425e6d-5f23-4933-a4e6-74d78620f88f.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10425e6d-5f23-4933-a4e6-74d78620f88f.png)'
- en: The result in the preceding screenshot is shown as an *N × M* matrix, depicting
    the sales differences.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述屏幕截图中的结果显示为*N × M*矩阵，描述了销售差异。
- en: As we gain more restaurants and add more items to our restaurant menu, utilizing
    matrix subtraction will help us to keep a note of which items we need to keep
    in stock.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们拥有更多的餐厅并在餐厅菜单中添加更多项目，利用矩阵减法将有助于我们记下我们需要保持库存的物品。
- en: Scalar multiplication
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标量乘法
- en: While manipulating matrices, we may want to multiply all of the values within
    a matrix by a scalar value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作矩阵时，我们可能希望将矩阵中的所有值乘以一个标量值。
- en: 'We can represent this in Go with the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码在Go中表示这一点：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code produces the following results:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生了以下结果：
- en: '![](img/c155d917-5fbb-42d8-b001-5a2b9f4a6270.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c155d917-5fbb-42d8-b001-5a2b9f4a6270.png)'
- en: Here, we can see that each element in our matrix has been scaled by 4, thus
    providing an executed example of matrix scaling.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到矩阵中的每个元素都被缩放了4倍，从而提供了矩阵缩放的执行示例。
- en: Scalar multiplication practical example
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标量乘法实际示例
- en: 'Let''s say we own a hardware store and we have a catalog of products that have
    a **United States Dollar** (**USD**) value associated with them. Our company has
    decided to start selling our products in Canada, as well as the US. At the time
    of writing this book, $1 USD is equivalent to $1.34 **Canadian Dollars** (**CAD**).
    We can look at our matrix of prices for screws, nuts, and bolts based on volume
    count, as shown in the following table:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们拥有一个五金店，我们有一个产品目录，其中的产品与**美元**（**USD**）值相关联。我们公司决定开始在加拿大和美国销售我们的产品。在撰写本书时，1美元等于1.34加拿大元（**CAD**）。我们可以查看我们的螺丝、螺母和螺栓价格矩阵，根据数量计数，如下表所示：
- en: '|  | **Individual USD** | **100ct USD** | **1000ct USD** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  | **单个USD** | **100个USD** | **1000个USD** |'
- en: '| Screws | $0.10 | $0.05 | $0.03 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 螺丝 | $0.10 | $0.05 | $0.03 |'
- en: '| Nuts | $0.06 | $0.04 | $0.02 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 螺母 | $0.06 | $0.04 | $0.02 |'
- en: '| Bolts | $0.03 | $0.02 | $0.01 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 螺栓 | $0.03 | $0.02 | $0.01 |'
- en: 'If we use matrix scalar multiplication to find the resulting cost in CAD, we''ll
    end up with the following matrix computation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用矩阵标量乘法来找到CAD中的结果成本，我们将得到以下矩阵计算：
- en: '![](img/7cb9da0e-246b-40c8-98c0-4e74ab792012.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cb9da0e-246b-40c8-98c0-4e74ab792012.png)'
- en: 'We can validate this with our Go scalar multiplication functionality, as shown
    in the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Go标量乘法功能验证这一点，如下所示的代码片段：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We receive a resulting matrix that contains the values for each of our items
    in CAD:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到一个包含我们每个物品的CAD值的结果矩阵：
- en: '![](img/ccdb70b9-3875-4224-b005-cab7c4b6a435.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccdb70b9-3875-4224-b005-cab7c4b6a435.png)'
- en: The output shows us the scaled resulting matrix.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了我们缩放后的结果矩阵。
- en: As we get more and more products and have more different currencies that we'd
    like to account for, our scalar matrix manipulation will come in very handy as
    it will reduce the amount of work we have to do to manipulate these large sets
    of data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们获得越来越多的产品，并有更多不同的货币需要考虑，我们的标量矩阵操作将非常方便，因为它将减少我们需要操作这些大量数据集的工作量。
- en: Matrix multiplication
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: 'We may also want to multiply two matrices together. Multiplying two matrices
    together gives you a product of the two matrices. This can be very helpful when
    we want to multiply many numbers together at once in a concurrent fashion. We
    can take matrix *A*, an *N × M* matrix, alongside *B*, an *M × P* matrix. The
    resulting set is called *AB*, which is an *N × P* matrix, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想将两个矩阵相乘。将两个矩阵相乘会得到两个矩阵的乘积。当我们想要同时以并发方式将许多数字相乘时，这将非常有帮助。我们可以取矩阵*A*，一个*N
    × M*矩阵，以及*B*，一个*M × P*矩阵。结果集称为*AB*，是一个*N × P*矩阵，如下所示：
- en: '![](img/e82ea761-1246-45b0-938f-effceac4c7eb.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e82ea761-1246-45b0-938f-effceac4c7eb.png)'
- en: 'We can represent this in Go with the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码在Go中表示这一点：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After execution, we receive the following result:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们得到以下结果：
- en: '![](img/47d0d3dc-cea7-458b-a975-fc1ca5e3bbdc.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47d0d3dc-cea7-458b-a975-fc1ca5e3bbdc.png)'
- en: This is how we can multiply matrices together using the `gonum/mat` package.
    Matrix multiplication is a common matrix function, and understanding how to perform
    this action will help you manipulate matrices effectively.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以使用`gonum/mat`包将矩阵相乘的方式。矩阵乘法是一个常见的矩阵函数，了解如何执行这个操作将帮助您有效地操作矩阵。
- en: Matrix multiplication practical example
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵乘法实际示例
- en: 'Let''s talk about a practical example of matrix multiplication so that we can
    tie our theoretical work into a workable example. Two separate electronic vendors
    are vying for your business to make widgets for your company. Vendor A and vendor
    B both design offerings for the widget and give you a parts list for what they''ll
    need. Both vendor A and vendor B use the same component supplier. In this example,
    we can use matrix multiplication to find out which vendor creates a less expensive
    widget. The parts list that each vendor gave you is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈矩阵乘法的一个实际例子，这样我们就可以将我们的理论工作与一个可行的例子联系起来。两家不同的电子供应商正在竞相为您的公司制造小部件。供应商A和供应商B都为该小部件设计并为您提供了所需的零件清单。供应商A和供应商B都使用相同的组件供应商。在这个例子中，我们可以使用矩阵乘法来找出哪个供应商创建了一个更便宜的小部件。每个供应商给您的零件清单如下：
- en: '**Vendor A**:Resistors: 5'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商A**：电阻：5'
- en: 'Transistors: 10'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 晶体管：10
- en: 'Capacitors: 2'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 电容器：2
- en: '**Vendor B**:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商B**：'
- en: 'Resistors: 8'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻：8
- en: 'Transistors: 6'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 晶体管：6
- en: 'Capacitors: 3'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 电容器：3
- en: 'You know from the component''s supplier catalog that the pricing for each of
    these components is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您从组件供应商目录中得知，每个组件的定价如下：
- en: 'Resistors cost: $0.10'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电阻成本：$0.10
- en: 'Transistors cost: $0.42'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 晶体管成本：$0.42
- en: 'Capacitors cost: $0.37'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电容器成本：$0.37
- en: 'We can represent each of these inputs with matrices, as we learned previously.
    This is done as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用之前学到的方法，用矩阵来表示每个输入。这样做如下：
- en: 'We create a matrix composed of the cost of the components, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个由组件成本组成的矩阵，如下所示：
- en: '![](img/54558420-1ed7-4e3d-ac0f-06e756954ced.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54558420-1ed7-4e3d-ac0f-06e756954ced.png)'
- en: 'We create a matrix composed of the number of components from each vendor:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个由每个供应商的组件数量组成的矩阵：
- en: '![](img/3bb4f614-13ca-4049-bbeb-12821e878eb2.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bb4f614-13ca-4049-bbeb-12821e878eb2.png)'
- en: 'Then, we use matrix multiplication to find some neat results:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用矩阵乘法来找到一些有趣的结果：
- en: '![](img/6a727ef6-8d10-449b-ae9c-030ba4aeb3f6.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a727ef6-8d10-449b-ae9c-030ba4aeb3f6.png)'
- en: This result tells us that vendor A's solution costs $5.44 for parts, whereas
    vendor B's solution costs $4.43 for parts. Vendor B's solution is less expensive
    from a raw materials perspective.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果告诉我们，供应商A的解决方案零件成本为5.44美元，而供应商B的解决方案零件成本为4.43美元。从原材料的角度来看，供应商B的解决方案更便宜。
- en: 'This can be calculated in Go with the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在Go中用以下代码计算：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The resulting output confirms the calculations we did in the preceding program:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 得到的输出确认了我们在前面程序中所做的计算：
- en: '![](img/ebec003c-cb2b-4b1f-96d8-a1e8545ebefa.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebec003c-cb2b-4b1f-96d8-a1e8545ebefa.png)'
- en: As we see from our result, our formatted matrix lines up with the math that
    we performed earlier. Having a practical example can be very helpful in solidifying
    our understanding of theoretical concepts.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从结果中看到的，我们格式化的矩阵与我们之前执行的数学相吻合。在巩固我们对理论概念的理解方面，具有一个实际的例子可能会非常有帮助。
- en: Matrix transposition
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵转置
- en: 'Transposing a matrix flips a matrix diagonally, swapping rows and column indices.
    The following image shows an example transposition of a matrix:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵转置是指将矩阵对角线翻转，交换行和列索引。以下图片显示了矩阵的一个转置示例：
- en: '![](img/1475bd2c-8592-40f8-bc57-e676face4d1c.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1475bd2c-8592-40f8-bc57-e676face4d1c.png)'
- en: 'We can represent a matrix transposition in Go using the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码在Go中表示矩阵转置：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result of this matrix transposition can be seen in the following image:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵转置的结果可以在下图中看到：
- en: '![](img/2fa63e4c-f0e4-49ff-9bac-afcb485a38e7.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fa63e4c-f0e4-49ff-9bac-afcb485a38e7.png)'
- en: In the preceding output, we can see the regular matrix and the transposed version.
    Matrix transposition is often used in computer science to do things such as improve
    memory locality by transposing a matrix while still in memory.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到常规矩阵和转置版本。矩阵转置经常用于计算机科学中，比如通过在内存中转置矩阵来改善内存局部性。
- en: Matrix transposition practical example
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵转置实际示例
- en: 'Transposing matrices is fun, but it may be helpful for you to have a practical
    example of when matrix transposition might be used. Let''s say that we have three
    engineers: **Bob**, **Tom**, and **Alice**. These three engineers push Git commits
    daily. We want to keep track of these Git commits in a meaningful way so that
    we can make sure the engineers have all the resources they need to continue writing
    code. Let''s take a count of our engineers'' code commits for 3 days:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 转置矩阵很有趣，但对您来说，可能有一个矩阵转置可能会被使用的实际示例会很有帮助。假设我们有三个工程师：**鲍勃**，**汤姆**和**爱丽丝**。这三个工程师每天都推送Git提交。我们希望以一种有意义的方式跟踪这些Git提交，以便我们可以确保工程师们有他们需要继续编写代码的所有资源。让我们统计一下我们工程师连续3天的代码提交：
- en: '| **User** | **Day** | **Commits** |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **用户** | **天** | **提交** |'
- en: '| Bob | 1 | 5 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 鲍勃 | 1 | 5 |'
- en: '| Bob | 2 | 3 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 鲍勃 | 2 | 3 |'
- en: '| Bob | 3 | 10 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 鲍勃 | 3 | 10 |'
- en: '| Tom | 1 | 1 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 汤姆 | 1 | 1 |'
- en: '| Tom | 2 | 6 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 汤姆 | 2 | 6 |'
- en: '| Tom | 3 | 4 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 汤姆 | 3 | 4 |'
- en: '| Alice | 1 | 8 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 爱丽丝 | 1 | 8 |'
- en: '| Alice | 2 | 7 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 爱丽丝 | 2 | 7 |'
- en: '| Alice | 3 | 2 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 爱丽丝 | 3 | 2 |'
- en: 'After we have our data points, we can represent them in a 2D array:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了我们的数据点后，我们可以用一个二维数组来表示它们：
- en: '![](img/76486750-5d15-428b-a297-aaccfe1dffce.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76486750-5d15-428b-a297-aaccfe1dffce.png)'
- en: 'Now that we have this array, we can take the transposition of the array:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个数组，我们可以对数组进行转置：
- en: '![](img/a3acc159-f37d-42de-869e-ac94f779af6d.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3acc159-f37d-42de-869e-ac94f779af6d.png)'
- en: 'Now that we''ve performed this transposition, we can see that the rows of the
    transposed array correspond to the day of commits rather than the individual end
    users'' commits. Let''s look at the first row:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进行了这个转置，我们可以看到转置数组的行对应于提交的天数，而不是个体最终用户的提交。让我们看看第一行：
- en: '![](img/f3574069-e3d2-42ad-bb87-f5e164f9cd82.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3574069-e3d2-42ad-bb87-f5e164f9cd82.png)'
- en: This now represents **BD1**, **TD1**, and **AD1** – the day 1 commits for each
    of the developers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代表**BD1**、**TD1**和**AD1**——每个开发者的第1天提交。
- en: Now that we are done with the operations part, it's high time we had a look
    at matrix structures.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了操作部分，是时候看看矩阵结构了。
- en: Understanding matrix structures
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解矩阵结构
- en: 'Matrices are usually classified into two different structures: dense matrices
    and sparse matrices. A dense matrix is composed of mostly non-zero elements. A
    sparse matrix is a matrix that is mostly composed of elements with a 0 value.
    The sparsity of a matrix is calculated as the number of elements with a zero value
    divided by the total count of elements.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵通常被分类为两种不同的结构：密集矩阵和稀疏矩阵。密集矩阵由大部分非零元素组成。稀疏矩阵是一个大部分由值为0的元素组成的矩阵。矩阵的稀疏度被计算为具有零值的元素数除以总元素数。
- en: If the result of this equation is greater than 0.5, the matrix is sparse. This
    distinction is important as it helps us to determine the best method for matrix
    manipulation. If a matrix is sparse, we may be able to use some optimizations
    to make the matrix manipulation more efficient. Inversely, if we have a dense
    matrix, we know that we will most likely be performing actions on the whole matrix.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个方程的结果大于0.5，那么矩阵是稀疏的。这种区别很重要，因为它帮助我们确定矩阵操作的最佳方法。如果矩阵是稀疏的，我们可能能够使用一些优化来使矩阵操作更有效。相反，如果我们有一个密集矩阵，我们知道我们很可能会对整个矩阵执行操作。
- en: It is important to remember that operations on matrices are most likely going
    to be memory bound with today's computer hardware. The size of the matrix is an
    important thing to remember. When you're calculating when to use a sparse matrix
    or a dense matrix, a dense matrix will have the value of one int64, which, according
    to the size and alignment for numeric types in Go, is 8 bytes. A sparse matrix
    will have that value, plus an int for the column index of the entry. Keep these
    sizes in mind as you're choosing which data structure to use for your data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，矩阵的操作很可能会受到当今计算机硬件的内存限制。矩阵的大小是一个重要的记住的事情。当你在计算何时使用稀疏矩阵或密集矩阵时，密集矩阵将具有一个int64的值，根据Go中数字类型的大小和对齐，这是8个字节。稀疏矩阵将具有该值，加上一个条目的列索引的int。在选择要用于数据的数据结构时，请记住这些大小。
- en: Dense matrices
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密集矩阵
- en: When you create a dense matrix, all of the values of the matrix are stored.
    There are times when this is unavoidable – when we care about all of the values
    associated with a table and the table is mostly full. Using 2D slices or arrays
    for dense matrix storage can often be the best choice, but if you'd like to manipulate
    matrices, using the Gonum package can offer data manipulation in an effective
    manner. In practice, most matrices do not fall into the dense matrix category.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个密集矩阵时，矩阵的所有值都被存储。有时这是不可避免的——当我们关心与表相关的所有值并且表大部分是满的时。对于密集矩阵存储，使用2D切片或数组通常是最好的选择，但如果你想操作矩阵，使用Gonum包可以以有效的方式进行数据操作。实际上，大多数矩阵不属于密集矩阵类别。
- en: Sparse matrices
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稀疏矩阵
- en: Sparse matrices come up frequently in real-world datasets. Whether or not someone
    has viewed a video in a movie catalog, listened to the number of songs on a playlist,
    or completed an item in their to-do list are all good examples of times it's possible
    to use a sparse matrix. Many of the values within these tables are zero, so it
    doesn't make sense to store these matrices as dense matrices. This would take
    up a lot of room in memory and would be expensive to manipulate.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵在现实世界的数据集中经常出现。无论某人是否观看了电影目录中的视频，听了播放列表上的歌曲数量，或者完成了待办事项列表中的项目，都是可以使用稀疏矩阵的好例子。这些表中的许多值都是零，因此将这些矩阵存储为密集矩阵是没有意义的。这将占用大量内存空间，并且操作起来会很昂贵。
- en: We can use the Go sparse library in order to create and manipulate sparse matrices.
    The Sparse library uses idioms from BLAS routines in order to perform a lot of
    common matrix manipulation. The Go Sparse library is fully compatible with the
    Gonum matrix package, so it can be used interchangeably with this package. In
    this example, we're going to create a new sparse **Dictionary of Keys** (**DOK**).
    After we create this, we'll set particular *M x N* values for sets in the array.
    Lastly, we will use the `gonum/mat` package in order to print the sparse matrix
    that we have created.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Go稀疏库来创建和操作稀疏矩阵。稀疏库使用来自BLAS例程的习语来执行许多常见的矩阵操作。Go稀疏库与Gonum矩阵包完全兼容，因此可以与该包互换使用。在这个例子中，我们将创建一个新的稀疏**键字典**（**DOK**）。创建后，我们将为数组中的集合设置特定的*M
    x N*值。最后，我们将使用`gonum/mat`包来打印我们创建的稀疏矩阵。
- en: 'In the following code, we''re creating a sparse matrix using the Sparse package.
    The `ToCSR()` and `ToCSC()` matrix functions create CSR and CSC matrices, respectively:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们使用Sparse包创建了一个稀疏矩阵。`ToCSR()`和`ToCSC()`矩阵函数分别创建CSR和CSC矩阵：
- en: '[PRE10]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After we execute this code, we can see that the sparse matrix has been returned:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完这段代码后，我们可以看到稀疏矩阵已经返回：
- en: '![](img/70599b5b-53e2-4949-80bf-92cba0e216a2.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70599b5b-53e2-4949-80bf-92cba0e216a2.png)'
- en: This output shows us the resulting sparse matrix.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出向我们展示了生成的稀疏矩阵。
- en: 'Sparse matrices can be grouped into three separate formats:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵可以分为三种不同的格式：
- en: Formats that are utilized for the efficient creation and modification of a matrix
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于有效创建和修改矩阵的格式
- en: Formats that are utilized for efficient access and matrix operations
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于有效访问和矩阵操作的格式
- en: Specialized formats
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用格式
- en: 'The formats that are utilized for the efficient creation and modification of
    a matrix are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 用于有效创建和修改矩阵的格式如下：
- en: '**Dictionary of Keys** (**DOK**)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键字典**（**DOK**）'
- en: '**List of** **Lists** (**LIL**)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表的列表**（**LIL**）'
- en: '**Coordinate Lists** (**COO**)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坐标列表**（**COO**）'
- en: These formats will be defined in the following sections.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式将在以下部分中定义。
- en: DOK matrix
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOK矩阵
- en: A DOK matrix is a map in Go. This map links row and column pairs to their associated
    value. If no value has been defined for a particular coordinate in the matrix,
    it is assumed to be zero. Usually, a hashmap is used as the underlying data structure,
    which affords O(1) for random access, but iterating over elements ends up being
    a little bit slower. A DOK is useful for matrix construction or updating, but
    it is a non-performant choice for arithmetic operations. A DOK matrix can also
    be simply converted into a COO matrix once it's been created.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: DOK 矩阵是 Go 中的一个映射。这个映射将行和列对链接到它们的相关值。如果没有为矩阵中的特定坐标定义值，则假定为零。通常，哈希映射被用作底层数据结构，这为随机访问提供了
    O(1)，但遍历元素的速度会变得稍慢一些。DOK 对于矩阵的构建或更新是有用的，但不适合进行算术运算。一旦创建了 DOK 矩阵，它也可以简单地转换为 COO
    矩阵。
- en: LIL matrix
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LIL 矩阵
- en: An LIL matrix stores a list per row that contains the column index and the value,
    usually sorted by column, as this decreases lookup time. LIL matrices are useful
    for incrementally composing sparse matrices. They are also useful when we don't
    know the sparsity pattern for our incoming dataset.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: LIL 矩阵存储了每行的列表，其中包含列索引和值，通常按列排序，因为这样可以减少查找时间。LIL 矩阵对于逐步组合稀疏矩阵是有用的。当我们不知道传入数据集的稀疏模式时，它们也是有用的。
- en: COO matrix
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COO 矩阵
- en: A COO matrix (also frequently referred to as a triplet format matrix) stores
    lists of tuples containing rows, columns, and values, sorted by row and column
    index. A COO matrix is simple to append to with an O(1) timing. Random reads from
    a COO matrix are relatively slow (O(n)). COO matrices are a good choice for matrix
    initialization and conversion into CSR. COO matrices are a poor choice for arithmetic
    operations. We can improve the performance of a sequential iteration on a COO
    matrix by sorting the vectors within the matrix.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: A COO 矩阵（也经常被称为三元组格式矩阵）存储了按行和列索引排序的元组列表，其中包含行、列和值。COO 矩阵可以简单地通过 O(1) 的时间进行追加。从
    COO 矩阵中进行随机读取相对较慢（O(n)）。COO 矩阵是矩阵初始化和转换为 CSR 的良好选择。COO 矩阵不适合进行算术运算。通过对矩阵内的向量进行排序，可以提高对
    COO 矩阵的顺序迭代的性能。
- en: 'The formats that are utilized for efficient access and matrix operations are
    as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 用于高效访问和矩阵操作的格式如下：
- en: '**Compressed Sparse Row** (**CSR**)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩稀疏行**（**CSR**）'
- en: '**Compressed Sparse Column** (**CSC**)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩稀疏列**（**CSC**）'
- en: These formats will be defined in the following sections.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式将在以下部分中定义。
- en: CSR matrix
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSR 矩阵
- en: 'CSR matrices use three one-dimensional arrays to represent a matrix. The CSR
    format uses these three arrays:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: CSR 矩阵使用三个一维数组来表示矩阵。CSR 格式使用这三个数组：
- en: 'A: Values present within the array.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A：数组中存在的值。
- en: 'IA: The index in which each of these values is present. These are defined as
    follows:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IA：这些值的索引。这些值定义如下：
- en: The value of IA at the 0 index, IA[0] = 0
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IA 在索引 0 处的值，IA[0] = 0
- en: The value of IA at the i index, IA[i] = IA[i − 1] + (number of non-zero elements
    on the i-1^(th) row in the original matrix)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IA 在索引 i 处的值，IA[i] = IA[i − 1] +（原始矩阵中第 i-1 行上的非零元素数）
- en: 'JA: Stores the column indices of the elements.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JA：存储元素的列索引。
- en: 'The following image shows an example of a 4 x 4 matrix. This is the matrix
    that we are going to use in our following code sample:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个 4 x 4 矩阵的示例。这是我们将在下面的代码示例中使用的矩阵：
- en: '![](img/5ab5424b-13fd-4162-aaa5-5e4e016ed4a2.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ab5424b-13fd-4162-aaa5-5e4e016ed4a2.png)'
- en: 'We can calculate these values as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式计算这些值：
- en: A = [ 1 2 3 4]
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A = [ 1 2 3 4]
- en: IA = [0 1 2 3 4]
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IA = [0 1 2 3 4]
- en: JA = [2 0 3 1]
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JA = [2 0 3 1]
- en: 'We can validate this using the `sparse` package, as shown in the following code
    snippet:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `sparse` 包进行验证，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result shows us the reconverted values of the DOK representation of the
    matrix that we created, as well as its corresponding CSR matrix:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了我们创建的矩阵的 DOK 表示的重新转换值，以及其对应的 CSR 矩阵：
- en: '![](img/f59aabb2-8043-4d8b-a7fb-fab0ddef139a.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f59aabb2-8043-4d8b-a7fb-fab0ddef139a.png)'
- en: The output from this code shows us a CSR matrix that prints the IA, JA, and
    A values, respectively. As the matrix grows, being able to calculate a CSR matrix
    makes matrix manipulation more and more efficient. Computer science often manipulates
    matrices with millions of rows and columns, so being able to do so in an efficient
    manner makes your code much more performant.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出显示了一个打印 IA、JA 和 A 值的 CSR 矩阵。随着矩阵的增长，能够计算 CSR 矩阵使得矩阵操作变得更加高效。计算机科学通常会处理数百万行和列的矩阵，因此能够以高效的方式进行操作会使您的代码更加高效。
- en: CSC matrix
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSC 矩阵
- en: 'A CSC matrix has an identical format to CSR matrices, but with one small difference.
    The column index slice is the element that is compressed, rather than the row
    index slice, as we saw within the CSR matrix. This means CSC matrices store their
    values in column-major order, instead of row-major order. This can also be viewed
    as a natural transposition of a CSR matrix. We can manipulate the example that
    we used in the previous section to look at how a CSC matrix is created, as shown
    in the following code block:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: CSC 矩阵与 CSR 矩阵具有相同的格式，但有一个小的不同之处。列索引切片是被压缩的元素，而不是行索引切片，就像我们在 CSR 矩阵中看到的那样。这意味着
    CSC 矩阵以列为主序存储其值，而不是以行为主序。这也可以看作是对 CSR 矩阵的自然转置。我们可以通过对前一节中使用的示例进行操作，来看一下如何创建 CSC
    矩阵，如下面的代码块所示：
- en: '[PRE12]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result shows us the reconverted values of the DOK representation of the
    matrix that we created, as well as its corresponding CSC matrix:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了我们创建的矩阵的 DOK 表示的重新转换值，以及其对应的 CSC 矩阵：
- en: '![](img/6ac314fa-998d-4d1a-80e1-5e86d0161180.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ac314fa-998d-4d1a-80e1-5e86d0161180.png)'
- en: The output from the preceding code block shows us the DOK matrix as well as
    the CSC matrix. Knowing how to represent CSR and CSC matrices is vital in the
    process of matrix manipulation. These two different types of matrices have different
    distinguishing characteristics. For example, DOK matrices have an O(1) access
    pattern, while CSC matrices use column-oriented operations for efficiency.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码块的输出向我们展示了DOK矩阵和CSC矩阵。了解如何表示CSR和CSC矩阵对于矩阵操作过程至关重要。这两种不同类型的矩阵具有不同的特征。例如，DOK矩阵具有O(1)的访问模式，而CSC矩阵使用面向列的操作以提高效率。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed matrices and vectors, alongside how these two
    data structures are used practically to perform much of the data manipulation
    that happens in computer science today. Also, we learned about BLAS, vectors,
    matrices, and vector/matrix manipulation. Vectors and matrices are building blocks
    that are commonly used for linear algebra, and we saw hard examples of where this
    can take place.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了矩阵和向量，以及这两种数据结构如何在计算机科学中实际使用来执行大部分数据操作。此外，我们还了解了BLAS、向量、矩阵和向量/矩阵操作。向量和矩阵是线性代数中常用的基本组件，我们看到了它们在哪些情况下会发挥作用。
- en: The examples we have discussed in this chapter will help us a lot in situations
    pertinent to real-world data manipulation. In [Chapter 6](3ce4cee8-eaaa-4a6d-b817-4fdd3899f973.xhtml),
    *Composing Readable Go Code*, we are going to talk about composing readable Go
    code. Being able to write readable Go code will help keep topics and ideas clear
    and succinct for easy collaboration across code contributors.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的示例将在涉及真实世界数据处理的情况下对我们有很大帮助。在[第6章](3ce4cee8-eaaa-4a6d-b817-4fdd3899f973.xhtml)中，《编写可读的Go代码》，我们将讨论如何编写可读的Go代码。能够编写可读的Go代码将有助于保持主题和想法清晰简洁，便于代码贡献者之间的轻松协作。
