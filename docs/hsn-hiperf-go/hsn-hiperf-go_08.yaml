- en: Composing Readable Go Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可读的Go代码
- en: 'Learning how to write readable Go code is an essential part of the language.
    Language developers used their previous experience while writing other languages
    to create a language that they felt was clear and concise. A commonly used phrase
    in describing the proper way to write with this language is *idiomatic Go*. This
    phrase is used to describe the *correct* way to program in Go. Style is often
    subjective, but the Go team has worked hard in order to write the language in
    an opinionated way and facilitate developer velocity, readability, and collaboration.
    In this chapter, we are going to talk about how to maintain some core tenets of
    the language:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何编写可读的Go代码是语言的一个重要部分。语言开发人员在编写其他语言时使用了他们的先前经验来创建一种他们认为清晰简洁的语言。在描述使用这种语言编写的正确方式时，经常使用的短语是*惯用Go*。这个短语用来描述在Go中编程的*正确*方式。风格往往是主观的，但Go团队为了以一种有见地的方式编写语言并促进开发者的速度、可读性和协作而努力工作。在本章中，我们将讨论如何保持语言的一些核心原则：
- en: Simplicity
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单
- en: Readability
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读性
- en: Packaging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包
- en: Naming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名
- en: Formatting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化
- en: Interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Inheritance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Reflection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射
- en: Understanding these patterns and idioms will help you to write Go code that
    is more easily readable and operable between teams. Being able to write idiomatic
    Go will help raise the level of your code quality and help your project maintain
    velocity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些模式和惯用法将帮助您编写更易读和可操作的Go代码。能够编写惯用的Go将有助于提高代码质量水平，并帮助项目保持速度。
- en: Maintaining simplicity in Go
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持Go中的简单性
- en: Out of the box, Go doesn't follow specific patterns that other programming languages
    use. The writers chose different idioms for some of these following language constructs
    in order to keep the language simple and clear. Keeping the simplicity of the
    language has been a difficult task for language developers. Having tooling, libraries,
    fast execution, and fast compilation, all while maintaining simplicity, has been
    at the forefront of the language's development. Go's language developers have
    kept on track with these decisions with a design-by-consensus model—having a general
    consensus on adding things to a language ensures they are added in a way that
    is important to the development of the language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Go默认不遵循其他编程语言使用的特定模式。作者选择了不同的惯用法来保持语言简单和清晰。保持语言的简单性对语言开发人员来说是一项艰巨的任务。拥有工具、库、快速执行和快速编译，同时保持简单性，一直是语言开发的重中之重。Go的语言开发人员一直坚持这些决定，采用共识设计模式——对向语言添加新功能的共识确保了这些功能的重要性。
- en: Language maintainers are active on the GitHub issues page and are very happy
    to review pull requests if you have them. Getting feedback from others who write
    with the language allows language maintainers to make informed decisions about
    adding new features and functionality to the language while maintaining readability
    and simplicity.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 语言维护者在GitHub的问题页面上活跃，并且非常乐意审查拉取请求。从其他使用该语言的人那里获得反馈，使语言维护者能够就向语言添加新功能和功能做出明智的决定，同时保持可读性和简单性。
- en: 'The following section will show us the next fundamental aspect of the Go language:
    readability.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将向我们展示Go语言的下一个基本方面：可读性。
- en: Maintaining readability in Go
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持Go语言中的可读性
- en: Readability is another core tenet of Go. Being able to quickly grok a new code
    base and understand some of its nuances is an important part of any programming
    language. As distributed systems continue to grow, with vendored libraries and
    APIs becoming more commonplace, being able to easily read the code that is included
    and be able to make sense of it is helpful for forward momentum. This also makes
    broken code easier to fix.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性是Go的另一个核心原则。能够快速理解新代码库并理解其中一些微妙之处是任何编程语言的重要部分。随着分布式系统的不断增长，供应商库和API变得更加普遍，能够轻松阅读包含的代码并理解其中的意义对于推动前进是有帮助的。这也使得破损的代码更容易修复。
- en: Having concrete data types, interfaces, packages, concurrency, functions, and
    methods has helped Go to continue moving forward. Readability is one of the most
    important parameters of being able to maintain a large code base over an extended
    period of time, and this is one of the most important things that sets Go apart
    from its competitors. The language was constructed with readability as a first
    class citizen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有具体的数据类型、接口、包、并发、函数和方法有助于Go继续前进。可读性是能够在较长时间内维护大型代码库的最重要参数之一，这是Go与竞争对手之间最重要的区别之一。该语言是以可读性作为一等公民构建的。
- en: Go has a lot of complex looking underlying internal parts of the language, but
    these are really not complex at all. Things such as simply defined constants,
    interfaces, packages, garbage collection, and easy to implement concurrency are
    all complex under the hood, but transparent to the end user. Having these constructs
    available  has helped to make Go thrive as a language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言有许多复杂的底层内部部分，但这些实际上并不复杂。诸如简单定义的常量、接口、包、垃圾回收和易于实现的并发等都是复杂的内部部分，但对最终用户来说是透明的。拥有这些构造有助于使Go语言蓬勃发展。
- en: Let's see what packaging in Go means in the next section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节看看Go语言中的打包意味着什么。
- en: Exploring packaging in Go
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Go中的打包
- en: Packaging is a fundamental part of the Go language. Every single Go program
    is required to have a package definition on the first line of the program. This
    helps readability, maintainability, referencing, and organization.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 打包是Go语言的一个基本部分。每个Go程序都需要在程序的第一行定义一个包。这有助于可读性、可维护性、引用和组织。
- en: The `main` package in a Go program uses the main declaration. This main declaration
    calls the `main` function of the program. After this occurs, we have other imports
    within the `main` function that can be used to import other packages within the
    program. We should try and keep the main package small in order to modularize
    all dependencies within our programs. We will talk about package naming next.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序中的`main`包使用主声明。这个主声明调用程序的`main`函数。这之后，我们在`main`函数中有其他导入，可以用来导入程序中的其他包。我们应该尽量保持主包的小型化，以便将我们程序中的所有依赖项模块化。接下来我们将讨论包命名。
- en: Package naming
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包命名
- en: 'While naming packages, developers should adhere to the following rules:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名包时，开发人员应遵循以下规则：
- en: Packages shouldn't have underscores, hyphens, or mixedCaps
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包不应该有下划线、连字符或混合大小写
- en: Packages shouldn't be named with generic naming schemes, such as common, util,
    base, or helper
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包不应该以通用的命名方案命名，比如common、util、base或helper
- en: Package naming should be related to the function that the package is performing
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包命名应该与包执行的功能相关
- en: Packages should retain a decent-sized scope; all the elements in a package should
    have similar goals and objectives
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包应该保持一个相当大的范围；包中的所有元素应该具有相似的目标和目标
- en: Utilizing internal packages can help while you're vetting new packages before
    they are aligned with your public API
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新包与公共API对齐之前，利用内部包可以帮助您审查新包
- en: Packaging layout
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装布局
- en: 'When we discuss the layout of a Go program, we have a couple of different processes
    that we should follow. A common convention is to keep your main programs in a
    folder named `cmd`. Your other packages that you build to be executed from the `main`
    function should live in a `pkg` directory. This separation helps to encourage
    the reuse of packages. In the following example, if we want to reuse the notification
    package for both the CLI and web main programs, we have the ability to do that
    easily with one import. The following a screenshot shows this separation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论Go程序的布局时，我们应该遵循一些不同的流程。一个常见的约定是将主程序放在名为`cmd`的文件夹中。您构建的其他要从`main`函数执行的包应该放在`pkg`目录中。这种分离有助于鼓励包的重用。在下面的例子中，如果我们想要在CLI和Web主程序中都重用通知包，我们可以轻松地通过一个导入来实现。以下是一个屏幕截图显示了这种分离：
- en: '![](img/2cc26180-33c9-43f4-9e5b-cfd15626cdc3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cc26180-33c9-43f4-9e5b-cfd15626cdc3.png)'
- en: 'An anti-pattern for Go is to have a one-to-one file for package mapping. We
    should be writing Go with the idea of driving common use cases together within
    a specific directory structure. For example, we could create a single directory
    per file and test it as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Go的一个反模式是为包映射创建一对一的文件。我们应该以在特定目录结构内驱动常见用例的方式来编写Go。例如，我们可以创建一个文件的单个目录并进行如下测试：
- en: '![](img/7259ab0e-d9fa-475c-b009-2f29fc0ca1d2.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7259ab0e-d9fa-475c-b009-2f29fc0ca1d2.png)'
- en: 'Instead, however, we should create our packages as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该按照以下方式创建我们的包：
- en: '![](img/c59b9d7d-6f00-4d7a-bcd5-cf018c48e5b5.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c59b9d7d-6f00-4d7a-bcd5-cf018c48e5b5.png)'
- en: All of these different notification strategies share a common practice. We should
    attempt to keep similar functionality coupled in the same package. This will help
    others to understand any context in which the notifications package has similar
    functionality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些不同的通知策略都共享一个共同的做法。我们应该尝试将类似的功能耦合在同一个包中。这将帮助其他人理解通知包具有类似功能的任何上下文。
- en: Internal packaging
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部包装
- en: Many Go programs use the concept of an internal package in order to signify
    an API that is not ready for external consumption. The idea of internal packages
    was first introduced in Go 1.4, to add boundaries around components within your
    program. These internal packages cannot be imported from outside the subtree in
    which they are stored. This is useful if you want to maintain your internal packages
    and not expose them to the rest of the program. Once you've vetted internal packages
    in the manner you deem fit, you can change the folder name and expose the previously
    internal package.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Go程序使用内部包的概念来表示尚未准备好供外部使用的API。内部包的概念首次在Go 1.4中引入，以在程序内部添加组件边界。这些内部包不能从存储它们的子树之外导入。如果您想要维护内部包并不将它们暴露给程序的其余部分，这是很有用的。一旦您以您认为合适的方式审查了内部包，您可以更改文件夹名称并公开先前的内部包。
- en: 'Let''s see an example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '![](img/de065a1d-6412-4b9d-95de-bb151434405f.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de065a1d-6412-4b9d-95de-bb151434405f.png)'
- en: In the preceding example, we can see that we have an internal directory. This
    is only accessible from within this project. The `pkg` and `cmd` directories,
    however, will be accessible from other projects. This is important as we continue
    to develop new products and features that should not yet be available for import
    in other projects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到我们有一个内部目录。这只能从这个项目内部访问。然而，`pkg`和`cmd`目录将可以从其他项目访问。这对于我们继续开发新产品和功能是很重要的，这些产品和功能在其他项目中还不应该可以导入。
- en: Vendor directory
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 供应商目录
- en: 'The idea of a vendor directory originated with the release of Go 1.5\. The
    `vendor` folder is a place to store a compiled grouping of external and internal
    sources into a directory within the project. This means that the code composer
    no longer has to copy in dependent packages to the source tree. The `vendor` folder
    is searched for when the `GOPATH` looks for dependencies. This is good for a number
    of reasons:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商目录的概念起源于Go 1.5的发布。 `vendor`文件夹是一个存储外部和内部源代码的编译组合的地方，存放在项目的一个目录中。这意味着代码组合器不再需要将依赖包复制到源代码树中。当`GOPATH`寻找依赖项时，将在`vendor`文件夹中进行搜索。这有很多好处：
- en: We can keep local copies of external dependencies on our projects. This can
    be helpful if we want to execute our programs on networks that have limited or
    no external network connectivity.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在我们的项目中保留外部依赖项的本地副本。如果我们想要在具有有限或没有外部网络连接的网络上执行我们的程序，这可能会有所帮助。
- en: This makes compilation of our Go programs faster. Storing all of these vendored
    dependencies locally means that we don't need to pull down our dependencies at
    build time.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样可以加快我们Go程序的编译速度。将所有这些依赖项存储在本地意味着我们不需要在构建时拉取依赖项。
- en: If you'd like to use third-party code but have tweaked it for your particular
    use case, you can vendor that code and change it for internal release.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想使用第三方代码，但已经为您的特定用例进行了调整，您可以将该代码存储并更改为内部发布。
- en: Go modules
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go模块
- en: Go modules were introduced in Go 1.11\. They afford the ability to keep track
    of versioned dependencies within a Go code base. They are a collection of Go packages
    that are stored as a cohesive unit in a `go.mod` file within a project directory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Go模块是在Go 1.11中引入的。它们可以跟踪Go代码库中的版本化依赖项。它们是一组作为一个统一单元存储在项目目录中的`go.mod`文件的Go包。
- en: 'We will perform the following steps to initialize a new module:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行以下步骤来初始化一个新模块：
- en: 'We first execute `go mod init repository`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先执行`go mod init repository`：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After you've initialized this new module, you can build your Go package and
    execute it as you normally would. You'll have any imported modules from within
    your project saved in a `go.mod` file within your project's directory.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化新模块后，您可以构建Go包并像往常一样执行它。您将在项目目录中的`go.mod`文件中保存来自项目内导入的模块。
- en: 'As an example, if we want to be able to create a simple web server using the
    Gin framework [[https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin)],
    we would create a directory for this in our project structure as follows: `/home/bob/git/HighPerformanceWithGo/6-composing-readable-go-code/goModulesExample`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要使用Gin框架[[https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin)]创建一个简单的Web服务器，我们可以在项目结构中创建一个目录，如下所示：`/home/bob/git/HighPerformanceWithGo/6-composing-readable-go-code/goModulesExample`。
- en: 'We next create a simple web server that returns a response with  `bar` to a
    `/foo` request:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来创建一个简单的Web服务器，以对`/foo`请求返回`bar`：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After this, we can create a new Go module in our newly created directory:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以在新创建的目录中创建一个新的Go模块：
- en: '![](img/0a10594a-9569-461b-aca2-1c5d84a65580.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a10594a-9569-461b-aca2-1c5d84a65580.png)'
- en: 'Next, we can execute our Go program; the proper dependencies will be pulled
    in as necessary:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以执行我们的Go程序；必要时将引入适当的依赖项：
- en: '![](img/840e0cfe-d102-4b92-b4b9-95bb3ca725d7.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/840e0cfe-d102-4b92-b4b9-95bb3ca725d7.png)'
- en: 'We can now see that we have our dependencies for our simple web server stored
    in the `go.sum` file within our directory (I''ve used the `head` command to truncate
    the list to the top 10 entries):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到我们的简单Web服务器的依赖项存储在我们目录中的`go.sum`文件中（我使用了`head`命令将列表截断为前10个条目）：
- en: '![](img/c420a06b-62d2-4fed-a04e-91e34413a63e.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c420a06b-62d2-4fed-a04e-91e34413a63e.png)'
- en: Go modules help keep vendored items within a Go repository clean and consistent.
    We can also use a vendored repository if we want to keep all of our dependencies
    local to our project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Go模块有助于保持Go存储库中的依赖项清洁和一致。如果需要，我们还可以使用存储库来保持所有依赖项与项目本地相关。
- en: 'Opinions on vendoring dependencies within your repository often vary greatly.
    Some like to use a vendored repository because it decreases build time and limits
    the risk of not being able to pull packages from an external repository. Others
    feel that vendoring can be a hindrance to package updates and security patches.
    Whether you choose to use a vendored directory in your program is up to you, but
    the fact that Go modules include this functionality in the language is convenient.
    The following output illustrates this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在存储库中存储依赖项的意见往往差异很大。一些人喜欢使用存储库，因为它可以减少构建时间并限制无法从外部存储库中拉取包的风险。其他人认为存储可能会妨碍包更新和安全补丁。您是否选择在程序中使用存储目录取决于您，但Go模块包含这种功能是很方便的。以下输出说明了这一点：
- en: '![](img/23e64c8a-290f-46fb-8f24-aa4aaaa29eff.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23e64c8a-290f-46fb-8f24-aa4aaaa29eff.png)'
- en: Being able to vendor directories with the built-in compilation tools makes it
    easy to set up and configure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用内置编译工具来存储目录使得设置和配置变得容易。
- en: In the next section, we will discuss naming things in Go.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论在Go中命名事物。
- en: Understanding naming in Go
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Go中的命名
- en: 'There are a lot of consistent behaviors that Go programmers like to retain
    in order to keep readable, maintainable code. Go naming schemes tend to be consistent,
    accurate, and short. We want to create names with the following idioms in mind:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多一致的行为，Go程序员喜欢保留以保持可读性和可维护性的代码。Go命名方案往往是一致的、准确的和简短的。我们希望在创建名称时记住以下习语：
- en: 'Local variables for iterators should be short and simple:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器的局部变量应该简短而简单：
- en: '`i` for an iterator; `i` and `j` if you have a two-dimensional iterator'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 代表迭代器；如果有二维迭代器，则使用`i`和`j`'
- en: '`r` for a reader'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r` 代表读取器'
- en: '`w` for a writer'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w` 代表写入器'
- en: '`ch` for channels'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch` 代表通道'
- en: 'Global variable names should be short and descriptive:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量名称应该简短且描述性强：
- en: '`RateLimit`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RateLimit`'
- en: '`Log`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log`'
- en: '`Pool`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pool`'
- en: 'Acronyms should follow the convention of using all capitals:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首字母缩略语应遵循使用全大写的约定：
- en: '`FooJSON`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FooJSON`'
- en: '`FooHTTP`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FooHTTP`'
- en: 'Avoid stuttering with the package name:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用模块名称时的口吃：
- en: '`log.Error()` instead of `log.LogError()`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log.Error()` 而不是 `log.LogError()`'
- en: 'Interfaces with one method should follow the method name plus the `-er` suffix:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有一个方法的接口应遵循方法名称加上`-er`后缀：
- en: '`Stringer`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stringer`'
- en: '`Reader`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reader`'
- en: '`Writer`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Writer`'
- en: '`Logger`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Logger`'
- en: 'Names in Go should follow a Pascal or mixedCaps case method:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中的名称应遵循Pascal或mixedCaps命名法：
- en: '`var ThingOne`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var ThingOne`'
- en: '`var thingTwo`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var thingTwo`'
- en: It's important to remember that, if a name has an initial capital letter, it
    is exported and can be used in other functions. Remember this whilst coming up
    with your own naming schemes for things.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，如果名称的首字母大写，它是公开的，并且可以在其他函数中使用。在为事物想出自己的命名方案时，请记住这一点。
- en: Following some of these naming conventions can you to have readable, consumable,
    reusable code. Another good practice is to use consistent naming styles. If you're
    instantiating the same type of parameter, make sure that it follows a consistent
    naming convention. This makes it easier for new consumers to follow along with
    the code that you have written.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些命名约定可以使您拥有可读性强、易消化、可重用的代码。另一个良好的实践是使用一致的命名风格。如果您正在实例化相同类型的参数，请确保它遵循一致的命名约定。这样可以使新的使用者更容易跟随您编写的代码。
- en: In the next section, we will discuss formatting Go code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Go代码的格式化。
- en: Understanding formatting in Go
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Go中的格式化
- en: As mentioned in [Chapter 1](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml), *Introduction
    to Performance in Go*, `gofmt` is an opinionated formatter for Go code. It indents
    and aligns your code the way the language maintainers intended for it to be read.
    Many of the most popular code editors today can execute `gofmt` when a file is
    saved. Doing this, as well as having your continuous integration software verification,
    saves you having to focus on the formatting of the code that you're writing since
    the language will be prescriptive in output. Using this tool will make Go code
    easier to read, write, and maintain with multiple contributors. It also removes
    quite a bit of controversy within the language, since spaces, tabs, and braces
    are positioned automatically.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第1章](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml)中所述，*Go性能简介*，`gofmt`是Go代码的一种主观格式化工具。它会缩进和对齐您的代码，以便按照语言维护者的意图进行阅读。今天许多最受欢迎的代码编辑器在保存文件时都可以执行`gofmt`。这样做，以及拥有您的持续集成软件验证，可以使您无需关注您正在编写的代码的格式，因为语言将会在输出中规定格式。使用这个工具将使Go代码更容易阅读、编写和维护，同时有多个贡献者。它还消除了语言内的许多争议，因为空格、制表符和大括号会自动定位。
- en: 'We can also add a pre-commit hook to our Git repository (in `.git/hooks/pre-commit`)
    in order to corroborate the fact that all of the code that is being committed
    to a repository is formatted as expected. The following code block illustrates
    this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向我们的Git存储库（在`.git/hooks/pre-commit`中）添加一个预提交挂钩，以确保提交到存储库的所有代码都按预期格式化。以下代码块说明了这一点：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After we add this pre-commit hook, we can confirm that things are working as
    expected by adding some erroneous spacing to a file within our repository. After
    we do so and `git commit` our code, we will see a warning message as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了这个预提交挂钩之后，我们可以通过向存储库中的文件添加一些错误的空格来确认一切是否按预期工作。这样做后，当我们`git commit`我们的代码时，我们将看到以下警告消息：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`gofmt` also has a lesser known but vastly helpful simplify method, which will
    perform source transformations where possible. This will take some of the composite,
    slice and range composite literals, and shorten them. The simplify formatting
    command will take the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`gofmt`还有一个鲜为人知但非常有用的简化方法，它将在可能的情况下执行源代码转换。这将对一些复合、切片和范围复合文字进行缩短。简化格式化命令将采用以下代码：'
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will simplify to the following code: `gofmt -s gofmtSimplify.go`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简化为以下代码：`gofmt -s gofmtSimplify.go`。
- en: 'The output of this `gofmt` code snippet is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`gofmt`代码片段的输出如下：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the variable `b` in the preceding code snippet has a simple definition
    and that the empty variable in the range definition has been removed by the `gofmt`
    tool. This tool can help you to have more cleanly defined code in your repository.
    It can also be used as a mechanism for writing code in such way that the writer
    can think through the problem, but the resulting code from `gofmt` can be stored
    in the shared repository in a tightly knit fashion.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面代码片段中的变量`b`有一个简单的定义，并且范围定义中的空变量已被`gofmt`工具移除。这个工具可以帮助您在存储库中定义更清晰的代码。它还可以用作一种编写代码的机制，使编写者可以思考问题，但`gofmt`生成的结果代码可以以紧密的方式存储在共享存储库中。
- en: In the next section, we will discuss interfaces in Go.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Go中的接口。
- en: Briefing on interfaces in Go
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go接口简介
- en: Go's interfacing system is different from the interfacing systems in other languages.
    They are named collections of methods. Interfaces are important in composing readable
    Go code because they make the code scalable and flexible. Interfaces also give
    us the ability to have polymorphism (providing a single interface to items with
    different types) in Go. Another positive aspect of interfaces is that they are
    implicitly implemented—the compiler checks that a specific type implements a specific
    interface.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Go的接口系统与其他语言的接口系统不同。它们是方法的命名集合。接口在组合可读的Go代码方面非常重要，因为它们使代码具有可伸缩性和灵活性。接口还赋予我们在Go中具有多态性（为具有不同类型的项目提供单一接口）的能力。接口的另一个积极方面是它们是隐式实现的——编译器检查特定类型是否实现了特定接口。
- en: 'We can define an interface as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个接口如下：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we want to implement an interface, all we need to do is implement the methods
    that are referenced in the interface. The compiler validates your interface's
    methods so that you don't have to perform this action.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要实现一个接口，我们只需要实现接口中引用的方法。编译器会验证您的接口方法，因此您无需执行此操作。
- en: 'We can also define an empty interface, which is an interface that has zero
    methods, represented by `interface{}`. Empty interfaces are valuable and practical
    in Go, as we can pass arbitrary values to them, as shown in the following code
    block:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义一个空接口，即一个没有方法的接口，表示为`interface{}`。在Go中，空接口是有价值和实用的，因为我们可以向它们传递任意值，如下面的代码块所示：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we execute our empty interface example, we can see that the type and value
    of the x interface change as we change the definition of the (initially) empty
    interface:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行我们的空接口示例时，我们可以看到x接口的类型和值随着我们改变（最初）空接口的定义而改变：
- en: '![](img/c77209dc-7c5a-47e0-ad53-ab7a6d084287.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c77209dc-7c5a-47e0-ad53-ab7a6d084287.png)'
- en: Empty, mutable interfaces are convenient because they give us the flexibility
    to manipulate our data in a way that makes sense to the code composer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 空的、可变的接口很方便，因为它们给了我们灵活性，以一种对代码编写者有意义的方式来操作我们的数据。
- en: In the next section, we will discuss comprehending methods in Go.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Go中的方法理解。
- en: Comprehending methods in Go
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Go中的方法
- en: Methods in Go are functions that have a special type, called a `receiver`, that
    sits between the `function` keyword and the method name associated with the keyword.
    Go doesn't have classes in the same manner that other programming languages do
    . Structs are often used in conjunction with methods in order to bundle data and
    its corresponding methods in a similar fashion to how classes are constructed
    in other languages. As we instantiate a new method, we can add struct values in
    order to enrich the function call.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的方法是具有特殊类型的函数，称为`接收器`，它位于`function`关键字和与关键字相关联的方法名称之间。Go没有类与其他编程语言相同的方式。结构体通常与方法一起使用，以便以与其他语言中构造类似的方式捆绑数据及其相应的方法。当我们实例化一个新方法时，我们可以添加结构值以丰富函数调用。
- en: 'We can instantiate a structure and a method as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实例化一个结构和一个方法如下：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After this has been done, we can then use this struct and method to display
    information about a user as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以使用此结构和方法来显示有关用户的信息，如下所示：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will return the result from `userExample.displayEmail()`, which prints
    the pertinent part of the structs as part of the method call as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`userExample.displayEmail()`的结果，它会在方法调用中打印结构的相关部分，如下所示：
- en: '![](img/cc7465c3-67c7-48fa-9461-d20edab04dad.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc7465c3-67c7-48fa-9461-d20edab04dad.png)'
- en: As we have larger structs of data, we have the ability to reference the data
    that is stored within these structs easily and effectively. If we decided that
    we wanted to write a method to find the end user's phone number, it would be simple
    to use our existing data type and write a method similar to the `displayEmail`
    method in order to return the end user's phone number.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们拥有更大的数据结构，我们有能力轻松有效地引用存储在这些结构中的数据。如果我们决定要编写一个方法来查找最终用户的电话号码，那么使用我们现有的数据类型并编写类似于`displayEmail`方法的方法来返回最终用户的电话号码将是很简单的。
- en: The methods we have looked at so far only have value receivers. Methods can
    also have pointer receivers. Pointer receivers are helpful when you would like
    to update the data in place and have the results available to the caller function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的方法只有值接收器。方法也可以有指针接收器。指针接收器在您希望在原地更新数据并使结果可用于调用函数时很有帮助。
- en: Consider our previous example with a couple of modifications. We are going to
    have two methods that will allow us to update our user's email address and phone
    number. The email address update is going to use a value receiver, whereas the
    phone update is going to use a pointer receiver.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们之前的例子，做一些修改。我们将有两种方法，允许我们更新用户的电子邮件地址和电话号码。电子邮件地址更新将使用值接收器，而电话更新将使用指针接收器。
- en: 'We create these functions in the following code block in order to be able to
    update the end user''s information easily:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下代码块中创建这些函数，以便能够轻松更新最终用户的信息：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We next create our example end user in `main`, as shown in the following code
    block:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在`main`中创建我们的示例最终用户，如下代码块所示：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then update the email and phone number of our end user in the following
    code block:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在以下代码块中更新我们最终用户的电子邮件和电话号码：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In our resulting output, we can see that the user email has not been updated
    from the perspective of the receiver, but that the user''s phone number has:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的输出结果中，我们可以看到从接收器的角度来看，用户的电子邮件地址没有被更新，但用户的电话号码已经被更新了：
- en: '![](img/a399ec7d-6ede-4114-b0a5-79f20cc686d6.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a399ec7d-6ede-4114-b0a5-79f20cc686d6.png)'
- en: This is important to remember when attempting to mutate state from within method
    calls. Methods are very helpful in manipulating data in Go programs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试从方法调用中改变状态时，记住这一点是很重要的。方法在操作Go程序中的数据方面非常有帮助。
- en: It's now time to see what inheritance in Go is all about.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看Go中的继承是怎么回事了。
- en: Comprehending inheritance in Go
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Go中的继承
- en: Go does not have inheritance. Composition is used in order to embed items (mostly
    structs) in one another. This is convenient when you have a baseline struct that
    is used for many different functions, with other structs that build on top of
    the initial struct.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Go没有继承。组合用于将项目（主要是结构）嵌入在一起。当您有一个用于许多不同功能的基线结构时，这是方便的，其他结构在初始结构的基础上构建。
- en: We can describe some of the items in my kitchen to show how inheritance works.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以描述一些我厨房里的物品，以展示继承是如何工作的。
- en: 'We can initialize our program as shown in the following code block. In this
    block, we create two structs:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以初始化我们的程序，如下代码块所示。在这个代码块中，我们创建了两个结构：
- en: '`Utensils`: For the utensils I have in my drawers in my kitchen'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`器具`：我厨房抽屉里的器具'
- en: '`Appliances`: For the appliances I have in my kitchen'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`电器`：我厨房里的电器'
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'I can next use Go''s nested structuring to create a `Kitchen` struct that contains
    all of the utensils and appliances as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我可以使用Go的嵌套结构来创建一个包含所有器具和电器的`厨房`结构，如下所示：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I can then fill my kitchen with the utensils and appliances that I have:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以用我拥有的器具和电器填满我的厨房：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once all of these things are in, we can see the resulting output where my kitchen
    items (the `Utensils` and `Appliances`) are organized in my `Kitchen` struct.
    My `Kitchen` struct is then easily referenced later in other methods.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些东西都在之后，我们可以看到结果输出，我的厨房物品（`器具`和`电器`）被组织在我的`厨房`结构中。我的`厨房`结构稍后可以轻松地在其他方法中引用。
- en: Having nested structs can be very practical for future extension. If I decided
    that I'd like to add other elements in my house to this structure, I could make
    a `House` struct and nest my `Kitchen` struct within the `House` struct. I could
    also compose structs for other rooms in my house and add them to the house struct
    as well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有嵌套结构对于未来的扩展非常实用。如果我决定想要向这个结构中添加其他元素，我可以创建一个`House`结构，并将我的`Kitchen`结构嵌套在`House`结构中。我还可以为房子中的其他房间组合结构，并将它们添加到房子结构中。
- en: In the next section, we will explore reflection in Go.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨Go中的反射。
- en: Exploring reflection in Go
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Go中的反射
- en: Reflection in Go is a form of metaprogramming. Using reflection in Go lets the
    program understand its own structure. There are times when you want to use a variable
    at runtime that doesn't exist when the program was composed. We use reflection
    to check the key and value pair that is stored within an interface variable. Reflection
    is not often clear, so be wary of using it—it should be used in special cases
    when necessary. It only has runtime checks (not compile checks), so we need to
    use reflection with common sense.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的反射是一种元编程形式。在Go中使用反射让程序理解自己的结构。有时候，当程序被组合时，我们想要在运行时使用一个变量，而这个变量在程序被组合时并不存在。我们使用反射来检查存储在接口变量中的键值对。反射通常不太清晰，因此在使用时要谨慎——它应该在必要时才使用。它只有运行时检查（而不是编译时检查），因此我们需要理性地使用反射。
- en: 'It''s important to remember that Go''s variables are statically typed. There
    are many different variable types that we can use in Go—`rune`, `int`, `string`,
    and so on. We can declare a specific type as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，Go的变量是静态类型的。我们可以在Go中使用许多不同的变量类型——`rune`、`int`、`string`等。我们可以声明特定类型如下：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both variables, `x` and `y`, will be int typed variables.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`x`和`y`都将是int类型的变量。
- en: 'There are three important pieces of reflection that are used in order to find
    out information:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个重要的反射部分用于获取信息：
- en: Types
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Kinds
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 种类
- en: Values
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值
- en: These three different pieces all work together to deduce the information you
    might need to know in relation to an interface. Let's take a look at each one
    individually and see how they mesh together.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个不同的部分共同工作，以推断与接口相关的信息。让我们分别看看每个部分，看看它们如何配合。
- en: Types
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'Being able to tell the type of a variable is important in Go. In our example,
    we can validate the fact that a string type is, in fact, a string, as shown in
    the following code block:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 能够确定变量的类型在Go中是很重要的。在我们的例子中，我们可以验证字符串类型是否确实是字符串，如下面的代码块所示：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output from our program will show us that the reflection type will accurately
    derive the `foo string` type:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的输出将向我们展示反射类型将准确推导出`foo string`类型：
- en: '![](img/f130eaff-5d87-4cb7-87d2-445a2c22918b.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f130eaff-5d87-4cb7-87d2-445a2c22918b.png)'
- en: 'Although this example is simple, it''s important to understand the underlying
    principle: if, instead of validating the string, we are looking at an incoming
    network call or the return from an external library call, or trying to build a
    program that can handle different types, the reflection library''s `TypeOf` definition
    can help us to identify these types correctly.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子很简单，但重要的是要理解其中的基本原则：如果我们不是验证字符串，而是查看传入的网络调用或外部库调用的返回，或者尝试构建一个可以处理不同类型的程序，反射库的`TypeOf`定义可以帮助我们正确地识别这些类型。
- en: Kinds
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 种类
- en: 'A kind is used as a placeholder to define the kind of type that a specific
    type represents. It is used to denote what the type is made of. This is very useful
    in determining what sort of structure has been defined. Let''s look at an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 种类被用作占位符，用于定义特定类型表示的类型。它用于表示类型由什么组成。这在确定定义了什么样的结构时非常有用。让我们看一个例子：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In our example, we can see that we have created a slice of strings – `foo`,
    `bar`, and `baz`. From there, we can use reflection to find the type of `i`, and
    we can use the `Kind()` function to determine what the type is made of—in our
    case, a slice as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们可以看到我们创建了一个字符串切片——`foo`、`bar`和`baz`。然后，我们可以使用反射来找到`i`的类型，并且我们可以使用`Kind()`函数来确定类型是由什么组成的——在我们的例子中，是一个切片，如下所示：
- en: '![](img/97e57f40-2a7e-409a-b097-8cc345e9c95c.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97e57f40-2a7e-409a-b097-8cc345e9c95c.png)'
- en: This can be useful if we want to deduce the type of a particular interface.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要推断特定接口的类型，这可能会很有用。
- en: Values
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值
- en: 'Values in reflection help to read, set, and store results on particular variables.
    In the following example, we can see that we set an example variable, `foo`, and,
    using the reflection package, we can deduce the value of our example variable
    in the resulting print statement as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 反射中的值有助于读取、设置和存储特定变量的结果。在下面的例子中，我们可以看到我们设置了一个示例变量`foo`，并且使用反射包，我们可以推断出我们示例变量的值如下所示：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In our output, we can see that the value of the example variable, `foo`, gets
    returned:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的输出中，我们可以看到示例变量`foo`的值被返回：
- en: '![](img/a3cfa0b8-90ae-4ce5-9e59-ceb21c646150.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3cfa0b8-90ae-4ce5-9e59-ceb21c646150.png)'
- en: These three different functions within the reflect system help us to deduce
    types that we can use within our code base.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 反射系统中的这三个不同的函数帮助我们推断我们可以在代码库中使用的类型。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use some core tenets of the language to write
    readable Go code. We learned how simplicity and readability are important, and
    how packaging, naming, and formatting are vital to writing readable Go. Also,
    we learned how interfaces, methods, inheritance, and reflection can all be used
    to write code that others can understand. Being able to use these core Go concepts
    effectively will help you produce more efficient code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用语言的一些核心原则来编写可读的Go代码。我们学习了简单性和可读性的重要性，以及打包、命名和格式化对于编写可读的Go代码是至关重要的。此外，我们还学习了接口、方法、继承和反射如何都可以用来编写其他人能够理解的代码。能够有效地使用这些核心Go概念将帮助您产生更高效的代码。
- en: In the next chapter, we are going to learn about memory management in Go and
    how to optimize for the memory resources that we have at hand.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Go语言中的内存管理，以及如何针对手头的内存资源进行优化。
