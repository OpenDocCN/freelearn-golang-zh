["```go\n^// Code generated .* DO NOT EDIT\\.$\n```", "```go\nsyntax = \"proto3\";\npackage userinfo;\n  service UserInfo {\n  rpc PrintUserInfo (UserInfoRequest) returns (UserInfoResponse) {}\n\n} \n\nmessage UserInfoRequest {\n  string user = 1;\n  string email = 2;\n} \n\nmessage UserInfoResponse {\n  string response = 1; \n} \n```", "```go\npackage userinfo\n//go:generate protoc -I ../userinfo --go_out=plugins=grpc:../userinfo ../userinfo/userinfo.proto\n```", "```go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"net\"      \n    pb \"github.com/HighPerformanceWithGo/7-metaprogramming-in-go/grpcExample/userinfo/userinfo\"\n    \"google.golang.org/grpc\"\n)      \ntype userInfoServer struct{}       \nfunc (s *userInfoServer) PrintUserInfo(ctx context.Context, in *pb.UserInfoRequest) (*pb.UserInfoResponse, error) {\n    log.Printf(\"%s %s\", in.User, in.Email)\n    return &pb.UserInfoResponse{Response: \"User Info: User Name: \" + in.User + \" User Email: \" + in.Email}, nil \n} \n```", "```go\nfunc main() {\n  l, err := net.Listen(\"tcp\", \":50051\")\n  if err != nil {\n    log.Fatalf(\"Failed to listen %v\", err)\n  }\n  s := grpc.NewServer()\n  pb.RegisterUserInfoServer(s, &userInfoServer{})\n  if err := s.Serve(l); err != nil {\n    log.Fatalf(\"Couldn't create Server: %v\", err)\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"context\"\n  \"log\"\n  \"time\"\n\n  pb \"github.com/HighPerformanceWithGo/7-metaprogramming-in-go/grpcExample/userinfo/userinfo\"\n  \"google.golang.org/grpc\"\n)\n\nconst (\n  defaultGrpcAddress = \"localhost:50051\"\n  defaultUser = \"Gopher\"\n  defaultEmail = \"Gopher@example.com\"\n)\n\n```", "```go\nfunc main() {\n  conn, err := grpc.Dial(defaultGrpcAddress, grpc.WithInsecure())\n  if err != nil {\n    log.Fatalf(\"did not connect: %v\", err)\n  }\n  defer conn.Close()\n  c := pb.NewUserInfoClient(conn)\n\n  user := defaultUser\n  email := defaultEmail\n  ctx, cancel := context.WithTimeout(context.Background(), time.Second)\n  defer cancel()\n  r, err := c.PrintUserInfo(ctx, &pb.UserInfoRequest{User: user, Email: email})\n  if err != nil {\n    log.Fatalf(\"could not greet: %v\", err)\n  }\n  log.Printf(\"%s\", r.Response)\n}\n```", "```go\ngo build -ldflags '-X importpath.name=value'\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n)\n\nvar SerialNumber = \"unlicensed\"\n\nfunc main() {\n  if SerialNumber == \"ABC123\" {\n    fmt.Println(\"Valid Serial Number!\")\n  } else {\n    fmt.Println(\"Invalid Serial Number\")\n  }\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    \"github.com/HighPerformanceWithGo/7-metaprogramming-in-go/clitooling/cmd\"\n) \n\nfunc main() {\n\n    if err := cmd.DateCommand.Execute(); err != nil { \n        fmt.Println(err)\n        os.Exit(1)\n    } \n} \n```", "```go\npackage cmd \n\nimport (\n    \"fmt\"\n    \"time\"\n\n    \"github.com/spf13/cobra\"\n    \"github.com/spf13/viper\"\n) \n\nvar verbose bool\n```", "```go\nvar DateCommand = &cobra.Command{\n    Use: \"date\",\n    Aliases: []string{\"time\"},\n    Short: \"Return the current date\",\n    Long: \"Returns the current date in a YYYY-MM-DD HH:MM:SS format\",\n    Run: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"Current Date :\\t\", time.Now().Format(\"2006.01.02 15:04:05\"))\n        if viper.GetBool(\"verbose\") {\n            fmt.Println(\"Author :\\t\", viper.GetString(\"author\"))\n            fmt.Println(\"Version :\\t\", viper.GetString(\"version\"))\n        } \n    }, \n} \n```", "```go\nvar LicenseCommand = &cobra.Command{\n    Use: \"license\",\n    Short: \"Print the License\",\n    Long: \"Print the License of this Command\",\n    Run: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"License: Apache-2.0\")\n    }, \n}         \n```", "```go\nfunc init() {\n    DateCommand.AddCommand(LicenseCommand) \n    viper.SetDefault(\"Author\", \"bob\")\n    viper.SetDefault(\"Version\", \"0.0.1\")\n    viper.SetDefault(\"license\", \"Apache-2.0\")\n    DateCommand.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"Date \n     Command Verbose\")\n    DateCommand.PersistentFlags().StringP(\"author\", \"a\", \"bob\", \"Date \n     Command Author\")\n\n    viper.BindPFlag(\"author\",    \n     DateCommand.PersistentFlags().Lookup(\"author\"))\n    viper.BindPFlag(\"verbose\", \n     DateCommand.PersistentFlags().Lookup(\"verbose\"))\n\n} \n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n  \"text/template\"\n)\n\nfunc main() {\n  type ToField struct {\n    Date string\n    Name string\n    Email string\n    InOffice bool\n  }\n```", "```go\n     const note = `\n{{/* we can trim whitespace with a {- or a -} respectively */}}\nDate: {{- .Date}}\nTo: {{- .Email | printf \"%s\"}}\n{{.Name}},\n{{if .InOffice }}\nThank you for your input yesterday at our meeting.  We are going to go ahead with what you've suggested.\n{{- else }}\nWe were able to get results in our meeting yesterday.  I've emailed them to you.  Enjoy the rest of your time Out of Office!\n{{- end}}\nThanks,\nBob\n`\n    var tofield = []ToField{\n        {\"07-19-2019\", \"Mx. Boss\", \"boss@example.com\", true},\n        {\"07-19-2019\", \"Mx. Coworker\", \"coworker@example.com\", false},\n    }\n```", "```go\n    t := template.Must(template.New(\"Email Body\").Parse(note))\n    for _, k := range tofield {\n        err := t.Execute(os.Stdout, k)\n        if err != nil {\n            fmt.Print(err)\n        }\n    }\n}\n```", "```go\npackage main\n\nimport (\n    \"html/template\"\n    \"net/http\"\n)\n\ntype UserFields struct {\n    Name string\n    URL string\n    Email string\n}\n```", "```go\nvar userResponse = ` \n<html>\n<head></head>\n<body>\n<h1>Hello {{.Name}}</h1>\n<p>You visited {{.URL}}</p>\n<p>Hope you're enjoying this book!</p> \n<p>We have your email recorded as {{.Email}}</p>\n</body>\n</html>\n`\n```", "```go\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {\n    requestedURL := string(r.URL.Path)\n    userfields := UserFields{\"Bob\", requestedURL, \"bob@example.com\"}\n    t := template.Must(template.New(\"HTML Body\").Parse(userResponse))\n    t.Execute(w, userfields)\n    log.Printf(\"User \" + userfields.Name + \" Visited : \" + requestedURL)\n}\n```", "```go\nfunc main() {\n s := http.Server{\n Addr: \"127.0.0.1:8080\",\n } \n http.HandleFunc(\"/\", rootHandler)\n s.ListenAndServe()\n}\n```", "```go\npackage main \n\nimport ( \n    \"fmt\" \n    \"os\" \n    \"text/template\" \n\n    \"github.com/Masterminds/sprig\" \n) \n\n```", "```go\nfunc main() {\n  inStr := map[string]interface{}{\"Name\": \" - bob smith\"}\n  transform := `{{.Name | trim | replace \"smith\" \"strecansky\" | trimPrefix \"-\" | title | repeat 10 | wrapWith 14 \"\\n\"}}`\n\n  functionMap := sprig.TxtFuncMap()\n  t := template.Must(template.New(\"Name Transformation\").Funcs(functionMap).Parse(transform))\n\n  err := t.Execute(os.Stdout, inStr)\n  if err != nil {\n    fmt.Printf(\"Couldn't create template: %s\", err)\n    return\n  }\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"text/template\"\n\n    \"github.com/Masterminds/sprig\"\n) \n\nfunc main() {\n```", "```go\n    tpl := `{{$v := \"Hands.On.High.Performance.In.Go\" | splitn \".\" 5}}{{$v._3}}`\n\n    functionMap := sprig.TxtFuncMap()\n    t := template.Must(template.New(\"String \n     Split\").Funcs(functionMap).Parse(tpl))\n\n    fmt.Print(\"String Split into Dict (word 3): \")\n    err := t.Execute(os.Stdout, tpl)\n    if err != nil {\n        fmt.Printf(\"Couldn't create template: %s\", err)\n        return\n    } \n```", "```go\n    alphaSort := `{{ list \"Foo\" \"Bar\" \"Baz\" | sortAlpha}}` \n    s := template.Must(template.New(\"sortAlpha\").\n      Funcs(functionMap).Parse(alphaSort))\n    fmt.Print(\"\\nAlpha Tuple: \")\n    alphaErr := s.Execute(os.Stdout, tpl)\n    if alphaErr != nil {\n        fmt.Printf(\"Couldn't create template: %s\", err)\n        return\n    } \n\n    fmt.Print(\"\\nString Slice Functions Completed\\n\")\n} \n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"text/template\"\n\n    \"github.com/Masterminds/sprig\"\n) \n\n```", "```go\nfunc main() {\n\n    emptyTemplate := map[string]interface{}{\"Name\": \"\"} \n    fullTemplate := map[string]interface{}{\"Name\": \"Bob\"}\n    tpl := `{{empty .Name}}`\n    functionMap := sprig.TxtFuncMap()\n    t := template.Must(template.New(\"Empty \n     String\").Funcs(functionMap).Parse(tpl))\n```", "```go\n    fmt.Print(\"empty template: \")\n    emptyErr := t.Execute(os.Stdout, emptyTemplate)\n    if emptyErr != nil {\n        fmt.Printf(\"Couldn't create template: %s\", emptyErr)\n        return\n    } \n\n    fmt.Print(\"\\nfull template: \")\n    fullErr := t.Execute(os.Stdout, fullTemplate)\n    if emptyErr != nil {\n        fmt.Printf(\"Couldn't create template: %s\", fullErr)\n        return\n    } \n    fmt.Print(\"\\nEmpty Check Completed\\n\") \n}\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"os\"\n    \"text/template\"\n    \"github.com/Masterminds/sprig\"\n)\nfunc main() {\n    jsonDict := map[string]interface{}{\"JSONExamples\": map[string]interface{}{\"foo\": \"bar\", \"bool\": false, \"integer\": 7}} \n    tpl := `{{.JSONExamples | toPrettyJson}}`\n    functionMap := sprig.TxtFuncMap()\n    t := template.Must(template.New(\"String Split\").Funcs(functionMap).Parse(tpl))\n    err := t.Execute(os.Stdout, jsonDict)\n    if err != nil {\n        fmt.Printf(\"Couldn't create template: %s\", err)\n        return\n    } \n} \n```"]