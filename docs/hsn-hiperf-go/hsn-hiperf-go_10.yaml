- en: Memory Management in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的内存管理
- en: 'Memory management is paramount to system performance. Being able to utilize
    a computer''s memory footprint to the fullest allows you to keep highly functioning
    programs in memory so that you don''t often have to take the large performance
    hit of swapping to disk. Being able to manage memory effectively is a core tenet
    of writing performant Go code. In this chapter, we will learn about the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理对系统性能至关重要。能够充分利用计算机的内存占用空间，使您能够将高度运行的程序保持在内存中，以便您不经常不得不承受交换到磁盘的巨大性能损失。能够有效地管理内存是编写高性能Go代码的核心原则。在本章中，我们将学习以下主题：
- en: Computer memory
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机内存
- en: How memory is allocated
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存如何分配
- en: How Go utilizes memory effectively
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go如何有效利用内存
- en: How objects are allocated in memory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中如何分配对象
- en: Strategies for computing devices with limited memory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限内存计算设备的策略
- en: Understanding how memory is utilized can help you learn to utilize memory effectively
    in your programs. Memory is one of the fastest places in the computer to store
    and manipulate data, so being able to manage it performantly will have a lasting
    impact on your code quality.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 了解内存如何被利用可以帮助您学会在程序中有效地利用内存。内存是计算机中存储和操作数据的最快速的地方之一，因此能够高效地管理它将对您的代码质量产生持久的影响。
- en: Understanding Modern Computer Memory - A Primer
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解现代计算机内存 - 入门
- en: 'Modern computers have **Random Access Memory** (**RAM**), which is utilized
    in machine code and data storage. RAM is used alongside the CPU and hard disks
    in order to store and retrieve information. Utilizing the CPU, RAM, and disks
    has performance trade-offs. In a modern computer at the time of writing, we have
    the following generic, rounded timings for some common operations in computers:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机具有**随机存取存储器**（**RAM**），用于机器代码和数据存储。 RAM与CPU和硬盘一起用于存储和检索信息。利用CPU、RAM和硬盘会有性能折衷。在撰写本文时的现代计算机中，我们对计算机中一些常见操作的一些通用、粗略的时间有以下表述：
- en: '| **Data Storage Type** | **Timing** |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **数据存储类型** | **时间** |'
- en: '| L1 (Processor Cache) Reference | 1 ns |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| L1（处理器缓存）引用 | 1 ns |'
- en: '| L2 (Processor Cache) Reference | 4 ns |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| L2（处理器缓存）引用 | 4 ns |'
- en: '| Main Memory Reference | 100 ns |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 主内存引用 | 100 ns |'
- en: '| SSD Random Read | 16 μs |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| SSD随机读取 | 16 μs |'
- en: '| 7200 RPM HDD Disk Seek | 2 ms |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 7200 RPM HDD磁盘搜索 | 2 ms |'
- en: As you'll notice from the table, the different storage types have wildly differing
    timings for different portions of a modern computer's architecture. New computers
    have KBs of L1 cache, MBs of L2 cache, GBs of main memory, and TBs of SSD/HDD.
    As we recognize that these different types of data storage vary significantly
    in terms of cost and performance, we need to learn how to use each of them effectively
    in order to write performant code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从表中所注意到的，不同的存储类型在现代计算机架构的不同部分具有截然不同的时间。新计算机具有KB的L1缓存，MB的L2缓存，GB的主内存和TB的SSD/HDD。由于我们认识到这些不同类型的数据存储在成本和性能方面存在显着差异，我们需要学会如何有效地使用它们，以便编写高性能的代码。
- en: Allocating memory
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配内存
- en: The main memory that a computer has is used for many things. The **Memory Management
    Unit** (**MMU**) is a piece of computer hardware that translates between physical
    and virtual memory addresses. When a CPU performs an instruction that uses a memory
    address, the MMU takes that logical memory address and translates it to a physical
    memory address. These are handled in groupings of physical memory addresses called
    pages. Pages are usually handled in 4 kB segments, using a table called a page
    table. The MMU also has other functionality, including using buffers, such as
    the **Translation Lookaside Buffer** (**TLB**), to hold recently accessed translations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的主内存用于许多事情。**内存管理单元**（**MMU**）是一种计算机硬件，用于在物理内存地址和虚拟内存地址之间进行转换。当CPU执行使用内存地址的指令时，MMU会获取逻辑内存地址并将其转换为物理内存地址。这些以物理内存地址的分组称为页面。页面通常以4
    kB段处理，使用称为页表的表。MMU还具有其他功能，包括使用缓冲区，如**转换旁路缓冲器**（**TLB**），用于保存最近访问的转换。
- en: 'Virtual memory is helpful because it does the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存有助于做到以下几点：
- en: Allows hardware device memory to be mapped to an address space
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许将硬件设备内存映射到地址空间
- en: Allows access permissions (rwx) for particular memory regions
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许特定内存区域的访问权限（rwx）
- en: Allows processes to have separate memory mappings
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许进程具有单独的内存映射
- en: Allows memory to be more easily moved
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许内存更容易移动
- en: Allows memory to be more easily swapped to disk
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许内存更容易地交换到磁盘
- en: Allows for shared memory, where physical ram is mapped to many processes simultaneously
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许共享内存，其中物理内存映射到多个进程
- en: When the virtual memory is allocated in a modern Linux OS, both the kernel and
    user space processes use virtual addresses. These virtual addresses are often
    split into two pieces—the upper portion of memory in a virtual address space is
    used for the kernel and kernel processes, and the lower portion of the memory
    is used for user space programs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当在现代Linux操作系统中分配虚拟内存时，内核和用户空间进程都使用虚拟地址。这些虚拟地址通常分为两部分 - 虚拟地址空间中的内存上部分用于内核和内核进程，内存下部分用于用户空间程序。
- en: The OS utilizes this memory. It moves processes between memory and disk to optimize
    the use of the resources that we have available in our computer. Computer languages
    use **virtual memory space** (**VMS**) in the underlying OS that they run on.
    Go is no exception to that rule. If you've programmed in C, you'll know the malloc
    and free idioms. In Go, we don't have a `malloc` function. Go is also a garbage-collected
    language, so we don't have to consider freeing memory allocation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统利用这些内存。它将进程在内存和磁盘之间移动，以优化我们计算机中可用资源的使用。计算机语言在其运行的底层操作系统中使用**虚拟内存空间**（**VMS**）。
    Go也不例外。如果您在C中编程，您会知道malloc和free的习语。在Go中，我们没有`malloc`函数。 Go也是一种垃圾收集语言，因此我们不必考虑释放内存分配。
- en: 'We have two different primary measures of memory within the user space: VSZ
    and RSS.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在用户空间内有两种不同的主要内存度量：VSZ和RSS。
- en: Introducing VSZ and RSS
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍VSZ和RSS
- en: '**VSZ**, the **virtual memory size**, references all of the memory that an
    individual process can access, including swapped memory. This is the memory size
    that is allocated during the initial execution of the program. VSZ is reported
    in KiB.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**VSZ**，**虚拟内存大小**，指的是一个单独进程可以访问的所有内存，包括交换内存。这是在程序初始执行时分配的内存大小。VSZ以KiB为单位报告。'
- en: '**RSS**, the **resident set size**, references how much memory a particular
    process has allocated in RAM, not including swapped memory. RSS includes shared
    library memory as long as that memory is currently available. RSS also includes
    stack and heap memory. RSS memory can be larger than the total memory available
    in the system based on the fact that these memory references are often shared.
    RSS is reported in kilobytes.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**RSS**，**驻留集大小**，指的是特定进程在RAM中分配了多少内存，不包括交换内存。RSS包括共享库内存，只要该内存目前可用。RSS还包括堆栈和堆内存。根据这些内存引用通常是共享的事实，RSS内存可能大于系统中可用的总内存。RSS以千字节为单位报告。'
- en: 'When we start up a simple HTTP server, we can see the VSZ and RSS that are
    allocated to our individual processes as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动一个简单的HTTP服务器时，我们可以看到分配给我们各个进程的VSZ和RSS如下：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can then take a look at the process ID that is spawned when the server is
    invoked, as can be seen in the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以看一下在调用服务器时生成的进程ID，如下所示：
- en: '![](img/81bdfc69-6487-4960-8314-6bbc1befb46f.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81bdfc69-6487-4960-8314-6bbc1befb46f.png)'
- en: Here, we can see the VSZ and RSS values for the `server.go` process that we've
    invoked.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们调用的`server.go`进程的VSZ和RSS值。
- en: 'If we want to reduce the Go binary build size, we can build our binary without
    libc libraries using a `build` flag as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要减小Go二进制文件的构建大小，我们可以使用`build`标志构建我们的二进制文件，而不包括libc库，如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we build our binary without including the libc libraries, we will have a
    much smaller memory footprint for our example server, as shown in the following
    output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们构建二进制文件时不包括libc库，我们的示例服务器的内存占用将会小得多，如下所示：
- en: '![](img/9c6365c0-e7b8-4ad6-b012-156776750b96.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c6365c0-e7b8-4ad6-b012-156776750b96.png)'
- en: As we can see, both our VSZ and RSS memory utilization were reduced considerably.
    In practice, memory is inexpensive and we can leave the libc libraries in our
    Golang binaries. Libc is utilized for a lot of standard library bits, including
    user and group resolution as well as bits of host resolution, and this is why
    it's dynamically linked at build time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的VSZ和RSS内存利用率都大大减少了。在实践中，内存是廉价的，我们可以将libc库留在我们的Golang二进制文件中。Libc用于许多标准库部分，包括用户和组解析以及主机解析的部分，这就是为什么它在构建时动态链接的原因。
- en: 'After we build our Go binaries, they are stored in a container format. Linux
    machines store this particular binary in a format known as **ELF** (short for
    **Executable** and **Linkable Format**). Go''s standard library has a methodology
    for reading ELF files. We can examine the `simpleServer` binary that we have generated
    previously:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Go二进制文件后，它们以容器格式存储。Linux机器将这个特定的二进制文件存储在一种称为**ELF**（可执行和可链接格式）的格式中。Go的标准库有一种方法来读取ELF文件。我们可以检查之前生成的`simpleServer`二进制文件：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The resulting output from our `simpleServer` example is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`simpleServer`示例的输出结果如下：
- en: '![](img/e368c05e-61a4-4f07-9d92-e6bfca7f7bc0.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e368c05e-61a4-4f07-9d92-e6bfca7f7bc0.png)'
- en: 'There are also other Linux tools that we can use to investigate these ELF binaries. `readelf`
    will also print ELF files in a more human readable format. For example, we can
    take a look at an ELF file as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他Linux工具可以用来调查这些ELF二进制文件。`readelf`也会以更易读的格式打印ELF文件。例如，我们可以这样查看一个ELF文件：
- en: '![](img/0fe039dc-bb91-46ab-b5a0-0f9faaa1b30a.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fe039dc-bb91-46ab-b5a0-0f9faaa1b30a.png)'
- en: 'ELF files have a specific format. This format is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ELF文件有特定的格式。该格式如下：
- en: '| **File Layout Portion** | **Description** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|**文件布局部分**|**描述**|'
- en: '| File header | **Class field**: Defines 32 and 64 bit addresses as 52 or 64
    bytes long, respectively.**Data**: Defines little or big endians.**Version**:
    Stores the ELF version (currently there is only one version, 01).**OS/ABI**: Defines
    the OS and the application binary interface.**Machine**: Tells you the machine
    type.**Type**: Indicates what type of file this is; common types are CORE, DYN
    (for shared objects), EXEC (for executable files), and REL (for relocatable files).
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|文件头|**类字段**：定义32位和64位地址分别为52或64字节长。**数据**：定义小端或大端。**版本**：存储ELF版本（目前只有一个版本，01）。**OS/ABI**：定义操作系统和应用程序二进制接口。**机器**：告诉你机器类型。**类型**：指示这是什么类型的文件；常见类型有CORE，DYN（用于共享对象），EXEC（用于可执行文件）和REL（用于可重定位文件）。|'
- en: '| Program headers or segments | Contain instructions on how to create a process
    or memory image for execution at runtime. The kernel then uses these to map to
    a virtual address space using mmap. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|程序头或段|包含有关如何在运行时创建进程或内存映像以执行的指令。然后内核使用这些指令通过mmap映射到虚拟地址空间。|'
- en: '| Section headers or sections | `.text`: Executable code (instructions, static
    constants, literals)`.data`: Access controlled, initialized data`.rodata`: Read-only
    data`.bss`: Read/write uninitialized data |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|部分头或部分|`.text`：可执行代码（指令，静态常量，文字）`.data`：受控访问的初始化数据`.rodata`：只读数据`.bss`：读/写未初始化数据|'
- en: 'We can also compile a 32 bit version of this program to see the difference.
    As mentioned in [Chapter 1](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml), *Introduction
    to Performance in Go*, we can build Go binaries for different architectures. We
    can build a binary for an i386 Linux system using the following build parameters:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以编译这个程序的32位版本以查看差异。如[第1章](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml)中所述，*Go性能简介*，我们可以为不同的架构构建Go二进制文件。我们可以使用以下构建参数为i386
    Linux系统构建二进制文件：
- en: '`env GOOS=linux GOARCH=386 go build -o 386simpleServer simpleServer.go`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`env GOOS=linux GOARCH=386 go build -o 386simpleServer simpleServer.go`'
- en: 'Once this build has been completed, we can inspect the resulting ELF file and
    corroborate the fact that the resulting ELF is different from the one we processed
    before for my x86_64 computer. We''ll use the `-h` flag just to view the headers
    for each file for brevity:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此构建后，我们可以检查生成的ELF文件，并证实生成的ELF与之前为我的x86_64计算机处理的ELF不同。我们将使用`-h`标志仅查看每个文件的头部以简洁起见：
- en: '![](img/642fb06a-a721-41ab-b51d-4db166d02b1d.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/642fb06a-a721-41ab-b51d-4db166d02b1d.png)'
- en: 'As you can see in the resulting output, this particular binary was generated
    for an i386 processor, as opposed to the x86_64 binary that was generated initially:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出结果中所见，这个特定的二进制文件是为i386处理器生成的，而不是最初生成的x86_64二进制文件：
- en: '![](img/5f2a3cba-31df-4636-a91e-44c3e442cc8e.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f2a3cba-31df-4636-a91e-44c3e442cc8e.png)'
- en: Knowing the limitations of your system, your architecture, and your memory limits
    can help you to build Go programs that will run effectively on your hosts. In
    this section, we will deal with memory utilization.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 了解系统的限制、架构和内存限制可以帮助您构建在主机上有效运行的Go程序。在本节中，我们将处理内存利用。
- en: Understanding memory utilization
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内存利用
- en: Once we have our initial binary, we start building on the knowledge that we
    have of the ELF format to continue our understanding of memory utilization. The
    text, data, and bss fields are a foundation on which the heap and stack are laid.
    The heap begins at the end of the `.bss` and `.data` bits and grows continuously to
    form larger memory addresses.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了初始的二进制文件，我们就开始建立对ELF格式的了解，以继续理解内存利用。文本、数据和bss字段是堆和栈的基础。堆从`.bss`和`.data`位的末尾开始，并持续增长以形成更大的内存地址。
- en: The stack is an allocation of contiguous blocks of memory. This allocation happens
    automatically within the function call stack. When a function is called, its variables
    get memory allocated on the stack. After the function call is completed, the variable's
    memory is deallocated. The stack has a fixed size and can only be determined at
    compile time. Stack allocation is inexpensive from an allocation perspective because
    it only needs to push to the stack and pull from the stack for allocation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈是连续内存块的分配。这种分配在函数调用堆栈内自动发生。当调用函数时，其变量在堆栈上分配内存。函数调用完成后，变量的内存被释放。堆栈具有固定大小，只能在编译时确定。从分配的角度来看，堆栈分配是廉价的，因为它只需要推送到堆栈和从堆栈中拉取以进行分配。
- en: The heap is a grouping of memory that is available to allocate and deallocate.
    Memory is allocated in random order, manually performed by the programmer. It
    is more expensive timewise and is slower to access because of its non-continuous
    blocks. It is, however, possible to resize elements in the heap. Heap allocation
    is expensive, as malloc searches for enough memory to hold the new data. As the
    garbage collector works later, it scans for objects in the heap that aren't referenced
    anymore, and deallocates them. These two processes are much more expensive than
    stack allocation/deallocation bits. Because of this, Go prefers allocation on
    the stack rather than the heap.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是可用于分配和释放的内存组合。内存是以随机顺序分配的，由程序员手动执行。由于其非连续的块，它在时间上更昂贵，访问速度较慢。然而，堆中的元素可以调整大小。堆分配是昂贵的，因为malloc搜索足够的内存来容纳新数据。随着垃圾收集器的工作，它扫描堆中不再被引用的对象，并将它们释放。这两个过程比堆栈分配/释放位要昂贵得多。因此，Go更喜欢在堆栈上分配而不是在堆上分配。
- en: We can compile programs with a gcflag of `-m` in order to see how the Go compiler
    uses escape analysis (the process in which the compiler determines whether to
    use the stack or the heap for variables initialized at runtime).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-m`的gcflag编译程序，以查看Go编译器如何使用逃逸分析（编译器确定在运行时初始化变量时是否使用堆栈或堆的过程）。
- en: 'We can create a very simple program as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个非常简单的程序如下：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can then compile our program with the escape analysis flag as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用逃逸分析标志编译我们的程序如下：
- en: '![](img/31678bb4-b5a6-4c78-816d-646eeb49a4e3.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31678bb4-b5a6-4c78-816d-646eeb49a4e3.png)'
- en: 'In our resulting output, we can see that our simple `greetingString` is allocated
    to the heap. If we want additional verbosity with this flag, we can pass multiple
    `m` values. At the time of writing, passing up to 5 `-m` flags gives us different
    levels of verbosity. The following screenshot is of a build with 3 `-m` flags
    (for the sake of brevity):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的输出结果中，我们可以看到我们简单的`greetingString`被分配到了堆上。如果我们想要使用此标志进行更多详细信息，我们可以传递多个`m`值。在撰写本文时，传递多达5个`-m`标志会给我们不同级别的详细信息。以下屏幕截图是使用3个`-m`标志进行构建的（为简洁起见）：
- en: '![](img/bb8813d9-27e7-4f36-bb82-d4cebcbae446.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb8813d9-27e7-4f36-bb82-d4cebcbae446.png)'
- en: Go variables that are statically assigned tend to live on the stack. Items that
    are pointers to memory or methods on interface types tend to be dynamic and therefore
    live on the heap generally.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分配的Go变量倾向于存在堆栈上。指向内存或接口类型方法的项目倾向于是动态的，因此通常存在堆上。
- en: If we want to see more available optimizations while performing our builds,
    we can see them using the following command: `go tool compile -help`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在执行构建时看到更多可用的优化，我们可以使用以下命令查看它们：`go tool compile -help`。
- en: Go runtime memory allocation
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go运行时内存分配
- en: As we learned in [Chapter 3](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml), *Understanding
    Concurrency*, the Go runtime uses the `G` struct to represent stack parameters
    for a single goroutine. The `P` struct manages logical processors for execution.
    The malloc that is used as part of the Go runtime, defined at [https://golang.org/src/runtime/malloc.g](https://golang.org/src/runtime/malloc.go)[o](https://golang.org/src/runtime/malloc.go),
    does a lot of work. Go uses mmap to ask the underlying OS directly for memory.
    Small allocation sizes (memory allocations up to and including 32 kB) are handled
    separately from large memory allocations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml)中所学的，*理解并发性*，Go运行时使用`G`结构来表示单个goroutine的堆栈参数。`P`结构管理执行的逻辑处理器。作为Go运行时的一部分使用的malloc，在[https://golang.org/src/runtime/malloc.g](https://golang.org/src/runtime/malloc.go)中定义，做了很多工作。Go使用mmap直接向底层操作系统请求内存。小的分配大小（内存分配最多达到32KB）与大内存分配分开处理。
- en: Memory allocation primer
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分配入门
- en: Let's quickly discuss a couple of objects that are associated with Go's small
    object memory allocation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速讨论与Go的小对象内存分配相关的一些对象。
- en: We can see the `mheap` and `mspan` structs in [https://golang.org/src/runtime/mheap.go](https://golang.org/src/runtime/mheap.go).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[https://golang.org/src/runtime/mheap.go](https://golang.org/src/runtime/mheap.go)中看到`mheap`和`mspan`结构。
- en: '`mheap` is the main malloc heap. It keeps track of global data, as well as
    many other heap details. Some important ones are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`mheap`是主要的malloc堆。它跟踪全局数据，以及许多其他堆细节。一些重要的细节如下：'
- en: '| **Name** | **Description** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| lock | A mutex locking mechanism |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| lock | 互斥锁机制 |'
- en: '| free | An mTreap (a data structure that is a blend of a tree and a heap)
    of non-scavenged spans |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| free | 一个非清除的mspan的mTreap（一种树和堆的混合数据结构） |'
- en: '| scav | An mTreap of free and scavenged spans |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| scav | 一个包含空闲和清除的mspan的mTreap |'
- en: '| sweepgen | An integer that keeps track of a span''s swept status |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| sweepgen | 用于跟踪跨度清除状态的整数 |'
- en: '| sweepdone | Tracking whether all spans are swept |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| sweepdone | 跟踪所有跨度是否都被清除 |'
- en: '| sweepers | The number of `sweepone` calls active |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| sweepers | 活动的`sweepone`调用数量 |'
- en: '`mspan` is the main span malloc. It keeps track of all available spans. Spans
    are 8K or larger contiguous regions of memory. It also keeps many other span details.
    Some important ones to note are as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`mspan`是主要的跨度malloc。它跟踪所有可用的跨度。跨度是内存的8K或更大的连续区域。它还保留许多其他跨度细节。一些重要的细节如下：'
- en: '| **Name** | **Description** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `next` | The next span in the list; (nil) if one isn''t present |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `next` | 列表中的下一个跨度；如果没有则为（nil） |'
- en: '| `previous` | Previous span in the list; (nil) if there isn''t one |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `previous` | 列表中的前一个跨度；（nil）如果没有 |'
- en: '| `list` | A span list for debugging |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `list` | 用于调试的跨度列表 |'
- en: '| `startAddr` | First byte of a span |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `startAddr` | 跨度的第一个字节 |'
- en: '| `npages` | The number of pages in the span |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `npages` | 跨度中的页面数 |'
- en: Memory object allocation
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存对象分配
- en: 'There are three classifications of memory objects:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 内存对象有三种分类：
- en: 'Tiny: An object that is less than 16 bytes in size'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微小：小于16字节的对象
- en: 'Small: An object that is greater than 16 bytes and less than or equal to 32
    kB'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小：大于16字节且小于或等于32KB的对象
- en: 'Large: An object that is larger than 32 kB in size'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大：大于32KB的对象
- en: 'A tiny object in memory in Go performs the following process for memory allocation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，内存中的微小对象执行以下内存分配过程：
- en: If `P`'s mcache has room, use that space.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`P`的mcache有空间，就使用那个空间。
- en: Take the existing sub object in the mcache and round it to 8, 4, or 2 bytes.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取现有的mcache中的子对象，并将其四舍五入为8、4或2字节。
- en: Place the object in memory if it fits in the allocated space.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果适合分配空间，则将对象放入内存中。
- en: 'A small object in memory in Go follows a specific pattern for memory allocation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，内存中的小对象遵循特定的内存分配模式：
- en: 'The object''s size gets rounded up and classified into one of the small size
    classes that are generated in [https://golang.org/src/runtime/mksizeclasses.go](https://golang.org/src/runtime/mksizeclasses.go).
    In the following output, we can see the `_NumSizeClasses` and the `class_to_size`
    variable allocations defined on my x86_64 machine. This value is then used to
    find a free bitmap within the mspan in P''s mcache and will allocate accordingly
    if there''s a free slot of memory available. The following screenshot illustrates
    this:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的大小被四舍五入并分类为在[https://golang.org/src/runtime/mksizeclasses.go](https://golang.org/src/runtime/mksizeclasses.go)中生成的小尺寸类之一。在以下输出中，我们可以看到在我的x86_64机器上定义的`_NumSizeClasses`和`class_to_size`变量分配。然后使用此值在P的mcache中找到一个空闲位图，并根据需要进行分配，如果有可用的内存空间。以下截图说明了这一点：
- en: '![](img/d1ab7fe3-9ab0-4a0a-8aca-c6c2e7035bf3.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1ab7fe3-9ab0-4a0a-8aca-c6c2e7035bf3.png)'
- en: If there are no free spots in P's mspan, a new mspan is obtained from mcentral's
    mspan list that has enough space for the new memory object.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果P的mspan没有空闲位置，则从mcentral的mspan列表中获取一个新的mspan，该列表有足够的空间来存放新的内存对象。
- en: If that list is empty, a run of pages from the mheap is performed in order to
    find room for the mspan.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该列表为空，则从mheap中执行页面运行，以便为mspan找到空间。
- en: If that fails, is empty, or doesn't have a large enough page to allocate, a
    new group of pages is allocated from the OS. This is expensive, but is done in
    at least 1 MB chunks, which helps with the cost of having to talk to the OS.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果失败，为空，或者没有足够大的页面来分配，就会从操作系统中分配一组新的页面。这很昂贵，但至少以1MB的块来完成，这有助于减少与操作系统通信的成本。
- en: 'Freeing objects from an mspan follow a similar process:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从mspan中释放对象遵循类似的过程：
- en: An mspan is returned to the mcache if it is being swept in response to an allocation.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果mspan正在响应分配而被清除，则将其返回到mcache。
- en: If the mspan still has objects that are allocated to it, the mcentral free list
    receives this mspan for deallocation.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果mspan仍然有分配给它的对象，mcentral的空闲列表将接收该mspan以进行释放。
- en: If the mspan is idle (it has no allocated objects), it gets returned to the
    mheap.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果mspan处于空闲状态（没有分配的对象），它将被返回到mheap。
- en: Once the mspan is idle for a given interval, these pages are returned to the
    underlying OS.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦mspan在给定的间隔内处于空闲状态，这些页面就会被返回到底层操作系统。
- en: Large objects don't use the mcache or the mcentral; they just use the mheap
    directly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大对象不使用mcache或mcentral；它们直接使用mheap。
- en: 'We can use our previously created HTTP server in order to take a look at some
    memory stats. Using the runtime package, we can derive the amount of memory the
    program has retrieved from the OS, as well as the heap allocation for the Go program.
    Let''s see how this happens step by step:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用先前创建的HTTP服务器来查看一些内存统计信息。使用runtime包，我们可以推导出程序从操作系统检索的内存量，以及Go程序的堆分配。让我们一步一步地看看这是如何发生的：
- en: 'First, we initialize our package, perform our imports, and set up our first
    handler:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们初始化我们的包，执行我们的导入，并设置我们的第一个处理程序：
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then write an anonymous function to capture our run statistics:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们编写一个匿名函数来捕获我们的运行统计：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After we execute this program, we can see the memory allocation for our service.
    The first printout in the following results shows the initial allocations of memory:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此程序后，我们可以看到我们服务的内存分配。以下结果中的第一个打印输出显示了内存的初始分配：
- en: '![](img/b113544c-1739-46b6-9cca-8d0ea15c940f.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b113544c-1739-46b6-9cca-8d0ea15c940f.png)'
- en: The second printout is after a request for `http://localhost:1234/` has been
    made. You can see that the system and heap allocations stay roughly the same,
    and that both the idle heap and the heap in use shift for utilization with the
    web request.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个打印输出是在对`http://localhost:1234/`发出请求后。您可以看到系统和堆分配大致保持不变，并且空闲堆和正在使用的堆会随着Web请求的利用而发生变化。
- en: Go's memory allocator was originally derived from TCMalloc, a thread caching
    malloc. More information about TCMalloc can be found at [http://goog-perftools.sourceforge.net/doc/tcmalloc.html](http://goog-perftools.sourceforge.net/doc/tcmalloc.html).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Go的内存分配器最初源自TCMalloc，一个线程缓存的malloc。有关TCMalloc的更多信息可以在[http://goog-perftools.sourceforge.net/doc/tcmalloc.html](http://goog-perftools.sourceforge.net/doc/tcmalloc.html)找到。
- en: 'Go allocator, the Go memory allocator, uses thread-local cache and spans that
    are 8 K or larger contiguous regions of memory. These 8 K regions, also known
    as spans, are commonly used in one of three capacities:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Go分配器，Go内存分配器，使用线程本地缓存和8K或更大的连续内存区域。这些8K区域，也称为span，通常用于以下三种能力之一：
- en: 'Idle: A span that can be reused for the heap/stack or returned to the OS'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空闲：可以重用于堆/栈或返回给操作系统的span
- en: 'In use: A span that is currently being used in the Go runtime'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中：当前在Go运行时中使用的span
- en: 'Stack: A span that is used for the goroutine stack'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈：用于goroutine堆栈的span
- en: 'If we create a program that doesn''t have shared libraries, we should see a
    much smaller memory footprint for our program:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个没有共享库的程序，我们应该看到我们的程序的内存占用要小得多：
- en: 'First, we initialize our package and import the required libraries:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们初始化我们的包并导入所需的库：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then perform the same actions that we did for our previous simple http server,
    but we just use the `fmt` package to print a string. We then sleep so that we
    have the ability to see the memory utilization output:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们执行与之前的简单http服务器相同的操作，但我们只使用`fmt`包来打印一个字符串。然后我们休眠，以便能够看到内存利用输出：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From the output from the execution of this program, we can see that the heap
    allocation for this executable is much smaller than our simple HTTP server:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从执行此程序的输出中，我们可以看到此可执行文件的堆分配要比我们的简单HTTP服务器小得多：
- en: '![](img/87c357c5-4297-4f02-953d-411fd51fd370.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87c357c5-4297-4f02-953d-411fd51fd370.png)'
- en: But why is this the case? We can use the goweight library [[https://github.com/jondot/goweight](https://github.com/jondot/goweight)]
    to see the size of the dependencies within our program. We just need to download
    this binary: `go get github.com/jondot/goweight`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么会这样呢？我们可以使用goweight库[[https://github.com/jondot/goweight](https://github.com/jondot/goweight)]来查看程序中依赖项的大小。我们只需要下载这个二进制文件：`go
    get github.com/jondot/goweight`。
- en: 'We can then determine what the large dependencies are in our Go program:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以确定我们Go程序中的大依赖项是什么：
- en: '![](img/a3278b05-e735-4544-8fac-6ece827fc174.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3278b05-e735-4544-8fac-6ece827fc174.png)'
- en: We can see that the `net/http` library takes up a lot of space, as do the runtime
    and the net library.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`net/http`库占用了很多空间，runtime和net库也是如此。
- en: 'In contrast, let''s look at our simple program with memory stats:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，让我们看一下带有内存统计的简单程序：
- en: '![](img/84587793-0388-4e30-8053-78dd733cfaa8.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84587793-0388-4e30-8053-78dd733cfaa8.png)'
- en: We can see that our next largest segments without the runtime are much smaller
    than the `net/http` and `net` libraries. It's always important to know exactly
    where our resources are being utilized in order to make more efficient binaries.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，没有运行时的下一个最大段要比`net/http`和`net`库小得多。了解资源的确切利用情况总是很重要，以便制作更高效的二进制文件。
- en: 'If we take a look at the OS level calls with strace, we can next see the difference
    between the interaction with our simple web server and our simple program. An
    example of our simple web server is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用strace查看操作系统级别的调用，我们接下来可以看到与我们的简单Web服务器和简单程序的交互之间的差异。我们简单Web服务器的示例如下：
- en: '![](img/15f01d58-f40a-4f5d-80d6-a17a17d9a441.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15f01d58-f40a-4f5d-80d6-a17a17d9a441.png)'
- en: 'An example of our simple program can be seen here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单程序的示例可以在这里看到：
- en: '![](img/a1797f59-dcb9-477d-a3c9-43d4761f5a36.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1797f59-dcb9-477d-a3c9-43d4761f5a36.png)'
- en: 'From the output, we can notice a couple of things:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以注意到几件事情：
- en: The output from our `simpleWebServer` is much longer than our `simpleProgram`
    (this has been truncated in the screenshots, but if it is generated we can see
    that the response length is longer).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`simpleWebServer`的输出比我们的`simpleProgram`要长得多（在截图中已经被截断，但如果生成了，我们可以看到响应长度更长）。
- en: The `simpleWebServer` loads a lot more C libraries (we can see `ld.so.preload`, `libpthread.so.0`,
    and `libc.so.6` in our strace capture in the screenshot).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simpleWebServer`加载了更多的C库（我们可以在截图中的strace捕获中看到`ld.so.preload`、`libpthread.so.0`和`libc.so.6`）。'
- en: There are quite a lot more memory allocations in our `simpleWebServer` than
    our `simpleProgram` output.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`simpleWebServer`中的内存分配比我们的`simpleProgram`输出要多得多。
- en: We can take a look at where these are pulled in. The `net/http` library doesn't
    have any C references, but its parent library net does. In all of the cgo packages
    in the net library, we have documentation that tells us how we can skip using
    underlying CGO resolvers for packages: [https://golang.org/pkg/net/#pkg-overview](https://golang.org/pkg/net/#pkg-overview).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看看这些是从哪里拉取的。`net/http`库没有任何C引用，但其父库net有。在net库中的所有cgo包中，我们有文档告诉我们如何跳过使用底层CGO解析器的包：[https://golang.org/pkg/net/#pkg-overview](https://golang.org/pkg/net/#pkg-overview)。
- en: 'This documentation shows us how we can use the Go and cgo resolvers:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这份文档向我们展示了如何使用Go和cgo解析器：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s use this to enable just the Go resolver in our example web server by
    executing the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令仅启用Go解析器在我们的示例Web服务器中：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the following screenshot, we can see the process that is executing for our
    `simpleServer` without the C resolver:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到没有C解析器的`simpleServer`正在执行的过程：
- en: '![](img/0c5071fb-8149-4b4a-ba74-c152eff4e528.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c5071fb-8149-4b4a-ba74-c152eff4e528.png)'
- en: 'We can see that our VSZ and RSS are low. Compare that to using the C resolver
    by typing the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的VSZ和RSS都很低。将其与使用C解析器进行比较，方法是输入以下命令：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can see the output of our `simpleServer` using the following C resolver:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到使用以下C解析器的`simpleServer`的输出：
- en: '![](img/456eb523-f097-49dc-9674-28140e57c054.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/456eb523-f097-49dc-9674-28140e57c054.png)'
- en: Our VSZ is significantly lower in our server that wasn't compiled with the cgo
    resolver. Next, we will discuss limited memory situations and how to account for
    and build them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的VSZ在没有使用cgo解析器编译的服务器中显着较低。接下来，我们将讨论有限的内存情况以及如何考虑和构建它们。
- en: Briefing on limited memory situations
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有限内存情况简介
- en: If you are running Go on an embedded device or a device with very constrained
    memory, it's sometimes smart to understand some of the underlying processes within
    the runtime to make informed decisions regarding your processes. The Go garbage
    collector *prioritizes low latency and simplicity*. It uses a non-generational
    concurrent tri-color mark and sweep garbage collector. By default, it manages
    memory allocation automatically.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在嵌入式设备或内存非常受限的设备上运行Go，有时了解运行时内部的一些基本过程以便就您的进程做出明智的决策是明智的。Go垃圾收集器*优先考虑低延迟和简单性*。它使用非生成并发三色标记和扫描垃圾收集器。默认情况下，它会自动管理内存分配。
- en: Go has a function in the debug standard library that will force a garbage collection
    and return memory to the OS. The Go garbage collector returns unused memory to
    the OS after 5 minutes. If you are running on a low memory device, this function,
    `FreeOSMemory()`, can be found here: [https://golang.org/pkg/runtime/debug/#FreeOSMemory](https://golang.org/pkg/runtime/debug/#FreeOSMemory).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'Go在调试标准库中有一个函数，它将强制进行垃圾收集并将内存返回给操作系统。Go垃圾收集器在5分钟后将未使用的内存返回给操作系统。如果您在内存较低的设备上运行，可以在这里找到此函数`FreeOSMemory()`:
    [https://golang.org/pkg/runtime/debug/#FreeOSMemory](https://golang.org/pkg/runtime/debug/#FreeOSMemory)。'
- en: We can also use the `GC()` function, which can be found here: [https://golang.org/pkg/runtime/#GC](https://golang.org/pkg/runtime/#GC).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`GC()`函数，可以在这里找到：[https://golang.org/pkg/runtime/#GC](https://golang.org/pkg/runtime/#GC)。
- en: The `GC()` function may also block the entire program. Use both of these functions
    at your own risk, because they can lead to unintended consequences.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`GC()`函数也可能会阻塞整个程序。使用这两个函数要自担风险，因为它们可能导致意想不到的后果。'
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've learned about how Go allocates the heap and stack. We've
    also learned how to effectively monitor VSZ and RSS memory, and how we can optimize
    our code to make better use of available memory. Being able to do this allows
    us to effectively scale with the resources we have, serving more concurrent requests
    with the same amount of hardware.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Go如何分配堆和栈。我们还学习了如何有效地监视VSZ和RSS内存，以及如何优化我们的代码以更好地利用可用内存。能够做到这一点使我们能够有效地利用我们拥有的资源，使用相同数量的硬件为更多的并发请求提供服务。
- en: In the next chapter, we will be discussing GPU processing in Go.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Go中的GPU处理。
