- en: Compile Time Evaluations in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的编译时评估
- en: The Go authors have written the language in a way that minimizes dependencies
    and each file declares its own dependencies. Regular syntax and module support
    also helps a developer improve compile times, as well as interface satisfaction.
    In this chapter, we will see how runtime evaluations help make Go compilation
    quicker, alongside using containers for building Go code and utilizing the Go
    build cache.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go的作者以一种最小化依赖的方式编写了语言，每个文件都声明了自己的依赖关系。常规的语法和模块支持也有助于开发人员提高编译时间，以及接口满意度。在本章中，我们将看到运行时评估如何帮助加快Go编译速度，以及如何使用容器构建Go代码和利用Go构建缓存。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Go runtime
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go运行时
- en: '`GCTrace`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GCTrace`'
- en: '`GOGC`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOGC`'
- en: '`GOMAXPROCS`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOMAXPROCS`'
- en: '`GOTRACEBACK`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOTRACEBACK`'
- en: The Go build cache
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go构建缓存
- en: Vendoring
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应
- en: Caching
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Debugging
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: '`KeepAlive`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeepAlive`'
- en: '`NumCPU`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumCPU`'
- en: '`ReadMemStats`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadMemStats`'
- en: These are all valuable topics for understanding how the Go runtime works and
    how you can use it to write performant code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是了解Go运行时如何工作以及如何使用它编写高性能代码的宝贵主题。
- en: Exploring the Go runtime
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Go运行时
- en: Within the Go source code, we can see the runtime source by looking at [https://golang.org/src/runtime/](https://golang.org/src/runtime/).
    The runtime package contains operations that interact with the Go runtime. This
    package is used to control things such as goroutines, garbage collection, reflection,
    and scheduling, which are all functions that are essential to the operation of
    the language. Within the runtime package, we have many environment variables that
    help us change the runtime behavior of Go executables. Let's review some of the
    most important environment variables we can talk about with respect to the Go
    runtime.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go源代码中，我们可以通过查看[https://golang.org/src/runtime/](https://golang.org/src/runtime/)来查看运行时源代码。运行时包含与Go运行时交互的操作。该包用于控制诸如goroutines、垃圾回收、反射和调度等功能，这些功能对语言的运行至关重要。在运行时包中，我们有许多环境变量，可以帮助我们改变Go可执行文件的运行时行为。让我们回顾一些关于Go运行时的最重要的环境变量。
- en: GODEBUG
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GODEBUG
- en: '`GODEBUG` is the controller of the variables and is used for debugging within
    the Go runtime. This variable contains a list of `name=val` key-value pairs, separated
    by commas. These named variables are used to tune the output of the debugging
    information the binary will return. One of the nice things about this variable
    is that the runtime allows you to apply this directly to a precompiled binary,
    rather than invoking it at build time. This is nice because it allows you to debug
    a binary that has already been built (and potentially already causing harm in
    a production environment). The variables you can pass to `GODEBUG` are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`GODEBUG`是变量的控制器，用于在Go运行时进行调试。该变量包含一系列以逗号分隔的`name=val`键值对。这些命名变量用于调整二进制文件返回的调试信息的输出。关于这个变量的一个好处是，运行时允许您直接将其应用于预编译的二进制文件，而不是在构建时调用它。这很好，因为它允许您调试已经构建的二进制文件（并且可能已经在生产环境中造成了损害）。您可以传递给`GODEBUG`的变量如下：'
- en: '| **GODEBUG variables** | **Enable value** | **Description** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **GODEBUG变量** | **启用值** | **描述** |'
- en: '| `allocfreetrace` | 1 | Used in order to profile every allocation. A stack
    trace is printed for each object''s allocation and is freed. Each stack trace
    contains the memory block, size, type, goroutine ID, and stack trace of the individual
    element. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `allocfreetrace` | 1 | 用于对每个分配进行分析。为每个对象的分配和释放打印堆栈跟踪。每个堆栈跟踪包含内存块、大小、类型、goroutine
    ID和单个元素的堆栈跟踪。 |'
- en: '| `clobberfree` | 1 | The GC clobbers the content of an object with bad content
    when it frees the object. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `clobberfree` | 1 | 当释放对象时，GC会用不良内容破坏对象的内容。 |'
- en: '| `cgocheck` | 0 – Disabled 1 (default) – Cheap checks 2 – Expensive checks
    | Checks for packages that use cgo for incorrectly passed go pointers to non-Go
    code.  Set 0 for disabled, 1 for cheap checks that may miss some errors (default),
    or 2 for expensive checks that will slow your program down. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `cgocheck` | 0 – 禁用 1（默认）– 廉价检查 2 – 昂贵检查 | 用于检查使用cgo的包是否将错误传递给非Go代码的go指针。设置为0表示禁用，1表示廉价检查可能会错过一些错误（默认），或者2表示昂贵检查会减慢程序运行速度。
    |'
- en: '| `efence` | 1 | The allocator will ensure each object is allocated on a unique
    page and that memory addresses aren''t recycled. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `efence` | 1 | 分配器将确保每个对象都分配在唯一的页面上，并且内存地址不会被重复使用。 |'
- en: '| `gccheckmark` | 1 | Verifies the GC''s current mark phase by doing a second
    mark pass. The world is stopped during this second mark pass. If the second pass
    finds an object that wasn''t found by the concurrent mark, the GC will panic.
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `gccheckmark` | 1 | 通过进行第二次标记传递来验证GC的当前标记阶段。在这第二次标记传递期间，世界会停止。如果第二次传递发现了并发标记没有找到的对象，GC将会发生panic。
    |'
- en: '| `gcpacertrace` | 1 | Prints information about the concurrent pacer''s internal
    state with respect to the garbage collector. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `gcpacertrace` | 1 | 打印有关垃圾收集器的并发pacer内部状态的信息。 |'
- en: '| `gcshrinkstackoff` | 1 | Moving goroutines cannot move onto smaller stacks.
    A Goroutine''s stack only grows in this mode. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `gcshrinkstackoff` | 1 | 移动的goroutines不能移动到更小的堆栈上。在这种模式下，goroutine的堆栈只会增长。
    |'
- en: '| `gcstoptheworld` | 1 – Disables GC 2 – Disables GC and concurrent sweeping
    | 1 disables concurrent garbage collection. This turns each GC event into a stop
    the world situation. 2 disables GC and disables concurrent sweeping after the
    completion of garbage collection. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `gcstoptheworld` | 1 – 禁用GC 2 – 禁用GC和并发扫描 | 1禁用并发垃圾回收。这将使每个GC事件变成一个全局停止的情况。2禁用GC并在垃圾回收完成后禁用并发扫描。
    |'
- en: '| `gctrace` | 1 | See the `GCTrace` header on the subsequent page. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `gctrace` | 1 | 请参阅下一页的`GCTrace`标题。 |'
- en: '| `madvdontneed` | 1 | Returns memory to the kernel with `MADV_DONTNEED` instead
    of `MADV_FREE` on Linux. Using this flag makes for less efficient memory utilization,
    but also makes RSS memory values drop more quickly. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `madvdontneed` | 1 | 在Linux上使用`MADV_DONTNEED`而不是`MADV_FREE`将内存返回给内核。使用此标志会导致内存利用效率降低，但也会使RSS内存值更快地下降。
    |'
- en: '| `memprofilerate` | 0 – Turn of profiling 1 – Include every allocated block
    X – Updates the value of `MemProfileRate` | Controls memory allocation fractions
    that are reported and recorded within the memory profile. Changing X controls
    the fraction of memory allocations that are recorded. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `memprofilerate` | 0 – 关闭分析 1 – 包括每个分配的块 X – 更新`MemProfileRate`的值 | 控制在内存分析中报告和记录的内存分配分数。更改X控制记录的内存分配的分数。|'
- en: '| `invalidptr` | 0 – Disables this check 1 – Crashes if an invalid pointer
    is found | The garbage collector and stack copier will crash if a value for an
    invalid pointer is found where a pointer is stored. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `invalidptr` | 0 – 禁用此检查 1 – 如果发现无效指针，则垃圾收集器和堆栈复制器将崩溃 | 如果在存储指针的地方发现无效指针的值，垃圾收集器和堆栈复制器将崩溃。'
- en: '| `sbrk` | 1 | Swaps in a trivial allocator from the OS that doesn''t reclaim
    memory, instead of using the default memory allocator and garbage collector. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `sbrk` | 1 | 从操作系统中交换一个不回收内存的简单分配器，而不是使用默认的内存分配器和垃圾收集器。|'
- en: '| `scavenge` | 1 | The heap scavenger debugging mode is enabled. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `scavenge` | 1 | 启用堆清扫调试模式。|'
- en: '| `scheddetail` | 1 (in conjunction with schedtrace=X) | The scheduler returns
    information that pertains to the scheduler, processor, thread, and goroutine processes
    every X milliseconds. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `scheddetail` | 1（与schedtrace=X一起使用） | 调度器每X毫秒返回与调度器、处理器、线程和goroutine进程相关的信息。|'
- en: '| `schedtrace` | X | A single line is emitted to STDERR every X milliseconds
    with a scheduler state summary. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `schedtrace` | X | 每X毫秒向STDERR发出一行调度器状态摘要。|'
- en: '| `tracebackancestors` | N | Tracebacks of where goroutines are crated with
    their associated stacks are extended, reporting N ancestor goroutines. No ancestry
    information is returned if N = 0. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `tracebackancestors` | N | 哪些goroutine的回溯与它们关联的堆栈被扩展，报告N个祖先goroutine。如果N
    = 0，则不返回祖先信息。|'
- en: Other packages also have variables that are able to be passed to `GODEBUG`.
    These are usually very well-known packages that may need runtime performance tweaks,
    such as `crypto/tls` and `net/http`. Packages should contain documentation if
    they have `GODEBUG` flags that are available at runtime.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 其他包还有一些变量可以传递给`GODEBUG`。这些通常是非常知名的包，可能需要运行时性能调整，比如`crypto/tls`和`net/http`。如果包含`GODEBUG`标志在运行时是可用的，包应该包含文档。
- en: GCTRACE
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GCTRACE
- en: '`GCTRACE` is utilized during runtime to view a single line that''s been printed
    to stderr showing the total memory collected and the length of the pause during
    each collection. At the time of writing, this line is organized as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`GCTRACE`在运行时被使用，以查看已经打印到stderr的单行，显示每次收集时总内存和暂停的长度。在撰写本文时，此行组织如下：'
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can instrument a simple HTTP server to provide an example of how this works.
    First, we write a simple HTTP server with a simple response of `Hello Gophers`
    to the root of `localhost:8080`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为提供一个简单的HTTP服务器来提供这个工作原理的示例。首先，我们编写一个简单的HTTP服务器，对`localhost:8080`的根目录返回一个简单的`Hello
    Gophers`响应：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we can build and run this simple web server, and then we can use Apache
    bench ([https://httpd.apache.org/docs/2.4/programs/ab.html](https://httpd.apache.org/docs/2.4/programs/ab.html))
    to simulate some load to the host:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以构建并运行这个简单的Web服务器，然后我们可以使用Apache bench ([https://httpd.apache.org/docs/2.4/programs/ab.html](https://httpd.apache.org/docs/2.4/programs/ab.html))
    来模拟对主机的一些负载：
- en: '![](img/4adaae82-8d0b-472f-b9a2-4adba426c69d.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4adaae82-8d0b-472f-b9a2-4adba426c69d.png)'
- en: 'After we see this output from Apache bench, showing that our test has completed,
    we will see some garbage collection statistics in our Terminal where we initially
    instantiated our simple HTTP daemon:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从Apache bench看到这个输出，显示我们的测试已经完成，我们将在最初实例化我们的简单HTTP守护程序的终端上看到一些垃圾回收统计信息：
- en: '![](img/30586da4-f98c-4ad0-ad04-36a39dc1756e.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30586da4-f98c-4ad0-ad04-36a39dc1756e.png)'
- en: 'Let''s break down the garbage collection output of this example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下这个示例的垃圾回收输出：|
- en: '| **Output** | **Description** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **输出** | **描述** |'
- en: '| gc 1 | The garbage collection number. This number is incremented at each
    garbage collection. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| gc 1 | 垃圾回收编号。每次垃圾回收时，此编号会递增。|'
- en: '| @6.131s | This garbage collection occurred 6.131 s after the program was
    started. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| @6.131s | 此垃圾回收发生在程序启动后的6.131秒。|'
- en: '| 0% | The percentage of time spent in GC since the program was started. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 0% | 自程序启动以来在GC中花费的时间百分比。|'
- en: '| 0.016+2.1+0.023 ms clock | The wallclock/CPU times that occur for the phases
    of the GC. This can be expressed as *Tgc = Tseq + Tmark + Tsweep.* **Tseq**: User
    Go routines time stop (stop the world sweep termination).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0.016+2.1+0.023 ms clock | GC阶段发生的挂钟/CPU时间。这可以表示为*Tgc = Tseq + Tmark + Tsweep.*
    **Tseq**: 用户Go例程时间停止（停止世界清扫终止）。'
- en: '**Tmark**: The heap making time (concurrent mark and scan time).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tmark**: 堆标记时间（并发标记和扫描时间）。'
- en: '**Tsweep**: Heap sweeping time (sweep the world mark termination). |'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tsweep**: 堆清扫时间（清扫世界标记终止）。|'
- en: '| 4->4->3 MB | GC start, GC end, and live heap sizes. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 4->4->3 MB | GC开始、GC结束和活动堆大小。|'
- en: '| 5 MB goal | The goal heap size. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 5 MB goal | 目标堆大小。|'
- en: '| 4 P | 4 processors being used. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 4 P | 使用的处理器数。|'
- en: 'If we wait a couple of moments, our Terminal should produce an output, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们等待几分钟，我们的终端应该会产生以下输出：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is an output that occurs using `gctrace > 0`. It produces a summary whenever
    the Go runtime releases memory back to the system, also known as **scavenging**. 
    At the time of writing, this output follows the following format:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`gctrace > 0`发生的输出。每当Go运行时将内存释放回系统时，也称为**清扫**，它会产生一个摘要。在撰写本文时，此输出遵循以下格式：
- en: '| **Output** | **Description** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **输出** | **描述** |'
- en: '| scvg1: 57 MB released | The scavenge cycle number. This number is incremented
    at each scavenge. This data point also lets us know the size of the memory block
    that is released back to the OS. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| scvg1: 57 MB released | 垃圾回收周期编号。每次垃圾回收时，此编号会递增。此数据点还让我们知道释放回操作系统的内存块的大小。|'
- en: '| inuse: 1 | The size in MB of memory used in our program (this can also indicate
    partially used spans). |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| inuse: 1 | 程序中使用的内存大小（这也可能表示部分使用的跨度）。|'
- en: '| idle: 61 | The size in MB of spans pending scavenging. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: 空闲：61 | 待清理的跨度大小（以MB为单位）。
- en: '| sys: 3 | The size in MB of memory that''s been mapped from the system. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| sys: 3 | 从系统映射的内存大小（以MB为单位）。'
- en: '| released: 57 | The size in MB of memory released to the system. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| released: 57 | 释放给系统的内存大小（以MB为单位）。'
- en: '| consumed: 5 | The size in MB of memory allocated from the system. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| consumed: 5 | 从系统分配的内存大小（以MB为单位）。'
- en: Both the garbage collection and scavenging output examples are important—they
    can tell us the current state of memory utilization in our system in a simple
    to read manner.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集和清理输出示例都很重要-它们可以以简单易读的方式告诉我们系统内存利用的当前状态。
- en: GOGC
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GOGC
- en: 'The `GOGC` variable allows us to tune the intensity of the Go garbage collection
    system. The garbage collector (instantiated at [https://golang.org/src/runtime/mgc.go](https://golang.org/src/runtime/mgc.go)) 
    reads the `GOGC` variable and determines the value of the garbage collector. A
    value of `off` sets the garbage collector off. This is often useful for debugging
    but not sustainable in the long term as the program needs to free memory that
    is collected within the executable''s heap. Setting this value to less than the
    default value of 100 will cause the garbage collector to execute more frequently.
    Setting this value larger than the default value of 100 will cause the garbage
    collector to execute less frequently. Very often for multi-core large machines,
    garbage collection happens too frequently and we can improve performance if we
    have garbage collection happen less frequently. We can use a compilation of the
    standard library to see how changing garbage collection will influence compile
    times. In the following code sample, we can see examples of the build of the standard
    library and their respective timings:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOGC`变量允许我们调整Go垃圾收集系统的强度。垃圾收集器（在[https://golang.org/src/runtime/mgc.go](https://golang.org/src/runtime/mgc.go)实例化）读取`GOGC`变量并确定垃圾收集器的值。值为`off`会关闭垃圾收集器。这在调试时通常很有用，但在长期内不可持续，因为程序需要释放在可执行堆中收集的内存。将此值设置为小于默认值100将导致垃圾收集器更频繁地执行。将此值设置为大于默认值100将导致垃圾收集器执行更不频繁。对于多核大型机器，垃圾收集经常发生，如果我们减少垃圾收集的频率，可以提高性能。我们可以使用标准库的编译来查看更改垃圾收集如何影响编译时间。在以下代码示例中，我们可以看到标准库的构建及其相应的时间：'
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our output shows us the respective timings of the Go standard library compile
    times:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出显示了Go标准库编译时间的相应时间：
- en: '![](img/2e31273d-884b-4f09-93e3-c24e027f8b1a.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e31273d-884b-4f09-93e3-c24e027f8b1a.png)'
- en: We can see that there is a vast difference in compile times by tuning the garbage
    collection. This will vary greatly, depending on your architecture, system specs,
    and Go version. It is important to recognize this is a knob we can turn for our
    Go programs. This knob is often turned for build times or highly monitored, latency-sensitive
    binaries that need to squeeze out more performance during their execution time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整垃圾收集，我们可以看到编译时间有很大的差异。这将大大变化，取决于您的架构、系统规格和Go版本。重要的是要认识到这是一个我们可以为我们的Go程序调整的旋钮。这个旋钮通常用于构建时间或高度监控、对延迟敏感的二进制文件，在执行时间内需要挤出更多的性能。
- en: GOMAXPROCS
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GOMAXPROCS
- en: '`GOMAXPROCS` is a variable that can be tuned to allow us to control the number
    of threads that our operating system will allocate to our goroutines within our
    Go binary. By default, `GOMAXPROCS` is equal to the number of cores available
    to the application. This is dynamically configurable via the runtime package.
    It is important to note that as of Go 1.10, `GOMAXPROCS` will have no upper bound
    limit.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOMAXPROCS`是一个可以调整的变量，允许我们控制操作系统为Go二进制文件中的goroutine分配的线程数。默认情况下，`GOMAXPROCS`等于应用程序可用的核心数。这可以通过运行时包动态配置。重要的是要注意，从Go
    1.10开始，`GOMAXPROCS`将没有上限限制。'
- en: 'If we have a function that is CPU-intensive and parallelized (such as goroutine
    sorting strings), we will see some serious improvements if we adjust the number
    of `GOMAXPROCS` we have.  In the following code example, we are going to test
    building the standard library with a different number set for `GOMAXPROCS`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个CPU密集型且并行化的函数（例如goroutine排序字符串），如果调整我们拥有的`GOMAXPROCS`数量，我们将看到一些严重的改进。在以下代码示例中，我们将测试使用不同数字设置`GOMAXPROCS`来构建标准库：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our results, we can see what happens when we manipulate the total number
    of `GOMAXPROCS`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的结果中，我们可以看到当我们操纵`GOMAXPROCS`的总数时会发生什么：
- en: '![](img/23351ad2-7dae-4807-a55f-ac54de7cd6fc.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23351ad2-7dae-4807-a55f-ac54de7cd6fc.png)'
- en: Realistically, we should never set `GOMAXPROCS` manually. There are rare occasions
    where you might want to limit CPU utilization for a particular binary based on
    the resources you have available to you on a system, or you may really need to
    optimize based on the resources you have on hand. For most cases, however, the
    default `GOMAXPROCS` value is sane.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不应该手动设置`GOMAXPROCS`。很少有情况下，您可能希望根据系统上可用的资源限制特定二进制文件的CPU利用率，或者您可能确实需要根据手头的资源进行优化。然而，在大多数情况下，默认的`GOMAXPROCS`值是合理的。
- en: GOTRACEBACK
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GOTRACEBACK
- en: '`GOTRACEBACK` allows you to control the generated output from a Go program
    with unexpected runtime conditions or unrecovered panic states. Setting a `GOTRACEBACK`
    variable will allow you to see more or less granular information about the goroutines
    that are instantiated for your specific error or panic. An example of panic from
    a channel/goroutine interrupt is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOTRACEBACK`允许您控制Go程序在出现意外运行时条件或未恢复的恐慌状态时生成的输出。设置`GOTRACEBACK`变量将允许您查看有关为特定错误或恐慌实例化的goroutine的更多或更少粒度的信息。来自通道/
    goroutine中断的恐慌示例如下：'
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we tweak the `GOTRACEBACK` variable in our output, we will see different
    varying levels of stack trace. Setting `GOTRACEBACK=none` or `GOTRACEBACK=0` gives
    us a minimal amount of information about this panic:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在输出中调整`GOTRACEBACK`变量，我们将看到不同级别的堆栈跟踪。设置`GOTRACEBACK=none`或`GOTRACEBACK=0`会给我们关于此恐慌的最少信息：
- en: '![](img/3d1ad4f0-7faa-4444-b8a1-c25fdae2d3df.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d1ad4f0-7faa-4444-b8a1-c25fdae2d3df.png)'
- en: 'Setting `GOTRACEBACK=single` (the default option in the Go runtime) will emit
    a single stack trace for the current goroutine for our particular request, as
    follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`GOTRACEBACK=single`（Go运行时的默认选项）将为我们的特定请求发出当前goroutine的单个堆栈跟踪，如下所示：
- en: '![](img/454b7684-81a2-4e21-aeaf-d3f083bb190b.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/454b7684-81a2-4e21-aeaf-d3f083bb190b.png)'
- en: 'Setting `GOTRACEBACK=all` or `GOTRACEBACK=1` will send us back the stack traces
    for all of the goroutines that were created by the user:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`GOTRACEBACK=all`或`GOTRACEBACK=1`将为用户创建的所有goroutine发送回堆栈跟踪：
- en: '![](img/e56929fc-6e24-45c6-8c70-6cc8df1c46c7.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e56929fc-6e24-45c6-8c70-6cc8df1c46c7.png)'
- en: Setting `GOTRACEBACK=system` or `GOTRACEBACK=2` will add all of the runtime
    stack frames for functions and goroutines that are created by the runtime.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`GOTRACEBACK=system`或`GOTRACEBACK=2`将为由运行时创建的函数和goroutine添加所有运行时堆栈帧。
- en: Finally, we can set `GOTRACEBACK=crash`. This functions similarly to the system
    but allows the operating system to trigger a core dump.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以设置`GOTRACEBACK=crash`。这与系统类似，但允许操作系统触发核心转储。
- en: Most of the time, the default of `GOTRACEBACK=single` gives us enough information
    about the current context in order to make an informed decision about why our
    program ended in a way that we did not expect.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，默认的`GOTRACEBACK=single`为我们提供了关于当前上下文的足够信息，以便就为什么我们的程序以我们没有预期的方式结束做出明智的决定。
- en: Go build cache
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go构建缓存
- en: In this chapter, we've discussed a couple of ways to optimize the runtime for
    Go builds. We also have the ability to improve Go build times with a couple of
    simple tweaks. Go's team has been optimizing for runtime, not for build time.
    Go has the ability to cache build time dependencies, which helps to reuse common
    artifacts from previous builds. These artifacts are kept in `$GOPATH/pkg/`. We
    can keep these intermediate results by using the `-i` flag while calling go build
    in order to reutilize those artifacts. If we want to debug what is happening during
    our build, we can run our build with a `-x` flag in order to produce a more verbose
    output from the Go build system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了优化Go构建的几种方法。我们还可以通过一些简单的调整来提高Go构建时间的能力。Go团队一直在优化运行时，而不是构建时间。Go具有缓存构建时间依赖项的能力，这有助于重用先前构建的常见构件。这些构件保存在`$GOPATH/pkg/`中。我们可以通过在调用go
    build时使用`-i`标志来保留这些中间结果，以便重新利用这些构件。如果我们想调试构建过程中发生了什么，我们可以使用`-x`标志运行我们的构建，以便从Go构建系统产生更详细的输出。
- en: Vendoring dependencies
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vendoring依赖项
- en: Vendoring is also a popular choice for improving build consistency and quality.
    Within the project structure, the authors of the language were receptive to the
    feedback of keeping support for vendoring dependencies. Keeping your dependencies
    within your repository makes it very large, but it can help with keeping third
    party dependencies available locally during build time. When we are using Go version
    1.11 or greater, we can use Go modules flagging to allow vendored builds. We can
    use `go mod vendor` to capture all of the dependencies in the `vendor/` directory,
    followed by using `go build -mod vendor` at build time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Vendoring也是改善构建一致性和质量的流行选择。在项目结构中，语言的作者们对保持对vendoring依赖的支持的反馈持开放态度。将依赖项保留在存储库中会使其非常庞大，但可以帮助在构建时保持本地可用的第三方依赖项。当我们使用Go版本1.11或更高版本时，我们可以使用Go模块标志来允许vendored构建。我们可以使用`go
    mod vendor`来捕获`vendor/`目录中的所有依赖项，然后在构建时使用`go build -mod vendor`。
- en: Caching and vendoring improvements
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存和vendoring改进
- en: 'In order to see the improvements we can make with built and cached assets,
    let''s build a project with a third-party dependency.  Prometheus [[https://prometheus.io/](https://prometheus.io/)]
    is a popular time-series database (also written in Go) that is commonly used for
    metrics gathering and collection. We may want to start up a Prometheus metrics
    server in any of our applications in order to learn more about our current running
    binary, from a systems perspective. To do this, we can import the Prometheus library
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到我们可以通过构建和缓存资产进行的改进，让我们构建一个具有第三方依赖的项目。Prometheus[[https://prometheus.io/](https://prometheus.io/)]是一个流行的时间序列数据库（也是用Go编写的），通常用于指标收集和收集。我们可能希望在我们的任何应用程序中启动一个Prometheus指标服务器，以便从系统角度了解我们当前运行的二进制文件。为此，我们可以按如下方式导入Prometheus库：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After we instantiate our `prometheus` server in a basic binary, we can build
    our binary and execute it. To perform a force rebuild of packages that are already
    up to date, we can use the `-a` flag with `go build`. If you're curious as to
    what's taking forever in our super long build time, you can also add the `-x`
    flag – it'll give you a very verbose output as to what's happening during the
    build process.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在基本二进制文件中实例化`prometheus`服务器之后，我们可以构建我们的二进制文件并执行它。要对已经是最新的包执行强制重建，我们可以使用`go
    build`的`-a`标志。如果你想知道在我们超长的构建时间中到底花了多长时间，你也可以添加`-x`标志——它会给你一个非常详细的输出，说明构建过程中发生了什么。
- en: 'By default, newer versions of Golang will define a `GOCACHE`. You can see where
    it''s located using `go env GOCACHE`. Using a combination of `GOCACHE` and mod
    vendor, we can see that our build time has significantly improved. Our first build
    in the list is a cold build, forcing packages to be rebuilt so they''re up to
    date. Our second build, which has some items stored from the mod vendor stanza,
    is much quicker. Our third build, which should have most build elements cached,
    is very quick in comparison. The following screenshot illustrates this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，较新版本的Golang将定义一个`GOCACHE`。您可以使用`go env GOCACHE`查看其位置。使用`GOCACHE`和mod vendor的组合，我们可以看到我们的构建时间显著提高了。列表中的第一个构建是冷构建，强制重新构建包以使其保持最新。我们的第二个构建，其中一些项目存储在mod
    vendor段中，要快得多。我们的第三个构建，应该有大部分构建元素被缓存，与之相比非常快。以下截图说明了这一点：
- en: '![](img/86acab39-2724-46f6-9fd2-3d35324715af.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86acab39-2724-46f6-9fd2-3d35324715af.png)'
- en: Debug
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: 'The debug package within the runtime gives us many functions and types that
    are available for debugging.  We have the ability to do the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时内的调试包为我们提供了许多可用于调试的函数和类型。我们可以做到以下几点：
- en: Force a garbage collection using `FreeOSMemory()`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FreeOSMemory()`强制进行垃圾收集。
- en: Print the stack trace that was generated at runtime. Stack to stderr using `PrintStack()`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PrintStack()`打印在运行时生成的堆栈跟踪到stderr。
- en: Read our garbage collection stats using `ReadGCStats()`.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ReadGCStats()`读取我们的垃圾收集统计数据。
- en: Set our garbage collection percentage using `SetGCPercent()`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SetGCPercent()`设置我们的垃圾收集百分比。
- en: Set our max stack size for a single goroutine using `SetMaxStack()`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SetMaxStack()`设置单个goroutine的最大堆栈大小。
- en: Set our maximum number of OS threads using `SetMaxThreads()`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SetMaxThreads()`设置我们的最大OS线程数。
- en: Control the runtime behavior while faulting on an unexpected address using `SetPanicOndefault()`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SetPanicOndefault()`在意外地址故障时控制运行时行为。
- en: Set the amount of traceback using `SetTraceback()`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SetTraceback()`设置回溯的数量。
- en: Return the stack trace of a goroutine using `Stack()`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Stack()`返回goroutine的堆栈跟踪。
- en: Write a heap dump using `WriteHeapDump()`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`WriteHeapDump()`编写堆转储。
- en: PProf/race/trace
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PProf/race/trace
- en: We will cover the details of profiling and tracing Go programs in [Chapter 12](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml),
    *Profiling Go Code*, and [Chapter 13](ec12b9e7-c528-45c2-b0b8-dea297659b3e.xhtml),
    *Tracing Go Code*, respectively. It is prudent to know that the runtime library
    is a key driver in these utilities. Being able to use pprof/race/trace can help
    you debug your code in a meaningful way and be able to find nascent errors  In
    the next section, we will learn about runtime functions and how they are prudent
    to the Go runtime library.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第12章](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml) *Go代码性能分析*和[第13章](ec12b9e7-c528-45c2-b0b8-dea297659b3e.xhtml)
    *Go代码追踪*中详细介绍性能分析和追踪Go程序的细节。值得注意的是运行时库是这些实用程序的关键驱动程序。能够使用pprof/race/trace可以帮助您以有意义的方式调试代码，并能够找到新生错误。在下一节中，我们将学习运行时函数以及它们对Go运行时库的重要性。
- en: Understanding functions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数
- en: The Go runtime library also has functions that you can inject into your program's
    runtime to emit runtime data. Let's run through a couple of prime examples. A
    full list of all of the available runtime functions can be found at [https://golang.org/pkg/runtime/#pkg-index](https://golang.org/pkg/runtime/#pkg-index). 
    Many of the functions that are available in this package are also included in
    the `runtime/pprof` package, which we will investigate in more detail in [Chapter
    12](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml), *Profiling Go Code*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Go运行时库还有一些函数，可以注入到程序的运行时中以发出运行时数据。让我们通过一些主要示例来了解一下。所有可用运行时函数的完整列表可以在[https://golang.org/pkg/runtime/#pkg-index](https://golang.org/pkg/runtime/#pkg-index)找到。这个包中提供的许多函数也包含在`runtime/pprof`包中，我们将在[第12章](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml)
    *Go代码性能分析*中更详细地进行调查。
- en: KeepAlive
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KeepAlive
- en: The `runtime.KeepAlive()` function expects `interface{}` and ensures that the
    object passed to it isn't freed and that its finalizer (as defined by `runtime.SetFinalizer`)
    is not run. This keeps the argument passed to `KeepAlive` reachable. The compiler
    sets up `OpKeepAlive`, as defined in the **static single assignment** (**SSA**)
    package ([https://golang.org/src/cmd/compile/internal/gc/ssa.go#L2947](https://golang.org/src/cmd/compile/internal/gc/ssa.go#L2947))
    – this allows the compiler to know the state of the interface as a variable and
    allows the keep alive context to be kept.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime.KeepAlive()`函数期望`interface{}`，并确保传递给它的对象不被释放，并且它的终结器（由`runtime.SetFinalizer`定义）不被运行。这使得传递给`KeepAlive`的参数可达。编译器设置了`OpKeepAlive`，如**静态单赋值**（SSA）包中所定义的（[https://golang.org/src/cmd/compile/internal/gc/ssa.go#L2947](https://golang.org/src/cmd/compile/internal/gc/ssa.go#L2947)）-
    这使得编译器能够知道接口的状态作为一个变量，并允许保持保持活动的上下文。'
- en: As a rule of thumb, we should not call `KeepAlive` in normal implementations.
    It's used to ensure that the garbage collector doesn't reclaim memory from a *no
    longer* referenced value within a function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，我们不应该在正常的实现中调用`KeepAlive`。它用于确保垃圾收集器不会从函数内部不再被引用的值中回收内存。
- en: NumCPU
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumCPU
- en: 'The `NumCPU` function returns the usable number of logical CPUs of the current
    process. When the binary is invoked, the runtime validates the number of CPUs
    that are available at startup. A simple example of this can be found in the following
    code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumCPU`函数返回当前进程可用的逻辑CPU数量。当二进制文件被调用时，运行时会验证启动时可用的CPU数量。这个的一个简单示例可以在以下代码片段中找到：'
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can see the number of CPUs currently available to the process. In my
    case, this value ended up being `4`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到当前进程可用的CPU数量。在我的情况下，这个值最终是`4`：
- en: '![](img/dc16f4e3-913e-4afb-8526-9aeae8522d04.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc16f4e3-913e-4afb-8526-9aeae8522d04.png)'
- en: With this, we can see that my computer has 4 CPUs available for use.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们可以看到我的计算机有4个可用于使用的CPU。
- en: ReadMemStats
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReadMemStats
- en: 'The `ReadMemStats()` function reads memory allocator statistics and populates
    them into a variable, say, `m`. The `MemStats` struct has a lot of really valuable
    information about in-flight memory utilization. Let''s take a deep look into what
    values it can produce for us. An HTTP handler function that allows us to see the
    memory utilization of the binary may be helpful as we make more requests in our
    system and wish to see where our memory allocation is utilized:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadMemStats()`函数读取内存分配器统计信息并将其填充到一个变量中，比如`m`。`MemStats`结构体包含了关于内存利用的很多有价值的信息。让我们深入了解一下它可以为我们产生哪些值。一个允许我们查看二进制文件内存利用的HTTP处理程序函数可能会有所帮助，因为我们在系统中发出更多请求并希望看到我们的内存分配是在哪里被利用：'
- en: 'First, we can instantiate the program and the function:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以实例化程序和函数：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we can print all of the values of the individual memory statistics that
    the runtime provides us with. Let''s start with `Alloc`, `Mallocs`, and `Frees`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以打印运行时提供给我们的各个内存统计值。让我们从`Alloc`、`Mallocs`和`Frees`开始：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s look at heap information:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看一下堆信息：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we look at stack/span/cache/bucket allocations:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将查看堆栈/跨度/缓存/桶分配：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we look at garbage collection information:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们查看垃圾收集信息：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s look at garbage collection interruption information:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看一下垃圾收集中断信息：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we instantiate a simple HTTP server:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实例化一个简单的HTTP服务器：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we can use our Apache bench tool to generate a bit of load on our memory
    allocator:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以使用我们的Apache bench工具在我们的内存分配器上生成一些负载：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we can see some active HTTP server information, along with a response,
    by making a request to `localhost:1234`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过向`localhost:1234`发出请求来查看一些活动的HTTP服务器信息和响应：
- en: '![](img/b8fd2707-0f29-4394-9e95-fb667b359d75.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8fd2707-0f29-4394-9e95-fb667b359d75.png)'
- en: The definitions for all of the `MemStats` values can be found in the documentation
    at [https://golang.org/pkg/runtime/#MemStats](https://golang.org/pkg/runtime/#MemStats).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`MemStats`值的定义可以在文档中找到：[https://golang.org/pkg/runtime/#MemStats](https://golang.org/pkg/runtime/#MemStats)。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the `GODEBUG`, `GCTRACE`, `GOGC`, `GOMAXPROCS`,
    and `GOTRACEBACK` runtime optimizations.  We also learned about the `GOBUILDCACHE`
    and Go vendoring dependencies. Lastly, we learned about debugging and calling
    runtime functions from code. Using these techniques while troubleshooting your
    Go code will help you spot your problems and bottlenecks more easily.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了`GODEBUG`、`GCTRACE`、`GOGC`、`GOMAXPROCS`和`GOTRACEBACK`运行时优化。我们还了解了`GOBUILDCACHE`和Go依赖项的供应。最后，我们学习了调试和从代码中调用运行时函数。在排除Go代码问题时使用这些技术将帮助您更容易地发现问题和瓶颈。
- en: In the next chapter, we will discuss the proper way to deploy Go code effectively.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论有效部署Go代码的正确方法。
