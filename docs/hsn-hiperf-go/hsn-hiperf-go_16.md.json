["```go\nTrace = \"gotrace\" Version {Event} .\n\nEvent = EventProcStart | EventProcStop | EventFreq | EventStack | EventGomaxprocs | EventGCStart | EventGCDone | EventGCScanStart | EventGCScanDone | EventGCSweepStart | EventGCSweepDone | EventGoCreate | EventGoStart | EventGoEnd | EventGoStop | EventGoYield | EventGoPreempt | EventGoSleep | EventGoBlock | EventGoBlockSend | EventGoBlockRecv | EventGoBlockSelect | EventGoBlockSync | EventGoBlockCond | EventGoBlockNet | EventGoUnblock | EventGoSysCall | EventGoSysExit | EventGoSysBlock | EventUser | EventUserStart | EventUserEnd .\n\nEventProcStart = \"\\x00\" ProcID MachineID Timestamp .\nEventProcStop = \"\\x01\" TimeDiff .\nEventFreq = \"\\x02\" Frequency .\nEventStack = \"\\x03\" StackID StackLen {PC} .\nEventGomaxprocs = \"\\x04\" TimeDiff Procs .\nEventGCStart = \"\\x05\" TimeDiff StackID .\nEventGCDone = \"\\x06\" TimeDiff .\nEventGCScanStart= \"\\x07\" TimeDiff .\nEventGCScanDone = \"\\x08\" TimeDiff .\nEventGCSweepStart = \"\\x09\" TimeDiff StackID .\nEventGCSweepDone= \"\\x0a\" TimeDiff .\nEventGoCreate = \"\\x0b\" TimeDiff GoID PC StackID .\nEventGoStart = \"\\x0c\" TimeDiff GoID .\nEventGoEnd = \"\\x0d\" TimeDiff .\nEventGoStop = \"\\x0e\" TimeDiff StackID .\nEventGoYield = \"\\x0f\" TimeDiff StackID .\nEventGoPreempt = \"\\x10\" TimeDiff StackID .\nEventGoSleep = \"\\x11\" TimeDiff StackID .\nEventGoBlock = \"\\x12\" TimeDiff StackID .\nEventGoBlockSend= \"\\x13\" TimeDiff StackID .\nEventGoBlockRecv= \"\\x14\" TimeDiff StackID .\nEventGoBlockSelect = \"\\x15\" TimeDiff StackID .\nEventGoBlockSync= \"\\x16\" TimeDiff StackID .\nEventGoBlockCond= \"\\x17\" TimeDiff StackID .\nEventGoBlockNet = \"\\x18\" TimeDiff StackID .\nEventGoUnblock = \"\\x19\" TimeDiff GoID StackID .\nEventGoSysCall = \"\\x1a\" TimeDiff StackID .\nEventGoSysExit = \"\\x1b\" TimeDiff GoID .\nEventGoSysBlock = \"\\x1c\" TimeDiff .\nEventUser = \"\\x1d\" TimeDiff StackID MsgLen Msg .\nEventUserStart = \"\\x1e\" TimeDiff StackID MsgLen Msg .\nEventUserEnd = \"\\x1f\" TimeDiff StackID MsgLen Msg .\n```", "```go\npackage main\n\nimport (\n    \"os\"\n    \"runtime/trace\"\n)\n```", "```go\nfunc main() {\n\n    f, err := os.Create(\"trace.out\")\n    if err != nil {\n        panic(err)\n    } \n\n    defer f.Close()\n```", "```go\n    err = trace.Start(f)\n    if err != nil {\n        panic(err)\n    } \n\n    defer trace.Stop()\n```", "```go\n    ch := make(chan string)\n    go func() {\n        ch <- \"Hi Gophers\"\n    }()\n    <-ch\n}\n```", "```go\npackage main\n\nimport (\n    \"io\"\n    \"net/http\"\n    _ \"net/http/pprof\"\n    \"time\"\n)\n\n```", "```go\nfunc main() {\n\n   handler := func(w http.ResponseWriter, req *http.Request) {\n       time.Sleep(5 * time.Second)\n       io.WriteString(w, \"Network Trace Profile Test\")\n    }\n\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":1234\", nil)\n}\n```", "```go\n$ pprof -http=:1235 ~/Downloads/io.profile\n```", "```go\ndocker pull redis:latest\n```", "```go\ndocker pull openzipkin/zipkin\n```", "```go\ndocker run -it -d -p 6379:6379 redis\n```", "```go\ndocker run -it -d -p 9411:9411 openzipkin/zipkin\n```", "```go\npackage main\n\nimport (\n\n    \"context\"\n    \"log\"\n    \"net/http\"\n    \"time\"\n\n    \"contrib.go.opencensus.io/exporter/zipkin\"\n    \"go.opencensus.io/trace\"\n    \"github.com/go-redis/redis\"\n    openzipkin \"github.com/openzipkin/zipkin-go\"\n    zipkinHTTP \"github.com/openzipkin/zipkin-go/reporter/http\"\n)\n\n```", "```go\nfunc tracingServer() {\n\n    l, err := openzipkin.NewEndpoint(\"oc-zipkin\", \"192.168.1.5:5454\")\n\n    if err != nil {\n        log.Fatalf(\"Failed to create the local zipkinEndpoint: %v\", err)\n\n    }\n\n    r := zipkinHTTP.NewReporter(\"http://localhost:9411/api/v2/spans\")\n    z := zipkin.NewExporter(r, l)\n    trace.RegisterExporter(z)\n    trace.ApplyConfig(trace.Config{DefaultSampler: trace.AlwaysSample()})\n\n}\n```", "```go\nfunc makeRequest(ctx context.Context, url string) string {\n    log.Printf(\"Retrieving URL\")\n    _, span := trace.StartSpan(ctx, \"httpRequest\")\n    defer span.End()\n    res, _ := http.Get(url)\n    defer res.Body.Close()\n    time.Sleep(100 * time.Millisecond)\n    log.Printf(\"URL Response : %s\", res.Status)\n    span.Annotate([]trace.Attribute{\n        trace.StringAttribute(\"URL Response Code\", res.Status),\n    }, \"HTTP Response Status Code:\"+res.Status)\n    time.Sleep(50 * time.Millisecond)\n    return res.Status\n}\n```", "```go\nfunc writeToRedis(ctx context.Context, key string, value string) {\n\n    log.Printf(\"Writing to Redis\")\n    _, span := trace.StartSpan(ctx, \"redisWrite\")\n    defer span.End()\n    client := redis.NewClient(&redis.Options{\n        Addr: \"localhost:6379\",\n        Password: \"\",\n        DB: 0,\n    })\n\n    err := client.Set(key, value, 0).Err()\n    if err != nil {\n        panic(err)\n    }\n}  \n```", "```go\nfunc main() {\n\n    tracingServer()\n    ctx, span := trace.StartSpan(context.Background(), \"main\")\n    defer span.End()\n    for i := 0; i < 10; i++ {\n        url := \"https://golang.org/\"\n        respStatus := makeRequest(ctx, url)\n        writeToRedis(ctx, url, respStatus)\n    }\n} \n```"]