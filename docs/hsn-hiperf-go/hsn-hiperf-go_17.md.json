["```go\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"math/rand\"\n\n  \"github.com/muesli/clusters\"\n  \"github.com/muesli/kmeans\"\n)\n```", "```go\nfunc createDataset(datasetSize int) clusters.Observations {\n  var dataset clusters.Observations\n  for i := 1; i < datasetSize; i++ {\n    dataset = append(dataset, clusters.Coordinates{\n      rand.Float64(),\n      rand.Float64(),\n    })\n  }\n  return dataset\n}\n```", "```go\nfunc printCluster(clusters clusters.Clusters) {\n  for i, c := range clusters {\n    fmt.Printf(\"\\nCluster %d center points: x: %.2f y: %.2f\\n\", i, c.Center[0], c.Center[1])\n    fmt.Printf(\"\\nDatapoints assigned to this cluster: : %+v\\n\\n\", c.Observations)\n  }\n}\n```", "```go\nfunc main() {\n\n  var clusterSize = 3\n  var datasetSize = 30\n  var thresholdSize = 0.01\n  rand.Seed(time.Now().UnixNano())\n  dataset := createDataset(datasetSize)\n  fmt.Println(\"Dataset: \", dataset)\n\n  km, err := kmeans.NewWithOptions(thresholdSize, kmeans.SimplePlotter{})\n  if err != nil {\n    log.Printf(\"Your K-Means configuration struct was not initialized properly\")\n  }\n\n  clusters, err := km.Partition(dataset, clusterSize)\n  if err != nil {\n    log.Printf(\"There was an error in creating your K-Means relation\")\n  }\n\n  printCluster(clusters)\n}\n\n```", "```go\npackage main\n\nimport (\n  \"log\"\n  \"time\"\n\n  \"gopkg.in/gomail.v2\"\n)\n\n```", "```go\nfunc main() {\n\n    log.Printf(\"Doing Work\")\n    log.Printf(\"Sending Emails!\")\n    go sendMail()\n    time.Sleep(time.Second)\n    log.Printf(\"Done Sending Emails!\")\n}\n```", "```go\nfunc sendMail() {\n    var sender = \"USERNAME@gmail.com\"\n    var recipient = \"RECIPIENT@gmail.com\"\n    var username = \"USERNAME@gmail.com\"\n    var password = \"PASSWORD\"\n    var host = \"smtp.gmail.com\"\n    var port = 587 \n\n    email := gomail.NewMessage()\n    email.SetHeader(\"From\", sender)\n    email.SetHeader(\"To\", recipient)\n    email.SetHeader(\"Subject\", \"Test Email From Goroutine\")\n    email.SetBody(\"text/plain\", \"This email is being sent from a Goroutine!\")\n\n    dialer := gomail.NewDialer(host, port, username, password)\n    err := dialer.DialAndSend(email)\n    if err != nil {\n        log.Println(\"Could not send email\")\n        panic(err)\n    }   \n}\n```", "```go\npackage main\n\nimport (\n  \"log\"\n  \"net/http\"\n)\n\nconst queueSize = 50\nconst workers = 10\nconst port = \"1234\"\n```", "```go\ntype job struct {\n  name string\n  payload string\n}\n```", "```go\nfunc runJob(id int, individualJob job) {\n  log.Printf(\"Worker %d: Completed: %s with payload %s\", id, individualJob.name, individualJob.payload)\n}\n\n```", "```go\nfunc main() {\n  jobQueue := make(chan job, queueSize)\n  for i := 1; i <= workers; i++ {\n    go func(i int) {\n      for j := range jobQueue {\n        runJob(i, j)\n      }\n    }(i)\n\n  }\n\n```", "```go\nhttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    submittedJob := job{r.FormValue(\"name\"), r.FormValue(\"payload\")}\n    jobQueue <- submittedJob\n  })\n\n  http.ListenAndServe(\":\"+port, nil)\n}\n```", "```go\nfor i in {1..15}; do curl localhost:1234/ -d id=$i -d name=job$i -d payload=\u201dHi from Job $i\u201d; done\n```", "```go\n#!/bin/bash\nrm -rf kafka_2.12-2.3.0\nwget -c http://apache.cs.utah.edu/kafka/2.3.0/kafka_2.12-2.3.0.tgz\ntar xvf kafka_2.12-2.3.0.tgz\n./kafka_2.12-2.3.0/bin/zookeeper-server-start.sh kafka_2.12-2.3.0/config/zookeeper.properties &\n./kafka_2.12-2.3.0/bin/kafka-server-start.sh kafka_2.12-2.3.0/config/server.properties\nwait\n```", "```go\n./testKafka.sh\n```", "```go\npackage main\n\nimport (\n  \"context\"\n  \"fmt\"\n  \"log\"\n  \"time\"\n\n  \"github.com/segmentio/kafka-go\"\n)\n```", "```go\nfunc main() {\n    var topic = \"go-example\"\n    var partition = 0 \n    var connectionType = \"tcp\"\n    var connectionHost = \"0.0.0.0\"\n    var connectionPort = \":9092\"\n\n    connection, err := kafka.DialLeader(context.Background(), connectionType,              \n      connectionHost+connectionPort, topic, partition)\n    if err != nil {\n        log.Fatal(err)\n    } \n    connection.SetWriteDeadline(time.Now().Add(10 * time.Second))\n\n    for i := 0; i < 10; i++ {\n        connection.WriteMessages(\n            kafka.Message{Value: []byte(fmt.Sprintf(\"Message : %v\", i))},\n        )\n    }\n\n    connection.Close()\n} \n```", "```go\npackage main\nimport (\n    \"context\"\n    \"fmt\"\n    \u201clog\u201d\n    \"time\"\n    \"github.com/segmentio/kafka-go\"\n)\n\n```", "```go\nfunc main() {\n\n    var topic = \"go-example\"\n    var partition = 0\n    var connectionType = \"tcp\"\n    var connectionHost = \"0.0.0.0\"\n    var connectionPort = \":9092\"\n\n    connection, err := kafka.DialLeader(context.Background(), connectionType,  \n      connectionHost+connectionPort, topic, partition)\n    if err != nil {\n        log.Fatal(\"Could not create a Kafka Connection\")\n    }\n\n```", "```go\n  connection.SetReadDeadline(time.Now().Add(1 * time.Second))\n  readBatch := connection.ReadBatch(500, 500000)\n\n  byteString := make([]byte, 500)\n  for {\n    _, err := readBatch.Read(byteString)\n    if err != nil {\n        break\n    }\n    fmt.Println(string(byteString))\n  }\n\n  readBatch.Close()\n  connection.Close()\n}\n```", "```go\n./kafka_2.12-2.3.0/bin/kafka-server-stop.sh\n./kafka_2.12-2.3.0/bin/zookeeper-server-stop.sh\n```", "```go\ndocker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3-management\n```", "```go\npackage main\n\nimport (\n  \"log\"\n\n  \"github.com/streadway/amqp\"\n)\n\nfunc main() {\n    var username = \"guest\"\n    var password = \"guest\"\n    var protocol = \"amqp://\"\n    var host = \"0.0.0.0\"\n    var port = \":5672/\"\n    var queueName = \"go-queue\"\n\n```", "```go\n  connectionString := protocol + username + \":\" + password + \"@\" + host + port\n  connection, err := amqp.Dial(connectionString)\n  if err != nil {\n    log.Printf(\"Could not connect to Local RabbitMQ instance on \" + host)\n  }\n  defer connection.Close()\n\n  ch, err := connection.Channel()\n  if err != nil {\n    log.Printf(\"Could not connect to channel\")\n  }\n  defer ch.Close()\n```", "```go\n  queue, err := ch.QueueDeclare(queueName, false, false, false, false, nil)\n  if err != nil {\n    log.Printf(\"Could not declare queue : \" + queueName)\n  }\n\n  messages, err := ch.Consume(queue.Name, \"\", true, false, false, false, nil)\n  if err != nil {\n    log.Printf(\"Could not register a consumer\")\n  }\n\n  listener := make(chan bool)\n\n  go func() {\n    for i := range messages {\n      log.Printf(\"Received message: %s\", i.Body)\n    }\n  }()\n\n  log.Printf(\"Listening for messages on %s:%s on queue %s\", host, port, queueName)\n  <-listener\n}\n```", "```go\npackage main\n\nimport (\n  \"log\"\n\n  \"github.com/streadway/amqp\"\n)\n\nfunc main() {\n  var username = \"guest\"\n  var password = \"guest\"\n  var protocol = \"amqp://\"\n  var host = \"0.0.0.0\"\n  var port = \":5672/\"\n  var queueName = \"go-queue\"\n```", "```go\n  connectionString := protocol + username + \":\" + password + \"@\" + host + port\n  connection, err := amqp.Dial(connectionString)\n  if err != nil {\n    log.Printf(\"Could not connect to Local RabbitMQ instance on \" + host)\n  }\n  defer connection.Close()\n\n  ch, err := connection.Channel()\n  if err != nil {\n    log.Printf(\"Could not connect to channel\")\n  }\n  defer ch.Close()\n```", "```go\n  queue, err := ch.QueueDeclare(queueName, false, false, false, false, nil)\n  if err != nil {\n    log.Printf(\"Could not declare queue : \" + queueName)\n  }\n\n  messageBody := \"Hello Gophers!\"\n  err = ch.Publish(\"\", queue.Name, false, false,\n    amqp.Publishing{\n      ContentType: \"text/plain\",\n      Body: []byte(messageBody),\n    })\n  log.Printf(\"Message sent on queue %s : %s\", queueName, messageBody)\n  if err != nil {\n    log.Printf(\"Message not sent successfully on queue %s\", queueName, messageBody)\n  }\n}\n```"]