["```go\npackage main\nimport (\n    \"net/http\"\n    \"github.com/prometheus/client_golang/prometheus/promhttp\"\n\n)\n```", "```go\nfunc main() {\n    mux := http.NewServeMux()\n    mux.Handle(\"/metrics\", promhttp.Handler())\n    http.ListenAndServe(\":1234\", mux)\n}\n```", "```go\nGOOS=linux go build promExporter.go\n```", "```go\ndocker network create prometheus\n```", "```go\ndocker build -t promexporter -f Dockerfile.promExporter .\n```", "```go\ndocker run -it --rm --name promExporter -d -p 1234:1234 --net prometheus promexporter\n```", "```go\nFROM prom/prometheus\nADD prometheus.yml /etc/prometheus/\n```", "```go\ndocker build -t prom -f Dockerfile.promservice .\n```", "```go\ndocker run -it --rm --name prom -d -p 9090:9090 --net prometheus prom\n```", "```go\nfor i in {1..10}; do curl -s localhost:1234/metrics -o /dev/null; done\n```", "```go\nexport GOOGLE_APPLICATION_CREDENTIALS=/home/bob/service-accounts-private-key.json\n```", "```go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"time\"\n\n    \"contrib.go.opencensus.io/exporter/stackdriver\"\n\n    \"go.opencensus.io/trace\"\n\n)\n\nconst server = \":1234\"\n```", "```go\nfunc init() {\n\n    exporter, err := stackdriver.NewExporter(stackdriver.Options{\n       ProjectID: os.Getenv(\"GOOGLE_CLOUD_PROJECT\"),\n    })\n\n    if err != nil {\n       log.Fatal(\"Can't initialize GOOGLE_CLOUD_PROJECT environment    \n         variable\", err)\n\n    }\n\n    trace.RegisterExporter(exporter)\n    trace.ApplyConfig(trace.Config{DefaultSampler:   \n      trace.AlwaysSample()})\n\n}\n```", "```go\nfunc sleep(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n    _, span := trace.StartSpan(ctx, \"sleep\")\n    defer span.End()\n    time.Sleep(1 * time.Second)\n    fmt.Fprintln(w, \"Done Sleeping\")\n}\n```", "```go\nfunc githubRequest(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n    _, span := trace.StartSpan(ctx, \"githubRequest\")\n    defer span.End()\n    res, err := http.Get(\"https://github.com\")\n    if err != nil {\n       log.Fatal(err)\n    }\n\n    res.Body.Close()\n    fmt.Fprintln(w, \"Request to https://github.com completed with a status of: \", res.Status)\n    span.End()\n}\n```", "```go\nfunc main() {\n\n    h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\n       ctx, span := trace.StartSpan(context.Background(), \"function/main\")\n       defer span.End()\n       githubRequest(ctx, w, r)\n       sleep(ctx, w, r)\n    })\n\n    http.Handle(\"/\", h)\n    log.Printf(\"serving at : %s\", server)\n    err := http.ListenAndServe(server, nil)\n\n    if err != nil {\n       log.Fatal(\"Couldn't start HTTP server: %s\", err)\n    }\n}\n```", "```go\ngo get -u github.com/rakyll/hey\n```", "```go\ndocker build -t slislo -f Dockerfile.promservice .\ndocker run -it --rm --name slislo -d -p 9090:9090 --net host slislo\n```", "```go\npackage main\n\nimport (\n    \"math/rand\"\n    \"net/http\"\n    \"time\"\n\n    \"github.com/prometheus/client_golang/prometheus\"\n    \"github.com/prometheus/client_golang/prometheus/promhttp\"\n\n)\n```", "```go\n    saturation := prometheus.NewGauge(prometheus.GaugeOpts{\n       Name: \"saturation\",\n       Help: \"A gauge of the saturation golden signal\",\n    })\n\n    requests := prometheus.NewCounterVec(\n       prometheus.CounterOpts{\n           Name: \"requests\",\n           Help: \"A counter for the requests golden signal\",\n       },\n       []string{\"code\", \"method\"},\n    )\n\n    latency := prometheus.NewHistogramVec(\n       prometheus.HistogramOpts{\n           Name: \"latency\",\n           Help: \"A histogram of latencies for the latency golden \n            signal\",\n           Buckets: []float64{.025, .05, 0.1, 0.25, 0.5, 0.75},\n       },\n       []string{\"handler\", \"method\"},\n    )\n```", "```go\ngoldenSignalChain := promhttp.InstrumentHandlerInFlight\n (saturation,promhttp.InstrumentHandlerDuration\n (latency.MustCurryWith(prometheus.Labels{\"handler\": \"signals\"}),\n\n           promhttp.InstrumentHandlerCounter(requests, goldenSignalHandler),\n       ),\n    )\n```", "```go\n    prometheus.MustRegister(saturation, requests, latency)\n    http.Handle(\"/metrics\", promhttp.Handler())\n    http.Handle(\"/signals\", goldenSignalChain)\n    http.ListenAndServe(\":1234\", nil)\n}\n```", "```go\ndocker run  -it --rm --name grafana -d -p 3000:3000 --net prometheus grafana/grafana\n```", "```go\npackage main\n\nimport (\n    \"time\"\n    \"go.uber.org/zap\"\n\n)\n```", "```go\nfunc main() {\n\n    c := zap.NewProductionConfig()\n    c.OutputPaths = []string{\"stdout\"}\n    logger, _ := c.Build()\n\n    logger.Debug(\"We can use this logging level to debug. This won't be printed, as the NewProduction logger only prints info and above log levels.\")\n\n    logger.Info(\"This is an INFO message for your code. We can log individual structured things here\", zap.String(\"url\", \"https://reddit.com\"), zap.Int(\"connectionAttempts\", 3), zap.Time(\"requestTime\", time.Now()))\n\n    logger.Warn(\"This is a WARNING message for your code. It will not exit your program.\")\n\n    logger.Error(\"This is an ERROR message for your code. It will not exit your program, but it will print your error message -> \")\n\n    logger.Fatal(\"This is a Fatal message for your code. It will exit your program with an os.Exit(1).\")\n\n    logger.Panic(\"This is a panic message for your code. It will exit your program. We won't see this execute because we have already exited from the above logger.Fatal log message. This also exits with an os.Exit(1)\")\n\n}\n```"]