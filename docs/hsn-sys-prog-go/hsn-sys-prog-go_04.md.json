["```go\n <meta name=\"go-import\" content=\"package-name vcs repository-url\">\n```", "```go\nimport \"math/rand\"\n...\nrand.Intn\n```", "```go\nimport r \"math/rand\"\n...\nr.Intn\n```", "```go\nimport . \"math/rand\"\n...\nIntn\n```", "```go\nimport _ math/rand  \n// still executes the rand.init function\n```", "```go\ntype Message string    // custom string\ntype Counter int       // custom integer\ntype Number float32    // custom float\ntype Success bool      // custom boolean\n```", "```go\ntype StringDuo [2]string            // custom array   \ntype News chan string               // custom channel\ntype Score map[string]int           // custom map\ntype IntPtr *int                    // custom pointer\ntype Transform func(string) string  // custom function\ntype Result struct {                // custom struct\n    A, B int\n}\n```", "```go\ntype Broadcast Message // custom Message\ntype Timer Counter     // custom Counter\ntype News chan Message // custom channel of custom type Message\n```", "```go\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n```", "```go\ntype ReadCloser interface {\n    Reader \n    Closer \n}\n```", "```go\ntype ReadCloser interface {\n    Reader        // composition\n    Close() error // method\n}\n```", "```go\nvar a = 1             // this will be an int\nb := 1                // this is equivalent\nvar c int64 = 1       // this will be an int64\n\nvar d interface{} = 1 // this is declared as an interface{}\n```", "```go\na := new(int)                   // pointer of a new in variable\nsliceEmpty := make([]int, 0)    // slice of int of size 0, and a capacity of 0\nsliceCap := make([]int, 0, 10)  // slice of int of size 0, and a capacity of 10\nmap1 = make(map[string]int)     // map with default capacity\nmap2 = make(map[string]int, 10) // map with a capacity of 10\nch1 = make(chan int)            // channel with no capacity (unbuffered)\nch2 = make(chan int, 10)        // channel with capacity of 10 (buffered)\n```", "```go\ntype N [2]int                // User defined type\nvar n = N{1,2}\nvar m [2]int = [2]int(N)     // since N is a [2]int this casting is possible\n\nvar a = 3.14                 // this is a float64\nvar b int = int(a)           // numerical types can be casted, in this case a will be rounded to 3\n\nvar i interface{} = \"hello\"  // a new empty interface that contains a string\nx, ok := i.(int)             // ok will be false\ny := i.(int)                 // this will panic\nz, ok := i.(string)          // ok will be true\n```", "```go\nfunc main() {\n    var a interface{} = 10\n    switch a.(type) {\n    case int:\n        fmt.Println(\"a is an int\")\n    case string:\n        fmt.Println(\"a is a string\")\n    }\n}\n```", "```go\n// this exists in the outside block\nvar err error\n// this exists only in this block, shadows the outer err\nif err := errors.New(\"Doh!\"); err != \n    fmt.Println(err)           // this not is changing the outer err\n}\nfmt.Println(err)               // outer err has not been changed\n```", "```go\nconst PiApprox = 3.14\n\nvar PiInt int = PiApprox // 3, converted to integer\nvar Pi float64 = PiApprox // is a float\n\ntype MyString string\n\nconst Greeting = \"Hello!\"\n\nvar s1 string = Greeting   // is a string\nvar s2 MyString = Greeting // string is converted to MyString\n```", "```go\nfunc simpleFunc()\nfunc funcReturn() (a, b int)\nfunc funcArgs(a, b int)\nfunc funcArgsReturns(a, b int) error\n```", "```go\nfunc foo(a int) int {        // no variable for returned type\n    if a > 100 {\n        return 100\n    }\n    return a\n}\n\nfunc bar(a int) (b int) {    // variable for returned type\n    if a > 100 {\n        b = 100\n        return               // same as return b\n    }\n    return a\n}\n```", "```go\nvar a = func(item string) error { \n    if item != \"elixir\" {\n        return errors.New(\"Gimme elixir!\")\n    }\n    return nil \n}\n```", "```go\ntype A int\n\nfunc (a A) Foo() {}\n\nfunc main() {\n    A{}.Foo()  // Call the method on an instance of the type\n    A.Foo(A{}) // Call the method on the type and passing an instance as argument  \n}\n```", "```go\n// use error interface with chan\ntype ErrChan chan error\n// use error interface in a map\ntype Result map[string]error\n\ntype Printer interface{\n    Print()\n}\n// use the interface as argument\nfunc CallPrint(p Printer) {\n    p.Print()\n}\n```", "```go\ntype error interface {\n    Error() string\n}\n```", "```go\ntype ErrKey string\n\nfunc (e Errkey) Error() string {\n    returm fmt.Errorf(\"key %q not found\", e)\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype A int\n\nfunc (a A) Foo() {\n    a++\n    fmt.Println(\"foo\", a)\n}\n\nfunc main() {\n    var a A\n    fmt.Println(\"before\", a) // 0\n    a.Foo() // 1\n    fmt.Println(\"after\", a) // 0\n}\n```", "```go\ntype User struct {\n    Name string\n    Age int\n}\n\nfunc (u User) Birthday() {\n    u.Age++\n    fmt.Println(u.Name, \"turns\", u.Age)\n}\n\nfunc main() {\n    u := User{Name: \"Pietro\", Age: 30}\n    fmt.Println(u.Name, \"is now\", u.Age)\n    u.Birthday()\n    fmt.Println(u.Name, \"is now\", u.Age)\n}\n```", "```go\nfunc (u *User) Birthday() {\n    u.Age++\n    fmt.Println(u.Name, \"turns\", u.Age)\n}\n```", "```go\nfunc (u *User) Birthday() {\n    *u = User{Name: u.Name, Age: u.Age + 1}\n   fmt.Println(u.Name, \"turns\", u.Age)\n}\n```", "```go\nfunc (u *User) Birthday() {\n    u = &User{Name: u.Name, Age: u.Age + 1}\n    fmt.Println(u.Name, \"turns\", u.Age)\n}\n```", "```go\nstruct {\n    m *internalHashtable\n}\n```", "```go\nstruct {\n    array *internalArray \n    len int\n    cap int\n}\n```", "```go\nstruct {\n    c *internalChannel\n}\n```", "```go\nif r := a%10; r != 0 { // if with short declaration\n    if r > 5 {         // if without declaration \n        a -= r\n    } else if r < 5 {  // else if statement\n        a += 10 - r \n    }\n} else {               // else statement\n    a /= 10\n}\n```", "```go\nswitch tier {                        // switch statement\ncase 1:                              // case statement\n    fmt.Println(\"T-shirt\")\n    if age < 18{\n        break                        // exits the switch block\n    }\n    fallthrough                      // executes the next case\ncase 2:\n    fmt.Println(\"Mug\")\n    fallthrough                      // executes the next case \ncase 3:\n    fmt.Println(\"Sticker pack\")    \ndefault:                             // executed if no case is satisfied\n    fmt.Println(\"no reward\")\n}\n```", "```go\nfor {                    // infinite loop\n    if condition {\n        break            // exit the loop\n    }\n}\n\nfor i < 0 {              // loop with condition\n    if condition {\n        continue         // skip current iteration and execute next    \n    }\n}\n\nfor i:=0; i < 10; i++ {  // loop with declaration, condition and operation \n}\n```", "```go\nlabel:\n    for i := a; i<a+2; i++ {\n        switch i%3 {\n        case 0:\n            fmt.Println(\"divisible by 3\")\n            break label                          // this break the outer for loop\n        default:\n            fmt.Println(\"not divisible by 3\")\n        }\n    }\n```", "```go\nf, err := os.Open(\"config.txt\")\nif err != nil {\n    return err\n}\ndefer f.Close() // it will be closed anyways\n\n// do operation on f\n```", "```go\na := myType{}\ngo doSomething(a)     // function call\ngo func() {           // closure call\n    // ...\n}()                   // note that the closure is executed\ngo a.someMethod()     // method call\n```", "```go\nunbuf := make(chan int)    // unbuffered channel\nbuf := make(chan int, 3)   // channel with size 3\n```", "```go\nvar ch = make(chan int)\ngo func() {\n    b := <-ch        // receive and assign\n    fmt.Println(b)\n}()\nch <- 10             // send to channel\n```", "```go\nvar ch = make(chan int)\ngo func() {\n    b, ok := <-ch        // channel open, ok is true\n    b, ok = <-ch         // channel closed, ok is false\n    b <- ch              // channel close, b will be a zero value\n}()\nch <- 10                 // send to channel\nclose(ch)                // close the channel\n```", "```go\nvar ch1 = make(chan int)\nvar ch2 = make(chan int)\ngo func() { ch1 <- 10 }\ngo func() { <-ch2 }\nswitch {            // the first operation that completes is selected\ncase a := <-ch1:\n    fmt.Println(a)\ncase ch2 <- 20:\n    fmt.Println(b)    \n}\n```", "```go\nfunc main() {\n    var a, b = 0, 1\n    f1(a,b)\n    f2(a)\n}\n\nfunc f1(a, b int) {\n    c := a + b\n    f2(c)\n}\n\nfunc f2(c int) {\n    print(c)\n}\n```", "```go\n$ go env\nGOARCH=\"amd64\"\n...\nGOOS=\"linux\"\nGOPATH=\"/home/user/go\"\n...\nGOROOT=\"/usr/lib/go-1.12\"\n...\n```", "```go\n$ ls /home/user/go/pkg/\nlinux_amd64\n```", "```go\n# building the current package in the working directory\n$ go build . \n\n# building the current package in a specific location\n$ go build . -o \"/usr/bin/mybinary\"\n```", "```go\n$ go run main.go\nmain output line 1\nmain output line 2\n\n$\n```"]