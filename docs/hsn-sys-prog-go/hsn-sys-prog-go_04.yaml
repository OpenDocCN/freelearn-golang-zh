- en: An Overview of Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go概述
- en: This chapter will provide an overview of the Go language and its basic functionality.
    We will provide a short explanation of the language and its features, which we
    will elaborate on in more detail in the following chapters. This will help us
    to understand Go better while we're using all its features and applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将概述Go语言及其基本功能。我们将简要解释语言及其特性，并在接下来的章节中详细阐述。这将帮助我们更好地理解Go，同时使用其所有功能和应用。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Features of the language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言的特点
- en: Packages and imports
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包和导入
- en: Basic types, interfaces, and user-defined types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型、接口和用户定义类型
- en: Variables and functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和函数
- en: Flow control
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程控制
- en: Built-in functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置函数
- en: Concurrency model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发模型
- en: Memory management
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'From this chapter onward, you will need Go installed on your machine. Follow
    these steps to do this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，您需要在计算机上安装Go。按照以下步骤进行操作：
- en: Download the latest version of Go from [https://golang.org/dl/](https://golang.org/dl/).
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://golang.org/dl/](https://golang.org/dl/)下载Go的最新版本。
- en: Extract it with `tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz`进行提取。
- en: Add it to `PATH` with `export PATH=$PATH:/usr/local/go/bin`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`export PATH=$PATH:/usr/local/go/bin`将其添加到`PATH`中。
- en: Ensure that Go is installed with `go version`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保使用`go version`安装了Go。
- en: Add the export statement in your `.profile` to add it automatically.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`.profile`中添加export语句以自动添加。
- en: You can also change the `GOPATH` variable (the default one is `~/go`) if you
    want to use a different directory for your code.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要使用不同的目录来存放代码，也可以更改`GOPATH`变量（默认为`~/go`）。
- en: I also recommend installing Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    with its vscode-go ([https://github.com/Microsoft/vscode-go](https://github.com/Microsoft/vscode-go))
    extension, which contains a helper that will install all the tools that are needed
    to improve the Go development experience.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议安装Visual Studio Code（https://code.visualstudio.com/）及其vscode-go（https://github.com/Microsoft/vscode-go）扩展，其中包含一个助手，可安装所有需要改进Go开发体验的工具。
- en: Language features
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言特性
- en: Go is a modern server language with great concurrency primitives and a memory
    system that is mostly automated. It is considered by some to be a successor to
    C, and it manages to do so in many scenarios because it's performant, has an extensive
    standard library, and has a great community that provides many third-party libraries
    which cover, extend, and improve its functionalities.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种具有出色并发原语和大部分自动化内存系统的现代服务器语言。一些人认为它是C的继任者，并且在许多场景中都能做到这一点，因为它的性能良好，具有广泛的标准库，并且有一个提供许多第三方库的伟大社区，这些库涵盖、扩展和改进了其功能。
- en: History of Go
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go的历史
- en: Go was created in 2007 in order to try and address Google's engineering problems,
    and was publicly announced in 2009, reaching version 1.0 in 2012\. The major version
    is still the same (version 1), while the minor version grows (version 1.1, 1.2,
    and so on) together with its functionalities. This is done to keep Go's promise
    of compatibility for all major versions. A draft for two new features (generics
    and error handling), which will probably be included in version 2.0, were presented
    in 2018.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Go是在2007年创建的，旨在解决Google的工程问题，并于2009年公开宣布，2012年达到1.0版本。主要版本仍然相同（版本1），而次要版本（版本1.1、1.2等）随着其功能一起增长。这样做是为了保持Go对所有主要版本的兼容性承诺。2018年提出了两个新功能（泛型和错误处理）的草案，这些功能可能会包含在2.0版本中。
- en: 'The minds behind Go are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Go背后的大脑如下：
- en: '**Robert Griesemer**: A Google researcher who worked on many projects, including
    V8 JavaScript engine and design, and the implementation of Sawzall.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Robert Griesemer**：谷歌研究员，参与了许多项目，包括V8 JavaScript引擎和设计，以及Sawzall的实现。'
- en: '**Rob Pike**: A member of the Unix team, the Plan 9 and Inferno OS development
    team, and the Limbo programming language design team.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rob Pike**：Unix团队成员，Plan 9和Inferno操作系统开发团队成员，Limbo编程语言设计团队成员。'
- en: '**Ken Thompson**: A pioneer of computer science, the designer of the original
    Unix, and inventor of B (direct predecessor of C). Ken was also one of the creators
    and early developers of the Plan 9 operating system.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ken Thompson**：计算机科学的先驱，原始Unix的设计者，B语言的发明者（C的前身）。Ken还是Plan 9操作系统的创造者和早期开发者之一。'
- en: Strengths and weaknesses
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优势和劣势
- en: 'Go is a very opinionated language; some people love it while some people hate
    it, mostly due to some of its design choices. Some of the features that have not
    been well received are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种非常有主见的语言；有些人喜欢它，有些人讨厌它，主要是由于其一些设计选择。以下是一些未受好评的功能：
- en: Verbose error handling
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冗长的错误处理
- en: Lack of generics
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏泛型
- en: Missing dependency and version management
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少依赖和版本管理
- en: The first two points will be addressed with the next major version, while the
    latter was addressed by the community first (godep, glide, and govendor) and by
    Google itself with dep for the dependencies, and by gopkg.in ([http://labix.org/gopkg.in](http://labix.org/gopkg.in))) in
    terms of version management.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前两点将在下一个主要版本中解决，而后者首先由社区（godep、glide和govendor）和Google自己（dep用于依赖项）以及gopkg.in（http://labix.org/gopkg.in）在版本管理方面解决。
- en: 'The strengths of the language are countless:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的优势是无数的：
- en: It's a statically typed language, with all the advantages that this brings,
    like static type checking.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种静态类型的语言，具有静态类型检查等带来的所有优势。
- en: It does not require an **integrated development environment** (**IDE**), even
    if it supports many of them.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不需要集成开发环境（IDE），即使它支持许多IDE。
- en: The standard library is really impressive, and it could be the only dependency
    of many projects.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库非常强大，对许多项目来说可能是唯一的依赖项。
- en: It has concurrency primitives (channels and goroutines), which hides the hardest
    parts of writing asynchronous code that are both efficient and safe.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有并发原语（通道和goroutines），隐藏了编写高效且安全的异步代码的最困难部分。
- en: It comes with a formatting tool, `gofmt`, that unifies the format of Go code,
    making other people's code look really familiar.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它配备了一个格式化工具`gofmt`，统一了Go代码的格式，使其他人的代码看起来非常熟悉。
- en: It produces binaries, with no dependencies, making deployments fast and easy.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它生成没有依赖的二进制文件，使部署快速简便。
- en: It's minimalistic and has a few keywords, and the code is really easy to read
    and understand.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是极简主义的，关键字很少，代码非常容易阅读和理解。
- en: It's duck typed, with implicit interface definition (*if it walks like a duck,
    swims like a duck, and quacks like a duck, then it probably is a duck*). This
    comes in very handy when testing a specific function of a system because it can
    be mocked.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是鸭子类型的，具有隐式接口定义（*如果它走起来像鸭子，游泳像鸭子，嘎嘎叫像鸭子，那么它可能就是鸭子*）。这在测试系统的特定功能时非常方便，因为它可以被模拟。
- en: It is cross platform, meaning that it's able to produce binaries for architecture
    and OS that are different from the hosting ones.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是跨平台的，这意味着它能够为与托管平台不同的架构和操作系统生成二进制文件。
- en: There are a huge amount of third-party packages and so it leaves very little
    behind in terms of functionality. Each package that's hosted on a public repository
    is indexed and searchable.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有大量的第三方包，因此在功能方面留下了很少。托管在公共存储库上的每个包都是可索引和可搜索的。
- en: Namespace
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'Now, let''s see how Go code is organized. The `GOPATH` environment variable determines
    where the code resides. There are three subdirectories inside this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Go代码是如何组织的。`GOPATH`环境变量决定了代码的位置。里面有三个子目录：
- en: '`src` contains all the source code.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`包含所有源代码。'
- en: '`pkg` contains compiled packages, which are divided into architecture/OS.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg`包含已编译的包，分为架构/操作系统。'
- en: '`bin` contains the compiled binaries.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin`包含编译后的二进制文件。'
- en: The path under the source folder corresponds to the name of the package (`$GOPATH/src/my/package/name`
    would be `my/package/name`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件夹下的路径对应包的名称（`$GOPATH/src/my/package/name`将是`my/package/name`）。
- en: 'The `go get` command makes it possible to fetch and compile packages using
    it. Go get calls to `http://package_name?go-get=1` and if it finds the `go-import` meta
    tag, it uses this to fetch the package. The tag should contain the package name,
    the VCS that was used, and the repository URL, all separated by a space. Let''s
    take a look at an example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get`命令使得可以使用它来获取和编译包。`go get`调用`http://package_name?go-get=1`，如果找到`go-import`元标签，就会使用它来获取包。该标签应包含包名称、使用的VCS和存储库URL，所有这些都用空格分隔。让我们看一个例子：'
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After `go get` downloads a package, it tries to do the same for the other packages
    it can't resolve recursively until all the necessary source code is available.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get`下载一个包后，它会尝试对其他无法递归解析的包执行相同的操作，直到所有必要的源代码都可用。'
- en: Each file starts with a package definition, that is, `package package_name`,
    that needs to be the same for all the files in a directory. If the package produces
    a binary, the package is `main`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件都以`package`定义开头，即`package package_name`，需要对目录中的所有文件保持一致。如果包生成一个二进制文件，那么包就是`main`。
- en: Imports and exporting symbols
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入和导出符号
- en: The package declaration is followed by a series of `import` statements that
    specify the packages that are needed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 包声明后是一系列`import`语句，指定所需的包。
- en: Importing packages that are not used (unless they are ignored) is a compilation
    error, which is why the Go formatting tool, `gofmt`, removes unused packages.
    There are experimental or community tools like goimports ([https://godoc.org/golang.org/x/tools/cmd/goimports](https://godoc.org/golang.org/x/tools/cmd/goimports)) or goreturns
    ([https://github.com/sqs/goreturns](https://github.com/sqs/goreturns)) that also
    add missing imports to a Go file. It's important to avoid having circular dependencies
    because they will not compile.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 导入未使用的包（除非它们被忽略）是编译错误，这就是为什么Go格式化工具`gofmt`会删除未使用的包。还有一些实验性或社区工具，如goimports ([https://godoc.org/golang.org/x/tools/cmd/goimports](https://godoc.org/golang.org/x/tools/cmd/goimports))或goreturns
    ([https://github.com/sqs/goreturns](https://github.com/sqs/goreturns))，也会向Go文件添加丢失的导入。避免循环依赖非常重要，因为它们将无法编译。
- en: Since circular dependencies are not allowed, the packages need to be designed
    differently to other languages. In order to break the circular dependency, it
    is good practice to export functionalities from a package or replace the dependency
    with an interface.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不允许循环依赖，包需要与其他语言设计不同。为了打破循环依赖，最好的做法是从一个包中导出功能，或者用接口替换依赖关系。
- en: Go reduces all the symbol visibility to a binary model – exported and not exported –
    unlike many other languages, which have intermediate levels. For each package, all
    the symbols starting with a capital letter are exported, while everything else
    is used only inside the package. The exported values can also be used by other
    packages, while the unexported ones can only be used in the package itself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Go将所有符号可见性减少到一个二进制模型 - 导出和未导出 - 不像许多其他语言有中间级别。对于每个包，所有以大写字母开头的符号都是导出的，而其他所有内容只能在包内部使用。导出的值也可以被其他包使用，而未导出的值只能在包内部使用。
- en: 'An exception is made if one of the package path elements is internal (for example, `my/package/internal/pdf`).
    This limits itself and its subpackages to be imported only by the nearby packages
    (for example, `my/package`). This is useful if there are a lot of unexported symbols
    and you want to break them down into subpackages, while preventing other packages
    from using it, making basically private subpackages. Take a look at the following
    list of internal packages:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例外是，如果包路径中的一个元素是`internal`（例如`my/package/internal/pdf`），这将限制它及其子包只能被附近的包导入（例如`my/package`）。如果有很多未导出的符号，并且希望将它们分解为子包，同时阻止其他包使用它，这将非常有用，基本上是私有子包。看一下以下内部包的列表：
- en: '`my/package/internal`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my/package/internal`'
- en: '`my/package/internal/numbers`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my/package/internal/numbers`'
- en: '`my/package/internal/strings`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my/package/internal/strings`'
- en: These can only be used by `my/package`, and cannot be imported by any other
    package, including `my`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只能被`my/package`使用，不能被任何其他包导入，包括`my`。
- en: 'The import can have different forms. The standard import form is the complete
    package name:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 导入可以有不同的形式。标准导入形式是完整的包名称：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A named import replaces the package name with a custom name, which must be
    used when referencing the package:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 命名导入将包名称替换为自定义名称，引用包时必须使用该名称：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The same package import makes the symbol available with no namespace:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的包导入使符号可用，而无需命名空间：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Ignored imports are used to import packages without you having to use them.
    This makes it possible to execute the `init` function of the package without referencing
    the package in your code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略的导入用于导入包，而无需使用它们。这使得可以在不在代码中引用包的情况下执行包的`init`函数：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Type system
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型系统
- en: The Go type system defines a series of basic types, including bytes, strings
    and buffers, composite types like slices or maps, and custom types that have been
    defined by the application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Go类型系统定义了一系列基本类型，包括字节，字符串和缓冲区，复合类型如切片或映射，以及应用程序定义的自定义类型。
- en: Basic types
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型
- en: 'These are Go''s basic types:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Go的基本类型：
- en: '| **Category** | **Types** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **类型** |'
- en: '| String | `string` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `string` |'
- en: '| Boolean | `bool` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | `bool` |'
- en: '| Integer | `int`, `int8`, `int16`, `int32`, and `int64` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | `int`，`int8`，`int16`，`int32`和`int64` |'
- en: '| Unsigned integer | `uint`,  `uint8`, `uint16`, `uint32`, and `uint64` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 无符号整数 | `uint`，`uint8`，`uint16`，`uint32`和`uint64` |'
- en: '| Pointer integer | `uinptr` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 整数指针 | `uinptr` |'
- en: '| Floating pointer | `float32` and `float64` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | `float32`和`float64` |'
- en: '| Complex number | `complex64` and `complex128` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 复数 | `complex64`和`complex128` |'
- en: The number of bits of `int`, `uint`, and `uiptr` depends on the architecture
    (for example, 32 bits for x86, 64 bits for x86_64).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`，`uint`和`uiptr`的位数取决于架构（例如，x86为32位，x86_64为64位）。'
- en: Composite types
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合类型
- en: 'Beside the basic types, there are others, which are known as composite types.
    These are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本类型外，还有其他类型，称为复合类型。它们如下：
- en: '| **Type** | **Description** | **Example** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **描述** | **示例** |'
- en: '| Pointer | The address in the memory of a variable | `*int` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 指针 | 变量在内存中的地址 | `*int` |'
- en: '| Array | A container of the element of the same type with a fixed length |
    `[2]int` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | 具有固定长度的相同类型元素的容器 | `[2]int` |'
- en: '| Slice | Contiguous segment of an array | `[]int` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 切片 | 数组的连续段 | `[]int` |'
- en: '| Map | Dictionary or associative array | `map[int]int` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 映射 | 字典或关联数组 | `map[int]int` |'
- en: '| Struct | A collection of fields that can have different types | `struct{
    value int }` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 结构体 | 可以具有不同类型字段的集合 | `struct{ value int }` |'
- en: '| Function | A set of functions with the same parameters and output | `func(int,
    int) int` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 具有相同参数和输出的一组函数 | `func(int, int) int` |'
- en: '| Channel | Type pipes that are used for the communication of elements of the
    same type | `chan int` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 通道 | 用于通信相同类型元素的管道 | `chan int` |'
- en: '| Interface | A specific collection of methods, with an underlying value that
    supports them | `interface{}` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 一组特定的方法，具有支持它们的基础值 | `interface{}` |'
- en: The empty interface, `interface{}`, is a generic type that can contain any value.
    Since this interface has no requirements (methods), it can be satisfied by any
    value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 空接口`interface{}`是一个通用类型，可以包含任何值。由于此接口没有要求（方法），因此可以满足任何值。
- en: 'Interfaces, pointers, slices, functions, channels, and maps can have a void
    value, which is represented in Go by `nil`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接口，指针，切片，函数，通道和映射可以具有空值，在Go中用`nil`表示：
- en: Pointers are self-explanatory; they are not referring to any variable address.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针是不言自明的；它们不指向任何变量地址。
- en: The interface's underlying value can be empty.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口的基础值可以为空。
- en: Other pointer types, like slices or channels, can be empty.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他指针类型，如切片或通道，可以为空。
- en: Custom-defined types
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义定义的类型
- en: 'A package can define its own types by using the `type defined definition` expression,
    where definition is a type that shares a defined memory representation. Custom
    types can be defined by basic types:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 包可以通过使用`type defined definition`表达式定义自己的类型，其中定义是共享定义内存表示的类型。自定义类型可以由基本类型定义：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'They can also be defined by composite types like slices, maps, or pointers:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以由切片，映射或指针等复合类型定义：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'They can also be used in combination with other custom types:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以与其他自定义类型结合使用：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The main uses of custom types are to define methods and to make the type specific
    for a scope, like defining a `string` type called `Message`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型的主要用途是定义方法并使类型特定于范围，例如定义名为`Message`的`string`类型。
- en: 'Interface definitions work in a different way. They can be defined by specifying
    a series of different methods, for instance:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义的工作方式不同。可以通过指定一系列不同的方法来定义它们，例如：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'They can also be a composition of other interfaces:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以是其他接口的组合：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, they can be a combination of the two interfaces:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们可以是两个接口的组合：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Variables and functions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和函数
- en: Now that we've looked at types, we'll take a look at how we can instantiate
    different types in the language. We'll see how variables and constants work first,
    and then we'll talk about functions and methods.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看过了类型，我们将看看如何在语言中实例化不同的类型。我们将首先了解变量和常量的工作原理，然后再讨论函数和方法。
- en: Handling variables
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理变量
- en: Variables represent mapping to the content of a portion of contiguous memory.
    They have a type that defines how much this memory extends, and a value that specifies
    what's in the memory. Type can be basic, composite, or custom, and its value can
    be initialized with their zero-value by a declaration, or with another value by
    assignment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 变量表示映射到连续内存部分的内容。它们具有定义内存扩展量的类型，以及指定内存中内容的值。类型可以是基本类型，复合类型或自定义类型，其值可以通过声明初始化为零值，也可以通过赋值初始化为其他值。
- en: Declaration
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明
- en: The zero value declaration for a variable is done using the `var` keyword and
    by specifying the name and type; for example, `var a int`. This could be counter-intuitive
    for a person that comes from another language, like Java, where type and name
    order is inverted, but it's actually more human readable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 关键字和指定名称和类型来声明变量的零值；例如 `var a int`。对于来自其他语言（如 Java）的人来说，这可能有些反直觉，因为类型和名称的顺序是颠倒的，但实际上更易读。
- en: 'The `var a int` example describes a variable (`var`) with a name, `a`, that
    is an integer (`int`). This kind of expression creates a new variable with a zero-value
    for the selected type:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`var a int` 的例子描述了一个带有名称 `a` 的变量（`var`），它是一个整数（`int`）。这种表达式创建了一个新的变量，其选定类型的零值为：'
- en: '| **Type** | **Zero value** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **零值** |'
- en: '| Numerical types (`int`, `uint`, and `float` types) | `0` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 数值类型（`int`、`uint` 和 `float` 类型） | `0` |'
- en: '| Strings (`string` types) | `""` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 字符串（`string` 类型） | `""` |'
- en: '| Booleans | `false` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | `false` |'
- en: '| Pointers, interfaces, slices, maps, and channels | `nil` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 指针、接口、切片、映射和通道 | `nil` |'
- en: 'The other way of initiating a variable is by assignment, which can have an
    inferred or specific type. An inferred type is achieved with the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化变量的另一种方式是通过赋值，可以有推断类型或特定类型。通过以下方式实现推断类型：
- en: The variable name, followed by the `:=` operator and the value (for example, `a
    := 1`), also called **short declaration**.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名称，后跟 `:=` 运算符和值（例如 `a := 1`），也称为**短声明**。
- en: The `var` keyword, followed by the name, the `=` operator, and a value (for
    example, `var a = 1`).
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var` 关键字，后跟名称、`=` 运算符和一个值（例如 `var a = 1`）。'
- en: Note that these two methods are almost equivalent, and redundant, but the Go
    team decided to keep them both for the sake of the compatibility promise of Go
    1\. The main difference in terms of the short declaration is that the type cannot
    be specified and it's inferred by the value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两种方法几乎是等效的，也是多余的，但 Go 团队决定保留它们两者，以遵守 Go 1 的兼容性承诺。就短声明而言，主要区别在于类型不能被指定，而是由值推断出来。
- en: 'An assignment with a specific type is made with a declaration, followed by
    an equals sign and the value. This is very useful if the declared type is an interface,
    or if the type that''s inferred is incorrect. Here are some examples:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 具有特定类型的赋值是通过声明进行的，后跟等号和值。如果声明的类型是接口，或者推断的类型是不正确的，这将非常有用。以下是一些示例：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Some types need to use built-in functions so that they can be initialized correctly:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类型需要使用内置函数才能正确初始化：
- en: '`new` makes it possible to create a pointer of a certain type while already
    allocating some space for the underlying variable.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new` 可以创建某种类型的指针，同时为底层变量分配一些空间。'
- en: '`make` initializes slices, maps, and channels:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make` 初始化切片、映射和通道：'
- en: Slices need an extra argument for the size, and an optional one for the capacity
    of the underlying array.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片需要一个额外的参数用于大小，以及一个可选的参数用于底层数组的容量。
- en: Maps can have one argument for their initial capacity.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射可以有一个参数用于其初始容量。
- en: Channels can also have one argument for its capacity. They are unlike maps,
    which cannot change.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道也可以有一个参数用于其容量。它们不同于映射，映射不能改变。
- en: 'The initialization of a type using a built-in function is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置函数初始化类型的方法如下：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Operations
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作
- en: 'We already saw the assignment operation, which gives a new value to a variable
    using the `=` operator. Let''s take a look at few more operators:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了赋值操作，使用 `=` 运算符给变量赋予一个新值。让我们再看看一些运算符：
- en: There are the comparison operators, `==` and `!=`, which compare two values
    and return a Boolean.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有比较运算符 `==` 和 `!=`，用于比较两个值并返回一个布尔值。
- en: There are some mathematical operations that can be executed on all numerical
    variables of the same types, that is, `+`, `-`, `*`, and `/`. The sum operation
    is also used for concatenating strings. `++` and `--` are shorthand for incrementing
    or decrementing a number by one. `+=`, `-=`, `*=`, and `/=` execute the operation
    before the equals sign between what's before and what's after the operator and
    assigns it to the variable on the left. These four operations produce a value
    of the same type of the variables involved; there are also other comparison operators
    that are specific to numbers: `<`, `<=`, `>`, and `>=`.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些数学运算可以在相同类型的所有数字变量上执行，即 `+`、`-`、`*` 和 `/`。求和运算也用于连接字符串。`++` 和 `--` 是用于将数字增加或减少一的简写形式。`+=`、`-=`、`*=`
    和 `/=` 在等号之前执行操作，并将其赋给左边的变量。这四种运算产生与所涉及的变量相同类型的值；还有其他一些特定于数字的比较运算符：`<`、`<=`、`>`
    和 `>=`。
- en: Some operations are exclusive for integers and produce other integers: `%,` , `&`,
    `|`, `^`, `&^`, `<<`, and `>>`.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些运算仅适用于整数，并产生其他整数：`%`、`&`、`|`、`^`、`&^`、`<<` 和 `>>`。
- en: Others are just for Booleans and produce another Boolean: `&&`, `||`, and `!`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一些仅适用于布尔值的运算符，产生另一个布尔值：`&&`、`||` 和 `!`。
- en: One operator is channel only, `<-`, and it's used to receive values from or
    send them to a channel.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个运算符仅适用于通道，即 `<-`，用于从通道接收值或向通道发送值。
- en: 'For all non-pointer variables, it is also possible to use `&`, the reference
    operator, to obtain the variable address that can be assigned to a pointer variable.
    The `*` operator makes it possible to execute a dereference operation on a pointer
    and obtain the value of the variable indicated by it:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有非指针变量，也可以使用 `&`，即**引用运算符**，来获取可以分配给指针变量的变量地址。`*` 运算符使得可以对指针执行**解引用操作**，并获取其指示的变量的值：
- en: '| **Operator** | **Name** | **Description** | **Example** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **名称** | **描述** | **示例** |'
- en: '| `=` | Assignment | Assigns the value to a variable | `a = 10` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 赋值 | 将值赋给变量 | `a = 10` |'
- en: '| `:=` | Declaration and assignment | Declares a variables and assigns a value
    to it | `a := 0` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `:=` | 声明和赋值 | 声明一个变量并给它赋值 | `a := 0` |'
- en: '| `==` | Equals | Compares two variables, returns a Boolean if they are the
    same | `a == b` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 等于 | 比较两个变量，如果它们相同则返回布尔值 | `a == b` |'
- en: '| `!=` | Not equals | Compares two variables, returns a Boolean if they are
    different | `a != b` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 不等于 | 比较两个变量，如果它们不同则返回布尔值 | `a != b` |'
- en: '| `+` | Plus | Sum between the same numerical type | `a + b` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加 | 相同数值类型之间的求和 | `a + b` |'
- en: '| `-` | Minus | Difference between the same numerical type | `a - b` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 减 | 相同数值类型之间的差异 | `a - b` |'
- en: '| `*` | Times | Multiplication between the same numerical type | `a * b` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘 | 相同数值类型的乘法 | `a * b` |'
- en: '| `/` | Divided | Division between the same numerical type | `a / b` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除 | 相同数值类型之间的除法 | `a / b` |'
- en: '| `%` | Modulo | Remainder after division of the same numerical type | `a %
    b` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 取模 | 相同数值类型的除法后余数 | `a % b` |'
- en: '| `&` | AND | Bit-wise AND | `a & b` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 和 | 按位与 | `a & b` |'
- en: '| `&^` | Bit clear | Bit clear | `a &^ b` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `&^` | 位清除 | 位清除 | `a &^ b` |'
- en: '| `<<` | Left shift | Bit shift to the left | `a << b` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | 左移 | 位向左移动 | `a << b` |'
- en: '| `>>` | Right shift | Bit shift to the right | `a >> b` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | 右移 | 位向右移动 | `a >> b` |'
- en: '| `&&` | AND | Boolean AND | `a && b` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 和 | 布尔与 | `a && b` |'
- en: '| `&#124;&#124;` | OR | Boolean OR | `a &#124;&#124; b` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `||` | 或 | 布尔或 | `a || b` |'
- en: '| `!` | NOT | Boolean NOT | `!a` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 非 | 布尔非 | `!a` |'
- en: '| `<-` | Receive | Receive from a channel | `<-a` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `<-` | 接收 | 从通道接收 | `<-a` |'
- en: '| `->` | Send | Send to a channel | `a <- b` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `->` | 发送 | 发送到通道 | `a <- b` |'
- en: '| `&` | Reference | Returns the pointer to a variable | `&a` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 引用 | 返回变量的指针 | `&a` |'
- en: '| `*` | Dereference | Returns the content of a pointer | `*a` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 解引用 | 返回指针的内容 | `*a` |'
- en: Casting
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: 'Converting a type into another type is an operation called **casting**, which
    works slightly differently for interfaces and concrete types:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 将一种类型转换为另一种类型的操作称为**转换**，对于接口和具体类型的工作方式略有不同：
- en: Interfaces can be casted to a concrete type that implements it. This conversion
    can return a second value (a Boolean) and show whether the conversion was successful
    or not. If the Boolean variable is omitted, the application will panic on a failed
    casting.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口可以转换为实现它的具体类型。此转换可以返回第二个值（布尔值），并显示转换是否成功。如果省略布尔变量，则应用程序将在转换失败时出现恐慌。
- en: 'With concrete types, casting can happen between types that have the same memory
    structure, or it can happen between numerical types:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体类型之间可以发生类型转换，这些类型具有相同的内存结构，或者可以在数值类型之间发生转换：
- en: '[PRE13]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There''s a special type of conditional operator for casting called **type switch**
    which allows an application to attempt multiple casts at once. The following is
    an example of using `interface{}` to check out the underlying value:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的条件运算符用于转换，称为**类型开关**，它允许应用程序一次尝试多次转换。以下是使用`interface{}`检查底层值的示例：
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Scope
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: 'The variables have a scope or visibility that is also connected to its lifetime.
    This can be one of the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 变量具有作用域或可见性，这也与其生命周期相关。这可以是以下之一：
- en: '**Package**: The variable is visible in all the packages; if the variable is
    exported, it is also visible from other packages.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包**: 变量在所有包中可见；如果变量被导出，它也可以从其他包中可见。'
- en: '**Function**: The variable is visible inside the function that declares it.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**: 变量在声明它的函数内可见。'
- en: '**Control**: The variable is visible inside the block in which it''s defined.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制**: 变量在定义它的块内可见。'
- en: The visibility goes down, going from package to block. Since blocks can be nested,
    outer blocks don't have visibility over the variables of inner blocks.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性下降，从包到块。由于块可以嵌套，外部块对内部块的变量没有可见性。
- en: 'Two variables in the same scope cannot have the same name, but a variable of
    an inner scope can reuse an identifier. When this happens, the outer variable
    is not visible in the inner scope – this is called **shadowing**, and it needs
    to be kept in mind in order to avoid issues that are hard to identify, such as
    the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 同一作用域中的两个变量不能具有相同的名称，但内部作用域的变量可以重用标识符。当这种情况发生时，外部变量在内部作用域中不可见 - 这称为**遮蔽**，需要牢记以避免出现难以识别的问题，例如以下情况：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Constants
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: 'Go doesn''t have immutability for its variables, but defines another type of
    immutable value called constant. This is defined by the `const` keyword (instead
    of `var`), and they are values that cannot change. These values can be base types
    and custom types, which are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Go的变量没有不可变性，但定义了另一种不可变值的类型称为常量。这由`const`关键字定义（而不是`var`），它们是不能改变的值。这些值可以是基本类型和自定义类型，如下所示：
- en: Numeric (integer, `float`)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值（整数，`float`）
- en: Complex
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂
- en: String
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Boolean
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: 'The value that''s specified doesn''t have a type when it''s assigned to a variable.
    There''s an automatic conversion of both numeric types and string-based types,
    as shown in the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的值在分配给变量时没有类型。数值类型和基于字符串的类型都会自动转换，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Numerical constants are very useful for mathematical operations because they
    are just regular numbers, so they can be used with any numerical variable type.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 数值常量对数学运算非常有用，因为它们只是常规数字，所以可以与任何数值变量类型一起使用。
- en: Functions and methods
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和方法
- en: 'Functions in Go are identified by the `func` keyword, followed by an identifier,
    eventual arguments, and return values. Functions in Go can return more than one
    value at a time. The combination of arguments and returned types is referred to
    as a **signature**, as shown in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的函数由`func`关键字标识，后跟标识符、可能的参数和返回值。Go中的函数可以一次返回多个值。参数和返回类型的组合称为**签名**，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The part between brackets is the function body, and the `return` statement can
    be used inside it for an early interruption of the function. If the function returns
    values, then the return statement must return values of the same type.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的部分是函数体，`return`语句可以在其中用于提前中断函数。如果函数返回值，则`return`语句必须返回相同类型的值。
- en: 'The `return` values can be named in the signature; they are zero value variables
    and if the `return` statement does not specify other values, these values are
    the ones that are returned:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`值可以在签名中命名；它们是零值变量，如果`return`语句没有指定其他值，那么这些值就是返回的值：'
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Functions are first-class types in Go and they can also be assigned to variables,
    with each signature representing a different type. They can also be anonymous;
    in this case, they are called **closures**. Once a variable is initialized with
    a function, the same variable can be reassigned with another function with the
    same signature. Here''s an example of assigning a closure to a variable:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，函数是一级类型，它们也可以被分配给变量，每个签名代表不同的类型。它们也可以是匿名的；在这种情况下，它们被称为**闭包**。一旦一个变量被初始化为一个函数，相同的变量可以被重新分配为具有相同签名的另一个函数。以下是将闭包分配给变量的示例：
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The functions that are declared by an interface are referred to as methods and
    they can be implemented by custom types. The method implementation looks like
    a function, with the exception being that the name is preceded by a single parameter
    of the implementing type. This is just syntactic sugar – the method definition
    creates a function under the hood, which takes an extra parameter, that is, the
    type that implements the method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由接口声明的函数称为方法，它们可以由自定义类型实现。方法的实现看起来像一个函数，唯一的区别是名称前面有一个实现类型的单个参数。这只是一种语法糖——方法定义在幕后创建一个函数，它接受一个额外的参数，即实现方法的类型。
- en: 'This syntax makes it possible to define the same method for different types,
    each of which will act as a namespace for the function declaration. In this way,
    it is possible to call a method in two different ways, as shown in the following
    code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法使得可以为不同类型定义相同的方法，每个方法将作为函数声明的命名空间。通过这种方式，可以以两种不同的方式调用方法，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It''s important to note that a type and its pointer share the same namespace,
    so the same method can be implemented just for one of them. The same method cannot
    be defined for both the type and for its pointer, since declaring the method twice
    (for a type and its pointer) will produce a compile error (method redeclared). Methods
    cannot be defined for interfaces, only for concrete types, but interfaces can
    be used in composite types, including function parameters and return values, as
    we can see in the following examples:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，类型及其指针共享相同的命名空间，因此同一个方法只能为其中一个实现。同一个方法不能同时为类型和其指针定义，因为对于类型和其指针声明两次方法将产生编译错误（方法重复声明）。方法不能为接口定义，只能为具体类型定义，但接口可以用于复合类型，包括函数参数和返回值，如下面的示例所示：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The built-in package already defines an interface that is used all over the
    standard library and in all the packages that are available online – the `error` interface:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 内置包已经定义了一个接口，它在标准库中和所有在线可用的包中都被使用——`error`接口：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This means that whatever type has an `Error() string` method can be used as
    an error, and each package can define its error types according to its needs.
    This can be used to concisely carry information about the error. In this example,
    we are defining `ErrKey`, which is specifying that a `string` key was not found.
    We don''t need anything else besides the key to represent our error, as shown
    in the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何类型都可以使用`Error() string`方法作为错误，并且每个包都可以根据自己的需要定义其错误类型。这可以用来简洁地携带有关错误的信息。在这个例子中，我们定义了`ErrKey`，它指定了未找到`string`键。除了键之外，我们不需要任何其他东西来表示我们的错误，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Values and pointers
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值和指针
- en: 'In Go, everything is passed by a value, so when a function or method is invoked,
    a copy of the variable is made in the stack. This implies that changes that are
    made to the value are not reflected outside of the called function. Even slices,
    maps, and other reference types are passed by value, but since their internal
    structure contains pointers, they act as if they were passed by reference. If
    a method is defined for a type, it cannot be defined for its pointer and vice
    versa. The following example has been used to check that the value is updated
    only inside the method, and that the change does not reflect the `main` function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，一切都是按值传递的，所以当函数或方法被调用时，变量的副本会被放在堆栈中。这意味着对值所做的更改不会反映在被调用的函数之外。即使切片、映射和其他引用类型也是按值传递的，但由于它们的内部结构包含指针，它们的行为就像是按引用传递一样。如果为一种类型定义了一个方法，则不能为其指针定义该方法，反之亦然。下面的示例已经用来检查值只在方法内部更新，而这种更改不会反映在`main`函数中：
- en: '[PRE24]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In order to change the original variable, the argument must be a pointer to
    the variable itself – the pointer will be copied, but it will reference the same
    memory area, making it possible to change its value. Note that assigning another
    value pointer, instead of its content, doesn't change what the original pointer
    refers to because it is a copy.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改变原始变量，参数必须是指向变量本身的指针——指针将被复制，但它将引用相同的内存区域，从而可以改变其值。请注意，分配另一个值指针，而不是其内容，不会改变原始指针所引用的内容，因为它是一个副本。
- en: If we use a method for the type instead of its pointer, we won't see the changes
    being propagated outside the method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为类型而不是其指针使用方法，我们将看不到更改在方法外传播。
- en: 'In the following example, we are using a value receiver. This makes the `User` value
    in the `Birthday` method a copy of the `User` value in `main`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用了值接收器。这使得`Birthday`方法中的`User`值成为`main`中的`User`值的副本：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The full example is available at [https://play.golang.org/p/hnUldHLkFJY](https://play.golang.org/p/hnUldHLkFJY).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/hnUldHLkFJY](https://play.golang.org/p/hnUldHLkFJY)中找到。
- en: 'Since the change is applied to the copy, the original value is left intact,
    as we can see from the second print statement. If we want to change the value
    in the original object, we have to use the pointer receiver so that the one that''s
    been copied will be the pointer and the changes will be made to the underlying
    value:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更改是应用于副本的，原始值保持不变，正如我们从第二个打印语句中所看到的。如果我们想要更改原始对象中的值，我们必须使用指针接收器，这样被复制的对象将是指针，更改将被应用于底层值：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The full example is available at [https://play.golang.org/p/JvnaQL9R7U5](https://play.golang.org/p/JvnaQL9R7U5).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/JvnaQL9R7U5](https://play.golang.org/p/JvnaQL9R7U5)中找到。
- en: 'We can see that using the pointer receiver allows us to change the underlying
    value, and that we can change one field of the `struct` or replace the whole `struct`
    itself, as shown in the following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到使用指针接收器允许我们更改底层值，并且我们可以更改`struct`的一个字段或替换整个`struct`本身，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The full example is available at [https://play.golang.org/p/3ugBEZqAood](https://play.golang.org/p/3ugBEZqAood).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/3ugBEZqAood](https://play.golang.org/p/3ugBEZqAood)中找到。
- en: 'If we try to change the value of the pointer instead of the underlying one,
    we will edit a new object that is not related to the one that was created in `main`,
    and the changes will not propagate:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试更改指针的值而不是底层值，我们将编辑一个与在`main`中创建的对象无关的新对象，并且更改不会传播：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The full example is available at [https://play.golang.org/p/m8u2clKTqEU](https://play.golang.org/p/m8u2clKTqEU).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/m8u2clKTqEU](https://play.golang.org/p/m8u2clKTqEU)中找到。
- en: 'Some types in Go are automatically passed by reference. This happens because
    these types are defined internally as structs that contain a pointer. This creates
    a list of the types, along with their internal definition:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的一些类型是自动按引用传递的。这是因为这些类型在内部被定义为包含指针的结构。这创建了一个类型列表，以及它们的内部定义：
- en: '| **Types** | **Internal definitions** |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **内部定义** |'
- en: '| `map` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `map` |'
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `slice` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `slice` |'
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `channel` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `channel` |'
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Understanding flow control
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解流控制
- en: In order to control the flow of an application, Go offers different tools – some
    statements like `if`/`else`, `switch`, and `for` are used in sequential scenarios,
    whereas others like `go` and `select` are used in concurrent ones.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制应用程序的流程，Go提供了不同的工具 - 一些语句如`if`/`else`，`switch`和`for`用于顺序场景，而`go`和`select`等其他语句用于并发场景。
- en: Condition
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件
- en: 'The `if` statement verifies a binary condition and executes the code inside
    the `if` block when the condition is `true`. When an `else` block is present,
    it''s executed when the condition is `false`. This statement also allows a short
    declaration before the condition, separated by a `;`. This condition can be chained
    with an `else if` statement, as shown in the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句验证一个二进制条件，并在条件为`true`时执行`if`块内的代码。当存在`else`块时，当条件为`false`时执行。该语句还允许在条件之前进行短声明，用`；`分隔。这个条件可以与`else
    if`语句链接，如下面的代码所示：'
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The other condition statement is `switch`. This allows a short declaration,
    like `if`, and this is followed by an expression. The value of such an expression
    can be of any type (not just Boolean), and it's evaluated against a series of
    `case` statements, each one followed by a block of code. The first statement that
    matches the expression, if the `switch` and `case` condition are equal, has its
    block executed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个条件语句是`switch`。这允许短声明，就像`if`一样，然后是一个表达式。这样的表达式的值可以是任何类型（不仅仅是布尔类型），并且它与一系列`case`语句进行比较，每个`case`语句后面都跟着一段代码。第一个与表达式匹配的语句，如果`switch`和`case`条件相等，将执行其块。
- en: 'If a `break` statement is present in the case where the block execution is
    interrupted, but  there''s a `fallthrough`, the code inside the following `case`
    block is executed. A special case called `default` can be used to execute its
    code if no case is satisfied, as shown in the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在中断块的执行中存在`break`语句，但有一个`fallthrough`，则执行以下`case`块内的代码。一个称为`default`的特殊情况可以用来在没有满足条件的情况下执行其代码，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Looping
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'The `for` statement is the only looping statement in Go. This requires that
    you specify three expressions, separated by `;`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句是Go中唯一的循环语句。这要求您指定三个表达式，用`；`分隔：'
- en: A short declaration or an assignment to an existing variable
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对现有变量进行短声明或赋值
- en: A condition to verify before each iteration
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次迭代之前验证的条件
- en: An operation to execute at the end of the iteration
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在迭代结束时执行的操作
- en: 'All of these statements can be optional, and the absence of a condition means
    that it is always `true`. A `break` statement interrupts the loop''s execution,
    while `continue` skips the current iteration and proceeds with the next one:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些语句都是可选的，没有条件意味着它总是`true`。`break`语句中断循环的执行，而`continue`跳过当前迭代并继续下一个：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When a combination of `switch` and `for` are nested, the `continue` and `break`
    statements refer to the inner flow control statement.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当`switch`和`for`的组合嵌套时，`continue`和`break`语句将引用内部流控制语句。
- en: 'An outer loop or condition can be labelled using a `name:` expression, whereas
    the name is its identifier, and both `loop` and `continue` can be followed by
    the name in order to specify where to intervene, as shown in the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 外部循环或条件可以使用`name:`表达式进行标记，其中名称是其标识符，`loop`和`continue`都可以在后面跟着名称，以指定在哪里进行干预，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Exploring built-in functions
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索内置函数
- en: 'We already listed some of the built-in functions that are used to initialize
    some variables, that is, `make` and `new`. Now, let''s go over each function and
    check out what they do:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经列出了一些用于初始化一些变量的内置函数，即`make`和`new`。现在，让我们逐个查看每个函数并了解它们的作用：
- en: '`func append(slice []Type, elems ...Type) []Type`: This function appends elements
    to the end of a slice. If the underlying array is full, it reallocates the content
    to a bigger slice before appending.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func append(slice []Type, elems ...Type) []Type`: 此函数将元素追加到切片的末尾。如果底层数组已满，则在追加之前将内容重新分配到一个更大的切片中。'
- en: '`func cap(v Type) int`: Returns the number elements of an array, or of the
    underlying array if the argument is a slice.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func cap(v Type) int`: 返回数组、或者如果参数是切片则返回底层数组的元素数量。'
- en: '`func close(c chan<- Type)`: Closes a channel.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func close(c chan<- Type)`: 关闭一个通道。'
- en: '`func complex(r, i FloatType) ComplexType`: Given two floating points, this
    returns a complex number.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func complex(r, i FloatType) ComplexType`: 给定两个浮点数，返回一个复数。'
- en: '`func copy(dst, src []Type) int`: Copies elements from a slice to another.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func copy(dst, src []Type) int`: 从一个切片复制元素到另一个切片。'
- en: '`func delete(m map[Type]Type1, key Type)`: Removes an entry from a map.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func delete(m map[Type]Type1, key Type)`: 从映射中删除一个条目。'
- en: '`func imag(c ComplexType) FloatType`: Returns the imaginary part of a complex
    number.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func imag(c ComplexType) FloatType`: 返回复数的虚部。'
- en: '`func len(v Type) int`: Returns the length of an array, slice, map, string,
    or channel.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func len(v Type) int`: 返回数组、切片、映射、字符串或通道的长度。'
- en: '`func make(t Type, size ...IntegerType) Type`: Creates a new slice, map, or
    channel.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func make(t Type, size ...IntegerType) Type`: 创建一个新的切片、映射或通道。'
- en: '`func new(Type) *Type`: Returns a pointer to a variable of the specified type,
    initialized with a zero value.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func new(Type) *Type`: 返回指向指定类型变量的指针，并初始化为零值。'
- en: '`func panic(v interface{})`: Stops the execution of the current goroutine and,
    if it''s not intercepted, the program.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func panic(v interface{})`: 停止当前 goroutine 的执行，并且如果没有被拦截，整个程序也会停止。'
- en: '`func print(args ...Type)`: Writes the arguments to the standard error.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func print(args ...Type)`: 将参数写入标准错误。'
- en: '`func println(args ...Type)`: Writes the arguments to the standard error and
    adds a new line at the end.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func println(args ...Type)`: 将参数写入标准错误，并在末尾添加一个新行。'
- en: '`func real(c ComplexType) FloatType`: Returns the real part of a complex number.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func real(c ComplexType) FloatType`: 返回复数的实部。'
- en: '`func recover() interface{}`: Stops a panic sequence and captures the panic
    value.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func recover() interface{}`: 停止 panic 序列并捕获 panic 值。'
- en: Defer, panic, and recover
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟、panic 和 recover
- en: 'A very important keyword that hides a lot of complexity but makes it possible
    to execute many operations easily is `defer`. This is applied to a function, method,
    or closure execution and makes the function it precedes execute before the function
    returns. A common and very useful usage is closing resources. After opening the
    resource successfully, a deferred close statement will ensure that it is executed
    independently of the exit point, as shown in the following code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一个隐藏了很多复杂性但使得执行许多操作变得容易的非常重要的关键字是`defer`。这个关键字应用于函数、方法或闭包的执行，并使得它之前的函数在函数返回之前执行。一个常见且非常有用的用法是关闭资源。在成功打开资源后，延迟的关闭语句将确保它被执行，而不受退出点的影响，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: During a function's lifetime, all the deferred statements are added to a list
    and before exiting, they are executed in reverse order, from the last to the first `defer`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的生命周期内，所有延迟语句都被添加到一个列表中，并在退出之前按相反的顺序执行，从最后一个`defer`到第一个。
- en: 'These statements are executed even when there''s a panic, which is why a deferred
    function with a `recover` call can be used to intercept a panic in the respective
    goroutine and avoid the panic that would kill the application otherwise. As well
    as a manual call to the `panic` function, there is a set of operations that will
    cause a panic, including the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 即使发生 panic，这些语句也会被执行，这就是为什么带有`recover`调用的延迟函数可以用于拦截相应 goroutine 中的 panic 并避免否则会终止应用程序的
    panic。除了手动调用`panic`函数外，还有一组操作会引发 panic，包括以下操作：
- en: Accessing a negative or non-existent array/slice index (index out of range)
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问负数或不存在的数组/切片索引（索引超出范围）
- en: Dividing an integer by `0`
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将整数除以`0`
- en: Sending to a closed channel
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向关闭的通道发送数据
- en: Dereferencing on a `nil` pointer (`nil` pointer*)*
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`nil`指针进行解引用（`nil`指针）
- en: Using a recursive function call that fills the stack (stack overflow)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用递归函数调用填充堆栈（堆栈溢出）
- en: Panic should be used for errors that are not recoverable, which is why errors
    are just values in Go. Recovering a panic should be just an attempt to do something
    with that error before exiting the application. If an unexpected problem occurs,
    it's because it hasn't been handled correctly or some checks are missing. This
    represents a serious issue that needs to be dealt with, and the program needs
    to change, which is why it should be intercepted and dismissed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Panic 应该用于不可恢复的错误，这就是为什么在 Go 中错误只是值。恢复 panic 应该只是尝试在退出应用程序之前对该错误进行处理。如果发生了意外问题，那是因为它没有被正确处理或者缺少了一些检查。这代表了一个需要处理的严重问题，程序需要改变，这就是为什么它应该被拦截和解除。
- en: Concurrency model
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发模型
- en: Concurrency is so central to Go that two of its fundamental tools are just keywords
    – `chan` and `go`. This is a very clever way of hiding the complexity of a well-designed
    and implemented concurrency model that is easy to use and understand.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 并发对于 Go 来说是如此核心，以至于它的两个基本工具只是关键字——`chan`和`go`。这是一种非常巧妙的方式，它隐藏了一个设计良好且实现简单易懂的并发模型的复杂性。
- en: Understanding channels and goroutines
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解通道和 goroutine
- en: 'Channels are made for communicating, which is why Go''s mantra is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是用于通信的，这就是为什么 Go 的口号是：
- en: '"Do not communicate by sharing memory, share memory by communicating."'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: “不要通过共享内存来通信，而是通过通信来共享内存。”
- en: A channel is made for sharing data, and it usually connects two or more execution
    threads in an application, which makes it possible to send and receive data without
    worrying about data safety. Go has a lightweight implementation of a thread that
    is managed by the runtime instead of the operating system, and the best way to
    make them communicate is through the use of channels.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通道用于共享数据，通常连接应用程序中的两个或多个执行线程，这使得可以发送和接收数据而不必担心数据安全性。Go具有由运行时而不是操作系统管理的轻量级线程的实现，它们之间进行通信的最佳方式是通过使用通道。
- en: 'Creating a new goroutine is pretty easy – you just need to use the `go` operator,
    followed by a function execution. This includes method calls and closures. If
    the function has any arguments, they will be evaluated before the routine starts.
    Once it starts, there is no guarantee that changes to variables from an outer
    scope will be synchronized if you don''t use channels:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的goroutine非常简单 - 只需要使用`go`运算符，后面跟着一个函数执行。这包括方法调用和闭包。如果函数有任何参数，它们将在例程开始之前被评估。一旦开始，如果不使用通道，就无法保证来自外部作用域的变量更改会被同步：
- en: '[PRE37]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We already saw how to create a new channel with the `make` function. If a channel
    is unbuffered (`0` capacity), sending to the channel is a blocking operation that
    will wait for another goroutine to receive data from the same channel in order
    to unlock it. The capacity shows how many messages the channel is capable of holding
    before sending the next becomes a blocking operation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`make`函数创建一个新的通道。如果通道是无缓冲的（`0`容量），向通道发送数据是一个阻塞操作，它会等待另一个goroutine从同一个通道接收数据以解锁它。容量显示了通道在进行下一个发送操作之前能够容纳多少消息：
- en: '[PRE38]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In order to send to a channel, we can use the `<-` operator. If the channel
    is on the left of the operator, it is a send operation, and if it''s on the right,
    it is a receive operation. The value that''s received from a channel can be assigned
    to a variable, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向通道发送数据，我们可以使用`<-`运算符。如果通道在运算符的左边，那么这是一个发送操作，如果在右边，那么这是一个接收操作。从通道接收到的值可以被赋给一个变量，如下所示：
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Closing a channel can be done with the `close()` function. This operation means
    that no more values can be sent to the channel. This is why it is usually the
    responsibility of the sender. Sending to a close channel will cause a `panic` anyway,
    which is why it should be done by the receiver. Also, when receiving from a channel,
    a second Boolean variable can be specified in the assignment. This will be true
    if the channel is still open so that the receiver knows when a channel has been
    closed:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`close()`函数可以关闭一个通道。这个操作意味着不能再向通道发送更多的值。这通常是发送者的责任。向关闭的通道发送数据会导致`panic`，这就是为什么应该由接收者来完成。此外，当从通道接收数据时，可以在赋值中指定第二个布尔变量。如果通道仍然打开，这将为真，以便接收者知道通道何时已关闭。
- en: '[PRE40]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There is a special control statement called `select` which works exactly like `switch`,
    but with only operations on channels:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的控制语句叫做`select`，它的工作方式与`switch`完全相同，但只能在通道上进行操作：
- en: '[PRE41]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Understanding memory management
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内存管理
- en: Go is garbage collected; it manages its own memory with a computational cost.
    Writing an efficient application requires knowledge of its memory model and internals
    in order to reduce the garbage collector's work and increase general performance.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Go是垃圾收集的；它以计算成本管理自己的内存。编写高效的应用程序需要了解其内存模型和内部工作，以减少垃圾收集器的工作并提高总体性能。
- en: Stack and heap
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈和堆
- en: Memory is arranged into two main areas – stack and heap. There is a stack for
    the application entry point function (`main`), and additional stacks are created
    with each goroutine, which are stored in the heap. The **stack** is, as its name
    suggests, a memory portion that grows with each function call, and shrinks when
    the function returns. The **heap** is made of a series of regions of memory that
    are dynamically allocated, and their lifetime is not defined a priori as the items
    in the stack; heap space can be allocated and freed at any time.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 内存被分为两个主要区域 - 栈和堆。应用程序入口函数（`main`）有一个栈，每个goroutine都有一个栈，它们存储在堆中。**栈**就像其名字所暗示的那样，是一个随着每个函数调用而增长的内存部分，在函数返回时会收缩。**堆**由一系列动态分配的内存区域组成，它们的生命周期不像栈中的项目那样事先定义；堆空间可以随时分配和释放。
- en: All the variables that outlive the function where they are defined are stored
    in the heap, such as a returned pointer. The compiler uses a process called **escape
    analysis** to check which variables go on the heap. This can be verified with
    the `go tool compile -m` command.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 所有超出定义它们的函数生存期的变量都存储在堆中，比如返回的指针。编译器使用一个叫做**逃逸分析**的过程来检查哪些变量进入堆中。可以使用`go tool
    compile -m`命令来验证这一点。
- en: 'Variables in the stack come and go with the function''s execution. Let''s take
    a look at a practical example of how the stack works:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 栈中的变量随着函数的执行而来而去。让我们看一个栈如何工作的实际例子：
- en: '[PRE42]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We have the `main` function calling a function called `f1`, which calls another
    function called `f2`. Then, the same function is called directly by `main`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`main`函数调用一个名为`f1`的函数，它调用另一个名为`f2`的函数。然后，同一个函数直接被`main`调用。
- en: 'When the `main` function starts, the stack grows with the variables that are
    being used. In memory, this would look something like the following table, where
    each column represents the pseudo state of the stack, which it represents how
    the stack changes in time, going from left to right:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当`main`函数开始时，栈会随着被使用的变量而增长。在内存中，这看起来像下表，每一列代表栈的伪状态，表示栈随时间变化的方式，从左到右：
- en: '| `main` invoked | `f1` invoked | `f2` invoked | `f2` return | `f1` returns
    | `f2` invoked | `f2` returns | `main` returns |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `main`调用 | `f1`调用 | `f2`调用 | `f2`返回 | `f1`返回 | `f2`调用 | `f2`返回 | `main`返回
    |'
- en: '| `main()` | `main()` | `main()` | `main()` | `main()` | `main()` | `main()`
    | // empty |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `main()` | `main()` | `main()` | `main()` | `main()` | `main()` | `main()`
    | // 空 |'
- en: '| `a = 0` | `a = 0` | `a = 0` | `a = 0` | `a = 0` | `a = 0` | `a = 0` |  |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `a = 0` | `a = 0` | `a = 0` | `a = 0` | `a = 0` | `a = 0` | `a = 0` |  |'
- en: '| `b = 1` | `b = 1` | `b = 1` | `b = 1` | `b = 1` | `b = 1` | `b = 1` |  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `b = 1` | `b = 1` | `b = 1` | `b = 1` | `b = 1` | `b = 1` | `b = 1` |  |'
- en: '|  | `f1()` | `f1()` | `f1()` |  | `f2()` |  |  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|  | `f1()` | `f1()` | `f1()` |  | `f2()` |  |  |'
- en: '|  | `a = 0` | `a = 0` | `a = 0` |  | `c = 0` |  |  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|  | `a = 0` | `a = 0` | `a = 0` |  | `c = 0` |  |  |'
- en: '|  | `b = 1` | `b = 1` | `b = 1` |  |  |  |  |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '|  | `b = 1` | `b = 1` | `b = 1` |  |  |  |  |'
- en: '|  | `c = 1` | `c = 1` | `c = 1` |  |  |  |  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|  | `c = 1` | `c = 1` | `c = 1` |  |  |  |  |'
- en: '|  |  | `f2()` |  |  |  |  |  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `f2()` |  |  |  |  |  |'
- en: '|  |  | `c = 1` |  |  |  |  |  |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `c = 1` |  |  |  |  |  |'
- en: When `f1` gets called, the stack grows again by copying the `a` and `b` variables
    in the new part and adding the new variable, `c`. The same thing happens for `f2`.
    When `f2` returns, the stack shrinks by getting rid of the function and its variables,
    which is what happens when `f1` finishes. When `f2` is called directly, it grows
    again by recycling the same memory part that was used for `f1`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`f1`时，堆栈再次增长，通过将`a`和`b`变量复制到新部分并添加新变量`c`来实现。`f2`也是同样的情况。当`f2`返回时，堆栈通过摆脱函数及其变量来缩小，这就是`f1`完成时发生的情况。当直接调用`f2`时，它会通过回收用于`f1`的相同内存部分来再次增长。
- en: The garbage collector is responsible for cleaning up the unreferenced values
    in the heap, so avoiding storing data in it is a good way of lowering the work
    of the **garbage collector** (**GC**), which causes a slight decrease in performance
    in the app when the GC is running.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器负责清理堆中未引用的值，因此避免在其中存储数据是降低**垃圾收集器**（**GC**）工作量的好方法，这会在GC运行时导致应用程序性能略微下降。
- en: The history of GC in Go
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中GC的历史
- en: The GC is responsible for freeing the areas of the heap that are not referenced
    in any stack. This was originally written in C and had a *stop the world* behavior.
    The program stopped for a fraction of time, freed the memory, and then resumed
    its flow.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: GC负责释放堆中任何栈中未引用的区域。这最初是用C编写的，并且具有*停止世界*行为。程序会在一小段时间内停止，释放内存，然后恢复其流程。
- en: Go 1.4 started the process of converting the runtime, including the garbage
    collector, into Go. Translating these parts in Go lays the foundations for easier
    optimization that already begun with version 1.5, where the GC became much faster
    and could run concurrently with other goroutines.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.4开始将运行时，包括垃圾收集器，转换为Go。将这些部分翻译成Go为更容易的优化奠定了基础，这在1.5版本中已经开始，其中GC变得更快，并且可以与其他goroutine并发运行。
- en: From that point on, there has been a lot of optimization and improvement of
    the process, which managed to reduce the GC time by several orders of magnitude.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，该过程进行了大量的优化和改进，成功将GC时间减少了几个数量级。
- en: Building and compiling programs
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和编译程序
- en: Now that we have had a quick overview of all the language features and capabilities, we
    can focus on how to run and build our applications.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速概述了所有语言特性和功能，我们可以专注于如何运行和构建我们的应用程序。
- en: Install
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: In Go, there are different commands to build packages and applications. The
    first one is `go install`, followed by a path or a package name, which creates
    a compiled version of the packages in the `pkg` directory inside `$GOPATH`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，有不同的命令来构建软件包和应用程序。第一个是`go install`，后面跟着路径或软件包名称，它将在`$GOPATH`内的`pkg`目录中创建软件包的编译版本。
- en: 'All the compiled packages are organized by the operating system and architecture,
    which are stored in the `$GOOS` and `$GOARCH` environment variables. These settings
    are visible by using the `go env` command, together with other information, like
    compilation flags:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编译的软件包都按操作系统和架构组织，这些都存储在`$GOOS`和`$GOARCH`环境变量中。可以使用`go env`命令查看这些设置，以及其他信息，比如编译标志：
- en: '[PRE43]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For the current architecture and operating system, all the compiled packages
    will be placed in the `$GOOS_$GOARCH` subdirectory:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前的架构和操作系统，所有编译的软件包将被放置在`$GOOS_$GOARCH`子目录中：
- en: '[PRE44]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If the package name is `main` and it contains a `main` function, the command
    will produce an executable binary file, which will be stored in `$GOPATH/bin`. If
    a package is already installed and the source file didn't change, it will not
    be compiled again, which will speed up build time significantly after the first
    compile.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件包名称是`main`并且包含一个`main`函数，该命令将生成一个可执行的二进制文件，该文件将存储在`$GOPATH/bin`中。如果软件包已经安装并且源文件没有更改，它将不会被重新编译，这将在第一次编译后显著加快构建时间。
- en: Build
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建
- en: 'A binary can also be built in a specific location using the `go build` command.
    A specific output file can be defined using the `-o` flag, otherwise it will be
    built in the working directory, using the package name as a binary name:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用`go build`命令在特定位置构建二进制文件。可以使用`-o`标志定义特定的输出文件，否则将在工作目录中构建，使用软件包名称作为二进制文件名：
- en: '[PRE45]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When executing the `go build` command, the argument can be one of the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`go build`命令时，参数可以是以下之一：
- en: A package as a relative path (like `go build .` for the current package or `go
    build ../name`)
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个软件包作为相对路径（比如`go build .`用于当前软件包或`go build ../name`）
- en: A package as an absolute path (`go build some/package`) that will be looked
    up in`$GOPATH`
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个软件包作为绝对路径（`go build some/package`）将在`$GOPATH`中查找
- en: A specific Go source file (`go build main.go`)
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个特定的Go源文件（`go build main.go`）
- en: The latter case allows you to build a file that is outside `$GOPATH` and will
    ignore any other source file in the same directory.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种情况允许您构建一个位于`$GOPATH`之外的文件，并且将忽略同一目录中的任何其他源文件。
- en: Run
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行
- en: 'There is a third command that works similarly to build, but also runs the binary.
    It creates the binary using the `build` command using a temporary directory as
    output, and executes the binary on the fly:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三个命令，它类似于构建，但也运行二进制文件。它使用`build`命令使用临时目录作为输出创建二进制文件，并即时执行二进制文件：
- en: '[PRE46]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Run can be used over build or install when you're making changes to the source
    code. If the code is the same, it is probably better to build it once and execute
    it many times.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对源代码进行更改时，可以使用运行而不是构建或安装。如果代码相同，最好是构建一次，然后多次执行。
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at some of the history of Go and its current pros
    and cons. After understanding the namespace by looking at how the package system
    and imports work, we explored its type system with basic, composite, and user-defined
    types.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些Go的历史以及它当前的优缺点。在了解了命名空间后，我们探讨了包系统和导入的工作方式，以及基本、复合和用户定义类型的类型系统。
- en: We focused on variables by looking at how they can be declared and initialized,
    which operations are allowed between types, how to cast variables to other types,
    and how to see what the underlying type of interface is. We saw how scope and
    shadowing work and the difference between constants and variables. After this,
    we jumped into functions, a first-class type, and how each signature represents
    a different type. We then understood how methods are basically functions in disguise
    and attached to a type that allows custom types to satisfy interfaces.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看变量的声明和初始化方式，允许类型之间的操作，如何将变量转换为其他类型，以及如何查看接口的基础类型，来重点关注变量。我们看到了作用域和屏蔽的工作方式，以及常量和变量之间的区别。之后，我们进入了函数，它是一种一等类型，以及每个签名代表不同类型的方式。然后，我们了解了方法实际上是伪装成函数并附加到允许自定义类型满足接口的类型。
- en: In addition, we learned how to control the application flow using statements
    like `if`, `for`, and `switch`. We analyzed the differences between the various
    control statements and the looping statement and viewed what each built-in function
    does. Then, we saw how basic concurrency works with channels and goroutines. Finally,
    we got some notion of how Go's internal memory allocation works, some history
    and performance of its garbage collector, and how to build, install, and run Go
    binaries.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们学习了如何使用诸如`if`、`for`和`switch`之类的语句来控制应用程序流程。我们分析了各种控制语句和循环语句之间的区别，并查看了每个内置函数的作用。然后，我们看到了基本并发是如何通过通道和goroutine工作的。最后，我们对Go的内部内存分配方式有了一些了解，以及其垃圾收集器的历史和性能，以及如何构建、安装和运行Go二进制文件。
- en: In the next chapter, we are going to see how to put some of this into practice
    by interacting with the filesystem.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何通过与文件系统交互将其中一些内容付诸实践。
- en: Questions
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's the difference between an exported and an unexported symbol?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出符号和未导出符号之间有什么区别？
- en: Why are custom types important?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义类型为什么重要？
- en: What is the main limit of a short declaration?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 短声明的主要限制是什么？
- en: What is scope and how does it affect variable shadowing?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是作用域，它如何影响变量屏蔽？
- en: How can you access a method?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何访问一个方法？
- en: Explain the difference between a series of `if`/`else` and `switch`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释一下一系列`if`/`else`和`switch`之间的区别。
- en: In a typical use case, who is generally responsible for closing a channel?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在典型的用例中，通常谁负责关闭通道？
- en: What is escape analysis?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是逃逸分析？
