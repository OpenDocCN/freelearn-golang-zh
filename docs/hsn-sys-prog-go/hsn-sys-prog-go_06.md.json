["```go\nuser:~ $ cd documents\n\nuser:~/documents $ cd ../videos\n\nuser:~/videos $\n```", "```go\nwd, err := os.Getwd()\nif err != nil {\n    fmt.Println(err)\n    return\n}\nfmt.Println(\"starting dir:\", wd)\n\nif err := os.Chdir(\"/\"); err != nil {\n    fmt.Println(err)\n    return\n}\n\nif wd, err = os.Getwd(); err != nil {\n    fmt.Println(err)\n    return\n}\nfmt.Println(\"final dir:\", wd)\n```", "```go\ntype WalkFunc func(path string, info os.FileInfo, err error) error\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n)\n\nfunc main() {\n    if len(os.Args) != 2 { // ensure path is specified\n        fmt.Println(\"Please specify a path.\")\n        return\n    }\n    root, err := filepath.Abs(os.Args[1]) // get absolute path\n    if err != nil {\n        fmt.Println(\"Cannot get absolute path:\", err)\n        return\n    }\n    fmt.Println(\"Listing files in\", root)\n    var c struct {\n        files int\n        dirs int\n    }\n    filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n        // walk the tree to count files and folders\n        if info.IsDir() {\n            c.dirs++\n        } else {\n            c.files++\n        }\n        fmt.Println(\"-\", path)\n        return nil\n    })\n    fmt.Printf(\"Total: %d files in %d directories\", c.files, c.dirs)\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n)\n\nfunc main() {\n    if len(os.Args) != 2 {\n        fmt.Println(\"Please specify a path.\")\n        return\n    }\n    b, err := ioutil.ReadFile(os.Args[1])\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n    fmt.Println(string(b))\n}\n```", "```go\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        fmt.Println(\"Please specify a file\")\n        return\n    }\n    f, err := os.Open(os.Args[1])\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    defer f.Close() // we ensure close to avoid leaks\n\n    var (\n        b = make([]byte, 16)\n    )\n    for n := 0; err == nil; {\n        n, err = f.Read(b)\n        if err == nil {\n            fmt.Print(string(b[:n])) // only print what's been read\n        }\n    }\n    if err != nil && err != io.EOF { // we expect an EOF\n        fmt.Println(\"\\n\\nError:\", err)\n    }\n}\n```", "```go\npackage main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n)\n\nfunc main() {\n    var b = bytes.NewBuffer(make([]byte, 26))\n    var texts = []string{\n        `As he came into the window`,\n        `It was the sound of a crescendo\nHe came into her apartment`,\n        `He left the bloodstains on the carpet`,\n        `She ran underneath the table\nHe could see she was unable\nSo she ran into the bedroom\nShe was struck down, it was her doom`,\n    }\n    for i := range texts {\n        b.Reset()\n        b.WriteString(texts[i])\n        fmt.Println(\"Length:\", b.Len(), \"\\tCapacity:\", b.Cap())\n    }\n}\n```", "```go\ntype SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)\n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        fmt.Println(\"Please specify a path.\")\n        return\n    }\n    f, err := os.Open(os.Args[1])\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    defer f.Close()\n    r := bufio.NewReader(f) // wrapping the reader with a buffered one\n    var rowCount int\n    for err == nil {\n        var b []byte\n        for moar := true; err == nil && moar; {\n            b, moar, err = r.ReadLine()\n            if err == nil {\n                fmt.Print(string(b))\n            }\n        }\n        // each time moar is false, a line is completely read\n        if err == nil {\n            fmt.Println()\n            rowCount++\n\n        }\n    }\n    if err != nil && err != io.EOF {\n        fmt.Println(\"\\nError:\", err)\n        return\n    }\n    fmt.Println(\"\\nRow count:\", rowCount)\n}\n```", "```go\ntype Closer interface {\n        Close() error\n}\n\ntype Seeker interface {\n        Seek(offset int64, whence int) (int64, error)\n}\n```", "```go\ntype ReadCloser interface {\n        Reader\n        Closer\n}\n\ntype ReadSeeker interface {\n        Reader\n        Seeker\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n)\n\nfunc main() {\n    if len(os.Args) != 3 {\n        fmt.Println(\"Please specify a path and some content\")\n        return\n    }\n    // the second argument, the content, needs to be casted to a byte slice\n    if err := ioutil.WriteFile(os.Args[1], []byte(os.Args[2]), 0644); err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n```", "```go\ntype Writer interface {\n        Write(p []byte) (n int, err error)\n}\n```", "```go\n// Let's omit argument check and file opening, we obtain src and dst\ncur, err := src.Seek(0, os.SEEK_END) // Let's go to the end of the file\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\nb := make([]byte, 16)\n```", "```go\n\nfor step, r, w := int64(16), 0, 0; cur != 0; {\n    if cur < step { // ensure cursor is 0 at max\n        b, step = b[:cur], cur\n    }\n    cur = cur - step\n    _, err = src.Seek(cur, os.SEEK_SET) // go backwards\n    if err != nil {\n        break\n    }\n    if r, err = src.Read(b); err != nil || r != len(b) {\n        if err == nil { // all buffer should be read\n            err = fmt.Errorf(\"read: expected %d bytes, got %d\", len(b), r)\n        }\n        break\n    }\n```", "```go\n    for i, j := 0, len(b)-1; i < j; i, j = i+1, j-1 {\n        switch { // Swap (\\r\\n) so they get back in place\n        case b[i] == '\\r' && b[i+1] == '\\n':\n            b[i], b[i+1] = b[i+1], b[i]\n        case j != len(b)-1 && b[j-1] == '\\r' && b[j] == '\\n':\n            b[j], b[j-1] = b[j-1], b[j]\n        }\n        b[i], b[j] = b[j], b[i] // swap bytes\n    }\n    if w, err = dst.Write(b); err != nil || w != len(b) {\n        if err != nil {\n            err = fmt.Errorf(\"write: expected %d bytes, got %d\", len(b), w)\n        }\n    }\n}\nif err != nil && err != io.EOF { // we expect an EOF\n    fmt.Println(\"\\n\\nError:\", err)\n}\n```", "```go\nconst grr = \"G.R.R. Martin\"\n\ntype book struct {\n    Author, Title string\n    Year int\n}\n\nfunc main() {\n    dst, err := os.OpenFile(\"book_list.txt\", os.O_CREATE|os.O_WRONLY, 0666)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    defer dst.Close()\n    bookList := []book{\n        {Author: grr, Title: \"A Game of Thrones\", Year: 1996},\n        {Author: grr, Title: \"A Clash of Kings\", Year: 1998},\n        {Author: grr, Title: \"A Storm of Swords\", Year: 2000},\n        {Author: grr, Title: \"A Feast for Crows\", Year: 2005},\n        {Author: grr, Title: \"A Dance with Dragons\", Year: 2011},\n        // if year is omitted it defaulting to zero value\n        {Author: grr, Title: \"The Winds of Winter\"},\n        {Author: grr, Title: \"A Dream of Spring\"},\n    }\n    b := bytes.NewBuffer(make([]byte, 0, 16))\n    for _, v := range bookList {\n        // prints a msg formatted with arguments to writer\n        fmt.Fprintf(b, \"%s - %s\", v.Title, v.Author)\n        if v.Year > 0 { \n            // we do not print the year if it's not there\n            fmt.Fprintf(b, \" (%d)\", v.Year)\n        }\n        b.WriteRune('\\n')\n        if _, err := b.WriteTo(dst); true { // copies bytes, drains buffer\n            fmt.Println(\"Error:\", err)\n            return\n        }\n    }\n}\n```", "```go\n  var w io.WriteCloser\n  // initialise writer\n  defer w.Close()\n  b := bufio.NewWriter(w)\n  defer b.Flush()\n  // write operations\n```", "```go\n// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.\nO_RDONLY int = syscall.O_RDONLY // open the file read-only.\nO_WRONLY int = syscall.O_WRONLY // open the file write-only.\nO_RDWR int = syscall.O_RDWR // open the file read-write.\n// The remaining values may be or'ed in to control behavior.\nO_APPEND int = syscall.O_APPEND // append data to the file when writing.\nO_CREATE int = syscall.O_CREAT // create a new file if none exists.\nO_EXCL int = syscall.O_EXCL // used with O_CREATE, file must not exist.\nO_SYNC int = syscall.O_SYNC // open for synchronous I/O.\nO_TRUNC int = syscall.O_TRUNC // if possible, truncate file when opened.\n```", "```go\npackage main\n\nimport \"os\"\n\nfunc main() {\n    f, err := os.Create(\"file.txt\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    f.Close()\n}\n```", "```go\npackage main\n\nimport \"os\"\n\nfunc main() {\n    // let's keep thing under 4kB\n    if err := os.Truncate(\"file.txt\", 4096); err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n```", "```go\npackage main\n\nimport \"os\"\n\nfunc main() {\n    if err := os.Remove(\"file.txt\"); err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n```", "```go\nimport \"os\"\n\nfunc main() {\n    if err := os.Rename(\"file.txt\", \"../file.txt\"); err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n```", "```go\nfunc CopyFile(from, to string) (int64, error) {\n    src, err := os.Open(from)\n    if err != nil {\n        return 0, err\n    }\n    defer src.Close()\n    dst, err := os.OpenFile(to, os.O_WRONLY|os.O_CREATE, 0644)\n    if err != nil {\n        return 0, err\n    }\n    defer dst.Close()  \n    return io.Copy(dst, src)\n}\n```", "```go\ntype FileInfo interface {\n        Name() string // base name of the file\n        Size() int64 // length in bytes for regular files; system-dependent for others\n        Mode() FileMode // file mode bits\n        ModTime() time.Time // modification time\n        IsDir() bool // abbreviation for Mode().IsDir()\n        Sys() interface{} // underlying data source (can return nil)\n}\n```"]