["```go\nfunc main() {\n    const a = `\u2318`\n\n    fmt.Printf(\"plain string: %s\\n\", a)\n    fmt.Printf(\"quoted string: %q\\n\",a)\n\n    fmt.Printf(\"hex bytes: \")\n    for i := 0; i < len(a); i++ {\n        fmt.Printf(\"%x \", a[i])\n    }\n    fmt.Printf(\"\\n\")\n}\n```", "```go\nfunc NewAngryReader(r io.Reader) *AngryReader {\n    return &AngryReader{r: r}\n}\n\ntype AngryReader struct {\n    r io.Reader\n}\n\nfunc (a *AngryReader) Read(b []byte) (int, error) {\n    n, err := a.r.Read(b)\n    for r, i, w := rune(0), 0, 0; i < n; i += w {\n        // read a rune\n        r, w = utf8.DecodeRune(b[i:])\n        // skip if not a letter\n        if !unicode.IsLetter(r) {\n            continue\n        }\n        // uppercase version of the rune\n        ru := unicode.ToUpper(r)\n        // encode the rune and expect same length\n        if wu := utf8.EncodeRune(b[i:], ru); w != wu {\n            return n, fmt.Errorf(\"%c->%c, size mismatch %d->%d\", r, ru, w, wu)\n        }\n    }\n    return n, err\n}\n```", "```go\n    bookList := []book{\n        {Author: grr, Title: \"A Game of Thrones\", Year: 1996},\n        {Author: grr, Title: \"A Clash of Kings\", Year: 1998},\n        {Author: grr, Title: \"A Storm of Swords\", Year: 2000},\n        {Author: grr, Title: \"A Feast for Crows\", Year: 2005},\n        {Author: grr, Title: \"A Dance with Dragons\", Year: 2011},\n        {Author: grr, Title: \"The Winds of Winter\"},\n        {Author: grr, Title: \"A Dream of Spring\"},\n    }\n    b := bytes.NewBuffer(make([]byte, 0, 16))\n    for _, v := range bookList {\n        // prints a msg formatted with arguments to writer\n        fmt.Fprintf(b, \"%s - %s\", v.Title, v.Author)\n        if v.Year > 0 { // we do not print the year if it's not there\n            fmt.Fprintf(b, \" (%d)\", v.Year)\n        }\n        b.WriteRune('\\n')\n        if _, err := b.WriteTo(dst); true { // copies bytes, drains buffer\n            fmt.Println(\"Error:\", err)\n            return\n        }\n    }\n```", "```go\npackage main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n)\n\nfunc main() {\n    b := bytes.NewBuffer(nil)\n    b.WriteString(\"One\")\n    s1 := b.String()\n    b.WriteString(\"Two\")\n    s2 := b.String()\n    b.Reset()\n    b.WriteString(\"Hey!\")    // does not change s1 or s2\n    s3 := b.String()\n    fmt.Println(s1, s2, s3)  // prints \"One OneTwo Hey!\"\n}\n```", "```go\npackage main\n\nimport (\n    \"strings\"\n)\n\nfunc main() {\n    b := strings.Builder{}\n    b.WriteString(\"One\")\n    c := b\n    c.WriteString(\"Hey!\") // panic: strings: illegal use of non-zero Builder copied by value\n}\n```", "```go\nfunc NewScrambleWriter(w io.Writer, r *rand.Rand, chance float64) *ScrambleWriter {\n    return &ScrambleWriter{w: w, r: r, c: chance}\n}\n\ntype ScrambleWriter struct {\n    w io.Writer\n    r *rand.Rand\n    c float64\n}\n```", "```go\nfunc (s *ScrambleWriter) Write(b []byte) (n int, err error) {\n    var runes = make([]rune, 0, 10)\n    for r, i, w := rune(0), 0, 0; i < len(b); i += w {\n        r, w = utf8.DecodeRune(b[i:])\n        if unicode.IsLetter(r) {\n            runes = append(runes, r)\n            continue\n        }\n        v, err := s.shambleWrite(runes, r)\n        if err != nil {\n            return n, err\n        }\n        n += v\n        runes = runes[:0]\n    }\n    if len(runes) != 0 {\n        v, err := s.shambleWrite(runes, 0)\n        if err != nil {\n            return n, err\n        }\n        n += v\n    }\n    return\n}\n```", "```go\nfunc (s *ScrambleWriter) shambleWrite(runes []rune, sep rune) (n int, err error) {\n    //scramble after first letter\n    for i := 1; i < len(runes)-1; i++ {\n        if s.r.Float64() > s.c {\n            continue\n        }\n        j := s.r.Intn(len(runes)-1) + 1\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    if sep!= 0 {\n        runes = append(runes, sep)\n    }\n    var b = make([]byte, 10)\n    for _, r := range runes {\n        v, err := s.w.Write(b[:utf8.EncodeRune(b, r)])\n        if err != nil {\n            return n, err\n        }\n        n += v\n    }\n    return\n}\n```", "```go\nfunc CopyNOffset(dst io.Writer, src io.ReadSeeker, offset, length int64) (int64, error) {\n  if _, err := src.Seek(offset, io.SeekStart); err != nil {\n    return 0, err\n  }\n  return io.CopyN(dst, src, length)\n}\n```", "```go\n    pr, pw := io.Pipe()\n    go func(w io.WriteCloser) {\n        for _, s := range []string{\"a string\", \"another string\", \n           \"last one\"} {\n                fmt.Printf(\"-> writing %q\\n\", s)\n                fmt.Fprint(w, s)\n        }\n        w.Close()\n    }(pw)\n    var err error\n    for n, b := 0, make([]byte, 100); err == nil; {\n        fmt.Println(\"<- waiting...\")\n        n, err = pr.Read(b)\n        if err == nil {\n            fmt.Printf(\"<- received %q\\n\", string(b[:n]))\n        }\n    }\n    if err != nil && err != io.EOF {\n        fmt.Println(\"error:\", err)\n    }\n```", "```go\ns := strings.NewReader(`Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged.`)\n    io.Copy(os.Stdout, io.LimitReader(s, 25)) // will print \"Lorem Ipsum is simply dum\"\n```", "```go\ntype queryWriter struct {\n    Query []byte\n    io.Writer\n}\n\nfunc (q queryWriter) Write(b []byte) (n int, err error) {\n    lines := bytes.Split(b, []byte{'\\n'})\n    l := len(q.Query)\n    for _, b := range lines {\n        i := bytes.Index(b, q.Query)\n        if i == -1 {\n            continue\n        }\n        for _, s := range [][]byte{\n            b[:i], // what's before the match\n            []byte(\"\\x1b[31m\"), //star red color\n            b[i : i+l], // match\n            []byte(\"\\x1b[39m\"), // default color\n            b[i+l:], // whatever is left\n        } {\n            v, err := q.Writer.Write(s)\n            n += v\n            if err != nil {\n                return 0, err\n            }\n        }\n        fmt.Fprintln(q.Writer)\n    }\n    return len(b), nil\n}\n```", "```go\nfunc main() {\n    if len(os.Args) < 3 {\n        fmt.Println(\"Please specify a path and a search string.\")\n        return\n    }\n    root, err := filepath.Abs(os.Args[1]) // get absolute path\n    if err != nil {\n        fmt.Println(\"Cannot get absolute path:\", err)\n        return\n    }\n    q := []byte(strings.Join(os.Args[2:], \" \"))\n    fmt.Printf(\"Searching for %q in %s...\\n\", query, root)\n    err = filepath.Walk(root, func(path string, info os.FileInfo,   \n        err error) error {\n            if info.IsDir() {\n                return nil\n            }\n            fmt.Println(path)\n            f, err := os.Open(path)\n            if err != nil {\n                return err\n            }\n        defer f.Close()\n\n        _, err = ioutil.ReadAll(io.TeeReader(f, queryWriter{q, os.Stdout}))\n        return err\n    })\n    if err != nil {\n        fmt.Println(err)\n    }\n}\n```", "```go\n    r := strings.NewReader(\"let's read this message\\n\")\n    b := bytes.NewBuffer(nil)\n    w := io.MultiWriter(b, os.Stdout)\n    io.Copy(w, r) // prints to the standard output\n    fmt.Println(b.String()) // buffer also contains string now\n```"]