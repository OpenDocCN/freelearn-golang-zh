["```go\ns := bufio.NewScanner(os.Stdin)\nw := os.Stdout\nfmt.Fprint(w, \"Some welcome message\\n\")\nfor {\n    s.Scan() // get next the token\n    fmt.Fprint(w, \"You wrote \\\"\") \n    w.Write(s.Bytes())\n    fmt.Fprintln(w, \"\\\"\\n\") // writing back the text\n}\n```", "```go\ns := bufio.NewScanner(os.Stdin)\nw := os.Stdout\nfmt.Fprint(w, \"Some welcome message\\n\")\nfor {\n    s.Scan() // get next the token\n    msg := string(s.Bytes())\n    if msg == \"exit\" {\n        return\n    }\n    fmt.Fprintf (w, \"You wrote %q\\n\", msg) // writing back the text\n}\n```", "```go\nargs := strings.Split(string(s.Bytes()), \" \")\ncmd := args[0]\nargs = args[1:]\n```", "```go\nswitch cmd {\ncase \"exit\":\n    return\ncase \"someCommand\":\n    someCommand(w, args)\ncase \"anotherCommand\":\n    anotherCommand(w, args)\n}\n```", "```go\nvar cmdFunc func(w io.Writer, args []string) (exit bool)\nswitch cmd {\ncase \"exit\":\n    cmdFunc = exitCmd\n}\nif cmdFunc == nil {\n    fmt.Fprintf(w, \"%q not found\\n\", cmd)\n    continue\n}\nif cmdFunc(w, args) { // execute and exit if true\n    return\n}\n```", "```go\nfunc exitCmd(w io.Writer, args []string) bool {\n    fmt.Fprintf(w, \"Goodbye! :)\")\n    return true\n}\n```", "```go\nfunc shuffle(w io.Writer, args ...string) bool {\n    rand.Shuffle(len(args), func(i, j int) {\n        args[i], args[j] = args[j], args[i]\n    })\n    for i := range args {\n        if i > 0 {\n            fmt.Fprint(w, \" \")\n        }\n        fmt.Fprintf(w, \"%s\", args[i])\n    }\n    fmt.Fprintln(w)\n    return false\n}\n```", "```go\nfunc print(w io.Writer, args ...string) bool {\n    if len(args) != 1 {\n        fmt.Fprintln(w, \"Please specify one file!\")\n        return false\n    }\n    f, err := os.Open(args[0])\n    if err != nil {\n        fmt.Fprintf(w, \"Cannot open %s: %s\\n\", args[0], err)\n    }\n    defer f.Close()\n    if _, err := io.Copy(w, f); err != nil {\n        fmt.Fprintf(w, \"Cannot print %s: %s\\n\", args[0], err)\n    }\n    fmt.Fprintln(w)\n    return false\n}\n```", "```go\ntype cmd struct {\n    Name string // the command name\n    Help string // a description string\n    Action func(w io.Writer, args ...string) bool\n}\n\nfunc (c cmd) Match(s string) bool {\n  return c.Name == s\n}\n\nfunc (c cmd) Run(w io.Writer, args ...string) bool {\n  return c.Action(w, args...)\n}\n```", "```go\nhelp := cmd{\n    Name: \"help\",\n    Help: \"Shows available commands\",\n    Action: func(w io.Writer, args ...string) bool {\n        fmt.Fprintln(w, \"Available commands:\")\n        for _, c := range cmds {\n            fmt.Fprintf(w, \" - %-15s %s\\n\", c.Name, c.Help)\n        }\n        return false\n    },\n}\n```", "```go\nfor i := range cmds {\n    if !cmds[i].Match(args[0]) {\n        continue\n    }\n    idx = i\n    break\n}\nif idx == -1 {\n    fmt.Fprintf(w, \"%q not found. Use `help` for available commands\\n\", args[0])\n    continue\n}\nif cmds[idx].Run(w, args[1:]...) {\n    fmt.Fprintln(w)\n    return\n}\n```", "```go\nfunc ScanArgs(data []byte, atEOF bool) (advance int, token []byte, err error) {\n    // first space\n    start, first := 0, rune(0)\n    for width := 0; start < len(data); start += width {\n        first, width = utf8.DecodeRune(data[start:])\n        if !unicode.IsSpace(first) {\n            break\n        }\n    }\n    // skip quote\n    if isQuote(first) {\n        start++\n    }\n```", "```go\n    // loop until arg end character\n    for width, i := 0, start; i < len(data); i += width {\n        var r rune\n        r, width = utf8.DecodeRune(data[i:])\n        if ok := isQuote(first); !ok && unicode.IsSpace(r) || ok  \n            && r == first {\n                return i + width, data[start:i], nil\n        }\n    }\n```", "```go\n    // token from EOF\n    if atEOF && len(data) > start {\n        return len(data), data[start:], nil\n    }\n    if isQuote(first) {\n        start--\n    }\n    return start, nil, nil\n}\n```", "```go\ntype argsScanner []string\n\nfunc (a *argsScanner) Reset() { *a = (*a)[0:0] }\n\nfunc (a *argsScanner) Parse(r io.Reader) (extra string) {\n    s := bufio.NewScanner(r)\n    s.Split(ScanArgs)\n    for s.Scan() {\n        *a = append(*a, s.Text())\n    }\n    if len(*a) == 0 {\n        return \"\"\n    }\n    lastArg := (*a)[len(*a)-1]\n    if !isQuote(rune(lastArg[0])) {\n        return \"\"\n    }\n    *a = (*a)[:len(*a)-1]\n    return lastArg + \"\\n\"\n}\n```", "```go\nfunc main() {\n s := bufio.NewScanner(os.Stdin)\n w := os.Stdout\n a := argsScanner{}\n b := bytes.Buffer{}\n for {\n        // prompt message \n        a.Reset()\n        b.Reset()\n        for {\n            s.Scan()\n            b.Write(s.Bytes())\n            extra := a.Parse(&b)\n            if extra == \"\" {\n                break\n            }\n            b.WriteString(extra)\n        }\n        // a contains the split arguments\n    }\n}\n```", "```go\ntype color int\n\nfunc (c color) Start(w io.Writer) {\n    fmt.Fprintf(w, \"\\x1b[%dm\", c)\n}\n\nfunc (c color) End(w io.Writer) {\n    fmt.Fprintf(w, \"\\x1b[%dm\", Reset)\n}\n\nfunc (c color) Sprintf(w io.Writer, format string, args ...interface{}) {\n    c.Start(w)\n    fmt.Fprintf(w, format, args...)\n    c.End(w)\n}\n\n// List of colors\nconst (\n    Reset color = 0\n    Red color = 31\n    Green color = 32\n    Yellow color = 33\n    Blue color = 34\n    Magenta color = 35\n    Cyan color = 36\n    White color = 37\n)\n```", "```go\nfunc shuffle(w io.Writer, args ...string) bool {\n    rand.Shuffle(len(args), func(i, j int) {\n        args[i], args[j] = args[j], args[i]\n    })\n    for i := range args {\n        if i > 0 {\n            fmt.Fprint(w, \" \")\n        }\n        var f func(w io.Writer, format string, args ...interface{})\n        if i%2 == 0 {\n            f = Red.Fprintf\n        } else {\n            f = Green.Fprintf\n        }\n        f(w, \"%s\", args[i])\n    }\n    fmt.Fprintln(w)\n    return false\n}\n```", "```go\ngo get github.com/agnivade/levenshtein/...\n```", "```go\nfunc commandNotFound(w io.Writer, cmd string) {\n    var list []string\n    for _, c := range cmds {\n        d := levenshtein.ComputeDistance(c.Name, cmd)\n        if d < 3 {\n            list = append(list, c.Name)\n        }\n    }\n    fmt.Fprintf(w, \"Command %q not found.\", cmd)\n    if len(list) == 0 {\n        return\n    }\n    fmt.Fprint(w, \" Maybe you meant: \")\n    for i := range list {\n        if i > 0 {\n            fmt.Fprint(w, \", \")\n        }\n        fmt.Fprintf(w, \"%s\", list[i])\n    }\n}\n```", "```go\n// Command represents a terminal command\ntype Command interface {\n    GetName() string\n    GetHelp() string\n    Run(input io.Reader, output io.Writer, args ...string) (exit bool)\n}\n```", "```go\n// ErrDuplicateCommand is returned when two commands have the same name\nvar ErrDuplicateCommand = errors.New(\"Duplicate command\")\n\nvar commands []Command\n\n// Register adds the Command to the command list\nfunc Register(command Command) error {\n    name := command.GetName()\n    for i, c := range commands {\n        // unique commands in alphabetical order\n        switch strings.Compare(c.GetName(), name) {\n        case 0:\n            return ErrDuplicateCommand\n        case 1:\n            commands = append(commands, nil)\n            copy(commands[i+1:], commands[i:])\n            commands[i] = command\n            return nil\n        case -1:\n            continue\n        }\n    }\n    commands = append(commands, command)\n    return nil\n}\n```", "```go\n// Base is a basic Command that runs a closure\ntype Base struct {\n    Name, Help string\n    Action func(input io.Reader, output io.Writer, args ...string) bool\n}\n\nfunc (b Base) String() string { return b.Name }\n\n// GetName returns the Name\nfunc (b Base) GetName() string { return b.Name }\n\n// GetHelp returns the Help\nfunc (b Base) GetHelp() string { return b.Help }\n\n// Run calls the closure\nfunc (b Base) Run(input io.Reader, output io.Writer, args ...string) bool {\n    return b.Action(input, output, args...)\n}\n```", "```go\n// GetCommand returns the command with the given name\nfunc GetCommand(name string) Command {\n    for _, c := range commands {\n        if c.GetName() == name {\n            return c\n        }\n    }\n    return suggest\n}\n```", "```go\nvar suggest = Base{\n    Action: func(in io.Reader, w io.Writer, args ...string) bool {\n        var list []string\n        for _, c := range commands {\n            name := c.GetName()\n            d := levenshtein.ComputeDistance(name, args[0])\n            if d < 3 {\n                list = append(list, name)\n            }\n        }\n        fmt.Fprintf(w, \"Command %q not found.\", args[0])\n        if len(list) == 0 {\n            return false\n        }\n        fmt.Fprint(w, \" Maybe you meant: \")\n        for i := range list {\n            if i > 0 {\n                fmt.Fprint(w, \", \")\n            }\n            fmt.Fprintf(w, \"%s\", list[i])\n        }\n        return false\n    },\n}\n```", "```go\nfunc init() {\n    Register(Base{Name: \"help\", Help: \"...\", Action: helpAction})\n    Register(Base{Name: \"exit\", Help: \"...\", Action: exitAction})\n}\n\nfunc helpAction(in io.Reader, w io.Writer, args ...string) bool {\n    fmt.Fprintln(w, \"Available commands:\")\n    for _, c := range commands {\n        n := c.GetName()\n        fmt.Fprintf(w, \" - %-15s %s\\n\", n, c.GetHelp())\n    }\n    return false\n}\n\nfunc exitAction(in io.Reader, w io.Writer, args ...string) bool {\n    fmt.Fprintf(w, \"Goodbye! :)\\n\")\n    return true\n}\n```", "```go\n// Embedded unnamed field (inherits method)\ntype MyCmd struct {\n    Base\n    MyField string\n}\n\n// custom implementation\ntype MyImpl struct{}\n\nfunc (MyImpl) GetName() string { return \"myimpl\" }\nfunc (MyImpl) GetHelp() string { return \"help string\"}\nfunc (MyImpl) Run(input io.Reader, output io.Writer, args ...string) bool {\n    // do something\n    return true\n}\n```", "```go\ntype Stack struct {\n    data []string\n}\n\nfunc (s *Stack) push(values ...string) {\n    s.data = append(s.data, values...)\n}\n\nfunc (s *Stack) pop() (string, bool) {\n    if len(s.data) == 0 {\n        return \"\", false\n    }\n    v := s.data[len(s.data)-1]\n    s.data = s.data[:len(s.data)-1]\n    return v, true\n}\n```", "```go\nfunc (s *Stack) GetName() string {\n    return \"stack\"\n}\n\nfunc (s *Stack) GetHelp() string {\n    return \"a stack-like memory storage\"\n}\n```", "```go\nfunc (s *Stack) isValid(cmd string, args []string) bool {\n    switch cmd {\n    case \"pop\":\n        return len(args) == 0\n    case \"push\":\n        return len(args) > 0\n    default:\n        return false\n    }\n}\n```", "```go\nfunc (s *Stack) Run(r io.Reader, w io.Writer, args ...string) (exit bool) {\n    if l := len(args); l < 2 || !s.isValid(args[1], args[2:]) {\n        fmt.Fprintf(w, \"Use `stack push <something>` or `stack pop`\\n\")\n        return false\n    }\n    if args[1] == \"push\" {\n        s.push(args[2:]...)\n        return false\n    }\n    if v, ok := s.pop(); !ok {\n        fmt.Fprintf(w, \"Empty!\\n\")\n    } else {\n        fmt.Fprintf(w, \"Got: `%s`\\n\", v)\n    }\n    return false\n}\n```", "```go\ntype Command interface {\n    Startup() error\n    Shutdown() error\n    GetName() string\n    GetHelp() string\n    Run(r io.Reader, w io.Writer, args ...string) (exit bool)\n}\n```", "```go\n// Startup does nothing\nfunc (b Base) Startup() error { return nil }\n\n// Shutdown does nothing\nfunc (b Base) Shutdown() error { return nil }\n```", "```go\n// Shutdown executes shutdown for all commands\nfunc Shutdown(w io.Writer) {\n    for _, c := range commands {\n        if err := c.Shutdown(); err != nil {\n            fmt.Fprintf(w, \"%s: shutdown error: %s\", c.GetName(), err)\n        }\n    }\n}\n\n// Startup executes Startup for all commands\nfunc Startup(w io.Writer) {\n    for _, c := range commands {\n        if err := c.Startup(); err != nil {\n            fmt.Fprintf(w, \"%s: startup error: %s\", c.GetName(), err)\n        }\n    }\n}\n```", "```go\nfunc main() {\n    s, w, a, b := bufio.NewScanner(os.Stdin), os.Stdout, args{}, bytes.Buffer{}\n    command.Startup(w)\n    defer command.Shutdown(w) // this is executed before returning\n    fmt.Fprint(w, \"** Welcome to PseudoTerm! **\\nPlease enter a command.\\n\")\n    for {\n        // main loop\n    }\n}\n```", "```go\nfunc (s *Stack) getPath() (string, error) {\n    u, err := user.Current()\n    if err != nil {\n        return \"\", err\n    }\n    return filepath.Join(u.HomeDir, \".stack\"), nil\n}\n```", "```go\nfunc (s *Stack) Shutdown(w io.Writer) error {\n    path, err := s.getPath()\n    if err != nil {\n        return err\n    }\n    f, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0600)\n    if err != nil {\n        return err\n    }\n    defer f.Close()\n    for _, v := range s.data {\n        if _, err := fmt.Fprintln(f, v); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```", "```go\nfunc (s *Stack) Startup(w io.Writer) error {\n    path, err := s.getPath()\n    if err != nil {\n        return err\n    }\n    f, err := os.Open(path)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return nil\n        }\n        return err\n    }\n    defer f.Close()\n    s.data = s.data[:0]\n    scanner := bufio.NewScanner(f)\n    for scanner.Scan() {\n        s.push(string(scanner.Bytes()))\n    }\n    return nil\n}\n```"]