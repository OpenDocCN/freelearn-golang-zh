["```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    fmt.Println(\"Current PID:\", os.Getpid())\n    fmt.Println(\"Current Parent PID:\", os.Getppid())\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    fmt.Println(\"User ID:\", os.Getuid())\n    fmt.Println(\"Group ID:\", os.Getgid())\n    groups, err := os.Getgroups()\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(\"Group IDs:\", groups)\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/user\"\n    \"strconv\"\n)\n\nfunc main() {\n    uid := os.Getuid()\n    u, err := user.LookupId(strconv.Itoa(uid))\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"User: %s (uid %d)\\n\", u.Username, uid)\n    gid := os.Getgid()\n    group, err := user.LookupGroupId(strconv.Itoa(gid))\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Group: %s (uid %d)\\n\", group.Name, uid)\n}\n```", "```go\n// obtain working directory\nwd, err := os.Getwd()\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\nfmt.Println(\"Working Directory:\", wd)\nfmt.Println(\"Application:\", filepath.Join(wd, os.Args[0]))\n\n// create a new directory\nd := filepath.Join(wd, \"test\")\nif err := os.Mkdir(d, 0755); err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\nfmt.Println(\"Created\", d)\n\n// change the current directory\nif err := os.Chdir(d); err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\nfmt.Println(\"New Working Directory:\", d)\n```", "```go\ntype Cmd struct {\n    Path string // command to run.\n    Args []string // command line arguments (including command)\n    Env []string // environment of the process\n    Dir string // working directory\n    Stdin io.Reader // standard input`\n    Stdout io.Writer // standard output\n    Stderr io.Writer // standard error\n    ExtraFiles []*os.File // additional open files\n    SysProcAttr *syscall.SysProcAttr // os specific attributes\n    Process *os.Process // underlying process\n    ProcessState *os.ProcessState // information on exited processte\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc main() {\n    cmd := exec.Command(\"echo\", \"A\", \"sample\", \"command\")\n    fmt.Println(cmd.Path, cmd.Args[1:]) // echo [A sample command]\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc main() {\n    cmd := exec.Command(\"ls\", \"-l\")\n    if err := cmd.Start(); err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(\"Cmd: \", cmd.Args[0])\n    fmt.Println(\"Args:\", cmd.Args[1:])\n    fmt.Println(\"PID: \", cmd.Process.Pid)\n    cmd.Wait()\n}\n```", "```go\npackage main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"os\"\n    \"os/exec\"\n)\n\nfunc main() {\n    b := bytes.NewBuffer(nil)\n    cmd := exec.Command(\"cat\")\n    cmd.Stdin = b\n    cmd.Stdout = os.Stdout\n    fmt.Fprintf(b, \"Hello World! I'm using this memory address: %p\", b)\n    if err := cmd.Start(); err != nil {\n        fmt.Println(err)\n        return\n    }\n    cmd.Wait()\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/exec\"\n    \"time\"\n)\n\nvar pid = os.Getpid()\n\nfunc main() {\n    fmt.Printf(\"[%d] Start\\n\", pid)\n    fmt.Printf(\"[%d] PPID: %d\\n\", pid, os.Getppid())\n    defer fmt.Printf(\"[%d] Exit\\n\\n\", pid)\n    if len(os.Args) != 1 {\n        runDaemon()\n        return\n    }\n    if err := forkProcess(); err != nil {\n        fmt.Printf(\"[%d] Fork error: %s\\n\", pid, err)\n        return\n    }\n    if err := releaseResources(); err != nil {\n        fmt.Printf(\"[%d] Release error: %s\\n\", pid, err)\n        return\n    }\n}\n```", "```go\nfunc forkProcess() error {\n    cmd := exec.Command(os.Args[0], \"daemon\")\n    cmd.Stdout, cmd.Stderr, cmd.Dir = os.Stdout, os.Stderr, \"/\"\n    return cmd.Start()\n}\n```", "```go\nfunc releaseResources() error {\n    p, err := os.FindProcess(pid)\n    if err != nil {\n        return err\n    }\n    return p.Release()\n}\n```", "```go\nfunc runDaemon() {\n    for {\n        fmt.Printf(\"[%d] Daemon mode\\n\", pid)\n        time.Sleep(time.Second * 10)\n    }\n}\n```", "```go\n#!/bin/sh\n\n\"/path/to/mydaemon\" $1\n```", "```go\n// ErrSudo is an error that suggest to execute the command as super user\n// It will be used with the functions that fail because of permissions\nvar ErrSudo error\n\nvar (\n    bin string\n    cmd string\n)\n\nfunc init() {\n    p, err := filepath.Abs(filepath.Dir(os.Args[0]))\n    if err != nil {\n        panic(err)\n    }\n    bin = p\n    if len(os.Args) != 1 {\n        cmd = os.Args[1]\n    }\n    ErrSudo = fmt.Errorf(\"try `sudo %s %s`\", bin, cmd)\n}\n```", "```go\nfunc main() {\n    var err error\n    switch cmd {\n    case \"run\":\n        err = runApp()\n    case \"install\":\n        err = installApp()\n    case \"uninstall\":\n        err = uninstallApp()\n    case \"status\":\n        err = statusApp()\n    case \"start\":\n        err = startApp()\n    case \"stop\":\n        err = stopApp()\n    default:\n        helpApp()\n    }\n    if err != nil {\n        fmt.Println(cmd, \"error:\", err)\n    }\n}\n```", "```go\nconst (\n    varDir = \"/var/mydaemon/\"\n    pidFile = \"mydaemon.pid\"\n)\n\nfunc writePid(pid int) (err error) {\n    f, err := os.OpenFile(filepath.Join(varDir, pidFile), os.O_CREATE|os.O_WRONLY, 0644)\n    if err != nil {\n        return err\n    }\n    defer f.Close()\n    if _, err = fmt.Fprintf(f, \"%d\", pid); err != nil {\n        return err\n    }\n    return nil\n}\n\nfunc getPid() (pid int, err error) {\n    b, err := ioutil.ReadFile(filepath.Join(varDir, pidFile))\n    if err != nil {\n        return 0, err\n    }\n    if pid, err = strconv.Atoi(string(b)); err != nil {\n        return 0, fmt.Errorf(\"Invalid PID value: %s\", string(b))\n    }\n    return pid, nil\n}\n```", "```go\nconst initdFile = \"/etc/init.d/mydaemon\"\n\nfunc installApp() error {\n    _, err := os.Stat(initdFile)\n    if err == nil {\n        return errors.New(\"Already installed\")\n    }\n    f, err := os.OpenFile(initdFile, os.O_CREATE|os.O_WRONLY, 0755)\n    if err != nil {\n        if !os.IsPermission(err) {\n            return err\n        }\n        return ErrSudo\n    }\n    defer f.Close()\n    if _, err = fmt.Fprintf(f, \"#!/bin/sh\\n\\\"%s\\\" $1\", bin); err != nil {\n        return err\n    }\n    fmt.Println(\"Daemon\", bin, \"installed\")\n    return nil\n}\n\nfunc uninstallApp() error {\n    _, err := os.Stat(initdFile)\n    if err != nil && os.IsNotExist(err) {\n        return errors.New(\"not installed\")\n    }\n    if err = os.Remove(initdFile); err != nil {\n        if err != nil {\n            if !os.IsPermission(err) {\n                return err\n            }\n       return ErrSudo\n        }\n    }\n    fmt.Println(\"Daemon\", bin, \"removed\")\n    return err\n}\n```", "```go\nfunc statusApp() (err error) {\n    var pid int\n    defer func() {\n        if pid == 0 {\n            fmt.Println(\"status: not active\")\n            return\n        }\n        fmt.Println(\"status: active - pid\", pid)\n    }()\n    pid, err = getPid()\n    if err != nil {\n        if os.IsNotExist(err) {\n            return nil\n        }\n        return err\n    }\n    p, err := os.FindProcess(pid)\n    if err != nil {\n        return nil\n    }\n    if err = p.Signal(syscall.Signal(0)); err != nil {\n        fmt.Println(pid, \"not found - removing PID file...\")\n        os.Remove(filepath.Join(varDir, pidFile))\n        pid = 0\n    }\n    return nil\n}\n```", "```go\nfunc startApp() (err error) {\n    const perm = os.O_CREATE | os.O_APPEND | os.O_WRONLY\n    if err = os.MkdirAll(varDir, 0755); err != nil {\n        if !os.IsPermission(err) {\n            return err\n        }\n        return ErrSudo\n    }\n    cmd := exec.Command(bin, \"run\")\n    cmd.Stdout, err = os.OpenFile(filepath.Join(varDir, outFile),  \n        perm, 0644)\n            if err != nil {\n                 return err\n            }\n    cmd.Stderr, err = os.OpenFile(filepath.Join(varDir, errFile), \n        perm, 0644)\n            if err != nil {\n                return err\n           }\n    cmd.Dir = \"/\"\n    if err = cmd.Start(); err != nil {\n        return err\n    }\n    if err := writePid(cmd.Process.Pid); err != nil {\n        if err := cmd.Process.Kill(); err != nil {\n            fmt.Println(\"Cannot kill process\", cmd.Process.Pid, err)\n        }\n        return err\n    }\n    fmt.Println(\"Started with PID\", cmd.Process.Pid)\n    return nil\n}\n```", "```go\nfunc stopApp() (err error) {\n    pid, err := getPid()\n    if err != nil {\n        if os.IsNotExist(err) {\n            return nil\n        }\n        return err\n    }\n    p, err := os.FindProcess(pid)\n    if err != nil {\n        return nil\n    }\n    if err = p.Signal(os.Kill); err != nil {\n        return err\n    }\n    if err := os.Remove(filepath.Join(varDir, pidFile)); err != nil {\n        return err\n    }\n    fmt.Println(\"Stopped PID\", pid)\n    return nil\n}\n```", "```go\nfunc runApp() error {\n    fmt.Println(\"RUN\")\n    for {\n        time.Sleep(time.Second)\n    }\n    return nil\n}\n```", "```go\ntype Interface interface {\n    // Start provides a place to initiate the service. The service doesn't not\n    // signal a completed start until after this function returns, so the\n    // Start function must not take more than a few seconds at most.\n    Start(s Service) error\n\n    // Stop provides a place to clean up program execution before it is terminated.\n    // It should not take more than a few seconds to execute.\n    // Stop should not call os.Exit directly in the function.\n    Stop(s Service) error\n}\n```"]