["```go\npackage main\n\nimport (\n   \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    fmt.Println(\"Hello, playground\")\n    os.Exit(1)\n}\n```", "```go\n> echo  $? # will print 1\n\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    fmt.Println(\"Hello, playground\")\n    os.Exit(-1)\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    defer fmt.Println(\"Hello, playground\")\n    os.Exit(0)\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    defer fmt.Println(\"Hello, playground\")\n    panic(\"panic\")\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"time\"\n)\n\nfunc main() {\n    go func() {\n        defer fmt.Println(\"go end (deferred)\")\n        fmt.Println(\"go start\")\n        os.Exit(1)\n    }()\n    fmt.Println(\"main end (deferred)\")\n    fmt.Println(\"main start\")\n    time.Sleep(time.Second)\n    fmt.Println(\"main end\")\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/exec\"\n    \"syscall\"\n)\n\nfunc exitStatus(state *os.ProcessState) int {\n    status, ok := state.Sys().(syscall.WaitStatus)\n    if !ok {\n        return -1\n    }\n    return status.ExitStatus()\n}\n\nfunc main() {\n    cmd := exec.Command(\"ls\", \"__a__\")\n    if err := cmd.Run(); err != nil {\n        if status := exitStatus(cmd.ProcessState); status == -1 {\n            fmt.Println(err)\n        } else {\n            fmt.Println(\"Status:\", status)\n        }\n    }\n}\n```", "```go\nfunc processState(e error) *os.ProcessState {\n    err, ok := e.(*exec.ExitError)\n    if !ok {\n        return nil\n    }\n    return err.ProcessState\n}\n```", "```go\nsignal.Notify(ch, signalList...)\n```", "```go\npackage main\n\nimport (\n    \"log\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n)\n\nfunc main() {\n    log.Println(\"Start application...\")\n    c := make(chan os.Signal)\n    signal.Notify(c)\n    s := <-c\n    log.Println(\"Exit with signal:\", s)\n}\n```", "```go\n$ go build -o \"signal\" ch8/signal/base/base.go\n\n$ ./signal &\n[1] 265\n[Log] Start application...\n\n$ kill -6 265\n[Log] Exit with signal: aborted\n```", "```go\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"time\"\n)\n\nfunc main() {\n    f, err := os.OpenFile(\"file.txt\", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    w := bufio.NewWriter(f)\n    defer w.Flush()\n    for i := 0; i < 3; i++ {\n        fmt.Fprintln(w, \"hello\")\n        log.Println(i)\n        time.Sleep(time.Second)\n    }\n}\n```", "```go\nfunc main() {\n    c := make(chan os.Signal, syscall.SIGTERM)\n    signal.Notify(c)\n    f, err := os.OpenFile(\"file.txt\", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    w := bufio.NewWriter(f)\n    go func() {\n        <-c\n        w.Flush()\n        os.Exit(0)\n    }()\n    for i := 0; i < 3; i++ {\n        fmt.Fprintln(w, \"hello\")\n        log.Println(i)\n        time.Sleep(time.Second)\n    }\n}\n```", "```go\nfunc main() {\n    c := make(chan os.Signal, 1)\n    d := time.Second * 4\n    signal.Notify(c,\n        syscall.SIGHUP, syscall.SIGINT, syscall.SIGQUIT,\n        syscall.SIGUSR1, syscall.SIGUSR2, syscall.SIGALRM)\n    // initial load\n    if err := handleSignal(syscall.SIGHUP, &d); err != nil && \n        !os.IsNotExist(err) {\n            log.Fatal(err)\n    }\n\n    for {\n        select {\n        case s := <-c:\n            if err := handleSignal(s, &d); err != nil {\n                log.Printf(\"Error handling %s: %s\", s, err)\n                continue\n            }\n        default:\n            time.Sleep(d)\n            log.Println(\"After\", d, \"Executing action!\")\n        }\n    }\n}\n```", "```go\nfunc handleSignal(s os.Signal, d *time.Duration) error {\n    switch s {\n    case syscall.SIGHUP:\n        return loadSettings(d)\n    case syscall.SIGALRM:\n        return saveSettings(d)\n    case syscall.SIGINT:\n        if err := saveSettings(d); err != nil {\n            log.Println(\"Cannot save:\", err)\n            os.Exit(1)\n        }\n        fallthrough\n    case syscall.SIGQUIT:\n        os.Exit(0)\n    case syscall.SIGUSR1:\n        changeSettings(d, (*d)*2)\n        return nil\n    case syscall.SIGUSR2:\n        changeSettings(d, (*d)/2)\n        return nil\n    }\n    return nil\n}\n```", "```go\n\nfunc changeSettings(d *time.Duration, v time.Duration) {\n    *d = v\n    log.Println(\"Changed\", v)\n}\n\nfunc loadSettings(d *time.Duration) error {\n    b, err := ioutil.ReadFile(cfgPath)\n    if err != nil {\n        return err\n    }\n    var v time.Duration\n    if v, err = time.ParseDuration(string(b)); err != nil {\n        return err\n    }\n    *d = v\n    log.Println(\"Loaded\", v)\n    return nil\n}\n\nfunc saveSettings(d *time.Duration) error {\n    f, err := os.OpenFile(cfgPath,   \n        os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)\n            if err != nil {\n                return err\n            }\n        defer f.Close()\n\n    if _, err = fmt.Fprint(f, d); err != nil {\n        return err\n    }\n    log.Println(\"Saved\", *d)\n    return nil\n```", "```go\nvar cfgPath string\n\nfunc init() {\n    u, err := user.Current()\n    if err != nil {\n        log.Fatalln(\"user:\", err)\n    }\n    cfgPath = filepath.Join(u.HomeDir, \".multi\")\n}\n```", "```go\n$ go run ch08/signal/multi/multi.go\nLoaded 1s\nAfter 1s Executing action!\n\nChanged 2s\nAfter 2s Executing action!\n\nChanged 4s\nAfter 4s Executing action!\n\nChanged 2s\nAfter 2s Executing action!\n\nSaved 1s\n\n$\n```", "```go\n $ kill -SIGUSR1 $(pgrep multi)\n\n$ kill -SIGUSR1 $(pgrep multi)\n\n$ kill -SIGUSR2 $(pgrep multi)\n\n$ kill -SIGINT $(pgrep multi)\n\n```", "```go\np, err := os.FindProcess(pid)\nif err != nil {\n    panic(err)\n}\n```", "```go\nif err = p.Signal(syscall.SIGTERM); err != nil {\n    panic(err)\n}\n```", "```go\ncat book_list.txt | grep \"Game\" | wc -l\n```", "```go\nr1, w1 := io.Pipe()\nr2, w2 := io.Pipe()\n\nvar cmds = []*exec.Cmd{\n   exec.Command(\"cat\", \"book_list.txt\"),\n   exec.Command(\"grep\", \"Game\"),\n   exec.Command(\"wc\", \"-l\"),\n}\n```", "```go\ncmds[1].Stdin, cmds[0].Stdout = r1, w1\ncmds[2].Stdin, cmds[1].Stdout = r2, w2\ncmds[2].Stdout = os.Stdout\n```", "```go\nfor i := range cmds {\n    if err := cmds[i].Start(); err != nil {\n        log.Fatalln(\"Start\", i, err)\n    }\n}\n```", "```go\nfor i, closer := range []io.Closer{w1, w2, nil} {\n    if err := cmds[i].Wait(); err != nil {\n        log.Fatalln(\"Wait\", i, err)\n    }\n    if closer == nil {\n        continue\n    }\n    if err := closer.Close(); err != nil {\n        log.Fatalln(\"Close\", i, err)\n    }\n}\n```", "```go\nvar (\n    words = []string{\"Game\", \"Feast\", \"Dragons\", \"of\"}\n    cmds = make([][2]*exec.Cmd, len(words))\n    writers = make([]io.Writer, len(words))\n    buffers = make([]bytes.Buffer, len(words))\n    err error\n)\n```", "```go\nfor i := range words {\n    cmds[i][0] = exec.Command(\"grep\", words[i])\n    if writers[i], err = cmds[i][0].StdinPipe(); err != nil {\n        log.Fatal(\"in pipe\", i, err)\n    }\n    cmds[i][1] = exec.Command(\"wc\", \"-l\")\n    if cmds[i][1].Stdin, err = cmds[i][0].StdoutPipe(); err != nil {\n        log.Fatal(\"in pipe\", i, err)\n    }\n    cmds[i][1].Stdout = &buffers[i]\n}\n\ncat := exec.Command(\"cat\", \"book_list.txt\")\ncat.Stdout = io.MultiWriter(writers...)\n```", "```go\nfor i := range cmds {\n    if err := writers[i].(io.Closer).Close(); err != nil {\n        log.Fatalln(\"close 0\", i, err)\n    }\n}\n\nfor i := range cmds {\n    if err := cmds[i][0].Wait(); err != nil {\n        log.Fatalln(\"grep wait\", i, err)\n    }\n}\n```", "```go\nfor i := range cmds {\n    if err := cmds[i][1].Wait(); err != nil {\n        log.Fatalln(\"wc wait\", i, err)\n    }\n    count := bytes.TrimSpace(buffers[i].Bytes())\n    log.Printf(\"%10q %s entries\", cmds[i][0].Args[1], count)\n}\n```"]