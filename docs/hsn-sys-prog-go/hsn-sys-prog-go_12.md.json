["```go\nconn, err := net.Dial(\"tcp\", \"localhost:8080\")\n```", "```go\naddr, err := net.ResolveTCPAddr(\"tcp\", \"localhost:8080\")\nif err != nil {\n    // handle error\n}\nconn, err := net.DialTCP(\"tcp\", nil, addr)\nif err != nil {\n    // handle error\n}\n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        log.Fatalln(\"Please specify an address.\")\n    }\n    addr, err := net.ResolveTCPAddr(\"tcp\", os.Args[1])\n    if err != nil {\n        log.Fatalln(\"Invalid address:\", os.Args[1], err)\n    }\n    listener, err := net.ListenTCP(\"tcp\", addr)\n    if err != nil {\n        log.Fatalln(\"Listener:\", os.Args[1], err)\n    }\n    log.Println(\"<- Listening on\", addr)\n\n    go createConn(addr)\n\n    conn, err := listener.AcceptTCP()\n    if err != nil {\n        log.Fatalln(\"<- Accept:\", os.Args[1], err)\n    }\n    handleConn(conn)\n}\n```", "```go\nfunc createConn(addr *net.TCPAddr) {\n    defer log.Println(\"-> Closing\")\n    conn, err := net.DialTCP(\"tcp\", nil, addr)\n    if err != nil {\n        log.Fatalln(\"-> Connection:\", err)\n    }\n    log.Println(\"-> Connection to\", addr)\n    r := bufio.NewReader(os.Stdin)\n    for {\n        fmt.Print(\"# \")\n        msg, err := r.ReadBytes('\\n')\n        if err != nil {\n            log.Println(\"-> Message error:\", err)\n        }\n        if _, err := conn.Write(msg); err != nil {\n            log.Println(\"-> Connection:\", err)\n            return\n        }\n    }\n}\n```", "```go\nfunc handleConn(conn net.Conn) {\n    r := bufio.NewReader(conn)\n    time.Sleep(time.Second / 2)\n    for {\n        msg, err := r.ReadString('\\n')\n        if err != nil {\n            log.Println(\"<- Message error:\", err)\n            continue\n        }\n        switch msg = strings.TrimSpace(msg); msg {\n        case `\\q`:\n            log.Println(\"Exiting...\")\n            if err := conn.Close(); err != nil {\n                log.Println(\"<- Close:\", err)\n            }\n            time.Sleep(time.Second / 2)\n            return\n        case `\\x`:\n            log.Println(\"<- Special message `\\\\x` received!\")\n        default:\n            log.Println(\"<- Message Received:\", msg)\n        }\n    }\n}\n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        log.Fatalln(\"Please specify an address.\")\n    }\n    addr, err := net.ResolveTCPAddr(\"tcp\", os.Args[1])\n    if err != nil {\n        log.Fatalln(\"Invalid address:\", os.Args[1], err)\n    }\n    listener, err := net.ListenTCP(\"tcp\", addr)\n    if err != nil {\n        log.Fatalln(\"Listener:\", os.Args[1], err)\n    }\n    for {\n        time.Sleep(time.Millisecond * 100)\n        conn, err := listener.AcceptTCP()\n        if err != nil {\n            log.Fatalln(\"<- Accept:\", os.Args[1], err)\n        }\n        go handleConn(conn)\n    }\n}\n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        log.Fatalln(\"Please specify an address.\")\n    }\n    addr, err := net.ResolveTCPAddr(\"tcp\", os.Args[1])\n    if err != nil {\n        log.Fatalln(\"Invalid address:\", os.Args[1], err)\n    }\n    createConn(addr)\n}\n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        log.Fatalln(\"Please specify an address.\")\n    }\n    addr, err := net.ResolveUDPAddr(\"udp\", os.Args[1])\n    if err != nil {\n        log.Fatalln(\"Invalid address:\", os.Args[1], err)\n    }\n    conn, err := net.DialUDP(\"udp\", nil, addr)\n    if err != nil {\n        log.Fatalln(\"-> Connection:\", err)\n    }\n    log.Println(\"-> Connection to\", addr)\n    r := bufio.NewReader(os.Stdin)\n    b := make([]byte, 1024)\n    for {\n        fmt.Print(\"# \")\n        msg, err := r.ReadBytes('\\n')\n        if err != nil {\n            log.Println(\"-> Message error:\", err)\n        }\n        if _, err := conn.Write(msg); err != nil {\n            log.Println(\"-> Connection:\", err)\n            return\n        }\n        n, err := conn.Read(b)\n        if err != nil {\n            log.Println(\"<- Receive error:\", err)\n        }\n        msg = bytes.TrimSpace(b[:n])\n        log.Printf(\"<- %q\", msg)\n    }\n}\n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        log.Fatalln(\"Please specify an address.\")\n    }\n    addr, err := net.ResolveUDPAddr(\"udp\", os.Args[1])\n    if err != nil {\n        log.Fatalln(\"Invalid address:\", os.Args[1], err)\n    }\n    conn, err := net.ListenUDP(\"udp\", addr)\n    if err != nil {\n        log.Fatalln(\"Listener:\", os.Args[1], err)\n    }\n\n    b := make([]byte, 1024)\n    for {\n        n, addr, err := conn.ReadFromUDP(b)\n        if err != nil {\n            log.Println(\"<-\", addr, \"Message error:\", err)\n            continue\n        }\n        msg := bytes.TrimSpace(b[:n])\n        log.Printf(\"<- %q from %s\", msg, addr)\n        for i, l := 0, len(msg); i < l/2; i++ {\n            msg[i], msg[l-1-i] = msg[l-1-i], msg[i]\n        }\n        msg = append(msg, '\\n')\n        if _, err := conn.WriteTo(b[:n], addr); err != nil {\n            log.Println(\"->\", addr, \"Send error:\", err)\n        }\n    }\n}\n```", "```go\nfunc Checksum(b []byte) []byte {\n    var sum uint64\n    for len(b) >= 5 {\n        for i := range b[:5] {\n            v := uint64(b[i])\n            for j := 0; j < i; j++ {\n                v = v * 256\n            }\n            sum += v\n        }\n        b = b[5:]\n    }\n    for _, v := range b {\n        sum += uint64(v)\n    }\n    s := make([]byte, 8)\n    binary.LittleEndian.PutUint64(s, sum)\n    return s[:4]\n}\n```", "```go\nvar ErrLength = errors.New(\"message too long\")\n\nfunc CreateMessage(content []byte) ([]byte, error) {\n    if len(content) > 65535 {\n        return nil, ErrLength\n    }\n    data := make([]byte, 0, len(content)+14)\n    data = append(data, Sequence...)\n    data = append(data, byte(len(content)/256), byte(len(content)%256))\n    data = append(data, Checksum(content)...)\n    data = append(data, content...)\n    data = append(data, Sequence...)\n    return data, nil\n}\n```", "```go\nfunc MessageContent(b []byte) ([]byte, error) {\n    n := len(b)\n    if n < 14 {\n        return nil, fmt.Errorf(\"Too short\")\n    }\n    if open := b[:4]; !bytes.Equal(open, Sequence) {\n        return nil, fmt.Errorf(\"Wrong opening sequence %x\", open)\n    }\n    if length := int(b[4])*256 + int(b[5]); n-14 != length {\n        return nil, fmt.Errorf(\"Wrong length: %d (expected %d)\", length, n-14)\n    }\n    if close := b[n-4 : n]; !bytes.Equal(close, Sequence) {\n        return nil, fmt.Errorf(\"Wrong closing sequence %x\", close)\n    }\n    content := b[10 : n-4]\n    if !bytes.Equal(Checksum(content), b[6:10]) {\n        return nil, fmt.Errorf(\"Wrong checksum\")\n    }\n    return content, nil\n}\n```", "```go\n// Send\ndata, err := common.CreateMessage(msg)\nif err != nil {\n    log.Println(\"->\", addr, \"Encode error:\", err)\n    continue\n}\nif _, err := conn.WriteTo(data, addr); err != nil {\n    log.Println(\"->\", addr, \"Send error:\", err)\n}\n```", "```go\n//Receive\nn, addr, err := conn.ReadFromUDP(b)\nif err != nil {\n    log.Println(\"<-\", addr, \"Message error:\", err)\n    continue\n}\nmsg, err := common.MessageContent(b[:n])\nif err != nil {\n    log.Println(\"<-\", addr, \"Decode error:\", err)\n    continue\n}\nlog.Printf(\"<- %q from %s\", msg, addr)\n```", "```go\nPOST /resource/ HTTP/1.1\nUser-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)\nHost: www.website.com\nContent-Length: 1024\nAccept-Language: en-us\n\nthe actual request content\nthat is optional\n```", "```go\nHTTP/1.1 200 OK\nContent-Length: 88\nContent-Type: text/html\n\n<html>\n  <body>\n    <h1>Sample Page</h1>\n  </body>\n</html>\n```", "```go\nresp, err := http.Get(\"http://example.com/\")\nresp, err := client.Get(\"http://example.com/\")\n...\nresp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", &buf)\nresp, err := client.Post(\"http://example.com/upload\", \"image/jpeg\", &buf)\n...\nvalues := url.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}}\nresp, err := http.PostForm(\"http://example.com/form\", values)\nresp, err := client.PostForm(\"http://example.com/form\", values)\n```", "```go\nreq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n// ...\nreq.Header.Add(\"Content-Type\", \"text/html\")\nresp, err := client.Do(req)\n// ...\n```", "```go\ntype logTripper struct {\n    http.RoundTripper\n}\n\nfunc (l logTripper) RoundTrip(r *http.Request) (*http.Response,  \n    error) {\n        log.Println(r.URL)\n        r.Header.Set(\"X-Log-Time\", time.Now().String())\n        return l.RoundTripper.RoundTrip(r)\n}\n```", "```go\nfunc main() {\n    client := http.Client{Transport: logTripper{http.DefaultTransport}}\n    req, err := http.NewRequest(\"GET\", \"https://www.google.com/search?q=golang+net+http\", nil)\n    if err != nil {\n        log.Fatal(err)\n    }\n    resp, err := client.Do(req)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer resp.Body.Close()\n    log.Println(\"Status code:\", resp.StatusCode)\n}\n```", "```go\ntype customHandler int\n\nfunc (c *customHandler) ServeHTTP(w http.ResponseWriter, r  \n    *http.Request) {\n        fmt.Fprintf(w, \"%d\", *c)\n        *c++\n}\n\nfunc main() {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/hello\", func(w http.ResponseWriter, r \n        *http.Request) {\n            fmt.Fprintf(w, \"Hello!\")\n    })\n    mux.HandleFunc(\"/bye\", func(w http.ResponseWriter, r \n        *http.Request) {\n            fmt.Fprintf(w, \"Goodbye!\")\n    })\n    mux.HandleFunc(\"/error\", func(w http.ResponseWriter, r \n        *http.Request) {\n            w.WriteHeader(http.StatusInternalServerError)\n            fmt.Fprintf(w, \"An error occurred!\")\n    })\n    mux.Handle(\"/custom\", new(customHandler))\n    if err := http.ListenAndServe(\":3000\", mux); err != nil {\n        log.Fatal(err)\n    }\n}\n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        log.Fatalln(\"Please specify a directory\")\n    }\n    s, err := os.Stat(os.Args[1])\n    if err == nil && !s.IsDir() {\n        err = errors.New(\"not a directory\")\n    }\n    if err != nil {\n        log.Fatalln(\"Invalid path:\", err)\n    }\n    http.Handle(\"/\", http.FileServer(http.Dir(os.Args[1])))\n    if err := http.ListenAndServe(\":3000\", nil); err != nil {\n        log.Fatal(err)\n    }\n}\n```", "```go\nswitch r.Method {\ncase http.MethodGet:\n    // GET implementation\ncase http.MethodPost:\n    // POST implementation\ndefault:\n    http.NotFound(w, r)\n}\n```", "```go\ntype methodHandler map[string]http.Handler\n\nfunc (m methodHandler) ServeHTTP(w http.ResponseWriter, r \n        *http.Request) {\n            h, ok := m[strings.ToUpper(r.Method)]\n            if !ok {\n                http.NotFound(w, r)\n                return\n            }\n    h.ServeHTTP(w, r)\n}\n```", "```go\nfunc main() {\n    http.HandleFunc(\"/path1\", methodHandler{\n        http.MethodGet: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            fmt.Fprint(w, \"Showing record\")\n        }),\n        http.MethodPost: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            fmt.Fprint(w, \"Updated record\")\n        }),\n    })\n    if err := http.ListenAndServe(\":3000\", nil); err != nil {\n        log.Fatal(err)\n    }\n}\n```", "```go\nMIME-Version: 1.0\nContent-Type: multipart/mixed; boundary=xxxx\n\nThis part before boundary is ignored\n--xxxx\nContent-Type: text/plain\n\nFirst part of the message. The next part is binary data encoded in base64\n--xxxx\nContent-Type: application/octet-stream\nContent-Transfer-Encoding: base64\n\nPGh0bWw+CiAgPGhlYWQ+CiAgPC9oZWFkPgogIDxib2R5PgogICAgPHA+VGhpcyBpcyB0aGUg\nYm9keSBvZiB0aGUgbWVzc2FnZS48L3A+CiAgPC9ib2R5Pgo8L2h0bWw+Cg==\n--xxxx--\n```", "```go\nconst (\n    param = \"file\"\n    endpoint = \"/upload\"\n    content = `<html><body>` +\n        `<form enctype=\"multipart/form-data\" action=\"%s\" method=\"POST\">` +\n        `<input type=\"file\" name=\"%s\"/><input type=\"submit\" \n    value=\"Upload\"/>` +\n        `</form></html></body>`\n)\n```", "```go\nmux.HandleFunc(endpoint, func(w http.ResponseWriter, r \n    *http.Request) {\n        if r.Method == \"GET\" {\n            fmt.Fprintf(w, content, endpoint, param)\n            return\n        } else if r.Method != \"POST\" {\n            http.NotFound(w, r)\n            return\n        }\n\n    path, err := upload(r)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    fmt.Fprintf(w, \"Uploaded to %s\", path)\n})\n```", "```go\nfunc upload(r *http.Request) (string, error) {\n    f, h, err := r.FormFile(param)\n    if err != nil {\n        return \"\", err\n    }\n    defer f.Close()\n\n    p := filepath.Join(os.TempDir(), h.Filename)\n    fw, err := os.OpenFile(p, os.O_WRONLY|os.O_CREATE, 0666)\n    if err != nil {\n        return \"\", err\n    }\n    defer fw.Close()\n\n    if _, err = io.Copy(fw, f); err != nil {\n        return \"\", err\n    }\n    return p, nil\n}\n```", "```go\n> openssl genrsa -out server.key 2048\n\n> openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650\n```", "```go\nfunc main() {\n    http.HandleFunc(\"/hello\", func(w http.ResponseWriter, r \n        *http.Request) {\n            fmt.Fprint(w, \"Hello!\")\n    })\n    err := http.ListenAndServeTLS(\":443\", \"server.crt\", \"server.key\", nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe: \", err)\n    }\n}\n```", "```go\nr := mux.NewRouter()\n// only local requests\nr.Host(\"localhost:3000\")\n// only when some header is present\nr.Headers(\"X-Requested-With\", \"XMLHttpRequest\")\nonly when a query parameter is specified\nr.Queries(\"access_key\", \"0x20\")\n```", "```go\nr := mux.NewRouter()\nr.HandleFunc(\"/products/\", ProductsHandler)\nr.HandleFunc(\"/products/{key}/\", ProductHandler)\nr.HandleFunc(\"/products/{key}/details\", ProductDetailsHandler)\n...\n// inside an handler\nvars := mux.Vars(request)\nkey:= vars[\"key\"]\n```", "```go\nr := mux.NewRouter()\ns := r.PathPrefix(\"/products\").Subrouter()\ns.HandleFunc(\"/\", ProductsHandler)\ns.HandleFunc(\"/{key}/\", ProductHandler)\ns.HandleFunc(\"/{key}/details\", ProductDetailsHandler)\n```", "```go\nr := mux.NewRouter()\npub := r.PathPrefix(\"/public\").Subrouter()\npub.HandleFunc(\"/login\", LoginHandler)\npriv := r.PathPrefix(\"/private\").Subrouter()\npriv.Use(AuthHandler)\npriv.HandleFunc(\"/profile\", ProfileHandler)\npriv.HandleFunc(\"/logout\", LogoutHandler)\n```", "```go\nrouter := gin.Default()\n\nrouter.GET(\"/resource\", getResource)\nrouter.POST(\"/resource\", createResource)\nrouter.PUT(\"/resource\", updateResoure)\nrouter.DELETE(\"/resource\", deleteResource)\n// with use grouping\ng := router.Group(\"/resource\")\ng.GET(\"\", getResource)\ng.POST(\"\", createResource)\ng.PUT(\"\", updateResoure)\ng.DELETE(\"\", deleteResource)\n```", "```go\nrouter := gin.Default()\nrouter.GET(\"/hello/:name\", func(c *gin.Context) {\n    c.String(http.StatusOK, \"Hello %s!\", c.Param(\"name\"))\n})\n```", "```go\nfunc main() {\n    const imgPath = \"/image.svg\"\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r \n        *http.Request) {\n            pusher, ok := w.(http.Pusher)\n            if ok {\n                fmt.Println(\"Push /image\")\n                pusher.Push(imgPath, nil)\n            }\n        w.Header().Add(\"Content-Type\", \"text/html\")\n        fmt.Fprintf(w, `<html><body><img src=\"img/%s\"/>`+\n            `</body></html>`, imgPath)\n    })\n    http.HandleFunc(imgPath, func(w http.ResponseWriter, r \n        *http.Request) {\n            w.Header().Add(\"Content-Type\", \"image/svg+xml\")\n            fmt.Fprint(w, `<?xml version=\"1.0\" standalone=\"no\"?>\n<svg >\n  <rect width=\"150\" height=\"150\" style=\"fill:blue\"/>\n</svg>`)\n    })\n    if err := http.ListenAndServe(\":3000\", nil); err != nil {\n        fmt.Println(err)\n    }\n}\n```", "```go\nvar data = struct {\n    Question string\n    Answer int\n}{\n    Question: \"Answer to the Ultimate Question of Life, \" +\n        \"the Universe, and Everything\",\n    Answer: 42,\n}\ntpl, err := template.New(\"question-answer\").Parse(`\n    <p>Question: {{.Question}}</p>\n    <p>Answer: {{.Answer}}</p>\n`)\nif err != nil {\n    log.Fatalln(\"Error:\", err)\n}\nif err = tpl.Execute(os.Stdout, data); err != nil {\n    log.Fatalln(\"Error:\", err)\n}\n```", "```go\n<html>\n    <body>\n        <h1>{{.name}}</h1>\n        <ul>\n            <li>First appearance: {{.appearance}}</li>\n            <li>Style: {{.style}}</li>\n        </ul>\n    </body>\n</html>\n```", "```go\nfunc main() {\n    tpl, err := template.ParseGlob(\"ch9/template/parse/*.html\")\n    if err != nil {\n        log.Fatal(\"Error:\", err)\n    }\n    data := map[string]string{\n        \"name\": \"Jin Kazama\",\n        \"style\": \"Karate\",\n        \"appearance\": \"Tekken 3\",\n    }\n    if err := tpl.Execute(os.Stdout, data); err != nil {\n        log.Fatal(\"Error:\", err)\n    }\n}\n```", "```go\nvar a = []int{1, 2, 3, 4}\n`{{ range . }} {{.}} {{ end }}` // simple\n`{{ range $v := . }} {{$v}} {{ end }}` // value\n`{{ range $i, $v := . }} {{$v}} {{ end }}` // index and value\n```", "```go\nvar data = []struct {\n    Question, Answer string\n}{{\n    Question: \"Answer to the Ultimate Question of Life, \" +\n        \"the Universe, and Everything\",\n    Answer: \"42\",\n}, {\n    Question: \"Who you gonna call?\",\n    Answer: \"Ghostbusters\",\n}}\ntpl, err := template.New(\"question-answer\").Parse(`{{range .}}\nQuestion: {{.Question}}\nAnswer: {{.Answer}}\n{{end}}`)\nif err != nil {\n    log.Fatalln(\"Error:\", err)\n}\nif err = tpl.Execute(os.Stdout, data); err != nil {\n    log.Fatalln(\"Error:\", err)\n}\n```", "```go\nvar data = []struct {\n    Name string\n    Score int\n}{\n    {\"Michelangelo\", 30},\n    {\"Donatello\", 50},\n    {\"Leonardo\", 80},\n    {\"Raffaello\", 100},\n}\ntpl, err := template.New(\"question-answer\").Parse(`{{range .}}\n{{.Name}} scored {{.Score}}. He did {{if lt .Score 50}}bad{{else if lt .Score 75}}okay{{else if lt .Score 90}}good{{else}}great{{end}}\n{{end}}`)\nif err != nil {\n    log.Fatalln(\"Error:\", err)\n}\nif err = tpl.Execute(os.Stdout, data); err != nil {\n    log.Fatalln(\"Error:\", err)\n}\n```", "```go\nvar data = struct {\n    Name, Surname, Occupation, City string\n}{\n    \"Bojack\", \"Horseman\", \"Actor\", \"Los Angeles\",\n}\ntpl, err := template.New(\"question-answer\").Funcs(template.FuncMap{\n    \"upper\": func(s string) string { return strings.ToUpper(s) },\n    \"lower\": func(s string) string { return strings.ToLower(s) },\n}).Parse(`{{.Name}} {{.Surname}} - {{lower .Occupation}} from {{upper .City}}`)\nif err != nil {\n    log.Fatalln(\"Error:\", err)\n}\nif err = tpl.Execute(os.Stdout, data); err != nil {\n    log.Fatalln(\"Error:\", err)\n}\n```", "```go\n// Book represents a book entry\ntype Book struct {\n    ISBN string\n    Title, Author string\n    Year, Pages int\n}\n\n// ReadingList keeps tracks of books and pages read\ntype ReadingList struct {\n    Books []Book\n    Progress []int\n}\n```", "```go\nfunc (r *ReadingList) bookIndex(isbn string) int {\n    for i := range r.Books {\n        if isbn == r.Books[i].ISBN {\n            return i\n        }\n    }\n    return -1\n}\n```", "```go\n// AddBook checks if the book is not present and adds it\nfunc (r *ReadingList) AddBook(b Book) error {\n    if b.ISBN == \"\" {\n        return ErrISBN\n    }\n    if r.bookIndex(b.ISBN) != -1 {\n        return ErrDuplicate\n    }\n    r.Books = append(r.Books, b)\n    r.Progress = append(r.Progress, 0)\n    return nil\n}\n\n// RemoveBook removes the book from list and forgets its progress\nfunc (r *ReadingList) RemoveBook(isbn string) error {\n    if isbn == \"\" {\n        return ErrISBN\n    }\n    i := r.bookIndex(isbn)\n    if i == -1 {\n        return ErrMissing\n    }\n    // replace the deleted book with the last of the list\n    r.Books[i] = r.Books[len(r.Books)-1]\n    r.Progress[i] = r.Progress[len(r.Progress)-1]\n    // shrink the list of 1 element to remove the duplicate\n    r.Books = r.Books[:len(r.Books)-1]\n    r.Progress = r.Progress[:len(r.Progress)-1]\n    return nil\n}\n```", "```go\n// GetProgress returns the progress of a book\nfunc (r *ReadingList) GetProgress(isbn string) (int, error) {\n if isbn == \"\" {\n return -1, ErrISBN\n }\n i := r.bookIndex(isbn)\n if i == -1 {\n return -1, ErrMissing\n }\n return r.Progress[i], nil\n}\n```", "```go\nfunc (r *ReadingList) SetProgress(isbn string, pages int) error {\n if isbn == \"\" {\n return ErrISBN\n }\n i := r.bookIndex(isbn)\n if i == -1 {\n return ErrMissing\n }\n if p := r.Books[i].Pages; pages > p {\n pages = p\n }\n r.Progress[i] = pages\n return nil\n}\n```", "```go\n\nfunc (r *ReadingList) AdvanceProgress(isbn string, pages int) error {\n    if isbn == \"\" {\n        return ErrISBN\n    }\n    i := r.bookIndex(isbn)\n    if i == -1 {\n        return ErrMissing\n    }\n    if p := r.Books[i].Pages - r.Progress[i]; p < pages {\n        pages = p\n    }\n    r.Progress[i] += pages\n    return nil\n}\n```", "```go\n// List of errors\nvar (\n    ErrISBN = fmt.Errorf(\"missing ISBN\")\n    ErrDuplicate = fmt.Errorf(\"duplicate book\")\n    ErrMissing = fmt.Errorf(\"missing book\")\n)\n```", "```go\n// ReadingService adapts ReadingList for RPC\ntype ReadingService struct {\n    ReadingList\n}\n\n// sets the success pointer value from error\nfunc setSuccess(err error, b *bool) error {\n    *b = err == nil\n    return err\n}\n```", "```go\nfunc (r *ReadingService) AddBook(b Book, success *bool) error {\n    return setSuccess(r.ReadingList.AddBook(b), success)\n}\n\nfunc (r *ReadingService) RemoveBook(isbn string, success *bool) error {\n    return setSuccess(r.ReadingList.RemoveBook(isbn), success)\n}\n```", "```go\nfunc (r *ReadingService) GetProgress(isbn string, pages *int) (err error) {\n    *pages, err = r.ReadingList.GetProgress(isbn)\n    return err\n}\n\ntype Progress struct {\n    ISBN string\n    Pages int\n}\n\nfunc (r *ReadingService) SetProgress(p Progress, success *bool) error {\n    return setSuccess(r.ReadingList.SetProgress(p.ISBN, p.Pages), success)\n}\n\nfunc (r *ReadingService) AdvanceProgress(p Progress, success *bool) error {\n    return setSuccess(r.ReadingList.AdvanceProgress(p.ISBN, p.Pages), success)\n}\n```", "```go\nif len(os.Args) != 2 {\n    log.Fatalln(\"Please specify an address.\")\n}\nif err := rpc.Register(&common.ReadingService{}); err != nil {\n    log.Fatalln(err)\n}\nrpc.HandleHTTP()\n\nl, err := net.Listen(\"tcp\", os.Args[1])\nif err != nil {\n    log.Fatalln(err)\n}\nlog.Println(\"Server Started\")\nif err := http.Serve(l, nil); err != nil {\n    log.Fatal(err)\n}\n```", "```go\nif len(os.Args) != 2 {\n    log.Fatalln(\"Please specify an address.\")\n}\nclient, err := rpc.DialHTTP(\"tcp\", os.Args[1])\nif err != nil {\n    log.Fatalln(err)\n}\ndefer client.Close()\n```", "```go\nconst hp = \"H.P. Lovecraft\"\nvar books = []common.Book{\n    {ISBN: \"1540335534\", Author: hp, Title: \"The Call of Cthulhu\", Pages: 36},\n    {ISBN: \"1980722803\", Author: hp, Title: \"The Dunwich Horror \", Pages: 53},\n    {ISBN: \"197620299X\", Author: hp, Title: \"The Shadow Over Innsmouth\", Pages: 40},\n    {ISBN: \"1540335534\", Author: hp, Title: \"The Case of Charles Dexter Ward\", Pages: 176},\n}\n```", "```go\nfunc callClient(client *rpc.Client, method string, in, out interface{}) {\n    var r interface{}\n    if err := client.Call(method, in, out); err != nil {\n        out = err\n    }\n    switch v := out.(type) {\n    case error:\n        r = v\n    case *int:\n        r = *v\n    case *bool:\n        r = *v\n    }\n    log.Printf(\"%s: [%+v] -> %+v\", method, in, r)\n}\n```", "```go\ncallClient(client, \"ReadingService.GetProgress\", books[0].ISBN, new(int))\ncallClient(client, \"ReadingService.AddBook\", books[0], new(bool))\ncallClient(client, \"ReadingService.AddBook\", books[0], new(bool))\ncallClient(client, \"ReadingService.GetProgress\", books[0].ISBN, new(int))\ncallClient(client, \"ReadingService.AddBook\", books[1], new(bool))\ncallClient(client, \"ReadingService.AddBook\", books[2], new(bool))\ncallClient(client, \"ReadingService.AddBook\", books[3], new(bool))\ncallClient(client, \"ReadingService.SetProgress\", common.Progress{\n    ISBN: books[3].ISBN,\n    Pages: 10,\n}, new(bool))\ncallClient(client, \"ReadingService.GetProgress\", books[3].ISBN, new(int))\ncallClient(client, \"ReadingService.AdvanceProgress\", common.Progress{\n    ISBN: books[3].ISBN,\n    Pages: 40,\n}, new(bool))\ncallClient(client, \"ReadingService.GetProgress\", books[3].ISBN, new(int))\n```"]