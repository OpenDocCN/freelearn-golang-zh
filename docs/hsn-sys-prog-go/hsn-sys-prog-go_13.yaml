- en: Data Encoding Using Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go进行数据编码
- en: This chapter will show you how to use the more common encoding for exchanging
    data in an application. Encoding is the process of transforming data, and it can
    be used when an application has to communicate with another—using the same encoding
    will allow the two programs to understand each other. This chapter will explain
    how to handle text-based protocols such as JSON, first of all, and then how to
    use binary protocols such as `gob`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何使用更常见的编码来交换应用程序中的数据。编码是将数据转换的过程，当应用程序必须与另一个应用程序通信时可以使用它——使用相同的编码将允许两个程序相互理解。本章将解释如何处理基于文本的协议，如首先是JSON，然后是如何使用二进制协议，如`gob`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using text-based encoding such as JSON and XML
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于文本的编码，如JSON和XML
- en: Learning about binary encoding such as `gob` and `protobuf`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习二进制编码，如`gob`和`protobuf`
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, please refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装Go并设置您喜欢的编辑器。有关更多信息，请参阅[第3章](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml)，*Go概述*。
- en: In order to use the protocol buffer, you will need to install the `protobuf`
    library. Instructions are available at [https://github.com/golang/protobuf](https://github.com/golang/protobuf).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用协议缓冲区，您需要安装`protobuf`库。有关说明，请访问[https://github.com/golang/protobuf](https://github.com/golang/protobuf)。
- en: Understanding text-based encoding
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基于文本的编码
- en: The most human-readable data serialization format is the text-based format.
    In this section, we will analyze some of the most used text-based encoding—CSV,
    JSON, XML, and YAML.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最易读的数据序列化格式是基于文本的格式。在本节中，我们将分析一些最常用的基于文本的编码方式，如CSV、JSON、XML和YAML。
- en: CSV
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSV
- en: '**Comma-separated values** (**CSV**) is a type of text encoding that stores
    data in a tabular form. Each line is a table entry and values of a line are separated
    by a special character, which is usually a comma—hence, the name CSV. Each record
    of the CSV file must have the same value count and the first record can be used
    as a header to describe each record field:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**逗号分隔值**（**CSV**）是一种以文本形式存储数据的编码类型。每一行都是表格条目，一行的值由一个特殊字符分隔，通常是逗号，因此称为CSV。CSV文件的每个记录必须具有相同的值计数，并且第一个记录可以用作标题来描述每个记录字段：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: String values can be quoted in order to permit the use of the comma.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串值可以用引号引起来，以允许使用逗号。
- en: Decoding values
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码值
- en: 'Go allows users to create a CSV reader from any `io.Reader`. It is possible
    to read records one by one using the `Read` method:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go允许用户从任何`io.Reader`创建CSV读取器。可以使用`Read`方法逐个读取记录：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A full example of the preceding code is available at [https://play.golang.org/p/wZgVzMqAN_K](https://play.golang.org/p/wZgVzMqAN_K).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的完整示例可在[https://play.golang.org/p/wZgVzMqAN_K](https://play.golang.org/p/wZgVzMqAN_K)找到。
- en: 'Note that each record is a string slice and the reader is expecting the length
    of each row to be consistent. If a row has more or fewer entries than the first,
    this will result in an error. It is also possible to read all records at once
    using `ReadAll`. The same example from before using such a method will look like
    this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每条记录都是一个字符串切片，读取器期望每行的长度保持一致。如果一行的条目比第一行多或少，这将导致错误。还可以使用`ReadAll`一次读取所有记录。使用此方法的相同示例将如下所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A full example of the preceding code is available at [https://play.golang.org/p/RJ-wxBB5fs6](https://play.golang.org/p/RJ-wxBB5fs6).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的完整示例可在[https://play.golang.org/p/RJ-wxBB5fs6](https://play.golang.org/p/RJ-wxBB5fs6)找到。
- en: Encoding values
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码值
- en: 'A CSV writer can be created using any `io.Writer`. The resulting writer will
    be buffered, so, in order to not lose data, it is necessary to call its method, `Flush`:
    this will ensure that the buffer gets drained and all content goes to the writer.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任何`io.Writer`创建CSV写入器。生成的写入器将被缓冲，因此为了不丢失数据，需要调用其方法`Flush`：这将确保缓冲区被清空，并且所有内容都传输到写入器。
- en: 'The `Write` method receives a string slice and encodes it in CSV format. Let''s
    see how it works in the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write`方法接收一个字符串切片并以CSV格式对其进行编码。让我们看看下面的示例中它是如何工作的：'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A full example of the preceding code is available at [https://play.golang.org/p/qwaz3xCJhQT](https://play.golang.org/p/qwaz3xCJhQT).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的完整示例可在[https://play.golang.org/p/qwaz3xCJhQT](https://play.golang.org/p/qwaz3xCJhQT)找到。
- en: 'As it happens, for the reader, there is a method for writing more than one
    record at once. It is known as `WriteAll`, and we can see it in the next example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如读者所知，有一种方法可以一次写入多条记录。它被称为`WriteAll`，我们可以在下一个示例中看到它：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A full example of the preceding code is available at [https://play.golang.org/p/lt_GBOLvUfk](https://play.golang.org/p/lt_GBOLvUfk).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的完整示例可在[https://play.golang.org/p/lt_GBOLvUfk](https://play.golang.org/p/lt_GBOLvUfk)找到。
- en: The main difference between `Write` and `WriteAll` is that the second operation
    uses more resources and it requires us to convert the records into a slice of
    string slices before calling it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write`和`WriteAll`之间的主要区别是第二个操作使用更多资源，并且在调用之前需要将记录转换为字符串切片。'
- en: Custom options
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义选项
- en: 'Both reader and writer have some options that can be changed after creation.
    Both structures share the `Comma` field, which is the character used for separating
    fields. Another important field that belongs to the writer only is `FieldsPerRecord`,
    which is an integer that determines how many fields the reader should expect for
    each record:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 读取器和写入器都有一些选项，可以在创建后更改。两个结构共享`Comma`字段，该字段是用于分隔字段的字符。还属于仅写入器的另一个重要字段是`FieldsPerRecord`，它是一个整数，确定读取器应为每个记录期望多少个字段。
- en: If greater than `0`, it will be the number of field required.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果大于`0`，它将是所需字段的数量。
- en: If equal to `0` it will set to the number of field of the first record.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果等于`0`，它将设置为第一条记录的字段数。
- en: If negative, all checks on the field count will be skipped, allowing for the
    reading of inconsistent sets of records.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果为负，则将跳过对字段计数的所有检查，从而允许读取不一致的记录集。
- en: 'Let''s look at a practical example of a reader that is not checking for consistency
    and uses a space as a separator:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个实际的例子，一个不检查一致性并使用空格作为分隔符的读取器：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A full example of the preceding code is available at [https://play.golang.org/p/KPHXRW5OxXT](https://play.golang.org/p/KPHXRW5OxXT).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的完整示例可在[https://play.golang.org/p/KPHXRW5OxXT](https://play.golang.org/p/KPHXRW5OxXT)找到。
- en: JSON
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: '**JavaScript Object Notation** (**JSON**) is a lightweight, text-based data
    interchange format. Its nature enables humans to read and write it easily, and
    its small overhead makes it very suitable for web-based applications.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）是一种轻量级的基于文本的数据交换格式。它的性质使人类能够轻松阅读和编写它，其小的开销使其非常适合基于Web的应用程序。'
- en: 'There are two main types of entities that compose JSON:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JSON由两种主要类型的实体组成：
- en: '**Collections of name/value pairs**: The name/value is represented as an object,
    structure, or dictionary in various programming languages.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称/值对的集合**：名称/值表示为对象、结构或字典在各种编程语言中。'
- en: '**Ordered lists of values**: These are lists of collections or values, which
    are usually represented as arrays or lists.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有序值列表**：这些是集合或值的列表，通常表示为数组或列表。'
- en: The objects are enclosed in braces with each key separated by a colon, and each
    value is comma separated from the next key/value. Lists are enclosed in brackets
    and elements are comma separated. These two types can be combined, so a list can
    also be a value, and objects can be elements in a list. Spaces, newlines, and
    tabs that are outside names and values are ignored and are used to indent the
    data and make it easier to read.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对象用大括号括起来，每个键用冒号分隔，每个值用逗号分隔。列表用方括号括起来，元素用逗号分隔。这两种类型可以结合使用，因此列表也可以是值，对象可以是列表中的元素。在名称和值之外的空格、换行和制表符将被忽略，并用于缩进数据，使其更易于阅读。
- en: 'Take this sample JSON object:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 取这个样本JSON对象：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It could be compressed into one line, removing the indentation, as this is
    a good practice when the data length matters—such as in a web server or a database:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以压缩成一行，去除缩进，因为当数据长度很重要时，这是一个很好的做法，比如在Web服务器或数据库中：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In Go, the default types associated to JSON dictionaries and lists are `map[string]interface{}`
    and `[]interface{}`. These two types (being so generic) are capable of hosting
    any JSON data structure.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，与JSON字典和列表相关联的默认类型是`map[string]interface{}`和`[]interface{}`。这两种类型（非常通用）能够承载任何JSON数据结构。
- en: Field tags
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段标签
- en: A `struct` can also host a specific set of JSON data; all of the exported keys
    will have names identical to the respective fields. In order to customize the
    keys, Go enables us to follow field declarations in a struct with a string that
    should contain metadata about the field.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`也可以承载特定的JSON数据；所有导出的键将具有与相应字段相同的名称。为了自定义键，Go允许我们在结构中的字段声明后跟一个字符串，该字符串应包含有关字段的元数据。'
- en: 'These tags take the form of colon separated keys/values. The value is a quoted
    string, which can contain additional information added using commas (such as `job,omitempty`).
    If there is more than one tag, spaces are used to separate them. Let''s see a
    practical example that uses struct tags:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签采用冒号分隔的键/值形式。值是带引号的字符串，可以使用逗号（例如`job,omitempty`）添加附加信息。如果有多个标签，空格用于分隔它们。让我们看一个使用结构标签的实际例子：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This example shows how two different tags can be used for the same field (we
    have both `json` and `foo`), and it shows how to specify a particular JSON key
    and introduce the `omitempty` tag that is used for output purposes to avoid marshaling
    the field if it has a zero value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示了如何为相同字段使用两个不同的标签（我们同时使用`json`和`foo`），并显示了如何指定特定的JSON键并引入`omitempty`标签，用于输出目的，以避免在字段具有零值时进行编组。
- en: Decoder
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码器
- en: 'There two ways of decoding data in JSON—the first is the `json.Unmarshal` function that
    uses a byte slice as input, and the second is the `json.Decoder` type that uses
    a generic `io.Reader` to get the encoded content. We will use the latter in our
    examples because it will enable us to work with structs such as `strings.Reader`.
    Another advantage of the decoder is the customization that can be done with the
    following methods:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON中解码数据有两种方式——第一种是使用字节片作为输入的`json.Unmarshal`函数，第二种是使用通用的`io.Reader`获取编码内容的`json.Decoder`类型。我们将在示例中使用后者，因为它将使我们能够使用诸如`strings.Reader`之类的结构。解码器的另一个优点是可以使用以下方法进行定制：
- en: '`DisallowUnknownFields`: The decode will return an error if a field that is
    unknown to the receiving data structure is found.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DisallowUnknownFields`：如果发现接收数据结构中未知的字段，则解码将返回错误。'
- en: '`UseNumber`: Numbers will be stored as `json.Number` instead of `float64`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseNumber`：数字将存储为`json.Number`而不是`float64`。'
- en: 'This is a practical example of data decoding using the `json.Decoder` type:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`json.Decoder`类型进行数据解码的实际示例：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The full example is available here: [https://play.golang.org/p/a-qt5Mk9E_J](https://play.golang.org/p/a-qt5Mk9E_J).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例在此处可用：[https://play.golang.org/p/a-qt5Mk9E_J](https://play.golang.org/p/a-qt5Mk9E_J)。
- en: Encoder
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码器
- en: 'Data encoding works in a similar fashion, with a `json.Marshal` function that
    takes a byte slice and the `json.Encoder` type that uses `io.Writer` instead.
    The latter is better for the obvious reasons of flexibility and customization.
    It allows us to change the output with the following methods:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 数据编码以类似的方式工作，使用`json.Marshal`函数获取字节片和`json.Encoder`类型，该类型使用`io.Writer`。后者更适合于灵活性和定制的明显原因。它允许我们使用以下方法更改输出：
- en: '`SetEscapeHTML`: If true, it specifies whether a problematic HTML character should
    be escaped inside JSON quoted strings.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetEscapeHTML`：如果为true，则指定是否应在JSON引用的字符串内部转义有问题的HTML字符。'
- en: '`SetIndent`: This allows us to specify a prefix at the beginning of each line,
    and what string will be used to indent the output JSON.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetIndent`：这允许我们指定每行开头的前缀，以及用于缩进输出JSON的字符串。'
- en: 'The following example uses an encore to marshal a data structure to standard
    output using tabs for indentation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用encore将数据结构编组到标准输出，使用制表符进行缩进：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is where we can see the utility of the `omitempty` tag in the `Job` field.
    Since the value is an empty string, its encoding is skipped. If the tag was absent,
    there would have been the `"job":"",` line after the surname.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以看到`Job`字段中`omitempty`标签的实用性。由于值是空字符串，因此跳过了它的编码。如果标签不存在，那么在姓氏之后会有`"job":"",`行。
- en: Marshaler and unmarshaler
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编组器和解组器
- en: 'Encoding and decoding are normally done using the reflection package, which
    is pretty slow. Before resorting to it, the encoder and decoder will check whether
    the data type implements the `json.Marshaller` and `json.Unmarshaller` interfaces
    and use the respective methods instead:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用反射包进行编码和解码，这是非常慢的。在诉诸它之前，编码器和解码器将检查数据类型是否实现了`json.Marshaller`和`json.Unmarshaller`接口，并使用相应的方法：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Implementing this interface allows for a generally faster encoding and decoding,
    and it grants the ability to execute other kinds of actions that would not be
    possible otherwise, such as reading from or writing to unexported fields; it can
    also embed some operations such as running checks on the data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此接口可以实现更快的编码和解码，并且可以执行其他类型的操作，否则不可能，例如读取或写入未导出字段；它还可以嵌入一些操作，比如对数据进行检查。
- en: If the goal is just to wrap the default behavior, it is necessary to define
    another type with the same data structure, so that it loses all methods. Otherwise,
    calling `Marshal` or `Unmarshal` inside the methods will result in a recursive
    call and, finally, a stack overflow.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标只是包装默认行为，则需要定义另一个具有相同数据结构的类型，以便它失去所有方法。否则，在方法内调用`Marshal`或`Unmarshal`将导致递归调用，最终导致堆栈溢出。
- en: 'In this practical example, we are defining a custom `Unmarshal` method to set
    a default value for the `Job` field when it''s empty:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实际的例子中，我们正在定义一个自定义的`Unmarshal`方法，以在`Job`字段为空时设置默认值：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The full example is available here: [https://play.golang.org/p/4BjFKiMiVHO](https://play.golang.org/p/4BjFKiMiVHO).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在此处可用：[https://play.golang.org/p/4BjFKiMiVHO](https://play.golang.org/p/4BjFKiMiVHO)。
- en: 'The `UnmarshalJSON` method needs a pointer receiver because it has to actually
    modify the value of the data type, but for the `MarshalJSON` method, there''s
    no real need for it, and it is a good practice to have a value receiver—unless
    the data type should do something different while `nil`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnmarshalJSON`方法需要一个指针接收器，因为它必须实际修改数据类型的值，但对于`MarshalJSON`方法，没有真正的需要，最好使用值接收器——除非数据类型在`nil`时应该执行不同的操作：'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The full example is available here: [https://play.golang.org/p/Q-q-9y6v6u-](https://play.golang.org/p/Q-q-9y6v6u-).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在此处可用：[https://play.golang.org/p/Q-q-9y6v6u-](https://play.golang.org/p/Q-q-9y6v6u-)。
- en: Interfaces
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: When working with interface types, the encoding part is really straightforward
    because the application knows which data structure is stored within the interface
    and will proceed with the marshaling. Doing the opposite operation is not quite
    as straightforward because the application received has an interface rather than
    a data structure and does not know what to do and, therefore, ends up doing nothing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用接口类型时，编码部分非常简单，因为应用程序知道接口中存储了哪种数据结构，并将继续进行编组。做相反的操作并不那么简单，因为应用程序接收到的是一个接口而不是数据结构，并且不知道该怎么做，因此最终什么也没做。
- en: 'A strategy that works really well (even if it involves a little boilerplate)
    is using a concrete type container, which will permit us to handle the interface
    in the `UnmarshalJSON` method. Let''s create a quick example by defining an interface
    and some different implementations:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常有效的策略（即使涉及一些样板文件）是使用具体类型的容器，这将允许我们在`UnmarshalJSON`方法中处理接口。让我们通过定义一个接口和一些不同的实现来创建一个快速示例：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we define a type that wraps the interface and has a `Type` field:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个包装接口并具有`Type`字段的类型：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, let''s populate the `Type` field before encoding:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在编码之前填充`Type`字段：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The decoding method is the more important one: it uses `json.RawMessage`, which
    is a special type of byte slice used for lazy decoding. We will first get the
    type from the string field and leave the value in the raw format, in order to
    use the correct data structure for its decoding:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 解码方法是更重要的：它使用`json.RawMessage`，这是一种用于延迟解码的特殊字节片类型。我们将首先从字符串字段中获取类型，并将值保留在原始格式中，以便使用正确的数据结构进行解码：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The full example is available here: [https://play.golang.org/p/GXMK_hC8Bpv](https://play.golang.org/p/GXMK_hC8Bpv).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在此处可用：[https://play.golang.org/p/GXMK_hC8Bpv](https://play.golang.org/p/GXMK_hC8Bpv)。
- en: Generating structs
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成结构体
- en: There is a very useful application that, when given a JSON string, generates
    a Go type automatically trying to infer field types. You can find one deployed
    at this address: [https://mholt.github.io/json-to-go/](https://mholt.github.io/json-to-go/).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常有用的应用程序，当给定一个JSON字符串时，会自动尝试推断字段类型生成Go类型。您可以在此地址找到一个部署的：[https://mholt.github.io/json-to-go/](https://mholt.github.io/json-to-go/)。
- en: It saves some time and most of the time the data structure is already correct
    after a simple conversion. Sometimes, it needs some changes such as number types,
    for instance, if you want a field to be `float`, but your sample JSON has an integer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以节省一些时间，大多数情况下，在简单转换后，数据结构已经是正确的。有时，它需要一些更改，比如数字类型，例如，如果您想要一个字段是`float`，但您的示例JSON是一个整数。
- en: JSON schemas
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON模式
- en: 'A JSON schema is a vocabulary that describes JSON data and enables the verification
    of data validity. It can be used for testing and it can be used as documentation.
    The schema specifies the type of an element and can add additional checks on its
    value. If the type is an array, it can also specify the type and details of each
    element. If the type is an object, it describes its fields. Let''s see a JSON
    schema for the `Character` struct that we used in the examples:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JSON模式是描述JSON数据并验证数据有效性的词汇。它可用于测试，也可用作文档。模式指定元素的类型，并可以对其值添加额外的检查。如果类型是数组，还可以指定每个元素的类型和详细信息。如果类型是对象，则描述其字段。让我们看一个我们在示例中使用的`Character`结构的JSON模式：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see that it specifies an object with all of its fields and indicates
    which fields are mandatory. There are some third-party Go packages that permit
    us to verify JSON against schema very easily such as [github.com/xeipuuv/gojsonschema](https://github.com/xeipuuv/gojsonschema).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它指定了一个带有所有字段的对象，并指示哪些字段是必需的。有一些第三方Go包可以让我们非常容易地根据模式验证JSON，例如[github.com/xeipuuv/gojsonschema](https://github.com/xeipuuv/gojsonschema)。
- en: XML
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML
- en: '**Extensible Markup Language** (**XML**) is another widely used data encoding
    format. It''s human and machine readable, like JSON, and it was defined by **World
    Wide Web Consortium** (**W3C**) in 1996\. It focuses on simplicity, usability,
    and generality, and it is actually used as a base for many formats including RSS
    or XHTML.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展标记语言**（**XML**）是另一种广泛使用的数据编码格式。它像JSON一样既适合人类阅读又适合机器阅读，并且是由**万维网联盟**（**W3C**）于1996年定义的。它专注于简单性，易用性和通用性，并且实际上被用作许多格式的基础，包括RSS或XHTML。'
- en: Structure
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构
- en: 'Each XML file starts with a declaration statement that specifies the version
    and encoding used in the file and whether the file is standalone (schema used
    is internal). This is a sample XML declaration:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个XML文件都以一个声明语句开始，该语句指定文件中使用的版本和编码，以及文件是否是独立的（使用的模式是内部的）。这是一个示例XML声明：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The declaration is followed by a tree of XML elements, which are delimited
    by tags that have the following form:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 声明后面跟着一个XML元素树，这些元素由以下形式的标签界定：
- en: '`<tag>`: Opening tag, defines the start of an element'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<tag>`：开放标签，定义元素的开始'
- en: '`</tag>`: Closing tag, defines the end of an element'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`</tag>`：关闭标签，定义元素的结束'
- en: '`<tag/>`: Self-closing tag, defines an element with no content'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<tag/>`：自关闭标签，定义没有内容的元素'
- en: 'Usually, elements are nested so that there are tags inside other tags:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，元素是嵌套的，因此一个标签内部有其他标签：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each element can have additional information in the form of attributes, which
    are space-separated key/value pairs found inside an opening or self-closing tag.
    The key and value are separated by an equals sign, and the value is delimited
    by double quotes. The following are examples of elements with attributes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素都可以以属性的形式具有附加信息，这些信息是在开放或自关闭标签内找到的以空格分隔的键/值对。键和值由等号分隔，并且值由双引号括起来。以下是具有属性的元素示例：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Document Type Definition
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档类型定义
- en: '**Document Type Definition** (**DTD**) is an XML document that defines the
    structure and constraints of other XML documents. It can be used to verify the
    validity of XML if its content is what is expected. An XML can and should specify
    its own schema, to ease the validation process. The elements of a DTD are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档类型定义**（**DTD**）是定义其他XML文档的结构和约束的XML文档。它可用于验证XML的有效性是否符合预期。XML可以和应该指定自己的模式，以便简化验证过程。DTD的元素如下：'
- en: '**Schema**: This represents the root of the document.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式**：这代表文档的根。'
- en: '**Complex type**: It allows an element to have content.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂类型**：它允许元素具有内容。'
- en: '**Sequence**: This specifies the child elements that must appear in the described
    sequence.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列**：这指定了描述的序列中必须出现的子元素。'
- en: '**Element**: This represents an XML element.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素**：这代表一个XML元素。'
- en: '**Attribute**: This represents an XML attribute for the parent tag.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：这代表父标签的XML属性。'
- en: 'This is a sample schema declaration for the `Character` struct we are using
    in this chapter:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在本章中使用的`Character`结构的示例模式声明：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see that it is a schema with an element (character) that is a complex
    type composed by a sequence of other elements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它是一个包含其他元素序列的复杂类型元素（字符）的模式。
- en: Decoding and encoding
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码和编码
- en: 'As we already saw for JSON, data decoding and encoding can be achieved in two
    different ways: by providing or returning a byte slice using `xml.Unmarshal` and `xml.Marshal` or
    by using `io.Reader` or `io.Writer` with the `xml.Decoder` and `xml.Encoder` types.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们已经看到的JSON一样，数据解码和编码可以通过两种不同的方式实现：通过使用`xml.Unmarshal`和`xml.Marshal`提供或返回一个字节片，或者通过使用`xml.Decoder`和`xml.Encoder`类型与`io.Reader`或`io.Writer`一起使用。
- en: 'We can do it by replacing the `json` tag from the `Character` struct with `xml` or
    by simply adding them:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`Character`结构中的`json`标签替换为`xml`或简单地添加它们来实现：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we use `xml.Decoder` to unmarshal the data:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`xml.Decoder`来解组数据：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The full example is available here: [https://play.golang.org/p/esopq0SMhG_T](https://play.golang.org/p/esopq0SMhG_T).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在此处找到：[https://play.golang.org/p/esopq0SMhG_T](https://play.golang.org/p/esopq0SMhG_T)。
- en: 'When encoding, the `xml` package will get the name of the root node from the
    data type used. If the data structure has a field named `XMLName`, the relative
    XML `struct` tag will be used for the root node. So, the data structure becomes
    the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码时，`xml`包将从使用的数据类型中获取根节点的名称。如果数据结构有一个名为`XMLName`的字段，则相对的XML `struct`标签将用于根节点。因此，数据结构变为以下形式：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The encoding operation is also pretty straightforward:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 编码操作也非常简单：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The full example is available here: [https://play.golang.org/p/YgZzdPDoaLX](https://play.golang.org/p/YgZzdPDoaLX).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在此处找到：[https://play.golang.org/p/YgZzdPDoaLX](https://play.golang.org/p/YgZzdPDoaLX)。
- en: Field tags
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段标签
- en: 'The name of the root tag can be changed using the `XMLName` field in a data
    structure. There are some other features of field tags that can be really useful:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根标签的名称可以使用数据结构中的`XMLName`字段进行更改。字段标签的一些其他特性可能非常有用：
- en: Tags with `-` are omitted.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`-`的标记被省略。
- en: A tag with the `attr` option becomes an attribute of the parent element.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`attr`选项的标记成为父元素的属性。
- en: A tag with the `innerxml` option is written verbatim, useful for lazy decoding.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`innerxml`选项的标记被原样写入，对于懒惰解码很有用。
- en: The `omitempty` option works the same as it does for JSON; it will not produce
    a tag for zero values.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`omitempty`选项与JSON的工作方式相同；它不会为零值生成标记。'
- en: The tag can contain a path in the XML using `>` as a separator, as `a > b >
    c`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记可以包含XML中的路径，使用`>`作为分隔符，如`a > b > c`。
- en: Anonymous struct fields are treated as if the fields of its value were in the
    outer struct.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名结构字段被视为其值的字段在外部结构中的字段。
- en: 'Let''s take a look at a practical example that uses some of these features:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用其中一些特性的实际示例：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This structure produces the following XML:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构产生以下XML：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The full example is available here: [https://play.golang.org/p/6zdl9__M0zF](https://play.golang.org/p/6zdl9__M0zF).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在这里：[https://play.golang.org/p/6zdl9__M0zF](https://play.golang.org/p/6zdl9__M0zF)。
- en: Marshaler and unmarshaler
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编组器和解组器
- en: 'As we have also seen for JSON, the `xml` package offers some interfaces to
    customize the behavior of a type during encoding and decoding operations—this
    can avoid the use of reflection or can be used to establish a different behavior.
    The interfaces that are offered by the package to obtain this behavior are the
    following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在JSON中看到的那样，`xml`包提供了一些接口来自定义类型在编码和解码操作期间的行为——这可以避免使用反射，或者可以用于建立不同的行为。该包提供的接口来获得这种行为是以下内容：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are two pairs of functions—one is used when decoding or encoding the
    type as an element, while the others are used when it''s an attribute. Let''s
    see that in action. First, we define a `MarshalXMLAttr` method for a custom type:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有两对函数——一对用于解码或编码类型作为元素时使用，而另一对用于其作为属性时使用。让我们看看它的作用。首先，我们为自定义类型定义一个`MarshalXMLAttr`方法：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we marshal some data, and we will see that the attribute name is replaced
    with `codename`, and its value is uppercase, as specified by the method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对一些数据进行编组，我们会看到属性名称被替换为`codename`，其值为大写，正如方法所指定的那样：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The full example is available here: [https://play.golang.org/p/XwJrMozQ6RY](https://play.golang.org/p/XwJrMozQ6RY).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在这里：[https://play.golang.org/p/XwJrMozQ6RY](https://play.golang.org/p/XwJrMozQ6RY)。
- en: Generating structs
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成结构
- en: As seen for JSON, there is a third-party package that can generate Go structures
    from encoded files. For XML we have [https://github.com/miku/zek](https://github.com/miku/zek).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就像JSON一样，有一个第三方包可以从编码文件生成Go结构。对于XML，我们有[https://github.com/miku/zek](https://github.com/miku/zek)。
- en: It takes care of any type of XML data including elements with their attributes,
    spacing between elements, or comments.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 它处理任何类型的XML数据，包括带有属性的元素，元素之间的间距或注释。
- en: YAML
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML
- en: '**YAML** is a recursive acronym that stands for **YAML Ain''t Markup Language**
    and it''s the name of another widely used encoding format for data. Part of its
    success is due to it being easier to write than JSON and XML, its lightweight
    nature, and its flexibility.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAML**是一个递归缩写，代表**YAML不是标记语言**，它是另一种广泛使用的数据编码格式的名称。它的成功部分归功于它比JSON和XML更容易编写，它的轻量级特性和灵活性。'
- en: Structure
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构
- en: 'YAML uses indentation for scope and newlines to separate entities. Elements
    in a sequence start with a dash followed by a space. The key and value are separated
    by a color, and a hash sign is used for comments. This is what a sample YAML file
    can look like:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: YAML使用缩进来表示范围，使用换行符来分隔实体。序列中的元素以破折号开头，后跟一个空格。键和值之间用冒号分隔，用井号表示注释。这是样本YAML文件的样子：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: One of the more important differences between JSON and YAML is that, while the
    first can only use strings as keys, the latter can use any kind of scalar value
    (strings, numbers, and Booleans).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: JSON和YAML之间更重要的区别之一是，虽然前者只能使用字符串作为键，但后者可以使用任何类型的标量值（字符串、数字和布尔值）。
- en: Decoding and encoding
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码和编码
- en: YAML is not included in the Go standard library but there are many third-party
    libraries available. The package that is more commonly used to handle this format
    is the `go-yaml` package ([https://gopkg.in/yaml.v2](https://gopkg.in/yaml.v2)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: YAML不包含在Go标准库中，但有许多第三方库可用。处理此格式最常用的包是`go-yaml`包([https://gopkg.in/yaml.v2](https://gopkg.in/yaml.v2))。
- en: 'It is built using the following standard encoding packages structure:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它是使用以下标准编码包结构构建的：
- en: There are encoders and decoders.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有编码器和解码器。
- en: There are `Marshal`/`Unmarshal` functions.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有`Marshal`/`Unmarshal`函数。
- en: It allows `struct` tags.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许`struct`标记。
- en: The behavior of types can be customized by implementing the methods of the interfaces
    defined.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型的行为可以通过实现定义的接口的方法来自定义。
- en: 'The interface is slightly different—the `Unmarshaler` receives the default
    marshaling function as arguments that can then be used with a data struct that
    is different to the type:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接口略有不同——`Unmarshaler`接收默认编组函数作为参数，然后可以与不同于类型的数据结构一起使用：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can use the `struct` tags in the same way as JSON tags:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像使用JSON标记一样使用`struct`标记：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And we can use them to encode a data structure or, in this case, a list of
    structures:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它们来编码数据结构，或者在这种情况下，一系列结构：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Decoding works in the same way, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 解码方式相同，如下所示：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can see that all it takes to create `Decoder` is `io.Reader` and the receiving
    struct to execute the decode.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到创建`Decoder`所需的全部内容是`io.Reader`和接收结构以执行解码。
- en: Learning about binary encoding
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解二进制编码
- en: Binary encoding protocols use bytes, so their string representation is not human
    friendly. They are usually not readable as strings and they are difficult to write,
    but they are of a smaller size, resulting in faster communication between applications.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制编码协议使用字节，因此它们的字符串表示不友好。它们通常不可读作为字符串，很难编写，但它们的大小更小，导致应用程序之间的通信更快。
- en: BSON
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BSON
- en: BSON is the binary version of JSON. It is used by MongoDB and has support for
    some data types that are not available in JSON, such as date and binary.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: BSON是JSON的二进制版本。它被MongoDB使用，并支持一些在JSON中不可用的数据类型，例如日期和二进制。
- en: There are a few packages that implement BSON encoding and decoding, and two
    of them are very widespread. One is inside the official MongoDB Golang driver,
    `github.com/mongodb/mongo-go-driver`. The other is not official, but has been
    around since the beginning of Go and it's part of an unofficial MongoDB driver,
    `gopkg.in/mgo.v2`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些包实现了BSON编码和解码，其中两个非常广泛。一个在官方的MongoDB Golang驱动程序内部，`github.com/mongodb/mongo-go-driver`。另一个不是官方的，但自Go开始就存在，并且是非官方MongoDB驱动程序的一部分，`gopkg.in/mgo.v2`。
- en: 'The second one is very similar to the JSON package in both interfaces and functions.
    The interfaces are called getter and setter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个与JSON包非常相似，无论是接口还是函数。这些接口被称为getter和setter：
- en: '`GetBSON` returns the actual data structure that would be encoded.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetBSON`返回将被编码的实际数据结构。'
- en: '`SetBSON` receives `bson.Raw`, which is a wrapper for `[]byte` that can be
    used with `bson.Unmarshal`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetBSON`接收`bson.Raw`，它是`[]byte`的包装器，可以与`bson.Unmarshal`一起使用。'
- en: 'A use case for these getters and setters is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些getter和setter的用例如下：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Encoding
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码
- en: 'BSON is a format made for documents/entities; therefore, the data structure
    used for encoding and decoding should be a structure or a map, but not a slice
    or an array. The `mgo` version of `bson` does not offer the usual encoder but
    only the marshal:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: BSON是为文档/实体设计的格式；因此，用于编码和解码的数据结构应该是结构体或映射，而不是切片或数组。`mgo`版本的`bson`不提供通常的编码器，而只提供marshal：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Decoding
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码
- en: 'The same thing applies to the `Unmarshal` function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的事情也适用于`Unmarshal`函数：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: gob
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gob
- en: '`gob` encoding is another type of binary encoding that is built into the standard
    library, and it''s actually introduced by Go itself. It is a stream of data items,
    each one preceded by a type declaration, and it does not allow pointers. It uses
    their value, forbidding the use of `nil` pointers (since they have no value).
    The package also has problems with types that have pointers that create a recursive
    structure and this could lead to unwanted behaviors.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`gob`编码是另一种内置于标准库中的二进制编码类型，实际上是由Go本身引入的。它是一系列数据项，每个数据项前面都有一个类型声明，并且不允许使用指针。它使用它们的值，禁止使用`nil`指针（因为它们没有值）。该包还存在与具有创建递归结构的指针的类型相关的问题，这可能导致意外的行为。'
- en: Numbers have arbitrary precision and they can be a float, signed, or unsigned.
    Signed integers can be stored in any signed integer type, unsigned integers into
    any unsigned integer type, and floating-point values may be received into any
    floating-point variable. However, if the variable can't represent the value (overflow,
    for instance), the decode will fail. Strings and byte slices are stored with a
    very efficient representation that tries to reuse the same underlying array. Structs
    will decode only the exported fields, so functions and channels will be ignored.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 数字具有任意精度，可以是浮点数、有符号数或无符号数。有符号整数可以存储在任何有符号整数类型中，无符号整数可以存储在任何无符号整数类型中，浮点值可以接收到任何浮点变量中。但是，如果变量无法表示该值（例如溢出），解码将失败。字符串和字节切片使用非常高效的表示存储，尝试重用相同的基础数组。结构体只会解码导出的字段，因此函数和通道将被忽略。
- en: Interfaces
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: 'The interface that `gob` uses to replace the default marshal and unmarshal
    behaviors are found in the `encoding` package:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`gob`用于替换默认编组和解组行为的接口可以在`encoding`包中找到：'
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: During the decoding phase, any struct fields that are not present are ignored,
    since the field name is also part of the serialization.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在解码阶段，任何不存在的结构字段都会被忽略，因为字段名称也是序列化的一部分。
- en: Encoding
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码
- en: 'Let''s try to encode a structure using `gob`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用`gob`对一个结构进行编码：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Decoding
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码
- en: 'Decoding data is also very easy; it works in the same way as the other encoding
    packages we have already seen:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 解码数据也非常简单；它的工作方式与我们已经看到的其他编码包相同：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s try to decode the same data in different structures—the original
    one and some with extra or missing fields. We will do this to see how the package
    behaves. Let''s define a general decode function and pass different type of structs
    to the decoder:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在不同的结构中解码相同的数据——原始数据和一些带有额外或缺少字段的数据。我们将这样做来查看该包的行为。让我们定义一个通用的解码函数，并将不同类型的结构传递给解码器：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s try to change the order of the fields in the struct to see whether the
    `gob` decoder still works:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试改变结构体中字段的顺序，看看`gob`解码器是否仍然有效：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s remove some fields:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除一些字段：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s put a field in between:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在中间加一个字段：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can see that the package keeps working even if we scramble, add, or remove
    the fields. But if we try to change the type of an existing field into another,
    it fails:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，即使我们混淆、添加或删除字段，该包仍然可以正常工作。但是，如果我们尝试将现有字段的类型更改为另一个类型，它会失败：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Interfaces
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: 'Another note about this package is that if you are working with interfaces,
    their implementation should be registered first, using the functions:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 关于该包的另一个注意事项是，如果您使用接口，它们的实现应该首先进行注册，使用以下函数：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will make the package aware of the specified types and it will enable
    us to call decode on the interface type. Let''s start by defining an interface
    and its implementation for our struct:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使该包了解指定的类型，并使我们能够在接口类型上调用解码。让我们首先定义一个接口及其实现，用于我们的结构：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we try to run the following code without the `gob.Register` function, it
    returns an error:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在没有`gob.Register`函数的情况下运行以下代码，会返回一个错误：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'But if we register the type, it works like a charm. Note that the data has
    been obtained by encoding a pointer to `Greeter` containing the `Character` structure:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们注册了该类型，它就会像魅力一样工作。请注意，该数据是通过对包含`Character`结构的`Greeter`的指针进行编码而获得的：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Proto
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Proto
- en: A protocol buffer is a serialization protocol made by Google. It is language-
    and platform-neutral, with little overhead, and it is very efficient. The idea
    behind it is to define how the data is structured once, then use some tools to
    generate the source code for the target language of the application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区是由谷歌制作的序列化协议。它是语言和平台中立的，开销很小，非常高效。其背后的想法是定义数据的结构一次，然后使用一些工具为应用程序的目标语言生成源代码。
- en: Structure
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构
- en: The main file that is needed in order to generate the code is the `.proto` file,
    which uses a specific syntax. We will focus on the latest version of the protocol
    syntax, `proto3`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 生成代码所需的主文件是`.proto`文件，它使用特定的语法。我们将专注于协议语法的最新版本`proto3`。
- en: 'We specify which version of the syntax of the file is to be used in the first
    line:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一行指定要使用的文件语法版本：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Definitions from other files can be used, with the `import` statement:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`import`语句使用其他文件中的定义：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The rest of the file contains definitions of messages (that are data types)
    and services. A service is an interface used to define RPC services:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的其余部分包含消息（数据类型）和服务的定义。服务是用于定义RPC服务的接口：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Messages are made up by their fields, and services by their methods. Field types
    are divided between scalars (which includes various integers, signed integers,
    float, strings, and Booleans) and other messages. Each field has a number associated
    to it that is its identifier, which should not be changed once selected, so as
    to maintain compatibility with the older version of the message.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 消息由它们的字段组成，服务由它们的方法组成。字段类型分为标量（包括各种整数、有符号整数、浮点数、字符串和布尔值）和其他消息。每个字段都有一个与之关联的数字，这是它的标识符，一旦选择就不应更改，以便与消息的旧版本保持兼容性。
- en: 'Using the `reserved` keyword allows us to prevent some fields or IDs from being
    reused, as this is very useful to avoid bugs or problems:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`reserved`关键字可以防止一些字段或ID被重用，这对于避免错误或问题非常有用：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Code generation
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码生成
- en: 'In order to generate the code from a `.proto` file, you need the `protoc` application
    and the official proto generation package:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从`.proto`文件生成代码，您需要`protoc`应用程序和官方的proto生成包：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The installed package comes with the `protoc-gen-go` command; this enables
    the `protoc` command to use the `--go_out` flag to produce Go source files in
    the desired folders. Version 1.4 of Go can specify special comments for automatic
    generation of code with its `go generate` command, and these comments start with
    `//go:generate` followed by the command, as in the following example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 安装的包带有`protoc-gen-go`命令；这使得`protoc`命令可以使用`--go_out`标志在所需的文件夹中生成Go源文件。Go的1.4版本可以指定特殊注释以使用其`go
    generate`命令自动生成代码，这些注释以`//go:generate`开头，后跟命令，如下例所示：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It enables us to specify a source path for import lookup, output directory,
    and a source file. The paths are relative to the package directory where the comment
    is found and it can be invoked with the `go generate $pkg` command.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 它使我们能够指定导入查找的源路径、输出目录和源文件。路径是相对于找到注释的包目录的，可以使用`go generate $pkg`命令调用。
- en: 'Let''s start with a simple `.proto` file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的`.proto`文件开始：
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And let''s create a Go source file in the same folder with the comment for
    generating the code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在相同的文件夹中创建一个带有用于生成代码的注释的Go源文件：
- en: '[PRE59]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, we can generate the `go` command that will produce a file with the same
    name as the `.proto` file and the `.pb.go` extension. The file will contain Go
    sources for the types and services defined in the `.proto` file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以生成`go`命令，它将生成一个与`.proto`文件相同名称和`.pb.go`扩展名的文件。该文件将包含`.proto`文件中定义的类型和服务的Go源代码：
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Encoding
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码
- en: 'This package permits us to use the `proto.Buffer` type to encode `pb.Message`
    values. The types created by `protoc` implement the interface defined so the `Character`
    type can be used directly:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包允许我们使用`proto.Buffer`类型来编码`pb.Message`值。由`protoc`创建的类型实现了定义的接口，因此`Character`类型可以直接使用：
- en: '[PRE61]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The resulting encoded data has almost no overhead compared to other encoding.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的编码数据与其他编码相比几乎没有额外开销。
- en: Decoding
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码
- en: 'The decode operation also needs to be executed using the `proto.Buffer` methods
    and the generated type:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 解码操作也需要使用`proto.Buffer`方法和生成的类型来执行：
- en: '[PRE62]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: gRPC protocol
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC协议
- en: Google uses protocol buffer encoding to build a web protocol called **gRPC**.
    It is a type of remote procedure call that uses HTTP/2 to establish connections
    and protocol buffers to marshal and unmarshal data.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌使用协议缓冲编码来构建名为**gRPC**的Web协议。它是一种使用HTTP/2建立连接和使用协议缓冲区来编组和解组数据的远程过程调用类型。
- en: The first step is generating code related to the server in the target language.
    This will produce a server interface and a client working implementation. Next,
    a server implementation needs to be created manually, and finally, the target
    language will enable the implementation to be used in a gRPC server and then use
    the client to connect and interact with it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在目标语言中生成与服务器相关的代码。这将产生一个服务器接口和一个客户端工作实现。接下来，需要手动创建服务器实现，最后，目标语言将使实现能够在gRPC服务器中使用，然后使用客户端连接和与之交互。
- en: 'There are different examples in the `go-grpc` package, including a client/server
    pair. The client uses the generated code, which only needs a working gRPC connection
    to the server, and then it can use the methods specified in the service:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`go-grpc`包中有不同的示例，包括客户端/服务器对。客户端使用生成的代码，只需要一个工作的gRPC连接到服务器，然后可以使用服务中指定的方法：'
- en: '[PRE63]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The full code is available at [grpc/grpc-go/blob/master/examples/helloworld/greeter_client/main.go](https://github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_client/main.go).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可在[grpc/grpc-go/blob/master/examples/helloworld/greeter_client/main.go](https://github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_client/main.go)找到。
- en: 'The server is an implementation of the client interface:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器是客户端接口的实现：
- en: '[PRE64]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This interface implementation can be passed to the generated register function, `RegisterGreeterServer`,
    together with a valid gRPC server, and it can serve incoming connections using
    a TCP listener:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口实现可以传递给生成的注册函数`RegisterGreeterServer`，连同一个有效的gRPC服务器，它可以使用TCP监听器来服务传入的连接：
- en: '[PRE65]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The full code is available at [grpc/grpc-go/blob/master/examples/helloworld/greeter_server/main.go](https://github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_server/main.go).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可在[grpc/grpc-go/blob/master/examples/helloworld/greeter_server/main.go](https://github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_server/main.go)找到。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the encoding methods offered by the Go standard
    package and third-party libraries. They can be divided into two main categories.
    The first is the textual-based encoding methods, which are easy to read and write
    for both human and machines. However, they have more overhead and tend to be much
    slower than their counterpart, binary-based encoding. Binary-based encoding methods
    have little overhead but are not human readable.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Go标准包和第三方库提供的编码方法。它们可以分为两大类。第一种是基于文本的编码方法，对人类和机器来说都易于阅读和编写。然而，它们的开销更大，而且往往比它们的对应的基于二进制的编码要慢得多。基于二进制的编码方法开销很小，但不易阅读。
- en: In text-based encoding, we find JSON, XML, and YAML. The first two are handled
    by the standard library, the last needs an external dependency. We explored how
    Go allows us to specify structure tags to change the default encoding and decoding
    behaviors, and how to use these tags in these operations. Then, we checked and
    implemented the interfaces that define custom behavior during the marshal and
    unmarshal operations. There are some third-party tools that allow us to generate
    the data structures from a JSON file or JSON schemas, which are JSON files used
    to define the structure of other JSON documents.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于文本的编码中，我们发现了JSON、XML和YAML。前两者由标准库处理，最后一个需要外部依赖。我们探讨了Go如何允许我们指定结构标签来改变默认的编码和解码行为，以及如何在这些操作中使用这些标签。然后，我们检查并实现了定义在编组和解组操作期间自定义行为的接口。有一些第三方工具可以让我们从JSON文件或JSON模式生成数据结构，JSON模式是用于定义其他JSON文档结构的JSON文件。
- en: XML is another widely used text format that HTML is based on. We checked the
    XML syntax and composing elements and then we showed a specific type of document
    called DTD, which is used for defining the content of other XML files. We learned
    how encoding and decoding works in XML, and the differences to JSON regarding
    `struct` tags that allow us to define nested XML elements for a type or to store
    or load a field from an attribute. We concluded with the text-based encoding with the
    third-party YAML package.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: XML是另一种广泛使用的文本格式，HTML就是基于它的。我们检查了XML语法和组成元素，然后展示了一种特定类型的文档，称为DTD，用于定义其他XML文件的内容。我们学习了XML中编码和解码的工作原理，以及与JSON有关的`struct`标签的区别，这些标签允许我们为类型定义嵌套的XML元素，或者从属性中存储或加载字段。最后，我们介绍了基于文本的编码与第三方YAML包。
- en: The first binary-based encoding we showed was BSON, a binary version of JSON
    that is used by MongoDB (which is handled by third-party packages). `gob` is another
    binary encoding method but it's part of the Go standard library. We learned that
    both encoding and decoding, together with the involved interfaces, work in the
    standard package fashion—similar to JSON and XML.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示的第一个基于二进制的编码是BSON，这是JSON的二进制版本，被MongoDB使用（由第三方包处理）。`gob`是另一种二进制编码方法，但它是Go标准库的一部分。我们了解到编码和解码以及涉及的接口，都是以标准包的方式工作的——类似于JSON和XML。
- en: Finally, we looked at the protocol buffer encoding, how to write a `.proto`
    file and its Go code generation usage and how to use it encode and decode data.
    We also introduced a practical example of the gRPC encoding, which takes advantage
    of this encoding to create client/server applications.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了一下协议缓冲编码，如何编写`.proto`文件以及其Go代码生成用法，以及如何使用它对数据进行编码和解码。我们还介绍了gRPC编码的一个实际示例，利用这种编码来创建客户端/服务器应用程序。
- en: In the next chapter, we will start digging into Go's concurrency model, starting
    with the built-in types—channels and goroutines.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始深入研究Go的并发模型，从内置类型开始——通道和goroutine。
- en: Questions
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's the trade-off between text and binary encodings?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本和二进制编码之间的权衡是什么？
- en: How does Go behave with data structure by default?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go默认情况下如何处理数据结构？
- en: How can this behavior be changed?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种行为如何改变？
- en: How does a structure field get encoded in an XML attribute?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构字段如何在XML属性中编码？
- en: What operation is needed to decode a `gob` interface value?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要什么操作来解码`gob`接口值？
- en: What is the protocol buffer encoding?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是协议缓冲编码？
