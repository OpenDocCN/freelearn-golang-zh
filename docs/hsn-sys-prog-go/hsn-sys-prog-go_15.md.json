["```go\nfunc main() {\n    go fmt.Println(\"Hello, playground\")\n}\n```", "```go\nfunc main() {\n    go fmt.Println(\"Hello, playground\")\n    time.Sleep(time.Nanosecond)\n}\n```", "```go\ntype a struct{}\n\nfunc (a) Method() { fmt.Println(\"Hello, playground\") }\n\nfunc main() {\n    go a{}.Method()\n    time.Sleep(time.Nanosecond)\n}\n```", "```go\nfunc main() {\n    go func() {\n        fmt.Println(\"Hello, playground\")\n    }()\n    time.Sleep(time.Nanosecond)\n}\n\n```", "```go\nfunc main() {\n    for i := 0; i < 10; i++ {\n        go fmt.Println(i)\n    }\n    time.Sleep(time.Nanosecond)\n}\n```", "```go\nfunc main() {\n    for i := 0; i < 10; i++ {\n         go func() { fmt.Println(i) }()\n    }\n    time.Sleep(time.Nanosecond)\n}\n```", "```go\nfunc main() {\n    var a int\n    // passing value\n    go func(v int) { fmt.Println(v) }(a)\n\n    // passing pointer\n    go func(v *int) { fmt.Println(*v) }(&a)\n\n    a = 42\n    time.Sleep(time.Nanosecond)\n}\n```", "```go\nfunc main() {\n    var i int\n    go func(i *int) {\n        for j := 0; j < 20; j++ {\n            time.Sleep(time.Millisecond)\n            fmt.Println(*i, j)\n        }\n    }(&i)\n    for i = 0; i < 20; i++ {\n        time.Sleep(time.Millisecond)\n        fmt.Println(i)\n    }\n}\n```", "```go\n// channel with implicit zero capacity\nvar a = make(chan int)\n\n// channel with explicit zero capacity\nvar a = make(chan int, 0)\n\n// channel with explicit capacity\nvar a = make(chan int, 10)\n```", "```go\nfunc main() {\n    var (\n        a = make(chan int, 0)\n        b = make(chan int, 5)\n    )\n\n    fmt.Println(\"a is\", cap(a))\n    fmt.Println(\"b is\", cap(b))\n}\n```", "```go\nfunc main() {\n    var (\n        a = make(chan int, 5)\n    )\n    for i := 0; i < 5; i++ {\n        a <- i\n        fmt.Println(\"a is\", len(a), \"/\", cap(a))\n    }\n}\n```", "```go\nfunc main() {\n    var (\n        a = make(chan int, 5)\n    )\n    for i := 0; i < 5; i++ {\n        a <- i\n        fmt.Println(\"a is\", len(a), \"/\", cap(a))\n    }\n    a <- 0 // Blocking\n}\n```", "```go\nfatal error: all goroutines are asleep - deadlock!\n```", "```go\nfunc main() {\n    var a = make(chan int)\n    a <- 10\n    fmt.Println(<-a)\n}\n```", "```go\nfunc main() {\n    var a = make(chan int)\n    go func() {\n        a <- 10\n    }()\n    fmt.Println(<-a)\n}\n```", "```go\nfunc main() {\n    const max = 10\n    var a = make(chan int)\n\n    go func() {\n        for i := 0; i < max; i++ {\n            a <- i\n        }\n    }()\n    for i := 0; i < max; i++ {\n        fmt.Println(<-a)\n    }\n}\n```", "```go\nvalue, ok := <-ch\n```", "```go\nfunc main() {\n    const max = 10\n    var a = make(chan int)\n\n    go func() {\n        for i := 0; i < max; i++ {\n            a <- i\n        }\n        close(a)\n    }()\n    for {\n        v, ok := <-a\n        if !ok {\n            break\n        }\n        fmt.Println(v)\n    }\n}\n```", "```go\nfor v := range a {\n    fmt.Println(v)\n}\n```", "```go\nfunc main() {\n    var a = make(chan int)\n    s, r := (chan<- int)(a), (<-chan int)(a)\n    fmt.Printf(\"%T - %T\", s, r)\n}\n```", "```go\nfunc send(ch chan<- int, max int) {\n    for i := 0; i < max; i++ {\n        ch <- i\n    }\n    close(ch)\n}\n```", "```go\nfunc receive(ch <-chan int) {\n    for v := range ch{\n        fmt.Println(v)\n    }\n}\n```", "```go\nfunc main() {\n    var a = make(chan int)\n\n    go send(a, 10)\n\n    receive(a)\n}\n```", "```go\nfunc receive(ch <-chan int, done chan<- struct{}) {\n    for v := range ch {\n        fmt.Println(v)\n    }\n    close(done)\n}\n```", "```go\nfunc main() {\n    a := make(chan int)\n    go send(a, 10)\n    done := make(chan struct{})\n    go receive(a, done)\n    <-done\n}\n```", "```go\nfunc main() {\n    var a chan int\n    a <- 1\n}\n```", "```go\nfunc main() {\n    var a chan int\n    <-a\n}\n```", "```go\nfunc main() {\n    var a chan int\n    close(a)\n}\n```", "```go\nfunc main() {\n    a := make(chan int)\n    close(a)\n    a <- 1\n}\n```", "```go\nfunc main() {\n    a := make(chan int)\n    close(a)\n    close(a)\n}\n```", "```go\nfunc main() {\n    ch1, ch2 := make(chan int), make(chan int)\n    a, b := 2, 10\n    go func() { <-ch1 }()\n    go func() { ch2 <- a }()\n    select {\n    case ch1 <- b:\n        fmt.Println(\"ch1 got a\", b)\n    case v := <-ch2:\n        fmt.Println(\"ch2 got a\", v)\n    }\n}\n```", "```go\nselect {\ncase v := <-ch2:\n    fmt.Println(\"ch2 got a\", v)\ncase ch1 <- b:\n    fmt.Println(\"ch1 got a\", b)\ndefault:\n    fmt.Println(\"too slow\")\n}\n```", "```go\nfunc main() {\n    ch1, ch2 := make(chan int), make(chan int)\n    a, b := 2, 10\n    for i := 0; i < 10; i++ {\n        go func() { <-ch1 }()\n        go func() { ch2 <- a }()\n        time.Sleep(time.Nanosecond)\n        select {\n        case ch1 <- b:\n            fmt.Println(\"ch1 got a\", b)\n        case v := <-ch2:\n            fmt.Println(\"ch2 got a\", v)\n        default:\n            fmt.Println(\"too slow\")\n        }\n    }\n}\n```", "```go\nfunc main() {\n    ch1, ch2 := make(chan int), make(chan int)\n    a, b := 2, 10\n    go func() { <-ch1 }()\n    go func() { ch2 <- a }()\n    t := time.NewTimer(time.Nanosecond)\n    select {\n    case ch1 <- b:\n        fmt.Println(\"ch1 got a\", b)\n    case v := <-ch2:\n        fmt.Println(\"ch2 got a\", v)\n    case <-t.C:\n        fmt.Println(\"too slow\")\n    }\n}\n```", "```go\nt := time.NewTimer(time.Millisecond)\ntime.Sleep(time.Millisecond / 2)\nif !t.Stop() {\n    panic(\"it should not fire\")\n}\nselect {\ncase <-t.C:\n    panic(\"not fired\")\ndefault:\n    fmt.Println(\"not fired\")\n}\n```", "```go\nif t.Reset(time.Millisecond) {\n    panic(\"timer should not be active\")\n}\ntime.Sleep(time.Millisecond)\nif t.Stop() {\n    panic(\"it should fire\")\n}\nselect {\ncase <-t.C:\n    fmt.Println(\"fired\")\ndefault:\n    panic(\"not fired\")\n}\n```", "```go\nfunc main() {\n    time.AfterFunc(time.Millisecond, func() {\n        fmt.Println(\"Hello 1!\")\n    })\n    t := time.AfterFunc(time.Millisecond*5, func() {\n        fmt.Println(\"Hello 2!\")\n    })\n    if !t.Stop() {\n        panic(\"should not fire\")\n    }\n    time.Sleep(time.Millisecond * 10)\n}\n```", "```go\nfunc main() {\n    tick := time.NewTicker(time.Millisecond)\n    stop := time.NewTimer(time.Millisecond * 10)\n    for {\n        select {\n        case a := <-tick.C:\n            fmt.Println(a)\n        case <-stop.C:\n            tick.Stop()\n        case <-time.After(time.Millisecond):\n            return\n        }\n    }\n}\n```", "```go\ntype Client struct {\n    client *http.Client\n    tick *time.Ticker\n}\n```", "```go\ntype apiTransport struct {\n    http.RoundTripper\n    key string\n}\n\nfunc (a apiTransport) RoundTrip(r *http.Request) (*http.Response, error) {\n    q := r.URL.Query()\n    q.Set(\"key\", a.key)\n    r.URL.RawQuery = q.Encode()\n    return a.RoundTripper.RoundTrip(r)\n}\n```", "```go\nfunc NewClient(tick time.Duration, key string) *Client {\n    return &Client{\n        client: &http.Client{\n            Transport: apiTransport{http.DefaultTransport, key},\n        },\n        tick: time.NewTicker(tick),\n    }\n}\n```", "```go\ntype Result struct {\n    AddressComponents []struct {\n        LongName string `json:\"long_name\"`\n        ShortName string `json:\"short_name\"`\n        Types []string `json:\"types\"`\n    } `json:\"address_components\"`\n    FormattedAddress string `json:\"formatted_address\"`\n    Geometry struct {\n        Location struct {\n            Lat float64 `json:\"lat\"`\n            Lng float64 `json:\"lng\"`\n        } `json:\"location\"`\n        // more fields\n    } `json:\"geometry\"`\n    PlaceID string `json:\"place_id\"`\n    // more fields\n}\n```", "```go\n    const url = \"https://maps.googleapis.com/maps/api/geocode/json?latlng=%v,%v\"\n    <-c.tick.C\n    resp, err := c.client.Get(fmt.Sprintf(url, lat, lng))\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n```", "```go\n    var v struct {\n        Results []Result `json:\"results\"`\n        Status string `json:\"status\"`\n    }\n    // get the result\n    if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {\n        return nil, err\n    }\n    switch v.Status {\n    case \"OK\":\n        return v.Results, nil\n    case \"ZERO_RESULTS\":\n        return nil, nil\n    default:\n        return nil, fmt.Errorf(\"status: %q\", v.Status)\n    }\n}\n```", "```go\nc := NewClient(24*time.Hour/100000, os.Getenv(\"MAPS_APIKEY\"))\nstart := time.Now()\nfor _, l := range [][2]float64{\n    {40.4216448, -3.6904040},\n    {40.4163111, -3.7047328},\n    {40.4123388, -3.7096724},\n    {40.4145150, -3.7064412},\n} {\n    locs, err := c.ReverseGeocode(l[0], l[1])\n    e := time.Since(start)\n    if err != nil {\n        log.Println(e, l, err)\n        continue\n    }\n    // just print the first location\n    if len(locs) != 0 {\n        locs = locs[:1]\n    }\n    log.Println(e, l, locs)\n}\n```", "```go\ntype result struct {\n    Loc [2]float64\n    Result []maps.Result\n    Error error\n}\n```", "```go\nkeys := strings.Split(os.Getenv(\"MAPS_APIKEYS\"), \",\")\nrequests := make(chan [2]float64, len(keys))\nresults := make(chan result, len(keys))\ndone := make(chan struct{})\n```", "```go\nfor i := range keys {\n    go func(id int) {\n        log.Printf(\"Starting worker %d with API key %q\", id, keys[id])\n        client := maps.NewClient(maps.DailyCap, keys[id])\n        for j := range requests {\n            var r = result{Loc: j}\n            log.Printf(\"w[%d] working on %v\", id, j)\n            r.Result, r.Error = client.ReverseGeocode(j[0], j[1])\n            results <- r\n        }\n        done <- struct{}{}\n    }(i)\n}\n```", "```go\ngo func() {\n    for _, l := range [][2]float64{\n        {40.4216448, -3.6904040},\n        {40.4163111, -3.7047328},\n        {40.4123388, -3.7096724},\n        {40.4145150, -3.7064412},\n    } {\n        requests <- l\n    }\n    close(requests)\n}()\n```", "```go\ngo func() {\n    count := 0\n    for range done {\n        if count++; count == len(keys) {\n            break\n        }\n    }\n    close(results)\n}()\n```", "```go\nfor r := range results {\n    log.Printf(\"received %v\", r)\n}\n```", "```go\nconst wait = time.Millisecond * 250\n\ntype pingPool chan *fastping.Pinger\n\nfunc (p pingPool) Get() *fastping.Pinger {\n    select {\n    case v := <-p:\n        return v\n    case <-time.After(wait):\n        return fastping.NewPinger()\n    }\n}\n\nfunc (p pingPool) Put(v *fastping.Pinger) {\n    select {\n    case p <- v:\n    case <-time.After(wait):\n    }\n    return\n}\n```", "```go\nifaces, err := net.Interfaces()\nif err != nil {\n    return nil, err\n}\nfor _, iface := range ifaces {\n    // ...\n    addrs, err := iface.Addrs()\n    // ...\n    for _, addr := range addrs {\n        var ip net.IP\n        switch v := addr.(type) {\n        case *net.IPNet:\n            ip = v.IP\n        case *net.IPAddr:\n            ip = v.IP\n        }\n        // ...\n        if ip = ip.To4(); ip != nil {\n            result = append(result, ip)\n        }\n    }\n}\n```", "```go\nif len(os.Args) != 2 {\n    help(ifaces)\n}\ni, err := strconv.Atoi(os.Args[1])\nif err != nil {\n    log.Fatalln(err)\n}\nif i < 0 || i > len(ifaces) {\n    help(ifaces)\n}\n```", "```go\nfunc help(ifaces []net.IP) {\n    log.Println(\"please specify a valid network interface number\")\n    for i, f := range ifaces {\n        mask, _ := f.DefaultMask().Size()\n        fmt.Printf(\"%d - %s/%v\\n\", i, f, mask)\n    }\n    os.Exit(0)\n}\n```", "```go\nm := ifaces[i].DefaultMask()\nip := ifaces[i].Mask(m)\nlog.Printf(\"Lookup in %s\", ip)\n```", "```go\nfunc makeIP(ip net.IP, i int) net.IP {\n    addr := make(net.IP, len(ip))\n    copy(addr, ip)\n    b := new(big.Int)\n    b.SetInt64(int64(i))\n    v := b.Bytes()\n    copy(addr[len(addr)-len(v):], v)\n    return addr\n}\n```", "```go\ndone := make(chan struct{})\naddress := make(chan net.IP)\nones, bits := m.Size()\npool := make(pingPool, 10)\nfor i := 0; i < 1<<(uint(bits-ones)); i++ {\n    go func(i int) {\n        p := pool.Get()\n        defer func() {\n            pool.Put(p)\n            done <- struct{}{}\n        }()\n        p.AddIPAddr(&net.IPAddr{IP: makeIP(ip, i)})\n        p.OnRecv = func(a *net.IPAddr, _ time.Duration) { address <- a.IP }\n        p.Run()\n    }(i)\n}\n```", "```go\ni = 0\nfor {\n    select {\n    case ip := <-address:\n        log.Printf(\"Found %s\", ip)\n    case <-done:\n        if i >= bits-ones {\n            return\n        }\n        i++\n    }\n}\n```", "```go\ntype sem chan struct{}\n\nfunc (s sem) Acquire() {\n    s <- struct{}{}\n}\n\nfunc (s sem) Relase() {\n    <-s\n}\n```", "```go\nfunc main() {\n    s := make(sem, 5)\n    for i := 0; i < 10; i++ {\n        go func(i int) {\n            s.Acquire()\n            fmt.Println(i, \"start\")\n            time.Sleep(time.Second)\n            fmt.Println(i, \"end\")\n            s.Relase()\n        }(i)\n    }\n    time.Sleep(time.Second * 3)\n}\n```"]