["```go\ntype Locker interface {\n    Lock()\n    Unlock()\n}\n```", "```go\nfunc main() {\n    var m sync.Mutex\n    done := make(chan struct{}, 10)\n    for i := 0; i < cap(done); i++ {\n        go func(i int, l sync.Locker) {\n            l.Lock()\n            defer l.Unlock()\n            fmt.Println(i)\n            time.Sleep(time.Millisecond * 10)\n            done <- struct{}{}\n        }(i, &m)\n    }\n    for i := 0; i < cap(done); i++ {\n        <-done\n    }\n}\n```", "```go\ndone := make(chan struct{}, 10000)\nvar a = 0\nfor i := 0; i < cap(done); i++ {\n    go func(i int) {\n        if i%2 == 0 {\n            a++\n        } else {\n            a--\n        }\n        done <- struct{}{}\n    }(i)\n}\nfor i := 0; i < cap(done); i++ {\n    <-done\n}\nfmt.Println(a)\n```", "```go\nm := sync.Mutex{}\nfor i := 0; i < cap(done); i++ {\n    go func(l sync.Locker, i int) {\n        l.Lock()\n        defer l.Unlock()\n        if i%2 == 0 {\n            a++\n        } else {\n            a--\n        }\n        done <- struct{}{}\n    }(&m, i)\n    fmt.Println(a)\n}\n```", "```go\ntype counter struct {\n    m     sync.Mutex\n    value int\n}\n```", "```go\nfunc (c *counter) Incr(){\n    c.m.Lock()\n    c.value++\n    c.m.Unlock()\n}\n\nfunc (c *counter) Decr(){\n    c.m.Lock()\n    c.value--\n    c.m.Unlock()\n}\n\nfunc (c *counter) Value() int {\n    c.m.Lock()\n    a := c.value\n    c.m.Unlock()\n    return a\n}\n```", "```go\nvar a = counter{}\nfor i := 0; i < cap(done); i++ {\n    go func(i int) {\n        if i%2 == 0 {\n            a.Incr()\n        } else {\n            a.Decr()\n        }\n        done <- struct{}{}\n    }(i)\n}\n// ...\nfmt.Println(a.Value())\n```", "```go\ntype list struct {\n    m sync.RWMutex\n    value []string\n}\n```", "```go\nfunc (l *list) contains(v string) bool {\n    for _, s := range l.value {\n        if s == v {\n            return true\n        }\n    }\n    return false\n}\n\nfunc (l *list) Contains(v string) bool {\n    l.m.RLock()\n    found := l.contains(v)\n    l.m.RUnlock()\n    return found\n}\n```", "```go\nfunc (l *list) Add(v string) bool {\n    l.m.Lock()\n    defer l.m.Unlock()\n    if l.contains(v) {\n        return false\n    }\n    l.value = append(l.value, v)\n    return true\n}\n```", "```go\nvar src = []string{\n    \"Ryu\", \"Ken\", \"E. Honda\", \"Guile\",\n    \"Chun-Li\", \"Blanka\", \"Zangief\", \"Dhalsim\",\n}\nvar l list\nfor i := 0; i < 10; i++ {\n    go func(i int) {\n        for _, s := range src {\n            go func(s string) {\n                if !l.Contains(s) {\n                    if l.Add(s) {\n                        fmt.Println(i, \"add\", s)\n                    } else {\n                        fmt.Println(i, \"too slow\", s)\n                    }\n                }\n            }(s)\n        }\n    }(i)\n}\ntime.Sleep(500 * time.Millisecond)\n```", "```go\ntype counter struct {\n    m sync.RWMutex\n    value int\n}\n\nfunc (c *counter) Write(i int) {\n    c.m.Lock()\n    time.Sleep(time.Millisecond * 100)\n    c.value = i\n    c.m.Unlock()\n}\n\nfunc (c *counter) Value() int {\n    c.m.RLock()\n    time.Sleep(time.Millisecond * 100)\n    a := c.value\n    c.m.RUnlock()\n    return a\n}\n```", "```go\nvar c counter\nt1 := time.NewTicker(time.Millisecond * 50)\ntime.AfterFunc(time.Second*2, t1.Stop)\nfor {\n    select {\n    case <-t1.C:\n        go func() {\n            t := time.Now()\n            c.Value()\n            fmt.Println(\"val\", time.Since(t))\n        }()\n        go func() {\n            t := time.Now()\n            c.Write(0)\n            fmt.Println(\"inc\", time.Since(t))\n        }()\n    case <-time.After(time.Millisecond * 200):\n        return\n    }\n}\n```", "```go\nfor condition {\n    mu.Lock()\n    defer mu.Unlock()\n    action()\n}\n```", "```go\nfor condition {\n    func() {\n        mu.Lock()\n        defer mu.Unlock()\n        action()\n    }()\n}\n```", "```go\nfor condition {\n    mu.Lock()\n    action()\n    mu.Unlock()\n}\n```", "```go\nch := make(chan struct{})\nfor i := 0; i < n; n++ {\n    go func() {\n        // do something\n        ch <- struct{}{}\n    }()\n}\nfor i := 0; i < n; n++ {\n    <-ch\n}\n```", "```go\ntype WaitGroup struct {\n    noCopy noCopy\n    state1 [3]uint32\n}\n```", "```go\nfunc main() {\n    wg := sync.WaitGroup{}\n    wg.Add(10)\n    for i := 1; i <= 10; i++ {\n        go func(a int) {\n            for i := 1; i <= 10; i++ {\n                fmt.Printf(\"%dx%d=%d\\n\", a, i, a*i)\n            }\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n}\n```", "```go\nfunc main() {\n    wg := sync.WaitGroup{}\n    for i := 1; rand.Intn(10) != 0; i++ {\n        wg.Add(1)\n        go func(a int) {\n            for i := 1; i <= 10; i++ {\n                fmt.Printf(\"%dx%d=%d\\n\", a, i, a*i)\n            }\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n}\n```", "```go\nfunc main() {\n    wg := sync.WaitGroup{}\n    for i := 1; i < 10; i++ {\n        go func(a int) {\n            wg.Add(1)\n            for i := 1; i <= 10; i++ {\n                fmt.Printf(\"%dx%d=%d\\n\", a, i, a*i)\n            }\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n}\n```", "```go\ntype obj struct {}\n\nvar instance *obj\n\nfunc Get() *obj{\n    if instance == nil {\n        instance = &obj{}\n    }\n    return instance\n}\n```", "```go\ntype obj struct {}\n\nvar (\n    instance *obj\n    lock     sync.Mutex\n)\n\nfunc Get() *obj{\n    lock.Lock()\n    defer lock.Unlock()\n    if instance == nil {\n        instance = &obj{}\n    }\n    return instance\n}\n```", "```go\ntype obj struct {}\n\nvar (\n    instance *obj\n    once     sync.Once\n)\n\nfunc Get() *obj{\n    once.Do(func(){\n        instance = &obj{}\n    })\n    return instance\n}\n```", "```go\ntype A struct{}\n\ntype Pool chan *A\n\nfunc (p Pool) Get() *A {\n    select {\n    case a := <-p:\n        return a\n    default:\n        return new(A)\n    }\n}\n\nfunc (p Pool) Put(a *A) {\n    select {\n    case p <- a:\n    default:\n    }\n}\n```", "```go\ntype Pool struct {\n    // New optionally specifies a function to generate\n    // a value when Get would otherwise return nil.\n    // It may not be changed concurrently with calls to Get.\n    New func() interface{}\n    // contains filtered or unexported fields\n}\n```", "```go\nvar pool = sync.Pool{\n    New: func() interface{} {\n        return bytes.NewBuffer(make([]byte, 0, 4096))\n    },\n}\n\nfunc Get() *bytes.Buffer {\n    return pool.Get().(*bytes.Buffer)\n}\n\nfunc Put(b *bytes.Buffer) {\n    b.Reset()\n    pool.Put(b)\n}\n```", "```go\nstart := time.Now()\nwg := sync.WaitGroup{}\nwg.Add(20)\nfor i := 0; i < 20; i++ {\n    go func(v int) {\n        time.Sleep(time.Second * time.Duration(1+v/4))\n        b := Get()\n        defer func() {\n            Put(b)\n            wg.Done()\n        }()\n        fmt.Fprintf(b, \"Goroutine %2d using %p, after %.0fs\\n\", v, b, time.Since(start).Seconds())\n        fmt.Printf(\"%s\", b.Bytes())\n    }(i)\n}\nwg.Wait()\n```", "```go\nvar (\n    list = make([][]byte, 20)\n    m sync.Mutex\n)\nfor i := 0; i < 20; i++ {\n    go func(v int) {\n        time.Sleep(time.Second * time.Duration(1+v/4))\n        b := Get()\n        defer func() {\n            Put(b)\n            wg.Done()\n        }()\n        fmt.Fprintf(b, \"Goroutine %2d using %p, after %.0fs\\n\", v, b, time.Since(start).Seconds())\n        m.Lock()\n        list[v] = b.Bytes()\n        m.Unlock()\n    }(i)\n}\nwg.Wait()\n```", "```go\n\nfor i := range list {\n    fmt.Printf(\"%d - %s\", i, list[i])\n}\n```", "```go\nm.Lock()\nlist[v] = make([]byte, b.Len())\ncopy(list[v], b.Bytes())\nm.Unlock()\n```", "```go\nch := make(chan struct{})\ngo func() {\n    // do something\n    ch <- struct{}{}\n}()\ngo func() {\n    // wait for condition\n    <-ch\n    // do something else\n}\n```", "```go\ngo func() {\n    // do something\n    close(ch)\n}()\nfor i := 0; i < n; i++ {\n    go func() {\n        // wait for condition\n        <-ch\n        // do something else\n    }()\n}\n```", "```go\ntype record struct {\n    sync.Mutex\n    buf string\n    cond *sync.Cond\n    writers []io.Writer\n}\n```", "```go\nfunc (r *record) Run() {\n    for i := range r.writers {\n        go func(i int) {\n            for {\n                r.Lock()\n                r.cond.Wait()\n                fmt.Fprintf(r.writers[i], \"%s\\n\", r.buf)\n                r.Unlock()\n            }\n        }(i)\n    }\n}\n```", "```go\n// let's make sure we have at least a file argument\nif len(os.Args) < 2 {\n    log.Fatal(\"Please specify at least a file\")\n}\nr := record{\n    writers: make([]io.Writer, len(os.Args)-1),\n}\nr.cond = sync.NewCond(&r)\nfor i, v := range os.Args[1:] {\n    f, err := os.Create(v)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    r.writers[i] = f\n}\nr.Run()\n```", "```go\nscanner := bufio.NewScanner(os.Stdin)\nfor {\n    fmt.Printf(\":> \")\n    if !scanner.Scan() {\n        break\n    }\n    r.Lock()\n    r.buf = scanner.Text()\n    r.Unlock()\n    switch {\n    case r.buf == `\\q`:\n        return\n    default:\n        r.cond.Broadcast()\n    }\n}\n```", "```go\nfunc main() {\n    var m = map[int]int{}\n    wg := sync.WaitGroup{}\n    wg.Add(10)\n    for i := 0; i < 10; i++ {\n        go func(i int) {\n            m[i%5]++\n            fmt.Println(m)\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n}\n```", "```go\nfunc main() {\n    var m = map[int]int{}\n    var done = make(chan struct{})\n    go func() {\n        for i := 0; i < 100; i++ {\n            time.Sleep(time.Nanosecond)\n            m[i]++\n        }\n        close(done)\n    }()\n    for {\n        time.Sleep(time.Nanosecond)\n        fmt.Println(len(m), m)\n        select {\n        case <-done:\n            return\n        default:\n        }\n    }\n}\n```", "```go\ntype m struct {\n    sync.Mutex\n    m map[int]int\n}\n```", "```go\nfunc (m *m) Get(key int) int {\n    m.Lock()\n    a := m.m[key]\n    m.Unlock()\n    return a\n}\n\nfunc (m *m) Put(key, value int) {\n    m.Lock()\n    m.m[key] = value\n    m.Unlock()\n}\n```", "```go\nfunc (m *m) Range(f func(k, v int)) {\n    m.Lock()\n    for k, v := range m.m {\n        f(k, v)\n    }\n    m.Unlock()\n}\n```", "```go\nfunc main() {\n    var m = sync.Map{}\n    var wg = sync.WaitGroup{}\n    wg.Add(1000)\n    for i := 0; i < 1000; i++ {\n        go func(i int) {\n            m.LoadOrStore(i, i)\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n    i := 0\n    m.Range(func(k, v interface{}) bool {\n        i++\n        return true\n    })\n   fmt.Println(i)\n}\n```", "```go\nfunc main() {\n    s := semaphore.NewWeighted(int64(10))\n    ctx := context.Background()\n    for i := 0; i < 20; i++ {\n        if err := s.Acquire(ctx, 1); err != nil {\n            log.Fatal(err)\n        }\n        go func(i int) {\n            fmt.Println(i)\n            s.Release(1)\n        }(i)\n    }\n    time.Sleep(time.Second)\n}\n```", "```go\ntype clicker int32\n\nfunc (c *clicker) Click() int32 {\n    return atomic.AddInt32((*int32)(c), 1)\n}\n\nfunc (c *clicker) Reset() {\n    atomic.StoreInt32((*int32)(c), 0)\n}\n\nfunc (c *clicker) Value() int32 {\n    return atomic.LoadInt32((*int32)(c))\n}\n```", "```go\nc := clicker(0)\nwg := sync.WaitGroup{}\n// 2*iteration + reset at 5\nwg.Add(21)\n```", "```go\nfor i := 0; i < 10; i++ {\n    go func() {\n        c.Click()\n        fmt.Println(\"click\")\n        wg.Done()\n    }()\n    go func() {\n        fmt.Println(\"load\", c.Value())\n        wg.Done()\n    }()\n    if i == 0 || i%5 != 0 {\n        continue\n    }\n    go func() {\n        c.Reset()\n        fmt.Println(\"reset\")\n        wg.Done()\n    }()\n}\nwg.Wait()\n```", "```go\ntype f64 uint64\n\nfunc uf(u uint64) (f float64) { return math.Float64frombits(u) }\nfunc fu(f float64) (u uint64) { return math.Float64bits(f) }\n\nfunc newF64(f float64) *f64 {\n    v := f64(fu(f))\n    return &v\n}\n\nfunc (f *f64) Load() float64 {\n  return uf(atomic.LoadUint64((*uint64)(f)))\n}\n\nfunc (f *f64) Store(s float64) {\n  atomic.StoreUint64((*uint64)(f), fu(s))\n}\n```", "```go\nfunc (f *f64) Add(s float64) float64 {\n    for {\n        old := f.Load()\n        new := old + s\n        if f.CompareAndSwap(old, new) {\n            return new\n        }\n    }\n}\n\nfunc (f *f64) CompareAndSwap(old, new float64) bool {\n    return atomic.CompareAndSwapUint64((*uint64)(f), fu(old), fu(new))\n}\n```", "```go\ntype cond int32\n\nfunc (c *cond) Set(v bool) {\n    a := int32(0)\n    if v {\n        a++\n    }\n    atomic.StoreInt32((*int32)(c), a)\n}\n\nfunc (c *cond) Value() bool {\n    return atomic.LoadInt32((*int32)(c)) != 0\n}\n```", "```go\nv1, v2 := 10, 100\np1, p2 := &v1, &v2\nlog.Printf(\"P1: %v, P2: %v\", *p1, *p2)\natomic.SwapPointer((*unsafe.Pointer)(unsafe.Pointer(&p1)), unsafe.Pointer(p2))\nlog.Printf(\"P1: %v, P2: %v\", *p1, *p2)\nv1 = -10\nlog.Printf(\"P1: %v, P2: %v\", *p1, *p2)\nv2 = 3\nlog.Printf(\"P1: %v, P2: %v\", *p1, *p2)\n```", "```go\nfunc main() {\n    var (\n        v atomic.Value\n        wg sync.WaitGroup\n    )\n    wg.Add(20)\n    for i := 0; i < 10; i++ {\n        go func(i int) {\n            fmt.Println(\"load\", v.Load())\n            wg.Done()\n        }(i)\n        go func(i int) {\n            v.Store(i)\n            fmt.Println(\"store\", i)\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n}\n```", "```go\ntype Value struct {\n    v interface{}\n}\n```", "```go\ntype ifaceWords struct {\n    typ unsafe.Pointer\n    data unsafe.Pointer\n}\n```"]