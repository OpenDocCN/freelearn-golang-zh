["```go\ntype Context interface {\n    Deadline() (deadline time.Time, ok bool)\n    Done() <-chan struct{}\n    Err() error\n    Value(key interface{}) interface{}\n}\n```", "```go\nfunc main() {\n    ctx := context.Background()\n    done := ctx.Done()\n    for i :=0; ;i++{\n        select {\n        case <-done:\n            return\n        case <-time.After(time.Second):\n            fmt.Println(\"tick\", i)\n        }\n    }\n}\n```", "```go\nvar (\n    background = new(emptyCtx)\n    todo = new(emptyCtx)\n)\n```", "```go\nfunc main() {\n    ctx, cancel := context.WithCancel(context.Background())\n    time.AfterFunc(time.Second*5, cancel)\n    done := ctx.Done()\n    for i := 0; ; i++ {\n        select {\n        case <-done:\n            fmt.Println(\"exit\", ctx.Err())\n            return\n        case <-time.After(time.Second):\n            fmt.Println(\"tick\", i)\n        }\n    }\n}\n```", "```go\nfunc main() {\n    ctx, cancel := context.WithDeadline(context.Background(), \n         time.Now().Add(5*time.Second))\n    time.AfterFunc(time.Second*10, cancel)\n    done := ctx.Done()\n    for i := 0; ; i++ {\n        select {\n        case <-done:\n            fmt.Println(\"exit\", ctx.Err())\n            return\n        case <-time.After(time.Second):\n            fmt.Println(\"tick\", i)\n        }\n    }\n}\n```", "```go\nfunc main() {\n    ctx, cancel := context.WithTimeout(context.Background(),5*time.Second)\n    time.AfterFunc(time.Second*10, cancel)\n    done := ctx.Done()\n    for i := 0; ; i++ {\n        select {\n        case <-done:\n            fmt.Println(\"exit\", ctx.Err())\n            return\n        case <-time.After(time.Second):\n            fmt.Println(\"tick\", i)\n        }\n    }\n}\n```", "```go\ntype key struct{}\n\ntype key struct{}\n\nfunc main() {\n    ctx, canc := context.WithCancel(context.Background())\n    wg := sync.WaitGroup{}\n    wg.Add(5)\n    for i := 0; i < 5; i++ {\n        go func(ctx context.Context) {\n            v := ctx.Value(key{})\n            fmt.Println(\"key\", v)\n            wg.Done()\n            <-ctx.Done()\n            fmt.Println(ctx.Err(), v)\n        }(context.WithValue(ctx, key{}, i))\n    }\n    wg.Wait()\n    canc()\n    time.Sleep(time.Second)\n}\n\n```", "```go\ntype key *int\n\nfunc main() {\n    k := new(key)\n    ctx, canc := context.WithCancel(context.Background())\n    wg := sync.WaitGroup{}\n    wg.Add(5)\n    for i := 0; i < 5; i++ {\n        go func(ctx context.Context) {\n            v := ctx.Value(k)\n            fmt.Println(\"key\", v, ctx.Value(new(key)))\n            wg.Done()\n            <-ctx.Done()\n            fmt.Println(ctx.Err(), v)\n        }(context.WithValue(ctx, k, i))\n    }\n    wg.Wait()\n    canc()\n    time.Sleep(time.Second)\n}\n```", "```go\ntype keyType struct{}\n\nvar key = &keyType{}\n\nfunc WithKey(ctx context.Context, value string) context.Context {\n    return context.WithValue(ctx, key, value)\n}\n\nfunc GetKey(ctx context.Context) (string, bool) {\n    v := ctx.Value(key)\n    if v == nil {\n        return \"\", false\n    }\n    return v.(string), true\n}\n```", "```go\nfunc main() {\n    const addr = \"localhost:8080\"\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        time.Sleep(time.Second * 5)\n    })\n    go func() {\n        if err := http.ListenAndServe(addr, nil); err != nil {\n            log.Fatalln(err)\n        }\n    }()\n    req, _ := http.NewRequest(http.MethodGet, \"http://\"+addr, nil)\n    ctx, canc := context.WithTimeout(context.Background(), time.Second*2)\n    defer canc()\n    time.Sleep(time.Second)\n    if _, err := http.DefaultClient.Do(req.WithContext(ctx)); err != nil {\n        log.Fatalln(err)\n    }\n}\n```", "```go\nconst addr = \"localhost:8080\"\nhttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    d := time.Second * time.Duration(rand.Intn(10))\n    log.Println(\"wait\", d)\n    time.Sleep(d)\n})\ngo func() {\n    if err := http.ListenAndServe(addr, nil); err != nil {\n        log.Fatalln(err)\n    }\n}()\n```", "```go\nctx, canc := context.WithCancel(context.Background())\nch, o, wg := make(chan int), sync.Once{}, sync.WaitGroup{}\nwg.Add(10)\nfor i := 0; i < 10; i++ {\n    go func(i int) {\n        defer wg.Done()\n        req, _ := http.NewRequest(http.MethodGet, \"http://\"+addr, nil)\n        if _, err := http.DefaultClient.Do(req.WithContext(ctx)); err != nil {\n            log.Println(i, err)\n            return\n        }\n        o.Do(func() { ch <- i })\n    }(i)\n}\nlog.Println(\"received\", <-ch)\ncanc()\nlog.Println(\"cancelling\")\nwg.Wait()\n```", "```go\nmux := http.NewServeMux()\nserver := http.Server{\n    Addr: \":3000\",\n    Handler: mux,\n}\nctx, canc := context.WithCancel(context.Background())\ndefer canc()\nmux.HandleFunc(\"/shutdown\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"OK\"))\n    canc()\n})\n```", "```go\ngo func() {\n    if err := server.ListenAndServe(); err != nil {\n        if err != http.ErrServerClosed {\n            log.Fatal(err)\n        }\n    }\n}()\n```", "```go\nselect {\ncase <-ctx.Done():\n    ctx, canc := context.WithTimeout(context.Background(), time.Second*5)\n    defer canc()\n    if err := server.Shutdown(ctx); err != nil {\n        log.Fatalln(\"Shutdown:\", err)\n    } else {\n        log.Println(\"Shutdown:\", \"ok\")\n    }\n}\n```", "```go\ntype keyType struct{}\n\nvar key = &keyType{}\n\nvar counter int32\n\nfunc WithKey(ctx context.Context) context.Context {\n    return context.WithValue(ctx, key, atomic.AddInt32(&counter, 1))\n}\n\nfunc GetKey(ctx context.Context) (int32, bool) {\n    v := ctx.Value(key)\n    if v == nil {\n        return 0, false\n    }\n    return v.(int32), true\n}\n```", "```go\n\nfunc AssignKeyHandler(h http.Handler) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        ctx := r.Context()\n        if ctx == nil {\n            ctx = context.Background()\n        }\n        if _, ok := GetKey(ctx); !ok {\n            ctx = WithKey(ctx)\n        }\n        h.ServeHTTP(w, r.WithContext(ctx))\n    }\n}\n```", "```go\nfunc ReadFileHandler(root string) http.HandlerFunc {\n    root = filepath.Clean(root)\n    return func(w http.ResponseWriter, r *http.Request) {\n        k, _ := GetKey(r.Context())\n        path := filepath.Join(root, r.URL.Path)\n        log.Printf(\"[%d] requesting path %s\", k, path)\n        if !strings.HasPrefix(path, root) {\n            http.Error(w, \"not found\", http.StatusNotFound)\n            log.Printf(\"[%d] unauthorized %s\", k, path)\n            return\n        }\n        if stat, err := os.Stat(path); err != nil || stat.IsDir() {\n            http.Error(w, \"not found\", http.StatusNotFound)\n            log.Printf(\"[%d] not found %s\", k, path)\n            return\n        }\n        http.ServeFile(w, r, path)\n        log.Printf(\"[%d] ok: %s\", k, path)\n    }\n}\n```", "```go\nhome, err := os.UserHomeDir()\nif err != nil {\n    log.Fatal(err)\n}\ntmp := os.TempDir()\nmux := http.NewServeMux()\nserver := http.Server{\n    Addr: \":3000\",\n    Handler: mux,\n}\n\nmux.Handle(\"/tmp/\", http.StripPrefix(\"/tmp/\", AssignKeyHandler(ReadFileHandler(tmp))))\nmux.Handle(\"/home/\", http.StripPrefix(\"/home/\", AssignKeyHandler(ReadFileHandler(home))))\nif err := server.ListenAndServe(); err != nil {\n    if err != http.ErrServerClosed {\n        log.Fatal(err)\n    }\n}\n```", "```go\naddr := os.Args[1]\ngo func() {\n    time.Sleep(time.Second)\n    listener, err := net.Listen(\"tcp\", addr)\n    if err != nil {\n        log.Fatalln(\"Listener:\", addr, err)\n    }\n    c, err := listener.Accept()\n    if err != nil {\n        log.Fatalln(\"Listener:\", addr, err)\n    }\n    defer c.Close()\n}()\n```", "```go\nctx, canc := context.WithTimeout(context.Background(),   \n    time.Millisecond*100)\ndefer canc()\nconn, err := (&net.Dialer{}).DialContext(ctx, \"tcp\", os.Args[1])\nif err != nil {\n    log.Fatalln(\"-> Connection:\", err)\n}\nlog.Println(\"-> Connection to\", os.Args[1])\nconn.Close()\n```", "```go\nlist := []string{\n    \"localhost:9090\",\n    \"localhost:9091\",\n    \"localhost:9092\",\n}\ngo func() {\n    listener, err := net.Listen(\"tcp\", list[0])\n    if err != nil {\n        log.Fatalln(\"Listener:\", list[0], err)\n    }\n    time.Sleep(time.Second * 5)\n    c, err := listener.Accept()\n    if err != nil {\n        log.Fatalln(\"Listener:\", list[0], err)\n    }\n    defer c.Close()\n}()\n```", "```go\nctx, canc := context.WithTimeout(context.Background(), time.Second*10)\ndefer canc()\nwg := sync.WaitGroup{}\nwg.Add(len(list))\nfor _, addr := range list {\n    go func(addr string) {\n        defer wg.Done()\n        conn, err := (&net.Dialer{}).DialContext(ctx, \"tcp\", addr)\n        if err != nil {\n            log.Println(\"-> Connection:\", err)\n            return\n        }\n        log.Println(\"-> Connection to\", addr, \"cancelling context\")\n        canc()\n        conn.Close()\n    }(addr)\n}\nwg.Wait()\n```", "```go\nfunc main() {\n    s := semaphore.NewWeighted(int64(5))\n    ctx, canc := context.WithTimeout(context.Background(), time.Second)\n    defer canc()\n    wg := sync.WaitGroup{}\n    wg.Add(20)\n    for i := 0; i < 20; i++ {\n        go func(i int) {\n            defer wg.Done()\n            if err := s.Acquire(ctx, 1); err != nil {\n                fmt.Println(i, err)\n                return\n            }\n            go func(i int) {\n                fmt.Println(i)\n                time.Sleep(time.Second / 2)\n                s.Release(1)\n            }(i)\n        }(i)\n    }\n    wg.Wait()\n}\n```", "```go\nfunc main() {\n    var a interface{} = \"request-id\"\n    var b interface{} = \"request-id\"\n    fmt.Println(a == b)\n\n    ctx := context.Background()\n    ctx = context.WithValue(ctx, a, \"a\")\n    ctx = context.WithValue(ctx, b, \"b\")\n    fmt.Println(ctx.Value(a), ctx.Value(b))\n}\n```", "```go\nfunc SomeFunc(ctx context.Context, \n    name, surname string, age int, \n    resourceID string, resourceName string) {}\n```", "```go\ntype User struct {\n    Name string\n    Surname string\n    Age int\n}\n\ntype Resource struct {\n    ID string\n    Name string\n}\n\nfunc SomeFunc(ctx context.Context, u User, r Resource) {}\n```", "```go\n// This function has two mandatory args and 4 optional ones\nfunc SomeFunc(ctx context.Context, arg1, arg2 int, \n    opt1, opt2, opt3, opt4 string) {}\n```", "```go\ntype Optional struct {\n    Opt1 string\n    Opt2 string\n    Opt3 string\n    Opt4 string\n}\n\n// This function has two mandatory args and 4 optional ones\nfunc SomeFunc(ctx context.Context, arg1, arg2 int, o *Optional) {}\n```", "```go\ntype Options struct {\n    Contents bool\n    Exclude []string\n}\n\nfunc FileSearch(ctx context.Context, root, term string, o *Options)\n```", "```go\ntype Result struct {\n    Err error\n    File string\n    Matches []Match\n}\n\ntype Match struct {\n    Line int\n    Text string\n}\n```", "```go\nfunc FileSearch(ctx context.Context, root, term string, o *Options) <-chan Result\n```", "```go\nfor r := range FileSearch(ctx, directory, searchTerm, options) {\n    if r.Err != nil {\n        fmt.Printf(\"%s - error: %s\\n\", r.File, r.Err)\n        continue\n    }\n    if !options.Contents {\n        fmt.Printf(\"%s - match\\n\", r.File)\n        continue\n    }\n    fmt.Printf(\"%s - matches:\\n\", r.File)\n    for _, m := range r.Matches {\n        fmt.Printf(\"\\t%d:%s\\n\", m.Line, m.Text)\n    }\n}\n```", "```go\nch, wg, once := make(chan Result), sync.WaitGroup{}, sync.Once{}\ngo func() {\n    wg.Wait()\n    fmt.Println(\"* Search done *\")\n    once.Do(func() {\n        close(ch)\n    })\n}()\ngo func() {\n    <-ctx.Done()\n    fmt.Println(\"* Context done *\")\n    once.Do(func() {\n        close(ch)\n    })\n}()\n```", "```go\nfunc fileSearch(ctx context.Context, ch chan<- Result, wg *sync.WaitGroup, file, term string, o *Options)\n```", "```go\nwg.Add(1)\ngo fileSearch(ctx, ch, &wg, root, term, o)\n```", "```go\ndefer wg.Done()\n_, name := filepath.Split(file)\nif o != nil {\n    for _, e := range o.Exclude {\n        if e == name {\n            return\n        }\n    }\n}\n```", "```go\ninfo, err := os.Stat(file)\nif err != nil {\n    select {\n    case <-ctx.Done():\n        return\n    default:\n        ch <- Result{File: file, Err: err}\n    }\n    return\n}\n```", "```go\nif info.IsDir() {\n    files, err := ioutil.ReadDir(file)\n    if err != nil {\n        select {\n        case <-ctx.Done():\n            return\n        default:\n            ch <- Result{File: file, Err: err}\n        }\n        return\n    }\n    select {\n    case <-ctx.Done():\n    default:\n        wg.Add(len(files))\n        for _, f := range files {\n            go fileSearch(ctx, ch, wg, filepath.Join(file, \n        f.Name()), term, o)\n        }\n    }\n    return\n}\n```", "```go\nif o == nil || !o.Contents {\n    if name == term {\n        select {\n        case <-ctx.Done():\n        default:\n            ch <- Result{File: file}\n        }\n    }\n    return\n}\n```", "```go\nf, err := os.Open(file)\nif err != nil {\n    select {\n    case <-ctx.Done():\n    default:\n        ch <- Result{File: file, Err: err}\n    }\n    return\n}\ndefer f.Close()\n```", "```go\nscanner, matches, line := bufio.NewScanner(f), []Match{}, 1\nfor scanner.Scan() {\n    select {\n    case <-ctx.Done():\n        break\n    default:\n        if text := scanner.Text(); strings.Contains(text, term) {\n            matches = append(matches, Match{Line: line, Text: text})\n        }\n        line++\n    }\n}\n```", "```go\nselect {\ncase <-ctx.Done():\n    break\ndefault:\n    if err := scanner.Err(); err != nil {\n        ch <- Result{File: file, Err: err}\n        return\n    }\n    if len(matches) != 0 {\n        ch <- Result{File: file, Matches: matches}\n    }\n}\n```"]