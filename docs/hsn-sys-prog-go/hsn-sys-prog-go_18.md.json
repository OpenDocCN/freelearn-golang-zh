["```go\ntype Generator interface {\n    Next() interface{}\n}\n\ntype GenInt64 interface {\n    Next() int64\n}\n```", "```go\ntype genInt64 int64\n\nfunc (g *genInt64) Next() int64 {\n    *g++\n    return int64(*g)\n}\n```", "```go\nfunc main() {\n    var g genInt64\n    for i := 0; i < 1000; i++ {\n        go func(i int) {\n            fmt.Println(i, g.Next())\n        }(i)\n    }\n    time.Sleep(time.Second)\n}\n```", "```go\ntype genInt64 int64\n\nfunc (g *genInt64) Next() int64 {\n    return atomic.AddInt64((*int64)(g), 1)\n}\n```", "```go\ntype genInt64 struct {\n    ch chan int64\n}\n\nfunc (g genInt64) Next() int64 {\n    return <-g.ch\n}\n\nfunc NewGenInt64() genInt64 {\n    g := genInt64{ch: make(chan int64)}\n    go func() {\n        for i := int64(0); ; i++ {\n            g.ch <- i\n        }\n    }()\n    return g\n}\n```", "```go\nfunc GenInt64() <-chan int64 {\n ch:= make(chan int64)\n    go func() {\n        for i := int64(0); ; i++ {\n            ch <- i\n        }\n    }()\n    return ch\n}\n```", "```go\nfunc main() {\n    ch1, ch2 := GenInt64(), GenInt64()\n    for i := 0; i < 20; i++ {\n        select {\n        case v := <-ch1:\n            fmt.Println(\"ch 1\", v)\n        case v := <-ch2:\n            fmt.Println(\"ch 2\", v)\n        }\n    }\n}\n```", "```go\nfunc NewGenInt64(ctx context.Context) genInt64 {\n    g := genInt64{ch: make(chan int64)}\n    go func() {\n        for i := int64(0); ; i++ {\n            select {\n            case g.ch <- i:\n                // do nothing\n            case <-ctx.Done():\n                close(g.ch)\n                return\n            }\n        }\n    }()\n    return g\n}\n```", "```go\nfunc main() {\n    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*100)\n    defer cancel()\n    g := NewGenInt64(ctx)\n    for i := range g.ch {\n        go func(i int64) {\n            fmt.Println(i, g.Next())\n        }(i)\n    }\n    time.Sleep(time.Second)\n}\n```", "```go\nfunc stage(in <-chan interface{}) <-chan interface{} {\n    var out = make(chan interface{})\n    go func() {\n        for v := range in {\n            v = v.(int)+1 // some operation\n            out <- v\n        }\n        close(out)\n    }()\n    return out\n}\n```", "```go\nfunc stage(ctx context.Context, in <-chan interface{}) <-chan interface{} {\n    var out = make(chan interface{})\n    go func() {\n        defer close(out)\n        for v := range in {\n            v = v.(int)+1 // some operation\n            select {\n                case out <- v:\n                case <-ctx.Done():\n                    return\n            }\n        }\n    }()\n    return out\n}\n```", "```go\nfunc SourceLine(ctx context.Context, r io.ReadCloser) <-chan string {\n    ch := make(chan string)\n    go func() {\n        defer func() { r.Close(); close(ch) }()\n        s := bufio.NewScanner(r)\n        for s.Scan() {\n            select {\n            case <-ctx.Done():\n                return\n            case ch <- s.Text():\n            }\n        }\n    }()\n    return ch\n}\n```", "```go\nfunc TextFilter(ctx context.Context, src <-chan string, filter string) <-chan string {\n    ch := make(chan string)\n    go func() {\n        defer close(ch)\n        for v := range src {\n            if !strings.Contains(v, filter) {\n                continue\n            }\n            select {\n            case <-ctx.Done():\n                return\n            case ch <- v:\n            }\n        }\n    }()\n    return ch\n}\n```", "```go\nfunc Printer(ctx context.Context, src <-chan string, color int, highlight string, w io.Writer) {\n    const close = \"\\x1b[39m\"\n    open := fmt.Sprintf(\"\\x1b[%dm\", color)\n    for {\n        select {\n        case <-ctx.Done():\n            return\n        case v, ok := <-src:\n            if !ok {\n                return\n            }\n            i := strings.Index(v, highlight)\n            if i == -1 {\n                panic(v)\n            }\n            fmt.Fprint(w, v[:i], open, highlight, close, v[i+len(highlight):], \"\\n\")\n        }\n    }\n}\n```", "```go\nfunc main() {\n    var search string\n    ...\n    ctx := context.Background()\n    src := SourceLine(ctx, ioutil.NopCloser(strings.NewReader(sometext)))\n    filter := TextFilter(ctx, src, search)\n    Printer(ctx, filter, 31, search, os.Stdout)\n}\n```", "```go\nfunc SourceLineWords(ctx context.Context, r io.ReadCloser) <-chan []string {\n    ch := make(chan []string)\n    go func() {\n        defer func() { r.Close(); close(ch) }()\n        b := bytes.Buffer{}\n        s := bufio.NewScanner(r)\n        for s.Scan() {\n            b.Reset()\n            b.Write(s.Bytes())\n            words := []string{}\n            w := bufio.NewScanner(&b)\n            w.Split(bufio.ScanWords)\n            for w.Scan() {\n                words = append(words, w.Text())\n            }\n            select {\n            case <-ctx.Done():\n                return\n            case ch <- words:\n            }\n        }\n    }()\n    return ch\n}\n```", "```go\nfunc WordOccurrence(ctx context.Context, src <-chan []string) <-chan map[string]int {\n    ch := make(chan map[string]int)\n    go func() {\n        defer close(ch)\n        for v := range src {\n            count := make(map[string]int)\n            for _, s := range v {\n                count[s]++\n            }\n            select {\n            case <-ctx.Done():\n                return\n            case ch <- count:\n            }\n        }\n    }()\n    return ch\n}\n```", "```go\nctx, canc := context.WithCancel(context.Background())\ndefer canc()\nsrc := SourceLineWords(ctx,   \n    ioutil.NopCloser(strings.NewReader(cantoUno)))\ncount1, count2 := WordOccurrence(ctx, src), WordOccurrence(ctx, src)\n```", "```go\nwg := sync.WaitGroup{}\nmerge := make(chan map[string]int)\nwg.Add(len(src))\ngo func() {\n    wg.Wait()\n    close(merge)\n}()\n```", "```go\nfor _, ch := range src {\n    go func(ch <-chan map[string]int) {\n        defer wg.Done()\n        for v := range ch {\n            select {\n            case <-ctx.Done():    \n                return\n            case merge <- v:\n            }\n        }\n    }(ch)\n}\n```", "```go\ncount := make(map[string]int)\nfor {\n    select {\n    case <-ctx.Done():\n        return count\n    case c, ok := <-merge:\n        if !ok {\n            return count\n        }\n        for k, v := range c {\n            count[k] += v\n        }\n    }\n}\n```", "```go\nfunc main() {\n    ctx, canc := context.WithCancel(context.Background())\n    defer canc()\n    src := SourceLineWords(ctx, ioutil.NopCloser(strings.NewReader(cantoUno)))\n    count1, count2 := WordOccurrence(ctx, src), WordOccurrence(ctx, src)\n    final := MergeCounts(ctx, count1, count2)\n    fmt.Println(final)\n}\n```", "```go\nfunc main() {\n    // one producer\n    var ch = make(chan int)\n    go func() {\n        for i := 0; i < 100; i++ {\n            ch <- i\n        }\n        close(ch)\n    }()\n    // one consumer\n    var done = make(chan struct{})\n    go func() {\n        for i := range ch {\n            fmt.Println(i)\n        }\n        close(done)\n    }()\n    <-done\n}\n```", "```go\n// three producer\nvar ch = make(chan string)\nwg := sync.WaitGroup{}\nwg.Add(3)\nfor i := 0; i < 3; i++ {\n    go func(n int) {\n        for i := 0; i < 100; i++ {\n            ch <- fmt.Sprintln(n, i)\n        }\n        wg.Done()\n    }(i)\n}\ngo func() {\n    wg.Wait()\n    close(ch)\n}()\n```", "```go\nfunc main() {\n    // three consumers\n    wg := sync.WaitGroup{}\n    wg.Add(3)\n    var ch = make(chan string)\n\n    for i := 0; i < 3; i++ {\n        go func(n int) {\n            for i := range ch {\n                fmt.Println(n, i)\n            }\n            wg.Done()\n        }(i)\n    }\n\n    // one producer\n    go func() {\n        for i := 0; i < 10; i++ {\n            ch <- fmt.Sprintln(\"prod-\", i)\n        }\n        close(ch)\n    }()\n\n    wg.Wait()\n}\n```", "```go\nconst (\n    N = 3\n    M = 5\n)\nwg1 := sync.WaitGroup{}\nwg1.Add(N)\nwg2 := sync.WaitGroup{}\nwg2.Add(M)\nvar ch = make(chan string)\n```", "```go\nfor i := 0; i < N; i++ {\n    go func(n int) {\n        for i := 0; i < 10; i++ {\n            ch <- fmt.Sprintf(\"src-%d[%d]\", n, i)\n        }\n        wg1.Done()\n    }(i)\n}\n\nfor i := 0; i < M; i++ {\n    go func(n int) {\n        for i := range ch {\n            fmt.Printf(\"cons-%d, msg %q\\n\", n, i)\n        }\n        wg2.Done()\n    }(i)\n}\n```", "```go\nwg1.Wait()\nclose(ch)\nwg2.Wait()\n```", "```go\nfunc main() {\n    ctx, canc := context.WithTimeout(context.Background(), time.Second)\n    defer canc()\n    wg := sync.WaitGroup{}\n    wg.Add(10)\n    var ch = make(chan int)\n    for i := 0; i < 10; i++ {\n        go func(ctx context.Context, i int) {\n            defer wg.Done()\n            d := time.Duration(rand.Intn(2000)) * time.Millisecond\n            time.Sleep(d)\n            select {\n            case <-ctx.Done():\n                fmt.Println(i, \"early exit after\", d)\n                return\n            case ch <- i:\n                fmt.Println(i, \"normal exit after\", d)\n            }\n        }(ctx, i)\n    }\n    go func() {\n        wg.Wait()\n        close(ch)\n    }()\n    for range ch {\n    }\n}\n```", "```go\nfunc visitor(url string) func() error {\n    return func() (err error) {\n        s := time.Now()\n        defer func() {\n            log.Println(url, time.Since(s), err)\n        }()\n        var resp *http.Response\n        if resp, err = http.Get(url); err != nil {\n            return\n        }\n        return resp.Body.Close()\n    }\n}\n```", "```go\nfunc main() {\n    eg := errgroup.Group{}\n    var urlList = []string{\n        \"http://www.golang.org/\",\n        \"http://invalidwebsite.hey/\",\n        \"http://www.google.com/\",\n    }\n    for _, url := range urlList {\n        eg.Go(visitor(url))\n    }\n    if err := eg.Wait(); err != nil {\n        log.Fatalln(\"Error:\", err)\n    }\n}\n```", "```go\nfunc sender(ctx context.Context, ch chan<- string, n int) func() error {\n    return func() (err error) {\n        for i := 0; ; i++ {\n            if rand.Intn(100) == 42 {\n                return errors.New(\"the answer\")\n            }\n            select {\n            case ch <- fmt.Sprintf(\"[%d]%d\", n, i):\n            case <-ctx.Done():\n                return nil\n            }\n        }\n    }\n}\n```", "```go\nfunc main() {\n    eg, ctx := errgroup.WithContext(context.Background())\n    ch := make(chan string)\n    for i := 0; i < 10; i++ {\n        eg.Go(sender(ctx, ch, i))\n    }\n    go func() {\n        for s := range ch {\n            log.Println(s)\n        }\n    }()\n    if err := eg.Wait(); err != nil {\n        log.Println(\"Error:\", err)\n    }\n    close(ch)\n    log.Println(\"waiting...\")\n    time.Sleep(time.Second)\n}\n```", "```go\ntype bucket struct {\n    capacity uint64\n    status uint64\n}\n```", "```go\nfunc newBucket(ctx context.Context, cap uint64, rate time.Duration) *bucket {\n    b := bucket{capacity: cap, status: cap}\n    go func() {\n        t := time.NewTicker(rate)\n        for {\n            select {\n            case <-t.C:\n                atomic.StoreUint64(&b.status, b.capacity)\n            case <-ctx.Done():\n                t.Stop()\n                return\n            }\n        }\n    }()\n    return &b\n}\n```", "```go\nfunc (b *bucket) Add(n uint64) uint64 {\n    for {\n        r := atomic.LoadUint64(&b.status)\n        if r == 0 {\n            return 0\n        }\n        if n > r {\n            n = r\n        }\n        if !atomic.CompareAndSwapUint64(&b.status, r, r-n) {\n            continue\n        }\n        return n\n    }\n}\n```", "```go\ntype client struct {\n    name string\n    max int\n    b *bucket\n    sleep time.Duration\n}\n\nfunc (c client) Run(ctx context.Context, start time.Time) {\n    for {\n        select {\n        case <-ctx.Done():\n            return\n        default:\n            n := 1 + rand.Intn(c.max-1)\n            time.Sleep(c.sleep)\n            e := time.Since(start).Seconds()\n            a := c.b.Add(uint64(n))\n            log.Printf(\"%s tries to take %d after %.02fs, takes  \n                %d\", c.name, n, e, a)\n        }\n    }\n}\n```", "```go\nfunc main() {\n    ctx, canc := context.WithTimeout(context.Background(), time.Second)\n    defer canc()\n    start := time.Now()\n    b := newBucket(ctx, 10, time.Second/5)\n    t := time.Second / 10\n    for i := 0; i < 5; i++ {\n        c := client{\n            name: fmt.Sprint(i),\n            b: b,\n            sleep: t,\n            max: 5,\n        }\n        go c.Run(ctx, start)\n    }\n    <-ctx.Done()\n}\n```", "```go\ntype msg struct {\n    value string\n    done chan struct{}\n}\n\nfunc (m *msg) Wait() {\n    <-m.done\n}\n\nfunc (m *msg) Done() {\n    m.done <- struct{}{}\n}\n```", "```go\nfunc send(ctx context.Context, v string) <-chan msg {\n    ch := make(chan msg)\n    go func() {\n        done := make(chan struct{})\n        for i := 0; ; i++ {\n            time.Sleep(time.Duration(float64(time.Second/2) * rand.Float64()))\n            m := msg{fmt.Sprintf(\"%s msg-%d\", v, i), done}\n            select {\n            case <-ctx.Done():\n                close(ch)\n                return\n            case ch <- m:\n                m.Wait()\n            }\n        }\n    }()\n    return ch\n}\n```", "```go\n\nfunc merge(ctx context.Context, sources ...<-chan msg) <-chan msg {\n    ch := make(chan msg)\n    go func() {\n        <-ctx.Done()\n        close(ch)\n    }()\n    for i := range sources {\n        go func(i int) {\n            for {\n                select {\n                case v := <-sources[i]:\n                    select {\n                    case <-ctx.Done():\n                        return\n                    case ch <- v:\n                    }\n                }\n            }\n        }(i)\n    }\n    return ch\n}\n```", "```go\nfunc main() {\n    ctx, canc := context.WithTimeout(context.Background(), time.Second)\n    defer canc()\n    sources := make([]<-chan msg, 5)\n    for i := range sources {\n        sources[i] = send(ctx, fmt.Sprint(\"src-\", i))\n    }\n    msgs := make([]msg, 0, len(sources))\n    start := time.Now()\n    for v := range merge(ctx, sources...) {\n        msgs = append(msgs, v)\n        log.Println(v.value, time.Since(start))\n        if len(msgs) == len(sources) {\n            log.Println(\"*** done ***\")\n            for _, m := range msgs {\n                m.Done()\n            }\n            msgs = msgs[:0]\n            start = time.Now()\n        }\n    }\n}\n```"]