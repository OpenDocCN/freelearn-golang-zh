["```go\n# unsafe assertion\nv := SomeVar.(SomeType)\n\n# safe assertion\nv, ok := SomeVar.(SomeType)\n```", "```go\nfunc main() {\n    var a interface{} = \"hello\"\n    fmt.Println(a.(string)) // ok\n    fmt.Println(a.(int))    // panics!\n}\n```", "```go\nfunc main() {\n    var a interface{} = \"hello\"\n    s, ok := a.(string) // true\n    fmt.Println(s, ok)\n    i, ok := a.(int) // false\n    fmt.Println(i, ok)\n}\n```", "```go\ntype Fooer interface {\n    Foo()\n}\n\ntype Barer interface {\n    Bar()\n}\n```", "```go\ntype A int\n\nfunc (A) Foo() {}\n\ntype B int\n\nfunc (B) Bar() {}\nfunc (B) Foo() {}\n```", "```go\nfunc main() {\n    var a Fooer \n\n    a = A(0)\n    v, ok := a.(Barer)\n    fmt.Println(v, ok)\n\n    a = B(0) \n    v, ok = a.(Barer)\n    fmt.Println(v, ok)\n}\n```", "```go\nfunc Closer(r io.Reader) io.ReadCloser {\n    if rc, ok := r.(io.ReadCloser); ok {\n        return rc\n    }\n    return ioutil.NopCloser(r)\n}\n\nfunc main() {\n    log.Printf(\"%T\", Closer(&bytes.Buffer{}))\n    log.Printf(\"%T\", Closer(&os.File{}))\n}\n```", "```go\nfunc main() {\n    var a interface{} = int64(23)\n    fmt.Println(reflect.TypeOf(a).String())\n    // int64\n    fmt.Println(reflect.ValueOf(a).String())\n    // <int64 Value>\n    fmt.Println(reflect.ValueOf(a).Type().String())\n    // int64\n}\n```", "```go\nfunc main() {\n    var a interface{}\n\n    a = \"\" // built in string\n    t := reflect.TypeOf(a)\n    fmt.Println(t.String(), t.Kind())\n\n    type A string // custom type\n    a = A(\"\")\n    t = reflect.TypeOf(a)\n    fmt.Println(t.String(), t.Kind())\n}\n```", "```go\nfunc main() {\n    var a interface{}\n\n    a = new(int) // int pointer\n    t := reflect.TypeOf(a)\n    fmt.Println(t.String(), t.Kind())\n\n    a = new(struct{}) // struct pointer\n    t = reflect.TypeOf(a)\n    fmt.Println(t.String(), t.Kind())\n}\n```", "```go\nfunc main() {\n    var a interface{} = int(12)\n    v := reflect.ValueOf(a)\n    fmt.Println(v.String())\n    fmt.Printf(\"%v\", v.Interface())\n}\n```", "```go\nfunc main() {\n    var a = int64(12)\n    v := reflect.ValueOf(a)\n    fmt.Println(v.String(), v.CanSet())\n    v.SetInt(24)\n}\n```", "```go\nfunc main() {\n    var a = int64(12)\n    v := reflect.ValueOf(&a)\n    fmt.Println(v.String(), v.CanSet())\n    e := v.Elem()\n    fmt.Println(e.String(), e.CanSet())\n    e.SetInt(24)\n    fmt.Println(a)\n}\n```", "```go\nfunc main() {\n    t := reflect.TypeOf(int64(100))\n    // zero value\n    fmt.Printf(\"%#v\\n\", reflect.Zero(t))\n    // pointer to int\n    fmt.Printf(\"%#v\\n\", reflect.New(t))\n}\n```", "```go\nfunc main() {\n    type X struct {\n        A, B int\n        c string\n    }\n    var a = X{10, 100, \"apple\"}\n    fmt.Println(a)\n    e := reflect.ValueOf(&a).Elem()\n    fmt.Println(e.String(), e.CanSet())\n    e.Set(reflect.ValueOf(X{1, 2, \"banana\"}))\n    fmt.Println(a)\n}\n```", "```go\ntype A struct {\n    B\n    x int\n    Y int\n    Z int\n}\n\ntype B struct {\n    F string\n    G string\n}\n```", "```go\nfunc main() {\n    var a A\n    v := reflect.ValueOf(&a)\n    func() {\n        // trying to get fields from ptr panics\n        defer func() {\n            log.Println(\"panic:\", recover())\n        }()\n        log.Printf(\"%s\", v.Field(1).String())\n    }()\n    v = v.Elem()\n    // changing fields by index\n    for i := 0; i < 4; i++ {\n        f := v.Field(i)\n        if f.CanSet() && f.Type().Kind() == reflect.Int {\n            f.SetInt(42)\n        }\n    }\n    // changing nested fields by index\n    v.FieldByIndex([]int{0, 1}).SetString(\"banana\")\n\n    // getting fields by name\n    v.FieldByName(\"B\").FieldByName(\"F\").SetString(\"apple\")\n\n    log.Printf(\"%+v\", a)\n}\n```", "```go\ntype StructField struct {\n    Name string\n    PkgPath string\n\n    Type Type      // field type\n    Tag StructTag  // field tag string\n    Offset uintptr // offset within struct, in bytes\n    Index []int    // index sequence for Type.FieldByIndex\n    Anonymous bool // is an embedded field\n}\n```", "```go\ntype Person struct {\n    Name string `json:\"name,omitempty\" xml:\"-\"`\n    Surname string `json:\"surname,omitempty\" xml:\"-\"`\n}\n\nfunc main() {\n    v := reflect.ValueOf(Person{\"Micheal\", \"Scott\"})\n    t := v.Type()\n    fmt.Println(\"Type:\", t)\n    for i := 0; i < t.NumField(); i++ {\n       fmt.Printf(\"%v: %v\\n\", t.Field(i).Name, v.Field(i))\n    }\n}\n```", "```go\ntype A struct {\n    Name    string `json:\"name,omitempty\" xml:\"-\"`\n    Surname string `json:\"surname,omitempty\" xml:\"-\"`\n}\n```", "```go\nfunc main() {\n    t := reflect.TypeOf(A{})\n    fmt.Println(t)\n    for i := 0; i < t.NumField(); i++ {\n        f := t.Field(i)\n        fmt.Printf(\"%s JSON=%s XML=%s\\n\", f.Name, f.Tag.Get(\"json\"), f.Tag.Get(\"xml\"))\n    }\n}\n```", "```go\nfunc main() {\n    maps := []interface{}{\n        make(map[string]struct{}),\n        make(map[int]rune),\n        make(map[float64][]byte),\n        make(map[int32]chan bool),\n        make(map[[2]string]interface{}),\n    }\n    for _, m := range maps {\n        t := reflect.TypeOf(m)\n        fmt.Printf(\"%s k:%-10s v:%-10s\\n\", m, t.Key(), t.Elem())\n    }\n}\n```", "```go\nfunc main() {\n    m := map[string]int64{\n        \"a\": 10,\n        \"b\": 20,\n        \"c\": 100,\n        \"d\": 42,\n    }\n\n    v := reflect.ValueOf(m)\n\n    // access one field\n    fmt.Println(\"a\", v.MapIndex(reflect.ValueOf(\"a\")))\n    fmt.Println()\n\n    // range keys\n    for _, k := range v.MapKeys() {\n        fmt.Println(k, v.MapIndex(k))\n    }\n    fmt.Println()\n\n    // range keys and values\n    i := v.MapRange()\n    for i.Next() {\n        fmt.Println(i.Key(), i.Value())\n    }\n}\n```", "```go\nfunc main() {\n    m := map[string]int64{}\n    v := reflect.ValueOf(m)\n\n    // setting one field\n    v.SetMapIndex(reflect.ValueOf(\"key\"), reflect.ValueOf(int64(1000)))\n\n    fmt.Println(m)\n}\n```", "```go\nfunc main() {\n    m := map[string]int64{\"a\": 10}\n    fmt.Println(m, len(m))\n\n    v := reflect.ValueOf(m)\n\n    // deleting field\n    v.SetMapIndex(reflect.ValueOf(\"a\"), reflect.Value{})\n\n    fmt.Println(m, len(m))\n}\n```", "```go\nfunc main() {\n    m := []int{10, 20, 100}\n    v := reflect.ValueOf(m)\n\n    for i := 0; i < v.Len(); i++ {\n        fmt.Println(i, v.Index(i))\n    }\n}\n```", "```go\nfunc main() {\n    m := []int64{10, 20, 100}\n    v := reflect.ValueOf(m)\n\n    for i := 0; i < v.Len(); i++ {\n        v.Index(i).SetInt(v.Index(i).Interface().(int64) * 2)\n    }\n    fmt.Println(m)\n}\n```", "```go\nfunc main() {\n    var s = []int{1, 2}\n    fmt.Println(s)\n\n    v := reflect.ValueOf(s)\n    // same as append(s, 3)\n    v2 := reflect.Append(v, reflect.ValueOf(3))\n    // s can't and does not change\n    fmt.Println(v.CanSet(), v, v2)\n\n    // using the pointer allows change\n    v = reflect.ValueOf(&s).Elem()\n    v.Set(v2)\n    fmt.Println(v.CanSet(), v, v2)\n}\n```", "```go\nfunc Foo() {}\n\nfunc Bar(a int, b string) {}\n\nfunc Baz(a int, b string) (int, error) { return 0, nil }\n\nfunc Qux(a int, b ...string) (int, error) { return 0, nil }\n```", "```go\nfunc main() {\n    for _, f := range []interface{}{Foo, Bar, Baz, Qux} {\n        t := reflect.TypeOf(f)\n        name := runtime.FuncForPC(reflect.ValueOf(f).Pointer()).Name()\n        in := make([]reflect.Type, t.NumIn())\n        for i := range in {\n            in[i] = t.In(i)\n        }\n        out := make([]reflect.Type, t.NumOut())\n        for i := range out {\n            out[i] = t.Out(i)\n        }\n        fmt.Printf(\"%q %v %v %v\\n\", name, in, out, t.IsVariadic())\n    }\n}\n```", "```go\nfunc main() {\n    for _, f := range []interface{}{Foo, Bar, Baz, Qux} {\n        v, t := reflect.ValueOf(f), reflect.TypeOf(f)\n        name := runtime.FuncForPC(v.Pointer()).Name()\n        in := make([]reflect.Value, t.NumIn())\n        for i := range in {\n            switch a := t.In(i); a.Kind() {\n            case reflect.Int:\n                in[i] = reflect.ValueOf(42)\n            case reflect.String:\n                in[i] = reflect.ValueOf(\"42\")\n            case reflect.Slice:\n                switch a.Elem().Kind() {\n                case reflect.Int:\n                    in[i] = reflect.ValueOf(21)\n                case reflect.String:\n                    in[i] = reflect.ValueOf(\"21\")\n                }\n            }\n        }\n        out := v.Call(in)\n        fmt.Printf(\"%q %v%v\\n\", name, in, out)\n    }\n}\n```", "```go\nfunc main() {\n    t := reflect.ChanOf(reflect.BothDir, reflect.TypeOf(\"\"))\n    v := reflect.MakeChan(t, 0)\n    fmt.Printf(\"%T\\n\", v.Interface())\n}\n```", "```go\nfunc main() {\n    t := reflect.ChanOf(reflect.BothDir, reflect.TypeOf(\"\"))\n    v := reflect.MakeChan(t, 0)\n    go func() {\n        for i := 0; i < 10; i++ {\n            v.Send(reflect.ValueOf(fmt.Sprintf(\"msg-%d\", i)))\n        }\n        v.Close()\n    }()\n    for msg, ok := v.Recv(); ok; msg, ok = v.Recv() {\n        fmt.Println(msg)\n    }\n}\n```", "```go\ntype SelectCase struct {\n    Dir  SelectDir // direction of case\n    Chan Value     // channel to use (for send or receive)\n    Send Value     // value to send (for send)\n}\n```", "```go\nfunc main() {\n    v := reflect.ValueOf(make(chan string, 1))\n    fmt.Println(\"sending\", v.TrySend(reflect.ValueOf(\"message\"))) // true 1 1\n    branches := []reflect.SelectCase{\n        {Dir: reflect.SelectRecv, Chan: v, Send: reflect.Value{}},\n        {Dir: reflect.SelectSend, Chan: v, Send: reflect.ValueOf(\"send\")},\n        {Dir: reflect.SelectDefault},\n    }\n\n    // send, receive and default\n    i, recv, closed := reflect.Select(branches)\n    fmt.Println(\"select\", i, recv, closed)\n\n    v.Close()\n    // just default and receive\n    i, _, closed = reflect.Select(branches[:2])\n    fmt.Println(\"select\", i, closed) // 1 false\n}\n```", "```go\nfunc baseTest(fn1, fn2 func(int)) {\n    ctx, canc := context.WithTimeout(context.Background(), time.Second)\n    defer canc()\n    go func() {\n        for i := 0; ; i++ {\n            select {\n            case <-ctx.Done():\n                return\n            default:\n                fn1(i)\n            }\n        }\n    }()\n    go func() {\n        for i := 0; ; i++ {\n            select {\n            case <-ctx.Done():\n                return\n            default:\n                fn2(i)\n            }\n        }\n    }()\n    <-ctx.Done()\n}\n```", "```go\nfunc testMap() {\n    m1, m2 := make(map[int]int), make(map[int]int)\n    m := reflect.ValueOf(m2)\n    baseTest(func(i int) { m1[i] = i }, func(i int) {\n        v := reflect.ValueOf(i)\n        m.SetMapIndex(v, v)\n    })\n    fmt.Printf(\"normal %d\\n\", len(m1))\n    fmt.Printf(\"reflect %d\\n\", len(m2))\n}\n```", "```go\nfunc testStruct() {\n    type T struct {\n        Field int\n    }\n    var m1, m2 T\n    m := reflect.ValueOf(&m2).Elem()\n    baseTest(func(i int) { m1.Field++ }, func(i int) {\n        f := m.Field(0)\n        f.SetInt(int64(f.Interface().(int) + 1))\n    })\n    fmt.Printf(\"normal %d\\n\", m1.Field)\n    fmt.Printf(\"reflect %d\\n\", m2.Field)\n}\n```", "```go\ntype Marshaler interface {\n    MarshalJSON() ([]byte, error)\n}\n\ntype Unmarshaler interface {\n    UnmarshalJSON([]byte) error\n}\n```", "```go\ntype Unmarshaller interface {\n    UnmarshalProp([]byte) error\n}\n```", "```go\ntype Decoder struct {\n    scanner *bufio.Scanner\n}\n\nfunc NewDecoder(r io.Reader) *Decoder {\n    return &Decoder{scanner: bufio.NewScanner(r)}\n}\n```", "```go\nfunc Unmarshal(data []byte, v interface{}) error {\n    return NewDecoder(bytes.NewReader(data)).Decode(v)\n}\n```", "```go\nvar cache = make(map[reflect.Type]map[string]int)\n\nfunc findIndex(t reflect.Type, k string) (int, bool) {\n    if v, ok := cache[t]; ok {\n        n, ok := v[k]\n        return n, ok\n    }\n    m := make(map[string]int)\n    for i := 0; i < t.NumField(); i++ {\n        f := t.Field(i)\n        if s := f.Name[:1]; strings.ToLower(s) == s {\n            continue\n        }\n        name := strings.ToLower(f.Name)\n        if tag := f.Tag.Get(\"prop\"); tag != \"\" {\n            name = tag\n        }\n        m[name] = i\n    }\n    cache[t] = m\n    return findIndex(t, k)\n}\n```", "```go\nfunc (d *Decoder) Decode(v interface{}) error {\n    val := reflect.ValueOf(v)\n    t := val.Type()\n    if t.Kind() != reflect.Ptr && t.Elem().Kind() != reflect.Struct {\n        return fmt.Errorf(\"%v not a struct pointer\", t)\n    }\n    val = val.Elem()\n    t = t.Elem()\n    line := 0\n    for d.scanner.Scan() {\n        line++\n        b := d.scanner.Bytes()\n        if len(b) == 0 || b[0] == '#' {\n            continue\n        }\n        parts := bytes.SplitN(b, []byte{':'}, 2)\n        if len(parts) != 2 {\n            return decodeError{line: line, err: errNoSep}\n        }\n        index, ok := findIndex(t, string(parts[0]))\n        if !ok {\n            continue\n        }\n        value := bytes.TrimSpace(parts[1])\n        if err := d.decodeValue(val.Field(index), value); err != nil {\n            return decodeError{line: line, err: err}\n        }\n    }\n    return d.scanner.Err()\n}\n```", "```go\nfunc (d *Decoder) decodeValue(v reflect.Value, value []byte) error {\n    if v, ok := v.Addr().Interface().(Unmarshaller); ok {\n        return v.UnmarshalProp(value)\n    }\n    switch valStr := string(value); v.Type().Kind() {\n    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n        i, err := strconv.ParseInt(valStr, 10, 64)\n        if err != nil {\n            return err\n        }\n        v.SetInt(i)\n    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n        i, err := strconv.ParseUint(valStr, 10, 64)\n        if err != nil {\n            return err\n        }\n        v.SetUint(i)\n    case reflect.Float32, reflect.Float64:\n        i, err := strconv.ParseFloat(valStr, 64)\n        if err != nil {\n            return err\n        }\n        v.SetFloat(i)\n    case reflect.String:\n        v.SetString(valStr)\n    case reflect.Bool:\n        switch value := valStr; value {\n        case \"true\":\n            v.SetBool(true)\n        case \"false\":\n            v.SetBool(false)\n        default:\n            return fmt.Errorf(\"invalid bool: %s\", value)\n        }\n    default:\n        return fmt.Errorf(\"invalid type: %s\", v.Type())\n    }\n    return nil\n}\n```", "```go\ntype UpperString string\n\nfunc (u *UpperString) UnmarshalProp(b []byte) error {\n        *u = UpperString(strings.ToUpper(string(b)))\n        return nil\n}\n```", "```go\nfunc main() {\n        r := strings.NewReader(\n                \"\\n# comment, ignore\\nkey1: 10.5\\nkey2: some string\" +\n                        \"\\nkey3: 42\\nkey4: false\\nspecial: another string\\n\")\n        var v struct {\n                Key1 float32\n                Key2 string\n                Key3 uint64\n                Key4 bool\n                Key5 UpperString `prop:\"special\"`\n                key6 int\n        }\n        if err := prop.NewDecoder(r).Decode(&v); err != nil {\n                log.Fatal(r)\n        }\n        log.Printf(\"%+v\", v)\n}\n```"]