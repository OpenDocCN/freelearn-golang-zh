- en: Using Reflection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反射
- en: This chapter is about **reflection**, a tool that allows an application to inspect
    its own code, overcoming some of the limitations imposed by Go static typing and
    its lack of generics. This can be very helpful, for instance, for producing packages
    that are capable of handling any type of input that they receive.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于**反射**，这是一种工具，允许应用程序检查自己的代码，克服Go静态类型和泛型缺乏所施加的一些限制。例如，这对于生成能够处理其接收到的任何类型输入的包可能非常有帮助。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding interfaces and type assertions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解接口和类型断言
- en: Learning about interaction with basic types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解与基本类型的交互
- en: Using reflection with complex types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复杂类型进行反射
- en: Evaluating the cost of reflection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估反射的成本
- en: Learning the best practices of reflection usage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习反射使用的最佳实践
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml), *An
    Overview of Go*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装Go并设置您喜欢的编辑器。有关更多信息，请参阅[第3章](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml)，*Go概述*。
- en: What's reflection?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是反射？
- en: Reflection is a very powerful feature that allows **meta-programming**, the
    capability of an application to examine its own structure. It's very useful to
    analyze the types in an application at runtime, and it is used in many encoding
    packages such as JSON and XML.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是一种非常强大的功能，允许**元编程**，即应用程序检查自身结构的能力。它非常有用，可以在运行时分析应用程序中的类型，并且在许多编码包中使用，例如JSON和XML。
- en: Type assertions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型断言
- en: 'We briefly mentioned how type assertions work in [Chapter 3](https://cdp.packtpub.com/hands_on_systems_programming_with_go/wp-admin/post.php?post=38&action=edit#post_26),* An
    Overview of Go*. A type assertion is an operation that allows us to go from interface
    to concrete type and vice versa. It takes the following form:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](https://cdp.packtpub.com/hands_on_systems_programming_with_go/wp-admin/post.php?post=38&action=edit#post_26)，*Go概述*中简要提到了类型断言的工作原理。类型断言是一种操作，允许我们从接口到具体类型以及反之进行转换。它采用以下形式：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first version is unsafe, and it assigns a value to a single variable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个版本是不安全的，它将一个值分配给一个变量。
- en: 'Using assertion as an argument of a function also counts as unsafe. This type
    of operation panics if the assertion is wrong:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将断言用作函数的参数也被视为不安全。如果断言错误，此类操作将引发**panic**：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A full example is available here: [https://play.golang.org/p/hNN87SuprGR](https://play.golang.org/p/hNN87SuprGR).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在此处找到：[https://play.golang.org/p/hNN87SuprGR](https://play.golang.org/p/hNN87SuprGR)。
- en: 'The second version uses a Boolean a as second value, and it will show the success
    of the operation. If the assertion is not possible, the first value will always
    be a zero value for the asserted type:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本使用布尔值作为第二个值，并且它将显示操作的成功。如果断言不可能，第一个值将始终是断言类型的零值：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A full example is available here: [https://play.golang.org/p/BIba2ywkNF_j](https://play.golang.org/p/BIba2ywkNF_j).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在此处找到：[https://play.golang.org/p/BIba2ywkNF_j](https://play.golang.org/p/BIba2ywkNF_j)。
- en: Interface assertion
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口断言
- en: 'Assertion can also be done from one interface to another. Imagine having two
    different interfaces:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 断言也可以从一个接口到另一个接口进行。想象一下有两个不同的接口：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s define a type that implements one of them and another that implements
    both:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个实现其中一个的类型，另一个实现两者的类型：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we define a new variable for the first interface, the assertion to the second
    is going to be successful only if the underlying value has a type that implements
    both; otherwise, it''s going to fail:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为第一个接口定义一个新变量，只有在底层值具有实现两者的类型时，对第二个的断言才会成功；否则，它将失败：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A full example is available here: [https://play.golang.org/p/bX2rnw5pRXJ](https://play.golang.org/p/bX2rnw5pRXJ).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在此处找到：[https://play.golang.org/p/bX2rnw5pRXJ](https://play.golang.org/p/bX2rnw5pRXJ)。
- en: 'A use case scenario could be having the `io.Reader` interface, checking out
    whether it is also an `io.Closer` interface, and wrapping it in the `ioutil.NopCloser`
    function (which returns an `io.ReadCloser` interface) if not:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用场景可能是拥有`io.Reader`接口，检查它是否也是`io.Closer`接口，并在需要时使用`ioutil.NopCloser`函数（返回`io.ReadCloser`接口）进行包装：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A full example is available here: [https://play.golang.org/p/hUEsDYHFE7i](https://play.golang.org/p/hUEsDYHFE7i).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在此处找到：[https://play.golang.org/p/hUEsDYHFE7i](https://play.golang.org/p/hUEsDYHFE7i)。
- en: There is an important aspect to interfaces that we need to underline before
    jumping onto reflection—its representation is always a tuple interface-value where
    the value is a concrete type and cannot be another interface.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳转到反射之前，接口有一个重要的方面需要强调——它的表示始终是一个元组接口值，其中值是一个具体类型，不能是另一个接口。
- en: Understanding basic mechanics
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本机制
- en: 'The `reflection` package allows you to extract the type and value from any `interface{}` variable.
    This can be done using the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflection`包允许您从任何`interface{}`变量中提取类型和值。可以使用以下方法完成：'
- en: Using `reflection.TypeOf` returns the type of the interface in a `reflection.Type ` variable.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`reflection.TypeOf`返回接口的类型到`reflection.Type`变量。
- en: The `reflection.ValueOf` function returns the value of the interface using the `reflection.Value` variable.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflection.ValueOf`函数使用`reflection.Value`变量返回接口的值。'
- en: Value and Type methods
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值和类型方法
- en: 'A `reflect.Value` type also carries information of the type that can be retrieved
    with the `Type` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect.Value`类型还携带可以使用`Type`方法检索的类型信息：'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A full example is available here: [https://play.golang.org/p/tmYuMc4AF1T](https://play.golang.org/p/tmYuMc4AF1T).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在此处找到：[https://play.golang.org/p/tmYuMc4AF1T](https://play.golang.org/p/tmYuMc4AF1T)。
- en: Kind
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 种类
- en: Another important property of `reflect.Type` is `Kind`, which is an enumeration
    of basic types and generic complex types. The main relationship between `reflect.Kind`
    and `reflect.Type` is that the first represents the memory representation of the
    second.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect.Type`的另一个重要属性是`Kind`，它是基本类型和通用复杂类型的枚举。`reflect.Kind`和`reflect.Type`之间的主要关系是，前者表示后者的内存表示。'
- en: 'For built-in types, `Kind` and `Type` are the same, but for custom types they
    will differ—the `Type` value will be what is expected, but the `Kind` value will
    be one of the built-in ones on which the custom type is defined:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内置类型，`Kind`和`Type`是相同的，但对于自定义类型，它们将不同 - `Type`值将是预期的值，但`Kind`值将是自定义类型定义的内置类型之一：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A full example is available here: [https://play.golang.org/p/qjiouk88INn](https://play.golang.org/p/qjiouk88INn).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在此处可用：[https://play.golang.org/p/qjiouk88INn](https://play.golang.org/p/qjiouk88INn)。
- en: 'For the composite type, it will reflect just the main type and not the underlying
    ones. This means that a pointer to a structure or to an integer is the same kind,
    `reflect.Pointer`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复合类型，它将反映出主要类型而不是底层类型。这意味着指向结构或整数的指针是相同类型，`reflect.Pointer`：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A full example is available here: [https://play.golang.org/p/-uJjZvTuzVf](https://play.golang.org/p/-uJjZvTuzVf).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在此处可用：[https://play.golang.org/p/-uJjZvTuzVf](https://play.golang.org/p/-uJjZvTuzVf)。
- en: The same reasoning applies to all the other composite types, such as arrays,
    slices, maps, and channels.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的推理适用于所有其他复合类型，例如数组，切片，映射和通道。
- en: Value to interface
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值到接口
- en: 'In the same way that we can get `reflect.Value` from any `interface{}` value, 
    we can execute the reverse operation and obtain `interface{}`from `reflect.Value`.
    This is done using the `Interface` method of the reflected value, and be cast
    to a concrete type if necessary. If the interested method or function accepts
    an empty interface, such as `json.Marshal` or `fmt.Println`, the returned value
    can be passed directly without any casting:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以从任何`interface{}`值获取`reflect.Value`一样，我们也可以执行相反的操作，并从`reflect.Value`获取`interface{}`。这是使用反射值的`Interface`方法完成的，并且如果需要，可以转换为具体类型。如果感兴趣的方法或函数接受空接口，例如`json.Marshal`或`fmt.Println`，则返回的值可以直接传递，而无需任何转换：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A full example is available here: [https://play.golang.org/p/1942Dhm5sap](https://play.golang.org/p/1942Dhm5sap).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在此处可用：[https://play.golang.org/p/1942Dhm5sap](https://play.golang.org/p/1942Dhm5sap)。
- en: Manipulating values
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操纵值
- en: Transforming values in their reflection and going back to the value is not very
    useful if the values themselves cannot be changed. That's why our next step is seeing
    how to change them using the `reflection` package.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将值转换为其反射形式，然后再转回值，如果值本身无法更改，这是没有什么用的。这就是为什么我们的下一步是看看如何使用`reflection`包来更改它们。
- en: Changing values
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改值
- en: 'There is a series of methods of the `reflect.Value` type that allow you to
    change the underlying value:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect.Value`类型有一系列方法，允许您更改底层值：'
- en: '`Set`: Uses another `reflect.Value`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set`: 使用另一个`reflect.Value`'
- en: '`SetBool`: Boolean'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetBool`: 布尔值'
- en: '`SetBytes`: Byte slice'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetBytes`: 字节切片'
- en: '`SetComplex`: Any complex type'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetComplex`: 任何复杂类型'
- en: '`SetFloat`: Any float type'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetFloat`: 任何浮点类型'
- en: '`SetInt`: Any signed integer type'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetInt`: 任何有符号整数类型'
- en: '`SetPointer`: A pointer'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetPointer`: 指针'
- en: '`SetString`: A string'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetString`: 字符串'
- en: '`SetUint`: Any unsigned integer'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetUint`: 任何无符号整数'
- en: 'In order to set a value, it needs to editable, and this happens in specific
    conditions. To verify this, there is a method, `CanSet`, which returns `true`
    if a value can be changed. If the value cannot be changed and a `Set` method is
    called anyway, the application will panic:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置一个值，它需要是可编辑的，这发生在特定条件下。为了验证这一点，有一个方法`CanSet`，如果一个值可以被更改，则返回`true`。如果值无法更改，但仍然调用了`Set`方法，应用程序将会引发恐慌：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A full example is available here: [https://play.golang.org/p/hKn8qNtn0gN](https://play.golang.org/p/hKn8qNtn0gN).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在此处可用：[https://play.golang.org/p/hKn8qNtn0gN](https://play.golang.org/p/hKn8qNtn0gN)。
- en: In order to be changed, a value needs to be addressable. A value is addressable
    if it's possible to modify the actual storage where the object is saved. When
    creating a new value using a basic built-in type, such as `string` , what gets
    passed to the function is `interface{}` , which hosts a copy of the string.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行更改，值需要是可寻址的。如果可以修改对象保存的实际存储位置，则值是可寻址的。当使用基本内置类型（例如`string`）创建新值时，传递给函数的是`interface{}`，它包含字符串的副本。
- en: Changing this copy would result in a variation of the copy with no effect on
    the original variable. This would be incredibly confusing, and it would make the
    usage of a sensible tool such as reflection, even harder. That's why, instead
    of this useless behavior, the `reflect` package panics—it's a design choice. This
    explains why the last example panicked.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 更改此副本将导致副本的变化，而不会影响原始变量。这将非常令人困惑，并且会使反射等实用工具的使用变得更加困难。这就是为什么，`reflect`包会引发恐慌
    - 这是一个设计选择。这就解释了为什么最后一个示例会引发恐慌。
- en: 'We can create `reflect.Value` using the pointer to the value we want to change,
    and access the value using the `Elem` method. This will give us a value that is
    addressable because we copied the pointer instead of the value, so the reflected
    value is still a pointer to the variable:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用要更改的值的指针创建`reflect.Value`，并使用`Elem`方法访问该值。这将给我们一个可寻址的值，因为我们复制了指针而不是值，所以反射的值仍然是变量的指针：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A full example is available here: [https://play.golang.org/p/-X5JsBrlr4Q](https://play.golang.org/p/-X5JsBrlr4Q).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在此处可用：[https://play.golang.org/p/-X5JsBrlr4Q](https://play.golang.org/p/-X5JsBrlr4Q)。
- en: Creating new values
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新值
- en: 'The `reflect` package allows us also to create new values using types. There
    are several functions that allow us to create a value:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect`包还允许我们使用类型创建新值。有几个函数允许我们创建一个值：'
- en: '`MakeChan` creates a new channel value'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeChan`创建一个新的通道值'
- en: '`MakeFunc` creates a new function value'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeFunc`创建一个新的函数值'
- en: '`MakeMap` and `MakeMapWithSize` creates a new map value'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeMap`和`MakeMapWithSize`创建一个新的映射值'
- en: '`MakeSlice` creates a new slice value'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeSlice`创建一个新的切片值'
- en: '`New` creates a new pointer to the type'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New`创建一个指向该类型的新指针'
- en: '`NewAt` creates a new pointer to the type using the selected address'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewAt` 使用所选地址创建类型的新指针'
- en: '`Zero` creates a zero value of the selected type'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zero` 创建所选类型的零值'
- en: 'The following code shows how to create new values in a couple of different
    ways:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何以几种不同的方式创建新值：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A full example is available here: [https://play.golang.org/p/wCTILSK1F1C](https://play.golang.org/p/wCTILSK1F1C).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例在这里：[https://play.golang.org/p/wCTILSK1F1C](https://play.golang.org/p/wCTILSK1F1C)。
- en: Handling complex types
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理复杂类型
- en: After seeing how to handle the reflection basics, we will now see how complex
    data types such as structures and maps can also be handled using reflection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何处理反射基础知识之后，我们现在将看到如何使用反射处理结构和地图等复杂数据类型。
- en: Data structures
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: For changeability, structures work in exactly the same way as the basic types;
    we need to obtain the reflection of the pointer, then access its element in order
    to be able to change the value, because using the structure directly would produce
    a copy of it and it would panic when changing values.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可更改性，结构与基本类型的工作方式完全相同； 我们需要获取指针的反射，然后访问其元素以能够更改值，因为直接使用结构会产生其副本，并且在更改值时会出现恐慌。
- en: 'We can replace the value of the entire structure using the `Set` method, after
    obtaining the new value''s reflection:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Set` 方法替换整个结构的值，然后获取新值的反射：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A full example is available here: [https://play.golang.org/p/mjb3gJw5CeA](https://play.golang.org/p/mjb3gJw5CeA).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例在这里：[https://play.golang.org/p/mjb3gJw5CeA](https://play.golang.org/p/mjb3gJw5CeA)。
- en: Changing fields
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改字段
- en: 'Individual fields can also be modified using `Field` methods:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 `Field` 方法修改单个字段：
- en: '`Field` returns a field using its index'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Field` 使用其索引返回一个字段'
- en: '`FieldByIndex` returns a nested field using a series of indexes'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FieldByIndex` 使用一系列索引返回嵌套字段'
- en: '`FieldByName` returns a field using its name'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FieldByName` 使用其名称返回一个字段'
- en: '`FieldByNameFunc` returns a field using  `func(string) bool` in the name'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FieldByNameFunc` 使用 `func(string) bool` 返回一个字段'
- en: 'Let''s define a structure to change the values of the fields, using both simple
    and complex types, with at least one unexported field:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个结构来更改字段的值，使用简单和复杂类型，至少有一个未导出的字段：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have the structure, we can try to access the fields in different
    ways:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了结构，我们可以尝试以不同的方式访问字段：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A full example is available here: [https://play.golang.org/p/z5slFkIU5UE](https://play.golang.org/p/z5slFkIU5UE).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例在这里：[https://play.golang.org/p/z5slFkIU5UE](https://play.golang.org/p/z5slFkIU5UE)。
- en: When working with `reflect.Value` and structure fields, what you get are other
    values, indistinguishable from the struct. When handling `reflect.Type` instead,
    you obtain a `reflect.StructField` structure, which is another type that carries
    all the information of the field with it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 `reflect.Value` 和结构字段时，您得到的是其他值，无法与结构区分。 相反，当处理 `reflect.Type` 时，您获得一个 `reflect.StructField`
    结构，它是另一种携带字段所有信息的类型。
- en: Using tags
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签
- en: 'A structure field carries plenty of information, from the field name and index
    to its tag:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 结构字段携带大量信息，从字段名称和索引到其标记：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A `reflect.StructField` value can be obtained using the `reflect.``Type` methods:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `reflect.Type` 方法获取 `reflect.StructField` 值：
- en: '`Field`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Field`'
- en: '`FieldByName`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FieldByName`'
- en: '`FieldByIndex`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FieldByIndex`'
- en: 'They are the same methods used by `reflect.Value`, but they return different
    types. The `NumField` method returns the total number of fields for the structure,
    allowing us to execute an iteration:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是由 `reflect.Value` 使用的相同方法，但它们返回不同的类型。 `NumField` 方法返回结构的字段总数，允许我们执行迭代：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A full example is available here: [https://play.golang.org/p/nkEADg77zFC](https://play.golang.org/p/nkEADg77zFC).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例在这里：[https://play.golang.org/p/nkEADg77zFC](https://play.golang.org/p/nkEADg77zFC)。
- en: 'Tags are really central to reflection because they can store extra information
    about a field and how other packages behave with it. To add a tag to a field,
    it needs to be inserted after the field name and type in a string, which should
    have a `key:"value"` structure. One field can have multiple tuples in its tag,
    and each pair is separated by a space. Let''s look at a practical example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 标签对于反射非常重要，因为它们可以存储有关字段的额外信息以及其他包如何与其交互的信息。 要向字段添加标签，需要在字段名称和类型之后插入一个字符串，该字符串应具有
    `key:"value"` 结构。 一个字段可以在其标记中有多个元组，并且每对由空格分隔。 让我们看一个实际的例子：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This structure has two fields, both with tags, and each tag has two pairs.
    The `Get` method returns the value for a specific key:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构有两个字段，都带有标签，每个标签都有两对。 `Get` 方法返回特定键的值：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A full example is available here: [https://play.golang.org/p/P-Te8O1Hyyn](https://play.golang.org/p/P-Te8O1Hyyn).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例在这里：[https://play.golang.org/p/P-Te8O1Hyyn](https://play.golang.org/p/P-Te8O1Hyyn)。
- en: Maps and slices
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图和切片
- en: You can easily use reflection to read and manipulate maps and slices. Since
    they are such important tools for writing applications, let's see how to execute
    an operation using reflection.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松使用反射来读取和操作地图和切片。 由于它们是编写应用程序的重要工具，让我们看看如何使用反射执行操作。
- en: Maps
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图
- en: 'A `map` type allows you to get the type of both value and key, using the `Key`
    and `Elem` methods:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 类型允许您使用 `Key` 和 `Elem` 方法获取值和键的类型：'
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A full example is available here: [https://play.golang.org/p/j__1jtgy-56](https://play.golang.org/p/j__1jtgy-56).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例在这里：[https://play.golang.org/p/j__1jtgy-56](https://play.golang.org/p/j__1jtgy-56)。
- en: 'The values can be accessed in all the ways that a map can be accessed normally:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以正常访问映射的所有方式访问值：
- en: By getting a value using a key
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过键获取值
- en: By ranging over keys
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过键的范围
- en: By ranging over values
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过值的范围
- en: 'Let''s see how it works in a practical example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个实际的例子：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we don't need to pass a pointer to the map to make it addressable,
    because maps are already pointers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们无需传递指向地图的指针以使其可寻址，因为地图已经是指针。
- en: 'Each method is pretty straightforward and depends on the type of access you
    need to the map. Setting values is also possible, and should always be possible
    because maps are passed by reference. The following snippet shows a practical
    example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都非常直接，并取决于您对映射的访问类型。设置值也是可能的，并且应该始终是可能的，因为映射是通过引用传递的。以下代码片段显示了一个实际示例：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A full example is available here: [https://play.golang.org/p/JxK_8VPoWU0](https://play.golang.org/p/JxK_8VPoWU0).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的示例可以在这里找到：[https://play.golang.org/p/JxK_8VPoWU0](https://play.golang.org/p/JxK_8VPoWU0)。
- en: 'It is also possible to use this method to unset a variable, like we do when
    calling the `delete` function using the zero value of `reflect.Value` as a second
    argument:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用此方法取消设置变量，就像我们在调用`delete`函数时使用`reflect.Value`的零值作为第二个参数一样：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A full example is available here: [https://play.golang.org/p/4bPqfmaKzTC](https://play.golang.org/p/4bPqfmaKzTC).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的示例可以在这里找到：[https://play.golang.org/p/4bPqfmaKzTC](https://play.golang.org/p/4bPqfmaKzTC)。
- en: The output will have one less field as it gets deleted because the length of
    the map decreases after `SetMapIndex`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将少一个字段，因为在`SetMapIndex`之后，映射的长度减少了。
- en: Slices
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: 'A slice allows you to get its size with the `Len` method and to access its
    elements using the `Index` method. Let''s see that in action in the following
    code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 切片允许您使用`Len`方法获取其大小，并使用`Index`方法访问其元素。让我们在以下代码中看看它的运行情况：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A full example is available here: [https://play.golang.org/p/ifq0O6bFIZc.](https://play.golang.org/p/ifq0O6bFIZc)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的示例可以在这里找到：[https://play.golang.org/p/ifq0O6bFIZc.](https://play.golang.org/p/ifq0O6bFIZc)
- en: 'Since it is always possible to get the address of a slice element, it is also
    possible to use `reflect.Value` to change the content of the respective element
    in the slice:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于始终可以获取切片元素的地址，因此也可以使用`reflect.Value`来更改切片中相应元素的内容：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A full example is available here: [https://play.golang.org/p/onuIvWyQ7GY](https://play.golang.org/p/onuIvWyQ7GY).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的示例可以在这里找到：[https://play.golang.org/p/onuIvWyQ7GY](https://play.golang.org/p/onuIvWyQ7GY)。
- en: 'It is also possible to append to a slice using the `reflect` package. If the
    value is obtained from the pointer to the slice, the result of this operation
    can also be used to replace the original slice:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`reflect`包将内容附加到切片。如果值是从切片的指针获得的，则此操作的结果也可以用于替换原始切片：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A full example is available here: [https://play.golang.org/p/2hXRg7Ih9wk](https://play.golang.org/p/2hXRg7Ih9wk).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的示例可以在这里找到：[https://play.golang.org/p/2hXRg7Ih9wk](https://play.golang.org/p/2hXRg7Ih9wk)。
- en: Functions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Method and function handling with reflection allow you to gather information
    about the signature of a certain entry and also to invoke it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反射处理方法和函数可以收集有关特定条目签名的信息，并调用它。
- en: Analyzing a function
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析函数
- en: 'There are a few methods of `reflect.Type` in the package that will return information
    about a function. These methods are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 包中有一些`reflect.Type`的方法将返回有关函数的信息。这些方法如下：
- en: '`NumIn`: Returns the number of input arguments of the function'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumIn`：返回函数的输入参数数量'
- en: '`In`: Returns the selected input argument'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`In`：返回所选输入参数'
- en: '`IsVariadic`: Tells you if the last argument of the function is variadic'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsVariadic`：告诉您函数的最后一个参数是否是可变参数'
- en: '`NumOut`: Returns the number of output values returned by the function'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumOut`：返回函数返回的输出值的数量'
- en: '`Out`: Returns the `Type` value of the select output'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Out`：返回选择输出的`Type`值'
- en: 'Note that all these methods will panic if the kind of `reflect.Type` is not
    `Func`. We can test these methods by defining a series of functions:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果`reflect.Type`的类型不是`Func`，所有这些方法都会引发恐慌。我们可以通过定义一系列函数来测试这些方法：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we can use the method from `reflect.Type` to obtain information about them:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`reflect.Type`的方法来获取有关它们的信息：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A full example is available here: [https://play.golang.org/p/LAjjhw8Et60](https://play.golang.org/p/LAjjhw8Et60).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的示例可以在这里找到：[https://play.golang.org/p/LAjjhw8Et60](https://play.golang.org/p/LAjjhw8Et60)。
- en: In order to obtain the name of the functions, we use the `runtime.FuncForPC`
    function, which returns `runtime.Func`  containing methods that will expose runtime
    information about the function—`name`, `file`, and `line`. The function takes `uintptr`
    as an argument, which can be obtained with `reflect.Value` of the function and
    its `Pointer` method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取函数的名称，我们使用`runtime.FuncForPC`函数，它返回包含有关函数的运行时信息的`runtime.Func`，包括`name`、`file`和`line`。该函数以`uintptr`作为参数，可以通过函数的`reflect.Value`和其`Pointer`方法获得。
- en: Invoking a function
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用函数
- en: While the type of the function shows information about it, in order to call
    a function, we need to use its value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数的类型显示了有关它的信息，但为了调用函数，我们需要使用它的值。
- en: 'We will pass the function a list of argument values and get back the ones returned
    by the function call:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向函数传递参数值列表，并获取函数调用返回的值：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A full example is available here: [https://play.golang.org/p/jPxO_G7YP2I](https://play.golang.org/p/jPxO_G7YP2I).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的示例可以在这里找到：[https://play.golang.org/p/jPxO_G7YP2I](https://play.golang.org/p/jPxO_G7YP2I)。
- en: Channels
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道
- en: Reflection allows us to create channels, send and receive data, and also to
    use `select` statements.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 反射允许我们创建通道，发送和接收数据，并且还可以使用`select`语句。
- en: Creating channels
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建通道
- en: 'A new channel can be created via the `reflect.MakeChan` function, which requires
    a `reflect.Type` interface value and a size:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`reflect.MakeChan`函数创建一个新的通道，该函数需要一个`reflect.Type`接口值和一个大小：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A full example is available here: [https://play.golang.org/p/7_RLtzjuTcz](https://play.golang.org/p/7_RLtzjuTcz).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的示例可以在这里找到：[https://play.golang.org/p/7_RLtzjuTcz](https://play.golang.org/p/7_RLtzjuTcz)。
- en: Sending, receiving, and closing
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送、接收和关闭
- en: 'The `reflect.Value` type offers a few methods that have to be used exclusively
    with channels, `Send` and `Recv` for sending and receiving, and `Close` for closing
    channels. Let''s take a look at a sample use case of these functions and methods:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect.Value`类型提供了一些方法，必须与通道一起使用，`Send`和`Recv`用于发送和接收，`Close`用于关闭通道。让我们看一下这些函数和方法的一个示例用法：'
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A full example is available here: [https://play.golang.org/p/Gp8JJmDbLIL](https://play.golang.org/p/Gp8JJmDbLIL).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个完整的示例：[https://play.golang.org/p/Gp8JJmDbLIL](https://play.golang.org/p/Gp8JJmDbLIL)。
- en: Select statement
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择语句
- en: 'A `select` statement can be executed with the `reflect.Select` function. Each
    case is represented by a data structure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`语句可以使用`reflect.Select`函数执行。每个case由一个数据结构表示：'
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It contains the direction of the operation and both the channel and the value
    (for send operations). The direction can be either send, receive, or none (for
    default statements):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含操作的方向以及通道和值（用于发送操作）。方向可以是发送、接收或无（用于默认语句）：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A full example is available here: [https://play.golang.org/p/_DgSYRIBkJA](https://play.golang.org/p/_DgSYRIBkJA).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个完整的示例：[https://play.golang.org/p/_DgSYRIBkJA](https://play.golang.org/p/_DgSYRIBkJA)。
- en: Reflecting on reflection
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射反射
- en: After talking how about how reflection works in all its aspects, we will now
    focus on its downside, when it is used in the standard library, and when to use
    it in packages.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了反射在所有方面的工作原理之后，我们现在将专注于其缺点，即在标准库中使用它的情况，以及何时在包中使用它。
- en: Performance cost
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能成本
- en: Reflection allows code to be flexible and handles unknown data types by analyzing
    their memory representation. This is not cost-free and, besides complexity, another
    aspect that reflection influences is performance.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 反射允许代码灵活处理未知数据类型，通过分析它们的内存表示。这并不是没有成本的，除了复杂性之外，反射影响的另一个方面是性能。
- en: 'We can create a couple of examples to demonstrate how some trivial operations
    are much slower using reflection. We can create a timeout and keep repeating these
    operations in goroutines. Both routines will terminate when the timeout expires,
    and we will compare the results:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一些示例来演示使用反射执行一些琐碎操作时的速度要慢得多。我们可以创建一个超时，并在goroutines中不断重复这些操作。当超时到期时，两个例程都将终止，我们将比较结果：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can compare normal map writing with the same operation done with reflection:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以比较普通的map写入与使用反射进行相同操作的速度：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also test out how fast the reading is and the settings of a structure
    field, with and without reflection:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试一下使用反射和不使用反射时读取的速度以及结构字段的设置：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There is at least a 50% performance drop when executing operation via reflection,
    compared to the standard, static way of doing things. This drop could be very
    critical when performance is a very important priority in an application, but
    if that's not the case, then the use of reflection could be a reasonable call.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反射执行操作时，性能至少下降了50％，与标准的静态操作方式相比。当性能在应用程序中非常重要时，这种下降可能非常关键，但如果不是这种情况，那么使用反射可能是一个合理的选择。
- en: Usage in the standard library
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库中的使用
- en: 'There are many different packages in the standard library that use the `reflect`
    package:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中有许多不同的包使用了`reflect`包：
- en: '`archive/tar`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`archive/tar`'
- en: '`context`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`'
- en: '`database/sql`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`database/sql`'
- en: '`encoding/asn1`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding/asn1`'
- en: '`encoding/binary`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding/binary`'
- en: '`encoding/gob`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding/gob`'
- en: '`encoding/json`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding/json`'
- en: '`encoding/xml`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding/xml`'
- en: '`fmt`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt`'
- en: '`html/template`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html/template`'
- en: '`net/http`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http`'
- en: '`net/rpc`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/rpc`'
- en: '`sort/slice`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort/slice`'
- en: '`text/template`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/template`'
- en: 'We can reason about their approach to reflection, taking as an example the
    encoding packages. Each of these packages offers interfaces for encoding and decoding,
    for instance, the `encoding/json` package. We have the following interfaces defined:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以思考他们对反射的处理方式，以编码包为例。这些包中的每一个都提供了编码和解码的接口，例如`encoding/json`包。我们定义了以下接口：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The package first looks if the unknown type implements the interface while decoding
    or encoding, and, if not, it uses reflection. We can think of reflection as a
    last resource that the package uses. Even the `sort` package has a generic `slice`
    method that takes any slice using reflection to set values and a sorting interface
    that avoids using reflection.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 该包首先查看未知类型是否在解码或编码时实现了接口，如果没有，则使用反射。我们可以将反射视为包使用的最后资源。即使`sort`包也有一个通用的`slice`方法，使用反射来设置值和一个排序接口，避免使用反射。
- en: There are other packages, such as `text/template` and `html/template`, that
    read runtime text files with instructions on which method or field to access or
    to use. In this case, there is no other way than reflection to accomplish it,
    and there is no interface that can avoid it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他包，比如`text/template`和`html/template`，它们读取运行时文本文件，其中包含关于要访问或使用的方法或字段的指令。在这种情况下，除了反射之外，没有其他方法可以完成它，也没有可以避免它的接口。
- en: Using reflection in a package
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在包中使用反射
- en: 'After seeing how reflection works and the kind of complications that it adds
    to code, we can think about using it in a package we are writing. One of the Go
    proverbs, from its creator Rob Pike, comes to the rescue:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了反射的工作原理以及它给代码增加的复杂性之后，我们可以考虑在我们正在编写的包中使用它。来自其创作者Rob Pike的Go格言之一拯救了我们：
- en: Clear is better than clever. Reflection is never clear.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰比聪明更好。反射从来不清晰。
- en: The power of reflection is huge, but it also comes at the expense of making
    code more complicated and implicit. It should be used only when it's extremely
    necessary, as in the template scenario, and should be avoided in any other case,
    or at least offer an interface to avoid it, as in the encoding packages.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 反射的威力是巨大的，但这也是以使代码更加复杂和隐式为代价的。只有在极端必要的情况下才应该使用它，就像在模板场景中一样，并且应该在任何其他情况下避免使用它，或者至少提供一个接口来避免使用它，就像在编码包中一样。
- en: Property files
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性文件
- en: We can try to use reflection to create a package that reads property files.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用反射来创建一个读取属性文件的包。
- en: 'We can use reflection to create a package that reads property files:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用反射来创建一个读取属性文件的包：
- en: 'The first thing we should do is define an interface that avoids using reflection:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该做的第一件事是定义一个避免使用反射的接口：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we can define a decoder structure that will feed on an `io.Reader` instance,
    using a line scanner to read the individual properties:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以定义一个解码器结构，它将利用一个`io.Reader`实例，使用行扫描器来读取各个属性：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The decoder will also be used by the `Unmarshal` method:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码器也将被`Unmarshal`方法使用：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can reduce the number of uses of reflection that we will do by building
    a cache of field names and indices. This will be helpful because the value of
    a field in reflection can only be accessed by an index, and not by a name:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过构建字段名称和索引的缓存来减少我们将使用反射的次数。这将很有帮助，因为在反射中，字段的值只能通过索引访问，而不能通过名称访问。
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The next step is defining the `Decode` method. This will receive a pointer
    to a structure and then proceed to process lines from the scanner and populate
    the structure fields:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义`Decode`方法。这将接收一个指向结构的指针，然后继续从扫描器中处理行并填充结构字段：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The most important part of the work will be done by the private `decodeValue` method.
    The first thing will be verifying that the `Unmarshaller` interface is satisfied,
    and, if it is, using it. Otherwise, the method is going to use reflection to decode
    the value received correctly. For each type, it will use a different `Set` method
    from `reflection.Value`, and it will return an error if it encounters an unknown
    type:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的工作将由私有的`decodeValue`方法完成。首先要验证`Unmarshaller`接口是否满足，如果满足，则使用它。否则，该方法将使用反射来正确解码接收到的值。对于每种类型，它将使用`reflection.Value`的不同`Set`方法，并且如果遇到未知类型，则会返回错误：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using the package
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包
- en: 'To test whether the package behaves as expected, we can create a custom type
    that satisfies the `Unmarshaller` interface. The type implemented transforms the
    string into uppercase when decoding:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试包是否按预期运行，我们可以创建一个满足`Unmarshaller`接口的自定义类型。实现的类型在解码时将字符串转换为大写：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we can use the type as a structure field and we can verify that it gets
    transformed correctly in a `decode` operation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将类型用作结构字段，并验证它在`decode`操作中是否被正确转换：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed the Go memory model for interfaces in detail, highlighting
    that an interface always contains a concrete type. We used this information to
    get a better look at type casting and understand what happens when an interface
    gets cast to another.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细回顾了Go语言接口的内存模型，强调了接口始终包含一个具体类型。我们利用这些信息更好地了解了类型转换，并理解了当一个接口被转换为另一个接口时会发生什么。
- en: Then, we introduced the basic mechanics of reflection, starting with type and
    value, which are the two main types of the package. They represent, respectively,
    the type and value of a variable. Value allows you to read a variable content
    and also to write it if the variable is addressable. In order to be addressable,
    a variable needs to be accessed from its address, using a pointer, for instance.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了反射的基本机制，从类型和值开始，这是该包的两种主要类型。它们分别表示变量的类型和值。值允许您读取变量的内容，如果变量是可寻址的，还可以写入它。为了使变量可寻址，需要从其地址访问变量，例如使用指针。
- en: We also saw how complex data types can be handled with reflection, seeing how
    to access structure field value. Data types of structure can be used to get metadata
    about fields, including name and tags, which are heavily used by encoding packages
    and other third-party libraries.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用反射处理复杂的数据类型，了解如何访问结构字段值。结构的数据类型可以用于获取关于字段的元数据，包括名称和标签，这些在编码包和其他第三方库中被广泛使用。
- en: We saw how to create and operate with maps, including adding, setting, and deleting
    values. With slices, we saw how to edit their values and how to execute append
    operations. We also showed how to use a channel to send and receive data, and
    even how to use `select` statements in the same way we do with static-typed programming.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何创建和操作映射，包括添加、设置和删除值。对于切片，我们看到了如何编辑它们的值以及如何执行追加操作。我们还展示了如何使用通道发送和接收数据，甚至如何像静态类型编程一样使用`select`语句。
- en: Finally, we listed where reflection is used in the standard library, and did
    a quick analysis of its computational cost. We concluded the chapter with some
    tips on how and when to use reflection in a library or in any application you
    are writing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们列出了标准库中使用反射的地方，并对其计算成本进行了快速分析。我们用一些关于何时何地使用反射的提示来结束本章，无论是在库中还是在您编写的任何应用程序中。
- en: The next chapter is the last one of the book, and it explains how to leverage
    the existing C library in Go using CGO.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是本书的最后一章，它解释了如何使用CGO在Go语言中利用现有的C库。
- en: Questions
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's the memory representation of an interface in Go?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go语言中接口的内存表示是什么？
- en: What happens when an interface type is cast to another one?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个接口类型被转换为另一个接口类型时会发生什么？
- en: What are `Value`, `Type` , and `Kind` in reflection?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反射中的`Value`、`Type`和`Kind`是什么？
- en: What does it mean if a value is addressable?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个值是可寻址的，这意味着什么？
- en: Why are structure field tags important in Go?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么Go语言中结构字段标签很重要？
- en: What's the general trade-off of reflection?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反射的一般权衡是什么？
- en: Could you describe a good approach to using reflection?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能描述一种使用反射的良好方法吗？
