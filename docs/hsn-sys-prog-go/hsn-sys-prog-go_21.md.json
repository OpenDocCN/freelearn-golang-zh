["```go\n sudo apt install gcc\n```", "```go\npackage example\n\n// #include <stdio.h>\nimport \"C\"\n```", "```go\npackage example\n\n/*\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\nvoid someFunction(char* s) {\n    printf(\"%s\\n\", s);\n}\n*/\nimport \"C\"\n```", "```go\npackage main\n\n/*\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid customPrint(char* s) {\n    printf(\"%s\\n\", s);\n}\n*/\nimport \"C\"\n\nimport \"unsafe\"\n\nfunc main() {\n    s := C.CString(`Printing to stdout with CGO\n        Using <stdio.h> and <stdlib.h>`)\n            defer C.free(unsafe.Pointer(s))\n            C.customPrint(s)\n}\n```", "```go\nfunc C.CString(string) *C.char\n```", "```go\n//export theAnswer\nfunc theAnswer() C.int {\n    return 42\n}\n```", "```go\nextern int theAnswer();\n```", "```go\npackage main\n\n// extern int goAdd(int, int);\n//\n// static int cAdd(int a, int b) {\n//     return goAdd(a, b);\n// }\nimport \"C\"\nimport \"fmt\"\n\n//export goAdd\nfunc goAdd(a, b C.int) C.int {\n    return a + b\n}\n\nfunc main() {\n    fmt.Println(C.cAdd(1, 3))\n}\n```", "```go\nchar lang[7] = {'G', 'o', 'l', 'a', 'n', 'g', '\\0'};\n\nchar lang[] = \"Golang\";\n```", "```go\nfunc C.CString(string) *C.char\n```", "```go\nfunc C.CBytes([]byte) unsafe.Pointer\n```", "```go\nfunc C.GoString(*C.char) string\n\nfunc C.GoStringN(*C.char, C.int) string\n```", "```go\nfunc C.GoBytes(unsafe.Pointer, C.int) []byte\n```", "```go\npackage main\n\n/*\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* reverseString(char* s) {\n    int l = strlen(s);\n    for (int i=0; i < l/2; i++) {\n        char a = s[i];\n        s[i] = s[l-1-i];\n        s[l-1-i] = a;\n    }\n    return s;\n}\n*/\nimport \"C\"\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc main() {\n    b1 := []byte(\"A byte slice\")\n    c1 := C.CBytes(b1)\n    fmt.Printf(\"Go ptr: %p\\n\", b1)\n    fmt.Printf(\"C ptr: %p\\n\", c1)\n    defer C.free(c1)\n    c2 := unsafe.Pointer(C.reverseString((*C.char)(c1)))\n    b2 := C.GoBytes(c2, C.int(len(b1)))\n    fmt.Printf(\"Go ptr: %p\\n\", b2)\n    fmt.Printf(\"%q -> %q\", b1, b2)\n}\n```", "```go\npackage main\n\n/*\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* reverseString(char* s) {\n    int l = strlen(s);\n    for (int i=0; i < l/2; i++) {\n        char a = s[i];\n        s[i] = s[l-1-i];\n        s[l-1-i] = a;\n    }\n    return s;\n}\n*/\nimport \"C\"\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc main() {\n    s1 := \"A byte slice\"\n    c1 := C.CString(s1)\n    defer C.free(unsafe.Pointer(c1))\n    c2 := C.reverseString(c1)\n    s2 := C.GoString(c2)\n    fmt.Printf(\"%q -> %q\", s1, s2)\n}\n```", "```go\npackage main\n\nimport \"C\"\n\nimport \"fmt\"\n\nfunc main() {\n    a := int64(0x1122334455667788)\n\n    // a fits in 64 bits\n    fmt.Println(a)\n    // short overflows, it's 16\n    fmt.Println(C.short(a), int16(0x7788))\n    // long also overflows, it's 32\n    fmt.Println(C.long(a), int32(0x55667788))\n    // longlong is okay, it's 64\n    fmt.Println(C.longlong(a), int64(0x1122334455667788))\n}\n```", "```go\npackage main\n\nimport \"C\"\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    a := float64(math.Pi)\n\n    fmt.Println(a)\n    fmt.Println(C.float(a))\n    fmt.Println(C.double(a))\n    fmt.Println(C.double(C.float(a)) - C.double(a))\n}\n```", "```go\npackage main\n\n/*\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid reverseString(char* s) {\n    int l = strlen(s);\n    for (int i=0; i < l/2; i++) {\n        char a = s[i];\n        s[i] = s[l-1-i];\n        s[l-1-i] = a;\n    }\n}\n*/\nimport \"C\"\n\nimport (\n  \"fmt\"\n  \"unsafe\"\n)\n\nfunc main() {\n    b1 := []byte(\"A byte slice\")\n    fmt.Printf(\"Slice: %s\\n\", b1)\n    C.reverseString((*C.char)(unsafe.Pointer(&b1[0])))\n    fmt.Printf(\"Slice: %s\\n\", b1)\n}\n```", "```go\npackage main\n\n/*\nvoid half(double* f) {\n    *f = *f/2;\n}\n*/\nimport \"C\"\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"unsafe\"\n)\n\nfunc main() {\n    a := float64(math.Pi)\n    fmt.Println(a)\n    C.half((*C.double)(unsafe.Pointer(&a)))\n    fmt.Println(a)\n}\n```", "```go\nfunc mean(l []float64) (m float64) {\n    for _, a := range l {\n        m += a\n    }\n    return m / float64(len(l))\n}\n```", "```go\ndouble mean(int len, double *a) {\n    if (a == NULL || len == 0) {\n        return 0;\n    }\n    double m = 0;\n    for (int i = 0; i < len; i++) {\n        m+=a[i];\n    }\n    return m / len;\n}\n```", "```go\nfunc mean(a []float64) float64 {\n    if len(a) == 0 {\n        return 0\n    }\n    return float64(C.mean(C.int(len(a)), (*C.double)(&a[0])))\n}\n```", "```go\nfunc mean2(a []float64) float64 {\n    if len(a) == 0 {\n        return 0\n    }\n    return float64(C.mean(C.int(len(a)*2), (*C.double)(&a[0])))\n}\n```", "```go\nvar a = make([]float64, 10)\n\nfunc init() {\n    for i := range a {\n        a[i] = float64(i + 1)\n    }\n}\n\nfunc main() {\n    cases := [][]float64{a, a[1:4], a[:0], nil}\n    for _, slice := range cases {\n        fmt.Println(slice, mean(slice))\n    }\n    for _, slice := range cases {\n        fmt.Println(slice, mean2(slice))\n    }\n}\n```", "```go\nstruct {\n    a string\n    b bool\n    c []byte\n}\n```", "```go\nstruct {\n    a, b bool\n    c rune\n    d byte\n    e string\n}\n```", "```go\nstruct{\n    a int32\n    b int32\n}\n```", "```go\nstruct{\n    a int32\n    _ int32\n    b int32\n    _ int32\n}\n```", "```go\ntypedef struct{\n  unsigned char a;\n  char b;\n  int c;\n  unsigned int d;\n  char e[10];\n} myStruct;\n```", "```go\nfunc main() {\n    v := C.myStruct{\n        a: C.uchar('A'),\n        b: C.char('Z'),\n        c: C.int(100),\n        d: C.uint(10),\n        e: [10]C.char{'h', 'e', 'l', 'l', 'o'},\n    }\n    log.Printf(\"%#v\", v)\n}\n```", "```go\nmain._Ctype_struct___0{\n    a:0x41, \n    b:90, \n    c:100, \n    d:0xa, \n    e:[10]main._Ctype_char{104, 101, 108, 108, 111, 0, 0, 0, 0, 0},\n     _:[2]uint8{0x0, 0x0},\n}\n```", "```go\n#pragma pack(1)\ntypedef struct{\n  unsigned char a;\n  char b;\n  int c;\n  unsigned int d;\n  char e[10];\n} myStruct;\n```", "```go\npack := C.myStruct{\n    a: C.uchar('A'),\n    b: C.char('Z'),\n    c: C.int(100),\n    d: C.uint(10),\n    e: [10]C.char{},\n}\n```", "```go\nmain._Ctype_struct___0{\n    a:0x41, \n    b:90, \n    _:[8]uint8{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, \n    e:[10]main._Ctype_char{104, 101, 108, 108, 111, 0, 0, 0, 0, 0},\n}\n```", "```go\nmyStruct makeStruct(){\n  myStruct p;\n  p.a = 'A';\n  p.b = 'Z';\n  p.c = 100;\n  p.d = 10;\n  p.e[0] = 'h';\n  p.e[1] = 'e';\n  p.e[2] = 'l';\n  p.e[3] = 'l';\n  p.e[4] = 'o';\n  p.e[5] = '\\0';\n  p.e[6] = '\\0';\n  p.e[7] = '\\0';\n  p.e[8] = '\\0';\n  p.e[9] = '\\0';\n  return p;\n}\n```", "```go\nmain._Ctype_struct___0{\n    a:0x41, \n    b:90, \n    _:[8]uint8{0x64, 0x0, 0x0, 0x0, 0xa, 0x0, 0x0, 0x0}, \n    e:[10]main._Ctype_char{104, 101, 108, 108, 111, 0, 0, 0, 0, 0}\n}\n```", "```go\ntype myStruct struct {\n    a uint8\n    b int8\n    c int32\n    d uint32\n    e [10]uint8\n}\n```", "```go\nfunc unpack(i *C.myStruct) (m myStruct) {\n    b := bytes.NewBuffer(C.GoBytes(unsafe.Pointer(i), C.sizeof_myStruct))\n    for _, v := range []interface{}{&m.a, &m.b, &m.c, &m.d, &m.e} {\n        binary.Read(b, binary.LittleEndian, v)\n    }\n    return\n}\n```", "```go\nmain.myStruct{\n    a:0x41, \n    b:90, \n    c:100, \n    d:0xa, \n    e:[10]uint8{0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x0, 0x0, 0x0, 0x0, 0x0},\n}\n```"]