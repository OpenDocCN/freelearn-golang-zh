# 评估

# 第一章

1.  应用程序和系统编程之间有什么区别？

应用程序编程侧重于为最终用户解决问题，而系统编程是关于创建其他软件使用的软件。

1.  什么是 API？API 为什么如此重要？

API 是软件公开的用于控制其控制资源访问的接口。它描述了其他应用程序应该如何与软件通信。

1.  你能解释一下保护环是如何工作的吗？

保护环是一种用于防止故障并增加安全性的系统。它以层次化的安全级别安排安全性，并通过使用特定的网关允许对更强大级别的功能进行中介访问。

1.  你能举一些在用户空间无法执行的例子吗？

用户空间中的应用程序不能将其当前空间更改为内核，也不能忽略文件系统访问硬盘，并且不能更改页表。

1.  什么是系统调用？

系统调用是操作系统提供的 API，用于访问计算机的资源。

1.  Unix 用哪些调用来管理进程？

Unix 用于管理进程的调用如下：`fork`、`exit`和`wait`。

1.  POSIX 为什么有用？各种 POSIX 标准定义了进程控制、信号、分段、非法指令、文件和目录操作、管道、I/O 控制和 C 库、shell 和实用程序，以及实时和多线程扩展。对于开发人员来说，它非常有用，因为它有助于构建与共享此标准的不同操作系统兼容的应用程序。

1.  Windows 是否符合 POSIX？Windows 不符合 POSIX，但正在尝试提供 POSIX 框架，例如 Windows Linux 子系统。

# 第二章

1.  现代操作系统使用哪种文件系统？

现代操作系统使用不同的文件系统：Windows 和 macOS 使用各自专有的格式 NTFS 和 APFS，而 Linux 系统主要使用 EXT4。

1.  什么是 inode？Unix 中的 inode `0`是什么？

inode 是表示文件的文件系统数据结构。它存储有关文件的信息，但不包括名称和数据。

inode `0` 保留给`/`文件夹。

1.  PID 和 PPID 之间有什么区别？

PID 是现有进程的唯一标识符，而 PPID 是父进程的标识符。当现有进程创建另一个进程时，新进程的 PPID 等于现有进程的 PID。

1.  如何终止后台运行的进程？

虽然`SIGINT`信号可以通过按*Ctrl* + *C*发送给前台进程，但对于后台进程，信号需要使用`kill`命令发送，此时为`kill -2 PID`。

1.  用户和组之间有什么区别？

用户标识一个可以拥有文件和进程的帐户，而组是在文件上共享权限的机制。

1.  Unix 权限模型的范围是什么？

Unix 权限模型使得可以通过三种不同级别的权限来限制对文件的访问：所有者、组和所有其他用户。

1.  你能解释一下信号和退出代码之间的区别吗？

信号和退出代码都是进程之间的通信方法，但信号是从任何进程到另一个进程，而退出代码用于从子进程到其父进程的通信。

1.  什么是交换文件？

交换文件是用于存储不需要的页面以释放主内存的物理内存的扩展。

# 第三章

1.  导出符号和未导出符号有什么区别？

导出符号可以被其他软件包使用，而未导出符号不能。第一组具有以大写字母开头的标识符，而第二组没有。

1.  自定义类型为什么重要？

自定义类型允许定义方法并有效地使用接口，或者继承另一种类型的数据结构，但是要摆脱它的方法。

1.  短声明的主要限制是什么？

短声明不允许推断出值的变量类型。通过对值进行类型转换，可以克服这种限制。

1.  作用域是什么，它如何影响变量遮蔽？

变量的作用域代表了它的生命周期和可见性，可以是包、函数或块。当相同的标识符在内部作用域中使用时，会发生遮蔽，阻止外部作用域共享该标识符的符号访问。

1.  如何访问一个方法？

方法是一种特殊类型的函数，它们具有与其所属类型相关联的命名空间。它们可以作为其类型实例的属性访问，也可以作为类型本身的属性访问，将实例作为第一个参数传递。

1.  解释一下一系列`if`/`else`语句和`switch`语句之间的区别。

一系列的`if`和`else`语句允许对每个`if`语句执行一个简短的声明，并且只会执行一个 case，跳过后续的声明。`switch`语句只允许一个声明，并且可以使用`continue`和`break`语句修改流程。

1.  在典型的用例中，通常谁负责关闭通道？

通道应该由发送方关闭，因为发送方负责通知没有更多信息要发送。此外，向关闭的通道发送会引发恐慌，而从中接收是一个非阻塞操作。

1.  什么是逃逸分析？

逃逸分析是 Go 编译器执行的优化过程，试图通过验证变量是否超出了它们定义的函数的生存期来减少在堆中分配的变量。

# 第四章

1.  绝对路径和相对路径有什么区别？

绝对路径以`/`（根）路径开头，而相对路径不是。要从相对路径获取绝对路径，必须将其连接到当前工作目录。

1.  如何获取或更改当前工作目录？

要找出当前工作目录，`os`包提供了`Getwd`函数，它返回当前工作目录。要更改当前工作目录，必须使用`Chdir`函数。它接受相对路径和绝对路径。

1.  使用`ioutil.ReadAll`的优缺点是什么？

`ioutil.ReadAll`函数将整个文件内容放入一个字节切片中，因此文件的大小会影响分配和释放的内存量。由于这种方式分配的内存没有回收利用，这些切片在不再使用时会被垃圾回收。

1.  为什么对于读取操作来说，缓冲区很重要？

字节缓冲区限制了读取操作分配的内存量，但它们也需要一定数量的读取操作，每个操作都带有一些影响速度和性能的开销。

1.  何时应该使用`ioutil.WriteFile`？如果内容的大小不是太大，可以使用`ioutil.WriteFile`函数，因为整个内容需要在内存中。在短期应用中最好使用它，并且避免在频繁写入操作中使用它。

1.  使用允许窥视的缓冲区读取时可以进行哪些操作？

窥视操作允许检查下一个字节的内容，而不会推进当前读取器的光标，这使我们能够进行上下文操作，例如读取单词、读取行或任何基于自定义标记的操作。

1.  何时最好使用字节缓冲区读取内容？

使用读取缓冲区是降低应用程序内存使用的一种方式。当不需要一次性获取所有内容时，可以使用它。

1.  **缓冲区如何用于写入？使用它们的优势是什么？**

在写入操作中，应用程序已经处理了即将写入的字节，因此使用底层缓冲区来优化系统调用的次数，只有当缓冲区满时才会进行系统调用的添加，以避免在传递给写入器的数据不足时增加系统调用开销。

# 第五章

1.  **什么是流？**

流是表示通用传入或传出数据流的抽象。

1.  **哪些接口抽象了传入流？**

`io.Reader`接口是用于传入流的抽象。

1.  **哪个接口代表传出流？**

`io.Writer`接口是用于传出流的抽象。

1.  **何时应该使用字节读取器？何时应该使用字符串读取器？**

当原始数据是字节片时应该使用字节读取器，而当原始数据是字符串时应该使用字符串读取器。从一种数据类型转换为另一种会导致复制并且不方便。

1.  **字符串构建器和字节缓冲区有什么区别？**

字节缓冲区可以被重用和覆盖。字符串构建器用于创建一个字符串而不是复制，因此它使用一个字节切片并将其转换为字符串而不复制，使用`unsafe`包。

1.  **为什么读取器和写入器的实现应该接受接口作为输入？**

接受接口作为输入意味着对具有相同行为的不同类型持开放态度。这使得现有的读取器和写入器，如缓冲区和文件，可以被使用。

1.  **管道与** `TeeReader` **有何不同？**

管道将写入器连接到读取器。无论写入了什么，读取器都会读取。`TeeReader`则相反，将读取器连接到写入器，因此读取的内容也会被写入到其他地方。

# 第六章

1.  **什么是终端，什么是伪终端？** 终端是一个行为类似于电传打字机的应用程序，通过显示一个 2x2 的字符矩阵。伪终端是在终端下运行并通过交互来模拟其行为的应用程序。

1.  **伪终端应该具备什么功能？** 伪终端应用程序应该能够接收用户输入，根据接收到的指令执行操作，并将结果显示给用户。

1.  **我们使用了哪些 Go 工具来模拟终端？** 为了管理用户输入，我们在标准输入中使用了一个缓冲扫描器，它将逐行读取用户输入。每个命令都是使用相同的接口实现的。为了理解调用的命令，我们使用了第一个参数和可用命令之间的比较。一个写入器被传递给命令来打印它们的输出。

1.  **我的应用程序如何从标准输入获取指令？** 应用程序可以使用标准输入结合扫描器，每次遇到新行时都会返回一个新的标记。

1.  **使用接口命令有什么优势？** 使用接口命令允许我们和我们包的用户通过实现他们自己的接口版本来扩展行为。

1.  **什么是莱文斯坦距离？为什么在伪终端中有用？** 莱文斯坦距离是将一个字符串转换为另一个字符串所需的更改次数。当用户指定一个不存在的命令时，它可以用于向用户建议其他命令。

# 第七章

1.  Go 应用程序内部的当前进程可用的应用程序有哪些？

进程可用的应用程序有 PID（进程 ID）、PPID（父进程 ID）、UID 和 GID（用户和组 ID）以及工作目录。

1.  **如何创建子进程？**

`exec.Cmd`数据结构可用于定义子进程。当调用`Run`、`Start`、`Output`和`CombinedOutput`方法之一时，进程将被创建。

1.  **如何确保子进程在其父进程之后继续存在？**

在 Unix 系统中，默认情况下，如果父进程终止，子进程会继续存在。此外，您可以更改子进程的进程组和会话 ID，以确保其继续存在。

1.  可以访问子属性吗？它们如何使用？

最大的优势之一是访问子 PID 以将其持久化在某个地方，例如磁盘上。这将允许应用程序的另一个实例或任何其他应用程序知道子进程的标识符，并验证它是否仍在运行。

1.  在 Linux 中，守护进程是什么，它们是如何处理的？

在 Linux 中，守护进程是在后台运行的进程。为了创建一个守护进程，进程可以创建自身的一个分支并终止，将`init`进程设置为分支的父进程，将当前工作目录设置为分支的根目录，将子进程的输入设置为`null`，并使用日志文件进行输出和错误处理。

# 第八章

1.  退出代码是什么？谁使用它？

退出代码是从进程传递给其父进程的整数值，用于表示进程结束的结果。如果没有错误，则为`0`。父进程可以使用此值决定下一步该做什么，例如，如果出现错误，则再次运行进程。

1.  应用程序发生 panic 时会发生什么？返回什么退出代码？

如果`panic`没有被恢复，应用程序将执行所有延迟函数，并以状态`2`退出。

1.  Go 应用程序在接收所有信号时的默认行为是什么？

Go 应用程序在处理信号时的默认行为是早期退出。

1.  你如何拦截信号并决定应用程序的行为？

可以使用`signal.Notify`方法在通道上拦截接收到的信号，指定要处理的信号类型。通道接收到的值可以与信号值进行比较，并相应地应用程序可以表现出不同的行为。

1.  你能向其他进程发送信号吗？如果可以，怎么做？

在 Go 应用程序中，可以向另一个进程发送信号。为了做到这一点，应用程序需要使用查找函数获取`os.Process`结构的实例，然后可以使用该结构的`Signal`方法发送信号。

1.  管道是什么，它们为什么重要？

管道是两个流，一个是输出流，另一个是输入流，它们连接在一起。输出中写入的内容可以在输入中使用，这有助于将一个进程的输出连接到另一个进程的输入。

# 第九章

1.  使用通信模型的优势是什么？

通信模型允许您抽象处理模型中处理的数据类型，使不同端点之间的通信变得容易。

1.  TCP 和 UDP 连接之间有什么区别？

TCP 是面向连接的，这使得它可靠，因为它在发送新数据之前验证目标是否正确接收数据。UDP 连接持续发送数据，而不确认目标是否接收了数据包。这可能导致数据包丢失，但它使连接更快，不会积累延迟。

1.  发送请求时，谁关闭请求体？

在进行 HTTP 调用时关闭请求是应用程序的责任。

1.  在服务器接收请求时，谁关闭请求体？

当连接关闭时，请求体会自动关闭，但服务器也可以在更早的时候关闭它，如果它愿意的话。

# 第十章

1.  文本和二进制编码之间的权衡是什么？

基于文本的编码对人类来说更容易阅读，也更容易调试和编写，但由于这个原因占用更多的空间。二进制编码对人类来说更难编写、阅读和调试，但尺寸更小。

1.  Go 在编码时默认如何处理数据结构？

Go 的默认行为是使用反射来读取字段及其值。

1.  这种行为如何改变？

通过实现你正在使用的编码的编组器接口，如`json.Marshaller`用于 JSON，可以改变这种行为。

1.  **结构字段如何在 XML 属性中编码？**

结构字段需要在其标签中指定`,attr`值。

1.  解码`gob`接口值需要什么操作？

实现接口的数据类型需要使用`gob.Register`函数在`gob`包中注册。

1.  **什么是协议缓冲编码？**协议缓冲是由谷歌制定的一种编码协议，它使用定义文件来定义数据结构和服务。该文件用于生成数据模型、客户端和服务器存根，只留下服务器的实现给开发人员。

# 第十一章

1.  **什么是线程，谁负责它？**

线程是进程的一部分，可以由特定的核心或 CPU 分配。它携带有关应用程序状态的信息，就像进程一样，并由操作系统调度程序管理。

1.  **goroutine 与线程有什么不同？**

与线程相比，goroutine 非常小，比例为 1:100，并且它们不受操作系统管理。Go 运行时负责调度 goroutine。

1.  **在启动 goroutine 时何时评估参数？**

启动 goroutine 的函数传递的所有参数在创建 goroutine 时进行评估。这意味着如果参数的值在 goroutine 实际被调度程序选中并启动之前发生变化，那么这种变化不会反映在 goroutine 中。

1.  **缓冲和非缓冲通道有什么不同？**

如果未指定容量，或者为`0`，则`make`函数创建非缓冲通道。对这样的通道的每次发送操作都会阻塞当前的 goroutine，直到另一个 goroutine 执行接收操作。缓冲通道可以支持等于其容量的非阻塞发送操作数量。这意味着如果通道的容量为`n`，那么前`n-1`个未被任何接收操作匹配的发送操作将不会阻塞。

1.  **为什么单向通道有用？**

它们只允许一部分操作，清楚地告诉用户通道的范围。只接收通道不允许发送数据，或关闭它，这是有道理的，因为这不是接收者的责任。只发送通道不允许接收数据，但允许发送和关闭通道，并暗示发送者关闭通道以表示没有更多数据。

1.  **当对`nil`或关闭的通道执行操作时会发生什么？**

向`nil`通道发送或接收会永久阻塞，关闭它会导致恐慌。从关闭的通道接收会立即返回零值和`false`，而向关闭的通道发送会引发恐慌，如果再次尝试关闭它也会发生相同的情况。

1.  **计时器和滴答器用于什么？**

计时器和滴答器都创建一个只接收通道。计时器可以在循环中与`select`语句一起使用，而不是使用`default`，以减少选择的频率并降低应用程序在空闲时的 CPU 使用率。滴答器非常适用于在固定时间间隔内执行操作，而一个实际的用途是速率限制器，它限制了在应用程序的某个部分内在一定时间段内执行的次数。

# 第十二章

1.  **什么是竞争条件？**

竞争条件是应用程序试图同时在同一资源上执行两个操作的情况，而资源的性质只允许一次操作。

1.  **当尝试在映射上同时执行读取和写入操作时会发生什么？**

当同时发生对映射的读取和写入操作时，会导致运行时错误：`concurrent map writes`。

1.  **`Mutex`**和**`RWMutex`**之间有什么区别？

常规互斥锁允许锁定和解锁资源，并且每个操作的优先级相同。读/写互斥锁有两种类型的锁，一种用于每个操作（读/写）。读锁允许同时进行多个操作，同时它是排他的。如果资源上有许多连续的读操作，写锁可能会受到延迟。这被称为写饥饿。

1.  **等待组有什么用？**

等待组是与不同 goroutine 的执行同步的完美工具。这使得在经典设置中有多个并发操作时，主 goroutine 必须等待它们结束才能继续的解决方案变得干净而优雅。

1.  **`sync.Once`**的主要用途是什么？

`sync.Once`可用于在一次性执行并发操作。例如，它可用于一次关闭通道并避免恐慌。另一个用例是延迟初始化变量以实现单例设计模式的线程安全版本。

1.  **你如何使用池？**

池允许重复使用短暂的项目。池的一个很好的用例是字节片和字节缓冲区，因为池将防止这些资源被垃圾收集器回收，同时防止分配新的池。

1.  **使用原子操作的优势是什么？**

对于数字变量使用互斥锁会有很大的开销。原子操作可以减少这种开销，并在数字变量上执行线程安全操作。它的主要用途是整数，但通过一些转换，我们可以对其他类型进行相同的操作，例如布尔值和浮点数。

# 第十三章

1.  **Go 中的上下文是什么？**

上下文是一个包，包含一个通用接口和一些辅助函数来返回上下文实例。它用于在应用程序的各个部分之间同步操作和携带值。

1.  **取消、截止日期和超时之间有什么区别？**

上下文有三种不同类型的过期——取消是应用程序显式调用取消函数，截止日期是上下文超过指定时间，超时是上下文经历特定持续时间。

1.  **传递上下文值时的最佳实践是什么？**

使用上下文传递的值应与当前范围或请求相关。它们不应该被用作传递可选函数参数或对应用程序至关重要的变量的方式。使用自定义私有类型作为键也是一个好主意，因为内置值可能被其他包覆盖。指向值的指针也是解决此类问题的一种方法。

1.  **哪些标准包已经使用了上下文？**

有不同的包使用上下文。最值得注意的是`net/http`，它使用上下文进行请求和服务器关闭；`net`使用上下文进行`Dial`或`Listen`等功能；`database/sql`使用上下文来取消查询等操作。

# 第十四章

1.  **生成器是什么？它的责任是什么？**

生成器是一个返回一系列值的工具——每次调用时，它返回系列中的下一个值。它负责按需生成序列中的值。在 Go 中，可以通过使用通道来接收由创建它们的 goroutine 发送的值来实现这一点。

1.  **你会如何描述一个管道？**

管道是一种将执行分割成不同阶段的应用程序流程。这些阶段通过某种通信方式进行通信，例如网络，或者运行时内部，例如通道。

1.  **什么类型的阶段获取一个通道并返回一个？**

中间阶段将从一个只接收通道接收并返回另一个只接收通道。

1.  **扇入和扇出之间有什么区别？**

Fan-in 也被称为分集，它涉及从不同来源收集消息到一个地方。Fan-out，或多路复用，是相反的——它涉及将单个消息源分发给更多的接收者。

# 第十五章

1.  在 Go 中，接口的内存表示是什么？

在 Go 中，接口由两个值表示——第一个是接口的具体类型，而第二个是该类型的值。

1.  当接口类型转换为另一个接口类型时会发生什么？

由于接口值需要是一个具体的值，而不能是另一个接口，所以会创建一个具有不同类型和相同具体值的新接口。

1.  在反射中，`Value`，`Type`和`Kind`是什么？

正如其名称所示，`Value`代表变量的内容；`Type`代表变量的 Go 类型；`Kind`是`Type`的内存表示，仅指内置类型。

1.  值是可寻址的意味着什么？

可寻址值是可以被编辑的值，因为它是通过指针获得的。

1.  为什么 Go 中的结构字段标签很重要？

结构字段标签是一种简单的方法，可以使用反射`Type`接口添加关于结构字段的额外信息，这样做很容易阅读。

1.  反射的一般权衡是什么？

反射允许您的代码处理未知类型的数据，并使您的包或应用程序通用化，但它会带来性能成本。它还使代码更加晦涩和难以维护。

1.  您能描述在使用反射时的一个良好方法吗？

反射的最佳方法是我们在标准库的许多不同部分找到的方法；例如，在`encoding`包中。它们将反射作为最后的手段，并通过为编码和解码操作提供接口来实现。如果这些接口由某种类型满足，包将使用相应的方法，而不是依赖于反射。

# 第十六章

1.  CGO 是什么？

CGO 是一个强大的 Go 工具，用于处理 C 代码和 Go 代码之间的通信。这允许 C 代码在 Go 应用程序中使用，并利用现有的大量 C 库。

1.  如何从 Go 调用 C 代码？

Go 提供了一个名为`C`的伪包，暴露了 C 类型，如`C.int`，以及一些函数，将 Go 字符串和字节转换为`C`字符数组，反之亦然。在导入`C`包之前的注释将被解释为 C 代码，并且其中定义的所有函数（无论是直接定义还是通过导入文件）都将作为`C`包的函数在 Go 中可用。

1.  如何在 C 中使用 Go 代码？

如果 Go 函数前面有一个特殊的注释`//export`，这个函数将对 C 代码可用。它还必须在 C 中定义为外部函数。

1.  Go 和 C 之间的数据类型有什么区别？

即使它们具有不同的数据类型，C 和 Go 共享大部分内置的数字类型。Go 中的字符串是一种内置的不可变类型，但在 C 中，它们只是以`\0`值终止的字符数组。

1.  如何在 C 代码中编辑 Go 值？

使用`unsafe`包，您可以将在 C 和 Go 中具有相同内存表示的数据类型进行转换。您需要将指针转换为其 C 对应值，这将允许您从应用程序的`C`部分编辑指针内容。

1.  紧凑数据结构相关的主要问题是什么？

紧凑的数据结构可以节省内存空间，但它们的字段可能不对齐，这意味着它们分布在多个内存区域之间。这意味着读写操作需要两倍的时间。还有另一个不便之处——一些紧凑的字段无法直接从 Go 中访问。

1.  CGO 的主要缺点是什么？

即使它是一个非常强大的工具，CGO 也有许多缺点——从 C 到 Go 的性能成本，反之亦然；编译时间增加，因为 C 编译器参与了这个过程；以及你的 Go 代码依赖于你的 C 代码工作，这可能更难以维护和调试。
