- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章
- en: '**What is the difference between application and system programming?**'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序和系统编程之间有什么区别？
- en: Application programming focuses on solving a problem for the final user, while
    system programming is about creating software used by other software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程侧重于为最终用户解决问题，而系统编程是关于创建其他软件使用的软件。
- en: '**What is an API? Why are APIs so important?**'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是API？API为什么如此重要？
- en: An API is an interface that the software exposes to control the access to the
    resources it controls. It is a description of how other applications should communicate
    with the software.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: API是软件公开的用于控制其控制资源访问的接口。它描述了其他应用程序应该如何与软件通信。
- en: '**Could you explain how protection rings work?**'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能解释一下保护环是如何工作的吗？
- en: Protection rings are a system used to prevent failures and increase security.
    They arrange security in hierarchical levels with growing limitations and allow
    a mediate access to the features of the more powerful levels by using specific
    gateways.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 保护环是一种用于防止故障并增加安全性的系统。它以层次化的安全级别安排安全性，并通过使用特定的网关允许对更强大级别的功能进行中介访问。
- en: '**Can you provide some examples of what cannot be undertaken in user space?**'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能举一些在用户空间无法执行的例子吗？
- en: An application in user space cannot change its current space to kernel, cannot
    access the hard drive ignoring the filesystem, and cannot change the page tables.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间中的应用程序不能将其当前空间更改为内核，也不能忽略文件系统访问硬盘，并且不能更改页表。
- en: '**What''s a system call?**'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是系统调用？
- en: System calls are the API provided by the operating system to access the machine's
    resources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用是操作系统提供的API，用于访问计算机的资源。
- en: '**Which calls are used in Unix to manage a process?**'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unix用哪些调用来管理进程？
- en: 'The calls that Unix uses to manage a process are as follows: `fork`, `exit`,
    and `wait`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Unix用于管理进程的调用如下：`fork`、`exit`和`wait`。
- en: '**Why is POSIX useful?** The various POSIX standards define process controls,
    signals, segmentation, illegal instructions, file and directory operations, pipes,
    I/O control and the C library, shells and utilities, and real-time and multithreaded
    extensions. It is extremely useful for a developer when building applications,
    because it aids in building an application that works with different operating
    systems sharing this standard.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: POSIX为什么有用？各种POSIX标准定义了进程控制、信号、分段、非法指令、文件和目录操作、管道、I/O控制和C库、shell和实用程序，以及实时和多线程扩展。对于开发人员来说，它非常有用，因为它有助于构建与共享此标准的不同操作系统兼容的应用程序。
- en: '**Is Windows POSIX-compliant?** Windows is not POSIX-compliant, but an attempt
    is being made to offer a POSIX framework, such as the Windows Linux subsystem.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows是否符合POSIX？Windows不符合POSIX，但正在尝试提供POSIX框架，例如Windows Linux子系统。
- en: Chapter 2
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: '** Which filesystem is used by modern operating systems?**'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现代操作系统使用哪种文件系统？
- en: 'Modern operating systems use different filesystems: Windows and macOS use their
    respective proprietary formats, NTFS and APFS, while Linux systems mainly use
    EXT4.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统使用不同的文件系统：Windows和macOS使用各自专有的格式NTFS和APFS，而Linux系统主要使用EXT4。
- en: '**What is an inode? What is inode** `0` **in Unix?**'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是inode？Unix中的inode `0`是什么？
- en: An inode is a filesystem data structure representing a file. It stores information
    about a file, excluding the name and data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: inode是表示文件的文件系统数据结构。它存储有关文件的信息，但不包括名称和数据。
- en: The inode `0` is reserved for the `/` folder.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: inode `0` 保留给`/`文件夹。
- en: '**What''s the difference between PID and PPID?**'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PID和PPID之间有什么区别？
- en: PID is the unique identifier for an existing process, while PPID is the identifier
    of the parent process. When an existing process creates another, the new process
    has a PPID equal to the existing process's PID.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: PID是现有进程的唯一标识符，而PPID是父进程的标识符。当现有进程创建另一个进程时，新进程的PPID等于现有进程的PID。
- en: '**How do you terminate a process running in the background?**'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何终止后台运行的进程？
- en: While a `SIGINT` signal can be sent to a foreground process by pressing *Ctrl*
    + *C*, for a background process, the signal needs to be sent with the `kill` command,
    in this case, `kill -2 PID`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`SIGINT`信号可以通过按*Ctrl* + *C*发送给前台进程，但对于后台进程，信号需要使用`kill`命令发送，此时为`kill -2 PID`。
- en: '**What is the difference between a user and a group?**'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户和组之间有什么区别？
- en: A user identifies an account that can own files and processes, while a group
    is a mechanism to share permissions on a file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 用户标识一个可以拥有文件和进程的帐户，而组是在文件上共享权限的机制。
- en: '**What''s the scope of the Unix permission model?**'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unix权限模型的范围是什么？
- en: 'The Unix permission model enables the restriction of access to a file with
    three different levels of power: owner, group, and all other users.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Unix权限模型使得可以通过三种不同级别的权限来限制对文件的访问：所有者、组和所有其他用户。
- en: '**Can you explain the difference between signals and exit codes?**'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能解释一下信号和退出代码之间的区别吗？
- en: Signals and exit codes are both methods of communication between processes,
    but whereas a signal is from any process to another, exit codes are used to communicate
    from a child to its parent.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和退出代码都是进程之间的通信方法，但信号是从任何进程到另一个进程，而退出代码用于从子进程到其父进程的通信。
- en: '**What''s a swap file?**'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是交换文件？
- en: A swap file is an extension of the physical memory that is used to store pages
    that are not required in order to free up the main memory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 交换文件是用于存储不需要的页面以释放主内存的物理内存的扩展。
- en: Chapter 3
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: '**What''s the difference between an exported and an unexported symbol?**'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出符号和未导出符号有什么区别？
- en: Exported symbols can be used by other packages, whereas unexported symbols cannot.
    The first group has an identifier that starts with a capital letter, while the
    second group does not.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 导出符号可以被其他软件包使用，而未导出符号不能。第一组具有以大写字母开头的标识符，而第二组没有。
- en: '**Why are custom types important?**'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义类型为什么重要？
- en: Custom types allow methods to be defined and interfaces to be used effectively,
    or the data structure of another type to be inherited, but getting rid of its
    methods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型允许定义方法并有效地使用接口，或者继承另一种类型的数据结构，但是要摆脱它的方法。
- en: '**What is the main limit of a short declaration?**'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 短声明的主要限制是什么？
- en: Short declarations do not allow the variable type inferred by the value to be
    defined. A type casting of the value enables this limitation to be overcome.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 短声明不允许推断出值的变量类型。通过对值进行类型转换，可以克服这种限制。
- en: '**What is scope and how does it affect variable shadowing?**'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作用域是什么，它如何影响变量遮蔽？
- en: The scope of a variable represents its lifetime and visibility that can be package,
    function, or blocked. Shadowing is when the same identifier gets used in an inner
    scope, preventing access to the symbol that shares that identifier by an outer
    scope.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域代表了它的生命周期和可见性，可以是包、函数或块。当相同的标识符在内部作用域中使用时，会发生遮蔽，阻止外部作用域共享该标识符的符号访问。
- en: '**How can you access a method?**'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何访问一个方法？
- en: Methods are special types of functions that have a namespace linked to the type
    they belong to. They can be accessed as a property of an instance of their type,
    or as a property of the type itself, passing the instance as a first argument.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是一种特殊类型的函数，它们具有与其所属类型相关联的命名空间。它们可以作为其类型实例的属性访问，也可以作为类型本身的属性访问，将实例作为第一个参数传递。
- en: '**Explain the difference between a series of** `if`/`else` **statements** **and
    a** `switch` **statement**.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释一下一系列`if`/`else`语句和`switch`语句之间的区别。
- en: A series of `if` and `else` statements allow the execution of a short declaration
    for each `if` statement and will execute only one of the cases, skipping the following
    declarations. A `switch` statement allows only one declaration, and can modify
    the flow using `continue` and `break` statements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列的`if`和`else`语句允许对每个`if`语句执行一个简短的声明，并且只会执行一个case，跳过后续的声明。`switch`语句只允许一个声明，并且可以使用`continue`和`break`语句修改流程。
- en: '**In a typical use case, who is generally responsible for closing a channel?**'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在典型的用例中，通常谁负责关闭通道？
- en: Channels should always be closed by the sender, because that party is responsible
    for communicating that there is no more information to send. Also, sending to
    a closed channel throws a panic, while receiving from it is a non-blocking operation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通道应该由发送方关闭，因为发送方负责通知没有更多信息要发送。此外，向关闭的通道发送会引发恐慌，而从中接收是一个非阻塞操作。
- en: '**What is escape analysis?**'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是逃逸分析？
- en: Escape analysis is an optimization process performed by the Go compiler that
    attempts to reduce the variables allocated in the heap by verifying whether they
    outlive the function where they are defined.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 逃逸分析是Go编译器执行的优化过程，试图通过验证变量是否超出了它们定义的函数的生存期来减少在堆中分配的变量。
- en: Chapter 4
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: '**What''s the difference between absolute and relative paths?**'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绝对路径和相对路径有什么区别？
- en: An absolute path starts with the `/` (root) path, while a relative path does
    not. To obtain an absolute path from a relative one, it must be joined to the
    current working directory.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径以`/`（根）路径开头，而相对路径不是。要从相对路径获取绝对路径，必须将其连接到当前工作目录。
- en: '**How do you obtain or change the current working directory?**'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何获取或更改当前工作目录？
- en: To find out the current working directory, the `os` package offers the `Getwd` function,
    which returns the current working directory. To change the current working directory,
    the `Chdir` function must be used. It accepts both relative and absolute paths.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出当前工作目录，`os`包提供了`Getwd`函数，它返回当前工作目录。要更改当前工作目录，必须使用`Chdir`函数。它接受相对路径和绝对路径。
- en: '**What are the advantages and downfalls of using `ioutil.ReadAll`?**'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ioutil.ReadAll`的优缺点是什么？
- en: The `ioutil.ReadAll` function places the entire file contents in a byte slice,
    so the size of file influences the amount of memory allocated, and then released.
    Since there is no recycling of the memory allocated this way, these slices get
    garbage-collected when they are no longer used.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ioutil.ReadAll`函数将整个文件内容放入一个字节切片中，因此文件的大小会影响分配和释放的内存量。由于这种方式分配的内存没有回收利用，这些切片在不再使用时会被垃圾回收。'
- en: '**Why are buffers important for reading operations?**'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么对于读取操作来说，缓冲区很重要？
- en: Byte buffers limit the amount of memory allocated by the reading operations,
    but they also require a certain number of read operations, each one with a little
    overhead that impacts speed and performance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 字节缓冲区限制了读取操作分配的内存量，但它们也需要一定数量的读取操作，每个操作都带有一些影响速度和性能的开销。
- en: '**When should you use `ioutil.WriteFile`?** The `ioutil.WriteFile` function can
    be used if the size of the content is not too big, because the entire content
    needs to be in memory. It is also preferable to use it in short-lived applications
    and avoid it for recurrent writing operations.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用`ioutil.WriteFile`？如果内容的大小不是太大，可以使用`ioutil.WriteFile`函数，因为整个内容需要在内存中。在短期应用中最好使用它，并且避免在频繁写入操作中使用它。
- en: '**Which operations are available when using a buffered reader that allows peeking?**'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用允许窥视的缓冲区读取时可以进行哪些操作？
- en: The peeking operation allows the content of the next bytes to be checked without
    advancing the cursor of the current reader, and this enables us to have contextual
    operations, such as read word, read line, or any custom token-based operation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 窥视操作允许检查下一个字节的内容，而不会推进当前读取器的光标，这使我们能够进行上下文操作，例如读取单词、读取行或任何基于自定义标记的操作。
- en: '**When is it better to read content using a byte buffer?**'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时最好使用字节缓冲区读取内容？
- en: Using a reading buffer is a way of lowering the memory usage of your application.
    It can be used when there's no need to have all the content at once.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用读取缓冲区是降低应用程序内存使用的一种方式。当不需要一次性获取所有内容时，可以使用它。
- en: '**How can buffers be used for writing? What''s the advantage of using them?**'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**缓冲区如何用于写入？使用它们的优势是什么？**'
- en: In writing operations, the application already handles the bytes that are about
    to be written, so an underlying buffer is used to optimize the number of system
    calls, only when the buffer is full, so as to avoid the addition of system call
    overheads when the data passed to the writer is not enough.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入操作中，应用程序已经处理了即将写入的字节，因此使用底层缓冲区来优化系统调用的次数，只有当缓冲区满时才会进行系统调用的添加，以避免在传递给写入器的数据不足时增加系统调用开销。
- en: Chapter 5
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: '**What''s a stream?**'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是流？**'
- en: A stream is an abstraction that represents a generic flow of incoming or outgoing
    data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 流是表示通用传入或传出数据流的抽象。
- en: '**What interfaces abstract the incoming streams?**'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪些接口抽象了传入流？**'
- en: The `io.Reader` interface is an abstraction for incoming streams.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Reader`接口是用于传入流的抽象。'
- en: '**Which interface represents the outgoing streams?**'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪个接口代表传出流？**'
- en: The `io.Writer` interface is an abstraction for outgoing streams.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Writer`接口是用于传出流的抽象。'
- en: '**When should a byte reader be used? When should a string reader be used instead?**'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**何时应该使用字节读取器？何时应该使用字符串读取器？**'
- en: A byte reader should be used when the raw data is a slice of bytes, while a
    string reader should be used with strings. Converting from one type of data to
    another causes a copy and is inconvenient.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当原始数据是字节片时应该使用字节读取器，而当原始数据是字符串时应该使用字符串读取器。从一种数据类型转换为另一种会导致复制并且不方便。
- en: '**What''s the difference between a string builder and a byte buffer?**'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字符串构建器和字节缓冲区有什么区别？**'
- en: A byte buffer can be reused and overwritten. A string builder is used to create
    a string without a copy, so it uses a byte slice and converts it to a string without
    copying, using the `unsafe` package.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 字节缓冲区可以被重用和覆盖。字符串构建器用于创建一个字符串而不是复制，因此它使用一个字节切片并将其转换为字符串而不复制，使用`unsafe`包。
- en: '**Why should reader and writer implementations accept an interface as input?**'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么读取器和写入器的实现应该接受接口作为输入？**'
- en: Accepting an interface as an input means to be open to different types with
    the same behavior. This enables existing readers and writers, such as buffers
    and files, to be used.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接受接口作为输入意味着对具有相同行为的不同类型持开放态度。这使得现有的读取器和写入器，如缓冲区和文件，可以被使用。
- en: '**How does a pipe differ from** `TeeReader`**?**'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**管道与** `TeeReader` **有何不同？**'
- en: A pipe connects a writer to a reader. Whatever gets written in the writer gets
    read by the reader. A `TeeReader` does the opposite, connecting a reader to a
    writer, so what gets read is also written somewhere else.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 管道将写入器连接到读取器。无论写入了什么，读取器都会读取。`TeeReader`则相反，将读取器连接到写入器，因此读取的内容也会被写入到其他地方。
- en: Chapter 6
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: '**What is a Terminal, and what is a pseudo-terminal?** A terminal is an application
    that behaves like a teletype, by displaying a 2 x 2 matrix of characters. Pseudo
    terminals are applications that run under a terminal and emulate its behavior
    by being interactive.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是终端，什么是伪终端？** 终端是一个行为类似于电传打字机的应用程序，通过显示一个2x2的字符矩阵。伪终端是在终端下运行并通过交互来模拟其行为的应用程序。'
- en: '**What should a pseudo terminal be able to do?** A pseudo terminal application
    should be able to receive input from a user, execute an action according to the
    instruction received, and display the result back to the user.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**伪终端应该具备什么功能？** 伪终端应用程序应该能够接收用户输入，根据接收到的指令执行操作，并将结果显示给用户。'
- en: '**What Go tools did we use in order to emulate a terminal?** To manage user
    input, we used a buffered scanner in standard input, which will read user input
    line by line. Each command has been implemented using the same interface. To understand
    the command invoked, we used a comparison between the first argument and the commands
    available. A writer is passed to command to print their output.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们使用了哪些Go工具来模拟终端？** 为了管理用户输入，我们在标准输入中使用了一个缓冲扫描器，它将逐行读取用户输入。每个命令都是使用相同的接口实现的。为了理解调用的命令，我们使用了第一个参数和可用命令之间的比较。一个写入器被传递给命令来打印它们的输出。'
- en: '**How can my application get instructions from the standard input?** The application
    can use the standard input combined with a scanner that will return a new token
    each time it encounters a new line.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我的应用程序如何从标准输入获取指令？** 应用程序可以使用标准输入结合扫描器，每次遇到新行时都会返回一个新的标记。'
- en: '**What is the advantage of using interfaces for commands?** Using interfaces
    for commands allows us and the user of our package to expand the behavior by implementing
    their own version of the interface.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用接口命令有什么优势？** 使用接口命令允许我们和我们包的用户通过实现他们自己的接口版本来扩展行为。'
- en: '**What is the Levenshtein distance? Why can it be useful in pseudo-terminals?**
    The Levenshtein distance is the number of changes required to transform a string
    into another. It can useful for suggesting other commands to the user when they
    specify a non-existing one.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是莱文斯坦距离？为什么在伪终端中有用？** 莱文斯坦距离是将一个字符串转换为另一个字符串所需的更改次数。当用户指定一个不存在的命令时，它可以用于向用户建议其他命令。'
- en: Chapter 7
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: '**What applications are available for the current process inside a Go application?**'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go应用程序内部的当前进程可用的应用程序有哪些？
- en: The applications available for a process are PID (process ID), PPID (parent
    PID), UID and GID (user and group ID), and the working directory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可用的应用程序有PID（进程ID）、PPID（父进程ID）、UID和GID（用户和组ID）以及工作目录。
- en: '**How do you create a child process?**'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何创建子进程？**'
- en: The `exec.Cmd` data structure can be used to define a child process. The process
    gets created when one of the `Run`, `Start`, `Output`, and `CombinedOutput` methods gets
    called.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec.Cmd`数据结构可用于定义子进程。当调用`Run`、`Start`、`Output`和`CombinedOutput`方法之一时，进程将被创建。'
- en: '**How do you ensure that a child process survives its parent?**'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何确保子进程在其父进程之后继续存在？**'
- en: By default in Unix systems, a child survives if the parent terminates. Additionally,
    you can change the process group and session ID of the child in order to ensure
    that it survives the parent.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix系统中，默认情况下，如果父进程终止，子进程会继续存在。此外，您可以更改子进程的进程组和会话ID，以确保其继续存在。
- en: '**Can you access child properties? How can they be used?**'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以访问子属性吗？它们如何使用？
- en: One of the biggest advantages is to access the child PID to persist it somewhere,
    such as on the disk. This will allow another instance of the application, or any
    other application, to know which is the identifier of the child and verify whether
    it's still running.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的优势之一是访问子PID以将其持久化在某个地方，例如磁盘上。这将允许应用程序的另一个实例或任何其他应用程序知道子进程的标识符，并验证它是否仍在运行。
- en: '**What''s a daemon in Linux and how are they handled?**'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Linux中，守护进程是什么，它们是如何处理的？
- en: A daemon in Linux is a process that is running in the background. In order to
    create a daemon, a process can create a fork of itself and terminate, set the
    `init` process to be the parent of the fork, set the current working directory
    to root for the fork, setting the input of the child to `null`, and use log files
    for output and error.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，守护进程是在后台运行的进程。为了创建一个守护进程，进程可以创建自身的一个分支并终止，将`init`进程设置为分支的父进程，将当前工作目录设置为分支的根目录，将子进程的输入设置为`null`，并使用日志文件进行输出和错误处理。
- en: Chapter 8
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: '**What''s an exit code? Who makes use of it?**'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出代码是什么？谁使用它？
- en: The exit code is an integer value passed from a process to is parent to signal
    when the process ends. It represents the outcome of the process, and it is `0`
    if there have been no errors. The parent process can use this value to decide
    what to do next, such as running the process again if there is an error.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 退出代码是从进程传递给其父进程的整数值，用于表示进程结束的结果。如果没有错误，则为`0`。父进程可以使用此值决定下一步该做什么，例如，如果出现错误，则再次运行进程。
- en: '**What happens when an application panics? What exit code is returned?**'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序发生panic时会发生什么？返回什么退出代码？
- en: If  `panic` is not recovered, the application will execute all the deferred
    functions and will exit with a status of `2`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`panic`没有被恢复，应用程序将执行所有延迟函数，并以状态`2`退出。
- en: '**What''s the default behavior of a Go application when receiving all signals?**'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go应用程序在接收所有信号时的默认行为是什么？
- en: The default behavior of a Go application with signals is an early exit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Go应用程序在处理信号时的默认行为是早期退出。
- en: '**How do you intercept signals and decide how the application must behave?**'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何拦截信号并决定应用程序的行为？
- en: The signals received can be intercepted using the `signal.Notify` method on
    a channel, specifying the type of signals that you want to handle. The values
    received by the channel can be compared to signal values, and the application
    can behave accordingly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`signal.Notify`方法在通道上拦截接收到的信号，指定要处理的信号类型。通道接收到的值可以与信号值进行比较，并相应地应用程序可以表现出不同的行为。
- en: '**Can you send signals to other processes? If so, how?**'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能向其他进程发送信号吗？如果可以，怎么做？
- en: It is possible to send signals to another process inside a Go application. In
    order to do so, the application needs to acquire an instance of the `os.Process`
    structure using a lookup function, and then it can use the `Signal` method of
    the structure to send a signal.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go应用程序中，可以向另一个进程发送信号。为了做到这一点，应用程序需要使用查找函数获取`os.Process`结构的实例，然后可以使用该结构的`Signal`方法发送信号。
- en: '**What are pipes and why are they important?**'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道是什么，它们为什么重要？
- en: Pipes are two streams, one of output and the other of input, connected together.
    What's written in the output is available to the input, and this facilitates the
    connection of one process output to another process input.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是两个流，一个是输出流，另一个是输入流，它们连接在一起。输出中写入的内容可以在输入中使用，这有助于将一个进程的输出连接到另一个进程的输入。
- en: Chapter 9
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: '**What''s the advantage of using communication models?**'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用通信模型的优势是什么？
- en: Communication models allow you to abstract the type of data handled with your
    model, making the communications between different endpoints easy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通信模型允许您抽象处理模型中处理的数据类型，使不同端点之间的通信变得容易。
- en: '**What''s the difference between a TCP and a UDP connection?**'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP和UDP连接之间有什么区别？
- en: TCP is connection oriented—this makes it reliable because it verifies that the
    destination receives data correctly before sending new data. A UDP connection
    sends data continuously, without acknowledging that the destination received the
    package. This can cause package loss, but it makes the connection faster and does
    not accumulate latency.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: TCP是面向连接的，这使得它可靠，因为它在发送新数据之前验证目标是否正确接收数据。UDP连接持续发送数据，而不确认目标是否接收了数据包。这可能导致数据包丢失，但它使连接更快，不会积累延迟。
- en: '**Who closes the request body when sending requests?**'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求时，谁关闭请求体？
- en: Closing the request when making an HTTP call is the responsibility of the application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行HTTP调用时关闭请求是应用程序的责任。
- en: '**Who closes the body when receiving requests in the server?**'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器接收请求时，谁关闭请求体？
- en: The request body is closed automatically when the connection is closed, but
    the server can close it even earlier if it so desires.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接关闭时，请求体会自动关闭，但服务器也可以在更早的时候关闭它，如果它愿意的话。
- en: Chapter 10
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: '**What''s the trade-off between text and binary encodings?**'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本和二进制编码之间的权衡是什么？
- en: Text-based encodings are easier to read for a human, as well as easier to debug
    and write, but they take more space because of it. Binary encodings are difficult
    to write, read, and debug for a human, but smaller in size.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文本的编码对人类来说更容易阅读，也更容易调试和编写，但由于这个原因占用更多的空间。二进制编码对人类来说更难编写、阅读和调试，但尺寸更小。
- en: '**How does Go behave with a data structure by default when encoding?**'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go在编码时默认如何处理数据结构？
- en: The default behavior of Go is to use reflection in order to read the fields
    and their values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Go的默认行为是使用反射来读取字段及其值。
- en: '**How can this behavior be changed?**'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种行为如何改变？
- en: This behavior can be changed by implementing the marshaller interface of the
    encoding you are using, such as `json.Marshaller` for JSON.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现你正在使用的编码的编组器接口，如`json.Marshaller`用于JSON，可以改变这种行为。
- en: '**How does a structure field get encoded in an XML attribute?**'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结构字段如何在XML属性中编码？**'
- en: The struct field needs to specify the `,attr` value in its tag.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 结构字段需要在其标签中指定`,attr`值。
- en: '**What operation is required to decode a** `gob` **interface value?**'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码`gob`接口值需要什么操作？
- en: The data types that implement the interface need to be registered in the `gob`
    package using the `gob.Register` function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实现接口的数据类型需要使用`gob.Register`函数在`gob`包中注册。
- en: '**What is the protocol buffer encoding?** The protocol buffer is an encoding
    protocol made by Google that uses a definition file for data structures and services.
    The file is used to generate data models, clients, and server stubs, leaving only
    the implementation of the server to the developer.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是协议缓冲编码？**协议缓冲是由谷歌制定的一种编码协议，它使用定义文件来定义数据结构和服务。该文件用于生成数据模型、客户端和服务器存根，只留下服务器的实现给开发人员。'
- en: Chapter 11
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: '**What is a thread and who is responsible for it?**'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是线程，谁负责它？**'
- en: A thread is a part of a process that can be assigned by a specific core or CPU.
    It carries information about the state of the application, like a process does,
    and is managed by the operating system scheduler.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是进程的一部分，可以由特定的核心或CPU分配。它携带有关应用程序状态的信息，就像进程一样，并由操作系统调度程序管理。
- en: '**How do goroutines differ from threads?**'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**goroutine与线程有什么不同？**'
- en: Goroutines are tiny in size compared to threads, with a 1 to 100 ratio, and
    they are not managed by the operating system. The Go runtime takes care of the
    scheduling of goroutines.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程相比，goroutine非常小，比例为1:100，并且它们不受操作系统管理。Go运行时负责调度goroutine。
- en: '**When are arguments evaluated when launching a goroutine?**'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在启动goroutine时何时评估参数？**'
- en: All the arguments passed to the function that starts the goroutine are evaluated
    when the goroutine is created. This means that if the value of the argument changes
    before the goroutine actually gets picked up by the scheduler and starts, the
    change is not going to be reflected in the goroutine.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 启动goroutine的函数传递的所有参数在创建goroutine时进行评估。这意味着如果参数的值在goroutine实际被调度程序选中并启动之前发生变化，那么这种变化不会反映在goroutine中。
- en: '**How do buffered and non-buffered channels differ?**'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**缓冲和非缓冲通道有什么不同？**'
- en: A non-buffered channel is created by the `make` function if no capacity is specified,
    or if it's `0`. Each send operation to such a channel will block the current goroutine,
    until a receive operation is performed by another goroutine. A buffered channel
    can support a number of non-blocking send operations equal to its capacity. This
    means that if a channel has a capacity of `n`, the first `n-1` send operations
    that are not matched by any receive operation will not be blocking.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定容量，或者为`0`，则`make`函数创建非缓冲通道。对这样的通道的每次发送操作都会阻塞当前的goroutine，直到另一个goroutine执行接收操作。缓冲通道可以支持等于其容量的非阻塞发送操作数量。这意味着如果通道的容量为`n`，那么前`n-1`个未被任何接收操作匹配的发送操作将不会阻塞。
- en: '**Why are one-way channels useful?**'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么单向通道有用？**'
- en: They allow just a subset of operations, making clear to the user what the scope
    of the channel is. A receive-only channel does not allow data to be sent, or to
    close it, and that makes perfect sense because it is not the responsibility of
    the receiver. A send-only channel does not allow the receipt of data, but allows
    it to be sent and to close the channel, with an implicit statement that it is
    up to the sender to close the channel to signal that there is no more data.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 它们只允许一部分操作，清楚地告诉用户通道的范围。只接收通道不允许发送数据，或关闭它，这是有道理的，因为这不是接收者的责任。只发送通道不允许接收数据，但允许发送和关闭通道，并暗示发送者关闭通道以表示没有更多数据。
- en: '**What happens when operations are executed on** `nil` **or closed channels?**'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当对`nil`或关闭的通道执行操作时会发生什么？**'
- en: Sending to, or receiving from, a `nil` channel blocks forever, and closing it
    creates panics. Receiving from a closed channel returns a zero value immediately,
    and `false`, while sending to a closed channel raises a panic and the same thing
    happens if we try to close it again.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 向`nil`通道发送或接收会永久阻塞，关闭它会导致恐慌。从关闭的通道接收会立即返回零值和`false`，而向关闭的通道发送会引发恐慌，如果再次尝试关闭它也会发生相同的情况。
- en: '**What are timers and tickers used for?**'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计时器和滴答器用于什么？**'
- en: Timers and tickers both create a receive-only channel. Timers can be used in
    a loop with a `select` statement, instead of using `default`, in order to reduce
    the frequency of the selection and lower the CPU usage of the application when
    it is idle. Tickers are very useful for executing an operation every fixed period
    of time, while one practical usage is a rate limiter, which limits the number
    of executions over a set period of time in a certain segment of an application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器和滴答器都创建一个只接收通道。计时器可以在循环中与`select`语句一起使用，而不是使用`default`，以减少选择的频率并降低应用程序在空闲时的CPU使用率。滴答器非常适用于在固定时间间隔内执行操作，而一个实际的用途是速率限制器，它限制了在应用程序的某个部分内在一定时间段内执行的次数。
- en: Chapter 12
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: '**What''s a race condition?**'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是竞争条件？**'
- en: A race condition is a situation where an application tries to execute two operations
    on the same resource at the same time, and the nature of the resource only allows
    one operation at time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件是应用程序试图同时在同一资源上执行两个操作的情况，而资源的性质只允许一次操作。
- en: '**What happens when you try to execute read and write operations concurrently
    with a map?**'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当尝试在映射上同时执行读取和写入操作时会发生什么？**'
- en: When reading and writing operations on a map happen simultaneously, this causes
    a runtime error: `concurrent map writes`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当同时发生对映射的读取和写入操作时，会导致运行时错误：`concurrent map writes`。
- en: '**What''s the difference between** `Mutex` **and** `RWMutex`**?**'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`Mutex`**和**`RWMutex`**之间有什么区别？'
- en: A regular mutex allows a resource to be locked and unlocked, and each operation
    has the same priority. A read/write mutex has two types of locks, one for each
    operation (read/write). The read lock allows more than one operation at time,
    while it is exclusive. Write locks could be subject to a delay if there are many
    continuous read operations on the resource. This is known as write starvation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 常规互斥锁允许锁定和解锁资源，并且每个操作的优先级相同。读/写互斥锁有两种类型的锁，一种用于每个操作（读/写）。读锁允许同时进行多个操作，同时它是排他的。如果资源上有许多连续的读操作，写锁可能会受到延迟。这被称为写饥饿。
- en: '**Why are wait groups useful?**'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等待组有什么用？**'
- en: Wait groups are the perfect tool to synchronize with the execution of different
    goroutines. This enables a clean and elegant solution to the classic setting,
    where there are several concurrent operations, and a main goroutine has to wait
    for them to end before moving on.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 等待组是与不同goroutine的执行同步的完美工具。这使得在经典设置中有多个并发操作时，主goroutine必须等待它们结束才能继续的解决方案变得干净而优雅。
- en: '**What''s the main use of** `sync.Once`**?**'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`sync.Once`**的主要用途是什么？'
- en: '`sync.Once` can be used to execute a concurrent operation on one occasion.
    It can be used to close a channel once and avoid panics, for instance. Another
    use case is the lazy initialization of a variable to implement a thread-safe version
    of the singleton design pattern.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Once`可用于在一次性执行并发操作。例如，它可用于一次关闭通道并避免恐慌。另一个用例是延迟初始化变量以实现单例设计模式的线程安全版本。'
- en: '**How can you use a pool?**'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何使用池？**'
- en: A pool allows short-lived items to be reused. A good use case for pools is byte
    slices and byte buffers, because the pool will prevent this resource from being
    recycled by the garbage collector, while preventing the allocation of new pools.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 池允许重复使用短暂的项目。池的一个很好的用例是字节片和字节缓冲区，因为池将防止这些资源被垃圾收集器回收，同时防止分配新的池。
- en: '**What''s the advantage of using atomic operations?**'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用原子操作的优势是什么？**'
- en: Using a mutex for numeric variables has a lot of overhead. Atomic operations
    allow such overheads to be reduced and thread-safe operations to be executed on
    numeric variables. Its main use is for integer numbers, but, with some transformation,
    we can do the same for other types, such as Booleans and floats.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数字变量使用互斥锁会有很大的开销。原子操作可以减少这种开销，并在数字变量上执行线程安全操作。它的主要用途是整数，但通过一些转换，我们可以对其他类型进行相同的操作，例如布尔值和浮点数。
- en: Chapter 13
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: '**What is context in Go?**'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Go中的上下文是什么？**'
- en: Context is a package that contains a generic interface and some auxiliary functions
    to return context instances. It is used to synchronize operations between various
    parts of the application and to carry values.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文是一个包，包含一个通用接口和一些辅助函数来返回上下文实例。它用于在应用程序的各个部分之间同步操作和携带值。
- en: '**What''s the difference between cancellation, deadline, and timeout?**'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**取消、截止日期和超时之间有什么区别？**'
- en: There are three different types of expiration for a context—cancellation is
    an explicit call to a cancellation function by the application, deadline is when
    the context goes over a specified time, and timeout is when the context survives
    a specific duration.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文有三种不同类型的过期——取消是应用程序显式调用取消函数，截止日期是上下文超过指定时间，超时是上下文经历特定持续时间。
- en: '**What are the best practices when passing values with a context?**'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**传递上下文值时的最佳实践是什么？**'
- en: Values passed around with context should be relative to the current scope or
    request. They should not be used as a way of passing around optional function
    parameters or variables that are essential to the application. It is also a good
    idea to use custom private types as keys, because built-in values can be overridden
    by other packages. Pointers to values are also a solution to such a problem.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文传递的值应与当前范围或请求相关。它们不应该被用作传递可选函数参数或对应用程序至关重要的变量的方式。使用自定义私有类型作为键也是一个好主意，因为内置值可能被其他包覆盖。指向值的指针也是解决此类问题的一种方法。
- en: '**Which standard packages already use context?**'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪些标准包已经使用了上下文？**'
- en: There are different packages that use context. The most notable are `net/http` ,
    which uses context for requests and for server shutdown; `net`, which uses context
    for functions such as `Dial` or `Listen`; and `database/sql`, which uses the context
    as a way to cancel operations such as queries.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的包使用上下文。最值得注意的是`net/http`，它使用上下文进行请求和服务器关闭；`net`使用上下文进行`Dial`或`Listen`等功能；`database/sql`使用上下文来取消查询等操作。
- en: Chapter 14
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: '**What is a generator? What are its responsibilities?**'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成器是什么？它的责任是什么？**'
- en: A generator is a tool that returns a series of values—it returns the next value
    in the series each time it is called. It's responsible for generating values in
    the sequence on demand. In Go, this can be done by using a channel to receive
    the values that are sent through by a goroutine that creates them.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一个返回一系列值的工具——每次调用时，它返回系列中的下一个值。它负责按需生成序列中的值。在Go中，可以通过使用通道来接收由创建它们的goroutine发送的值来实现这一点。
- en: '**How would you describe a pipeline?**'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你会如何描述一个管道？**'
- en: A pipeline is a type of application flow that splits the execution into different
    stages. These stages communicate with one another by using a certain means of
    communication, such as networks, or runtime internals, such as channels.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一种将执行分割成不同阶段的应用程序流程。这些阶段通过某种通信方式进行通信，例如网络，或者运行时内部，例如通道。
- en: '**What type of stage gets a channel and returns one?**'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么类型的阶段获取一个通道并返回一个？**'
- en: An intermediate stage will receive from a receive-only channel and return another
    receive-only channel.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 中间阶段将从一个只接收通道接收并返回另一个只接收通道。
- en: '**What is the difference between fan-in and fan-out?**'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扇入和扇出之间有什么区别？**'
- en: Fan-in is also known as demultiplexing, and entails gathering messages from
    different sources into one. Fan-out, or multiplexing, is the opposite—it entails
    splitting a single source of a message to more receivers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Fan-in也被称为分集，它涉及从不同来源收集消息到一个地方。Fan-out，或多路复用，是相反的——它涉及将单个消息源分发给更多的接收者。
- en: Chapter 15
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章
- en: '**What''s the memory representation of an interface in Go?**'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Go中，接口的内存表示是什么？
- en: An interface in Go is represented by two values—the first one is the interface
    concrete type, while the second is the value for such a type.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，接口由两个值表示——第一个是接口的具体类型，而第二个是该类型的值。
- en: '**What happens when an interface type is casted to another one?**'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接口类型转换为另一个接口类型时会发生什么？
- en: Since interface values need to be a concrete value, and cannot be another interface,
    a new interface is created with a different type and the same concrete value.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接口值需要是一个具体的值，而不能是另一个接口，所以会创建一个具有不同类型和相同具体值的新接口。
- en: '**What are** `Value`**,** `Type`**, and** `Kind` **in reflection?**'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在反射中，`Value`，`Type`和`Kind`是什么？
- en: A `Value`, as the name suggests, represents the content of a variable; a `Type`
    represents the Go type of a variable; and `Kind` is the memory representation
    of a `Type` and refers only to built-in types.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`Value`代表变量的内容；`Type`代表变量的Go类型；`Kind`是`Type`的内存表示，仅指内置类型。
- en: '**What does it mean that a value is addressable?**'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值是可寻址的意味着什么？
- en: An addressable value is a value that can be edited because it has been obtained
    by a pointer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可寻址值是可以被编辑的值，因为它是通过指针获得的。
- en: '**Why are structure field tags important in Go?**'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么Go中的结构字段标签很重要？
- en: Structure field tags are an easy way to add extra information about a structure
    field that is easy to read, using the reflection `Type` interface.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 结构字段标签是一种简单的方法，可以使用反射`Type`接口添加关于结构字段的额外信息，这样做很容易阅读。
- en: '**What''s the general trade-off of reflection?**'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反射的一般权衡是什么？
- en: Reflection allows your code to deal with unknown types of data and make your
    package or application generic, but it comes with an overhead that has a performance
    cost. It also makes code more obscure and less maintainable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 反射允许您的代码处理未知类型的数据，并使您的包或应用程序通用化，但它会带来性能成本。它还使代码更加晦涩和难以维护。
- en: '**Could you describe a good approach when using reflection?**'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能描述在使用反射时的一个良好方法吗？
- en: The best approach to reflection is the one that we find in many different parts
    of the standard library; for instance, in the `encoding` packages. They use reflection
    as a last resort, and they do so by providing interfaces for encoding and decoding
    operations. If these interfaces are satisfied by a type, the package will use
    the respective methods instead of relying on reflection.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 反射的最佳方法是我们在标准库的许多不同部分找到的方法；例如，在`encoding`包中。它们将反射作为最后的手段，并通过为编码和解码操作提供接口来实现。如果这些接口由某种类型满足，包将使用相应的方法，而不是依赖于反射。
- en: Chapter 16
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章
- en: '**What is CGO?**'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CGO是什么？
- en: CGO is a powerful Go tool that handles communication between C code and Go code.
    This allows C code to be used in a Go application and to leverage the huge amount
    of existing C libraries.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: CGO是一个强大的Go工具，用于处理C代码和Go代码之间的通信。这允许C代码在Go应用程序中使用，并利用现有的大量C库。
- en: '**How can you call C code from Go?**'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从Go调用C代码？
- en: Go offers a pseudo package called `C` that exposed C types, such as `C.int`,
    and some functions that will convert Go strings and bytes into `C` character arrays,
    and vice versa. The comment that comes before the import `C` package will be interpreted
    as C code, and all the functions defined in it ( be it directly, or by importing
    files), will be available in Go as functions of the `C` package.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个名为`C`的伪包，暴露了C类型，如`C.int`，以及一些函数，将Go字符串和字节转换为`C`字符数组，反之亦然。在导入`C`包之前的注释将被解释为C代码，并且其中定义的所有函数（无论是直接定义还是通过导入文件）都将作为`C`包的函数在Go中可用。
- en: '**How can you use Go code in C?**'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在C中使用Go代码？
- en: If a Go function is preceded by a special comment, `//export`, this function
    will be available to the C code. It will also have to be defined as an external
    function in C.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Go函数前面有一个特殊的注释`//export`，这个函数将对C代码可用。它还必须在C中定义为外部函数。
- en: '**What are the differences in data types between Go and C?**'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go和C之间的数据类型有什么区别？
- en: Even if they have different data types, C and Go share most of their built-in
    numeric types. Strings in Go are a built-in immutable type, but in C, they are
    just a character array terminated by a `\0` value.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它们具有不同的数据类型，C和Go共享大部分内置的数字类型。Go中的字符串是一种内置的不可变类型，但在C中，它们只是以`\0`值终止的字符数组。
- en: '**How can you edit Go values inside C code?**'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在C代码中编辑Go值？
- en: Using the `unsafe` package, you can convert data types with the same memory
    representation in both C and Go. You need to convert the pointer to a value in
    its C counterpart, and this will allow you to edit the pointer content from the
    `C` part of the application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`unsafe`包，您可以将在C和Go中具有相同内存表示的数据类型进行转换。您需要将指针转换为其C对应值，这将允许您从应用程序的`C`部分编辑指针内容。
- en: '**What is the main problem associated with packed data structures?**'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧凑数据结构相关的主要问题是什么？
- en: Packed data structures save space in memory, but their fields can be unaligned,
    meaning that they are split between multiple memory zones. This means that read
    and write operations take twice as long. There is also another inconvenience—some
    of the packed fields are not directly accessible from Go.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 紧凑的数据结构可以节省内存空间，但它们的字段可能不对齐，这意味着它们分布在多个内存区域之间。这意味着读写操作需要两倍的时间。还有另一个不便之处——一些紧凑的字段无法直接从Go中访问。
- en: '**What are the main downfalls of CGO?**'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CGO的主要缺点是什么？
- en: Even if it is a very powerful tool, CGO has many downsides—the performance cost
    of passing from C to Go, and vice versa; the fact that the compiling time increases
    because the C compiler gets involved in the process; and that your Go code is
    reliant on your C code to work, which could be harder to maintain and debug.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它是一个非常强大的工具，CGO也有许多缺点——从C到Go的性能成本，反之亦然；编译时间增加，因为C编译器参与了这个过程；以及你的Go代码依赖于你的C代码工作，这可能更难以维护和调试。
