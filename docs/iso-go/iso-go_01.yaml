- en: Isomorphic Web Applications with Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go创建同构Web应用程序
- en: Isomorphic web applications, are applications where the web server and the web
    browser (the client), may share all, or some parts of the web application code. Isomorphic
    web applications allow us to reap maximum benefits from traditional web application
    architectures. They provide a better user experience, enhanced discoverability
    by search engines, and reduced operating costs by sharing parts of the web application
    code across environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 同构Web应用程序是指Web服务器和Web浏览器（客户端）可能共享Web应用程序代码的全部或部分。同构Web应用程序允许我们从传统Web应用程序架构中获得最大的好处。它们提供了更好的用户体验，通过搜索引擎增强了可发现性，并通过在不同环境中共享Web应用程序代码的部分来降低运营成本。
- en: Well-established businesses, such as Airbnb, Bloomberg, Capital One, Facebook,
    Google, Netflix, and Walmart have accepted isomorphic web application development,
    and with good reason—the financial bottom line.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 成熟的企业，如Airbnb、彭博社、Capital One、Facebook、谷歌、Netflix和沃尔玛已经接受了同构Web应用程序开发，并且有充分的理由——财务底线。
- en: 'A study by Walmart found that for every *1 second of improvement, they experienced
    up to a 2% increase in conversions*. In addition to that, they also found that
    for every *100 milliseconds of improvement, they grew incremental revenue by up
    to 1%*. Source: How Website Speed Affects Conversion Rates ([http://www.globaldots.com/how-website-speed-affects-conversion-rates/](http://www.globaldots.com/how-website-speed-affects-conversion-rates/)).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 沃尔玛的一项研究发现，他们每提高1秒的速度，就会增加2%的转化率。此外，他们还发现，每提高100毫秒的速度，就会增加1%的增量收入。来源：网站速度如何影响转化率（http://www.globaldots.com/how-website-speed-affects-conversion-rates/）。
- en: Isomorphic Go is the methodology to create isomorphic web applications using
    the Go programming language. In this book, we will explore, in-depth, the process
    of creating an isomorphic web application in Go.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 同构Go是使用Go编程语言创建同构Web应用程序的方法论。在本书中，我们将深入探讨使用Go创建同构Web应用程序的过程。
- en: 'This chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Why you should consider isomorphic Go for developing modern web applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该考虑使用同构Go来开发现代Web应用程序
- en: An overview of the traditional web application architectures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统Web应用程序架构概述
- en: An introduction to the isomorphic web application architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同构Web应用程序架构简介
- en: When to implement isomorphic web applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时实现同构Web应用程序
- en: What you should know before learning Isomorphic Go
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在学习同构Go之前你应该知道的事情
- en: Why Isomorphic Go?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择同构Go？
- en: There is no doubt that JavaScript is the current leading technology, in terms
    of market share and mindshare, for creating isomorphic web applications. On the
    client-side, JavaScript comes included with all the major web browsers. JavaScript
    can now, also exist on the server side, thanks to Node.js.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，JavaScript是当前领先的技术，就市场份额和思想份额而言，用于创建同构Web应用程序。在客户端，JavaScript已经包含在所有主要的Web浏览器中。由于Node.js的出现，JavaScript现在也可以存在于服务器端。
- en: 'If this is the case, then why should we focus our attention on Go for creating
    isomorphic web applications? The answer to this question is manifold. Consider
    the list of answers provided here, as an initial list, which is the starting point
    for our discussion:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样的话，那么为什么我们应该把注意力集中在使用Go来创建同构Web应用程序呢？这个问题的答案是多方面的。将这里提供的答案列表视为一个初始列表，这是我们讨论的起点：
- en: Go comes with type checking
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go具有类型检查
- en: Even the tech giants avoid Vanilla JavaScript
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是科技巨头也避免使用纯JavaScript
- en: Transpiling code to Vanilla JavaScript has become widely accepted
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码转换为纯JavaScript已经被广泛接受
- en: Go comes with a lot of benefits for front-end web development
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go对前端Web开发有很多好处
- en: Go comes with type checking
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go具有类型检查
- en: Go is a language that includes built-in static type checking. The immediate
    ramification of this fact is that many errors can be caught at compile time itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种包含内置静态类型检查的语言。这个事实的直接影响是，许多错误可以在编译时被捕获。
- en: The single-most pain point for many JavaScript developers is the lack of static
    type checking in JavaScript. Having personally worked in JavaScript code bases
    that have spanned several hundred thousand lines of code, I have seen first hand,
    how the most trivial bug can arise from the lack of static type checking.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对许多JavaScript开发人员来说，最大的痛点是JavaScript缺乏静态类型检查。我个人曾在跨越数十万行代码的JavaScript代码库中工作过，亲眼看到最微不足道的错误是如何由于缺乏静态类型检查而产生的。
- en: Avoiding Vanilla JavaScript with transpilers
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过转换器避免纯JavaScript
- en: To avoid writing Vanilla JavaScript, tech giants Microsoft and Google, have
    created TypeScript and Dart, respectively, as languages and transpilers. A **transpiler**
    is a source code to source code compiler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免编写纯JavaScript，科技巨头微软和谷歌分别创建了TypeScript和Dart作为语言和转换器。**转换器**是一种源代码到源代码的编译器。
- en: A compiler will turn human readable code, written in a programming language,
    into machine code. A transpiler is used to transform source code from one programming
    language into that of another language. The output may or may not be readable
    by a human, depending on the intent of the transpiler.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将人类可读的代码，写成一种编程语言，转换成机器代码。转换器用于将源代码从一种编程语言转换为另一种语言。输出可能或可能不可读取，这取决于转换器的意图。
- en: Languages, such as Typescript and Dart, get transpiled into Vanilla JavaScript
    code, so that they can be run in JavaScript-enabled web browsers. In the case
    of TypeScript, it's essentially a superset of JavaScript that introduces static
    type checking. The creators of the AngularJS Framework chose TypeScript over Vanilla
    JavaScript as the language of choice, to develop the next major version of their
    framework.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如TypeScript和Dart之类的语言被转换为纯JavaScript代码，以便在支持JavaScript的Web浏览器中运行。在TypeScript的情况下，它本质上是JavaScript的超集，引入了静态类型检查。AngularJS框架的创建者选择了TypeScript而不是纯JavaScript作为开发其框架下一个主要版本的语言。
- en: This approach to side stepping JavaScript, using an alternative programming
    language and a transpiler, creates a win-win situation for the developer. The
    developer is allowed to program in a programming language that is most productive
    for them and, at the end of the day, the code the developer created, is guaranteed
    to run in the web browser—thanks to the transpiler.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用另一种编程语言和转译器来规避JavaScript，为开发人员创造了双赢局面。开发人员可以使用对他们最有效的编程语言进行编程，而最终，开发人员创建的代码将得以在Web浏览器中运行——这要归功于转译器。
- en: Transpiling code
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转译代码
- en: Transpiling code to JavaScript, has become a widely accepted practice, even
    within the JavaScript community itself. For instance, the Babel transpiler allows
    developers to code in yet-to-be-released future standards of the JavaScript language,
    which get transpiled into the widely accepted standard JavaScript code that's
    currently supported in the major web browsers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码转译为JavaScript已经成为一种被广泛接受的做法，甚至在JavaScript社区内部也是如此。例如，Babel转译器允许开发人员编写尚未发布的JavaScript语言未来标准，将其转译为目前在主要Web浏览器中支持的标准JavaScript代码。
- en: Within this context, it is not outlandish, or far-fetched, to run Go programs,
    that get transpiled into JavaScript code, in the web browser. In fact, besides
    static type checking, there are many more benefits to be gained from being able
    to run Go on the front-end.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在Web浏览器中运行被转译为JavaScript代码的Go程序并不奇怪或牵强。事实上，除了静态类型检查之外，还有许多其他好处可以从能够在前端运行Go中获得。
- en: Benefits of Go on the front-end
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go在前端的好处
- en: 'Having Go available on the front-end comes with many advantages, including
    the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端使用Go具有许多优势，包括以下内容：
- en: A robust standard library
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个稳健的标准库
- en: Code modularization is easy with Go packages
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Go包进行代码模块化很容易
- en: Go comes with an implicit build system
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go附带了一个隐式构建系统
- en: Go's concurrency constructs allow us to avoid callback hell
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go的并发构造允许我们避免回调地狱
- en: The concept of concurrency comes built-in with Go
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发概念内置于Go中
- en: Go can be utilized for isomorphic web application development
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go可用于同构Web应用程序开发
- en: Robust standard library
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稳健的标准库
- en: Go comes with a robust standard library that provides a lot of powerful functionality
    out of the box. For instance, in Go, we can render an inline client-side template
    without having to include any third-party template library or framework. We will
    consider an example of how to do this in [Chapter 3](0f18d7dd-b081-4090-8b9c-c7a392261b31.xhtml),
    *Go on the Front-End with GopherJS*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Go附带了一个稳健的标准库，提供了许多强大的功能。例如，在Go中，我们可以渲染内联客户端模板，而无需包含任何第三方模板库或框架。我们将在[第3章](0f18d7dd-b081-4090-8b9c-c7a392261b31.xhtml)中考虑如何做到这一点，*使用GopherJS在前端上使用Go*。
- en: Promoting modularization using Go packages
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go包促进模块化
- en: Go has a powerful package implementation that promotes modularization, allowing
    for far greater code-reuse and maintainability. Also, the Go tool chain includes
    the `go get` command, which allows us to easily fetch official and third-party
    Go packages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Go具有强大的包实现，促进了模块化，允许更大程度的代码重用和可维护性。此外，Go工具链包括`go get`命令，允许我们轻松获取官方和第三方Go包。
- en: If you're coming from the JavaScript world, think of `go get` as a more simple,
    lightweight `npm` (`npm` is the Node Package Manager, a repository of third-party
    JavaScript packages).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自JavaScript世界，把`go get`想象成一个更简单、更轻量级的`npm`（`npm`是Node包管理器，一个第三方JavaScript包的存储库）。
- en: An implicit build system
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式构建系统
- en: In the JavaScript ecosystem, it is still popular, in modern times, for developers
    to spend their time manually creating and maintaining project build files. Being
    a modern programming language, Go ships with an implicit build system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript生态系统中，现代开发人员仍然流行手动创建和维护项目构建文件。作为一种现代编程语言，Go附带了一个隐式构建系统。
- en: As long as you follow Go's prescribed conventions, and once you issue the `go
    build` command for your Go application, the implicit build system kicks in. It
    will build and compile the Go project automatically by examining the dependencies
    it finds, within the application's Go source code itself. This provides a major
    productivity boost for the developer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 只要遵循Go的约定，并且一旦为Go应用程序发出`go build`命令，隐式构建系统就会启动。它将通过检查应用程序Go源代码中找到的依赖项，自动构建和编译Go项目。这为开发人员提供了重大的生产力提升。
- en: Avoiding callback hell
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免回调地狱
- en: Perhaps the most compelling reason to consider Go for isomorphic web development
    is to avoid *callback hell*. JavaScript is a single threaded programming language.
    When we want to delay the execution of a particular task after an asynchronous
    call has been made, we would place the code for those tasks inside a callback
    function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 也许考虑使用Go进行同构Web开发最具吸引力的原因是避免*回调地狱*。JavaScript是一种单线程编程语言。当我们想要在异步调用之后延迟执行特定任务时，我们会将这些任务的代码放在回调函数中。
- en: Soon enough, our list of tasks to delay for execution will grow, and the amount
    of nested callback functions will grow along with it. This situation is known
    as *callback hell*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们要延迟执行的任务列表将增长，嵌套回调函数的数量也将随之增长。这种情况被称为*回调地狱*。
- en: We can avoid callback hell in Go, using Go's built-in concurrency constructs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Go的内置并发构造来避免回调地狱。
- en: Concurrency
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: Go is a modern programming language designed to be relevant in an age of multicore
    processors and distributed systems. It was designed in a manner where the importance
    of concurrency was not treated as an afterthought.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种现代编程语言，旨在在多核处理器和分布式系统的时代保持相关性。它的设计并不是将并发的重要性作为事后的想法。
- en: 'In fact, concurrency was so important to the creators of Go, that they built
    concurrency right into the language itself. In Go, we can avoid callback hell,
    using Go''s built-in concurrency constructs: goroutines and channels. **Goroutines**
    are cheap, lightweight threads. **Channels**, are the conduits that allow for
    communication between goroutines.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，并发对于Go的创建者来说非常重要，以至于他们将并发直接构建到语言本身中。在Go中，我们可以避免回调地狱，使用Go的内置并发构造：goroutines和channels。**Goroutines**是廉价、轻量级的线程。**Channels**是允许goroutines之间通信的通道。
- en: Isomorphic web application development using Go
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go进行等同于Web应用程序开发
- en: When it comes to isomorphic web application development, JavaScript is no longer
    the only game in town. Due to recent technological advancements, notably the creation
    of **GopherJS**, we can now use the Go programming language on the front-end;
    this allows us to create isomorphic web applications in Go.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在等同于Web应用程序开发方面，JavaScript不再是唯一的选择。由于最近的技术进步，特别是**GopherJS**的创建，我们现在可以在前端使用Go编程语言；这使我们能够在Go中创建等同于Web应用程序。
- en: '**Isomorphic Go** is an emerging technology that provides us the essential
    ingredients needed to create isomorphic web applications, using the powerful and
    productive features that the Go programming language has to offer. In this book,
    we will use the functionality from Go''s standard library and third-party libraries
    from the Go community to implement an isomorphic web application.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**等同于Go**是一种新兴技术，它为我们提供了创建等同于Web应用程序所需的基本要素，利用了Go编程语言提供的强大和高效的功能。在本书中，我们将使用Go标准库的功能和Go社区的第三方库来实现等同于Web应用程序。'
- en: An overview of web application architectures
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序架构概述
- en: In order to understand and fully appreciate the architecture of isomorphic web
    applications, it's insightful to have an understanding of the web application
    architectures that preceded it. We will cover the major web application architectures
    that have been prevalent in the industry over the past 25 years.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解和充分欣赏等同于Web应用程序的架构，有必要了解其前身的Web应用程序架构。我们将介绍过去25年在行业中流行的主要Web应用程序架构。
- en: After all, we can't truly appreciate where we have arrived at, until we've fully
    acknowledged where we have been. With the monumental changes that have occurred
    in the web application architecture realm over the years, there is much to acknowledge.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 毕竟，直到我们完全承认我们所在的位置，我们才能真正欣赏到我们所到达的地方。随着多年来Web应用程序架构领域发生的重大变化，有很多值得承认的地方。
- en: 'Before we present the isomorphic web application architecture, let''s devote
    some time to review the three traditional web application architectures that came
    before it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍等同于Web应用程序架构之前，让我们花些时间回顾它之前的三种传统Web应用程序架构：
- en: The classic web application architecture
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典Web应用程序架构
- en: The AJAX web application architecture
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AJAX Web应用程序架构
- en: The **single-page application** (**SPA**) architecture
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单页应用程序**（**SPA**）架构'
- en: We'll identify the advantages and disadvantages for each of the three architectures
    considered. We will start a wish list of requirements, based on each disadvantage
    that we identify for a given architecture. After all, a shortcoming is actually
    an opportunity for improvement.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将确定考虑的三种架构的优缺点。我们将根据我们为给定架构确定的每个缺点开始一个需求愿望清单。毕竟，缺点实际上是改进的机会。
- en: The classic web application architecture
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典Web应用程序架构
- en: 'The **classic web application architecture** dates back to the early 1990s,
    when graphical web browsers started to gain traction. When the user interacts
    with a web server using a web browser, each user interaction, makes a request
    to a web server using HTTP. *Figure 1.1* depicts the classic web application architecture:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**经典Web应用程序架构**可以追溯到上世纪90年代初，当图形Web浏览器开始流行起来。当用户使用Web浏览器与Web服务器进行交互时，每个用户交互都会使用HTTP向Web服务器发出请求。*图1.1*描述了经典Web应用程序架构。'
- en: '![](img/2864d216-af37-499e-9c57-18db57a61689.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2864d216-af37-499e-9c57-18db57a61689.png)'
- en: 'Figure 1.1: The Classic Web Application Architecture'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：经典Web应用程序架构
- en: The diagram also depicts an HTTP transaction, which consists of a request that's
    sent from the user's web browser to the web server. Once the web server accepts
    the request, it will return a corresponding response for that request.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该图还描述了一个HTTP事务，其中包括用户的Web浏览器发送到Web服务器的请求。一旦Web服务器接受了请求，它将返回相应的响应。
- en: Typically, the response is an HTML web page, which may either contain inline
    CSS and/or JavaScript, or call external CSS stylesheets and/or JavaScript source
    files.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，响应是一个HTML网页，它可能包含内联CSS和/或JavaScript，或者调用外部CSS样式表和/或JavaScript源文件。
- en: 'There are two types of resources that the web server can return in the form
    of a response: a static resource and a dynamic resource.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器可以以响应的形式返回两种类型的资源：静态资源和动态资源。
- en: A **static resource** is a file. For example, it could be an HTML, JPEG, PDF,
    or MP4 file that lives on the web server. The server will return the document
    specified by the request in its response body.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态资源**是一个文件。例如，它可以是存储在Web服务器上的HTML、JPEG、PDF或MP4文件。服务器将在其响应主体中返回请求指定的文档。'
- en: A **dynamic resource** is a resource that gets built by the server on the fly.
    An example of a dynamic resource is a search engine's search results page. Usually,
    the response body of a dynamic request will be formatted in HTML.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态资源**是服务器动态生成的资源。动态资源的一个例子是搜索引擎的搜索结果页面。通常，动态请求的响应主体将以HTML格式进行格式化。'
- en: When it comes to web applications, we deal with dynamic resources. The web server
    is serving a web application, and usually the web application contains a controller
    with the logic that routes the user's request to a specific action to perform
    on the server. Once the web server is done processing the user's request, the
    server sends a response back to the client in the form of a web page response.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到Web应用程序时，我们处理动态资源。Web服务器正在提供Web应用程序，通常Web应用程序包含一个控制器，该控制器包含将用户请求路由到服务器上执行的特定操作的逻辑。一旦Web服务器处理完用户的请求，服务器会以Web页面响应的形式将响应发送回客户端。
- en: A server-side programming language (such as Go, Perl, PHP, Python, Ruby, and
    Java) is used to process the requests sent from the web browser. For example,
    let's consider we have a server side web application that is used for an e-commerce
    website.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端编程语言（如Go、Perl、PHP、Python、Ruby和Java）用于处理从Web浏览器发送的请求。例如，让我们考虑一个用于电子商务网站的服务器端Web应用程序。
- en: The web application can route requests by making use of a server-side **route
    handler** (as shown in *Figure 1.1*); the `/product-detail/swiss-army-knife` route can
    be associated to a product detail controller, which will serve an HTML web page
    response containing the product profile page for the Swiss Army Knife product.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序可以通过使用服务器端的**路由处理程序**（如*图1.1*所示）路由请求；`/product-detail/swiss-army-knife`路由可以与产品详细信息控制器相关联，该控制器将提供包含瑞士军刀产品概要页面的HTML网页响应。
- en: In a classic web application architecture, the code to render the web page lives
    on the server side, typically consolidated into template files. Rendering the
    web page response from a set of templates is performed by the **template renderer**
    that resides on the server (as shown in *Figure 1.1*).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的Web应用程序架构中，用于呈现Web页面的代码位于服务器端，通常整合到模板文件中。从一组模板呈现Web页面响应是由驻留在服务器上的**模板渲染器**执行的（如*图1.1*所示）。
- en: Usually in this paradigm, JavaScript may be included in a rendered web page
    to enhance the user experience. In this type of web application architecture,
    the responsibility of implementing the web application is placed primarily on
    the server-side language, and JavaScript is placed on the sidelines of being used
    primarily for user interface controls or enhanced user interactivity for the website.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在这种范式中，JavaScript可能会包含在呈现的Web页面中以增强用户体验。在这种Web应用程序架构中，实施Web应用程序的责任主要放在服务器端语言上，JavaScript主要用于用户界面控件或网站的增强用户交互，放在次要位置。
- en: Advantages
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优势
- en: 'The classic web application architecture comes with two major advantages:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 经典Web应用程序架构具有两个主要优势：
- en: Faster initial page loads
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的初始页面加载
- en: Greater search engine discoverability
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的搜索引擎可发现性
- en: Greater search engine discoverability
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的搜索引擎可发现性
- en: The second primary advantage of the classic web application architecture is
    that this architecture is search engine friendly, since the web application serves
    up web page responses, in HTML, that can be readily consumed by search engine
    bots. In addition to this, the server-side route-handler allows for the creation
    of search engine friendly URLs, that can be associated with a specific server-side
    controller.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 经典Web应用程序架构的第二个主要优势是这种架构对搜索引擎友好，因为Web应用程序提供了可以被搜索引擎机器人轻松消化的HTML网页响应。除此之外，服务器端路由处理程序允许创建与特定服务器端控制器相关联的搜索引擎友好的URL。
- en: A key factor to making a website friendly to search engines is discoverability.
    Besides having great content, a search engine friendly website also needs permalinks
    – web links that are intended to remain in service permanently. Descriptive and
    well-named URLs can be registered as routes with the server-side's router. These
    routes end up serving as permalinks, which the search engine bot crawlers can
    easily index while crawling through the website.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使网站对搜索引擎友好的关键因素是可发现性。除了拥有优质内容外，搜索引擎友好的网站还需要永久链接 - 旨在永久保持服务的网页链接。描述性良好的URL可以在服务器端的路由器中注册为路由。这些路由最终成为永久链接，搜索引擎机器人爬虫可以在浏览网站时轻松索引。
- en: 'The goal is to have pretty website URLs that can contain meaningful information,
    which can be easily indexed by a search engine''s bot crawler, such as: `http://igweb.kamesh.com/product-detail/swiss-army-knife`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是拥有美观的网站URL，其中包含有意义的信息，可以轻松被搜索引擎的机器人爬虫索引，例如：`http://igweb.kamesh.com/product-detail/swiss-army-knife`。
- en: 'The aforementioned permalink is much more easily indexed by a search engine
    and understood by a human rather than the following one: `http://igweb.kamesh.com/webapp?section=product-detail&amp;product_id=052486`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述永久链接比以下链接更容易被搜索引擎索引和人类理解：`http://igweb.kamesh.com/webapp?section=product-detail&amp;product_id=052486`。
- en: Faster initial page loads
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快的初始页面加载
- en: The first primary advantage of the classic web application architecture is that
    page loads are perceived to be fast by the user since the entire page is rendered
    at once. This is a result of the web server rendering the web page response, using
    a template renderer, on the server side itself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 经典Web应用程序架构的第一个主要优势是用户认为页面加载速度快，因为整个页面一次性呈现。这是由于Web服务器在服务器端使用模板渲染器呈现Web页面响应的结果。
- en: The user does not perceive slowness, since they are delivered the rendered page
    from the server instantaneously.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用户不会感知到缓慢，因为他们立即从服务器接收到呈现的页面。
- en: Keep in mind that if there is high latency in the server's response time, then
    the user interaction will come to a grinding halt. In this scenario, the fast
    initial page load advantage is lost since the user has to stare at a blank screen—waiting
    for the server to finish processing. This waiting will end with either the web
    page response being delivered to the user, or the HTTP request timing out—whichever
    comes first.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果服务器的响应时间延迟很高，那么用户交互将停滞不前。在这种情况下，快速的初始页面加载优势将丧失，因为用户必须盯着空白屏幕等待服务器完成处理。这种等待将以Web页面响应被交付给用户或HTTP请求超时而结束，以先到者为准。
- en: The primary disadvantage
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要的缺点
- en: We'll be examining the primary disadvantage(s) for each of the traditional web
    application architectures considered in this chapter. *The isomorphic web application
    architecture* section in this chapter, will show us how the isomorphic web application
    architecture provides a solution for each disadvantage presented and also gather
    the benefits offered from each of the traditional web application architectures.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中考虑的传统Web应用程序架构中检查每种传统Web应用程序架构的主要缺点。本章的*同构Web应用程序架构*部分将向我们展示同构Web应用程序架构如何为每个提出的缺点提供解决方案，并收集每种传统Web应用程序架构提供的好处。
- en: The primary disadvantage of the classic web application architecture is that all
    user interactions, even the most trivial, require a full page reload.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 经典Web应用程序架构的主要缺点是，所有用户交互，甚至最微不足道的交互，都需要完整的页面重新加载。
- en: 'This means that the **Document Object Model** (**DOM**), the tree data structure
    representing the current state of the web page, and the elements that comprise
    it, are completely wiped out, and recreated again upon each user interaction:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着**文档对象模型**（**DOM**），表示当前网页状态的树形数据结构以及组成它的元素，在每次用户交互时都会被完全清除，并重新创建：
- en: '![](img/607435db-ddc5-4849-9eea-0ae2f645f355.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/607435db-ddc5-4849-9eea-0ae2f645f355.png)'
- en: 'Figure 1.2: A layout diagram of a news website with a comments section and
    a wireframe depicting the comments section'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：新闻网站的布局图和评论部分的线框图
- en: For example, let's consider that we are reading an article on a news website.
    *Figure 1.2*, depicts a layout diagram of the news website (the illustration on
    the left), with the comments section of the website at the bottom of the web page.
    Other sections may exist on the news website in the negative (empty) space in
    the layout.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设我们正在阅读新闻网站上的一篇文章。*图1.2*描述了新闻网站的布局图（左侧的插图），网页底部是网站的评论部分。其他部分可能存在于布局中的负（空）空间中。
- en: '*Figure 1.2* also includes a wireframe design of the news comments section
    (the illustration on the right), which contains a few sample comments. The ellipses
    (...) denotes multiple website comments that are not listed for the sake of brevity.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.2*还包括新闻评论部分的线框设计（右侧的插图），其中包含一些示例评论。省略号（...）表示出于简洁起见未列出的多个网站评论。'
- en: 'Let''s consider scenario where this particular news article has gone viral
    and it contains more than 10,000 comments. The comments are paginated, and there
    are 50 comments displayed per page:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这样一个情景，这篇特定的新闻文章已经变得非常火爆，包含超过10,000条评论。评论是分页的，每页显示50条评论：
- en: '![](img/0687777b-b22a-4e9c-980f-b407a6a171c2.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0687777b-b22a-4e9c-980f-b407a6a171c2.png)'
- en: 'Figure 1.3: The entire web page needs to be refreshed to view the next set
    of comments'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：查看下一组评论需要整个网页刷新
- en: '*Figure 1.3* depicts the web page for the news website being refreshed (the
    illustration on the left). Note that the user will perceive the refresh to be
    quick because the page will instantaneously load (considering that network latency
    is low). *Figure 1.3* also depicts the next batch of 50 articles (the illustration
    on the right) after the next link has been clicked.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.3*描述了新闻网站的网页被刷新（左侧的插图）。请注意，用户会感觉刷新很快，因为页面会立即加载（考虑到网络延迟很低）。*图1.3*还描述了点击下一个链接后（右侧的插图）下一批50篇文章。'
- en: If we were to click on the next link on the paginated navigation control, it
    would cause a full page reload, which would destroy the DOM and recreate it again.
    Since the comments are located at the bottom of the screen, upon a full page reload,
    the scroll position may also change back to the top of the web page, resulting
    in a poor user experience.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击分页导航控件上的下一个链接，将导致整个页面重新加载，这将销毁DOM并重新创建。由于评论位于屏幕底部，在整个页面重新加载时，滚动位置也可能会回到网页顶部，导致用户体验不佳。
- en: We only wanted to see the next set of comments at the bottom of the page. We
    didn't intend for the whole web page to reload, but it did, and that's the major
    limitation of the classic web application architecture.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想在页面底部看到下一组评论。我们并不打算整个网页重新加载，但它确实重新加载了，这就是经典Web应用程序架构的主要局限性。
- en: '**Wish list item #1:** To enhance the user experience, clicking on a link on
    the website should not cause a full page reload.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**愿望清单项目＃1：**为了增强用户体验，点击网站上的链接不应导致整个页面重新加载。'
- en: The AJAX web application architecture
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX Web应用程序架构
- en: With the advent of the **XMLHttpRequest** (**XHR**) object, the **Asynchronous
    JavaScript And XML** (**AJAX**) era began. *Figure 1.4* illustrates the AJAX web
    application architecture.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随着**XMLHttpRequest**（**XHR**）对象的出现，**异步JavaScript和XML**（**AJAX**）时代开始了。*图1.4*说明了AJAX
    Web应用程序架构。
- en: After the client's initial request, the server sends back a web page response
    containing HTML, CSS, and JavaScript. Once the web page has finished loading,
    the JavaScript application on the client side may initiate asynchronous requests
    back to the web server over HTTP, using the XHR object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的初始请求后，服务器发送回一个包含HTML、CSS和JavaScript的网页响应。一旦网页加载完成，客户端的JavaScript应用程序可以通过XHR对象发起HTTP异步请求回到Web服务器。
- en: Some observers have characterized the advent of AJAX as the *Web 2.0 era*, where
    websites became more interactive with more rich user experiences and the use of
    JavaScript libraries started to gain traction.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些观察者将AJAX的出现描述为*Web 2.0时代*，在这个时代，网站变得更加互动，用户体验更加丰富，JavaScript库的使用开始获得关注。
- en: '![](img/5b063664-99ed-44f9-aa20-ea8a800ec367.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b063664-99ed-44f9-aa20-ea8a800ec367.png)'
- en: 'Figure 1.4: The AJAX web application architecture'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：AJAX Web应用程序架构
- en: Because the XHR calls are asynchronous in nature, they don't block the single
    threaded JavaScript application running in the web browser. Once a response is
    received from the server for a given XHR request, an action can be taken with
    the data that was returned from the server.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于XHR调用是异步的，它们不会阻塞在Web浏览器中运行的单线程JavaScript应用程序。一旦从服务器收到给定XHR请求的响应，就可以对从服务器返回的数据采取行动。
- en: The primary advantage
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要优势
- en: The primary advantage of the AJAX web application architecture is that it removes
    the need to perform a full page reload.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX Web应用程序架构的主要优势是它消除了执行完整页面重新加载的需要。
- en: In the scenario that we considered with the news article web page that had 10,000+
    comments, we can program the web application to initiate an XHR call when the
    Next button is pressed, then the server can send back an HTML fragment that contains
    the next set of comments to display. Once we get back the next set of comments,
    we can have JavaScript dynamically update the DOM, and completely avoid the need
    to perform a full page reload!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们考虑的新闻文章网页有10,000多条评论的情况下，我们可以编写Web应用程序，在按下“下一页”按钮时发起XHR调用，然后服务器可以发送包含要显示的下一组评论的HTML片段。一旦我们收到下一组评论，我们可以使用JavaScript动态更新DOM，完全避免执行完整的页面重新加载！
- en: '*Figure 1.5* illustrates this approach. The left-most illustration depicts
    the comments in the comment section. The middle illustration depicts only the
    comments section being updated. Finally, the illustration on the right depicts
    the next batch of comments loaded in the comments section:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.5*说明了这种方法。最左边的插图描述了评论部分中的评论。中间的插图只描述了更新的评论部分。最后，右边的插图描述了加载到评论部分的下一批评论：'
- en: '![](img/58d8dbdc-911a-4e7a-bc69-a59cc3202fd2.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58d8dbdc-911a-4e7a-bc69-a59cc3202fd2.png)'
- en: 'Figure 1.5: When the *Next* link is clicked, only the comments section of the
    news website is updated, avoiding a full page refresh'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：当单击“下一页”链接时，只更新新闻网站的评论部分，避免了完整的页面刷新
- en: As you can see, the primary advantage of this approach is that we avoid the
    full page reload, which enhances the user experience. Keep in mind that in certain
    scenarios, such as navigating through different sections of the website, full
    page reloads may still occur.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这种方法的主要优势是我们避免了完整的页面重新加载，从而增强了用户体验。请记住，在某些情况下，例如浏览网站的不同部分，仍然可能发生完整的页面重新加载。
- en: Disadvantages
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'The AJAX web application architecture comes with the following disadvantages:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX Web应用程序架构具有以下缺点：
- en: Handling the mental context switch between two programming languages
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理两种编程语言之间的心理上下文转换
- en: The complexity introduced by performing piecemeal client-side rendering
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过逐步客户端渲染引入的复杂性
- en: The duplication of efforts
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作重复
- en: Mental context shifts
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 心理上下文转换
- en: When it comes to developer productivity, we have now introduced a mental context
    shift (also known as a cognitive switch) assuming that the back-end server-side
    language is not JavaScript. For example, let's consider that our back-end application
    is implemented in Go and the front-end application is implemented in JavaScript.
    Now, the developer will have to be fluent in both the server-side language (Go)
    and the client-side language (JavaScript) which apart from syntactical differences
    may have a different set of guiding philosophies and idioms.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到开发人员的生产力时，我们现在引入了一种心理上下文转换（也称为认知转换），假设后端服务器端语言不是JavaScript。例如，让我们假设我们的后端应用程序是用Go实现的，前端应用程序是用JavaScript实现的。现在，开发人员将不得不精通服务器端语言（Go）和客户端语言（JavaScript），除了语法上的差异之外，它们可能具有不同的指导理念和习惯用法。
- en: This causes a mental context shift for the full stack developer that is tasked
    with maintaining the client side and the server side of the codebase. One way
    for organizations to immediately address the issue of mental context shifts is
    to reach into the pocketbooks. If the organization can afford to do this, it could
    take the hit in increased operating costs and dedicate at least one developer
    to the front-end and one developer to the back-end.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于负责维护代码库的全栈开发人员来说是一种心理上下文转换。组织立即解决心理上下文转换问题的一种方法是动用资金。如果组织有能力这样做，它可以承担增加的运营成本，并至少指定一个开发人员负责前端，一个开发人员负责后端。
- en: '**Wish list item #2: **To increase maintainability, there should be a single,
    unified, project codebase, which is implemented in a single programming language.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**愿望清单项目＃2：**为了增加可维护性，应该有一个单一的、统一的项目代码库，使用单一的编程语言实现。'
- en: Increased rendering complexity
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加的渲染复杂性
- en: In addition to introducing the mental context shift of handling two different
    programming languages, we have now increased the level of rendering complexity.
    In the classic web application architecture, the rendered web page that was received
    from the server response was never mutated. In fact, it was wiped out once a new
    page request was initiated.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了引入处理两种不同编程语言的心理上下文转换之外，我们现在增加了渲染复杂性的级别。在经典的Web应用程序架构中，从服务器响应接收到的渲染的网页从未被改变。事实上，一旦发起新的页面请求，它就被清除了。
- en: Now, we are re-rendering portions of the web page in a piecemeal fashion from
    the client side, which requires us to implement more logic to make (and keep track
    of) subsequent updates to the web page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们以逐步方式从客户端重新渲染网页的部分，这要求我们实现更多的逻辑来进行（并跟踪）对网页的后续更新。
- en: '**Wish list item #3: **To increase efficiency, there should be a mechanism
    to perform distributed template rendering.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**愿望清单项目＃3：**为了增加效率，应该有一种机制来执行分布式模板渲染。'
- en: Duplication of efforts
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作重复
- en: The AJAX web application architecture introduces a duplication of efforts between
    the server side and the client side. Let's say that we wanted to add a new comment
    to the news article. Once we fill out the form, to add the new comment, we can
    initiate an XHR call, which will send the new comment, that is to be added, to
    the server. The server-side web application can then persist the new comment to
    the database, where all comments are stored. Instead of refreshing the entire
    web page, we can immediately update the comment section to include the new comment
    that was just added.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX Web应用程序架构在服务器端和客户端之间引入了工作重复。比如，我们想要在新闻文章中添加新评论。填写表单后，为了添加新评论，我们可以发起一个XHR调用，将要添加的新评论发送到服务器。服务器端Web应用程序随后可以将新评论持久保存到数据库中，其中存储了所有评论。我们可以立即更新评论部分，以包括刚刚添加的新评论，而不是刷新整个网页。
- en: A basic tenet in computer programming, and especially in web programming, is
    to never trust user input. Let's consider the scenario where the user may have
    introduced a set of invalid characters into the comment box. We will have to implement
    some type of validation that checks the user's comment, both on the client side
    and on the server side. This means that we'll have to implement client-side form
    validation in JavaScript and server-side form validation in Go.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机编程的一个基本原则，特别是在Web编程中，就是不要相信用户输入。让我们考虑一种情况，用户可能在评论框中输入了一组无效字符。我们将不得不实现一些类型的验证，既在客户端又在服务器端检查用户的评论。这意味着我们将不得不在JavaScript中实现客户端表单验证，并在Go中实现服务器端表单验证。
- en: At this point, we have introduced a duplication of efforts in two programming
    languages spread across two different operating environments. Besides the example
    we just considered, there may be other scenarios that require duplication of efforts
    when going down this architectural path. This happens to be a major disadvantage
    of the AJAX web application architecture.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们在两种不同的操作环境中引入了两种编程语言的工作重复。除了我们刚刚考虑的例子，可能还有其他需要在这种架构路径上进行工作重复的情况。这恰好是AJAX
    Web应用程序架构的一个主要缺点。
- en: '**Wish list item #4:** To increase productivity, there should be a means to
    share and reuse code across environments to avoid the duplication of efforts.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**愿望清单项目＃4：**为了提高生产力，应该有一种方法在不同环境之间共享和重用代码，以避免工作重复。'
- en: The single page application (SPA) architecture
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用程序（SPA）架构
- en: In 2004, the **World Wide Web Consortium** (**W3C**) started working on the
    new HTML standard, which was to be the precursor to HTML5\. In 2010, HTML5 started
    to pick up speed, and features from the specification started to make their way
    into the major web browsers and the HTML5 functionality became very popular.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 2004年，**万维网联盟**（**W3C**）开始制定新的HTML标准，这将是HTML5的前身。2010年，HTML5开始加速发展，规范中的功能开始进入主要的Web浏览器，HTML5功能变得非常流行。
- en: 'The major selling point for HTML5 was to introduce capabilities that would
    allow web applications to behave more like native applications. A new set of APIs
    that were accessible through JavaScript were introduced. These APIs included the
    functionality to store data locally on the user''s device, better control of the
    forward and back button (using the web browser''s History API), a 2D canvas for
    rendering graphics, and the second version of the XHR object that included greater
    capabilities than its predecessor:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5的主要卖点是引入功能，使Web应用程序能够更像本机应用程序。通过JavaScript可以访问一组新的API。这些API包括在用户设备上本地存储数据的功能，更好地控制前进和后退按钮（使用Web浏览器的历史API），用于呈现图形的2D画布，以及包括比其前身更强大功能的XHR对象的第二个版本。
- en: '![](img/afac4340-c6a5-4165-b267-2b883bea71cc.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afac4340-c6a5-4165-b267-2b883bea71cc.png)'
- en: 'Figure 1.6: The Single Page Application (SPA) Architecture'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：单页应用程序（SPA）架构
- en: In the early 2010s, JavaScript frameworks began to emerge, which facilitated
    in the development of a new type of architecture, the SPA architecture. This architecture,
    as depicted in *Figure 1.6*, focuses on a *fat client* and *thin server* strategy.
    The idea was to remove the responsibility of any type of template rendering from
    the server side and assign all **User Interface**(**UI**) rendering to the client
    side. In this architecture, there is a clear separation of concerns between the
    duties of the server and the client.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在2010年代初，开始出现了JavaScript框架，这有助于开发一种新型架构，即SPA架构。这种架构，如*图1.6*所示，专注于*fat client*和*thin
    server*策略。其思想是从服务器端删除任何类型的模板渲染的责任，并将所有**用户界面**（**UI**）渲染分配给客户端。在这种架构中，服务器和客户端的职责有明确的分离。
- en: The SPA architecture removes the duplication of efforts for user interface responsibilities.
    It does so by consolidating all UI code to the client. Doing so eliminates the
    duplication of efforts on the server side in terms of the user interface. As depicted
    in *Figure 1.6*, the responsibility for the user interface rests solely with the
    client.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: SPA架构消除了用户界面责任的工作重复。它通过将所有UI代码整合到客户端来实现这一点。这样做消除了服务器端在用户界面方面的工作重复。如*图1.6*所示，用户界面的责任完全由客户端承担。
- en: The server initially returns a payload containing JavaScript and client-side
    templates. The JavaScript payload could possibly be *aggregated*, which means
    that all JavaScript source files that comprise the web application can be combined
    into one JavaScript source file. In addition to that, the JavaScript payload might
    also be **minified**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器最初返回一个包含JavaScript和客户端模板的有效负载。JavaScript有效负载可能会被*聚合*，这意味着组成Web应用程序的所有JavaScript源文件可以合并成一个JavaScript源文件。除此之外，JavaScript有效负载还可能被**缩小**。
- en: '**Minification** is the process of removing any unnecessary characters from
    the source code, which may include renaming identifiers in the source code without
    changing the functionality of the source code, in order to reduce its storage
    footprint.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**缩小**是从源代码中删除任何不必要字符的过程，这可能包括在不改变源代码功能的情况下重命名源代码中的标识符，以减少其存储占用空间。'
- en: Once the web browser has fully downloaded the JavaScript payload, the first
    order of business for the JavaScript code is to bootstrap the JavaScript application,
    rendering the user interface on the client side.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Web浏览器完全下载了JavaScript负载，JavaScript代码的首要任务是在客户端上引导JavaScript应用程序，渲染用户界面。
- en: Reduced search engine discoverability
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索引擎可发现性降低
- en: The use of the SPA architecture may reduce search engine discoverability. Because
    of the dynamic nature of rendering content on the client side, some SPA implementations
    may not produce well-formed HTML content that can be easily consumed by search
    engine bot crawlers that are used to consuming an initial web page response only.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SPA架构可能会降低搜索引擎的可发现性。由于在客户端动态渲染内容的性质，一些SPA实现可能无法生成易于搜索引擎爬虫消费的格式良好的HTML内容，这些爬虫通常只用于消费初始网页响应。
- en: The search engine bot crawler may not have the capability to render the web
    page, since it may not be equipped with a JavaScript runtime. Without the fully
    rendered web page content, the bot crawler cannot effectively perform its duty
    of consuming the web page's content.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎爬虫可能无法渲染网页，因为它可能没有配备JavaScript运行时。没有完全渲染的网页内容，爬虫无法有效地执行其消费网页内容的职责。
- en: In addition to this, SPA implementations handle routes using fragment identifiers,
    strings that refer to a resource, after the hash mark (#) of a URL. This approach
    is not search engine friendly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，SPA实现使用片段标识符处理路由，这种方法对搜索引擎不友好。
- en: 'Let''s return to our e-commerce web application example. In the classic and
    AJAX web application architectures, our web application could have the following
    URL: `http://igweb.kamesh.com/product-detail/swiss-army-knife`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的电子商务Web应用程序示例。在经典和AJAX Web应用程序架构中，我们的Web应用程序可能具有以下URL：`http://igweb.kamesh.com/product-detail/swiss-army-knife`。
- en: 'In the case of the SPA implementation, the URL, with a fragment identifer,
    could look like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在SPA实现的情况下，带有片段标识符的URL可能如下所示：
- en: '`http://igweb.kamesh.com/#section=product_detail&amp;product=swiss-army-knife`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://igweb.kamesh.com/#section=product_detail&amp;product=swiss-army-knife`'
- en: This URL would be difficult for a search engine bot crawler to index because
    the fragment identifier (the characters after the hash symbol) is meant to specify
    a location within a given web page.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个URL对于搜索引擎爬虫来说很难索引，因为片段标识符（#符号后面的字符）是用来指定给定网页内的位置的。
- en: Fragment identifiers were designed to provide links within sections of an individual
    web page. The fragment identifier influences the web browser's history since we
    can tack on unique identifiers to the URL. This effectively, prevents the user
    from encountering a full page reload.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 片段标识符旨在提供单个网页部分内的链接。片段标识符影响Web浏览器的历史，因为我们可以在URL上附加唯一标识符。这有效地防止用户遇到完整的页面重新加载。
- en: 'The shortcoming of this approach is that fragment identifiers are not included
    in the HTTP request, so from a web server''s perspective, the URL, `http://igweb.kamesh.com/webapp#orange`,
    and the URL, `http://igweb.kamesh.com/webapp#apple`, are pointing to the same
    resource: `http://igweb.kamesh.com/webapp`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是HTTP请求中不包括片段标识符，因此从Web服务器的角度来看，URL `http://igweb.kamesh.com/webapp#orange`和URL
    `http://igweb.kamesh.com/webapp#apple`指向相同的资源：`http://igweb.kamesh.com/webapp`。
- en: The search engine bot crawler would have to be implemented in a more sophisticated
    manner to handle the complexity of indexing websites containing fragment identifiers.
    Although Google has made considerable progress on this problem, implementing URLs,
    without the fragment identifiers, is still the recommended best practice to ensure
    websites are easily indexed by search engines.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎爬虫必须以更复杂的方式实现，以处理包含片段标识符的网站的索引复杂性。尽管谷歌在解决这个问题上取得了相当大的进展，但实现不带片段标识符的URL仍然是推荐的最佳实践，以确保网站能够被搜索引擎轻松索引。
- en: It is important to note is that in some cases, the SPA architecture may overcome
    this disadvantage, using more modern practices. For example, more recent SPA implementations
    avoid fragment identifiers altogether, using the web browser's History API to
    have more search engine friendly URLs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在某些情况下，SPA架构可能会通过使用更现代的实践来克服这一劣势。例如，更近期的SPA实现完全避免了片段标识符，而是使用Web浏览器的History
    API来拥有更友好的搜索引擎URL。
- en: '**Wish list item #6:** To promote discoverability, the website should provide
    well-formed HTML content that is easily consumed by search engine bots. The website
    should also contain links that are easily indexed by search engine bots.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**愿望清单项目＃6：**为了促进可发现性，网站应提供易于搜索引擎爬虫消费的格式良好的HTML内容。网站还应包含易于搜索引擎爬虫索引的链接。'
- en: The primary advantage
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要优势
- en: The primary advantage of the SPA architecture is that it provides client-side
    routing, preventing full page reloads. Client-side routing involves intercepting
    the click event of hyperlinks on a given web page, so that they don't initiate
    a new HTTP request to the web server. The client-side router associates a given
    route with a client-side route handler that is responsible for servicing the route.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: SPA架构的主要优势在于它提供了客户端路由，防止了整个页面的重新加载。客户端路由涉及拦截给定网页上超链接的点击事件，以便它们不会发起新的HTTP请求到Web服务器。客户端路由器将给定路由与负责处理路由的客户端路由处理程序相关联。
- en: For example, let's consider an e-commerce website that has implemented client-side
    routing. When a user clicks on a link to the Swiss Army Knife product detail page,
    instead of initiating a full page reload, an XHR call is made to a REST API endpoint
    on the web server. The endpoint returns the profile data about the Swiss Army
    knife, in the **JavaScript Object Notation** (**JSON**) format, which is used
    by the client-side application to render the content for the Swiss Army knife
    product detail page.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个实现了客户端路由的电子商务网站。当用户点击链接到瑞士军刀产品详情页面时，不会启动完全重新加载页面，而是向Web服务器的REST API端点发出XHR调用。端点以JavaScript对象表示法（JSON）格式返回有关瑞士军刀的配置数据，客户端应用程序用于呈现瑞士军刀产品详情页面的内容。
- en: The experience is seamless from the user's perspective, since the user will
    not experience the sudden white flash that is encountered on a full page reload.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，体验是无缝的，因为用户不会经历在完全重新加载页面时遇到的突然的白屏。
- en: Disadvantages
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'The SPA architecture comes with the following disadvantages:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: SPA架构具有以下缺点：
- en: The initial page loads are perceived to be slower
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最初的页面加载被认为是较慢的
- en: Reduced search engine discoverability
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低搜索引擎的可发现性
- en: Slower initial page loads
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 较慢的初始页面加载
- en: The initial page load of an SPA-based web application can be perceived to be
    slow. The slowness can result from the time-consuming, initial download of the
    aggregated JavaScript payload.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 基于SPA的Web应用程序的初始页面加载可能被认为是缓慢的。这种缓慢可能是由于初始下载聚合JavaScript有效载荷所需的时间而导致的。
- en: 'The **Transmission Control Protocol** (**TCP**) has a slow start mechanism,
    where data is sent in segments. The JavaScript payload will require multiple round
    trips between the server and the client before it can be fully delivered to the
    web browser:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 传输控制协议（TCP）具有缓慢启动机制，其中数据以段的形式发送。JavaScript有效载荷在完全传递到Web浏览器之前，需要在服务器和客户端之间进行多次往返：
- en: '![](img/f4bc0017-3e81-4ff6-9c82-31dea3279a3d.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4bc0017-3e81-4ff6-9c82-31dea3279a3d.png)'
- en: 'Figure 1.7: The initial page load is perceived to be slow since the user is
    greeted with a loading indicator instead of the rendered web page'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：由于用户被加载指示器所招呼，初始页面加载被认为是缓慢的，而不是呈现的网页
- en: A consequence of this is that users have to wait for the JavaScript payload
    to be completely fetched before the web page can be fully rendered. It is a common **user
    experience** (**UX**) practice to use a loading indicator (such as a spinning
    wheel) to let the user know that the user interface is still loading.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致用户必须等待JavaScript有效载荷完全获取，然后网页才能完全呈现。使用加载指示器（如旋转的轮子）是一种常见的用户体验（UX）实践，让用户知道用户界面仍在加载中。
- en: '*Figure 1.7* includes an illustration (on the left) that depicts the loading
    indicator, and an illustration (on the right) that depicts the layout of the loaded
    web page. It is important to note that, depending on the SPA implementation, there
    may be more than one loading indicator spread across the individual sections that
    make up the web page.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.7*包括一个插图（左侧）显示加载指示器，以及一个插图（右侧）显示加载的网页布局。重要的是要注意，根据SPA的实现方式，可能会在构成网页的各个部分中分布多个加载指示器。'
- en: I'm sure that, in your own web browsing travels, you have probably used web
    applications that have contained these loading spinners. We can agree, from the
    user's perspective, that ideally we would rather want to see the rendered output
    instead of the spinning wheel.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，在您自己的网络浏览中，您可能已经使用过包含这些加载旋转器的Web应用程序。从用户的角度来看，我们可以同意，理想情况下，我们宁愿看到呈现的输出，而不是旋转的轮子。
- en: '**Wish list item #5:** To make the best first impression, the website should
    readily display content to the user .'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**愿望清单项目＃5：**为了给用户留下最好的第一印象，网站应该能够立即向用户显示内容。'
- en: The isomorphic web application architecture
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同构Web应用程序架构
- en: 'The **isomorphic web application architecture** consists of implementing two
    web applications, one on the server side and one on the client side, using the
    same programming language and reusing code across the two environments:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**同构Web应用程序架构**包括在服务器端和客户端分别实现两个Web应用程序，使用相同的编程语言并在两个环境中重用代码：'
- en: '![](img/6567eb2b-b96e-46d8-b63a-a8718516213c.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6567eb2b-b96e-46d8-b63a-a8718516213c.png)'
- en: 'Figure 1.8: The Isomorphic Web Application Architecture'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8：同构Web应用程序架构
- en: As depicted in *Figure 1.8*, business logic can be shared across environments.
    For example, if we had defined a `Product` struct to model a product for our e-commerce
    website, both the server-side and client-side applications can be made aware of
    it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如图1.8所示，业务逻辑可以在不同环境中共享。例如，如果我们定义了一个“产品”结构来模拟我们电子商务网站上的产品，服务器端和客户端应用程序都可以知道它。
- en: In addition to this, a template renderer exists on both the server side and
    the client side, so that templates can also be rendered across environments, making
    templates *isomorphic*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，模板渲染器存在于服务器端和客户端，因此模板也可以在不同环境中进行渲染，使模板成为“同构”。
- en: The term *isomorphic* can be used to describe anything (business logic, templates,
    template functions, and validation logic) that can be shared across environments.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: “同构”一词可用于描述可以在不同环境之间共享的任何内容（业务逻辑、模板、模板函数和验证逻辑）。
- en: The server-side route handler is responsible for servicing routes on the server
    side and the client-side route handler is responsible for servicing routes on
    the client side. When a user initially accesses a website implemented using isomorphic
    web application architecture, the server-side route handler kicks in and generates
    a web page response using the server-side template renderer.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端路由处理程序负责在服务器端服务路由，客户端路由处理程序负责在客户端服务路由。当用户最初访问使用同构Web应用程序架构实现的网站时，服务器端路由处理程序启动并使用服务器端模板渲染器生成网页响应。
- en: Subsequent user interactions with the website are performed in the SPA mode
    using client-side routing. The client-side route handler is responsible for servicing
    a given client-side route and rendering content to the web page (the user interface)
    using the client-side template renderer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的后续用户交互是在SPA模式下使用客户端路由进行的。客户端路由处理程序负责为给定的客户端路由提供服务，并使用客户端模板渲染器将内容呈现到网页（用户界面）上。
- en: The client-side application can initiate a XHR request to a Rest API endpoint
    on the web server, retrieve data from the server's response, and render content
    on the web page using the client-side template renderer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序可以发起XHR请求到Web服务器上的Rest API端点，从服务器的响应中检索数据，并使用客户端模板渲染器在网页上呈现内容。
- en: An Isomorphic Go web application may optionally utilize a WebSocket connection,
    as shown in *Figure 1.8*, for persistent, bidirectional communication between
    the web server and the web browser. Isomorphic Go web applications have the added
    benefit of sending and receiving data in the `gob` format—Go's format for binary
    encoded data. Encoding and decoding data to the `gob` format can be done using
    the `encoding/gob` package from the standard library.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 同构的Go Web应用程序可以选择使用WebSocket连接，如*图1.8*所示，用于Web服务器和Web浏览器之间的持久、双向通信。同构的Go Web应用程序还具有以`gob`格式发送和接收数据的额外好处——`gob`是Go的二进制编码数据格式。可以使用标准库中的`encoding/gob`包对数据进行编码和解码为`gob`格式。
- en: Gob encoded data has a major advantage over JSON—it has a smaller data storage
    footprint.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Gob编码的数据比JSON具有更小的数据存储占用空间。
- en: The primary advantage of the `gob` format is its lower storage footprint. JSON
    data is in text format, and it's understood that data formatted as text requires
    a heavier storage footprint when compared with a binary encoded format. With smaller
    data payloads exchanged between the client and server, the web application can
    benefit with faster response times when transferring data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`gob`格式的主要优势是其较小的存储占用空间。JSON数据是文本格式，众所周知，文本格式的数据在与二进制编码格式相比需要更大的存储占用空间。通过在客户端和服务器之间交换较小的数据负载，Web应用程序在传输数据时可以获得更快的响应时间。'
- en: Wish list fulfilled
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 愿望清单已实现
- en: 'The Isomorphic Web Application Architecture offers a solution for all of the
    disadvantages found in the three traditional web application architectures. Let''s
    take stock of the items that we''ve placed on our wish list:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 同构的Web应用架构为三种传统Web应用架构中发现的所有缺点提供了解决方案。让我们盘点一下我们在愿望清单上放置的项目：
- en: To **enhance the user experience**, clicking a link on the website should not
    cause a full page reload.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了**增强用户体验**，在网站上点击链接不应导致全页重新加载。
- en: To **increase maintainability**, there should be a single, unified, project
    codebase that is implemented in a single programming language.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了**增加可维护性**，应该有一个单一、统一的项目代码库，使用单一编程语言实现。
- en: To **increase efficiency**, there should be a mechanism to perform distributed
    template rendering.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了**提高效率**，应该有一种分布式模板渲染的机制。
- en: To **increase productivity**, there should be a means to share and reuse code
    across environments, to avoid the duplication of efforts.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了**提高生产力**，应该有一种方式在不同环境中共享和重用代码，以避免重复劳动。
- en: To **make the best first impression**, the website should readily display content
    to the user.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了**给出最好的第一印象**，网站应该能够迅速向用户显示内容。
- en: To **promote discoverability**, the website should provide well-formed HTML
    content that is easily consumed by search engine bots. The website should also
    contain links that are easily indexed by search engine bots.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了**提高可发现性**，网站应提供易于搜索引擎机器人消费的格式良好的HTML内容。网站还应包含易于搜索引擎机器人索引的链接。
- en: Now, it's time to examine how the isomorphic web application architecture fulfills
    each item that has been placed on our wish list.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候检查同构的Web应用架构如何满足我们愿望清单上的每一项了。
- en: 1\. Enhancing the user experience
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 提升用户体验
- en: After the initial server-side rendered web page response, the isomorphic web
    application architecture enhances the user experience by running in the SPA mode.
    Client-side routing is used for subsequent user interactions with the website,
    preventing full page reloads and enhancing the user experience of the website.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始服务器端呈现的网页响应之后，同构的Web应用架构通过以SPA模式运行来增强用户体验。客户端路由用于网站的后续用户交互，防止全页重新加载，并增强网站的用户体验。
- en: 2\. Increasing the maintainability
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 增加可维护性
- en: Maintainability of the project codebase is strengthened by the isomorphic web
    application architecture due to the fact that a single programming language is
    used to implement both the client-side and server-side web applications. This
    prevents the mental context shifts that occur when dealing with two different
    programming languages across environments.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同构的Web应用架构使用单一编程语言来实现客户端和服务器端的Web应用程序，因此项目代码库的可维护性得到了加强。这可以避免在不同环境中处理两种不同编程语言时发生的心理上下文转换。
- en: 3\. Increasing the efficiency
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 增加效率
- en: The isomorphic web application architecture increases the efficiency of rendering
    content by providing a mechanism for distributed template rendering—the isomorphic
    template renderer. With a template renderer present on both the server side and
    the client side, as depicted in *Figure 1.8*, templates can easily be reused across
    environments.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 同构的Web应用架构通过提供分布式模板渲染机制——同构模板渲染器，增加了呈现内容的效率。如*图1.8*所示，由于服务器端和客户端都有模板渲染器，模板可以在不同环境中轻松重用。
- en: 4\. Increasing the productivity
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 增加生产力
- en: The single unified codebase that is the hallmark of the isomorphic web application
    architecture provides many opportunities to share code across environments. For
    example, form validation logic can be shared across environments, allowing a web
    form to be validated, both on the client side and the server side using the same
    validation logic. It is also possible to share models and templates across the
    client and the server.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 同构Web应用程序架构的标志是单一统一的代码库，提供了许多机会在不同环境之间共享代码。例如，表单验证逻辑可以在不同环境之间共享，允许在客户端和服务器端使用相同的验证逻辑验证Web表单。还可以在客户端和服务器端之间共享模型和模板。
- en: 6\. Promoting discoverability
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 促进可发现性
- en: The isomorphic web application architecture promotes discoverability, since
    it can easily provide well-formed HTML content. Keep in mind that the rendered
    output of Go templates is HTML.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 同构Web应用程序架构促进了可发现性，因为它可以轻松提供格式良好的HTML内容。请记住，Go模板的渲染输出是HTML。
- en: With an isomorphic template renderer, HTML content is easily rendered on the
    client side and the server side. This means that we can provide well-formed HTML
    content for traditional search engine bot crawlers that simply scrape web page
    content, as well as for modern search engine bot crawlers that may be equipped
    with a JavaScript runtime.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用同构模板渲染器，HTML内容可以在客户端和服务器端轻松渲染。这意味着我们可以为传统搜索引擎爬虫提供格式良好的HTML内容，这些爬虫只是简单地抓取网页内容，以及为可能配备JavaScript运行时的现代搜索引擎爬虫提供格式良好的HTML内容。
- en: Another means by which the isomorphic web application architecture promotes
    discoverability is that well-formed URLs can be defined by the application's route
    handlers (both on the server side and client side) and these URLs can easily be
    indexed by search engine bot crawlers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 同构Web应用程序架构促进可发现性的另一种方式是应用程序的路由处理程序（服务器端和客户端）可以定义格式良好的URL，并且这些URL可以轻松被搜索引擎爬虫索引。
- en: This is possible because the route handler implemented on the client side makes
    use of the web browser's History API to match the same routes that are defined
    on the server side. For example, the `/product-detail/swiss-army-knife` route for
    the Swiss Army Knife product detail page can be registered by both the server-side
    and the client-side routers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的，因为客户端实现的路由处理程序利用Web浏览器的History API来匹配服务器端定义的相同路由。例如，瑞士军刀产品详情页面的`/product-detail/swiss-army-knife`路由可以由服务器端和客户端路由器注册。
- en: 5\. Making the best first impression
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 给出最好的第一印象
- en: The isomorphic web application architecture's usage of server-side rendering
    for the initial web page response, guarantees that the user will see content immediately
    upon accessing the website. For the first encounter with the user, the isomorphic
    web application architecture takes a page out of the classic web application architecture's
    playbook for providing the initial web page response.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 同构Web应用程序架构使用服务器端渲染初始网页响应，确保用户在访问网站时立即看到内容。对于与用户的第一次接触，同构Web应用程序架构借鉴了经典Web应用程序架构的方法，提供初始网页响应。
- en: This is a welcome benefit to the user, since content is displayed to them instantly
    and the user will perceive a fast page load as a result of this. This is a sharp
    contrast to the SPA architecture, where the user would have to wait for the client-side
    application to bootstrap before seeing the web page's content appear on the screen.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这对用户来说是一个受欢迎的好处，因为内容会立即显示给他们，用户会感知到快速加载页面的结果。这与SPA架构形成鲜明对比，因为在SPA架构中，用户必须等待客户端应用程序引导完成后才能在屏幕上看到网页内容出现。
- en: Live demo
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时演示
- en: 'Now it''s time to see the isomorphic web application architecture in action.
    A live demo of IGWEB, the website that we will be implementing over the course
    of this book, is available at [http://igweb.kamesh.com](http://igweb.kamesh.com).
    *Figure 1.9* is a screenshot of the website''s home page:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看同构Web应用程序架构的实际效果了。我们将在本书的过程中实施的网站IGWEB的实时演示可在[http://igweb.kamesh.com](http://igweb.kamesh.com)上找到。*图1.9*是网站首页的截图：
- en: '![](img/d9a58ed0-9559-4676-8e20-b2a24c4f5a11.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9a58ed0-9559-4676-8e20-b2a24c4f5a11.png)'
- en: 'Figure 1.9: IGWEB: A website implemented with Isomorphic Go'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9：IGWEB：使用同构Go实现的网站
- en: Notice that the content in the *above the fold* area (the area that is visible
    in the browser window) is displayed instantly. Also, take note of the responsiveness
    of the website when navigating to different sections of the website by clicking
    on the links in the navigation menu. We'll provide you with a detailed introduction
    to the IGWEB project in the next chapter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在*以上折叠*区域（在浏览器窗口中可见的区域）中的内容会立即显示。此外，当通过导航菜单中的链接导航到网站的不同部分时，请注意网站的响应性。我们将在下一章为您详细介绍IGWEB项目。
- en: 'At the time of writing, IGWEB has been verified to function in the following
    web browsers: Google Chrome version 62.0, Apple Safari version 9.1.1, Mozilla
    Firefox 57.0, and Microsoft Edge 15.0\. It is recommended that you use a web browser
    that has the same version, or above the version, provided in this list.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，IGWEB已经验证可以在以下Web浏览器中运行：Google Chrome版本62.0，Apple Safari版本9.1.1，Mozilla
    Firefox 57.0和Microsoft Edge 15.0。建议您使用与此列表中提供的版本相同或更高版本的Web浏览器。
- en: Measurable benefits
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可衡量的好处
- en: The methodology to develop an isomorphic web application using Go, that is presented
    in this book, has proven, measurable benefits with regard to providing an enhanced
    user experience.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本书介绍的使用Go开发同构Web应用程序的方法已经被证明在提供增强用户体验方面具有可衡量的好处。
- en: 'We can use the Google PageSpeed Insights tool ([https://developers.google.com/speed/pagespeed/insights/](https://developers.google.com/speed/pagespeed/insights/)) to
    evaluate the performance of IGWEB''s home page. The tool measures how well a web
    page delivers a good user experience, on a scale of 0 to 100, based on various
    criteria, namely the organization of web page content, size of static assets,
    and time taken to render the web page:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Google PageSpeed Insights工具（[https://developers.google.com/speed/pagespeed/insights/](https://developers.google.com/speed/pagespeed/insights/)）来评估IGWEB首页的性能。该工具根据网页内容的组织、静态资产的大小和呈现网页所需的时间等各种标准，评估网页提供良好用户体验的程度，评分从0到100。
- en: '![](img/f6b3afb1-039b-482c-9787-c9b62c27d754.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6b3afb1-039b-482c-9787-c9b62c27d754.png)'
- en: 'Figure 1.10: The result of running the IGWEB home page through the Google PageSpeed
    Insights tool'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10：通过Google PageSpeed Insights工具运行IGWEB首页的结果
- en: '*Figure 1.10* is a screenshot that shows the result of evaluating the desktop
    edition of IGWEB. At the time of writing, IGWEB scores 97/100 for the desktop
    browsing experience, and 91/100 for the mobile browsing experience. According
    to the tool, the 90+ score attained for both the desktop and mobile editions indicates
    that the IGWEB home page *applies most performance best practices and should deliver
    a good user experience*.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.10*是一个屏幕截图，显示了评估IGWEB桌面版的结果。在撰写本文时，IGWEB在桌面浏览体验方面得分为97/100，在移动浏览体验方面得分为91/100。根据该工具，桌面和移动版均达到90+分，表明IGWEB首页*应用了大多数性能最佳实践，并应该提供良好的用户体验*。'
- en: Nomenclature
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名
- en: I used the term *Isomorphic Go* as the title for my introductory presentation
    on the subject of developing isomorphic web applications in Go at **GopherCon
    India**. The title of my presentation was inspired by the term *Isomorphic JavaScript*.
    The term *Isomorphic JavaScript* was coined by Charlie Robbins in his 2011 blog
    post ([https://blog.nodejitsu.com/scaling-isomorphic-javascript-code/](https://blog.nodejitsu.com/scaling-isomorphic-javascript-code/)),
    *Scaling Isomorphic JavaScript Code*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我在**GopherCon India**上的开场演讲中使用了“等同Go”作为标题，主题是在Go中开发等同Web应用程序。我的演讲标题是受到“等同JavaScript”一词的启发。术语“等同JavaScript”是由Charlie
    Robbins在他2011年的博客文章中创造的（[https://blog.nodejitsu.com/scaling-isomorphic-javascript-code/](https://blog.nodejitsu.com/scaling-isomorphic-javascript-code/)），*Scaling
    Isomorphic JavaScript Code*。
- en: The word *isomorphism* comes from mathematics. In Greek, iso means equal and
    morphosis means to form or to shape.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: “等同”一词源自数学。在希腊语中，iso意为相等，morphosis意为形成或塑造。
- en: A debate has existed within the JavaScript community on the usage of the term
    *isomorphic* to describe a web application that contains code that can run on
    either the client or on the server. Some members of the JavaScript community prefer
    using the term *universal* instead.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript社区内存在关于使用术语“等同”的辩论，用来描述一个包含可以在客户端或服务器上运行的代码的Web应用程序。JavaScript社区的一些成员更喜欢使用术语“universal”。
- en: In my opinion, the term *isomorphic* is more appropriate, while the term *universal*
    introduces ambiguity. The ambiguity stems from the fact that the term *universal*
    carries some baggage along with it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，术语“等同”更合适，而术语“universal”引入了歧义。这种歧义源于“universal”一词带有一些附加含义。
- en: Apple has widely used the term *universal binary* to describe fat binaries that
    contain machine code for multiple processor architectures. Modern JavaScript code
    gets compiled into machine code by a just-in-time compiler.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果广泛使用术语“通用二进制”来描述包含多个处理器架构的机器代码的fat二进制文件。现代JavaScript代码通过即时编译器编译为机器代码。
- en: Therefore, using the term *universal* is ambiguous, and requires extra detail,
    to determine the context in which it is used. For this reason, the preferred term
    that will be used in this book is *isomorphic*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用术语“universal”是模棱两可的，并且需要额外的细节来确定其使用的上下文。因此，本书中将使用的首选术语是“等同”。
- en: Prerequisites
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: This book focuses on teaching you how to create an isomorphic web application
    using the Go programming language. Since we will be taking an idiomatic approach
    that focuses exclusively on Go, it is not necessary to have prior familiarity
    with libraries and tools from the JavaScript ecosystem.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本书侧重于教授如何使用Go编程语言创建等同Web应用程序。由于我们将采用一种以Go为重点的成语化方法，因此不需要事先熟悉JavaScript生态系统中的库和工具。
- en: We assume that the reader has some level of prior programming experience in
    Go, or some other server-side programming language.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设读者在Go或其他服务器端编程语言方面具有一定的先前编程经验。
- en: 'If you have never programmed in Go, I would recommend that you refer to *A Tour
    of Go* available at: [https://tour.golang.org](https://tour.golang.org).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前从未在Go中编程，我建议您参考[https://tour.golang.org](https://tour.golang.org)上提供的《Go之旅》。
- en: For a more in-depth study of fundamental Go concepts, I would recommend that
    you take my video course, *Go Essentials For Full Stack Web Development,* *Packt
    Publishing*, available at [https://www.packtpub.com/web-development/go-essentials-full-stack-web-development-video](https://www.packtpub.com/web-development/go-essentials-full-stack-web-development-video).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要更深入地学习基本的Go概念，我建议您观看我的视频课程《全栈Web开发的Go基础》，*Packt Publishing*，可在[https://www.packtpub.com/web-development/go-essentials-full-stack-web-development-video](https://www.packtpub.com/web-development/go-essentials-full-stack-web-development-video)上找到。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we provided an introduction to Isomorphic Go. We covered the
    many advantages that the Go programming language provides, and why it makes a
    compelling choice for the creation of isomorphic web applications.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了等同Go。我们介绍了Go编程语言提供的许多优势，以及为什么它是创建等同Web应用程序的一个引人注目的选择。
- en: We reviewed the traditional web application architectures, which included the
    classic web application architecture, the AJAX application architecture, and the
    SPA architecture. We identified the advantages and disadvantages of each traditional
    architecture. We introduced the isomorphic web application architecture and presented
    how it solved all the shortcomings of the traditional architectures.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了传统的Web应用程序架构，包括经典的Web应用程序架构、AJAX应用程序架构和SPA架构。我们确定了每种传统架构的优缺点。我们介绍了同构Web应用程序架构，并展示了它是如何解决传统架构的所有缺点的。
- en: We presented a live demo of IGWEB, an Isomorphic Go website, and introduced
    you to the Google PageSpeed Insight tool to measure web page performance. Finally,
    we provided you with some background on the term *isomorphic* and the items that
    you need to know to make the most out of understanding the material covered in
    this book.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了IGWEB的现场演示，这是一个同构Go网站，并向您介绍了Google PageSpeed Insight工具，用于衡量网页性能。最后，我们为您提供了一些关于术语“同构”以及您需要了解的内容，以便充分理解本书涵盖的材料。
- en: In [Chapter 2](9b9730ea-ae72-4285-be30-58f2f8ab2f1e.xhtml), *The Isomorphic
    Go Toolchain*, we will introduce you to the key technologies used to develop Isomorphic
    Go web applications. We will also introduce you to IGWEB, the Isomorphic Go website,
    that we will be building over the course of this book.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](9b9730ea-ae72-4285-be30-58f2f8ab2f1e.xhtml)中，“同构Go工具链”，我们将向您介绍开发同构Go
    Web应用程序所使用的关键技术。我们还将向您介绍IGWEB，这是一个同构Go网站，我们将在本书的过程中构建。
