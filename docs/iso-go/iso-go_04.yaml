- en: Isomorphic Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同构模板
- en: In the previous chapter, we provided an introduction to GopherJS, and we covered
    code examples to perform various front-end operations. One of the interesting
    tasks that we performed on the client side, was template rendering, using an inline
    Go template. However, rendering inline Go templates in the web browser is not
    a maintainable solution. For one thing, mixing HTML code from an inline Go template,
    along with Go source code, can become an unmaintainable arrangement as the project
    codebase grows. In addition to this, real-world web applications often require
    having multiple template files that are often nested together with a layout hierarchy
    in mind. In addition to that, the template package from Go's standard library
    was designed particularly for templates rendered on the server side since it depends
    on accessing template files from the filesystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了GopherJS，并涵盖了执行各种前端操作的代码示例。我们在客户端执行的有趣任务之一是使用内联Go模板进行模板渲染。然而，在Web浏览器中呈现内联Go模板并不是一个可维护的解决方案。首先，将HTML代码与Go源代码混合在一起，随着项目代码库的增长，可能会变得难以维护。此外，现实世界的Web应用程序通常需要具有多个模板文件，这些文件通常以布局层次结构嵌套在一起。除此之外，Go标准库中的模板包特别设计用于在服务器端呈现模板，因为它依赖于从文件系统访问模板文件。
- en: To fully unleash the power of templates across environments, we need a solution
    that provides more flexibility to render any template within a set of templates
    for a given project. This flexibility can be found by implementing isomorphic
    template rendering using the `isokit` package from the Isomorphic Go toolkit.
    Using the functionality from the `isokit` package, we can render a template belonging
    to a template set, either on the server side or on the client side, and we'll
    show you exactly how that's done in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分发挥模板在各种环境中的功能，我们需要一个解决方案，提供更多灵活性，以在给定项目的一组模板中呈现任何模板。通过使用Isomorphic Go工具包中的`isokit`包，可以找到这种灵活性。使用`isokit`包的功能，我们可以在服务器端或客户端呈现属于模板集的模板，并且我们将在本章中向您展示如何实现这一点。
- en: 'Specifically, we will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章将涵盖以下主题：
- en: The web template system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页模板系统
- en: IGWEB page structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IGWEB页面结构
- en: Template categories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板类别
- en: Custom template functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义模板函数
- en: Feeding data to the content template
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向内容模板提供数据
- en: Isomorphic template rendering
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同构模板渲染
- en: The web template system
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网页模板系统
- en: In web programming, a **web template** is a text document that describes the
    format in which a web page should appear to the user. In this book, we will focus
    on web templates from Go's `html/template` package—the package that implements
    data-driven templates suitable for use in web applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web编程中，**网页模板**是描述网页应如何呈现给用户的文本文档。在本书中，我们将专注于Go的`html/template`包中的Web模板——该包实现了适用于Web应用程序的数据驱动模板。
- en: Web templates (we'll refer to them simply as *templates* moving forward) are
    text documents, that are typically implemented in HTML, and may contain special
    commands that are embedded inside of them. In Go, we refer to these commands as
    *actions.* We denote actions in templates by placing them inside a pair of opening
    and closing double curly braces—`{{` and `}}`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Web模板（我们将在以后简称为*模板*）是文本文档，通常以HTML实现，并可能包含嵌入其中的特殊命令。在Go中，我们将这些命令称为*操作*。我们通过将它们放在一对开放和关闭的双大括号中（`{{`和`}}`）来表示模板中的操作。
- en: Templates form the means to present data to the user in a manner that is intuitive
    and acceptable. In fact, you can think of a template as the means by which we
    dress up data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是以直观和可接受的方式向用户呈现数据的手段。实际上，您可以将模板视为我们打扮数据的手段。
- en: In this book, we will use the file extension of `.tmpl` to designate Go template
    source files. You may notice that some other Go projects use the file extension
    of `.html` instead. There is no hard set rule to prefer one extension over the
    other, just remember that once you choose which file extension to use, it's best
    to stick with it to promote uniformity in the project codebase.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用`.tmpl`文件扩展名来指定Go模板源文件。您可能会注意到其他一些Go项目使用`.html`扩展名。没有硬性规定要优先选择其中一个扩展名，只需记住一旦选择了要使用的文件扩展名，最好坚持使用它，以促进项目代码库的统一性。
- en: 'Templates are used in conjunction with a **web template system**. In Go, we
    have the robust `html/template` package from the standard library to render templates. When
    we use the term *render template*, we refer to the process by which one or more
    templates, along with a **data object**, is processed through a **template engine**
    that generates HTML web page output, as depicted in *Figure 4.1*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模板与**网页模板系统**一起使用。在Go中，我们有强大的`html/template`包来呈现模板。当我们使用术语*呈现模板*时，我们指的是通过**模板引擎**处理一个或多个模板以及**数据对象**的过程，生成HTML网页输出，如*图4.1*所示：
- en: '![](img/e3e99fcd-9757-43c8-a6ef-4409d6d14330.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3e99fcd-9757-43c8-a6ef-4409d6d14330.png)'
- en: 'Figure 4.1: How a web page is rendered by a web template system'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：网页模板系统如何呈现网页
- en: The key components in *Figure 4.1*, the **template engine**, the **template
    data object**, and the **templates**, can be classified as comprising a **web
    template system**. Each component plays an important role toward rendering the
    web page output, and in the following sections, we'll consider the role that each
    component plays in this process of producing the HTML output to display in the
    web browser. In this chapter, we will build IGWEB's About page.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.1*中的关键组件，**模板引擎**、**模板数据对象**和**模板**，可以被归类为**网页模板系统**的组成部分。每个组件在呈现网页输出方面都起着重要作用，在接下来的章节中，我们将考虑每个组件在生成要在Web浏览器中显示的HTML输出过程中所起的作用。在本章中，我们将构建IGWEB的关于页面。'
- en: The template engine
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板引擎
- en: The major responsibility of a template engine is to take one or more template
    files, along with a data object, and generate text output. In our specific field
    of study, isomorphic web development, this text output is in the HTML format and
    can be consumed by web clients. In Go, the `html/template` package can be considered
    as our template engine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎的主要责任是获取一个或多个模板文件以及一个数据对象，并生成文本输出。在我们特定的研究领域，等距网络开发中，这种文本输出是以HTML格式的，并且可以被Web客户端消耗。在Go中，`html/template`包可以被视为我们的模板引擎。
- en: The template engine is activated by the route handler, when it's time to serve
    the HTML output. From the perspective of an isomorphic web application, the template
    engine can be activated by both the server-side route handler and the client-side
    route handler.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板引擎激活时，由路由处理程序激活，当需要提供HTML输出时。从等距网络应用程序的角度来看，模板引擎可以由服务器端路由处理程序和客户端路由处理程序激活。
- en: When the template engine is activated from the server-side route handler, the
    produced HTML web page output is written out to the web client in the server response,
    by the web server instance, using `http.ResponseWriter`. This activity typically
    occurs when a page on the website is accessed for the first time, and the initial
    page request is serviced on the server side. In this scenario, the HTML that is
    returned from the template engine describes a full HTML web page document and
    includes the opening and closing `<html>` and `<body>` tags.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板引擎从服务器端路由处理程序激活时，生成的HTML网页输出将通过Web服务器实例使用`http.ResponseWriter`写入到服务器响应中的Web客户端。这种活动通常发生在首次访问网站上的页面时，并且初始页面请求在服务器端得到服务。在这种情况下，从模板引擎返回的HTML描述了完整的HTML网页文档，并包括开头和结尾的`<html>`和`<body>`标签。
- en: When the template engine is activated from the client-side route handler, the
    produced HTML content is rendered in a designated area of a fully rendered web
    page. We will be rendering HTML content on the client side for a given web page
    on IGWEB in a designated area, known as the *primary content area.* We will cover
    the primary content area, a `<div>` container, later in this chapter. Client-side
    template rendering typically occurs on a subsequent user interaction with the
    website, such as when the user clicks on a link in the navigation bar to access
    a particular page on the website. In this scenario, the HTML that is returned
    from the template engine represents only a portion of a HTML web page.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板引擎从客户端路由处理程序激活时，生成的HTML内容将呈现在完全呈现的网页的指定区域。我们将在IGWEB上的特定区域为给定网页的客户端呈现HTML内容，该区域称为*主要内容区域*。我们将在本章后面讨论主要内容区域，即`<div>`容器。客户端模板呈现通常发生在用户与网站进行后续交互时，例如当用户单击导航栏中的链接以访问网站上的特定页面时。在这种情况下，从模板引擎返回的HTML仅代表HTML网页的一部分。
- en: Worth nothing is that Go comes with two template packages. The `text/template`
    package is used to generate text, and the `html/template` package is meant to
    be used to generate HTML output. The `html/template` package provides the same
    interface as the `text/template` package. In this book, we are specifically interested
    in generating the HTML web page output, and this is why we will be focusing on
    the `html/template` package. The `html/template` package provides us with extra
    security by generating the HTML output that is safe against code injection, which
    the regular `text/template` package doesn't do. This is why it's best to use the
    `html/template` package for the purpose of web development.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Go带有两个模板包。`text/template`包用于生成文本，`html/template`包用于生成HTML输出。`html/template`包提供与`text/template`包相同的接口。在本书中，我们特别关注生成HTML网页输出，这就是为什么我们将专注于`html/template`包的原因。`html/template`包通过生成安全的HTML输出提供了额外的安全性，而常规的`text/template`包则不会这样做。这就是为什么最好使用`html/template`包进行Web开发的目的。
- en: The template data object
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板数据对象
- en: The major responsibility of the template data object (or simply the *data object*)
    is to supply a given template with data that is to be presented to the user. In
    the About page that we will be constructing, there are two pieces of data that
    need to be presented. The first need is subtle, it's the title of the web page
    that will be displayed in the web browser's title bar window, or as the title
    of the web browser tab containing the web page. The second data need is more profound,
    it is the data object, the list of gophers that should be displayed on the About
    page.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模板数据对象（或简称*数据对象*）的主要责任是为给定模板提供要呈现给用户的数据。在我们将要构建的“关于”页面中，有两个需要呈现的数据。第一个需求是微妙的，它是将显示在Web浏览器标题栏窗口中的网页标题，或作为包含网页的Web浏览器选项卡的标题。第二个数据需求更深刻，它是数据对象，应在“关于”页面上显示的土拨鼠列表。
- en: 'We will use the following `About` struct from the `templatedata` package, defined
    in the `shared/templatedata/about.go` source file, to fulfill the data needs of
    the About page:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`shared/templatedata/about.go`源文件中定义的`templatedata`包中的以下`About`结构来满足“关于”页面的数据需求：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `PageTitle` field represents the web page title that should be displayed
    in the web browser's title bar (or as the title of the web browser tab). The `Gophers`
    field is a slice of pointers to a `Gopher` struct. The `Gopher` struct represents
    a gopher, a member of the IGWEB team, that should be displayed on the About page.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageTitle`字段表示应在Web浏览器标题栏中显示的网页标题（或作为Web浏览器选项卡的标题）。`Gophers`字段是指向`Gopher`结构的指针切片。`Gopher`结构表示应在“关于”页面上显示的土拨鼠，即IGWEB团队的成员。'
- en: 'The definition for the `Gopher` struct can be found in the `gopher.go` source
    file found in the `shared/models` folder:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gopher`结构的定义可以在`shared/models`文件夹中的`gopher.go`源文件中找到：'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Name` field represents the name of the Gopher. The `Title` field represents
    the title that the IGWEB organization has bestowed to a particular gopher. The
    `Biodata` field represents a brief bio about a particular gopher. We used a loren
    ipsum generator, to generate some random gibberish in Latin, to populate this
    field. The `ImageURI` field is the path to the image of the gopher that should
    be displayed, relative to the server root. The gopher's image will be displayed
    on the left-hand side of the page, and the the gopher's profile information will
    be displayed on the right-hand side of the page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Name`字段代表地鼠的姓名。`Title`字段代表IGWEB组织赋予特定地鼠的头衔。`Biodata`字段代表特定地鼠的简要个人资料。我们使用了loren
    ipsum生成器，在这个字段中生成了一些拉丁文的随机胡言乱语。`ImageURI`字段是应该显示的地鼠图片的路径，相对于服务器根目录。地鼠的图片将显示在页面的左侧，地鼠的个人资料将显示在页面的右侧。'
- en: Finally, the `StartTime` field represents the date and time that the gopher
    joined the IGWEB organization. We will be displaying the gopher's start time in
    the standard time format, and later in this chapter we will learn how to display
    the start time using Ruby-style formatting by implementing a custom template function.
    In [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml), *Cogs – Reusable Components*,
    we will learn how to display the start time in the human readable time format.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`StartTime`字段代表地鼠加入IGWEB组织的日期和时间。我们将以标准时间格式显示地鼠的开始时间，本章后面我们将学习如何通过实现自定义模板函数来使用Ruby风格格式显示开始时间。在[第9章](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml)，*齿轮-可重用组件*中，我们将学习如何以人类可读的时间格式显示开始时间。
- en: The templates
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: Templates are responsible for presenting information to the user in an intuitive
    and understandable manner. Templates form the view layer of the isomorphic web
    application. Go templates are a combination of standard HTML markup mixed with
    a lightweight template language that provides us with the means to perform token
    substitution, looping, conditional flow of control, template nesting, and the
    ability to call custom template functions within the template using pipelining
    constructs. All of the aforementioned activities can be performed using template
    actions, and we will be using them throughout this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 模板负责以直观和易懂的方式向用户呈现信息。模板构成同构Web应用的视图层。Go模板是标准HTML标记和轻量级模板语言的组合，它为我们提供了执行标记替换、循环、条件控制流、模板嵌套以及使用管道构造在模板中调用自定义模板函数的手段。所有上述活动都可以使用模板操作来执行，我们将在本书中使用它们。
- en: The templates for the IGWEB project can be found in the `shared/templates` folder.
    They are considered as isomorphic templates, since they can be utilized on the
    server side and on the client side. We will now explore the web page layout organization
    of IGWEB, and directly after that, we will examine the templates needed to implement
    the structure of a web page on IGWEB.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: IGWEB项目的模板可以在`shared/templates`文件夹中找到。它们被视为同构模板，因为它们可以在服务器端和客户端上使用。现在我们将探索IGWEB的网页布局组织，然后直接查看实现IGWEB网页结构所需的模板。
- en: IGWEB page structure
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IGWEB页面结构
- en: '*Figure 4.2* depicts a wireframe design illustrating the structure of a web
    page on IGWEB. The figure provides us with a good idea of the fundamental layout
    and navigational needs of the website:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.2*描绘了IGWEB网页结构的线框设计。该图为我们提供了网站的基本布局和导航需求的良好想法：'
- en: '![](img/3c6bfd34-adfd-4181-ae26-8bdcdae0d8ea.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c6bfd34-adfd-4181-ae26-8bdcdae0d8ea.png)'
- en: 'Figure 4.2: IGWEB wireframe design'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：IGWEB线框设计
- en: 'By organizing the web page structure into these individual areas, we can demarcate
    the unique function(s) that each area plays in the web page structure as a whole.
    Let''s go ahead and examine each individual area that comprises the page structure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将网页结构组织成这些个别区域，我们可以划分出每个区域在整个网页结构中所扮演的独特功能。让我们继续检查构成页面结构的每个个别区域。
- en: The header
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页眉
- en: The primary content area
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要内容区域
- en: The footer
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页脚
- en: The header
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页眉
- en: The header area, as depicted in *Figure 4.2*, appears at the top of the web
    page. It marks the beginning of the web page, and it is useful for the purposes
    of branding, navigation, and user interactivity. It is comprised of the top bar
    and the navigation bar.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图4.2*所示，页眉区域出现在网页顶部。它标志着网页的开始，并且对品牌、导航和用户交互很有用。它由顶部栏和导航栏组成。
- en: The top bar
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶部栏
- en: As depicted in *Figure 4.2*, the top bar is a subarea that exists within the
    header. At the left-most side of the top bar is the logo for IGWEB. Besides having
    an obvious function for branding purposes, the logo also serves as a navigational
    component, since when the user clicks on it, they will be returned to the home
    page. At the right-most side of the top bar are ancillary user controls to activate
    specific functionality—the shopping cart and the live chat feature.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图4.2*所示，顶部栏是存在于页眉内的子区域。在顶部栏的最左侧是IGWEB的标志。除了用于品牌目的，标志还作为导航组件，因为用户点击它时，他们将返回到主页。在顶部栏的最右侧是辅助用户控件，用于激活特定功能——购物车和实时聊天功能。
- en: The navigation bar
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航栏
- en: The navigation bar, as depicted in *Figure 4.2*, is a subarea that exists within
    the header. The navigation area consists of links to various pages on the website.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图4.2*所示，导航栏是存在于页眉内的子区域。导航区域包括指向网站各个页面的链接。
- en: The primary content area
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要内容区域
- en: The primary content area, as depicted in *Figure 4.2*, is sandwiched between
    the header area and the footer area. The contents of an individual web page will
    be displayed here. For example, the About page will display the pictures and profile
    information for the IGWEB team gophers in the primary content area.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 主要内容区域，如*图4.2*所示，位于页眉区域和页脚区域之间。网页的内容将显示在这里。例如，关于页面将在主要内容区域显示IGWEB团队地鼠的图片和简介信息。
- en: The footer
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页脚
- en: The footer area, as depicted in *Figure 4.2*, appears at the bottom of the web
    page. It contains the copyright notice of the website. The footer marks the end
    of the web page.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图4.2*所示，页脚区域出现在网页底部。它包含网站的版权声明。页脚标志着网页的结束。
- en: Now that we have established the web page structure for IGWEB, we will learn
    how we can implement the structure using a preplanned hierarchy of Go templates.
    To improve our understanding, we will organize templates into categories based
    on their functional purpose.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为IGWEB建立了网页结构，我们将学习如何使用预先计划的Go模板层次结构来实现结构。为了提高我们的理解，我们将根据它们的功能目的将模板组织成类别。
- en: Template categories
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板类别
- en: 'Organizing templates into categories based on their functional purpose allows
    us to be productive when implementing the structure of a web page. Templates can
    be organized into the following three categories, based on the role they serve
    in implementing the web page structure:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据功能目的将模板组织成类别，可以让我们在实现网页结构时更加高效。模板可以根据它们在实现网页结构中所起的作用，分为以下三类：
- en: Layout templates
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局模板
- en: Partial templates
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分模板
- en: Regular templates
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规模板
- en: '**Layout templates** describe the general layout of the entire web page. They
    provide us with a bird''s-eye view of the page structure and give us a sense of
    how all the other templates fit in.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**布局模板**描述整个网页的一般布局。它们为我们提供了页面结构的鸟瞰图，并让我们了解所有其他模板如何适应其中。'
- en: '**Partial templates** contain only a part of the web page, and hence they are
    named **partials**. They are partial in nature, since they are meant to fulfill
    a particular need within a region of the web page, such as displaying the footer
    of the web page.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**部分模板**只包含网页的一部分，因此它们被称为**部分**。它们是部分性质的，因为它们旨在满足网页区域内的特定需求，比如显示网页的页脚。'
- en: '**Regular templates** contain content that is meant for a specific section
    of the website, and this content is meant to be displayed in the primary content
    area. In the following sections, we will examine each template category, and consider
    the respective template implementation performed for each category.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**常规模板**包含特定网站部分的内容，并且这些内容应该显示在主要内容区域。在接下来的部分中，我们将检查每个模板类别，并考虑为每个类别执行的相应模板实现。'
- en: Layout templates
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局模板
- en: A page layout template, also known as a **layout template**, holds the structure
    of the entire web page. Since they define the overall structure for the web page,
    they require other templates (partial and regular) to complete them. For isomorphic
    web applications, these types of templates are used to render the web page on
    the server side for the initial web page response, that is sent to the client. In
    the IGWEB project, we place layout templates in the `shared/templates/layouts` folder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 页面布局模板，也称为**布局模板**，包含整个网页的结构。由于它们定义了网页的整体结构，它们需要其他模板（部分和常规）来完成。对于同构的网络应用程序，这些类型的模板用于在服务器端呈现网页，用于发送到客户端的初始网页响应。在IGWEB项目中，我们将布局模板放在`shared/templates/layouts`文件夹中。
- en: The web page layout template
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网页布局模板
- en: 'Here''s the web page layout template found in the `webpage_layout.tmpl` source
    file in the `shared/templates/layouts` directory:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`shared/templates/layouts`目录中的`webpage_layout.tmpl`源文件中找到的网页布局模板：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the layout template covers the entire web page, from the opening
    `<html>` tag to the closing `</html>` tag. The layout template issues the `template`
    actions (shown in bold) to render the `header` partial template, the `pagecontent`
    regular template, and the `footer` partial template.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，布局模板覆盖了整个网页，从开头的`<html>`标签到结束的`</html>`标签。布局模板发出了渲染`header`部分模板、`pagecontent`常规模板和`footer`部分模板的`template`动作（以粗体显示）。
- en: The dot `.` between the `partials/header_partial` template name and the closing
    pair of curly braces, `}}`, is known as an action. The template engine considers
    this to be a command that is to be replaced with the value of the data object
    that is fed into the template upon the execution of the template. By placing the
    dot here, we ensure that the header partial template, which is responsible for
    displaying the content in the header area of the website, has access to the data
    object that was fed into the template. Notice that we have done the same thing,
    for the `pagecontent` template, and the `partials/footer_partial` template.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`partials/header_partial`模板名称和闭合的一对大括号`}}`之间的点`.`被称为动作。模板引擎认为这是一个命令，应该用在模板执行时传入的数据对象的值来替换。通过在这里放置点，我们确保页眉部分模板可以访问被传入模板的数据对象，这个模板负责显示网站页眉区域的内容。请注意，我们对`pagecontent`模板和`partials/footer_partial`模板也做了同样的操作。
- en: Partial templates
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分模板
- en: Partial templates, also known as **partials**, typically hold portions of content
    for a specific area of the web page. Examples of a partial template include the
    header and footer of the web page. Partial templates for the header and footer
    come in very handy when including them in the page layout template, since the
    header and footer will be preset on all web pages in the website. Let's examine
    how the header and footer partial templates are implemented. In the IGWEB project,
    we place partial templates in the `shared/templates/partials` folder.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 部分模板，也称为**部分**，通常包含网页特定区域的部分内容。部分模板的示例包括网页的页眉和页脚。当在页面布局模板中包含页眉和页脚时，页眉和页脚部分模板非常有用，因为页眉和页脚将预设在网站的所有网页上。让我们看看页眉和页脚部分模板是如何实现的。在IGWEB项目中，我们将部分模板放在`shared/templates/partials`文件夹中。
- en: The header partial template
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页眉部分模板
- en: 'Here''s an example of the header partial found in the `header_partial.tmpl`
    source file in the `shared/templates/partials` folder:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`shared/templates/partials`文件夹中的`header_partial.tmpl`源文件中找到的页眉部分的示例：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Between the opening `<head>` and closing `</head>` tags, we include the icon
    for the website along with external CSS style sheets and external JavaScript source
    files. The `igweb.css` stylesheet defines the styles for the IGWEB website (shown
    in bold). The `client.js` JavaScript source file, is the JavaScript source file
    for the client-side web application, which is transpiled into JavaScript by GopherJS
    (shown in bold).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在开头的`<head>`和结尾的`</head>`标签之间，我们包括网站图标以及外部CSS样式表和外部JavaScript源文件。`igweb.css`样式表定义了IGWEB网站的样式（以粗体显示）。`client.js`
    JavaScript源文件是客户端Web应用程序的JavaScript源文件，它通过GopherJS转译为JavaScript（以粗体显示）。
- en: Notice that we render the top bar, and the navigation partial templates, inside
    the header partial template using the `template` actions (shown in bold). We don't
    include the dot `.` here, since these partials don't need access to the data object.
    Both the content for the top bar and the navigation bar are within their own respective
    `<div>` containers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在头部部分模板中使用`template`操作（以粗体显示）来呈现顶部栏和导航栏部分模板。我们在这里不包括点`.`，因为这些部分模板不需要访问数据对象。顶部栏和导航栏的内容都在各自的`<div>`容器中。
- en: The top bar partial template
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶部栏部分模板
- en: 'Here''s the top bar partial template found in the `topbar_partial.tmpl` source
    file in the `shared/templates/partials` folder:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`shared/templates/partials`文件夹中的`topbar_partial.tmpl`源文件中找到的顶部栏部分模板：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The top bar partial template is a good example of a static template where there's
    no dynamic action going on. There are no `template` actions defined within it,
    and it's main purpose is to include the HTML markup to render the website logo,
    the shopping cart icon, and the live chat icon.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部栏部分模板是一个静态模板的很好例子，其中没有动态操作。它没有在其中定义`template`操作，它的主要目的是包含HTML标记以呈现网站标志、购物车图标和在线聊天图标。
- en: The navigation bar partial template
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航栏部分模板
- en: 'Here''s an example of the navigation bar partial template found in the `navbar_partial.tmpl`
    source file in the `shared/templates/partials` folder:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`shared/templates/partials`文件夹中的`navbar_partial.tmpl`源文件中找到的导航栏部分模板的示例：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The navigation bar partial template is also a static template. It contains the
    `div` container that contains the list of navigation links that make up IGWEB's
    navigation bar. These links allow users to access the Home, Products, About, and
    Contact pages.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏部分模板也是一个静态模板。它包含一个`div`容器，其中包含组成IGWEB导航栏的导航链接列表。这些链接允许用户访问主页、产品、关于和联系页面。
- en: The footer partial template
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页脚部分模板
- en: 'Here''s an example of the footer partial template found in the `footer_partial.tmpl`
    source file in the `shared/templates/partials` folder:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`shared/templates/partials`文件夹中的`footer_partial.tmpl`源文件中找到的页脚部分模板的示例：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The footer partial template is also a static template, whose current, sole purpose
    is to have the HTML markup that contains the copyright notice for the IGWEB website.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 页脚部分模板也是一个静态模板，其当前唯一目的是包含IGWEB网站的版权声明的HTML标记。
- en: Now that we've covered all the partial templates that comprise the web page
    structure, it's time to examine what a regular template looks like, both from
    the perspective of the server side and that of the client side.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了构成网页结构的所有部分模板，是时候来看看常规模板从服务器端和客户端的角度看是什么样子了。
- en: Regular templates
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常规模板
- en: A **regular template** is used to hold the primary content that is to be displayed
    on the web page. For example, in the About page, the primary content would be
    the information about the gophers on the IGWEB team along with their individual
    pictures.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**常规模板**用于保存要在网页上显示的主要内容。例如，在关于页面中，主要内容将是关于IGWEB团队地鼹鼠的信息以及他们个人的图片。'
- en: 'In this chapter, we will build the About page. We can see exactly what will
    go into the primary content area in the About page, by examining its wireframe
    design depicted in *Figure 4.3*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建关于页面。通过检查其线框设计（见*图4.3*），我们可以清楚地看到关于页面主要内容区域中的内容：
- en: '![](img/827e74b7-b222-454c-a3a3-ebee1049e08a.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/827e74b7-b222-454c-a3a3-ebee1049e08a.png)'
- en: 'Figure 4.3: Wireframe design for the about page'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：关于页面的线框设计
- en: For each gopher on the IGWEB team, we will display the gopher's picture, its
    name, its title, and a brief description about its role (randomly generated Latin
    gibberish). We will also display the date/time that the gopher joined the IGWEB
    team in several different time formats.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IGWEB团队中的每只地鼹鼠，我们将显示地鼹鼠的图片、姓名、头衔以及关于其角色的简要描述（随机生成的拉丁文胡言乱语）。我们还将以几种不同的时间格式显示地鼹鼠加入IGWEB团队的日期/时间。
- en: We will render the About page in two markedly different ways, depending on whether
    the rendering takes place on the server side or the client side. On the server
    side, when we render the About page, we are in need of a page template, that is
    a regular template, that contains the layout for the whole web page, in addition
    to containing the content of the About page. On the client side, we only need
    to render the content contained in the About page to populate the primary content
    area, since the web page has already been rendered for us from the initial page
    load.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以明显不同的方式呈现关于页面，具体取决于呈现是在服务器端还是客户端进行。在服务器端，当我们呈现关于页面时，我们需要一个页面模板，即一个常规模板，其中包含整个网页的布局，以及包含关于页面的内容。在客户端，我们只需要呈现关于页面中包含的内容以填充主要内容区域，因为网页已经在初始页面加载时为我们呈现出来。
- en: 'At this point, we can define two subcategories of regular templates: a *page
    template* that will serve our server-side rendering needs, and a *content template* that
    will serve our client-side rendering needs. In the IGWEB project, we will place
    regular templates in the `shared/templates` folder.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以定义常规模板的两个子类别：*页面模板*将满足我们的服务器端渲染需求，*内容模板*将满足我们的客户端渲染需求。在IGWEB项目中，我们将把常规模板放在`shared/templates`文件夹中。
- en: The page template for the about page
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于页面的页面模板
- en: 'Here''s an example of the page template for the About page, from the `about_page.tmpl`
    source file in the `shared/templates` folder:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于页面的页面模板示例，来自`shared/templates`文件夹中的`about_page.tmpl`源文件：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use the `define` action in the page template, to define the region of the
    template that contains the template section that we have declared as the `pagecontent`
    section. We have a corresponding `end` action to mark the end of the `pagecontent`
    section. Notice that we have a template action in between the define and end actions
    to include the template named `about_content`. Also note that we provide the dot
    (`.`) action to pass the data object to the `about_content` template.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在页面模板中使用`define`操作来定义包含我们声明为`pagecontent`部分的模板部分的区域。我们有一个相应的`end`操作来标记`pagecontent`部分的结束。请注意，在定义和结束操作之间，我们使用模板操作来包含名为`about_content`的模板。还要注意，我们使用点（`.`）操作将数据对象传递给`about_content`模板。
- en: This page template is a good example that shows how we can render layout templates
    inside of a regular template. In the last line of the template, we declare a `template`
    action to load the layout template for the web page that is named `layouts/webpage_layout`.
    Again, notice that we provide the dot (`.`) action to pass the data object to
    the web page layout template.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面模板是一个很好的示例，显示了我们如何在常规模板中呈现布局模板。在模板的最后一行，我们声明了一个`template`操作，以加载名为`layouts/webpage_layout`的网页布局模板。再次注意，我们使用点（`.`）操作将数据对象传递给网页布局模板。
- en: Now that we've examined the `about_page` template, it's time to examine the
    `about_content` template.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了`about_page`模板，是时候检查`about_content`模板了。
- en: The content template for the about page
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于页面的内容模板
- en: 'Here''s an example of the content template, which is rendered into the primary
    content area found in the About page, from the `about_content.tmpl` source file
    in the `shared/templates` folder:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是内容模板的示例，该模板被呈现到关于页面中的主要内容区域中，来自`shared/templates`文件夹中的`about_content.tmpl`源文件：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use the `range` action to iterate through the Gophers property of the data
    object supplied to the template (shown in bold). Notice that we use the dot (`.`)
    action to access the `Gophers` property of the data object. Remember, the Gophers
    property is a slice of pointers to a `Gopher` struct. We print out the fields
    of each `Gopher` struct, in their designated area in the template, using the dot
    (`.`) action (shown in bold). We use the `end` action to denote the end of the
    `range` looping action (shown in bold).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`range`操作来遍历模板提供的数据对象的Gophers属性（以粗体显示）。请注意，我们使用点（`.`）操作来访问数据对象的`Gophers`属性。请记住，`Gophers`属性是指向`Gopher`结构的指针切片。我们使用`end`操作来表示`range`循环操作的结束（以粗体显示）。
- en: Important to note is that the content template is required on both the server
    side and the client side. Remember, that on the server side, the full web page
    layout needs to be rendered, in addition to the content template. On the client
    side, we only need to render the content template.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，内容模板在服务器端和客户端都是必需的。请记住，在服务器端，需要呈现完整的网页布局，以及内容模板。在客户端，我们只需要呈现内容模板。
- en: Notice that in the last two places where we print the `StartTime` field using
    the dot (`.`) action, we make use of the pipe (`|`) operator to format the `StartTime`
    field using a custom function. First, we use the `rubyformat` function to show
    the `StartTime` value in Ruby date/time format, and then we use the `unixformat`
    function to populate the `"data-starttimeunix"` attribute with the Unix time representation
    of the `StartTime` value. Let's take a look at where these custom functions are
    defined in the IGWEB project codebase.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最后两个打印`StartTime`字段的地方，我们使用管道（`|`）运算符使用自定义函数格式化`StartTime`字段。首先，我们使用`rubyformat`函数以Ruby日期/时间格式显示`StartTime`值，然后我们使用`unixformat`函数将`"data-starttimeunix"`属性填充为`StartTime`值的Unix时间表示。让我们看看这些自定义函数在IGWEB项目代码库中是如何定义的。
- en: Custom template functions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义模板函数
- en: 'We defined our custom template functions in the `funcs.go` source file found
    in the `shared/templatefuncs` folder:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`shared/templatefuncs`文件夹中找到的`funcs.go`源文件中定义了我们的自定义模板函数。
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `RubyDate` function displays a given time using the time layout specified
    by the `time.RubyDate` constant. We call the function in a template using the
    `rubyformat` function name.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`RubyDate`函数使用`time.RubyDate`常量指定的时间布局显示给定的时间。我们在模板中使用`rubyformat`函数名称调用该函数。'
- en: 'As noted before, inside the about content template (`shared/templates/about_content.tmpl)`,
    we use the pipe (`|`) operator to apply the `rubyformat` function to the `StartTime`
    as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在关于内容模板（`shared/templates/about_content.tmpl`）中，我们使用管道（`|`）运算符将`rubyformat`函数应用于`StartTime`，如下所示：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this way, custom template functions provide us with the flexibility to format
    values in our templates to meet the unique needs that our project may require.
    You might be wondering, how we map the `rubyformat` name to the `RubyDate` function.
    We create a template function map that contains this mapping; we will cover how
    we can use the template function map across environments, later in this chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，自定义模板函数为我们提供了灵活性，可以在模板中格式化值，以满足项目可能需要的独特需求。也许你会想，我们如何将`rubyformat`名称映射到`RubyDate`函数。我们创建一个包含此映射的模板函数映射；我们将在本章后面介绍如何在不同环境中使用模板函数映射。
- en: The fact that the three subfolders, `templates`, `templatedata`, and `templatefuncs`,
    reside in the `shared` folder imply that the code found within these folders can
    be used across environments. In fact, any code contained within the `shared` folder
    and its subfolders, is code that's meant for sharing across environments.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`templates`、`templatedata`和`templatefuncs`这三个子文件夹位于`shared`文件夹中，这意味着这些文件夹中的代码可以在不同环境中使用。实际上，`shared`文件夹及其子文件夹中包含的任何代码都是用于在不同环境中共享的代码。'
- en: We will be covering the `UnixTime` function, referred to as the `unixformat`
    function in the template, in [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml),
    *Cogs – Reusable Components*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml)中介绍`UnixTime`函数，模板中称为`unixformat`函数，*齿轮-可重用组件*。
- en: Feeding data to the content template
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向内容模板提供数据
- en: The data object that we will feed to the about content template is a slice of
    pointers to `Gopher` structs that represent each gopher on the IGWEB team. The
    plan for feeding data to our template is to obtain a slice of gophers from the
    Redis datastore and populate the `Gophers` property of the template data object
    for the About page along with the data object's `PageTitle` property.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要提供给关于内容模板的数据对象是指向代表IGWEB团队上每只地鼠的`Gopher`结构体的指针切片。我们的模板数据对象的`Gophers`属性将从Redis数据存储中获取地鼠切片，并与数据对象的`PageTitle`属性一起填充到“关于”页面的模板数据对象中。
- en: 'We call the `GetGopherTeam` method on our datastore object to obtain a slice
    of gophers that belongs to the IGWEB team. Here''s the declaration of the `GetGopherTeam`
    function from the `redis.go` source file found in the `common/datastore` folder:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在数据存储对象上调用`GetGopherTeam`方法，以获取属于IGWEB团队的地鼠切片。以下是在`common/datastore`文件夹中找到的`redis.go`源文件中`GetGopherTeam`函数的声明：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `GetGopherTeam` function checks if the `gopher-team` key exists in the `Redis`
    database. The slice of gophers are stored as JSON-encoded data within the `Redis`
    database. If the `gopher-team` key exists, we attempt to `unmarshal` the JSON-encoded
    data into the `t` variable, which is a slice of pointers to the `Gopher` structs.
    If we were able to successfully `unmarshal` the JSON data we will return the `t` variable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetGopherTeam`函数检查`Redis`数据库中是否存在`gopher-team`键。地鼠切片以JSON编码的数据形式存储在`Redis`数据库中。如果`gopher-team`键存在，我们尝试将JSON编码的数据解码为`t`变量，这是指向`Gopher`结构体的指针切片。如果我们成功解码了JSON数据，我们将返回`t`变量。'
- en: At this point, we've created the means to fetch the data for our team of gophers
    that will be displayed on the About page. You might be wondering, why can't we
    just feed the about content template with the slice of gophers, as the data object,
    and call it a day? Why do we need to pass a data object with a type of `templatedata.About` to
    the about content template?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了获取将显示在“关于”页面上的地鼠团队数据的方法。你可能会想，为什么我们不能只是用地鼠的切片作为数据对象，将其传递给关于内容模板，然后就完成了呢？为什么我们需要传递一个类型为`templatedata.About`的数据对象给关于内容模板呢？
- en: The one-word answer to both of these questions is *extensibility*. Currently,
    the `About` section doesn't just need the slice of Gophers—it also needs a page
    title that will be displayed in the web browser's title window and/or in the web
    browser tab. So for all the sections of IGWEB, we have created accompanying structs
    to model the individual data needs for each page of the website in the `shared/templatedata`
    folder. Since the `templatedata` package is found in the `shared` folder, the
    `templatedata` package is isomorphic and can be accessed across environments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对这两个问题的一言以蔽之的答案是*可扩展性*。目前，“关于”部分不仅需要地鼠的切片，还需要一个页面标题，该标题将显示在网页浏览器的标题窗口和/或网页浏览器标签中。因此，对于IGWEB的所有部分，我们已经创建了相应的结构体，以在`shared/templatedata`文件夹中为网站的每个页面建模个别数据需求。由于`templatedata`包位于`shared`文件夹中，因此`templatedata`包是同构的，可以在各种环境中访问。
- en: 'We defined the `About` struct in the `about.go` source file found in the `shared/templatedata`
    folder:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`shared/templatedata`文件夹中的`about.go`源文件中定义了`About`结构：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `PageTitle` field of the `string` type is the title of the About page. The `Gophers` field
    is a slice of pointers pointing to the `Gopher` structs. This slice represents
    the gopher team that will be displayed on the about page. As we saw earlier in
    this chapter, we'll use the `range` action in the content template to iterate
    through the slice and display the profile information for each gopher.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageTitle`字段是`string`类型的，是“关于”页面的标题。`Gophers`字段是指向`Gopher`结构体的指针切片。这个切片代表将在关于页面上显示的地鼠团队。正如我们在本章前面看到的，我们将在内容模板中使用`range`操作来遍历切片并显示每只地鼠的个人资料信息。'
- en: Coming back to the topic of extensibility, the fields defined for the structs
    in the `templatedata` package are not meant to stay stationary and unchanging.
    They are meant to change over time to accommodate the future needs of the particular
    web page they are meant to serve.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 回到可扩展性的话题，`templatedata`包中定义的结构体字段并不是固定不变的。它们是为了随着时间的推移而改变，以适应特定网页的未来需求。
- en: For example, if an IGWEB product manager decides that they should have pictures
    of the gopher team members working, studying, and playing in the office, for public
    relations purposes, they can easily accommodate the request by adding a new field
    to the `About` struct called `OfficeActivityImages`. This new field could be a
    slice of strings that denotes the server relative path to the images of gophers,
    engaging in the various activities, that should be displayed on the About page.
    We would then add a new section in our template, where we would `range` through
    the `OfficeActivityImages` slice, and display each image.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果IGWEB产品经理决定他们应该有地鼠团队成员在办公室工作、学习和玩耍的照片，以供公共关系用途，他们可以通过向`About`结构体添加名为`OfficeActivityImages`的新字段来轻松满足这一要求。这个新字段可以是一个字符串切片，表示应该在“关于”页面上显示的地鼠图片的服务器相对路径。然后，我们将在模板中添加一个新的部分，通过`range`遍历`OfficeActivityImages`切片，并显示每张图片。
- en: At this point, we have the data needs for the About page satisfied, and we have all
    our templates lined up. It's now time to focus on how to perform the rendering
    of the templates, on both the server side and the client side. This is where isomorphic
    template rendering comes into play.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经满足了“关于”页面的数据需求，并且我们已经准备好了所有的模板。现在是时候专注于如何在服务器端和客户端执行模板的渲染了。这就是同构模板渲染发挥作用的地方。
- en: Isomorphic template rendering
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同构模板渲染
- en: Isomorphic template rendering allows us to render and reuse templates across
    environments. The traditional procedure to render templates in Go, which relies
    on accessing templates through the file system, comes with certain limitations
    that prevent us from rendering these same templates on the client side. It's important
    for us to acknowledge these limitations to fully appreciate the benefits that
    isomorphic template rendering presents for us.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 等同模板渲染允许我们在不同环境中渲染和重用模板。在Go中渲染模板的传统程序依赖于通过文件系统访问模板，但这带来了一些限制，阻止我们在客户端上渲染相同的模板。我们需要承认这些限制，以充分理解等同模板渲染为我们带来的好处。
- en: Limitations of filesystem-based template rendering
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于文件系统的模板渲染的限制
- en: When it comes to sharing template rendering responsibilities with the client,
    there are certain limitations in the template rendering workflow that we need
    to acknowledge. First, and foremost, template files are defined on the web server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在与客户端共享模板渲染责任时，我们需要承认模板渲染工作流程中的某些限制。首先，模板文件是在Web服务器上定义的。
- en: 'Let''s consider an example that follows the classic web application architecture
    to fully understand the limitations we face. Here''s an example of server-side
    template rendering using a template file, `edit.html`, taken from the *Writing
    Web Applications* article ([https://golang.org/doc/articles/wiki/](https://golang.org/doc/articles/wiki/))
    from the Go website:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，遵循经典的Web应用程序架构，以充分理解我们面临的限制。以下是一个使用模板文件`edit.html`进行服务器端模板渲染的示例，取自Go网站的*编写Web应用程序*文章（[https://golang.org/doc/articles/wiki/](https://golang.org/doc/articles/wiki/)）：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `editHandler` function is responsible for handling the `/edit` route. The
    last two lines (shown in bold) are of particular interest for our consideration.
    The `ParseFiles` function in the `html/template` package is called to parse the
    `edit.html` template file. After the template is parsed, the `Execute` function
    in the `html/template` package is called to execute the template along with the `p` data
    object, which is a `Page` struct. The produced web page output is then written
    out to the client as a web page response using `http.ResponseWriter`, `w`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`editHandler`函数负责处理`/edit`路由。最后两行（以粗体显示）特别值得我们考虑。调用`html/template`包中的`ParseFiles`函数来解析`edit.html`模板文件。模板解析后，调用`html/template`包中的`Execute`函数来执行模板以及`p`数据对象，它是一个`Page`结构。生成的网页输出然后使用`http.ResponseWriter`
    `w`作为网页响应写出到客户端。'
- en: The *Writing Web Applications* article from the Go website is an excellent article
    to learn and understand classic, sever-side web application programming with Go.
    I highly recommend that you read this article: [https://golang.org/doc/articles/wiki/](https://golang.org/doc/articles/wiki/).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Go网站的*编写Web应用程序*文章是一篇了解使用Go进行经典的服务器端Web应用程序编程的优秀文章。我强烈建议您阅读这篇文章：[https://golang.org/doc/articles/wiki/](https://golang.org/doc/articles/wiki/)。
- en: The drawback of rendering templates in this manner is that we are anchored to
    the server-side file system, where the `edit.html` template file resides. The
    dilemma we face is that the client needs access to the contents of template files
    in order to render a template on the client-side. It is not possible to make the
    `ParseFiles` function call on the client side, because we don't have access to
    any template file that can be read on the local file system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式渲染模板的缺点是，我们被锚定在服务器端文件系统上，`edit.html`模板文件所在的地方。我们面临的困境是，客户端需要访问模板文件的内容才能在客户端上渲染模板。在客户端无法调用`ParseFiles`函数，因为我们无法访问本地文件系统上可以读取的任何模板文件。
- en: The robust security sandbox implemented in modern web browsers, prevents clients
    from accessing template files from the local file system, as it rightly should.
    In contrast, calling the `ParseFiles` function makes sense, from the server side,
    since the server-side application can actually access the server-side filesystem,
    where the templates reside.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web浏览器中实施的强大安全沙箱阻止客户端从本地文件系统访问模板文件，这是正确的。相比之下，从服务器端调用`ParseFiles`函数是有意义的，因为服务器端应用程序实际上可以访问服务器端文件系统，模板就驻留在那里。
- en: So how do we get past this roadblock? The `isokit` package comes to our rescue
    by providing us the capability to gather a group of templates from the server-side
    file system, and create an in-memory template collection, called a template set.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何克服这一障碍呢？`isokit`包通过提供我们从服务器端文件系统中收集一组模板，并创建一个内存模板集的能力来拯救我们。
- en: The in-memory template set
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存中的模板集
- en: The `isokit` package comes with the functionality to render templates in an
    isomorphic manner. In order to think isomorphically, when it comes to template
    rendering, we have to step away from the thought process of rendering a template
    from the file system, as we have been much accustomed to in the past. Instead,
    we have to think in terms of maintaining a set of templates in-memory, where we
    could access a particular template by the name that we have given to it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`isokit`包具有以等同方式渲染模板的功能。为了以等同方式思考，在模板渲染时，我们必须摆脱以往在文件系统中渲染模板的思维方式。相反，我们必须考虑在内存中维护一组模板，我们可以通过给定的名称访问特定模板。'
- en: When we use the term, in-memory, we are not referring to an in-memory database,
    but rather having the template set persisted in the running application itself,
    whether it's on the server side or the client side. The template set stays resident
    in memory for the application to utilize while it is running.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用术语“内存”时，我们并不是指内存数据库，而是指模板集在运行的应用程序本身中持续存在，无论是在服务器端还是客户端。模板集在应用程序运行时保持驻留在内存中供应用程序利用。
- en: 'The `Template` type from the `isokit` package represents an isomorphic template,
    one that can be rendered either on the server side or the client side. In the
    type definition of `Template`, notice that the `*template.Template` type is embedded:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`isokit`包中的`Template`类型表示等同模板，可以在服务器端或客户端上呈现。在`Template`的类型定义中，注意到`*template.Template`类型被嵌入：'
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Embedding the `*template.Template` type allows us to tap into all the functionality
    from the `Template` type defined in the `html/template` package. The `templateType` field
    indicates the type of template we are dealing with. Here''s the constant grouping
    declaration with all the possible values for this field:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入`*template.Template`类型允许我们利用`html/template`包中定义的`Template`类型的所有功能。`templateType`字段指示我们正在处理的模板类型。以下是带有此字段所有可能值的常量分组声明：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, the constant grouping declaration has accounted for all the
    template categories that we will be dealing with: regular templates, partial templates,
    and layout templates.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，常量分组声明已经考虑到我们将处理的所有模板类别：常规模板、部分模板和布局模板。
- en: 'Let''s take a look at what the `TemplateSet` struct from the `isokit` package
    looks like:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`isokit`包中的`TemplateSet`结构是什么样子的：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `members` field is `map` with a key of type `string` and a value that is
    a pointer to an `isokit.Template` struct. The `Funcs` field is an optional function
    map (`template.FuncMap`) that can be supplied to the template set, to call custom
    functions inside of a template. The `bundle` field is the template bundle. The
    `TemplateBundle` is a `map`, where the key represents the name of the template
    (a `string` type) and the value is the contents of the template file (also of
    the `string` type). The `TemplateFilesPath` field represents the path where all
    of the web application's isomorphic templates reside.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`members`字段是一个`map`，键的类型是`string`，值是指向`isokit.Template`结构的指针。`Funcs`字段是一个可选的函数映射(`template.FuncMap`)，可以提供给模板集，以在模板内调用自定义函数。`bundle`字段是模板包。`TemplateBundle`是一个`map`，其中键表示模板的名称（`string`类型），值是模板文件的内容（也是`string`类型）。`TemplateFilesPath`字段表示所有Web应用程序等同模板所在的路径。'
- en: 'Here''s what the `TemplateBundle struct` looks like:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemplateBundle`结构如下：'
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `items` field of the `TemplateBundle struct` is simply a `map` having a
    key of the `string` type and a value of the `string` type. The `items` map serves
    an important purpose, it is the data structure that will be `gob` encoded on the
    server side, and we''ll expose it to the client side using the `/template-bundle`
    server-side route, where it can be retrieved through an XHR call and decoded,
    as depicted in *Figure 4.4*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemplateBundle`结构的`items`字段只是一个具有`string`类型键和`string`类型值的`map`。`items`映射起着重要作用，它是将在服务器端进行`gob`编码的数据结构，并且我们将通过服务器端路由`/template-bundle`将其暴露给客户端，在那里可以通过XHR调用检索并解码，如*图4.4*所示：'
- en: '![](img/866af4e4-0fb8-4963-a065-9106142a273c.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/866af4e4-0fb8-4963-a065-9106142a273c.png)'
- en: Figure 4.4 How the items in a template bundle get transported to the client-side
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 模板包中的项目如何传输到客户端
- en: The template bundle type plays a critical role since we use it as the basis
    to recreate the in-memory template set on the client-side. This allows us to provide
    the full set of templates for use on the client side. Now that we're armed with
    the knowledge that we can utilize the concept of a template set to isomorphically
    render templates, let's see how it's done in practice.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 模板包类型发挥着关键作用，因为我们将其用作在客户端重新创建内存中的模板集的基础。这使我们能够为客户端提供完整的模板集。现在我们已经了解到可以利用模板集的概念来等同地呈现模板，让我们看看实际操作中是如何完成的。
- en: Setting up the template set on the server side
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器端设置模板集
- en: 'Let''s examine the variable declarations at the beginning of the `igweb.go`
    source file found in the `igweb` folder:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`igweb`文件夹中的`igweb.go`源文件开头的变量声明：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The variables declared here are critical for the proper operation of the web
    server instance. The `WebAppRoot` variable is responsible for specifying where
    the `igweb` project folder resides. The `WebServerPort` variable is responsible
    for specifying on what port the web server instance should run on. The `DBConnectionString`
    variable is used to specify the connection string to the database. The `StaticAssetsPath`
    variable is used to specify the directory that contains all of the static (nondynamic)
    assets for the project. These assets may consist of CSS style sheets, JavaScript
    source files, images, fonts, and anything else that isn't meant to be dynamic.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此处声明的变量对于Web服务器实例的正常运行至关重要。`WebAppRoot`变量负责指定`igweb`项目文件夹的位置。`WebServerPort`变量负责指定Web服务器实例应在哪个端口上运行。`DBConnectionString`变量用于指定到数据库的连接字符串。`StaticAssetsPath`变量用于指定包含项目的所有静态（非动态）资产的目录。这些资产可能包括CSS样式表、JavaScript源文件、图像、字体以及任何不需要是动态的东西。
- en: 'We initialize the variables in the `init` function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`init`函数中初始化变量：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `WebAppRoot` and `WebServerPort` variables are obtained from the `IGWEB_APP_ROOT`
    and `$IGWEB_SERVER_PORT` environment variables, respectively.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAppRoot`和`WebServerPort`变量分别从`IGWEB_APP_ROOT`和`$IGWEB_SERVER_PORT`环境变量中获取。'
- en: We will cover the `WebAppMode` variable and the `$IGWEB_MODE` environment variable
    in [Chapter 11](19922281-fd33-4fab-bac2-75066243176d.xhtml), *Deploying an Isomorphic
    Go Web Application*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第11章](19922281-fd33-4fab-bac2-75066243176d.xhtml)中介绍`WebAppMode`变量和`$IGWEB_MODE`环境变量，*部署等同Go
    Web应用程序*。
- en: If the `$IGWEB_SERVER_PORT` environment variable has not been set, the default
    port is set to `8080`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`$IGWEB_SERVER_PORT`环境变量未设置，默认端口设置为`8080`。
- en: The `DBConnectionString` variable is assigned the value of `"localhost:6379"`,
    which is the hostname and port on which the Redis database instance is running.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBConnectionString`变量被赋予值`"localhost:6379"`, 这是Redis数据库实例运行的主机名和端口。'
- en: The `StaticAssetsPath` variable is assigned to the `static` folder, which resides
    inside the `WebAppRoot` folder.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticAssetsPath`变量被分配给`static`文件夹，该文件夹位于`WebAppRoot`文件夹内。'
- en: 'Let''s examine the beginning of the `main` function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`main`函数的开头：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Right at the beginning of the `main` function, we check whether the `WebAppRoot`
    variable has been set, and if it hasn't been set, we exit from the application.
    One of the biggest advantages of setting the `$IGWEB_APP_ROOT` environment variable,
    which is used to populate the `WebAppRoot` variable, is that we can issue the
    `igweb` command from any folder on the system.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的开头，我们检查`WebAppRoot`变量是否已设置，如果没有设置，我们就退出应用程序。设置`$IGWEB_APP_ROOT`环境变量的最大优势之一是，我们可以从系统上的任何文件夹中发出`igweb`命令。
- en: Inside the `main` function, we initialize the `env` object. Right after calling
    the `initializeDatastore` function to initialize the datastore, we make a call
    to the `initializeTemplateSet` function (shown in bold), passing a reference to
    the `env` object to the function. This function, as you may have guessed from
    its name, is responsible for initializing the template set. We will make use of
    the second argument, of the `bool` type, passed to the function in [Chapter 11](19922281-fd33-4fab-bac2-75066243176d.xhtml), *Deploying
    an Isomorphic Go Web Application*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们初始化了`env`对象。在调用`initializeDatastore`函数初始化数据存储之后，我们调用`initializeTemplateSet`函数（以粗体显示），将`env`对象的引用传递给函数。这个函数，正如你从它的名字中猜到的那样，负责初始化模板集。我们将在[第11章](19922281-fd33-4fab-bac2-75066243176d.xhtml)中使用传递给函数的`bool`类型的第二个参数，*部署一个同构的Go
    Web应用程序*。
- en: 'Let''s examine the `initializeTemplateSet` function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`initializeTemplateSet`函数：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We start by initializing the `isokit` package's exported variables for the `WebAppRoot`,
    `TemplateFilesPath`, and `StaticAssetsPath` variables. We create a new template
    set, `ts`, by calling the `NewTemplateSet` function found in the `isokit` package.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化`isokit`包的`WebAppRoot`、`TemplateFilesPath`和`StaticAssetsPath`变量的导出变量。通过调用`isokit`包中的`NewTemplateSet`函数，我们创建了一个新的模板集`ts`。
- en: Right after we create our template set object, `ts`, we declare a function map,
    `funcMap`. We have populated our map with two custom functions that will be exposed
    to our templates. The key for the first function is `rubyformat`, and the value
    is the `RubyDate` function found in the `templatefuncs` package. This function
    will return the Ruby format for a given time value. The key for the second function
    is `unixformat`, and this function will return the Unix timestamp for a given
    time value. We populate the `Funcs` field of the template set object with the
    `funcMap` object that we just created. Now, all the templates in our template
    set have access to these two custom functions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建模板集对象`ts`之后，我们声明了一个函数映射`funcMap`。我们用两个自定义函数填充了我们的映射，这些函数将暴露给我们的模板。第一个函数的键是`rubyformat`，值是`templatefuncs`包中找到的`RubyDate`函数。这个函数将返回给定时间值的Ruby格式。第二个函数的键是`unixformat`，这个函数将返回给定时间值的Unix时间戳。我们用我们刚刚创建的`funcMap`对象填充了模板集对象的`Funcs`字段。现在，我们模板集中的所有模板都可以访问这两个自定义函数。
- en: Up to this point, we've prepped the template set, but we haven't populated the
    template set's `bundle` field. In order to do this, we must call the `GatherTemplate`
    method of the `TemplateSet` object, which will gather all the templates found
    in the directory specified by `isokit.TemplateFilesPath` and all of its subdirectories.
    The names of the template filenames without the `.tmpl` file extension will be
    used as the key in the bundle map. The string contents of the template file will
    be used as the value in the bundle map. If the template is a layout or partial,
    their respective directory name will be included in the name to refer to them.
    For example, the `partials/footer.tmpl` template will have a name of `partials/footer`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好了模板集，但还没有填充模板集的`bundle`字段。为了做到这一点，我们必须调用`TemplateSet`对象的`GatherTemplate`方法，该方法将收集`isokit.TemplateFilesPath`指定的目录及其所有子目录中找到的所有模板。模板文件的名称（不包括`.tmpl`文件扩展名）将用作bundle映射中的键。模板文件的字符串内容将用作bundle映射中的值。如果模板是布局或部分，它们各自的目录名称将包含在名称中以引用它们。例如，`partials/footer.tmpl`模板的名称将是`partials/footer`。
- en: Now that our template set is fully prepped, we can populate the `TemplateSet`
    field of the `env` object, so that our server-side application has access to the
    template set. This comes in handy later on, since it allows us to access the template
    set from any request handler function defined in our server-side web application,
    providing us the capability to render any template that exists within the template
    set.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的模板集已经准备好了，我们可以填充`env`对象的`TemplateSet`字段，这样我们的服务器端应用程序就可以访问模板集。这在以后会很方便，因为它允许我们从服务器端Web应用程序中定义的任何请求处理程序函数中访问模板集，从而使我们能够渲染模板集中存在的任何模板。
- en: Registering the server-side handlers
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册服务器端处理程序
- en: 'After we have initialized the template set inside the `main` function of the
    `igweb.go` source file, we create a new Gorilla Mux router, and we call the `registerRoutes`
    function to register all the routes of the server-side web application. Let''s
    examine the lines of the `registerRoutes` function that are essential for the
    proper functioning of the client-side web application:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`igweb.go`源文件的`main`函数中初始化模板集之后，我们创建了一个新的Gorilla Mux路由器，并调用`registerRoutes`函数来注册服务器端Web应用程序的所有路由。让我们来看看`registerRoutes`函数中对客户端Web应用程序正常运行至关重要的行：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We register a handler for the `/js/client.js` route and specify that it will
    be handled by the `GopherjsScriptHandler` function from the `isokit` package.
    This will associate the route to serving the `client.js` JavaScript source file that
    was built by running the `gopherjs build` command in the `client` directory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`/js/client.js`路由注册了一个处理程序，并指定它将由`isokit`包中的`GopherjsScriptHandler`函数处理。这将把路由与通过在`client`目录中运行`gopherjs
    build`命令构建的`client.js` JavaScript源文件相关联。
- en: We handle the `map` file of the `client.js.map` in a similar manner. We register
    a `/js/client.js.map` route and specify that it will be handled by the `GopherjsScriptMapHandler`
    function from the `isokit` package.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类似的方式处理`client.js.map`的`map`文件。我们注册了一个`/js/client.js.map`路由，并指定它将由`isokit`包中的`GopherjsScriptMapHandler`函数处理。
- en: Now that we've registered the routes for the JavaScript source file and the
    JavaScript source `map` file that are critical for our client-side application
    to function, we need to register a route to access the template bundle. We will
    call the `Handle` method on the `r` router object and specify that the `/template-bundle`
    route will be handled by the `TemplateBundleHandler` function, found in the `handlers`
    package. This route will be retrieved by the client through an XHR call, and the
    server will send the template bundle as `gob` encoded data.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经注册了JavaScript源文件和JavaScript源`map`文件的路由，这对我们的客户端应用程序的功能至关重要，我们需要注册一个路由来访问模板包。我们将在`r`路由对象上调用`Handle`方法，并指定`/template-bundle`路由将由`handlers`包中的`TemplateBundleHandler`函数处理。客户端将通过XHR调用检索此路由，并且服务器将以`gob`编码数据的形式发送模板包。
- en: 'The very last route that we register, which is of particular interest for us
    right now, is the `/about` route. Here''s the line of code where we register the
    `/about` route and associate it with the `AboutHandler` function found in the
    handlers package:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册的最后一个路由，目前对我们来说特别重要的是`/about`路由。以下是我们注册`/about`路由并将其与`handlers`包中的`AboutHandler`函数关联的代码行：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we've seen how to set up the template set in our server-side web application,
    and how we registered the routes that are of importance to us in this chapter,
    let's go ahead and take a look at the server-side handlers, starting with the
    `TemplateBundleHandler` function in the `handlers` package.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何在服务器端Web应用程序中设置模板集，以及如何注册对我们在本章中重要的路由，让我们继续查看服务器端处理程序，从`handlers`包中的`TemplateBundleHandler`函数开始。
- en: Serving the template bundle items
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供模板包项目
- en: 'Here''s the `TemplateBundleHandler` function found in the `templatebundle.go`
    source file in the `handlers` folder:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`handlers`文件夹中`templatebundle.go`源文件中的`TemplateBundleHandler`函数：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code to encode data to `gob` format should look familiar, it's just like
    how we encoded the cars slice to gob format in the *Transmitting gob encoded data
    section* from the [Chapter 3](0f18d7dd-b081-4090-8b9c-c7a392261b31.xhtml), *Go
    on the Front-End with GopherJS*. Inside the `TemplateBundleHandler` function,
    we first declare `templateContentItemsBuffer`, of the `bytes.Buffer` type, which
    will hold the `gob` encoded data. We then create a new `gob` encoder, `enc`. Right
    after this, we'll create an `m` variable and assign it the value of the template
    bundle map. We call the `Encode` method of the `enc` object, and pass in the reference
    to the `m` map. At this point, `templateContentItemsBuffer` should contain the
    `gob` encoded data that represents the `m` map. We will write out a content-type
    header to specify that the server will be sending out binary data (`application/octet-stream`).
    We will then write out the binary contents of `templateContentItemsBuffer` by
    calling its `Bytes` method. In the *Setting up the template set on the client
    side* section of this chapter, we'll see how the client-side web application picks
    up the template bundle items, and utilizes it to create a template set on the
    client side.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据编码为`gob`格式的代码应该看起来很熟悉，就像我们在[第3章](0f18d7dd-b081-4090-8b9c-c7a392261b31.xhtml)的*在前端使用GopherJS*中的*传输gob编码数据*部分中对cars切片进行gob格式编码一样。在`TemplateBundleHandler`函数内部，我们首先声明`templateContentItemsBuffer`，类型为`bytes.Buffer`，它将保存`gob`编码数据。然后我们创建一个新的`gob`编码器`enc`。紧接着，我们将创建一个`m`变量，并将其赋值为模板包映射的值。我们调用`enc`对象的`Encode`方法，并传入对`m`映射的引用。此时，`templateContentItemsBuffer`应该包含代表`m`映射的`gob`编码数据。我们将写出一个内容类型标头，以指定服务器将发送二进制数据(`application/octet-stream`)。然后我们将通过调用其`Bytes`方法写出`templateContentItemsBuffer`的二进制内容。在本章的*在客户端设置模板集*部分，我们将看到客户端Web应用程序如何获取模板包项目，并利用它在客户端上创建模板集。
- en: Rendering the about page from the server side
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器端渲染about页面
- en: 'Now that we''ve seen how the server-side application transmits the template
    bundle to the client-side application, let''s take a look at the `AboutHandler`
    function found in the `about.go` source file in the `handlers` folder. This is
    the server-side handler function that is responsible for rendering the About page:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了服务器端应用程序如何将模板包传输到客户端应用程序，让我们来看看`handlers`文件夹中`about.go`源文件中的`AboutHandler`函数。这是负责渲染`About`页面的服务器端处理程序函数：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `AboutHandler` function has three responsibilities:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`AboutHandler`函数有三个职责：'
- en: Fetching the gophers from the datastore
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据存储中获取gophers
- en: Creating the template data object
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模板数据对象
- en: Rendering the About page template
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染`About`页面模板
- en: 'The first line of code, defined in the function, fetches the gopher objects
    from the datastore, where a gopher object represents an individual gopher team
    member. In our sample data set, there are three gophers: Molly, Case, and Wintermute.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中定义的第一行代码从数据存储中获取gopher对象，其中gopher对象表示单个gopher团队成员。在我们的示例数据集中，有三个gophers：Molly，Case和Wintermute。
- en: The second line of code is used to set up the template data object of the `templatedata.About` type.
    This is the data object that will be fed into the template. The `PageTitle` property
    of the data object is used to display the page title, and we will populate the
    `Gophers` property of the object with the slice of gopher objects that are retrieved
    from the datastore.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行代码用于设置`templatedata.About`类型的模板数据对象。这是将被输入模板的数据对象。数据对象的`PageTitle`属性用于显示页面标题，我们将使用对象的`Gophers`属性填充从数据存储中检索到的gopher对象的切片。
- en: In the third, and final line of the handler function, we call the `Render` method
    of the template set to render the template. The first parameter passed to the
    method is the name of the template to be rendered. In this case, we have specified
    that we want to render the `about_page` template. Take note that this is a page
    template that will not only render the About page content but also the entire
    web page layout, which in addition to the primary content area section will also
    include the header, the top bar, the navigation bar, and the footer areas of the
    web page.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序函数的第三行，我们调用模板集的`Render`方法来呈现模板。传递给该方法的第一个参数是要呈现的模板的名称。在这种情况下，我们已经指定要呈现`about_page`模板。请注意，这是一个页面模板，不仅会呈现关于页面内容，还会呈现整个网页布局，除了主要内容区域部分外，还包括网页的页眉、顶部栏、导航栏和页脚区域。
- en: The second parameter to the function is the template render parameters (`isokit.RenderParams`).
    We have populated the `Writer` field, with `http.ResponseWriter`, `w`. Also, we
    have populated the `Data` field, which represents the data object that should
    be supplied to the template with the `templateData` object that we had just created.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第二个参数是模板渲染参数（`isokit.RenderParams`）。我们已经用`http.ResponseWriter` `w`填充了`Writer`字段。此外，我们已经用我们刚刚创建的`templateData`对象填充了`Data`字段，该对象表示应提供给模板的数据对象。
- en: 'That''s all there is to it. Now we can render this template on the server side.
    We have now implemented the classic web application architecture flow where the
    entire web page is rendered from the server side. We can access the About page
    at `http://localhost:8080/about`. Here''s how the About page looks rendered from
    the server side:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在我们可以在服务器端呈现此模板。我们现在已经实现了经典的Web应用程序架构流程，其中整个网页都是从服务器端呈现的。我们可以在`http://localhost:8080/about`访问关于页面。以下是从服务器端呈现的关于页面的外观：
- en: '![](img/d2c0612e-9e58-4e6c-a86d-014515d6a91b.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2c0612e-9e58-4e6c-a86d-014515d6a91b.png)'
- en: Figure 4.5 The About page rendered from the server side
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 从服务器端呈现的关于页面
- en: Setting up the template set on the client side
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端设置模板集
- en: 'Now that we''ve seen how a web template gets rendered on the server side, it''s
    time to focus on how a web template gets rendered on the client side. The primary
    entry point of our client-side web application is the `main` function defined
    in the `client.go` source file in the `client` folder:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了Web模板如何在服务器端呈现，是时候关注Web模板如何在客户端呈现了。我们客户端Web应用程序的主要入口点是`client.go`源文件中`client`文件夹中定义的`main`函数：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we assign the document object to the `D` variable, we're performing the
    usual aliasing operation here to save us some typing. We then declare a `switch`
    block on the document object's `readyState` property. We obtain the document object's
    `readyState` by calling the `ReadyState` method on the `Document` object.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将文档对象分配给`D`变量，我们在这里执行了通常的别名操作，以节省一些输入。然后，我们在文档对象的`readyState`属性上声明了一个`switch`块。我们通过在`Document`对象上调用`ReadyState`方法来获取文档对象的`readyState`。
- en: 'The ready state property of a document describes the loading state of the document.
    You can read more about this property at the Mozilla Developer Network: [https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState](https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的readyState属性描述了文档的加载状态。您可以在Mozilla开发者网络上阅读有关此属性的更多信息：[https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState](https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState)。
- en: In the first `case` statement, we will check whether the `readyState` value
    is `"loading"`, and if it is, it indicates that the document is still loading.
    We set up an event listener to listen for the `DOMContentLoaded` event. The `DOMContentLoaded`
    event will be the cue that tells us that the web page has fully loaded, at which
    point, we can call the `run` function as a goroutine. We will call the `run` function
    as a goroutine since we don't want any operations inside the `run` function to
    block, because we are calling it from within the event handler function.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`case`语句中，我们将检查`readyState`值是否为“loading”，如果是，则表示文档仍在加载中。我们设置一个事件侦听器来监听`DOMContentLoaded`事件。`DOMContentLoaded`事件将告诉我们网页已完全加载，此时我们可以调用`run`函数作为goroutine。我们将`run`函数作为goroutine调用，因为我们不希望`run`函数内部的任何操作被阻塞，因为我们是从事件处理程序函数中调用它的。
- en: In the second `case` statement, we will check whether the `readyState` value
    is either `"interactive"` or `"complete"`. An `interactive` state indicates that
    the document has finished loading, but there may be some resources, such as images
    or style sheets, that haven't fully loaded. The `complete` state indicates that
    the document and all subresources have finished loading. If `readyState` is either
    interactive or complete, we will call the `run` function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个`case`语句中，我们将检查`readyState`值是否为“interactive”或“complete”。`interactive`状态表示文档已经完成加载，但可能还有一些资源，如图像或样式表，尚未完全加载。`complete`状态表示文档和所有子资源都已完成加载。如果`readyState`是交互式或完整的，我们将调用`run`函数。
- en: Finally, the `default` statement handles unexpected behavior. Ideally, we should
    never reach the `default` scenario, and if we ever do, we will print a message
    in the web console indicating that we have encountered an unexpected document
    `readyState` value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`default`语句处理意外行为。理想情况下，我们永远不应该达到`default`情况，如果我们确实达到了，我们将在Web控制台中打印一条消息，指示我们遇到了意外的文档`readyState`值。
- en: 'The functionality that we have created in our `main` function provides us with
    the valuable benefit of being able to import our GopherJS produced JavaScript
    source file, `client.js`, from the `<head>` section of our HTML document as an
    external JavaScript source file, as shown here (shown in bold):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main`函数中创建的功能为我们提供了宝贵的好处，即能够从HTML文档的`<head>`部分作为外部JavaScript源文件导入我们的GopherJS生成的JavaScript源文件`client.js`，如下所示（用粗体显示）：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This means that we don't have to import the external JavaScript source file
    right before the closing `</body>` tag to ensure that the web page has fully loaded.
    The procedure to include the external JavaScript source file, in the head declaration
    itself, is more robust, since our code specifically accounts for `readyState`
    in a responsible manner. The other, more brittle approach, is apathetic to `readyState`,
    and is dependent on the location of the included `<script>` tag within the HTML
    document to function properly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不必在关闭`</body>`标签之前导入外部JavaScript源文件，以确保网页已完全加载。在头部声明中包含外部JavaScript源文件的过程更加健壮，因为我们的代码特别考虑了`readyState`。另一种更脆弱的方法对`readyState`漠不关心，并且依赖于包含的`<script>`标签在HTML文档中的位置才能正常工作。
- en: 'Inside the `run` function, we will first print a message in the web console,
    indicating that we have successfully entered the client-side application:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`run`函数内，我们将首先在Web控制台中打印一条消息，指示我们已成功进入客户端应用程序：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will then fetch the template set from the server-side `/template-bundle`
    route that we set up earlier in this chapter:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从本章前面设置的服务器端`/template-bundle`路由中获取模板集：
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will create a channel called `templateSetChannel`, of the `*isokit.TemplateSet` type,
    in which we will receive the `TemplateSet` object. We will create a function map,
    containing the `rubyformat` and `unixformat` custom functions. We will then call
    the `FetchTemplateBundleWithSuppliedFunctionMap` function from the `isokit` package,
    supplying the `templateSetChannel` that we had just created, along with the `funcMap`
    variable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`templateSetChannel`的通道，类型为`*isokit.TemplateSet`，我们将在其中接收`TemplateSet`对象。我们将创建一个包含`rubyformat`和`unixformat`自定义函数的函数映射。然后，我们将从`isokit`包中调用`FetchTemplateBundleWithSuppliedFunctionMap`函数，提供我们刚刚创建的`templateSetChannel`以及`funcMap`变量。
- en: The `FetchTemplateBundleWithSuppliedFunctionMap` function is responsible for
    fetching the template bundle items map from the server side, and assembling the
    template set using this map. In addition to that, the received `TemplateSet` object's
    `Funcs` property will be populated with the `funcMap` variable, ensuring that
    the custom functions will be accessible to all templates in our template set.
    Upon successfully calling this method, the template set will be sent over `templateSetChannel`.
    Finally, we will assign the `ts` variable with the `*isokit.TemplateSet` value
    that we receive from `templateSetChannel`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchTemplateBundleWithSuppliedFunctionMap`函数负责从服务器端获取模板包项映射，并使用此映射组装模板集。除此之外，接收到的`TemplateSet`对象的`Funcs`属性将使用`funcMap`变量填充，确保自定义函数对模板集中的所有模板都是可访问的。成功调用此方法后，模板集将通过`templateSetChannel`发送。最后，我们将使用从`templateSetChannel`接收到的`*isokit.TemplateSet`值来分配`ts`变量。'
- en: 'We will create a new instance of the `Env` object, which we will use throughout
    the client-side application:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`Env`对象的新实例，我们将在整个客户端应用程序中使用它：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will then populate the `TemplateSet` property with the `Env` instance that
    we just created:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`TemplateSet`属性填充为我们刚刚创建的`Env`实例：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To save ourselves from having to type out `dom.GetWindow()` to access the `Window`
    object, and `dom.GetWindow().Document()` to access the `Document` object, we can
    populate the `Window` and `Document` properties of the `env` object with their
    respective values:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免每次需要访问`Window`对象时都要输入`dom.GetWindow()`，以及访问`Document`对象时都要输入`dom.GetWindow().Document()`，我们可以将`env`对象的`Window`和`Document`属性填充为它们各自的值：
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will be dynamically replacing the contents of the primary content `div` container
    as the user clicks on different sections of the website using the navigation bar.
    We will populate the `PrimaryContent` property of the `env` object to hold the
    primary content `div` container:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击网站的不同部分时，我们将动态替换主要内容`div`容器的内容。我们将填充`env`对象的`PrimaryContent`属性以保存主要内容`div`容器：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This comes in handy, when we need to access this `div` container from within
    the route handler functions. It saves us from having to perform a DOM operation
    to retrieve this element each time we need it in the route handler.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要从路由处理程序函数内访问此`div`容器时，这将非常方便。它使我们免于每次在路由处理程序中需要时执行DOM操作来检索此元素。
- en: 'We will call the `registerRoutes` function and supply it with the reference
    to the `env` object as the sole input argument to the function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`registerRoutes`函数，并将`env`对象的引用作为函数的唯一输入参数提供给它：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This function is responsible for registering all the client-side routes and
    their associated handler functions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数负责注册所有客户端路由及其关联的处理程序函数。
- en: 'We will call the `initializePage` function and supply it with the reference
    to the `env` object:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`initializePage`函数，并将`env`对象的引用提供给它：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This function is responsible for initializing interactive elements and components
    on the web page for a given client-side route.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数负责为给定的客户端路由初始化网页上的交互元素和组件。
- en: 'There are two tasks that are of particular interest for us in the `registerRoutes`
    function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`registerRoutes`函数中，有两个特别感兴趣的任务：
- en: Creating the client-side router
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建客户端路由
- en: Registering the client-side route
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册客户端路由
- en: Creating the client-side router
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建客户端路由
- en: 'First, we will create a new instance of the `isokit` router object and assign
    it to the `r` variable:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建`isokit`路由对象的新实例，并将其分配给`r`变量：
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Registering the client-side route
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册客户端路由
- en: The second line of code, registers the client-side `/about` route, along with
    its associated client-side handler function, `AboutHandler`, from the `handlers`
    package.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行代码注册了客户端`/about`路由，以及与之关联的客户端处理函数`AboutHandler`，来自`handlers`包。
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We will be covering the rest of the `registerRoutes` function in more detail
    in [Chapter 5](8c1d6725-c841-42b2-904d-e34ba3764cc3.xhtml), *End-to-End Routing*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](8c1d6725-c841-42b2-904d-e34ba3764cc3.xhtml)中更详细地介绍`registerRoutes`函数的其余部分，*端到端路由*。
- en: Initializing interactive elements on the web page
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化网页上的交互元素
- en: The `initializePage` function will get called only once when the web page is
    first loaded. Its role is to initialize the functionality that enables user interactivity
    with the client-side web application. This would be the respective `initialize`
    function for a given web page, which would be responsible for initializing event
    handlers and reusable components (cogs).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializePage`函数将在网页首次加载时调用一次。它的作用是初始化使用户能够与客户端Web应用程序进行交互的功能。这将是给定网页的相应`initialize`函数，负责初始化事件处理程序和可重用组件（齿轮）。'
- en: 'Inside the `initializePage` function, we will extract the `routeName` from
    the `PathName` property of the window''s location object; the route name for the
    `http://localhost:8080/about` URL will be `"about"`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initializePage`函数内部，我们将从窗口位置对象的`PathName`属性中提取`routeName`；`http://localhost:8080/about`
    URL的路由名称将是`"about"`。
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If no `routeName` is available, we will assign the value of `"index"`, the route
    name for the home page, to `routeName`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有可用的`routeName`，我们将把值赋给`"index"`，即主页的路由名称。
- en: 'We will declare a `switch` block on `routeName`, and here''s the corresponding
    `case` statement that handles the scenario where `routeName` is equal to `"about"`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`routeName`上声明一个`switch`块，以下是处理`routeName`等于`"about"`的情况的相应`case`语句：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The designated `initialize` function for the About page, is the `InitializeAboutPage`
    function, which is defined in the `handlers` package. This function is responsible
    for enabling user interactivity on the About page.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 关于页面的指定`initialize`函数是`InitializeAboutPage`函数，它在`handlers`包中定义。此函数负责在`About`页面上启用用户交互。
- en: Now that we've set up the template set on the client-side, and registered the
    `/about` route, let's go ahead and take a look at the client-side About page handler
    function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在客户端设置了模板集，并注册了`/about`路由，让我们继续看看客户端的`About`页面处理函数。
- en: Rendering the about page from the client side
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从客户端渲染关于页面
- en: 'Here''s the definition of the client-side `AboutHandler` function in the `about.go`
    source file found in the `client/handlers` folder:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`client/handlers`文件夹中找到的`about.go`源文件中`AboutHandler`函数的定义：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We start out by creating a channel, `gopherTeamChannel`, which we will use to
    retrieve a slice of `Gopher` instances. We will call the `FetchGopherTeam` function
    as a goroutine, and supply it with `gopherTeamChannel` as the sole input argument
    to the function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`gopherTeamChannel`的通道，我们将使用它来检索`Gopher`实例的切片。我们将调用`FetchGopherTeam`函数作为一个goroutine，并将`gopherTeamChannel`作为函数的唯一输入参数。
- en: We will then receive the value returned from `gopherTeamChannel` and assign
    it to the `gophers` variable.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将接收从`gopherTeamChannel`返回的值，并将其赋给`gophers`变量。
- en: We will declare and initialize the `templateData` variable, the `about_content`
    template's data object, which has a type of `templatedata.About`. We will set
    the `PageTitle` property of the template data object and we populate the `Gophers`
    property with the `gophers` variable that we had just created.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声明并初始化`templateData`变量，即`about_content`模板的数据对象，其类型为`templatedata.About`。我们将设置模板数据对象的`PageTitle`属性，并使用我们刚刚创建的`gophers`变量填充`Gophers`属性。
- en: We will call the `Render` method on the template set object to render the about
    template. The first argument we pass to the function is the name of the template,
    `about_content` that corresponds to the about content template. On the server
    side, we used the `about_page` template, since we also needed to generate the
    entire web page layout. Since we are operating from the client side, this is not
    necessary since we only need to populate the primary content area with the rendered
    content from the `about_content` template.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在模板集对象上调用`Render`方法来渲染关于模板。我们传递给函数的第一个参数是模板的名称，即对应于关于内容模板的`about_content`。在服务器端，我们使用了`about_page`模板，因为我们还需要生成整个网页布局。由于我们是从客户端操作，这不是必要的，因为我们只需要用`about_content`模板的渲染内容填充主要内容区域。
- en: The second and final argument to the `Render` method is the render parameters
    of the `isokit.RenderParams` type. Let's examine each property that we set in
    the `RenderParams` object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`Render`方法的第二个和最后一个参数是`isokit.RenderParams`类型的渲染参数。让我们检查一下在`RenderParams`对象中设置的每个属性。'
- en: The `Data` property specifies the template data object that the template will
    be using.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data`属性指定模板将使用的模板数据对象。'
- en: The `Disposition` property specifies the disposition of the template content
    that will be rendered relative to an associated target element. The `isokit.PlacementReplaceInnerContents`
    disposition instructs the renderer to replace the inner contents of the associated
    target element.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`Disposition`属性指定将相对于相关目标元素呈现的模板内容的处理方式。`isokit.PlacementReplaceInnerContents`处理方式指示渲染器替换相关目标元素的内部内容。'
- en: The `Element` property specifies the associated target element that the renderer
    should take into consideration upon performing a template rendering. We will be
    placing the rendered content from the template in the primary content `div` container,
    and so we'll assign `env.PrimaryContent` to the `Element` property.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Element`属性指定渲染器应该考虑的相关目标元素。我们将把模板的渲染内容放在主要内容`div`容器中，因此我们将`env.PrimaryContent`分配给`Element`属性。'
- en: The `PageTitle` property specifies the web page title that should be used. The
    template data object's `PageTitle` property is equally important on the client
    side as it was on the server side, since the client-side renderer has the capability
    to change the web page's title.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageTitle`属性指定应该使用的网页标题。模板数据对象的`PageTitle`属性在客户端端和服务器端一样重要，因为客户端渲染器有能力更改网页的标题。'
- en: Finally, we make a call to the `InitializeAboutPage` function to enable functionality
    that requires user interactivity. If the About page was the first page that was
    rendered on the website (from the server side), the `InitalizeAboutPage` function
    would be called from the `initializePage` function found in the `client.go` source
    file. If we landed on the About page subsequently, by clicking on the About link
    on the navigation bar, then the request is serviced by the client-side `AboutHandler`
    function and we enable the functionality that requires user interactivity by calling
    the `InitializeAboutPage` function.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`InitializeAboutPage`函数来启用需要用户交互的功能。如果“关于”页面是网站上渲染的第一个页面（从服务器端），则`InitalizeAboutPage`函数将从`client.go`源文件中的`initializePage`函数中调用。如果我们随后点击导航栏上的“关于”链接而着陆在“关于”页面上，则请求将由客户端的`AboutHandler`函数处理，并通过调用`InitializeAboutPage`函数来启用需要用户交互的功能。
- en: When it comes to user interactivity on the About page, we only have one reusable
    component that displays the time in a human readable format. We don't set up any
    event handlers, since we don't have any buttons or user input fields on this particular
    page. This being the case, we will skip the `InitializeAboutPage` function for
    now, and return to it in [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml),
    *Cogs – Reusable Components*. We'll show you an example of setting up event handlers
    in the designated `initialize` function for a given web page, in [Chapter 5](8c1d6725-c841-42b2-904d-e34ba3764cc3.xhtml), *End-to-End
    Routing*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在“关于”页面的用户交互方面，我们只有一个可重用的组件，用于以人类可读的格式显示时间。我们不设置任何事件处理程序，因为在这个特定页面上没有任何按钮或用户输入字段。在这种情况下，我们将暂时跳过`InitializeAboutPage`函数，并在[第9章](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml)“齿轮-可重用组件”中返回它。我们将在[第5章](8c1d6725-c841-42b2-904d-e34ba3764cc3.xhtml)“端到端路由”中向您展示为特定网页设置事件处理程序的`initialize`函数的示例。
- en: 'The `FetchGopherTeam` function is responsible for making an XHR call to the
    `/restapi/get-gopher-team` Rest API endpoint and retrieving the list of gophers
    that appear on the About page. Let''s examine the `FetchGopherTeam` function:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchGopherTeam`函数负责对`/restapi/get-gopher-team` Rest API端点进行XHR调用，并检索出出现在“关于”页面上的地鼠列表。让我们来看看`FetchGopherTeam`函数：'
- en: '[PRE41]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We make an XHR call by calling the `Send` function from the `xhr` package, and
    specifying that we will be using the `GET` HTTP method to make the call. We also
    specify that the call will be made to the `/restapi/get-gopher-team` endpoint.
    The last argument to the `Send` function is `nil`, since we will not be sending
    any data to the server from the client side.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从`xhr`包中调用`Send`函数来进行XHR调用，并指定我们将使用`GET` HTTP方法进行调用。我们还指定调用将被发往`/restapi/get-gopher-team`端点。`Send`函数的最后一个参数是`nil`，因为我们不会从客户端向服务器发送任何数据。
- en: If the XHR call is successfully made, the server will respond with JSON encoded
    data, representing a slice of gophers. We will create a new JSON decoder to decode
    the server's response into the `gophers` variable. Finally, we will send the `gophers`
    slice over `gopherTeamChannel`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果XHR调用成功，服务器将以JSON编码的数据作出响应，表示地鼠的一个切片。我们将创建一个新的JSON解码器，将服务器的响应解码为`gophers`变量。最后，我们将通过`gopherTeamChannel`发送`gophers`切片。
- en: Now it's time to examine the Rest API endpoint that is responsible for servicing
    our XHR call to get the IGWEB team's gophers.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候检查一下负责处理我们的XHR调用以获取IGWEB团队地鼠的Rest API端点了。
- en: The gopher team Rest API endpoint
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gopher团队Rest API端点
- en: 'The `/restapi/get-gopher-team` route is handled by the `GetGopherTeamEndpoint`
    function defined in the `gopherteam.go` source file found in the `endpoints` folder:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`/restapi/get-gopher-team`路由由`endpoints`文件夹中的`gopherteam.go`源文件中定义的`GetGopherTeamEndpoint`函数处理：'
- en: '[PRE42]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We will declare and initialize the `gophers` variable to the value returned
    from calling the `GetGopherTeam` method of the Redis datastore object, `env.DB`.
    We will then set a header to indicate that the server will be sending a JSON response.
    Finally, we will use a JSON encoder to encode the slice of gophers as JSON data.
    The data is sent to the client using `http.ResponseWriter`, `w`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声明并初始化`gophers`变量，以调用`env.DB`的Redis数据存储对象的`GetGopherTeam`方法返回的值。然后，我们将设置一个标头，指示服务器将发送JSON响应。最后，我们将使用JSON编码器将地鼠的切片编码为JSON数据。数据通过`http.ResponseWriter`
    `w`发送到客户端。
- en: 'We have now set up everything we need to render the About page from the client
    side. We can view our client-side rendered About page by clicking on the About
    link on the navigation bar. Here''s what the About page looks like rendered from
    the client side:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置好了从客户端渲染“关于”页面所需的一切。我们可以通过在导航栏上点击“关于”链接来查看我们的客户端渲染的“关于”页面。以下是客户端渲染的“关于”页面的样子：
- en: '![](img/30089b59-1891-4621-84ef-65e9290362dd.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30089b59-1891-4621-84ef-65e9290362dd.png)'
- en: Figure 4.6 The About page rendered from the client-side
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 从客户端渲染的“关于”页面
- en: Can you make out any difference between the About page rendered on the server
    side and the one that was rendered on the client side? You shouldn't be able to
    see any differences since they are practically identical! We saved the user from
    having to witness a full page reload by simply rendering the About page content
    in the primary content area `div` container.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您能看出服务器端渲染的“关于”页面和客户端渲染的页面之间有什么区别吗？你不应该看到任何区别，因为它们实际上是相同的！我们通过简单地在主要内容区域`div`容器中渲染“关于”页面内容，避免了用户必须观看完整页面重新加载。
- en: Take a look at the start times that are displayed for each gopher. The first
    time presented here, follows Go's default time formatting. The second time is
    the time using the Ruby date format. Recall that we use a custom function to present
    the time in this format. The third start time is displayed in human readable format.
    It uses a reusable component to format the time, which we will cover in [Chapter
    9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml), *Cogs – Reusable Components*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下显示每个地鼠的开始时间。这里呈现的第一个时间遵循Go的默认时间格式。第二个时间是使用Ruby日期格式的时间。请记住，我们使用自定义函数以这种格式呈现时间。第三个开始时间以人类可读的格式显示。它使用可重用组件来格式化时间，我们将在[第9章](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml)中介绍，*齿轮-可重用组件*。
- en: We now know how to render templates isomorphically, and we will be following
    this same procedure for the other pages on IGWEB.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何同构渲染模板，我们将按照相同的流程处理IGWEB上的其他页面。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we introduced you to the web template system and the individual
    components that comprise it—the template engine, the template data object, and
    the templates. We explored the purpose of each component of the web template system,
    and we designed the web page structure for IGWEB. We covered the three template
    categories: the layout template, the partial template, and the regular template.
    We then implemented each section of the IGWEB page structure as a template. We
    showed you how to define custom template functions that we could reuse across
    environments.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了Web模板系统以及构成它的各个组件-模板引擎、模板数据对象和模板。我们探讨了Web模板系统的每个组件的目的，并为IGWEB设计了Web页面结构。我们涵盖了三种模板类别：布局模板、部分模板和常规模板。然后，我们将IGWEB页面结构的每个部分实现为模板。我们向您展示了如何定义自定义模板函数，以便在各种环境中重用。
- en: We then introduced you to the concept of isomorphic template rendering. We identified
    the limitations of standard template rendering, based on loading the template
    file from the file system, and introduced the in-memory template set, provided
    by the `isokit` package to render templates isomorphically. We then demonstrated
    how to set up the template set and render the About page on both the server side
    and on the client side.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们向您介绍了同构模板渲染的概念。我们确定了标准模板渲染的局限性，基于从文件系统加载模板文件，并介绍了由`isokit`包提供的内存模板集，以同构方式渲染模板。然后，我们演示了如何在服务器端和客户端上设置模板集并渲染“关于”页面。
- en: In this chapter, we briefly touched upon routing, only so much to understand
    how to register the `/about` route, with its associated handler function on both
    the server side and the client side. In [Chapter 5](8c1d6725-c841-42b2-904d-e34ba3764cc3.xhtml), *End-to-End
    Routing*, we will explore end-to-end application routing in further detail.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了路由，只是为了理解如何在服务器端和客户端注册`/about`路由及其关联的处理程序函数。在[第5章](8c1d6725-c841-42b2-904d-e34ba3764cc3.xhtml)中，*端到端路由*，我们将更详细地探讨端到端应用程序路由。
