["```go\n<!doctype html>\n<html>\n  {{ template \"partials/header_partial\" . }}\n\n    <div id=\"primaryContent\" class=\"pageContent\">\n      {{ template \"pagecontent\" . }}\n    </div>\n\n <div id=\"chatboxContainer\" class=\"containerPulse\">\n </div>\n\n  {{ template \"partials/footer_partial\" . }}\n</html>\n```", "```go\n<div id=\"chatbox\">\n  <div id=\"chatboxHeaderBar\" class=\"chatboxHeader\">\n    <div id=\"chatboxTitle\" class=\"chatboxHeaderTitle\"><span>Chat with {{.AgentName}}</span></div>\n    <div id=\"chatboxCloseControl\">X</div>\n  </div>\n\n  <div class=\"chatboxAgentInfo\">\n    <div class=\"chatboxAgentThumbnail\"><img src=\"img/{{.AgentThumbImagePath}}\" height=\"81px\"></div>\n    <div class=\"chatboxAgentName\">{{.AgentName}}</div>\n    <div class=\"chatboxAgentTitle\">{{.AgentTitle}}</div>\n  </div>\n\n  <div id=\"chatboxConversationContainer\">\n\n  </div>\n\n  <div id=\"chatboxMsgInputContainer\">\n <input type=\"text\" id=\"chatboxInputField\" placeholder=\"Type your message here...\">\n\n </input>\n  </div>\n\n  <div class=\"chatboxFooter\">\n    <a href=\"http://www.isomorphicgo.org\" target=\"_blank\">Powered by Isomorphic Go</a>\n  </div>\n</div>\n```", "```go\n<div class=\"chatboxMessage\">\n <div class=\"chatSenderName\">{{.Name}}</div>\n <div class=\"chatSenderMsg\">{{.Message}}</div>\n</div>\n```", "```go\n$ go get github.com/gorilla/websocket\n```", "```go\ntype Hub struct {\n  chatbot bot.Bot\n  clients map[*Client]bool\n  broadcastmsg chan *ClientMessage\n  register chan *Client\n  unregister chan *Client\n}\n```", "```go\ntype ClientMessage struct {\n  client *Client\n  message []byte\n}\n```", "```go\nfunc NewHub(chatbot bot.Bot) *Hub {\n  return &Hub{\n    chatbot: chatbot,\n    broadcastmsg: make(chan *ClientMessage),\n    register: make(chan *Client),\n    unregister: make(chan *Client),\n    clients: make(map[*Client]bool),\n  }\n}\n```", "```go\nfunc (h *Hub) ChatBot() bot.Bot {\n  return h.chatbot\n}\n```", "```go\nfunc (h *Hub) SendMessage(client *Client, message []byte) {\n  client.send <- message\n}\n```", "```go\nfunc (h *Hub) Run() {\n  for {\n    select {\n    case client := <-h.register:\n      h.clients[client] = true\n      greeting := h.chatbot.Greeting()\n      h.SendMessage(client, []byte(greeting))\n\n    case client := <-h.unregister:\n      if _, ok := h.clients[client]; ok {\n        delete(h.clients, client)\n        close(client.send)\n      }\n    case clientmsg := <-h.broadcastmsg:\n      client := clientmsg.client\n      reply := h.chatbot.Reply(string(clientmsg.message))\n      h.SendMessage(client, []byte(reply))\n    }\n  }\n}\n```", "```go\ntype Client struct {\n  hub *Hub\n  conn *websocket.Conn\n  send chan []byte\n}\n```", "```go\nfunc (c *Client) readPump() {\n  defer func() {\n    c.hub.unregister <- c\n    c.conn.Close()\n  }()\n  c.conn.SetReadLimit(maxMessageSize)\n  c.conn.SetReadDeadline(time.Now().Add(pongWait))\n  c.conn.SetPongHandler(func(string) error { c.conn.SetReadDeadline(time.Now().Add(pongWait)); return nil })\n  for {\n    _, message, err := c.conn.ReadMessage()\n    if err != nil {\n      if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway) {\n        log.Printf(\"error: %v\", err)\n      }\n      break\n    }\n    message = bytes.TrimSpace(bytes.Replace(message, newline, space, -1))\n    // c.hub.broadcast <- message\n\n    clientmsg := &ClientMessage{client: c, message: message}\n c.hub.broadcastmsg <- clientmsg\n\n  }\n}\n```", "```go\ntype ClientMessage struct {\n  client *Client\n  message []byte\n}\n```", "```go\n    clientmsg := &ClientMessage{client: c, message: message}\n    c.hub.broadcastmsg <- clientmsg\n```", "```go\nfunc (c *Client) writePump() {\n  ticker := time.NewTicker(pingPeriod)\n  defer func() {\n    ticker.Stop()\n    c.conn.Close()\n  }()\n  for {\n    select {\n    case message, ok := <-c.send:\n      c.conn.SetWriteDeadline(time.Now().Add(writeWait))\n      if !ok {\n        // The hub closed the channel.\n        c.conn.WriteMessage(websocket.CloseMessage, []byte{})\n        return\n      }\n\n      w, err := c.conn.NextWriter(websocket.TextMessage)\n      if err != nil {\n        return\n      }\n      w.Write(message)\n\n      // Add queued chat messages to the current websocket message.\n      n := len(c.send)\n      for i := 0; i < n; i++ {\n        w.Write(newline)\n        w.Write(<-c.send)\n      }\n\n      if err := w.Close(); err != nil {\n        return\n      }\n    case <-ticker.C:\n      c.conn.SetWriteDeadline(time.Now().Add(writeWait))\n      if err := c.conn.WriteMessage(websocket.PingMessage, []byte{}); err != nil {\n        return\n      }\n    }\n  }\n}\n```", "```go\nfunc ServeWs(hub *Hub) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    conn, err := upgrader.Upgrade(w, r, nil)\n    if err != nil {\n      log.Println(err)\n      return\n    }\n    client := &Client{hub: hub, conn: conn, send: make(chan []byte, 256)}\n    client.hub.register <- client\n    go client.writePump()\n    client.readPump()\n  })\n}\n```", "```go\nfunc startChatHub(hub *chat.Hub) {\n  go hub.Run()\n}\n```", "```go\n  chatbot := bot.NewAgentCase()\n  hub := chat.NewHub(chatbot)\n  startChatHub(hub)\n```", "```go\n  r := mux.NewRouter()\n  registerRoutes(&env, r, hub)\n```", "```go\nr.Handle(\"/restapi/get-agent-info\", endpoints.GetAgentInfoEndpoint(env, hub.ChatBot()))\n```", "```go\n  r.Handle(\"/ws\", chat.ServeWs(hub))\n```", "```go\ntype Bot interface {\n  Greeting() string\n  Reply(string) string\n  Name() string\n  Title() string\n  ThumbnailPath() string\n  SetName(string)\n  SetTitle(string)\n  SetThumbnailPath(string)\n}\n```", "```go\ntype AgentCase struct {\n Bot\n name string\n title string\n thumbnailPath string\n knowledgeBase map[string]string\n knowledgeCorpus []string\n sampleQuestions []string\n}\n```", "```go\nfunc (a *AgentCase) initializeIntelligence() {\n\n  a.knowledgeBase = map[string]string{\n    \"isomorphic go isomorphic go web applications\": \"Isomorphic Go is the methodology to create isomorphic web applications using the Go (Golang) programming language. An isomorphic web application, is a web application, that contains code which can run, on both the web client and the web server.\",\n    \"kick recompile code restart web server instance instant kickstart lightweight mechanism\": \"Kick is a lightweight mechanism to provide an instant kickstart to a Go web server instance, upon the modification of a Go source file within a particular project directory (including any subdirectories). An instant kickstart consists of a recompilation of the Go code and a restart of the web server instance. Kick comes with the ability to take both the go and gopherjs commands into consideration when performing the instant kickstart. This makes it a really handy tool for isomorphic golang projects.\",\n    \"starter code starter kit\": \"The isogoapp, is a basic, barebones web app, intended to be used as a starting point for developing an Isomorphic Go application. Here's the link to the github page: https://github.com/isomorphicgo/isogoapp\",\n    \"lack intelligence idiot stupid dumb dummy don't know anything\": \"Please don't question my intelligence, it's artificial after all!\",\n    \"find talk topic presentation lecture subject\": \"Watch the Isomorphic Go talk by Kamesh Balasubramanian at GopherCon India: https://youtu.be/zrsuxZEoTcs\",\n    \"benefits of the technology significance of the technology importance of the technology\": \"Here are some benefits of Isomorphic Go: Unlike JavaScript, Go provides type safety, allowing us to find and eliminate many bugs at compile time itself. Eliminates mental context-shifts between back-end and front-end coding. Page loading prompts are not necessary.\",\n    \"perform routing web app register routes define routes\": \"You can implement client-side routing in your web application using the isokit Router preventing the dreaded full page reload.\",\n    \"render templates perform template rendering\": \"Use template sets, a set of project templates that are persisted in memory and are available on both the server-side and the client-side\",\n    \"cogs reusable components react-like react\": \"Cogs are reuseable components in an Isomorphic Go web application.\",\n  }\n\n  a.knowledgeCorpus = make([]string, 1)\n  for k, _ := range a.knowledgeBase {\n    a.knowledgeCorpus = append(a.knowledgeCorpus, k)\n  }\n\n  a.sampleQuestions = []string{\"What is isomorphic go?\", \"What are the benefits of this technology?\", \"Does isomorphic go offer anything react-like?\", \"How can I recompile code instantly?\", \"How can I perform routing in my web app?\", \"Where can I get starter code?\", \"Where can I find a talk on this topic?\"}\n\n}\n```", "```go\nfunc (a *AgentCase) Name() string {\n  return a.name\n}\n\nfunc (a *AgentCase) Title() string {\n  return a.title\n}\n\nfunc (a *AgentCase) ThumbnailPath() string {\n  return a.thumbnailPath\n}\n\nfunc (a *AgentCase) SetName(name string) {\n  a.name = name\n}\n\nfunc (a *AgentCase) SetTitle(title string) {\n  a.title = title\n}\n\nfunc (a *AgentCase) SetThumbnailPath(thumbnailPath string) {\n  a.thumbnailPath = thumbnailPath\n}\n```", "```go\nfunc NewAgentCase() *AgentCase {\n  agentCase := &AgentCase{name: \"Case\", title: \"Resident Isomorphic Gopher Agent\", thumbnailPath: \"/static/images/chat/Case.png\"}\n  agentCase.initializeIntelligence()\n  return agentCase\n}\n```", "```go\nfunc (a *AgentCase) Greeting() string {\n\n  sampleQuestionIndex := randomNumber(0, len(a.sampleQuestions))\n  greeting := \"Hi there! I'm Case. You can ask me a question on Isomorphic Go. Such as...\\\"\" + a.sampleQuestions[sampleQuestionIndex] + \"\\\"\"\n  return greeting\n\n}\n```", "```go\nfunc randomNumber(min, max int) int {\n  rand.Seed(time.Now().UTC().UnixNano())\n  return min + rand.Intn(max-min)\n}\n```", "```go\n$ go get github.com/james-bowman/nlp\n```", "```go\nfunc (a *AgentCase) Reply(query string) string {\n```", "```go\n  var result string\n```", "```go\n  vectoriser := nlp.NewCountVectoriser(true)\n  transformer := nlp.NewTfidfTransformer()\n```", "```go\n  reducer := nlp.NewTruncatedSVD(4)\n```", "```go\n  matrix, _ := vectoriser.FitTransform(a.knowledgeCorpus...)\n  matrix, _ = transformer.FitTransform(matrix)\n  lsi, _ := reducer.FitTransform(matrix)\n```", "```go\n  matrix, _ = vectoriser.Transform(query)\n  matrix, _ = transformer.Transform(matrix)\n  queryVector, _ := reducer.Transform(matrix)\n```", "```go\n  highestSimilarity := -1.0\n  var matched int\n  _, docs := lsi.Dims()\n  for i := 0; i < docs; i++ {\n    similarity := nlp.CosineSimilarity(queryVector.(mat.ColViewer).ColView(0), lsi.(mat.ColViewer).ColView(i))\n    if similarity > highestSimilarity {\n      matched = i\n      highestSimilarity = similarity\n    }\n  }\n```", "```go\n  if highestSimilarity == -1 {\n    result = \"I don't know the answer to that one.\"\n  } else {\n    result = a.knowledgeBase[a.knowledgeCorpus[matched]]\n  }\n\n  return result\n```", "```go\nfunc GetAgentInfoEndpoint(env *common.Env, chatbot bot.Bot) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\n    m := make(map[string]string)\n    m[\"AgentName\"] = chatbot.Name()\n    m[\"AgentTitle\"] = chatbot.Title()\n    m[\"AgentThumbImagePath\"] = chatbot.ThumbnailPath()\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(m)\n  })\n```", "```go\n  liveChatIcon := env.Document.GetElementByID(\"liveChatIcon\").(*dom.HTMLImageElement)\n  liveChatIcon.AddEventListener(\"click\", false, func(event dom.Event) {\n\n    chatbox := env.Document.GetElementByID(\"chatbox\")\n    if chatbox != nil {\n      return\n    }\n    go chat.StartLiveChat(env)\n  })\n```", "```go\n$ go get -u github.com/gopherjs/websocket\n```", "```go\nvar ws *websocketjs.WebSocket\nvar agentInfo map[string]string\n```", "```go\nconst ENTERKEY int = 13\n```", "```go\nfunc GetAgentInfoRequest(agentInfoChannel chan map[string]string) {\n  data, err := xhr.Send(\"GET\", \"/restapi/get-agent-info\", nil)\n  if err != nil {\n    println(\"Encountered error: \", err)\n  }\n  var agentInfo map[string]string\n  json.NewDecoder(strings.NewReader(string(data))).Decode(&agentInfo)\n  agentInfoChannel <- agentInfo\n}\n```", "```go\nfunc getServerPort(env *common.Env) string {\n\n  if env.Location.Port != \"\" {\n    return env.Location.Port\n  }\n\n  if env.Location.Protocol == \"https\" {\n    return \"443\"\n  } else {\n    return \"80\"\n  }\n\n}\n```", "```go\nfunc StartLiveChat(env *common.Env) {\n\n  agentInfoChannel := make(chan map[string]string)\n  go GetAgentInfoRequest(agentInfoChannel)\n  agentInfo = <-agentInfoChannel\n```", "```go\n  var err error\n  serverEndpoint := \"ws://\" + env.Location.Hostname + \":\" + getServerPort(env) + \"/ws\"\n  ws, err = websocketjs.New(serverEndpoint)\n  if err != nil {\n    println(\"Encountered error when attempting to connect to the websocket: \", err)\n  }\n```", "```go\n  chatContainer := env.Document.GetElementByID(\"chatboxContainer\").(*dom.HTMLDivElement)\n  chatContainer.SetClass(\"containerPulse\")\n\n  env.TemplateSet.Render(\"partials/chatbox_partial\", &isokit.RenderParams{Data: agentInfo, Disposition: isokit.PlacementReplaceInnerContents, Element: chatContainer})\n```", "```go\n  chatboxHeaderBar := env.Document.GetElementByID(\"chatboxHeaderBar\").(*dom.HTMLDivElement)\n  chatboxHeaderBar.SetClass(\"chatboxHeader\")\n```", "```go\n  InitializeChatEventHandlers(env)\n```", "```go\nfunc InitializeChatEventHandlers(env *common.Env) {\n\n  msgInput := env.Document.GetElementByID(\"chatboxInputField\").(*dom.HTMLInputElement)\n  msgInput.AddEventListener(\"keypress\", false, func(event dom.Event) {\n    if event.Underlying().Get(\"keyCode\").Int() == ENTERKEY {\n      event.PreventDefault()\n      go ChatSendMessage(env, msgInput.Value)\n      msgInput.Value = \"\"\n    }\n\n  })\n```", "```go\n  closeControl := env.Document.GetElementByID(\"chatboxCloseControl\").(*dom.HTMLDivElement)\n  closeControl.AddEventListener(\"click\", false, func(event dom.Event) {\n    CloseChat(env)\n  })\n```", "```go\n  ws.AddEventListener(\"message\", false, func(ev *js.Object) {\n    go HandleOnMessage(env, ev)\n  })\n```", "```go\n  ws.AddEventListener(\"close\", false, func(ev *js.Object) {6\n\n    chatboxContainer := env.Document.GetElementByID(\"chatboxContainer\").(*dom.HTMLDivElement)\n    if len(chatboxContainer.ChildNodes()) > 0 {\n      go HandleDisconnection(env)\n    }\n  })\n```", "```go\n  env.Window.AddEventListener(\"offline\", false, func(event dom.Event) {\n    go HandleDisconnection(env)\n  })\n\n}\n```", "```go\nfunc ChatSendMessage(env *common.Env, message string) {\n  ws.Send([]byte(message))\n  UpdateChatBox(env, message, \"Me\")\n}\n```", "```go\nfunc UpdateChatBox(env *common.Env, message string, sender string) {\n\n  m := make(map[string]string)\n  m[\"Name\"] = sender\n  m[\"Message\"] = message\n  conversationContainer := env.Document.GetElementByID(\"chatboxConversationContainer\").(*dom.HTMLDivElement)\n  env.TemplateSet.Render(\"partials/livechatmsg_partial\", &isokit.RenderParams{Data: m, Disposition: isokit.PlacementAppendTo, Element: conversationContainer})\n  scrollHeight := conversationContainer.Underlying().Get(\"scrollHeight\")\n  conversationContainer.Underlying().Set(\"scrollTop\", scrollHeight)\n}\n```", "```go\nfunc HandleOnMessage(env *common.Env, ev *js.Object) {\n\n  response := ev.Get(\"data\").String()\n  UpdateChatBox(env, response, agentInfo[\"AgentName\"])\n}\n```", "```go\nfunc CloseChat(env *common.Env) {\n  ws.Close()\n  chatboxContainer := env.Document.GetElementByID(\"chatboxContainer\").(*dom.HTMLDivElement)\n  chatboxContainer.RemoveChild(chatboxContainer.ChildNodes()[0])\n\n}\n```", "```go\nfunc HandleDisconnection(env *common.Env) {\n\n  chatContainer := env.Document.GetElementByID(\"chatboxContainer\").(*dom.HTMLDivElement)\n  chatContainer.SetClass(\"\")\n\n  chatboxHeaderBar := env.Document.GetElementByID(\"chatboxHeaderBar\").(*dom.HTMLDivElement)\n  chatboxHeaderBar.SetClass(\"chatboxHeader disconnected\")\n\n  chatboxTitleDiv := env.Document.GetElementByID(\"chatboxTitle\").(*dom.HTMLDivElement)\n  if chatboxTitleDiv != nil {\n    titleSpan := chatboxTitleDiv.ChildNodes()[0].(*dom.HTMLSpanElement)\n    if titleSpan != nil {\n      var countdown uint64 = 6\n      tickerForCountdown := time.NewTicker(1 * time.Second)\n      timerToCloseChat := time.NewTimer(6 * time.Second)\n      go func() {\n        for _ = range tickerForCountdown.C {\n          atomic.AddUint64(&countdown, ^uint64(0))\n          safeCountdownValue := atomic.LoadUint64(&countdown)\n          titleSpan.SetInnerHTML(\"Disconnected! - Closing LiveChat in \" + strconv.FormatUint(safeCountdownValue, 10) + \" seconds.\")\n        }\n      }()\n      go func() {\n        <-timerToCloseChat.C\n        tickerForCountdown.Stop()\n        CloseChat(env)\n      }()\n    }\n  }\n}\n```"]