- en: Cogs – Reusable Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cogs - 可重用组件
- en: In the previous five chapters of this book, we focused on developing functionality
    for either a specific web page on IGWEB or a specific feature, such as the live
    chat feature that we implemented in the last chapter. The solutions that we've
    made thus far have served a particular individual purpose. Not much consideration
    was factored into promoting code reuse for a particular user interface feature,
    since we didn't have the need to create multiple instances of it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前五章中，我们专注于为IGWEB上的特定网页或特定功能开发功能，例如我们在上一章中实现的实时聊天功能。到目前为止，我们所做的解决方案都为特定的个人目的服务。并没有考虑为特定的用户界面功能促进代码重用，因为我们没有需要创建多个实例。
- en: Reusable components are user interface widgets that provide a means to promote
    greater reusability. They can be used in a plug and play manner, since each component
    is a standalone user interface widget that contains its own set of Go source files
    and static assets, such as Go template files, along with CSS and JavaScript source
    files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用组件是用户界面小部件，提供了促进更大重用性的手段。它们可以以即插即用的方式使用，因为每个组件都是一个独立的用户界面小部件，包含自己的一组Go源文件和静态资产，例如Go模板文件，以及CSS和JavaScript源文件。
- en: In this chapter, we will focus on creating **cogs**—reusable components that
    can be utilized in Isomorphic Go web applications. The term `cog` stands for **component
    object in Go**. Cogs are reusable user interface widgets that can either be implemented
    exclusively in Go (a **pure cog**) or implemented using Go and JavaScript (a **hybrid
    cog**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于创建可在同构Go web应用程序中使用的**cogs**——可重用组件。术语`cog`代表**Go中的组件对象**。Cogs是可重用的用户界面小部件，可以纯粹由Go实现（**纯齿轮**），也可以使用Go和JavaScript实现（**混合齿轮**）。
- en: We can create multiple instances of a `cog` and control the cog's behavior by
    supplying input parameters (in the form of key-value pairs) to the `cog`, known
    as **props**. When subsequent changes are made to the props, the `cog` is **reactive**,
    meaning that it can automatically re-render itself. Therefore, cogs have the capability
    to change their appearance, based on changes made to their props.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建多个`cog`的实例，并通过提供输入参数（以键值对的形式）给`cog`，即**props**，来控制cog的行为。当对props进行后续更改时，`cog`是**响应式**的，这意味着它可以自动重新渲染自己。因此，cogs具有根据其props的更改而改变外观的能力。
- en: Perhaps, the most attractive feature of cogs is that they are readily reusable.
    Cogs are implemented as standalone Go packages that contain one or more Go source
    files along with any static assets that are needed by the cog's implementation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，cogs最吸引人的特点是它们是可以立即重用的。Cogs被实现为独立的Go包，包含一个或多个Go源文件以及cog实现所需的任何静态资产。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Essential `cog` concepts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的`cog`概念
- en: Implementing pure cogs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现纯齿轮
- en: Implementing hybrid cogs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现混合齿轮
- en: Essential cog concepts
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本cog概念
- en: '**Cogs** (component objects in Go) are reusable components that are implemented
    in Go. The guiding philosophy behind cogs is to allow developers to create reusable
    components on the front-end in an idiomatic manner. Cogs are self-contained defined
    as their own Go package, which makes it easy to reuse and maintain them. Due to
    their self-contained nature, cogs can be used to create composable user interfaces.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cogs**（Go中的组件对象）是在Go中实现的可重用组件。cogs背后的指导理念是允许开发人员以成熟的方式在前端创建可重用组件。Cogs是自包含的，定义为自己的Go包，这使得重用和维护它们变得容易。由于它们的自包含性质，cogs可以用于创建可组合的用户界面。'
- en: Cogs follow a clear separation of concerns where the presentation layer of a
    `cog` is implemented using one or more Go templates, and the controller logic
    of the cog is implemented in one or more Go source files contained within a Go
    package. These Go source files may import Go packages from the standard library
    or third-party libraries. We'll see an example of this when we implement the time
    ago cog in the *Implementing pure cogs* section of this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Cogs遵循关注点的清晰分离，其中`cog`的表示层使用一个或多个Go模板实现，`cog`的控制器逻辑在一个或多个Go源文件中实现，这些文件包含在一个Go包中。这些Go源文件可能导入标准库或第三方库的Go包。当我们在本章的*实现纯齿轮*部分实现时间之前的齿轮时，我们将看到一个例子。
- en: Cogs may also have CSS stylesheet and JavaScript code associated with them,
    allowing `cog` developers/maintainers to leverage prebuilt JavaScript solutions
    as needed rather than porting a JavaScript widget directly to Go. This makes cogs
    interoperable with existing JavaScript solutions and prevents situations where
    the developer can save valuable time, by not having to reinvent the proverbial
    wheel. For example, Pikaday ([https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday))
    is a well-established calendar date picker JavaScript widget. In the *Implementing
    hybrid cogs* section of this chapter, we will learn how to implement a date picker
    `cog` that utilizes the functionality that the Pikaday JavaScript widget provides.
    Go developers that use the date picker `cog` need not have any knowledge of JavaScript,
    and can utilize it solely with their knowledge of Go.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Cogs也可能有与之相关的CSS样式表和JavaScript代码，允许`cog`开发者/维护者根据需要利用预构建的JavaScript解决方案，而不是直接将JavaScript小部件移植到Go。这使得cogs与现有的JavaScript解决方案具有互操作性，并防止开发人员重复发明轮子，从而节省宝贵的时间。例如，Pikaday（[https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday)）是一个成熟的日历日期选择器JavaScript小部件。在本章的*实现混合齿轮*部分，我们将学习如何实现一个使用Pikaday
    JavaScript小部件提供的功能的日期选择器`cog`。使用日期选择器`cog`的Go开发人员不需要了解JavaScript，并且可以仅使用他们对Go的知识来使用它。
- en: 'Each `cog` comes with a **virtual DOM tree**, an in-memory representation of
    its actual DOM tree. It is far more efficient to manipulate the cog''s in-memory
    virtual DOM tree rather than manipulating the actual DOM tree itself. *Figure
    9.1* is a Venn diagram depicting a cog''s virtual DOM tree, the difference between
    the two trees, and the actual DOM tree:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`cog`都带有一个**虚拟DOM树**，这是其实际DOM树的内存表示。操作`cog`的内存虚拟DOM树要比操作实际DOM树本身更有效率。*图9.1*是一个Venn图，描述了`cog`的虚拟DOM树、两个树之间的差异以及实际DOM树：
- en: '![](img/53478aff-9055-402c-8a14-4400ab176f58.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53478aff-9055-402c-8a14-4400ab176f58.png)'
- en: 'Figure 9.1: A Venn diagram depicting the virtual DOM, the difference, and the
    actual DOM'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：显示虚拟DOM、差异和实际DOM的Venn图
- en: As changes are made to a cog's properties (*props*), the cog's rendering engine
    will utilize its virtual DOM tree to determine the changes and then reconcile
    the changes with the actual DOM tree. This allows the `cog` to be *reactive*,
    meaning that the `cog` can automatically re-render itself the moment that one
    of its props gets updated. In this manner, cogs reduce the complexity that is
    involved when updating the user interface.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当对`cog`的属性（*props*）进行更改时，`cog`的渲染引擎将利用其虚拟DOM树来确定更改，然后将更改与实际DOM树进行协调。这允许`cog`是*reactive*，意味着`cog`可以在其props更新时自动重新渲染自身。通过这种方式，cogs减少了更新用户界面时涉及的复杂性。
- en: The UX toolkit
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UX工具包
- en: 'The UX toolkit provides the functionality to implement cogs within the `cog`
    package, which can be installed using the following `go get` command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: UX工具包提供了在`cog`包中实现cogs的功能，可以使用以下`go get`命令进行安装：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All cogs must implement the `Cog` interface:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有cogs必须实现`Cog`接口：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Render` method is responsible for rendering the `cog` on the web page.
    If there are any errors in the rendering process, the method will return an `error`
    object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Render`方法负责在网页上渲染`cog`。如果在渲染过程中出现任何错误，该方法将返回一个`error`对象。'
- en: The `Start` method is responsible for activating the `cog`. If the `cog` was
    not able to start, the method will return an `error` object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`方法负责激活`cog`。如果`cog`无法启动，该方法将返回一个`error`对象。'
- en: The `cog` package contains two important exported variables, `ReactivityEnabled`
    and `VDOMEnabled`. Both of these exported variables are of type `bool`, and by
    default, they are both set to `true`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`cog`包含两个重要的导出变量，`ReactivityEnabled`和`VDOMEnabled`。这两个导出变量都是`bool`类型，默认情况下都设置为`true`。'
- en: When the variable `ReactivityEnabled` is set to `true`, cogs will be re-rendered
    as changes are made to their props. If `ReactivityEnabled` is set to `false`,
    then the cog's `Render` method must explicitly be called to re-render the cog.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量`ReactivityEnabled`设置为`true`时，cogs将在其props更改时重新渲染。如果`ReactivityEnabled`设置为`false`，则必须显式调用`cog`的`Render`方法来重新渲染`cog`。
- en: When the variable `VDOMEnabled` is set to `true`, cogs will be rendered utilizing
    the cog's virtual DOM tree. If `VDOMEnabled` is set to `false`, the `cog` will
    be rendered using the actual DOM tree through a replace inner HTML operation.
    This can be an expensive operation which can be avoided by utilizing the cog's
    virtual DOM tree.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量`VDOMEnabled`设置为`true`时，cogs将利用`cog`的虚拟DOM树进行渲染。如果`VDOMEnabled`设置为`false`，则将通过替换内部HTML操作使用实际DOM树来渲染`cog`。这可能是一个昂贵的操作，可以通过利用`cog`的虚拟DOM树来避免。
- en: 'The `UXCog` type implements the `Render` method of the `Cog` interface. Here
    is what the `UXCog struct` looks like:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`UXCog`类型实现了`Cog`接口的`Render`方法。以下是`UXCog struct`的样子：'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `UXCog` type provides the basic functionality to make cogs work. That means
    in order to implement our own cogs, we must type embed `UXCog` in the type definition
    of all cogs that we create. The following methods (for brevity, only the method
    signatures are presented) of the `UXCog` type are of particular interest to us:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`UXCog`类型提供了使cogs工作的基本功能。这意味着为了实现我们自己的cogs，我们必须在我们创建的所有cogs的类型定义中嵌入`UXCog`。`UXCog`类型的以下方法（为简洁起见，仅呈现方法签名）对我们来说特别重要：'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `ID` method is a getter method that returns the ID of the cog's `div` container
    in the DOM. A cog's `div` container is known as its **mount point**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`ID`方法是一个getter方法，返回`cog`在DOM中的`div`容器的ID。`cog`的`div`容器被称为其**挂载点**。'
- en: The `SetID` method is a setter method that is used to set the ID of the cog's
    `div` container in the DOM.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetID`方法是一个setter方法，用于设置DOM中`cog`的`div`容器的ID。'
- en: The `CogInit` method is used to associate the `cog` to the application's `TemplateSet`
    object. There are two significant purposes served for this method. First, the
    method is used to register a `cog` on the server-side, so that all of the templates
    for a given `cog` are included in the template bundle that is produced by the
    static assets bundling system built into `isokit`. Second, calling the cog's `CogInit`
    method on the client-side provides the `cog` access to the client-side application's
    `TemplateSet` object, allowing the `cog` to render itself on the web page.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`CogInit`方法用于将`cog`与应用程序的`TemplateSet`对象关联起来。该方法有两个重要目的。首先，该方法用于在服务器端注册`cog`，以便所有给定`cog`的模板都包含在由`isokit`内置的静态资产捆绑系统生成的模板包中。其次，在客户端调用`cog`的`CogInit`方法允许`cog`访问客户端应用程序的`TemplateSet`对象，从而允许`cog`在网页上进行渲染。'
- en: The `SetCogType` method allows us to dynamically set the cog's type by performing
    runtime reflection on a newly instantiated `cog`. This provides the hook needed
    by isokit's static assets bundling system to bundle the template files, CSS source
    files, and JavaScript source files associated for a given `cog`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetCogType`方法允许我们通过对新实例化的`cog`执行运行时反射来动态设置`cog`的类型。这为isokit的静态资产捆绑系统提供了所需的钩子，以捆绑与给定`cog`相关的模板文件、CSS源文件和JavaScript源文件。'
- en: The `SetProp` method is used to set a key-value pair in the cog's `Props` map,
    which is of type `map[string]interface{}`. The `key` of the map represents the
    name of the prop, and the value represents the value of the prop.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetProp` 方法用于在 cog 的 `Props` 映射中设置键值对，该映射的类型为 `map[string]interface{}`。映射的
    `key` 表示 prop 的名称，值表示 prop 的值。'
- en: The `Render` method is responsible for rendering the `cog` to the DOM. If a
    change is made to the `cog` (its prop value is updated) after it has been rendered,
    the `cog` will be re-rendered.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Render` 方法负责将 `cog` 渲染到 DOM。如果在渲染后对 `cog` 进行更改（其 prop 值已更新），则将重新渲染 `cog`。'
- en: 'You can visit the UX toolkit website to learn more about cogs: [http://uxtoolkit.io](http://uxtoolkit.io).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问 UX 工具包网站，了解有关 cogs 的更多信息：[http://uxtoolkit.io](http://uxtoolkit.io)。
- en: Now that we have been acquainted with the `UXCog` type, it's time to examine
    the anatomy of a `cog`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `UXCog` 类型，是时候来检查 `cog` 的解剖学了。
- en: The anatomy of a cog
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cog 的解剖学
- en: For the IGWEB project, we will be creating cogs in the `$IGWEB_APP_ROOT/shared/cogs`
    folder. You can take a peek at the time ago `cog`, whose implementation is found
    in the `$IGWEB_APP_ROOT/shared/cogs/timeago` folder, as you read through this
    section, to see a tangible implementation of the concepts presented herein.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 IGWEB 项目，我们将在 `$IGWEB_APP_ROOT/shared/cogs` 文件夹中创建 cogs。当您阅读本节时，您可以查看 `$IGWEB_APP_ROOT/shared/cogs/timeago`
    文件夹中找到的 time ago `cog` 的实现，以查看所述概念的具体实现。
- en: For the purposes of illustration only, we are going to walk you through the
    process of creating a simple `cog` called `widget`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用于说明的目的，我们将带您了解创建一个名为 `widget` 的简单 `cog` 的过程。
- en: 'The project structure for the widget `cog` contained within the `widget` folder
    is organized in the following manner:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`widget` 文件夹中包含的小部件 `cog` 的项目结构以以下方式组织：'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `widget.go` source file will contain the implementation for the widget `cog`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`widget.go` 源文件将包含小部件 `cog` 的实现。'
- en: The `templates` folder contains the template source file(s) used to implement
    the `cog`. If the `cog` is to be rendered on the web page, at least one template
    source file must be present. The template source file's name must match the package
    name of the `cog`. For example, for the `cog` package `widget`, the name of the
    template source file must be `widget.tmpl`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`templates` 文件夹包含用于实现 `cog` 的模板源文件。如果要在网页上呈现 `cog`，至少必须存在一个模板源文件。模板源文件的名称必须与
    `cog` 的包名称匹配。例如，对于 `cog` 包 `widget`，模板源文件的名称必须是 `widget.tmpl`。'
- en: 'Cogs follow a *convention over configuration* strategy when it comes to naming
    package names and source files. Since we have chosen the name `widget` we must
    declare a Go package named `widget` as well inside the `widget.go` source file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名包名称和源文件时，cogs 遵循 *约定优于配置* 策略。由于我们选择了名称 `widget`，因此我们必须在 `widget.go` 源文件中也声明一个名为
    `widget` 的 Go 包：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'All cogs are required to include the `errors` package, the `reflect` package,
    and the `cog` package in their import grouping:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 cogs 都需要在其导入分组中包含 `errors` 包、`reflect` 包和 `cog` 包：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We must declare an un-exported, package scoped variable called `cogType`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须声明一个未导出的、包范围的变量，名为 `cogType`：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This variable represents the cog''s type. We call the `TypeOf` function in
    the `reflect` package, passing in a newly created instance of the `cog`, to dynamically
    set the cog''s type inside the `cog` package''s `init` function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此变量表示 `cog` 的类型。我们在 `cog` 包的 `init` 函数中调用 `reflect` 包中的 `TypeOf` 函数，传入一个新创建的
    `cog` 实例，以动态设置 `cog` 的类型：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This provides a hook for isokit's static bundling system, to know where to look,
    to obtain the static assets required to make a `cog` function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这为 isokit 的静态捆绑系统提供了一个钩子，以了解在哪里获取所需的静态资源来使 `cog` 函数正常运行。
- en: 'A `cog` implements a specific type. In the case of a widget, we implement the
    `Widget` type. Here''s the `Widget struct`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`cog` 实现了特定类型。对于小部件，我们实现了 `Widget` 类型。这是 `Widget struct`：'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We must type embed the `cog.UXCog` type to bring all the functionality needed
    from the `cog.UxCog` type in order to implement the `cog`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将 `cog.UXCog` 类型嵌入到 `cog` 中，以从 `cog.UxCog` 类型中获取所需的所有功能，以实现 `cog`。
- en: The `struct` may contain other field definitions that are required to implement
    the `cog`, depending on the purpose that the `cog` serves.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` 可能包含其他字段定义，这些字段定义是实现 `cog` 所需的，具体取决于 `cog` 的用途。'
- en: 'Every `cog` implementation should include a constructor function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `cog` 实现都应包含一个构造函数：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As with any typical constructor function, the purpose is to create a new instance
    of the cog, `Widget`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何典型的构造函数一样，目的是创建 `Widget` 的新实例。
- en: The cog's constructor function must contain the line that calls the `SetCogType`
    method (shown in bold). This is used as a hook by isokit's automatic static assets
    bundling system to bundle the cog's required static assets.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: cog 的构造函数必须包含调用 `SetCogType` 方法的行（以粗体显示）。这是 isokit 的自动静态资源捆绑系统用作钩子，以捆绑 `cog`
    所需的静态资源。
- en: Additional fields of the `Widget` type may be set to initialize the `cog` based
    on the cog's implementation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置 `Widget` 类型的其他字段以初始化 `cog`，这取决于 `cog` 的实现。
- en: 'In order to fulfill the implementation of the `Cog` interface, all cogs must
    implement a `Start` method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 `Cog` 接口的实现，所有 cogs 必须实现一个 `Start` 方法：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Start` method is responsible for activating the `cog`, which includes the
    initial render of the `cog` to the web page. The `Start` method will return an
    `error` object, if the `cog` failed to start, otherwise, a `nil` value will be
    returned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start` 方法负责激活 `cog`，包括将 `cog` 初始渲染到网页上。如果 `cog` 启动失败，`Start` 方法将返回一个 `error`
    对象，否则将返回一个 `nil` 值。'
- en: 'For illustration purposes, we have defined an `if` conditional block containing
    a Boolean variable called `allRequiredConditionsHaveBeenMet`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用于说明，我们定义了一个包含名为 `allRequiredConditionsHaveBeenMet` 的布尔变量的 `if` 条件块：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If all the conditions to start the `cog` have been met, this variable will be
    equal to `true`. Otherwise, it will be equal to `false`. If it is `false`, then
    we will return a new `error` object, indicating that the `cog` was unable to start
    since all requirements had not been met.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足了启动`cog`的所有条件，这个变量将等于`true`。否则，它将等于`false`。如果它是`false`，那么我们将返回一个新的`error`对象，表示`cog`由于未满足所有要求而无法启动。
- en: 'We can set a key-value pair in a cog''s `Props` map by calling the `SetProp`
    method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`SetProp`方法在cog的`Props`映射中设置键值对：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, we have set the prop named `foo` to the value `bar`. The `Props`
    map will automatically be used as the data object that gets fed into a cog's template.
    This means that all props defined in the `Props` map are accessible by the cog's
    template.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已将名为`foo`的prop设置为值`bar`。`Props`映射将自动用作传入cog模板的数据对象。这意味着`Props`映射中定义的所有prop都可以被cog的模板访问。
- en: The cog's template source file name, by convention, must be named `widget.tmpl`
    to match the cog's package name of `widget`, and the template file should reside
    in the `templates` folder, which is located in the cog's folder, `widget`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，cog的模板源文件名称必须命名为`widget.tmpl`，以匹配cog的包名称`widget`，并且模板文件应该位于cog的文件夹`widget`中的`templates`文件夹中。
- en: 'Let''s take a quick look at what the `widget.tmpl` source file may look like:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下`widget.tmpl`源文件可能是什么样子：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that we are able to print out the value of the prop that has a key of
    `foo` within the template.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们能够打印出模板中具有键`foo`的prop的值。
- en: 'Let''s return back to the widget cog''s `Start` method. We call the cog''s
    `Render` method to render the `cog` in the web browser:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到widget cog的`Start`方法。我们调用cog的`Render`方法来在web浏览器中渲染`cog`：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Render` method returns an `error` object if an error was encountered while
    rendering a `cog`, otherwise it will return a value of `nil` to indicate that
    the `cog` was rendered successfully.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在渲染`cog`时遇到错误，`Render`方法将返回一个`error`对象，否则将返回一个值为`nil`，表示`cog`已成功渲染。
- en: 'If the `cog` was rendered successfully, the cog''s `Start` method returns a
    value of `nil` to indicate that the `cog` has been started successfully:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cog`成功渲染，cog的`Start`方法会返回一个值为`nil`，表示`cog`已成功启动：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to render our `cog` to the real DOM, we need a place to render the
    `cog` to. The `div` container that houses the rendered content of a `cog` is known
    as its **mount point**. The mount point is where the `cog` gets rendered to in
    the DOM. To render the widget `cog` on the home page, we would add the following
    markup to the home page''s content template:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的`cog`渲染到真实的DOM中，我们需要一个地方来渲染`cog`。包含`cog`渲染内容的`div`容器被称为其**挂载点**。挂载点是`cog`在DOM中渲染的位置。要在主页上渲染widget
    `cog`，我们需要将以下标记添加到主页的内容模板中：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By setting the `data-component` attribute to `"cog"`, we indicate that the `div` element
    is meant to be used as a cog's mount point, and the cog's rendered content will
    be contained inside this element.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`data-component`属性设置为`"cog"`，我们表明`div`元素将用作cog的挂载点，并且cog的渲染内容将包含在此元素内。
- en: 'In the client-side application, the widget `cog` can be instantiated like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端应用程序中，widget `cog`可以这样实例化：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We create a new `Widget` instance and assign it to the variable `w`. We must
    call the `CogInit` method of the `cog` to associate the application's `TemplateSet`
    object with the `cog`. The `cog` utilizes the `TemplateSet` so that it may fetch
    it's associated template(s), which are required to render the `cog`. We call the
    cog's `SetID` method, passing in the `id` to the `div` element that acts as the
    cog's mount point. We call the cog's `Start` method to activate the `cog`. Since
    the `Start` method calls the cog's `Render` method, the cog will be rendered in
    the designated mount point, the `div` element with id, `"widgetContainer"`. Finally,
    when we call the `SetProp` method and change the value of the `"foo"` prop to
    `"bar2"`, the `cog` will get re-rendered automatically.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的`Widget`实例，并将其分配给变量`w`。我们必须调用`cog`的`CogInit`方法，将应用程序的`TemplateSet`对象与`cog`关联起来。`cog`利用`TemplateSet`来获取其关联的模板，这些模板是渲染`cog`所需的。我们调用cog的`SetID`方法，将`id`传递给充当cog挂载点的`div`元素。我们调用cog的`Start`方法来激活`cog`。由于`Start`方法调用了cog的`Render`方法，因此cog将在指定的挂载点`div`元素中渲染，即`"widgetContainer"`的id。最后，当我们调用`SetProp`方法并将`"foo"`
    prop的值更改为`"bar2"`时，`cog`将自动重新渲染。
- en: Now that we've examined the basic anatomy of a `cog`, let's consider how cogs
    are rendered using a virtual DOM.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了`cog`的基本结构，让我们考虑如何使用虚拟DOM来渲染cog。
- en: The virtual DOM tree
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟DOM树
- en: Each `cog` instance has a virtual DOM tree associated with it. This virtual
    DOM tree is a parse tree comprised of all the children of the cog's `div` container.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`cog`实例都有一个与之关联的虚拟DOM树。这个虚拟DOM树是由cog的`div`容器的所有子元素组成的解析树。
- en: '*Figure 9.2* is a flowchart depicting the process to render, and re-render
    (through the application of reconciliation) the `cog` to the DOM:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.2*是一个流程图，描述了将`cog`渲染和重新渲染（通过协调应用）到DOM的过程：'
- en: '![](img/d0aea435-af93-438d-9ce3-b88c23d6edd5.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0aea435-af93-438d-9ce3-b88c23d6edd5.png)'
- en: 'Figure 9.2: A flowchart depicting the process to render and re-render a cog'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：描述了渲染和重新渲染cog的流程图
- en: When the `cog` is first rendered in the DOM, a replace inner HTML operation
    is performed. The operation to replace the inner HTML contents of an element in
    the DOM is an expensive operation. Hence, it is not performed on subsequent renders
    of the `cog`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当`cog`首次在DOM中渲染时，会执行替换内部HTML操作。在DOM中替换元素的内部HTML内容是一个昂贵的操作。因此，在`cog`的后续渲染中不会执行此操作。
- en: All subsequent calls to the cog's `Render` method will utilize the cog's virtual
    DOM tree. The cog's virtual DOM tree is used to keep track of changes between
    the cog's current virtual DOM tree and the cog's new virtual DOM tree. A `cog`
    will have a new virtual DOM tree to compare against its current one when a cog's
    prop value has been updated.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 齿轮的`Render`方法的所有后续调用将利用齿轮的虚拟DOM树。齿轮的虚拟DOM树用于跟踪齿轮当前虚拟DOM树与齿轮新虚拟DOM树之间的变化。当齿轮的prop值已更新时，`cog`将有一个新的虚拟DOM树与其当前虚拟DOM树进行比较。
- en: Let's consider an example scenario with the widget cog. Calling a widget cog's
    `Start` method will perform the initial render of the `cog` (since the cog's `Render`
    method is called within the `Start` method). The `cog` will have a virtual DOM
    tree that will be the parse tree of the `div` container holding the cog's rendered
    content. If we were to update the `"foo"` prop (which is rendered in the cog's
    template) by calling the `SetProp` method on the `cog`, then the `Render` method
    will automatically be called, since the `cog` is reactive. Upon performing the
    subsequent render operation on the `cog`, the cog's current virtual DOM tree will
    be diffed against the cog's new virtual DOM tree (the virtual DOM tree that is
    created after updating the cog's prop).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个小部件齿轮的示例场景。调用小部件齿轮的`Start`方法将执行`cog`的初始渲染（因为`Start`方法内部调用了`Render`方法）。`cog`将具有一个虚拟DOM树，该树将是包含`cog`渲染内容的`div`容器的解析树。如果我们通过调用`cog`的`SetProp`方法更新了“foo”prop（该prop在`cog`的模板中呈现），那么将自动调用`Render`方法，因为`cog`是响应式的。在对`cog`执行后续渲染操作时，齿轮的当前虚拟DOM树将与齿轮的新虚拟DOM树（更新齿轮prop后创建的虚拟DOM树）进行差异比较。
- en: 'If there are no changes between the current virtual DOM tree and the new virtual
    DOM tree, there is no need to perform any operation. However, if there are differences
    between the current virtual DOM tree and the new virtual DOM tree, then we must
    apply the changes that constitute the difference to the actual DOM. The process
    of applying these changes is known as **reconciliation**. Performing reconciliation
    allows us to avoid performing an expensive replace inner HTML operation. Upon
    successful application of reconciliation, the cog''s new virtual DOM tree will
    be considered as the cog''s current virtual DOM tree to prepare the `cog` for
    the next render cycle:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前虚拟DOM树和新虚拟DOM树之间没有变化，则无需执行任何操作。但是，如果当前虚拟DOM树和新虚拟DOM树之间存在差异，则必须将构成差异的更改应用于实际的DOM。应用这些更改的过程称为**协调**。执行协调允许我们避免执行昂贵的替换内部HTML操作。成功应用协调后，齿轮的新虚拟DOM树将被视为齿轮的当前虚拟DOM树，以准备`cog`进行下一个渲染周期：
- en: '![](img/f1b661e1-dbf9-40f0-a649-2349e36cf1c2.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1b661e1-dbf9-40f0-a649-2349e36cf1c2.png)'
- en: 'Figure 9.3: A cog''s existing virtual DOM tree (left) and the cog''s new virtual
    DOM tree (right)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：齿轮的现有虚拟DOM树（左）和齿轮的新虚拟DOM树（右）
- en: '*Figure 9.3* depicts a cog''s existing virtual DOM tree on the left and the
    cog''s new virtual DOM tree on the right. After performing a `diff` operation
    on the two virtual DOM trees (new and existing), it is determined that the rightmost
    `div` element (which contains the `ul` element) and its children have changed,
    and the reconciliation operation would only update the `div` element and its children
    in the actual DOM.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.3*在左侧描述了齿轮的现有虚拟DOM树，右侧描述了齿轮的新虚拟DOM树。在对两个虚拟DOM树（新的和现有的）进行`diff`操作后，确定右侧的`div`元素（包含`ul`元素）及其子元素已更改，并且协调操作将仅更新实际DOM中的`div`元素及其子元素。'
- en: The life cycle of a cog
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 齿轮的生命周期
- en: '*Figure 9.4* depicts the life cycle of a `cog`, which starts on the server-side,
    where we first register the `cog`. The cog''s type must be registered on the server-side
    so that the cog''s associated template(s), along with other static assets can
    be automatically bundled and made available to the client-side application:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.4*描述了`cog`的生命周期，该生命周期始于服务器端，在那里我们首先注册`cog`。必须在服务器端注册`cog`的类型，以便`cog`的关联模板以及其他静态资产可以自动捆绑并提供给客户端应用程序：'
- en: '![](img/39a0e440-a9ed-406b-a79c-9aa495618c26.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39a0e440-a9ed-406b-a79c-9aa495618c26.png)'
- en: 'Figure 9.4: The life cycle of a cog'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：齿轮的生命周期
- en: The subsequent steps in the `cog` life cycle, take place on the client-side.
    We declare a mount point for the `cog`, by introducing a `div` element with a
    data-component attribute equal to `"cog"`, to indicate that the `div` element
    is a mount point for a `cog`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`cog`生命周期中的后续步骤发生在客户端。我们通过引入一个`div`元素，其data-component属性等于`"cog"`，来声明`cog`的挂载点，以指示该`div`元素是`cog`的挂载点。'
- en: The next step, is to create a new instance of the `cog` by calling its constructor
    function. We initialize the `cog` by calling its `CogInit` method and pass in
    the `TemplateSet` object of the client-side application. Initializing the `cog` also
    consists of calling the cog's `SetID` method to associate the mount point to the
    `cog` (so that the `cog` knows where to render to). `Cog` initialization also
    includes setting a prop in the cog's `Props map` by calling its `SetProp` method
    before calling the `Start` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过调用其构造函数创建`cog`的新实例。我们通过调用其`CogInit`方法并传递客户端应用程序的`TemplateSet`对象来初始化`cog`。初始化`cog`还包括通过调用其`SetID`方法将挂载点与`cog`关联起来（以便`cog`知道在哪里进行渲染）。`Cog`初始化还包括在调用`Start`方法之前通过调用其`SetProp`方法在`cog`的`Props
    map`中设置prop。
- en: Note that calling a cog's `SetProp` method, before its `Start` method is called,
    will not render the `cog`. A `cog` will re-render upon calling its `SetProp` method
    only after a `cog` has been rendered to the mount point, by calling its `Start`
    method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在调用齿轮的`Start`方法之前调用齿轮的`SetProp`方法将不会渲染`cog`。只有在通过调用其`Start`方法将`cog`呈现到挂载点后，才会在调用其`SetProp`方法后重新呈现`cog`。
- en: Calling the Cog's `Start` method will activate the `cog` and render the cog's
    contents to the specified mount point.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Cog`的`Start`方法将激活`cog`并将`cog`的内容呈现到指定的挂载点。
- en: Any subsequent calls made to the cog's `SetProp` method will result in a re-render
    of the `cog`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 任何后续对齿轮的`SetProp`方法的调用都将导致齿轮的重新渲染。
- en: When the user navigates to a different page on the website, the container that
    the `cog` resides in is removed, effectively destroying the `cog`. The user may
    specify a clean-up function that should be called just before the `cog` is destroyed.
    This can come in handy to free up resources in a responsible manner prior to the
    cog's destruction. We'll see an example of implementing a clean-up function later
    in this chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在网站上导航到不同的页面时，包含`cog`的容器将被移除，从而有效地销毁`cog`。用户可以指定一个清理函数，在销毁`cog`之前应该调用该函数。这可以帮助在`cog`被销毁之前以负责任的方式释放资源。我们将在本章后面看到实现清理函数的示例。
- en: Implementing pure cogs
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现纯cogs
- en: Now that we have a basic understanding of cogs, its time to implement a few
    cogs in practice. Although cogs operate on the client-side, it is important to
    note that the server-side application needs to acknowledge their existence by
    registering them. Code for cogs are strategically placed in the `shared/cogs` folder
    for this reason.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对cogs有了基本的了解，是时候在实践中实现一些cogs了。尽管cogs在客户端操作，但重要的是要注意，服务器端应用程序需要通过注册来承认它们的存在。出于这个原因，cogs的代码被策略性地放置在`shared/cogs`文件夹中。
- en: Pure cogs are implemented exclusively in Go. As you will see, we can leverage
    functionality from existing Go packages to implement cogs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 纯cogs是专门用Go实现的。正如你将看到的，我们可以利用现有的Go包的功能来实现cogs。
- en: 'Inside the main function in the `igweb.go` source file, we call the `initailizeCogs`
    function passing in the application''s template set:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`igweb.go`源文件的主函数中，我们调用`initailizeCogs`函数，传入应用程序的模板集：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `initializeCogs` function is responsible for initializing all the cogs
    that are going to be used in the Isomorphic Go web application:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeCogs`函数负责初始化Isomorphic Go web应用程序中要使用的所有cogs：'
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the `initializeCogs` function takes a sole input argument, `ts`, the
    `TemplateSet` object. We call the cog's constructor function to create a new instance
    of the `cog`, and immediately call the `CogInit` method of the `cog`, passing
    in the `TemplateSet` object, `ts`, as an input argument to the method. This allows
    the `cog` to include its templates to the application's template set, so that
    the subsequent template bundle that is to be produced will include templates associated
    with the `cog`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`initializeCogs`函数接受一个唯一的输入参数`ts`，即`TemplateSet`对象。我们调用齿轮的构造函数来创建一个新的`cog`实例，并立即调用`cog`的`CogInit`方法，将`TemplateSet`对象`ts`作为输入参数传递给该方法。这允许`cog`将其模板包含到应用程序的模板集中，以便随后要生成的模板包将包括与`cog`相关的模板。
- en: We call the `BundleStaticAssets` method to generate the static assets (CSS and
    JavaScript source files) that are required for each `cog`. Two files will be produced.
    The first file is `cogimports.css`, which will contain the CSS source code needed
    for all the cogs, and the second file is `cogimports.js`, which will contain the
    JavaScript source code needed for all of the cogs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`BundleStaticAssets`方法来生成每个`cog`所需的静态资源（CSS和JavaScript源文件）。将生成两个文件。第一个文件是`cogimports.css`，其中包含所有cogs所需的CSS源代码，第二个文件是`cogimports.js`，其中包含所有cogs所需的JavaScript源代码。
- en: The time ago cog
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间差cog
- en: Now that we have seen how the cogs are initialized on the server-side, it's
    time to take a look at what goes into making a `cog`. We're going to start out
    by making a very simple `cog`, a time ago `cog`, which displays time in human
    understandable format.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何在服务器端初始化cogs，是时候来看看制作`cog`需要做些什么了。我们将从制作一个非常简单的`cog`开始，即时间差`cog`，它以人类可理解的格式显示时间。
- en: It's time revisit the gopher bios on the about page. In the section *Custom
    template functions* found in [Chapter 3](0f18d7dd-b081-4090-8b9c-c7a392261b31.xhtml),
    *Go on the Front-End with GopherJS*, we learned how to use a custom template function
    to display the gopher's start date-time in Ruby format.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候重新查看关于页面上的Gopher简介了。在[第3章](0f18d7dd-b081-4090-8b9c-c7a392261b31.xhtml)中的*自定义模板函数*部分，*Go
    on the Front-End with GopherJS*，我们学习了如何使用自定义模板函数以Ruby格式显示Gopher的开始日期时间。
- en: 'We are going to go a step further and display the start date-time in human
    understandable format by implementing a time ago `cog`. *Figure 9.5* is an illustration
    showing the start date for Molly in the default Go format, in Ruby format, and
    in human understandable format:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进一步展示开始日期时间的人类可理解格式，通过实现一个时间差`cog`。*图9.5*是一个示例，显示了Molly在默认Go格式、Ruby格式和人类可理解格式的开始日期：
- en: '![](img/2f766aa0-f732-486e-bb0f-b66f8b102f43.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f766aa0-f732-486e-bb0f-b66f8b102f43.png)'
- en: 'Figure 9.5: Illustration depicting the time ago cog, which is the last line
    showing the time in human readable format'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：描绘时间差cog的插图，最后一行显示了人类可读格式的时间
- en: Molly joined the IGWEB team on May 24, 2017, which in human readable format
    is 6 months ago (at the present time of writing).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Molly于2017年5月24日加入了IGWEB团队，以人类可读的格式，即6个月前（在撰写时的当前时间）。
- en: 'In the `about_content.tmpl` template source file, we introduce a `div` container
    for the time ago `cog`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`about_content.tmpl`模板源文件中，我们为时间差`cog`引入了一个`div`容器：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we've assigned the attribute, named `data-component`, with a value
    of `cog`. This is to indicate that this `div` container will serve as a mount
    point, housing the rendered content of a `cog`. We set the `id` attribute of the
    container to the first name of the Gopher with a prefix of `"Gopher-"`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经分配了名为`data-component`的属性，其值为`cog`。这是为了表明这个`div`容器将作为一个装载点，容纳`cog`的渲染内容。我们将容器的`id`属性设置为带有前缀“Gopher-”的Gopher的名字。
- en: Later you will see that when we instantiate a `cog`, we must supply a cog's
    `div` container with an ID, so that the `cog` instance knows where its mount point
    is the place that the `cog` should render its output to. We define another custom
    data attribute, `starttimeunix`, and we set it to the Unix timestamp value of
    when the Gopher started working for IGWEB.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后您将看到，当我们实例化一个`cog`时，我们必须为`cog`的`div`容器提供一个ID，以便`cog`实例知道它的挂载点是`cog`应该将其输出呈现到的位置。我们定义了另一个自定义数据属性`starttimeunix`，并将其设置为Gopher开始为IGWEB工作时的Unix时间戳值。
- en: Recall that the value is obtained from calling the template action, which places
    the value obtained by pipelining the `StartTime` property to the custom template
    function, `unixformat`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，该值是通过调用模板操作获得的，该操作将`StartTime`属性通过管道传输到自定义模板函数`unixformat`中获得的值。
- en: 'The `unixformat` custom template function is an alias to the `UnixTime` function
    defined in the `shared/templatefuncs/funcs.go` source file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`unixformat`自定义模板函数是`shared/templatefuncs/funcs.go`源文件中定义的`UnixTime`函数的别名：'
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function will return the time as a `string` value, in Unix format, for
    a given `Time` instance.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将返回给定`Time`实例的Unix格式的时间作为`string`值。
- en: Returning back to the `about_content.tmpl` source file, take note of the `humanReadableDate`
    CSS `className` provided to the `div` container. We'll be using this CSS `className`
    later to fetch all the `timeago` cog `div` containers on the About page.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`about_content.tmpl`源文件，注意提供给`div`容器的`humanReadableDate` CSS `className`。我们稍后将使用这个CSS
    `className`来获取关于页面上所有`timeago` `cog`的`div`容器。
- en: Now that we've seen how to declare the cog's `div` container on the About page,
    let's take a look at how to implement the time ago `cog`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何在关于页面上声明`cog`的`div`容器，让我们来看看如何实现时间过去的`cog`。
- en: 'The time ago `cog` is a pure Go `cog`. That means it''s implemented using only
    Go. The Go package, `go-humanize`, provides us the functionality we need to display
    the time in human readable format. We are going to utilize this package to implement
    the time ago `cog`. Here''s the URL to the GitHub page for the `go-humanize` package:
    [https://github.com/dustin/go-humanize](https://github.com/dustin/go-humanize).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 时间过去的`cog`是一个纯Go `cog`。这意味着它仅使用Go实现。Go包`go-humanize`为我们提供了显示时间的功能。我们将利用这个包来实现时间过去的`cog`。这是`go-humanize`包的GitHub页面的URL：[https://github.com/dustin/go-humanize](https://github.com/dustin/go-humanize)。
- en: 'Let''s examine the `shared/cogs/timeago/timeago.go` source file. We start out
    by declaring the package name as `timeago`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`shared/cogs/timeago/timeago.go`源文件。我们首先声明包名为`timeago`：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our import grouping, we include `github.com/uxtoolkit/cog`, the package
    that provides us with functionality to implement a `cog` (shown in bold). We include
    the `go-humanize` grouping in our import grouping and alias it with the name `"humanize"`
    (shown in bold):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的导入分组中，我们包括`github.com/uxtoolkit/cog`，这个包为我们提供了实现`cog`的功能（以粗体显示）。我们在导入分组中包括`go-humanize`分组，并用名称`"humanize"`进行别名（以粗体显示）：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All cogs must declare an unexported variable called `cogType`, which is of
    type `reflect.Type`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的齿轮都必须声明一个名为`cogType`的未导出变量，其类型为`reflect.Type`：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside the `init` function, we assign the `cogType` variable with the value
    returned by calling the `reflect.TypeOf` function on a newly created `TimeAgo`
    instance:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数内，我们使用`reflect.TypeOf`函数对新创建的`TimeAgo`实例调用，将返回的值赋给`cogType`变量：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Initializing the `cogType` variable is also required for every `cog` that we
    implement. Properly setting the `cogType` allows the static assets bundling system
    to account for the cog's static assets dependencies in the web application. The
    `cogType` will be utilized to gather all of the templates and static assets that
    are required to make the `cog` function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们实现的每个`cog`，也需要初始化`cogType`变量。正确设置`cogType`允许静态资产捆绑系统考虑到齿轮在Web应用程序中的静态资产依赖关系。`cogType`将被用于收集所有模板和静态资产，这些资产是使`cog`函数正常运行所需的。
- en: 'Here''s the `struct` we use to define the `TimeAgo cog`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们用来定义`TimeAgo cog`的`struct`：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Take note that we have embedded `ux.UXCog` in our `struct` definition. As noted
    earlier, the `cog.UXCog` type will provide us the necessary functionality to allow
    us to render the `cog`. Besides embedding the `ux.UXCog`, we have declared an
    unexported field, called `timeInstance`, of type `time.Time`. This will contain
    the `time.Time` instance that we will be converting to human readable format.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在`struct`定义中嵌入了`ux.UXCog`。正如前面所述，`cog.UXCog`类型将为我们提供必要的功能，以允许我们呈现`cog`。除了嵌入`ux.UXCog`，我们还声明了一个未导出字段，名为`timeInstance`，类型为`time.Time`。这将包含我们将转换为人类可读格式的`time.Time`实例。
- en: 'We create a constructor function called `NewTimeAgo` that returns a new `TimeAgo
    cog` instance:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为`NewTimeAgo`的构造函数，它返回一个新的`TimeAgo cog`实例：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The constructor function that we have here, follows the same pattern as any
    other constructor function implemented in Go. Notice that we pass the `cogType`
    to the `SetCogType` method of the newly created `TimeAgo` instance. This is required
    so that the the cog's static assets are included in the static assets bundle that
    is produced by isokit's static asset bundling system.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里拥有的构造函数遵循Go中实现的任何其他构造函数的相同模式。请注意，我们将`cogType`传递给新创建的`TimeAgo`实例的`SetCogType`方法。这是必需的，以便`cog`的静态资产包含在isokit的静态资产捆绑系统生成的静态资产捆绑中。
- en: 'We create a setter method for the `TimeAgo` struct''s `timeInstance` field
    called `SetTime`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`TimeAgo`结构的`timeInstance`字段创建了一个setter方法，名为`SetTime`：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This setter method will be used by the client-side application to set the time
    for the `TimeAgo` cog. We will use the `SetTime` method to set the start date
    of when the gopher joined the IGWEB team.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序将使用此setter方法为`TimeAgo` `cog`设置时间。我们将使用`SetTime`方法来设置Gopher加入IGWEB团队的开始日期。
- en: 'In order to implement the `Cog` interface, a `cog` must define a `Start` method.
    The `Start` method is where the action in a `cog` happens. You should be able
    to get a general idea of what a `cog` does by reading its `Start` method. Here''s
    the `Start` method for the `TimeAgo` cog:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现`Cog`接口，`cog`必须定义一个`Start`方法。`Start`方法是`cog`中操作发生的地方。通过阅读其`Start`方法，您应该能够对`cog`的功能有一个大致的了解。以下是`TimeAgo`
    cog的`Start`方法：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `Start` method returns an error object to inform the caller whether or not
    the `cog` started up properly. Prior to performing any activity, a check is made
    to see if a `timeInstance` value has been set. We use an `if` conditional statement
    to check if the `timeInstance` value is at its zero value, indicating that it
    has not been set. If this condition occurs, the method returns a newly created
    `error` object indicating that the time value has not been set. If the `timeInstance`
    value has been set, we continue forward.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`方法返回一个错误对象，通知调用者`cog`是否正确启动。在执行任何活动之前，会检查`timeInstance`值是否已设置。我们使用`if`条件语句来检查`timeInstance`值是否为其零值，表示它尚未设置。如果发生这种情况，该方法将返回一个新创建的`error`对象，指示时间值尚未设置。如果`timeInstance`值已设置，我们将继续向前。'
- en: We call the cog's `SetProp` method to set the `timeAgoValue` property with the
    human understandable time value. We get the human understandable time value by
    calling the `Time` function from the `go-humanize` package (aliased as `humanize`)
    and passing it the cog's `timeInstance` value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用cog的`SetProp`方法，使用人类可理解的时间值设置`timeAgoValue`属性。我们通过调用`go-humanize`包（别名为`humanize`）中的`Time`函数，并传递cog的`timeInstance`值来获取人类可理解的时间值。
- en: We call the cog's `Render` method to render the `cog`. If an error occurred
    while attempting to render the `cog`, the `Start` method will return the `error`
    object. Otherwise, a value of `nil` will be returned to indicate that there was
    no error starting the `cog`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用cog的`Render`方法来渲染`cog`。如果在尝试渲染`cog`时发生错误，则`Start`方法将返回`error`对象。否则，将返回`nil`值，表示启动`cog`时没有错误。
- en: At this point, we have implemented the Go portion of the `timeago` cog. In order
    to make the human readable time appear on the web page, we have to implement the
    cog's template.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经实现了`timeago` cog的Go部分。为了使人类可读的时间出现在网页上，我们必须实现cog的模板。
- en: 'The `timeago.tmpl` file (found in the `shared/cogs/timeago/templates` directory)
    is a simple, one-liner template. We declare the following `span` element, and
    we have a template action to render the `timeAgoValue` property:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeago.tmpl`文件（位于`shared/cogs/timeago/templates`目录中）是一个简单的单行模板。我们声明以下`span`元素，并且有一个模板动作来渲染`timeAgoValue`属性：'
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: By convention, we must name the primary template of a `cog` found in the `cog`
    package's `templates` folder with the same name of the cog's package. For example,
    for the `timeago` package, the primary template of the `cog` will be `timeago.tmpl`.
    You are free to define and use any custom template function that has been registered
    with the application's template set along with the `cog` templates. You are also
    free to create any number of sub-templates that will be called by the cog's primary
    template.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，`cog`包中的主要模板的名称必须与`cog`包的相同。例如，对于`timeago`包，`cog`的主要模板将是`timeago.tmpl`。您可以自由定义和使用已在应用程序模板集中注册的任何自定义模板函数，以及`cog`模板。您还可以创建任意数量的子模板，这些子模板将由`cog`的主要模板调用。
- en: Now that we have the template for the `TimeAgo` cog in place, we have everything
    we need to instantiate the `cog` on the About page.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在关于页面上实例化`cog`的模板。
- en: 'Let''s examine the `InitializeAboutPage` function in the `client/handlers/about.go`
    source file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`client/handlers/about.go`源文件中的`InitializeAboutPage`函数：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since there are three gophers listed on the About page, there will be a total
    of three `TimeAgo` cog instances running on the page. We gather the `div` containers
    for the cogs using the `GetElementByClassName` method on the `env.Document` object,
    supplying a class name of `humanReadableDate`. We then loop through each `div`
    element, and this is where all the action to instantiate the `cog` takes place.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关于页面上列出了三个地鼠，页面上将运行总共三个`TimeAgo` cog实例。我们使用`env.Document`对象上的`GetElementByClassName`方法，提供`humanReadableDate`类名，来收集cog的`div`容器。然后我们循环遍历每个`div`元素，这就是实例化`cog`的所有操作发生的地方。
- en: First, we extract the Unix timestamp value from the custom data attribute contained
    in the `div` container. Recall that we had populated the `starttimeunix` custom
    data attribute with the Unix timestamp of the Gopher's start time, using the custom
    template function, `unixformat`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`div`容器中包含的自定义数据属性中提取Unix时间戳值。回想一下，我们使用自定义模板函数`unixformat`将`starttimeunix`自定义数据属性填充为地鼠的开始时间的Unix时间戳。
- en: We then create a new `time.Time` object using the `Unix` function available
    in the `time` package and providing the `unixTimestamp` we extracted from the
    custom data attribute of the `div` container. The code to instantiate and set
    up the `TimeAgo` cog is shown in bold. We first instantiate a new `TimeAgo` cog
    by calling the constructor function, `NewTimeAgo`, and assigning it to the `humanTime` variable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`time`包中可用的`Unix`函数创建一个新的`time.Time`对象，并提供我们从`div`容器的自定义数据属性中提取的`unixTimestamp`。用粗体显示了实例化和设置`TimeAgo`
    cog的代码。我们首先通过调用构造函数`NewTimeAgo`来实例化一个新的`TimeAgo` cog，并将其分配给`humanTime`变量。
- en: We then call the `CogInit` method on the `humanTime` object and supply it with
    the `env.TemplateSet` object. We call the `SetID` method to register the `div`
    container's `id` attribute to associate it with the `cog` instance. We then call
    the `SetTime` method on the `TimeAgo` cog, passing in the `time.Time` object,
    `t`, that we had created using the `unixTimestamp` we extracted from the `div`
    container.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在`humanTime`对象上调用`CogInit`方法，并提供`env.TemplateSet`对象。我们调用`SetID`方法来注册`div`容器的`id`属性，以将其与`cog`实例关联起来。然后我们在`TimeAgo`
    cog上调用`SetTime`方法，传入我们从`div`容器中提取的`unixTimestamp`创建的`time.Time`对象`t`。
- en: We have everything in place now to start up the `cog` by calling its `Start`
    method. We assign the `error` object returned by the `Start` method to `err`.
    If `err` is not equal to `nil`, it indicates that an error occurred while starting
    up the `cog`, and in that case we print out a meaningful message in the web console.
    If there were no errors, the `cog` will be rendered to the web page. *Figure 9.6*
    shows a screenshot of Molly's start time in human readable format.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好通过调用其`Start`方法启动`cog`。我们将`Start`方法返回的`error`对象分配给`err`。如果`err`不等于`nil`，则表示在启动`cog`时发生了错误，在这种情况下，我们将在网页控制台中打印出有意义的消息。如果没有错误，`cog`将呈现在网页上。*图9.6*显示了Molly的启动时间的屏幕截图。
- en: '![](img/15fecc9b-375a-4b05-89b6-9892c784b211.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15fecc9b-375a-4b05-89b6-9892c784b211.png)'
- en: 'Figure 9.6: The time ago cog in action'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：时间前`cog`的操作
- en: The live clock cog
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时时钟`cog`
- en: When we called the `Start` method on the time ago `cog`, the time was rendered
    on the web page using the virtual DOM, instead of a replace inner HTML operation
    taking place. Since the time ago `cog`, only updates the time once, upon calling
    the `Start` method of the `cog`, it's hard to appreciate the cog's virtual DOM
    in action.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在时间前调用`Start`方法时，时间将使用虚拟DOM呈现在网页上，而不是进行替换内部HTML操作。由于时间前`cog`只更新一次时间，即在调用`cog`的`Start`方法时，很难欣赏到`cog`的虚拟DOM的作用。
- en: In this example, we're going to build a live clock `Cog`, which has the ability
    to display the current time of any place in the world. Since we'll be displaying
    the time to the seconds, we'll be performing a `SetProp` operation every second
    to re-render the live clock `Cog`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将构建一个实时时钟`Cog`，它具有显示世界上任何地方的当前时间的能力。由于我们将显示到秒的时间，我们将每秒执行一次`SetProp`操作以重新呈现实时时钟`Cog`。
- en: '*Figure 9.7* is an illustration of the live clock:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.7*是实时时钟的插图：'
- en: '![](img/aa3d10d9-cfda-475d-952d-b54caf49810b.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa3d10d9-cfda-475d-952d-b54caf49810b.png)'
- en: 'Figure 9.7: An illustration depicting the live clock cog'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：描绘实时时钟`cog`的插图
- en: 'We''ll be rendering the current time for four places: where you are presently
    located, Chennai, Singapore, and Hawaii. Inside the `shared/templates/index_content.tmpl`
    template source file, we declare four `div` containers that serve as the mounting
    points for the four live clock cogs we''ll be instantiating:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为四个地方渲染当前时间：您目前所在的地方、金奈、新加坡和夏威夷。在`shared/templates/index_content.tmpl`模板源文件中，我们声明了四个`div`容器，它们作为我们将实例化的四个实时时钟`cog`的安装点。
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice again that we have defined the mount points for the live clocks by declaring
    `div` containers containing the attribute, `"data-component"`, and having its
    value set to `"cog"`. We assign unique IDs to all four `cog` containers. The class
    name, `liveclockTime`, that we have declared in the `div` container is for styling
    purposes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们通过声明包含属性`"data-component"`的`div`容器来定义实时时钟的安装点，并将其值设置为`"cog"`。我们为所有四个`cog`容器分配了唯一的ID。我们在`div`容器中声明的类名`liveclockTime`是用于样式目的。
- en: Now that we've set up the mounting points for the four live clock cogs, let's
    take a look at how to implement the live clock `cog`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为四个实时时钟`cog`设置了安装点，让我们来看看如何实现实时时钟`cog`。
- en: The implementation for the live clock `Cog` can be found in the `liveclock.go`
    source file in the `shared/cogs/liveclock` folder.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实时时钟`Cog`的实现可以在`shared/cogs/liveclock`文件夹中的`liveclock.go`源文件中找到。
- en: 'We declare the name `liveclock` for the cog''s package name:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`cog`的包名称声明了名称`liveclock`：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Notice, that in our import grouping we have included the `github.com/uxtoolkit/cog`
    package:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们的导入分组中，我们包含了`github.com/uxtoolkit/cog`包：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We define the `cogType` unexported package variable:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了未导出的包变量`cogType`：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inside the `init` function, we assign the `cogType` variable with the value
    returned by calling the `reflect.TypeOf` function on a newly created `LiveClock`
    instance:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数内，我们将`cogType`变量赋值为调用`reflect.TypeOf`函数在新创建的`LiveClock`实例上返回的值：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is a required step to implement a `cog`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现`cog`的必要步骤。
- en: At this point, we've established that declaring and initializing the `cogType` of
    a `cog` are part of the baseline requirements that we must perform to implement
    a `cog`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定了声明和初始化`cogType`是实现`cog`的基本要求的一部分。
- en: 'Here''s what the struct for the `LiveClock` cog looks like:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`LiveClock` cog的结构：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We embed the `cog.UXCog` type in the cog's struct definition. We introduce a
    `ticker` field which is a pointer to a `time.Ticker`. We'll be using this `ticker` to
    tick at every second for the live clock.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`cog`的结构定义中嵌入了`cog.UXCog`类型。我们引入了一个`ticker`字段，它是指向`time.Ticker`的指针。我们将使用这个`ticker`每秒进行一次实时时钟的滴答。
- en: 'Here''s the `LiveClock` cog''s constructor function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`LiveClock` cog的构造函数：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `NewLiveClock` function serves as the constructor function for the live
    clock `cog`. We declare and initialize the `liveClock` variable to a new `LiveClock`
    instance. We call the `SetCogType` method of the `liveClock` object and pass the
    `cogType`. Recall that this is a required step (shown in bold) that must be present
    in a cog's constructor function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewLiveClock`函数充当实时时钟`cog`的构造函数。我们声明并初始化`liveClock`变量为一个新的`LiveClock`实例。我们调用`liveClock`对象的`SetCogType`方法并传递`cogType`。请记住，这是构造函数中必须存在的步骤（以粗体显示）。'
- en: We then call the `SetCleanupFunc` method of the `liveClock` object, and provide
    it a clean up function, `liveClock.Cleanup`. The `SetCleanUp` method is included
    in the `cog.UXCog` type. It allows us to specify a clean up function that should
    be called prior to the `cog` being removed from the DOM. Finally, we return the
    new instance of the `LiveClock cog`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`liveClock`对象的`SetCleanupFunc`方法，并提供一个清理函数`liveClock.Cleanup`。`SetCleanUp`方法包含在`cog.UXCog`类型中。它允许我们指定一个在`cog`从DOM中移除之前应该调用的清理函数。最后，我们返回`LiveClock
    cog`的新实例。
- en: 'Let''s examine the `Cleanup` function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`Cleanup`函数：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This function is really simple. We simply call the `Stop` method on the cog's `ticker`
    object to stop the `ticker`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单。我们只需在cog的`ticker`对象上调用`Stop`方法来停止`ticker`。
- en: 'Here''s the cog''s `Start` method where the `ticker` will be started:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是cog的`Start`方法，其中`ticker`将被启动：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We start out by declaring the time layout constant, `layout`, and setting it
    to the `RFC1123Z` time format. We declare a `location` variable, a pointer to
    a `time.Location` type:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明时间布局常量`layout`，并将其设置为`RFC1123Z`时间格式。我们声明一个`location`变量，指向`time.Location`类型：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Prior to starting up a `LiveClock` cog, the user of the `cog` must set two
    important props, the `"timezoneName"`, and the `"timezoneOffset"`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动`LiveClock` cog之前，`cog`的用户必须设置两个重要的属性，即“timezoneName”和“timezoneOffset”：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These values are used to initialize the location variable. If either of these
    props were not provided, an `error` will be returned.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值用于初始化位置变量。如果这些属性中的任何一个未提供，将返回一个错误。
- en: 'If both of the props are present, we proceed to assigning the `ticker` property
    of the live clock `cog` to a newly created `time.Ticker` instance, which will
    tick at every second:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个属性都存在，我们继续将实时时钟`cog`的`ticker`属性分配给一个新创建的`time.Ticker`实例，它将每秒进行滴答：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We `range` on the ticker''s channel to iterate at every one second, as a value
    arrives, and we set the `currentTime` prop, providing it a formatted time value
    (shown in bold):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在ticker的通道上使用`range`来迭代每一秒，当值到达时，我们设置`currentTime`属性，为其提供格式化的时间值（以粗体显示）：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that we used both the location, and the time layout to format the time.
    Once the `cog` has been rendered, calls to `SetProp` that will occur every second
    will automatically call the `Render` method to re-render the `cog`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们同时使用了位置和时间布局来格式化时间。一旦cog被渲染，每秒将自动调用`SetProp`来调用`Render`方法重新渲染cog。
- en: 'We make a call to the cog''s `Render` method to render the `cog` to the web
    page:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用cog的`Render`方法来将cog渲染到网页上：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the last line of the method, we return a `nil` value to indicate that no
    errors occurred:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的最后一行，我们返回一个`nil`值，表示没有发生错误：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We''ve defined the template for the `cog` in the `liveclock.tmpl` source file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`liveclock.tmpl`源文件中定义了`cog`的模板：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We print out the time label, along with the current time. The `timeLabel` prop
    is used to supply the time label to the `cog` and will be the name of the place
    for which we want to know the current time of.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出时间标签，以及当前时间。`timeLabel`属性用于向`cog`提供时间标签，并且将是我们想要知道当前时间的地方的名称。
- en: Now that we've seen what goes into making the live clock `cog`, and how it displays
    the time, let's go ahead and sprinkle some live clock cogs on the home page.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了制作实时时钟“cog”所需的内容，以及它如何显示时间，让我们继续在主页上添加一些实时时钟cogs。
- en: 'Here''s the section of code inside the `InitializeIndexPage` function of the
    `index.go` source file, where we instantiate the live clock cog for the local
    time zone:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`index.go`源文件中`InitializeIndexPage`函数内部的代码部分，我们在其中为本地时区实例化实时时钟cog：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In order to instantiate the cog for the local time, we first obtain the local
    zone name and the local time zone offset. We then create a new instance of a `LiveClock
    cog` called `lc`. We call the `CogInit` method to initialize the cog. We call
    the `SetID` method to register the `id` of the cog's mount point, the `div` container
    where the `cog` will render its output to. We make calls to the `SetProp` method
    to set the `"timeLabel"`, `"timezoneName"`, and `"timezoneOffset"` props. Finally,
    we call the `Start` method to start up the `LiveClock` cog. As usual, we check
    to see if the `cog` started up properly, and if it didn't, we print the `error`
    object in the web console.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实例化本地时间的cog，我们首先获取本地区域名称和本地时区偏移量。然后我们创建一个名为`lc`的`LiveClock cog`的新实例。我们调用`CogInit`方法来初始化cog。我们调用`SetID`方法来注册cog的挂载点的`id`，即`div`容器，`cog`将把其输出渲染到其中。我们调用`SetProp`方法来设置“timeLabel”、“timezoneName”和“timezoneOffset”属性。最后，我们调用`Start`方法来启动`LiveClock`
    cog。和往常一样，我们检查`cog`是否正常启动，如果没有，我们在web控制台中打印出`error`对象。
- en: 'In a similar manner, we instantiate the `LiveClock` cogs for Chennai, Singapore,
    and Hawaii, in much the same way as we did for the local time, except for one
    thing. For the other places, we explicitly provide the timezone name and the GMT
    timezone offset for each place:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们以与本地时间相同的方式实例化了Chennai、新加坡和夏威夷的`LiveClock` cogs，除了一件事。对于其他地方，我们明确提供了每个地方的时区名称和GMT时区偏移量：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, we will be able to see the live clock cogs in action. *Figure 9.8* is a
    screenshot of the live clogs displayed on the homepage.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将能够看到实时时钟cogs的运行情况。*图9.8*是主页上显示的实时时钟的屏幕截图。
- en: '![](img/7e166fd4-a7db-4b49-8d19-07f012ac9d5c.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e166fd4-a7db-4b49-8d19-07f012ac9d5c.png)'
- en: 'Figure 9.8: The live clock cog in action'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：实时时钟cog的运行情况
- en: With every passing second, each live clock gets updated with the new time value.
    The virtual DOM kicks in and renders only the difference of what changed, efficiently
    re-rendering the live clock at every second.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每一秒的流逝，每个实时时钟都会更新新的时间值。虚拟DOM会渲染出变化的部分，有效地在每秒重新渲染实时时钟。
- en: The first two cogs that we have implemented so far, have been pure cogs that
    are entirely implemented in Go. What if we wanted to leverage an existing JavaScript
    solution to provide a specific feature? That would be a situation that calls for
    implementing a hybrid cog, a `cog` that is implemented in Go and JavaScript.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实现的前两个cogs都是完全由Go实现的纯cogs。如果我们想利用现有的JavaScript解决方案来提供特定功能，该怎么办？这将是需要实现混合cog的情况，一个由Go和JavaScript实现的`cog`。
- en: Implementing hybrid cogs
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现混合cogs
- en: JavaScript has been around for more than two decades. In that time span, a lot
    of robust, production-ready solutions have been created using the language. Isomorphic
    Go cannot exist on its own island, and we have to acknowledge that there are many
    helpful, ready-made solutions that are useful from the JavaScript ecosystem. In
    many scenarios, we can save considerable time and effort by creating solutions
    that leverage existing JavaScript solutions, rather than re-implementing the whole
    solution in a pure Go manner.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript已经存在了二十多年。在这段时间内，使用这种语言创建了许多强大的、可用于生产的解决方案。同构Go不能独立存在，我们必须承认JavaScript生态系统中有许多有用的现成解决方案。在许多情况下，我们可以通过利用现有的JavaScript解决方案来节省大量时间和精力，而不是以纯Go的方式重新实现整个解决方案。
- en: Hybrid cogs are implemented using Go and JavaScript. The main purpose of hybrid
    cogs is to leverage functionality in existing JavaScript solutions and expose
    that functionality as a `cog`. This means that `cog` implementors would need to
    know both Go and JavaScript to implement hybrid cogs. Keep in mind that users
    of hybrid cogs only need to know Go, since the usage of JavaScript is an internal
    implementation detail of the `cog`. This allows cogs to be readily usable by Go
    developers that may not be familiar with JavaScript.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 混合cogs是使用Go和JavaScript实现的。混合cogs的主要目的是利用现有的JavaScript解决方案的功能，并将该功能公开为`cog`。这意味着`cog`实现者需要了解Go和JavaScript来实现混合cogs。请记住，混合cogs的用户只需要了解Go，因为JavaScript的使用是`cog`的内部实现细节。这使得那些可能不熟悉JavaScript的Go开发人员可以方便地使用cogs。
- en: The date picker cog
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期选择器cog
- en: Let's consider a scenario that warrants the implementation of a hybrid `cog`.
    Molly, the de-facto product manager of IGWEB, came up with a killer idea to provide
    better customer support. Her feature request to the tech team was to allow the
    website user to provide an optional priority date on the contact form, by which
    a user should hear back from a gopher on the IGWEB team.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一种需要实现混合`cog`的情况。Molly，IGWEB的事实产品经理，提出了一个提供更好客户支持的绝佳主意。她向技术团队提出的功能请求是允许网站用户在联系表单上提供一个可选的优先日期，通过这个日期，用户应该在IGWEB团队的gopher回复。
- en: Molly found a self-contained, date picker widget, implemented in vanilla JavaScript
    (no framework/library dependencies) called Pikaday: [https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Molly找到了一个独立的日期选择器小部件，使用纯JavaScript实现（没有框架/库依赖），名为Pikaday：[https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday)。
- en: 'The Pikaday, JavaScript date picker widget, highlights the fact that was presented
    in the beginning of this section. JavaScript is not going away, and there are
    many useful solutions that have already been made using it. That means, we must
    have the capability to leverage existing JavaScript solutions when it makes sense
    to do so. The Pikaday date picker is a particular use-case where it is more beneficial
    to leverage this existing JavaScript date picker widget, rather than implement
    one as a pure `cog`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Pikaday，JavaScript日期选择器小部件，突出了本节开头提到的事实。JavaScript不会消失，已经有许多有用的解决方案是用它创建的。这意味着，我们必须有能力在有意义的时候利用现有的JavaScript解决方案。Pikaday日期选择器是一个特定的用例，更有利于利用现有的JavaScript日期选择器小部件，而不是将其作为纯`cog`实现。
- en: '![](img/72dbbc90-5aa2-4242-a10a-c8bb83c6cfb7.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72dbbc90-5aa2-4242-a10a-c8bb83c6cfb7.png)'
- en: 'Figure 9.9: A wireframe design depicting the time sensitivity date input field
    and the calendar date picker widget'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：描述时间敏感日期输入字段和日历日期选择器小部件的线框设计
- en: '*Figure 9.9* is a wireframe design depicting the contact form with a time sensitivity
    input field, that when clicked, will reveal a calendar date picker. Let''s see
    what it takes to fulfill Molly''s request by implementing the date picker cog,
    a hybrid cog, made with Go and JavaScript.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.9*是一个线框设计，描述了带有时间敏感输入字段的联系表单，当点击时，将显示一个日历日期选择器。让我们看看通过使用Go和JavaScript实现的日期选择器cog来满足Molly的请求需要做些什么。'
- en: We start out by placing the JavaScript and CSS source files required by the
    Pikaday, date picker widget, inside the `js` and `css` folders (respectively),
    inside the cog's `static` folder.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将Pikaday日期选择器所需的JavaScript和CSS源文件放在`cog`的`static`文件夹中的`js`和`css`文件夹中（分别）。
- en: 'Inside the `shared/templates/partials/contactform_partial.tmpl` source file,
    we declare the mount point for the date picker cog (shown in bold):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在`shared/templates/partials/contactform_partial.tmpl`源文件中，我们声明了日期选择器cog的挂载点（以粗体显示）：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `div` container fulfills two basic requirements of all `cog` mounting points:
    we have set the attribute, `"data-component"`, with the value `"cog"`, and we
    have specified an `id` of `"sensitivityDate"` for the `cog` container.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`div`容器满足所有`cog`挂载点的两个基本要求：我们已经设置了属性`"data-component"`，值为`"cog"`，并为`cog`容器指定了一个`id`为`"sensitivityDate"`。'
- en: 'Let''s examine the implementation of the date picker cog, defined in the `shared/cogs/datepicker/datepicker.go`
    source file, section by section. First, we start out by declaring the package
    name:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐节检查日期选择器cog的实现，定义在`shared/cogs/datepicker/datepicker.go`源文件中。首先，我们从声明包名开始：
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here''s the cog''s import grouping:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是cog的导入分组：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice that we include the `gopherjs` package in the import grouping (shown
    in bold). We will need functionality from `gopherjs` to query the DOM.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在导入分组中包含了`gopherjs`包（以粗体显示）。我们将需要`gopherjs`的功能来查询DOM。
- en: 'Right after we declare the `cogType`, we initialize the `JS` variable to `js.Global`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们声明`cogType`之后，我们将`JS`变量初始化为`js.Global`：
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you may recall, this saves us a little bit of typing. We can directly refer
    to `js.Global` as `JS`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得的那样，这为我们节省了一点输入。我们可以直接将`js.Global`称为`JS`。
- en: 'From the Pikaday project web page, [https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday),
    we can learn all of the input parameters the date picker widget accepts. The input
    parameters are provided as a single JavaScript object. The date picker `cog` will
    expose a subset of these input parameters, just enough to fulfill Molly''s feature
    request. We create a `struct` called `DatePickerParams` that serves as the input
    parameters to the date picker widget:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 从Pikaday项目网页[https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday)，我们可以了解日期选择器小部件接受的所有输入参数。输入参数作为单个JavaScript对象提供。日期选择器`cog`将公开这些输入参数的子集，足以满足Molly的功能请求。我们创建了一个名为`DatePickerParams`的`struct`，它作为日期选择器小部件的输入参数：
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We embed the `*js.Object` to indicate that this is a JavaScript object. We then
    declare the respective Go fields for the `struct` for the respective properties
    of the JavaScript input object. For example, the field named `Field` is for the
    `field` property. The `"js"` `struct` tags that we have provided for each field
    allows GopherJS to convert the `struct` and its field, from its designated Go
    name to its equivalent JavaScript name. Just as we declared the field named Field,
    we have also declared fields for `FirstDay` (`firstDay`), `MinDate` (`minDate`),
    `MaxDate` (`maxDate`), and `YearRange` (`yearRange`).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们嵌入`*js.Object`以指示这是一个JavaScript对象。然后我们为JavaScript输入对象的相应属性的`struct`声明相应的Go字段。例如，名为`Field`的字段是为`field`属性而声明的。我们为每个字段提供的`"js"`
    `struct`标签允许GopherJS将`struct`及其字段从其指定的Go名称转换为其等效的JavaScript名称。正如我们声明了名为Field的字段一样，我们还为`FirstDay`（`firstDay`）、`MinDate`（`minDate`）、`MaxDate`（`maxDate`）和`YearRange`（`yearRange`）声明了字段。
- en: 'Reading the Pikaday documentation, [https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday),
    we can learn what purpose each of these input parameters serve:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读Pikaday文档，[https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday)，我们可以了解每个输入参数的作用：
- en: '`Field` - Used to bind the date picker to a form field.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Field` - 用于将日期选择器绑定到表单字段。'
- en: '`FirstDay` - Used to specify the first day of the week. (0 for Sunday, 1 for
    Monday, etc).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstDay` - 用于指定一周的第一天。（0代表星期日，1代表星期一，依此类推）。'
- en: '`MinDate` - The earliest date that can be selected in the date picker widget.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinDate` - 可以在日期选择器小部件中选择的最早日期。'
- en: '`MaxDate` - The latest date that can be selected in the date picker widget.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxDate` - 可以在日期选择器小部件中选择的最晚日期。'
- en: '`YearRange` - The range of years to display.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YearRange` - 要显示的年份范围。'
- en: 'Now that we''ve defined the date picker''s input parameters struct, `DatePickerParams`,
    it''s time to implement the date picker `cog`. We start out by declaring the `DatePicker`
    struct:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了日期选择器的输入参数结构`DatePickerParams`，是时候实现日期选择器`cog`了。我们首先声明`DatePicker`结构：
- en: '[PRE56]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As usual, we embed the `cog.UXCog` to bring along all the UXCog functionality
    we need. We also declare a field, `picker`, that's a pointer to a `js.Object`.
    The `picker` property will be used to refer to the Pikaday date picker JavaScript
    object.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们嵌入`cog.UXCog`来带来我们需要的所有UXCog功能。我们还声明了一个字段`picker`，它是指向`js.Object`的指针。`picker`属性将用于引用Pikaday日期选择器JavaScript对象。
- en: 'We then implement a constructor function for the date picker `cog` called `NewDatePicker`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为日期选择器`cog`实现了一个名为`NewDatePicker`的构造函数：
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: By now, the cog constructor should look familiar to you. Its duties are to return
    a new instance of a `DatePicker` and to set the cog's `cogType`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，cog构造函数对您来说应该很熟悉。它的职责是返回`DatePicker`的新实例，并设置cog的`cogType`。
- en: 'Now that our constructor function is in place, it''s time to examine the date
    picker cog''s `Start` method:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的构造函数已经就位，是时候来检查日期选择器cog的`Start`方法了：
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We start out by checking to see if the `"datepickerInputID"` prop has been set.
    This is the `id` of the input field element, which will be used as the `Field`
    value in the `DatePickerParams` `struct`. It is a hard requirement, that this
    prop must be set by the caller, before starting the `cog`. Failure to set this
    prop will result in an error.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否已设置`"datepickerInputID"`属性。这是输入字段元素的`id`，将用作`DatePickerParams` `struct`中的`Field`值。在开始`cog`之前，调用者必须设置此属性，这是一个硬性要求。未设置此属性将导致错误。
- en: If the `"datepickerInputID"` prop has been set, we call the cog's `Render` method
    to render the cog. This will render the HTML markup for the input field that the
    date picker JavaScript widget object will rely on.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已设置`"datepickerInputID"`属性，我们调用cog的`Render`方法来渲染cog。这将为日期选择器JavaScript小部件依赖的输入字段渲染HTML标记。
- en: 'We then go on to declare and instantiate, `params`, the input parameters JavaScript
    object that will be shipped to the date picker JavaScript widget:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明并实例化`params`，这是一个JavaScript对象，将被传递给日期选择器JavaScript小部件：
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The date picker input parameters object, `params`, is a JavaScript object. The
    Pikaday JavaScript object will use the `params` object for initial configuration.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 日期选择器输入参数对象`params`是一个JavaScript对象。Pikaday JavaScript对象将使用`params`对象进行初始配置。
- en: 'We use the cog''s `Props` property to range through the cog''s properties.
    For each iteration we fetch the property''s name (`propName`) and the property''s
    value (`propValue`):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用cog的`Props`属性来遍历cog的属性。对于每次迭代，我们获取属性的名称（`propName`）和属性的值（`propValue`）：
- en: '[PRE60]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `switch` block we have declared is important for readability:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明的`switch`块对于可读性很重要：
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Each `case` statement inside the `switch` block, tells us all the properties
    the date picker `cog` accepts as input parameters that will be ferried over to
    the Pikaday JavaScript widget. If a prop name is not recognized, we print out
    a warning in the web console that the prop is unknown.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`块内的每个`case`语句告诉我们日期选择器`cog`接受的所有属性作为输入参数，这些参数将被传递到Pikaday JavaScript小部件。如果未识别属性名称，则在Web控制台中打印警告，说明该属性未知。'
- en: The first case, handles the `"datepickerInputID"` prop. It will be used to specify
    the `id` of the input element that activates the Pikaday widget. Inside this `case`,
    we get the input element field by calling the `getElementById` method on the `document`
    object and passing the `inputFieldID` to the method. We set the input `params`
    property, `Field` to the input field element that was obtained from the `getElementById` method
    call.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况处理了`"datepickerInputID"`属性。它将用于指定激活Pikaday小部件的输入元素的`id`。在这种情况下，我们通过在`document`对象上调用`getElementById`方法并将`inputFieldID`传递给该方法来获取输入元素字段。我们将输入`params`属性`Field`设置为从`getElementById`方法调用中获取的输入字段元素。
- en: The second case handles the `"datepickerLabel"` prop. The value for the `"datepickerLabel"`
    prop will be used in the cog's template source file. Therefore there's no work
    needed to handle this particular case.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况处理了`"datepickerLabel"`属性。`"datepickerLabel"`属性的值将在cog的模板源文件中使用。因此，不需要处理这种特殊情况。
- en: The third case handles the `"datepickerMinDate"` prop. It will be used to get
    the minimum date that should be shown by the Pikaday widget. We convert the `"datepickerMinDate"`
    value of `type time.Time` provided by the caller to its Unix timestamp representation.
    We then create a new JavaScript `date` object using the Unix timestamp, which
    is suitable for use for the `minDate` input parameter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种情况处理了`"datepickerMinDate"`属性。它将用于获取Pikaday小部件应显示的最小日期。我们将调用者提供的`type time.Time`的`"datepickerMinDate"`值转换为其Unix时间戳表示。然后，我们使用Unix时间戳创建一个新的JavaScript
    `date`对象，适用于`minDate`输入参数。
- en: The fourth case handles the `"datepickerMaxDate"` prop. It will be used to get
    the maximum date that should be shown by the date picker widget. We follow the
    same strategy here, that we did for the `minDate` argument.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种情况处理了`"datepickerMaxDate"`属性。它将用于获取日期选择器小部件应显示的最大日期。我们在这里采用了与`minDate`参数相同的策略。
- en: The fifth case handles the `"datepickerYearRange"` prop. It will be used to
    specify the range of years that the displayed calendar will cover. The year range
    is a slice, and we populate the `YearRange` property of the input parameters object
    using the prop's value.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第五种情况处理了`"datepickerYearRange"`属性。它将用于指定显示的日历将覆盖的年份范围。年份范围是一个切片，我们使用属性的值填充输入参数对象的`YearRange`属性。
- en: As stated earlier, the `default` `case` handles the scenario, where the caller
    provides a prop name that is not known. If we reach the `default` `case`, we print
    out a warning message in the web console.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`default` `case`处理了调用者提供未知属性名称的情况。如果我们到达`default` `case`，我们将在Web控制台中打印警告消息。
- en: 'Now we can instantiate the Pikaday widget and provide the input parameters
    obect, `params`, to it like so:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实例化Pikaday小部件，并将输入参数对象`params`提供给它：
- en: '[PRE62]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we indicate that there were no errors starting up the cog, by returning
    a `nil` value:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过返回`nil`值表示启动`cog`时没有错误：
- en: '[PRE63]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now that we have implemented the date picker cog, let''s take a look at what
    the cog''s primary template, defined in the `shared/cogs/datepicker/templates/datepicker.tmpl`
    source file, looks like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了日期选择器cog，让我们来看看cog的主要模板，定义在`shared/cogs/datepicker/templates/datepicker.tmpl`源文件中，是什么样子：
- en: '[PRE64]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We declare a `label` element to display the label of the date picker cog using
    the prop `"datepickerLabel"`. We declare an `input` element that will serve as
    the input element field that will be used in conjunction with the Pikaday widget.
    We specify the `id` attribute of the input element field using the `"datepickerInputID"`
    prop.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个`label`元素，使用属性`"datepickerLabel"`显示日期选择器cog的标签。我们声明一个`input`元素，它将作为与Pikaday小部件一起使用的输入元素字段。我们使用`"datepickerInputID"`属性指定输入元素字段的`id`属性。
- en: 'Now that we have implemented the date picker cog, it''s time to start using
    it. We instantiate the `cog` inside the `InitializeContactPage` function, found
    in the `client/handlers/contact.go` source file:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了日期选择器cog，是时候开始使用它了。我们在`client/handlers/contact.go`源文件中的`InitializeContactPage`函数中实例化`cog`：
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: First, we create a new instance of the `DatePicker cog`. We then call the cog's `CogInit`
    method, to register the application's template set. We call the `SetID` method
    to set the cog's mount point. We make calls to the cog's `SetProp` method to set
    the `datePickerLabel`, `datepickerInputID`, `datepickerMinDate`, and `datepickerMaxDate`
    props. We call the cog's `Start` method to activate it. If there were any errors
    starting the `cog`, we print the error message out to the web console.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`DatePicker cog`的新实例。然后，我们调用cog的`CogInit`方法，注册应用程序的模板集。我们调用`SetID`方法设置cog的挂载点。我们调用cog的`SetProp`方法设置`datePickerLabel`、`datepickerInputID`、`datepickerMinDate`和`datepickerMaxDate`属性。我们调用cog的`Start`方法来激活它。如果启动`cog`时出现任何错误，我们将错误消息打印到Web控制台。
- en: And that's all there is to it! We could leverage the functionality we needed
    from the Pikaday widget using the date picker hybrid `cog`. The advantage of this
    approach is that Go developers utilizing the date picker `cog` will not need to
    have knowledge of the inner workings (JavaScript) of the Pikaday widget in order
    to use it. Instead, they can use the functionality that the date picker `cog`
    exposes to them from within the confines of Go.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容了！我们可以利用日期选择器混合`cog`从Pikaday小部件中获取所需的功能。这种方法的优势在于，使用日期选择器`cog`的Go开发人员不需要了解Pikaday小部件的内部工作（JavaScript），就可以使用它。相反，他们可以在Go的范围内使用日期选择器`cog`向他们公开的功能。
- en: '*Figure 9.10* shows a screenshot of the date picker `cog` in action:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.10*显示了日期选择器`cog`的操作截图：'
- en: '![](img/8e47b957-a807-4bb5-8ccf-4950f4ddd950.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e47b957-a807-4bb5-8ccf-4950f4ddd950.png)'
- en: 'Figure 9.10: The calendar date picker widget in action'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：日历日期选择器小部件的操作
- en: Even if the cog user didn't provide any props, other than the required `datepickerInputID`,
    to custom configure the date picker `cog`, the Pikaday widget starts up just fine.
    However, what if we needed to supply a default set of parameters for the `cog`?
    In the next example, we are going to build another hybrid `cog`, a carousel (an
    image slider) `cog`, in which we will define default parameters.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 即使齿轮用户除了必需的`datepickerInputID`之外没有提供任何自定义配置日期选择器`cog`的props，Pikaday小部件也可以正常启动。但是，如果我们需要为`cog`提供一组默认参数怎么办？在下一个示例中，我们将构建另一个混合`cog`，一个轮播图（图像滑块）`cog`，在其中我们将定义默认参数。
- en: The carousel cog
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮播图齿轮
- en: In this example, we will be creating an image carousel cog, as depicted by the
    wireframe design in *Figure 9.11*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将创建一个图像轮播图齿轮，如*图9.11*中的线框设计所示。
- en: '![](img/bc822f06-91d8-4abd-ad46-dee1c7ecf5f3.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc822f06-91d8-4abd-ad46-dee1c7ecf5f3.png)'
- en: 'Figure 9.11: A wireframe design depicting the carousel cog'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：描述轮播图齿轮的线框设计
- en: 'The carousel cog will be powered by the tiny-slider widget which is implemented
    in vanilla JavaScript. Here''s the URL to the tiny-slider project: [https://github.com/ganlanyuan/tiny-slider](https://github.com/ganlanyuan/tiny-slider).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 轮播图齿轮将由vanilla JavaScript中实现的tiny-slider小部件提供动力。以下是tiny-slider项目的URL：[https://github.com/ganlanyuan/tiny-slider](https://github.com/ganlanyuan/tiny-slider)。
- en: We place the JavaScript source file for the tiny-slider widget, `tiny-slider.min.js`
    in the cog's `static/js` folder. We place the CSS files associated with the tiny-slider
    widget, `tiny-slider.css`, and `styles.css` in the `static/css` folder.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将tiny-slider小部件的JavaScript源文件`tiny-slider.min.js`放在齿轮的`static/js`文件夹中。我们将与tiny-slider小部件相关的CSS文件`tiny-slider.css`和`styles.css`放在`static/css`文件夹中。
- en: 'The carousel cog that we will build will expose the following input parameters
    provided by the tiny-slider widget:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的轮播图齿轮将公开由tiny-slider小部件提供的以下输入参数：
- en: '[PRE66]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `container` parameter represents the slider container element or selector:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`container`参数表示滑块容器元素或选择器：'
- en: '[PRE67]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `items` parameter represents the number of slides being displayed:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`items`参数表示正在显示的幻灯片数量：'
- en: '[PRE68]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `slideBy` parameter represents the number of slides going on one "click":'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`slideBy`参数表示一次“点击”要进行的幻灯片数量：'
- en: '[PRE69]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `autoplay` parameter toggles the automatic change of slides:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoplay`参数用于切换幻灯片的自动更改：'
- en: '[PRE70]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `autoplayText` parameter controls the text or markup that appears in the
    autoplay start/stop button.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoplayText`参数控制自动播放开始/停止按钮中显示的文本或标记。'
- en: '[PRE71]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `controls` parameter is used to toggle the display and functionalities of
    controls (previous/next buttons).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`controls`参数用于切换控件（上一个/下一个按钮）的显示和功能。'
- en: 'The image carousel will display a set of featured products available on IGWEB.
    We''ve declared the cog''s mounting point in the `shared/templates/index_content.tmpl`
    source file:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图像轮播图将显示IGWEB上可用的一组特色产品。我们在`shared/templates/index_content.tmpl`源文件中声明了齿轮的挂载点：
- en: '[PRE72]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We've declared the `div` container that will serve as the carousel cog's mount
    point. We've declared the attribute, `"data-component"`, and assigned it a value
    of `"cog"`. We've also declared an `id` attribute of `"carousel"`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了作为轮播图齿轮挂载点的`div`容器。我们声明了属性`"data-component"`，并将其赋值为`"cog"`。我们还声明了一个`id`属性为`"carousel"`。
- en: 'The carousel cog is implemented in the `carousel.go` source file found in the
    `shared/cogs/carousel` folder. Here''s the package declaration and import groupings:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 轮播图齿轮实现在`shared/cogs/carousel`文件夹中的`carousel.go`源文件中。以下是包声明和导入分组：
- en: '[PRE73]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The tiny-slider widget is instantiated with an input parameters JavaScript
    object. We''ll be using the `CarouselParams struct` to model the input parameters
    object:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: tiny-slider小部件使用输入参数JavaScript对象进行实例化。我们将使用`CarouselParams struct`来建模输入参数对象：
- en: '[PRE74]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: After embedding the pointer to `js.Object`, each field that we have defined
    in the `struct` corresponds to its equivalent JavaScript parameter object property.
    For example, the `Container` field maps to the `container` property of the input
    parameters object.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入指向`js.Object`的指针之后，我们在`struct`中定义的每个字段都对应于其等效的JavaScript参数对象属性。例如，`Container`字段映射到输入参数对象的`container`属性。
- en: 'Here''s the struct that defines the `carousel` cog:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是定义`carousel`齿轮的`struct`：
- en: '[PRE75]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As usual we embed the `cog.UXCog` type to borrow functionality from the `UXCog`.
    The `carousel` field will be used to refer to the tiny-slider widget, which is
    a JavaScript object.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们嵌入了`cog.UXCog`类型，以借用`UXCog`的功能。`carousel`字段将用于引用JavaScript对象的tiny-slider小部件。
- en: 'By now, you should be able to guess what the carousel cog''s constructor function
    looks like:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该能够猜到轮播图齿轮的构造函数是什么样子的：
- en: '[PRE76]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Besides creating a new reference to a `Carousel` instance, the constructor function
    sets the cog's `cogType`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建对`Carousel`实例的新引用之外，构造函数还设置了齿轮的`cogType`。
- en: 'Now it''s time to examine the lion''s share of the carousel cog''s implementation,
    which is found in the cog''s `Start` method:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候检查轮播图齿轮实现的大部分内容了，这些内容可以在齿轮的`Start`方法中找到：
- en: '[PRE77]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We start out by checking if the user of the `cog` has set the `contentItems`
    and `carouselContentID` props. The `contentItems` prop is a string slice of server
    relative image paths for the images that should appear in the carousel. The `carouselContentID`
    prop is the value of the `id` attribute of the `div` container that holds the
    carousel's content.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查`cog`的用户是否设置了`contentItems`和`carouselContentID`props。`contentItems`prop是应该出现在轮播图中的图像的服务器相对路径的字符串切片。`carouselContentID`prop是包含轮播图内容的`div`容器的`id`属性的值。
- en: 'If either of these props haven''t been set, we return an `error` indicating
    that both of these props must be set. If the two props have been set, we proceed
    to render the cog:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些props中的任何一个都没有设置，我们将返回一个指示这两个props都必须设置的`error`。如果这两个props已经设置，我们将继续渲染齿轮：
- en: '[PRE78]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We render the `cog` at this juncture, since there is HTML markup that needs
    to exist on the web page in order for the `cog` to function properly. Notably,
    the `div` container that holds the carousel''s content, whose `id` we supply using
    the required `carouselContentID` prop. If there was an `error` rendering the `cog`,
    we return the `error` to indicate that the `cog` cannot be started. If there was
    no `error` encountered while rendering the `cog`, we proceed to instantiate the
    input parameters object:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一时刻我们渲染`cog`，因为网页上需要存在HTML标记才能使`cog`正常工作。值得注意的是，包含轮播内容的`div`容器，我们使用必需的`carouselContentID`属性提供其`id`。如果渲染`cog`时出现错误，我们返回错误以表示无法启动`cog`。如果在渲染`cog`时没有遇到错误，我们继续实例化输入参数对象：
- en: '[PRE79]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This `struct` represents the input parameters that we will be feeding to the
    tiny-slider object upon its instantiation.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`struct`代表了我们将在实例化时提供给tiny-slider对象的输入参数。
- en: 'The next section of code is important, since this is where we define the default
    parameters:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码部分很重要，因为这是我们定义默认参数的地方：
- en: '[PRE80]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: When a cog maintainer looks at this block of code, they can readily ascertain
    what the default behavior of the cog is. From looking at the default parameters,
    one can tell that the slider will show only one item at a time. The slider is
    set to slide by page mode and the slider will automatically start the slideshow.
    We've provided a string slice for the `AutoplayText` property, with text symbols
    for the play and stop buttons using the `PLAYTEXT` and `STOPTEXT` constants respectively.
    We have set the `Controls` property to `false`, so that the Next and Previous
    buttons will not appear on the image carousel by default.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当齿轮维护者查看这一段代码时，他们可以很容易地确定齿轮的默认行为。通过查看默认参数，可以知道滑块一次只会显示一个项目。滑块设置为按页模式滑动，并且滑块将自动开始幻灯片放映。我们为`AutoplayText`属性提供了一个字符串切片，使用`PLAYTEXT`和`STOPTEXT`常量分别表示播放和停止按钮的文本符号。我们将`Controls`属性设置为`false`，这样默认情况下图像轮播中将不会出现上一个和下一个按钮。
- en: 'We proceed to iterate over all the properties that the user of the `cog` has
    provided, accessing each prop, consisting of a `propName` (`string`) and a `propValue`
    (`interface{}`):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续迭代`cog`的用户提供的所有属性，访问每个属性，包括`propName`（`string`）和`propValue`（`interface{}`）：
- en: '[PRE81]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We declare a `switch` block on the `propName`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`propName`上声明了一个`switch`块：
- en: '[PRE82]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Using the `switch` block makes it easy to see the names of all the valid props
    in each `case` statement that is defined. If a prop name is not known, it falls
    into the `default` case, where we print a warning message in the web console.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`switch`块可以轻松看到每个`case`语句中所有有效属性的名称。如果属性名称未知，则会进入`default`情况，在那里我们会在Web控制台中打印警告消息。
- en: The first `case` handles the required `"carouselContentID"` prop. It is used
    to specify the `div` container that will contain the content items of the carousel.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`case`处理了必需的`"carouselContentID"`属性。它用于指定将包含轮播内容项目的`div`容器。
- en: The second `case` handles the required `"contentItems"` prop. This prop is a
    `string` slice, and it's meant to be used in the cog's template, so there's no
    action that we have to perform for it.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`case`处理了必需的`"contentItems"`属性。这个属性是一个`string`切片，用于在cog的模板中使用，因此我们不需要执行任何操作。
- en: The third `case` handles the `"items"` prop. This is the prop that handles the
    tns-slider object's `items` parameter, which shows the amount of slides to display
    at a given time. If the prop value is not `nil`, we assign the `int` value of
    the prop value to the `params.Items` property.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个`case`处理了`"items"`属性。这是处理tns-slider对象的`items`参数的属性，它显示在同一时间显示的幻灯片数量。如果属性值不是`nil`，我们将属性值的`int`值分配给`params.Items`属性。
- en: The fourth `case` handles the `slideBy` prop. If the prop value is not `nil`,
    we assign the prop value (type asserted as a `string`) to the `SlideBy` property
    of the `params` object.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个`case`处理了`slideBy`属性。如果属性值不是`nil`，我们将属性值（断言为`string`类型）分配给`params`对象的`SlideBy`属性。
- en: The fifth `case` handles the `"autoplay"` prop. If the prop value is not `nil`,
    we assign the prop value (type asserted as a `bool`) to the `Autoplay` property
    of the `params` object.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个`case`处理了`"autoplay"`属性。如果属性值不是`nil`，我们将属性值（断言为`bool`类型）分配给`params`对象的`Autoplay`属性。
- en: The sixth `case` handles the `"autoplayText"` prop. If the prop value is not
    `nil`, we assign the prop value (type asserted as a `[]string`) to the `AutoplayText`
    property of the `params` object.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 第六个`case`处理了`"autoplayText"`属性。如果属性值不是`nil`，我们将属性值（断言为`[]string`类型）分配给`params`对象的`AutoplayText`属性。
- en: The seventh `case` handles the `"controls"` prop. If the prop value is not `nil`
    we assign the property value (type asserted as a `bool`) to the `Controls` property
    of the `params` object.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 第七个`case`处理了`"controls"`属性。如果属性值不是`nil`，我们将属性值（断言为`bool`类型）分配给`params`对象的`Controls`属性。
- en: If the property name does not fall under any of the seven previous cases, it
    will be handled by the `default case`. Recall, that if we were to reach this `case`,
    it indicates that the user of the `cog` has supplied a prop name that is unknown.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性名称不属于前面七个情况之一，它将由`default case`处理。请记住，如果我们到达这个`case`，这表示`cog`的用户提供了一个未知的属性名称。
- en: 'We can now instantiate the tiny-slider widget and assign it to the cog''s `carousel` property:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实例化tiny-slider小部件并将其分配给齿轮的`carousel`属性：
- en: '[PRE83]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'A value of `nil` is returned by the `Start` method, to indicate that there
    were no errors encountered while starting up the `cog`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`方法返回`nil`值，表示启动`cog`时没有遇到错误：'
- en: '[PRE84]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `shared/cogs/carousel/templates/carousel.tmpl` source file defines the
    template for the carousel `cog`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared/cogs/carousel/templates/carousel.tmpl`源文件定义了carousel `cog`的模板：'
- en: '[PRE85]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We declare a `div` container to house the carousel's images. Each item in the
    `contentItems` `string` slice is a server relative path to an image. We use the
    `range` template action to iterate through the `contentItems` property (a `string`
    slice) to print out the address of each image, which resides inside its own `div`
    container. Notice that we provide the dot (`.`) template action as the value for
    the `img` element's `src` attribute. The dot template action represents the current
    value while iterating through the `contentItems` slice.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个`div`容器来存放轮播图像。`contentItems`中的每个项目都是到图像的服务器相对路径。我们使用`range`模板操作来迭代`contentItems`属性（一个`string`切片），以打印出每个图像的地址，这些地址位于自己的`div`容器内。请注意，我们将点（`.`）模板操作作为`img`元素的`src`属性的值。点模板操作表示在迭代`contentItems`切片时的当前值。
- en: 'Now that we have implemented the carousel `cog` and created its template, it''s
    time to instantiate and start the `cog` on the homepage. We place the code to
    add the carousel `cog` at the beginning of the `InitializeIndexPage` function
    inside the `client/handlers/index.go` source file:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了轮播`cog`并创建了其模板，是时候在主页上实例化和启动`cog`了。我们将添加轮播`cog`的代码到`client/handlers/index.go`源文件的`InitializeIndexPage`函数的开头。
- en: '[PRE86]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We start out by creating a new carousel `cog`, `c`, by calling the constructor
    function `NewCarousel`. We call the `CogInit` method to associate the application's
    template set to the `cog`. We call the `SetID` method to associate the `cog` to
    its mount point, the `div` container where the `cog` will render its output to.
    We create a `string` slice using a `string` slice literal that consists of the
    paths to the image files. We make calls to the `SetProp` method to set the required
    `contentItems` and the required `carouselContent` props. We don't set any other
    prop, because we're satisfied with the carousel cog's default behavior. We start
    up the `cog` and check if we encountered any errors while doing so. If there were
    any errors encountered, we print the error message in the web console.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过调用构造函数`NewCarousel`创建一个新的轮播`cog`，`c`。我们调用`CogInit`方法将应用程序的模板集与`cog`关联起来。我们调用`SetID`方法将`cog`与其挂载点关联起来，即`div`容器，`cog`将在其中呈现其输出。我们使用`string`切片文字将路径设置为图像文件的路径。我们调用`SetProp`方法设置所需的`contentItems`和所需的`carouselContent`属性。我们不设置任何其他属性，因为我们对轮播`cog`的默认行为感到满意。我们启动`cog`并检查是否在此过程中遇到任何错误。如果遇到任何错误，我们将在Web控制台中打印错误消息。
- en: '*Figure 9.12* is a screenshot of the rendered carousel cog:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.12*是渲染的轮播`cog`的屏幕截图：'
- en: '![](img/4be2b386-51b2-4bd6-899d-d06b545241a2.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4be2b386-51b2-4bd6-899d-d06b545241a2.png)'
- en: 'Figure 9.12: The carousel cog in action'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：轮播`cog`的运行情况
- en: Now that we've wrapped up the carousel cog, we're going to create a notify cog
    in the next section that displays an animated notification message on the web
    page.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了轮播`cog`，接下来我们将在下一节中创建一个通知`cog`，用于在网页上显示动画通知消息。
- en: The notify cog
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知`cog`
- en: All `cog` implementations that we've considered, thus far, have rendered output
    to the web page. Let's consider the implementation of a `cog` that doesn't render
    any output to the web page. The notify `cog` that we are going to implement, will
    utilize the Alertify JavaScript library to display animated notification messages
    on the web page.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们考虑的所有`cog`实现都已将输出呈现到网页上。让我们考虑实现一个不将任何输出呈现到网页上的`cog`。我们将要实现的通知`cog`将利用Alertify
    JavaScript库在网页上显示动画通知消息。
- en: '*Figure 9.13* is an illustration depicting a notification message that appears
    on the bottom-right corner of the web page, when the user adds an item to the
    shopping cart:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.13*是一个插图，描述了当用户将商品添加到购物车时，出现在网页右下角的通知消息：'
- en: '![](img/132cedbc-64e4-4837-8316-8be30cb47e23.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](img/132cedbc-64e4-4837-8316-8be30cb47e23.png)'
- en: 'Figure 9.13: An illustration depicting a notification'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：插图描述了一个通知
- en: Since the `cog` will solely rely on the JavaScript library for its rendering
    needs, we won't have to implement a template for the `cog`, and we don't have
    to declare a mount point for the cog either.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`cog`将完全依赖JavaScript库进行渲染，因此我们不必为`cog`实现模板，也不必为`cog`声明挂载点。
- en: We will be leveraging the functionality from the Alertify JavaScript library
    to display notifications. Here's the URL to the Alertify project: [https://github.com/MohammadYounes/AlertifyJS](https://github.com/MohammadYounes/AlertifyJS).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用Alertify JavaScript库的功能来显示通知。以下是Alertify项目的URL：[https://github.com/MohammadYounes/AlertifyJS](https://github.com/MohammadYounes/AlertifyJS)。
- en: Peek inside the `shared/cogs/notify` folder, and notice that no templates folder
    exists. We have placed the static assets for Alertify's CSS, and JavaScript source
    files, in the `shared/cogs/notify/static/css` and `shared/cogs/notify/static/js` folders
    respectively.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`shared/cogs/notify`文件夹，注意没有模板文件夹存在。我们已将Alertify的CSS和JavaScript源文件的静态资产放在`shared/cogs/notify/static/css`和`shared/cogs/notify/static/js`文件夹中。
- en: 'The notify `cog` is implemented in the `notify.go` source file found in the
    `shared/cogs/notify` folder. Since it makes sense for the client-side web application
    to have only one notification system that which is provided by the notify `cog`,
    only once instance of the `cog` should ever be started. In order to keep track
    and ensure that only one notify `cog` instance can be started, we will declare
    the `alreadyStarted` Boolean variable:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 通知`cog`实现在`shared/cogs/notify`文件夹中的`notify.go`源文件中。由于对于客户端Web应用程序来说只有一个通知系统是有意义的，即由通知`cog`提供的通知系统，因此只能启动一个`cog`实例。为了跟踪并确保只能启动一个通知`cog`实例，我们将声明`alreadyStarted`布尔变量：
- en: '[PRE87]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `Notify` struct defines the fields of the notify `cog`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notify`结构定义了通知`cog`的字段：'
- en: '[PRE88]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We type embed the `cog.UXCog` in order to bring over the functionality needed
    to implement the `Cog` interface. The `alertify` field is used to refer to the
    `alertify` JavaScript object.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里输入`cog.UXCog`以便带入实现`Cog`接口所需的功能。`alertify`字段用于引用`alertify` JavaScript对象。
- en: The notify `cog` that we are building is event-driven. For example, a success
    notification will be displayed when a custom success notification event is fired
    from any page on the client-side application. We have defined two fields, `successNotificationEventListener`
    and `errorNotificationEventListener`, which are both functions that take a JavaScript
    object pointer as an input variable. We have defined these fields, so that we
    can keep track of the custom event listener functions that we set up to listen
    for success and error notifications. When it comes time to remove the event listeners,
    it becomes easy to access them because they are properties of the notify `cog`
    instance.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的通知`cog`是事件驱动的。例如，当从客户端应用程序的任何页面触发自定义成功通知事件时，将显示成功通知。我们定义了两个字段，`successNotificationEventListener`和`errorNotificationEventListener`，它们都是函数，以JavaScript对象指针作为输入变量。我们定义了这些字段，以便我们可以跟踪设置用于监听成功和错误通知的自定义事件监听器函数。当需要移除事件监听器时，因为它们是通知`cog`实例的属性，所以很容易访问它们。
- en: 'The `NewNotify` function serves as a constructor function:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewNotify`函数充当构造函数：'
- en: '[PRE89]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Notice that we have registered a clean-up function (shown in bold), which will
    be called prior to the `cog` being destroyed.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已注册了一个清理函数（以粗体显示），该函数将在销毁`cog`之前调用。
- en: 'Let''s examine the cog''s `Start` method:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`Start`方法：
- en: '[PRE90]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We first check to see if a notify `cog` instance has already been started by
    checking the value of the `alreadyStarted` Boolean variable. If the value of `alreadyStarted`
    is `true`, it indicates that a previous notify `cog` instance has already been
    started, so we return an `error` indicating that the notify `cog` could not be
    started.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查`alreadyStarted`布尔变量的值，以查看是否已经启动了通知`cog`实例。如果`alreadyStarted`的值为`true`，则表示先前已经启动了通知`cog`实例，因此我们返回一个指示无法启动通知`cog`的`error`。
- en: 'If the `cog` has not been started yet, we proceed to instantiate the Alertify
    JavaScript object:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cog`尚未启动，我们继续实例化Alertify JavaScript对象：
- en: '[PRE91]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We make a call to the cog''s `StartListening` method to set up the event listeners
    that listen for custom success and error notification message events:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`StartListening`方法来设置监听自定义成功和错误通知消息事件的事件监听器：
- en: '[PRE92]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here''s the cog''s `StartListening` method:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`StartListening`方法：
- en: '[PRE93]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: If we have reached this method, it indicates that the `cog` was started successfully,
    so we set the `alreadyStarted` Boolean variable to `true`. We set up an event
    listener that will listen for the `displaySuccessNotification` custom event. We
    keep track of the event listener function that we are creating by assigning it
    to the `successNotificationEventListener` property of the `cog` instance. We declare
    and instantiate the `message` variable and set it equal to the the `detail` property
    of the `event` object, which will contain the `string` `message` that should be
    displayed to the user on the web page. We then call the cog's `notifySuccess`
    method to display the success notification message on the web page.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经到达这个方法，这表明`cog`已经成功启动，所以我们将`alreadyStarted`布尔变量设置为`true`。我们设置一个事件监听器，用于监听`displaySuccessNotification`自定义事件。我们通过将其赋值给`cog`实例的`successNotificationEventListener`属性来跟踪我们正在创建的事件监听器函数。我们声明并实例化`message`变量，并将其设置为`event`对象的`detail`属性，该属性将包含应在网页上显示给用户的`string`
    `message`。然后我们调用`cog`的`notifySuccess`方法来在网页上显示成功通知消息。
- en: We follow a similar procedure to set up the event listener for the `displayErrorNotification`.
    We assign the event listener function to the cog's `errorNotificationEventListener`
    property. We extract the `detail` property from the `event` object and assign
    it to the `message` variable. We call the cog's `notifyError` method to display
    the error notification message on the web page.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循类似的程序来设置`displayErrorNotification`的事件监听器。我们将事件监听器函数分配给`cog`的`errorNotificationEventListener`属性。我们从`event`对象中提取`detail`属性，并将其分配给`message`变量。我们调用`cog`的`notifyError`方法来在网页上显示错误通知消息。
- en: 'The `notifySuccess` method is responsible for displaying a success notification
    message on the web page:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`notifySuccess`方法负责在网页上显示成功通知消息：'
- en: '[PRE94]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We call the alertify object's `success` method to display the success notification
    message.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用alertify对象的`success`方法来显示成功通知消息。
- en: 'The `notifyError` method is responsible for displaying an error notification
    message on the web page:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`notifyError`方法负责在网页上显示错误通知消息：'
- en: '[PRE95]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: We call the alertify object's `error` method to display the error notification
    message.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用alertify对象的`error`方法来显示错误通知消息。
- en: 'The cog''s `CleanUp` method simply makes a call to the cog''s `StopListening`
    method:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`CleanUp`方法只是调用`StopListening`方法：'
- en: '[PRE96]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `StopListening` method is used to remove the event listeners prior to the
    `cog` being destroyed:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`StopListening`方法用于在销毁`cog`之前移除事件监听器：'
- en: '[PRE97]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We call the DOM object's `RemoveEventListener` method to remove the event listener
    functions that handle the `displaySuccessNotification` and `displayErrorNotification`
    custom events.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用DOM对象的`RemoveEventListener`方法来移除处理`displaySuccessNotification`和`displayErrorNotification`自定义事件的事件监听函数。
- en: 'The `notify` package''s exported `Success` function is used to broadcast a
    custom success event notification message:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`notify`包的导出`Success`函数用于广播自定义成功事件通知消息：'
- en: '[PRE98]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Inside the function, we create a new JavaScript object called `eventDetail`.
    We assign the `string` `message` that should be displayed on the web page to the
    `detail` property of the `eventDetail` object. We then create a new custom `event`
    object called `customEvent`. We pass in the name of the custom event, `displaySuccessNotification`,
    along with the `eventDetail` object as input arguments to the `CustomEvent` type's
    constructor function. Finally, to dispatch the event, we call the `dispatchEvent`
    method on the `window` object and supply the `customEvent`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们创建了一个名为`eventDetail`的新JavaScript对象。我们将应该在网页上显示的`string` `message`分配给`eventDetail`对象的`detail`属性。然后，我们创建了一个名为`customEvent`的新自定义`event`对象。我们将自定义事件的名称`displaySuccessNotification`以及`eventDetail`对象作为输入参数传递给`CustomEvent`类型的构造函数。最后，为了分发事件，我们在`window`对象上调用`dispatchEvent`方法，并提供`customEvent`。
- en: 'The notify package''s exported `Error` function is used to broadcast a custom
    error event notification message:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: notify包的导出`Error`函数用于广播自定义错误事件通知消息：
- en: '[PRE99]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The implementation of this function is nearly identical to the `Success` function.
    The only difference is that we dispatch a `displayErrorNotification` custom event.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的实现几乎与`Success`函数完全相同。唯一的区别是我们分发了一个`displayErrorNotification`自定义事件。
- en: 'We instantiate and start the notify `cog` (shown in bold) inside the `InitializePageLayoutControls`
    function found in the `client/handlers/initpagelayoutcontrols.go` source file:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`client/handlers/initpagelayoutcontrols.go`源文件中的`InitializePageLayoutControls`函数中实例化和启动通知`cog`（以粗体显示）：
- en: '[PRE100]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The notification messages (success or error) for adding an item to the shopping
    cart are found within the `addToCart` function inside the `client/handlers/shoppingcart.go`
    source file:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 将添加商品到购物车的通知消息（成功或错误）放在`client/handlers/shoppingcart.go`源文件中的`addToCart`函数中：
- en: '[PRE101]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `notify.Error` function is called (shown in bold) if the item could not
    be added to the shopping cart. The `notify.Success` function is called (shown
    in bold) if the item was successfully added to the shopping cart.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果商品无法添加到购物车，则调用`notify.Error`函数（以粗体显示）。如果商品成功添加到购物车，则调用`notify.Success`函数（以粗体显示）。
- en: 'The notification messages for removing an item from the shopping cart are found
    in the `removeFromCart` function in the `client/handlers/shoppingcart.go` source
    file:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 从`client/handlers/shoppingcart.go`源文件中的`removeFromCart`函数中找到从购物车中移除商品的通知消息：
- en: '[PRE102]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `notify.Error` function is called (shown in bold) if the item could not
    be removed from the shopping cart. The `notify.Success` function is called (shown
    in bold) if the item was successfully removed from the shopping cart.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果商品无法从购物车中移除，则调用`notify.Error`函数（以粗体显示）。如果商品成功从购物车中移除，则调用`notify.Success`函数（以粗体显示）。
- en: '*Figure 9.14* is a cropped screenshot of the notification cog in action, when
    we add a product to the shopping cart:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.14*是通知cog在操作时的裁剪截图，当我们向购物车中添加产品时：'
- en: '![](img/6776f61a-1404-4129-8eb4-8815fef218c1.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6776f61a-1404-4129-8eb4-8815fef218c1.png)'
- en: 'Figure 9.14: The notify cog in action'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：通知cog在操作中
- en: Summary
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were introduced to cogs—reusable components that could be
    implemented either exclusively in Go (pure cogs) or with Go and JavaScript (hybrid
    cogs). Cogs come with many benefits. We can use them in a plug and play manner,
    create multiple instances of them, readily maintain them due to their self-contained
    nature, and easily reuse them since they can exist as their own Go package along
    with their required static assets (template files, CSS, and JavaScript source
    files).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了cogs——可重复使用的组件，可以纯粹使用Go（纯cogs）实现，也可以使用Go和JavaScript（混合cogs）实现。Cogs带来了许多好处。我们可以以即插即用的方式使用它们，创建它们的多个实例，由于它们的自包含性质，可以轻松地维护它们，并且可以轻松地重用它们，因为它们可以作为自己的Go包以及它们所需的静态资产（模板文件、CSS和JavaScript源文件）存在。
- en: We introduced you to the UX toolkit, which provides us with the technology to
    implement cogs. We studied the anatomy of a cog and explored what a cog's file
    structure may look like with regards to the placement of Go, CSS, JavaScript,
    and template files. We considered how cogs utilize a virtual DOM to render their
    contents instead of performing an expensive replace inner HTML operation. We presented
    the various stages of the cog's life cycle. We showed you how to implement various
    cogs that we sprinkled all across IGWEB, which included both pure cogs and hybrid
    cogs.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向您介绍了UX工具包，它为我们提供了实现cogs的技术。我们研究了cog的解剖结构，并探讨了关于Go、CSS、JavaScript和模板文件放置的cog文件结构可能是什么样子。我们考虑了cogs如何利用虚拟DOM来呈现其内容，而不是执行昂贵的替换内部HTML操作。我们介绍了cog生命周期的各个阶段。我们向您展示了如何在IGWEB中实现各种cogs，其中包括纯cogs和混合cogs。
- en: In [Chapter 10](23f09ecc-d992-4efb-8f48-b83f65fac7a1.xhtml), *Testing an Isomorphic
    Go Web Application*, we will learn how to perform automated, end-to-end testing
    of IGWEB. This will consist of implementing tests to exercise functionality on
    both the server-side and the client-side.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](23f09ecc-d992-4efb-8f48-b83f65fac7a1.xhtml)中，*测试同构Go Web应用程序*，我们将学习如何对IGWEB进行自动化的端到端测试。这将包括实现测试来在服务器端和客户端上执行功能。
