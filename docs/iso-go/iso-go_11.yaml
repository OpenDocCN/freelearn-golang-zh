- en: Deploying an Isomorphic Go Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署同构Go Web应用程序
- en: With the automated end-to-end tests that we implemented in the last chapter,
    the IGWEB demo website now meets a baseline set of expected functionality. The
    time has come to free our Isomorphic Go web application out into the web. It's
    time to focus on deploying IGWEB to production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们在上一章中实施的自动化端到端测试，IGWEB演示网站现在满足了一组预期功能的基线。现在是时候将我们的同构Go Web应用程序释放到网络中了。是时候专注于将IGWEB部署到生产环境了。
- en: Our exploration of Isomorphic Go production deployments will include deploying
    IGWEB as a static binary executable, along with static assets, to a standalone
    server (real or virtual) and deploying IGWEB as a multi-docker container application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对同构Go生产部署的探索将包括将IGWEB作为静态二进制可执行文件以及静态资产部署到独立服务器（真实或虚拟）上，以及将IGWEB作为多Docker容器应用程序部署。
- en: Deploying web applications is a vast subject, an ocean, worthy of the many books
    that are dedicated to covering this topic alone. Real-world web application deployments
    may include continuous integration, configuration management, automated testing,
    deployment automation tools, and agile team management. These deployments may
    also include multiple team members, fulfilling various roles in the deployment
    process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 部署Web应用程序是一个广阔的主题，一个值得专门讨论的海洋，有许多专门讨论这个主题的书籍。现实世界的Web应用程序部署可能包括持续集成、配置管理、自动化测试、部署自动化工具和敏捷团队管理。这些部署可能还包括多个团队成员，在部署过程中扮演各种角色。
- en: The focus in this chapter will solely be on deploying an Isomorphic Go web application
    by a single individual. For the purpose of illustration, the deployment procedure
    will be performed manually.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将仅仅是通过单个个体部署同构Go Web应用程序。为了说明，部署过程将手动执行。
- en: There are certain considerations that need to be made to successfully prepare
    an Isomorphic Go web application for production use, such as minifying the GopherJS
    produced JavaScript source file and ensuring that static assets are transferred
    to the web client with GZIP compression enabled. By keeping the emphasis of the
    material presented in this chapter on Isomorphic Go, it is left to the reader
    to adapt the concepts and techniques presented in this chapter for their own particular
    deployment needs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑一些特定的因素，以成功地准备一个用于生产的同构Go web应用程序，例如，对由GopherJS生成的JavaScript源文件进行缩小，并确保静态资产以启用GZIP压缩的方式传输到Web客户端。通过将本章中呈现的材料重点放在同构Go上，读者可以根据自己特定的部署需求来调整本章中呈现的概念和技术。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How IGWEB operates in production mode
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IGWEB在生产模式下的运行方式
- en: Deploying an Isomorphic Go web application to a standalone server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将同构Go Web应用程序部署到独立服务器。
- en: Deploying an Isomorphic Go web application using Docker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker部署同构Go Web应用程序
- en: How IGWEB operates in production mode
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IGWEB在生产模式下的运行方式
- en: 'Before proceeding to production deployment, we need to understand how the server-side
    web application, `igweb`, operates when it''s placed into production mode. Production
    mode can be turned on by setting the `IGWEB_MODE` environment variable with the
    value `"production"` before starting the `igweb` server-side application, like
    so:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行生产部署之前，我们需要了解当将服务器端Web应用程序`igweb`放入生产模式时，它是如何运行的。可以通过在启动`igweb`服务器端应用程序之前设置`IGWEB_MODE`环境变量的值为`"production"`来打开生产模式。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are three important behaviors that will take place when IGWEB runs in
    production mode:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: IGWEB在生产模式下运行时将发生三种重要的行为：
- en: The JavaScript external `<script>` tag that includes the client-side application,
    inside the header partial template, will request the minified JavaScript source
    file located at `$IGWEB_APP_ROOT/static/js/client.min.js`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头部部分模板中包含客户端应用程序的JavaScript外部`<script>`标签将请求位于`$IGWEB_APP_ROOT/static/js/client.min.js`的缩小JavaScript源文件。
- en: Static assets for cogs (`cogimport.css` and `cogimport.js`) will not be generated
    automatically when the web server instance starts. Instead, the minified source
    files containing the bundled static assets for the CSS and JavaScript will be
    located at `$IGWEB_APP_ROOT/static/css/cogimports.min.css` and `$IGWEB_APP_ROOT/static/js/cogimports.min.js`,
    respectively.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Web服务器实例启动时，cogs（`cogimport.css`和`cogimport.js`）的静态资产将不会自动生成。相反，包含捆绑静态资产的缩小源文件将分别位于`$IGWEB_APP_ROOT/static/css/cogimports.min.css`和`$IGWEB_APP_ROOT/static/js/cogimports.min.js`。
- en: Rather than relying on the templates found in the `$IGWEB_APP_ROOT/shared/templates`
    folder, templates will be read from a single, gob encoded, template bundle file
    persisted on the disk.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与依赖于`$IGWEB_APP_ROOT/shared/templates`文件夹中的模板不同，模板将从单个、gob编码的模板捆绑文件中读取，该文件将持久保存在磁盘上。
- en: We are going to consider how the server-side web application responds to each
    one of these behaviors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑服务器端Web应用程序如何响应这些行为。
- en: GopherJS-produced JavaScript source file
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由GopherJS生成的JavaScript源文件
- en: 'Inside the `funcs.go` source file where our template functions are defined,
    we introduce a new function called `IsProduction`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`funcs.go`源文件中定义我们的模板函数的地方，我们引入了一个名为`IsProduction`的新函数：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function, meant to be used on the server-side, will return a value of `true` if
    the current operating mode is production, and `false` if it isn't. We can use
    this custom function within a template to determine from where the client-side
    JavaScript application should be obtained.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是用于在服务器端使用的，如果当前操作模式是生产模式，则返回`true`，否则返回`false`。我们可以在模板中使用这个自定义函数来确定客户端JavaScript应用程序应该从哪里获取。
- en: When operating in non-production mode, the `client.js` source file will be obtained
    from the server relative path of `/js/client.js`. In production mode, the minified
    JavaScript source file will be obtained from the server relative path of `/static/js/client.min.js`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在非生产模式下运行时，`client.js`源文件将从服务器相对路径`/js/client.js`获取。在生产模式下，缩小的JavaScript源文件将从服务器相对路径`/static/js/client.min.js`获取。
- en: 'Inside the header partial template, we call the `productionmode` custom function
    to determine from which path to serve the client-side JavaScript source file,
    like so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部部分模板中，我们调用`productionmode`自定义函数来确定从哪个路径提供客户端JavaScript源文件，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You might be wondering why we include different JavaScript source files (`client.js`
    versus `client.min.js`) between non-production mode and production-mode. Recall
    that in a development environment with `kick` running, the `client.js` and `client.js.map`
    source files get produced in the `$IGWEB_APP_ROOT/client` folder. Inside `igweb.go`,
    we registered handlers functions for routes that will map the `/js/client.js`
    path and the `/js/client.js.map` path to the respective source files in the `$IGWEB_APP_ROOT/client`
    folder:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么在非生产模式和生产模式之间包含不同的JavaScript源文件（`client.js`与`client.min.js`）。回想一下，在运行`kick`的开发环境中，`client.js`和`client.js.map`源文件会在`$IGWEB_APP_ROOT/client`文件夹中生成。在`igweb.go`中，我们注册了路由处理函数，将`/js/client.js`路径和`/js/client.js.map`路径映射到`$IGWEB_APP_ROOT/client`文件夹中的相应源文件：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This provided us with the convenience that we could have `kick` automatically
    transpile the JavaScript code for us, the instant that we made a change to the
    application code. In non-production mode, we prefer not to minify the JavaScript
    source file so that we can get more detailed debug information through the web
    console, such as the panic stack trace (covered in [Appendix](416459e8-d23f-421d-a3fb-5c1c8da3afd8.xhtml),
    *Debugging Isomorphic Go*).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了便利，我们可以让`kick`在我们对应用程序代码进行更改时自动转换JavaScript代码。在非生产模式下，我们更喜欢不缩小JavaScript源文件，以便通过Web控制台获得更详细的调试信息，例如恐慌堆栈跟踪（在[附录](416459e8-d23f-421d-a3fb-5c1c8da3afd8.xhtml)中介绍，*调试同构Go*）。
- en: In production mode, there is no need to use `kick`. If you inspect the file
    size of the `client.js` source file, you will notice that it's approximately 8.1
    MB big! That sure is some serious sticker shock! In the next section, we'll learn
    how to cut that unwieldy file footprint down to size.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产模式下，无需使用`kick`。如果你检查`client.js`源文件的文件大小，你会注意到它大约有8.1MB！这确实是一个严重的震惊！在下一节中，我们将学习如何将这个笨重的文件大小缩小。
- en: Taming the GopherJS-produced JavaScript file size
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驯服GopherJS生成的JavaScript文件大小
- en: During the production deployment process, we must issue the `gopherjs build`
    command, specifying the option to minify the produced JavaScript source file and
    to save the output of the JavaScript source file to a specified target location.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产部署过程中，我们必须发出`gopherjs build`命令，指定选项来缩小生成的JavaScript源文件，并将JavaScript源文件的输出保存到指定的目标位置。
- en: 'We must minify the produced JavaScript code to reduce its file size. As mentioned
    previously, the un-minified, JavaScript source file is 8.1 MB! We can further
    reduce the size of the source file to 2.9 MB by minifying it, running the `gopherjs
    build` command with the `-m` option and by specifying the `--tags` option with
    the value `clientonly` like so:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须缩小生成的JavaScript代码以减小文件大小。如前所述，未缩小的JavaScript源文件为8.1MB！通过缩小它，使用`gopherjs
    build`命令运行`-m`选项，并指定`--tags`选项值为`clientonly`，我们可以将源文件的大小进一步减小到2.9MB，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `clientonly` tag, tells isokit to avoid transpiling source files that are
    not used by the client-side application. The `-o` option will place the produced
    output JavaScript source file in the specified target location.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`clientonly`标签告诉isokit避免转换客户端应用程序未使用的源文件。`-o`选项将把生成的输出JavaScript源文件放在指定的目标位置。'
- en: Prior to running the `gopherjs build` command, it's always a good idea to execute
    `clear_gopherjs_cache.sh` bash script found in the `$IGWEB_APP_ROOT/scripts` directory.
    It will clear project artifacts that have been cached from previous `gopherjs
    build` runs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`gopherjs build`命令之前，执行`$IGWEB_APP_ROOT/scripts`目录中找到的`clear_gopherjs_cache.sh`
    bash脚本总是一个好主意。它将清除从先前的`gopherjs build`运行中缓存的项目构件。
- en: Serving a JavaScript source file that is nearly 3 MB large is still an untenable
    proposition for production needs. We can further cut down the size of transferring
    the file by enabling GZIP compression. Once the source file is sent using GZIP
    compression, the transfer file size will be approximately 510 KB. We will learn
    how to enable GZIP compression on the web server in the *Enabling GZIP compression* section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个将近3MB大的JavaScript源文件仍然是一个不可行的方案。通过启用GZIP压缩，我们可以进一步减小传输文件的大小。一旦使用GZIP压缩发送源文件，传输文件大小将约为510KB。我们将在*启用GZIP压缩*部分学习如何在Web服务器上启用GZIP压缩。
- en: Generating static assets
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成静态资产
- en: When deploying server-side Go web applications, it is commonplace to not only
    push out the binary executable file for the web server instance but also static
    asset files (CSS, JavaScript, template files, images, fonts, and so on) and template
    files. In traditional Go web applications, we would have to push out the individual
    template files to the production system, since traditional Go web applications
    would be dependent on having each individual file available in order to render
    the given template on the server-side.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署服务器端Go Web应用程序时，通常不仅会推送Web服务器实例的二进制可执行文件，还会推送静态资产文件（CSS、JavaScript、模板文件、图像、字体等）和模板文件。在传统的Go
    Web应用程序中，我们必须将单独的模板文件推送到生产系统，因为传统的Go Web应用程序依赖于每个单独的文件可用以在服务器端呈现给定的模板。
- en: Since we are utilizing the concept of a template set persisted in-memory through
    the running application, there is no need to bring along the individual template
    files to the production environment. This is due to the fact that all we need
    to generate the in-memory template set is a single `gob` encoded template bundle
    file, which is persisted on disk in the `$IGWEB_APP_ROOT/static/templates` folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们利用了在运行应用程序中通过内存持久化的模板集的概念，因此无需将单独的模板文件带到生产环境中。这是因为我们生成内存模板集所需的一切只是一个`gob`编码的模板捆绑文件，它被持久化在`$IGWEB_APP_ROOT/static/templates`文件夹中。
- en: 'By setting the exported `StaticTemplateBundleFilePath` variable in the `isokit` package,
    we instruct isokit to generate the static template bundle file at the file path
    that we provide. Here''s the line in the `initializeTemplateSet` function in the `igweb.go` source
    file where we set the variable:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`isokit`包中设置导出的`StaticTemplateBundleFilePath`变量，我们指示isokit在我们提供的文件路径生成静态模板捆绑文件。以下是在`igweb.go`源文件中的`initializeTemplateSet`函数中设置变量的行：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml), *Cogs – Reusable
    Components*, we learned that isokit bundles all of the JavaScript source files
    from all of the cogs into a single `cogimports.js` source file when the `igweb`
    application is first started. In a similar manner, all of the CSS stylesheets
    from all of the cogs are bundled into a single `cogimports.css` source file. When
    running IGWEB in non-production mode, the static assets are bundled automatically
    by calling the `isokit.BundleStaticAssets` function (shown in bold) in the `initailizeCogs`
    function found in the `igweb.go` source file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml)中，*Cogs-可重用组件*，我们了解到当首次启动`igweb`应用程序时，isokit将所有cogs的JavaScript源文件捆绑到单个`cogimports.js`源文件中。类似地，所有cogs的CSS样式表都捆绑到单个`cogimports.css`源文件中。在非生产模式下运行IGWEB时，通过在`igweb.go`源文件中的`initailizeCogs`函数中调用`isokit.BundleStaticAssets`函数（以粗体显示）自动捆绑静态资产：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The automatic static assets bundling should not be utilized in a production
    environment, because the dynamic functionality that bundles the JavaScript and
    CSS is dependent on the server having an installed Go distribution with a configured
    Go workspace, and access to the source files for the cogs must be present in that
    Go workspace.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不应在生产环境中使用自动静态资产捆绑，因为捆绑JavaScript和CSS的动态功能取决于服务器上安装了配置了Go工作区的Go发行版，并且该Go工作区中必须存在cogs的源文件。
- en: This immediately removes one of the advantages that Go comes with out of the
    box. Since Go produces statically linked binary executable files, we don't need
    to have a Go runtime installed on our production server in order to deploy our
    application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这立即消除了Go默认的优势之一。由于Go生成静态链接的二进制可执行文件，我们不需要在生产服务器上安装Go运行时即可部署我们的应用程序。
- en: 'When we run IGWEB in production mode, we can prevent the automatic static assets
    bundling by introducing the following code in the `initializeTemplateSet` function
    found in the `igweb.go` source file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以生产模式运行IGWEB时，可以通过在`igweb.go`源文件中的`initializeTemplateSet`函数中引入以下代码来阻止自动静态资产捆绑：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We instruct isokit to use a static template bundle file, and we instruct isokit
    not to automatically bundle static assets.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指示isokit使用静态模板捆绑文件，并指示isokit不自动捆绑静态资产。
- en: 'In order to generate the static assets (CSS, JavaScript, and the template bundle)
    that our Isomorphic Go web application requires, we can run `igweb` with the `--generate-static-assets
    flag` on a non-production system:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成我们的同构Go Web应用程序所需的静态资产（CSS、JavaScript和模板捆绑），我们可以在非生产系统上使用`igweb`运行`--generate-static-assets`标志：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This command will produce the necessary static assets, and then it will exit
    the `igweb` program. The implementation for this functionality can be found in
    the `generateStaticAssetsAndExit` function defined in the `igweb.go` source file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将生成必要的静态资产，然后退出`igweb`程序。此功能的实现可以在`igweb.go`源文件中定义的`generateStaticAssetsAndExit`函数中找到：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Three files will be created upon instructing `igweb` to generate the static
    assets:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在指示`igweb`生成静态资产后，将创建三个文件：
- en: '`$IGWEB_APP_ROOT/static/templates/igweb.tmplbundle` (template bundle)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$IGWEB_APP_ROOT/static/templates/igweb.tmplbundle`（模板捆绑）'
- en: '`$IGWEB_APP_ROOT/static/css/cogimports.min.css` (minified CSS bundle)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$IGWEB_APP_ROOT/static/css/cogimports.min.css`（压缩的CSS捆绑包）'
- en: '`$IGWEB_APP_ROOT/static/js/cogimports.min.js` (minified JavaScript bundle)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$IGWEB_APP_ROOT/static/js/cogimports.min.js`（压缩的JavaScript捆绑包）'
- en: Upon performing a production deployment, the entire `$IGWEB_APP_ROOT/static`
    folder can be copied over to the production system, ensuring that the three aforementioned
    static assets will be made available on the production system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行生产部署时，可以将整个`$IGWEB_APP_ROOT/static`文件夹复制到生产系统，确保三个前述的静态资产将在生产系统上提供。
- en: At this point, we have established how IGWEB will operate in production mode.
    Now, it's time to perform the most simplest of deployments—deploying an Isomorphic
    Go web application to a standalone server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经建立了IGWEB在生产模式下的操作方式。现在，是时候执行最简单的部署了-将同构Go Web应用程序部署到独立服务器。
- en: Deploying an Isomorphic Go web application to a standalone server
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将同构Go Web应用程序部署到独立服务器
- en: For demonstrating a standalone Isomorphic Go deployment, we will be using a
    virtual private server (VPS) hosted on Linode ([http://www.linode.com](http://www.linode.com)).
    The procedure presented herein holds good for any other cloud provider, as well
    as the scenario where the standalone server happens to be a real server residing
    in your server room. The standalone deployment procedure that we will outline
    is performed manually to illustrate each step of the process.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示独立的同构Go部署，我们将使用Linode（[http://www.linode.com](http://www.linode.com)）托管的虚拟专用服务器（VPS）。此处提出的程序适用于任何其他云提供商，以及独立服务器恰好是位于服务器室中的真实服务器的情况。我们将概述的独立部署过程是手动执行的，以说明每个步骤。
- en: Provisioning the server
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为服务器提供服务
- en: The server in this demonstration, and the servers mentioned in subsequent demonstrations
    in this chapter will be running Ubuntu Linux version 16.04 LTS on Linode, a provider
    of **virtual private server (VPS)** instances. We will be running Linode's default
    stock image of Ubuntu 16.04 without making any kernel modifications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本演示中的服务器，以及本章后续演示中提到的服务器将在Linode上运行Ubuntu Linux 16.04 LTS版本，Linode是**虚拟专用服务器（VPS）**实例的提供商。我们将运行Linode的默认Ubuntu
    16.04存储映像，而不进行任何内核修改。
- en: When we issue any commands in this chapter prefaced with `sudo`, we assume that
    your user account is part of the sudoers group. If you are using the server's
    root account, you need not preface the command with `sudo`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章中发出任何以`sudo`为前缀的命令时，我们假设您的用户帐户是sudoers组的一部分。如果您使用服务器的root帐户，则无需在命令前加上`sudo`。
- en: 'We will create a less-privileged user called `igweb` by issuing the following
    command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过发出以下命令创建一个名为`igweb`的权限较低的用户：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After running the `adduser` command, you will be prompted to enter additional
    information for the `igweb` user and the password. If you are not prompted to
    enter the password for the user, you may set a password by issuing the following
    command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`adduser`命令后，您将被提示为`igweb`用户和密码输入附加信息。如果您没有提示输入用户密码，您可以通过发出以下命令来设置密码：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `igweb` application depends on two components to function properly. First,
    we need to install the Redis database. Second, we need to install `nginx`. We
    will be using `nginx` as a reverse proxy server, which will allow us to enable
    GZIP compression when serving static assets to the web client. As you will see,
    this makes a huge difference when it comes to the file size of the GopherJS-produced
    JavaScript source file (510 KB versus 3MB). *Figure 11.1* depicts the Linode VPS
    instance with the three key components, `igweb`, `nginx`, and `redis-server`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`igweb`应用程序依赖于两个组件才能正常运行。首先，我们需要安装Redis数据库。其次，我们需要安装`nginx`。我们将使用`nginx`作为反向代理服务器，这将允许我们在为Web客户端提供静态资产时启用GZIP压缩。正如您将看到的，这在GopherJS生成的JavaScript源文件的文件大小方面有很大的区别（510
    KB与3MB）。*图11.1*描述了Linode VPS实例与三个关键组件`igweb`、`nginx`和`redis-server`：'
- en: '![](img/61f49e5a-74f7-42a8-939a-3006cb47bb45.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61f49e5a-74f7-42a8-939a-3006cb47bb45.png)'
- en: 'Figure 11.1: The Linode VPS instance running igweb, nginx, and redis-server'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：运行igweb、nginx和redis-server的Linode VPS实例
- en: Setting up the Redis database instance
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Redis数据库实例
- en: 'You can follow the same procedure that was demonstrated in [Chapter 2](9b9730ea-ae72-4285-be30-58f2f8ab2f1e.xhtml),
    *The Isomorphic Go Toolchain,* to install the Redis database. Before doing so,
    you should issue the following command to install the essential build tools:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照[第2章](9b9730ea-ae72-4285-be30-58f2f8ab2f1e.xhtml)中演示的相同过程来安装Redis数据库。在这之前，您应该发出以下命令来安装必要的构建工具：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once you have installed the Redis database, you should launch the Redis server
    by issuing the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Redis数据库后，您应该通过发出以下命令来启动Redis服务器：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `--daemonize` command-line argument allows us to run the Redis server in
    the background. The server will continue to run even after our session has ended.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`--daemonize`命令行参数允许我们在后台运行Redis服务器。即使我们的会话结束后，服务器也将继续运行。'
- en: You should secure the Redis installation by adding sufficient firewall rules
    to prevent external traffic from accessing port 6379, the default port of the
    Redis server instance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该通过添加足够的防火墙规则来保护Redis安装，以防止外部流量访问端口6379，Redis服务器实例的默认端口。
- en: Setting up the NGINX reverse proxy
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置NGINX反向代理
- en: Although the `igweb` web server instance, a Go application, can single-handedly
    fulfill the major needs to serve IGWEB, it is more advantageous to have the `igweb`,
    web server instance, sit behind a reverse proxy.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`igweb` Web服务器实例，一个Go应用程序，可以独自满足服务IGWEB的主要需求，但将`igweb` Web服务器实例置于反向代理之后更有利。
- en: A reverse proxy server is a type of proxy server that will service a client
    request by dispatching the request to a designated destination server (in this
    case, `igweb`), get the response from the `igweb` server instance, and send the
    response back to the client.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理服务器是一种代理服务器类型，它将通过将请求分派到指定的目标服务器（在本例中为`igweb`）来为客户端请求提供服务，从`igweb`服务器实例获取响应，并将响应发送回客户端。
- en: Reverse proxies come in handy for several reasons. The most important reason
    for the immediate benefit of releasing IGWEB is that we can enable GZIP compression
    on the outbound static assets. In addition to that, reverse proxies also allow
    us to easily add redirect rules to control the flow of traffic as the need arises.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理有几个方面的便利。释放IGWEB的即时好处最重要的原因是我们可以在出站静态资产上启用GZIP压缩。除此之外，反向代理还允许我们在需要时轻松添加重定向规则来控制流量。
- en: 'NGINX is a popular high performance web server. We will be using `nginx` as
    the reverse proxy that sits in front of the `igweb` web server instance. *Figure
    11.2* depicts a typical reverse proxy configuration, where a web client will issue
    a HTTP request over port 80 and `nginx` will service the request by sending the
    HTTP request to the `igweb` server instance over port 8080, retrieving the response
    from the `igweb` server and sending the response back to the web client over port
    80:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX是一种流行的高性能Web服务器。我们将使用`nginx`作为`igweb` Web服务器实例前面的反向代理。*图11.2*描述了一个典型的反向代理配置，其中Web客户端将通过端口80发出HTTP请求，`nginx`将通过端口8080将HTTP请求发送到`igweb`服务器实例，从`igweb`服务器检索响应，并通过端口80将响应发送回Web客户端：
- en: '![](img/4fdfd999-0d8b-41d8-b393-5815a7bda632.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fdfd999-0d8b-41d8-b393-5815a7bda632.png)'
- en: 'Figure 11.2: The reverse proxy configuration'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：反向代理配置
- en: 'Here is a listing of the `nginx` configuration file, `nginx.conf`, that we
    will use to run `nginx` as a reverse proxy:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将用于运行`nginx`作为反向代理的`nginx.conf`配置文件清单：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are two sections of settings that are of particular interest to us, the
    section to enable GZIP compression and the section for proxy settings.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对我们感兴趣的两个设置部分，即启用GZIP压缩的部分和代理设置的部分。
- en: Enabling GZIP compression
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用GZIP压缩
- en: Let's examine the `nginx` configuration settings related to enable GZIP compression.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查与启用GZIP压缩相关的`nginx`配置设置。
- en: We set the `gzip` directive to `on` to enable the gzipping of server responses.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`gzip`指令设置为`on`以启用服务器响应的压缩。
- en: The `gzip_min_length` directive allows us to specify the minimum length of a
    response that will be gzipped.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`gzip_min_length`指令允许我们指定将进行gzip压缩的响应的最小长度。'
- en: The `gzip_buffers` directive sets the number and size of buffers that are used
    to compress the response. We have specified that we will be using 16 buffers with
    a memory page size of 8K.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`gzip_buffers`指令设置用于压缩响应的缓冲区的数量和大小。我们指定将使用16个缓冲区，内存页大小为8K。'
- en: The `gzip_types` directive allows us to specify the MIME types that we should
    enable GZIP compression on in addition to *text/HTML*. We have specified the MIME
    types for plain text files, JavaScript source files, and CSS source files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`gzip_types`指令允许我们指定应在其上启用GZIP压缩的MIME类型，除了*text/HTML*之外。我们已指定纯文本文件、JavaScript源文件和CSS源文件的MIME类型。'
- en: 'The `gzip_vary` directive is used to either enable or disable the *Vary: Accept-Encoding*
    response header. The *Vary: Accept-Encoding* response header instructs the cache
    to store a different version of the web page if there is a variation in the header.
    This setting is particularly important for web browsers that do not support GZIP
    encoding to receive the uncompressed version of the file properly.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`gzip_vary`指令用于启用或禁用*Vary: Accept-Encoding*响应头。*Vary: Accept-Encoding*响应头指示缓存存储网页的不同版本，如果头部有变化，则特别重要。对于不支持GZIP编码的Web浏览器，这个设置特别重要，以便正确接收文件的未压缩版本。'
- en: The `gzip_comp_level` directive specifies the level of GZIP compression that
    will be used. We have specified a value of 9, which is the maximum level of GZIP
    compression.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`gzip_comp_level`指令指定将使用的GZIP压缩级别。我们指定了一个值为9的最大GZIP压缩级别。'
- en: Proxy settings
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理设置
- en: The second section in the `nginx` configuration settings that is important is
    the reverse proxy settings.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`nginx`配置设置中的第二部分是反向代理设置。'
- en: We include the `proxy_pass` directive inside the `location` block with the value
    of the address and port of the web server. This specifies that all requests should
    be sent to the specified proxy server (`igweb`) located at `http://192.168.1.207:8080`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`location`块内包括`proxy_pass`指令，值为web服务器的地址和端口。这指定所有请求应发送到指定的代理服务器（`igweb`），位于`http://192.168.1.207:8080`。
- en: Remember to replace the IP address 192.168.1.207 shown in this example with
    the IP address of the machine that is running your `igweb` instance.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，将此示例中显示的IP地址192.168.1.207替换为运行您的`igweb`实例的机器的IP地址。
- en: The reverse proxy will fetch the response from the `igweb` server instance and
    send it back to the web client.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理将从`igweb`服务器实例获取响应并将其发送回Web客户端。
- en: The `proxy_set_header` directive allows us to redefine (or append) fields to
    the request header that are passed on to the proxy server. We have included the
    *X-Forwaded-For* header so that the proxy server can identify the originating
    IP address of the web client that initiated the request.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy_set_header`指令允许我们重新定义（或追加）传递给代理服务器的请求头字段。我们已经包括了*X-Forwaded-For*头，以便代理服务器可以识别发起请求的Web客户端的原始IP地址。'
- en: To support the proper functioning of websockets (which the live chat feature
    depends on), we include the following proxy settings. First, we specify using
    the `proxy_http_version` directive that the server will be using HTTP version
    1.1\. The `"Upgrade"` and `"Connection"` headers are not passed to a proxied server
    by default. Due to this, we must send these headers to the proxy server using
    the `proxy_set_header` directive.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持websockets的正常运行（这是实时聊天功能所依赖的），我们包括以下代理设置。首先，我们指定使用`proxy_http_version`指令，服务器将使用HTTP版本1.1。默认情况下，`"Upgrade"`和`"Connection"`头不会传递给代理服务器。因此，我们必须使用`proxy_set_header`指令将这些头发送到代理服务器。
- en: 'We can install `nginx` by issuing the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令安装`nginx`：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Upon installing `nginx`, the web server usually starts up by default. However
    if it doesn''t, we can start up `nginx` by issuing the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`nginx`后，Web服务器通常会默认启动。但是如果没有启动，我们可以通过以下命令启动`nginx`：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `nginx.conf` file found in the `$IGWEB_APP_ROOT/deployments-config/standalone-setup`
    folder can be placed in the production server's `/etc/nginx` folder.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`$IGWEB_APP_ROOT/deployments-config/standalone-setup`文件夹中找到的`nginx.conf`文件可以放置在生产服务器的`/etc/nginx`文件夹中。'
- en: '*Figure 11.3* depicts the 502 Bad Gateway error encountered when we attempt
    to access the `igweb.kamesh.com` URL:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.3*描述了当我们尝试访问`igweb.kamesh.com` URL时遇到的502 Bad Gateway错误：'
- en: '![](img/90fe7f2d-4a43-4cd6-afa4-5160595d45f9.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90fe7f2d-4a43-4cd6-afa4-5160595d45f9.png)'
- en: 'Figure 11.3: The 502 Bad Gateway Error'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：502 Bad Gateway错误
- en: We get this server error because we haven't started `igweb` yet. To get `igweb`
    up and running, we first need to set up a place on the server where the `igweb`
    binary executable and the static assets will reside.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了这个服务器错误，因为我们还没有启动`igweb`。要让`igweb`运行起来，我们首先需要在服务器上设置一个位置，用于存放`igweb`二进制可执行文件和静态资产。
- en: Setting up the IGWEB root folder
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置IGWEB根文件夹
- en: 'The IGWEB root folder is where the `igweb` executable and the static assets
    will reside on the production server. We use the following command to become the
    `igweb` user on the production server:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: IGWEB根文件夹是生产服务器上`igweb`可执行文件和静态资产所驻留的地方。我们使用以下命令在生产服务器上成为`igweb`用户：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We create an `igweb` folder in the home directory of the `igweb` user like
    so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`igweb`用户的主目录中创建一个`igweb`文件夹，如下所示：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the directory that will contains the binary executable file for the
    `igweb` web server instance and the static assets that are required by the IGWEB
    demo website. Take note that the static assets will reside in the in the `~/igweb/static`
    folder.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含`igweb` Web服务器实例的二进制可执行文件和IGWEB演示网站所需的静态资产的目录。请注意，静态资产将驻留在`~/igweb/static`文件夹中。
- en: Cross compiling IGWEB
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉编译IGWEB
- en: 'Using the `go build` command, we can actually build binaries for different
    target operating systems, a technique known as **cross compiling**. For example,
    on my macOS machine, I can build a 64-bit Linux binary that we can push out to
    the standalone production server running Ubuntu Linux. Prior to building our binary,
    we specify the target operating system we want to build to by setting the `GOOS`
    environment variable:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go build` 命令，我们实际上可以为不同的目标操作系统构建二进制文件，这种技术称为**交叉编译**。例如，在我的 macOS 机器上，我可以构建一个
    64 位 Linux 二进制文件，然后将其推送到运行 Ubuntu Linux 的独立生产服务器上。在构建我们的二进制文件之前，我们通过设置 `GOOS`
    环境变量来指定我们要构建的目标操作系统：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By setting the `GOOS` environment variable to `linux`, we have specified that
    we wish to generate a binary file for Linux.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `GOOS` 环境变量设置为 `linux`，我们已经指定我们希望为 Linux 生成一个二进制文件。
- en: 'In order to specify that we want the binary to be a 64-bit binary, we set the
    `GOARCH` environment variable to specify the target architecture:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定我们希望二进制文件是 64 位二进制文件，我们设置 `GOARCH` 环境变量来指定目标架构：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By setting the `GOARCH` variable to `amd64`, we have specified that we want
    a 64-bit binary.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `GOARCH` 变量设置为 `amd64`，我们已经指定我们需要一个 64 位二进制文件。
- en: 'Let''s create a `builds` directory within our `igweb` folder by issuing the
    `mkdir` command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发出 `mkdir` 命令，在 `igweb` 文件夹内创建一个 `builds` 目录：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This directory will serve as the depot containing `igweb` binary executables
    for various operating systems. For the purpose of this chapter, we'll only consider
    building a 64-bit Linux binary, but in the future we can accommodate builds for
    other operating systems, such as Windows, in this directory.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目录将作为包含各种操作系统的 `igweb` 二进制可执行文件的仓库。在本章中，我们只考虑构建 64 位 Linux 二进制文件，但在将来，我们可以在此目录中适应其他操作系统的构建，比如
    Windows。
- en: 'We issue the `go build` command and provide the `-o` argument to specify where
    the produced binary file should reside:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发出 `go build` 命令，并提供 `-o` 参数来指定生成的二进制文件应该位于哪里：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have instructed that the produced 64-bit Linux binary should be created in
    the `$IGWEB_APP_ROOT/builds` folder and that the name of the executable will be
    `igweb-linux64`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指示生成的 64 位 Linux 二进制文件应该创建在 `$IGWEB_APP_ROOT/builds` 文件夹中，并且可执行文件的名称将是 `igweb-linux64`。
- en: 'You can verify that the produced binary is a Linux binary by issuing the `file`
    command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过发出 `file` 命令来验证生成的二进制文件是否为 Linux 二进制文件：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From the result, we can see that the `go build` command has produced a `64-bit
    LSB` (Linux Standard Base) executable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中，我们可以看到 `go build` 命令生成了一个 `64 位 LSB`（Linux 标准基础）可执行文件。
- en: If you are interested in building Go binaries for other operating systems besides
    Linux, this link will provide you with a full list of all possible `GOOS` and
    `GOARCH` values: [https://golang.org/doc/install/source#environment](https://golang.org/doc/install/source#environment).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣为 Linux 以外的其他操作系统构建 Go 二进制文件，此链接将为您提供所有可能的 `GOOS` 和 `GOARCH` 值的完整列表：[https://golang.org/doc/install/source#environment](https://golang.org/doc/install/source#environment)。
- en: Preparing the deployment bundle
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备部署包
- en: Besides shipping out the `igweb` executable file, we also need to ship the contents
    of the static folder, that holds all of IGWEB's static assets.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发布 `igweb` 可执行文件，我们还需要发布存放所有 IGWEB 静态资产的静态文件夹的内容。
- en: 'Preparing the static assets for the deployment bundle consists of the following
    steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 准备部署包的静态资产包括以下步骤：
- en: Transpiling the client-side application
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换客户端应用程序
- en: Generating the static assets bundles (template bundle, CSS, and JavaScript)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成静态资产包（模板包、CSS 和 JavaScript）
- en: Minifying the IGWEB CSS stylesheet
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩小 IGWEB 的 CSS 样式表
- en: 'First, we transpile the client-side application:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们转换客户端应用程序：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Second, we have to generate the static assets bundle:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要生成静态资产包：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The third, and final step, of preparing the deployment bundle consists of minifying
    the CSS stylesheet.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 准备部署包的第三个也是最后一个步骤是压缩 CSS 样式表。
- en: 'First, we need to install the Go-based minifier by issuing the following commands:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过发出以下命令来安装基于 Go 的缩小器：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can minify IGWEB''s CSS stylesheet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以压缩 IGWEB 的 CSS 样式表：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With these items in place, we are now ready to create a deployment bundle,
    a tarball, which includes the `igweb` Linux binary along with the `static` folder.
    We create the tarball by issuing the following commands:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些项目，我们现在准备创建一个部署包，一个 tarball，其中包括 `igweb` Linux 二进制文件以及 `static` 文件夹。我们通过发出以下命令来创建
    tarball：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''ll use the `scp` command to ship the bundle off to the remote server:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `scp` 命令将包发送到远程服务器：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `scp` command will copy the tarball, `bundle.tgz`, to the `/tmp` directory
    on the server having the hostname `targetserver`. With the deployment bundle now
    placed on the server, it's time to get `igweb` up and running.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`scp` 命令将 tarball `bundle.tgz` 复制到具有主机名 `targetserver` 的服务器上的 `/tmp` 目录。现在部署包已放置在服务器上，是时候让
    `igweb` 运行起来了。'
- en: Deploying the bundle and starting IGWEB
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署包并启动 IGWEB
- en: 'We move the template bundle that we had secure copied to the `/tmp` folder
    into the `~/igweb` folder and extract the contents of the tarball:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安全复制到 `/tmp` 文件夹的模板包移动到 `~/igweb` 文件夹，并提取 tarball 的内容：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After we are done extracting the contents of the `bundle.tgz` tarball, we remove
    the tarball file by issuing the `rm` command.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们提取 `bundle.tgz` 压缩包的内容后，通过发出 `rm` 命令来删除压缩包文件。
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can rename the binary file back to `igweb` using the `mv` command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `mv` 命令将二进制文件重新命名为 `igweb`：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We had tacked on the `-linux64` to the name of the binary file in our local
    machine so that we could distinguish it from builds for other operating system/architecture
    combinations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本地机器上将 `-linux64` 附加到二进制文件的名称上，以便我们可以将其与其他操作系统/架构组合的构建区分开。
- en: At this point we have deployed the bundle to the production server. It's now
    time to run `igweb`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此时我们已经将包部署到生产服务器。现在是运行 `igweb` 的时候了。
- en: Running IGWEB
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 IGWEB
- en: 'Prior to running the `igweb` executable, we must set the `$IGWEB_APP_ROOT`
    and `$IGWEB_MODE` environment variables on the production server:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`igweb`可执行文件之前，我们必须在生产服务器上设置`$IGWEB_APP_ROOT`和`$IGWEB_MODE`环境变量：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Setting the `$IGWEB_APP_ROOT` environment variable allows the `igweb` application
    to know the designated `igweb` directory that will contain dependent resources,
    such as static assets.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`$IGWEB_APP_ROOT`环境变量允许`igweb`应用程序知道指定的`igweb`目录，该目录将包含依赖资源，如静态资产。
- en: Setting the `$IGWEB_MODE` environment variable to `production` allows us to
    run the `igweb` application in production mode.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将`$IGWEB_MODE`环境变量设置为`production`允许我们以生产模式运行`igweb`应用程序。
- en: 'You should add entries for these two environment variables in the `igweb` user''s
    `.bashrc` configuration file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在`igweb`用户的`.bashrc`配置文件中为这两个环境变量添加条目：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can log out and log back in on the production server for the changes made
    to the `.bashrc` to take effect.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产服务器上注销并重新登录，以使对`.bashrc`所做的更改生效。
- en: Running IGWEB in the foreground
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在前台运行IGWEB
- en: 'Let''s start up the `igweb` web server instance:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动`igweb` Web服务器实例：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Figure 11.4* shows a screenshot of IGWEB running on a standalone server instance
    at the address [http://igweb.kamesh.com](http://igweb.kamesh.com):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.4*显示了IGWEB在地址[http://igweb.kamesh.com](http://igweb.kamesh.com)上运行的独立服务器实例的屏幕截图：'
- en: '![](img/e852eed5-74cf-40ee-927b-847e741cec07.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e852eed5-74cf-40ee-927b-847e741cec07.png)'
- en: 'Figure 11.4: IGWEB running on a standalone server instance'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：IGWEB在独立服务器实例上运行
- en: When we hit the *Ctrl* + *C* key combination to exit the `igweb` program, our
    web server instance comes to a grinding halt since it's been running in the foreground.
    NGINX will return the 502 Bad Gateway server error for any client request. We
    need a way to daemonize `igweb` so that it runs in the background.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下*Ctrl* + *C*组合键退出`igweb`程序时，我们的Web服务器实例会因为一直在前台运行而停止。NGINX将为任何客户端请求返回502
    Bad Gateway服务器错误。我们需要一种方法来使`igweb`以守护进程方式运行，以便在后台运行。
- en: Running IGWEB in the background
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台运行IGWEB
- en: 'The `igweb` web server instance can run in the background using the `nohup`
    command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`igweb` Web服务器实例可以使用`nohup`命令在后台运行：'
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `nohup` command is used to continue running the `igweb` program even after
    the current session has been terminated. On a Unix-like system, the `2>&1` construct
    means redirecting standard error (`stderr`) to the same place as the standard
    output (`stdout`). Log messages from the `igweb` program will be available for
    view by tailing the `/var/log/syslog` file. Finally, the last ampersand, `&`,
    in the command indicates running the program in the background.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`nohup`命令用于在当前会话终止后继续运行`igweb`程序。在类Unix系统上，`2>&1`构造意味着将标准错误（`stderr`）重定向到与标准输出（`stdout`）相同的位置。`igweb`程序的日志消息将通过尾随`/var/log/syslog`文件进行查看。最后，命令中的最后一个`&`表示在后台运行该程序。'
- en: 'We can stop the `igweb` process by first getting the **PID** (process ID):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过首先获取**PID**（进程ID）来停止`igweb`进程：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the output returned from running this command, the PID value will be right
    next to the name of the executable, `igweb`. Once we determine the PID of the
    process, we can stop the `igweb` process by killing it using the `kill` command
    and specifying the PID''s value:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从运行此命令返回的输出中，PID值将紧邻可执行文件`igweb`的名称。一旦确定了进程的PID，我们可以使用`kill`命令并指定PID的值来停止`igweb`进程：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that we have placed the name `PID` in the preceding `kill` command for
    illustration purposes only. You will have to provide the `kill` command with the
    numeric value of the PID returned from running the `ps` command.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在前述`kill`命令中放置了名称`PID`，仅用于说明目的。您将需要使用从运行`ps`命令返回的PID的数字值来为`kill`命令提供PID。
- en: Running IGWEB with systemd
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用systemd在后台运行IGWEB
- en: This approach to running `igweb` works for the time being, but what if the server
    is rebooted? We need a means for the `igweb` program to be more resilient. It
    has to be able to start up again once the server comes back online, and `nohup`
    is not the suitable choice to accomplish this goal.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种运行`igweb`的方法暂时有效，但是如果服务器重新启动会怎么样？我们需要一种方法使`igweb`程序更具弹性。它必须能够在服务器重新上线后再次启动，并且`nohup`不是实现此目标的合适选择。
- en: What we really need is a way to turn `igweb` into a system service. We can do
    exactly that with `sysytemd`, an init system, that is available with Ubuntu 16.04
    LTS. With `systemd`, we can initialize, manage, and track system services. It
    can be used while the system starts up or while it is running.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要的是将`igweb`转换为系统服务的方法。我们可以使用`sysytemd`来实现这一点，`sysytemd`是一个可用于Ubuntu 16.04
    LTS的初始化系统。使用`systemd`，我们可以初始化、管理和跟踪系统服务。它可以在系统启动时或系统运行时使用。
- en: You will need to run the following commands as the `root` user, since you need
    to be `root` in order to add a new system service.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以`root`用户身份运行以下命令，因为您需要成为`root`用户才能添加新的系统服务。
- en: 'In order to turn `igweb` into a service, we create a unit file called `igweb.service`
    and place it in the `/etc/systemd/system` directory. Here''s the contents of the
    unit file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`igweb`转换为服务，我们创建一个名为`igweb.service`的单元文件，并将其放在`/etc/systemd/system`目录中。以下是单元文件的内容：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Specifying the file extension of `.service` indicates that we are creating a
    service unit that describes how to manage an application on the server. This includes
    performing actions such as starting or stopping the service, and if the service
    should be started on system startup.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`.service`文件扩展名表示我们正在创建一个服务单元，描述如何在服务器上管理应用程序。这包括执行诸如启动或停止服务的操作，以及服务是否应在系统启动时启动。
- en: The unit file is organized into multiple sections, where the start of each section
    is denoted with a pair of square brackets *[* and *]* with the name of the section
    enclosed between the brackets.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件分为多个部分，每个部分的开头用一对方括号*[*和*]*标示，括号之间包含部分的名称。
- en: Section names in unit files are case sensitive!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件中的部分名称区分大小写！
- en: 'The first section is the `[Unit]` section. This is used to define the metadata
    for the unit and how this unit relates to other units. Inside the `[Unit]` section
    we have specified a value for the `Description`, which is used to describe the
    name of the unit. For example, we run the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是`[Unit]`部分。这用于定义单元的元数据以及该单元与其他单元的关系。在`[Unit]`部分中，我们已经为`Description`指定了一个值，用于描述单元的名称。例如，我们运行以下命令：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When we run it, the description we see for `nginx` is the description that was
    specified using the `Description` directive.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，我们在`nginx`的描述中看到的是使用`Description`指令指定的描述。
- en: The `[Service]` section is used to specify the configuration of the service. The
    `USER` and `GROUP` directive specify what user and group the command should run
    as. We use the `Environment` directive to set the `$IGWEB_APP_ROOT` environment
    variable, and we use it again to set the `$IGWEB_MODE` environment variable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Service]`部分用于指定服务的配置。`USER`和`GROUP`指令指定命令应该以什么用户和组身份运行。我们使用`Environment`指令来设置`$IGWEB_APP_ROOT`环境变量，并再次使用它来设置`$IGWEB_MODE`环境变量。'
- en: The `WorkingDirectory` directive sets the working directory for the executed
    command. The `ExecStart` directive specifies the full path to the command that
    is to be executed; in this case, we have provided the full path to the `igweb`
    executable file.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkingDirectory`指令设置了执行命令的工作目录。`ExecStart`指令指定了要执行的命令的完整路径；在这种情况下，我们提供了`igweb`可执行文件的完整路径。'
- en: The `Restart` directive is used to specify the circumstances that `systemd`
    will attempt to restart the service. By providing a value of *always*, we have
    specified that the service should always be running, and if for some reason it
    stops, it should be started up again.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Restart`指令用于指定`systemd`将尝试重新启动服务的情况。通过提供*always*的值，我们指定服务应始终运行，如果出现某种原因停止，应该再次启动。'
- en: The last section we've defined is the `[Install]` section. This section allows
    us to specify the behavior of a unit when it is enabled or disabled.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的最后一个部分是`[Install]`部分。这个部分允许我们指定单元在启用或禁用时的行为。
- en: The `WantedBy` directive that is declared in this section tells `systemd` how
    a unit should be enabled, that is, at what system runlevel should the service
    run in when it is enabled. By setting the value for this directive to `multi-user.target`,
    we specify that this service has a system runlevel of 3 (multi-user mode).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个部分声明的`WantedBy`指令告诉`systemd`如何启用一个单元，也就是说，当启用服务时，该服务应该在什么系统运行级别下运行。通过将此指令的值设置为`multi-user.target`，我们指定该服务在系统运行级别3（多用户模式）下运行。
- en: 'Anytime we introduce a new `systemd` service script or make changes to an existing
    one, we must reload the `systemd` daemon. We can do so by issuing the following
    command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们引入新的`systemd`服务脚本或对现有脚本进行更改时，我们必须重新加载`systemd`守护程序。我们可以通过发出以下命令来实现：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can specify, that we want the `igweb` service to startup automatically on
    boot by issuing the following command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定，我们希望`igweb`服务在启动时自动启动，方法是发出以下命令：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we don''t want the `igweb` service to startup automatically on boot, we
    can issue the following command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望`igweb`服务在启动时自动启动，我们可以发出以下命令：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can start the `igweb` service by issuing the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下命令来启动`igweb`服务：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can stop the `igweb` service by issuing the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下命令来停止`igweb`服务：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have now completed the standalone deployment of `igweb`. It's amazing that
    we can run the `igweb` application without having to install Go on the target
    production system.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了`igweb`的独立部署。令人惊讶的是，我们可以在目标生产系统上运行`igweb`应用程序，而无需安装Go。
- en: However, this approach is rather opaque to the DevOps crew that is tasked to
    keep IGWEB up and running. What I mean by *opaque* is that there's not much a
    DevOps engineer can ascertain by examining a static binary executable file and
    a bunch of static assets.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法对于负责保持IGWEB运行的DevOps团队来说相当不透明。我所说的*不透明*是指DevOps工程师无法通过检查静态二进制可执行文件和一堆静态资产来确定太多信息。
- en: What we need is a more streamlined way to deploy IGWEB, a procedure that shows
    us all of the dependencies needed to launch an `igweb` instance from scratch.
    To achieve this goal, we need to dockerize IGWEB.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种更简化的方式来部署IGWEB，一种程序可以显示从头开始启动`igweb`实例所需的所有依赖关系。为了实现这个目标，我们需要将IGWEB放入Docker容器中。
- en: Deploying an Isomorphic Go web application using Docker
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker部署同构Go Web应用程序
- en: This section provides an overview of deploying `igweb` as a multi-container
    Docker application on the Linode cloud. Docker is a technology and a platform
    that allows us to run and manage multiple Docker containers on a single machine.
    You can think of a Docker container as a modular, lightweight virtual machine.
    We can make an application, such as `igweb`, instantly portable by packaging it
    as a Docker container. The application is guaranteed to run the same way inside
    the container, regardless of which environment it is run on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了在Linode云上将`igweb`部署为多容器Docker应用程序的过程。Docker是一种技术和平台，允许我们在单台机器上运行和管理多个Docker容器。您可以将Docker容器视为模块化、轻量级的虚拟机。我们可以通过将应用程序（如`igweb`）打包为Docker容器，使其立即可移植。无论在哪个环境中运行，应用程序都保证在容器内以相同的方式运行。
- en: 'You can learn more about Docker at the following link: [https://www.docker.com](https://www.docker.com).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解有关Docker的更多信息：[https://www.docker.com](https://www.docker.com)。
- en: Most cloud providers offer support for Docker making it a very handy tool for
    cloud-based deployments. As you will see later in this chapter, deploying a multi-container
    Docker application on the Linode cloud is relatively easy.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数云提供商都支持Docker，使其成为云部署的非常方便的工具。正如您将在本章后面看到的，将多容器Docker应用程序部署到Linode云上相对容易。
- en: Installing Docker
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: 'Before installing Docker on the production system, we first need to install
    some prerequisites:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统上安装Docker之前，我们首先需要安装一些先决条件：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we can issue the following command to install Docker:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以发出以下命令来安装Docker：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To verify that Docker has been installed properly on the production system,
    you may issue the following command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证Docker是否已经在生产系统上正确安装，您可以发出以下命令：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You should see the version of Docker installed after running the command.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，您应该看到安装的Docker版本。
- en: Dockerizing IGWEB
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker化IGWEB
- en: The process to dockerize `igweb` first involves creating a `Dockerfile`, a file
    that specifies instructions on how to create a Docker image. The Docker image
    will then be used to create a Docker container.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: docker化`igweb`的过程首先涉及创建一个`Dockerfile`，该文件指定了如何创建Docker镜像的指令。然后将使用Docker镜像来创建Docker容器。
- en: After having created the Dockerfile, we will be using the `docker-compose` tool
    to define and run multiple containers needed to power the IGWEB website.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了Dockerfile之后，我们将使用`docker-compose`工具来定义和运行多个容器，以支持IGWEB网站的运行。
- en: 'Deploying `igweb` as a multi-container Docker application is a three-step process:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将`igweb`部署为多容器Docker应用程序是一个三步过程：
- en: Create a `Dockerfile` from which an IGWEB docker image can be created
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从中可以创建一个IGWEB docker镜像的`Dockerfile`
- en: Define the services that make up IGWEB in a `docker-compose.yml` file
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`docker-compose.yml`文件中定义组成IGWEB的服务
- en: Run `docker-compose up` to start up the multi-container application
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker-compose up`来启动多容器应用程序
- en: The Dockerfile
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile
- en: The `Dockerfile` describes what an `igweb` docker image should be made of. The
    file is located in the `deployments-config/docker-single-setup` folder. Let's
    examine the `Dockerfile` to examine how it works.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`描述了应该由`igweb` docker镜像制作的内容。该文件位于`deployments-config/docker-single-setup`文件夹中。让我们检查`Dockerfile`以了解它的工作原理。'
- en: 'The `FROM` instruction specifies the base parent image from which the current
    image is derived:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`指令指定了当前镜像派生的基本父镜像：'
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we have specified that we will be using the base `golang` docker image.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定将使用基本的`golang` docker镜像。
- en: More information about the `golang` docker image can be found at [https://hub.docker.com/_/golang/](https://hub.docker.com/_/golang/).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`golang` docker镜像的更多信息可以在[https://hub.docker.com/_/golang/](https://hub.docker.com/_/golang/)找到。
- en: 'The `MAINTAINER` instruction specifies the name of the maintainer of the `Dockerfile`
    along with their email address:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAINTAINER`指令指定了`Dockerfile`的维护者姓名以及他们的电子邮件地址：'
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We have specified a group of `ENV` instructions which allow us to define and
    set all the required environment variables:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指定了一组`ENV`指令，允许我们定义和设置所有必需的环境变量：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For the proper operation of the `igweb` application, we set the `$IGWEB_APP_ROOT`,
    the `$IGWEB_DB_CONNECTION`, `$IGWEB_MODE`, and the `$GOPATH` environment variables.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`igweb`应用程序正常运行，我们设置了`$IGWEB_APP_ROOT`、`$IGWEB_DB_CONNECTION`、`$IGWEB_MODE`和`$GOPATH`环境变量。
- en: 'In this block, we use `RUN` instructions to get the Go packages that are required
    by the `igweb` application:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个块中，我们使用`RUN`指令来获取`igweb`应用程序所需的Go包：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is basically the list of Go packages that are needed to get `igweb` up
    and running.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是运行`igweb`所需的Go包列表。
- en: 'The following `RUN` command installs a Go-based CSS/JavaScript minifier:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`RUN`命令安装了一个基于Go的CSS/JavaScript缩小器：
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We use another `RUN` instruction to transpile the client-side Go program:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用另一个`RUN`指令来转译客户端Go程序：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This command is actually a combination of three sequential commands, where each
    command is separated using a semicolon.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令实际上是三个连续命令的组合，每个命令使用分号分隔。
- en: The first command changes directory into the `$IGWEB_APP_ROOT/client` directory. In
    the second command, we fetch any remaining required Go packages in the current
    directory and all sub-directories. The third command transpiles the Go code to
    a minified JavaScript source file, `client.min.js`, which is placed in the `$IGWEB_APP_ROOT/static/js`
    directory.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令将目录更改为`$IGWEB_APP_ROOT/client`目录。在第二个命令中，我们在当前目录和所有子目录中获取任何剩余所需的Go包。第三个命令将Go代码转译为一个缩小的JavaScript源文件`client.min.js`，并将其放置在`$IGWEB_APP_ROOT/static/js`目录中。
- en: 'The next `RUN` instruction builds and installs the server-side Go program:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的`RUN`指令构建并安装服务器端Go程序：
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Take note that the `go install` command will not only produce the `igweb` binary
    executable file by performing a build operation, but it will also move the produced
    executable file to `$GOPATH/bin`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`go install`命令不仅会通过执行构建操作生成`igweb`二进制可执行文件，还会将生成的可执行文件移动到`$GOPATH/bin`。
- en: 'We issue the following `RUN` instruction to generate the static assets:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发出以下`RUN`指令来生成静态资产：
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This `RUN` instruction minifies IGWEB''s CSS stylesheet:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`RUN`指令缩小了IGWEB的CSS样式表：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `ENTRYPOINT` instruction allows us to set the main command of the container:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`指令允许我们设置容器的主要命令：'
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This provides us the ability to run the image as if it were a command. We have
    set the `ENTRYPOINT` to the path of the `igweb` executable file: `/go/bin/igweb`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够像运行命令一样运行镜像。我们将`ENTRYPOINT`设置为`igweb`可执行文件的路径：`/go/bin/igweb`。
- en: 'We use the `EXPOSE` instruction to inform Docker the network port the container
    should listen in on at runtime:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`EXPOSE`指令来通知Docker容器在运行时应监听的网络端口：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We have exposed port `8080` of the container.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经暴露了容器的端口`8080`。
- en: Besides being able to build a docker image using a `Dockerfile`, one of the
    most important benefits of this file is that it conveys meaning and intent. It
    can be treated as a first-class project configuration artifact to understand exactly
    what goes into building the isomorphic web application that is comprised of the
    server-side `igweb` application and the client-side application `client.min.js`.
    From looking over the `Dockerfile`, a DevOps engineer can readily ascertain the
    procedure to successfully build the entire isomorphic web application from scratch.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够使用`Dockerfile`构建docker镜像之外，该文件最重要的好处之一是它传达了意义和意图。它可以被视为一个一流的项目配置工件，以确切了解构建同构Web应用程序的过程，该应用程序由服务器端`igweb`应用程序和客户端应用程序`client.min.js`组成。通过查看`Dockerfile`，DevOps工程师可以轻松地确定成功从头开始构建整个同构Web应用程序的过程。
- en: The Dockerfile for a closed source project
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭源项目的Dockerfile
- en: The `Dockerfile` that we presented works great for an open source project, but
    what would you do if your particular Isomorphic Go project is closed source? How
    could you still take advantage of running Docker in the cloud and keep your source
    code secure from view at the same time? We would need to make slight modifications
    to the `Dockerfile` to account for a closed-source project.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提出的`Dockerfile`非常适合开源项目，但如果你的特定同构Go项目是闭源的，你该怎么办呢？你如何能够利用在云中运行Docker并同时保护源代码不被查看？我们需要对`Dockerfile`进行轻微修改以适应闭源项目。
- en: Let's consider a scenario where the `igweb` code distribution is closed source.
    Let's presume that we could not obtain it using the `go get` command.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，`igweb`的代码分发是闭源的。假设我们无法使用`go get`命令获取它。
- en: Let's also assume that you have created a tarball bundle of the closed source
    `igweb` project, including a closed-source friendly `Dockerfile` at the root of
    the project directory. You have secure copied the tarball from your local machine
    to the target machine, and you have extracted the tarball.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经在项目目录的根目录下创建了一个闭源友好的`Dockerfile`，并且已经将闭源`igweb`项目的tarball捆绑包从本地机器安全地复制到目标机器，并且已经解压了tarball。
- en: 'Here are the changes that we would need to make to the `Dockerfile`. First,
    we comment out the respective `RUN` instruction that gets the `igb` distribution
    using the `go get` command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要对`Dockerfile`进行的更改。首先，我们注释掉使用`go get`命令获取`igb`分发的相应`RUN`指令：
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Right after the set of `RUN` instructions, we immediately introduce a `COPY`
    instruction:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在一系列`RUN`指令之后，我们立即引入了一个`COPY`指令：
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This `COPY` instruction will recursively copy all files and folders within the
    current directory to the destination specified by `$IGWEB_APP_ROOT/.`. That's
    all there is to it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`COPY`指令将递归地将当前目录中的所有文件和文件夹复制到由`$IGWEB_APP_ROOT/.`指定的目的地。就是这样。
- en: Now that we have taken an in-depth look at the anatomy of IGWEB's `Dockerfile`,
    we have to acknowledge the fact that the `igweb` web server instance cannot serve
    the IGWEB website by itself. It has certain service dependencies that we must
    account for, such as the Redis database for its data persistence needs and the
    NGINX reverse proxy for serving hefty static assets in a sensible gzipped manner.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经深入研究了IGWEB的`Dockerfile`的结构，我们必须承认`igweb` web服务器实例本身无法为IGWEB网站提供服务。它有一定的服务依赖性，我们必须考虑，比如Redis数据库用于数据持久性需求，以及NGINX反向代理以合理的gzip方式提供大型静态资产。
- en: What we need is a Docker container for Redis and another Docker container for
    NGINX. `igweb` is turning out to be a multi-container Docker application. It's
    time to turn our focus to `docker-compose`, the handy tool for defining and running
    multi-container applications.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个Redis的Docker容器，以及另一个NGINX的Docker容器。`igweb`正在成为一个多容器的Docker应用程序。现在是时候把注意力转向`docker-compose`，这是一个方便的工具，用于定义和运行多容器应用程序。
- en: Docker compose
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker compose
- en: The `docker-compose` tool allows us to define a multi-container Docker application
    and run it using a single command, `docker-compose up`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`工具允许我们定义一个多容器的Docker应用程序，并使用单个命令`docker-compose up`来运行它。'
- en: '`docker-compose` works by reading a `docker-compose.yml` file that contains
    specific instructions that not only describe the containers in the application,
    but also their individual dependencies. Let''s examine each section of the `docker-compose.yml`
    file for the multi-container `igweb` application.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`通过读取包含特定指令的`docker-compose.yml`文件来工作，这些指令不仅描述了应用程序中的容器，还描述了它们各自的依赖关系。让我们来检查`docker-compose.yml`文件中多容器`igweb`应用程序的每个部分。'
- en: 'In the first line of the file, we indicate that we will be using version 2
    of the Docker Compose configuration file format:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的第一行，我们指示将使用Docker Compose配置文件格式的第2版：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We declare the application''s services inside the `services` section. Each
    service (shown in bold) is given a name to indicate its role in the multi-container
    application:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`services`部分内声明了应用程序的服务。每个服务（以粗体显示）都被赋予一个名称，以指示它在多容器应用程序中的角色：
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We have defined a service with the name `database`, which will be the container
    for the Redis database instance. We set the image option to `redis` to tell `docker-compose`
    to run a container based on the Redis image.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个名为`database`的服务，它将成为Redis数据库实例的容器。我们将image选项设置为`redis`，以告诉`docker-compose`基于Redis镜像运行一个容器。
- en: Right after that, we define a service with the name `webapp`, which will be
    the container for the `igweb` application. We use the `depends_on` option to explicitly
    state that the `webapp` service needs the `database` service to function. Without
    the `database` service up, the `webapp` service cannot be brought up.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，我们定义了一个名为`webapp`的服务，它将成为`igweb`应用程序的容器。我们使用`depends_on`选项明确说明`webapp`服务需要`database`服务才能运行。如果没有`database`服务，`webapp`服务就无法启动。
- en: We specify the `build` option to tell `docker-compose` to build an image based
    on the `Dockerfile` in the path specified. By specifying the relative path of
    `.`, we indicate that the `Dockerfile` that exists in the current directory should
    be used to build the base image.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定`build`选项告诉`docker-compose`根据指定路径中的`Dockerfile`构建镜像。通过指定相对路径`.`，我们指示应使用当前目录中存在的`Dockerfile`构建基础镜像。
- en: We specify a value of `8080:8080` (HOST:CONTAINER) for the `ports` section to
    indicate that we want to open up port `8080` on the host and forward connections
    to port `8080` of the Docker container.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ports`部分，我们指定了`8080:8080`（HOST:CONTAINER）的值，表示我们要在主机上打开端口`8080`并将连接转发到Docker容器的端口`8080`。
- en: We have defined the service with the name `reverseproxy`, which will be the
    container for the `nginx` reverse proxy server. We set the `depends_on` option
    to `webapp` to indicate that the `reverseproxy` service cannot be brought up without
    the `webapp` service being up. We've set the image option to `nginx` to tell `docker-compose`
    to run a container based on the `nginx` image.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了名为`reverseproxy`的服务，它将作为`nginx`反向代理服务器的容器。我们将`depends_on`选项设置为`webapp`，以表示`reverseproxy`服务在`webapp`服务启动之前不能启动。我们将image选项设置为`nginx`，告诉`docker-compose`基于`nginx`镜像运行容器。
- en: In the `volumes` section, we can define our mount paths, in the form of HOST:CONTAINER.
    We have defined a single mount path where we have mounted the `nginx` configuration
    file, `nginx.conf`, located in the `./deployments-config/docker-single-setup`
    directory to the `/etc/nginx/nginx.conf` path inside the container.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在`volumes`部分，我们可以定义我们的挂载路径，格式为HOST:CONTAINER。我们定义了一个挂载路径，将位于`./deployments-config/docker-single-setup`目录中的`nginx.conf`配置文件挂载到容器内部的`/etc/nginx/nginx.conf`路径。
- en: Since the `reverseproxy` service will be servicing HTTP client requests, we
    specify a value of `80:80` for the `ports` section to indicate that we want to
    open up port `80` (the default HTTP port) on the host and forward connections
    to port `80` of the Docker container.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`reverseproxy`服务将为HTTP客户端请求提供服务，我们在`ports`部分指定了值为`80:80`，表示我们要在主机上打开端口`80`（默认HTTP端口）并将连接转发到Docker容器的端口`80`。
- en: Now that we've gone through the Docker Compose configuration file, it's time
    to start up `igweb` as a multi-container Docker application using the `docker-compose
    up` command.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了Docker Compose配置文件，是时候使用`docker-compose up`命令启动`igweb`作为多容器Docker应用程序了。
- en: Running Docker compose
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Docker Compose
- en: 'We issue the following command to build the services:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发出以下命令来构建服务：
- en: '[PRE64]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here''s the output of running the `docker-compose build` command (some part
    of the output has been omitted for brevity):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker-compose build`命令的输出如下（为了简洁起见，部分输出已省略）：
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'After the build is complete, we can go ahead and run the multi-container `igweb`
    application by issuing the following command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以通过以下命令运行多容器`igweb`应用：
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '*Figure 11.5* is a screenshot of IGWEB running as a multi-container application:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.5*是IGWEB作为多容器应用程序运行的截图：'
- en: '![](img/8c58f00f-245d-4d24-bf98-36e9fd4877f4.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c58f00f-245d-4d24-bf98-36e9fd4877f4.png)'
- en: 'Figure 11.5: IGWEB running as a multi-container application'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：IGWEB作为多容器应用程序运行
- en: When we run the `docker-compose up` command, the command provides us live output
    of activity across all of the running containers. To exit the program, you can
    use the *Ctrl* + *C* key combination. Note that this will terminate the `docker-compose`
    program, which will shut down the running containers in a graceful manner.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`docker-compose up`命令时，该命令会提供所有运行容器的实时活动输出。要退出程序，可以使用*Ctrl* + *C*组合键。请注意，这将终止`docker-compose`程序，从而以一种优雅的方式关闭运行的容器。
- en: 'Alternatively, when starting the multi-container `igweb` application, you may
    specify the `-d` option to run in detached mode, which will run the containers
    in the background, like so:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，在启动多容器`igweb`应用程序时，可以指定`-d`选项以在后台运行，如下所示：
- en: '[PRE67]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you wish to bring the multi-container application down, you can issue the
    following command:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要关闭多容器应用程序，可以发出以下命令：
- en: '[PRE68]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If you make further changes to the `Dockerfile` or the `docker-compose.yml`
    file, you must run the `docker-compose build` command again to rebuild the services:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对`Dockerfile`或`docker-compose.yml`文件进行进一步更改，必须再次运行`docker-compose build`命令来重建服务：
- en: '[PRE69]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It's convenient to have the facility of `docker-compose up -d` to run the containers
    in the background, but by now, we know that it would be best to turn our multi-container
    Docker application into a `systemd` service.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台运行容器的`docker-compose up -d`非常方便，但现在我们知道最好将多容器Docker应用程序转换为`systemd`服务。
- en: Setting up the dockerized IGWEB service
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置docker化的IGWEB服务
- en: 'Setting up the `systemd` service for the dockerized `igweb` is pretty straightforward.
    Here are the contents of the `igweb-docker.service` file, which should be placed
    in the production system''s `/etc/systemd/system` directory:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 设置docker化的`igweb`的`systemd`服务非常简单。以下是`igweb-docker.service`文件的内容，应放置在生产系统的`/etc/systemd/system`目录中：
- en: '[PRE70]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the `[Unit]` section, we have set the `After` directive with the value `docker.service`.
    This indicates that the `docker` unit must be started before the `igweb-docker`
    unit. The `Requires` directive has also been set with the value `docker.service`.
    This indicates that the `igweb-docker` unit is dependent on the `docker` unit
    to successfully run. Failure to start the `docker` unit will result in a failure
    to start the `igweb-docker` unit.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[Unit]`部分，我们使用`After`指令设置了值为`docker.service`。这表示`docker`单元必须在`igweb-docker`单元之前启动。`Requires`指令也设置为值为`docker.service`。这表示`igweb-docker`单元依赖于`docker`单元成功运行。如果无法启动`docker`单元，将导致无法启动`igweb-docker`单元。
- en: In the `[Service]` section, we have set the `Type` directive to `oneshot`. This
    indicates that the executable we are launching is short-lived. It makes sense
    to use it because we will be running `docker-compose up` with the `-d` flag specified
    (detached mode) so that the containers run in the background.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[Service]`部分，我们将`Type`指令设置为`oneshot`。这表明我们正在启动的可执行文件是短暂的。使用它是有道理的，因为我们将使用`-d`标志指定（分离模式）运行`docker-compose
    up`，以便容器在后台运行。
- en: We have specified the `RemainAfterExit` directive in conjunction with the `Type`
    directive. By setting the `RemainAfterExit` directive to `yes`, we indicate that
    the `igweb-docker` service should be considered active even after the `docker-compose`
    process exits.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`RemainAfterExit`指令中指定了`Type`指令。通过将`RemainAfterExit`指令设置为`yes`，我们表明`igweb-docker`服务即使在`docker-compose`进程退出后也应被视为活动状态。
- en: Using the `ExecStart` directive, we start the `docker-compose` process in detached
    mode. We have specified the `ExecStop` directive to indicate the command that
    is needed to stop the service.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ExecStart`指令，我们以分离模式启动`docker-compose`进程。我们已经指定了`ExecStop`指令，以指示停止服务所需的命令。
- en: In the `[Install]` section by setting the value for the `WantedBy` directive
    to `multi-user.target`, we specify that this service has a system runlevel of
    3 (multi-user mode).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[Install]`部分，通过将`WantedBy`指令的值设置为`multi-user.target`，我们指定了该服务在系统运行级别3（多用户模式）下运行。
- en: 'Recall that after placing the `igweb-docker.service` file in the `/etc/systemd/system`
    directory, we must reload the `systemd` daemon like so:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在将`igweb-docker.service`文件放置在`/etc/systemd/system`目录后，我们必须像这样重新加载`systemd`守护程序：
- en: '[PRE71]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, we can start the dockerized `igweb` application:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动docker化的`igweb`应用程序：
- en: '[PRE72]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You may use the `systemctl enable` command to specify that `igweb-docker` should
    be started on system startup.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`systemctl enable`命令指定`igweb-docker`应该在系统启动时启动。
- en: 'We can take down the service by issuing the following command:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发出以下命令，我们可以关闭服务：
- en: '[PRE73]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: At this point, we've demonstrated how to run the `igweb` application as a multi-container
    Docker application hosted on the Linode cloud. Again, although we are using Linode,
    the procedure that we have demonstrated can be replicated on your preferred cloud
    provider of choice.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经演示了如何将`igweb`应用程序作为托管在Linode云上的多容器Docker应用程序运行。再次强调，虽然我们使用的是Linode，但我们演示的过程可以在您选择的首选云提供商上复制。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to deploy an isomorphic web application to the
    cloud. We presented how the `igweb` server-side application operates in production
    mode, showing you how external CSS and JavaScript source files were included by
    the application. We also showed you how to tame the file size of the JavaScript
    program produced by GopherJS. We showed you how to generate static assets for
    the application's template bundle along with the JavaScript and CSS that were
    to be used by the deployed cogs.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将等同构Web应用程序部署到云上。我们介绍了`igweb`服务器端应用程序在生产模式下的运行方式，向您展示了应用程序如何包含外部CSS和JavaScript源文件。我们还向您展示了如何控制GopherJS生成的JavaScript程序的文件大小。我们向您展示了如何为应用程序的模板包生成静态资产，以及要部署的齿轮使用的JavaScript和CSS。
- en: We first considered the deployment of an isomorphic web application to a standalone
    server. This consisted of adding an `igweb` user to the server, setting up the
    `redis-server` instance, setting up `nginx` as a reverse proxy with GZIP compression
    enabled, and setting up the `igweb` root folder. We also showed you how to cross
    compile Go code from the development system (64-bit macOS) to the operating system
    running on the production system (64-bit Linux). We guided you through the process
    of preparing a deployment bundle, and then we deployed the bundle to the production
    system. Finally, we showed you how to set up `igweb` as a `systemd` service so
    that it could easily be started, stopped, restarted, and automatically started
    on system startup.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先考虑了将等跨服务器部署等同构Web应用程序。这包括向服务器添加`igweb`用户，设置`redis-server`实例，使用启用了GZIP压缩的`nginx`作为反向代理，并设置`igweb`根文件夹。我们还向您展示了如何从开发系统（64位macOS）交叉编译Go代码到运行在生产系统上的操作系统（64位Linux）。我们指导您准备部署包的过程，然后部署包到生产系统。最后，我们向您展示了如何将`igweb`设置为`systemd`服务，以便可以轻松地启动、停止、重新启动，并在系统启动时自动启动。
- en: We then focused our attention to the deployment of an isomorphic web application
    as a multi-container Docker application. We showed you how to install Docker on
    the production system. We walked you through the process of dockerizing `igweb`,
    which consisted of creating a `Dockerfile`, defining the services that make up
    IGWEB in a `docker-compose.yml` file, and running the `docker-compose up` command
    to start up IGWEB as a multi-container Docker application. Finally, we showed
    you how to set up the `igweb-docker systemd` script to manage `igweb` as a system
    service.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将注意力集中在将等同构Web应用程序部署为多容器Docker应用程序。我们向您展示了如何在生产系统上安装Docker。我们带您完成了dockerizing
    `igweb`的过程，其中包括创建`Dockerfile`，在`docker-compose.yml`文件中定义组成IGWEB的服务，并运行`docker-compose
    up`命令以将IGWEB作为多容器Docker应用程序启动。最后，我们向您展示了如何设置`igweb-docker systemd`脚本来管理`igweb`作为系统服务。
