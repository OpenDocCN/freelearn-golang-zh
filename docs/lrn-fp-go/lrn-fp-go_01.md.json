["```go\nvar found bool \ncarToLookFor := \"Blazer\" \ncars := []string{\"Accord\", \"IS250\", \"Blazer\" }\nfor _, car := range cars {\n   if car == carToLookFor {\n      found = true; // set flag\n   }\n}\nfmt.Printf(\"Found? %v\", found)\n```", "```go\ncars := []string{\"Accord\", \"IS250\", \"Blazer\" }\nfmt.Printf(\"Found? %v\", cars.contains(\"Blazer\"))\n```", "```go\ntype Car struct {\n   Model string\n}\naccord := &Car{\"Accord\"}; is250 := &Car{\"IS250\"}; blazer := &Car{\"Blazer\"}\ncars := []*Car{is250, accord, blazer}\nvar found bool\ncarToLookFor := is250\nfor _, car := range cars {\n   if car == carToLookFor {\n     found = true;\n   }\n}\nfmt.Printf(\"Found? %v\", found)\n```", "```go\ntype Car struct {\n   Model string\n}\ntype Cars []Car\n```", "```go\nfunc (cars *Cars) Add(car Car) {\n   myCars = append(myCars, car)\n}\n\nfunc (cars *Cars) Find(model string) (*Car, error) {\n   for _, car := range *cars {\n      if car.Model == model {\n         return &car, nil\n      }\n   }\n   return nil, errors.New(\"car not found\")\n}\n```", "```go\nvar myCars Cars\n```", "```go\nfunc main() {\n   myCars.Add(Car{\"IS250\"})\n   myCars.Add(Car{\"Blazer\"})\n   myCars.Add(Car{\"Highlander\"})\n```", "```go\n    car, err := myCars.Find(\"Highlander\")\n   if err != nil {\n      fmt.Printf(\"ERROR: %v\", car)\n   } else {\n      fmt.Printf(\"Found %v\", car)\n   }\n}\n```", "```go\n 1  1  2  3  5  8  13  21  34\n```", "```go\nfunc Fibonacci(x int) int {\n    if x == 0 {\n        return 0\n } else if x <= 2 {\n        return 1\n } else {\n        return Fibonacci(x-2) + Fibonacci(x-1)\n    }\n}\n```", "```go\nfunc main() {\n   fib := Fibonacci\n   fmt.Printf(\"%vn\", fib(5))\n}\n```", "```go\ntype Memoized func(int) int\nvar fibMem Memoized\n```", "```go\nfunc Memoize(mf Memoized) Memoized {\n       cache := make(map[int]int)\n       return func(key int) int {\n if val, found := cache[key]; found {\n return val\n }\n temp := mf(key)\n cache[key] = temp\n return temp\n }\n}\n```", "```go\nfunc fib(x int) int {\n   if x == 0 {\n      return 0\n } else if x <= 2 {\n      return 1\n } else {\n      return fib(x-2) + fib(x-1)\n   }\n}\n```", "```go\nfunc FibMemoized(n int) int {\n   return fibMem(n)\n}\n```", "```go\nprintln(fibonacci.FibMemoized(5))\n```", "```go\n5\n```", "```go\nfunc FibMemoized(n int) int {\n   return fibMem(n)\n}\n```", "```go\nreturn func(key int) int {\n   if val, found := cache[key]; found {\n      return val\n   }\n   temp := mf(key)\n   cache[key] = temp\n   return temp\n}\n```", "```go\nfunc fib(x int) int {\n   if x == 0 {\n      return 0\n } else if x <= 2 {\n      return 1\n } else {\n      return fib(x-2) + fib(x-1)\n   }\n}\n```", "```go\nfunc namedGreeting(name string) {\n   fmt.Printf(\"Hey %s!n\", name)\n}\n```", "```go\nfunc anonymousGreeting() func(string) {\n     return func(name string) {\n            fmt.Printf(\"Hey %s!n\", name)\n     }\n}\n```", "```go\nfunc main() {\n   namedGreeting(\"Alice\")\n\n   greet := anonymousGreeting()\n   greet(\"Bob\")\n\n   func(name string) {\n      fmt.Printf(\"Hello %s!n\", name)\n   }(\"Cindy\")\n}\n```", "```go\nHello Alice!\nHello Bob!\nHello Cindy!\n```", "```go\nfunc greeting(name string) {\n     msg := name + fmt.Sprintf(\" (at %v)\", time.Now().String())\n\n     closure := func() {\n            fmt.Printf(\"Hey %s!n\", msg)\n     }\n     closure()\n}\n\nfunc main() {\n     greeting(\"alice\")\n}\n```", "```go\nHey alice (at 2017-01-29 12:29:30.164830641 -0500 EST)!\n```", "```go\nfunc greeting(name string) func() {\n     msg := name + fmt.Sprintf(\" (at %v)\", time.Now().String())\n     closure := func() {\n            fmt.Printf(\"Hey %s!n\", msg)\n     }\n     return closure\n}\n\nfunc main() {\n     fmt.Println(time.Now())\n     hey := greeting(\"bob\")\n     time.Sleep(time.Second * 10)\n     hey()\n}\n```", "```go\n2017-01-29 12:42:09.767187225 -0500 EST\nHey bob (at 2017-01-29 12:42:09.767323847 -0500 EST)!\n```", "```go\nchannel <- data\ndata := <-channel\n```", "```go\nfunc Channel(ch chan int, counter int) {\n       n1, n2 := 0, 1\n for i := 0; i < counter; i++ {\n              ch <- n1\n              n1, n2 = n2, n1 + n2\n       }\n       close(ch)\n}\n```", "```go\nfunc FibChanneled(n int) int {\n       n += 2\n ch := make(chan int)\n       go Channel(ch, n)\n       i := 0; var result int\n       for num := range ch {\n              result = num\n              i++\n       }\n       return result\n}\n```", "```go\n// File: chapter1/_01_fib/ex1_test.go\npackage fib\n\nimport \"testing\"\n\nvar fibTests = []struct {\n   a int\n   expected int\n}{\n   {1, 1},\n   {2, 2},\n   {3, 3},\n   {4, 5},\n   {20, 10946},\n   {42, 433494437},\n}\n\nfunc TestSimple(t *testing.T) {\n   for _, ft := range fibTests {\n      if v := FibSimple(ft.a); v != ft.expected {\n        t.Errorf(\"FibSimple(%d) returned %d, expected %d\", ft.a, v, ft.expected)\n      }\n   }\n}\n```", "```go\nfunc BenchmarkFibSimple(b *testing.B) {\n     fn := FibSimple\n     for i := 0; i < b.N; i++ {\n            _ = fn(8)\n     }\n}\n```", "```go\n01_duck@ -> /Users/lex/clients/packt/dev/fp-go/2-design-patterns/ch04-solid/01_duck\n01_hof@ -> /Users/lex/clients/packt/dev/fp-go/1-functional-fundamentals/ch03-hof/01_hof\n04_onion@ -> /Users/lex/clients/packt/dev/fp-go/2-design-patterns/ch07-onion-arch/04_onion\n```", "```go\nfunc benchmarkFibSimple(i int, b *testing.B) {\n     for n := 0; n < b.N; n++ {\n            FibSimple(i)\n     }\n}\n\nfunc BenchmarkFibSimple1(b *testing.B)  { benchmarkFibSimple(1, b) }\nfunc BenchmarkFibSimple2(b *testing.B)  { benchmarkFibSimple(2, b) }\nfunc BenchmarkFibSimple3(b *testing.B)  { benchmarkFibSimple(3, b) }\nfunc BenchmarkFibSimple10(b *testing.B) { benchmarkFibSimple(4, b) }\nfunc BenchmarkFibSimple20(b *testing.B) { benchmarkFibSimple(20, b) }\nfunc BenchmarkFibSimple40(b *testing.B) { benchmarkFibSimple(42, b) }\n```", "```go\nfunc TestMemoized(t *testing.T) {\n   for _, ft := range fibTests {\n      if v := FibMemoized(ft.a); v != ft.expected {\n         t.Errorf(\"FibMemoized(%d) returned %d, expected %d\", ft.a, v, ft.expected)\n      }\n   }\n}\n```", "```go\nfunc BenchmarkFibMemoized(b *testing.B) {\n     fn := FibMemoized\n     for i := 0; i < b.N; i++ {\n            _ = fn(8)\n     }\n}\n```", "```go\nfunc BenchmarkFibMemoized(b *testing.B) {\n     fn := FibMemoized\n     for i := 0; i < b.N; i++ {\n            _ = fn(8)\n     }\n}\n\nfunc benchmarkFibMemoized(i int, b *testing.B) {\n     for n := 0; n < b.N; n++ {\n            FibMemoized(i)\n     }\n}\n\nfunc BenchmarkFibMemoized1(b *testing.B)  { \n    benchmarkFibMemoized(1, b) }\nfunc BenchmarkFibMemoized2(b *testing.B)  { \n    benchmarkFibMemoized(2, b) }\nfunc BenchmarkFibMemoized3(b *testing.B)  { \n    benchmarkFibMemoized(3, b) }\nfunc BenchmarkFibMemoized10(b *testing.B) { \n    benchmarkFibMemoized(4, b) }\nfunc BenchmarkFibMemoized20(b *testing.B) { \n    benchmarkFibMemoized(20, b) }\nfunc BenchmarkFibMemoized40(b *testing.B) { \n    benchmarkFibMemoized(42, b) }\n```", "```go\npackage fib\n\nimport \"testing\"\n\nfunc TestChanneled(t *testing.T) {\n     for _, ft := range fibTests {\n            if v := FibChanneled(ft.a); v != ft.expected {\n                   t.Errorf(\"FibChanneled(%d) returned %d, expected %d\", ft.a, v, ft.expected)\n            }\n     }\n}\n\nfunc BenchmarkFibChanneled(b *testing.B) {\n     fn := FibChanneled\n     for i := 0; i < b.N; i++ {\n            _ = fn(8)\n     }\n}\n\nfunc benchmarkFibChanneled(i int, b *testing.B) {\n     for n := 0; n < b.N; n++ {\n            FibChanneled(i)\n     }\n}\n\nfunc BenchmarkFibChanneled1(b *testing.B)  { \n    benchmarkFibChanneled(1, b) }\nfunc BenchmarkFibChanneled2(b *testing.B)  { \n    benchmarkFibChanneled(2, b) }\nfunc BenchmarkFibChanneled3(b *testing.B)  { \n    benchmarkFibChanneled(3, b) }\nfunc BenchmarkFibChanneled10(b *testing.B) { \n    benchmarkFibChanneled(4, b) }\nfunc BenchmarkFibChanneled20(b *testing.B) { \n    benchmarkFibChanneled(20, b) }\nfunc BenchmarkFibChanneled40(b *testing.B) { \n    benchmarkFibChanneled(42, b) }\n```", "```go\nfunc SumLoop(nums []int) int {\n       sum := 0\n for _, num := range nums {\n              sum += num\n       }\n       return sum\n}\n```", "```go\nfunc SumRecursive(nums []int) int {\n       if len(nums) == 0 {\n              return 0\n }\n       return nums[0] + SumRecursive(nums[1:])\n}\n```", "```go\nfunc benchmarkSumLoop(s []int, b *testing.B) {\n       for n := 0; n < b.N; n++ {\n              SumLoop(s)\n       }\n}\n\nfunc BenchmarkSumLoop40(b *testing.B) { benchmarkSumLoop([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40}, b) }\n```", "```go\nfunc benchmarkSumRecursive(s []int, b *testing.B) {\n       for n := 0; n < b.N; n++ {\n              SumRecursive(s)\n       }\n}\n\nfunc BenchmarkSumRecursive40(b *testing.B) { benchmarkSumRecursive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40}, b) }\n```", "```go\nfunc SumTailCall(vs []int) int {\n       if len(vs) == 0 {\n              return 0\n }\n       return vs[0] + SumTailCall(vs[1:])\n}\n```", "```go\npackage main\n\nfunc curryAddTwo(n int) (ret int) {\n   defer func(){ret = n + 2}()\n   return n\n}\n\nfunc main()  {\n   println(curryAddTwo(1))\n}\n```", "```go\n3\n```"]