["```go\ntype CarIterator interface {\n     Next() (value string, ok bool)\n}\nconst INVALID_INT_VAL = -1\nconst INVALID_STRING_VAL = \"\"\n```", "```go\ntype Collection struct {\n       index int\n       List  []string\n}\n```", "```go\nfunc (collection *Collection) Next() (value string, ok bool) {\n       collection.index++\n       if collection.index >= len(collection.List) {\n              return INVALID_STRING_VAL, false\n       }\n       return collection.List[collection.index], true\n}\n```", "```go\nfunc newSlice(s []string) *Collection {\n        return &Collection{INVALID_INT_VAL, s}\n}\n```", "```go\n$ cat ips.log | awk '{print $7}' | sort | uniq -c\n```", "```go\nSun Feb 12 20:27:32 EST 2017 74.125.196.101\nSun Feb 12 20:27:33 EST 2017 98.139.183.24\nSun Feb 12 20:27:34 EST 2017 151.101.0.73\nSun Feb 12 20:27:35 EST 2017 98.139.183.24\nSun Feb 12 20:27:36 EST 2017 151.101.0.73\n>Sun Feb 12 20:27:37 EST 2017 74.125.196.101\nSun Feb 12 20:27:38 EST 2017 98.139.183.24\nSun Feb 12 20:27:39 EST 2017 151.101.0.73\nSun Feb 12 20:27:40 EST 2017 98.139.183.24\nSun Feb 12 20:27:41 EST 2017 151.101.0.73\nSun Feb 12 20:27:42 EST 2017 151.101.0.73\nSun Feb 12 20:27:43 EST 2017 151.101.0.73\n```", "```go\n6 151.101.0.73\n2 74.125.196.101\n4 98.139.183.24\n```", "```go\n// http.Get :: String -> JSON\nvar renderPage = curry(func(makes, models) { /* render page */ })\n// return two divs: one with makes and the other with models HTML/ULs\nTask.Of(renderPage).Ap(http.Get(\"/makes\")).Ap(http.Get(\"/models\"))\n```", "```go\n// cam72cam.immersiverailroading.render.TileSteamHammerRender\npublic class TileSteamHammerRender extends TileEntitySpecialRenderer<TileSteamHammer> {   \n   private List<String> hammer;\n   private List<String> rest;\n```", "```go\n$ cat access10k.log | head -n 1 | awk '{print $7}' | grep \"\\.json\" | uniq -c | sort -nr \n```", "```go\nrSum :: [Integer] -> Integer\nrSum (x:xs) = x + (rSum xs)\nrSum [] = 0\n\n```", "```go\ntSum :: [Integer] -> Integer\ntSum lst = tSum lst 0 where\n tSum (x:xs) i = tSum xs (i+x)\n    tSum [] i = i\n```", "```go\nnumbers := []interface{}{\n 1,\n 5,\n 3,\n 2,\n}\n\ncoll := collections.NewFromSlice(numbers)\nmin := collections.Reduce(0, func(a, b interface{}) interface{} {\n if a > b { return a } else { return b }\n})\n```", "```go\nnames := []interface{}{\n \"Alice\",\n \"Bob\",\n \"Cindy\",\n}\ncollection := collections.NewFromSlice(planets)\ncollection = collection.Map(func(v interface{}) interface{} {\n return strings.Join([]string{ \"Hey \", v.(string) })\n})\nprintln(collection)\n```", "```go\nHey Alice\nHey Bob\nHey Cindy\n```", "```go\n // left collection:\n 0001, \"alice\", \"bob\"\n 0001, \"cindy\", \"dan\"\n 0002, \"evelyn\", \"frank\"\n // right collection:\n 0001, \"greg\", \"izzy\"\n 0002, \"jenny\", \"alice\"\n\nleft.Join(right)\n```", "```go\n 0001, \"alice\", \"bob\", \"greg\", \"izzy\"\n 0001, \"cindy\", \"dan\", \"greg\", \"izzy\"\n 0002, \"evelyn\", \"frank\", \"jenny\", \"alice\"\n```", "```go\n// input collection:\n 0001, \"alice\", 0002\n 0001, \"bob\", 0002\n 0003, \"cindy\", 0002\n\n GroupBy(1,3)\n```", "```go\n 0001, 0002, [\"alice\", \"bob\"]\n 0003, 0002, [\"cindy\"]\n```", "```go\nnumbers := []interface{}{\n 1,\n 5,\n 3,\n 2,\n}\ncollection := collections.NewFromSlice(numbers)\nmin := collection.Reduce(0, func(a, b interface{}) interface{} {\n if a > b { return a } else { return b }\n})\n```", "```go\npackage predicate\n\nfunc All(vals []string, predicate func(string) bool) bool {\n       for _, val := range vals {\n              if !predicate(val) {\n                     return false\n              }\n       }\n       return true\n}\n```", "```go\nfunc Any(vs []string, predicate func(string) bool) bool {\n       for _, val := range vs {\n              if predicate(val) {\n                     return true\n              }\n       }\n       return false\n}\n```", "```go\nfunc Filter(vals []string, predicate func(string) bool) []string {\n       filteredVals := make([]string, 0)\n       for _, v := range vals {\n              if predicate(v) {\n                     filteredVals = append(filteredVals, v)\n              }\n       }\n       return filteredVals\n}\n```", "```go\nfunc Count(vals []string) int {\n       return len(vals)\n}\n```", "```go\npackage predicate\n\nimport (\n       \"testing\"\n \"strings\"\n . \"github.com/franela/goblin\"\n)\n\nfunc TestPredicateSucceed(t *testing.T) {\n       fakeTest := testing.T{}\n       g := Goblin(&fakeTest)\n```", "```go\n     g.Describe(\"Predicate Tests\", func() {\n          cars := []string{\"CRV\", \"IS250\", \"Highlander\"}\n```", "```go\ng.Describe(\"Starts High\", func() {\n       g.It(\"Should be true\", func() {\n              bs := Any(cars, func(v string) bool {\n                     return strings.HasPrefix(v, \"High\")\n              })\n              g.Assert(bs).Equal(true)\n       })\n})\n```", "```go\ng.Describe(\"Highlander should be High\", func() {\n       high := Filter(cars, func(v string) bool {\n              return strings.Contains(v, \"High\")\n       })\n       highlander := []string{\"Highlander\"}\n       g.It(\"Should be true\", func() {\n              g.Assert(high).Equal(highlander)\n       })\n})\n```", "```go\ng.Describe(\"One is High\", func() {\n       high := Count(Filter(cars, func(v string) bool {\n              return strings.Contains(v, \"High\")\n       }))\n       g.It(\"Should be true\", func() {\n              g.Assert(high).Equal(1)\n       })\n})\n```", "```go\ng.Describe(\"All are High\", func() {\n       high := All(cars, func(v string) bool {\n              return strings.Contains(v, \"High\")\n       })\n       g.It(\"Should be false\", func() {\n              g.Assert(high).Equal(false)\n       })\n})\n```", "```go\nfunc Any(vs []string, predicate func(string) bool) bool\n```", "```go\npackage main\nimport (\n   \"fmt\"\n   \"log\"\n   \"strings\"\n   \"errors\"\n   u \"github.com/go-goodies/go_utils\"\n)\n```", "```go\ntype WordSize int\nconst (\n     ZERO WordSize = 6 * iota\n     SMALL\n     MEDIUM\n     LARGE\n     XLARGE\n     XXLARGE  WordSize = 50\n     SEPARATOR = \", \"\n)\n```", "```go\ntype ChainLink struct {\n     Data []string\n}\n```", "```go\nfunc (v *ChainLink) Value() []string {\n     return v.Data\n}\n```", "```go\ntype stringFunc func(s string) (result string)\n```", "```go\nfunc (v *ChainLink)Map(fn stringFunc) *ChainLink {\n     var mapped []string\n     orig := *v\n     for _, s := range orig.Data {\n            mapped = append(mapped, fn(s))\n     }\n     v.Data = mapped\n     return v\n}\n```", "```go\nmapped = append(mapped, fn(s))\n```", "```go\nfunc (v *ChainLink)Filter(max WordSize) *ChainLink {\n     filtered := []string{}\n     orig := *v\n     for _, s := range orig.Data {\n            if len(s) <= int(max) {             // embedded logic\n                   filtered = append(filtered, s)\n            }\n     }\n     v.Data = filtered\n     return v\n}\n```", "```go\nfunc (cars Collection) Filter(fn FilterFunc) Collection {\n   filteredCars := make(Collection, 0)\n   for _, car := range cars {\n      if fn(car) {\n         filteredCars = append(filteredCars, car)\n      }\n   }\n   return filteredCars\n}\n```", "```go\nfunc main() {\n   constants := `\n** Constants ***\nZERO: %v\nSMALL: %d\nMEDIUM: %d\nLARGE: %d\nXLARGE: %d\nXXLARGE: %d\n`\n fmt.Printf(constants, ZERO, SMALL, MEDIUM, LARGE, XLARGE, XXLARGE)\n```", "```go\n** Constants ***\nZERO: 0\nSMALL: 6\nMEDIUM: 12\nLARGE: 18\nXLARGE: 24\nXXLARGE: 50\n```", "```go\nwords := []string{\n   \"tiny\",\n   \"marathon\",\n   \"philanthropinist\",\n   \"supercalifragilisticexpialidocious\"}\n\ndata := ChainLink{words};\nfmt.Printf(\"unfiltered: %#v\\n\", data.Value())\n```", "```go\nunfiltered: []string{\"tiny\", \"marathon\", \"philanthropinist\", \"supercalifragilisticexpialidocious\"}\n```", "```go\n  filtered := data.Filter(SMALL)\n  fmt.Printf(\"filtered: %#vn\", filtered)\n```", "```go\nfiltered: &main.ChainLink{Data:[]string{\"tiny\"}}\n```", "```go\n     fmt.Printf(\"filtered and mapped (<= SMALL sized words): %#vn\",\n          filtered.Map(strings.ToUpper).Value())\n```", "```go\nfiltered and mapped (<= SMALL sized words): []string{\"TINY\"}\n```", "```go\n     data = ChainLink{words}\n     fmt.Printf(\"filtered and mapped (<= MEDIUM and smaller sized words): %#vn\",\n          data.Filter(MEDIUM).Map(strings.ToUpper).Value())\n```", "```go\nfiltered and mapped (<= MEDIUM and smaller sized words): []string{\"TINY\", \"MARATHON\"}\n```", "```go\n     data = ChainLink{words}\n     fmt.Printf(\"filtered twice and mapped (<= LARGE and smaller sized words): \n     %#vn\",\n          data.Filter(XLARGE).Map(strings.ToUpper).Filter(LARGE).Value())\n```", "```go\nfiltered twice and mapped (<= LARGE and smaller sized words): []string{\"TINY\", \"MARATHON\", \"PHILANTHROPINIST\"}\n```", "```go\n     data = ChainLink{words}\n     val := data.Map(strings.ToUpper).Filter(XXLARGE).Value()\n     fmt.Printf(\"mapped and filtered (<= XXLARGE and smaller sized words): %#vn\", \n     val)\n```", "```go\nmapped and filtered (<= XXLARGE and smaller sized words): []string{\"TINY\", \"MARATHON\", \"PHILANTHROPINIST\", \"SUPERCALIFRAGILISTICEXPIALIDOCIOUS\"}\n```", "```go\n** Constants ***\nZERO: 0\nSMALL: 6\nMEDIUM: 12\nLARGE: 18\nXLARGE: 24\nXXLARGE: 50\n```", "```go\n     fmt.Printf(\"norig_data : %vn\", u.Join(orig_data, SEPARATOR))\n     fmt.Printf(\"data: %vnn\", u.Join(data.Value(), SEPARATOR))\n```", "```go\n orig_data : tiny, marathon, philanthropinist, supercalifragilisticexpialidocious\n data: TINY, MARATHON, PHILANTHROPINIST, SUPERCALIFRAGILISTICEXPIALIDOCIOUS\n```", "```go\npackage main\ntype Car struct {\n     Make string\n     Model string\n}\ntype Cars []*Car\n```", "```go\nfunc (cars Cars) Contains(modelName string) bool {\n     for _, a := range cars {\n            if a.Model == modelName {\n                   return true\n            }\n     }\n     return false\n}\n```", "```go\ntype Object interface{}\ntype Collection []Object\nfunc (list Collection) Contains(e string) bool {\n     for _, t := range list { if t == e { return true } }\n     return false\n}\n```", "```go\nfunc main() {\n     crv := &Car{\"Honda\", \"CRV\"}\n     is250 := &Car{\"Lexus\", \"IS250\"}\n     highlander := &Car{\"Toyota\", \"Highlander\"}\n     cars := Cars{crv, is250, highlander}\n     if cars.Contains(\"Highlander\") {\n            println(\"Found Highlander\")\n     }\n     if !cars.Contains(\"Hummer\") {\n            println(\"Did NOT find a Hummer\")\n     }\n}\n```", "```go\nFound Highlander\nDid NOT find a Hummer\n```", "```go\nfunc Map(f func(v string) bool, vs [] string) []bool {\n     if len(vs) == 0 {\n            return nil\n     }\n     return append(\n            []bool{f(vs[0])},\n            Map(f, vs[1:])...)\n}\n```", "```go\nfunc main() {\n     vowels := map[string]bool{\n            \"a\": true,\n            \"e\": true,\n            \"i\": true,\n            \"o\": true,\n            \"u\": true,\n     }\n     isVowel := func(v string) bool { _, ok := vowels[v]; return ok }\n     letters := []string{\"a\", \"b\", \"c\", \"d\", \"e\"}\n     fmt.Println(Map(isVowel, letters))\n}\n```", "```go\nfunc Map(f func(v <string>) <bool>, vs [] <string>) []<bool> \n```", "```go\npackage main\nimport \"fmt\"\ntype Object interface{}\ntype Collection []Object\nfunc NewCollection(size int) Collection {\n     return make(Collection, size)\n}\n```", "```go\ntype Callback func(current, currentKey, src Object) Object\n```", "```go\nfunc Map(c Collection, cb Callback) Collection {\n     if c == nil {\n          return Collection{}\n     } else if cb == nil {\n          return c\n     }\n     result := NewCollection(len(c))\n     for index, val := range c {\n          result[index] = cb(val, index, c)\n     }\n     return result\n}\n```", "```go\nfunc main() {\n     transformation10 := func(curVal, _, _ Object) Object {\n     return curVal.(int) * 10 }\n     result := Map(Collection{1, 2, 3, 4}, transformation10)\n     fmt.Printf(\"result: %vn\", result)\n```", "```go\nresult: [10 20 30 40]\n```", "```go\n     transformationUpper := func(curVal, _, _ Object) Object { return strings.ToUpper(curVal.(string)) }\n     result = Map(Collection{\"alice\", \"bob\", \"cindy\"}, transformationUpper)\n     fmt.Printf(\"result: %vn\", result)\n}\n```", "```go\nresult: [ALICE BOB CINDY]\n```", "```go\ntype Iter chan interface{}\nfunc New(els ... interface{}) Iter {\n     c := make(Iter)\n     go func () {\n            for _, el := range els {\n                   c <- el\n            }\n            close(c)\n     }()\n     return c\n}\n```", "```go\nNew(3,5,6)\n```", "```go\npackage itertools\nimport (\n     \"testing\"\n     \"reflect\"\n     . \"github.com/yanatan16/itertools\"\n)\n```", "```go\nfunc testIterEq(t *testing.T, it1, it2 Iter) {\n     t.Log(\"Start\")\n     for el1 := range it1 {\n            if el2, ok := <- it2; !ok {\n                   t.Error(\"it2 shorter than it1!\", el1)\n                   return\n            } else if !reflect.DeepEqual(el1, el2) {\n                   t.Error(\"Elements are not equal\", el1, el2)\n            } else {\n                   t.Log(el1, el2)\n            }\n     }\n     if el2, ok := <- it2; ok {\n            t.Error(\"it1 shorter than it2!\", el2)\n     }\n     t.Log(\"Stop\")\n}\n```", "```go\nfunc TestMap(t *testing.T) {\n     mapper := func (i interface{}) interface{} {\n            return len(i.(string))\n     }\n     testIterEq(t, New(3,5,10), Map(mapper, New(\"CRV\", \"IS250\", \"Highlander\")))\n}\n```", "```go\n~/clients/packt/dev/go/src/bitbucket.org/lsheehan/fp-in-go-work/chapter2/itertools $ go test\nPASS\nok bitbucket.org/lsheehan/fp-in-go-work/chapter2/itertools 0.008s\n```", "```go\nlocal ffi = require(\"ffi\")\nLoad LuaJIT's FF library\nffi.cdef[[\nint printf(const char *fmt, ...);\n]]\nAdd a C declaration for the function.\nffi.C.printf(\"Hello %s!\", \"world\")\n```", "```go\n$ cat /etc/paths\n/usr/local/bin\n/usr/bin\n/bin\n/usr/sbin\n/sbin\n```", "```go\npackage main\nimport (\n     \"os\"\n     \"github.com/chrislusf/gleam/flow\"\n)\nfunc main() {\n     flow.New().TextFile(\"/etc/paths\").Partition(2).FlatMap(`\n            function(line)\n                   return line:gmatch(\"%w+\")\n            end\n     `).Map(`\n            function(word)\n                   return word, 1\n            end\n     `).ReduceBy(`\n            function(x, y)\n                   return x + y\n            end\n     `).Fprintf(os.Stdout, \"%s,%dn\").Run()\n}\n```", "```go\nbin,3\nlocal,1\nsbin,2\nusr,3\n```"]