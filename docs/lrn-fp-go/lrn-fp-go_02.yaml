- en: Manipulating Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作集合
- en: Handling lists of items is a common occurrence in life as well as in programming
    languages. When a list has associated functions that help us manipulate the items
    in the list, we often call that object a collection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 处理项目列表在生活中以及编程语言中是常见的。当一个列表有相关的函数帮助我们操作列表中的项目时，我们通常称该对象为集合。
- en: In this chapter, we will see how high-order functions can be used to greatly
    simplify the task of manipulating collections. We'll see how we can code using functional
    programming techniques and open source functional packages to create elegant solutions
    that are not only insightful, but also performant in today's distributed processing
    environments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将看到如何使用高阶函数来极大地简化操作集合的任务。我们将看到如何使用函数式编程技术和开源的函数式包来创建优雅的解决方案，这些解决方案不仅富有洞察力，而且在当今的分布式处理环境中也具有高性能。
- en: 'Our goal in this chapter is to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是：
- en: Iterate through a collection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历集合
- en: Learn about intermediate and terminal functors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解中间和终端函子
- en: Use predicates to filter items in a collection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用谓词来过滤集合中的项目
- en: Test using a Mocha-like BDD library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类似 Mocha 的 BDD 库进行测试
- en: Focus on Map functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于Map函数
- en: Grasp the breadth of the collection-manipulating functions in Itertools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握Itertools中操作集合的函数的广度
- en: Leverage routines and channels to iterate through a collection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用例程和通道来遍历集合
- en: See how we can use Go to process big data collections
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看我们如何使用 Go 处理大数据集合
- en: Iterating through a collection
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历集合
- en: In order to implement a collection, we must provide a way to access each element
    in the collection, which can be accomplished using the int index value shown in
    the following code. We will implement a **first in, first out** (**FIFO**) order
    queue. We will provide a way to store the elements using a slice data structure.
    Lastly, we will implement a `Next()` method to provide a way to traverse the elements
    in the collection.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个集合，我们必须提供一种访问集合中每个元素的方式，可以使用下面代码中显示的 int 索引值来实现。我们将实现一个**先进先出**（**FIFO**）顺序队列。我们将提供一种使用切片数据结构来存储元素的方法。最后，我们将实现一个`Next()`方法来提供一种遍历集合中元素的方式。
- en: 'In the following code, we define an interface for the `Iterator` object. It
    has one method, `Next()`, which will return the next element in the collection
    and a Boolean flag to indicate whether it''s OK to continue iterating:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们为`Iterator`对象定义了一个接口。它有一个`Next()`方法，它将返回集合中的下一个元素和一个布尔标志，指示是否可以继续迭代：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we define a collection object that has two properties: an `int` index
    used to access the current element and a slice of strings, that is, the actual
    data in the collection:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个具有两个属性的集合对象：用于访问当前元素的`int`索引和一个字符串切片，即集合中的实际数据：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we implement the collection''s `Next()` method to meet the `IntIterator`
    interface''s specification:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实现集合的`Next()`方法，以满足`IntIterator`接口的规范：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `newSlice` function is the constructor for the iterable collection `intCollection`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`newSlice`函数是可迭代集合`intCollection`的构造函数：'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, we implement the `main()` function to test our `Collection`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现`main()`函数来测试我们的`Collection`。
- en: 'Let''s open up a terminal window and use the `.init` toolset to run our simple
    Go application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个终端窗口，并使用`.init`工具集来运行我们简单的Go应用程序：
- en: '![](img/a83d65f5-90c5-4260-b7dc-78042af5eb3b.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a83d65f5-90c5-4260-b7dc-78042af5eb3b.png)'
- en: The `. init` ("Dot Init") toolset ensures that we have Go installed and that
    our `GOPATH` and `GOBIN` directories are properly configured. First, we source
    the init script by typing `.init`. Since we have no import statements, there is
    no need to run glide-update. To run our application, we type `go-run`. For more
    details about Dot Init, see the [Appendix](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=99&action=edit#post_7),
    *Miscellaneous Information and How-Tos*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`.init`（"Dot Init"）工具集确保我们已经安装了 Go，并且我们的`GOPATH`和`GOBIN`目录已经正确配置。首先，我们通过输入`.init`来源化初始化脚本。由于我们没有导入语句，因此无需运行glide-update。要运行我们的应用程序，我们输入`go-run`。有关`Dot
    Init`的更多详细信息，请参见[附录](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=99&action=edit#post_7)，*其他信息和操作方法*。'
- en: The problem with this implementation is that we are mixing what we want to do
    with how we do it. We implement an explicit `for` loop to perform the mechanics
    of the iteration. We define and mutate the value of the index value in order to
    traverse the elements. We can immediately see that this is an imperative implementation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的问题在于我们混合了我们想要做的事情和我们如何做的事情。我们实现了一个显式的`for`循环来执行迭代的机制。我们定义并改变了索引值的值，以便遍历元素。我们可以立即看到这是一种命令式的实现。
- en: In functional programming, we declare what to, rather than imperatively implementing
    each detail of each operation. We also avoid the sequential nature of `for` loops,
    which are difficult to fit into a concurrent programming model.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们声明要做什么，而不是命令式地实现每个操作的每个细节。我们还避免了`for`循环的顺序性质，这些循环很难适应并发编程模型。
- en: Go is not a functional programming language, but it has a lot of functional
    features and we can leverage those features to write concise, expressive, and
    hopefully, bug-free code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Go不是一种函数式编程语言，但它具有许多函数式特性，我们可以利用这些特性来编写简洁、表达力强、并且希望是无错误的代码。
- en: A pure functional language does not maintain a state. Function calls are often
    chained, where input is passed from function to function. Each function call transforms
    its input in some way. These functions do not need to be concerned about the external
    state and do not produce side effects. Each function call can be very efficient
    at what it does. This style of programming lends itself to efficient testing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数式语言不维护状态。函数调用经常被链接在一起，其中输入从一个函数传递到另一个函数。每个函数调用以某种方式转换其输入。这些函数不需要关心外部状态，也不会产生副作用。每个函数调用在其所做的事情上都可以非常高效。这种编程风格适合进行高效的测试。
- en: Next, we'll see how function chaining is a lot like piping output through Bash
    commands.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到函数链式调用非常类似于通过Bash命令传递输出。
- en: Piping Bash commands
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bash命令传递
- en: Executing a composition or chain of functions is very much like executing a
    series of Bash commands, where the output from one command is piped into the next
    command. For example, we might cat an input a file that contains a list of timestamps
    and IP addresses in an `awk` command. The `awk` command removes all but the seventh
    column. Next, we sort the list in descending order, and finally, we group that
    data by unique IP addresses.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 执行函数的组合或链非常类似于执行一系列Bash命令，其中一个命令的输出被传送到下一个命令。例如，我们可能在`awk`命令中输入一个包含时间戳和IP地址列表的文件。`awk`命令删除除第七列之外的所有内容。接下来，我们按降序对列表进行排序，最后，我们按唯一的IP地址对数据进行分组。
- en: 'Consider the following Bash command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Bash命令：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s give this command the following input:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给这个命令以下输入：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will get the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a very common pattern in functional programming. We often input a collection
    of data to a function, or chain of function calls, and get a result that has been
    transformed in some way.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数式编程中非常常见的模式。我们经常将数据集输入到函数或一系列函数调用中，并获得以某种方式转换的结果。
- en: Collections are used frequently. When we implement them in a concise manner,
    chaining function calls that explicitly declare what we want to accomplish, we
    greatly reduce code ceremony. The result is that our code is more expressive,
    concise, and easier to read.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 集合经常被使用。当我们以简洁的方式实现它们时，通过链式函数调用明确声明我们想要实现的目标，我们大大减少了代码的繁文缛节。结果是，我们的代码更具表现力、简洁，并且更易于阅读。
- en: Functors
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函子
- en: 'Go has three predeclared/raw data types: `bool`, `string`, numeric (`float`,
    `int64`, and so on). Other data types in Go require type declarations, that is,
    they require we use the `type` keyword. Functions fall in the later category of
    data types along with array, struct, pointer, interface, slice, map, and channel
    types. In Go, functions are first-class data types, which means that can be passed
    around as parameters and returned as values. Functions that can take functions
    as arguments and return functions are called high-order functions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Go有三种预声明/原始数据类型：`bool`、`string`、数值（`float`、`int64`等）。Go中的其他数据类型需要类型声明，也就是说，它们需要我们使用`type`关键字。函数属于后一类数据类型，与数组、结构、指针、接口、切片、映射和通道类型一起。在Go中，函数是头等数据类型，这意味着它们可以作为参数传递并作为值返回。可以接受函数作为参数并返回函数的函数称为高阶函数。
- en: We can write function factories--functions that return functions--and even function
    factory factories. We can also write functions that modify functions or create
    functions for specific purposes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写函数工厂--返回函数的函数--甚至函数工厂工厂。我们还可以编写修改函数或为特定目的创建函数的函数。
- en: '**Functors**: A functor is a collection of `X` variables that can apply a function,
    `f`, over itself to create a collection of `Y`, that is, `f (X) → Y`. (To see
    what we''re talking about here, take a quick look at the *Fingers times 10 functor*
    example in [Chapter 9](../Text/Ch09.xhtml), *Functors, Monoids, and Generics*)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**函子**：函子是一个包含`X`变量的集合，可以将函数`f`应用于自身，以创建一个`Y`的集合，即`f(X) → Y`。（要了解我们在这里谈论的是什么，请快速查看[第9章](../Text/Ch09.xhtml)中的*Fingers
    times 10 functor*示例，*函子、幺半群和泛型*）'
- en: Note that the Prolog software language defines a functor to simply be a function.
    The preceding definition comes from the *Category Theory* influence on functional
    programming. (For more details, see [Chapter 11](../Text/Ch11.xhtml), *Category
    Theory That Applies*.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Prolog软件语言将函子定义为简单的函数。前面的定义来自于函数式编程对*范畴论*的影响。（有关更多详细信息，请参见[第11章](../Text/Ch11.xhtml)，*适用的范畴论*。）
- en: Functions that modify functions
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改函数的函数
- en: Before we explore intermediate and terminal functions lets' clarify the phrase
    *functions that modify functions* using a few examples.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索中间和终端函数之前，让我们通过一些例子澄清短语*修改函数的函数*。
- en: A coding example of functions that modify functions
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数修改函数的编码示例
- en: 'The following is a snippet of the code we might write to build a section of
    a page with two drop down lists, one for makes and the other for models of cars:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可能编写的代码片段，用于构建一个页面部分，其中包含两个下拉列表，一个用于汽车制造商，另一个用于汽车型号：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that each http.Get is a separate API call. Each API call is a partial
    application. In order for renderPage to wait for each call to complete we must
    curry our API calls.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个http.Get都是一个单独的API调用。每个API调用都是部分应用。为了使renderPage等待每个调用完成，我们必须对我们的API调用进行柯里化。
- en: 'Here''s what the resulting HTML might look like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成的HTML可能看起来像：
- en: '![](img/108dc35b-5d2a-48a3-a59f-1dbe93e674d5.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/108dc35b-5d2a-48a3-a59f-1dbe93e674d5.png)'
- en: A visual example of functions that modify functions
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数修改函数的视觉示例
- en: In the previous example we composed part of an HTML web page. In this example,
    let's immerse ourselves into a Railroading world and lay down some train tracks
    using function composition.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们组成了HTML网页的一部分。在这个例子中，让我们沉浸在一个铁路世界中，使用函数组合铺设一些火车轨道。
- en: '![](img/0f10db22-6848-4ac4-b2cc-7b6edc8ff6e5.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f10db22-6848-4ac4-b2cc-7b6edc8ff6e5.png)'
- en: Immersive Railroading World
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 沉浸式铁路世界
- en: The following is our toolbox of reusable components. We modify our world by
    adding items from our toolbox. Thus, our immersive railroading *world* function
    is modified by adding and connecting a bunch of smaller *component* functions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的可重用组件工具箱。我们通过从工具箱中添加项目来修改我们的世界。因此，我们沉浸式铁路*世界*函数通过添加和连接一堆较小的*组件*函数来修改。
- en: '![](img/e9f7d447-6994-47df-8b0d-290b01cdc9a9.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9f7d447-6994-47df-8b0d-290b01cdc9a9.png)'
- en: 'Here''s Christian laying down a railroad switch:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Christian铺设铁路开关的一个例子：
- en: '![](img/b1bf5814-eaad-48aa-a4bb-d26eb1397e7b.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1bf5814-eaad-48aa-a4bb-d26eb1397e7b.png)'
- en: Composition in Mindcraft
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Mindcraft中的组合
- en: We can find the source code for this Immersive Railroad application at [https://github.com/cam72cam/ImmersiveRailroading](https://github.com/cam72cam/ImmersiveRailroading).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[https://github.com/cam72cam/ImmersiveRailroading](https://github.com/cam72cam/ImmersiveRailroading)找到这个Immersive
    Railroad应用的源代码。
- en: 'Minecraft could have chosen to implement their world building UI exclusively
    with FP techniques by currying partial applications, but when we look closer we
    find more of an imperative implementation. Though generics are used:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Minecraft可以选择通过柯里化部分应用来专门使用FP技术实现其世界构建UI，但当我们仔细观察时，我们发现更多的是命令式实现。尽管使用了泛型：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tacit programming
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tacit编程
- en: Tacit programming is a style of programming where function definitions compose
    other functions and combinators manipulate the arguments. A combinator is a higher-order
    function that uses only function application and pre-defined combinators to define
    the result from its arguments. For more details, see the Moses Schonfinkel section
    in [Chapter 11](../Text/Ch11.xhtml), *Category Theory That Applies*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Tacit编程是一种编程风格，其中函数定义组合其他函数，组合器操作参数。组合器是一个高阶函数，它仅使用函数应用程序和预定义的组合器来定义其参数的结果。有关更多详细信息，请参见[第11章](../Text/Ch11.xhtml)中的Moses
    Schonfinkel部分，*适用的范畴论*。
- en: Tacit programming with Unix pipes
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Unix管道的Tacit编程
- en: The following combinators are the functions in the pipeline, for example, `head`,
    `awk`, `grep`, and so on. Each combinator is a function that sends output to standard
    out and reads input from standard in. Note that arguments are not mentioned  in
    the command.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中的以下组合器是函数，例如`head`，`awk`，`grep`等。每个组合器都是一个将输出发送到标准输出并从标准输入读取输入的函数。请注意，命令中没有提到参数。
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Programming CMOS with Unix pipes
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Unix管道编程CMOS
- en: Unix pipes can also be used to model the flow control of NAND gates of a CMOS
    device.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Unix管道也可以用来模拟CMOS设备的NAND门的流程控制。
- en: Assuming nil represents and electron then, `/dev/zero` (aka VSS) provides an
    infinite supply of electrons and `/dev/null` (aka VDD) will consume every electron
    sent to it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设nil代表电子，那么`/dev/zero`（又名VSS）提供了无限的电子供应，`/dev/null`（又名VDD）将消耗发送到它的每个电子。
- en: '![](img/7c08dd33-3219-4653-983f-451d32b33aae.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c08dd33-3219-4653-983f-451d32b33aae.png)'
- en: CMOS NAND gate
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: CMOS NAND门
- en: In our model, the UNIX pipe acts like a wire. When the pipe is connected to
    Vss, its buffer fills up with nil-bytes and the pipe acts like a negatively charged
    metal plate. When it is connected to Vdd, the pipe's buffer is drained, and the
    pipe acts like a positively charged metal plate. Unix pipes are used to model
    flow control in our NAND logic gate.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模型中，UNIX管道就像一根导线。当管道连接到Vss时，其缓冲区填满了空字节，管道就像一个带负电荷的金属板。当它连接到Vdd时，管道的缓冲区被排空，管道就像一个带正电荷的金属板。Unix管道用于模拟我们的NAND逻辑门中的流程控制。
- en: For more details, see [http://www.linusakesson.net/programming/pipelogic/index.php](http://www.linusakesson.net/programming/pipelogic/index.php).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参见[http://www.linusakesson.net/programming/pipelogic/index.php](http://www.linusakesson.net/programming/pipelogic/index.php)。
- en: Tacit programming with FP
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用FP的Tacit编程
- en: We'll use Haskell to demonstrate  a program that sums a list of integers. Both
    will be recursive, the second benefits from **Tail Call Optimization** (**TCO**).
    We would use Go, but currently Go does not support TCO.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Haskell来演示一个对整数列表求和的程序。两者都是递归的，第二个受益于**尾调用优化**（**TCO**）。我们可以使用Go，但目前Go不支持TCO。
- en: We loop over the list of numbers to accumulate the sum. In imperative programming,
    we would use a loop index to store the accumulated sum value. In functional programming,
    we implement loops using recursion where the accumulated sum is passed as a parameter
    to the next recursive call. What would be loop index variables/accumulator variables
    in an imperative language become *parameters* in the tail-recursive version.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们循环遍历数字列表以累积总和。在命令式编程中，我们将使用循环索引来存储累积和值。在函数式编程中，我们使用递归来实现循环，其中累积和作为参数传递给下一个递归调用。在命令式语言中作为循环索引变量/累加器变量的东西在尾递归版本中成为*参数*。
- en: Non-TCO recursive example
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 非TCO递归示例
- en: 'First, we''ll look at the imperative example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看看命令式的例子：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that x:xs means we store the head of the list in x and the rest of the
    list is in xs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，x:xs表示我们将列表的头存储在x中，列表的其余部分存储在xs中。
- en: '![](img/b5312a5a-329b-447d-a3f9-04a86b194eca.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5312a5a-329b-447d-a3f9-04a86b194eca.png)'
- en: Each call to `rSum` needs to get the return value of the recursive call and
    add it to its x parameter before it can return. This means that each function
    must stay on the stack longer than the frame of any function that it calls. We
    had to create four stack frames to sum three numbers. Imagine the amount of RAM
    storage that this implementation will require when we process lists with a lot
    of values. Without TCO the our implementation will require **O**(n) of RAM storage
    space, based on the number of items in the list. (See Big-Oh notation in [Chapter
    10](../Text/Ch10.xhtml), *Monads, Type Classes, and Generics*)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`rSum`都需要获取递归调用的返回值，并将其添加到其x参数中，然后才能返回。这意味着每个函数必须比其调用的任何函数的帧在堆栈上停留更长的时间。我们必须创建四个堆栈帧来对三个数字求和。想象一下，当我们处理具有大量值的列表时，这种实现将需要多少RAM存储空间。没有TCO，我们的实现将需要**O**(n)的RAM存储空间，根据列表中的项目数。（请参阅[第10章](../Text/Ch10.xhtml)中的大O符号表示法，*单子，类型类和泛型*）
- en: TCO recursive example
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: TCO递归示例
- en: In our  tail recursive function, our stack frames do not need to be preserved.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的尾递归函数中，我们的堆栈帧不需要被保留。
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The following diagram illustrates that unlike the previous example (`rSum`), no
    action needs to be taken in the context of a frame after `tSum` makes its recursive
    call. `rSum` created a stack frame for each member of the list. `tSum` only needs
    to create one stack frame, which it reuses.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了与先前的例子（`rSum`）不同，`tSum`在进行递归调用后不需要在帧的上下文中执行任何操作。`rSum`为列表的每个成员创建了一个堆栈帧。`tSum`只需要创建一个堆栈帧，然后重用它。
- en: '![](img/17c37ebf-a4a8-44a3-9a9e-38acf240fe79.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17c37ebf-a4a8-44a3-9a9e-38acf240fe79.png)'
- en: TCO avoids creating a new stack frame when the last call in a recursion is the
    function itself. Go currently does not support TCO. What is the implication? Without
    TCO, we should avoid using recursion to process lists with a lot of elements,
    that is, over a few thousand; Otherwise, our program will likely run out of RAM
    and crash. Why not replace recursive functions with functions that implement imperative
    loops? In other words, what is the importance of recursion in functional programming?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: TCO在递归的最后调用是函数本身时避免创建新的堆栈帧。Go目前不支持TCO。这意味着什么？没有TCO，我们应该避免使用递归来处理具有大量元素的列表，也就是说，超过几千个；否则，我们的程序很可能会耗尽内存并崩溃。为什么不用实现命令式循环的函数替换递归函数？换句话说，递归在函数式编程中的重要性是什么？
- en: The importance of recursion
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归的重要性
- en: First, let's make sure we understand what recursion is. Let's think about how
    we pull apart Russian Dolls.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保我们理解递归是什么。让我们想想如何拆开俄罗斯娃娃。
- en: '![](img/f685a5c3-86ee-4fdf-8ae6-6e6afe872654.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f685a5c3-86ee-4fdf-8ae6-6e6afe872654.png)'
- en: Recursion works like the process of finding the smallest doll. We repeat the
    same process, i.e., pulling apart the doll until we find a doll that is solid.
    Though our problems get smaller, the problem solving process is the same as the
    previous because the structure of the nesting dolls is the same. Each doll is
    a smaller than the previous one. Eventually, we get to a doll that's too small
    to have a doll inside it and we're done. That's the fundamental idea behind recursion.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的工作原理就像寻找最小的娃娃的过程。我们重复相同的过程，即，拆开娃娃，直到找到一个实心的娃娃。虽然我们的问题变得更小，但问题解决的过程与之前相同，因为嵌套娃娃的结构是相同的。每个娃娃都比前一个小。最终，我们找到了一个太小而无法再放置娃娃的娃娃，我们完成了。这就是递归背后的基本思想。
- en: We also need to understand how to to write a tail recursive function because
    that's the kind of recursion that's a candidate for TCO. When our recursive function
    that calls itself as its last action, then we can reuse the stack frame of that
    function. The tSum function in the previous section is an example of tail recursion.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要了解如何编写尾递归函数，因为这是TCO的候选递归类型。当我们的递归函数在最后一个动作调用自身时，我们可以重用该函数的堆栈帧。上一节中的tSum函数就是尾递归的一个例子。
- en: Understanding recursion marks a transition for us from a programmer to a computer
    scientist. Recursion requires some mathematical sophistication to understand,
    but once  we master it we'll find that it opens up a plethora of ways to solve
    important problems.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 理解递归标志着我们从程序员转变为计算机科学家。递归需要一些数学知识来理解，但一旦我们掌握了它，我们会发现它为解决重要问题打开了大量的方式。
- en: A soccer coach would not have his player practice kicking balls down hill to
    a target; that scenario will never occur in a game. Similarly, we will not spend
    a lot of time pursuing recursive implementations in Go.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个足球教练不会让他的球员练习将球踢下山到目标处；这种情况在比赛中永远不会发生。同样，我们也不会花费大量时间追求在Go中的递归实现。
- en: A tail recursive function is the functional form of a loop, and with TCO it
    executes just as efficiently as a loop. Without recursion, we must implement most
    loops using imperative programming techniques. Thus, having TCO in Go would actually
    be more beneficial to FP than Generics. We'll learn more about Generics in [Chapters
    9](../Text/Ch09.xhtml), *Functors, Monoids, and Generics* and [Chapter 10](../Text/Ch10.xhtml),
    *Monads, Type Classes, and Generics*. See the *How to Propose Changes To Go * section
    in the Appendix or jump directly to the discussion regarding adding TCO to Go
    at [https://github.com/golang/go/issues/22624](https://github.com/golang/go/issues/22624).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归函数是循环的函数形式，通过TCO执行效率与循环一样高。没有递归，我们必须使用命令式编程技术来实现大多数循环。因此，在Go中具有TCO实际上对FP比泛型更有益。我们将在[第9章](../Text/Ch09.xhtml)
    *函子、幺半群和泛型*和[第10章](../Text/Ch10.xhtml) *单子、类型类和泛型*中了解更多关于泛型的知识。请参阅附录中的*如何提出对Go的更改*部分，或直接跳转到有关在Go中添加TCO的讨论[https://github.com/golang/go/issues/22624](https://github.com/golang/go/issues/22624)。
- en: Various intermediate and terminal functions
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 各种中间和终端函数
- en: Look at the various intermediate and terminal functions in the following functor
    diagram. They are all functors. When a function, for example, `Map`, is provided
    with a set of values as input, it will apply a transformation on the elements
    and produce output that will be a different set of values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下函子图中的各种中间和终端函数。它们都是函子。例如，当函数`Map`提供一组值作为输入时，它将对元素应用转换，并产生一个不同的值集作为输出。
- en: In functional programming, given the same input, a given function will always
    return the same result set.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，对于相同的输入，给定函数将始终返回相同的结果集。
- en: '![](img/699a2988-487c-40d7-98ba-e99bc371c96a.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/699a2988-487c-40d7-98ba-e99bc371c96a.png)'
- en: In the first row of preceding functors, `Map` and `Sort`, take a collection,
    transform it in some way, and return a collection of equal size.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函子的第一行中，`Map`和`Sort`，接受一个集合，以某种方式对其进行转换，并返回一个相同大小的集合。
- en: In the second row of functors, `Filter` and `GroupBy`, take a collection and
    transform it into another collection of smaller size.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在函子图的第二行中，`Filter`和`GroupBy`，接受一个集合，并将其转换为另一个较小的集合。
- en: In the third row, `Reduce` takes a collection, performs computations over its
    elements, and returns a single result value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行中，`Reduce`接受一个集合，对其元素执行计算，并返回单个结果值。
- en: Reduce example
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少的例子
- en: 'Here''s an implementation for reducing a collection, using the `alediaferia/go-collections`
    package, to find the maximum value:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`alediaferia/go-collections`包来减少集合以找到最大值的实现：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Join` function takes two different collections and combines them into a
    single, larger collection.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join`函数接受两个不同的集合，并将它们合并成一个更大的集合。'
- en: 'There are two basic types of functors in functional programming: intermediate
    functions and terminal functions. They work together to transform the incoming
    collection into either another collection or a single value. Any number of intermediate
    functions can be chained together followed by the terminal function.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中有两种基本类型的函子：中间函数和终端函数。它们一起工作，将传入的集合转换为另一个集合或单个值。任意数量的中间函数可以链接在一起，然后是终端函数。
- en: Intermediate functions
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间函数
- en: Intermediate functions are not evaluated until the terminal function has been
    processed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 中间函数在终端函数被处理之前不会被评估。
- en: '**Lazy evaluation** is an evaluation strategy that delays the processing of
    an intermediate function until its value is required. It can be combined with
    **memoization**, where the evaluation is first cached so that subsequent requests
    for that value return the cached value immediately without reevaluating the expression
    that originally created it.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**惰性评估**是一种延迟处理中间函数的评估策略，直到需要其值为止。它可以与**记忆化**结合使用，其中首先对评估进行缓存，以便对该值的后续请求立即返回缓存的值，而无需重新评估最初创建它的表达式。'
- en: A few of the more popular intermediate functions include `map`, `filter`, and `sort`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更流行的中间函数包括`map`、`filter`和`sort`。
- en: We can create many other high-order functions to process the incoming stream,
    which is often a collection. We'll soon see functional programming libraries that
    provide a plethora of variations of these basic function types.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建许多其他高阶函数来处理传入的流，通常是一个集合。我们很快将看到提供这些基本函数类型各种变体的函数式编程库。
- en: Common intermediate functions
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常见的中间函数
- en: 'Here''s a table that describes some of the more common intermediate functions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个描述一些常见的中间函数的表格：
- en: '| **Function** | **Gleam** | **Preserves type** | **Preserves count** | **Preserves
    order** | **Description** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **Gleam** | **保留类型** | **保留计数** | **保留顺序** | **描述** |'
- en: '| `map` | Yes | No | Yes | Yes | This transforms each element in the list into
    another element in the resulting list of the same size. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `map` | 是 | 否 | 是 | 是 | 这将列表中的每个元素转换为结果列表中大小相同的另一个元素。 |'
- en: '| `filter` | Yes | Yes | No | Yes | This calls a predicate function. If true,
    the current item is skipped and does not end up in the result list. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `filter` | 是 | 是 | 否 | 是 | 这调用一个谓词函数。如果为真，则当前项目将被跳过，不会出现在结果列表中。 |'
- en: '| `sort` | Yes | Yes | Yes | Yes | This orders the result set by a criteria.
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `sort` | 是 | 是 | 是 | 是 | 这按照标准对结果集进行排序。 |'
- en: Map Example
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 映射示例
- en: 'Here''s an example of mapping a collection using the `alediaferia/go-collections`
    package:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`alediaferia/go-collections`包对集合进行映射的示例：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Terminal functions
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 终端函数
- en: Terminal functions are eagerly executed. They execute immediately and once executed,
    they execute all the previous intermediate, lazy functions in the call chain.
    Terminal functions either return a single value or produce a side effect. The
    reduce example, we saw earlier, returns a single value: `1`. The `ForEach` function
    does not return a value but can produce a side effect, such as printing out each
    item. The `Collect`, `Join`, and `GroupBy` functions group items in a collection.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 终端函数会被急切地执行。它们立即执行，一旦执行，它们会执行调用链中的所有先前的中间、惰性函数。终端函数要么返回单个值，要么产生副作用。前面我们看到的reduce示例返回一个单个值：`1`。`ForEach`函数不返回值，但可以产生副作用，比如打印出每个项目。`Collect`、`Join`和`GroupBy`函数将集合中的项目分组。
- en: Common terminal functions
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常见的终端函数
- en: 'Here''s a table that describes some of the more popular terminal functions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个描述一些更流行的终端函数的表格：
- en: '| **Function** | **Gleam** | **Groups items** | **Creates side effects** |
    **Gathers results** | **Description** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **Gleam** | **分组项目** | **创建副作用** | **收集结果** | **描述** |'
- en: '| `Collect`, `Join`, and `GroupBy` | Yes | Yes |  |  | Produce another collection
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Collect`、`Join`和`GroupBy` | 是 | 是 |  |  | 产生另一个集合 |'
- en: '| `ForEach` | Yes |  | Yes |  | Used for processing individual items |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `ForEach` | 是 |  | 是 |  | 用于处理单个项目 |'
- en: '| `Reduce` | Yes |  |  | Yes | Forces the required lazy expressions to fire
    and produce results |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `Reduce` | 是 |  |  | 是 | 强制要求延迟表达式触发并产生结果 |'
- en: Join example
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Join示例
- en: 'The following code shows an example of the `Join()` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`Join()`函数的示例：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: GroupBy example
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: GroupBy示例
- en: 'The following code shows an example of the `GroupBy()` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`GroupBy()`函数的示例：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Reduce example
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Reduce示例
- en: 'Here''s an implementation for reducing a collection, using the `alediaferia/go-collections`
    package, to find the maximum value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`alediaferia/go-collections`包来减少集合以找到最大值的实现：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Predicates
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谓词
- en: We can use predicates to perform operations on input data. Predicates can be
    used to implement many of the functions that we apply to collections to transform
    input data into the result collection or value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用谓词对输入数据执行操作。谓词可用于实现我们应用于集合以将输入数据转换为结果集合或值的许多函数。
- en: The `predicate` function is a function that takes one item as input and returns
    either true or false, based on whether the item satisfies some condition. They
    are often used conditionally to determine whether to apply certain operations
    in the execution chain.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`predicate`函数是一个接受一个项目作为输入并根据项目是否满足某些条件返回true或false的函数。它们通常被条件地使用，以确定是否在执行链中应用某些操作。'
- en: Let's create some predicate functions that we can use to manipulate a collection
    of cars.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些谓词函数，以便我们可以用来操作一组汽车。
- en: 'The `All()` function returns `true` only if all the values in the collection
    satisfy the `predicate` condition:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`All()`函数仅在集合中的所有值都满足`predicate`条件时返回`true`：'
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Any()` function returns `true` as long as any one of the values in the
    collection satisfies the `predicate` condition:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any()`函数只要集合中的任何一个值满足`predicate`条件就返回`true`：'
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Filter()` function returns a new, smaller, or equal-sized collection containing
    all the strings in the collection that satisfy the `predicate` condition:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filter()` 函数返回一个新的、更小的或大小相等的集合，其中包含满足 `predicate` 条件的集合中的所有字符串：'
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Count()` function is a helper function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count()` 函数是一个辅助函数：'
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, let's use a Mocha-like BDD Go testing framework, named `goblin`, to test
    our predicates.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用一个名为 `goblin` 的类似 Mocha 的 BDD Go 测试框架来测试我们的谓词。
- en: 'Declare the package and define the basic imports. We only need to define one
    function. Let''s call it `TestPredicateSucceed`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 声明包并定义基本导入。我们只需要定义一个函数。让我们称之为 `TestPredicateSucceed`：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s wrap all our unit tests with a `Describe` block named `Predicate Tests`,
    where we define the `cars` variable to hold a list of our car models:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个名为 `Predicate Tests` 的 `Describe` 块包装所有我们的单元测试，其中我们定义 `cars` 变量来保存我们的汽车型号列表：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here''s our first test. It starts with a `Describe` block and contains one
    `It` block. Inside our `It` block, we assign our first-class function `bs`, the
    return value of calling the `Any()` function. Our predicate function is the function
    literal that calls the `strings.HasPrefix()` function. The last line of our unit
    test asserts that `bs` is `true`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个测试。它以一个 `Describe` 块开始，并包含一个 `It` 块。在我们的 `It` 块内，我们将我们的一等函数 `bs` 赋值为调用
    `Any()` 函数的返回值。我们的谓词函数是调用 `strings.HasPrefix()` 函数的函数文本。我们的单元测试的最后一行断言 `bs` 是
    `true`：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our next unit test says `Highlander should be High` and asserts that it should
    be true. We pass the `strings.Contains()` function as our predicate to the `Filter()`
    function to return only those items in the list that contain the `High` substring:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个单元测试说 `Highlander should be High` 并断言它应该为真。我们将 `strings.Contains()` 函数作为我们的谓词传递给
    `Filter()` 函数，以仅返回列表中包含 `High` 子字符串的项目：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This test counts the number of cars that contain the `High` substring and asserts
    that the count should be 1:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试计算包含 `High` 子字符串的汽车数量，并断言计数应该为 1：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our last test asserts that not all cars contain the `High` substring:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个测试断言并非所有汽车都包含 `High` 子字符串：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's take a moment to reflect on this implementation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来反思这个实现。
- en: Reflection
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射
- en: 'Our implementation of predicates is performant but restrictive. Take the `Any()`
    function signature, for example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的谓词实现是高效的但是有限制的。以 `Any()` 函数签名为例：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `Any` function only works for slices of `string`. What if we wanted to iterate
    over a tree or map structure? We'd have to write separate functions for each.
    This is a valid argument for requesting Go to support generics. If Go supported
    generics, our implementations would likely require much less code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any` 函数仅适用于 `string` 切片。如果我们想要迭代树或映射结构怎么办？我们将不得不为每个写单独的函数。这是请求 Go 支持泛型的一个有效论点。如果
    Go 支持泛型，我们的实现可能需要的代码量会少得多。'
- en: An alternative implementation could be to use empty interfaces. This would solve
    the problem of having to implement separate functions for each type of data we
    want to handle, given that an empty interface can take on a value of any type.
    To use a value of the `interface{}` type, you must use reflection or type assertion
    or a type switch to determine the type of value, and there will be a performance
    hit for any of those methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种替代实现可以使用空接口。这将解决我们需要为要处理的每种数据类型实现单独的函数的问题，因为空接口可以接受任何类型的值。要使用 `interface{}`
    类型的值，必须使用反射或类型断言或类型开关来确定值的类型，并且任何这些方法都会导致性能损失。
- en: Another alternative implementation could be to use Goroutines and channels.
    Itertools uses empty interfaces, Goroutines, and channels.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种替代实现可以使用 Goroutines 和通道。Itertools 使用空接口、Goroutines 和通道。
- en: The `github.com/ahl5esoft/golang-underscore` is a package that uses a lot of
    reflection and empty interfaces to provide an underscore-like implementation of
    high-order functions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/ahl5esoft/golang-underscore` 是一个使用大量反射和空接口来提供类似下划线的高阶函数实现的包。'
- en: Combinator pattern
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合器模式
- en: Since Go supports passing functions around as values, we can create predicate
    combinators to build more complex predicates from simpler ones.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Go 支持将函数作为值传递，我们可以创建谓词组合器，从更简单的谓词构建更复杂的谓词。
- en: '**Combinator pattern**: Creating systems by combining more primitive functions
    into more complex functions.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合器模式**：通过将更原始的函数组合成更复杂的函数来创建系统。'
- en: We'll dive deeper into the composition and the combinator pattern later in the
    book. Now, let's look a little closer at the `map` and `filter` functions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面更深入地探讨组合和组合器模式。现在，让我们更仔细地看一下 `map` 和 `filter` 函数。
- en: Map and filter
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射和过滤
- en: The next code example demonstrates the use of a few standard intermediate functions: `map`
    and `filter`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码示例演示了几个标准中间函数的使用：`map` 和 `filter`。
- en: The code in this example can be copy/pasted into The Go playground, which is
    a service that takes your Go program, compiles, links, and runs your program with
    the latest version of Go inside a sandbox and then returns the output to the screen.
    You can find it at [https://play.golang.org/](https://play.golang.org/).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的代码可以复制/粘贴到 Go playground 中，这是一个服务，它接受您的 Go 程序，编译，链接，并在沙箱中使用最新版本的 Go 运行您的程序，然后将输出返回到屏幕上。您可以在
    [https://play.golang.org/](https://play.golang.org/) 找到它。
- en: Executable commands must always use `package main`. We can separate each import
    statement on a separate line for readability.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行命令必须始终使用 `package main`。我们可以将每个导入语句分开放在单独的行上以提高可读性。
- en: 'External packages can be referenced using their remote GitHub repository path.
    We can preface long package names with a shorter alias. The `go_utils` package
    can now be referenced with the `u` letter. Note that if we aliased a package name
    with `_`, its exported functions can be referenced directly in our Go code without
    indicating which package it came from:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用其远程 GitHub 存储库路径引用外部包。我们可以用更短的别名前缀长包名。`go_utils` 包现在可以用 `u` 字母引用。请注意，如果我们用
    `_` 给包名取别名，它的导出函数可以直接在我们的 Go 代码中引用，而不需要指示它来自哪个包：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`iota`: A Go identifier used in `const` declarations that represents successive
    untyped integer constants. It is reset to 0 whenever the reserved word `const`
    appears:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`iota`：Go中用于`const`声明的标识符，表示连续的无类型整数常量。每当保留字`const`出现时，它都会重置为0：'
- en: '`const (`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`const (`'
- en: '`   SMALL = iota // 0`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`   SMALL = iota // 0`'
- en: '`   MEDIUM // 1`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`   MEDIUM // 1`'
- en: '`   LARGE // 2`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`   LARGE // 2`'
- en: '`)`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`)`'
- en: We can apply expressions to iota to set increment values greater than `1`. We
    do this as discussed in the next section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对`iota`应用表达式来设置大于`1`的增量值。我们将在下一节中讨论这个问题。
- en: 'Let''s define a type of ints called `WordSize` and use an `iota` expression
    to create an enumeration from our constants. The first `iota` elements are assigned
    values that start at 0 and then increase by 1\. Since we multiplied the `iota` element
    by `6`, the sequence will look like `0`, `6`, `12`, `18`, and so on. We explicitly
    assign the value of `50` to the last element in the enumeration:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个名为`WordSize`的int类型，并使用`iota`表达式从我们的常量中创建一个枚举。前`iota`元素被分配的值从0开始，然后递增1。由于我们将`iota`元素乘以`6`，所以序列看起来像`0`，`6`，`12`，`18`等。我们明确将值`50`分配给枚举中的最后一个元素：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `ChainLink` type allows us to chain function/method calls. It also keeps
    data internal to `ChainLink`, avoiding the side effect of mutated data:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainLink`类型允许我们链接函数/方法调用。它还将数据保持在`ChainLink`内部，避免了数据变异的副作用：'
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `Value()` method will return the value of the referenced element or link
    in the chain:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`Value()`方法将返回链中引用元素或链接的值：'
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s define `stringFunc` as a function type. This first-class method is used
    in the following code as a parameter to the `Map` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`stringFunc`定义为一个函数类型。这个一级方法在以下代码中作为`Map`函数的参数使用：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `Map` function uses `stringFunc` to transform (up-case) each string in
    the slice:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`函数使用`stringFunc`来转换（大写）切片中的每个字符串：'
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This line is worth repeating:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行值得重复：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We execute the `fn()` function parameter against each element in the slice.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对切片中的每个元素执行`fn()`函数参数
- en: 'The `Filter` function uses embedded logic to filter the slice of strings. We
    could have chosen to use a first-class function, but this implementation is faster:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filter`函数使用嵌入逻辑来过滤字符串切片。我们本可以选择使用一级函数，但这个实现更快：'
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: What's wrong, from a pure FP perspective, about our filter function in the preceding
    code?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯函数式的角度来看，前面代码中的过滤函数有什么问题？
- en: We are using an imperative loop
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用命令式循环
- en: We are saving the filtered results to the `Data` field our `ChainLink` structure
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将过滤后的结果保存到`ChainLink`结构中的`Data`字段
- en: Why not use recursion? We discussed this earlier. The short version is that
    until Go gets TCO we need to avoid recursion if our list of elements we're processing
    could be over a few thousand elements.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不使用递归？我们之前讨论过这个问题。简短的版本是，直到Go获得TCO，如果我们正在处理的元素列表可能超过几千个元素，我们需要避免递归。
- en: 'Why are we storing the filtered data rather than returning it? Good question.
    This implementation of the filter function serves as a learning lesson. It shows
    us how we can chain functions in a non-pure FP way. We''ll look at an improved
    filter implementation in the next chapter. Here''s sneak peek:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要存储过滤后的数据而不是返回它呢？好问题。这个过滤函数的实现作为一个学习课程。它向我们展示了如何以非纯函数式的方式链接函数。我们将在下一章中看到一个改进的过滤实现。这里是一个预览：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's display our constants using a here-doc with interpolation. Note that the first
    argument to the `fmt.Printf` statement is our here-doc, `constants`, and the remaining
    arguments are interpolated in `constants`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用插值的方式显示我们的常量。请注意，`fmt.Printf`语句的第一个参数是我们的插值文档`constants`，其余参数被插入到`constants`中。
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output will be as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s initialize `ChainLink` with our slice of words:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们的单词切片初始化`ChainLink`：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output will be as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s filter our list of words:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们过滤我们的单词列表：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output will be as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, let''s apply the `ToUpper` mapping to our small-sized words:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将`ToUpper`映射应用到我们的小型单词上：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output will be as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s apply a `MEDIUM` filter and the `ToUpper` filter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用一个`MEDIUM`过滤器和`ToUpper`过滤器：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output will be as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, let''s apply our `XLARGE` filter and map then `ToUpper`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们应用我们的`XLARGE`过滤器并映射然后`ToUpper`：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output will be as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s apply our `XXLARGE` filter and map with `ToUpper`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们应用我们的`XXLARGE`过滤器并映射`ToUpper`：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output will be as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output will be as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, we use the `Join()` function to join the items in the list to help with
    formatting our output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`Join()`函数来连接列表中的项目，以帮助格式化我们的输出：
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output will be as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s compare our original collection of words with the value that we
    passed through our chain of functions to see whether there were side effects:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们比较我们原始的单词集合与我们通过函数链传递的值，看看是否有副作用：
- en: 'This is what your terminal console should look like:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的终端控制台应该看起来的样子：
- en: '![](img/aed12031-9b10-4174-9691-0b8f3cc23347.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aed12031-9b10-4174-9691-0b8f3cc23347.png)'
- en: Contains
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含
- en: Let's consider another common collection operation: `contains`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个常见的集合操作：`contains`。
- en: In Go, lists of things are often stored in a slice. Wouldn't it be nice if Go
    provided a `contains` method to tell us whether the item we are looking for is
    contained in the slice? Since there is no generic `contains` method for working
    with lists of items in Go, let's implement one to iterate over a collection of
    car objects.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，事物的列表通常存储在切片中。如果Go提供了一个`contains`方法来告诉我们我们正在寻找的项目是否包含在切片中，那不是很好吗？由于Go中没有用于处理项目列表的通用`contains`方法，让我们实现一个来迭代一组汽车对象。
- en: Iterating over a collection of cars
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代一组汽车
- en: 'First, let''s create a `Car` struct that we can use to define the `Cars` collection
    as a slice of `Car`. Later, we''ll create a `Contains()` method to try out on
    our collection:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个`Car`结构，用来定义`Cars`集合作为`Car`切片。稍后，我们将创建一个`Contains()`方法来尝试在我们的集合上使用：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here''s our `Contains()` implementation. `Contains()` is a method for `Cars`.
    It takes a `modelName` string, for example, `Highlander`, and returns `true` if
    it was found in the slice of `Cars`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`Contains()`实现。`Contains()`是`Cars`的一个方法。它接受一个`modelName`字符串，例如`Highlander`，如果在`Cars`的切片中找到了它，就返回`true`：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This seems simple enough to implement, but what happens when we are given a
    list of boats or boxes to iterate over? That's right, we'll have to reimplement
    the `Contains()` method for each one. That's ugly!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎很容易实现，但是当我们得到一个要迭代的船只或箱子列表时会发生什么？没错，我们将不得不为每一个重新实现`Contains()`方法。这太丑陋了！
- en: This is yet another situation where it would be nice to have generics.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个情况，如果有泛型将会很好。
- en: The empty interface
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空接口
- en: 'Another alternative would be to use the empty interface like so:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是这样使用空接口：
- en: '[PRE59]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: However, reflection or typecasting would be required and that would again adversely
    affect the performance.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将需要反射或类型转换，这将再次对性能产生不利影响。
- en: The Contains() method
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Contains()方法
- en: 'Now, let''s exercise our `Contains()` method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来使用我们的`Contains()`方法：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output will be as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE61]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In order to understand how to make the leap from imperative programming to functional
    programming, let's look at pure functional programming languages and how to implement
    high-order functions such as `Map()` that manipulate collections.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何从命令式编程转向函数式编程，让我们看看纯函数式编程语言以及如何实现`Map()`这样的高阶函数来操作集合。
- en: 'With pure functional types, you had a function, `f`, that takes a cube and
    returns a heart, as shown in the following diagram:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯函数类型，你有一个函数`f`，它接受一个立方体并返回一个心形，如下图所示：
- en: '![](img/ee48a5f5-1cf3-4611-9741-d2fcdee1e086.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee48a5f5-1cf3-4611-9741-d2fcdee1e086.png)'
- en: If you pass `f` a list of cubes, you could use `f` to return a list of hearts.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给`f`传递一个立方体列表，你可以使用`f`来返回一个心形列表。
- en: 'In order to implement this in Go, we can replace the cube with a string and
    the heart with a `bool` value:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Go语言中实现这一点，我们可以用一个字符串替换立方体，用一个`bool`值替换心形：
- en: '[PRE62]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'First, we define a map of vowels that we later test for a key without retrieving
    the value, using an underscore in place of the first value:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个元音字母的映射，然后测试一个不检索值的键，使用下划线代替第一个值：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We define `isVowel` to be a literal function that takes a string and returns
    a `bool` result. We define letters to be a slice of strings (`a`, `b`,... `e`)
    and then call our `Map` function, passing our `isVowel` function and the list
    of strings to check.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义`isVowel`为一个取一个字符串并返回一个`bool`结果的文字函数。我们定义letters为一个字符串切片（`a`、`b`、... `e`），然后调用我们的`Map`函数，传递我们的`isVowel`函数和要检查的字符串列表。
- en: 'This works well, but the problem is that we would have to rewrite our logic
    for every data type that we want to use. If we want to check whether a specific
    rune character exists in a list of runes, we would have to write a new `Map` function.
    We would have to be concerned about things such as this: does `len()` work with
    runes like it works with strings? If not, we would have to replace this logic. This
    would include a lot of effort and code, which would perform similar operations
    and would not be good style.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有效，但问题是我们必须为每种数据类型重新编写我们的逻辑。如果我们想要检查一个特定的符文字符是否存在于符文列表中，我们将不得不编写一个新的`Map`函数。我们将不得不关心这样的事情：`len()`是否像它在字符串中那样与符文一起工作？如果不是，我们将不得不替换这个逻辑。这将包括大量的工作和代码，执行类似的操作，这不是一个好的风格。
- en: This is yet another example of why having generics in Go would be a delight.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子，说明了在Go语言中拥有泛型将是一种乐趣。
- en: If Go had generics
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果Go语言有泛型
- en: 'If Go had generics, we could have written a function signature like the following
    to replace strings with runes, and we would not have to rewrite the inner logic:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Go语言有泛型，我们可以编写一个函数签名，用以下内容替换字符串中的符文，而不必重写内部逻辑：
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: However, Go does not have generics, so we can use empty interfaces and reflection
    to achieve the same result.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Go语言没有泛型，所以我们可以使用空接口和反射来实现相同的结果。
- en: Map function
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Map函数
- en: Let's create a `Map` function to transform the contents of a Collection.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`Map`函数来转换集合的内容。
- en: 'First, let''s define `Object` to be the empty interface type and create a `Collection`
    type to be a slice of objects:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义`Object`为空接口类型，并创建一个`Collection`类型作为对象的切片：
- en: '[PRE65]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `NewCollection` function creates a new instance of the collection with
    the given size:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewCollection`函数创建一个给定大小的集合的新实例：'
- en: '[PRE66]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `Callback` type is a first-class function type that returns the calculated
    result:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callback`类型是一个一流函数类型，返回计算结果：'
- en: '[PRE67]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `Map` function returns a new collection where every element is the result
    of calling the `Callback` function.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`函数返回一个新的集合，其中每个元素都是调用`Callback`函数的结果。'
- en: Testing our empty interface-based Map function
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试我们基于空接口的`Map`函数
- en: 'We''ll test our new empty interface-based `Map` function by defining a transformation
    function. This function will multiply every item in the collection by 10:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过定义一个变换函数来测试我们的新的基于空接口的`Map`函数。这个函数将把集合中的每个项目乘以10：
- en: '[PRE68]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We pass a collection of the numbers `1`, `2`, `3`, and `4` as well as the transformation
    function.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了数字`1`、`2`、`3`和`4`的集合以及变换函数。
- en: 'The output will be as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE69]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, let''s pass our `Map` function a collection of strings:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把我们的`Map`函数传递给一个字符串集合：
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This time we pass a collection of strings and transform each by calling `ToUpper`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们传递了一个字符串集合，并通过调用`ToUpper`来转换每个字符串。
- en: 'Here''s the output:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE71]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice how in each case, we had to cast each `curVal`? With `transformation10`,
    we can cast each item in the collection to an `int` variable; with `transformationUpper`,
    we can cast each item to a `string` variable. We could choose to use reflection
    to avoid explicit casting, but that is even worse for performance than casting.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在每种情况下，我们都必须转换每个`curVal`？使用`transformation10`，我们可以将集合中的每个项目转换为一个`int`变量；使用`transformationUpper`，我们可以将每个项目转换为一个`string`变量。我们可以选择使用反射来避免显式转换，但这对性能来说甚至更糟。
- en: As with our earlier example, we could pass the collection to a chain of transformation
    functions to arrive at the result, which could be another collection or a single
    terminal value.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的例子一样，我们可以将集合传递给一系列转换函数，以得到结果，结果可以是另一个集合或单个终端值。
- en: Instead of reinventing the wheel each time, we need another high-order function;
    let's use any one of the number of Go packages available that easily enable the
    functional style of programming in Go.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 不要每次都重新发明轮子，我们需要另一个高阶函数；让我们使用Go中可用的许多包中的任何一个，这些包可以轻松地实现Go中的函数式编程风格。
- en: Itertools
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Itertools
- en: Itertools is a Go package that provides many of the same high-order functions
    from the Python standard library.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Itertools是一个Go包，它提供了与Python标准库中相同的许多高阶函数。
- en: Next, we see the different types of high-order functions provided by Itertools.
    High-order functions provide the vocabulary for the declarative coding style.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到Itertools提供的不同类型的高阶函数。高阶函数为声明性编码风格提供了词汇。
- en: 'Infinite iterator creators:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 无限迭代器创建者：
- en: '`Count(i)`: Infinite count from `i`'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Count(i)`: 从`i`开始的无限计数'
- en: '`Cycle(iter)`: Infinite cycling of `iter` (requires memory)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cycle(iter)`: 对`iter`进行无限循环（需要内存）'
- en: '`Repeat(element [, n])`: Repeat the element `n` times (or infinitely)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Repeat(element [, n])`: 重复元素`n`次（或无限次）'
- en: 'Iterator destroyers:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器销毁者：
- en: '`Reduce(iter, reducer, memo)`: Reduce (or Foldl) across the iterator'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reduce(iter, reducer, memo)`: 在迭代器上进行减少（或Foldl）'
- en: '`List(iter)`: Create a list from the iterator'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List(iter)`: 从迭代器创建一个列表'
- en: 'Iterator modifiers:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器修改器：
- en: '`Chain(iters...)`: Chain together multiple iterators.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chain(iters...)`: 将多个迭代器链接在一起。'
- en: '`DropWhile(predicate, iter)`: Drop elements until predicate(el) == false.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DropWhile(predicate, iter)`: 删除元素，直到predicate(el) == false。'
- en: '`TakeWhile(predicate, iter)`: Take elements until predicate(el) == false.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TakeWhile(predicate, iter)`: 当predicate(el) == false时取元素。'
- en: '`Filter(predicate, iter)`: Filter out elements when predicate(el) == false.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Filter(predicate, iter)`: 当predicate(el) == false时过滤掉元素。'
- en: '`FilterFalse(predicate, iter)`: Filter out elements when predicate(el) == true.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FilterFalse(predicate, iter)`: 当predicate(el) == true时过滤掉元素。'
- en: '`Slice(iter, start[, stop[, step]])`: Drop elements until the start (zero-based
    index). Stop upon stop (exclusive) unless not given. Step is 1 unless given.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slice(iter, start[, stop[, step]])`: 删除元素，直到开始（从零开始的索引）。停止在停止时（独占），除非没有给出。步长为1，除非给出。'
- en: 'More iterator modifiers:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的迭代器修改器：
- en: '`Map(mapper func(interface{}) interface{}, iter)`: Map each element to mapper(el).'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map(mapper func(interface{}) interface{}, iter)`: 将每个元素映射到mapper(el)。'
- en: '`MultiMap(multiMapper func(interface{}...)interface{}, iters...)`: Map all
    the iterators as variadic arguments to `multiMaper(elements...)`; stop at the
    shortest iterator.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiMap(multiMapper func(interface{}...)interface{}, iters...)`: 将所有迭代器作为可变参数映射到`multiMaper(elements...)`；在最短的迭代器处停止。'
- en: '`MultiMapLongest(multiMapper func(interface{}...)interface{}, iters...)`: Same
    as `MultiMap`, except that here you need to stop at the longest iterator. Shorter
    iterators are filled with nil after they are exhausted.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiMapLongest(multiMapper func(interface{}...)interface{}, iters...)`: 与`MultiMap`相同，只是这里需要在最长的迭代器处停止。较短的迭代器在耗尽后填充为nil。'
- en: '`Starmap(multiMapper func(interface{}...)interface{}, iter)`: If `iter` is
    an iterator of `[]interface{}`, then expand it to `multiMapper`.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Starmap(multiMapper func(interface{}...)interface{}, iter)`: 如果`iter`是`[]interface{}`的迭代器，则将其扩展为`multiMapper`。'
- en: '`Zip(iters...)`: Zip multiple iterators together.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zip(iters...)`: 将多个迭代器一起压缩。'
- en: '`ZipLongest(iters...)`: Zip multiple iterators together. Take the longest;
    shorter ones are appended with nil.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZipLongest(iters...)`: 将多个迭代器一起压缩。取最长的；较短的追加为nil。'
- en: '`Tee(iter, n)`: Split an iterator into n equal versions.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tee(iter, n)`: 将迭代器分成n个相等的版本。'
- en: '`Tee2(iter)`: Split an iterator into two equal versions.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tee2(iter)`: 将迭代器分成两个相等的版本。'
- en: Go channels used by the New function
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: New函数使用的Go通道
- en: 'In the `itertools.go` file, we see that the iterator uses Go channels to range
    over each element in the collection:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在`itertools.go`文件中，我们看到迭代器使用Go通道来遍历集合中的每个元素：
- en: '[PRE72]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `New` function can be used as follows to take a list of values and turn
    it into a new iterable collection:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`New`函数可以按以下方式使用，将值列表转换为新的可迭代集合：'
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Testing itertool's Map function
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试itertool的Map函数
- en: 'Let’s test itertool''s `Map` function by passing it a collection of words of
    various lengths and a literal function to operate on each word to return its length:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过传递各种长度的单词集合和一个操作每个单词返回其长度的文字函数来测试itertool的`Map`函数：
- en: '[PRE74]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Let's not forget to run `go get -u github.com/yanatan16/itertools` to download
    the `itertools` package along with its dependencies.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记运行`go get -u github.com/yanatan16/itertools`来下载`itertools`包以及它的依赖项。
- en: Testing iterators for element equality
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试迭代器的元素相等性
- en: 'First, let''s create the `testIterEq` function to test whether two collections
    are equivalent:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建`testIterEq`函数来测试两个集合是否等价：
- en: '[PRE75]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In our test function `TestMap`, we define a `mapper` function literal that
    is passed to our `Map` function to perform the transformation. The `mapper` function
    returns the length of each string passed to it:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试函数`TestMap`中，我们定义了一个`mapper`函数文字，它被传递给我们的`Map`函数来执行转换。`mapper`函数返回传递给它的每个字符串的长度：
- en: '[PRE76]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s go to the directory with this test file and run the following to verify
    that the `Map` function works as we expect. Here''s what my console output looks
    like:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到具有此测试文件的目录，并运行以下内容，以验证`Map`函数是否按我们的期望工作。这是我的控制台输出的样子：
- en: '[PRE77]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Functional  packages
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能包
- en: There are many other Go packages that provide the high-order functions (HOF)
    that we've come to expect when writing declarative code for manipulating collections.
    They typically use empty interfaces and reflection, which have negative performance
    impacts. A well known HOF implementation is  Rob Pike's `Reduce` package (see [https://github.com/robpike/filter](https://github.com/robpike/filter))
    where he states his preference for using for loops and clearly states, *don't
    use this*.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他Go包提供了我们在编写用于操作集合的声明代码时所期望的高阶函数（HOF）。它们通常使用空接口和反射，这对性能有负面影响。一个众所周知的HOF实现是Rob
    Pike的`Reduce`包（参见[https://github.com/robpike/filter](https://github.com/robpike/filter)），他在那里表明了他对使用for循环的偏好，并明确表示，*不要使用这个*。
- en: Another time of reflection
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一次反思
- en: Are we frustrated yet? We learned how to code in a concise, declarative functional
    programming style only to learn that it would probably run too slow to be viable
    in production. We tried various techniques to speed it up, but nothing we've done
    thus far with pure functional programming can match the performance of old-school
    imperative programming.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否感到沮丧了？我们学会了如何以简洁、声明式的函数式编程风格编码，却发现它可能运行得太慢，无法在生产中使用。我们尝试了各种技术来加快速度，但迄今为止，我们所做的一切纯函数式编程都无法与老式的命令式编程的性能相匹敌。
- en: Our goal is to find a way to program using the declarative functional programming
    style in Go with performance numbers that meet or exceed expectations.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到一种在Go中使用声明式函数式编程风格的编程方式，并且性能指标达到或超过预期。
- en: Go is awesome
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go很棒
- en: 'Go is our favorite language for many reasons including:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Go是我们喜欢的语言，原因有很多，包括：
- en: Performance
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Fast and easy deployment
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速且易于部署
- en: Cross-platform support
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台支持
- en: Protected source code
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的源代码
- en: Concurrent processing
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发处理
- en: Go is awesome, but
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go很棒，但是
- en: Since Go was not designed to be a pure functional language and lacks generics,
    we must take a performance hit to force Go into a functional style of programming,
    right? (Keep the faith! There's hope around the corner.)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go并不是为了成为纯函数式语言而设计的，并且缺乏泛型，我们必须承受性能损失，以将Go强制转换为函数式编程风格，对吗？（保持信念！希望就在拐角处。）
- en: We have covered the core principles of implementing and using collections. You
    learned that in functional programming, a single function can take input and return
    a result and transformations to the collection that occurs inside the function.
    You learned that we can compose functions by chaining them together.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了实现和使用集合的核心原则。您学到了在函数式编程中，单个函数可以接受输入并返回结果，并且在函数内部发生的对集合的转换。您学到了我们可以通过将它们链接在一起来组合函数。
- en: If Go had generics that would simplify our implementation task, but more importantly,
    if Go were designed to perform **tail-call optimization** (**TCO**) and other
    performance-boosting optimizations, then it would be an easy decision to choose
    to program in the functional style in Go.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Go具有泛型，那将简化我们的实现任务，但更重要的是，如果Go被设计为执行**尾递归优化**（**TCO**）和其他提高性能的优化，那么选择在Go中以函数式风格编程将是一个容易的决定。
- en: One of Go's best features is its performance, and if we are developing a solution
    that runs on a single server and performance is more important to us than having
    concise, intuitive, and declarative code, then most likely we would not program
    Go in the functional style.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Go最好的特性之一是其性能，如果我们正在开发一个在单个服务器上运行且性能比简洁、直观和声明式代码更重要的解决方案，那么很可能我们不会以函数式风格编程Go。
- en: The cure
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方法
- en: However, if we are looking to implement a distributed computing solution using
    Go, then we're in luck.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要使用Go来实现分布式计算解决方案，那么我们很幸运。
- en: Let's take a quick look at the features of a new Go package for performing distributed
    **MapReduce** for data processing at scale.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下一个新的Go包的特性，用于在规模上进行数据处理的分布式**MapReduce**。
- en: Gleam - distributed MapReduce for Golang
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gleam - 用于Golang的分布式MapReduce
- en: '"First, generics are needed. Of course, we can use reflection. But it is noticeably
    slower, to the point that I do not want to show the performance numbers. Second,
    dynamic remote code execution is also needed if we want to dynamically adjust
    the execution plan. We could pre-build all the execution DAGs first and choose
    one of them during runtime. But it is very limiting. As everyone else here, I
    enjoyed the beauty of Go. How to make it work for big data?"'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: “首先，我们需要泛型。当然，我们可以使用反射。但明显要慢得多，以至于我不想展示性能数字。其次，如果我们想要在运行时动态调整执行计划，还需要动态远程代码执行。我们可以预先构建所有执行DAG，然后在运行时选择其中一个。但这非常有限。和这里的每个人一样，我享受Go的美。如何使其适用于大数据？”
- en: '- Chris Lu'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '- Chris Lu'
- en: That's the right question.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是正确的问题。
- en: Chris resolved the performance issues of reflection and the lack of Generics
    using a scripting language named LuaJIT. Rather than building the entire **directed
    acyclic graph** (**DAG**) and then choosing one branch during runtime, the scripting
    nature of LuaJIT allows dynamic remote code execution, allowing us to dynamically
    adjust the execution plan during runtime.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Chris使用了一个名为LuaJIT的脚本语言来解决反射和泛型缺失的性能问题。与其在运行时构建整个**有向无环图**（**DAG**），然后选择一个分支，不如使用LuaJIT的脚本性质允许动态远程代码执行，允许我们在运行时动态调整执行计划。
- en: LuaJIT's FFI library
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LuaJIT的FFI库
- en: 'LuaJIT''s FFI library makes it easy to call C functions and C data structures
    by parsing C declarations:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: LuaJIT的FFI库通过解析C声明，使调用C函数和C数据结构变得容易：
- en: '[PRE78]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Call the named C function. Simple!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 调用命名的C函数。简单！
- en: Unix pipe tools
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Unix管道工具
- en: Gleam also leverages Unix pipe tools.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Gleam还利用了Unix管道工具。
- en: Gleam = Go + LuaJIT + Unix Pipes
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Gleam = Go + LuaJIT + Unix管道
- en: Let's look at how we can use Gleam to process collections.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Gleam处理集合。
- en: Processing Gleam collections
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理Gleam集合
- en: 'Let''s see how Gleam processes collections. The input we''ll use is a collection
    of lines that comprises words in the `/etc/paths` file:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Gleam如何处理集合。我们将使用的输入是`/etc/paths`文件中包含单词的行集合：
- en: '[PRE79]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Gleam reads the file content as lines and feeds each line into the flow. From
    this, it creates the stream through which the functions `Map` and `Reduce` are
    called to count the number of occurrences of each word:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Gleam将文件内容作为行读取，并将每一行输入到流中。从这里，它创建了一个流，通过这个流调用`Map`和`Reduce`函数来计算每个单词的出现次数：
- en: '[PRE80]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here''s the output of this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE81]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Disappointed? Were you hoping that there was a practical use of pure functional
    programming in pure Go? (Where practical means the performance of using recursion
    is not an issue and where you can write your business logic and control flow logic
    in a declarative style, free from empty interfaces, downcasting/unboxing and those
    noisy if err != nil blocks?) Keep working through the book and you'll find a solution
    in the last unit.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 失望了吗？你是不是希望在纯Go中有纯函数式编程的实际用途？（在这里，实际意味着使用递归的性能不是问题，你可以以声明式风格编写业务逻辑和控制流逻辑，摆脱空接口、向下转型/拆箱和那些繁琐的if
    err != nil代码块？）继续阅读本书，你会在最后一个单元中找到一个解决方案。
- en: Summary
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We manipulate collections constantly in our code. We often start with a list
    of items and need to transform our initial list into another list of different
    items. Sometimes, we want to map our list to another list of equal size. Sometimes,
    we want to group and sort our list. Other times, we need to arrive at a single
    result value.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中不断地操作集合。我们经常从一系列项目开始，需要将我们的初始列表转换为另一个不同项目的列表。有时，我们希望将我们的列表映射到另一个相同大小的列表。有时，我们希望对我们的列表进行分组和排序。其他时候，我们需要得到一个单一的结果值。
- en: In this chapter, we explored the different types (intermediate and terminal)
    of collection functors. We dived into a few key areas of collection manipulation,
    including iterators, the `map` function, the `contains` method, and chaining of
    functions.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了不同类型（中间和终端）的集合函子。我们深入研究了集合操作的几个关键领域，包括迭代器、`map`函数、`contains`方法和函数的链接。
- en: We looked at a few Go packages that provide a cadre of high-order functions
    that we can use in our new functional style of programming.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了一些Go包，它们提供了一系列高阶函数，可以在我们的新函数式编程风格中使用。
- en: We gained an appreciation for Unix pipes and discovered that a new distributed
    processing Go package, named Gleam, leverages pipe to deliver a lightweight Go-based functional
    solution.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Unix管道有了更深的了解，并发现一个名为Gleam的新的分布式处理Go包，利用管道提供了一个基于Go的轻量级函数式解决方案。
- en: In the next chapter, we'll dive deeper into pipelining and see how it can improve
    performance.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨流水线技术，看看它如何提高性能。
