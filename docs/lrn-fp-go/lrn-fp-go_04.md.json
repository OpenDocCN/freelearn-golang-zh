["```go\ntype errorBehavior interface {\n       Retryable() bool\n}\n\nfunc IsRetryable(err error) bool {\n       eb, ok := err.(errorBehavior)\n       return ok && eb.Retryable()\n}\n```", "```go\nval, err := buggyCode()\n// more code\nreturn val, err\n```", "```go\ntype Reader interface {\n   Read(p []byte) (n int, err error)\n}\ntype Writer interface {\n   Write(p []byte) (n int, err error)\n}\n```", "```go\nthree := add(1, 2)\nfunc add1 := + 1\nthree == add1(2)\n```", "```go\npackage car\n\nimport \"fmt\"\n\ntype Car struct {\n   Make string\n   Model string\n}\nfunc (c Car) Tires() int { return 4 }\nfunc (c Car) PrintInfo() {\n   fmt.Printf(\"%v has %d tires\\n\", c, c.Tires())\n}\n```", "```go\ntype CarWithSpare struct {\n   Car\n}\nfunc (o CarWithSpare) Tires() int { return 5 }\n```", "```go\npackage main\n\nimport (\n   . \"car\"\n \"fmt\"\n)\n\nfunc main() {\n   accord := Car{\"Honda\", \"Accord\"}\n   accord.PrintInfo()\n   highlander := CarWithSpare{Car{\"Toyota\", \"Highlander\"}}\n   highlander.PrintInfo()\n   fmt.Printf(\"%v has %d tires\", highlander.Car, highlander.Tires())\n}\n```", "```go\n{Honda Accord} has 4 tires\n{Toyota Highlander} has 4 tires\n{Toyota Highlander} has 5 tires\n```", "```go\nfunc (c CarWithSpare) PrintInfo() {\n   fmt.Printf(\"%v has %d tires\\n\", c, c.Tires())\n}\n```", "```go\n{Honda Accord} has 4 tires\n{Toyota Highlander} has 5 tires\n{Toyota Highlander} has 5 tires\n```", "```go\n{Honda Accord} has 4 tires\n```", "```go\ntype Dividend struct {\n   Val int\n}\nfunc (n Dividend) Divide(divisor int) int {\n   return n.Val/divisor\n}\n\nfunc main() {\n   d := Dividend{2}\n   fmt.Printf(\"%d\", d.Divide(0))\n}\n```", "```go\nPositiveInt :: Int -> Maybe Positive\nPositiveInt n = if (n < 0) then Nothing else Just (Positive n)\n```", "```go\nimport \"theirpkg\"\n\nfunc MyFunction(t *theirpkg.AType)\n\nfunc MyOtherFunction(i theirpkg.AnInterface)\n```", "```go\n198.0.200.105 - - [14/Jan/2014:09:36:51 -0800] \"GET /example.com/music/js/main.js HTTP/1.1\" 200 614 \"http://www.example.com/music/\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36\"\n```", "```go\n$ cat access10k.log | while read line; do echo \"$line\" | awk '{print $7}' | grep \"\\.json\";done | sort | uniq -c | sort -nr\n 234 /example.com/music/data/artist.json\n 232 /example.com/music/data/songs.json\n 227 /example.com/music/data/influencers.json\n  28 /example.com/music-no-links/data/songs.json\n  28 /example.com/music-no-links/data/influencers.json\n  28 /example.com/music-no-links/data/artist.json\n   8 /example.com/music/data/influencers2.json\n```", "```go\nreal 1m3.932s\nuser 0m38.125s\nsys 0m42.863s\n```", "```go\n85733 /example.com/music/data/artist.json\n71938 /example.com/music/data/songs.json\n57837 /example.com/music/data/influencers.json\n17500 /example.com/music-no-links/data/songs.json\n17500 /example.com/music-no-links/data/influencers.json\n```", "```go\nif err != nil {\n   return nil, fmt.Errorf(\"%s:%d: %v\", sourceFile, sourceLine, err)\n}\n```", "```go\nhappy path code\n```", "```go\nadd error checking\n```", "```go\nFP code including error handling\n```", "```go\npackage main\n\nimport (\n       \"fmt\"\n \"errors\"\n \"log\"\n)\nconst DASHES = \"----------------------\"\n\ntype Pond struct {\n       BugSupply       int\n       StrokesRequired int\n}\n```", "```go\ntype StrokeBehavior interface {\n       PaddleFoot(strokeSupply *int)\n}\n\ntype EatBehavior interface {\n       EatBug(strokeSupply *int)\n}\n```", "```go\ntype SurvivalBehaviors interface {\n       StrokeBehavior\n       EatBehavior\n}\n```", "```go\ntype Duck struct{}\n```", "```go\ntype Foot struct{}\nfunc (Foot) PaddleFoot(strokeSupply *int) {\n       fmt.Println(\"- Foot, paddle!\")\n       *strokeSupply--\n}\n```", "```go\ntype Bill struct{}\nfunc (Bill) EatBug(strokeSupply *int) {\n       *strokeSupply++\n       fmt.Println(\"- Bill, eat a bug!\")\n}\n```", "```go\nfunc (Duck) Stroke(s StrokeBehavior, strokeSupply *int, p Pond) (err error) {\n       for i := 0; i < p.StrokesRequired; i++ {\n              if *strokeSupply < p.StrokesRequired - i {\n                     err = errors.New(\"Our duck died!\")\n              }\n              s.PaddleFoot(strokeSupply)\n       }\n       return err\n}\n```", "```go\nfunc (Duck) Eat(e EatBehavior, strokeSupply *int, p Pond) {\n       for i := 0; i < p.BugSupply; i++ {\n              e.EatBug(strokeSupply)\n       }\n}\n```", "```go\nfunc (d Duck) SwimAndEat(se SurvivalBehaviors, strokeSupply *int, ponds []Pond) {\n       for i := range ponds {\n              pond := &ponds[i]\n              err := d.Stroke(se, strokeSupply, *pond)\n              if err != nil {\n                     log.Fatal(err)  // the duck died!\n }\n              d.Eat(se, strokeSupply, *pond)\n       }\n}\n```", "```go\nfunc (Duck) Eat(e EatBehavior, strokeSupply *int, p Pond) {\n       for i := 0; i < p.BugSupply; i++ {\n              e.EatBug(strokeSupply)\n       }\n}\n```", "```go\ntype Foot struct{}\nfunc (Foot) PaddleFoot(strokeSupply *int) {\n       fmt.Println(\"- Foot, paddle!\")\n       *strokeSupply--\n}\n```", "```go\ntype Bill struct{}\nfunc (Bill) EatBug(strokeSupply *int) {\n       *strokeSupply++\n       fmt.Println(\"- Bill, eat a bug!\")\n}\n```", "```go\nfunc (d Duck) SwimAndEat(se SurvivalBehaviors, strokeSupply *int, ponds []Pond) {\n       for i := range ponds {\n              pond := &ponds[i]\n              err := d.Stroke(se, strokeSupply, pond)\n              if err != nil {\n                     log.Fatal(err)  // the duck died!\n }\n              d.Eat(se, strokeSupply, pond)\n       }\n}\n```", "```go\ntype SurvivalBehaviors interface {\n       StrokeBehavior\n       EatBehavior\n}\n```", "```go\ntype BytesReadConn struct {\n   net.Conn\n   BytesRead uint64\n}\n\nfunc (brc *BytesReadConn) Read(p []byte) (int, error) {\n   n, err := brc.Conn.Read(p)\n   brc.BytesRead += uint64(n)\n   return n, err\n}\n```", "```go\nerr := d.Stroke(se, strokeSupply, pond)\nif err != nil {\n       log.Fatal(err)  // the duck died!\n}\n```", "```go\ntype Capabilities struct {\n       StrokeBehavior\n       EatBehavior\n       strokes int\n}\n```", "```go\nfunc main() {\n       var duck Duck\n       capabilities := Capabilities{\n              StrokeBehavior: Foot{},\n              EatBehavior:    Bill{},\n              strokes:        5,\n       }\n```", "```go\nponds := []Pond{\n       {BugSupply: 1, StrokesRequired: 3},\n       {BugSupply: 1, StrokesRequired: 2},\n}\nduck.SwimAndEat(&capabilities, &capabilities.strokes, ponds)\ndisplayDuckStats(&capabilities, ponds)\n```", "```go\nfunc displayDuckStats(c *Capabilities, ponds []Pond) {\n       fmt.Printf(\"%s\\n\", DASHES)\n       fmt.Printf(\"Ponds Processed:\")\n       for _, pond := range ponds {\n              fmt.Printf(\"\\n\\t%+v\", pond)\n       }\n       fmt.Printf(\"\\nStrokes remaining: %+v\\n\", c.strokes)\n       fmt.Printf(\"%s\\n\\n\", DASHES)\n}\n```", "```go\n- Foot, paddle!\n- Foot, paddle!\n- Foot, paddle!\n- Bill, eat a bug!\n- Foot, paddle!\n- Foot, paddle!\n- Bill, eat a bug!\n----------------------\nPonds Processed:\n{BugSupply:1 StrokesRequired:3}\n{BugSupply:1 StrokesRequired:2}\nStrokes remaining: 2\n----------------------\n```", "```go\nponds = []Pond{\n       {BugSupply: 2, StrokesRequired: 3},\n}\nduck.SwimAndEat(&capabilities, &capabilities.strokes, ponds)\ndisplayDuckStats(&capabilities, ponds)\n```", "```go\n- Foot, paddle!\n- Foot, paddle!\n- Foot, paddle!\n\n2017/05/12 19:11:51 Our duck died!\nexit status 1\n```"]