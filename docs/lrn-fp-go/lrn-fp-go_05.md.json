["```go\ntype SurvivalBehaviors interface {\n       StrokeBehavior\n       EatBehavior\n}\n```", "```go\ntype Reader interface {\n       Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n       Write(p []byte) (n int, err error)\n}\n```", "```go\ntype Hash interface {\n       io.Writer\n       Sum(b []byte) []byte\n       Reset()\n       Size() int\n       BlockSize() int\n}\n```", "```go\n// The File interface is implemented by os.File. App specific\n// implementations may add concurrency, caching, stats, fuzzing, etc.\ntype File interface {\n       io.ReaderAt\n       io.WriterAt\n       io.Closer\n       Stat() (os.FileInfo, error)\n       Sync() error\n       Truncate(size int64) error\n}\n```", "```go\n// File is an interface to access the file part of a multipart message.\n// Its contents may be either stored in memory or on disk.\ntype File interface {\n       io.Reader\n       io.ReaderAt\n       io.Seeker\n       io.Closer\n}\n```", "```go\n// Copy copies from src to dst until either EOF is reached\n// on src or an error occurs. It returns the number of bytes\n// copied and the first error encountered while copying, if any.\nfunc Copy(dst Writer, src Reader) (written int64, err error) {\n    return copyBuffer(dst, src, nil)\n}\n```", "```go\n// A LimitedReader reads from R but limits the amount of\n// data returned to just N bytes. Each call to Read\n// updates N to reflect the new amount remaining.\n// Read returns EOF when N <= 0 or when the underlying R returns EOF.\ntype LimitedReader struct {\n   R Reader // underlying reader\n   N int64 // max bytes remaining\n}\n```", "```go\n// MultiReader returns a Reader that's the logical concatenation of\n// the provided input readers. They're read sequentially. Once all\n// inputs have returned EOF, Read will return EOF. If any of the readers\n// return a non-nil, non-EOF error, Read will return that error.\nfunc MultiReader(readers ...Reader) Reader {\n     r := make([]Reader, len(readers))\n     copy(r, readers)\n  return &multiReader{r}\n }\n```", "```go\n// ReadRune reads a single UTF-8 encoded Unicode character\n// and returns the rune and its size in bytes. If no character is\n// available, err will be set.\ntype RuneReader interface {\n     ReadRune() (r rune, size int, err error) }\n```", "```go\n// WriteSeeker is the interface that groups the basic Write and Seek methods.\ntype WriteSeeker interface {\n     Writer\n     Seeker\n }\n```", "```go\n// MultiWriter creates a writer that duplicates its writes to all the\n// provided writers, similar to the Unix tee(1) command.\nfunc MultiWriter(writers ...Writer) Writer {\n     w := make([]Writer, len(writers))\n     copy(w, writers)\n  return &multiWriter{w}\n }\n```", "```go\npackage main\n\nimport (\n       \"io\"\n \"strings\"\n \"os\"\n)\n\ntype titlizeReader struct {\n       src io.Reader\n}\n\nfunc NewTitlizeReader(source io.Reader) *titlizeReader {\n       return &titlizeReader{source}\n}\n```", "```go\ntype Reader interface {\n       Read(p []byte) (n int, err error)\n}\n```", "```go\nfunc (t *titlizeReader) Read(p []byte) (int, error) {\n       count, err := t.src.Read(p)\n       if err != nil {\n              return count, err\n       }\n       for i := 0; i < len(p); i++ {\n              if i == 0 {\n                     if (p[i] >= 't' && p[i] <= 'z') {\n                            p[i] = p[i] - 32\n }\n              } else {\n                     if (p[i] >= 'A' && p[i] <= 'Z') {\n                            p[i] = p[i] + 32\n }\n              }\n       }\n       return count, io.EOF\n}\n```", "```go\nfunc main() {\n       var r io.Reader\n       r = strings.NewReader(\"this IS a tEsT\")\n       r = io.LimitReader(r, 12)\n       r = NewTitlizeReader(r)\n```", "```go\nr := NewTitlizeReader(io.LimitReader(strings.NewReader(\"this IS a tEsT\", 12))\n```", "```go\n        var w io.Writer\n       w = os.Stdout\n       io.Copy(w, r)\n}\n```", "```go\nrequest.Header.Add(\"Authorization\", token)\n```", "```go\ntype Client interface {\n       Do(*http.Request) (*http.Response, error)\n}\n```", "```go\nPick a Product Type:\n(1) Appliance\n(2) Book\n(3) Clothing\n3\n\nPick a Clothing Type:\n(1) Men\n(2) Women\n(3) Children\n2\n```", "```go\npackage main\n\nimport (\n   \"crypto/tls\"\n \"flag\"\n \"fmt\"\n \"io/ioutil\"\n \"log\"\n \"net/http\"\n \"net/url\"\n \"os\"\n \"os/signal\"\n \"time\"\n \"easy_metrics\"\n . \"decorator\"\n)\n\nconst (\n   host = \"127.0.0.1\"\n protocol = \"http://\"\n)\nvar (\n   serverUrl string\n   proxyUrl string\n)\n```", "```go\nfunc init() {\n       serverPort := 3000\n proxyPort := 8080\n flag.IntVar(&serverPort, \"serverPort\", serverPort, \"Server Port\")\n       flag.IntVar(&proxyPort, \"proxyPort\", proxyPort, \"Server Port\")\n       flag.Parse()\n       serverUrl = fmt.Sprintf(\"%s:%d\", host, serverPort)\n       proxyUrl = fmt.Sprintf(\"%s:%d\", host, proxyPort)\n}\n\nSimple Logger\n```", "```go\npackage decorator\n\nimport (\n       \"io\"\n \"log\"\n \"os\"\n)\n\nvar (\n       Debug   *log.Logger\n       Info    *log.Logger\n       Error   *log.Logger\n       InfoHandler io.Writer\n)\n```", "```go\nfunc InitLog(\n       traceFileName string,\n       debugHandler io.Writer,\n       infoHandler io.Writer,\n       errorHandler io.Writer,\n) {\n```", "```go\nInitLog(\"trace-log.txt\", ioutil.Discard, os.Stdout, os.Stderr)\n```", "```go\nInitLog(nil, os.Stdout, os.Stdout, os.Stderr)\n```", "```go\nif len(traceFileName) > 0 {\n      _ = os.Remove(traceFileName)\n      file, err := os.OpenFile(traceFileName,\n      os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0666)\n      if err != nil {\n             log.Fatalf(\"Failed to create log file: %s\", traceFileName)\n      }\n      debugHandler = io.MultiWriter(file, debugHandler)\n      infoHandler = io.MultiWriter(file, infoHandler)\n      errorHandler = io.MultiWriter(file, errorHandler)\n}\n\nInfoHandler = infoHandler\n\nDebug = log.New(debugHandler, \"DEBUG : \",\n        log.Ldate|log.Ltime|log.Lshortfile)\n\nInfo = log.New(infoHandler, \"INFO : \",\n       log.Ltime)\n\nError = log.New(errorHandler, \"ERROR : \",\n        log.Ldate|log.Ltime|log.Lshortfile)\n}\n```", "```go\nfunc main() {\n       InitLog(\"trace-log.txt\", \n              ioutil.Discard, os.Stdout, os.Stderr)\n```", "```go\nInfo.Printf(\"Metrics server listening on %s\", serverUrl)\ngo func() {\n       log.Fatal(easy_metrics.Serve(serverUrl))\n}()\ntime.Sleep(1 * time.Second)\n```", "```go\nreq, err := http.NewRequest(http.MethodGet, protocol + serverUrl, nil)\nif err != nil {\n       log.Fatalln(err)\n}\n```", "```go\nInfo.Printf(\"Proxy listening on %s\", proxyUrl)\nproxyURL, _ := url.Parse(proxyUrl)\ntr := &http.Transport{\n       Proxy: http.ProxyURL(proxyURL),\n       TLSClientConfig: &tls.Config{\n              InsecureSkipVerify: true,\n       },\n}\n```", "```go\ntr.TLSNextProto = make(map[string]func(string, *tls.Conn) http.RoundTripper)\nproxyTimeoutClient := &http.Client{Transport: tr, Timeout: 1 * time.Second}\n```", "```go\nclient := Decorate(proxyTimeoutClient,\n       Authorization(\"mysecretpassword\"),\n       LoadBalancing(RoundRobin(0, \"web01:3000\", \"web02:3000\", \"web03:3000\")),\n       Logging(log.New(InfoHandler, \"client: \", log.Ltime)),\n       FaultTolerance(2, time.Second),\n)\n```", "```go\n127.0.0.1 localhost web01 web02 web03\n```", "```go\njob := &Job{\n       Client:       client,\n       Request:      req,\n       NumRequests:  10,\n       IntervalSecs: 10,\n}\n```", "```go\nstart := time.Now()\njob.Run()\nInfo.Printf(\"\\n>> It took %s\", time.Since(start))\n```", "```go\nINFO  : 12:48:30 Go to http://127.0.0.1:3000/easy-metrics?show=Stats\nInfo.Printf(\"metrics\")\nerr = easy_metrics.DisplayResults(serverUrl)\nif err != nil {\n       log.Fatalln(err)\n}\n```", "```go\n        Info.Printf(\"CTRL+C to exit\")\n       c := make(chan os.Signal, 1)\n       signal.Notify(c, os.Interrupt)\n       <-c\n}\n```", "```go\npackage decorator\n\nimport (\n       \"log\"\n \"net/http\"\n \"sync/atomic\"\n \"time\"\n)\n\ntype Client interface {\n       Do(*http.Request) (*http.Response, error)\n}\n\n// ClientFunc is a function type that implements the client interface.\ntype ClientFunc func(*http.Request) (*http.Response, error)\n\nfunc (f ClientFunc) Do(r *http.Request) (*http.Response, error) {\n       return f(r)\n}\n```", "```go\nvar ratelimitDuration time.Duration\n\nfunc (f ClientFunc) SetRatelimit(duration time.Duration) (error) {\n       ratelimitDuration = duration\n       return nil\n}\n\nfunc (f ClientFunc) GetRatelimit() (time.Duration, error) {\n       return ratelimitDuration, nil\n}\n```", "```go\ntype Decorator func(Client) Client\n```", "```go\nclient := Decorate(proxyTimeoutClient,\n       Authorization(\"mysecretpassword\"),\n       LoadBalancing(RoundRobin(0, \"web01:3000\", \"web02:3000\", \"web03:3000\")),\n       Logging(log.New(InfoHandler, \"client: \", log.Ltime)),\n       FaultTolerance(2, time.Second),\n)\n```", "```go\nr := NewTitlizeReader(io.LimitReader(strings.NewReader(\"this IS a tEsT\", 12))\n```", "```go\nfunc Decorate(c Client, ds ...Decorator) Client {\n       decorated := c\n       for _, decorate := range ds {\n              decorated = decorate(decorated)\n       }\n       return decorated\n}\n```", "```go\nfunc Authorization(token string) Decorator {\n       return Header(\"Authorization\", token)\n}\n\nfunc Header(name, value string) Decorator {\n       return func(c Client) Client {\n              return ClientFunc(func(r *http.Request)(*http.Response, error) {\n                     r.Header.Add(name, value)\n                     return c.Do(r)\n              })\n       }\n}\n```", "```go\nLogging(log.New(InfoHandler, \"client: \", log.Ltime)),\nfunc Logging(l *log.Logger) Decorator {\n       return func(c Client) Client {\n return ClientFunc(func(r *http.Request) (*http.Response, error ) {\n l.Printf(\"%s %s\", r.Method, r.URL)\n return c.Do(r)\n })\n }\n}\n```", "```go\nLoadBalancing(RoundRobin(0, \"web01:3000\", \"web02:3000\", \"web03:3000\")),\n```", "```go\nfunc RoundRobin(robin int64, backends ...string) Director {\n       return func(r *http.Request) {\n if len(backends) > 0 {\n r.URL.Host = backends[atomic.AddInt64(&robin, 1) % int64(len(backends))]\n }\n }\n}\n```", "```go\nfunc LoadBalancing(dir Director) Decorator {\n       return func(c Client) Client {\n return ClientFunc(func(r *http.Request)(*http.Response, error) {\n dir(r)\n return c.Do(r)\n })\n }\n}\n```", "```go\ntype Director func(*http.Request)\n```", "```go\nfunc FaultTolerance(attempts int, backoff time.Duration) Decorator {\n       return func(c Client) Client {\n return ClientFunc(func(r *http.Request) (*http.Response, error) {\n var res *http.Response\n var err error\n for i := 0; i <= attempts; i++ {\n if res, err = c.Do(r); err == nil {\n Info.Println(\"SUCCESS!\")\n break\n }\n Debug.Println(\"backing off...\")\n time.Sleep(backoff * time.Duration(i))\n }\n if err != nil { Info.Println(\"FAILURE!\") }\n return res, err\n })\n }\n}\n```", "```go\nINFO : 13:46:19 Metrics server listening on 127.0.0.1:3000\nINFO : 13:46:20 Proxy listening on 127.0.0.1:8080\nDEBUG : 2017/05/17 13:46:30 requester.go:114: makeRequest:\nclient: 13:46:30 GET http://127.0.0.1:3000\nDEBUG : 2017/05/17 13:46:30 metrics.go:66: - randInt: 3081\nDEBUG : 2017/05/17 13:46:31 decorator.go:107: backing off...\nclient: 13:46:31 GET http://web02:3000\nDEBUG : 2017/05/17 13:46:31 metrics.go:66: - randInt: 2887\nDEBUG : 2017/05/17 13:46:32 decorator.go:107: backing off...\nclient: 13:46:33 GET http://web03:3000\nDEBUG : 2017/05/17 13:46:33 metrics.go:66: - randInt: 1847\nDEBUG : 2017/05/17 13:46:34 decorator.go:107: backing off...\nINFO : 13:46:36 FAILURE! \n```", "```go\nFaultTolerance(2, time.Second),\n```", "```go\nfunc FaultTolerance(attempts int, backoff time.Duration) Decorator\n   . . .\n       for i := 0; i <= attempts; i++ {\n              if res, err = c.Do(r); err == nil {\n                     Info.Println(\"SUCCESS!\")\n                     break\n }\n              Debug.Println(\"backing off...\")\n              time.Sleep(backoff * time.Duration(i))\n       }\n       if err != nil { Info.Println(\"FAILURE!\") }\n       return res, err\n   . . .\n```", "```go\nfunc work() {\n       randInt := rand.Intn(5000)\n       decorator.Debug.Printf(\"- randInt: %v\", randInt)\n       workTime := time.Duration(randInt) * time.Millisecond\n time.Sleep(workTime)\n}\n```", "```go\nproxyTimeoutClient := &http.Client{Transport: tr, Timeout: 1 * time.Second}\n```", "```go\nDEBUG : 2017/05/17 13:47:30 requester.go:114: makeRequest:\nclient: 13:47:30 GET http://web03:3000\nDEBUG : 2017/05/17 13:47:30 metrics.go:66: - randInt: 1445\nDEBUG : 2017/05/17 13:47:31 decorator.go:107: backing off...\nclient: 13:47:31 GET http://web01:3000\nDEBUG : 2017/05/17 13:47:31 metrics.go:66: - randInt: 3237\nDEBUG : 2017/05/17 13:47:32 decorator.go:107: backing off...\nclient: 13:47:33 GET http://web02:3000\nDEBUG : 2017/05/17 13:47:33 metrics.go:66: - randInt: 4106\nDEBUG : 2017/05/17 13:47:34 decorator.go:107: backing off...\nINFO : 13:47:36 FAILURE!\nDEBUG : 2017/05/17 13:47:36 requester.go:65: > 7 requests done.\nDEBUG : 2017/05/17 13:47:40 requester.go:114: makeRequest:\nclient: 13:47:40 GET http://web03:3000\nDEBUG : 2017/05/17 13:47:40 metrics.go:66: - randInt: 495\nINFO : 13:47:41 SUCCESS!\nDEBUG : 2017/05/17 13:47:41 requester.go:65: > 8 requests done.\n```", "```go\npackage decorator\n\nimport (\n       \"io\"\n \"io/ioutil\"\n \"net/http\"\n \"os\"\n \"os/signal\"\n \"sync\"\n \"syscall\"\n \"time\"\n)\n\ntype response struct {\n       duration      time.Duration\n       err           error\n}\n```", "```go\ntype Job struct {\n       Client       Client\n       NumRequests  int\n       Request      *http.Request\n       IntervalSecs int\n       responseChan chan *response\n}\n```", "```go\njob := &Job{\n       Client:       client,\n       Request:      req,\n       NumRequests:  10,\n       IntervalSecs: 10,\n}\n```", "```go\nfunc (b *Job) displayProgress(stopChan chan struct{}) {\n       var prevResponseCount int\n       for {\n              select {\n              case <-time.Tick(time.Millisecond * 500):\n                     responseCount := len(b.responseChan)\n                     if prevResponseCount < responseCount {\n                            prevResponseCount = responseCount\n                            Debug.Printf(\"> %d requests done.\", responseCount)\n                     }\n              case <-stopChan:\n                     return\n }\n       }\n}\n```", "```go\nDEBUG : 2017/05/17 19:04:36 requestor.go:38: > 3 requests done.\n```", "```go\nfunc (j *Job) Run() {\n       j.responseChan = make(chan *response, j.NumRequests)\n       stopChan := make(chan struct{})\n       go j.displayProgress(stopChan)\n```", "```go\ninterruptChan := make(chan os.Signal, 1)\nsignal.Notify(interruptChan, os.Interrupt, syscall.SIGTERM)\ngo func() {\n       <-interruptChan\n       stopChan <- struct{}{}\n       close(j.responseChan)\n       os.Exit(130)\n}()\n```", "```go\nvar wg sync.WaitGroup\nintervalSecs := time.Duration(j.IntervalSecs)\nrequestsPerformed := 0\nfor range time.Tick(intervalSecs * time.Second)  {\n       wg.Add(1)\n       go func() {\n              client := j.Client\n              j.makeRequest(client)\n              wg.Done()\n       }()\n       requestsPerformed++\n       if requestsPerformed >= j.NumRequests {\n              break\n }\n}\nwg.Wait()\n```", "```go\n        stopChan <- struct{}{}\n       Debug.Printf(\"All requests done.\")\n       close(j.responseChan)\n}\n```", "```go\ngo func() {\n       client := j.Client\n       j.makeRequest(client)\n       wg.Done()\n}()\n```", "```go\nfunc (j *Job) makeRequest(c Client) {\n       Debug.Printf(\"makeRequest: \")\n       start := time.Now()\n       resp, err := c.Do(j.Request)\n       if err == nil {\n              io.Copy(ioutil.Discard, resp.Body)\n              resp.Body.Close()\n       }\n       t := time.Now()\n       finish := t.Sub(start)\n       j.responseChan <- &response{\n              duration:   finish,\n              err:        err,\n       }\n}\n```", "```go\nclient := Decorate(proxyTimeoutClient,\n       Authorization(\"mysecretpassword\"),\n       LoadBalancing(RoundRobin(0, \"web01:3000\", \"web02:3000\", \"web03:3000\")),\n       Logging(log.New(InfoHandler, \"client: \", log.Ltime)),\n       FaultTolerance(2, time.Second),\n)\n```", "```go\ntype Client interface {\n       Do(*http.Request) (*http.Response, error)\n}\n```", "```go\nresp, err := c.Do(j.Request)\n```"]