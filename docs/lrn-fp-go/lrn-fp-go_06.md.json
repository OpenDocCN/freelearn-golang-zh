["```go\npackage packageb\n\nfunc Btask() {\n   println(\"B\")\n}\n```", "```go\n// dependency-rule-good/src/packageb/featureb.go\n\npackage packagea\n\nimport b \"packageb\"\n\nfunc Atask() {\n   println(\"A\")\n   b.Btask()\n}\n```", "```go\n// dependency-rule-good/main.go\n\npackage main\n\nimport a \"packagea\"\n\nfunc main() {\n   a.Atask()\n}\n```", "```go\nA\nB\n```", "```go\n// circulardep/src/packageb/featureb.go\n\npackage packageb\n\nimport a \"packagea\"\n\nfunc Btask() {\n   println(\"B\")\n   a.Atask()\n}\n```", "```go\npackage packagea\n\nimport b \"packageb\"\n\nfunc Atask() {\n   println(\"A\")\n   b.Btask()\n}\n```", "```go\npackage main\n\nimport a \"packagea\"\n\nfunc main() {\n   a.Atask()\n}\n```", "```go\nimport cycle not allowed\npackage main\nimports packagea\nimports packageb\nimports packagea\n```", "```go\ntype StrokeBehavior interface {\n       PaddleFoot(strokeSupply *int)\n}\n\ntype EatBehavior interface {\n       EatBug(strokeSupply *int)\n}\n```", "```go\ntype GcpHandler interface {\n   ListBuckets(flowType domain.FlowType, projectId string) (buckets []domain.Bucket, err error)\n   FileExists(fileName string) (fileExists bool, err error)\n   DownloadFile(fileName string) (success bool, err error)\n   UploadFile(fileName string) (success bool, err error)\n}\n```", "```go\n//main.go\n\npackage main\n\nimport (\n   . \"observer\"\n)\n\nfunc main() {\n\n   subject := Subject{}\n   oa := Observable{Name: \"A\"}\n   ob := Observable{Name: \"B\"}\n   subject.AddObserver(&Observer{})\n   subject.NotifyObservers(oa, ob)\n\n   oc := Observable{Name: \"C\"}\n   subject.NotifyObservers(oa, ob, oc)\n\n   subject.DeleteObserver(&Observer{})\n   subject.NotifyObservers(oa, ob, oc)\n\n   od := Observable{Name: \"D\"}\n   subject.NotifyObservers(oa, ob, oc, od)\n}\n```", "```go\n// src/observer.go\n\npackage observer\n\ntype Observable struct {\n   Name string\n}\n\ntype Observer struct {\n}\n\nfunc (ob *Observer) Notify(o *Observable) {\n   println(o.Name)\n}\n\ntype Callback interface {\n   Notify(o *Observable)\n}\n```", "```go\n// src/subject.go\n\npackage observer\n\ntype Subject struct {\n   callbacks []Callback\n}\n\nfunc (o *Subject) AddObserver(c Callback) {\n   o.callbacks = append(o.callbacks, c)\n}\nfunc (o *Subject) DeleteObserver(c Callback) {\n   o.callbacks = append(o.callbacks, c)\n\n   newCallbacks := []Callback{}\n   for _, cb := range o.callbacks {\n      if cb != c {\n         newCallbacks = append(newCallbacks, cb)\n      }\n   }\n   o.callbacks = newCallbacks\n}\n\nfunc (o *Subject) NotifyObservers(oes ...Observable) {\n   for _, oe := range oes {\n      for _, c := range o.callbacks {\n         c.Notify(&oe)\n      }\n   }\n}\n```", "```go\nA\nB\nA\nB\nC\n```", "```go\n\u251c\u2500\u2500 downloads\n\u251c\u2500\u2500 keys\n\u2502   \u2514\u2500\u2500 google-cloud-storage\n\u251c\u2500\u2500 pkg\n\u2502   \u2514\u2500\u2500 darwin_amd64\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 domain\n\u2502   \u251c\u2500\u2500 infrastructure\n\u2502   \u251c\u2500\u2500 interfaces\n\u2502   \u251c\u2500\u2500 usecases\n\u2502   \u2514\u2500\u2500 utils\n\u2514\u2500\u2500 vendors\n    \u251c\u2500\u2500 pkg\n    \u2514\u2500\u2500 src\n```", "```go\nfunc init() {\n   GetOptions()\n   if Config.LogDebugInfo {\n      InitLog(\"trace-debug-log.txt\", os.Stdout, os.Stdout, os.Stderr)\n   } else {\n      InitLog(\"trace-log.txt\", ioutil.Discard, os.Stdout, os.Stderr)\n   }\n   // use a filename in a downloads subdirectory\n fileName = os.Getenv(\"TEST_FILENAME\")\n   if len(fileName) == 0 {\n      fileName = defaultFileName // CloudflareLogFilename(time.Now())\n }\n   // . . .\n   HandlePanic(os.Chdir(Config.ProjectRoot))\n}\n```", "```go\nfunc HandlePanic(err error) {\n   if err != nil {\n      _, filePath, lineNo, _ := runtime.Caller(1)\n      _, fileName := path.Split(filePath)\n      msg := fmt.Sprintf(\"[file:%s line:%d]: %s\", fileName, lineNo, err.Error())\n      panic(msg)\n   }\n}\n```", "```go\nimport . \"utils\"\n```", "```go\nfunc main() {\n   gcpi, err := infrastructure.GetGcpInteractor()\n   HandlePanic(errors.Wrap(err, \"unable to get gcp interactor\"))\n   li, err := infrastructure.GetLocalInteractor()\n   HandlePanic(errors.Wrap(err, \"unable to get local interactor\"))\n\n   wsh = WebserviceHandler{}\n   wsh.GcpInteractor = gcpi\n   wsh.LocalInteractor = li\n```", "```go\ntype (\n   HostProvider int\n   FlowType  int\n)\n\ntype CloudStorage struct {\n   HostProvider HostProvider //Host location for log files, e.g., google cloud bucket\n ProjectId    string       //Project Id for this GCP storage account\n FlowType     FlowType     //source or sink\n}\n\ntype LocalRepository interface {\n   FileExists(fileName string) (fileExists bool, err error)\n}\n\ntype BucketRepository interface {\n   List(projectId string) (buckets []Bucket, err error)\n   FileExists(fileName string) (fileExists bool, err error)\n   DownloadFile(fileName string) (success bool, err error)\n   UploadFile(fileName string) (success bool, err error)\n}\n\ntype FileRepository interface {\n   Store(file File)\n   FindById(id int) File\n}\n\ntype Bucket struct {\n   Name    string `json:\"name\"`\n}\ntype Buckets struct {\n   Buckets []Bucket `json:\"buckets\"`\n}\n```", "```go\n// downloads/eventset1.jsonl\n\n{\"eventId\":1000,\"timestamp\":1500321544026000125,\"description\":\"something bad happened\",\"userId\":997776,\"country\":\"AF\",\"deviceType\":\"UD10\",\"ip\":\"19.123.3.22\",\"srcPort\":80}{\"eventId\":1001,\"timestamp\":1500321544026000126,\"description\":\"something pretty bad happened\",\"userId\":429444,\"country\":\"AL\",\"deviceType\":\"KG90\",\"ip\":\"44.74.43.30\",\"srcPort\":80}{\"eventId\":1002,\"timestamp\":1500321544026000127,\"description\":\"something super bad happened\",\"userId\":458696,\"country\":\"NZ\",\"deviceType\":\"VM30\",\"ip\":\"101.4.66.210\",\"srcPort\":8000}\n```", "```go\n// domain/log_file.go\n\ntype User struct {\n   UserId int `json:\"userId\"`\n Country string `json:\"country\"`\n DeviceType string `json:\"deviceType\"`\n IP string `json:\"ip\"`\n SrcPort int `json:\"srcPort\"`\n}\n\ntype LogFile struct {\n   EventId     int `json:\"eventId\"`\n Timestamp   int64 `json:\"timestamp\"`\n Description string `json:\"description\"`\n User\n}\n```", "```go\nfunc NewLogFile(logfileJson string) (logFile *LogFile, err error) {\n   err = json.Unmarshal([]byte(logfileJson), &logFile)\n   if err != nil {\n      return nil, errors.Wrap(err, \"unable to unmarshal json\")\n   }\n   return\n}\n```", "```go\nfunc (lf *LogFile) ToJson() (logFileJson string, err error) {\n   logFileBytes, err := json.Marshal(lf)\n   if err != nil {\n      return \"\", errors.Wrap(err, \"unable to marshal json\")\n   }\n   logFileJson = string(logFileBytes)\n   return\n}\n```", "```go\nfunc (lf *LogFile) Write(logFilename, contents string) (err error) {\n   overwrite := true\n flag := os.O_WRONLY | os.O_CREATE\n if overwrite {\n      flag |= os.O_TRUNC\n } else {\n      flag |= os.O_EXCL\n }\n   osFile, err := os.OpenFile(logFilename, flag, 0666)\n   if err != nil {\n      return errors.Wrapf(err, \"unable to open %s\", logFilename)\n   }\n   bytes := []byte(contents)\n   n, err := osFile.Write(bytes)\n   if err == nil && n < len(bytes) {\n      err = io.ErrShortWrite\n      return errors.Wrapf(io.ErrShortWrite, \"not all bytes written for %s\", logFilename)\n   }\n   if err1 := osFile.Close(); err1 != nil {\n      return errors.Wrapf(err, \"unable to close %s\", logFilename)\n   }\n   return\n}\n```", "```go\n// domain/file.go\n\ntype File struct {\n   Id         int\n   Name       string `json:\"name\"`\n ErrorMsg   string `json:\"error\"`\n Contents   LogFile `json:\"logFile\"`\n Bytes      []byte  `json:\"bytes\"`\n}\n```", "```go\ntype CloudFile struct {\n   Name       string `json:\"name\"`\n}\ntype CloudFiles struct {\n   Names       []CloudFile\n}\n\ntype CloudPath struct {\n   Path       string `json:\"path\"`\n}\ntype CloudPaths struct {\n   Paths  []CloudPath\n}\n```", "```go\n// domain/api.go\n\ntype Existence struct {\n   Exists    bool `json:\"exists\"`\n}\n\ntype Outcome struct {\n   Success    bool `json:\"success\"`\n}\n\ntype OutcomeAndMsg struct {\n   Success    bool `json:\"success\"`\n Message    string `json:\"message\"`\n}\n\ntype MultiStatus struct {\n   OutcomeAndMsgs []OutcomeAndMsg\n}\n```", "```go\n// usecases/usecases.go\ntype LocalInteractor struct {\n   LocalRepository domain.LocalRepository\n}\n\nfunc (interactor *LocalInteractor) LocalFileExists(fileName string) (fileExists bool, err error) {\n   return interactor.LocalRepository.FileExists(fileName)\n}\n```", "```go\ntype GcpInteractor struct {\n   SourceBucketRepository domain.BucketRepository\n   SinkBucketRepository domain.BucketRepository\n}\n```", "```go\nfunc (interactor *GcpInteractor) ListSinkBuckets(projectId string) (buckets []domain.Bucket, err error) {\n   return interactor.SinkBucketRepository.List(projectId)\n}\n```", "```go\nfunc (interactor *GcpInteractor) SourceFileExists(fileName string) (fileExists bool, err error) {\n   return interactor.SourceBucketRepository.FileExists(fileName)\n}\n```", "```go\nfunc (interactor *GcpInteractor) DownloadFile(fileName string) (success bool, err error) {\n   return interactor.SourceBucketRepository.DownloadFile(fileName)\n}\n\nfunc (interactor *GcpInteractor) UploadFile(fileName string) (success bool, err error) {\n   return interactor.SinkBucketRepository.UploadFile(fileName)\n}\n```", "```go\n// domain/domain.go\n\ntype BucketRepository interface {\n   List(projectId string) (buckets []Bucket, err error)\n   FileExists(fileName string) (fileExists bool, err error)\n   DownloadFile(fileName string) (success bool, err error)\n   UploadFile(fileName string) (success bool, err error)\n}\n```", "```go\n// interfaces/gcpstorage.go\n\ntype GcpHandler interface {\n   ListBuckets(flowType domain.FlowType, projectId string) (buckets []domain.Bucket, err error)\n   FileExists(fileName string) (fileExists bool, err error)\n   DownloadFile(fileName string) (success bool, err error)\n   UploadFile(fileName string) (success bool, err error)\n}\n// infrastructure/gcphandler.go\nfunc (handler *GcpHandler) FileExists(fileName string) (fileExists bool, err error) {\n   . . .\n   br, err := handler.Client.Bucket(bucketName).Object(fullPath).NewReader(ctx)\n   . . .\n   return true, err\n}\n```", "```go\nfunc main() {\n   gcpi, err := infrastructure.GetGcpInteractor()\n   . . .\n   wsh = WebserviceHandler{}\n   wsh.GcpInteractor = gcpi \n   . . .\n\n    {Api{wsh.SourceFileExists, \"/source-file-exists\"}, \"fileName=\"+fileName}\n```", "```go\n// interfaces/gcpstorage.go\n\ntype GcpHandler interface {\n   ListBuckets(flowType domain.FlowType, projectId string) (buckets []domain.Bucket, err error)\n   FileExists(fileName string) (fileExists bool, err error)\n   DownloadFile(fileName string) (success bool, err error)\n   UploadFile(fileName string) (success bool, err error)\n}\n```", "```go\ntype GcpRepo struct {\n   gcpHandlers map[string]GcpHandler\n   gcpHandler  GcpHandler\n}\n\ntype SourceBucketRepo GcpRepo\ntype SinkBucketRepo GcpRepo\n```", "```go\nfunc NewSourceBucketRepo(gcpHandlers map[string]GcpHandler) *SourceBucketRepo {\n   bucketRepo := new(SourceBucketRepo)\n   bucketRepo.gcpHandlers = gcpHandlers\n   bucketRepo.gcpHandler = gcpHandlers[\"SourceBucketRepo\"]\n   return bucketRepo\n}\n\nfunc (repo *SourceBucketRepo) List(projectId string) (buckets []domain.Bucket, err error) {\n   return repo.gcpHandler.ListBuckets(domain.SourceFlow, projectId)\n}\n\nfunc (repo *SourceBucketRepo) FileExists(fileName string) (fileExists bool, err error) {\n   return repo.gcpHandler.FileExists(fileName)\n}\n\nfunc (repo *SourceBucketRepo) DownloadFile(fileName string) (success bool, err error) {\n   return repo.gcpHandler.DownloadFile(fileName)\n}\n// UploadFile is not operational for a source bucket\nfunc (repo *SourceBucketRepo) UploadFile(fileName string) (success bool, err error) {\n   return false, nil\n}\n```", "```go\nfunc NewSourceBucketRepo(gcpHandlers map[string]GcpHandler) *SourceBucketRepo {\n   return &SourceBucketRepo{\n      gcpHandlers: gcpHandlers,\n      gcpHandler: gcpHandlers[\"SourceBucketRepo\"],\n      }\n}\n```", "```go\nfunc NewSinkBucketRepo(gcpHandlers map[string]GcpHandler) *SinkBucketRepo {\n   return &SinkBucketRepo{\n      gcpHandlers: gcpHandlers,\n      gcpHandler: gcpHandlers[\"SinkBucketRepo\"],\n   }\n}\n\nfunc (repo *SinkBucketRepo) List(projectId string) (buckets []domain.Bucket, err error) {\n   return repo.gcpHandler.ListBuckets(domain.SinkFlow, projectId)\n}\n\nfunc (repo *SinkBucketRepo) FileExists(fileName string) (fileExists bool, err error) {\n   return repo.gcpHandler.FileExists(fileName)\n}\n\nfunc (repo *SinkBucketRepo) DownloadFile(fileName string) (success bool, err error) {\n   return false, nil\n}\n\nfunc (repo *SinkBucketRepo) UploadFile(fileName string) (success bool, err error) {\n   return repo.gcpHandler.UploadFile(fileName)\n}\n\nfunc (repo *SinkBucketRepo) ListFileNamesToFetch(fileName string) (cloudFiles domain.CloudFiles, err error) {\n   return cloudFiles, err\n}\n```", "```go\n// interfaces/localstorage.go\n\ntype LocalHandler interface {\n   FileExists(fileName string) (fileExists bool, err error)\n}\n\nvar FileCache map[string][]string  //slice of json values, one for each LogFile\n\ntype LocalRepo struct {\n   localHandlers map[string]LocalHandler\n   localHandler  LocalHandler\n   fileCache map[string]domain.File\n}\n\ntype LocalFileSystemRepo LocalRepo\n```", "```go\nfunc NewLocalRepo(localHandlers map[string]LocalHandler) *LocalFileSystemRepo {\n   localRepo := new(LocalFileSystemRepo)\n   localRepo.localHandlers = localHandlers\n   localRepo.localHandler = localHandlers[\"LocalFileSystemRepo\"]\n   return localRepo\n}\n```", "```go\nfunc (repo *LocalFileSystemRepo) FileExists(fileName string) (fileExists bool, err error) {\n   return repo.localHandler.FileExists(fileName)\n}\n```", "```go\nvar FileCache map[string][]string  //slice of json values, one for each LogFile\n\n```", "```go\nfunc init() {\n FileCache = make(map[string][]string)\n}\n```", "```go\ntype Api struct {\n   Handler func(res http.ResponseWriter, req *http.Request)\n   Url     string\n}\n```", "```go\ntype endpoint struct {\n   Api\n   uriExample  string\n}\n```", "```go\nvar endpoints = []endpoint{\n   {Api{wsh.Health, \"/health\"}, \"\"},\n   {Api{wsh.ListSourceBuckets, \"/list-source-buckets\"}, \"projectId=\"+Config.GcpSourceProjectId},\n   {Api{wsh.ListSinkBuckets, \"/list-sink-buckets\"}, \"projectId=\"+Config.GcpSinkProjectId},\n   {Api{wsh.SourceFileExists, \"/source-file-exists\"}, \"fileName=\"+fileName},\n   {Api{wsh.DownloadFile, \"/download-file\"}, \"fileName=\"+fileName},\n   {Api{wsh.UploadFile, \"/upload-file\"}, \"fileName=\"+fileName},\n   {Api{wsh.LocalFileExists, \"/local-file-exists\"}, \"fileName=\"+fileName},\n}\n```", "```go\nInfo.Println(\"Example API endpoints:\")\n{\n   for _, ep := range endpoints {\n      http.HandleFunc(ep.Api.Url, ep.Api.Handler)\n      printApiExample(ep.Api.Url, ep.uriExample)\n   }\n}\n```", "```go\nExample API endpoints:\nhttp://localhost:8080/health\nhttp://localhost:8080/list-source-buckets?projectId=rdbx-168418\nhttp://localhost:8080/list-sink-buckets?projectId=rdbx-168418\nhttp://localhost:8080/source-file-exists?fileName=eventset1.jsonl\nhttp://localhost:8080/download-file?fileName=eventset1.jsonl\nhttp://localhost:8080/upload-file?fileName=eventset1.jsonl\nhttp://localhost:8080/local-file-exists?fileName=eventset1.jsonl\nhttp://localhost:8080/get-local-file?fileName=eventset1.jsonl\n```", "```go\ntype LocalInteractor interface {\n   LocalFileExists(fileName string) (fileExists bool, err error)\n}\n```", "```go\ntype GcpInteractor interface {\n   ListSourceBuckets(projectId string) (buckets []domain.Bucket, err error)\n   ListSinkBuckets(projectId string) (buckets []domain.Bucket, err error)\n   SourceFileExists(fileName string) (fileExists bool, err error)\n   DownloadFile(fileName string) (success bool, err error)\n   UploadFile(fileName string) (success bool, err error)\n}\n```", "```go\ntype WebserviceHandler struct {\n   LocalInteractor LocalInteractor\n   GcpInteractor   GcpInteractor\n}\n```", "```go\nfunc (handler WebserviceHandler) Health(res http.ResponseWriter, req *http.Request) {\n   res.WriteHeader(http.StatusOK)\n   res.Header().Set(\"Content-Type\", \"application/json\")\n   io.WriteString(res, `{\"alive\": true}`)\n}\n```", "```go\n$ curl http://localhost:8080/health\n{\"alive\": true}\n```", "```go\n$ curl -s -I http://localhost:8080/health\nHTTP/1.1 200 OK\nDate: Sun, 23 Jul 2017 22:19:03 GMT\nContent-Length: 15\nContent-Type: text/plain; charset=utf-8\n```", "```go\nfunc (handler WebserviceHandler) LocalFileExists(res http.ResponseWriter, req *http.Request) {\n   fileName := req.FormValue(\"fileName\")\n   exists, err := handler.LocalInteractor.LocalFileExists(fileName)\n   handleExists(sf(\"Running LocalFileExists for fileName: %s...\", fileName), \"find file\", req, res, err, exists)\n}\n```", "```go\nfunc (handler WebserviceHandler) SourceFileExists(res http.ResponseWriter, req *http.Request) {\n   fileName := req.FormValue(\"fileName\")\n   exists, err := handler.GcpInteractor.SourceFileExists(fileName)\n   handleExists(sf(\"Running SourceFileExists for fileName: %s...\", fileName), \"file exists\", req, res, err, exists)\n}\n```", "```go\nvar sf = fmt.Sprintf\n```", "```go\nvar ErrorResponse = []byte(\"Error\")\n```", "```go\nfunc getFormat(r *http.Request) (format string) {\n   //format = r.URL.Query()[\"format\"][0]\n // Hard code json for now\n format = \"json\"\n return\n}\n```", "```go\nfunc setFormat(format string, data interface{}) ([]byte, error) {\n   var apiOutput []byte\n   if format == \"json\" {\n      output, err := json.Marshal(data)\n      if err != nil {\n         return nil, errors.Wrap(err, \"unable to marshal data to json\")\n      }\n      apiOutput = output\n   } else {\n      Error.Printf(\"invalid data format encountered\")\n      apiOutput = ErrorResponse\n   }\n   return apiOutput, nil\n}\n```", "```go\nfunc handleSuccess(debugMsg, msg string, req *http.Request, res http.ResponseWriter, err error, success bool) {\n   Debug.Printf(debugMsg)\n   response := domain.Outcome{}\n   response.Success = success\n   if err != nil {\n      Error.Printf(\"Failed to %s. %v\", msg, err)\n   }\n   output, err := setFormat(getFormat(req), response)\n   if err != nil {\n      output = ErrorResponse\n      Error.Printf(\"Failed to setFormat. %v\",  err)\n   }\n   Debug.Printf(\"string(output): %s\", string(output))\n   fmt.Fprintln(res, string(output))\n}\n```", "```go\nfunc (handler WebserviceHandler) SourceFileExists(res http.ResponseWriter, req *http.Request) {\n   fileName := req.FormValue(\"fileName\")\n   exists, err := handler.GcpInteractor.SourceFileExists(fileName)\n   handleExists(sf(\"Running SourceFileExists for fileName: %s...\", fileName), \"file exists\", req, res, err, exists)\n}\n```", "```go\nsf(\"Running SourceFileExists for fileName: %s...\", fileName)\n```", "```go\nvar sf = fmt.Sprintf\n```", "```go\nfunc (interactor *GcpInteractor) SourceFileExists(fileName string) (fileExists bool, err error) {\n   return interactor.SourceBucketRepository.FileExists(fileName)\n}\n```", "```go\nfunc (repo *SourceBucketRepo) FileExists(fileName string) (fileExists bool, err error) {\n   return repo.gcpHandler.FileExists(fileName)\n}\n```", "```go\npackage interfaces_test\n\nimport (\n   . \"interfaces\"\n . \"utils\"\n \"infrastructure\"\n \"github.com/pkg/errors\"\n \"io/ioutil\"\n \"net/http\"\n \"net/http/httptest\"\n \"os\"\n \"strings\"\n \"testing\"\n)\n\nconst failure = \"\\u2717\"\nconst defaultFileName = \"eventset1.jsonl\"\n\nvar fileName               string\nvar wsh                    WebserviceHandler\n```", "```go\nfunc init() {\n   GetOptions()\n   if Config.LogDebugInfoForTests {\n      InitLog(\"trace-debug-log.txt\", os.Stdout, os.Stdout, os.Stderr)\n   } else {\n      InitLog(\"trace-debug-log.txt\", ioutil.Discard, os.Stdout, os.Stderr)\n   }\n   HandlePanic(os.Chdir(Config.ProjectRoot))\n   Debug.Printf(\"Config: %+v\\n\", Config)\n   // use a filename in a downloads subdirectory\n fileName = os.Getenv(\"TEST_FILENAME\")\n   if len(fileName) == 0 {\n      fileName = defaultFileName\n }\n   // instantiate interactors\n gcpi, err := infrastructure.GetGcpInteractor()\n   HandlePanic(errors.Wrap(err, \"unable to get gcp interactor\"))\n   li, err := infrastructure.GetLocalInteractor()\n   HandlePanic(errors.Wrap(err, \"unable to get local interactor\"))\n   // wire up interactors to webservice handler\n wsh = WebserviceHandler{}\n   wsh.GcpInteractor = gcpi\n   wsh.LocalInteractor = li\n}\n```", "```go\ntype endpoint struct {\n   Api\n   expectedBody   string\n}\n```", "```go\nfunc TestEndpoints(t *testing.T) {\n   Debug.Printf(\"fileName: %s\", fileName)\n\n   var endpoints = []endpoint{\n      {Api{wsh.Health, \n         \"/health\"}, \n         `{\"alive\": true}`},\n      {Api{wsh.ListSourceBuckets, \n         \"/list-source-buckets?projectId=\"+Config.GcpSourceProjectId}, \n         `{\"buckets\":[{\"name\":\"my-backup-bucket\"},{\"name\":\"my-source-bucket\"}]}`},\n      {Api{wsh.ListSinkBuckets, \n         \"/list-sink-buckets?projectId=\"+Config.GcpSinkProjectId}, \n         `{\"buckets\":[{\"name\":\"my-backup-bucket\"},{\"name\":\"my-source-bucket\"}]}`},\n      {Api{wsh.SourceFileExists, \n         \"/source-file-exists?fileName=\"+fileName}, \n         `{\"exists\":true}`},\n      {Api{wsh.UploadFile, \n         \"/upload-file?fileName=\"+fileName}, \n         `{\"success\":true}`},\n      {Api{wsh.DownloadFile, \n         \"/download-file?fileName=\"+fileName}, \n         `{\"success\":true}`},\n      {Api{wsh.LocalFileExists, \n         \"/local-file-exists?fileName=\"+fileName}, \n         `{\"exists\":true}`},\n   }\n```", "```go\nt.Log(\"Testing API endpoints...\")\n{\n   for _, ep := range endpoints {\n      {\n         req, err := http.NewRequest(\"GET\", ep.Api.Url, nil)\n         if err != nil {\n            t.Fatal(err)\n         }\n```", "```go\n rr := httptest.NewRecorder()\n            handler := http.HandlerFunc(ep.Api.Handler)\n```", "```go\n handler.ServeHTTP(rr, req)\n            t.Logf(\"\\tChecking \\\"%s\\\" for status code \\\"%d\\\"\",\n               ep.Api.Url, http.StatusOK)\n            if status := rr.Code; status != http.StatusOK {\n               t.Errorf(\"\\t\\t%v handler returned wrong status code: got \n %v want %v\", failure, status, http.StatusOK)\n            }\n```", "```go\n            t.Logf(\"\\tChecking \\\"%s\\\" for expected body\", ep.Api.Url)\n            Debug.Println(\"rr.Body.String(): \", rr.Body.String())\n            if strings.TrimSpace(rr.Body.String()) != ep.expectedBody {\n               t.Errorf(\"\\t\\t%v handler returned unexpected body: got \n %v want %v\", failure, rr.Body.String(), ep.expectedBody)\n            }\n         }\n      }\n   }\n}\n```", "```go\n$ go test interfaces/interfaces_test -config ../../../config.toml\nwebservice_test.go:79: Testing API endpoints...\nwebservice_test.go:93: Checking \"/health\" for status code \"200\"\nwebservice_test.go:98: Checking \"/health\" for expected body\nwebservice_test.go:93: Checking \"/list-source-buckets?projectId=rdbx-168418\" for status code \"200\"\nwebservice_test.go:98: Checking \"/list-source-buckets?projectId=rdbx-168418\" for expected body\nwebservice_test.go:93: Checking \"/list-sink-buckets?projectId=rdbx-168418\" for status code \"200\"\nwebservice_test.go:98: Checking \"/list-sink-buckets?projectId=rdbx-168418\" for expected body\nwebservice_test.go:93: Checking \"/upload-file?fileName=eventset1.jsonl\" for status code \"200\"\nwebservice_test.go:98: Checking \"/upload-file?fileName=eventset1.jsonl\" for expected body\nwebservice_test.go:93: Checking \"/download-file?fileName=eventset1.jsonl\" for status code \"200\"\nwebservice_test.go:98: Checking \"/download-file?fileName=eventset1.jsonl\" for expected body\nwebservice_test.go:93: Checking \"/source-file-exists?fileName=eventset1.jsonl\" for status code \"200\"\nwebservice_test.go:98: Checking \"/source-file-exists?fileName=eventset1.jsonl\" for expected body\nwebservice_test.go:93: Checking \"/local-file-exists?fileName=eventset1.jsonl\" for status code \"200\"\nwebservice_test.go:98: Checking \"/local-file-exists?fileName=eventset1.jsonl\" for expected body\n```", "```go\n$ go test interfaces/interfaces_test -config ../../../config.toml\nFailed to file exists. bucket reader error for source-events/eventset1.jsonl: storage: object doesn't exist\nFailed to upload file. unable to get file (eventset1.jsonl) from bucket(lexttc3-my-source-bucket): storage: object doesn't exist\n--- FAIL: TestEndpoints (1.45s)\nwebservice_test.go:79: Testing API endpoints...\nwebservice_test.go:93: Checking \"/health\" for status code \"200\"\nwebservice_test.go:98: Checking \"/health\" for expected body\nwebservice_test.go:93: Checking \"/list-source-buckets?projectId=rdbx-168418\" for status code \"200\"\nwebservice_test.go:98: Checking \"/list-source-buckets?projectId=rdbx-168418\" for expected body\nwebservice_test.go:93: Checking \"/list-sink-buckets?projectId=rdbx-168418\" for status code \"200\"\nwebservice_test.go:98: Checking \"/list-sink-buckets?projectId=rdbx-168418\" for expected body\nwebservice_test.go:93: Checking \"/source-file-exists?fileName=eventset1.jsonl\" for status code \"200\"\nwebservice_test.go:98: Checking \"/source-file-exists?fileName=eventset1.jsonl\" for expected body\nwebservice_test.go:102: X handler returned unexpected body: got {\"exists\":false}\nwant {\"exists\":true}\nwebservice_test.go:93: Checking \"/upload-file?fileName=eventset1.jsonl\" for status code \"200\"\nwebservice_test.go:98: Checking \"/upload-file?fileName=eventset1.jsonl\" for expected body\nwebservice_test.go:93: Checking \"/download-file?fileName=eventset1.jsonl\" for status code \"200\"\nwebservice_test.go:98: Checking \"/download-file?fileName=eventset1.jsonl\" for expected body\nwebservice_test.go:102: X handler returned unexpected body: got {\"success\":false}\nwant {\"success\":true}\nwebservice_test.go:93: Checking \"/local-file-exists?fileName=eventset1.jsonl\" for status code \"200\"\nwebservice_test.go:98: Checking \"/local-file-exists?fileName=eventset1.jsonl\" for expected body\nFAIL\nFAIL interfaces/interfaces_test 1.475s\n```", "```go\nfunc (handler *GcpHandler) FileExists(fileName string) (fileExists bool, err error) {\n   ctx := context.Background()\n   bucketName := Config.SourceBucketName\n   newFile := domain.NewFile(fileName)\n   fullPath := newFile.FullHostPath(Config.GcpSourceDir)\n```", "```go\n ctx := context.Background()\n . . .\n br, err := handler.Client.Bucket(bucketName).Object(fullPath).NewReader(ctx)\n```", "```go\nif err != nil {\n   return false, errors.Wrapf(err, \"bucket reader error for %s\", fullPath)\n} else {\n```", "```go\n       data, err := ioutil.ReadAll(br)\n      defer br.Close()\n      if err != nil {\n         return false, errors.Wrapf(err, \"ioutil.ReadAll error for %s\", \n         fullPath)\n      } else if len(data) == 0 {\n         return false, errors.Wrapf(err, \"File size must be greater \n than 0 for %s\", fullPath)\n      }\n   }\n   return true, err\n}\n```", "```go\ntype LocalHandler struct {}\n\nvar LocalInteractor *usecases.LocalInteractor\n\nfunc NewLocalHandler() *LocalHandler {\n   gcpHandler := new(LocalHandler)\n   return gcpHandler\n}\n```", "```go\nfunc (handler *LocalHandler) FileExists(fileName string) (fileExists bool, err error) {\n   _, err = os.Stat(fmt.Sprintf(\"%s/%s\", Config.DownloadDir, fileName))\n   if !os.IsNotExist(err) {\n      fileExists = true\n }\n   return\n}\n```", "```go\nfunc GetLocalInteractor() (localInteractor *usecases.LocalInteractor, err error) {\n   if LocalInteractor == nil {\n      localHandler := NewLocalHandler()\n      localHandlers := make(map[string] interfaces.LocalHandler)\n      localHandlers[\"LocalFileSystemRepo\"] = localHandler\n      localInteractor = new(usecases.LocalInteractor)\n      localInteractor.LocalRepository = interfaces.NewLocalRepo(localHandlers)\n      LocalInteractor = localInteractor\n   }\n   return LocalInteractor, nil\n}\n```"]