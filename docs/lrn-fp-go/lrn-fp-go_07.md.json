["```go\n lineItemPrice := quantity * itemPrice;\n discount := getDiscount();\n totalPrice := getDiscountedPrice(lineItemPrice, discount);\n```", "```go\n lineItemPrice := quantity * itemPrice;\n totalPrice := getDiscountedPrice(lineItemPrice);\n```", "```go\nCreateCustomer(fullName, address)\n```", "```go\nCreateCustomer(salutation, firstName, middleName, lastName, suffix, street1, street2, city, state, zip)\n```", "```go\nfunc InitLog (\n   traceFileName string,\n   debugHandler io.Writer,\n   infoHandler io.Writer,\n   errorHandler io.Writer,\n) {\n// . . .\n}\n```", "```go\nfunc printClientConfig(config *ClientConfig) {\n   Info.Printf(\" - security params: %v\", config.SecurityParams)\n   Info.Printf(\" - core limit: %v\", config.CoreLimit)\n   Info.Printf(\" - payload config: %v\", config.PayloadConfig)\n   Info.Printf(\" - channel number: %v\", config.ClientChannels)\n   Info.Printf(\" - load params: %v\", config.LoadParams)\n   // . . .\n```", "```go\nfunc add(x, y int) int {\n   return x + y\n}\n```", "```go\nfunc addOnePartialFn() func(int) int {\n   return func(y int) int {\n      return add(1, y)\n   }\n}\n```", "```go\nfunc main() {\n   fmt.Printf(\"add(1, 2): %d\\n\", add(1, 2))\n   addOne := addOnePartialFn()\n   fmt.Printf(\"addOne(2): %d\\n\", addOne(2))\n}\n```", "```go\nadd(1, 2): 3\naddOne(2): 3\n```", "```go\npackage main\n\nimport (\n   \"server\"\n . \"utils\"\n \"context\"\n \"io/ioutil\"\n \"net/http\"\n \"os\"\n \"os/signal\"\n \"time\"\n \"fmt\"\n)\n\nfunc init() {\n   GetOptions()\n   InitLog(\"trace-log.txt\", ioutil.Discard, os.Stdout, os.Stderr)\n}\n```", "```go\nfunc main() {\n   quit := make(chan os.Signal, 1)\n   signal.Notify(quit, os.Interrupt)\n```", "```go\nnewServer, err := server.New(\n   server.MaxConcurrentConnections(4),\n   server.MaxNumber(256), // Config.MaxNumber\n server.UseNumberHandler(true),\n   server.FormatNumber(func(x int) (string, error) { return fmt.Sprintf(\"%x\", x), nil }), \n //server.FormatNumber(func(x int) (string, error) { return \"\", errors.New(\"FormatNumber error\") }), // anonymous fcn\n)\n```", "```go\nserver.FormatNumber(func(x int) (string, error) { return fmt.Sprintf(\"%x\", x), nil }) \n```", "```go\nif err != nil {\n   Error.Printf(\"unable to initialize server: %v\", err)\n   os.Exit(1)\n}\n```", "```go\nsrv := &http.Server{\n   Addr:    \":\"+Config.Port,\n   Handler: newServer,\n}\n```", "```go\ngo func() {\n   <-quit\n   ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))\n   defer cancel()\n   Info.Println(\"shutting down server...\")\n   if err := srv.Shutdown( ctx ); err != nil {\n      Error.Printf(\"unable to shutdown server: %v\", err)\n   }\n}()\n```", "```go\nError.Println(\"server started at localhost:\"+Config.Port)\nerr = srv.ListenAndServe()\n```", "```go\nInfo.Printf(\"Config %+v\", Config)\n```", "```go\nsignal.Notify(quit, os.Interrupt)\n```", "```go\nfunc httpDo(ctx context.Context, req *http.Request, f func(*http.Response, error) error) error {\n    // Run the HTTP request in a goroutine and pass the response to f.\n    tr := &http.Transport{}\n    client := &http.Client{Transport: tr}\n    c := make(chan error, 1)\n    go func() { c <- f(client.Do(req)) }()\n    select {\n    case <-ctx.Done():\n        tr.CancelRequest(req)\n        <-c // Wait for f to return.\n        return ctx.Err()\n    case err := <-c:\n        return err\n    }\n }\n```", "```go\nfunc Report(ctx context.Context)  {\n   reportName, _ := ctx.Value(\"reportName\").(string)\n   filter, _ := ctx.Value(\"filter\").(string)\n   RunReport(reportName, filter)\n}\n```", "```go\nRunReport(reportName, filter)\n```", "```go\nimport (\n   \"database/sql\"\n \"github.com/pkg/errors\"\n)\n```", "```go\ntype Transaction interface {\n   Commit() error\n   Rollback() error\n}\n```", "```go\ntype TxFunc func(tx Transaction) error\n```", "```go\ntype Dbms struct {\n   db *sql.DB\n}\n```", "```go\nfunc (s Dbms) WithTransaction(fn TxFunc) error {\n   var tx         Transaction\n   var isCommitted bool\n   var err        error\n```", "```go\ntx, err = s.db.Begin()\nif err != nil {\n   return errors.Wrap(err, \"error starting transaction\")\n}\n```", "```go\ndefer func() {\n   if isCommitted != true {\n      tx.Rollback()\n   }\n}()\n```", "```go\nif err = fn(tx); err != nil {\n   return errors.Wrap(err, \"error in TxFunc\")\n}\n```", "```go\n    if err = tx.Commit(); err != nil {\n      return errors.Wrap(err, \"error committing transaction\")\n   }\n   isCommitted = true\n return nil\n}\n```", "```go\npackage server\n\nimport (\n   \"encoding/json\"\n \"fmt\"\n \"github.com/pkg/errors\"\n \"log\"\n \"net/http\"\n \"os\"\n \"strconv\"\n)\n```", "```go\nconst (\n   defaultServerMaxMessageSize = 1024 * 1024 * 4\n defaultMaxNumber = 30\n defaultMaxConcurrentConnections = 2\n)\n\nvar defaultServerOptions = options {\n   maxMessageSize:          defaultServerMaxMessageSize,\n   maxNumber:               defaultMaxNumber,\n   maxConcurrentConnections:  defaultMaxConcurrentConnections,\n}\n```", "```go\ntype Server struct {\n   logger  Logger\n   opts options\n   handler http.Handler\n}\n```", "```go\ntype Logger interface {\n   Printf(format string, v ...interface{})\n}\n```", "```go\nfunc (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n   s.handler.ServeHTTP(w, r)\n}\n```", "```go\nfunc New(opt ...ServerOption) (*Server, error) {\n```", "```go\n   opts := defaultServerOptions\n```", "```go\ntype ServerOption func(*options) error\n```", "```go\n   for _, f := range opt {\n      err := f(&opts)\n      if err != nil {\n         return nil, errors.Wrap(err, \"error setting option\")\n      }\n   }   \n```", "```go\n   s := &Server{\n      opts:  opts,\n      logger: log.New(os.Stdout, \"\", 0),\n   }\n   s.register()\n   return s, nil\n}\n```", "```go\nfunc (s *Server) register() {\n   mux := http.NewServeMux()\n   if s.opts.useNumberHandler {\n      mux.Handle(\"/\", http.HandlerFunc(s.displayNumber))\n   } else {\n      mux.Handle(\"/\", http.FileServer(http.Dir(\"./\")))\n   }\n   s.handler = mux\n}\n```", "```go\nfunc (s *Server) displayNumber(w http.ResponseWriter, r *http.Request) {\n   s.logger.Printf(\"displayNumber called with number=%s\\n\", r.URL.Query().Get(\"number\"))\n   if numberParam := r.URL.Query().Get(\"number\"); numberParam != \"\" {\n      number, err := strconv.Atoi(numberParam)\n      if err != nil {\n         writeJSON(w, map[string]interface{}{\n            \"error\": fmt.Sprintf(\"invalid number (%v)\", numberParam),\n         }, http.StatusBadRequest)\n      }\n```", "```go\n      if number > s.opts.maxNumber {\n         writeJSON(w, map[string]interface{}{\n            \"error\": fmt.Sprintf(\"number (%d) too big. Max number: %d\", number, s.opts.maxNumber),\n         }, http.StatusBadRequest)\n      } else {\n```", "```go\n         var displayNumber string\n         if s.opts.convertFn == nil {\n            displayNumber = numberParam\n         } else {\n            displayNumber, err = s.opts.convertFn(number)\n         }        \n```", "```go\nserver.FormatNumber(func(x int) (string, error) { return fmt.Sprintf(\"%x\", x), nil }),\n```", "```go\nserver.FormatNumber(func(x int) (string, error) { return fmt.Sprintf(\"%b\", x), nil }),\n```", "```go\n//server.FormatNumber . . .  <= comment out FormatNumber parameter\n```", "```go\n         if err != nil {\n            writeJSON(w, map[string]interface{}{\n               \"error\": \"error running convertFn number\",\n            }, http.StatusBadRequest)\n         } else {\n            writeJSON(w, map[string]interface{}{\n               \"displayNumber\": displayNumber,\n            })\n         }\n      }\n   } else {\n      writeJSON(w, map[string]interface{}{\n         \"error\": \"missing number\",\n      }, http.StatusBadRequest)\n   }\n}\n```", "```go\npackage server\n\nimport (\n   . \"utils\"\n \"errors\"\n)\n```", "```go\ntype ServerOption func(*options) error\n```", "```go\nfunc MaxNumber(n int) ServerOption {\n   return func(o *options) error {\n      o.maxNumber = n\n      return nil\n   }\n}\n```", "```go\nfunc MaxConcurrentConnections(n int) ServerOption {\n   return func(o *options) error {\n      if n > Config.MaxConcurrentConnections {\n         return errors.New(\"error setting MaxConcurrentConnections\")\n      }\n      o.maxConcurrentConnections = n\n      return nil\n   }\n}\n```", "```go\ntype convert func(int) (string, error)\n```", "```go\nfunc FormatNumber(fn convert) ServerOption {\n   return func(o *options) (err error) {\n      o.convertFn = fn\n      return\n }\n}\n```", "```go\nserver.FormatNumber(func(x int) (string, error) { return fmt.Sprintf(\"%x\", x), nil }),\n```", "```go\ntype convert func(int) (string, error)\n```", "```go\nnewServer, err := server.New( . . .\n```", "```go\nfunc New(opt ...ServerOption) (*Server, error) {\n   opts := defaultServerOptions\n   for _, f := range opt {\n      err := f(&opts)\n```", "```go\ndisplayNumber, err = s.opts.convertFn(number)\n```", "```go\nfunc UseNumberHandler(b bool) ServerOption {\n   return func(o *options) error  {\n      o.useNumberHandler = b\n      return nil\n   }\n}\n```"]