- en: Functional Parameters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能参数
- en: While writing this chapter, my mind wandered back a few years to when I used
    to program in FoxPro. As I recall, I wrote a lot of functions in FoxPro. The functions
    I wrote were typically singular in purpose and rarely required more than four
    parameters. After Microsoft purchased Fox Software, newer versions of FoxPro began
    to be less functional. The UI builder was becoming more like Visual Basic. Functions
    began to be replaced by classes. Logic that was once readily accessible became
    hidden behind buttons and GUI objects. The lines of code increased, testing took
    more time and development cycles took longer. I felt a lack of productivity and
    could not adequately explain my feelings.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这一章的时候，我的思绪回到了几年前，当我还在FoxPro中编程时。我记得我在FoxPro中写了很多函数。我写的函数通常都是单一用途的，很少需要超过四个参数。在微软收购Fox
    Software之后，FoxPro的新版本开始变得不那么实用。UI构建器变得更像Visual Basic。函数开始被类所取代。曾经容易访问的逻辑被隐藏在按钮和GUI对象后面。代码行数增加，测试需要更多时间，开发周期变得更长。我感到缺乏生产力，无法充分解释我的感受。
- en: '"He who does not understand the supreme certainty of mathematics is wallowing
    in confusion."'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “不理解数学的最高确定性的人陷入了困惑。”
- en: '- Leonardo Da Vinci'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '- 莱昂纳多·达·芬奇'
- en: When I discovered Go, it was like paradise regained; A return to simplicity
    with added benefits of concurrency, networking, great development tools, first
    class functions as well as the best parts of OOP.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我发现Go时，就像天堂重新获得；回归简单，同时具有并发性、网络、出色的开发工具、一流的函数以及面向对象编程的最佳部分。
- en: 'Our goal in this chapter is to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的目标是做以下事情：
- en: Learn a better way to refactor long parameter lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习重构长参数列表的更好方法
- en: Recognize the difference between a dead data object and a functional parameter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识死数据对象和功能参数之间的区别
- en: Learn the difference between currying and partial application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习柯里化和部分应用之间的区别
- en: Learn how to apply a partial application to create another function with a smaller
    arity
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何应用部分应用程序来创建另一个具有较小arity的函数
- en: Use a context to gracefully shut down our server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文来优雅地关闭我们的服务器
- en: Use a context to cancel and rollback a long-running database transaction
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文来取消和回滚长时间运行的数据库事务
- en: Implement functional options to improve our APIs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现功能选项以改进我们的API
- en: If you think it's okay to simplify a long parameter list by either passing pointers
    to mutable data objects or by calling other functions hidden within your function,
    please read this chapter with an open mind.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为通过将指针传递给可变数据对象或调用隐藏在函数中的其他函数来简化长参数列表是可以接受的，请以开放的心态阅读本章。
- en: Refactoring long parameter lists
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构长参数列表
- en: Long parameter lists are typically considered code smell.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 长参数列表通常被认为是代码异味。
- en: How long is too long?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 太长了吗？
- en: When we look at a parameter list and are unable to keep track of it all, then
    it's likely too long.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看着参数列表而无法跟踪它们时，那么它很可能太长了。
- en: '**Mind''s limit found - 4 things at once**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**发现大脑的极限 - 一次4件事**'
- en: Working memory relates to the information we can pay attention to and grasp.
    Keeping our parameter lists short helps others easily understand our function's
    purpose.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 工作记忆与我们可以关注和理解的信息有关。保持我们的参数列表简短有助于他人轻松理解我们函数的目的。
- en: '[https://www.livescience.com/2493-mind-limit-4.html](https://www.livescience.com/2493-mind-limit-4.html)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.livescience.com/2493-mind-limit-4.html](https://www.livescience.com/2493-mind-limit-4.html)'
- en: Four parameters or fewer is the sweet spot, but seven is the maximum.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 四个参数或更少是最佳选择，但七个是最大值。
- en: 'Consider our telephone numbers. How many digits? Seven. For example: 867-5309'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下我们的电话号码。有多少位数字？七位。例如：867-5309
- en: Why do you think the seven digits are separated into two sets of numbers with
    the largest set having four digits?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为为什么七个数字被分成两组数字，其中最大的一组有四个数字？
- en: What's wrong with a function signature with more than seven parameters?
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数签名中超过七个参数有什么问题？
- en: A function signature should not be so long and complicated that we are unable
    to comprehend it. Keep it simple. Use thoughtful, reasonable, and meaningful parameter
    names.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名不应该太长和复杂，以至于我们无法理解。保持简单。使用周到、合理和有意义的参数名称。
- en: Ever noticed that functions with a long parameter list are typically some type
    of constructor? And that those functions are prone to get even more parameters
    over time?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 是否注意到具有长参数列表的函数通常是某种类型的构造函数？并且这些函数往往会随着时间的推移而获得更多的参数？
- en: '![](img/1db4c530-01da-43f2-a7d6-dcf06b6b3101.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1db4c530-01da-43f2-a7d6-dcf06b6b3101.png)'
- en: It is natural for software engineers to want to reduce their functions' parameter
    lists. That's part of what we do when we refactor our application. As long as
    we keep the goal of comprehensibility in mind, we'll be fine. Sometimes, we might
    have a function signature that has ten parameters. If other alternatives would
    make our function signature ambiguous, then go for it. Clarity trumps ambiguity.
    How many parameters should we use? It depends.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师希望减少函数的参数列表是很自然的。这是我们重构应用程序时所做的一部分。只要我们牢记可理解性的目标，我们就会没问题。有时，我们可能有一个具有十个参数的函数签名。如果其他替代方案会使我们的函数签名模糊不清，那就去做吧。清晰胜过模糊。我们应该使用多少参数？这取决于情况。
- en: Refactoring code is the process of changing the structure of our code without
    changing its behavior. We are not adding features. Instead, we are making our
    code more readable and more easily maintained. Often, we take large functions
    (over 200 lines of code) and break them into smaller, more comprehensible units
    of code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重构代码是改变代码结构而不改变其行为的过程。我们不是在添加功能。相反，我们是使我们的代码更易读和更易维护。通常，我们会将大型函数（超过200行代码）分解为更小、更易理解的代码单元。
- en: Some ways of accomplishing this feat are better than others.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有些方法比其他方法更好。
- en: Refactoring - the book
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构 - 这本书
- en: Ever read the book *Refactoring*? It covers the topic of refactoring long parameter
    lists.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 读过《重构》这本书吗？它涵盖了重构长参数列表的主题。
- en: 'The following points are made:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 提出了以下观点：
- en: Methods can query other objects' methods internally for data required to make
    decisions
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法可以在内部查询其他对象的方法以获取做出决策所需的数据
- en: Methods should depend on their host class for needed data
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法应该依赖于它们所在的类来获取所需的数据
- en: We should pass one or more objects to simplify our call signature
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该传递一个或多个对象来简化我们的调用签名
- en: We should use a technique called *replace parameter with method* to reduce the
    number of required parameters
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该使用一种叫做*用方法替换参数*的技术来减少所需参数的数量
- en: Pass a whole object with required attributes to reduce the number of required
    parameters
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个具有所需属性的整个对象以减少所需参数的数量
- en: Use a parameter object when we have unrelated data elements to pass
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们有不相关的数据元素要传递时，请使用参数对象
- en: We can send separate parameters when we do not want to create a dependency on
    a larger parameter object; this is an exception and we should probably not do
    it
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们不想在一个更大的参数对象上创建依赖关系时，我们可以发送单独的参数；这是一个例外，我们可能不应该这样做
- en: Long parameter lists will change over time and are inherently difficult to understand
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长参数列表会随时间改变，并且本质上很难理解
- en: This advice is consistent with the pure object-oriented language design methodology.
    However, we as good Go programmers should only be in agreement with the last point.
    Why?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个建议与纯面向对象的语言设计方法一致。然而，作为优秀的Go程序员，我们应该只同意最后一点。为什么？
- en: How can it be that the advice that many have followed for almost 20 years could
    be so horribly wrong?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会有这样一个几乎持续了20年的建议会如此糟糕？
- en: Edsger W. Dijkstra says OOP is a bad idea
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 艾兹格·W·迪科斯彻说面向对象编程是一个糟糕的想法
- en: 'The Dutch computer scientist, Dijkstra, provides the following insight on OOP:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 荷兰计算机科学家迪科斯彻对面向对象编程提供了以下见解：
- en: '"Object-oriented programming is an exceptionally bad idea which could only
    have originated in California."'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: “面向对象编程是一个只能在加利福尼亚州产生的极其糟糕的想法。”
- en: '-  Edsger W. Dijkstra'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '- 艾兹格·W·迪科斯彻'
- en: What? OOP is an *exceptionally bad idea*? Why?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？面向对象编程是一个*极其糟糕的想法*？为什么？
- en: First, let's understand a little bit more about Edsger W. Dijkstra.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更多地了解一下艾兹格·W·迪科斯彻。
- en: What else did Edsger W. Dijkstra say?
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 艾兹格·W·迪科斯彻还说了什么？
- en: 'Dijkstra said things such as:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 迪科斯彻说了一些诸如：
- en: '"The competent programmer is fully aware of the strictly limited size of his
    own skull; therefore he approaches the programming task in full humility, and
    among other things he avoids clever tricks like the plague."'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: “胜任的程序员完全意识到自己头脑的严格有限大小；因此他怀着完全的谦卑态度对待编程任务，而且他避免像瘟疫一样的聪明技巧。”
- en: '- Edsger W. Dijkstra'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '- 艾兹格·W·迪科斯彻'
- en: 'He also said the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 他还说了以下的话：
- en: '"Simplicity is prerequisite for reliability."'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “简单是可靠的前提。”
- en: '- Edsger W. Dijkstra'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '- 艾兹格·W·迪科斯彻'
- en: '![](img/3d6b32ec-a539-4e00-9b39-14bcf5e86cea.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d6b32ec-a539-4e00-9b39-14bcf5e86cea.png)'
- en: Mozart composition
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 莫扎特的作曲
- en: '"Neither a lofty degree of intelligence nor imagination nor both together go
    to the making of genius. Love, love, love, that is the soul of genius."'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: “智力的高度或想象力的高度或两者结合在一起并不能造就天才。爱，爱，爱，那是天才的灵魂。”
- en: '- Wolfgang Amadeus Mozart'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '- 沃尔夫冈·阿马德乌斯·莫扎特'
- en: Dijkstra shared his thoughts about the differing programming styles found in
    software development. Dijkstra compared the difference between the way Mozart
    and Beethoven composed music. Dijkstra explained that Mozart began composing with
    the entire composition in mind. Beethoven, on the other hand, would write parts
    of the music before the composition was completed and would literally glue the
    corrections to create the final composition.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 迪科斯彻分享了他对软件开发中不同编程风格的看法。迪科斯彻比较了莫扎特和贝多芬作曲音乐的方式。迪科斯彻解释说，莫扎特开始时就有整个作曲的构思。而贝多芬则会在作曲未完成时写下音乐的部分，并且会用胶水粘贴修正来创作最终的作品。
- en: '![](img/57e11402-b3ea-4ef0-8031-458e27b6a63d.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57e11402-b3ea-4ef0-8031-458e27b6a63d.png)'
- en: Beethoven composition
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 贝多芬的作曲
- en: Edsger seems to prefer Mozart's style of programming. His own approach to programming
    illustrates that programs should be designed and correctly composed, not just
    hacked and debugged into correctness.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 迪科斯彻似乎更喜欢莫扎特的编程风格。他自己的编程方法表明，程序应该被设计和正确组合，而不仅仅是被修改和调试到正确。
- en: The reason Mozart was able to perform detailed design before implementation
    was due to the fact that he was a master of the art of music composition and had
    a lot of experience. Sometimes, when developing software, we won't have that luxury.
    When we are unable to identify a framework suited for our project, there will
    be much more trial-and-error programming.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 莫扎特之所以能在实施之前进行详细设计，是因为他是音乐作曲艺术的大师，并且有丰富的经验。有时，在开发软件时，我们可能没有这样的奢侈条件。当我们无法确定适合我们项目的框架时，将会有更多的试错式编程。
- en: Personally, when I am not under a tight deadline, I prefer the Beethoven style
    of development. I think of it as recreational programming. It's self-exploratory
    in nature. For me, Mozart development requires more discipline. Typically, the
    end result is the same. Mozart development takes less time to complete, but Beethoven
    development is more enjoyable. I suppose that's why the developers enjoy R&D projects
    so much.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '就我个人而言，当我没有严格的截止日期时，我更喜欢贝多芬式的开发。我把它看作是娱乐性编程。它本质上是自我探索的。对我来说，莫扎特式的开发需要更多的纪律。通常，最终结果是一样的。莫扎特式的开发需要更少的时间来完成，但贝多芬式的开发更加愉快。我想这就是为什么开发人员如此喜欢研发项目。 '
- en: The underlying OOP problem
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 面向对象编程的根本问题
- en: As noted in [Chapter 4](../Text/Ch04.xhtml), *SOLID Design in Go*, you learned
    how Java (and OOP languages) places emphasis on a type hierarchy. The designers
    of OOP focused on nouns rather than verbs. Everything is an object. An object
    has attributes (data) and can perform actions (methods).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第4章](../Text/Ch04.xhtml)中所指出的，*Go中的SOLID设计*，你学到了Java（和面向对象编程语言）如何强调类型层次结构。面向对象编程的设计者关注的是名词而不是动词。一切都是对象。一个对象有属性（数据）并且可以执行动作（方法）。
- en: '![](img/66b75afc-8bb8-415f-aada-746631d67ca1.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66b75afc-8bb8-415f-aada-746631d67ca1.png)'
- en: An inactive noun
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不活跃的名词
- en: One of the underlying problems with OOP is that it promotes storing and hiding
    data in the object's properties/attributes. It is assumed that our application
    will eventually want to access this object's data while executing one or more
    of the object's methods.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的一个潜在问题是它促进了在对象的属性/属性中存储和隐藏数据。假设我们的应用程序最终会在执行一个或多个对象的方法时想要访问该对象的数据。
- en: OOP inconsistency
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: OOP的不一致性
- en: An OOP application can recall its hidden information and mutate it. An object's
    method can be called multiple times during the lifetime of the application. Each
    call to the same method with the same call signature can produce different results
    every time. This characteristic of its behavior makes OOP unreliable and difficult
    to test effectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程应用可以调用其隐藏的信息并对其进行改变。在应用程序的生命周期内，可以多次调用对象的方法。每次以相同的调用签名调用相同的方法都可能产生不同的结果。其行为特性使得面向对象编程不可靠且难以有效测试。
- en: OOP is inconsistent with basic mathematics. In OOP, due to an object's mutable
    state, we cannot always call a method with the same parameters each time and always
    get the same results. There is no mathematical model for OOP. For example, if
    we call `myMethod(1,2)` and get 3 the first time and get 4 the next time, due
    to the mutable state and internal calls to other objects, then the correctness
    of an OOP program cannot be defined.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程与基本数学不一致。在面向对象编程中，由于对象的可变状态，我们不能总是以相同的参数调用方法并始终获得相同的结果。面向对象编程没有数学模型。例如，如果我们调用`myMethod(1,2)`，第一次得到3，下一次得到4，由于可变状态和对其他对象的内部调用，那么面向对象编程程序的正确性无法定义。
- en: Functional programming and cloud computing
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数式编程和云计算
- en: The essence of functional programs is very different from OOP. Functional programs,
    given the same set of input parameters, will always yield the same results. We
    can easily run them in parallel. We can chain/compose them in ways that are faster
    and not possible with OOP.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序的本质与面向对象编程非常不同。给定相同的输入参数，函数式程序将始终产生相同的结果。我们可以轻松地并行运行它们。我们可以以更快的方式链接/组合它们，这是面向对象编程所不可能的。
- en: Our deployment model has changed from in-house servers, where admins would spend
    so much time configuring and optimizing them that they gave the server pet names.
    We used to see names follow a pattern such as Greek gods. There's *Zeus*, our
    database server, and *Apollo* our HR server.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的部署模型已经从内部服务器改变，管理员会花费大量时间配置和优化它们，以至于给服务器取了宠物名字。我们过去看到的名字遵循了希腊神的模式。有*宙斯*，我们的数据库服务器，还有*阿波罗*，我们的人力资源服务器。
- en: 'Now that our servers are deployed in the cloud, our admins can add new servers
    with the click of a button or set up auto scaling: if the average CPU goes above
    80%, then add a new server. It looks something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的服务器部署在云中，我们的管理员可以通过点击按钮添加新服务器或设置自动扩展：如果平均CPU超过80％，则添加新服务器。看起来是这样的：
- en: '![](img/a52acd9f-b1c4-448a-b051-3d0aa11f467f.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a52acd9f-b1c4-448a-b051-3d0aa11f467f.png)'
- en: The Pods in the preceding diagram represent a server, which might have a few
    related containers. One container in the pod would be running our `f(x)` function.
    If a server crashes, our auto scaling logic that's running in our container orchestrator
    would be notified and it will automatically start another server to replace it.
    Pods can quickly be provisioned and can be taken out of service based on our cloud
    deployment profile settings and our sites' traffic patterns. Since servers come
    and go so easily and quickly these days, we refer to them as cattle rather than
    pets. We are more concerned with the health of our herd of servers than we are
    about any one particular pet server.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上图中的Pod代表一个服务器，可能有几个相关的容器。Pod中的一个容器将运行我们的`f(x)`函数。如果服务器崩溃，我们容器编排器中运行的自动扩展逻辑将被通知，并将自动启动另一台服务器来替换它。Pod可以根据我们的云部署配置文件和网站的流量模式快速进行配置，并根据需要停用。由于服务器这些天来来去去如此容易和迅速，我们称它们为牲畜而不是宠物。我们更关心我们的服务器群的健康状况，而不是任何一个特定的宠物服务器。
- en: The term *Pod* is taken from Kubernetes. Refer to [https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/)
    to know more.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*Pod*取自Kubernetes。请参阅[https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/)了解更多信息。
- en: Pods are the rough equivalent of OpenShift v2 gears and logically represent
    a *logical host*, where all service containers can communicate with each other
    via localhost.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Pods大致相当于OpenShift v2的齿轮，并在逻辑上代表一个*逻辑主机*，所有服务容器都可以通过localhost相互通信。
- en: Other container orchestrators include Docker Swarm, Mesos, Marathon, and Nomad.
    Refer to [https://github.com/KaivoAnastetiks/container-orchestration-comparison](https://github.com/KaivoAnastetiks/container-orchestration-comparison).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '其他容器编排器包括Docker Swarm、Mesos、Marathon和Nomad。请参阅[https://github.com/KaivoAnastetiks/container-orchestration-comparison](https://github.com/KaivoAnastetiks/container-orchestration-comparison)。 '
- en: Applications with FP characteristics behave reliably in our cloud environments;
    however, applications with OOP characteristics of mutable state do not do so.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 具有FP特征的应用在我们的云环境中表现可靠；然而，具有可变状态的OOP特征的应用则不会如此。
- en: A closer look at f(x)
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 深入了解f(x)
- en: Let's examine a basic function definition, where **f** is the function name
    and **x** is the input value. Another name for **x** is the input parameter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个基本的函数定义，其中**f**是函数名，**x**是输入值。**x**的另一个名称是输入参数。
- en: 'The entire expression **f(x)** represents the output value:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 整个表达式**f(x)**代表输出值：
- en: '![](img/533ed4de-b9bc-476d-bba2-516b17d7cca3.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/533ed4de-b9bc-476d-bba2-516b17d7cca3.png)'
- en: If *f(x) = x + 1*, then we know that every time we input the value 2, the output
    value will always be 3.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*f(x) = x + 1*，那么我们知道每次输入值2时，输出值总是3。
- en: This pure and simple characteristic is what makes functional programming so
    powerful.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种纯粹和简单的特性是使函数式编程如此强大的原因。
- en: 'If, on the other hand, we had an object with an `AddOne` method that would
    sometimes return 3 when given the value of 2, then how could we reliably scale
    our `object.AddOne` method? We can''t, and that is the main reason why, in the
    context of cloud computing, the following equation is true: *FP > OOP*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们有一个带有`AddOne`方法的对象，有时会在给定值为2时返回3，那么我们如何可靠地扩展我们的`object.AddOne`方法呢？我们不能，这就是为什么在云计算的背景下，以下等式成立的主要原因：*FP
    > OOP*。
- en: A closer look at refactoring
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构的更近距离观察
- en: Let's examine each point made in the Refactoring book in the light of functional
    programming.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据函数式编程的观点审视《重构》一书中提出的每一点。
- en: Passing every parameter a function requires to do its job is not a good idea
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 传递函数所需的每个参数并不是一个好主意
- en: Why wouldn't we want our function signature to indicate the values (parameters)
    that it needs to make decisions?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不希望我们的函数签名指示它需要做出决策的值（参数）？
- en: How can we reduce the parameters that a function requires?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何减少函数需要的参数？
- en: Methods can query other objects' methods internally for data required to make
    decisions
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法可以在内部查询其他对象的方法以获取做出决策所需的数据
- en: So, instead of calling the `GetTravelTime(startLocation, endLocation)` method,
    it would be better to call `GetTravelTime()`?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与其调用`GetTravelTime(startLocation, endLocation)`方法，最好调用`GetTravelTime()`？
- en: Where would we get the `startLocation` and `endLocation` values from?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从哪里获取`startLocation`和`endLocation`的值？
- en: How can we be sure that there aren't other values, such as `modeOfTransportation`,
    that would impact our travel time result?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保没有其他值，比如`modeOfTransportation`，会影响我们的旅行时间结果？
- en: Doesn't that create internal, undocumented dependencies (assuming we document
    our external APIs)?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否会创建内部的、未记录的依赖关系（假设我们记录了我们的外部API）？
- en: Methods should depend on their host class for needed data
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法应该依赖于它们所属的类来获取所需的数据
- en: Does this mean that we are relying on mutable data that could be updated before
    and during our function call?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们依赖于可变数据，这些数据在我们的函数调用之前和期间可能会被更新？
- en: If we want to prevent updates on data during the time our function is running,
    what extra code must we write to ensure data consistency? What locking mechanisms
    will we need to implement?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在我们的函数运行时阻止数据更新，我们需要写什么额外的代码来确保数据一致性？我们需要实现什么样的锁定机制？
- en: Will this prevent us from writing code that runs in parallel?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这会阻止我们编写并行运行的代码吗？
- en: Is concurrent programming possible?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程是否可能？
- en: Pass a whole object with required attributes to reduce the number of required
    parameters
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 传递一个带有所需属性的完整对象以减少所需参数的数量
- en: 'So, instead of `GetTravelTime(startLocation, endLocation, speed)`, our call
    should look like this: `GetTravelTime(info)`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的调用应该像这样：`GetTravelTime(info)`，而不是`GetTravelTime(startLocation, endLocation,
    speed)`。
- en: There are times when a function call like this `Initialize(Config)` makes sense,
    and it depends on our use case.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时像这样的函数调用`Initialize(Config)`是有意义的，这取决于我们的用例。
- en: However, maybe we should strive to simplify what our function does so that it
    naturally requires fewer parameters rather than finding ways to jam more parameter
    values into a single input parameter object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也许我们应该努力简化我们的函数，以便自然地需要更少的参数，而不是找到将更多参数值塞入单个输入参数对象的方法。
- en: Replace parameter with method technique to reduce the number of required parameters
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用方法替换参数技术来减少所需参数的数量
- en: This technique instructs us to remove the parameter and let the receiver invoke
    the method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术指导我们删除参数，让接收者调用方法。
- en: Before applying Replace Parameter with Method technique
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在应用*用方法替换参数*技术之前
- en: 'We start with a `getDiscountedPrice` function that takes two parameter: `lineItemPrice`
    and discount:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个`getDiscountedPrice`函数开始，它需要两个参数：`lineItemPrice`和discount：
- en: '[PRE0]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Replace Parameter with Method* aggressively strives to reduce the number of
    parameters.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*用方法替换参数*积极努力减少参数的数量。'
- en: In this case we have two parameters. That is clearly fewer than the four parameters.
    Why reduce this low number of parameters?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有两个参数。这显然比四个参数少。为什么要减少这么少的参数？
- en: After applying Replace Parameter with Method technique
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用*用方法替换参数*技术后
- en: 'After refactoring our code per our instructions, we have removed a parameter.
    Now we only have one parameter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的指示重构我们的代码后，我们已经删除了一个参数。现在我们只有一个参数：
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How will code maintainers know that the `totalPrice` can be reduced by a discount?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 代码维护者如何知道`totalPrice`可以通过折扣减少？
- en: Does hiding the discount parameter improve understandability or does it actually
    increase code complexity?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏折扣参数是否提高了可理解性，还是实际上增加了代码复杂性？
- en: Use a parameter object when we have unrelated data elements to pass
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 当我们有不相关的数据元素需要传递时，使用参数对象
- en: A parameter object contains only fields and crude methods for accessing them
    (getters and setters). It is a dead data structure used only to transfer data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 参数对象只包含字段和用于访问它们的简单方法（getter和setter）。它是一个死数据结构，仅用于传输数据。
- en: If we are passing a lot of unrelated data items into a function, then what are
    the odds that our function would fail the Single Responsibility Principle?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将许多不相关的数据项传递到一个函数中，那么我们的函数失败单一职责原则的几率有多大？
- en: What if we wanted to add logic that could modify a data value based on our runtime
    context?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要添加可以根据我们的运行时上下文修改数据值的逻辑，该怎么办？
- en: 'However, if we have a set of parameters that describe a new customer, we could
    consider grouping them into a data objects. Something like the following could
    be considered a reasonable thing to do:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们有一组描述新客户的参数，我们可以考虑将它们分组到一个数据对象中。以下内容可能被认为是一个合理的做法：
- en: '![](img/64bb268c-422e-4620-af03-b3a01bf5bad8.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64bb268c-422e-4620-af03-b3a01bf5bad8.png)'
- en: 'We grouped the `FullName` attributes (salutation, `firstName`, `middleName`,
    `lastName`, suffix) together to form a `FullName` data object. We also grouped
    address attributes to create an `Address` data object. Now, we can call `CreateCustomer`
    passing only two attributes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将“FullName”属性（称谓，“firstName”，“middleName”，“lastName”，后缀）分组在一起，形成“FullName”数据对象。我们还分组地址属性以创建“Address”数据对象。现在，我们可以调用“CreateCustomer”只传递两个属性：
- en: '[PRE2]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The call with two parameters is an improvement over the following one with
    eight:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 具有两个参数的调用比具有八个参数的调用更好：
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, as with most things in the world, the right thing to do depends on our situation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就像世界上的大多数事情一样，正确的做法取决于我们的情况。
- en: Can you think of a problem with this approach?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到这种方法的问题吗？
- en: Doesn't this create a dependency upon the `fullName` and address objects?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做不会在“fullName”和地址对象上创建依赖关系吗？
- en: What if either the `fullName` or address data objects changed after we began
    executing our `CreateCustomer` function but before it was complete? What data
    inconsistencies would we have then?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行“CreateCustomer”函数之后但在完成之前，要么“fullName”要么地址数据对象发生了变化，那么我们会有什么数据不一致？
- en: Long parameter lists will change over time and are inherently difficult to understand
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 长参数列表会随时间改变，并且本质上很难理解
- en: This statement makes a lot of sense. The rest of this chapter will expound on
    this statement. We'll explore how we can manage an API that could change over
    time and that might need more than a few parameters to get the information it
    needs to complete its task(s).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个陈述很有道理。本章的其余部分将阐述这个陈述。我们将探讨如何管理一个可能随时间变化并且可能需要多个参数来获取完成任务所需信息的API。
- en: If we compose our application like Beethoven, starting with a general idea of
    what we want to accomplish and beating our program into shape, then we might not
    know exactly what parameters an API will need at first.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像贝多芬一样构建我们的应用程序，从我们想要实现的一般想法开始，并将我们的程序打磨成形，那么我们可能一开始不知道API将需要什么参数。
- en: '![](img/98cbeafd-7c81-410c-8526-bda0051b3f8f.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/98cbeafd-7c81-410c-8526-bda0051b3f8f.png)
- en: An action verb
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动作动词
- en: How do we design an API that requires more than a few parameters, yet has the
    following qualities?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何设计一个需要多个参数的API，但具有以下特点？
- en: Provides sensible defaults
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供合理的默认值
- en: Indicates which parameters are required/optional
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示哪些参数是必需的/可选的
- en: Provides the entire power of language to init complex values rather than relaying
    via dead structures
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了语言的全部功能来初始化复杂值，而不是通过死结构传递
- en: Can grow over time
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以随着时间增长
- en: Is safe
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Is discoverable
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可发现
- en: Is self-documenting
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自我记录
- en: Is highly configurable
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度可配置
- en: What about passing a configuration struct?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 传递配置结构怎么样？
- en: Like the `fullName` and address data objects we saw earlier, passing a configuration
    data object creates a dependency. The configuration object is retained by both
    the `caller` and the function `called`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前看到的“fullName”和地址数据对象一样，传递配置数据对象会创建一个依赖关系。配置对象由“调用者”和函数“被调用者”保留。
- en: If we pass pointers to our configuration object that would complicate issues
    if any mutations occurred, either by the caller or the callee.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递指向我们的配置对象的指针，那么如果发生任何变化，无论是调用者还是被调用者，都会使问题复杂化。
- en: The solution
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The solution we''re looking for would allow a new constructor to accept a variable
    number of parameters with the following characteristics:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找的解决方案将允许新的构造函数接受可变数量的参数，并具有以下特点：
- en: Predefining default values (where no parameter is passed for that particular
    setting)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预定义默认值（在没有为特定设置传递参数的情况下）
- en: Only passing values that have meaning
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只传递有意义的值
- en: Harnessing the power of the Go programming language to customize the value of
    the parameter passed
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Go编程语言的强大功能来自定义传递的参数值
- en: Much of this design comes from one of Rob Pike's blog posts.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的很多思想来自Rob Pike的一篇博客文章。
- en: Refer to self-referential functions and the design of options, by Rob Pike in
    his blog post at [https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html](https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 参考Rob Pike在他的博客文章中关于自引用函数和选项设计的内容[https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html](https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html)。
- en: Kudos for sharing the closure technique of returning a function literal in which
    we set the value of our server setting. We'll see exactly how this works later
    in this chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为分享返回函数文字的闭包技术点赞，其中我们设置了服务器设置的值。稍后我们将看到这是如何工作的。
- en: '![](img/899209bd-10b1-409e-b6d9-4cef3d91a999.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/899209bd-10b1-409e-b6d9-4cef3d91a999.jpg)
- en: Three ways to pass multiple parameters
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 传递多个参数的三种方法
- en: Let's keep in mind that there are three ways to pass multiple parameters to
    a function. We will discuss them in the next sections.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住，有三种方法可以将多个参数传递给函数。我们将在接下来的章节中讨论它们。
- en: Simply passing multiple parameters
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简单地传递多个参数
- en: 'Here, we pass four parameters to the `InitLog` function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向“InitLog”函数传递了四个参数：
- en: '[PRE4]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Passing a configuration object/struct that contains multiple attributes
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 传递包含多个属性的配置对象/结构
- en: 'Here, we pass the `ClientConfig` configuration data object and print its values
    out:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递了“ClientConfig”配置数据对象并打印其值：
- en: '[PRE5]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A disadvantage of this approach is that we create a dependency between the caller
    and the callee. What if the caller or some other part of the caller's system modifies
    the configuration object while our function is processing?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是我们在调用者和被调用者之间创建了一个依赖关系。如果调用者或调用者系统的其他部分在我们的函数处理时修改了配置对象会怎么样？
- en: Sometimes, as in the example provided earlier, it is fairly safe to assume that
    the configuration object will not change. In that case, passing a configuration
    object is the right thing to do. It's easy and effective with little chance of
    a mutation causing an inconsistent state.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，就像前面提供的示例一样，可以相当安全地假设配置对象不会改变。在这种情况下，传递配置对象是正确的做法。这样做简单有效，几乎没有变异导致不一致状态的可能性。
- en: But what if the parameter might need to be modified due to the additional complexity
    that lies inside the called function? Static values from a dead structure can't
    help.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果由于所调用函数内部的额外复杂性而需要修改参数怎么办？来自死结构的静态值无法帮助。
- en: Partial application
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部分应用
- en: Our third option is called **partial application**. We can accomplish this with
    currying.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个选项称为**部分应用**。我们可以通过柯里化来实现这一点。
- en: The idea behind currying is to create new, more specific functions from other
    more general functions by partially applying them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化的思想是通过部分应用来从其他更一般的函数创建新的更具体的函数。
- en: 'Consider that we have have an `add` function that takes two numbers:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下，我们有一个接受两个数字的`add`函数：
- en: '[PRE6]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can create another function that returns the `add` function with one of
    the parameters pre-inserted. We''ll take a simple example of adding one to any
    other number:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建另一个函数，它返回带有一个参数预插入的`add`函数。我们将以将任何其他数字加一的简单示例为例：
- en: '[PRE7]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The results of calling `add(1,2)` will be the same as calling `addOne(2)`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`add(1,2)`的结果将与调用`addOne(2)`相同：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the output of the preceding code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '[PRE9]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Currying** is the ability of a function to return a new single argument function
    until the original function receives all of its arguments.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**柯里化**是函数返回一个新的单参数函数，直到原始函数接收到所有参数的能力。'
- en: Calling a curried function with only a few of its arguments is called **partial
    application**.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用某些参数调用柯里化函数称为**部分应用**。
- en: Function currying is a technique we can use to chop up complex functionality
    into smaller parts that are easier to reason about. Smaller units of logic are
    also easier to test. Our  application becomes a clean composition of the smaller
    parts.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 函数柯里化是一种技术，我们可以使用它将复杂的功能分解成更容易理解的小部分。逻辑的较小单元也更容易测试。我们的应用程序变成了较小部分的清晰组合。
- en: However, the solution that we will be pursuing in this chapter will be of the
    first variety, that is, we will pass all the required parameters. However, we
    will only need to pass the required parameters and we will use sensible default
    values for unprovided parameters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中我们将追求的解决方案将是第一种，也就是，我们将传递所有必需的参数。但是，我们只需要传递必需的参数，并且我们将为未提供的参数使用合理的默认值。
- en: How can we accomplish this? By using functional parameters!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现这一点？通过使用函数参数！
- en: Functional parameters
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数
- en: 'We''ll use the `GetOptions()` utils function as we have in previous chapters
    and we''ll call `GetOptions` and `InitLog` in our init function so that our configuration
    values and logger will be set up prior to running any commands in the `main` package:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`GetOptions()`实用函数，就像我们在之前的章节中使用的那样，并且我们将在我们的init函数中调用`GetOptions`和`InitLog`，以便在运行`main`包中的任何命令之前设置我们的配置值和记录器：
- en: '[PRE10]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's subscribe to the `SIGINT` signal using signal `Notify`. Now, we can catch
    a *Ctrl* + *C* event before our program abruptly stops. We'll create a quit channel
    to hold our signal. It only needs to have a buffer size of 1.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用信号`Notify`订阅`SIGINT`信号。现在，我们可以在程序突然停止之前捕获*Ctrl* + *C*事件。我们将创建一个退出通道来保存我们的信号。它只需要有一个大小为1的缓冲区。
- en: 'When our `quit` channel receives a `SIGINT` signal, we can begin our graceful,
    orderly shutdown procedure:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的`quit`通道接收到`SIGINT`信号时，我们可以开始我们的优雅、有序的关闭过程：
- en: '[PRE11]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Pay close attention to the following code. This is where we pass our functional
    parameters!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细注意以下代码。这是我们传递函数参数的地方！
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In our example, we chose to provide four parameters (`MaxConcurrentConnections`,
    `MaxNumber`, `FormatNumber`, and `UseNumberHandler`) to our server's `New` constructor.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们选择为服务器的`New`构造函数提供四个参数（`MaxConcurrentConnections`、`MaxNumber`、`FormatNumber`和`UseNumberHandler`）。
- en: Note that the parameter names are self-explanatory. We passed the actual scalar
    values (4, 256, true) for the first three parameters. We could have chosen to
    use config values (`Config.MaxConcurrentConnections`, `Config.MaxNumber`, and
    `Config.UseNumberHandler`) or use environment variables. We could also use environment
    variables. We'd likely not use an environment variable for `UseNumberHandler`.
    Mostly, environment variables are used for settings that are likely to vary from
    development, test, QA and production environments, for example, `IPADDRESS` and
    `PORT`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，参数名称是不言自明的。我们为前三个参数传递了实际的标量值（4、256、true）。我们可以选择使用配置值（`Config.MaxConcurrentConnections`、`Config.MaxNumber`和`Config.UseNumberHandler`）或使用环境变量。我们也可以使用环境变量。我们可能不会为`UseNumberHandler`使用环境变量。大多数情况下，环境变量用于设置可能会在开发、测试、QA和生产环境中变化的设置，例如`IPADDRESS`和`PORT`。
- en: 'Here''s a handy library for dealing with environment variables in Go:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个处理Go环境变量的方便库：
- en: '[https://github.com/caarlos0/env](https://github.com/caarlos0/env)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/caarlos0/env](https://github.com/caarlos0/env)'
- en: 'The last parameter `FormatNumber` accepts an anonymous function to change the
    display format of the number:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数`FormatNumber`接受一个匿名函数来改变数字的显示格式：
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `%x` argument in the `fmt.Sprintf` statement instructs our handler to display
    the entered number in binary format.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Sprintf`语句中的`%x`参数指示我们的处理程序以二进制格式显示输入的数字。'
- en: 'When the user enters the number **2** in their request, this is what''s displayed:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在其请求中输入数字**2**时，将显示如下内容：
- en: '![](img/aa6d94bd-da2b-47aa-b2a3-8a3c215ecc79.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa6d94bd-da2b-47aa-b2a3-8a3c215ecc79.png)'
- en: 'If the call to `Server.New` fails, then log the error and exit the program:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用`Server.New`失败，则记录错误并退出程序：
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we provide the parameters required for a running HTTP server. The `Addr`
    parameter is the address the server listens on.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提供运行HTTP服务器所需的参数。`Addr`参数是服务器监听的地址。
- en: 'Rather than letting the `http.Server` default to using `http.DefaultServeMux`
    to handle requests, we we pass our `newServer` function type variable to accept
    our custom `ServerOption` functional parameters to customize its behavior:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与其让`http.Server`默认使用`http.DefaultServeMux`来处理请求，我们将我们的`newServer`函数类型变量传递给接受我们自定义的`ServerOption`函数参数的`http.Server`，以自定义其行为：
- en: '[PRE15]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we'll create a Goroutine for an anonymous function call.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为匿名函数调用创建一个Goroutine。
- en: Our Goroutine will wait until the user triggers a `SIGINT` interrupt (by pressing
    *Ctrl* + *C* in the terminal session where the server was started). At that time,
    the quit channel will receive the signal.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Goroutine将等待，直到用户触发“SIGINT”中断（通过在启动服务器的终端会话中按下*Ctrl* + *C*）。此时，“quit”通道将接收到信号。
- en: Though `Context` can be used to pass request-scoped variables, we're only going
    to use it to pass a cancellation signal. We'll go into more detail about `Context`
    in the next section.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管“上下文”可以用于传递请求范围的变量，但我们只会用它来传递取消信号。我们将在下一节更详细地介绍“上下文”。
- en: 'The `quit` channel is closed when the 2 second deadline expires or when the
    returned `cancel` function is called. As long as the server shutdown logic takes
    less than two seconds, the defer `cancel()` will be called; otherwise, the deadline
    will close the `quit` channel:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当2秒截止日期到期或调用返回的“cancel”函数时，“quit”通道将关闭。只要服务器关闭逻辑花费的时间不超过两秒，延迟“cancel()”将被调用；否则，截止日期将关闭“quit”通道。
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The call to `Shutdown` will stop the server without interrupting any active
    connections. First, `Shutdown` closes open listeners, then it closes idle connections.
    Without a deadline, it could wait indefinitely for connections to return to idle
    before shutting them down.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对“Shutdown”的调用将停止服务器而不会中断任何活动连接。首先，“Shutdown”关闭打开的监听器，然后关闭空闲连接。如果没有截止日期，它可能会无限期地等待连接返回到空闲状态，然后再关闭它们。
- en: 'The `ListenAndServe` function listens on the localhost port `Config.Port` and
    calls serve to handle requests on incoming connections:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: “ListenAndServe”函数在本地主机端口“Config.Port”上监听，并调用serve来处理传入连接的请求：
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, our server will be listening for requests and our terminal will
    look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的服务器将监听请求，我们的终端将如下所示：
- en: '![](img/5ad4327e-c548-4b7b-9ea9-4ca0a041af18.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ad4327e-c548-4b7b-9ea9-4ca0a041af18.png)'
- en: 'Note that we can get that config information printed to our terminal by inserting
    the following as our first line in our `main` function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以通过将以下内容插入到我们的“main”函数的第一行来将配置信息打印到我们的终端：
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The "`+`" in `%+v` tells the `Printf` function to print the field names as well
    as the values.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: “％+v”中的“+”告诉“Printf”函数打印字段名称以及值。
- en: 'When we press *Ctrl* + *C*, the code in the following line signals our Goroutine
    on the `quit` channel:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下*Ctrl* + *C*时，以下行中的代码会在“quit”通道上向我们的Goroutine发出信号：
- en: '[PRE19]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](img/aea8c228-dec8-4f6e-ab7c-2ed1ab712c20.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aea8c228-dec8-4f6e-ab7c-2ed1ab712c20.png)'
- en: The `srv.Shutdown` method runs and then the last line in `main` executes to
    print `server shutdown gracefully`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: “srv.Shutdown”方法运行，然后“main”中的最后一行执行以打印“server shutdown gracefully”。
- en: Before diving into more of our `func-param` project code, let's look more closely
    at to Go's `Context` package functionality.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解更多关于我们的“func-param”项目代码之前，让我们更仔细地看看Go的“Context”包功能。
- en: Contexts
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: Contexts are primarily used for requests spanning multiple processes and API
    boundaries. Contexts help maintain background information on the state of the
    object during different phases of a process life cycle as it traverses various
    API boundary processes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文主要用于跨多个进程和API边界的请求。上下文有助于在对象的不同生命周期阶段穿越各种API边界进程时维护有关对象状态的背景信息。
- en: 'Here''s an example (from [https://blog.golang.org/context](https://blog.golang.org/context))
    of passing a `Context` parameter:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个传递“上下文”参数的示例（来自[https://blog.golang.org/context](https://blog.golang.org/context)）：
- en: '[PRE20]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Passing the `Context` parameter to every function in every request provides
    control over timeouts and cancellation for requests that span APIs and process
    boundaries. Furthermore, it helps to ensure that critical values such as security
    credentials do not stay in transit longer than necessary.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 将“上下文”参数传递给每个请求中的每个函数可以控制跨API和进程边界的请求的超时和取消。此外，它有助于确保诸如安全凭据之类的关键值不会在传输中停留的时间超过必要的时间。
- en: Third-party libraries and frameworks, for example, Gorilla's ([http://github.com/gorilla/context](http://github.com/gorilla/context))
    package, provide a bridge between their packages and others that take a Context
    request-scoped parameter. This improves interoperability between heterogeneous
    packages when building scalable services.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方库和框架，例如Gorilla的（[http://github.com/gorilla/context](http://github.com/gorilla/context)）包，提供了它们的包和接受上下文请求范围参数的其他包之间的桥梁。这提高了在构建可扩展服务时异构包之间的互操作性。
- en: We will use an application context to provide control over stopping our server.
    The deadline ensures that our shutdown process does not exceed a reasonable amount
    of time (2 seconds in our example). Also, by sending the cancel signal, we provide
    our server with the opportunity to run its cleanup processes prior to shutting
    down.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用应用程序上下文来控制停止我们的服务器。截止日期确保我们的关闭过程不会超过合理的时间（在我们的示例中为2秒）。此外，通过发送取消信号，我们为服务器提供了在关闭之前运行其清理过程的机会。
- en: 'Here''s an illustration of what''s going on with our `Context` parameter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于我们的“上下文”参数正在发生的情况的说明：
- en: '![](img/7aab879a-c096-4374-bf09-00882e2709b0.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7aab879a-c096-4374-bf09-00882e2709b0.png)'
- en: When the admin user presses *Ctrl* + *C*, the `os.interrupt` signals the `quit`
    (buffered) channel. A `Context` (`ctx`) is created with a deadline of 2 seconds.
    That Context parameter is sent to the `srv.Shutdown` function, where the server's
    cleanup code is executed. If it takes longer than 2 seconds, then our Goroutine
    will be canceled. The result is that our server is gracefully shut down and we
    can be assured that it won't take longer than 2 seconds.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当管理员用户按下*Ctrl* + *C*时，“os.interrupt”会向“quit”（缓冲）通道发出信号。创建了一个截止日期为2秒的上下文（ctx）。该上下文参数被发送到“srv.Shutdown”函数，其中执行服务器的清理代码。如果超过2秒，那么我们的Goroutine将被取消。结果是我们的服务器会优雅地关闭，我们可以确保它不会花费超过2秒的时间。
- en: 'We could build elaborate `Context` trees like the one here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建像这样复杂的“上下文”树：
- en: '![](img/56df5017-1483-4b5f-8870-c52db31d2b8a.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56df5017-1483-4b5f-8870-c52db31d2b8a.png)'
- en: However, before doing so, we should be aware of our `Context` limitations, which
    we will discuss next.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这样做之前，我们应该意识到我们的`Context`限制，接下来我们将讨论这一点。
- en: Context limitations
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文限制
- en: Trees can be traversed upward, that is, from children nodes to parent nodes
    (not the other way).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 树可以向上遍历，即从子节点到父节点（而不是相反）。
- en: We should only use values that advise, for example, this user's localname is
    `en_US`. The `en_US` can be used to enhance the user experience, but not to change
    the flow of the application. We should not store values that can affect the flow
    of control in the `Context` package.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该只使用建议的值，例如，这个用户的本地名称是`en_US`。`en_US`可以用来增强用户体验，但不能改变应用程序的流程。我们不应该存储可能影响`Context`包中控制流的值。
- en: Report example
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 报告示例
- en: 'As an example of the effects caused by storing the flow of control values in
    the `Context`, let''s consider the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在`Context`中存储控制流值所导致的影响的一个例子，让我们考虑以下情况：
- en: '[PRE21]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, we passed only the context as a parameter. Inside
    our `Report` function, we extract the flow of control modifying values, `reportName`
    and filter. Now, we have the format in which the `Report` function needs to do
    its job.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只传递了上下文作为参数。在我们的`Report`函数内部，我们提取了修改值`reportName`和filter的控制流。现在，我们有了`Report`函数需要完成其工作的格式。
- en: Why do some people think that it's a good idea to query other objects' methods
    internally for data required to make decisions or to make a habit of passing a
    big amorphous object, filled with data that we must then extract inside our function
    in order to know what to do next?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有些人认为在内部查询其他对象的方法以获取做出决策所需的数据或养成传递一个充满数据的大模糊对象的习惯，然后在我们的函数内部提取以知道接下来该做什么是一个好主意？
- en: It is typically best practice to pass all of the parameters that a function
    requires. This coding style creates self-documenting APIs. If we find that our
    parameter list is growing large, that is, over six parameters, then we should
    consider whether our function should be refactored. Is there any reusable code
    in our large function? Maybe we can create a helper function and reduce our parameter
    footprint?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最佳实践是传递函数所需的所有参数。这种编码风格创建了自我说明的API。如果我们发现我们的参数列表变得很大，即超过六个参数，那么我们应该考虑是否应该重构我们的函数。我们的大函数中是否有可重用的代码？也许我们可以创建一个辅助函数并减少我们的参数印记？
- en: Let's not forget what we discussed in the [Chapter 4](../Text/Ch04.xhtml), *SOLID
    Design in Go*. The *(S)ingle Responsibility principle* states that a class should
    have only a single responsibility.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记我们在[第4章](../Text/Ch04.xhtml)中讨论的内容，*Go中的SOLID设计*。*(S)ingle Responsibility
    principle*表明一个类应该只有一个责任。
- en: If we are passing a ton of parameters, could it be possible that our function
    is performing more than one task?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递了大量参数，我们的函数是否可能执行了多个任务？
- en: Writing good code is not unlike a good game of soccer
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写良好的代码与踢好一场足球并无二致
- en: Play it simple. Make your passes crisp and short. Be intentional. Maintain control
    of the ball. Always keep your eye on the ball.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地进行。传球要干脆而短。有意识地。控制好球。始终保持对球的关注。
- en: Watch a recreational player and then watch an **elite player** (**EP**) play
    the game. What is the the main difference? How well does EP receive the ball?
    How well does EP pass the ball? Does EP play the ball into space in the path of
    their teammate or does EP kick long balls in the general direction of the opponent's
    goal?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 观看业余球员，然后观看一位**精英球员**（**EP**）踢球。主要区别是什么？EP接球有多好？EP传球有多好？EP是否将球传到队友的空间中，还是朝着对手球门的方向踢长传球？
- en: Move (to open space), receive (the ball), then pass (the ball). Teams that do
    that well consistently win. What are we talking about here? Interfaces. Teams
    that pass the ball effectively from player to player win more games.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 移动（到开放空间），接球，然后传球。做得好的球队一直能赢。我们在谈论什么？接口。能够有效地从一个球员传球到另一个球员的球队赢得更多比赛。
- en: We can learn from this. If we strive to write self-documenting APIs (move to
    open space) then our API becomes more accessible to our clients. When the APIs
    that we call are similarly designed (as simple as possible, requiring only mandatory
    parameters, with sensible defaults) our system will be highly interoperable and
    efficient.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从中学到东西。如果我们努力编写自我说明的API（移动到开放空间），那么我们的API对我们的客户更加可访问。当我们调用的API设计类似（尽可能简单，只需要强制参数，具有合理的默认值）时，我们的系统将具有高度的互操作性和效率。
- en: '![](img/dad32d2b-040a-4512-805b-64f2f26016e3.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dad32d2b-040a-4512-805b-64f2f26016e3.png)'
- en: Real Madrid, an amazing team, plays combinations and passing. Our APIs should
    interoperate like the Real Madrid team in the video at [https://www.youtube.com/watch?v=b6_IUVBAJJ0](https://www.youtube.com/watch?v=b6_IUVBAJJ0).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 皇家马德里，一个了不起的球队，进行组合和传球。我们的API应该像视频中的皇家马德里队一样进行互操作[https://www.youtube.com/watch?v=b6_IUVBAJJ0](https://www.youtube.com/watch?v=b6_IUVBAJJ0)。
- en: Was that a typical use case? Assuming the soccer ball is our data/message, when
    would we want to pass a message along, avoiding opponents, to move API endpoints
    and deposit it in the goal unchanged?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的用例吗？假设足球是我们的数据/消息，我们何时想要传递消息，避开对手，将API端点移动并将其不变地存入目标？
- en: Functional parameters - Rowe
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 功能参数 - Rowe
- en: Watch the throw-in to Rowe. What Kelyn Rowe does with the ball is like what
    a functional parameter can do in its callee. Compare that magic with the passing
    we see in recreational soccer or with passing a dead value in a `Context`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 观看罗的掷界外球。Kelyn Rowe对球的处理就像调用者中的功能参数可以做的事情一样。将这种魔术与我们在业余足球中看到的传球或在`Context`中传递死值进行比较。
- en: '![](img/f4944efe-2911-4a8a-9961-48c4a403f2f7.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4944efe-2911-4a8a-9961-48c4a403f2f7.png)'
- en: Dom Dwyer scored Team USA 1-0 over Panama; refer to this video at [https://www.youtube.com/watch?v=CVXPeGhPXkE](https://www.youtube.com/watch?v=CVXPeGhPXkE).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Dom Dwyer在美国队以1-0击败巴拿马；请参考此视频[https://www.youtube.com/watch?v=CVXPeGhPXkE](https://www.youtube.com/watch?v=CVXPeGhPXkE)。
- en: Report example
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 报告示例
- en: 'The values in the `Context` are affecting the control flow of the application.
    Let''s refactor it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`中的值会影响应用程序的控制流。让我们重构一下：'
- en: '[PRE22]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, using `Context` to pass values only obfuscates our intention and
    makes our code less readable. We'd be hard pressed to find a good use case for
    `Context` values in real-world applications.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用`Context`传递值只会混淆我们的意图，并使我们的代码不太可读。在现实世界的应用程序中，我们很难找到`Context`值的一个好用例。
- en: A more practical Context use case
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个更实际的上下文使用案例
- en: A more practical `Context` use case would be to send a `Cancel` message to a
    long-running function.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更实际的`Context`使用案例是向长时间运行的函数发送`Cancel`消息。
- en: Several use cases come to mind when dealing with database transactions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据库事务时，会想到几种用例。
- en: 'In some cases a request could generate a number of child requests, each running
    for varying amounts of time and consuming various resources. If during our database
    transaction, one of our child requests panics, we could use the `Context` to signal
    all routines to cancel and to free up all transaction-related resources:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个请求可能会生成多个子请求，每个请求运行的时间和消耗的资源各不相同。如果在我们的数据库事务期间，其中一个子请求发生恐慌，我们可以使用`Context`来发出取消所有例程的信号，并释放所有与事务相关的资源：
- en: '[PRE23]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Provide access to the `sql.DB` commit and rollback:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 提供对`sql.DB`提交和回滚的访问：
- en: '[PRE24]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `TxFunc` param is a functional parameter provided to the `db.WithTransaction`
    function. It will execute the given function within the context of the database
    transaction. If an error occurs, the transaction will be rolled back:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`TxFunc`参数是提供给`db.WithTransaction`函数的一个功能参数。它将在数据库事务的上下文中执行给定的函数。如果发生错误，则事务将被回滚：'
- en: '[PRE25]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Db uses the `sql.DB` implementation to access the `Begin` and `Commit` transaction:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Db使用`sql.DB`实现来访问`Begin`和`Commit`事务：
- en: '[PRE26]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `WithTransaction` function is a function that provides a `Transaction`
    interface that can be used to perform SQL operations in a transaction. If the
    function returns an error, then the transaction will be rolled back:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithTransaction`函数是一个提供`Transaction`接口的函数，可以用于在事务中执行SQL操作。如果函数返回错误，则事务将被回滚：'
- en: '[PRE27]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Begin the transaction:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 开始事务：
- en: '[PRE28]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Rollback if an error occurred during the transaction:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事务期间发生错误，则回滚：
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Execute the function that performs the SQL operations in the transaction.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 执行在事务中执行SQL操作的函数。
- en: See the `fn(tx)` function?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 看到`fn(tx)`函数了吗？
- en: 'That''s where our functional parameter is executed. That''s where the real
    work is performed. It''s where the logic that performs SQL queries runs. It executes
    in the context of the transaction. So, if any of the queries or subqueries fail,
    the entire transaction will be rolled back:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的函数参数被执行的地方。这就是真正的工作执行的地方。这是执行执行SQL查询的逻辑的地方。它在事务的上下文中执行。因此，如果任何查询或子查询失败，整个事务将被回滚：
- en: '[PRE30]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Commit the transaction and set `isCommitted` to true to indicate success:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 提交事务并将`isCommitted`设置为true以指示成功：
- en: '[PRE31]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We're done with our look at Context. Now, back to the functional parameters
    solution...
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对上下文的查看。现在，回到功能参数解决方案...
- en: src/server/server.go
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: src/server/server.go
- en: 'We can skim the imports to get an idea of what we''ll be doing in this file.
    We''ll process some HTTP requests, marshal some JSON-converting strings to integers,
    handle errors, and implement a logger for our server:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以浏览导入以了解我们将在这个文件中做些什么。我们将处理一些HTTP请求，将一些JSON转换字符串转换为整数，处理错误，并为我们的服务器实现一个日志记录器：
- en: '[PRE32]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''ll define three constants and use them when defining our default values:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义三个常量，并在定义默认值时使用它们：
- en: '[PRE33]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our `Server` struct has three fields:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Server`结构有三个字段：
- en: '[PRE34]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here''s the `Logger` type:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Logger`类型：
- en: '[PRE35]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We use the handler to provide the `ServeHTTP`, which is a `Handler` that responds
    to HTTP requests:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用处理程序提供`ServeHTTP`，这是一个响应HTTP请求的`Handler`：
- en: '[PRE36]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: New is our server constructor. New is a variadic function that receives an arbitrary
    number of functional parameters of type `ServerOption`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 新的是我们的服务器构造函数。`New`是一个可变函数，接收类型为`ServerOption`的任意数量的功能参数。
- en: Note that the `opt` param is a variadic parameter of type `ServerOption`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`opt`参数是`ServerOption`类型的可变参数。
- en: 'We return a pointer to our newly created `Server` object and the idiomatic
    `error` value:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回一个指向我们新创建的`Server`对象的指针和惯用的`error`值：
- en: '[PRE37]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'First, we prepopulate our options with default values:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用默认值预填充我们的选项：
- en: '[PRE38]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we iterate through each `ServerOption`. The following is the signature
    for a `ServerOption`. We see that we use it to define the function type variables
    that accept a pointer to the options:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历每个`ServerOption`。以下是`ServerOption`的签名。我们看到我们使用它来定义接受指向选项的函数类型变量：
- en: '[PRE39]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If an error is found, we wrap our error to be returned and exit this function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现错误，我们会将错误包装起来返回并退出这个函数：
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, we create our `Server` variable and populate it with the functional parameters
    (`opts`) as well as a `logger`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了我们的`Server`变量，并用功能参数(`opts`)以及一个`logger`填充它：
- en: '[PRE41]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Before returning a call, our server's `register` method with our HTTP multiplexer
    (mux). A mux matches the URL incoming requests against registered patterns and
    calls the handler for the pattern that most closely matches the requested URL.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回调用之前，我们的服务器的`register`方法与我们的HTTP多路复用器（mux）一起。mux将传入的URL请求与注册的模式进行匹配，并调用最接近请求的URL的模式的处理程序。
- en: 'Here''s the the `register` method:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`register`方法：
- en: '[PRE42]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that we use the `useNumberHandler` option to determine which handler to
    associate with our root path "`/`".
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`useNumberHandler`选项来确定与我们的根路径"`/`"关联的处理程序。
- en: This is a contrived mux example used to illustrate a use for server options.
    In production, you're likely better off using packages such as [https://github.com/gorilla/mux](https://github.com/gorilla/mux)
    and [https://github.com/justinas/alice](https://github.com/justinas/alice) on
    top of [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个虚构的mux示例，用于说明服务器选项的用法。在生产中，您可能更好地使用诸如[https://github.com/gorilla/mux](https://github.com/gorilla/mux)和[https://github.com/justinas/alice](https://github.com/justinas/alice)这样的包，以及[https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/)。
- en: If `s.opts.useNumberHandler` is `true`, then the mux will call the `http.HandlerFunc`
    function and pass the `displayNumber` function as its only functional parameter.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`s.opts.useNumberHandler`为`true`，那么mux将调用`http.HandlerFunc`函数，并将`displayNumber`函数作为其唯一的函数参数传递。
- en: 'The `displayNumber` function in an HTTP  that uses a few server options to
    determine how to handle the `request:handler`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayNumber`函数在一个HTTP中使用了一些服务器选项来确定如何处理`request:handler`：'
- en: '[PRE43]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the following block of code we compare the number entered by the user to
    the `maxNumber` server option value. If the entered value is greater than the
    max value, we display an error message; otherwise, we continue processing:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们将用户输入的数字与`maxNumber`服务器选项值进行比较。如果输入值大于最大值，我们显示错误消息；否则，我们继续处理：
- en: '[PRE44]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If there is no convert function (`convertFn`), then we set the number to be
    displayed (`displayNumber`) to the value entered by the user.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有转换函数（`convertFn`），那么我们将要显示的数字（`displayNumber`）设置为用户输入的值。
- en: 'However, if `convertFn` is defined, we pass the number to it, execute it, and
    assign the return value to `displayNumber`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果定义了`convertFn`，我们将数字传递给它，执行它，并将返回值赋给`displayNumber`：
- en: '[PRE45]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: See how we use a function literal in `main()` with the `fmt.Sprintf` command
    to affect the displayed number?
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何在`main()`中使用函数文字与`fmt.Sprintf`命令来影响显示的数字？
- en: '[PRE46]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To see our number in a hexadecimal format, we''ll open a web browser and enter
    this in the address bar:` http://localhost:8080/?number=255`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要以十六进制格式查看我们的数字，我们将在浏览器中输入以下内容到地址栏：`http://localhost:8080/?number=255`：
- en: '![](img/48c67ccc-29e5-4d74-ab0e-4a2ae7f3cca9.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48c67ccc-29e5-4d74-ab0e-4a2ae7f3cca9.png)'
- en: 'Want to see the `displayNumber` in different format? If so: stop the app by
    entering *Ctrl* + *C* in the terminal console. In `main.go`, change` fmt.Sprintf("%x",
    x)` to`  fmt.Sprintf("%b", x)` and restart the app by entering the `go-run` command.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 想以不同的格式看`displayNumber`吗？如果是：在终端控制台中输入*Ctrl* + *C*停止应用程序。在`main.go`中，将`fmt.Sprintf("%x",
    x)`更改为`fmt.Sprintf("%b", x)`，然后输入`go-run`命令重新启动应用程序。
- en: '[PRE47]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When we go back to our web browser and refresh we see our number 255 in a binary
    format:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回到我们的网络浏览器并刷新时，我们会看到我们的数字255以二进制格式显示：
- en: '![](img/5447be32-88c9-4b52-a5aa-d0c94d05ad63.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5447be32-88c9-4b52-a5aa-d0c94d05ad63.png)'
- en: 'If we were to comment out the `server.FormatNumber` parameter, we''d get the
    number entered by the user without formatting:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们注释掉`server.FormatNumber`参数，我们将得到用户输入的未经格式化的数字：
- en: '[PRE48]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![](img/820bcbad-1664-4d32-b794-b1099e3b13a3.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/820bcbad-1664-4d32-b794-b1099e3b13a3.png)'
- en: Refer to the following resource for more `Sprintf` options [http://lexsheehan.blogspot.com/search?q=octal+hex+printf](http://lexsheehan.blogspot.com/2015/02/fmtprintf-format-reference.html).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下资源以获取更多的`Sprintf`选项 [http://lexsheehan.blogspot.com/search?q=octal+hex+printf](http://lexsheehan.blogspot.com/2015/02/fmtprintf-format-reference.html)。
- en: 'If there is an error, we display it. If there are no errors, we display our
    (possibly formatted) number:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有错误，我们将显示它。如果没有错误，我们将显示我们的（可能经过格式化的）数字：
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Our last project file that we'll examine contains our `ServerOption` functions.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的最后一个项目文件包含我们的`ServerOption`函数。
- en: The src/server/server_options.go file
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: src/server/server_options.go文件
- en: 'We''ll use the Go standard library errors package because we simply want to
    create an error object:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Go标准库的errors包，因为我们只是想创建一个错误对象：
- en: '[PRE50]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We define a `ServerOption` type to simplify our function signatures:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`ServerOption`类型来简化我们的函数签名：
- en: '[PRE51]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Currying allows functions to yield new functions as their return value. Is that
    what `MaxNumber` is doing? `MaxNumber` is a function and returns a `ServerOption`.
    A `SeverOption` is a function. So, yes. We have some currying going on here.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化允许函数产生新的函数作为它们的返回值。`MaxNumber`正在这样做吗？`MaxNumber`是一个函数，并返回一个`ServerOption`。`SeverOption`是一个函数。所以，是的。我们在这里进行了柯里化。
- en: 'Our first `ServerOption` function is `MaxNumber`. It has a simple responsibility:
    assigning the value of its argument (`n`) to our option''s `maxNumber` field:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个`ServerOption`函数是`MaxNumber`。它有一个简单的职责：将其参数（`n`）的值分配给我们选项的`maxNumber`字段：
- en: '[PRE52]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that `MaxNumber` is a function that returns a function that returns an
    error. Since there is no possibility of an error occurring in this function, we
    simply return nil.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`MaxNumber`是一个返回错误的函数。由于在此函数中不可能发生错误，我们只是返回nil。
- en: Other `ServerOption` functions can be more complicated and we might run into
    an error condition in one of those non-trivial functions and have the need to
    return an error.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 其他`ServerOption`函数可能更复杂，我们可能会在其中一些非平凡的函数中遇到错误条件，并且需要返回一个错误。
- en: 'The `MaxConcurrenConnections` function has a conditional statement, as shown
    here:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`MaxConcurrenConnections`函数有一个条件语句，如下所示：'
- en: '[PRE53]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The next two functions provide the ability to format our input number.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个函数提供了格式化我们输入数字的能力。
- en: 'The `convert` type is a function type that accepts an int and returns a string
    and possibly an error:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert`类型是一个接受int并返回string和可能的错误的函数类型：'
- en: '[PRE54]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `FormatNumber` function is another `ServerOption`. Unlike the other ones,
    which accept scalar input values, `FormatNumber` accepts a function parameter
    of type `convert`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormatNumber`函数是另一个`ServerOption`。与其他接受标量输入值的函数不同，`FormatNumber`接受类型为`convert`的函数参数：'
- en: '[PRE55]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s take another look at `main()`, where `FormatNumber` is called:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下`main()`，在那里调用了`FormatNumber`：
- en: '[PRE56]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `FormatNumber` function''s argument is passed in as a functional parameter.
    It is an anonymous function that satisfies the signature of a convert function
    type:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormatNumber`函数的参数作为函数参数传递。它是一个满足转换函数类型签名的匿名函数：'
- en: '[PRE57]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The function accepts an `int` and returns a string and and error.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个`int`并返回一个字符串和一个错误。
- en: '`FormatNumber` has one statement--the return statement. It returns a `ServerOption`
    function after it executes the convert function (fn).'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormatNumber`只有一个语句——返回语句。它在执行转换函数（fn）后返回一个`ServerOption`函数。'
- en: 'Don''t be confused by the fact that we know that the convert function receives
    an int but we do not see it in the anonymous return function: `o.convertFn = fn`.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这样一个事实所困惑，即我们知道转换函数接收一个int，但在匿名返回函数中我们看不到它：`o.convertFn = fn`。
- en: 'The line of code, `o.convertFn = fn`, is executed by `main()`; when it runs
    it creates the `newServer` value:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 代码行`o.convertFn = fn`由`main()`执行；当它运行时，创建了`newServer`值：
- en: '[PRE58]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'What it''s doing is assigning the `fn` function to the `convertFn` function''s
    `SeverOption` value:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的是将`fn`函数分配给`convertFn`函数的`SeverOption`值：
- en: '[PRE59]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It''s not until the user submits a request and that request is handled by the
    `displayNumber` function that the following line is executed:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 直到用户提交请求并且该请求由`displayNumber`函数处理时，才执行以下行：
- en: '[PRE60]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That's where the `int` number is actually passed to the `convertFn` function.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`int`数字实际传递给`convertFn`函数的地方。
- en: 'The last `ServerOption` function is `UserNumberHandler`. It is simple, quite
    like `MaxNumber`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个`ServerOption`函数是`UserNumberHandler`。它很简单，很像`MaxNumber`：
- en: '[PRE61]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Go is designed using good ideas from both FP and OOP world. For example, go
    borrowed interfaces, duck typing, and composition over inheritance from OOP world
    and functions as first class citizens from the FP world.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Go是使用函数式编程和面向对象编程世界中的好思想设计的。例如，Go从面向对象编程世界借鉴了接口、鸭子类型和组合优于继承的概念，从函数式编程世界借鉴了函数作为一等公民的概念。
- en: Go is a perfect example of being pragmatic. Go took the better principles from
    both OOP and FP paradigms, while clearly ignoring many ideas from each. Perhaps,
    this perfectly balanced design is what makes Go so special? In that way, Go is
    the perfect ratio of software languages.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Go是实用主义的完美例子。Go吸收了面向对象编程和函数式编程范式中更好的原则，同时明显地忽略了许多思想。也许，这种完美平衡的设计是使Go如此特别的原因？从这个角度看，Go是软件语言的完美比例。
- en: See [Chapter 11](../Text/Ch11.xhtml), *Category Theory That Applies*, for a
    discussion about the golden ration.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 有关黄金比例的讨论，请参阅[第11章](../Text/Ch11.xhtml)，*适用的范畴论*。
- en: In the next chapter, we'll delve more deeply into pure functional programming.
    We'll see how to leverage category theory and class types to abstract away details
    in order to glean new insights. We'll look at functors along with slightly stronger
    and more useful versions of functors called applicative functors. You'll also
    learn how to bring the world of side-effects under control using Monads and Monoids.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨纯函数式编程。我们将看到如何利用范畴论和类类型来抽象细节以获得新的见解。我们将研究函子以及稍微更强大和更有用的函子的版本，称为应用函子。您还将学习如何使用单子和幺半群控制副作用世界。
