["```go\nimperative loop: [2 3 4]\nfp map: [2 3 4]\n```", "```go\ninstance Functor Maybe where\nfmap f Nothing = Nothing\nfmap f (Just x) = Just (f x)\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n)\n\nfunc int8Sum(list []int8) (int8) {\n   var result int8 = 0\n for x := 0; x < len(list); x++ {\n      result += list[x]\n   }\n   return result\n}\n\nfunc int32Sum(list []int32) (int32) {\n   var result int32 = 0\n for x := 0; x < len(list); x++ {\n      result += list[x]\n   }\n   return result\n}\n\nfunc float64Sum(list []float64) (float64) {\n   var result float64 = 0\n for x := 0; x < len(list); x++ {\n      result += list[x]\n   }\n   return result\n}\n\nfunc complex128Sum(list []complex128) (complex128) {\n   var result complex128 = 0\n for x := 0; x < len(list); x++ {\n      result += list[x]\n   }\n   return result\n}\n\nfunc main() {\n   fmt.Println(\"int8Sum:\", int8Sum([]int8 {1, 2, 3}))\n   fmt.Println(\"int32Sum:\", int32Sum([]int32{1, 2, 3}))\n   fmt.Println(\"float64Sum:\", float64Sum([]float64{1, 2, 3}))\n   fmt.Println(\"complex128Sum:\", complex128Sum([]complex128{1, 2, 3}))\n}\n```", "```go\nint8Sum: 6\nint32Sum: 6\nfloat64Sum: 6\ncomplex128Sum: (6+0i)\n```", "```go\nfunc Sum(list []<T>) (<T>) {\n   var ret <T> = 0\n   for item := range list {\n      ret += item\n   }\n   return ret\n}\n```", "```go\n\"List <A>\".Replace(\"<A>\", a)\n```", "```go\n\"List <T>\".Replace(\"<T>\", \"Foo\")\n\"List <T>\".Replace(\"<T>\", \"Bar\")\n```", "```go\ncd <DEVDIR>/fp-go/4-purely-functional/ch11-functor-monoid/03_generics_cars\n. init\nglide-update\ngo get github.com/clipperhouse/gen\n```", "```go\npackage car\n\n// +gen slice:\"Where,Sum[Dollars],GroupBy[string],Select[Dollars]\"\ntype Car struct {\n   Make string\n   Model string\n   Price Dollars\n}\n\ntype Dollars int\n```", "```go\n// Generated by: gen\n// TypeWriter: slice\n// Directive: +gen on Car\n\npackage car\n\n// CarSlice is a slice of type Car. Use it where you would use []Car.\ntype CarSlice []Car\n\n// Where returns a new CarSlice whose elements return true for func. See: http://clipperhouse.github.io/gen/#Where\nfunc (rcv CarSlice) Where(fn func(Car) bool) (result CarSlice) {\n   for _, v := range rcv {\n      if fn(v) {\n         result = append(result, v)\n      }\n   }\n   return result\n}\n\n// SumDollars sums Car over elements in CarSlice. See: http://clipperhouse.github.io/gen/#Sum\nfunc (rcv CarSlice) SumDollars(fn func(Car) Dollars) (result Dollars) {\n   for _, v := range rcv {\n      result += fn(v)\n   }\n   return\n}\n\n// GroupByString groups elements into a map keyed by string. See: http://clipperhouse.github.io/gen/#GroupBy\nfunc (rcv CarSlice) GroupByString(fn func(Car) string) map[string]CarSlice {\n   result := make(map[string]CarSlice)\n   for _, v := range rcv {\n      key := fn(v)\n      result[key] = append(result[key], v)\n   }\n   return result\n}\n\n// SelectDollars projects a slice of Dollars from CarSlice, typically called a map in other frameworks. See: http://clipperhouse.github.io/gen/#Select\nfunc (rcv CarSlice) SelectDollars(fn func(Car) Dollars) (result []Dollars) {\n   for _, v := range rcv {\n      result = append(result, fn(v))\n   }\n   return\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n . \"car\"\n)\n\nfunc main() {\n   var cars = CarSlice{\n      Car{\"Honda\", \"Accord\", 3000},\n      Car{\"Lexus\", \"IS250\", 40000},\n      Car{\"Toyota\", \"Highlander\", 3500},\n      Car{\"Honda\", \"Accord ES\", 3500},\n   }\n   fmt.Println(\"cars:\", cars)\n```", "```go\nOutput:cars: [{honda accord 3000} {lexus is250 40000} {toyota highlander 3500} {honda accord es 3500}]\n```", "```go\n\n   var cars = Slice<Car>{\n      Car{\"Honda\", \"Accord\", 3000},\n      Car{\"Lexus\", \"IS250\", 40000},\n      Car{\"Toyota\", \"Highlander\", 3500},\n      Car{\"Honda\", \"Accord ES\", 3500},\n   }\n   fmt.Println(\"cars:\", cars)\n```", "```go\nhonda := func (c Car) bool {\n   return c.Make == \"Honda\"\n}\nfmt.Println(\"filter cars by 'Honda':\", cars.Where(honda))\n```", "```go\nfilter cars by 'honda': [{honda accord 3000} {honda accord es 3500}]\n```", "```go\nprice := func (c Car) Dollars {\n   return c.Price\n}\nfmt.Println(\"Hondas prices:\", cars.Where(honda).SelectDollars(price))\n```", "```go\nhondas prices: [3000 3500]\n```", "```go\nfmt.Println(\"Hondas sum(prices):\", cars.Where(honda).SumDollars(price))\n```", "```go\nhondas sum(prices): 6500\n```", "```go\ncd <DEVDIR>/fp-go/4-purely-functional/ch11-functor-monoid/04_generics_nums\n. init\nglide-update\n```", "```go\ngo get github.com/clipperhouse/gen\n```", "```go\ncd src/num;gen;cd -\n```", "```go\npackage num\n\n// +gen slice:\"Sum[Int8]\"\ntype Int8 int8\n\n// +gen slice:\"Sum[Int32]\"\ntype Int32 int32\n\n// +gen slice:\"Sum[Float64]\"\ntype Float64 float64\n\n// +gen slice:\"Sum[Complex128]\"\ntype Complex128 complex128\n```", "```go\n// Generated by: gen\n// TypeWriter: slice\n// Directive: +gen on Int8\n\npackage num\n\n// Int8Slice is a slice of type Int8\\. Use it where you would use []Int8.\ntype Int8Slice []Int8\n\n// SumInt8 sums Int8 over elements in Int8Slice. See: http://clipperhouse.github.io/gen/#Sum\nfunc (rcv Int8Slice) SumInt8(fn func(Int8) Int8) (result Int8) {\n   for _, v := range rcv {\n      result += fn(v)\n   }\n   return\n}\n```", "```go\nprice := func (c Car) Dollars {\n   return c.Price\n}\nfmt.Println(\"Hondas prices:\", cars.Where(honda).SelectDollars(price))\n```", "```go\npackage num\n\nvar (\n   Int8fn = func (n Int8) Int8 { return n }\n   Int32fn = func (n Int32) Int32 { return n }\n   Float64fn = func (n Float64) Float64 { return n }\n   Complex128fn = func (n Complex128) Complex128 { return n }\n)\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n . \"num\"\n)\n\nfunc main() {\n   fmt.Println(\"int8Sum:\", Int8Slice{1, 2, 3}.SumInt8(Int8fn))\n   fmt.Println(\"int32Sum:\", Int32Slice{1, 2, 3}.SumInt32(Int32fn))\n   fmt.Println(\"float64Sum:\", Float64Slice{1, 2, 3}.SumFloat64(Float64fn))\n   fmt.Println(\"complex128Sum:\", Complex128Slice{1, 2, 3}.SumComplex128(Complex128fn))\n}\n```", "```go\nint8Sum: 6\nint32Sum: 6\nfloat64Sum: 6\ncomplex128Sum: (6+0i)\n```", "```go\n// +gen slice:\"Where,GroupBy[int],Any\"\n type Example struct {}\n```", "```go\nfunc (ExampleSlice) AggregateT(func(T, Example) T) T\n```", "```go\n// +gen slice:\"Aggregate[string]\"\n type Employee struct{\n Name   string\n Department string\n }\n\n employees := EmployeeSlice {\n {\"Alice\", \"Accounting\"},\n {\"Bob\", \"Back Office\"},\n {\"Carly\", \"Containers\"},\n }\n\n join := func(state string, e Employee) string {\n    if state != \"\" {\n        state += \", \"\n    }\n    return state + e.Name\n }\n\n employees.AggregateString(join) // => \"Alice, Bob, Carly\"\n```", "```go\nints := []int{1,2,3}\nimpInts := []int{}\nfor _, v := range ints {\n   impInts = append(impInts, v + 2)\n}\nfmt.Println(\"imperative loop:\", impInts)\n```", "```go\nimperative loop: [3 4 5]\n```", "```go\nadd2 := func(i int) int { return i + 2 }\nfpInts := Functor(ints).Map(add2)\nfmt.Println(\"fp map:\", fpInts)\n```", "```go\nfp map: [3 4 5]\n```", "```go\npackage functor\n\nimport (\n   \"fmt\"\n)\n\ntype IntFunctor interface {\n   Map(f func(int) int) IntFunctor\n}\n```", "```go\ntype intBox struct {\n   ints []int\n}\n```", "```go\nfunc (box intBox) Map(f func(int) int) IntFunctor {\n   for i, el := range box.ints {\n      box.ints[i] = f(el)\n   }\n   return box\n}\n```", "```go\nfunc Functor(ints []int) IntFunctor {\n   return intBox{ints: ints}\n}\n```", "```go\nfpInts := Functor(ints).Map(add2)\n```", "```go\nfunc (box intBox) String() string {\n   return fmt.Sprintf(\"%+v\", box.ints)\n}\n```", "```go\ntype Stringer interface {\n    String() string\n}\n```", "```go\n// /usr/local/Cellar/go/1.9/libexec/src/fmt/print.go\n// If a string is acceptable according to the format, see if\n// the value satisfies one of the string-valued interfaces.\n// Println etc. set verb to %v, which is \"stringable\".\nswitch verb {\ncase 'v', 's', 'x', 'X', 'q':\n   // Is it an error or Stringer?\n // The duplication in the bodies is necessary:\n // setting handled and deferring catchPanic\n // must happen before calling the method.\n switch v := p.arg.(type) {\n   case error:\n      handled = true\n defer p.catchPanic(p.arg, verb)\n      p.fmtString(v.Error(), verb)\n      return\n\n case Stringer:\n      handled = true\n defer p.catchPanic(p.arg, verb)\n      p.fmtString(v.String(), verb)\n      return\n }\n}\n```", "```go\nfmap id  ==  id\nfmap (f . g)  ==  fmap f . fmap g\n```", "```go\n> (.) g f = \\x -> g (f x)\n> :t (.)\n(.) :: (b -> c) -> (a -> b) -> a -> c\n```", "```go\npackage compose\n\nfunc Humanize(b bool) string {\n   if b { return \"yes\" } else { return \"no\" }\n}\n\nfunc Emphasize(s string) string {\n   return s + \"!!\"\n}\n\nfunc EmphasizeHumanize(b bool) string {\n   return Emphasize(Humanize(b))\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n . \"compose\"\n)\n\nfunc main() {\n   fmt.Println(\"A to B - Humanize(true):\", Humanize(true))\n   fmt.Println(\"B to C - Emphasize(\\\"yes\\\"):\", Emphasize(\"yes\"))\n   fmt.Println(\"A to C - EmphasizeHumanizeFG(true)\", EmphasizeHumanizeFG(true))\n}\n```", "```go\nhumanize b = if b then \"yes\" else \"no\"\nemphasize str = str ++ \"!\"\ncompose g f = \\x -> g (f x)\nemphasizeHumanize = compose emphasize humanize\nemphasizeHumanize True\n```", "```go\n:t humanize\nhumanize :: Bool -> [Char]\n```", "```go\ncompose g f = \\x -> g (f x)\n```", "```go\n:t compose\n compose :: (t2 -> t1) -> (t -> t2) -> t -> t1\n```", "```go\n:t (.)\n (.) :: (b -> c) -> (a -> b) -> a -> c\n```", "```go\nemphasizeHumanize = compose emphasize humanize\n```", "```go\n:t emphasizeHumanize\n emphasizeHumanize :: Bool -> [Char]\n```", "```go\nemphasizeHumanize True\n \"yes!\"\n```", "```go\n(.) g f = \\x -> g (f x)\n```", "```go\n:t (.)\n(.) :: (t2 -> t1) -> (t -> t2) -> t -> t1\n```", "```go\nemphasizeHumanize = (.) emphasize humanize\nemphasizeHumanize True\n \"yes!\" \n```", "```go\nemphasizeHumanize = emphasize . humanize\n```", "```go\nemphasizeHumanize True\n \"yes!\"\nemphasizeHumanize False\n \"no!\"\n```", "```go\npackage compose\n\nfunc Humanize(b bool) string {\n   if b { return \"yes\" } else { return \"no\" }\n}\n\nfunc Emphasize(s string) string {\n   return s + \"!!\"\n}\n\nfunc EmphasizeHumanize(b bool) string {\n   return Emphasize(Humanize(b))\n}\n```", "```go\ntype Fbs func(bool) string\ntype Fss func(string) string\n```", "```go\nfunc Compose(g Fss, f Fbs) Fbs {\n   return func(x bool) string {\n      return g(f(x))\n   }\n}\n```", "```go\nvar Emphasize_Humanize = Compose(Emphasize, Humanize)\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n . \"compose\"\n)\n\nfunc main() {\n   fmt.Println(\"A to B - Humanize(true):\", Humanize(true))\n   fmt.Println(\"B to C - Emphasize(\\\"yes\\\"):\", Emphasize(\"yes\"))\n   fmt.Println(\"A to C - EmphasizeHumanize(true):\", EmphasizeHumanize(true))\n   fmt.Println(\"A to C - Emphasize_Humanize(true):\", Emphasize_Humanize(true))\n}\n```", "```go\nfunc Compose(f Fss, g Fbs) Fbs {\n   return func(n bool) string {\n      return g(f(n))\n   }\n}\n```", "```go\nvar EmphasizeHumanizeFoG = Compose(Emphasize, Humanize)\n```", "```go\nfunc Compose(g Fss, f Fbs) Fbs {\n   return func(x bool) string {\n      return g(f(x))\n   }\n}\n```", "```go\n// src/functor/clock.go\n\npackage functor\n\nimport (\n   \"fmt\"\n)\n```", "```go\ntype ClockFunctor interface {\n   Map(f func(int) int) ClockFunctor\n}\n```", "```go\ntype hourContainer struct {\n   hours []int\n}\n```", "```go\nfunc (box hourContainer) Map(f func(int) int) ClockFunctor {\n   for i, el := range box.hours {\n      box.hours[i] = f(el)\n   }\n   return box\n}\n```", "```go\nfunc Functor(hours []int) ClockFunctor {\n   return hourContainer{hours: hours}\n}\n```", "```go\nvar Unit = func(i int) int {\n   return (i)\n}\n```", "```go\nvar AmPmMapper = func(i int) int {\n   return (i + 12) % 24\n}\n```", "```go\nfunc AmHoursFn()  []int {\n   return []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}\n}\n```", "```go\nfunc (box hourContainer) String() string {\n   return fmt.Sprintf(\"%+v\", box.hours)\n}\n```", "```go\npackage main\n\nimport (\n   . \"functor\"\n \"fmt\"\n)\n\nfunc main() {\n```", "```go\nfmt.Println(\"initial state :\", Functor(AmHoursFn()))\n```", "```go\ninitial state : [1 2 3 4 5 6 7 8 9 10 11 12]\n```", "```go\nfmt.Println(\"unit application :\", Functor(AmHoursFn()).Map(Unit))\n```", "```go\nunit application : [1 2 3 4 5 6 7 8 9 10 11 12]\n```", "```go\nfmt.Println(\"1st application :\", Functor(AmHoursFn()).Map(AmPmMapper))\n```", "```go\n1st application : [13 14 15 16 17 18 19 20 21 22 23 0]\n```", "```go\nfmt.Println(\"chain applications:\", Functor(AmHoursFn()).Map(AmPmMapper).Map(AmPmMapper))\n```", "```go\nchain applications: [1 2 3 4 5 6 7 8 9 10 11 12]\n```", "```go\nFunctor([]int{1, 2, 3}).Map(mapperFn).Map(mapperFn))\n```", "```go\npackage functor\n\nimport (\n   \"fmt\"\n \"strings\"\n)\n\ntype (\n   Car struct {\n      Make string `json:\"make\"`\n Model string `json:\"model\"`\n }\n)\n```", "```go\ntype CarFunctor interface {\n   Map(f func(Car) Car) CarFunctor\n}\n```", "```go\ntype carContainer struct {\n   cars []Car\n}\n```", "```go\nfunc (box carContainer) Map(f func(Car) Car) CarFunctor {\n   for i, el := range box.cars {\n      box.cars[i] = f(el)\n   }\n   return box\n}\n```", "```go\nfunc Wrap(cars []Car) CarFunctor {\n   return carContainer{cars: cars}\n}\n```", "```go\nvar (\n   Unit = func(i Car) Car {\n      return (i)\n   }\n\n   Upgrade = func(car Car) Car {\n      if !strings.Contains(car.Model, \" LX\") {\n         car.Model += \" LX\"\n } else if !strings.Contains(car.Model, \" Limited\") {\n         car.Model += \" Limited\"\n }\n      return car\n   }\n\n   Downgrade = func(car Car) Car {\n      if strings.Contains(car.Model, \" Limited\") {\n         car.Model = strings.Replace(car.Model, \" Limited\", \"\", -1)\n      } else if strings.Contains(car.Model, \" LX\") {\n         car.Model = strings.Replace(car.Model, \" LX\", \"\", -1)\n      }\n      return car\n   }\n)\n```", "```go\nfunc (box carContainer) String() string {\n   return fmt.Sprintf(\"%+v\", box.cars)\n}\n```", "```go\npackage main\n\nimport (\n   \"encoding/json\"\n \"fmt\"\n \"functor\"\n \"strings\"\n)\n```", "```go\nfunc main() {\n\n   cars := []functor.Car{\n      {\"Honda\", \"Accord\"},\n      {\"Lexus\", \"IS250\"}}\n\n   str := `{\"make\": \"Toyota\", \"model\": \"Highlander\"}`\n highlander := functor.Car{}\n   json.Unmarshal([]byte(str), &highlander)\n   cars = append(cars, highlander)\n```", "```go\nfmt.Println(\"initial state :\", functor.Wrap(cars))\nfmt.Println(\"unit application:\", functor.Wrap(cars).Map(functor.Unit))\nfmt.Println(\"one upgrade :\", functor.Wrap(cars).Map(functor.Upgrade))\nfmt.Println(\"chain upgrades :\", functor.Wrap(cars).Map(functor.Upgrade).Map(functor.Upgrade))\nfmt.Println(\"one downgrade :\", functor.Wrap([]functor.Car{{\"Honda\", \"Accord\"}, {\"Lexus\", \"IS250 LX\"}, {\"Toyota\", \"Highlander LX Limited\"}}).Map(functor.Downgrade))\n```", "```go\n// FUNCTIONAL STYLE\nfmt.Println(\"up and downgrade:\", functor.Wrap(cars).Map(functor.Upgrade).Map(functor.Downgrade))\n\n// IMPERATIVE STYLE\ncars2 := []functor.Car{}\nfor _, car := range cars {\n   // upgrade\n if !strings.Contains(car.Model, \" LX\") {\n      car.Model += \" LX\"\n } else if !strings.Contains(car.Model, \" Limited\") {\n      car.Model += \" Limited\"\n }\n   cars2 = append(cars2, car)\n}\ncars3 := []functor.Car{}\nfor _, car := range cars2 {\n   // downgrade\n if strings.Contains(car.Model, \" Limited\") {\n      car.Model = strings.Replace(car.Model, \" Limited\", \"\", -1)\n   } else if strings.Contains(car.Model, \" LX\") {\n      car.Model = strings.Replace(car.Model, \" LX\", \"\", -1)\n   }\n   cars3 = append(cars3, car)\n}\nfmt.Println(\"up and downgrade:\", cars3)\n```", "```go\n( 1 + 2 ) + 3 == 1 + ( 2 + 3 )   // left and right associativity\n```", "```go\n1 * 0 == 0\n1 * 2 == 2\n```", "```go\n1 + 2 + 3   \u21d2   [1,2,3] |> List.reduce(+)\n```", "```go\n\"a\" + \"b\" + \"c\"   \u21d2   [\"a\", \"b\", \"c] |> List.reduce(+)\n```", "```go\npackage monoid\n\ntype NameMonoid interface {\n   Append(s string) NameMonoid\n   Zero() string\n}\n\nfunc WrapName(s string) NameMonoid {\n   return nameContainer{name: s}\n}\n\ntype nameContainer struct {\n   name string\n}\n\nfunc (s nameContainer) Append(name string) NameMonoid {\n   s.name = s.name + name\n   return s\n}\n\nfunc (nameContainer) Zero() string {\n   return \"\"\n}\n\nfunc (s nameContainer) String() string {\n   return s.name\n}\n```", "```go\npackage main\n\nimport (\n   \"monoid\"\n \"fmt\"\n)\n\nfunc main() {\n\n   const name = \"Alice\"\n stringMonoid := monoid.WrapName(name)\n   fmt.Println(\"NameMonoid\")\n   fmt.Println(\"Initial state:\", stringMonoid)\n   fmt.Println(\"Zero:\", stringMonoid.Zero())\n   fmt.Println(\"1st application:\", stringMonoid.Append(name))\n   fmt.Println(\"Chain applications:\", stringMonoid.Append(name).Append(name))\n```", "```go\npackage monoid\n\ntype IntMonoid interface {\n   Zero() []int\n   Append(i ...int) IntMonoid\n   Reduce() int\n}\n\nfunc WrapInt(ints []int) IntMonoid {\nreturn intContainer{ints: ints}\n}\n\ntype intContainer struct {\n   ints []int\n}\n\nfunc (intContainer) Zero() []int {\nreturn nil\n}\n\nfunc (i intContainer) Append(ints ...int) IntMonoid {\n   i.ints = append(i.ints, ints...)\nreturn i\n}\n\nfunc (i intContainer) Reduce() int {\n   total := 0\n for _, item := range i.ints {\n      total += item\n   }\nreturn total\n}\n\n```", "```go\nints := []int{1, 2, 3}\nintMonoid := monoid.WrapInt(ints)\nfmt.Println(\"\\nIntMonoid\")\nfmt.Println(\"Initial state:\", intMonoid)\nfmt.Println(\"Zero:\", intMonoid.Zero())\nfmt.Println(\"1st application:\", intMonoid.Append(ints...))\nfmt.Println(\"Chain applications:\", intMonoid.Append(ints...).Append(ints...))\nfmt.Println(\"Reduce chain:\", intMonoid.Append(ints...).Append(ints...).Reduce())\n```", "```go\ntype Lineitem struct {\n   Quantity   int\n   Price     int\n   ListPrice  int\n}\n```", "```go\npackage monoid\n\ntype LineitemMonoid interface {\n   Zero() []int\n   Append(i ...int) LineitemMonoid\n   Reduce() int\n}\n\nfunc WrapLineitem(lineitems []Lineitem) lineitemContainer {\nreturn lineitemContainer{lineitems: lineitems}\n}\n\ntype Lineitem struct {\n   Quantity   int\n   Price     int\n   ListPrice  int\n}\n\ntype lineitemContainer struct {\n   lineitems []Lineitem\n}\n\nfunc (lineitemContainer) Zero() []Lineitem {\nreturn nil\n}\n\nfunc (i lineitemContainer) Append(lineitems ...Lineitem) lineitemContainer {\n   i.lineitems = append(i.lineitems, lineitems...)\nreturn i\n}\n\nfunc (i lineitemContainer) Reduce() Lineitem {\n   totalQuantity := 0\n totalPrice := 0\n totalListPrice := 0\n for _, item := range i.lineitems {\n      totalQuantity += item.Quantity\n      totalPrice += item.Price\n      totalListPrice += item.ListPrice\n   }\nreturn Lineitem{totalQuantity, totalPrice, totalListPrice}\n}\n```", "```go\nlineitems := []monoid.Lineitem{\n   {1, 12978, 22330},\n   {2, 530, 786},\n   {5, 270, 507},\n}\nlineitemMonoid := monoid.WrapLineitem(lineitems)\nfmt.Println(\"\\nLineItemMonoid\")\nfmt.Println(\"Initial state:\", lineitemMonoid)\nfmt.Println(\"Zero:\", lineitemMonoid.Zero())\nfmt.Println(\"1st application:\", lineitemMonoid.Append(lineitems...))\nfmt.Println(\"Chain applications:\", lineitemMonoid.Append(lineitems...).Append(lineitems...))\nfmt.Println(\"Reduce chain:\", lineitemMonoid.Append(lineitems...).Append(lineitems...).Reduce())\n```"]