- en: Functors, Monoids, and Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数对象，幺半群和泛型
- en: '"Here''s my attempt at functional programming in Go. I think it''s a good idea,
    but I''m really not sure."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"这是我在Go中尝试函数式编程。我认为这是一个好主意，但我真的不确定。"'
- en: I have seen comments like this on over a dozen blog articles. I hope that after
    reading this chapter and working through the examples, you'll have a new-found
    love for functional programming (FP). Not because it's so pure that you worry
    that side-effect programming will send you to hell, but rather, because you feel
    comfortable with concepts that form the basis of pure FP and you see that its
    benefits outweigh the costs of learning how to use it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我在超过十几篇博客文章上看到了这样的评论。我希望在阅读完本章并完成示例后，你会对函数式编程（FP）有一种新的热爱。不是因为它是如此纯净，以至于你担心有副作用的编程会把你送到地狱，而是因为你对构成纯FP基础的概念感到舒适，并且你看到它的好处超过了学习如何使用它的成本。
- en: 'Our goals in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: Appreciate how the lack of generics support in Go can be a good thing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欣赏Go中泛型支持的缺失可能是一件好事
- en: Learn how to use a generics code generation tool to solve the boilerplate problem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用泛型代码生成工具来解决样板问题
- en: Deeply understand how function composition works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入理解函数组合是如何工作的
- en: Build a few functors and understand how to map between worlds
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一些函数对象，并了解如何在不同领域之间进行映射
- en: Build a few monoids and learn how to write your own reduce functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一些幺半群，并学习如何编写自己的reduce函数
- en: Understanding functors
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解函数对象
- en: A functor is a structure-preserving transformation between categories. In other
    words, a functor is a mappable type. Let's see what that means with an example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象是范畴之间保持结构的变换。换句话说，函数对象是可映射的类型。让我们通过一个例子来看看这意味着什么。
- en: An imperative versus pure FP example
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令式与纯函数式的例子
- en: Suppose we start with a slice of ints, `ints := []int{1,2,3}`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从一个int切片开始，`ints := []int{1,2,3}`。
- en: 'In imperative programming, we write all the scaffold code to implement exactly
    how to process this slice of ints. In pure FP, however, we tell our functor what
    we want the loop to do:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，我们编写所有的脚手架代码来准确实现如何处理这个int切片。然而，在纯函数式编程中，我们告诉我们的函数对象我们希望循环做什么：
- en: '![](img/bb333e07-c020-4551-a72f-6f87db47d65b.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb333e07-c020-4551-a72f-6f87db47d65b.jpg)'
- en: 'Here''s the output:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's see how this works.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。
- en: What did that Map function do for us?
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 那个Map函数为我们做了什么？
- en: The `Map` function abstracted the loop. We don't have to bother writing the
    same old range/for looping code. We simply pass in our original `ints` list and
    tell our functor to map that slice into a slice where each element is one greater
    than it was before. This is a lot like SQL, where we declare what data we want
    and let the database engine worry about how to get the data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`函数抽象了循环。我们不必再写相同的range/for循环代码。我们只需传入我们原始的`ints`列表，并告诉我们的函数对象将该切片映射为一个每个元素比以前大一的切片。这很像SQL，我们声明我们想要的数据，让数据库引擎去担心如何获取数据。'
- en: What possible benefits can this afford us?
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 这能给我们带来什么可能的好处？
- en: Do we have to change our SQL query code to benefit from a database engine update
    that increases the query performance? The answer is no, and the same goes for
    our pure FP code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否必须更改我们的SQL查询代码以从数据库引擎更新中受益，从而提高查询性能？答案是否定的，对于我们的纯函数式编程代码也是一样的。
- en: What if all we had to do was write `Functor(list).Map(add1)` and define our
    custom `add1` function? What if `Functor` was part of the Go Standard Library
    (or another very stable third-party package), and what if the next version of
    Go came out and it knew how to optimize performance based on the size of the list
    we passed it? Would that not be an automatic, significant benefit gained from
    simply compiling with the latest version of Go (or that other, very stable third-party
    package)?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要编写`Functor(list).Map(add1)`并定义我们自定义的`add1`函数呢？如果`Functor`是Go标准库的一部分（或者是另一个非常稳定的第三方包），并且如果Go的下一个版本发布了，并且它知道如何根据我们传递的列表的大小来优化性能，那不是仅仅编译使用最新版本的Go（或者其他非常稳定的第三方包）就能获得的自动的显著的好处吗？
- en: This may not seem like a big win in terms of the lines of code written, or even
    clarity. In this case, and in smaller utility or administrative programs, it might
    not be of great benefit. The IMHO place where using FP style offers the greatest
    benefit is in business use case logic. We look for places where we need to be
    careful to not clutter business intent with noisy code like for loop scaffolding
    and error checking code blocks. Those are great places for FP-style programming.
    Other good places are where we would like to horizontally scale our application
    without worrying about race conditions or side effects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码行数或者清晰度来看，这可能并不是一个巨大的胜利。在这种情况下，以及在较小的实用程序或管理程序中，它可能并不会带来很大的好处。在我看来，使用FP风格提供最大好处的地方是业务用例逻辑。我们寻找需要小心谨慎地不要用嘈杂的代码（如for循环脚手架和错误检查代码块）混淆业务意图的地方。这些都是FP风格编程的绝佳场所。其他好的地方是我们希望在不担心竞态条件或副作用的情况下横向扩展我们的应用程序。
- en: A magical structure
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个神奇的结构
- en: A functor can be thought of as a magical structure that can be mapped over,
    where the magical structure can be thought of as a shape with a constant set of
    elements accompanied by the ability to apply a transformation operation to each
    element.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象可以被看作是一个神奇的结构，可以被映射，其中神奇的结构可以被看作是一个形状，带有一组恒定的元素，并伴随着对每个元素应用变换操作的能力。
- en: Let's look at some examples.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子。
- en: Color blocks functor
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 颜色块函数对象
- en: 'A functor consists of a structure, usually a slice in Go, and a transformation
    operation, that is, the mapping function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数对象由一个结构组成，通常是Go中的一个切片，以及一个变换操作，即映射函数：
- en: '| **Structure** | Eight blocks, each filled with a different color |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **结构** | 八个块，每个填充有不同的颜色 |'
- en: '| **Transformation operation** | `f(x) = x - 30`, where `x` is the hue |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **变换操作** | `f(x) = x - 30`，其中`x`是色调 |'
- en: Below, is a functor that maps eight colored blocks to eight corresponding blocks
    whose color has been altered by applying the transformation operations above to
    adjust the hue of the color displayed in the boxes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个函子，它将八个彩色块映射到八个相应的块，其颜色经过上面的转换操作调整色调。
- en: '![](img/7001a6f6-694a-4b8b-b94a-8166e7ebf186.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7001a6f6-694a-4b8b-b94a-8166e7ebf186.png)'
- en: 'The preceding diagram shows a single **f(x)** arrow to keep the clutter to
    a minimum, but a more accurate representation would show arrows from each original
    element to its corresponding, new, transformed element. That''s what actually
    occurs--each element is processed inside the structure and transformed into a
    new value that is returned inside the structure:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了一个单个**f(x)**箭头，以保持最小的混乱，但更准确的表示应该显示从每个原始元素到其相应的新转换元素的箭头。这实际上是发生的--每个元素在结构内被处理，并转换为一个新值，该值返回到结构内：
- en: '![](img/cf666dbf-d617-46f4-b833-058bb997d673.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf666dbf-d617-46f4-b833-058bb997d673.png)'
- en: Fingers times 10 functor
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手指乘以10的函子
- en: 'As mentioned before, a functor consists of a structure and a transformation
    operation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函子由结构和转换操作组成：
- en: '| **Structure** | Five fingers, each representing an integer |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **结构** | 五个手指，每个手指代表一个整数 |'
- en: '| **Transformation operation** | `f(x) = x * 10` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **转换操作** | `f(x) = x * 10` |'
- en: '![](img/573afd21-9780-4895-b8d5-926181d3aa15.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/573afd21-9780-4895-b8d5-926181d3aa15.png)'
- en: 'From the last chapter, we know that a category consists of the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章我们知道，一个类别包括以下内容：
- en: Grouping of objects
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的分组
- en: '**Objects**: Dots/points/a primitive with no properties and no structure'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：点/点/没有属性和结构的原始物体'
- en: '**Morphism (arrow)**: Something that goes between two objects/elements'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**态射（箭头）**：连接两个对象/元素的东西'
- en: Can you see the objects (the numbers on each finger)?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到对象（每个手指上的数字）吗？
- en: Can you see the mappings (**1** to **10**, **2** to **20**, **3** to **30**,
    and so on)?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到映射关系吗（1对应10，2对应20，3对应30，依此类推）？
- en: The fact that our category is closed under multiplication, has an identity element,
    and has a mapping function (times 10), means that we've got a functor. See it?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类别在乘法下是封闭的，有一个单位元，并且有一个映射函数（乘以10），这意味着我们有一个函子。看到了吗？
- en: This is a shape-preserving map that maps from one category to another; hence,
    the functor is called a category homomorphism. The **f(x)** illustrates that the
    functor is a function between two categories.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个保持形状的映射，从一个类别映射到另一个类别；因此，函子被称为类别同态。**f(x)**说明了函子是两个类别之间的函数。
- en: Counting on our fingers (functors) is more proof that all we really need to
    know, we are taught in kindergarten!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数手指（函子）更多地证明了我们真正需要知道的一切都是在幼儿园里教的！
- en: Definition of a functor in Haskell
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Haskell中函子的定义
- en: 'We''ve seen a **functor** in the previous chapter in the type class hierarchy
    diagram. A functor has only one type class method, `fmap`, which has a type of
    `fmap :: (a -> b) -> f a -> f b`. It says--give me a function that takes an `a`
    and returns a `b`, a structure with an `a` inside it, and I''ll give you a structure
    with a `b` inside it. The function is applied to each element inside the structure.
    The `fmap` function transforms values inside the structure.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一章的类型类层次结构图中，我们已经看到了一个**函子**。函子只有一个类型类方法，`fmap`，它的类型是`fmap :: (a -> b) ->
    f a -> f b`。它说--给我一个接受`a`并返回`b`的函数，一个包含`a`的结构，我会给你一个包含`b`的结构。该函数应用于结构内的每个元素。`fmap`函数转换结构内的值。'
- en: 'We could use the following terms interchangeably:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以互换使用以下术语：
- en: Structure
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构
- en: Container
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Box
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盒子
- en: The important thing to remember is that a functor operates on the element inside
    the thing (structure/container/box) and returns the structure with the transformed
    value (not the raw value).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的重要一点是，函子作用于结构/容器/盒子内部的元素，并返回具有转换值的结构（而不是原始值）。
- en: Kinds of types
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型的种类
- en: 'Functors in Haskell must have the kind `* -> *`. Kinds are another layer of
    types, above the concrete types in Haskell. Kinds allow us to define what behavior
    types are capable of and then connect them with the appropriate type classes.
    For example, an **Int** can act like a showable, readable, ordered, or enumerable
    thing. Values in Haskell can be classified by their type. Let''s use Haskell''s
    concise syntax to look at some examples:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell中的函子必须具有kind `* -> *`。Kinds是Haskell中具体类型之上的另一层类型。Kinds允许我们定义类型的行为能力，然后将它们与适当的类型类连接起来。例如，一个**Int**可以像可显示的、可读的、有序的或可枚举的东西一样。Haskell中的值可以根据它们的类型进行分类。让我们使用Haskell的简洁语法来看一些例子：
- en: '| **Type(Class)** | **__Kind__  ** | **Description** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **类型（类）** | **__种__  ** | **描述** |'
- en: '| **Int** | `*` | `*` represents concrete types (such as Bool, Char, or Int).
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **Int** | `*` | `*`代表具体类型（如Bool、Char或Int）。|'
- en: '| **Char** | `*` | `*` represents concrete types (such as Bool, Char, or Int).
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **Char** | `*` | `*`代表具体类型（如Bool、Char或Int）。|'
- en: '| **[]** | `* -> *` | [] takes a single type of kind `*` and returns a new
    type of kind `*`. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **[]** | `* -> *` | []接受一种类型的kind `*`，并返回一种新的kind `*`的类型。|'
- en: '| **Maybe** | `* -> *` | A higher-kinded type that takes a single type of kind
    `*` and returns a new type of kind `*`. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **Maybe** | `* -> *` | 一种高级类型，接受一种kind `*`的类型，并返回一种新的kind `*`的类型。|'
- en: '| **Either** | `* -> * -> *` | A higher-kinded type that takes a single type
    of kind `*` and either returns a new type of kind `*` or returns a new type of
    kind `*`. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **Either** | `* -> * -> *` | 一种高级类型，接受一种kind `*`的类型，并返回一种新的kind `*`的类型，或者返回一种新的kind
    `*`的类型。|'
- en: '| **Functor** | `(* -> *) ->` Constraint | A functor is a type class, not a
    type. We define the behavior of the higher-kinded type that is a functor to be
    something that takes a kind `*` and maps it into another kind, `*`. The constraint
    refers to the fact that the functor must obey the rules defined in its algebra.
    A constraint enforces some sort of limitation. For example, a Numeric constraint
    might constrain all values of the Numeric type to be numeric. 123 passes, but
    "ABC" fails for the Numeric constraint. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **函子** | `(* -> *) ->` 约束 | 函子是一个类型类，而不是一种类型。我们定义了作为函子的高阶类型的行为，它接受一种`*`并将其映射到另一种`*`。约束指的是函子必须遵守其代数中定义的规则。约束强制执行某种限制。例如，数值约束可能限制所有数值类型的值都是数值的。123通过，但"ABC"对于数值约束失败。|'
- en: Maybe
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 也许
- en: '**Maybe** is a functor that maps every type to the same type with an additional
    `Nothing` value. `Maybe` is like an optional value (note that types are the objects
    in our category):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**Maybe**是一个函子，将每种类型映射到具有额外的`Nothing`值的相同类型。`Maybe`就像一个可选值（注意，类型是我们类别中的对象）：'
- en: '`data Maybe a = Just a | Nothing`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`data Maybe a = Just a | Nothing`'
- en: The value of `Maybe Int` can be either just a number, such as Just 2, or Nothing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe Int`的值可以是一个数字，比如`Just 2`，也可以是`Nothing`。'
- en: 'The `Maybe` type maps types to types. For example, it maps **Char** to **Maybe
    Char**. `fmap`, defined in the following snippet, shows how every `a -> b` function has
    a corresponding version, `Maybe a -> Maybe b`, which just returns `Nothing` when
    given `Nothing` and behaves normally otherwise:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “Maybe”类型将类型映射到类型。例如，它将**Char**映射到**Maybe Char**。在下面的代码片段中定义的`fmap`显示了每个`a ->
    b`函数都有一个对应的版本，`Maybe a -> Maybe b`，当给定`Nothing`时只返回`Nothing`，否则正常运行：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Polymorphism at a higher level
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更高级别的多态性
- en: Haskell's rich type features (type classes, parameterized algebraic data types,
    recursive data types, and so on) allow us to implement polymorphism on a much
    higher level than is currently possible in Go.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell丰富的类型特性（类型类、参数化代数数据类型、递归数据类型等）使我们能够在比Go当前可能的更高级别上实现多态性。
- en: It is possible to implement polymorphic behavior in Go. However, due to language
    limitations (the lack of generics), it requires additional code to specify each
    type that implements the desired behaviors.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中实现多态行为是可能的。但是，由于语言限制（缺乏泛型），需要额外的代码来指定实现所需行为的每种类型。
- en: For a Golang code example that demonstrates how to leverage structs and methods
    to derive polymorphic behavior, see [http://l3x.github.io/golang-code-examples/2014/07/15/polymorphic-shapes.html](http://l3x.github.io/golang-code-examples/2014/07/15/polymorphic-shapes.html).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Golang代码示例，演示如何利用结构和方法来获得多态行为，请参阅[http://l3x.github.io/golang-code-examples/2014/07/15/polymorphic-shapes.html](http://l3x.github.io/golang-code-examples/2014/07/15/polymorphic-shapes.html)。
- en: No Generics results in a lot of boilerplate code
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有泛型会导致大量的样板代码
- en: 'Without support for generics, when we implement a list function, we must implement
    it for each type our application requires. It''s a lot of repetitive, boilerplate
    code. For example, if we must implement a `Sum` function for `int8`, `int32`,
    `float64`, and `complex128`, this is what it might look like:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 没有泛型的支持，当我们为应用程序需要的每种类型实现列表函数时，我们必须为每种类型都实现它。这是大量重复的样板代码。例如，如果我们必须为`int8`、`int32`、`float64`和`complex128`实现`Sum`函数，它可能看起来像这样：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here''s the output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With generics, we would only need to implement a `Sum` function similar to
    the following one. `<T>` is a placeholder for any type we pass into `Sum` that
    supports the `+` operator:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型，我们只需要实现一个类似以下的`Sum`函数。`<T>`是我们传递给`Sum`的任何类型的占位符，支持`+`运算符：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It would be nice to not have to write all that repetitive boilerplate code.
    Are there any other options?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不用编写所有那些重复的样板代码会很好。还有其他选择吗？
- en: Yes. We could use the empty `interface{}` everywhere and perform reflection
    and type casting to pull the data out of the list structure and put it back into
    the generic `interface{}`, but that is not performant, and it's a lot of extra
    code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。我们可以在任何地方使用空的`interface{}`，并执行反射和类型转换来从列表结构中提取数据并将其放回通用的`interface{}`，但这不是高性能的，而且会增加很多额外的代码。
- en: Solve lack of generics with metaprogramming
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用元编程解决泛型缺失问题
- en: '**Metaprogramming** (**MP**) is about writing code that writes code. In MP,
    we write programs that treat programs, even themselves, as input data. Our MP
    will read, analyze, transform, and generate code.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**元编程**（**MP**）是关于编写编写代码的代码。在MP中，我们编写将程序视为输入数据的程序。我们的MP将读取、分析、转换和生成代码。'
- en: Maybe we can use MP to fix what's missing in Go due to its lack of support for
    generics?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们可以使用MP来修复Go中由于不支持泛型而缺失的部分？
- en: Maybe. First, let's get a better understanding of what MP is about.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 也许。首先，让我们更好地了解MP是关于什么的。
- en: 'Here are some examples:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: Lexers, parsers, interpreters, and compilers
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词法分析器、解析器、解释器和编译器
- en: '**Domain-Specific Languages** (**DSLs**)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域特定语言**（**DSL**）'
- en: '**Aspect-Oriented Programming** (**AOP**)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向方面的编程**（**AOP**）'
- en: Attributes (.NET)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性（.NET）
- en: Annotations (Java)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解（Java）
- en: Generics (.NET, Java)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型（.NET，Java）
- en: Templates (C++)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板（C++）
- en: Macros (C)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏（C）
- en: method_missing (Ruby)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: method_missing（Ruby）
- en: Reflection (Go, C#, Ruby)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射（Go，C#，Ruby）
- en: There are several types of MP.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的MP。
- en: 'Programs that support the `eval` function can generate new code by concatenating
    strings that represent executable commands. Note: this can pose security risks
    and is generally not a best practice.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 支持`eval`函数的程序可以通过连接表示可执行命令的字符串来生成新代码。注意：这可能会带来安全风险，通常不是最佳实践。
- en: Some languages, such as LISP, can change their own application code based on
    state information, which provides the flexibility to make new decisions at runtime.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，如LISP，可以根据状态信息更改其自己的应用程序代码，这提供了在运行时做出新决策的灵活性。
- en: Other statically typed languages, such as C++, have the ability to evaluate
    expressions and make compile-time decisions to generate code that can be compiled
    statically into the final executable. This is the type of MP that we'll look at
    in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其他静态类型的语言，比如C++，有能力评估表达式并做出编译时决策，生成可以静态编译到最终可执行文件中的代码。这是我们将在下一节中看到的MP类型。
- en: Reflection is a form of MP where a program can observe and modify its own structure
    and behavior, such as by determining what type of data a pointer is referring
    to or returning a list of all the properties of an object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是一种MP形式，程序可以观察和修改自己的结构和行为，比如确定指针引用的数据类型或返回对象的所有属性列表。
- en: Go does not come with support for macros or generics, so it looks like we must
    use reflection. Reflection allows our program to manipulate objects whose types
    are not known at compile time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言不支持宏或泛型，因此看起来我们必须使用反射。反射允许我们的程序操作那些在编译时类型未知的对象。
- en: 'For example, we can create a linked list of items using the empty `interface{}`.
    That will allow us to put any type of data in our list. When we pull an item out
    of our list, we must use type assertion to assign a data type to it in order to
    use it. The problem is that this is not a type-safe operation, it''s cumbersome
    to use, and it is a slow operation. Using reflection is generally not a best practice.
    Some possible use cases include the following (none of which help us with generics):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用空的`interface{}`创建一个项目的链表。这将允许我们在列表中放入任何类型的数据。当我们从列表中取出一个项目时，我们必须使用类型断言为其分配一个数据类型以便使用它。问题在于这不是一个类型安全的操作，它使用起来很麻烦，而且速度很慢。使用反射通常不是最佳实践。一些可能的用例包括以下内容（这些都不能帮助我们实现泛型）：
- en: Calling functions
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用函数
- en: Recognizing interfaces
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别接口
- en: Validating fields
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证字段
- en: 'For more information on reflection in Go, have a look at the following information:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Go语言中反射的更多信息，请参阅以下信息：
- en: '[golang.org/pkg/reflect/](http://golang.org/pkg/reflect/)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[golang.org/pkg/reflect/](http://golang.org/pkg/reflect/)'
- en: '[blog.golang.org/laws-of-reflection](http://blog.golang.org/laws-of-reflection)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[blog.golang.org/laws-of-reflection](http://blog.golang.org/laws-of-reflection)'
- en: '[blog.ralch.com/tutorial/golang-reflection/](http://blog.ralch.com/tutorial/golang-reflection/)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[blog.ralch.com/tutorial/golang-reflection/](http://blog.ralch.com/tutorial/golang-reflection/)'
- en: '[blog.gopheracademy.com/birthday-bash-2014/advanced-reflection-with-go-at-hashicorp/](http://blog.gopheracademy.com/birthday-bash-2014/advanced-reflection-with-go-at-hashicorp/)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[blog.gopheracademy.com/birthday-bash-2014/advanced-reflection-with-go-at-hashicorp/](http://blog.gopheracademy.com/birthday-bash-2014/advanced-reflection-with-go-at-hashicorp/)'
- en: If we shouldn't use reflection, then how can we solve this problem of repetitive,
    boilerplate code?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不应该使用反射，那么我们如何解决这种重复的样板代码问题呢？
- en: Generics code generation tool
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型代码生成工具
- en: How can we not write all that repetitive code and not take a performance hit,
    nor lose any type safety of our strongly-typed language?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何不写所有那些重复的代码，又不会受到性能损失，也不会失去我们强类型语言的类型安全性呢？
- en: Let's look at using Go tooling to generate the boilerplate code for us. We'll
    use it to replace `interface{}` in our code with `<T>`. Here, `<T>` represents
    any type that works in the context in which it is found.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用Go工具来为我们生成样板代码。我们将用它来用<T>替换我们代码中的`interface{}`。这里，<T>代表在其被发现的上下文中工作的任何类型。
- en: Since we'll be using real types, we'll get compile-time type safety.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用真实类型，我们将获得编译时类型安全性。
- en: The clipperhouse/gen tool
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: clipperhouse/gen工具
- en: Though there are several generics code generation tools available, let's look
    at my personal favorite, clipperhouse/gen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有几种泛型代码生成工具可用，让我们来看看我个人最喜欢的clipperhouse/gen。
- en: 'We get the following functions for free with the clipperhouse/gen tool:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用clipperhouse/gen工具免费获得以下函数：
- en: '| **Aggregation** | **Filter** | **Map** | **Misc** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **聚合** | **过滤** | **映射** | **其他** |'
- en: '| [Aggregate[T]](https://clipperhouse.github.io/gen/slice/#aggregatet) | [All](https://clipperhouse.github.io/gen/slice/#all)
    | [Select[T]](https://clipperhouse.github.io/gen/slice/#selectt) | [List](https://clipperhouse.github.io/gen/optional/#list)
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '[Aggregate[T]](https://clipperhouse.github.io/gen/slice/#aggregatet) | [All](https://clipperhouse.github.io/gen/slice/#all)
    | [Select[T]](https://clipperhouse.github.io/gen/slice/#selectt) | [List](https://clipperhouse.github.io/gen/optional/#list)
    |'
- en: '| [Average](https://clipperhouse.github.io/gen/slice/#average) | [Any](https://clipperhouse.github.io/gen/slice/#any)
    | [Where](https://clipperhouse.github.io/gen/slice/#where) | [Ring](https://clipperhouse.github.io/gen/optional/#ring)
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| [Average](https://clipperhouse.github.io/gen/slice/#average) | [Any](https://clipperhouse.github.io/gen/slice/#any)
    | [Where](https://clipperhouse.github.io/gen/slice/#where) | [Ring](https://clipperhouse.github.io/gen/optional/#ring)
    |'
- en: '| [Average[T]](https://clipperhouse.github.io/gen/slice/#averaget) | [Distinct](https://clipperhouse.github.io/gen/slice/#distinct)
    |  | [Set](https://clipperhouse.github.io/gen/optional/#set) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| [Average[T]](https://clipperhouse.github.io/gen/slice/#averaget) | [Distinct](https://clipperhouse.github.io/gen/slice/#distinct)
    |  | [Set](https://clipperhouse.github.io/gen/optional/#set) |'
- en: '| [Count](https://clipperhouse.github.io/gen/slice/#count) | [DistinctBy](https://clipperhouse.github.io/gen/slice/#distinctby)
    |  | [stringer](https://clipperhouse.github.io/gen/stringer/#) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| [Count](https://clipperhouse.github.io/gen/slice/#count) | [DistinctBy](https://clipperhouse.github.io/gen/slice/#distinctby)
    |  | [stringer](https://clipperhouse.github.io/gen/stringer/#) |'
- en: '| [Max](https://clipperhouse.github.io/gen/slice/#max) | [First](https://clipperhouse.github.io/gen/slice/#first)
    |  |  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| [Max](https://clipperhouse.github.io/gen/slice/#max) | [First](https://clipperhouse.github.io/gen/slice/#first)
    |  |  |'
- en: '| [Max[T]](https://clipperhouse.github.io/gen/slice/#maxt) | [GroupBy[T]](https://clipperhouse.github.io/gen/slice/#groupbyt)
    |  |  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| [Max[T]](https://clipperhouse.github.io/gen/slice/#maxt) | [GroupBy[T]](https://clipperhouse.github.io/gen/slice/#groupbyt)
    |  |  |'
- en: '| [MaxBy](https://clipperhouse.github.io/gen/slice/#maxby) | [Shuffle](https://clipperhouse.github.io/gen/slice/#shuffle)
    |  |  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| [MaxBy](https://clipperhouse.github.io/gen/slice/#maxby) | [Shuffle](https://clipperhouse.github.io/gen/slice/#shuffle)
    |  |  |'
- en: '| [Min](https://clipperhouse.github.io/gen/slice/#min) | [Sort](https://clipperhouse.github.io/gen/slice/#sort)
    |  |  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| [Min](https://clipperhouse.github.io/gen/slice/#min) | [Sort](https://clipperhouse.github.io/gen/slice/#sort)
    |  |  |'
- en: '| [Min[T]](https://clipperhouse.github.io/gen/slice/#mint) | [SortBy](https://clipperhouse.github.io/gen/slice/#sortby)
    |  |  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| [Min[T]](https://clipperhouse.github.io/gen/slice/#mint) | [SortBy](https://clipperhouse.github.io/gen/slice/#sortby)
    |  |  |'
- en: '| [MinBy](https://clipperhouse.github.io/gen/slice/#minby) |  |  |  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| [MinBy](https://clipperhouse.github.io/gen/slice/#minby) |  |  |  |'
- en: '`gen` is a code-generation tool for Go. It''s intended to offer generics-like
    functionality for your types. Out of the box, it offers LINQ/underscore-inspired
    methods.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen`是一个用于Go的代码生成工具。它旨在为您的类型提供类似泛型的功能。开箱即用，它提供了LINQ/underscore风格的方法。'
- en: '[https://github.com/clipperhouse/gen](https://github.com/clipperhouse/gen)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/clipperhouse/gen](https://github.com/clipperhouse/gen)'
- en: '[https://en.wikipedia.org/wiki/Language_Integrated_Query](https://en.wikipedia.org/wiki/Language_Integrated_Query)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Language_Integrated_Query](https://en.wikipedia.org/wiki/Language_Integrated_Query)'
- en: '[https://en.wikipedia.org/wiki/Underscore.js](https://en.wikipedia.org/wiki/Underscore.js)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Underscore.js](https://en.wikipedia.org/wiki/Underscore.js)'
- en: Using the gen tool, we'll gain most of the benefits of generics without the
    performance hits of either reflection or type assertion.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gen工具，我们将获得大部分泛型的好处，而不会受到反射或类型断言的性能损失。
- en: 'What generics do for us is a lot like code generation. At runtime, when we
    pass an `a` of type `A` to a function, it seems magical that our function can
    accept the `a` and do the right thing. What happens most of the time at runtime
    (by JIT or a regular Go compiler, depending on the situation) is that Go does
    a code generation replacement operation. What happens at runtime is that our a
    gets swapped in/out of A-shaped holes in our code. This is the same pattern that
    our generics code generation tool will use to generate generic code for us:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型为我们做的事情很像代码生成。在运行时，当我们将类型为`A`的`a`传递给函数时，我们的函数可以接受`a`并执行正确的操作，这似乎是神奇的。大多数情况下在运行时（由JIT或常规Go编译器，取决于情况），Go进行代码生成替换操作。在运行时发生的是我们的`a`在我们的代码中被换入/换出A形状的空白。这是我们的泛型代码生成工具将用来为我们生成通用代码的相同模式：
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ll use our generics generation tool to swap out any type that fits in the
    T-shaped hole:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的泛型生成工具来替换适合T形空白的任何类型：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can use our gen tool to generate code at development time. It spits out code
    for us, much like an IDE might do.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的gen工具在开发时生成代码。它为我们生成代码，就像IDE可能会做的那样。
- en: We mark up our types using **annotations** in a comment line above the **type**
    of our code for which we want code generation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**注释**中的**注释**标记我们的类型，以便我们想要为其生成代码。
- en: Let's work through an example. First, let's go to the correct directory and
    initialize our Go environment by sourcing the init script, running glide-update,
    and pulling gen into our vendors directory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来工作。首先，让我们进入正确的目录，并通过源init脚本，运行glide-update，并将gen拉入我们的vendors目录来初始化我们的Go环境。
- en: 'Here''s the list of the commands we use:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用的命令列表：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is what our directory structure looks like before running `gen`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在运行`gen`之前的目录结构：
- en: '![](img/71ef883b-c503-4457-ae04-1e836013159e.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71ef883b-c503-4457-ae04-1e836013159e.png)'
- en: 'Here''s our directory structure after running `gen`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运行`gen`后的目录结构：
- en: '![](img/dc46692b-f53c-4fb9-8087-295c00a04762.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc46692b-f53c-4fb9-8087-295c00a04762.jpg)'
- en: 'Now, let''s look at our project''s code in `src/car/types.go`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们项目中的代码在`src/car/types.go`中：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Do you see the `// +gen slice:"Where,Sum[Dollars],GroupBy[string],Select[Dollars]` annotation?
    It tells our gen tool to generate a slice of `Car` and give us the following methods:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了`// +gen slice:"Where,Sum[Dollars],GroupBy[string],Select[Dollars]`的注释吗？它告诉我们的gen工具生成一个`Car`的切片，并为我们提供以下方法：
- en: '`CarSlice.Where`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CarSlice.Where`'
- en: '`CarSlice.SelectDollars`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CarSlice.SelectDollars`'
- en: '`CarSlice.SumDollars`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CarSlice.SumDollars`'
- en: 'When we run gen in the directory with `types.go`, gen will generate a **src/cars/car_slice.go**
    file with the following content:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在带有`types.go`的目录中运行gen时，gen将生成一个名为**src/cars/car_slice.go**的文件，其中包含以下内容：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, gen is generating all that boilerplate code for us. That keeps our source
    files clean and tidy. If Go supported generics, our code would be similar to the
    code we write that works with gen. How similar? Let's see.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，gen为我们生成了所有那些样板代码。这使我们的源文件保持整洁。如果Go支持泛型，我们的代码将类似于与gen一起使用的代码。有多相似？让我们看看。
- en: 'Here''s our `main.go` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`main.go`文件：
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s the output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See that `CarSlice` type? That's what gen created for us. We must type in the
    actual struct types, such as `Car`, and gen will create the `CarSlice` type and
    all the methods that we tell it to generate for us in our annotation (just above
    the type definition).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 看到`CarSlice`类型了吗？那是gen为我们创建的。我们必须键入实际的结构类型，比如`Car`，gen将为我们创建`CarSlice`类型和我们在注释中告诉它为我们生成的所有方法（就在类型定义的上面）。
- en: If Go supported generics
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如果Go支持泛型
- en: 'This is what the same block of code might look like if Go supported generics:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Go支持泛型，同一段代码块可能会如下所示：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Looking at this code block from a lazy programmer's perspective, if Go supported
    generics, we'd have to type two extra characters, `<` and `>`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从懒惰程序员的角度来看，如果Go支持泛型，我们将不得不键入两个额外的字符，`<`和`>`。
- en: It looks like the biggest feature of generic code support has just been neutralized.
    When we consider this information along with the functions we get for free with
    gen and the fact that the performance hit is guaranteed to occur at compile time
    (rather than runtime), it makes Go's direct support of generics seem like a benefit
    or, at the very least, much less of a problem.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来泛型代码支持的最大特性刚刚被中和了。当我们考虑这些信息以及我们通过gen免费获得的函数，以及性能损失保证会在编译时发生（而不是运行时），这使得Go对泛型的直接支持看起来像是一个好处，或者至少是一个不那么严重的问题。
- en: Adding new methods
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加新方法
- en: If we want to add methods that gen does not provide to our `CarSlice`, we can
    put those in a separate file. The thing we need to remember is to not type any
    of our source code into the files generated by gen. That's because our code would
    be overwritten the next time we told gen to run.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为我们的`CarSlice`添加gen不提供的方法，我们可以将这些方法放在一个单独的文件中。我们需要记住的是不要将我们的任何源代码键入gen生成的文件中。这是因为我们的代码将在下次我们告诉gen运行时被覆盖。
- en: Defining a filter function
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义一个`filter`函数
- en: 'A few lines down in our `main.go` file, let''s define a `filter` function that
    will return cars whose `Make` is `Honda.` We use our new `Where` method and pass
    it our `honda` literal function:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main.go`文件中的几行下面，让我们定义一个`filter`函数，它将返回`Make`为`Honda`的汽车。我们使用我们的新`Where`方法，并将其传递给我们的`honda`文字函数：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s the output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Cool. Next, let''s create a mapping function to return the price field:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷。接下来，让我们创建一个映射函数来返回价格字段：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s the output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since we have already filtered by Honda, the result only contains the prices
    of Honda cars.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经按照本田进行了筛选，结果只包含本田汽车的价格。
- en: 'Aggregation? Sure, we can do aggregation. Let’s call the `SumDollars` function
    that we got for free when we ran our annotation:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合？当然，我们可以进行聚合。让我们调用我们在注释中免费获得的`SumDollars`函数：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s the output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Nums revisited
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nums重访
- en: 'Remember those four numerics types that we implemented a `Sum` method for without
    generics? Let''s revisit that code and see if we can improve our code base now
    that we know about gen:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们为四种数字类型实现了`Sum`方法而不使用泛型吗？让我们重新访问一下那段代码，看看我们是否可以改进我们的代码库，现在我们知道了gen：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that we need to run glide-update so that the vendors directory will be
    created for us. It will first be placed in our GOPATH so that when we run the
    next command, the gen package and its dependencies will go in our vendors directory
    rather than our project’s src directory:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要运行glide-update，以便为我们创建供应商目录。它将首先放在我们的GOPATH中，这样当我们运行下一个命令时，gen包及其依赖项将放在我们的供应商目录中，而不是我们项目的src目录中：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s cd to **~/dev/04_generics_nums/src/num** and run gen:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们cd到**~/dev/04_generics_nums/src/num**并运行gen：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can see that gen created four files, one for each slice type:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到gen创建了四个文件，每个文件都有一个切片类型：
- en: '![](img/e19e1fb0-d162-4e12-b621-5ba5ed88711b.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e19e1fb0-d162-4e12-b621-5ba5ed88711b.jpg)'
- en: We have to define each type and annotate that we want gen to create a `Sum`
    method for each slice. Note that we never need to create a type for a slice, only
    the types. Gen creates the slices for each type for us, along with the methods
    that we request in the gen slice annotations.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须定义每种类型，并注释我们希望gen为每个切片创建一个`Sum`方法。请注意，我们从不需要为切片创建类型，只需要类型。Gen为我们创建每种类型的切片，以及我们在gen切片注释中请求的方法。
- en: 'Here is the code from `src/num/types.go`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自`src/num/types.go`的代码：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is what one of the generated files (`src/num/int8_slice.go`) looks like:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成的文件（`src/num/int8_slice.go`）的片段，看起来像这样：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Remember the price function that we passed to the `Select<T>` function in our
    previous cars example? Let''s have a look at it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在之前的汽车示例中将价格函数传递给`Select<T>`函数吗？让我们来看看：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That''s the kind of function we''ll create in our `src/num/vars.go` file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在`src/num/vars.go`文件中创建的函数类型：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll simply return the value that''s passed into our literal function definitions
    in our `fmt.Println` statements:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地返回传递给我们的文字函数定义的值在我们的`fmt.Println`语句中：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here''s the output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Even with this simple sum numbers example, we see that our gen tool saves us
    from typing the boilerplate loop structures for summing numbers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个简单的求和数字示例中，我们也看到我们的gen工具使我们免于输入繁琐的循环结构来求和数字。
- en: We have only used the `Sum` method, but there are about two dozen more to choose
    from.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用了`Sum`方法，但还有大约两打其他方法可供选择。
- en: A snippet of documentation describing the `Aggregate` method can be found at
    [https://clipperhouse.github.io/gen/slice/#](https://clipperhouse.github.io/gen/slice/#).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://clipperhouse.github.io/gen/slice/#](https://clipperhouse.github.io/gen/slice/#)找到描述`Aggregate`方法的文档片段。
- en: The slice typewriter
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 切片打字机
- en: The slice typewriter is built into gen by default. It generates functional convenience
    methods that will look familiar to users of C#'s LINQ or JavaScript's array methods.
    It is intended to save you some loops, using a pass a function pattern. It offers
    easier ad hoc sorting.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 切片打字机默认内置到gen中。它生成功能便利方法，这些方法对于使用C#的LINQ或JavaScript的数组方法的用户来说会很熟悉。它旨在为您节省一些循环，使用传递函数模式。它提供更容易的特定多态排序。
- en: 'The annotation looks like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注释看起来像这样：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, `Example` is used as a placeholder for your type.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Example`被用作您的类型的占位符。
- en: 'A new type, `ExampleSlice`, is generated, and becomes the receiver for the
    following methods:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 生成了一个新类型`ExampleSlice`，并成为以下方法的接收者：
- en: Aggregate[T]
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 聚合[T]
- en: '`AggregateT` iterates over a slice, aggregating each element into a single
    result. `AggregateT` is comparable to LINQ''s Aggregate and underscores reduce
    function.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`AggregateT`遍历切片，将每个元素聚合成单个结果。`AggregateT`类似于LINQ的Aggregate和下划线reduce函数。'
- en: 'Here is the signature:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是签名：
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the following example, we specify in our comment annotation that we want
    gen to create an `Aggregate` function that operates over a slice of strings. We
    define a `join` function that we pass to `AggregateString,` which performs the
    join operation:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们在我们的注释注释中指定我们希望gen创建一个在字符串切片上操作的`Aggregate`函数。我们定义了一个`join`函数，将其传递给`AggregateString`，执行连接操作：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Generics implementation options
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型实现选项
- en: Below is a decision matrix that can be used to evaluate which generics implementation
    is best.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个决策矩阵，可用于评估哪种泛型实现最好。
- en: '![](img/384b20d6-080a-4b7a-8021-792e51da8da6.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/384b20d6-080a-4b7a-8021-792e51da8da6.png)'
- en: There are many aspects to consider when we think about how to implement generics.
    For example, let's consider the difference between Haskell's parametric polymorphism
    and C++'s ad hoc polymorphism.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑如何实现泛型时，有许多方面需要考虑。例如，让我们考虑Haskell的参数多态性和C++的特定多态性之间的区别。
- en: In Haskell, polymorphic functions are defined uniformly for all types. We could
    call this compile time polymorphism.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，多态函数对所有类型都是统一定义的。我们可以称之为编译时多态。
- en: In C++, dynamic polymorphism, via substitution, virtual functions and interfaces
    enable polymorphic behavior, but whether our implementation works for any particular type
    is decided at runtime when the concrete type is substituted for its parameter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，通过替换、虚函数和接口实现动态多态行为，但我们的实现是否适用于任何特定类型是在运行时决定的，当具体类型替换其参数时。
- en: C++ templates offer a similar functionality without the runtime overhead of
    dynamic polymorphism. The tradeoff is the fact that the flexibility is fixed at
    compile time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: C++模板提供了类似的功能，而没有动态多态性的运行时开销。这种权衡是灵活性在编译时固定的事实。
- en: Type classes in Haskell allow us to define different behaviors for the same
    function for different types. In C++, we do this using template specialization
    and function overloading.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell中的类型类允许我们为不同类型的相同函数定义不同的行为。在C++中，我们使用模板特化和函数重载来实现这一点。
- en: Note that we are only scratching the surface of the issues, and only with a
    discussion of two languages (C++ and Haskell). There are plenty of edge cases
    to consider. For example, should the Go compiler perform aggressive optimizations?
    If so, that would mean specializing polymorphic functions for all types in which
    they are used, which opens up another level of complexity to manage.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只是触及了问题的表面，并且只讨论了两种语言（C++和Haskell）。还有很多边缘情况需要考虑。例如，Go编译器是否应该执行激进的优化？如果是这样，那将意味着为所有使用它们的类型专门化多态函数，这将开启另一层需要管理的复杂性。
- en: If generics support were added to Go, there would be a cost and risk involved.
    The cost would come up front, either at compile time or runtime. In all cases,
    the pros and cons of each approach should be carefully evaluated and we should
    be careful what we ask for. We'll talk more about generics in the next chapter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Go添加了泛型支持，将会涉及成本和风险。成本将会在编译时或运行时提前产生。在所有情况下，每种方法的利弊都应该仔细评估，我们应该谨慎地提出要求。我们将在下一章更多地讨论泛型。
- en: For more information on generics and Go, including more tools like gen, you
    can refer to [docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4).
    Another resource is [golang.org/doc/faq#generics.](https://golang.org/doc/faq#generics)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有关泛型和Go的更多信息，包括像gen这样的更多工具，您可以参考[docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4)。另一个资源是[golang.org/doc/faq#generics.](https://golang.org/doc/faq#generics)
- en: We used the gen tool
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们使用了gen工具。
- en: We used the gen tool, which is more aligned with the C++/Template approach.
    While using gen caused us to write a little more code, we were in control, and
    we got some LINQ-like functionality out of the box, which keeps us from having
    to write a lot of boilerplate code for handling slices. Nice!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了gen工具，这更符合C++/模板的方法。虽然使用gen导致我们编写了更多的代码，但我们掌控了局面，并且得到了一些类似LINQ的功能，这使我们不必为处理切片编写大量样板代码。不错！
- en: So, does Go support generics? No. But we can use a tool such as gen to solve
    the big problem of having repetitive boilerplate code. We still have our type
    safety and do not pay the performance penalty for using reflection.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Go支持泛型吗？不支持。但是我们可以使用像gen这样的工具来解决重复样板代码的大问题。我们仍然拥有我们的类型安全，并且不需要为使用反射付出性能代价。
- en: The shape of a functor
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函子的形状
- en: A functor is an algebraic type that accepts a value (or usually, a list of values)
    and has a map function that applies to each element in the list to produce a new
    functor of the same shape. What is a shape?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 函子是一种代数类型，它接受一个值（或通常是一系列值），并具有一个map函数，该函数应用于列表中的每个元素，以产生相同形状的新函子。形状是什么？
- en: 'Let''s look at an imperative example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个命令式的例子：
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s the output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The shape in this example means a slice with three ints. We started with a slice
    with three ints, ran our imperative code, and ended up with a slice with three
    ints.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，形状意味着一个包含三个整数的切片。我们从一个包含三个整数的切片开始，运行我们的命令式代码，最终得到一个包含三个整数的切片。
- en: A functor gets the same results (three elements in and three elements out) but
    a functor does it in a different way.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 函子得到相同的结果（三个元素进入，三个元素出去），但是函子以不同的方式实现。
- en: 'We give our functor the same slice of three ints. The functor executes `add2`
    for each int and returns a slice with three ints (each of which is two greater
    than before):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给我们的函子相同的三个整数切片。函子对每个整数执行`add2`并返回一个包含三个整数的切片（每个整数比以前大两个）：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here''s the output:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There must be more to a functor than that, right?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 函子肯定不止这些，对吧？
- en: Yes. The devil is in the details. So, let's shine some light on it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。魔鬼就在细节中。所以，让我们来揭开一些细节。
- en: Functor implementation
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函子实现
- en: Let's look at our ints functor implementation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的ints函子实现。
- en: ints functor
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ints函子
- en: Like the good programmers that we are, we declare our interface at the top of
    our file. Our interface, that is, our contract, has only one function, `Map.`
    Our `IntFunctor` type accepts a `func(int) int` function and returns another `IntFunctor`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 作为优秀的程序员，我们在文件顶部声明了我们的接口。我们的接口，也就是我们的契约，只有一个函数`Map`。我们的`IntFunctor`类型接受一个`func(int)
    int`函数，并返回另一个`IntFunctor`。
- en: What? It returns an `IntFunctor?` What is that, and how did it print correctly?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？它返回一个`IntFunctor`？那是什么，它是如何正确打印的？
- en: 'Let''s have a look at `src/functor/ints.go`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`src/functor/ints.go`：
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: One feature of a functor is that it applies that `f` function inside its container.
    Now, what is a container?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 函子的一个特性是它在其容器内应用`f`函数。那么，什么是容器？
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That's our functor's container. We'll call it a `box`, because a box is a container,
    and since we are good, lazy programmers, we prefer names that are short.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们函子的容器。我们将其称为`box`，因为盒子是一个容器，而且由于我们是优秀的懒惰程序员，我们更喜欢简短的名称。
- en: Okay. I see the box. What happens in our magical `box`?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我看到了盒子。我们的神奇`box`里发生了什么？
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Firstly, we notice that `Map` is a method and box is the receiver. `Map` takes
    a function and returns another `IntFunctor.` Ah, so we map from one `IntFunctor`
    to another? Yes, indeed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们注意到`Map`是一个方法，`box`是接收者。`Map`接受一个函数并返回另一个`IntFunctor`。啊，所以我们从一个`IntFunctor`映射到另一个`IntFunctor`？是的，确实是这样。
- en: Since a functor needs to map one structure to another one, and since there may
    be more than one element to map (and when we say map, we mean transform element
    for element/three in, three out). It's safe to assume we're going to be mapping
    lists of elements.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个函数器需要将一个结构映射到另一个结构，并且可能有多个元素需要映射（当我们说映射时，我们指的是逐个元素/三个输入，三个输出的转换）。可以肯定地假设我们将映射元素的列表。
- en: How are list shapes in Go usually implemented? With a slice, right? It should
    be no surprise that the receiver of our `Map` method is a slice. Every slice can
    be iterated over using `range,` and that's what we use to iterate through our
    list of elements and apply our function (`f`) to each element and return the `box`
    we were passed. The difference is that the `box` now contains transformed elements.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Go中列表形状通常是如何实现的？用一个切片，对吧？我们不应该感到惊讶，我们的`Map`方法的接收者是一个切片。每个切片都可以使用`range`进行迭代，这就是我们用来迭代我们的元素列表并将我们的函数（`f`）应用于每个元素并返回我们传入的`box`的方法。不同之处在于`box`现在包含了转换后的元素。
- en: Wait a second, what's a `range` with iterator variables `i` and `el`, that are
    mutating, doing in our pure FP world? And even more disturbing is the fact that
    we are mutating the contents of our box. That's right, mutations did occur, but
    only in the box. It's magical, remember? Inside this box is where things can change
    and not affect our otherwise pure world of FP.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，一个带有迭代变量`i`和`el`的`range`是如何在我们纯函数式编程的世界中进行变异的？更令人不安的是我们正在变异我们盒子的内容。没错，变异确实发生了，但只发生在盒子里。这是神奇的，记住吗？在这个盒子里的东西可以改变而不影响我们纯函数式编程的世界。
- en: 'How can we draw a line between pure and impure? This is where we do it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何区分纯和不纯？这就是我们做的地方：
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'That''s it. That''s the place where we allow our execution to be lowered into
    the gutter of mutation:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。这就是我们允许我们的执行降到变异的下水道的地方：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See the `Functor(ints)` part in the preceding line? That's where we wrap our
    `ints` inside the magical box, and that is where we allow the naughty `add2` mutation
    function to apply itself to each int in our slice.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 看到前一行的`Functor(ints)`部分了吗？那就是我们将我们的`ints`包装在神奇的盒子里的地方，也是我们允许淘气的`add2`变异函数应用于我们切片中的每个整数的地方。
- en: This action of lowering elements into the gutter of mutation is typically referred
    to as lifting. I would argue that, according to the upcoming analogy, lifting
    is a misnomer. Lowering would be a more appropriate name for it. For more information,
    see [https://en.wikipedia.org/wiki/Lambda_lifting](https://en.wikipedia.org/wiki/Lambda_lifting).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将元素降低到变异的下水道的这种行为通常被称为lifting。我认为，根据即将到来的类比，lifting是一个误称。降低更适合它的名字。更多信息，请参见[https://en.wikipedia.org/wiki/Lambda_lifting](https://en.wikipedia.org/wiki/Lambda_lifting)。
- en: 'What happens in the functor box is not unlike what happens when a person entertains
    impure thoughts. The structure would be the list of three lovely cows dressed
    in polka-dot dresses in one''s mind. The impure person would allow their thoughts
    to be lowered to a place where they would apply the `Undress<T>` literal function,
    where the `T` type in this case would be a Cow:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 函数器盒子中发生的事情与一个人沉溺于不纯洁的思想时发生的事情并无二致。结构将是在一个人的脑海中穿着圆点连衣裙的三头可爱奶牛的列表。不纯洁的人会让他们的思想降低到一个地方，他们会应用`Undress<T>`的文字函数，其中在这种情况下`T`类型将是一头奶牛：
- en: '![](img/900ee368-8112-4bb9-ad0a-bbeb777329c2.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/900ee368-8112-4bb9-ad0a-bbeb777329c2.jpg)'
- en: Pure FP goes to Hell
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数式编程走向地狱
- en: The person may feel safe knowing that their mind is the magical box where all
    sorts of impure mutations are permitted. When this occurs, a person exercises
    an `Undress` functor and maps lovely, dressed cows from one world down into another.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个人知道他们的思想是允许各种不纯的变异的神奇盒子时，他们可能会感到安全。当这种情况发生时，一个人会使用`Undress`函数器，将可爱的、穿着衣服的奶牛从一个世界映射到另一个世界。
- en: When your Momma says, *"Get your mind out of the gutter!"*, this is exactly
    what she's talking about.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当你妈妈说：“别想那些下流的事！”时，这正是她所说的。
- en: 'The last thing we do in `src/functor.ints.go` is create a `String()` method:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/functor.ints.go`中我们做的最后一件事是创建一个`String()`方法：
- en: '[PRE40]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Since we have implemented this one `String()` method, per the duck typing rules
    of Go, our `IntFunctor` is a `Stringer`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们实现了这个`String()`方法，根据Go的鸭子类型规则，我们的`IntFunctor`是一个`Stringer`：
- en: '[PRE41]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is a beautiful, one-method interface. `fmt` looks for this interface to
    print values.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个美丽的、单方法接口。`fmt`寻找这个接口来打印值。
- en: 'The Go Standard Library is very accessible and a great place to go to see how
    things really work. In our example, we see that we passed `v` as the verb (when
    we returned `fmt.Sprintf("%+v", box.ints)` ) around *line 577* in the `print.go`
    file. Here is the snippet from `print.go` that starts on *line 577*:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库非常易于访问，是了解事物真正工作原理的好地方。在我们的例子中，我们看到我们将`v`作为动词传递（当我们返回`fmt.Sprintf("%+v",
    box.ints)`时）在`print.go`文件的*第577行*。这是`print.go`中从*第577行*开始的片段：
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Functor definition
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数器定义
- en: The Functor ([https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html#t:Functor](https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html#t:Functor)) class
    is used for types that can be mapped over.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 函数器([https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html#t:Functor](https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html#t:Functor))类用于可以进行映射的类型。
- en: We'll use Haskell syntax because it so clearly defines FP algebraic data types,
    including their structures, rules, and logic. `fmap` is the map function. The
    period `.` notation is the `compose` operator.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Haskell语法，因为它清晰地定义了FP代数数据类型，包括它们的结构、规则和逻辑。`fmap`是映射函数。句号`.`表示`compose`运算符。
- en: 'Instances of Functor should satisfy the following identity and associativity
    laws:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 函数器的实例应满足以下的身份和结合律：
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We should recognize these two rules from [Chapter 11](../Text/Ch11.xhtml), *Category
    Theory That Applies*.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从[第11章](../Text/Ch11.xhtml)中认识到这两条规则，*适用的范畴论*。
- en: Identity operation
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 身份运算
- en: 'The identity law of our category says that the identity morphism of **A** is
    **A**:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的范畴的恒等律说，**A**的恒等态射是**A**：
- en: '![](img/45776db5-ff12-437d-b841-76c5c71611b4.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45776db5-ff12-437d-b841-76c5c71611b4.png)'
- en: If our operation is a map and the elements in our list are numbers, then the
    identity morphism is +0\. If we add 0 to every element of our input list, our
    transformed list will consist of the same elements.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的操作是一个映射，列表中的元素是数字，那么恒等态射是+0。如果我们将0添加到输入列表的每个元素，我们的转换列表将由相同的元素组成。
- en: HEADS UP! We are going to hammer home the concept of composition. Your understanding
    of what composition is and how it works is essential to your ability to be productive
    in pure functional programming. If you read only a few pages in this book, let
    your reading begin now.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意！我们将强调组合的概念。您对组合是什么以及它是如何工作的理解对于您能够在纯函数式编程中提高生产力至关重要。如果您只读了本书的几页，那么您的阅读现在就开始吧。
- en: Composition operation
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合操作
- en: The composition operation, **g.f** or **g** after **f**, applies function **f**
    to x (which takes us from **A** to **B**) and passes the result of that to **g**
    (which takes us from **B** to **C**), and that nested set of operations is equivalent
    to the composition operation of **g.f**.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 组合操作**g.f**或**g**在**f**之后，将函数**f**应用于x（将我们从**A**到**B**），并将结果传递给**g**（将我们从**B**到**C**），这个嵌套的操作等同于**g.f**的组合操作。
- en: 'In Haskell, we define our composition operation on the first line and request
    to see the type definition of our composition operation on the second line. The
    third line is what the composition means:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，我们在第一行定义我们的组合操作，并在第二行请求查看我们组合操作的类型定义。第三行是组合的含义：
- en: '[PRE44]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `a`, `b`, and `c` above correspond to the **A**, **B**, and **C** in the
    following diagram.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`a`，`b`和`c`对应于以下图表中的**A**，**B**和**C**。
- en: It says, when we pass  the **A** to **B** function (**f**) to the **B** to **C**
    function (**g**), we get the **A** to **C** function (**g.f**).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 它说，当我们将**A**到**B**函数（**f**）传递给**B**到**C**函数（**g**）时，我们得到**A**到**C**函数（**g.f**）。
- en: 'This is basic composition. Assuming we start at **A**, this diagram says we
    can get to **C** either by way of **B** (**A** to **B** to **C**) or by going
    directly from **A** to **C**. When we choose the short route (**A** to **C**),
    or **g.f**, we compose **g** and **f** in a nested manner, like g(f(x)), where
    x is the value that we get from **A**:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基本的组合。假设我们从**A**开始，这个图表表示我们可以通过**B**（**A**到**B**到**C**）的方式或者直接从**A**到**C**的方式到达**C**。当我们选择短路线（**A**到**C**）或**g.f**时，我们以嵌套的方式组合**g**和**f**，就像g(f(x))，其中x是我们从**A**得到的值：
- en: '![](img/85c1f822-890f-4447-b754-920dafc3f1c8.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85c1f822-890f-4447-b754-920dafc3f1c8.png)'
- en: Not quite there? Hang in there. After a few examples you will be.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 还不太明白？坚持一下。经过几个例子，你就会明白了。
- en: Composition example in Go
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go中的组合示例
- en: 'We''re going to create two functions, `Humanize` and `Emphasize` (representing
    f and g), and a composition function of `Emphasize(Humanize(true))` to illustrate
    the path **A** to **B** to **C**:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个函数，`Humanize`和`Emphasize`（代表f和g），以及`Emphasize(Humanize(true))`的组合函数，以说明从**A**到**B**到**C**的路径：
- en: '![](img/04e03132-a800-4159-a025-6386d4dd9684.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04e03132-a800-4159-a025-6386d4dd9684.png)'
- en: 'The `src/compose/compose.go` file contains the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/compose/compose.go`文件包含以下代码：'
- en: '[PRE45]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`main.go` looks like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go`看起来是这样的：'
- en: '[PRE46]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you''re using the init script, then your terminal should look like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用init脚本，则您的终端应如下所示：
- en: '![](img/9b514e34-af68-4690-b047-b3642323ccd0.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b514e34-af68-4690-b047-b3642323ccd0.png)'
- en: 'If this was a more complicated example that included external packages, then
    you would have run the following (in this order):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个包括外部包的更复杂的示例，那么您将按照以下顺序运行：
- en: '`. init`, `glide-update`, and `go-run`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`. init`，`glide-update`和`go-run`'
- en: Haskell version of compose
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: compose的Haskell版本
- en: 'We''ll cover the Haskell version of composing Humanize and Emphasize:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍组合Humanize和Emphasize的Haskell版本：
- en: '[PRE47]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That's it!  Those five lines are equivalent to the 25 lines of Go code!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！这五行等同于25行Go代码！
- en: I am not at all advocating for any Gophers to switch to Haskell--there are far
    too many reasons to keep coding and deploying Go solutions to address here. I
    include the Haskell code for informational purposes. As mentioned earlier in the
    book, category theory trickles down from the brains of the mathematicians directly
    into Haskell. So, if we want to be good, pure functional programming Gophers,
    then we should learn Haskell.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我绝不主张任何Gophers转换到Haskell——有太多原因要保持编写和部署Go解决方案，这里无法一一列举。我包含Haskell代码是出于信息目的。正如本书前面提到的，范畴论直接从数学家的大脑中滴入Haskell。因此，如果我们想成为优秀的纯函数式编程Gophers，那么我们应该学习Haskell。
- en: 'Here''s the REPL terminal log of our session:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们会话的REPL终端日志：
- en: '![](img/a5e2627c-878c-4bcf-b32a-5fd0636440ad.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5e2627c-878c-4bcf-b32a-5fd0636440ad.png)'
- en: Let's look a bit closer at some of the lines.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一些行。
- en: We can ask our Haskell REPL to tell us the type of what we define using `:t
    <symbol>`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以要求Haskell REPL告诉我们我们定义的内容的类型使用`:t <symbol>`。
- en: 'For example, `:t humanize` tells us that it is a function (`->`) that takes
    a `Bool` and returns a list of characters:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`:t humanize`告诉我们它是一个函数（`->`），它接受一个`Bool`并返回一个字符列表：
- en: '[PRE48]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `\x` tells Haskell that compose is a lambda expression. We name our lambda
    `compose` and pass the `g` and `f` functions as parameters.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`\x`告诉Haskell，compose是一个lambda表达式。我们将我们的lambda命名为`compose`，并将`g`和`f`函数作为参数传递。'
- en: 'The `g (f x)` says, apply `f` to `x`, take that result, and pass it to `g`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`g (f x)`表示，应用`f`到`x`，取得结果，并将其传递给`g`：'
- en: '[PRE49]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let''s see what type compose is:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看compose的类型是什么：
- en: '[PRE50]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That''s a little hard to follow. So, let''s see how Haskell says the type is
    of its default implementation of the compose operator:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点难以理解。因此，让我们看看Haskell如何说它的默认实现的compose运算符的类型是什么：
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We''ve seen that before:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前见过这个：
- en: '![](img/2b57e872-3fab-4a46-b5bf-a87286883296.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b57e872-3fab-4a46-b5bf-a87286883296.png)'
- en: 'Great! Now we''re making progress. Time to define our `emphasizeHumanize` composition
    lambda:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们正在取得进展。是时候定义我们的`emphasizeHumanize`组合lambda了：
- en: '[PRE52]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`compose` is our function, and we pass it two parameters--`emphasize` and `humanize`.
    Being good, careful programmers, we''ll check our function literal''s type:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose`是我们的函数，我们传递了两个参数--`emphasize`和`humanize`。作为优秀、细心的程序员，我们将检查我们函数文字的类型：'
- en: '[PRE53]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Rock solid! It takes a Bool and returns a string.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 非常稳固！它接受一个布尔值并返回一个字符串。
- en: 'So far, so good. Now it''s time to run this Haskell `compose` function and
    see if we get the same results as we did in Go:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。现在是时候运行这个Haskell的`compose`函数，看看我们是否得到了与Go中相同的结果：
- en: '[PRE54]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Woot!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！
- en: Given that a lot of Haskellers are mathematicians, we know that they like to
    use symbols instead of words. Furthermore, we know they like their code to look like
    math equations. So, let's think like good, math-minded programmers and spice up
    the syntax.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于许多Haskeller是数学家，我们知道他们喜欢使用符号而不是单词。此外，我们知道他们喜欢他们的代码看起来像数学方程式。因此，让我们像优秀的、数学思维的程序员一样思考，为语法增添一些调味。
- en: 'Let''s redefine the composition function name with the `.` symbol (notice that
    we have to put the `.` in parentheses; otherwise, Haskell complains):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`.`符号重新定义组合函数名称（注意我们必须将`.`放在括号中；否则，Haskell会抱怨）：
- en: '[PRE55]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And now let''s check its type:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查它的类型：
- en: '[PRE56]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Okay, we can grok that now...it''s basic composition. We can use our period
    in place of compose:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以理解了...这是基本的组合。我们可以用句号代替compose：
- en: '[PRE57]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'But that''s not good enough. We can do better. Let''s use the infix notation
    by moving the (.) in between our two parameters, like so:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不够。我们可以做得更好。让我们使用中缀表示法，将（.）放在我们的两个参数之间，就像这样：
- en: '[PRE58]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And let''s verify that it works:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下它是否有效：
- en: '[PRE59]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: (g.f)(x) = g(f(x)) composition in Go
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: (g.f)(x) = g(f(x)) Go中的组合
- en: 'This is a graphical representation of our final example of composition in Go:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在Go中最终的组合示例的图形表示：
- en: '>![](img/ecafc22b-274b-4a39-8856-eea7314ee282.png)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/ecafc22b-274b-4a39-8856-eea7314ee282.png)'
- en: Don't gloss over that diagram. Study it. Let it sink in.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忽视那个图表。仔细研究它。让它深入你的心灵。
- en: This is composition, the fundamental principle of functional programming.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是组合，函数式编程的基本原则。
- en: That **(g.f)(x) = g(f(x))** equation is quite literal. It says that we can execute
    the **f** function, **Humanize(true)**, and then pass that value **"yes"** to **g** ... **Emphasize**(**"yes"**)
    to get **"yes!!"**.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 那个**(g.f)(x) = g(f(x))**方程非常字面。它说我们可以执行**f**函数，**Humanize(true)**，然后将值**"yes"**传递给**g**...**Emphasize**(**"yes"**)以获得**"yes!!"**。
- en: That **(g.f)(x) = g(f(x))** equation says one more thing. It says that we can
    nest our functions, **g(f(x))**, which is like going from **A** to **B** and then
    **B** to **C**, or we can simply go directly from **A** to **C** by executing **EmphasizeHumanize(true)**.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 那个**(g.f)(x) = g(f(x))**方程还说了一件事。它说我们可以嵌套我们的函数，**g(f(x))**，就像从**A**到**B**，然后从**B**到**C**，或者我们可以直接执行**EmphasizeHumanize(true)**从**A**到**C**。
- en: So, according to the left-hand diagram, **(g.f)(x) == g(f(x))**, and similarly,
    according to the right-hand diagram, **EmphasizeHumanize(true) ==  Emphasize(Humanize(true))**.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据左侧图表，**(g.f)(x) == g(f(x))**，同样地，根据右侧图表，**EmphasizeHumanize(true) ==  Emphasize(Humanize(true))**。
- en: '![](img/7df60447-1a1e-4479-ac5e-6c7c2fb8d0e6.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7df60447-1a1e-4479-ac5e-6c7c2fb8d0e6.png)'
- en: Bam!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 嘭！
- en: The (g.f)(x) = g(f(x)) implementation
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: (g.f)(x) = g(f(x))的实现
- en: Now let's take a peek at the code.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下代码。
- en: 'Here are the **f** and **g** functions from the preceding diagram:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面图表中的**f**和**g**函数：
- en: '[PRE60]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now for the new stuff.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是新东西的时间。
- en: 'We''ll create two types. Fbs represents **f** (or **A** to **B**), which takes
    a bool (true), and returns a string, `"yes"`. Fss represents **g** (or **B** to
    **C**). `Fss` takes a string, `"yes"`, and returns a string, `"yes!!"`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两种类型。Fbs代表**f**（或**A**到**B**），它接受一个布尔值（true），并返回一个字符串，`"yes"`。Fss代表**g**（或**B**到**C**）。`Fss`接受一个字符串，`"yes"`，并返回一个字符串，`"yes!!"`：
- en: '[PRE61]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here''s our `Compose` function:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`Compose`函数：
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Nested inside our `Compose` function is an anonymous function. It's our Lambda.
    In Haskell, it looked like `\x -> g (f x)`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Compose`函数内部嵌套着一个匿名函数。这是我们的Lambda。在Haskell中，它看起来像`\x -> g (f x)`。
- en: Lambdas are expressions, and we could pass them around anywhere. We need a function
    that takes a Boolean and returns a `"yes!!"` or a `"no!!"`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda是表达式，我们可以在任何地方传递它们。我们需要一个接受布尔值并返回一个`"yes!!"`或`"no!!"`的函数。
- en: 'Lastly, we define our `g.f` function literal:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义我们的`g.f`函数文字：
- en: '[PRE63]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: A note about composition naming conventions in Go
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于Go中组合命名约定的说明
- en: 'In Go, we don''t have the luxury of renaming a function name with the . symbol
    or a way to easily convert a function call that looks like **compose(f, g)** to
    one that looks like **g compose f**, much less one that looks like **g . f**.
    But no worries! We''ll just use the following naming convention to represent a
    compose function: `Emphasize_Humanize` (which reads, `g . f`, where `g` is `Emphasize`
    and `f` is `Humanize`). Typically, a camelcased symbol would look like `EmphasizeHumanize`,
    but with the `_` separating the camel humps, it''s obvious that this a special
    symbol.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，我们没有将函数名重命名为`.`符号的奢侈，也没有一种简单地将看起来像**compose(f, g)**的函数调用转换为看起来像**g compose
    f**，更不用说看起来像**g . f**的方法。但别担心！我们只需使用以下命名约定来表示一个组合函数：`Emphasize_Humanize`（读作`g
    . f`，其中`g`是`Emphasize`，`f`是`Humanize`）。通常，驼峰式符号看起来像`EmphasizeHumanize`，但用下划线分隔驼峰，很明显这是一个特殊符号。
- en: 'Here''s main.go:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这是main.go：
- en: '[PRE64]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And here''s what it looks like when we run it:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运行它时的样子：
- en: '![](img/29458000-fc00-4eee-8684-6eaaee0acfbe.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29458000-fc00-4eee-8684-6eaaee0acfbe.png)'
- en: The directions of the arrows are significant
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 箭头的方向是重要的
- en: In the last chapter, we used the following chart to solve *f(x) = x + 2:*
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用以下图表来解决*f(x) = x + 2:*
- en: '![](img/eb3c1664-0764-49e2-9751-e8222a3db109.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb3c1664-0764-49e2-9751-e8222a3db109.png)'
- en: 'Remember when we composed *f(x) = x + 2* with *g(x) = x2 + 1*? We solved **g(f(1))
    = 10**:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们将*f(x) = x + 2*与*g(x) = x2 + 1*组合时吗？我们解决了**g(f(1)) = 10**：
- en: '![](img/8b95812f-0f1a-47a6-bf5d-02a5fbaf3658.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b95812f-0f1a-47a6-bf5d-02a5fbaf3658.png)'
- en: We also proved that **f(g(1)) = 4**, which is obviously not **10**. So, we know
    that function composition is not commutative. The arrows go one way only.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还证明了**f(g(1)) = 4**，显然不是**10**。因此，我们知道函数组合不是可交换的。箭头只能单向移动。
- en: EmphasizeHumanize ordered incorrectly
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 强调人性化排序不正确
- en: 'When we try to reverse the order of operations, this is what we''re trying
    to do:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试颠倒操作顺序时，我们正在尝试做什么：
- en: '![](img/0499e2cc-9754-426f-8d2f-c0e33c2d6854.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0499e2cc-9754-426f-8d2f-c0e33c2d6854.png)'
- en: This does not compute.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这不符合逻辑。
- en: 'We start by passing a Boolean **true** to **Emphasize**, but what does that
    mean?  What are we trying to do?  We are not changing the direction of the arrows,
    but we are attempting to change the order in which we call them. Given our context
    of beginning with a Boolean and trying to get a `"yes!!"` or a `"no!!"` out, it
    only makes sense to apply our `Humanize` and `Emphasize` functions in one direction.
    We are, in effect, trying to compose backwards:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将布尔值**true**传递给**Emphasize**，但这是什么意思？我们试图做什么？我们没有改变箭头的方向，但我们试图改变调用它们的顺序。鉴于我们从布尔值开始，试图得到一个“是！”或“不是！”的结果，只有在一个方向上应用我们的`Humanize`和`Emphasize`函数才有意义。实际上，我们试图向后组合：
- en: '[PRE65]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that the rest of the code is identical to before. We only swapped the nesting
    order of **f** and **g** in our return statement.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，其余的代码与以前完全相同。我们只交换了返回语句中**f**和**g**的嵌套顺序。
- en: 'Our function literal that calls our `Compose` function looks like this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 调用我们的`Compose`函数的函数文字看起来像这样：
- en: '[PRE66]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: That says, *"Emphasize the true and then Humanize the result of that"*, which
    is clearly not going to work (see the preceding diagram).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，“强调真实，然后使结果人性化”，显然行不通（见前面的图表）。
- en: 'This code won''t even compile:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码甚至无法编译：
- en: '![](img/6d32204b-2ad1-45ba-83f4-3fa6407afc60.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d32204b-2ad1-45ba-83f4-3fa6407afc60.png)'
- en: Function composition is associative
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数组合是结合的
- en: 'So, function composition does not commute, but it is associative:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数组合不是交换的，但是它是结合的：
- en: '![](img/0c6f1211-4f95-468c-8aee-f8824c3dd744.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c6f1211-4f95-468c-8aee-f8824c3dd744.png)'
- en: That diagram says that we can compose our functions to get from **A** to **D**
    by either choosing the upper (**A****→C**→**D**) path or the lower (**A**→**B**→**D**) path.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表表示我们可以通过选择上方（**A****→C**→**D**）路径或下方（**A**→**B**→**D**）路径来组合我们的函数从**A**到**D**。
- en: The idea of a functor is that it translates the diagrams we can draw in one
    category into diagrams in another category. This often lets us convert ideas and
    theorems from one category into another.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 函子的概念是，它将我们可以在一个范畴中绘制的图表转换为另一个范畴中的图表。这通常让我们将一个范畴中的思想和定理转换为另一个范畴。
- en: Let's look at an example of a particular functor, the forgetful functor, to
    get a better feel for what it means to convert things from one category into another.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个特定函子的例子，遗忘函子，以更好地理解将事物从一个范畴转换为另一个范畴的含义。
- en: Functional composition in the context of a legal obligation
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在法律义务的背景下的功能组合
- en: Assume that Larry agreed to pay Lucy $5,000 by 1st October and that date has
    passed. Lucy wants to get paid $5,000 and Larry wants to pay her, but he does
    not have the money.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 假设拉里同意在10月1日之前支付给露西5000美元，那个日期已经过去了。露西想要得到5000美元的报酬，拉里也想支付她，但他没有钱。
- en: Should Lucy sue Larry to get him to pay?
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 露西应该起诉拉里让他付款吗？
- en: 'The following category diagram describes their situation:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的范畴图描述了他们的情况：
- en: '![](img/b6196744-65f1-403c-8569-d9979a00200c.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6196744-65f1-403c-8569-d9979a00200c.png)'
- en: 'The category states are as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴状态如下：
- en: '**A** = Where we are today (12th October)'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A** = 我们今天的位置（10月12日）'
- en: '**B** = Lucy demands a lawsuit'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B** = 露西要求提起诉讼'
- en: '**C** = Lucy gets paid'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C** = 露西得到报酬'
- en: 'The category morphisms are as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴态射如下：
- en: '**f** =  Legal expense (for both, $2,000+)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f** = 法律费用（对于两者，2000美元以上）'
- en: '**g** = Larry pays Lucy $5,000'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**g** = 拉里支付露西5000美元'
- en: '**h** = Larry pays Lucy $5,000'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**h** = 拉里支付露西5000美元'
- en: Decisions determine state transitions
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决定决定状态转换
- en: If Larry, in good faith, communicates the following to Lucy, which path will
    Lucy take?
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果拉里以诚意向露西传达以下内容，露西会选择哪条路？
- en: To be clear, I'm simply asking for more time to pay or for you to allow me to
    make scheduled payments directly to you without going through the court system.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确，我只是要求更多时间付款，或者你允许我直接向你支付预定的付款，而不需要通过法院系统。
- en: Your thoughts?
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 你的想法是什么？
- en: Larry
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 拉里
- en: It's obvious that these two will eventually get from **A** to **C**, but which
    path is the shortest? Which path is more costly, both in terms of time and financial
    expenses?
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这两个路径最终都会从**A**到**C**，但哪条路径最短？哪条路径在时间和财务开支方面更昂贵？
- en: Category theory review
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范畴论复习
- en: We connect two arrows from **A** to **B** and **B** to **C**, and another equivalent
    arrow from **A** to **C**. **A**, **B**, and **C** are called objects. They can
    represent anything. In this example, they represent states--beginning (**A**),
    intermediate (**B**), and final (**C**) states. In the next example, the domain
    and range represent different court cases, different worlds. The facts of each
    case make up the structure of each, and the arrows between the two worlds are
    the mappings the attorneys perform to make their case.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们连接两个箭头从**A**到**B**和**B**到**C**，以及另一个等价的箭头从**A**到**C**。**A**，**B**和**C**被称为对象。它们可以代表任何东西。在这个例子中，它们代表状态--开始（**A**），中间（**B**）和最终（**C**）状态。在下一个例子中，域和范围代表不同的法院案件，不同的世界。每个案件的事实构成了每个案件的结构，两个世界之间的箭头是律师进行的映射，以证明他们的案件。
- en: Categorical rules
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 范畴规则
- en: 'There are only two rules that must be followed:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两条规则必须遵循：
- en: Identity
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份
- en: Associativity
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合性
- en: Results oriented
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果导向
- en: 'Category theory is results oriented. It''s all about getting from **A** to
    **C**. The arrows are one-directional. When we compose the two paths (**A** →
    **B** and **B** → **C**), we get an equivalent path (**A** → **C**). That is what
    we are doing when we compose functions. We can call one `Compose` function (shown
    in the following snippet) rather than two functions (`f` and `g`):'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '范畴论是结果导向的。它的重点是从**A**到**C**。箭头是单向的。当我们组合两条路径（**A** → **B**和**B** → **C**）时，我们得到一个等效的路径（**A**
    → **C**）。这就是我们组合函数时所做的。我们可以调用一个`Compose`函数（如下面的代码片段中所示），而不是两个函数（`f`和`g`）： '
- en: '[PRE67]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The forgetful functor and the law
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遗忘函子和法律
- en: Suppose Lucy chooses the longer path; how will Lucy's attorneys make the case
    for their client?
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Lucy选择了更长的路径；Lucy的律师们将如何为他们的客户辩护？
- en: Let's assume there is more to this story. Let's assume that Lucy has injured
    Larry in some way in the past, and now that Lucy is forcing Larry into a lawsuit,
    he will in turn choose to convey this new information to his attorney in order
    to file a counterclaim.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设这个故事还有更多内容。假设Lucy在过去某种方式上伤害了Larry，现在Lucy正在强迫Larry提起诉讼，他将选择向他的律师传达这些新信息，以提起反诉。
- en: The rule of law
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 法律规则
- en: How will the law work when they go to court? The attorneys research the law
    to find a case from prior court cases that might yield favorable results for their
    client. They then use that case's ruling as a precedent to win the current case
    for their client.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 他们上法庭时法律将如何运作？律师们研究法律，寻找以前的法院案例，可能会为他们的客户带来有利的结果。然后，他们使用该案例的裁决作为先例来为他们的客户赢得当前的案件。
- en: It is impossible to refer to the entirety of case history to prove their point.
    So, attorneys for both sides will use a rhetorical device, known to category theorists
    as the forgetful functor. The forgetful functor necessarily leaves behind some
    structure. It is very difficult to find a case from the past that is identical
    in every way to the case at hand.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明他们的观点，不可能参考整个案件历史。因此，双方的律师将使用一种修辞手法，范畴论者称之为健忘函子。健忘函子必然会留下一些结构。很难找到一个在每个方面都与手头案件相同的过去案例。
- en: Each attorney attempts to convince others that the structure that they present--that
    is, the one court case that, if chosen, would yield the best results for their
    client--is the one that should be applied.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 每个律师都会努力说服他人，他们提出的结构，即如果选择的话，将为他们的客户带来最佳结果的一个法院案件，应该被应用。
- en: The reality is that there is a very large number of court rulings in the past
    that could apply, but each attorney will try to convince the judge and/or jury
    that the case that they choose is the way the the law actually is.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，过去有很多法院裁决可能适用，但每个律师都会试图说服法官和/或陪审团，他们选择的案件才是实际情况。
- en: The winning side will have effectively mapped a prior court ruling from a world
    that included different parties (plaintiff, defendants, and case facts) onto the
    current case. Some of the details will be different, but the winning attorney
    is the one that best communicates that they have identified the most relevant
    and applicable case to apply in court today.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 获胜的一方将有效地从一个包括不同当事人（原告、被告和案件事实）的世界中映射出先前的法院裁决到当前案件。一些细节会有所不同，但获胜的律师是最好地传达他们已经确定了最相关和适用的案例来在今天的法庭上应用。
- en: Each attorney identifies the bilateral symmetry between an old case that will
    best help their client and the present court case, and does their part to convince
    others to apply that case. We might hear the argument begin this way, *"Ladies
    and gentlemen, the essential structure you need to apply is this one**".*
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 每个律师都会确定一个旧案件与最有助于他们客户的现行法庭案件之间的双边对称性，并尽力说服他人应用该案件。我们可能会听到这样的论点开始，*“女士们，先生们，您需要应用的基本结构是这样的**”。*
- en: Lucy’s forgetful functor
  id: totrans-446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Lucy的健忘函子
- en: 'Given that G is their current case, with its current set of facts, Lucy''s
    attorney maps the facts from the case (**E**) that helps Lucy the most:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于G是他们当前的案件，以及它当前的事实，Lucy的律师将案件（**E**）中对Lucy最有帮助的事实进行映射：
- en: '![](img/0e32e19a-3dfd-40db-94ea-248a677711f2.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e32e19a-3dfd-40db-94ea-248a677711f2.png)'
- en: '**f[Lucy]** is the mapping function from the facts of case **E**, with precedence
    in favor of Lucy.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**f[Lucy]**是来自案件**E**的事实的映射函数，优先考虑Lucy。'
- en: Larry’s forgetful functor
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Larry的健忘函子
- en: 'Larry''s attorney maps the facts from the case (**F**) that helps Larry the
    most:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Larry的律师将案件（**F**）中对Larry最有帮助的事实进行映射：
- en: '![](img/2b9faa05-5037-48ac-af96-bd719c58b1d4.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b9faa05-5037-48ac-af96-bd719c58b1d4.png)'
- en: It's up to the judge and/or jury to decide which mapping fits best with the
    current case under review. The side with the best mapping wins.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 由法官和/或陪审团决定哪种映射最适合当前审查的案件。拥有最佳映射的一方获胜。
- en: It's time to code another functor (pun intended).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候编写另一个函子了（这是双关语）。
- en: Build a 12-hour clock functor
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个12小时时钟函子
- en: 'We''ll build a 12-hour clock functor like this one:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个类似这样的12小时时钟函子：
- en: '| **Structure** | A clock with 12 places for the hours |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| **结构** | 一个有12个小时位置的时钟 |'
- en: '| **Transformation operation** | *f(x) = x + 12*, where *x* is the hour |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| **转换操作** | *f(x) = x + 12*，其中*x*是小时 |'
- en: '![](img/3da5772f-617f-406d-b8a1-9163d5f7c878.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3da5772f-617f-406d-b8a1-9163d5f7c878.png)'
- en: 'First, let’s examine the functor implementation:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下函子的实现：
- en: '[PRE68]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Define our `ClockFunctor` interface to include a single function (`Map`):'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 定义我们的`ClockFunctor`接口以包括一个函数（`Map`）：
- en: '[PRE69]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a container to hold our list of 12 hours:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个容器来保存我们的12小时列表：
- en: '[PRE70]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When called, `Map` will be executed/applied to each element in the container:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用时，`Map`将被执行/应用到容器中的每个元素：
- en: '[PRE71]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: It's okay for the implementation of `Map` to be impure, as long as the side
    effects are limited to variables, such as the loop variables, scoped to the `Map`
    function. Notice that return the container, that we call `box`, whose elements
    have been transformed in some way by the mapper function, **f**.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`的实现可以是不纯的，只要副作用限于变量，比如循环变量，作用域在`Map`函数中。注意返回容器，我们称之为`box`，其元素已经以某种方式被映射函数**f**转换。'
- en: 'Next, we create a function named Functor that wraps our list of 12 hours into
    the magical box for transformation. This is where we lower our values into the
    gutter. Some call this process lifting, where the mapping transformation from
    one world to another occurs (for details, see *Pure FP goes to Hell* earlier in
    this chapter):'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为Functor的函数，它将我们的12小时列表包装到魔法盒中进行转换。这是我们将价值降低到低谷的地方。有些人称这个过程为lifting，其中从一个世界到另一个世界的映射转换发生（有关详情，请参见本章前面的*Pure
    FP goes to Hell*）：
- en: '[PRE72]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Clock functor helpers
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时钟函子助手
- en: Towards the end of our `clock.go` file, we'll add some helpers, as discussed
    in the following sections.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的“clock.go”文件末尾，我们将添加一些辅助函数，如下面的部分所讨论的。
- en: The Unit function
  id: totrans-473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元函数
- en: 'Our `Unit` function is our identity function. When applied to elements in the
    slice, it will have no effect. It''s trivial, but it''s a requirement to satisfy
    the functor algebraic laws:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“Unit”函数是我们的身份函数。当应用于切片中的元素时，它不会产生任何效果。这很琐碎，但它是满足函子代数法则的要求：
- en: '[PRE73]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The AmPmMapper function
  id: totrans-476
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AmPmMapper函数
- en: This is the mapper we apply when we want to change from AM to PM hours. It will
    be passed to the `Map` method and applied to each hour contained in the box. It
    converts an AM hour (1, 2...12) to its corresponding PM hour (13, 14..0).
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在想要从上午小时变成下午小时时应用的映射器。它将被传递给“Map”方法，并应用于盒子中包含的每个小时。它将把上午小时（1、2...12）转换为相应的下午小时（13、14..0）。
- en: '[PRE74]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The AmHoursFn helper
  id: totrans-479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AmHoursFn辅助函数
- en: 'We can call this handy function any time we want the list of AM hours. Note
    that if we create an `AmHours` variable to pass to our clock''s functor, its value
    can be changed. So, this is like a slice constant of AM hours:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随时调用这个方便的函数，以获取上午小时的列表。请注意，如果我们创建一个“AmHours”变量传递给我们时钟的函子，它的值是可以改变的。因此，这就像是一个上午小时的切片常量：
- en: '[PRE75]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In real-world scenarios, we'll use functors as intended, that is, we will pass
    an initial slice of values in and allow each functor to transform the slice of
    values each time a new functor's `Map` function is called. In our `main.go` file,
    we want to reset the set of hours for learning purposes.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，我们将按照预期使用函子，也就是说，我们将传入一组初始值的切片，并允许每个函子在调用新的函子的“Map”函数时转换这组值的切片。在我们的“main.go”文件中，我们想要重置学习目的的小时集。
- en: The String helper function
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串辅助函数
- en: 'Create a String helper function to use when printing the functor''s contents:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个字符串辅助函数，用于在打印函子内容时使用：
- en: '[PRE76]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: main.go
  id: totrans-486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: main.go
- en: 'We start with our typical `package main` and `import` statements and the `main()`
    function:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从典型的“package main”和“import”语句以及“main（）”函数开始：
- en: '[PRE77]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that we preface our internal `functor` package (found in the `src` directory)
    with a dot. That allows us to refer to symbols that it exports, such as `Functor`
    and `Map.`
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在内部的“functor”包（在“src”目录中找到）前面加上一个点。这样可以让我们引用它导出的符号，比如“Functor”和“Map”。
- en: First, we call our `Functor` method and pass in our slice of `AmHours`. `Functor`
    wraps our hours structure in a function of type `ClockFunctor:`
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用我们的“Functor”方法，并传入我们的“AmHours”切片。“Functor”将我们的小时结构包装在类型为“ClockFunctor”的函数中：
- en: '[PRE78]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here''s the output:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE79]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `Functor` function is what connects our two worlds: the world of AM hours
    and the world of PM hours (or vice versa). We can say that `Functor` lowers our
    hours into a magical box where the transformation mapping function, `amPmMapper`,
    is applied to each element, transforming it into its corresponding PM (or AM)
    hour.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: “Functor”函数是连接我们两个世界的东西：上午小时的世界和下午小时的世界（或者反之亦然）。我们可以说，“Functor”将我们的小时数降低到一个神奇的盒子中，在这个盒子中，变换映射函数“amPmMapper”被应用到每个元素上，将其转换为相应的下午（或上午）小时。
- en: 'Note that the mapper function must be free of any side effects:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，映射函数必须不产生任何副作用：
- en: '[PRE80]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here''s the output:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE81]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We can see that when we pass our functor's identity function, unit, to its `Map`
    method, it returns what we passed it, that is, the AM hours.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当我们将我们的函子的身份函数“unit”传递给它的“Map”方法时，它会返回我们传递的内容，也就是上午小时。
- en: 'Now for the fun part. Let''s pass our mapping function to our functor:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分。让我们将我们的映射函数传递给我们的函子：
- en: '[PRE82]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here''s the output:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE83]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Awesome! Our list of AM hours has been transformed into a list of PM hours.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的上午小时列表已经转换为下午小时列表。
- en: 'Now, let''s show off and chain two `Map` calls:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们炫耀一下，并链接两个“Map”调用：
- en: '[PRE84]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Here''s the output:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE85]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Why was that showing off?  It does not look like anything changed. Lame. Right?
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么那样炫耀呢？看起来好像什么都没变。无聊。对吧？
- en: Wrong. We're chaining our functors.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 错误。我们正在链接我们的函子。
- en: '![](img/2330d241-2d2b-4a81-9b91-50bb0bfad2fb.png)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2330d241-2d2b-4a81-9b91-50bb0bfad2fb.png)'
- en: The reason why the output doesn't look like it's changed is because it went
    from AM hours to PM hours and back to AM hours.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来没有改变的原因是因为它从上午小时变成下午小时，然后又变回上午小时。
- en: Terminal output log
  id: totrans-513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 终端输出日志
- en: 'Here''s what it looks like in our terminal:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们终端上的样子：
- en: '![](img/243541e1-0f3c-4980-aab4-e6517bfb0c19.png)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![](img/243541e1-0f3c-4980-aab4-e6517bfb0c19.png)'
- en: Functor summary
  id: totrans-516
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函子总结
- en: Our clock functor comprises a structure (an int slice) that holds 12 hours and
    a `Map` method that accepts a mapper function that is used to transform each of
    the 12 hours into the subsequent set of 12 hours (AM/PM). Each time the `Map`
    method is executed, it returns a new functor; because of this feature, we can
    chain our `Map` method calls.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的时钟函子包括一个结构（一个整数切片），其中包含12小时和一个“Map”方法，该方法接受一个映射函数，用于将12小时中的每个小时转换为随后的12小时（上午/下午）。每次执行“Map”方法时，它都会返回一个新的函子；由于这个特性，我们可以链接我们的“Map”方法调用。
- en: 'In other words, have a look at the following example:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，看看以下示例：
- en: '[PRE86]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We see that with functors, we wrap and `Map` (and can chain our maps).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，使用函子，我们包装并“Map”（并且可以链接我们的映射）。
- en: The car functor
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汽车函子
- en: Let's use a functor to upgrade (and downgrade) some cars! We'll start by opening
    our `car.go` file in our `functor` package.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个函子来升级（和降级）一些汽车！我们将首先打开我们“functor”包中的“car.go”文件。
- en: The functor package
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函子包
- en: 'Let''s have a look at `src/functor/car.go`:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看“src/functor/car.go”：
- en: '[PRE87]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: It's good practice to define our types at the top. Putting them in a type block
    helps to keep our code clean and tidy. Another good practice is to add JSON annotations
    to each field of a struct to enable easy (un)marshalling of JSON into our `Car`
    struct.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部定义我们的类型是一个好习惯。将它们放在一个类型块中有助于保持我们的代码整洁。另一个好习惯是为结构体的每个字段添加JSON注释，以便轻松地将JSON（解）编组为我们的“Car”结构。
- en: 'If you want to omit empty fields from a struct, you can add the `omitempty`
    clause to the end of your field annotation. For example, if the `Make` was optional
    or sometimes not included and we didn''t want the `json` created from a `Car`
    struct to include empty `Make` fields, our struct definition would look like this:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从结构中省略空字段，可以在字段注释的末尾添加`omitempty`子句。例如，如果`Make`是可选的或有时不包括在内，我们不希望从`Car`结构创建的`json`包含空的`Make`字段，我们的结构定义将如下所示：
- en: '`Car struct {`'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car struct {`'
- en: '`    Make string `json:"make"``'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '` Make string `json:"make"``'
- en: '`    Model string `json:"model,omitempty"``'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '` Model string `json:"model,omitempty"``'
- en: '`}`'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'Next comes our interface definition that includes the single `Map` method:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的接口定义，其中包括单个`Map`方法：
- en: '[PRE88]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'And here''s our magical box that consists of the slice we''ll be transforming:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的神奇盒子，其中包含我们将要转换的切片：
- en: '[PRE89]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here''s our `Map` method implementation, where we iterate through the elements
    of the slice of cars in our magical box, applying the mapping function `f` to
    each element:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`Map`方法实现，我们在其中遍历我们神奇盒子中的汽车切片的元素，将映射函数`f`应用于每个元素：
- en: '[PRE90]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Here''s our `Wrap` method that is used to lower our slice of cars into the
    magical box for transformation:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`Wrap`方法，用于将我们的汽车切片降低到神奇盒子进行转换：
- en: '[PRE91]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Here we define our helper functions. `Unit` we''ve seen before--it''s our identity
    morphism. The other two are `Upgrade` and `Downgrade.` We''ll keep it simple and
    simply append an `" LX"` to the end of the model name when we upgrade or remove
    it to downgrade a car:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了我们的辅助函数。`Unit`我们以前见过--它是我们的身份态射。另外两个是`Upgrade`和`Downgrade`。我们将保持简单，当我们升级或删除汽车时，我们将简单地在模型名称的末尾附加“LX”：
- en: '[PRE92]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Lastly, we include a `String` method so that our `fmt` package knows how to
    print our cars:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们包括一个`String`方法，以便我们的`fmt`包知道如何打印我们的汽车：
- en: '[PRE93]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: main.go
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: main.go
- en: 'We''ll manipulate strings and some JSON, as well as a `car` functor:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将操作字符串和一些JSON，以及一个`car`函子：
- en: '[PRE94]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Create a `cars` variable to hold a `Car` type and initialize it with two cars.
    Since we annotated our `Make` and `Model` fields with `''json''`, we can easily
    unmarshal a `Toyota Highlander` into a car:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`cars`变量来保存`Car`类型，并用两辆车进行初始化。由于我们用`'json'`注释了我们的`Make`和`Model`字段，我们可以轻松地将`Toyota
    Highlander`解组为一辆车：
- en: '[PRE95]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now, let''s exercise our `car` functor and verify that it works properly:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们练习一下我们的`car`函子，并验证它是否正常工作：
- en: '[PRE96]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Compare one line of FP to a bunch of imperative lines
  id: totrans-551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将FP的一行与大量的命令式行进行比较
- en: It takes one line of FP-style code to apply an upgrade and downgrade to a car.
    Granted, the `Upgrade` and `Downgrade` mapper functions were defined in the `functor`
    package, but that's a great benefit. We can keep the boilerplate implementation
    of looping through the slice of cars separate from our business use case logic.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 应用升级和降级到汽车只需要一行FP风格的代码。当然，`Upgrade`和`Downgrade`映射函数是在`functor`包中定义的，但这是一个很大的好处。我们可以将循环遍历汽车切片的样板实现与我们的业务用例逻辑分开。
- en: 'With the imperative implementation style, we first implement the `for...range`
    iteration block into which we insert our Upgrade/Downgrade logic:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令式实现风格，我们首先将`for...range`迭代块实现到其中，然后插入我们的升级/降级逻辑：
- en: '[PRE97]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: See the difference?
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 看到区别了吗？
- en: Which style of coding will be easier to maintain?
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种编码风格更容易维护？
- en: Car functor terminal session
  id: totrans-557
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Car函子终端会话
- en: 'Let''s run our car functor example:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的car函子示例：
- en: '![](img/ff3b748b-7219-4d67-a60a-26b586fc36ea.png)'
  id: totrans-559
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff3b748b-7219-4d67-a60a-26b586fc36ea.png)'
- en: Monoids
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幺半群
- en: Monoids are the most basic way to combine any values. A monoid is algebra that
    is closed under an associative binary operation and has an identity element.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群是组合任何值的最基本方式。幺半群是代数，它在一个可结合的二元运算下是封闭的，并且具有一个身份元素。
- en: We can think of a monoid as a design pattern that allows us to quickly reduce
    (or fold) on a collection of a single type in a parallel way.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将幺半群看作是一种设计模式，它允许我们以并行方式快速减少（或折叠）单一类型的集合。
- en: Monoid rules
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 幺半群规则
- en: 'A monoid is anything that satisfies the following rules:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群是满足以下规则的任何东西：
- en: Closure rule
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包规则
- en: Associativity rule
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合律规则
- en: Identity rule
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份规则
- en: Let's discuss these rules in brief.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论这些规则。
- en: Closure rule
  id: totrans-569
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 闭包规则
- en: “If you combine two values of same type, you get another value of the same type.”
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: “如果你组合两个相同类型的值，你会得到另一个相同类型的值。”
- en: Given two inputs of the same type, a monoid returns one value of the same type
    as the input.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 给定相同类型的两个输入，幺半群返回相同类型的一个值。
- en: Closure rule examples
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 闭包规则示例
- en: 1 + 2 = 3, and 3 is an integer.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + 2 = 3，3是一个整数。
- en: 1 + 2 + 3 also equals an integer.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + 2 + 3也等于一个整数。
- en: 1 + 2 + 3 + 4 also equals an integer.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + 2 + 3 + 4也等于一个整数。
- en: Our binary operation has been extended into an operation that works on lists!
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的二元运算已经扩展为适用于列表的运算！
- en: Closure axiom
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 闭包公理
- en: If a, b ∈ S, then a + b ∈ S.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 如果a，b ∈ S，则a + b ∈ S。
- en: That says, if a and b are any two values in the set S of integers and if we
    apply the binary operation + to any two values, then the result of that addition
    operation will be a value that is also in the set of integers.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果a和b是整数集合S中的任意两个值，并且如果我们将二元运算+应用于任意两个值，那么该加法运算的结果也将是整数集合中的一个值。
- en: Associativity rule
  id: totrans-580
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结合律规则
- en: “If you combine several more values, the order in which you combine does not
    matter”
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: “如果你组合了更多的值，组合的顺序并不重要”
- en: '[PRE98]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: So, if we have 1 + 2 + 3 + 4, we can transform that into ( 1 + 2 ) + ( 3 + 4
    ).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们有1 + 2 + 3 + 4，我们可以将其转换为（1 + 2）+（3 + 4）。
- en: Note that associativity works for addition and multiplication and string concatenation,
    but not for subtraction and division.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，结合性适用于加法和乘法以及字符串连接，但不适用于减法和除法。
- en: Identity rule
  id: totrans-585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 身份规则
- en: “There is an identity element that doesn’t do anything.”
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: “有一个不做任何事情的身份元素。”
- en: '- Identity rule'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '- 身份规则'
- en: A monoid will take two values of the same type and return one value of the same
    type.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群将取两个相同类型的值，并返回一个相同类型的值。
- en: Identity rule examples
  id: totrans-589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 身份规则示例
- en: Under the + operator, the set of integers has an identity of 0.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在+运算符下，整数集合的身份是0。
- en: '| Rule | Example |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| 规则 | 示例 |'
- en: '| Left identity | 0 + 1 == 1 |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| 左身份 | 0 + 1 == 1 |'
- en: '| Right identity | 1 + 0 == 1 |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| 右单位 | 1 + 0 == 1 |'
- en: Notice that the operator is binary, that is, it takes two inputs, and those
    inputs must be of the same type.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运算符是二元的，即它接受两个输入，并且这些输入必须是相同的类型。
- en: The result of combining the identity element (sometimes called empty or zero)
    with x is always x.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 将身份元素（有时称为空或零）与x组合的结果始终是x。
- en: An identity of 0
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 0的身份
- en: Under the * operator the set of integers has an identity of 1.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在*运算符下，整数集合具有1的身份。
- en: '[PRE99]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Writing a reduction function
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个缩减函数
- en: Given the previous three rules, we can write a reduction function. When we run
    a reduction on an array of integers using addition, we seed our operation with
    a 0 (the identity element).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的三条规则，我们可以编写一个缩减函数。当我们使用加法对整数数组进行缩减时，我们的操作以0（身份元素）为种子。
- en: When we run a reduction on an array of integers using multiplication, we seed
    our operation with a 1 (the identity element).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用乘法对整数数组进行缩减时，我们的操作以1（身份元素）为种子。
- en: 'That''s the idea. The following table summarizes a number of possible reductions:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是想法。以下表格总结了许多可能的缩减：
- en: '| **Type** | **Operation** | **Unit/zero/neutral value** |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **操作** | **单位/零/中性值** |'
- en: '| ints | + | 0 |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | + | 0 |'
- en: '| ints | * | 1 |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | * | 1 |'
- en: '| string | + (concat strings) | “” |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | +（连接字符串） | “” |'
- en: '| bool | && | true |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '| 布尔 | && | true |'
- en: '| bool | &#124;&#124; | false |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| 布尔 | &#124;&#124; | false |'
- en: '| list | << (concat list) | [] |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | <<（连接列表） | [] |'
- en: '|  |  |  |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: A semigroup is a missing neutral value
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 半群是缺少中性值
- en: If we are missing the unit/zero/neutral value, then we don’t have a monoid,
    we have a semigroup. Note that a semigroup can be converted into a monoid.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们缺少单位/零/中性值，那么我们就没有幺半群，而是半群。请注意，半群可以转换为幺半群。
- en: That was a very interesting discussion of the algebra of monoids, but what the
    heck are they good for, and why should we care?
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于幺半群代数的非常有趣的讨论，但是它们有什么用呢，我们为什么要关心呢？
- en: Here are a couple of good uses for monoids.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是幺半群的几个很好的用途。
- en: Converting binary operations into operations that work on lists
  id: totrans-615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将二进制运算转换为在列表上工作的运算
- en: 'Consider the following operation:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下操作：
- en: '[PRE100]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Instead of having to write all that code where we type a number, type a `+`,
    type another number, and we can feed a list of numbers into our reduce function
    that applies the `+` operation to each item and accumulates the sum.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必编写所有那些代码，其中我们输入一个数字，输入一个`+`，再输入另一个数字，我们可以将数字列表输入到我们的缩减函数中，该函数对每个项目应用`+`操作并累积总和。
- en: 'Here''s an example of appending strings:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个字符串附加的例子：
- en: '[PRE101]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: What was the neutral/identity element used in each of the preceding examples?
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，使用了哪个中性/身份元素？
- en: The preceding code is F# code. The `|>` symbol is just a pipe symbol, like we
    use in a Unix terminal. It allows us to pipe the list of integers `[1,2,3]` or
    a list strings `["a", "b", "c"]`  into `List.reduce(+)`. The greater than symbol
    is just an indication of the direction of the flow of data, that is, from left
    to right.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是F#代码。`|>`符号只是一个管道符号，就像我们在Unix终端中使用的一样。它允许我们将整数列表`[1,2,3]`或字符串列表`["a",
    "b", "c"]`传递到`List.reduce(+)`中。大于符号只是数据流的方向指示，即从左到右。
- en: Using monoids with divide and conquer algorithms
  id: totrans-623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将幺半群与分治算法一起使用
- en: Monoids are frequently used to solve large computations. Monoids help us to
    break our computations into pieces. We can run smaller computations in separate
    cores or on separate servers and recombine/reduce/fold the results into a single
    result. We often employ parallel or concurrency techniques along with incremental
    accumulation of our result.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群经常用于解决大型计算问题。幺半群帮助我们将计算分解成片段。我们可以在单独的核心或单独的服务器上运行较小的计算，并将结果重新组合/缩减/折叠成单一结果。我们经常使用并行或并发技术以及递增积累我们的结果。
- en: 'As a very simple example, if we need to add these numbers: 1 + 2 + 3 + 4.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常简单的例子，如果我们需要添加这些数字：1 + 2 + 3 + 4。
- en: 'We can add ( 1 + 2 ) on one CPU/core and ( 3 + 4 ) on another:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个CPU/核心上添加（1 + 2），在另一个CPU/核心上添加（3 + 4）：
- en: 3 + 7 = 10
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 3 + 7 = 10
- en: Where associativity holds, we can parallelize our computations.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 当结合律成立时，我们可以并行计算。
- en: Referential transparency
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用透明性
- en: Identifying when using monoid can help us make design decisions that affect
    performance.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 使用幺半群可以帮助我们做影响性能的设计决策。
- en: 'On day one, we''re asked to add 1 + 2 + 3\. Then, on day two, we''re asked
    to add 1 more. We don''t have to add 1 + 2 + 3 again. We can simply store that
    and add our new 1 to it:  6 + 1 = 7.'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一天，我们被要求添加1 + 2 + 3。然后，在第二天，我们被要求再添加1。我们不必再次添加1 + 2 + 3。我们只需存储它并将新的1加到它上：6
    + 1 = 7。
- en: Given that nothing is free, what did it cost us to gain the performance boost
    of not having to add 1 + 2 + 3? Storage. The question becomes, which is more costly?
    The answer to that will tell us whether to leverage referential transparency or
    not. Just because we can do something does not mean we always should.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑到没有什么是免费的，我们为了获得不必再次添加1 + 2 + 3的性能提升付出了什么代价？存储。问题是，哪个更昂贵？这个答案将告诉我们是否利用引用透明性。仅仅因为我们可以做某事，并不意味着我们总是应该这样做。 '
- en: Handling no data
  id: totrans-633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理没有数据
- en: What if we have no data but we're asked to reduce it? Similarly, what if we
    have no data but we’re asked to incrementally add to it?
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有数据，但被要求对其进行缩减呢？同样，如果我们没有数据，但被要求逐步添加到它呢？
- en: This is when the identity element comes in handy! It can be the initial value
    for missing data.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是身份元素派上用场的时候！它可以是缺失数据的初始值。
- en: More examples of monoids
  id: totrans-636
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 幺半群的更多例子
- en: Lists are monoids. The operation to combine them is simply concatenation. Many
    types of containers are also monoids, including monads.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是幺半群。将它们组合的操作只是连接。许多类型的容器也是幺半群，包括单子。
- en: What are not monoids?
  id: totrans-638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么不是幺半群？
- en: Integers are not monoids, but integers under addition (a way to combine them)
    are monoids.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 整数不是幺半群，但加法下的整数（一种组合方式）是幺半群。
- en: Whole numbers (integers starting at 1), and even whole numbers under addition,
    are not monoids. What is the neutral element for addition? The answer is zero.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 整数（从1开始的整数），甚至加法下的整数都不是幺半群。加法的中性元素是什么？答案是零。
- en: 'Invoices are not monoids:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 发票不是幂等性：
- en: '![](img/0b8f0dc3-8f8b-4661-bfbc-136ea1ba44c6.png)'
  id: totrans-642
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b8f0dc3-8f8b-4661-bfbc-136ea1ba44c6.png)'
- en: How can we combine two invoices?
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何组合两张发票？
- en: '![](img/412e3faf-2ded-4b05-99c7-1c1353b2a4a8.png)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
  zh: '![](img/412e3faf-2ded-4b05-99c7-1c1353b2a4a8.png)'
- en: What does it mean to add invoices? Are we going to merge the colors or somehow
    smash them together? If we stack them, how can we do anything with them, other
    than take the top one off the list? How do we combine the customer addresses?
    Sure, we can add the work order numbers, 1,000 + 1,000 = 2,000, but what value
    is that to us?
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 添加发票意味着什么？我们要合并颜色还是以某种方式将它们混合在一起？如果我们堆叠它们，除了从列表中取出顶部的那个之外，我们怎么能对它们做任何事情？我们如何组合客户地址？当然，我们可以添加工作订单号，1,000
    + 1,000 = 2,000，但对我们有什么价值呢？
- en: How could we possibly add invoices? Maybe if we choose some fields that are
    statistical in nature?
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么可能添加发票？也许如果我们选择一些具有统计性质的字段？
- en: Monoid examples
  id: totrans-647
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幂等性示例
- en: 'We''ll cover three types of monoid here:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里涵盖三种类型的幂等性：
- en: Name monoid
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字幂等性
- en: Int slice monoid
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int切片幂等性
- en: Line item monoid
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行项目幂等性
- en: That's right. We're going to turn that invoice into a monoid!
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 没错。我们要把那张发票变成一个幂等性！
- en: Name monoid
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名字幂等性
- en: Let's see what we can do with a name. First, we define an interface that has
    two methods, `Append` and `Zero.` We wrap our name in `nameContainer.`
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以用一个名字做些什么。首先，我们定义一个具有两种方法`Append`和`Zero`的接口。我们将我们的名字包装在`nameContainer`中。
- en: Our `nameContainer` is a struct with a single string field, `name`. Our `Append`
    method appends the given name to the long name string it's building up that lives
    in the magical `nameContainer`. Our zero morphism for our name string is an empty
    string.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`nameContainer`是一个结构体，有一个字符串字段`name`。我们的`Append`方法将给定的名字附加到长名字字符串中，该字符串存储在神奇的`nameContainer`中。我们名字的零态射是一个空字符串。
- en: 'The content of `src/monoid/name_monoid.go` would look as follows:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/monoid/name_monoid.go`的内容如下：'
- en: '[PRE102]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Here''s what `main.go` looks like:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go`看起来是这样的：'
- en: '[PRE103]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Name monoid terminal session
  id: totrans-660
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 名字幂等性终端会话
- en: 'Let''s run our monoid:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的幂等性：
- en: '![](img/00863fff-a211-46a6-b700-096d647b1250.png)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00863fff-a211-46a6-b700-096d647b1250.png)'
- en: Here, we ran our app and got good results. The initial state is Alice, and the
    **Zero** value is the empty string; after the first append we get **AliceAlice,**
    and when we chain another we get **AliceAliceAlice.**
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行了我们的应用程序并获得了良好的结果。初始状态是Alice，**Zero**值是空字符串；在第一次附加后，我们得到**AliceAlice**，当我们再附加一次时，我们得到**AliceAliceAlice**。
- en: Int slice monoid
  id: totrans-664
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Int切片幂等性
- en: Let's see what we can do with a slice of ints.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以用一些整数做些什么。
- en: First, we define an interface that has two methods, `Append` and `Zero.` We
    wrap our int in `intContainer`. `intContainer` is a struct with a single int field,
    `ints`. Our `Append` method appends the given int slice to the slice of `ints`
    it's building up that lives in the magical `intContainer`. The `Zero` morphism
    for a slice is `nil`.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个具有两种方法`Append`和`Zero`的接口。我们将我们的整数包装在`intContainer`中。`intContainer`是一个结构体，有一个整数字段`ints`。我们的`Append`方法将给定的整数切片附加到它正在构建的`ints`切片中，该切片存储在神奇的`intContainer`中。切片的`Zero`态射是`nil`。
- en: 'Here is the content of `src/monoid/int_monoid.go`:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`src/monoid/int_monoid.go`的内容：
- en: '[PRE104]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: That is just about the same logic as the Name monoid, except for that `Reduce`
    method. The `Reduce` method will allow us to combine all of our ints with our
    binary operator, addition, and arrive at a sum of all ints in the `intMonoid`
    container.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 这与名字幂等性的逻辑几乎相同，只是`Reduce`方法不同。`Reduce`方法将允许我们使用我们的二进制运算符，加法，将所有整数与我们的`intMonoid`容器中的所有整数相结合，并得到一个总和。
- en: 'The contents of `main.go` are as follows:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go`的内容如下：'
- en: '[PRE105]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We call the same list of methods we did for our `nameMonoid` and get correct
    results. The interesting line is the last one, where we chain our Appends and
    then call Reduce to sum up our ints:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了与`nameMonoid`相同的方法列表，并获得了正确的结果。有趣的一行是最后一行，我们在其中链式调用我们的附加方法，然后调用Reduce来总结我们的整数：
- en: '![](img/4e8a85ac-c638-49da-a812-1693649b8ac4.png)'
  id: totrans-673
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e8a85ac-c638-49da-a812-1693649b8ac4.png)'
- en: Int slice monoid terminal session
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: Int切片幂等性终端会话
- en: Lineitem slice monoid
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 行项目切片幂等性
- en: Let's see what we can do with a slice of line items.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以用一些行项目做些什么。
- en: 'First, we define an interface that has three methods, `Append`, `Zero`, and
    `Reduce.` We wrap our line items in the `lineitemContainer.` Our `lineitemContainer`
    is a struct with three fields that correspond to our invoice''s line items:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个具有三种方法`Append`，`Zero`和`Reduce`的接口。我们将我们的行项目包装在`lineitemContainer`中。我们的`lineitemContainer`是一个结构体，有三个字段对应于我们发票的行项目：
- en: '[PRE106]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Our `Append` method appends the given line item to the slice of line items it's
    building up that lives in the magical `lineitemContainer`.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Append`方法将给定的行项目附加到正在构建的行项目切片中，该切片存储在神奇的`lineitemContainer`中。
- en: The `Zero` morphism for a slice is `nil`.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的`Zero`态射是`nil`。
- en: 'The `src/monoid/lineitem_monoid.go` file will have the following code:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/monoid/lineitem_monoid.go`文件将包含以下代码：'
- en: '[PRE107]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: That is just about the same logic as the `Int` slice monoid, except for that
    `Reduce` method. The `Reduce` method will allow us to combine all of our line
    item fields with our binary operator, addition, and arrive at a sum total of all
    line item entries in the `lineitemMonoid` container.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`Int`切片幂等性的逻辑几乎相同，只是`Reduce`方法不同。`Reduce`方法将允许我们使用我们的二进制运算符，加法，将所有行项目字段与我们的`lineitemMonoid`容器中的所有行项目相结合，并得到一个总和。
- en: 'The `main.go` file will have the following code:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go`文件将包含以下代码：'
- en: '[PRE108]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: That's the same stuff we verified with the other monoids. Our feeder value,
    line items, is a slice of three line item tuples. Verify that the math of the
    `Reduce` works.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们验证其他幂等性的内容相同。我们的输入值，行项目，是一个包含三个行项目元组的切片。验证`Reduce`的数学是否正确。
- en: Int slice monoid terminal session
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Int切片幂等性终端会话
- en: 'Looking at the last line of output, we can see that we have called our `Reduce`
    function to sum our totals (`totalQuantity`, `totalPrice`, and `totalListPrice`):'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 看着输出的最后一行，我们可以看到我们已经调用了我们的`Reduce`函数来求和我们的总数（`totalQuantity`，`totalPrice`和`totalListPrice`）：
- en: '![](img/43b2d198-4888-4d14-b678-1d996b294807.png)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43b2d198-4888-4d14-b678-1d996b294807.png)'
- en: For a quick manual verification, let's look at `totalQuantity`--*1+2+5+1+2+5+1+2+5
    = 24*. Looks good!
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速手动验证，让我们看一下`totalQuantity`--*1+2+5+1+2+5+1+2+5 = 24*。看起来不错！
- en: Summary
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use tooling to solve issues that arise in
    Go because of its lack of support for generics. We were able to use this tooling
    to generate underscore like features in our Go code by starting with properly
    defined base types. With no more worries about potential generics support slowing
    down our runtime executables (as is the case with Java), we jumped for joy with
    an unexpected productivity boost.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学会了如何使用工具来解决Go语言中由于其不支持泛型而引起的问题。我们能够使用这些工具来通过从正确定义的基本类型开始，在我们的Go代码中生成类似下划线的特性。不再担心潜在的泛型支持会减慢我们的运行时可执行文件（就像Java一样），我们因意外的生产力提升而欢欣鼓舞。
- en: We continued forward into the land of pure FP, where we tackled the concept
    of function composition. With `g.f(x) == g(f(x))` in our tool belt, we studied
    functors and learned how to transform lists of items. We chained our maps and
    even learned how attorneys can use the forgetful functor to win cases in court
    for their clients.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续前进进入纯函数式编程的领域，我们解决了函数组合的概念。有了`g.f(x) == g(f(x))`在我们的工具箱中，我们研究了函子，并学会了如何转换项目列表。我们链接了我们的映射，甚至学会了律师如何使用遗忘函子为他们的客户在法庭上赢得案件。
- en: We wrapped up the chapter with monoids. We not only learned the algebraic laws
    of monoids, but we implemented them. We chained `Append` methods and even wrote
    a couple of reductions.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用单子结束了这一章。我们不仅学习了单子的代数定律，还实现了它们。我们链接了`Append`方法，甚至写了一些规约。
- en: In the next chapter, we'll continue our on our path towards pure enlightenment,
    and maintain our quest for simpler code and improved error handling.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续走向纯粹的启蒙之路，保持对更简单的代码和改进的错误处理的追求。
