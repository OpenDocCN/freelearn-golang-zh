["```go\nstep := Get(lineBase64)\nstep = Next(step, Base64ToBytes)\nstep = Next(step, BytesToData)\nstep = Next(step, TimestampData)\nstep = Next(step, DataToJson)\n```", "```go\nFilter(ByDomestic()).Map(Upgrade()).Reduce(JsonReducer())\n```", "```go\nloveGo :: IO Bool\n loveGo =\n do putStrLn \"Do you love Go? (yes/no)\"\n inpStr <- getLine\n return ((inpStr) == \"yes\")\n```", "```go\naddop = \"+\" &#124; \"-\".\ndigit = \"0\" &#124; \"1\" &#124; ... &#124; \"8\" &#124; \"9\".\nexpr = term { addop term }.\nfactor = \"(\" expr \")\" &#124; number.\nmulop = \"*\".\nnumber = [ \"-\" ] digit { digit }.\nterm = factor { mulop factor }.\n```", "```go\nghci> 1+2\n 3\n```", "```go\nclass Monad m where\n return :: a -> m a \n (>>=) :: m a -> (a -> m b) -> m b\n```", "```go\nmain.hs:\n\nmodule Main (main) where\n import Lib\n main :: IO ()\n main = do\n putStrLn \"Enter your first name:\" >>\n getLine >>=\n (\\yourName -> putStrLn $ \"Hello, \" ++ yourName)\n```", "```go\n*Main Lib> main\n Enter your first name:\n CocoPuff\n Hello,\nCocoPuff\n```", "```go\n(>>=) :: Monad m => m a -> (a -> m b) -> m b\n```", "```go\n*Main Lib> putStr \"Hello, \" >> putStrLn \"CocoPuff\"\n Hello, CocoPuff\n```", "```go\n(>>) :: Monad m => m a -> m b -> m\n```", "```go\nresults <- forM items $ \\item -> do\n    -- A big do-block using `item`.\nforM :: (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)\n```", "```go\nforever :: Applicative f => f a -> f b\n```", "```go\nmapM :: (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)\n```", "```go\nsequence :: (Monad m, Traversable t) => t (m a) -> m (t a)\n```", "```go\nvoid :: Functor f => f a -> f ()\n```", "```go\n(=<<) :: Monad m => (a -> m b) -> m a -> m b\n```", "```go\n(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n```", "```go\n(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c\n```", "```go\nfilterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]\n```", "```go\nfoldM  :: (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b\n```", "```go\n> join [[[1]]]\n [[1]]\n\n > join [[1]]\n [1]\njoin :: Monad m => m (m a) -> m a\n```", "```go\n> msum [Nothing, Nothing, Just \"A\", Just \"B\"]\n Just \"A\"\n\n> msum [[],[1,2],[],[3]]\n [1,2,3]\nmsum :: (MonadPlus m, Foldable t) => t (m a) -> m a\n```", "```go\nreplicateM :: Applicative m => Int -> m a -> m [a]\n```", "```go\nzipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]\n```", "```go\n4-purely-functional/ch10-monads/01_car_steps/data/cars.base64\neyJjYXIiOnsidmluIjoiREc1NDVIRzQ5NDU5WiIsIm1ha2UiOiJUb3lvdGEiLCJtb2RlbCI6IkhpZ2hsYW5kZXIiLCJvcHRpb25zIjp7Im9wdGlvbl8xIjoiSGVhdGVkIFNlYXRzIiwib3B0aW9uXzIiOiJQb3dlciBTdGVlcmluZyIsIm9wdGlvbl8zIjoiR1BTIn19fQ0K\neyJjYXIiOnsidmluIjoiMzQ4NTQzOTg1QVpERCIsIm1ha2UiOiJMZXh1cyIsIm1vZGVsIjoiSVMgMjUwIiwib3B0aW9ucyI6eyJvcHRpb25fMSI6IlN0aWNrIFNoaWZ0Iiwib3B0aW9uXzIiOiJNb29uIFJvb2YiLCJvcHRpb25fMyI6IkxlYXRoZXIifX19DQo=\neyJjYXIiOnsidmluIjoiTUZORkg2NkZCWlE5OSIsIm1ha2UiOiJIb25kYSIsIm1vZGVsIjoiQWNjb3JkIiwib3B0aW9ucyI6eyJvcHRpb25fMSI6IkFsbG95IFdoZWVscyIsIm9wdGlvbl8yIjoiUG93ZXIgU3RlZXJpbmcifX19\n```", "```go\n{\n  \"car\": {\n    \"vin\": \"MFNFH66FBZQ99\",\n    \"make\": \"Honda\",\n    \"model\": \"Accord\",\n    \"options\": {\n      \"option_1\": \"GPS\",\n      \"option_2\": \"Alloy Wheels\"\n }\n  },\n  \"timestamp\": \"20171030003135\"\n}\n```", "```go\npackage main\n\nimport (\n   \"workflow\"\n . \"utils\"\n \"bufio\"\n \"os\"\n)\n\nfunc init() {\n   GetOptions()\n   InitLog(\"trace.log\", os.Stdout, os.Stdout, os.Stderr)\n   Info.Println(\"AppEnv:\", Config.AppEnv)\n}\n\n```", "```go\n# Full path to the file containing the base64 car strings\ndata_filepath = \"./data/cars.base64\"\n\n# Runtime environment\napp_env = \"development\"\n\n# Level options: panic, error, info, debug\nlog_level = \"debug\"\n\n# The character(s) used to preface debug lines\nlog_debug_chars = \">>\"\n\n# Whether to include timestamps and log level on all log entries\nlog_verbose = true\n\n# Enable or disable logging of utils/TimeTrack() (For benchmarking/debugging)\nlog_timetrack = true\n\n# i18n translation file name, see github.com/nicksnyder/go-i18n\ni18n_filename = \"en-us.all.json\"\n```", "```go\n# Full path to the file containing the base64 car strings\ndata_filepath = \"./data/cars.base64\"\n```", "```go\nfunc main() {\n   carCntr := 0\n if file, err := os.Open(Config.DataFilepath); err == nil {\n```", "```go\n// NewScanner returns a new Scanner to read from r.\n// The split function defaults to ScanLines.\nfunc NewScanner(r io.Reader) *Scanner {\n   return &Scanner{\n      r:            r,\n      split:        ScanLines,\n      maxTokenSize: MaxScanTokenSize,\n   }\n}\n```", "```go\ntype Reader interface {\n   Read(p []byte) (n int, err error)\n}\n```", "```go\n   defer file.Close()\nInfo.Println(\"----\")\n   scanner := bufio.NewScanner(file)\n   for scanner.Scan() {\n       carCntr += 1\n Info.Println(\"Processing car #\", carCntr)\n       line :=  scanner.Text()\n       Info.Println(\"IN :\", line)\n```", "```go\nProcessing car # 1\nIN : eyJjYXIiOnsidmluIjoiREc1NDVIRzQ5NDU5WiIsIm1ha2UiOiJUb3lvdGEiLCJtb2RlbCI6IkhpZ2hsYW5kZXIiLCJvcHRpb25zIjp7Im9wdGlvbl8xIjoiSGVhdGVkIFNlYXRzIiwib3B0aW9uXzIiOiJQb3dlciBTdGVlcmluZyIsIm9wdGlvbl8zIjoiR1BTIn19fQ0K\n```", "```go\nerr, carJson := workflow.ProcessCar(line)\n\nif err == nil {\nInfo.Println(\"OUT:\", carJson)\n}\n```", "```go\nOUT: {\"car\":{\"vin\":\"DG545HG49459Z\",\"make\":\"Toyota\",\"model\":\"Highlander\",\"options\":{\"option_1\":\"Heated Seats\",\"option_2\":\"Power Steering\",\"option_3\":\"GPS\"}},\"timestamp\":\"20171030145251\"}\n```", "```go\n          Info.Println(\"----\")\n       }\n       if err = scanner.Err(); err != nil {\n         Error.Error(err)\n       }\n   } else {\n      Error.Error(err)\n   }\n}\n```", "```go\nAppEnv: development\n----\nProcessing car # 1\nIN : eyJjYXIiOnsidmluIjoiREc1NDVIRzQ5NDU5WiIsIm1ha2UiOiJUb3lvdGEiLCJtb2RlbCI6IkhpZ2hsYW5kZXIiLCJvcHRpb25zIjp7Im9wdGlvbl8xIjoiSGVhdGVkIFNlYXRzIiwib3B0aW9uXzIiOiJQb3dlciBTdGVlcmluZyIsIm9wdGlvbl8zIjoiR1BTIn19fQ0K\nOUT: {\"car\":{\"vin\":\"DG545HG49459Z\",\"make\":\"Toyota\",\"model\":\"Highlander\",\"options\":{\"option_1\":\"Heated Seats\",\"option_2\":\"Power Steering\",\"option_3\":\"GPS\"}},\"timestamp\":\"20171030145251\"}\n----\nProcessing car # 2\nIN : eyJjYXIiOnsidmluIjoiMzQ4NTQzOTg1QVpERCIsIm1ha2UiOiJMZXh1cyIsIm1vZGVsIjoiSVMgMjUwIiwib3B0aW9ucyI6eyJvcHRpb25fMSI6IlN0aWNrIFNoaWZ0Iiwib3B0aW9uXzIiOiJNb29uIFJvb2YiLCJvcHRpb25fMyI6IkxlYXRoZXIifX19DQo=\nOUT: {\"car\":{\"vin\":\"348543985AZDD\",\"make\":\"Lexus\",\"model\":\"IS 250\",\"options\":{\"option_1\":\"Stick Shift\",\"option_2\":\"Moon Roof\",\"option_3\":\"Leather\"}},\"timestamp\":\"20171030145251\"}\n----\nProcessing car # 3\nIN : eyJjYXIiOnsidmluIjoiTUZORkg2NkZCWlE5OSIsIm1ha2UiOiJIb25kYSIsIm1vZGVsIjoiQWNjb3JkIiwib3B0aW9ucyI6eyJvcHRpb25fMSI6IkFsbG95IFdoZWVscyIsIm9wdGlvbl8yIjoiUG93ZXIgU3RlZXJpbmcifX19\nOUT: {\"car\":{\"vin\":\"MFNFH66FBZQ99\",\"make\":\"Honda\",\"model\":\"Accord\",\"options\":{\"option_1\":\"Alloy Wheels\",\"option_2\":\"Power Steering\"}},\"timestamp\":\"20171030145251\"}\n----\n```", "```go\nerr, carJson := workflow.ProcessCar(line)\n```", "```go\n//src/workflow/process_car_steps.go\n\npackage workflow\n\nimport (\n   . \"utils\"\n)\n```", "```go\nfunc ProcessCar(lineBase64 string) (err error, carJson string) {\n   step := Get(lineBase64)\n   step = Next(step, Base64ToBytes)\n   step = Next(step, BytesToData)\n   step = Next(step, TimestampData)\n   step = Next(step, DataToJson)\n   json, err := step(nil)\n   if err != nil {\n      Error.Error(err)\n   } else {\n      carJson = json.(string)\n   }\n   return\n}\n```", "```go\npackage workflow\n\ntype Data interface{}\n```", "```go\nfunc Base64ToBytes(d Data) Monad {\n   dString := d.(string)\n   return func(e error) (Data, error) {\n      return base64.StdEncoding.DecodeString(dString)\n   }\n}\n```", "```go\nfunc Base64ToBytes(<T>) Monad {\n   return func(e error) (Data, error) {\n      return base64.StdEncoding.DecodeString(T)\n   }\n}\n```", "```go\ntype Monad func(error) (Data, error)\n```", "```go\nfunc Get(d Data) Monad {\n   return func(e error) (Data, error) {\n      return d, e\n   }\n}\n```", "```go\nstep := Get(lineBase64)\n```", "```go\nfunc Next(m Monad, f func(Data) Monad) Monad {\n   return func(e error) (Data, error) {\n      newData, newError := m(e)\n      if newError != nil {\n         return nil, newError\n      }\n      return f(newData)(newError)\n   }\n}\n```", "```go\nreturn func(e error) (Data, error) {\n```", "```go\nnewData, newError := m(e)\n```", "```go\nworkflow.Next (Base64ToBytes)\nworkflow.Next (BytesToData)\nworkflow.Next (TimestampData)\nworkflow.Next (DataToJson)\nworkflow.ProcessCar\nmain.main\n```", "```go\nfunc Get(d Data) Monad {\n   return func(e error) (Data, error) {\n      return d, e\n   }\n}\n```", "```go\nfunc Next(m Monad, f func(Data) Monad) Monad {\n   return func(e error) (Data, error) {\n      newData, newError := m(e)\n      if newError != nil {\n         return nil, newError\n      }\n      return f(newData)(newError)\n   }\n}\n```", "```go\nsomeFunction(val1)(val2)\n```", "```go\n(\\x. x+2) 3\n```", "```go\n(\\x.\\y. (x+y)/2) 3 5\n```", "```go\nforLoop := (\\x.x x) (\\x.x x)\n```", "```go\nrecursive f = f(recursive f)\n```", "```go\nY = \\f.(\\x.f(x x)) (\\x.f(x x)) \n```", "```go\nfunc ProcessCar(lineBase64 string) (err error, carJson string) {\n   step := Get(lineBase64)\n   step = Next(step, Base64ToBytes)\n   step = Next(step, BytesToData)\n   step = Next(step, TimestampData)\n   step = Next(step, DataToJson)\n   json, err := step(nil)\n   if err != nil {\n      Error.Error(err)\n   } else {\n      carJson = json.(string)\n   }\n   return\n}\n```", "```go\nif err != nil {\n   Error.Error(err)\n} else {\n   carJson = json.(string)\n}\n```", "```go\ntype Either struct {\n   Value interface{}\n   Error error\n}\n```", "```go\ntype SuccessOrFailure interface {\n   Success() bool\n   Failure() bool\n}\n```", "```go\ntype Either interface {\n   SuccessOrFailure\n   Succeeded() StringOption\n   Failed() ErrorOption\n}\n```", "```go\n4-purely-functional/ch10-monads/02_error_checker/alphabet.txt\nABCDEFGHIJKLMNOP\n```", "```go\nfunc main() {\n    file, err := os.Open(\"alphabet.txt\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    byteSlice := make([]byte, 2)\n    numBytesRead, err := io.ReadFull(file, byteSlice)\n    if err != nil {\n        log.Fatal(err)\n    }\n    logInfo(numBytesRead, byteSlice)\n\n    byteSlice = make([]byte, 2)\n    numBytesRead, err = io.ReadFull(file, byteSlice)\n    if err != nil {\n        log.Fatal(err)\n    }\n    logInfo(numBytesRead, byteSlice)\n\n    byteSlice = make([]byte, 2)\n    numBytesRead, err = io.ReadFull(file, byteSlice)\n    if err != nil {\n        log.Fatal(err)\n    }\n    logInfo(numBytesRead, byteSlice)\n\n```", "```go\ntype twoByteReader struct {\n    err      error\n    reader io.Reader\n}\n```", "```go\nfunc (tbr *twoByteReader) read() (numBytesRead int, byteSlice []byte)  {\n    if tbr.err != nil {\n        return\n }\n    byteSlice = make([]byte, 2)\n    numBytesRead, tbr.err = io.ReadFull(tbr.reader, byteSlice)\n    logInfo(numBytesRead, byteSlice)\n    return\n}\n```", "```go\n    tbr := &twoByteReader{reader: file}\n    byteSlice = make([]byte, 2)\n    tbr.read()\n    tbr.read()\n    tbr.read()\n}\n```", "```go\n{\n  \"car\": {\n    \"vin\": \"348543985AZDD\",\n    \"make\": \"Lexus\",\n    \"model\": \"IS 250\",\n    \"options\": {\n      \"option_1\": \"Stick Shift\",\n      \"option_2\": \"Moon Roof\",\n      \"option_3\": \"Leather\"\n }\n  },\n  \"timestamp\": \"20171030205535\"\n}\n```", "```go\nfunc fib(x int) int {\n    if x == 0 {\n        return 0\n } else if x <= 2 {\n        return 1\n } else {\n        return fib(x-2) + fib(x-1)\n    }\n}\n```", "```go\n//4-purely-functional/ch10-monads/03_y_combinator/main.go\n\npackage main\n\nimport \"fmt\"\n\ntype Func func(int) int\ntype FuncFunc func(Func) Func\ntype RecursiveFunc func (RecursiveFunc) Func\n```", "```go\nyCombo := yCombinator(fibFuncFunc)\n```", "```go\nfunc fib(x int) int {\n    if x == 0 {\n        return 0\n } else if x <= 2 {\n        return 1\n } else {\n        return fib(x-2) + fib(x-1)\n    }\n}\n```", "```go\npackage main\n\nimport (\n\"os\"\n \"text/template\"\n \"github.com/nicksnyder/go-i18n/i18n\"\n \"fmt\"\n)\n```", "```go\nvar funcMap = map[string]interface{}{\n\"T\": i18n.IdentityTfunc,\n}\n```", "```go\nvar tmplIllegalBase64Data = template.Must(template.New(\"\").Funcs(funcMap).Parse(`\n{{T \"illegal_base64_data\" .}}\n`))\nvar tmplUnexpectedEndOfJson= template.Must(template.New(\"\").Funcs(funcMap).Parse(`\n{{T \"unexpected_end_of_json_input\"}}\n`))\nvar tmplJsonUnsupportedValue = template.Must(template.New(\"\").Funcs(funcMap).Parse(`\n{{T \"json_unsupported_value\" .}}\n`))\n```", "```go\nfunc illegalBase64(T i18n.TranslateFunc, bytePos string) {\n   tmplIllegalBase64Data.Execute(os.Stdout, map[string]interface{}{\n      \"BytePos\":    bytePos,\n   })\n}\nfunc unexpectedEndOfJson(T i18n.TranslateFunc) {\n   tmplUnexpectedEndOfJson.Execute(os.Stdout, map[string]interface{}{\n   })\n}\nfunc jsonUnsupportedValue(T i18n.TranslateFunc, bytePos string) {\n   tmplJsonUnsupportedValue.Execute(os.Stdout, map[string]interface{}{\n      \"Val\":    bytePos,\n   })\n}\n```", "```go\nillegal base64 data at input byte 136\n```", "```go\nfunc main() {\n   i18n.MustLoadTranslationFile(\"en-us.all.json\")\n   i18n.MustLoadTranslationFile(\"de-de.all.json\")\n```", "```go\nfor _, locale := range []string{\"en-US\", \"de-DE\"} {\n   fmt.Println(\"\\nERROR MESSAGES FOR\", locale)\n   T, _ := i18n.Tfunc(locale)\n   tmplIllegalBase64Data.Funcs(map[string]interface{}{\n      \"T\": T,\n   })\n   tmplUnexpectedEndOfJson.Funcs(map[string]interface{}{\n      \"T\": T,\n   })\n   tmplJsonUnsupportedValue.Funcs(map[string]interface{}{\n      \"T\": T,\n   })\n\n    illegalBase64(T, \"136\")\n    unexpectedEndOfJson(T)\n    jsonUnsupportedValue(T, \"+Inf\")\n  }\n}\n\n```", "```go\nT, _ := i18n.Tfunc(locale)\n```", "```go\ntmplIllegalBase64Data.Funcs(map[string]interface{}{\n   \"T\": T,\n})\n```", "```go\nfunc (t *Template) Funcs(funcMap FuncMap) *Template {\n   t.init()\n   t.muFuncs.Lock()\n   defer t.muFuncs.Unlock()\n   addValueFuncs(t.execFuncs, funcMap)\n   addFuncs(t.parseFuncs, funcMap)\n   return t\n}\n```", "```go\nillegalBase64(T, \"136\")\nunexpectedEndOfJson(T)\njsonUnsupportedValue(T, \"+Inf\")\n```", "```go\nERROR MESSAGES FOR en-US\nillegal base64 data at input byte 136\nunexpected end of JSON input\njson: unsupported value: +Inf\n\nERROR MESSAGES FOR de-DE\nung\u00fcltige base64-Daten am Eingangsbyte 136\nunerwartetes Ende der JSON-Eingabe\njson: nicht unterst\u00fctzter Wert: +Inf\n```", "```go\n{\n  \"illegal_base64_data\": {\n    \"other\": \"illegal base64 data at input byte {{.BytePos}}\"\n },\n  \"json_unsupported_value\": {\n    \"other\": \"json: unsupported value: {{.Val}}\"\n },\n  \"unexpected_end_of_json_input\": {\n    \"other\": \"unexpected end of JSON input\"\n }\n}\n```", "```go\n{\n  \"illegal_base64_data\": {\n    \"other\": \"ung\u00fcltige base64-Daten am Eingangsbyte {{.BytePos}}\"\n },\n  \"json_unsupported_value\": {\n    \"other\": \"json: nicht unterst\u00fctzter Wert: {{.Val}}\"\n },\n  \"unexpected_end_of_json_input\": {\n    \"other\": \"unerwartetes Ende der JSON-Eingabe\"\n }\n}\n\n```", "```go\n//4-purely-functional/ch11-monads/05_typeclasss/src/typeclass/equals.go\npackage typeclass\n\nimport (\n   \"strconv\"\n)\ntype Equals interface {\n   Equals(Equals) bool\n}\n```", "```go\ntype Int int\n\nfunc (i Int) Equals(e Equals) bool {\n   intVal := int(i)\n   switch x := e.(type) {\n   case Int:\n      return intVal == int(x)\n   case String:\n      convertedInt, err := strconv.Atoi(string(x))\n      if err != nil {\n         return false\n }\n      return intVal == convertedInt\n   default:\n      return false\n }\n}\n```", "```go\ntype String string\n\nfunc (s String) Equals(e Equals) bool {\n   stringVal := string(s)\n   switch x := e.(type) {\n   case String:\n      return stringVal == string(x)\n   case Int:\n      return stringVal == strconv.Itoa(int(x))\n   default:\n      return false\n }\n}\n```", "```go\npackage main\n\nimport (\n    \"typeclass\"\n \"fmt\"\n)\n\nfunc main() {\n    int42 := typeclass.Int(42)\n    str42 := typeclass.String(\"42\")\n    fmt.Println(\"str42.Equals(int42):\", str42.Equals(int42))\n```", "```go\nstr42.Equals(int42): true\n```", "```go\n4-purely-functional/ch10-monads/05_typeclasss/src/typeclass/sum.go\npackage typeclass\n\ntype Sum interface {\n   Sum(Sum) int64\n}\n```", "```go\ntype Int32 int32\ntype Int64 int64\ntype Float32 float32\ntype IntSlice []int\n```", "```go\nfunc (i Int32) Sum(s Sum) int64 {\n   it := int64(i)\n   switch x := s.(type) {\n   case Int64:\n      return it + int64(x)\n   case Int32:\n      return it + int64(x)\n   case Float32:\n      return it + int64(x)\n   case IntSlice:\n      sum := int64(0)\n      for _, num := range x {\n         sum += int64(num)\n      }\n      return it + sum\n   default:\n      return 0\n }\n}\n```", "```go\nfunc (i Int64) Sum(s Sum) int64 {\n   it := int64(i)\n   switch x := s.(type) {\n   case Int64:\n      return it + int64(x)\n   case Int32:\n      return it + int64(x)\n   case Float32:\n      return it + int64(x)\n   case IntSlice:\n      sum := int64(0)\n      for _, num := range x {\n         sum += int64(num)\n      }\n      return it + sum\n   default:\n      return 0\n }\n}\n\nfunc (i Float32) Sum(s Sum) int64 {\n   it := int64(i)\n   switch x := s.(type) {\n   case Int64:\n      return it + int64(x)\n   case Int32:\n      return it + int64(x)\n   case Float32:\n      return it + int64(x)\n   case IntSlice:\n      sum := int64(0)\n      for _, num := range x {\n         sum += int64(num)\n      }\n      return it + sum\n   default:\n      return 0\n }\n}\n```", "```go\nfunc (i IntSlice) Sum(s Sum) int64 {\n   it := i\n   switch x := s.(type) {\n   case Int64:\n      sum := int64(0)\n      for _, num := range it {\n         sum += int64(num)\n      }\n      return int64(x) + sum\n   case Int32:\n      sum := int64(0)\n      for _, num := range it {\n         sum += int64(num)\n      }\n      return int64(x) + sum\n   case Float32:\n      sum := int64(0)\n      for _, num := range it {\n         sum += int64(num)\n      }\n      return int64(x) + sum\n   case IntSlice:\n      sum := int64(0)\n      for _, num := range it {\n         sum += int64(num)\n      }\n      for _, num := range x {\n         sum += int64(num)\n      }\n      return sum\n   default:\n      return 0\n }\n}\n```", "```go\n    int64One := typeclass.Int64(1)\n    int64Two := typeclass.Int64(2)\n    fmt.Println(\"int64Two.Sum(int64One):\", int64Two.Sum(int64One))\n\n    int32One := typeclass.Int32(1)\n    fmt.Println(\"int32One.Sum(int64One):\", int32One.Sum(int64One))\n\n    float32Five := typeclass.Float32(5)\n    fmt.Println(\"int32One.Sum(int64One):\", float32Five.Sum(int64One))\n\n    int64Slice123 := typeclass.IntSlice([]int{1, 2, 3})\n    int64Slice234 := typeclass.IntSlice([]int{2, 3, 4})\n    fmt.Println(\"int64Slice123.Sum(int64Slice234):\", int64Slice123.Sum(int64Slice234))\n}\n```", "```go\nint64Two.Sum(int64One): 3\nint32One.Sum(int64One): 2\nint32One.Sum(int64One): 6\nint64Slice123.Sum(int64Slice234): 15\n```", "```go\ntype Car struct {\n   Make, Model string\n   Price Dollars\n}\ntype Truck struct {\n   Make, Model string\n   BedSize int\n   Price Dollars\n}\nprice := func (c T) Dollars {\n   return c.Price\n}\n```", "```go\ntype CarSlice []Car\nfunc (rcv CarSlice) SumDollars(fn func(Car) Dollars) (result Dollars) {\n   for _, v := range rcv {\n      result += fn(v)\n   }\n   return\n}\n\ntype TruckSlice []Truck\nfunc (rcv TruckSlice) SumDollars(fn func(Truck) Dollars) (result Dollars) {\n   for _, v := range rcv {\n      result += fn(v)\n   }\n   return\n}\n```", "```go\nfmt.Println(\"Car Prices:\", cars.SumDollars(price))\nfmt.Println(\"Truck Prices:\", trucks.SumDollars(price))\n```", "```go\nfunc (rcv []T) SumDollars(fn func(T) Dollars) (result Dollars) {\n   for _, v := range rcv {\n      result += fn(v)\n   }\n   return\n}\n```", "```go\nfmt.Println(\"Car Prices:\", cars.SumDollars(<Car>))\nfmt.Println(\"Truck Prices:\", trucks.SumDollars(<Truck>))\n```", "```go\nif err != nil {\n return nil, err\n}\n```"]