["```go\ndef factorial(i int) int\n```", "```go\npublic static int[] wc<char> (IEnumerable<char> coll) {\n    int nl = 0, nw = 0, nc = 0;\n    bool state = false;\n    foreach(char c in coll) {\n        ++nc;\n        if(c == '\\n') ++nl;\n        if (c == ' ' || c == '\\n' || c == '\\t') {\n            state = false;\n        } else if (state == false) {\n            state = true;\n            ++nw;\n        }\n    }\n    int[] res = {nc, nw, nl};\n    return res;\n}\n```", "```go\nK[A => B => C] <*>\nK[A] <*> K[B]\nK[B => C] <*> K[B] == K[C]\n\n```", "```go\ncar, err := myCars.Find(\"Highlander\")\n```", "```go\nfunc (cars *Cars) Find(model string) (*Car, error) {\n  for _, car := range *cars {\n     if car.Model == model {\n        return &car, nil\n     }\n  }\n  return nil, errors.New(\"car not found\")\n}\n```", "```go\ntype Car struct {\n  Model string\n}\n\nfunc (cars *Cars) Add(car Car) {\n  myCars = append(myCars, car)\n}\n```", "```go\nselect User\nscatter memvar\nselect Customer\ngather memvar\n```", "```go\nPass 1 to to add2 expression to get: 3\nPass 2 to to add2 expression to get: 4\n```", "```go\nvar add = function (a) {\n  return function (b) {\n      return a + b;\n  };\n};\nadd2 = add(2);\n```", "```go\nconst add = a => b => a + b;\nadd2 = add(2);\n```", "```go\nadd = lambda {|a, b| a + b}\n```", "```go\nadd = -> a, b{a + b}\n```", "```go\n>> add.call(2, 1)\n=> 3\n```", "```go\nclass Make < ApplicationRecord\nend\n\nclass Car < ApplicationRecord\n    belongs_to :make\n    scope :by_make, -> (id) { where(:make_id => id) }\nend\n```", "```go\nMake.create({name: 'Lexus'})\n Make.create({name: 'Honda'})\n Car.create({make_id: 1, model: 'IS250'})\n Car.create({make_id: 2, model: 'Accord'})\n Car.create({make_id: 2, model: 'Highlander'})\n```", "```go\n>> ar.by_make(2)\nCar Load (1.2ms) SELECT \"cars\".* FROM \"cars\" WHERE \"cars\".\"make_id\" = $1\n+----+---------+------------+\n| id | make_id | model      |\n+----+---------+------------+\n| 2  | 2       | Accord     |\n| 3  | 2       | Highlander |\n+----+---------+------------+\n```", "```go\nadd2 = add.curry.call(2)\n```", "```go\n>> add2.call(1)\n=> 3\n```", "```go\n>> add.call(2, 1)\n```", "```go\n>> add2.call(1)\n```", "```go\ndef add(a, b)\n    a+b\nend\n```", "```go\n>> add(1,2)\n=> 3\n```", "```go\n>> add(1,Time.now)\nTypeError: Time can't be coerced into Integer\n```", "```go\nvar a = 5\na := 5\n```", "```go\na := 1.8\nb := math.Floor(a + 1)\nfmt.Println(\"b:\", reflect.TypeOf(b))\n```", "```go\nb: float64\n```", "```go\na := 1\nb := math.Floor(a + 1.8)\nprintln(b)\n```", "```go\nconstant 1.8 truncated to integer\ncannot use a + 1.8 (type int) as type float64 in argument to math.Floor\n```", "```go\n(\\a -> a + 2)\n```", "```go\na \u00d7 (b + c) = a \u00d7 b + a \u00d7 c\n(b + c) \u00d7 a = b \u00d7 a + c \u00d7 a\n```"]