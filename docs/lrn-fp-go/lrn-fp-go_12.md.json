["```go\nalias go-test='go test ./... 2>&1 | grep -v \"$(basename $(pwd))\\t\\[no test files\"'\n</span>alias go-test-bench='go test -bench=. ./... 2>&1 | grep -v \"$(basename $(pwd))\\t\\[no test files\"'\nalias glide-ignore-project-dirs=\"printf \\\"ignore:\\n$(find ./src -maxdepth 1 -type d | tail -n +2 | sed 's|./src\\/||' | sed -e 's/^/- \\.\\//')\\n\\\"\"\nalias mvglide='mkdir -p vendors && mv vendor/ vendors/src/ && export GOPATH=$(pwd)/vendors:$(pwd);echo \"vendor packages have been moved to $(pwd)/vendors and your GOPATH: $GOPATH\"'\nalias glide-update='if [ ! -z $(readlink `pwd`) ]; then export LINKED=true && pushd \"$(readlink `pwd`)\"; fi;rm -rf {vendor,vendors};rm glide.*;export GOPATH=$(pwd):$(pwd)/vendors && export GOBIN=$(pwd)/bin && glide init --non-interactive && glide-ignore-project-dirs >> glide.yaml && glide up && mvglide && if [ $LINKED==true ]; then popd;fi'\nalias prune-project=\"(rm -rf bin pkg vendors;rm glide.lock;rm -rf ./src/mypackage;sed -i -e '/mypackage/ s/^#*/\\/\\//' main.go) 2>/dev/null\"\nalias show-path='echo $PATH | tr \":\" \"\\n\"'\nalias prune-path='export PATH=\"$(echo $PATH | tr \":\" \"\\n\" | uniq | grep -v \"$(dirname $ORIG_DIR)\" | tr \"\\n\" \":\")\"; if [[ \"$PATH\" =~ ':'$ ]]; then export PATH=\"${PATH::-1}\";fi'\nalias find-imports='find . -type f -name \"*.go\" -exec grep -A3 \"import\" {} \\; -exec echo {} \\; -exec echo --- \\;'\nalias go-fmt='set -x;goimports -w main.go src/*;{ set +x; } 2>/dev/null'\n```", "```go\ntdml() {\n   if [ -z $1 ]; then LEVEL=2; else LEVEL=$1;fi\n tree -C -d -L $LEVEL\n}\nget-go-binary() {\n    GO_BINARY_URL=\"$1\"\n if [ -z $GO_BINARY_URL ]; then\n echo \"Missing GO_BINARY_URL. Usage: get-go-binary <GO_BINARY_URL> Example: get-go-binary github.com/nicksnyder/go-i18n/goi18n\"\n return\n fi\n TMP_DIR=\"tmp_dir_$RANDOM\"; mkdir \"$TMP_DIR\"; pushd \"$TMP_DIR\"; export GOPATH=\"$(pwd)\"; go get -u $GO_BINARY_URL; popd; rm -rf \"$TMP_DIR\"\n}\n```", "```go\ngo get --help\n...When checking out or updating a package, get looks for a branch or tag that matches the locally installed version of Go. The most important rule is that if the local installation is running version \"go1\", get\nsearches for a branch or tag named \"go1\". If no such version exists it retrieves the default branch of the package...\n```", "```go\nbrew search go\n```", "```go\n  ~/clients/packt/dev/fp-go/2-design-patterns/ch07-onion-arch/01_dependency-rule-good $ tree -C -d -L 2; find . -type f\n.\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 packagea\n    \u2514\u2500\u2500 packageb\n\n3 directories\n./.bash_exports\n./config.toml\n./glide.yaml\n./init\n./main.go\n./src/packagea/featurea.go\n./src/packageb/featureb.go\n```", "```go\n#!/bin/bash\n# Author : Lex Sheehan\n# Purpose: This script initializes a go project with glide dependency management\n# For details see: https://www.amazon.com/Learning-Functional-Programming-Lex-Sheehan-ebook/dp/B0725B8MYW\n# License: MIT, 2017 Lex Sheehan LLC\nMY_DEV_DIR=~/dev\nCURRENT_GO_VERSION=1.9.2\nUSES_TOML_CONFIG_YN=no\nLOCAL_BIN_DIR=/usr/local/bin/\n# ---------------------------------------------------------------\n# Verify variables above are correct. Do not modify lines below.\nif [ -L \"$(pwd)\" ]; then\n echo \"You must be in the real project directory to run this init script. You are currently in a linked directory\"\n echo \"Running: ln -l \\\"$(pwd)\\\"\"\n ls -l \"$(pwd)\"\n return\nfi\nCURRENT_GOVERSION=\"go$CURRENT_GO_VERSION\"\nORIG_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\nDEV_DIR=\"$MY_DEV_DIR/$(basename $ORIG_DIR)\"\nPROJECT_DIR_LINK=\"$MY_DEV_DIR/$(basename $ORIG_DIR)\"\nif [ -L \"$PROJECT_DIR_LINK\" ]; then\n rm \"$PROJECT_DIR_LINK\"\nfi\nif [ ! -d \"$MY_DEV_DIR\" ]; then\n mkdir \"$MY_DEV_DIR\"\nfi\n# Create link to project directory in MY_DEV_DIR\nset -x\nln -s \"$ORIG_DIR\" \"$PROJECT_DIR_LINK\"\n{ set +x; } 2>/dev/null\ncd \"$PROJECT_DIR_LINK\"\nexport GOPATH=$ORIG_DIR\nexport GOBIN=$ORIG_DIR/bin\nif [ -e \"$GOBIN\" ]; then\n rm \"$GOBIN/*\" 2>/dev/null\nelse\n mkdir \"$GOBIN\"\nfi\n#[ $(which \"$(basename $(pwd))\") ] && { echo \"An executable named $(basename $(pwd)) found on path here: $(which $(basename $(pwd))). Continue anyway? (yes/no)\"; read CONTINUE_YN; if [[ \"$CONTINUE_YN\" =~ ^(yes|y)$ ]]; then echo 'Okay, but when you run go-run it may run the pre-existing binary.'; else echo \"You might want to rename this project directory ($(basename $(pwd))) to a name that does not match a pre-existing binary name.\"; return; fi; } 2>/dev/null\nAPP_NAME=$(basename $(pwd))\nGOVERSION=$(go version)\necho \"Installed Go version: $GOVERSION\"\nif [[ $(type goenv) ]]; then\n # Attempt to automatically set desired/current go version. This requires goenv.\n . goenv \"$CURRENT_GO_VERSION\"\n echo \"GOVERSION: $GOVERSION\"\n echo \"CURRENT_GOVERSION: $CURRENT_GOVERSION\"\n if [ -z \"$GOVERSION\" ] || [[ \"$(echo $GOVERSION | awk '{print $3}')\" != \"$CURRENT_GOVERSION\" ]]; then\n echo \"Expected Go version $CURRENT_GOVERSION to be installed\"\n return\n fi\nelse\n if [ -z \"$GOVERSION\" ] || [[ \"$(echo $GOVERSION | awk '{print $3}')\" != \"$CURRENT_GOVERSION\" ]]; then\n echo \"Expected Go version $CURRENT_GOVERSION to be installed. Consider using github.com/l3x/goenv to manage your go runtimes.\"\n return\n fi\nfi\ncommand -v goimports >/dev/null 2>&1 || { echo >&2 \"Missing goimports. For details, see: https://github.com/bradfitz/goimports\"; return; }\ncommand -v glide >/dev/null 2>&1 || { echo >&2 \"Missing glide. For details, see: https://github.com/Masterminds/glide\"; return; }\nif [ ! -e ./src ]; then\n mkdir src\nfi\n\nif [ ! -e ./src/mypackage/ ]; then\n mkdir ./src/mypackage\nfi\n\nif [ ! -e ./src/mypackage/myname.go ]; then\n cat > ./src/mypackage/myname.go <<TEXT\npackage mypackage\n\nfunc MyName() string { return \"Alice\" }\nTEXT\nfi\n\nif [ ! -e ./main.go ]; then\n cat > ./main.go <<TEXT\npackage main\n\nimport (\n \"mypackage\"\n)\n\nfunc main() {\n println(\"hello from main.go\")\n println(mypackage.MyName() + \" says hi from mypackage\")\n}\nTEXT\nfi\n\nif [ ! -e ./.gitignore ]; then\n cat > ./.gitignore <<TEXT\n# Binaries for programs and plugins\n*.exe\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Project-local glide cache, RE: https://github.com/Masterminds/glide/issues/736\n.glide/\n\n# Temporary backup file created by sed in prune-project alias\nmain.go-e\nTEXT\nfi\n\nif [ \"${PATH/$GOBIN}\" == \"$PATH\" ] ; then\n export PATH=$PATH:$GOBIN\nfi\n\nif [[ \"$USES_TOML_CONFIG_YN\" =~ ^(yes|y)$ ]]; then\n if [ ! -e ./config.toml ]; then\n echo You were missing the config.toml configuration file... Creating bare config.toml file ...\n        echo -e \"# Runtime environment\\napp_env = \\\"development\\\"\" > config.toml\n fi\n ls -l config.toml\n    alias go-run=\"go install && $APP_NAME -config ./config.toml\"\nelse\n alias go-run=\"go install && $APP_NAME\"\nfi\nalias go-test='go test ./... 2>&1 | grep -v \"$(basename $(pwd))\\t\\[no test files\"'\nalias go-test-bench='go test -bench=. ./... 2>&1 | grep -v \"$(basename $(pwd))\\t\\[no test files\"'\nalias glide-ignore-project-dirs=\"printf \\\"ignore:\\n$(find ./src -maxdepth 1 -type d | tail -n +2 | sed 's|./src\\/||' | sed -e 's/^/- \\.\\//')\\n\\\"\"\nalias mvglide='mkdir -p vendors && mv vendor/ vendors/src/ && export GOPATH=$(pwd)/vendors:$(pwd);echo \"vendor packages have been moved to $(pwd)/vendors and your GOPATH: $GOPATH\"'\nalias glide-update='if [ ! -z $(readlink `pwd`) ]; then export LINKED=true && pushd \"$(readlink `pwd`)\"; fi;rm -rf {vendor,vendors};rm glide.*;export GOPATH=$(pwd):$(pwd)/vendors && export GOBIN=$(pwd)/bin && glide init --non-interactive && glide-ignore-project-dirs >> glide.yaml && glide up && mvglide && if [ $LINKED==true ]; then popd;fi'\nalias prune-project=\"(rm -rf bin pkg vendors;rm glide.lock;rm -rf ./src/mypackage;sed -i -e '/mypackage/ s/^#*/\\/\\//' main.go) 2>/dev/null\"\nalias show-path='echo $PATH | tr \":\" \"\\n\"'\nalias prune-path='export PATH=\"$(echo $PATH | tr \":\" \"\\n\" | uniq | grep -v \"$(dirname $ORIG_DIR)\" | tr \"\\n\" \":\")\"; if [[ \"$PATH\" =~ ':'$ ]]; then export PATH=\"${PATH::-1}\";fi'\nalias find-imports='find . -type f -name \"*.go\" -exec grep -A3 \"import\" {} \\; -exec echo {} \\; -exec echo --- \\;'\nalias go-fmt='set -x;goimports -w main.go src/*;{ set +x; } 2>/dev/null'\ntdml() {\n   if [ -z $1 ]; then LEVEL=2; else LEVEL=$1;fi\n tree -C -d -L $LEVEL\n}\nget-go-binary() {\n    GO_BINARY_URL=\"$1\"\n if [ -z $GO_BINARY_URL ]; then\n echo \"Missing GO_BINARY_URL. Usage: get-go-binary <GO_BINARY_URL> Example: get-go-binary github.com/nicksnyder/go-i18n/goi18n\"\n return\n fi\n TMP_DIR=\"tmp_dir_$RANDOM\"; mkdir \"$TMP_DIR\"; pushd \"$TMP_DIR\"; export GOPATH=\"$(pwd)\"; go get -u $GO_BINARY_URL; popd; rm -rf \"$TMP_DIR\"\n}\necho You should only need to run this init script once.\necho Add Go source code files under the src directory.\necho After updating dependencies, i.e., adding a new import statement, run:  glide-update\necho To build and run your app, run:  go-run\n```", "```go\nMY_DEV_DIR=~/dev\nCURRENT_GO_VERSION=1.9.2\nUSES_TOML_CONFIG_YN=no\nLOCAL_BIN_DIR=/usr/local/bin/\n```", "```go\npackage packagea\n\nimport (\n   b \"packageb\"\n \"fmt\"\n)\n\nfunc Atask() {\n   fmt.Println(\"A\")\n   b.Btask()\n}\n```", "```go\npackage packageb\n\nimport (\n   \"log\"\n)\n\nfunc Btask() {\n   log.Println(\"B\")\n}\n```", "```go\npackage packagea\n\nimport (\n   b \"packageb\"\n \"fmt\"\n u \"github.com/go-goodies/go_utils\"\n)\n\nfunc Atask() {\n   fmt.Println(u.PadLeft(\"A\", 3))\n   b.Btask()\n}\n```", "```go\n                                /\\\n           /\\    /\\ /\\   /\\    /  \\\n/\\/\\/\\, /\\/  \\, /  \\/\\, /  \\, /    \\\n```", "```go\n()()(), ()(()), (())(), (()()), ((()))\n```", "```go\nif b !=0 {\n   result := a/b\n} else {\n   result := NaN\n}\nreturn result\n```", "```go\n(if (b != 0) ( / a b) (NaN) )\n```"]