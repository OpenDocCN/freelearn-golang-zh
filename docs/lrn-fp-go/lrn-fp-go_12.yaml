- en: Miscellaneous Information and How-Tos
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他信息和操作指南
- en: 'This appendix has four sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录有四个部分：
- en: How to build and run Go projects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建和运行Go项目
- en: How to propose changes to Go
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何提出对Go的更改
- en: FP Resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FP资源
- en: Minggatu-Catalan Number
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minggatu-Catalan数
- en: How to build and run Go projects
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何构建和运行Go项目
- en: There are various ways to build and run Go applications. In this section, I'll
    show you what I used to build the example Go projects for this book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种方法可以构建和运行Go应用程序。在本节中，我将向您展示我用来构建本书示例Go项目的方法。
- en: TL;DR
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TL;DR
- en: Use the `cd` command to direct to your project root directory. Run `. init`
    once.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cd`命令转到您的项目根目录。运行一次`. init`。
- en: Ready to run your app? Did you change a (non-standard library) import statement?
    If so, run `glide-update`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 准备运行您的应用程序了吗？您更改了（非标准库）导入语句吗？如果是这样，请运行`glide-update`。
- en: To run your app, execute `go-run`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行您的应用程序，请执行`go-run`。
- en: Development workflow
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发工作流程
- en: 'This is what our development workflow looks like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发工作流程如下：
- en: '![](img/99611dc3-7dc1-42c4-93c3-1dc7baaa676b.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99611dc3-7dc1-42c4-93c3-1dc7baaa676b.png)'
- en: We put `cd` into our project source code root directory and run `init`. Then,
    we updated code, run the `glide-update` and `go-run` commands, and repeat until
    done. Note that if we only added imports for packages from Go's standard library,
    we won't need to run the `glide-update` command, though running the `glide-update` command
    won't hurt.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`cd`到我们的项目源代码根目录，并运行`init`。然后，我们更新代码，运行`glide-update`和`go-run`命令，并重复直到完成。请注意，如果我们只添加了来自Go标准库的包的导入，我们将不需要运行`glide-update`命令，尽管运行`glide-update`命令也不会有害。
- en: Dot init features and benefits
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dot init的功能和好处
- en: 'The *dot init* solution will do the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*dot init*解决方案将执行以下操作：'
- en: Create a link to this project root directory in your `MY_DEV_DIR` directory.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`MY_DEV_DIR`目录中创建一个指向此项目根目录的链接。
- en: Verify that you are running the correct version of Go.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您是否正在运行正确的Go版本。
- en: Verify that you have a `src` directory (it will create one if you don't have
    one).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您是否有一个`src`目录（如果没有，它将创建一个）。
- en: Simplify references to project-local packages.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化对项目本地包的引用。
- en: Verify that you have a `toml` config file (if you set `USES_TOML_CONFIG_YN`
    to yes).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您是否有一个`toml`配置文件（如果将`USES_TOML_CONFIG_YN`设置为yes）。
- en: Create aliases for your convenience.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的方便创建别名。
- en: Verify that you have glide installed.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您是否已安装glide。
- en: In *step 1*, it's nice to have one place to go `MY_DEV_DIR`, for example, `~/myprojects`
    to see all the projects I've worked on. I can sort by date and easily delete the
    links to inactive projects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，有一个地方可以方便地前往`MY_DEV_DIR`，例如`~/myprojects`，以查看我曾经工作过的所有项目。我可以按日期排序，并轻松删除不活跃项目的链接。
- en: Use *step 2* to avoid messing with GOPATH, GOROOT, or GOBIN.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*步骤2*来避免干扰GOPATH、GOROOT或GOBIN。
- en: As explained in *step 3*, the `src` directory is where we put our project-local
    package source files. We also have a file (typically named `main.go`) in our project
    root directory with the `main()` function in the main package.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如*步骤3*中所解释的，`src`目录是我们放置项目本地包源文件的地方。我们的项目根目录中还有一个文件（通常命名为`main.go`），其中包含主包中的`main()`函数。
- en: Perform *step 4* so that we no longer need to include the full GitHub repository
    path for project-local packages!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 执行*步骤4*，这样我们就不再需要包含项目本地包的完整GitHub存储库路径了！
- en: Instead of `".github.comlearn-fp-go/2-design-patterns/ch05-decoration/02_decorator/decorator"`,
    we simply use `". decorator"`. Note that if you just really do not want to use
    *dot init*, you'll need to go through the source code and replace all of the simple
    project-local package references with the full repository path references and
    move the code. You may also need to move the code out of the project-local package's `src`
    directory up a level; it won't conflict with your global GOPATH's `src` directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用`".github.comlearn-fp-go/2-design-patterns/ch05-decoration/02_decorator/decorator"`，而是简单地使用`".
    decorator"`。请注意，如果您真的不想使用*dot init*，您需要浏览源代码，并用完整的存储库路径引用替换所有简单的项目本地包引用，并移动代码。您可能还需要将代码移出项目本地包的`src`目录，这样它就不会与全局GOPATH的`src`目录冲突。
- en: In *step 5*, the `toml` config file ([https://github.com/BurntSushi/toml](https://github.com/BurntSushi/toml))
    is the default config file solution. The `.init` file includes the `toml` config
    file runtime flag automatically (as long as you set this in the `init` script: `USES_TOML_CONFIG_YN=yes`).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，`toml`配置文件（[https://github.com/BurntSushi/toml](https://github.com/BurntSushi/toml)）是默认的配置文件解决方案。`.init`文件会自动包含`toml`配置文件运行时标志（只要您在`init`脚本中设置了这个：`USES_TOML_CONFIG_YN=yes`）。
- en: Aliases available
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可用的别名
- en: 'Here''re the available alias commands:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可用的别名命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In summary, dot init will allow you to update your dependencies with one command
    (`glide-update`) and compile and run your application with one other command (`go-run`).
    All you have to do to start using it is make sure that the init script exists
    in your project root directory and run `. init` one time. The `.init` initialization reduces
    the code you have to write and maintain, and it keeps building and running your
    Go app as simply as possible.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`dot init`将允许您使用一个命令（`glide-update`）更新您的依赖关系，并使用另一个命令（`go-run`）编译和运行您的应用程序。您只需确保init脚本存在于您的项目根目录中，并运行一次`.
    init`。`.init`初始化减少了您需要编写和维护的代码，并尽可能简单地构建和运行您的Go应用程序。
- en: Functions available
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可用的函数
- en: 'Here''re the functions available:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可用的函数：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Motivation for using goenv
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用goenv的动机
- en: If you always use the latest version of Go or if do your development work on
    a non-Macintosh computer, you can skip this section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您始终使用最新版本的Go，或者在非Macintosh计算机上进行开发工作，您可以跳过本节。
- en: If we need to support multiple go runtimes, we put our Go project code in different
    directories. To help us manage our go runtime environments, let's look at a little
    utility script named `goenv` and the init script found in our project root directories.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要支持多个go运行时，我们将把我们的Go项目代码放在不同的目录中。为了帮助我们管理我们的go运行时环境，让我们看一下一个名为`goenv`的小型实用脚本和我们项目根目录中的init脚本。
- en: This section assumes that you are using a Mac computer. Manage your Go runtime
    environment with `goenv`; visit: [https://github.com/l3x/goenv](https://github.com/l3x/goenv). For
    more information on the `go` command, visit: [https://golang.org/cmd/go](https://golang.org/cmd/go)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本节假设您使用的是Mac电脑。使用`goenv`来管理您的Go运行时环境；访问：[https://github.com/l3x/goenv](https://github.com/l3x/goenv)。有关`go`命令的更多信息，请访问：[https://golang.org/cmd/go](https://golang.org/cmd/go)
- en: Motivation for using the init script
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用init脚本的动机
- en: 'The `init` script and the alias commands that it provides has one purpose:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`脚本及其提供的别名命令只有一个目的：'
- en: '*To make building and running our Go apps easy.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*使构建和运行我们的Go应用程序变得简单。*'
- en: Managing dependencies (third-party packages) can be a pain. Import statements
    can be too long for our local source files. Always keeping our `GOPATH`, `GOBIN`,
    `PATH`, and so on up to date can also be a pain.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 管理依赖关系（第三方包）可能很麻烦。导入语句可能对我们的本地源文件来说太长了。始终保持我们的`GOPATH`，`GOBIN`，`PATH`等等是一件麻烦的事情。
- en: I created the init script to simplify the process of building and running the
    example apps in this book. I found it so useful that I use it for other projects
    too. I hope it works well for you, too.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了init脚本来简化构建和运行本书中示例应用的过程。我发现它非常有用，所以我也在其他项目中使用它。希望它对你也有用。
- en: Ways to manage Go dependencies
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理Go依赖的方法
- en: There are over a dozen ways to manage Go dependencies. We can do so with the
    tools that we will discuss in this section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有超过十种方法来管理Go的依赖关系。我们可以使用本节中将讨论的工具来实现。
- en: The go get tool
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: go get工具
- en: 'When I started developing in Go, I used the `go get` tool. Here''s a snippet
    from its help message:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始使用Go进行开发时，我使用了`go get`工具。以下是它的帮助信息中的一部分：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I soon learned that it would get the most recent version of all packages. Not
    what I wanted.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我很快就了解到它会获取所有包的最新版本。这不是我想要的。
- en: I was looking for something more like Ruby's **Gemfile** or the **npm** package
    manager where I could specify the specific version of each package and create
    a `.lock` file to keep it from changing every time I run my build tool.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在寻找更像Ruby的**Gemfile**或**npm**包管理器的东西，我可以指定每个包的特定版本，并创建一个`.lock`文件来防止每次运行构建工具时都发生变化。
- en: The Godep tool
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Godep工具
- en: I used Godep for a while. And it worked fine, but it was a hassle to use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经使用Godep。它运行得很好，但使用起来很麻烦。
- en: Godep created a `Godeps.json` file in a Godeps directory in the root of my project.
    Godep then created copies of all of my third-party packages into the Godeps directory
    at the root of my project. I typically checked those third-party packages into
    version control with the rest of my code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Godep在我的项目的根目录的Godeps目录中创建了一个`Godeps.json`文件。然后，Godep将所有第三方包的副本创建到了我的项目根目录的Godeps目录中。我通常会将这些第三方包与我的其他代码一起检入版本控制。
- en: Godep requires a number of steps that I find quirky. For example, to update
    a project's dependency, you will have to update it in your `GOPATH` via the `go
    get -u github.com/another-thirdparty/package` command, and then copy it from my
    `$GOPATH` to my project's Godeps directory via the `godep save github.com/another-thirdparty/package`
    command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Godep需要进行一些我认为古怪的步骤。例如，要更新项目的依赖关系，您必须通过`go get -u github.com/another-thirdparty/package`命令在您的`GOPATH`中更新它，然后通过`godep
    save github.com/another-thirdparty/package`命令将其从我的`$GOPATH`复制到我的项目的Godeps目录中。
- en: In my humble opinion, having to modify a dependency using `$GOPATH` is quirky.
    Modifying dependencies of multiple projects using different versions of dependencies
    concurrently is even more quirky (quirky == more user errors).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，使用`$GOPATH`修改依赖关系是古怪的。同时使用不同版本的依赖关系修改多个项目的依赖关系更加古怪（古怪==更多用户错误）。
- en: I like simple, not quirky.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢简单，不喜欢古怪。
- en: Vendoring in Go
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Go中的Vendoring
- en: Vendoring in Go was introduced in Go 1.5\. It allows Go apps to fetch dependencies
    not only from `$GOPATH/src`, but also from a child folder named vendor, located
    at the root your project. Previously, you had to save your third-party packages
    in the globally shared `$GOPATH` path. Now, you can place your dependencies into
    your project's vendor folder.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的Vendoring是在Go 1.5中引入的。它允许Go应用程序不仅从`$GOPATH/src`获取依赖项，还可以从项目根目录下名为vendor的子文件夹中获取依赖项。以前，您必须将第三方包保存在全局共享的`$GOPATH`路径中。现在，您可以将依赖项放入项目的vendor文件夹中。
- en: I was still looking for a way to pin down the version of each package or to
    specify a `MAJOR.MINOR` version and have my package manager grab the latest `MAJOR.MINOR.PATCH`
    version.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍在寻找一种方法来固定每个包的版本，或者指定一个`MAJOR.MINOR`版本，并让我的包管理器获取最新的`MAJOR.MINOR.PATCH`版本。
- en: For more information, visit [https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo/edit](https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo/edit)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请访问[https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo/edit](https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo/edit)
- en: Glide - the modern package manager
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Glide-现代包管理器
- en: I found Glide and appreciated its features and the fact that it's under active
    development/improvement. It reminded me of Ruby's Gem package management. It's
    great, but still a lot to remember.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现了Glide，并欣赏它的功能以及它正在积极开发/改进的事实。它让我想起了Ruby的Gem包管理。这很棒，但仍然有很多要记住。
- en: Glide references
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Glide参考
- en: '[https://github.com/Masterminds/glide](https://github.com/Masterminds/glide)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Masterminds/glide](https://github.com/Masterminds/glide)'
- en: '[https://glide.sh/](https://glide.sh/)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://glide.sh/](https://glide.sh/)'
- en: '[https://glide.readthedocs.io/en/latest/getting-started/](https://glide.readthedocs.io/en/latest/getting-started/)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://glide.readthedocs.io/en/latest/getting-started/](https://glide.readthedocs.io/en/latest/getting-started/)'
- en: '[https://glide.readthedocs.io/en/latest/commands/](https://glide.readthedocs.io/en/latest/commands/)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://glide.readthedocs.io/en/latest/commands/](https://glide.readthedocs.io/en/latest/commands/)'
- en: I just wanted to run one command to build my code and one command to run my
    code. I wanted something simple, so I created the init script and its aliased
    commands to wrap the functionality of Glide.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我只想运行一个命令来构建我的代码，运行一个命令来运行我的代码。我想要简单的东西，所以我创建了init脚本及其别名命令来包装Glide的功能。
- en: I find the `init`, `glide-update`, and `go-run` set of commands super easy to
    use. Hopefully, you will too. Granted, when you use it to build very large projects,
    you will initially need to deal with import/dependency errors, as with any dependency
    management tool, but I find Glide to be the best one out there. So, what you see
    in this appendix is a simple set of build and run commands that's built on top
    of the full featured build tool, Glide.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现`init`，`glide-update`和`go-run`一系列命令非常容易使用。希望您也是如此。当您用它构建非常大的项目时，最初可能需要处理导入/依赖错误，就像任何依赖管理工具一样，但我发现Glide是最好的。因此，在本附录中，您看到的是一组简单的构建和运行命令，它是基于功能齐全的构建工具Glide构建的。
- en: Each dot init step in detail
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个点init步骤的详细信息
- en: First, use the `cd` command to direct to the project directory with our source
    code. Let's look at the `01_dependency-rule-good` source code. This happens to
    be the first code project from [Chapter 7](../Text/Ch07.xhtml), *Functional Parameters*.
    Next, let's run `goenv info`, which will inform us about our Go environment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`cd`命令将项目目录切换到我们的源代码。让我们看看`01_dependency-rule-good`源代码。这恰好是来自[第7章](../Text/Ch07.xhtml)
    *Functional Parameters*的第一个代码项目。接下来，让我们运行`goenv info`，它将告诉我们关于我们的Go环境的信息。
- en: The cd command to project root directory
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: cd命令到项目根目录
- en: 'Before using **dot init**, you might see invalid settings for `GOROOT`, `GOPATH`,
    and `GOBIN`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用**dot init**之前，您可能会看到`GOROOT`，`GOPATH`和`GOBIN`的无效设置：
- en: '![](img/41c404e7-cc83-4bbc-9dc8-f4d01ee0c112.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41c404e7-cc83-4bbc-9dc8-f4d01ee0c112.png)'
- en: The * on the last line of output in the preceding screenshot indicates that
    our Go version is set to version 1.8.3\. Note that running `go version`  returns  `go1.9
    darwin/amd64`, which was the most recent version of Go when our book was published.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述屏幕截图的输出的最后一行上的*表示我们的Go版本设置为版本1.8.3。请注意，运行`go version`返回`go1.9 darwin/amd64`，这是我们的书出版时最新的Go版本。
- en: We see that our `GOPATH` is not properly set and that we have three versions
    of Go installed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们的`GOPATH`没有正确设置，并且我们安装了三个Go版本。
- en: Using homebrew to install Go
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用homebrew安装Go
- en: 'On a Mac, we can use homebrew to install and manage our Go installations:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，我们可以使用homebrew来安装和管理我们的Go安装：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running the preceding command might return result like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令可能会返回如下结果：
- en: '`go`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`go`'
- en: '`go@1.4`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`go@1.4`'
- en: '`go@1.5`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`go@1.5`'
- en: '`go@1.6`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`go@1.6`'
- en: '`go@1.7`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`go@1.7`'
- en: '`go@1.8`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`go@1.8`'
- en: The checks indicate which versions of Go are already installed. To install go
    version 1.5, we can run `brew install go@1.5`. To install the latest version of
    go (currently 1.9), run  `brew install go`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 检查指示哪些Go版本已安装。要安装go版本1.5，可以运行`brew install go@1.5`。要安装最新版本的go（当前为1.9），请运行`brew
    install go`。
- en: Examining the initial directory structure and files
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查初始目录结构和文件
- en: 'Let''s examine our initial directory structure and files:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们的初始目录结构和文件：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The init script contents
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: init脚本内容
- en: 'Before we run our `init` script, let''s look at the contents of our init script:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们的`init`脚本之前，让我们看看我们的init脚本的内容：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'All we need to do is verify that the preceding variables the dotted line are
    correct:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要验证上述虚线的变量是否正确：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we don't change anything, the script will work using go version 1.9 and it
    will create a `~/dev` directory if it does not already exist.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不改变任何东西，脚本将使用go版本1.9工作，并且如果`~/dev`目录不存在，它将创建一个。
- en: Running the init script
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行init脚本
- en: To get our project ready for development, in our terminal, just run `. init`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的项目准备好开发，在我们的终端中，只需运行`. init`。
- en: '![](img/94462aca-6c7e-43b7-8d65-4a818e58b0f5.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94462aca-6c7e-43b7-8d65-4a818e58b0f5.png)'
- en: Note that `source` and "."  do the same thing; they run the following command
    in the context of the current shell environment.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`source`和"."做同样的事情；它们在当前shell环境的上下文中运行以下命令。
- en: Note that our current directory path is shorter. We're in a newly linked directory.
    It's a link file in `MY_DEV_DIR`. A benefit or side-effect of running this script
    is that we can go to our `MY_DEV_DIR` to see what projects we've worked on lately.
    It's also nice not to have such a long path name in our terminal (assuming we
    display our full, current directory path in our shell prompt).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们当前的目录路径更短。我们在一个新链接的目录中。这是`MY_DEV_DIR`中的一个链接文件。运行此脚本的一个好处或副作用是，我们可以去`MY_DEV_DIR`看看我们最近工作过的项目。在我们的终端中显示我们的完整当前目录路径时，这也很好（假设我们显示我们的shell提示符中的完整当前目录路径）。
- en: Re-examining the initial directory structure and files
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重新检查初始目录结构和文件
- en: We also ran the tree command to see our project directories and ran the file
    command to see our files.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还运行了tree命令来查看我们的项目目录，并运行了file命令来查看我们的文件。
- en: The only new file the init script created is `PROJECT_DIR_LINK` (in this example,
    `/home/lex/dev/01_dependency-rule-good`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: init脚本创建的唯一新文件是`PROJECT_DIR_LINK`（在此示例中为`/home/lex/dev/01_dependency-rule-good`）。
- en: The goenv shows what's been updated
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: goenv显示了更新的内容
- en: 'That init script must have done something else for us, right? Let''s run our
    goenv info command again to see what else it did:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 那个init脚本一定为我们做了其他事情，对吧？让我们再次运行我们的goenv info命令，看看它还做了什么：
- en: '![](img/4ace780a-74ab-4fc4-9884-ccee1c07f9ef.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ace780a-74ab-4fc4-9884-ccee1c07f9ef.png)'
- en: We get a warning because the `GOPATH` is actually a path. (Most other vendor
    solutions will not work properly if `GOPATH` is anything other than a single directory.)
    Our `GOPATH` is constructed just like our `PATH` environment variable. It's composed
    of paths appended together, separated by a colon character.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到警告，因为`GOPATH`实际上是一个路径。（如果`GOPATH`不是单个目录，则大多数其他供应商解决方案将无法正常工作。）我们的`GOPATH`的构造方式与我们的`PATH`环境变量相同。它由路径组成，由冒号字符分隔。
- en: 'Our `GOPATH` is comprised of two values: the `src` path (with our project source
    files) and the vendors path (with our third-party dependency source files).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`GOPATH`由两个值组成：`src`路径（带有我们的项目源文件）和vendors路径（带有我们的第三方依赖源文件）。
- en: Running glide-update to get third-party dependency files
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行glide-update以获取第三方依赖文件
- en: After we add files to our src directory and have some import statements and
    before we run our Go app, let's ensure that Go has all the source files for our
    dependencies that it requires to build our application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向src目录添加文件并有一些导入语句之后，在运行我们的Go应用程序之前，让我们确保Go具有构建我们应用程序所需的所有依赖项的源文件。
- en: Anytime we update any import statement (and before we run our application),
    we run `glide-update`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们更新任何导入语句（并在运行应用程序之前），我们都运行`glide-update`。
- en: '![](img/ad0fb628-a5b6-4789-be3b-118c79b71ea8.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad0fb628-a5b6-4789-be3b-118c79b71ea8.png)'
- en: We can run our Go application by typing `go-run` . This will compile our application
    (putting the binary in our `GOBIN` directory) and run it. Our application outputs
    two lines with the characters **A** and **B**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入`go-run`来运行我们的Go应用程序。这将编译我们的应用程序（将二进制文件放入我们的`GOBIN`目录）并运行它。我们的应用程序输出两行字符**A**和**B**。
- en: Running `glide-update` will create the typical `vendor` directory and quickly
    rename it to vendors (which is a further indication that this is not a standard
    glide installation). We don't have to be a glide expert to get our dependencies
    managed by glide. Anytime we update dependencies (and change an import statement),
    we just run the glide-update alias and all the dependencies' code will go into
    the vendors directory and our `GOPATH` will know to look there when it compiles.
    Also note that if you use a fancy IDE that requires you to enter your `GOROOT`,
    `GOBIN`, and `GOPATH`, you just need to run `goenv-info` to see what our project
    correct settings are.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`glide-update`将创建典型的`vendor`目录，并迅速将其重命名为vendors（这进一步表明这不是标准的glide安装）。我们不必成为glide专家就能让glide管理我们的依赖项。每当我们更新依赖项（并更改导入语句），我们只需运行`glide-update`别名，所有依赖项的代码都将进入vendors目录，我们的`GOPATH`在编译时会知道在那里查找。还要注意，如果您使用需要输入`GOROOT`、`GOBIN`和`GOPATH`的高级IDE，您只需运行`goenv-info`来查看我们项目的正确设置是什么。
- en: If `glide-update` reports any errors, it will be up to us resolve them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`glide-update`报告任何错误，就由我们来解决。
- en: Adding standard library imports
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加标准库导入
- en: 'We''ll add the `fmt` package to the import statement in `packagea`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`packagea`的导入语句中添加`fmt`包：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ll add the log package to the import statement in `packageb`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`packageb`的导入语句中添加日志包：
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After adding our imports, we source init:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们的导入后，我们初始化源：
- en: '![](img/4e60334a-6164-4431-af90-72783b1fc303.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e60334a-6164-4431-af90-72783b1fc303.png)'
- en: 'Next, we update our dependencies:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新我们的依赖项：
- en: '![](img/f605043a-b950-4ae8-a2a6-7e94b9def563.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f605043a-b950-4ae8-a2a6-7e94b9def563.png)'
- en: 'Now, we can run our app:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的应用程序：
- en: '![](img/8712c6c0-cdab-40d8-8e8b-83e6e5a3481a.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8712c6c0-cdab-40d8-8e8b-83e6e5a3481a.png)'
- en: The only difference is that the `log.Println` command adds a time stamp. We
    see that it works, but what about the dependencies? Does the vendor's directory
    now have some files?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是`log.Println`命令添加了时间戳。我们看到它起作用了，但依赖关系呢？现在vendor目录中有一些文件吗？
- en: '![](img/b3945f73-1f15-4ec7-82e2-227f10ec763d.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3945f73-1f15-4ec7-82e2-227f10ec763d.png)'
- en: Nope. Still no files. Why?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不。仍然没有文件。为什么？
- en: That's because `fmt` and `log` are both from Go's standard library.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`fmt`和`log`都来自Go的标准库。
- en: The Go standard library
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Go标准库
- en: The Go standard library is a set of core packages that enhance and extend the
    language.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库是一组增强和扩展语言的核心包。
- en: By *core*, we mean that every time we compile our Go app, we'll get that pkg
    directory and it will be filled with the Go standard library packages.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*core*，我们的意思是每次编译我们的Go应用程序，我们都会得到那个pkg目录，并且它将填满Go标准库包。
- en: 'Go standard library packages have the following features:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库包具有以下功能：
- en: They add no extra overhead
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不会增加额外的开销
- en: They are guaranteed to always exist
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们保证始终存在
- en: They are guaranteed to always be backwards compatible (won't break between release
    cycles)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们保证始终向后兼容（不会在发布周期之间中断）
- en: Using packages from Go's standard library will make our code easier to manage
    and more reliable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go标准库中的包将使我们的代码更易于管理和更可靠。
- en: 'Example packages include the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 示例包括以下内容：
- en: '`log`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log`'
- en: '`fmt`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt`'
- en: '`encoding/json`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding/json`'
- en: '`database/sql/driver`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`database/sql/driver`'
- en: '`net/http`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http`'
- en: For details regarding Go's Standard Library, refer to: [https://golang.org/pkg/](https://golang.org/pkg/)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Go标准库的详细信息，请参阅：[https://golang.org/pkg/](https://golang.org/pkg/)
- en: Adding third-party imports
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加第三方导入
- en: For this example, we'll import a simple third-party utility package, `go-goodies/go_utils`.
    I created `go-goodies/go_utils` back in 2015 (when I was still very much learning
    the language). I have not modified much of the code in a while, so that I can
    look back to see how much I've learned. It all should still work properly, but
    in many cases, there are better ways to accomplish things. You've been warned,
    so please don't judge.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将导入一个简单的第三方实用程序包`go-goodies/go_utils`。我在2015年创建了`go-goodies/go_utils`（当时我还在学习这门语言）。我很久没有修改代码了，所以我可以回头看看我学到了多少。它应该仍然正常工作，但在许多情况下，有更好的方法来完成任务。您已经被警告了，请不要评判。
- en: Importing statement referencing  go_utils
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入语句引用go_utils
- en: Let's add a third import, `u "github.com/go-goodies/go_utils"`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加第三个导入，`u "github.com/go-goodies/go_utils"`。
- en: 'Note that we use the preceding `u` in the `Atask` function to reference the
    `PadLeft` function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在`Atask`函数中使用前缀`u`来引用`PadLeft`函数：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can use the `grep` command on our source files for `import` statements:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的源文件上使用`grep`命令查找`import`语句：
- en: '![](img/398d0073-f2fc-4973-bc7c-c61582779519.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/398d0073-f2fc-4973-bc7c-c61582779519.png)'
- en: 'Since we updated an import statement, we need to run `glide-update` before
    we run our app:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们更新了一个导入语句，我们需要在运行应用程序之前运行`glide-update`：
- en: '![](img/d001b9b6-d0bc-4dc3-8ae2-aeacba80cd5d.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d001b9b6-d0bc-4dc3-8ae2-aeacba80cd5d.png)'
- en: 'This time, we can see that `glide-update` pulled in the third-party (`go_utils`)
    files under the vendor''s directory:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们可以看到`glide-update`将第三方（`go_utils`）文件拉入了vendor目录：
- en: '![](img/9bf04c1e-b76d-438e-ba8d-1b6025516ec6.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bf04c1e-b76d-438e-ba8d-1b6025516ec6.png)'
- en: 'We can see that the `go-goodies/go_utils` references the following third-party
    packages:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`go-goodies/go_utils`引用了以下第三方包：
- en: '[http://github.com/margnus1/go-deepcopy](http://github.com/margnus1/go-deepcopy)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://github.com/margnus1/go-deepcopy](http://github.com/margnus1/go-deepcopy)'
- en: '[http://github.com/nu7hatch/gouuid](http://github.com/nu7hatch/gouuid)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://github.com/nu7hatch/gouuid](http://github.com/nu7hatch/gouuid)'
- en: 'When we run our app, we see the effect of using the `PadLeft` function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的应用程序时，我们可以看到使用`PadLeft`函数的效果：
- en: '![](img/9c7e4325-d4d3-41c7-a5ce-25b3654d5090.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c7e4325-d4d3-41c7-a5ce-25b3654d5090.png)'
- en: You can use the init script and the aliases it provides with confidence that
    they will not touch your source files (well, except prune-project will comment
    out lines in `./main.go` that reference `mypackage`). The files they modify include
    the soft linked directory file in your `~/dev` directory and the `bin`, `pkg`
    and vendors directories.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以放心地使用init脚本和它提供的别名，它们不会影响您的源文件（好吧，除了prune-project会注释掉`./main.go`中引用`mypackage`的行）。它们修改的文件包括软链接的目录文件在您的`~/dev`目录和`bin`、`pkg`和vendors目录中。
- en: Development workflow summary
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发工作流程摘要
- en: How you manage your dependencies, build, run, and deploy your applications is
    a matter of preference. It's often a good idea to get all of the developers in
    your team to  build applications the same way. The techniques shared in this section
    demonstrate the way I built the demo applications for this book. I kept it simple.
    However, the rest of the story is that I rarely build applications in isolation
    like I did for this book. Nearly every time, I use Docker in my `development/test/deployment`
    workflow. Note that the use of Docker is out of scope of this book.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如何管理依赖项、构建、运行和部署应用程序是个人偏好的问题。让团队中的所有开发人员以相同的方式构建应用程序通常是个好主意。本节分享的技术演示了我为本书构建演示应用程序的方式。我保持了简单。然而，事实是，我很少像为本书那样孤立地构建应用程序。几乎每次，我都会在我的`开发/测试/部署`工作流程中使用Docker。请注意，本书不涉及Docker的使用。
- en: Troubleshooting dot init
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除dot init
- en: This is how I resolved the build errors that occurred when converting [Chapter
    4](../Text/Ch04.xhtml), *SOLID Design in Go*, to the dot init technique.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我解决转换[Chapter 4](../Text/Ch04.xhtml)，*Go中的SOLID设计*，到点init技术时出现的构建错误。
- en: 'First, I used the `cd` command to direct to the project''s root directory (where
    the `project` is [Chapter 4](../Text/Ch04.xhtml), *SOLID Design in Go*, source
    code):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我使用`cd`命令将项目的根目录（`project`是[Chapter 4](../Text/Ch04.xhtml)，*Go中的SOLID设计*，源代码）指向：
- en: '![](img/a36879c6-acf9-4bd6-b2e7-46b99d8abd5b.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a36879c6-acf9-4bd6-b2e7-46b99d8abd5b.png)'
- en: 'Next, I ran `glide-update` to tell Glide to put the dependencies in the vendors
    directory:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我运行了`glide-update`，告诉Glide将依赖项放在vendors目录中：
- en: '![](img/805cf76c-27cd-46a8-a41e-c14eb915025a.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/805cf76c-27cd-46a8-a41e-c14eb915025a.png)'
- en: 'But, that failed because the `import` statement was incorrect:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这失败了，因为`import`语句是错误的：
- en: '![](img/cbef03c3-164f-45ee-80f9-77929617fbfd.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbef03c3-164f-45ee-80f9-77929617fbfd.png)'
- en: 'Here''s what the imports look like now:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在导入的样子是这样的：
- en: '![](img/14547117-0140-47ce-b3ee-da6e1d030dd5.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14547117-0140-47ce-b3ee-da6e1d030dd5.png)'
- en: Tell Glide to put third-party packages in the vendor's directory.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉Glide将第三方包放在vendors目录中。
- en: '![](img/85da26bf-a648-488c-8c18-3ef752bf2e55.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85da26bf-a648-488c-8c18-3ef752bf2e55.png)'
- en: 'Compile and run:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和运行：
- en: '![](img/9e23bdaa-486f-4575-b3a8-fedab6c2cf13.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e23bdaa-486f-4575-b3a8-fedab6c2cf13.png)'
- en: Bummer! `.init` can't find the binary.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！`.init`找不到二进制文件。
- en: 'No worries, just cd back to the original project root directory and re-source
    init:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，只需`cd`回到原始项目根目录并重新源init：
- en: '![](img/e1a1a47a-72a7-476a-9f90-8f9b76d1614a.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1a1a47a-72a7-476a-9f90-8f9b76d1614a.png)'
- en: If you run `go-run` and you see *command not found*, just rerun `init`, `glide-update`,
    and `go-run`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`go-run`时看到*command not found*，只需重新运行`init`、`glide-update`和`go-run`。
- en: Still more problems!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多问题！
- en: 'Oh, right. I forgot to read the init''s message and failed to run `glide-update`.
    Let''s do that next:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，对了。我忘了阅读init的消息，并且没有运行`glide-update`。我们接下来要做的就是这个：
- en: '![](img/94c01af8-0e43-4cc6-9d70-2eb95fb81da1.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94c01af8-0e43-4cc6-9d70-2eb95fb81da1.png)'
- en: Success!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！
- en: What might happen when we try to run our tests?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行测试时可能会发生什么？
- en: 'When we `cd` into our `02_fib` example application and type `go test -bench=.
    ./...`, we might run into a few errors:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们`cd`到我们的`02_fib`示例应用程序中并输入`go test -bench=. ./...`时，可能会遇到一些错误：
- en: '![](img/a0d14403-85bc-44eb-a136-162a50b05a40.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0d14403-85bc-44eb-a136-162a50b05a40.png)'
- en: This could happen if our `GOROOT` and/or `GOPATH` gets set to an invalid value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`GOROOT`和/或`GOPATH`设置为无效值，就会发生这种情况。
- en: There are two obvious errors here. The environment variables, `GOROOT` and `GOPATH`,
    are both invalid.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个明显的错误。环境变量`GOROOT`和`GOPATH`都是无效的。
- en: 'We find the path for `GOROOT` on a Mac computer by typing `brew info go|grep
    Cellar|grep -v export`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过输入`brew info go|grep Cellar|grep -v export`在Mac电脑上找到`GOROOT`的路径：
- en: '![](img/6c7d8a00-1c72-428b-b86c-96b9a6dafbda.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c7d8a00-1c72-428b-b86c-96b9a6dafbda.png)'
- en: We just happen to know that we need to add the `libexec` directory to the path
    that returned the result as shown in previous screenshot, to set our `GOPATH`.
    We'll set our `GOPATH` to the root directory of our current application, that
    is, our current directory. We also set the `GOBIN` path to tell Go where to store
    the executable file that gets created when we compile our source code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们碰巧知道我们需要将`libexec`目录添加到返回结果的路径中，以设置我们的`GOPATH`。我们将`GOPATH`设置为当前应用程序的根目录，也就是当前目录。我们还设置了`GOBIN`路径，告诉Go在编译源代码时存储可执行文件的位置。
- en: Since we won't need to handle any third-party packages in this chapter, we don't
    need to deal with dependency management. There are more than a dozen Go dependency
    management tools available. For subsequent chapters, we'll use Glide ([https://github.com/Masterminds/glide](https://github.com/Masterminds/glide))
    for package management and a very lightweight wrapper dot init that further simplifies
    our build and run processes. For details, see the Appendix.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在本章中我们不需要处理任何第三方包，因此我们不需要处理依赖管理。有十多种Go依赖管理工具可用。在后续章节中，我们将使用Glide（[https://github.com/Masterminds/glide](https://github.com/Masterminds/glide)）进行包管理，并使用一个非常轻量级的包装器dot
    init来进一步简化我们的构建和运行过程。详情请参见附录。
- en: Note that dot init eliminates the possibility of these sort of errors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，点初始化消除了这类错误的可能性。
- en: That was a lot of information for a tool that is supposed to simplify things.
    True, but nearly every time, all you need to know is in the *TL;DR* section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于一个旨在简化事情的工具来说是大量的信息。没错，但几乎每次，你需要知道的都在*TL;DR*部分。
- en: How to propose changes to Go
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何提出对Go的更改
- en: I am certain that Generics are not supported in Go (not even in Go 2.0), and
    as mentioned in the summary, I'm okay with that.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信在Go中不支持泛型（即使在Go 2.0中也不支持），正如摘要中提到的，我对此没有意见。
- en: However, the feature that we'd benefit most greatly from, if Go had it, is **Tail
    Call Optimization** (**TCO**).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果Go支持，我们将从中获益最大的功能是**尾递归优化**（**TCO**）。
- en: The first step - search specs
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步 - 搜索规范
- en: Is it possible that Go already supports TCO? Time to find out.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Go是否已经支持了TCO？是时候找出来了。
- en: First, I looked at the Go language specification for any mention of a TCO feature
    ([https://golang.org/ref/spec](https://golang.org/ref/spec)).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我查看了Go语言规范中有关TCO功能的任何提及（[https://golang.org/ref/spec](https://golang.org/ref/spec)）。
- en: I found nothing about TCO.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有找到关于TCO的任何信息。
- en: Second step - Google search
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步 - 谷歌搜索
- en: 'Next, I did the requisite Google search, and found this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我进行了必要的谷歌搜索，并找到了这个：
- en: '![](img/fd8626a0-04f0-43b7-9c38-1f659b87cfa1.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd8626a0-04f0-43b7-9c38-1f659b87cfa1.png)'
- en: The official Golang change proposal process
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Golang官方变更提案流程
- en: Then, I learned about the process of proposing changes to Go ([https://github.com/golang/proposal/](https://github.com/golang/proposal/)).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我了解了提出对Go进行更改的流程（[https://github.com/golang/proposal/](https://github.com/golang/proposal/)）。
- en: Search for existing issues
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索现有问题
- en: Here's the process.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是流程。
- en: 'First, visit [https://github.com/golang/go/issues](https://github.com/golang/go/issues)
     and search the language feature you''d like to be added to go, for example, type `tail
    call optimization`, as shown in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，访问[https://github.com/golang/go/issues](https://github.com/golang/go/issues)，并搜索您希望添加到Go中的语言功能，例如，输入`tail
    call optimization`，如下面的屏幕截图所示：
- en: '![](img/57a9bbcf-81ab-4f83-b9eb-9f60e9aa4f5a.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57a9bbcf-81ab-4f83-b9eb-9f60e9aa4f5a.png)'
- en: Reading existing proposals
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读现有提案
- en: 'I clicked on the line (with 13 comments) to see details:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我点击了带有13条评论的行，以查看详情：
- en: '![](img/0cf166dd-e498-4bd9-bcd8-bcad6dc3a7cd.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cf166dd-e498-4bd9-bcd8-bcad6dc3a7cd.png)'
- en: This is the feature that would dramatically improve our recursive function calls,
    for example, the Y-Combinator.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以显著改进我们递归函数调用的功能，例如Y-Combinator。
- en: Remember our benchmark test results from running the `SumRecursive` function
    in [Chapter 1](../Text/Ch01.xhtml), *Pure Functional Programming in Go*? It was
    about three times slower that the imperative version. The lack of TCO is the single
    most important reason why using FP on Go today is generally not recommended. Adding
    TCO to the list of Go's compiler features would solve this problem. That is why
    this low impact, high reward feature is so important.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在[第1章](../Text/Ch01.xhtml)中运行`SumRecursive`函数的基准测试结果吗？它比命令式版本慢了大约三倍。缺乏TCO是使用FP在Go上通常不推荐的最重要原因。将TCO添加到Go编译器功能列表中将解决这个问题。这就是为什么这个影响较小、回报较高的功能如此重要。
- en: 'There are other proposals that included more information in the initial post,
    which is a better way to present our idea. However, when we read the subsequent
    comments, details become more apparent. When I read the following comments, I
    was convinced that this proposal gets my vote:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他提案在初始帖子中包含了更多信息，这是呈现我们想法的更好方式。然而，当我们阅读后续评论时，细节变得更加明显。当我阅读以下评论时，我确信这个提案得到了我的支持：
- en: '![](img/6e6854e6-0cdc-43f7-ae17-cf5d7c7cb027.png)![](img/cb6b8824-8119-482e-9aee-c9bfaf05e34f.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e6854e6-0cdc-43f7-ae17-cf5d7c7cb027.png)![](img/cb6b8824-8119-482e-9aee-c9bfaf05e34f.png)'
- en: I think sharing an example of the `@tco` annotation I have in mind could bring
    more attention to this proposal. But it is about a month before my book is published.
    Do I enter the following comment in now and say, "*wait for my book to get all,
    the glory details*." or wait? What the heck, I'm going for it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为分享我心目中的`@tco`注释的示例可能会更引起人们对这个提案的关注。但是距离我的书出版还有一个月。我现在就输入以下评论并说，“*等待我的书获得所有的荣耀细节*。”还是等待？管他呢，我要去做。
- en: Adding a comment to the existing TCO proposal
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向现有TCO提案添加评论
- en: You can read the comment at [https://github.com/golang/go/issues/16798](https://github.com/golang/go/issues/16798).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/golang/go/issues/16798](https://github.com/golang/go/issues/16798)上阅读评论。
- en: '![](img/a3a36924-b456-46cd-b5a9-cd86a171cff2.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3a36924-b456-46cd-b5a9-cd86a171cff2.png)'
- en: 'Now, I wonder if my request warrants a separate proposal for the compiler directive?
    For example, *Proposal: Add compiler hints in the form of comment annotations*.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想知道我的请求是否值得为编译器指令提出单独的提案？例如，*提案：以注释注释的形式添加编译器提示*。
- en: We'll just leave that comment as is and see what happens.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留该评论，并看看会发生什么。
- en: The comment turned into a new proposal ([https://github.com/golang/go/issues/22624](https://github.com/golang/go/issues/22624)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 评论变成了一个新的提案（[https://github.com/golang/go/issues/22624](https://github.com/golang/go/issues/22624)）。
- en: The conversation is ongoing as this book goes to the press.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这本书的出版，这个讨论还在继续。
- en: Creating a new proposal
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新提案
- en: 'If I had not found this existing proposal, this is what I would have done.
    Go to [https://github.com/golang/go/issues/new](https://github.com/golang/go/issues/new)
    to create an issue:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我没有找到这个现有的提案，我会这样做。转到[https://github.com/golang/go/issues/new](https://github.com/golang/go/issues/new)创建一个问题：
- en: '![](img/33a4d7fb-5b63-4e5e-8aef-6cbf94aa4ef5.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33a4d7fb-5b63-4e5e-8aef-6cbf94aa4ef5.png)'
- en: Assuming after writing the proposal, if it becomes obvious from the questions
    that I failed to clearly define the proposal in the proposal message, I could
    then create a design document to help clarify the request.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在撰写提案后，如果从问题中变得明显，我未能在提案消息中清晰定义提案，那么我可以创建一个设计文档来帮助澄清请求。
- en: Creating a design document
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建设计文档
- en: I would go here, [https://github.com/golang/proposal/](https://github.com/golang/proposal/)
     click  on the Create new file button, and save it as  `design/NNNN-tco-annotation.md`, where
    `NNNN` is the GitHub issue number and `tco-annotation` is its short name. For
    example, `15292-generics.md` ([https://github.com/golang/proposal/blob/master/design/15292-generics.md](https://github.com/golang/proposal/blob/master/design/15292-generics.md)).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在这里[https://github.com/golang/proposal/](https://github.com/golang/proposal/)点击“创建新文件”按钮，将其保存为`design/NNNN-tco-annotation.md`，其中`NNNN`是GitHub问题编号，`tco-annotation`是其简称。例如，`15292-generics.md`
    ([https://github.com/golang/proposal/blob/master/design/15292-generics.md](https://github.com/golang/proposal/blob/master/design/15292-generics.md))。
- en: The design doc should follow the design template format at: [https://github.com/golang/proposal/blob/master/design/TEMPLATE.md](https://github.com/golang/proposal/blob/master/design/TEMPLATE.md).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 设计文档应遵循以下设计模板格式：[https://github.com/golang/proposal/blob/master/design/TEMPLATE.md](https://github.com/golang/proposal/blob/master/design/TEMPLATE.md)。
- en: Sending an email to notify the golang-dev group
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送电子邮件通知golang-dev组
- en: 'After saving the design document, I would post a NEW TOPIC to the  `golang-dev`
    mail group, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 保存设计文档后，我会在`golang-dev`邮件组中发布一个新主题，如下所示：
- en: '![](img/8cf12e22-a98b-432f-a47c-302b947cad84.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cf12e22-a98b-432f-a47c-302b947cad84.png)'
- en: An example proposal
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个示例提案
- en: 'Here''s an example of the notification email for a well-written proposal:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个写得很好的提案的通知电子邮件的示例：
- en: '![](img/54e64b3f-fea1-4ece-94e2-710d3dfcfbe5.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54e64b3f-fea1-4ece-94e2-710d3dfcfbe5.png)'
- en: Monitoring a proposal until the resolution is reached
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控提案直到解决方案达成
- en: I would monitor my inbox for new messages regarding the proposal  to check whether
    I needed to add clarification. Once comments and revisions on the design doc wind
    down, there will be a final discussion about the proposal and it will either be
    accepted or declined.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我会监视我的收件箱，查看有关提案的新消息，以检查是否需要添加澄清。一旦对设计文档的评论和修订结束，将就提案进行最后讨论，然后它将被接受或拒绝。
- en: FP resources
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FP资源
- en: 'Rather than compiling a list of functional programming resources that would
    interest Go developers here, I''ll make a github repo that can be updated over
    time:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里编译一个对Go开发人员感兴趣的函数式编程资源列表，我会创建一个可以随时间更新的github存储库：
- en: '[ https://github.com/l3x/fp-resources](https://github.com/l3x/fp-resources)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/l3x/fp-resources](https://github.com/l3x/fp-resources)'
- en: If you are aware of any missing links, feel free to submit a pull request so
    that I can update the information for everyone to see.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道任何缺失的链接，请随时提交拉取请求，以便我可以更新信息供所有人查看。
- en: Minggatu - Catalan number
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Minggatu - Catalan数
- en: '![](img/b650000a-ba51-4bac-b783-8984968f7ae5.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b650000a-ba51-4bac-b783-8984968f7ae5.png)'
- en: The discovery of the Catalan number is generally credited to Eugene Catalan
    in 1844, even though it was actually originally discovered more than 100 years
    earlier by the Chinese mathematician Minggatu  (1730).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 发现Catalan数通常归因于1844年的Eugene Catalan，尽管它实际上是由中国数学家Minggatu（1730）在100多年前最初发现的。
- en: 'The nth Catalan number can be represented by the following equation:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第n个Catalan数可以用以下方程表示：
- en: '![](img/e26adf67-9406-4d08-901d-04802f18626f.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e26adf67-9406-4d08-901d-04802f18626f.png)'
- en: The first few Catalan numbers for n = 0, 1, 2, 3, 4, 5, 6 are 1, 1, 2, 5, 14,
    42, 132.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当n = 0, 1, 2, 3, 4, 5, 6时，前几个Catalan数分别为1, 1, 2, 5, 14, 42, 132。
- en: The Catalan numbers are a sequence of numbers that appear in many counting and
    computer science solutions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Catalan数是许多计数和计算机科学解决方案中出现的一系列数字。
- en: The easiest way for me to explain the concept is by answering, How many *mountain
    tops* can you form with n upstroke and n downstroke that all stay above the original
    line?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我解释这个概念最简单的方法是回答，你可以用n个上升和n个下降的笔画形成多少个*山峰*，这些山峰都在原始线上方？
- en: 'The variable C[n] number of mountain tops containing n pairs of matching /\
    characters:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 变量C[n]是包含n对匹配/\字符的山峰数量：
- en: '[PRE10]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's use use textual delimiters (of open and close parenthesis) to represent
    containers.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用文本定界符（开放和关闭括号）来表示容器。
- en: Catalan numbers are a fundamental concept of containment often used to assist
    the conceptualization and design of new software and hardware architectures based
    in combinatory logic.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Catalan数是一个基本的包含概念，经常用于辅助基于组合逻辑的新软件和硬件架构的概念化和设计。
- en: 'The variable C[n] is the number of expressions containing n pairs with matching
    parentheses:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 变量C[n]是包含n对匹配括号的表达式的数量：
- en: '[PRE11]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The connection to lambda calculus is that that combinatory logic of matching
    parenthesis is sufficiently expressive to formalize recursive functions, and we
    know from our study of the Y-Combinator that recursive functions are fundamental.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 与λ演算的联系在于，匹配括号的组合逻辑足够表达递归函数，我们知道从对Y-组合子的研究中，递归函数是基本的。
- en: 'For a better intuition, consider that in most programming languages, code is
    represented internally by the interpreter or compiler using an **abstract syntax
    tree** (**AST**). An AST decomposes blocks of code into its smallest parts, making
    it easy to transform, analyze, or execute the code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，可以考虑在大多数编程语言中，代码在解释器或编译器内部使用**抽象语法树**（**AST**）来表示。 AST将代码块分解为最小的部分，使得转换、分析或执行代码变得容易：
- en: '[PRE12]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following AST chart represents the preceding code block:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下AST图表代表了前面的代码块：
- en: '![](img/b0a1d67c-a1ca-49d3-8cdc-e536ac719f09.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0a1d67c-a1ca-49d3-8cdc-e536ac719f09.png)'
- en: 'Here''s about what that code block looks like in LISP:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在LISP中，代码块看起来是这样的：
- en: '[PRE13]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use parentheses to represent the AST. An open parenthesis, "(", means step
    down a level of the tree, and a close parenthesis, ")", means step back up a level
    of the tree.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用括号来表示AST。一个开括号“（”表示向树的下一级，而一个闭括号“）”表示向树的上一级。
- en: There are other ways we could represent a tree structure in code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用其他方式来表示代码中的树结构。
- en: An explanation and call to action
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释和行动呼吁
- en: Though this information is directly applicable and meaningful to functional
    programming, it was not placed in the *History of Functional Programming* because
    the discovery dates were not in line with the sequence of events that lead directly
    to the invention/discovery of The Lambda calculus by Alonzo Church.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些信息直接适用于函数式编程，并且对函数式编程的历史有意义，但它没有被放在*函数式编程的历史*中，因为发现日期与直接导致阿隆佐·邱奇发明/发现λ演算的事件顺序不一致。
- en: This serves to show that people often think along the same lines, but for lack
    of communication/collaboration, nobody knows and nobody benefits from each other's
    work.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明人们经常思考的方向是相似的，但由于缺乏沟通/合作，没有人知道，也没有人从彼此的工作中受益。
- en: Today, we are neither bound by distance nor by planes, trains, or automobiles,
    but by human nature.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们既不受距离的限制，也不受飞机、火车或汽车的限制，而是受人性的限制。
- en: I believe that if it were up to software engineers and mathematicians, we would
    all share equally and rapidly. We are eager to share what we have learned and
    created (and love), but it's the corporation owners and governments (motivated
    by greed and power) that shut our mouths.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，如果由软件工程师和数学家决定，我们会平等并迅速地分享。我们渴望分享我们所学到的和创造的（以及爱），但是企业所有者和政府（受贪婪和权力驱使）却堵住了我们的嘴。
- en: I would like to acknowledge the great thinkers around the world like Minggatu
    and urge my fellow engineers, of all nations, to join in an effort to replace
    the lust for power with our love and passion for science.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要感谢像明嘎图这样的世界伟人，并敦促我的工程师同行，无论来自哪个国家，加入努力，用我们对科学的热爱和激情来取代对权力的欲望。
- en: '**f(x)** is pure. Humanity can be impure.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**f(x)**是纯粹的。人性可以是不纯的。'
- en: The Lambda Calculus (refer to the Y-Combinator and DNA Double Helix section
    in the last chapter)  is empirical proof that we (Chinese, Russian, Korean, Indian,
    African, Arab, American, and so on) are all more alike than we are different.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: λ演算（参见上一章的Y-Combinator和DNA双螺旋部分）是证明我们（中国人、俄罗斯人、韩国人、印度人、非洲人、阿拉伯人、美国人等）更相似而不是不同的经验性证据。
- en: We are all created equal. Let's substitute the love for power with the power
    of love. Let's put our differences aside and collaborate, whenever possible, to
    make a better world.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都是平等的。让我们用爱取代权力的欲望，用爱的力量。让我们把分歧放在一边，尽可能合作，创造一个更美好的世界。
- en: Peace,
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 和平，
- en: Lex
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Lex
