["```go\n$> go version\ngo version go1.6.1 linux/amd64\n\n```", "```go\npackage main\nimport \"fmt\"\nfunc main() { \n  fmt.Println(\"Hello, World!\")\n} \n\n```", "```go\n$> go run helloworld.go \nHello, World!\n\n```", "```go\n// This program prints molecular information for known metalloids \n// including atomic number, mass, and atom count found \n// in 100 grams of each element using the mole unit. \n// See http://en.wikipedia.org/wiki/Mole_(unit) \npackage main \n\nimport \"fmt\" \n\nconst avogadro float64 = 6.0221413e+23 \nconst grams = 100.0 \n\ntype amu float64 \n\nfunc (mass amu) float() float64 { \n  return float64(mass) \n} \n\ntype metalloid struct { \n  name   string \n  number int32 \n  weight amu \n} \n\nvar metalloids = []metalloid{ \n  metalloid{\"Boron\", 5, 10.81}, \n  metalloid{\"Silicon\", 14, 28.085}, \n  metalloid{\"Germanium\", 32, 74.63}, \n  metalloid{\"Arsenic\", 33, 74.921}, \n  metalloid{\"Antimony\", 51, 121.760}, \n  metalloid{\"Tellerium\", 52, 127.60}, \n  metalloid{\"Polonium\", 84, 209.0}, \n} \n\n// finds # of moles \nfunc moles(mass amu) float64 { \n  return float64(mass) / grams \n} \n\n// returns # of atoms moles \nfunc atoms(moles float64) float64 { \n  return moles * avogadro \n} \n\n// return column headers \nfunc headers() string { \n  return fmt.Sprintf( \n    \"%-10s %-10s %-10s Atoms in %.2f Grams\\n\", \n    \"Element\", \"Number\", \"AMU\", grams, \n  ) \n} \n\nfunc main() { \n  fmt.Print(headers()) \n\n    for _, m := range metalloids { \n      fmt.Printf( \n    \"%-10s %-10d %-10.3f %e\\n\", \n      m.name, m.number, m.weight.float(), atoms(moles(m.weight)), \n      ) \n    } \n}\n\n```", "```go\n$> go run metalloids.go \nElement    Number     AMU        Atoms in 100.00 Grams \nBoron      5          10.810     6.509935e+22 \nSilicon    14         28.085     1.691318e+23 \nGermanium  32         74.630     4.494324e+23 \nArsenic    33         74.921     4.511848e+23 \nAntimony   51         121.760    7.332559e+23 \nTellerium  52         127.600    7.684252e+23 \nPolonium   84         209.000    1.258628e+24\n\n```", "```go\n// a simple Go function \nfunc moles(mass amu) float64 { \n    return float64(mass) / grams \n} \n\n```", "```go\nfunc moles(mass amu) (float64, error) { \n    if mass < 0 { \n        return 0, error.New(\"invalid mass\") \n    } \n    return (float64(mass) / grams), nil \n}\n```", "```go\nconst grams = 100.0 \n\n```", "```go\npackage main  \nimport \"fmt\"  \nfunc main() { \n  var name = \"Metalloids\" \n  var triple = [3]int{5,14,84} \n  elements := []string{\"Boron\",\"Silicon\", \"Polonium\"} \n  isMetal := false \n  fmt.Println(name, triple, elements, isMetal) \n\n} \n\n```", "```go\nvar metalloids = []metalloid{ \n    metalloid{\"Boron\", 5, 10.81}, \n    metalloid{\"Silicon\", 14, 28.085}, \n    metalloid{\"Germanium\", 32, 74.63}, \n    metalloid{\"Arsenic\", 33, 74.921}, \n    metalloid{\"Antimony\", 51, 121.760}, \n    metalloid{\"Tellerium\", 52, 127.60}, \n    metalloid{\"Polonium\", 84, 209.0}, \n} \n\n```", "```go\nfunc main() { \n  planet := struct { \n      name string \n      diameter int  \n  }{\"earth\", 12742} \n} \n\n```", "```go\ntype amu float64 \n\ntype metalloid struct { \n  name string \n  number int32 \n  weight amu \n} \n\n```", "```go\ntype amu float64 \n\nfunc (mass amu) float() float64 { \n    return float64(mass) \n} \n\n```", "```go\ntype Stringer interface { \n    String() string \n} \n\n```", "```go\ntype metalloid struct { \n    name string \n    number int32 \n    weight amu \n} \nfunc (m metalloid) String() string { \n  return fmt.Sprintf( \n    \"%-10s %-10d %-10.3f %e\", \n    m.name, m.number, m.weight.float(), atoms(moles(m.weight)), \n  ) \n}  \n\n```", "```go\nfunc main() { \n  fmt.Print(headers()) \n  for _, m := range metalloids { \n    fmt.Print(m, \"\\n\") \n  } \n} \n\n```", "```go\n// Calculates sum of all multiple of 3 and 5 less than MAX value. \n// See https://projecteuler.net/problem=1 \npackage main \n\nimport ( \n  \"fmt\" \n) \n\nconst MAX = 1000 \n\nfunc main() { \n  work := make(chan int, MAX) \n  result := make(chan int) \n\n  // 1\\. Create channel of multiples of 3 and 5 \n  // concurrently using goroutine \n  go func(){ \n    for i := 1; i < MAX; i++ { \n      if (i % 3) == 0 || (i % 5) == 0 { \n        work <- i // push for work \n      } \n    } \n    close(work)  \n  }() \n\n  // 2\\. Concurrently sum up work and put result \n  //    in channel result  \n  go func(){ \n    r := 0 \n    for i := range work { \n      r = r + i \n    } \n    result <- r \n  }() \n\n  // 3\\. Wait for result, then print \n  fmt.Println(\"Total:\", <- result) \n} \n\n```", "```go\nfunc DivMod(dvdn, dvsr int) (q, r int) { \n  r = dvdn \n  for r >= dvsr { \n    q += 1 \n    r = r - dvsr \n  } \n  return \n} \n\n```", "```go\npackage testexample \nimport \"testing\" \nfunc TestDivide(t *testing.T) { \n  dvnd := 40 \n    for dvsor := 1; dvsor < dvnd; dvsor++ { \n      q, r := DivMod(dvnd, dvsor) \n  if (dvnd % dvsor) != r { \n    t.Fatalf(\"%d/%d q=%d, r=%d, bad remainder.\", dvnd, dvsor, q, r) \n    } \n  } \n}  \n\n```", "```go\n$> go test . \nok   github.com/vladimirvivien/learning-go/ch01/testexample  0.003s\n\n```", "```go\n// DivMod performs a Eucledan division producing a quotient and remainder. \n// This version only works if dividend and divisor > 0\\. \nfunc DivMod(dvdn, dvsr int) (q, r int) { \n... \n}\n```", "```go\n$> godoc -http=\":6001\"\n\n```"]