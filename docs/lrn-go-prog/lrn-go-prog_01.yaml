- en: Chapter 1. A First Step in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。Go的第一步
- en: In the first chapter of the book, you will be introduced to Go and take a tour
    of the features that have made the language a favorite among its adopters. The
    start of the chapter provides the motivation behind the Go programming language.
    If you are impatient, however, you are welcome to skip to any of the other topics
    and learn how to write your first Go program. Finally, the *Go in a nutshell*
    section provides a high-level summary of the characteristics of the language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一章中，您将介绍Go并了解使该语言成为受欢迎的特点。本章的开头部分介绍了Go编程语言背后的动机。然而，如果您感到不耐烦，可以跳到其他主题并学习如何编写您的第一个Go程序。最后，“Go简介”部分提供了对该语言特性的高级摘要。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: The Go programming language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go编程语言
- en: Playing with Go
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Go
- en: Installing Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Go
- en: Your first Go program
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的第一个Go程序
- en: Go in a nutshell
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go简介
- en: The Go programming language
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go编程语言
- en: 'Since the invention of the C language in the early 1970s by *Dennis Ritchie*
    at Bell Labs, the computing industry has produced many popular languages that
    are based directly on (or have borrowed ideas from) its syntax. Commonly known
    as the C-family of languages, they can be split into two broad evolutionary branches.
    In one branch, derivatives such as C++, C#, and Java have evolved to adopt a strong
    type system, object orientation, and the use of compiled binaries. These languages,
    however, tend to have a slow build-deploy cycle and programmers are forced to
    adopt a complex object-oriented type system to attain runtime safety and speed
    of execution:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 自从贝尔实验室的*Dennis Ritchie*在1970年代初发明了C语言以来，计算机行业已经产生了许多流行的语言，它们直接基于（或借鉴了）C语言的语法。通常被称为C语言家族的语言，它们可以分为两个广泛的演变分支。在一个分支中，派生语言如C++、C#和Java已经发展出采用了强类型系统、面向对象和使用编译二进制的特点。然而，这些语言往往具有较慢的构建部署周期，程序员被迫采用复杂的面向对象类型系统来获得运行时安全性和执行速度：
- en: '![The Go programming language](img/image_01_001.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Go编程语言](img/image_01_001.jpg)'
- en: In the other evolutionary linguistic branch are languages such as Perl, Python,
    and JavaScript that are described as dynamic languages for their lack of type
    safety formalities, use of lightweight scripting syntax, and code interpretation
    instead of compilation. Dynamic languages have become the preferred tool for web
    and cloud scale development where speed and ease of deployment are valued over
    runtime safety. The interpreted nature of dynamic languages means, however, they
    generally run slower than their compiled counterparts. In addition, the lack of
    type safety at runtime means the correctness of the system scales poorly as the
    application grows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个演变的语言分支中，有诸如Perl、Python和JavaScript等语言，它们被描述为动态语言，因为它们缺乏类型安全形式，使用轻量级脚本语法，并且代码解释而非编译。动态语言已成为Web和云规模开发的首选工具，速度和部署便利性被重视胜过运行时安全性。然而，动态语言的解释性质意味着它们通常运行速度比编译语言慢。此外，运行时缺乏类型安全意味着系统的正确性随着应用程序的增长而变得不稳定。
- en: 'Go was created as a system language at Google in 2007 by *Robert Griesemer*,
    *Rob Pike*, and *Ken Thomson* to handle the needs of application development.
    The designers of Go wanted to mitigate the issues with the aforementioned languages
    while creating a new language that is simple, safe, consistent, and predictable.
    As Rob Pike puts it:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go是由*Robert Griesemer*、*Rob Pike*和*Ken Thomson*于2007年在Google创建的系统语言，用于处理应用程序开发的需求。Go的设计者们希望在创建一种新语言的同时，减轻前述语言的问题，使其简单、安全、一致和可预测。正如Rob
    Pike所说：
- en: '*"Go is an attempt to combine the safety and performance of a statically-typed
    language with the expressiveness and convenience of a dynamically-typed interpreted
    language."*'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“Go试图将静态类型语言的安全性和性能与动态类型解释语言的表现力和便利性相结合。”*'
- en: 'Go borrows ideas from different languages that came before it, including:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Go从之前的不同语言中借鉴了一些想法，包括：
- en: Simplified but concise syntax that is fun and easy to use
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化但简洁的语法，有趣且易于使用
- en: A type of system that feels more like a dynamic language
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种更像动态语言的系统类型
- en: Support for object-oriented programming
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持面向对象编程
- en: Statically typed for compilation and runtime safety
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型用于编译和运行时安全
- en: Compiled to native binaries for fast runtime execution
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译为本机二进制以实现快速运行时执行
- en: Near-zero compilation time that feels more like an interpreted language
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎零编译时间，更像解释型语言
- en: A simple concurrency idiom to leverage multi-core, multi-chip machines
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种简单的并发习语，以利用多核、多芯片机器
- en: A garbage collector for safe and automatic memory management
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于安全和自动内存管理的垃圾收集器
- en: The remainder of this chapter will walk you through an introductory set of steps
    that will give you a preview of the language and get you started with building
    and running your first Go program. It is a precursor to the topics that are covered
    in detail in the remaining chapters of the book. You are welcome to skip to other
    chapters if you already have a basic understanding of Go.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将带您走过一系列入门步骤，让您预览该语言并开始构建和运行您的第一个Go程序。这是本书其余章节中详细讨论的主题的前奏。如果您已经对Go有基本的了解，可以跳到其他章节。欢迎您跳到其他章节。
- en: Playing with Go
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go
- en: 'Before we jump head-first into installing and running Go tools on your local
    machine, let us take a look at the **Go Playground**. The creators of the language
    have made available a simple way to familiarize yourself with the language without
    installing any tools. Known as the Go Playground, it is a web-based tool, accessible
    from [https://play.golang.org/](https://play.golang.org/), that uses an editor
    metaphor to let developers test their Go skills by writing code directly within
    the web browser window. The Playground gives its users the ability to compile
    and run their code on Google''s remote servers and get immediate results as shown
    in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们首先安装和运行Go工具之前，让我们先来看看**Go Playground**。语言的创建者提供了一种简单的方式来熟悉语言，而无需安装任何工具。Go
    Playground是一个基于Web的工具，可从[https://play.golang.org/](https://play.golang.org/)访问，它使用编辑器的比喻，让开发人员可以直接在Web浏览器窗口中编写代码来测试他们的Go技能。Playground让用户能够在Google的远程服务器上编译和运行他们的代码，并立即获得结果，如下面的截图所示：
- en: '![Playing with Go](img/image_01_002.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Playing with Go](img/image_01_002.jpg)'
- en: 'The editor is basic, as it is meant to be used as a learning tool and a way
    to share code with others. The Playground includes practical features such as
    line numbers and formatting to ensure your code remains readable as it goes beyond
    a few lines long. Since this is a free service that consumes real compute resources,
    Google understandably imposes a few limitations on what can be done with Playground:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器很基础，因为它旨在作为学习工具和与他人分享代码的方式。Playground包括实用功能，如行号和格式化，以确保您的代码在超过几行时仍然可读。由于这是一个消耗实际计算资源的免费服务，Google可以理解地对Playground可以做什么施加一些限制：
- en: You are restricted on the amount of memory your code will consume
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码将消耗的内存量受到限制
- en: Long-running programs will be killed
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间运行的程序将被终止
- en: Access to files is simulated with an in-memory filesystem.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件访问是通过内存文件系统模拟的。
- en: Network access is simulated against the loopback interface only
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络访问仅模拟对回环接口的访问
- en: No IDE required
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无需IDE
- en: Besides the Go Playground, how is one supposed to write Go code anyway? Writing
    Go does not require a fancy **Integrated Development Environment** (**IDE**).
    As a matter of fact, you can get started writing your simple Go programs with
    your favorite plain text editor that is bundled with your OS. There are, however,
    Go plugins for most major text editors (and full-blown IDEs) such as Atom, Vim,
    Emacs, Microsoft Code, IntelliJ, and many others. There is a complete list of
    editors and IDE plugins for Go which can be found at [https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins](https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Go Playground，有什么其他方法可以编写Go代码呢？编写Go并不需要一个花哨的**集成开发环境**（**IDE**）。事实上，您可以使用捆绑在您的操作系统中的喜爱的纯文本编辑器开始编写简单的Go程序。但是，大多数主要文本编辑器（和完整的IDE）都有针对Go的插件，如Atom、Vim、Emacs、Microsoft
    Code、IntelliJ等。可以在[https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins](https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins)找到完整的编辑器和IDE插件列表。
- en: Installing Go
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Go
- en: 'To start programming with Go on your local machine you will need to install
    the **Go Toolchain** on your computer. At the time of writing, Go comes ready
    to be installed on the following major OS platforms:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地计算机上开始使用Go进行编程，您需要在计算机上安装**Go工具链**。目前，Go已准备好在以下主要操作系统平台上安装：
- en: Linux
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: FreeBSD Unix
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD Unix
- en: Mac OSX
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac OSX
- en: Windows
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows
- en: The official installation packages are all available for 32-bit and 64-bit Intel-based
    architectures. There are also official binary releases that are available for
    ARM architectures as well. As Go grows in popularity, there will certainly be
    more binary distribution choices made available in the future.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 官方安装包都适用于32位和64位的基于英特尔的架构。还有官方的二进制发布版本适用于ARM架构。随着Go的流行，未来肯定会提供更多的二进制发行选择。
- en: 'Let us skip the detailed installation instructions as they will certainly change
    by the time you read this. Instead, you are invited to visit [http://golang.org/doc/install](http://golang.org/doc/install)
    and follow the directions given for your specific platform. Once completed, be
    sure to test your installation is working before continuing to use the following
    command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳过详细的安装说明，因为当您阅读此文时，这些说明肯定会发生变化。相反，您可以访问[http://golang.org/doc/install](http://golang.org/doc/install)并按照针对您特定平台的说明进行操作。完成后，请确保在继续使用以下命令之前测试您的安装是否正常：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous command should print the version number, target OS, and the machine
    architecture where Go and its tools are installed. If you do not get an output
    similar to that preceding command, ensure to add the path of the Go binaries to
    your OS's execution `PATH` environment variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令应该打印出版本号、目标操作系统以及安装了Go及其工具的机器架构。如果您没有得到类似于前面命令的输出，请确保将Go二进制文件的路径添加到您的操作系统的执行`PATH`环境变量中。
- en: Before you start writing your own code, ensure that you have properly set up
    your `GOPATH`. This is a local directory where your Go source files and compiled
    artifacts are saved as you use the Go Toolchain. Follow the instructions found
    in [https://golang.org/doc/install#testing](https://golang.org/doc/install#testing)
    to set up your GOPATH.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写自己的代码之前，请确保已正确设置了`GOPATH`。这是一个本地目录，您在使用Go工具链时保存Go源文件和编译后的构件的地方。请按照[https://golang.org/doc/install#testing](https://golang.org/doc/install#testing)中的说明设置您的GOPATH。
- en: Source code examples
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码示例
- en: The programming examples presented throughout this book are available on the
    GitHub source code repository service. There you will find all source files grouped
    by chapters in the repository at [https://github.com/vladimirvivien/learning-go/](https://github.com/vladimirvivien/learning-go/).
    To save the readers a few keystrokes, the examples use a shortened URL, that starts
    with `golang.fyi`, that points directly to the respective file in GitHub.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中提供的编程示例都可以在GitHub源代码存储库上找到。在那里，你将找到所有按章节分组的源文件，存储在存储库中的[https://github.com/vladimirvivien/learning-go/](https://github.com/vladimirvivien/learning-go/)。为了节省读者一些按键次数，示例使用了一个缩短的URL，以`golang.fyi`开头，直接指向GitHub中的相应文件。
- en: Alternatively, you can follow along by downloading and unzipping (or cloning)
    the repository locally. Create a directory structure in your `GOPATH` so that
    the root of the source files is located at `$GOPATH/src/github.com/vladimirvivien/learning-go/`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过下载和解压（或克隆）本地存储库来跟随。在你的`GOPATH`中创建一个目录结构，使得源文件的根目录位于`$GOPATH/src/github.com/vladimirvivien/learning-go/`。
- en: Your first Go program
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个Go程序
- en: 'After installing the Go tools successfully on your local machine, you are now
    ready to write and execute your first Go program. For that, simply open your favorite
    text editor and type in the simple Hello World program shown in the following
    code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的本地机器上成功安装了Go工具之后，你现在可以准备编写和执行你的第一个Go程序了。为此，只需打开你喜欢的文本编辑器，输入下面代码中显示的简单的Hello
    World程序：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch01/helloworld.go
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch01/helloworld.go
- en: 'Save the source code in a file called `helloworld.go` anywhere inside your
    GOPATH. Then use the following Go command to compile and run the program:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将源代码保存在名为`helloworld.go`的文件中，放在你的GOPATH的任何位置。然后使用以下Go命令来编译和运行程序：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If all goes well, you should see the message **Hello, World!** output on your
    screen. Congratulations, you have just written and executed your first Go program.
    Now, let us explore the attributes and characteristics of the Go language at a
    high level.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该在屏幕上看到消息**Hello, World!**的输出。恭喜，你刚刚编写并执行了你的第一个Go程序。现在，让我们以高层次来探索Go语言的属性和特性。
- en: Go in a nutshell
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go简介
- en: 'By design, Go has a simple syntax. Its designers wanted to create a language
    that is clear, concise, and consistent with few syntactic surprises. When reading
    Go code, keep this mantra in mind: w*hat you see is what it is*. Go shies away
    from a clever and terse coding style in favor of code that is clear and readable
    as exemplified by the following program:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按设计，Go具有简单的语法。它的设计者希望创建一种清晰、简洁、一致的语言，减少语法上的惊喜。阅读Go代码时，要记住这句口号：*你看到的就是它的样子*。Go避免了巧妙而简洁的编码风格，而更倾向于清晰易读的代码，正如下面的程序所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch01/metalloids.go
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch01/metalloids.go
- en: 'When the code is executed, it will give the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码被执行时，它将给出以下输出：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you have never seen Go before, you may not understand some of the details
    of the syntax and idioms used in the previous program. Nevertheless, when you
    read the code, there is a good chance you will be able to follow the logic and
    form a mental model of the program's flow. That is the beauty of Go's simplicity
    and the reason why so many programmers use it. If you are completely lost, no
    need to worry, as the subsequent chapters will cover all aspects of the language
    to get you going.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未见过Go，你可能不理解前一个程序中使用的语法和习惯用法的一些细节。然而，当你阅读代码时，你很有可能能够跟上逻辑并形成程序流的心智模型。这就是Go简单之美的所在，也是为什么有这么多程序员使用它的原因。如果你完全迷失了，不用担心，后续章节将涵盖语言的所有方面，让你上手。
- en: Functions
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Go programs are composed of functions, the smallest callable code unit in the
    language. In Go, functions are typed entities that can either be named (as shown
    in the previous example) or be assigned to a variable as a value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序由函数组成，函数是语言中最小的可调用代码单元。在Go中，函数是有类型的实体，可以是命名的（如前面的示例所示），也可以被赋值给一个变量作为值：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another interesting feature about Go functions is their ability to return multiple
    values as a result of a call. For instance, the previous function could be re-written
    to return a value of type `error` in addition to the calculated `float64` value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Go函数的另一个有趣特性是它们能够返回多个值作为调用的结果。例如，前面的函数可以重写为返回`error`类型的值，以及计算出的`float64`值：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The previous code uses the multi-return capabilities of Go functions to return
    both the mass and an error value. You will encounter this idiom throughout the
    book used as a mean to properly signal errors to the caller of a function. There
    will be further discussion on multi-return value functions covered in [Chapter
    5](ch05.html "Chapter 5. Functions in Go"), *Functions in Go*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了Go函数的多返回能力来返回质量和错误值。你将在整本书中遇到这种习惯用法，作为向函数的调用者正确地传递错误的一种方式。在[第5章](ch05.html
    "第5章. Go中的函数") *Go中的函数*中将进一步讨论多返回值函数。
- en: Packages
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: Source files containing Go functions can be further organized into directory
    structures known as a package. Packages are logical modules that are used to share
    code in Go as libraries. You can create your own local packages or use tools provided
    by Go to automatically pull and use remote packages from a source code repository.
    You will learn more about Go packages in [Chapter 6](ch06.html "Chapter 6. Go
    Packages and Programs"), *Go Packages and Programs*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 包含Go函数的源文件可以进一步组织成称为包的目录结构。包是逻辑模块，用于在Go中共享代码作为库。你可以创建自己的本地包，或者使用Go提供的工具自动从源代码存储库中拉取和使用远程包。你将在[第6章](ch06.html
    "第6章. Go包和程序") *Go包和程序*中学到更多关于Go包的知识。
- en: The workspace
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作空间
- en: Go follows a simple code layout convention to reliably organize source code
    packages and to manage their dependencies. Your local Go source code is stored
    in the workspace, which is a directory convention that contains the source code
    and runtime artifacts. This makes it easy for Go tools to automatically find,
    build, and install compiled binaries. Additionally, Go tools rely on the `workspace`
    setup to pull source code packages from remote repositories, such as Git, Mercurial,
    and Subversion, and satisfy their dependencies.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Go遵循简单的代码布局约定，可靠地组织源代码包并管理其依赖关系。您的本地Go源代码存储在工作区中，这是一个包含源代码和运行时工件的目录约定。这使得Go工具可以自动找到、构建和安装已编译的二进制文件。此外，Go工具依赖于`workspace`设置来从远程存储库（如Git、Mercurial和Subversion）中拉取源代码包，并满足其依赖关系。
- en: Strongly typed
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强类型
- en: 'All values in Go are statically typed. However, the language offers a simple
    but expressive type system that can have the feel of a dynamic language. For instance,
    types can be safely inferred as shown in the following code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的所有值都是静态类型的。但是，该语言提供了一个简单但富有表现力的类型系统，可以具有动态语言的感觉。例如，类型可以像下面的代码片段中那样被安全地推断出来：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you would expect, constant grams would be assigned a numeric type, `float64`,
    to be precise, by the Go type system. This is true not only for constants, but
    any variable can use a short-hand form of declaration and assignment as shown
    in the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的，常量克会被Go类型系统分配一个数值类型，准确地说是`float64`。这不仅适用于常量，而且任何变量都可以使用声明和赋值的简写形式，就像下面的示例中所示的那样：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that the variables, in the previous code snippet, are not explicitly
    assigned a type. Instead, the type system assigns each variable a type based on
    the literal value in the assignment. [Chapter 2](ch02.html "Chapter 2. Go Language
    Essentials"), *Go Language Essentials* and [Chapter 4](ch04.html "Chapter 4. Data
    Types"), *Data Types*, go into more details regarding Go types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码片段中，变量没有明确分配类型。相反，类型系统根据赋值中的文字值为每个变量分配类型。[第2章](ch02.html "第2章。Go语言基础")*Go语言基础*和[第4章](ch04.html
    "第4章。数据类型")*数据类型*更详细地介绍了Go类型。
- en: Composite types
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合类型
- en: 'Besides the types for simple values, Go also supports composite types such
    as `array`, `slice`, and `map`. These types are designed to store indexed elements
    of values of a specified type. For instance, the `metalloid` example shown previously
    makes use of a slice, which is a variable-sized array. The variable `metalloid`
    is declared as a `slice` to store a collection of the type `metalloid`. The code
    uses the literal syntax to combine the declaration and assignment of a `slice`
    of type `metalloid`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单值的类型之外，Go还支持复合类型，如`array`、`slice`和`map`。这些类型旨在存储指定类型的索引元素的值。例如，前面显示的`metalloid`示例使用了一个`slice`，它是一个可变大小的数组。变量`metalloid`被声明为一个`slice`，用于存储类型为`metalloid`的集合。该代码使用文字语法来组合声明和赋值一个`slice`类型的`metalloid`：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Go also supports a `struct` type which is a composite that stores named elements
    called fields as shown in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Go还支持`struct`类型，它是一个存储名为字段的命名元素的复合类型，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous example uses the literal syntax to declare `struct{name string;
    diameter int}` with the value `{"earth", 12742}`. You can read all about composite
    types in [Chapter 7](ch07.html "Chapter 7. Composite Types"), *Composite Types*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用文字语法声明了`struct{name string; diameter int}`，其值为`{"earth", 12742}`。您可以在[第7章](ch07.html
    "第7章。复合类型")*复合类型*中了解有关复合类型的所有信息。
- en: The named type
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名类型
- en: 'As discussed, Go provides a healthy set of built-in types, both simple and
    composite. Go programmers can also define new named types based on an existing
    underlying type as shown in the following snippet extracted from `metalloid` in
    the earlier example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如讨论的那样，Go提供了一组健全的内置类型，包括简单类型和复合类型。Go程序员还可以根据现有基础类型定义新的命名类型，就像在前面的示例中从`metalloid`中提取的代码片段所示的那样：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The previous snippet shows the definition of two named types, one called `amu`,
    which uses type `float64` as its underlying type. Type `metalloid`, on the other
    hand, uses a `struct` composite type as its underlying type, allowing it to store
    values in an indexed data structure. You can read more about declaring new named
    types in [Chapter 4](ch04.html "Chapter 4. Data Types"), *Data Types*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示了两个命名类型的定义，一个称为`amu`，它使用`float64`类型作为其基础类型。另一方面，类型`metalloid`使用`struct`复合类型作为其基础类型，允许它在索引数据结构中存储值。您可以在[第4章](ch04.html
    "第4章。数据类型")*数据类型*中了解更多关于声明新命名类型的信息。
- en: Methods and objects
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法和对象
- en: Go is not an object-oriented language in a classical sense. Go types do not
    use a class hierarchy to model the world as is the case with other object-oriented
    languages. However, Go can support the object-based development idiom, allowing
    data to receive behaviors. This is done by attaching functions, known as methods,
    to named types.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Go并不是传统意义上的面向对象语言。Go类型不使用类层次结构来模拟世界，这与其他面向对象的语言不同。但是，Go可以支持基于对象的开发习惯，允许数据接收行为。这是通过将函数（称为方法）附加到命名类型来实现的。
- en: 'The following snippet, extracted from the metalloid example, shows the type
    `amu` receiving a method called `float()` that returns the mass as a `float64`
    value:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从metalloid示例中提取的以下代码片段显示了类型`amu`接收了一个名为`float()`的方法，该方法返回`float64`值作为质量：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The power of this concept is explored in detail in [Chapter 8](ch08.html "Chapter 8. Methods,
    Interfaces, and Objects"), *Methods, Interfaces, and Objects*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念的强大之处在[第8章](ch08.html "第8章。方法、接口和对象")*方法、接口和对象*中得到了详细探讨。
- en: Interfaces
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: Go supports the notion of a programmatic interface. However, as you will see
    in [Chapter 8](ch08.html "Chapter 8. Methods, Interfaces, and Objects"), *Methods,
    Interfaces, and Objects*, the Go interface is itself a type that aggregates a
    set of methods that can project capabilities onto values of other types. Staying
    true to its simplistic nature, implementing a Go interface does not require a
    keyword to explicitly declare an interface. Instead, the type system implicitly
    resolves implemented interfaces using the methods attached to a type.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持程序接口的概念。但是，正如您将在[第8章](ch08.html "第8章。方法、接口和对象")，“方法、接口和对象”中看到的，Go接口本身是一种类型，它聚合了一组可以将能力投射到其他类型值上的方法。忠实于其简单的本质，实现Go接口不需要使用关键字显式声明接口。相反，类型系统通过附加到类型的方法隐式解析实现的接口。
- en: 'For instance, Go includes the built-in interface called `Stringer`, defined
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Go包括名为`Stringer`的内置接口，定义如下：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Any type that has the method `String()` attached, automatically implements
    the `Stringer` interface. So, modifying the definition of the type `metalloid`,
    from the previous program, to attach the method `String()` will automatically
    implement the `Stringer` interface:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有附加`String()`方法的类型都会自动实现`Stringer`接口。因此，修改前一个程序中类型`metalloid`的定义，以附加`String()`方法将自动实现`Stringer`接口：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: golang.fyi/ch01/metalloids2.go
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch01/metalloids2.go
- en: 'The `String()` methods return a pre-formatted string that represents the value
    of a `metalloid`. The function `Print()`, from the standard library package `fmt`,
    will automatically call the method `String()`, if its parameter implements `stringer`.
    So, we can use this fact to print `metalloid` values as follow:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`String()`方法返回表示`metalloid`值的预格式化字符串。标准库包`fmt`中的`Print()`函数将自动调用方法`String()`，如果其参数实现了`stringer`。因此，我们可以利用这一点将`metalloid`值打印如下：'
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Again, refer to [Chapter 8](ch08.html "Chapter 8. Methods, Interfaces, and Objects"),
    *Methods, Interfaces, and Objects*, for a thorough treatment of the topic of interfaces.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次参考[第8章](ch08.html "第8章。方法、接口和对象")，“方法、接口和对象”，对接口主题进行深入讨论。
- en: Concurrency and channels
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发和通道
- en: One of the main features that has rocketed Go to its current level of adoption
    is its inherent support for simple concurrency idioms. The language uses a unit
    of concurrency known as a `goroutine`, which lets programmers structure programs
    with independent and highly concurrent code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将Go推向当前采用水平的主要特性之一是其固有支持简单并发习语。该语言使用一种称为`goroutine`的并发单元，它允许程序员使用独立和高度并发的代码结构化程序。
- en: 'As you will see in the following example, Go also relies on a construct known
    as a channel used for both communication and coordination among independently
    running `goroutines`. This approach avoids the perilous and (sometimes brittle)
    traditional approach of thread communicating by sharing memory. Instead, Go facilitates
    the approach of sharing by communicating using channels. This is illustrated in
    the following example that uses both `goroutines` and channels as processing and
    communication primitives:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在以下示例中看到的，Go还依赖于一种称为通道的构造，用于独立运行的`goroutine`之间的通信和协调。这种方法避免了通过共享内存进行线程通信的危险和（有时脆弱的）传统方法。相反，Go通过使用通道促进了通过通信共享的方法。下面的示例说明了使用`goroutine`和通道作为处理和通信原语：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: golang.fyi/ch01/euler1.go
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch01/euler1.go
- en: The code in the previous example splits the work to be done between two concurrently
    running `goroutines` (declared with the `go` keyword) as annotated in the code
    comment. Each `goroutine` runs independently and uses the Go channels, `work`
    and `result`, to communicate and coordinate the calculation of the final result.
    Again, if this code does not make sense at all, rest assured, concurrency has
    the whole of [Chapter 9](ch09.html "Chapter 9. Concurrency"), *Concurrency*, dedicated
    to it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的代码将要做的工作分成了两个并发运行的`goroutine`（使用`go`关键字声明），如代码注释所示。每个`goroutine`都独立运行，并使用Go通道`work`和`result`来通信和协调计算最终结果。再次强调，如果这段代码一点也不清楚，放心，整个[第9章](ch09.html
    "第9章。并发")，“并发”都专门讨论了并发。
- en: Memory management and safety
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理和安全性
- en: Similar to other compiled and statically-typed languages such as C and C++,
    Go lets developers have direct influence on memory allocation and layout. When
    a developer creates a `slice` (think `array`) of bytes, for instance, there is
    a direct representation of those bytes in the underlying physical memory of the
    machine. Furthermore, Go borrows the notion of pointers to represent the memory
    addresses of stored values giving Go programs the support of passing function
    parameters by both value and reference.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编译和静态类型语言（如C和C++）类似，Go允许开发人员直接影响内存分配和布局。例如，当开发人员创建字节的`slice`（类似`array`）时，这些字节在机器的底层物理内存中有直接的表示。此外，Go借用指针的概念来表示存储值的内存地址，使得Go程序可以支持通过值和引用传递函数参数。
- en: Go asserts a highly opinionated safety barrier around memory management with
    little to no configurable parameters. Go automatically handles the drudgery of
    bookkeeping for memory allocation and release using a runtime garbage collector.
    Pointer arithmetic is not permitted at runtime; therefore, developers cannot traverse
    memory blocks by adding to or subtracting from a base memory address.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Go在内存管理周围设定了高度主观的安全屏障，几乎没有可配置的参数。Go使用运行时垃圾收集器自动处理内存分配和释放的繁琐工作。指针算术在运行时不被允许；因此，开发人员不能通过增加或减少基本内存地址来遍历内存块。
- en: Fast compilation
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速编译
- en: Another one of Go's attractions is its millisecond build-time for moderately-sized
    projects. This is made possible with features such as a simple syntax, conflict-free
    grammar, and a strict identifier resolution that forbids unused declared resources
    such as imported packages or variables. Furthermore, the build system resolves
    packages using transitivity information stored in the closest source node in the
    dependency tree. Again, this reduces the code-compile-run cycle to feel more like
    a dynamic language instead of a compiled language.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Go的另一个吸引力是对中等规模项目的毫秒级构建时间。这得益于诸如简单的语法、无冲突的语法和严格的标识符解析等功能，这些功能禁止未使用的声明资源，如导入的包或变量。此外，构建系统使用依赖树中最近的源节点中存储的传递性信息来解析包。这再次使得代码-编译-运行周期更像是动态语言而不是编译语言。
- en: Testing and code coverage
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和代码覆盖
- en: While other languages usually rely on third-party tools for testing, Go includes
    both a built-in API and tools designed specifically for automated testing, benchmarking,
    and code coverage. Similar to other features in Go, the test tools use simple
    conventions to automatically inspect and instrument the test functions found in
    your code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其他语言通常依赖于第三方工具进行测试，但Go包括专门用于自动化测试、基准测试和代码覆盖的内置API和工具。与Go中的其他功能类似，测试工具使用简单的约定自动检查和检测代码中找到的测试函数。
- en: 'The following function is a simplistic implementation of the Euclidean division
    algorithm that returns a quotient and a remainder value (as variables `q` and
    `r`) for positive integers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是欧几里德除法算法的简单实现，返回正整数的商和余数值（作为变量`q`和`r`）：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: golang.fyi/ch01/testexample/divide.go
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch01/testexample/divide.go
- en: 'In a separate source file, we can write a test function to validate the algorithm
    by checking the remainder value returned by the tested function using the Go test
    API as shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在单独的源文件中，我们可以编写一个测试函数，通过使用Go测试API检查被测试函数返回的余数值来验证算法，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: golang.fyi/ch01/testexample/divide_test.go
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch01/testexample/divide_test.go
- en: 'To exercise the test source code, simply run Go''s test tool as shown in the
    following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试源代码，只需按照以下示例运行Go的测试工具：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The test tool reports a summary of the test result indicating the package that
    was tested and its pass/fail outcome. The Go Toolchain comes with many more features
    designed to help programmers create testable code, including:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工具报告测试结果的摘要，指示已测试的包及其通过/失败的结果。Go工具链配备了许多其他功能，旨在帮助程序员创建可测试的代码，包括：
- en: Automatically instrument code to gather coverage statistics during tests
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试期间自动检测代码以收集覆盖统计信息
- en: Generating HTML reports for covered code and tested paths
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成覆盖代码和测试路径的HTML报告
- en: A benchmark API that lets developers collect performance metrics from tests
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基准API，允许开发人员从测试中收集性能指标
- en: Benchmark reports with valuable metrics for detecting performance issues
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有有价值的指标的基准报告，用于检测性能问题
- en: You can read all about testing and its related tools in [Chapter 12](ch12.html
    "Chapter 12. Code Testing"), *Code Testing*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[第12章](ch12.html "第12章。代码测试")*代码测试*中了解有关测试及其相关工具的所有信息。
- en: Documentation
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档
- en: 'Documentation is a first-class component in Go. Arguably, the language''s popularity
    is in part due to its extensive documentation (see [http://golang.org/pkg](http://golang.org/pkg)).
    Go comes with the Godoc tool, which makes it easy to extract documentation from
    comment text embedded directly in the source code. For example, to document the
    function from the previous section, we simply add comment lines directly above
    the `DivMod` function as shown in the following example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 文档在Go中是一流的组件。可以说，该语言的流行部分原因是其广泛的文档（参见[http://golang.org/pkg](http://golang.org/pkg)）。Go配备了Godoc工具，可以轻松地从源代码中直接嵌入的注释文本中提取文档。例如，要为上一节中的函数编写文档，我们只需在`DivMod`函数上方直接添加注释行，如下例所示：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The Go documentation tool can automatically extract and create HTML-formatted
    pages. For instance, the following command will start the Godoc tool as a server
    on `localhost port 6000`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Go文档工具可以自动提取和创建HTML格式的页面。例如，以下命令将在`localhost端口6000`上启动Godoc工具作为服务器：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can then access the documentation of your code directly from your web browser.
    For instance, the following figure shows the generated documentation snippet for
    the previous function located at `http://localhost:6001/pkg/github.com/vladimirvivien/learning-go/ch01/testexample/`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以直接从Web浏览器访问代码的文档。例如，以下图显示了位于`http://localhost:6001/pkg/github.com/vladimirvivien/learning-go/ch01/testexample/`的先前函数的生成文档片段：
- en: '![Documentation](img/image_01_003.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![文档](img/image_01_003.jpg)'
- en: An extensive library
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个广泛的库
- en: 'For its short existence, Go rapidly grew a collection of high-quality APIs
    as part of its standard library that are comparable to other popular and more
    established languages. The following, by no means exhaustive, lists some of the
    core APIs that programmers get out-of-the-box:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在其短暂的存在中，Go迅速发展了一套高质量的API集合，作为其标准库的一部分，这些API与其他流行和更成熟的语言相媲美。以下列出了一些核心API的列表，当然这并不是详尽无遗的：
- en: Complete support for regular expressions with search and replace
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全支持具有搜索和替换功能的正则表达式
- en: Powerful IO primitives for reading and writing bytes
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于读写字节的强大IO原语
- en: Full support for networking from socket, TCP/UDP, IPv4, and IPv6
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全支持网络编程，包括套接字、TCP/UDP、IPv4和IPv6
- en: APIs for writing production-ready HTTP services and clients
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编写生产就绪的HTTP服务和客户端的API
- en: Support for traditional synchronization primitives (mutex, atomic, and so on)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持传统的同步原语（互斥锁、原子等）
- en: General-purpose template framework with HTML support
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有HTML支持的通用模板框架
- en: Support for JSON/XML serializations
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持JSON/XML序列化
- en: RPC with multiple wire formats
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有多种传输格式的RPC
- en: 'APIs for archive and compression algorithms: `tar`, `zip`/`gzip`, `zlib`, and
    so on'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存档和压缩算法的API：`tar`，`zip`/`gzip`，`zlib`等
- en: Cryptography support for most major algorithms and hash functions
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数主要算法和哈希函数的加密支持
- en: Access to OS-level processes, environment info, signaling, and much more
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问操作系统级别的进程、环境信息、信号等等
- en: The Go Toolchain
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 工具链
- en: 'Before we end the chapter, one last aspect of Go that should be highlighted
    is its collection of tools. While some of these tools were already mentioned in
    previous sections, others are listed here for your awareness:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，应该强调 Go 的一个方面，那就是它的工具集。虽然本章的前几节已经提到了一些工具，但其他工具在这里列出以供您了解：
- en: '`fmt`: Reformats source code to adhere to the standard'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt`：重新格式化源代码以符合标准'
- en: '`vet`: Reports improper usage of source code constructs'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vet`：报告源代码构造的不当使用'
- en: '`lint`: Another source code tool that reports flagrant style infractions'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lint`：另一个源代码工具，报告 flagrant 风格违规'
- en: '`goimports`: Analyzes and fixes package import references in source code'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goimports`：分析和修复源代码中的包导入引用'
- en: '`godoc`: Generates and organizes source code documentation'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`godoc`：生成和组织源代码文档'
- en: '`generate`: Generates Go source code from directives stored in source code'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate`：从存储在源代码中的指令生成 Go 源代码'
- en: '`get`: Remotely retrieves and installs packages and their dependencies'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`：远程检索和安装包及其依赖项'
- en: '`build`: Compiles code in a specified package and its dependencies'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：编译指定包及其依赖项中的代码'
- en: '`run`: Provides the convenience of compiling and running your Go program'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`：提供编译和运行您的 Go 程序的便利'
- en: '`test`: Performs unit tests with support for benchmark and coverage reports'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：执行单元测试，并支持基准和覆盖率报告'
- en: '`oracle` static analysis tool: Queries source code structures and elements'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oracle` 静态分析工具：查询源代码结构和元素'
- en: '`cgo`: Generates source code for interoperability between Go and C'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cgo`：生成用于 Go 和 C 之间互操作性的源代码'
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Within its relatively short existence, Go has won the hearts of many adopters
    who value simplicity as a way to write code that is exact and is able to scale
    in longevity. As you have seen from the previous sections in this chapter, it
    is easy to get started with your first Go program.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在其相对较短的存在期内，Go 已经赢得了许多重视简单性的采用者的心。正如您从本章的前几节中所看到的，很容易开始编写您的第一个 Go 程序。
- en: The chapter also exposed its readers to a high-level summary of the most essential
    features of Go including its simplified syntax, its emphasis on concurrency, and
    the tools that make Go a top choice for software engineers, creating systems for
    the age of data center computing. As you may imagine, this is just a taste of
    what's to come.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还向读者介绍了 Go 最重要特性的高级摘要，包括其简化的语法、对并发性的强调以及使 Go 成为软件工程师首选的工具，为数据中心计算时代创建系统。正如您所想象的那样，这只是即将到来的一小部分。
- en: In the following chapters, the book will continue to explore in detail the syntactical
    elements and language concepts that make Go a great language to learn. Let's Go!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，本书将继续详细探讨使 Go 成为一个很棒的学习语言的语法元素和语言概念。让我们开始吧！
