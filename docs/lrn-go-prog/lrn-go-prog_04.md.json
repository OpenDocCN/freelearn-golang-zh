["```go\npackage main \nimport ( \n   \"fmt\" \n   \"unsafe\" \n) \n\nvar ( \n   a uint8   = 72 \n   b int32   = 240 \n   c uint64  = 1234564321 \n   d float32 = 12432345.232 \n   e int64   = -1233453443434 \n   f float64 = -1.43555622362467 \n   g int16   = 32000 \n   h [5]rune = [5]rune{'O', 'n', 'T', 'o', 'p'} \n) \n\nfunc main() { \n   fmt.Printf(\"a = %v [%T, %d bits]\\n\", a, a, unsafe.Sizeof(a)*8) \n   fmt.Printf(\"b = %v [%T, %d bits]\\n\", b, b, unsafe.Sizeof(b)*8) \n   fmt.Printf(\"c = %v [%T, %d bits]\\n\", c, c, unsafe.Sizeof(c)*8) \n   fmt.Printf(\"d = %v [%T, %d bits]\\n\", d, d, unsafe.Sizeof(d)*8) \n   fmt.Printf(\"e = %v [%T, %d bits]\\n\", e, e, unsafe.Sizeof(e)*8) \n   fmt.Printf(\"f = %v [%T, %d bits]\\n\", f, f, unsafe.Sizeof(f)*8) \n   fmt.Printf(\"g = %v [%T, %d bits]\\n\", g, g, unsafe.Sizeof(g)*8) \n   fmt.Printf(\"h = %v [%T, %d bits]\\n\", h, h, unsafe.Sizeof(h)*8) \n} \n\n```", "```go\n$>go run alloc.go\na = 72 [uint8, 8 bits]\nb = 240 [int32, 32 bits]\nc = 1234564321 [uint64, 64 bits]\nd = 1.2432345e+07 [float32, 32 bits]\ne = -1233453443434 [int64, 64 bits]\nf = -1.43555622362467 [float64, 64 bits]\ng = 32000 [int16, 16 bits]\nh = [79 110 84 111 112] [[5]int32, 160 bits]\n\n```", "```go\npackage main \nimport ( \n   \"math\" \n   \"unsafe\" \n) \n\nvar _ int8 = 12 \nvar _ int16 = -400 \nvar _ int32 = 12022 \nvar _ int64 = 1 << 33 \nvar _ int = 3 + 1415 \n\nvar _ uint8 = 18 \nvar _ uint16 = 44 \nvar _ uint32 = 133121 \nvar i uint64 = 23113233 \nvar _ uint = 7542 \nvar _ byte = 255 \nvar _ uintptr = unsafe.Sizeof(i) \n\nvar _ float32 = 0.5772156649 \nvar _ float64 = math.Pi \n\nvar _ complex64 = 3.5 + 2i \nvar _ complex128 = -5.0i \n\nfunc main() { \n   fmt.Println(\"all types declared!\") \n} \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc main() { \n   vals := []int{ \n       1024, \n       0x0FF1CE, \n       0x8BADF00D, \n       0xBEEF, \n       0777, \n   } \n   for _, i := range vals { \n         if i == 0xBEEF { \n               fmt.Printf(\"Got %d\\n\", i) \n               break \n         } \n   } \n} \n\n```", "```go\npackage main \n\nimport \"fmt\" \n\nfunc main() { \n   p := 3.1415926535 \n   e := .5772156649 \n   x := 7.2E-5 \n   y := 1.616199e-35 \n   z := .416833e32 \n\n   fmt.Println(p, e, x, y, z) \n} \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc main() { \n   a := -3.5 + 2i \n   fmt.Printf(\"%v\\n\", a) \n   fmt.Printf(\"%+g, %+g\\n\", real(a), imag(a)) \n} \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc main() { \n   var readyToGo bool = false \n   if !readyToGo { \n       fmt.Println(\"Come on\") \n   } else { \n       fmt.Println(\"Let's go!\") \n   } \n} \n\n```", "```go\n$>go run runes.go\n8\n9\n10\n632\n2438\n35486\n873\n250\n37 \n\n```", "```go\nvar ( \n   txt2 = \"\\u6C34\\x20brings\\x20\\x6c\\x69\\x66\\x65.\" \n   txt3 = ` \n   \\u6C34\\x20 \n   brings\\x20 \n   \\x6c\\x69\\x66\\x65\\. \n   ` \n) \n\n```", "```go`. This creates what is known as a raw string in Go. Raw string values are uninterpreted where escape sequences are ignored and all valid characters are encoded as they appear in the literal.\n\nWhen variable `txt3` is printed, it produces the following output:\n\n```", "```go\n\nNotice that the printed string contains all the backslash-escaped values as they appear in the original string literal. Uninterpreted string literals are a great way to embed large multi-line textual content within the body of a source code without breaking its syntax.\n\n# Pointers\n\nIn Go, when a piece of data is stored in memory, the value for that data may be accessed directly or a pointer may be used to reference the memory address where the data is located. As with other C-family languages, pointers in Go provide a level of indirection that let programmers process data more efficiently without having to copy the actual data value every time it is needed.\n\nUnlike C, however, the Go runtime maintains control of the management of pointers at runtime. A programmer cannot add an arbitrary integer value to the pointer to generate a new pointer address (a practice known as pointer arithmetic). Once an area of memory is referenced by a pointer, the data in that area will remain reachable until it is no longer referenced any pointer variable. At that point, the unreferenced value becomes eligible for garbage collection.\n\n## The pointer type\n\nSimilar to C/C++, Go uses the `*` operator to designate a type as a pointer. The following snippet shows several pointers with different underlying types:\n\n```", "```go\n\ngolang.fyi/ch04/pointers.go\n\nGiven a variable of type `T`, Go uses expression `*T`\u00a0as its pointer type. The type system considers `T` and `*T` as distinct and are\u00a0not fungible. The zero value of a pointer, when it is not pointing to anything, is the address 0, represented by the literal *constant* nil.\n\n## The address operator\n\nPointer values can only be assigned addresses of their declared types. One way you can do so in Go is to use the address operator `&`(ampersand) to obtain the address value of a variable as shown in the following example:\n\n```", "```go\n\ngolang.fyi/ch04/pointers.go\n\nVariable `aptr`, of pointer type `*int`, is initialized and assigned the address value of variable `a` using expression `&a` as listed here:\n\n```", "```go\n\nWhile variable `a` stores the actual value, we say that `aptr` points to `a`. The following shows the output of the program with the value of variable `a` and its memory location assigned to `aptr`:\n\n```", "```go\n\nThe assigned address value will always be the same (always pointing to `a`) regardless of where `aptr` may be accessed in the code. It is also worth noting that Go does not allow the use of the address operator with literal constant for numeric, string, and bool types. Therefore, the following will not compile:\n\n```", "```go\n\nThere is a syntactical exception to this rule, however, when initializing composite types such as struct and array with literal constants. The following program illustrates such scenarios:\n\n```", "```go\n\ngolang.fyi/ch04/address2.go\n\nIn the previous code snippet, the address operator is used directly with composite literal `&struct{ x, y int }{44, 55}` and `&[2]string{\"A\", \"B\"}` to return pointer types `*struct { x int; y int }` and `*[2]string` respectively. This is a bit of syntactic sugar that eliminates the intermediary step of assigning the values to a variable, then retrieving their assigned addresses.\n\n## The new() function\n\nThe built-in function *new(<type>)* can also be used to initialize a pointer value. It first allocates the appropriate memory for a zero-value of the specified type. The function then returns the address for the newly created value. The following program uses the `new()` function to initialize variables `intptr` and `p`:\n\n```", "```go\n\ngolang.fyi/ch04/newptr.go\n\nVariable `intptr` is initialized as `*int` and `p` as `*struct{first, last string}`. Once initialized, both values are updated accordingly later in the code. You can use the `new()` function to initialize pointer variables with zero values when the actual values are not available at the time of initialization.\n\n## Pointer indirection - accessing referenced values\n\nIf all you have is an address, you can access the value to which it points by applying the `*` operator to the pointer value itself (or dereferencing). The following program illustrates this idea in functions `double()` and `cap()`:\n\n```", "```go\n\ngolang.fyi/ch04/derefptr.go\n\nIn the preceding code, the expression `*x = *x * 2`, in function `double()`, can be decomposed as follows to understand how it works:\n\n| **Expression** | **Step** |\n|  \n```", "```go\n\n | Original expression where `x` is of type `*int`. |\n|  \n```", "```go\n\n | Dereferencing pointers by applying `*` to address values. |\n|  \n```", "```go\n\n | Dereferenced value of `*(*x) = 3`. |\n|  \n```", "```go\n\n | The right side of this expression dereferences the value of `x`. It is updated with the result 6. |\n\nIn function `cap()`, a similar approach is used to access and update fields in composite variable `p` of type `struct{first, last string}`. However, when dealing with composites, the idiom is more forgiving. It is not necessary to write `*p.first` to access the pointer's field value. We can drop the `*` and just use `p.first = strings.ToUpper(p.first).`\n\n# Type declaration\n\nIn Go, it is possible to bind a type to an identifier to create a new named type that can be referenced and used wherever the type is needed. Declaring a type takes the general format as follows:\n\n*type <name identifier> <underlying type name>*\n\nThe type declaration starts with the keyword `type` followed by a *name identifier\u00a0*and the name of an existing *underlying type*. The underlying type can be a built-in named type such as one of the numeric types, a Boolean, or a string type as shown in the following snippet of type declarations:\n\n```", "```go\n\n### Note\n\nA type declaration can also use a composite *type literal* as its underlying type. Composite types include array, slice, map, and struct. This section focuses on non-composite types. For further details on composite types, refer to [Chapter 7](ch07.html \"Chapter\u00a07.\u00a0Composite Types\"), *Composite Types*.\n\nThe following sample illustrates how named types work in their most basic forms. The code in the example converts temperature values. Each temperature unit is represented by a declared type including `fahrenheit`, `celsius`, and `kelvin`.\n\n```", "```go\n\ngolang.fyi/ch04/typedef.go\n\nIn the preceding code snippet, the new declared types are all based on the underlying built-in numeric type `float64`. Once the new type has been declared, it can be assigned to variables and participate in expressions just like its underlying type. The newly declared type will have the same zero-value and can be converted to and from its underlying type.\n\n# Type conversion\n\nIn general, Go considers each type to be different. This means under normal circumstances, values of different types are not fungible in assignment, function parameters, and expression contexts. This is true for built-in and declared types. For instance, the following will cause a build error due to type mismatch:\n\n```", "```go\n\ngolang.fyi/ch04/type_conv.go\n\nThe expression `actual + count` causes a build time error because both variables are of different types. Even though variables `actual` and `count` are of numeric types and `int32` and `int` have the same memory representation, the compiler still rejects the expression.\n\nThe same is true for declared named types and their underlying types. The compiler will reject assignment `var event int = sig` because type `signal` is considered to be different from type `int`. This is true even though `signal` uses `int` as its underlying type.\n\nTo cross type boundaries, Go supports a type conversion expression that converts value from one type to another. Type conversion is done using the following format:\n\n*<target_type>(<value or expression>)*\n\nThe following code snippet fixes the previous example by converting the variables to the proper types:\n\n```", "```go\n\ngolang.fyi/ch04/type_conv2.go\n\nNote that in the previous snippet assignment expression `var test int32 = int32(actual) + count` converts variable `actual` to the proper type to match the rest of the expression. Similarly, expression `var event int = int(sig)` converts variable `sig` to match the target type `int` in the assignment.\n\nThe conversion expressions satisfy the assignment by explicitly changing the type of the enclosing values. Obviously, not all types can be converted from one to another. The following table summarizes common scenarios when type conversion is appropriate and allowed:\n\n| **Description** | **Code** |\n| The target type and converted value are both simple numeric types. |  \n```", "```go\n\n |\n| The target type and the converted value are both complex numeric types. |  \n```", "```go\n\n |\n| The target type and converted value have the same underlying types. |  \n```", "```go\n\n |\n| The target type is a string and the converted value is a valid integer type. |  \n```", "```go\n\n |\n| The target type is string and the converted value is a slice of bytes, int32, or runes. |  \n```", "```go\n\n |\n| The target type is a slice of byte, int32, or rune values and the converted value is a string. |  \n```"]