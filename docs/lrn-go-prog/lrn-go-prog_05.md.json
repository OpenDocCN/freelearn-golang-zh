["```go\npackage main import (\n\u00a0 \"fmt\"\n \u00a0\"math\"\n)func printPi() {\n  fmt.Printf(\"printPi()\n    %v\\n\", math.Pi)\n} func main() {\n  printPi() }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (\"fmt\" \"math\" ) func\nprintPi() {\n  fmt.Printf(\"printPi()\n    %v\\n\", math.Pi)\n}\nfunc main() { printPi() }\n```", "```go\npackage main   \nimport \"fmt\"   \n\nfunc avogadro() float64 {   \n   return 6.02214129e23   \n}   \n\nfunc main() {   \n   fmt.Printf(\"avogadro()\n   = %e 1/mol\\n\",   \n   avogadro())   \n}   \n\n```", "```go\npackage main   \nimport \"fmt\"    \nfunc fib(n int) {   \n  fmt.Printf(\"fib(%d):\n    [\", n)\n  var p0, p1 uint64 = 0,\n    1   \n  fmt.Printf(\"%d %d \",\n    p0, p1)   \n  for i := 2; i <= n; i++\n  {   \n    p0, p1 = p1, p0+p1\n    fmt.Printf(\"%d \",p1)\n  }   \n  fmt.Println(\"]\")   \n}   \nfunc main() {   \n  fib(41)   \n}\n```", "```go\npackage main   \nimport (   \n  \"fmt\"   \n  \"math\"   \n)    \nfunc isPrime(n int) bool {   \n  lim :=\n  int(math.Sqrt\n  (float64(n)))\n  for p := 2; p <= lim;\n  p++ {\n    if (n % p) == 0 {   \n      return false   \n    }  }   \n  return true   \n}   \nfunc main() {   \n  prime := 37\n  fmt.Printf\n  (\"isPrime(%d)  =\n  %v\\n\", prime,\n  isPrime(prime))\n}\n```", "```go\nfunc main() { \n   fib(41) \n} \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc add(op0 int, op1 int) int { \n   return op0 + op1 \n} \n\nfunc sub(op0, op1 int) int { \n   return op0 - op1 \n} \n\nfunc main() { \n   var opAdd func(int, int) int = add \n   opSub := sub \n   fmt.Printf(\"op0(12,44)=%d\\n\", opAdd(12, 44)) \n   fmt.Printf(\"sub(99,13)=%d\\n\", opSub(99, 13)) \n}  \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc avg(nums ...float64) float64 { \n   n := len(nums) \n   t := 0.0 \n   for _, v := range nums { \n         t += v \n   } \n   return t / float64(n) \n} \n\nfunc sum(nums ...float64) float64 { \n   var sum float64 \n   for _, v := range nums { \n         sum += v \n   } \n   return sum \n} \n\nfunc main() { \n   fmt.Printf(\"avg([1, 2.5, 3.75]) =%.2f\\n\", avg(1, 2.5, 3.75)) \n   points := []float64{9, 4, 3.7, 7.1, 7.9, 9.2, 10} \n   fmt.Printf(\"sum(%v) = %.2f\\n\", points, sum(points...)) \n} \n\n```", "```go\nfmt.Printf(\"avg([1, 2.5, 3.75]) =%.2f\\n\", avg(1, 2.5, 3.75)))  \n\n```", "```go\npoints := []float64{9, 4, 3.7, 7.1, 7.9, 9.2, 10} \nfmt.Printf(\"sum(%v) = %f\\n\", points, sum(points...))  \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc div(op0, op1 int) (int, int) { \n   r := op0 \n   q := 0 \n   for r >= op1 { \n         q++ \n         r = r - op1 \n   } \n   return q, r \n} \n\nfunc main() { \n   q, r := div(71, 5) \n   fmt.Printf(\"div(71,5) -> q = %d, r = %d\\n\", q, r) \n} \n\n```", "```go\nq, r := div(71, 5) \nfmt.Printf(\"div(71,5) -> q = %d, r = %d\\n\", q, r) \n\n```", "```go\nfunc div(dvdn, dvsr int) (q, r int) { \n   r = dvdn \n   for r >= dvsr { \n         q++ \n         r = r - dvsr \n   } \n   return \n} \n\n```", "```go\npackage main \nimport ( \n   \"fmt\" \n   \"math\" \n) \n\nfunc dbl(val float64) { \n   val = 2 * val // update param \n   fmt.Printf(\"dbl()=%.5f\\n\", val) \n} \n\nfunc main() { \n   p := math.Pi \n   fmt.Printf(\"before dbl() p = %.5f\\n\", p) \n   dbl(p) \n   fmt.Printf(\"after dbl() p = %.5f\\n\", p) \n} \n\n```", "```go\n$> go run funcpassbyval.go\nbefore dbl() p = 3.14159\ndbl()=6.28319\nafter dbl() p = 3.14159\n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc half(val *float64) { \n   fmt.Printf(\"call half(%f)\\n\", *val) \n   *val = *val / 2 \n} \n\nfunc main() { \n   num := 2.807770 \n   fmt.Printf(\"num=%f\\n\", num) \n   half(&num) \n   fmt.Printf(\"half(num)=%f\\n\", num) \n} \n\n```", "```go\n$> go run funcpassbyref.go\nnum=2.807770\ncall half(2.807770)\nhalf(num)=1.403885\n\n```", "```go\npackage main \nimport \"fmt\" \n\nvar ( \n   mul = func(op0, op1 int) int { \n         return op0 * op1 \n   } \n\n   sqr = func(val int) int { \n         return mul(val, val) \n   } \n) \n\nfunc main() { \n   fmt.Printf(\"mul(25,7) = %d\\n\", mul(25, 7)) \n   fmt.Printf(\"sqr(13) = %d\\n\", sqr(13)) \n}  \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc main() { \n   fmt.Printf( \n         \"94 (\u00b0F) = %.2f (\u00b0C)\\n\", \n         func(f float64) float64 { \n               return (f - 32.0) * (5.0 / 9.0) \n         }(94), \n   ) \n} \n\n```", "```go\nfmt.Printf( \n   \"94 (\u00b0F) = %.2f (\u00b0C)\\n\", \n   func(f float64) float64 { \n         return (f - 32.0) * (5.0 / 9.0) \n   }(94), \n) \n\n```", "```go\npackage main \nimport ( \n   \"fmt\" \n   \"math\" \n) \n\nfunc main() { \n   for i := 0.0; i < 360.0; i += 45.0 { \n         rad := func() float64 { \n               return i * math.Pi / 180 \n         }() \n         fmt.Printf(\"%.2f Deg = %.2f Rad\\n\", i, rad) \n   } \n} \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc apply(nums []int, f func(int) int) func() { \n   for i, v := range nums { \n         nums[i] = f(v) \n   } \n   return func() { \n         fmt.Println(nums) \n   } \n} \n\nfunc main() { \n   nums := []int{4, 32, 11, 77, 556, 3, 19, 88, 422} \n   result := apply(nums, func(i int) int { \n         return i / 2 \n   }) \n   result() \n} \n\n```", "```go\nnums := []int{4, 32, 11, 77, 556, 3, 19, 88, 422} \nresult := apply(nums, func(i int) int { \n   return i / 2 \n}) \nresult() \n\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"bytes\" \n   \"fmt\" \n   \"os\" \n   \"errors\" \n) \n\n// sorts letters in a word (i.e. \"morning\" -> \"gimnnor\") \nfunc sortRunes(str string) string { \n   runes := bytes.Runes([]byte(str)) \n   var temp rune \n   for i := 0; i < len(runes); i++ { \n         for j := i + 1; j < len(runes); j++ { \n               if runes[j] < runes[i] { \n                     temp = runes[i] \n                     runes[i], runes[j] = runes[j], temp \n               } \n\n         } \n   } \n   return string(runes) \n} \n\n// load loads content of file fname into memory as []string \nfunc load(fname string) ([]string, error) { \n   if fname == \"\" { \n         return nil, errors.New( \n               \"Dictionary file name cannot be empty.\")  \n   } \n\n   file, err := os.Open(fname) \n   if err != nil { \n         return nil, err \n   } \n   defer file.Close() \n\n   var lines []string \n   scanner := bufio.NewScanner(file) \n   scanner.Split(bufio.ScanLines) \n   for scanner.Scan() { \n         lines = append(lines, scanner.Text()) \n   } \n   return lines, scanner.Err() \n} \n\nfunc main() { \n   words, err := load(\"dict.txt\")       \n   if err != nil { \n         fmt.Println(\"Unable to load file:\", err) \n         os.Exit(1) \n   } \n\n      anagrams := make(map[string][]string) \n   for _, word := range words { \n         wordSig := sortRunes(word) \n         anagrams[wordSig] = append(anagrams[wordSig], word) \n   } \n\n   for k, v := range anagrams { \n         fmt.Println(k, \"->\", v) \n   } \n} \n\n```", "```go\nfunc load(fname string) ([]string, error) { \n   if fname == \"\" { \n       return nil, errors.New( \n         \"Dictionary file name cannot be empty.\")  \n   } \n\n   file, err := os.Open(fname) \n   if err != nil { \n         return nil, err \n   } \n   ... \n} \n\n```", "```go\nfunc main() { \n   words, err := load(\"dict.txt\") \n   if err != nil { \n         fmt.Println(\"Unable to load file:\", err) \n         os.Exit(1) \n   } \n   ... \n} \n\n```", "```go\nerrors.New(\"Dictionary file name cannot be empty.\")  \n\n```", "```go\nfunc load(fname string) ([]string, error) { \n   if fname == \"\" { \n         return nil, errors.New( \n             \"Dictionary file name cannot be emtpy.\") \n   } \n\n   file, err := os.Open(fname) \n   if err != nil { \n         return nil, fmt.Errorf( \n             \"Unable to open file %s: %s\", fname, err) \n   } \n   ... \n} \n\n```", "```go\nvar ( \n   ErrInvalid    = errors.New(\"invalid argument\") \n   ErrPermission = errors.New(\"permission denied\") \n   ErrExist      = errors.New(\"file already exists\") \n   ErrNotExist   = errors.New(\"file does not exist\") \n) \n\n```", "```go\npackage main \nimport \"fmt\" \n\nfunc do(steps ...string) { \n   defer fmt.Println(\"All done!\") \n   for _, s := range steps { \n         defer fmt.Println(s) \n   } \n\n   fmt.Println(\"Starting\") \n} \n\nfunc main() { \n   do( \n         \"Find key\", \n         \"Aplly break\", \n         \"Put key in ignition\", \n         \"Start car\", \n   ) \n} \n\n```", "```go\n$> go run defer1.go\nStarting\nStart car\nPut key in ignition\nAplly break\nFind key\nAll done!\n\n```", "```go\nfunc load(fname string) ([]string, error) { \n... \n   file, err := os.Open(fname) \n   if err != nil { \n         return nil, err \n   } \n   defer file.Close() \n... \n} \n\n```", "```go\npackage main \n... \nfunc write(fname string, anagrams map[string][]string) { \n   file, err := os.OpenFile( \n         fname,  \n         os.O_WRONLY+os.O_CREATE+os.O_EXCL,  \n         0644, \n   ) \n   if err != nil { \n         msg := fmt.Sprintf( \n               \"Unable to create output file: %v\", err, \n         ) \n         panic(msg) \n   } \n   ... \n} \n\nfunc main() { \n   words, err := load(\"dict.txt\") \n   if err != nil { \n         fmt.Println(\"Unable to load file:\", err) \n         os.Exit(1) \n   } \n   anagrams := mapWords(words) \n   write(\"out.txt\", anagrams) \n} \n\n```", "```go\n> go run anagram2.go \npanic: Unable to create output file: open out.txt: file exists\ngoroutine 1 [running]:\nmain.write(0x4e7b30, 0x7, 0xc2080382a0)\n/Go/src/github.com/vladimirvivien/learning-go/ch05/anagram2.go:72 +0x1a3 \nmain.main()\nGo/src/github.com/vladimirvivien/learning-go/ch05/anagram2.go:103 +0x1e9\nexit status 2\n\n```", "```go\npackage main \n... \nfunc write(fname string, anagrams map[string][]string) { \n   file, err := os.OpenFile( \n         fname,  \n         os.O_WRONLY+os.O_CREATE+os.O_EXCL,  \n         0644, \n   ) \n   if err != nil { \n         msg := fmt.Sprintf( \n               \"Unable to create output file: %v\", err, \n         ) \n         panic(msg) \n   } \n   ... \n} \n\nfunc makeAnagrams(words []string, fname string) { \n   defer func() { \n         if r := recover(); r != nil { \n               fmt.Println(\"Failed to make anagram:\", r) \n         } \n   }() \n\n   anagrams := mapWords(words) \n   write(fname, anagrams) \n} \nfunc main() { \n   words, err := load(\"\") \n   if err != nil { \n         fmt.Println(\"Unable to load file:\", err) \n         os.Exit(1) \n   } \n   makeAnagrams(words, \"\") \n} \n\n```", "```go\ndefer func() { \n   if r := recover(); r != nil { \n         fmt.Println(\"Failed to make anagram:\", r) \n   } \n}() \n\n```", "```go\n> go run anagram3.go\nFailed to make anagram: Unable to open output file for creation: open out.txt: file exists\n\n```"]