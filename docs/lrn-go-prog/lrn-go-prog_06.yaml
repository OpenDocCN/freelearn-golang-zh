- en: Chapter 6. Go Packages and Programs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。Go包和程序
- en: '[Chapter 5](ch05.html "Chapter 5. Functions in Go"), *Functions in Go* covered
    functions, the elementary level of abstraction for code organization that makes
    code addressable and reusable. This chapter continues up the ladder of abstraction
    with a discussion centered around Go packages. As will be covered in detail here,
    a package is a logical grouping of language elements stored in source code files
    that can be shared and reused, as covered in the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。Go中的函数"), *Go中的函数*涵盖了函数，这是代码组织的基本抽象级别，使代码可寻址和可重用。本章将继续讨论围绕Go包展开的抽象层次。正如将在这里详细介绍的那样，包是存储在源代码文件中的语言元素的逻辑分组，可以共享和重用，如下面的主题所涵盖的：'
- en: The Go package
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go包
- en: Creating packages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包
- en: Building packages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建包
- en: Package visibility
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可见性
- en: Importing packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入包
- en: Package initialization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包初始化
- en: Creating programs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建程序
- en: Remote packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程包
- en: The Go package
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go包
- en: Similar to other languages, Go source code files are grouped into compilable
    and sharable units known as packages. However, all Go source files must belong
    to a package (there is no such notion as a default package). This strict approach
    allows Go to keep its compilation rules and package resolution rules simple by
    favoring convention over configuration. Let us take a deep dive into the fundamentals
    of packages, their creation, use, and recommended practice.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言类似，Go源代码文件被分组为可编译和可共享的单元，称为包。但是，所有Go源文件必须属于一个包（没有默认包的概念）。这种严格的方法使得Go可以通过偏爱惯例而不是配置来保持其编译规则和包解析规则简单。让我们深入了解包的基础知识，它们的创建、使用和推荐做法。
- en: Understanding the Go package
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Go包
- en: 'Before we dive into package creation and use, it is crucial to take a high-level
    view of the concept of packages to help steer the discussion later. A Go package
    is both a physical and a logical unit of code organization used to encapsulate
    related concepts that can be reused. By convention, a group of source files stored
    in the same directory are considered to be part of the same package. The following
    illustrates a simple directory tree, where each directory represents a package
    containing some source code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论包的创建和使用之前，至关重要的是从高层次上理解包的概念，以帮助引导后续的讨论。Go包既是代码组织的物理单元，也是逻辑单元，用于封装可以重用的相关概念。按照惯例，存储在同一目录中的一组源文件被认为是同一个包的一部分。以下是一个简单的目录树示例，其中每个目录代表一个包，包含一些源代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch06-foo
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06-foo
- en: 'While not a requirement, it is a recommended convention to set a package''s
    name, in each source file, to match the name of the directory where the file is
    located. For instance, source file `blat.go` is declared to be part of package
    `foo`, as shown in the following code, because it is stored in directory named
    `foo`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必需的，但是建议按照惯例，在每个源文件中设置包的名称与文件所在目录的名称相匹配。例如，源文件`blat.go`被声明为`foo`包的一部分，因为它存储在名为`foo`的目录中，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch06-foo/foo/blat.go
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06-foo/foo/blat.go
- en: 'Files `quux.go` and `qux.go` are both part of package `bazz` since they are
    located in a directory with that name, as shown in the following code snippets:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`quux.go`和`qux.go`都是`bazz`包的一部分，因为它们位于具有该名称的目录中，如下面的代码片段所示：
- en: '|'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch06-foo/foo/bazz/quux.go |
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06-foo/foo/bazz/quux.go |
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch06-foo/foo/bazz/qux.go |
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06-foo/foo/bazz/qux.go |
- en: The workspace
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作区
- en: 'Another important concept to understand when discussing packages is that of
    the *Go * *workspace*. The workspace is simply an arbitrary directory that serves
    as a namespace used to resolved packages during certain tasks such as compilation.
    By convention, Go tools expect three specifically named subdirectories in a workspace
    directory: `src`, `pkg`, and `bin`. These subdirectories store Go source files
    along with all built package artifacts respectively.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论包时理解的另一个重要概念是*Go工作区*。工作区只是一个任意的目录，用作在某些任务（如编译）期间解析包的命名空间。按照惯例，Go工具期望工作区目录中有三个特定命名的子目录：`src`、`pkg`和`bin`。这些子目录分别存储Go源文件以及所有构建的包构件。
- en: 'Establishing a static directory location where Go packages are kept together
    has the following advantages:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 建立一个静态目录位置，将Go包放在一起具有以下优势：
- en: Simple setup with near-zero configuration
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单设置，几乎没有配置
- en: Fast compilation by reducing code search to a known location
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将代码搜索减少到已知位置来实现快速编译
- en: Tools can easily create source graph of code and package artifacts
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具可以轻松创建代码和包构件的源图
- en: Automatic inference and resolution of transitive dependencies from source
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码自动推断和解析传递依赖关系
- en: Project setup can be made portable and easily distributable
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置可以是可移植的，并且易于分发
- en: 'The following is a partial (and simplified) tree layout of my Go workspace
    on my laptop with the three subdirectories, `bin`, `pkg`, and `src`, highlighted:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我笔记本电脑上Go工作区的部分（和简化的）树状布局，其中突出显示了三个子目录`bin`、`pkg`和`src`：
- en: '|'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Sample workspace directory
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 示例工作区目录
- en: '`bin`: This is an auto-generated directory that stores compiled Go executable
    artifacts (also known as programs or commands). When Go tools compile and install
    executable packages, they are placed in this directory. The previous sample workspace
    shows two binaries listed `circ` and `golint`. It is a recommended practice to
    add this directory to your operating system''s `PATH` environment variable to
    make your command available locally.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin`：这是一个自动生成的目录，用于存储编译的Go可执行文件（也称为程序或命令）。当Go工具编译和安装可执行包时，它们被放置在此目录中。前面的示例工作区显示了两个列出的二进制文件`circ`和`golint`。建议将此目录添加到操作系统的`PATH`环境变量中，以使您的命令在本地可用。'
- en: '`pkg`: This directory is also auto-generated to store built package artifacts.
    When the Go tools build and install non-executable packages, they are stored as
    object files (with `.a` suffix) in subdirectories with name patterns based on
    the targeted operating system and architecture. In the sample workspace, the object
    files are placed under subdirectory `linux_amd64`, which indicates that the object
    files in this directory were compiled for the Linux operating system running on
    a 64-bit architecture.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg`：这个目录也是自动生成的，用于存储构建的包构件。当Go工具构建和安装非可执行包时，它们被存储为对象文件（带有`.a`后缀）在子目录中，子目录的名称模式基于目标操作系统和架构。在示例工作区中，对象文件被放置在`linux_amd64`子目录下，这表明该目录中的对象文件是为运行在64位架构上的Linux操作系统编译的。'
- en: '`src`: This is a user-created directory where the Go source code files are
    stored. Each subdirectory under `src` is mapped to a package. *src* is the root
    directory from which all import paths are resolved. The Go tools search that directory
    to resolve packages referenced in your code during compilation or other activities
    that depend on the source path. The sample workspace in the previous figure shows
    two packages: `github.com/golang/lint/golint/` and `github.com/vladimirvivien/learning-go/ch06/current`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：这是一个用户创建的目录，用于存储Go源代码文件。`src`下的每个子目录都映射到一个包。*src*是解析所有导入路径的根目录。Go工具搜索该目录以解析代码中引用的包，这些引用在编译或其他依赖源路径的活动中。上图中的示例工作区显示了两个包：`github.com/golang/lint/golint/`和`github.com/vladimirvivien/learning-go/ch06/current`。'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may be wondering about the `github.com` prefix in the package path shown
    in the workspace example. It is worth noting there are no naming requirements
    for the package directories (see the *Naming packages* section). A package can
    have any arbitrary name. However, Go recommends certain conventions that help
    with global namespace resolution and package organization.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会对工作区示例中显示的包路径中的`github.com`前缀感到疑惑。值得注意的是，包目录没有命名要求（请参阅*命名包*部分）。包可以有任意的名称。但是，Go建议遵循一些约定，这有助于全局命名空间解析和包组织。
- en: Creating a workspace
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建工作区
- en: 'Creating a workspace is as simple as setting an operating system environment
    named `GOPATH` and assigning to it the root path of the location of the workspace
    directory. On a Linux machine, for instance, where the root directory for the
    workspace is `/home/username/Go`, the workspace would be set as:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建工作区就像设置一个名为`GOPATH`的操作系统环境一样简单，并将其分配给工作区目录的根路径。例如，在Linux机器上，工作区的根目录为`/home/username/Go`，工作区将被设置为：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When setting up the `GOPATH` environment variable, it is possible to specify
    multiple locations where packages are stored. Each directory is separated by an
    OS-dependent path delimiter character (in other words, colon for Linux/Unix, semi-colon
    for Windows) as shown below:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置`GOPATH`环境变量时，可以指定存储包的多个位置。每个目录由操作系统相关的路径分隔符分隔（换句话说，Linux/Unix使用冒号，Windows使用分号），如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Go tools will search all listed locations in the `GOPATH` when resolving
    package names. The Go compiler will, however, only store compiled artifacts, such
    as object and binary files, in the first directory location assigned to `GOPATH`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析包名称时，Go工具将搜索`GOPATH`中列出的所有位置。然而，Go编译器只会将编译后的文件，如对象和二进制文件，存储在分配给`GOPATH`的第一个目录位置中。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The ability to configure your workspace by simply setting an OS environmental
    variable has tremendous advantages. It gives developers the ability to dynamically
    set the workspace at compile time to meet certain workflow requirements. For instance,
    a developer may want to test an unverified branch of code prior to merging it.
    He or she may want to set up a temporary workspace to build that code as follows
    (Linux): `$> GOPATH=/temporary/go/workspace/path go build`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单设置操作系统环境变量来配置工作区具有巨大的优势。它使开发人员能够在编译时动态设置工作区，以满足某些工作流程要求。例如，开发人员可能希望在合并代码之前测试未经验证的代码分支。他或她可能希望设置一个临时工作区来构建该代码，方法如下（Linux）：`$>
    GOPATH=/temporary/go/workspace/path go build`
- en: The import path
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入路径
- en: Before moving on to the detail of setting up and using packages, one last important
    concept to cover is the notion of an *import path*. The relative path of each
    package, under workspace path `$GOPATH/src`, constitutes a global identifier known
    as the package's `import path`. This implies that no two packages can have the
    same import path values in a given workspace.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续设置和使用包的详细信息之前，最后一个重要概念要涵盖的是*导入路径*的概念。每个包的相对路径，位于工作区路径`$GOPATH/src`下，构成了一个全局标识符，称为包的`导入路径`。这意味着在给定的工作区中，没有两个包可以具有相同的导入路径值。
- en: 'Let us go back to our simplified directory tree from earlier. For instance,
    if we set the workspace to some arbitrary path value such as `GOPATH=/home/username/Go`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到之前的简化目录树。例如，如果我们将工作区设置为某个任意路径值，如`GOPATH=/home/username/Go`：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From the sample workspace illustrated above, the directory path of the packages
    is mapped to their respective import paths as shown in the following table:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面示例的工作区中，包的目录路径映射到它们各自的导入路径，如下表所示：
- en: '| **Directory Path** | **Import Path** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **目录路径** | **导入路径** |'
- en: '| `/home/username/Go/foo` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `/home/username/Go/foo` |'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/home/username/Go/foo/bar` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `/home/username/Go/foo/bar` |'
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/home/username/Go/foo/bar/bazz` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `/home/username/Go/foo/bar/bazz` |'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Creating packages
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建包
- en: Until now, the chapter has covered the rudimentary concepts of the Go package;
    now it is time to dive deeper and look at the creation of Go code contained in
    packages. One of the main purposes of a Go package is to abstract out and aggregate
    common logic into sharable code units. Earlier in the chapter, it was mentioned
    that a group of Go source files in a directory is considered to be a package.
    While this is technically true, there is more to the concept of a Go package than
    just shoving a bunch of files in a directory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经涵盖了Go包的基本概念；现在是时候深入了解并查看包含在包中的Go代码的创建。Go包的主要目的之一是将常见逻辑抽象出来并聚合到可共享的代码单元中。在本章的前面提到，一个目录中的一组Go源文件被认为是一个包。虽然这在技术上是正确的，但是关于Go包的概念还不仅仅是将一堆文件放在一个目录中。
- en: 'To help illustrate the creation of our first packages, we will enlist the use
    of example source code found in [github.com/vladimirvivien/learning-go/ch06](https://github.com/vladimirvivien/learning-go/ch06).
    The code in that directory defines a set of functions to help calculate electrical
    values using *Ohm''s Law*. The following shows the layout of the directories that
    make up the packages for the example (assuming they are saved in some workspace
    directory `$GOPATH/src`):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助说明我们的第一个包的创建，我们将利用在[github.com/vladimirvivien/learning-go/ch06](https://github.com/vladimirvivien/learning-go/ch06)中找到的示例源代码。该目录中的代码定义了一组函数，用于使用*欧姆定律*计算电气值。以下显示了组成示例包的目录布局（假设它们保存在某个工作区目录`$GOPATH/src`中）：
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Package layout for Ohm's Law example
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Ohm's Law示例的包布局
- en: 'Each directory, in the previous tree, contains one or more Go source code files
    that define and implement the functions, and other source code elements, that
    will be arranged into packages and be made reusable. The following table summarizes
    the import paths and package information extracted from preceding workspace layout:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述目录中，每个目录都包含一个或多个Go源代码文件，用于定义和实现函数以及其他源代码元素，这些元素将被组织成包并可重复使用。以下表格总结了从前面的工作区布局中提取的导入路径和包信息：
- en: '| **Import Path** | **Package** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '**导入路径** | **包** |'
- en: '| "github.com/vladimirvivien/learning-go/ch06/**current**" | `current` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| "github.com/vladimirvivien/learning-go/ch06/**current**" | `current` |'
- en: '| "github.com/vladimirvivien/learning-go/ch06/**power**" | `power` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| "github.com/vladimirvivien/learning-go/ch06/**power**" | `power` |'
- en: '| "github.com/vladimirvivien/learning-go/ch06/**power/ir**" | `ir` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| "github.com/vladimirvivien/learning-go/ch06/**power/ir**" | `ir` |'
- en: '| "github.com/vladimirvivien/learning-go/ch06/**power/vr**" | `vr` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| "github.com/vladimirvivien/learning-go/ch06/**power/vr**" | `vr` |'
- en: '| "github.com/vladimirvivien/learning-go/ch06/**resistor**" | `resistor` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| "github.com/vladimirvivien/learning-go/ch06/**resistor**" | `resistor` |'
- en: '| "github.com/vladimirvivien/learning-go/ch06/**volt**" | `volt` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| "github.com/vladimirvivien/learning-go/ch06/**volt**" | `volt` |'
- en: While there are no naming requirements, it is sensible to name package directories
    to reflect their respective purposes. From the previous table, each package in
    the example is named to represent an electrical concept, such as current, power,
    resistor, and volt. The *Naming packages* section will go into further detail
    about package naming conventions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有命名要求，但是将包目录命名为反映其各自目的的名称是明智的。从前面的表格中，每个示例中的包都被命名为代表电气概念的名称，例如current、power、resistor和volt。*包命名*部分将详细介绍包命名约定。
- en: Declaring the package
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明包
- en: 'Go source files must declare themselves to be part of a package. This is done
    using the `package` clause, as the first legal statement in a Go source file.
    The declared package consists of the `package` keyword followed by a name identifier.
    The following shows source file `volt.go` from the `volt` package:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Go源文件必须声明自己属于一个包。这是使用`package`子句完成的，作为Go源文件中的第一个合法语句。声明的包由`package`关键字后跟一个名称标识符组成。以下显示了`volt`包中的源文件`volt.go`：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: golang.fyi/ch06/volt/volt.go
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06/volt/volt.go
- en: The package identifier in the source file can be set to any arbitrary value.
    Unlike, say, Java, the name of the package does not reflect the directory structure
    where the source file is located. While there are no requirements for the package
    name, it is an accepted convention to name the package identifier the same as
    the directory where the file is located. In our previous source listing, the package
    is declared with identifier `volt` because the file is stored inside the *volt*
    directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件中的包标识符可以设置为任意值。与Java不同，包的名称不反映源文件所在的目录结构。虽然对于包名称没有要求，但是将包标识符命名为与文件所在目录相同的约定是被接受的。在我们之前的源代码清单中，包被声明为标识符`volt`，因为该文件存储在*volt*目录中。
- en: Multi-File packages
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多文件包
- en: 'The logical content of a package (source code elements such as types, functions,
    variables, and constants) can physically scale across multiple Go source files.
    A package directory can contain one or more Go source files. For instance, in
    the following example, package `resistor` is unnecessarily split among several
    Go source files to illustrate this point:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包的逻辑内容（源代码元素，如类型、函数、变量和常量）可以在多个Go源文件中物理扩展。一个包目录可以包含一个或多个Go源文件。例如，在下面的示例中，包`resistor`被不必要地分割成几个Go源文件，以说明这一点：
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: golang.fyi/ch06/resistor/lib.go |
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06/resistor/lib.go |
- en: '|'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: golang.fyi/ch06/resistor/res_equivalance.go |
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06/resistor/res_equivalance.go |
- en: '|'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch06/resistor/res.go |
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06/resistor/res.go |
- en: '|'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: golang.fyi/ch06/resistor/res_power.go |
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06/resistor/res_power.go |
- en: Each file in the package must have a package declaration with the same name
    identifier (in this case `resistor`). The Go compiler will stitch all elements
    from all of the source files together to form one logical unit within a single
    scope that can be used by other packages.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 包中的每个文件必须具有相同的名称标识符的包声明（在本例中为`resistor`）。Go编译器将从所有源文件中的所有元素中拼接出一个逻辑单元，形成一个可以被其他包使用的单一范围内的逻辑单元。
- en: It is important to point out that compilation will fail if the package declaration
    is not identical across all source files in a given directory. This is understandable,
    as the compiler expects all files in a directory to be part of the same package.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，如果给定目录中所有源文件的包声明不相同，编译将失败。这是可以理解的，因为编译器期望目录中的所有文件都属于同一个包。
- en: Naming packages
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名包
- en: As mentioned earlier, Go expects each package in a workspace to have a unique
    fully qualified import path. Your program may have as many packages as you want
    and your package structure can be as deep as you like in the workspace. However,
    idiomatic Go prescribes some **rules** for the naming and organization of your
    packages to make creating and using packages simple.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Go期望工作区中的每个包都有一个唯一的完全限定的导入路径。您的程序可以拥有任意多的包，您的包结构可以在工作区中深入到您喜欢的程度。然而，惯用的Go规定了一些关于包的命名和组织的**规则**，以使创建和使用包变得简单。
- en: Use globally unique namespaces
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用全局唯一的命名空间
- en: Firstly, it is a good idea to fully qualify the import path of your packages
    in a global context, especially if you plan to share your code with others. Consider
    starting the name of your import path with a namespace scheme that uniquely identifies
    you or your organization. For instance, company *Acme, Inc.* may choose to start
    all of their Go package names with `acme.com/apps`. So a fully qualified import
    path for a package would be `"acme.com/apps/foo/bar"`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在全局上下文中，完全限定您的包的导入路径是一个好主意，特别是如果您计划与他人共享您的代码。考虑以唯一标识您或您的组织的命名空间方案开始您的导入路径的名称。例如，公司*Acme,
    Inc.*可能选择以`acme.com/apps`开头命名他们所有的Go包名称。因此，一个包的完全限定导入路径将是`"acme.com/apps/foo/bar"`。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Later in this chapter, we will see how package import paths can be used when
    integrating Go with source code repository services such as GitHub.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将看到如何在集成Go与GitHub等源代码存储库服务时使用包导入路径。
- en: Add context to path
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为路径添加上下文
- en: 'Next, as you devise a naming scheme for your package, use the package''s path
    to add context to the name of your package name. The context in the name should
    start generic and get more specific from left to right. As an example, let us
    refer to the import paths for the power package (from the example earlier). The
    calculation of power values is split among three sub-packages shown as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当您为您的包设计一个命名方案时，使用包的路径为您的包名称添加上下文。名称中的上下文应该从左到右开始通用，然后变得更具体。例如，让我们参考电源包的导入路径（来自之前的示例）。电源值的计算分为三个子包，如下所示：
- en: '`github.com/vladimirvivien/learning-go/ch06/**power**`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`github.com/vladimirvivien/learning-go/ch06/**power**`'
- en: '`github.com/vladimirvivien/learning-go/ch06/**power/ir**`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`github.com/vladimirvivien/learning-go/ch06/**power/ir**`'
- en: '`github.com/vladimirvivien/learning-go/ch06/**power/vr**`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`github.com/vladimirvivien/learning-go/ch06/**power/vr**`'
- en: 'The parent path `power` contains package members with broader context. The
    sub-packages `ir` and `vr` contain members that are more specific with narrower
    contexts. This naming pattern is used heavily in Go, including the built-in packages
    such as the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 父路径`power`包含具有更广泛上下文的包成员。子包`ir`和`vr`包含更具体的成员，具有更窄的上下文。这种命名模式在Go中被广泛使用，包括内置包，如以下所示：
- en: '`crypto/md5`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crypto/md5`'
- en: '`net/http`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http`'
- en: '`net/http/httputil`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http/httputil`'
- en: '`reflect`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflect`'
- en: Note a package depth of one is a perfectly legitimate package name (see `reflect`)
    as long as it captures both context and the essence of what it does. Again, keep
    things simple. Avoid the temptation of nesting your packages beyond a depth of
    more than three inside your namespace. This temptation will be especially strong
    if you are a Java developer used to long nested package names.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个包深度为一是一个完全合法的包名称（参见`reflect`），只要它能捕捉上下文和它所做的本质。同样，保持简单。避免在您的命名空间内将您的包嵌套超过三层的诱惑。如果您是一个习惯于长嵌套包名称的Java开发人员，这种诱惑将特别强烈。
- en: Use short names
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用简短的名称
- en: When reviewing the names of built-in Go packages, one thing you will notice
    is the brevity of the names compared to other languages. In Go, a package is considered
    to be a collection of code that implements a specific set of closely related functionalities.
    As such, the import paths of your packages should be succinct and reflect what
    they do without being excessively long. Our example source code exemplifies this
    by naming the package directory with short names such as volt, power, resistance,
    current. In their respective contexts, each directory name states exactly what
    the package does.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当审查内置的Go包名称时，您会注意到一个事实，即与其他语言相比，名称的简洁性。在Go中，包被认为是实现一组紧密相关功能的代码集合。因此，您的包的导入路径应该简洁，并反映出它们的功能，而不会过长。我们的示例源代码通过使用诸如volt、power、resistance、current等简短名称来命名包目录，充分体现了这一点。在各自的上下文中，每个目录名称都准确说明了包的功能。
- en: 'The short name rule is rigorously applied in the built-in packages of Go. For
    instance, following are several package names from Go''s built-in packages: `log`,
    `http`, `xml`, and `zip`. Each name readily identifies the purpose of the package.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go的内置包中严格遵守了简短名称规则。例如，以下是Go内置包中的几个包名称：`log`、`http`、`xml`和`zip`。每个名称都能够清楚地识别包的目的。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Short package names have the advantage of reducing keystrokes in larger code
    bases. However, having short and generic package names also has the disadvantage
    of being prone to import path clashes where developers in a large project (or
    developers of open source libraries) may end up using the same popular names (in
    other words, `log`, `util`, `db`, and so on) in their code. As we will see later
    in the chapter, this can be handled using `named` import paths.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 短包名称有助于减少在较大代码库中的击键次数。然而，拥有短而通用的包名称也有一个缺点，即容易发生导入路径冲突，即在大型项目中的开发人员（或开源库的开发人员）可能最终在他们的代码中使用相同的流行名称（换句话说，`log`、`util`、`db`等）。正如我们将在本章后面看到的那样，这可以通过使用`命名`导入路径来处理。
- en: Building packages
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建包
- en: 'The Go tools reduce the complexity of compiling your code by applying certain
    conventions and sensible defaults. Although a full discussion of Go''s build tool
    is beyond the scope of this section (or chapter), it is useful to understand the
    purpose and use of the `build` and `install` tools. In general, the use of the
    build and install tools is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用某些约定和合理的默认值，Go工具减少了编译代码的复杂性。虽然完整讨论Go的构建工具超出了本节（或本章）的范围，但了解`build`和`install`工具的目的和用法是有用的。一般来说，使用构建和安装工具的方式如下：
- en: '*$> go build [<package import path>]*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*$> go build [<package import path>]*'
- en: 'The `import path` can be explicitly provided or omitted altogether. The `build`
    tool accepts the `import path` expressed as either fully qualified or relative
    paths. Given a properly setup workspace, the following are all equivalent ways
    to compile package `volt`, from the earlier example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`import path`可以明确提供或完全省略。`build`工具接受`import path`，可以表示为完全限定或相对路径。在正确设置的工作区中，以下是从前面的示例中编译包`volt`的等效方式：'
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `go build` command above will compile all Go source files and their dependencies
    found in directory `volt`. Furthermore, it is also possible to build all of your
    packages and sub-packages in a given directory using the wildcard parameter appended
    to an import path shown as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`go build`命令将编译在目录`volt`中找到的所有Go源文件及其依赖项。此外，还可以使用通配符参数构建给定目录中的所有包和子包，如下所示：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous will build all packages and sub-packages found in the directory
    `$GOPATH/src/github.com/vladimirvivien/learning-go/ch06`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的内容将构建在目录`$GOPATH/src/github.com/vladimirvivien/learning-go/ch06`中找到的所有包和子包。
- en: Installing a package
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装一个包
- en: By default, the build command outputs its results into a tool-generated temporary
    directory that is lost after the build process completes. To actually generate
    a usable artifact, you must use the `install` tool to keep a copy of the compiled
    object files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，构建命令将其结果输出到一个工具生成的临时目录中，在构建过程完成后会丢失。要实际生成可用的构件，必须使用`install`工具来保留已编译的对象文件的副本。
- en: 'The `install` tool has the exact semantics as the build tool:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`install`工具与构建工具具有完全相同的语义：'
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In addition to compiling the code, it also saves and outputs the result to
    workspace location `$GOPATH/pkg` as shown in the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编译代码，它还将结果保存并输出到工作区位置`$GOPATH/pkg`，如下所示：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The generated object files (with the `.a` extension) allow the package to be
    reused and linked against other packages in the workspace. Later in the chapter,
    we will examine how to compile executable programs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的对象文件（带有`.a`扩展名）允许包在工作区中被重用和链接到其他包中。在本章的后面，我们将讨论如何编译可执行程序。
- en: Package visibility
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包可见性
- en: 'Regardless of the number of source files declared to be part of a package,
    all source code elements (types, variables, constants, and functions), declared
    at a package level, share a common scope. Therefore, the compiler will not allow
    an element identifier to be re-declared more than once in the entire package.
    Let us use the following code snippets to illustrate this point, assuming both
    source files are part of the same package `$GOPATH/src/foo`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 无论声明为包的一部分的源文件数量如何，所有在包级别声明的源代码元素（类型、变量、常量和函数）都共享一个公共作用域。因此，编译器不允许在整个包中重新声明元素标识符超过一次。让我们使用以下代码片段来说明这一点，假设两个源文件都是同一个包`$GOPATH/src/foo`的一部分：
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: foo/file1.go |
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: foo/file1.go |
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: foo/file2.go |
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: foo/file2.go |
- en: Illegal variable identifier re-declaration
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 非法的变量标识符重新声明
- en: Although they are in two separate files, the declaration of variables with identifier
    `bar` is illegal in Go. Since the files are part of the same package, both identifiers
    have the same scope and therefore clash.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们在两个不同的文件中，但在Go中使用标识符`bar`声明变量是非法的。由于这些文件是同一个包的一部分，两个标识符具有相同的作用域，因此会发生冲突。
- en: 'The same is true for function identifiers. Go does not support the overloading
    of function names within the same scope. Therefore, it is illegal to have a function
    identifier used more than once, regardless of the function''s signature. If we
    assume the following code appears in two different source files within the same
    package, the following snippet would be illegal:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 函数标识符也是如此。Go不支持在相同作用域内重载函数名称。因此，无论函数的签名如何，使用函数标识符超过一次都是非法的。如果我们假设以下代码出现在同一包内的两个不同源文件中，则以下代码片段将是非法的：
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: foo/file1.go |
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: foo/file1.go |
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: foo/file1.go |
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: foo/file1.go |
- en: Illegal function identifier re-declaration
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 非法的函数标识符重新声明
- en: In the previous code snippets, function name identifier `qux` is used twice.
    The compiler will fail the compilation even though both functions have different
    signatures. The only way to fix this is to change the name.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，函数名标识符`qux`被使用了两次。即使这两个函数具有不同的签名，编译器也会失败。唯一的解决方法是更改名称。
- en: Package member visibility
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包成员可见性
- en: 'The usefulness of a package is its ability to expose its source elements to
    other packages. Controlling the visibility of elements of a package is simple
    and follows this rule: *capitalized identifiers are exported automatically*. This
    means any type, variable, constant, or function with capitalized identifiers is
    automatically visible from outside of the package where it is declared.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 包的有用性在于其能够将其源元素暴露给其他包。控制包元素的可见性很简单，遵循这个规则：*大写标识符会自动导出*。这意味着任何具有大写标识符的类型、变量、常量或函数都会自动从声明它的包之外可见。
- en: 'Referring to the Ohm''s Law example, described earlier, the following illustrates
    this functionality from the package `resistor` (found in [github.com/vladimirvivien/learning-go/ch06/resistor](https://github.com/vladimirvivien/learning-go/ch06/resistor)):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 参考之前描述的欧姆定律示例，以下说明了来自包`resistor`（位于[github.com/vladimirvivien/learning-go/ch06/resistor](https://github.com/vladimirvivien/learning-go/ch06/resistor)）的功能：
- en: '| **Code** | **Description** |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **描述** |'
- en: '|'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| Function `R` is automatically exported and can be accessed from other packages
    as: `resistor.R()` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 函数`R`自动导出，并且可以从其他包中访问：`resistor.R()` |'
- en: '|'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| Function identifier `recip` is in all lowercase and therefore is not exported.
    Though accessible within its own scope, the function will not be visible from
    within other packages. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 函数标识符`recip`全部小写，因此未导出。虽然在其自己的范围内可访问，但该函数将无法从其他包中可见。 |'
- en: It is worth restating that members within the same package are always visible
    to each other. In Go, there are no complicated visibility structures of private,
    friend, default, and so on, as is found in other languages. This frees the developer
    to concentrate on the solution being implemented rather than modeling visibility
    hierarchies.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 值得重申的是，同一个包内的成员始终对彼此可见。在Go中，没有复杂的可见性结构，比如私有、友元、默认等，这使得开发人员可以专注于正在实现的解决方案，而不是对可见性层次进行建模。
- en: Importing package
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入包
- en: 'At this point, you should have a good understanding of what a package is, what
    it does, and how to create one. Now, let us see how to use a package to import
    and reuse its members. As you will find in several other languages, the keyword
    `import` is used to import source code elements from an external package. It allows
    the importing source to access exported elements found in the imported package
    (see the *Package scope and visibility* section earlier in the chapter). The general
    format for the import clause is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对包是什么，它的作用以及如何创建包有了很好的理解。现在，让我们看看如何使用包来导入和重用其成员。正如您在其他几种语言中所发现的那样，关键字`import`用于从外部包中导入源代码元素。它允许导入源访问导入包中的导出元素（请参阅本章前面的*包范围和可见性*部分）。导入子句的一般格式如下：
- en: '*import [package name identifier] "<import path>"*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*import [包名称标识符] "<导入路径>"*'
- en: 'Notice that the import path must be enclosed within double quotes. The `import`
    statement also supports an optional package identifier that can be used to explicitly
    name the imported package (discussed later). The import statement can also be
    written as an import block, as shown in the following format. This is useful where
    there are two or more import packages listed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，导入路径必须用双引号括起来。`import`语句还支持可选的包标识符，可用于显式命名导入的包（稍后讨论）。导入语句也可以写成导入块的形式，如下所示。这在列出两个或更多导入包的情况下很有用：
- en: '*import (*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*import (*'
- en: '*[package name identifier] "<import path>"*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*[包名称标识符] "<导入路径>"*'
- en: '*)*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*)*'
- en: 'The following source code snippet shows the import declaration block in the
    Ohm''s Law examples introduced earlier:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下源代码片段显示了先前介绍的欧姆定律示例中的导入声明块：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: golang.fyi/ch06/main.go
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06/main.go
- en: 'Often the name identifiers of imported packages are omitted, as done above.
    Go then applies the name of the last directory of the import path as the name
    identifier for the imported package, as shown, for some packages, in the following
    table:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通常省略导入包的名称标识符，如上所示。然后，Go将导入路径的最后一个目录的名称作为导入包的名称标识符，如下表所示，对于某些包：
- en: '| **Import Path** | **Package name** |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **导入路径** | **包名称** |'
- en: '| `flag` | `flag` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `flag` | `flag` |'
- en: '| `github.com/vladimirvivien/learning-go/ch06/current` | `current` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `github.com/vladimirvivien/learning-go/ch06/current` | `current` |'
- en: '| `github.com/vladimirvivien/learning-go/ch06/power/ir` | `ir` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `github.com/vladimirvivien/learning-go/ch06/power/ir` | `ir` |'
- en: '| `github.com/vladimirvivien/learning-go/ch06/volt` | `volt` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `github.com/vladimirvivien/learning-go/ch06/volt` | `volt` |'
- en: 'The dot notation is used to access exported members of an imported package.
    In the following source code snippet, for instance, method `volt.V()` is invoked
    from imported package `"github.com/vladimirvivien/learning-go/ch06/volt"`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 点符号用于访问导入包的导出成员。例如，在下面的源代码片段中，从导入包`"github.com/vladimirvivien/learning-go/ch06/volt"`调用了方法`volt.V()`：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: golang.fyi/ch06/main.go
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06/main.go
- en: Specifying package identifiers
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定包标识符
- en: 'As was mentioned, an `import` declaration may explicitly declare a name identifier
    for the import, as shown in the following import snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`import`声明可以显式为导入声明一个名称标识符，如下面的导入片段所示：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Following the format described earlier, the name identifier is placed before
    the import path as shown in the preceding snippet. A named package can be used
    as a way to shorten or customize the name of a package. For instance, in a large
    source file with numerous usage of a certain package, this can be a welcome feature
    to reduce keystrokes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面描述的格式，名称标识符放在导入路径之前，如前面的片段所示。命名包可以用作缩短或自定义包名称的一种方式。例如，在一个大型源文件中，有大量使用某个包的情况下，这可以是一个很好的功能，可以减少按键次数。
- en: 'Assigning a name to a package is also a way to avoid package identifier collisions
    in a given source file. It is conceivable to import two or more packages, with
    different import paths, that resolve to the same package names. As an example,
    you may need to log information with two different logging systems from different
    libraries, as illustrated in the following code snippet:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 给包分配一个名称也是避免给定源文件中的包标识符冲突的一种方式。可以想象导入两个或更多的包，具有不同的导入路径，解析为相同的包名称。例如，您可能需要使用来自不同库的两个不同日志系统记录信息，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As depicted in the previous snippet, both logging packages will resolve to the
    same name identifier of `"logger"` by default. To resolve this, at least one of
    the imported packages must be assigned a name identifier to resolve the name clash.
    In the previous example, both import paths were named with a meaningful name to
    help with code comprehension.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的片段所示，两个日志包默认都将解析为名称标识符`"logger"`。为了解决这个问题，至少其中一个导入的包必须分配一个名称标识符来解决名称冲突。在上面的例子中，两个导入路径都被命名为有意义的名称，以帮助代码理解。
- en: The dot identifier
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点标识符
- en: 'A package can optionally be assigned a dot (period) as its identifier. When
    an `import` statement uses the dot identifier (`.`) for an import path, it causes
    members of the imported package to be merged in scope with that of the importing
    package. Therefore, imported members may be referenced without additional qualifiers.
    So if package `logger` is imported with the dot identifier in the following source
    code snippet, when accessing exported member function `SubmitError` from the logger
    package, the package name is omitted:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包可以选择将点（句号）分配为它的标识符。当一个`import`语句使用点标识符（`.`）作为导入路径时，它会导致导入包的成员与导入包的作用域合并。因此，导入的成员可以在不添加额外限定符的情况下被引用。因此，如果在以下源代码片段中使用点标识符导入了包`logger`，那么在访问logger包的导出成员函数`SubmitError`时，包名被省略了：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: While this feature can help reduce repetitive keystrokes, it not an encouraged
    practice. By merging the scope of your packages, it becomes more likely to run
    into identifier collisions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个特性可以帮助减少重复的按键，但这并不是一种鼓励的做法。通过合并包的作用域，更有可能遇到标识符冲突。
- en: The blank identifier
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空白标识符
- en: When a package is imported, it is a requirement that one of its members be referenced
    in the importing code at least once. Failure to do so will result in a compilation
    error. While this feature helps simplify package dependency resolution, it can
    be cumbersome, especially in the early phase of a developing code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入一个包时，要求在导入的代码中至少引用其成员之一。如果未能这样做，将导致编译错误。虽然这个特性有助于简化包依赖关系的解析，但在开发代码的早期阶段，这可能会很麻烦。
- en: 'Using the blank identifier (similar to variable declarations) causes the compiler
    to bypass this requirement. For instance, the following snippet imports the built-in
    package `fmt`; however, it never uses it in the subsequent source code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空白标识符（类似于变量声明）会导致编译器绕过此要求。例如，以下代码片段导入了内置包`fmt`；但是，在随后的源代码中从未使用过它：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A common idiom for the blank identifier is to load packages for their side effects.
    This relies on the initialization sequence of packages when they are imported
    (see the following *Package initialization* section). Using the blank identifier
    will cause an imported package to be initialized even when none of its members
    can referenced. This is used in contexts where the code is needed to silently
    run certain initialization sequences.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 空白标识符的一个常见用法是为了加载包的副作用。这依赖于包在导入时的初始化顺序（请参阅下面的*包初始化*部分）。使用空白标识符将导致导入的包在没有引用其成员的情况下被初始化。这在需要在不引起注意的情况下运行某些初始化序列的代码中使用。
- en: Package initialization
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包初始化
- en: 'When a package is imported, it goes through a series of initialization sequences
    before its members are ready to be used. Package-level variables are initialized
    using dependency analysis that relies on lexical scope resolution, meaning variables
    are initialized based on their declaration order and their resolved transitive
    references to each other. For instance, in the following snippet, the resolved
    variable declaration order in package `foo` will be `a`, `y`, `b`, and `x`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入一个包时，它会在其成员准备好被使用之前经历一系列的初始化序列。包级变量的初始化是使用依赖分析来进行的，依赖于词法作用域解析，这意味着变量是基于它们的声明顺序和它们相互引用的解析来初始化的。例如，在以下代码片段中，包`foo`中的解析变量声明顺序将是`a`、`y`、`b`和`x`：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Go also makes use of a special function named `init` that takes no arguments
    and returns no result values. It is used to encapsulate custom initialization
    logic that is invoked when the package is imported. For instance, the following
    source code shows an `init` function used in the `resistor` package to initialize
    function variable `Rpi`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Go还使用了一个名为`init`的特殊函数，它不接受任何参数，也不返回任何结果值。它用于封装在导入包时调用的自定义初始化逻辑。例如，以下源代码显示了在`resistor`包中使用的`init`函数来初始化函数变量`Rpi`：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: golang.fyi/ch06/resistor/res_power.go
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06/resistor/res_power.go
- en: 'In the preceding code, the `init` function is invoked after the package-level
    variables are initialized. Therefore, the code in the `init` function can safely
    rely on the declared variable values to be in a stable state. The `init` function
    is special in the following ways:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`init`函数在包级变量初始化之后被调用。因此，`init`函数中的代码可以安全地依赖于声明的变量值处于稳定状态。`init`函数在以下方面是特殊的：
- en: A package can have more than one `init` functions defined
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包可以定义多个`init`函数
- en: You cannot directly access declared `init` functions at runtime
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能直接在运行时访问声明的`init`函数
- en: They are executed in the lexical order they appear within each source file
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们按照它们在每个源文件中出现的词法顺序执行
- en: The `init` function is a great way to inject logic into a package that gets
    executed prior to any other functions or methods.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`函数是将逻辑注入到在任何其他函数或方法之前执行的包中的一种很好的方法。'
- en: Creating programs
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建程序
- en: 'So far in the book, you have learned how to create and bundle Go code as reusable
    packages. A package, however, cannot be executed as a standalone program. To create
    a program (also known as a command), you take a package and define an entry point
    of execution as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，您已经学会了如何创建和捆绑Go代码作为可重用的包。但是，包本身不能作为独立的程序执行。要创建一个程序（也称为命令），您需要取一个包，并定义一个执行入口，如下所示：
- en: Declare (at least one) source file to be part of a special package called `main`
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明（至少一个）源文件作为名为`main`的特殊包的一部分
- en: Declare one function name `main()` to be used as the entry point of the program
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个名为`main()`的函数作为程序的入口点
- en: 'The function `main` takes no argument nor returns any value. The following
    shows the abbreviated source code for the `main` package used in the Ohm''s Law
    example (from earlier). It uses the package `flag`, from Go''s standard library,
    to parse program arguments formatted as `flag`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`main`不接受任何参数，也不返回任何值。以下是`main`包的缩写源代码，用于之前的Ohm定律示例中。它使用了Go标准库中的`flag`包来解析格式为`flag`的程序参数：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: golang.fyi/ch06/main.go
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06/main.go
- en: The previous listing shows the source code of the `main` package and the implementation
    of the function `main` which gets executed when the program runs. The Ohm's Law
    program accepts command-line arguments that specify which electrical operation
    to execute (see the following *Accessing program arguments* section). The function
    `init` is used to initialize parsing of the program flag values. The function
    main is set up as a big switch statement block to select the proper operation
    to execute based on the selected flags.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的清单显示了`main`包的源代码以及`main`函数的实现，当程序运行时将执行该函数。Ohm's Law程序接受指定要执行的电气操作的命令行参数（请参阅下面的*访问程序参数*部分）。`init`函数用于初始化程序标志值的解析。`main`函数设置为一个大的开关语句块，以根据所选的标志选择要执行的适当操作。
- en: Accessing program arguments
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问程序参数
- en: 'When a program is executed, the Go runtime makes all command-line arguments
    available as a slice via package variable `os.Args`. For instance, when the following
    program is executed, it prints all command-line arguments passed to the program:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序被执行时，Go运行时将所有命令行参数作为一个切片通过包变量`os.Args`提供。例如，当执行以下程序时，它会打印传递给程序的所有命令行参数：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: golang.fyi/ch06-args/hello.go
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch06-args/hello.go
- en: 'The following is the output of the program when it is invoked with the shown
    arguments:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用显示的参数调用程序时，以下是程序的输出：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that the command-line argument `"hello world how are you?"`, placed after
    the program's name, is split as a space-delimited string. Position 0 in slice
    `os.Args` holds the fully qualified name of the program's binary path. The rest
    of the slice stores each item in the string respectively.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，程序名称后面放置的命令行参数`"hello world how are you?"`被拆分为一个以空格分隔的字符串。切片`os.Args`中的位置0保存了程序二进制路径的完全限定名称。切片的其余部分分别存储了字符串中的每个项目。
- en: 'The `flag` package, from Go''s standard library, uses this mechanism internally
    to provide processing of structured command-line arguments known as flags. In
    the Ohm''s Law example listed earlier, the `flag` package is used to parse several
    flags, as listed in the following source snippet (extracted from the full listing
    earlier):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库中的`flag`包在内部使用此机制来提供已知为标志的结构化命令行参数的处理。在前面列出的Ohm's Law示例中，`flag`包用于解析几个标志，如以下源代码片段中所示（从前面的完整清单中提取）：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The snippet shows function `init` used to parse and initialize expected flags
    `"v"`, `"i"`, `"p",` and `"op"` (at runtime, each flag is prefixed with a minus
    sign). The initialization functions in package `flag` sets up the expected type,
    the default value, a flag description, and where to store the parsed value for
    the flag. The flag package also supports the special flag "help", used to provide
    helpful hints about each flag.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段显示了`init`函数用于解析和初始化预期的标志`"v"`、`"i"`、`"p"`和`"op"`（在运行时，每个标志都以减号开头）。`flag`包中的初始化函数设置了预期的类型、默认值、标志描述以及用于存储标志解析值的位置。`flag`包还支持特殊标志"help"，用于提供有关每个标志的有用提示。
- en: '`flag.Parse()`, in the function `main`, is used to start the process of parsing
    any flags provided as command-line. For instance, to calculate the current of
    a circuit with 12 volts and 300 ohms, the program takes three flags and produces
    the shown output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag.Parse()`在`main`函数中用于开始解析作为命令行提供的任何标志的过程。例如，要计算具有12伏特和300欧姆的电路的电流，程序需要三个标志，并产生如下输出：'
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Building and installing programs
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和安装程序
- en: Building and installing Go programs follow the exact same procedures as building
    a regular package (as was discussed earlier in the *Building and installing packages*
    section). When you build source files of an executable Go program, the compiler
    will generate an executable binary file by transitively linking all the decencies
    declared in the `main` package. The build tool will name the output binary, by
    default the same name as the directory where the Go program source files are located.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和安装Go程序遵循与构建常规包相同的程序（如在*构建和安装包*部分中讨论的）。当您构建可执行的Go程序的源文件时，编译器将通过传递链接`main`包中声明的所有依赖项来生成可执行的二进制文件。构建工具将默认使用与包含Go程序源文件的目录相同的名称命名输出二进制文件。
- en: 'For instance, in the Ohm''s Law example, the file `main.go`, which is located
    in the directory `github.com/vladimirvivien/learning-go/ch06`, is declared to
    be part of the `main` package. The program can be built as shown in the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Ohm's Law示例中，位于目录`github.com/vladimirvivien/learning-go/ch06`中的文件`main.go`被声明为`main`包的一部分。程序可以按以下方式构建：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When the `main.go` source file is built, the build tool will generate a binary
    named `ch06` because the source code for the program is located in a directory
    with that name. You can control the name of the binary using the output flag `-o`.
    In the following example, the build tool creates a binary file named `ohms`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建`main.go`源文件时，构建工具将生成一个名为`ch06`的二进制文件，因为程序的源代码位于具有该名称的目录中。您可以使用输出标志`-o`来控制二进制文件的名称。在以下示例中，构建工具将创建一个名为`ohms`的二进制文件。
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Lastly, installing a Go program is done in exactly the same way as installing
    a regular package using the Go `install` command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，安装Go程序的方法与使用Go `install`命令安装常规包的方法完全相同：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When a program is installed using the Go install command, it will be built,
    if necessary, and its generated binary will be saved in the `$GOPAHT/bin` directory.
    Adding the workspace `bin` directory to your OS's `$PATH` environment variable
    will make your Go program available for execution.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go install命令安装程序时，如果需要，将构建该程序，并将生成的二进制文件保存在`$GOPAHT/bin`目录中。将工作区`bin`目录添加到您的操作系统的`$PATH`环境变量中，将使您的Go程序可供执行。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Go-generated programs are statically linked binaries. They require no additional
    dependencies to be satisfied to run. However, Go-compiled binaries include the
    Go runtime. This is the set of operations that handle functionalities such as
    garbage collection, type information, reflection, goroutines scheduling, and panic
    management. While a comparable C program would be order of magnitudes smaller,
    Go's runtime comes with the tools that make Go enjoyable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Go生成的程序是静态链接的二进制文件。它们不需要满足任何额外的依赖关系就可以运行。但是，Go编译的二进制文件包括Go运行时。这是一组处理功能的操作，如垃圾回收、类型信息、反射、goroutines调度和panic管理。虽然可比的C程序会小上几个数量级，但Go的运行时带有使Go变得愉快的工具。
- en: Remote packages
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程软件包
- en: 'One of the tools that is shipped with Go allows programmers to retrieve packages
    directly from remote source code repositories. Go, by default, readily supports
    integration with version control systems including the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Go附带的工具之一允许程序员直接从远程源代码存储库检索软件包。默认情况下，Go可以轻松支持与以下版本控制系统的集成：
- en: Git (`git`, [http://git-scm.com/](http://git-scm.com/))
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git（`git`，[http://git-scm.com/](http://git-scm.com/)）
- en: Mercurial (`hg`, [https://www.mercurial-scm.org/](https://www.mercurial-scm.org/))
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mercurial（`hg`，[https://www.mercurial-scm.org/](https://www.mercurial-scm.org/)）
- en: Subversion (`svn`, [http://subversion.apache.org/](http://subversion.apache.org/))
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion（`svn`，[http://subversion.apache.org/](http://subversion.apache.org/)）
- en: Bazaar (`bzr`, [http://bazaar.canonical.com/](http://bazaar.canonical.com/))
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bazaar（`bzr`，[http://bazaar.canonical.com/](http://bazaar.canonical.com/)）
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order for Go to pull package source code from a remote repository, you must
    have a client for that version control system installed as a command on your operating
    system's execution path. Under the cover, Go launches the client to interact with
    the source code repository server.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Go从远程存储库中拉取软件包源代码，您必须在操作系统的执行路径上安装该版本控制系统的客户端作为命令。在幕后，Go启动客户端与源代码存储库服务器进行交互。
- en: 'The `get` command-line tool allows programmers to retrieve remote packages
    using a fully qualified project path as the import path for the package. Once
    the package is downloaded, it can be imported for use in local source files. For
    instance, if you wanted to include one of the packages from the Ohm''s Law example
    from preceding snippet, you would issue the following command from the command-line:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`命令行工具允许程序员使用完全合格的项目路径作为软件包的导入路径来检索远程软件包。一旦软件包被下载，就可以在本地源文件中导入以供使用。例如，如果您想要包含前面片段中Ohm''s
    Law示例中的一个软件包，您可以从命令行发出以下命令：'
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `go get` tool will download the specified import path along with all referenced
    dependencies. The tool will then build and install the package artifacts in `$GOPATH/pkg`.
    If the `import` path happens to be a program, go get will generate the binary
    in `$GOPATH/bin` as well as any referenced packages in `$GOPATH/pkg`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get`工具将下载指定的导入路径以及所有引用的依赖项。然后，该工具将在`$GOPATH/pkg`中构建和安装软件包工件。如果`import`路径恰好是一个程序，go
    get还将在`$GOPATH/bin`中生成二进制文件，以及在`$GOPATH/pkg`中引用的任何软件包。'
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter presented an extensive look into the notion of source code organization
    and packages. Readers learned about the Go workspace and the import path. Readers
    were also introduced to the creation of packages and how to import packages to
    achieve code reusability. The chapter introduced mechanisms such as visibility
    of imported members and package initialization. The last portion of the chapter
    discussed the steps that are necessary to create an executable Go program from
    packaged code.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了源代码组织和软件包的概念。读者了解了Go工作区和导入路径。读者还了解了如何创建软件包以及如何导入软件包以实现代码的可重用性。本章介绍了诸如导入成员的可见性和软件包初始化之类的机制。本章的最后部分讨论了从打包代码创建可执行Go程序所需的步骤。
- en: This was a lengthy chapter, and deservedly so to do justice to such a broad
    topic as package creation and management in Go. The next chapter returns to the
    Go types discussion with a detailed treatment of the composite types, such as
    array, slice, struct, and map.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个冗长的章节，理所当然地对Go中软件包创建和管理这样一个广泛的主题进行了公正的处理。下一章将详细讨论复合类型，如数组、切片、结构和映射，回到Go类型讨论。
