- en: Chapter 7. Composite Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。复合类型
- en: 'In prior chapters, you may have caught glimpses of the use of composite types
    such as arrays, slices, maps, and structs in some of the sample code. While early
    exposure to these types may have left you curious, rest assured in this chapter
    you will get a chance to learn all about these composite types. This chapter continues
    what started in [Chapter 4](ch04.html "Chapter 4. Data Types"), *Data Types*,
    with discussions covering the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您可能已经在一些示例代码中看到了复合类型（如数组、切片、映射和结构体）的使用。尽管对这些类型的早期接触可能让您感到好奇，但请放心，在本章中，您将有机会了解所有这些复合类型。本章继续了[第4章](ch04.html
    "第4章。数据类型")*数据类型*中开始的内容，讨论了以下主题：
- en: The array type
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组类型
- en: The slice type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片类型
- en: The map type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射类型
- en: The struct type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构类型
- en: The array type
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组类型
- en: 'As you would find in other languages, Go arrays are containers for storing
    sequenced values of the same type that are numerically indexed. The following
    code snippet shows samples of variables that are assigned array types:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在其他语言中所看到的那样，Go数组是用于存储相同类型的序列化值的容器，这些值是按数字索引的。以下代码片段显示了分配了数组类型的变量的示例：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch07/arrtypes.go
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arrtypes.go
- en: 'Notice the types that are assigned to each variable in the previous example
    are specified using the following type format:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面示例中分配给每个变量的类型是使用以下类型格式指定的：
- en: '*[<length>]<element_type>*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*[<长度>]<元素类型>*'
- en: 'The type definition of an array is composed of its length, enclosed within
    brackets, followed by the type of its stored elements. For instance, the `days`
    variable is assigned a type `[7]string`. This is an important distinction as Go''s
    type system considers two arrays, storing the same type of elements but with different
    lengths, to be of different types. The following code illustrates this situation:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的类型定义由其长度组成，用括号括起来，后跟其存储元素的类型。例如，`days`变量被分配了类型`[7]string`。这是一个重要的区别，因为Go的类型系统认为存储相同类型元素但长度不同的两个数组是不同类型。以下代码说明了这种情况：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even though both variables are arrays with elements of type `string`, the type
    system considers the `days` and `weekdays` variables as different types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个变量都是具有`string`类型元素的数组，但类型系统将`days`和`weekdays`变量视为不同类型。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Later in the chapter, you will see how this type restriction is mitigated with
    the use of the slice type instead of arrays.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，您将看到如何使用切片类型而不是数组来缓解这种类型限制。
- en: 'Array types can be defined to be multi-dimensions. This is done by combining
    and nesting the definition of one-dimensional array types as shown in the following
    snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数组类型可以定义为多维的。这是通过将一维数组类型的定义组合和嵌套来实现的，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch07/arrtypes.go
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arrtypes.go
- en: Go does not have a separate type for multi-dimensional arrays. An array with
    more than one dimension is composed of one-dimensional arrays that are nested
    within each other. The next section covers how single and multi-dimensional arrays
    are initialized.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Go没有单独的多维数组类型。具有多个维度的数组由相互嵌套的一维数组组成。下一节将介绍如何初始化单维和多维数组。
- en: Array initialization
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组初始化
- en: 'When an array variable is not explicitly initialized, all of its elements will
    be assigned the zero-value for the declared type of the elements. An array can
    be initialized with a composite literal value with the following general format:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组变量没有明确初始化时，所有元素将被分配为元素声明类型的零值。数组可以使用复合文字值进行初始化，其一般格式如下：
- en: '*<array_type>{<comma-separated list of element values>}*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*<数组类型>{<逗号分隔的元素值列表>}*'
- en: 'The literal value for an array is composed of the array type definition (discussed
    in the previous section) followed by a set of comma-separated values, enclosed
    in curly brackets, as illustrated by the following code snippet, which shows several
    arrays being declared and initialized:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的文字值由数组类型定义（在前一节中讨论）组成，后跟一组逗号分隔的值，用大括号括起来，如下面的代码片段所示，其中显示了声明和初始化了几个数组：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch07/arrinit.go
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arrinit.go
- en: 'The number of elements in the literal must be less than or equal to the size
    declared in the array type. If the array defined is multi-dimensional, it can
    be initialized using literal values by nesting each dimension within the enclosing
    brackets of another, as shown in the following example snippets:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 文字值中的元素数量必须小于或等于数组类型中声明的大小。如果定义的数组是多维的，可以通过将每个维度嵌套在另一个括号的括号中，使用文字值进行初始化，如下面的示例代码片段所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: golang.fyi/ch07/arrinit.go
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arrinit.go
- en: 'The following snippet shows two additional ways that array literals can be
    specified. The length of an array may be omitted and replaced by ellipses during
    initialization. The following will assign type `[5]string` to variable `weekdays`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了指定数组文字的另外两种方式。在初始化期间，数组的长度可以被省略并用省略号替换。以下将类型`[5]string`分配给变量`weekdays`：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The literal value of an array can also be indexed. This is useful if you want
    to initialize only certain array elements while allowing others to be initialized
    with their natural zero-value. The following specifies the initial values for
    elements at positions 0, `2`, `4`, `6`, `8`. The remaining elements will be assigned
    the empty string:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的文字值也可以被索引。如果您只想初始化某些数组元素，同时允许其他元素以它们的自然零值进行初始化，这将非常有用。以下指定了位置0、`2`、`4`、`6`、`8`的元素的初始值。其余元素将被分配为空字符串：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Declaring named array types
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明命名数组类型
- en: 'The type of an array can become awkward for reuse. For each declaration, it
    becomes necessary to repeat the declaration, which can be error prone. The way
    to handle this idiomatically is to alias array types using type declarations.
    To illustrate how this works, the following code snippet declares a new named
    type, `matrix`, using a multi-dimension array as its underlying type:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的类型可能会变得难以重用。对于每个声明，需要重复声明，这可能会出错。处理这种习惯用法的方法是使用类型声明别名数组类型。为了说明这是如何工作的，以下代码片段声明了一个新的命名类型`matrix`，使用多维数组作为其基础类型：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: golang.fyi/ch07/arrtype_dec.go
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arrtype_dec.go
- en: The declared named type, `matrix`, can be used in all contexts where its underlying
    array type is used. This allows a simplified syntax that promotes reuse of the
    complex array type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的命名类型`matrix`可以在使用其基础数组类型的所有上下文中使用。这允许使用简化的语法，促进复杂数组类型的重用。
- en: Using arrays
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组
- en: Arrays are static entities that cannot grow or shrink in size once they are
    declared with a specified length. Arrays are a great option when a program needs
    to allocate a block of sequential memory of a predefined size. When a variable
    of an array type is declared, it is ready to be used without any further allocation
    semantics.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是静态实体，一旦使用指定的长度声明，就无法增长或缩小。当程序需要分配预定义大小的连续内存块时，数组是一个很好的选择。当声明数组类型的变量时，它已经准备好在没有任何进一步分配语义的情况下使用。
- en: 'So the following declaration of the `image` variable would allocate a memory
    block composed of 256 adjacent `int` values initialized with zeroes, as shown
    in the following figure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`image`变量的以下声明将分配一个由256个相邻的`int`值组成的内存块，并用零初始化，如下图所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Using arrays](img/image_07_001.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![使用数组](img/image_07_001.jpg)'
- en: 'Similar to C and Java, Go uses the square brackets index expression to access
    values stored in an array variable. This is done by specifying the variable identifier
    followed by an index of the element enclosed within the square brackets, as shown
    in the following code sample:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与C和Java类似，Go使用方括号索引表达式来访问存储在数组变量中的值。这是通过指定变量标识符，后跟方括号括起来的元素的索引来完成的，如下面的代码示例所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The previous code updates the fifth element and prints the first element in
    the array.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码更新了数组中的第五个元素，并打印了数组中的第一个元素。
- en: Array length and capacity
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组长度和容量
- en: 'The built-in `len` function returns the declared length of an array type. The
    built-in `cap` function can be used on an array to return its capacity. For instance,
    in the following source snippet, the array `seven` of type `[7]string` will return
    `7` as its length and capacity:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`len`函数返回数组类型的声明长度。内置的`cap`函数可以用于返回数组的容量。例如，在以下源代码片段中，类型为`[7]string`的数组`seven`将返回`7`作为其长度和容量：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For arrays, the `cap()` function always returns the same value as `len()`. This
    is because the maximum capacity of an array value is its declared length. The
    capacity function is better suited for use with the slice type (discussed later
    in the chapter).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，`cap()`函数始终返回与`len()`相同的值。这是因为数组值的最大容量是其声明的长度。容量函数更适合与切片类型一起使用（稍后在本章中讨论）。
- en: Array traversal
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组遍历
- en: 'Array traversal can be done using the traditional `for` statement or with the
    more idiomatic `for…range` statement. The following snippet of code shows array
    traversal done with both the `for` statement, to initialize an array with random
    numbers in `init()`, and the `for` range statement used to realize the `max()`
    function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数组遍历可以使用传统的`for`语句或更符合习惯的`for…range`语句。以下代码片段显示了使用`for`语句进行数组遍历，以在`init()`中使用随机数初始化数组，并使用`for`范围语句实现`max()`函数：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: golang.fyi/ch07/arrmax_iter.go
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arrmax_iter.go
- en: In the traditional `for` statement, the loop's index variable `i` is used to
    access the value of the array using the index expression `num[i]`. In the `for…range`
    statement, in the `max` function, the iterated value is stored in the `val` variable
    with each pass of the loop and the index is ignored (assigned to the blank identifier).
    If you do not understand how *for* statements work, refer to [Chapter 3](ch03.html
    "Chapter 3. Go Control Flow"), *Go Control Flow*, for a thorough explanation of
    the mechanics of loops in Go.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的`for`语句中，循环的索引变量`i`用于使用索引表达式`num[i]`访问数组的值。在`for…range`语句中，在`max`函数中，迭代的值存储在`val`变量中，每次循环都会忽略索引（分配给空白标识符）。如果您不了解*for*语句的工作原理，请参阅[第3章](ch03.html
    "第3章。Go控制流")，*Go控制流*，详细解释Go中循环的机制。
- en: Array as parameters
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组作为参数
- en: Arrays values are treated as a single unit. An array variable is not a pointer
    to a location in memory, but rather represents the entire block of memory containing
    the array elements. This has the implications of creating a new copy of an array
    value when the array variable is reassigned or passed in as a function parameter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数组值被视为单个单元。数组变量不是指向内存中的位置的指针，而是表示包含数组元素的整个内存块。当重新分配数组变量或将其作为函数参数传递时，这意味着创建数组值的新副本。
- en: 'This could have unwanted side effects on memory consumption for a program.
    One fix for is to use pointer types to reference array values. In the following
    example, a named type, `numbers`, is declared to represent array type `[1024 *
    1024]]int`. Instead of taking the array value directly as parameters, functions
    `initialize()` and `max()` receive a pointer of type `*numbers`, as shown in the
    following source snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会对程序的内存消耗产生不良的副作用。一个解决方法是使用指针类型来引用数组值。在以下示例中，声明了一个命名类型`numbers`，表示数组类型`[1024
    * 1024]]int`。函数`initialize()`和`max()`不直接接受数组值作为参数，而是接受`*numbers`类型的指针，如下面的源代码片段所示：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: golang.fyi/ch07/arrptr.go
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arrptr.go
- en: The previous code uses the built-in function `new(numbers)` to initialize the
    array elements with their zero values and obtain a pointer to that array as shown
    in `main()`. So when the functions `initialize` and `max` are invoked, they will
    receive the address (a copy of it) of the array instead of the entire 100K-sized
    array.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用内置函数`new(numbers)`来初始化数组元素为它们的零值，并在`main()`中获取指向该数组的指针。因此，当调用`initialize`和`max`函数时，它们将接收到数组的地址（其副本），而不是整个大小为100K的数组。
- en: 'Before changing the subject, it should be noted that a composite literal array
    value can be initialized with the address operator `&` to initialize and return
    a pointer for the array, as shown in the following example. In the snippet, composite
    literal `&galaxies{...}` returns pointer `*galaxies`, initialized with the specified
    element values:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在改变主题之前，应该注意到复合文字数组值可以使用地址运算符`&`初始化并返回数组的指针，如下例所示。在代码片段中，复合文字`&galaxies{...}`返回指针`*galaxies`，并用指定的元素值初始化：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: golang.fyi/ch07/arraddr.go
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/arraddr.go
- en: The array type is a low-level storage construct in Go. Arrays, for instance,
    are usually used as the basis for storage primitives, where there are strict memory
    allocation requirements to minimize space consumption. In more common cases however,
    the slice, covered in the next section, is often used as the more idiomatic way
    of working with sequenced indexed collections.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 数组类型是Go中的低级存储构造。例如，数组通常用作存储原语的基础，其中有严格的内存分配要求以最小化空间消耗。然而，在更常见的情况下，切片，下一节中介绍的，通常被用作处理序列化索引集合的更成语化的方式。
- en: The slice type
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片类型
- en: 'The slice type is commonly used as the idiomatic construct for indexed data
    in Go. The slice is more flexible and has many more interesting characteristics
    than arrays. The slice itself is a composite type with semantics similar to arrays.
    In fact, a slice uses an array as its underlying data storage mechanism. The general
    form of a slice type is given as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 切片类型通常用作Go中索引数据的成语构造。切片比数组更灵活，具有许多更有趣的特性。切片本身是一种具有类似数组语义的复合类型。实际上，切片使用数组作为其底层数据存储机制。切片类型的一般形式如下所示：
- en: '*[ ]<element_type>*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*[ ]<element_type>*'
- en: 'The one obvious difference between a slice and an array type is omission of
    the size in the type declaration, as shown in the following examples:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 切片和数组类型之间一个明显的区别是在类型声明中省略了大小，如下面的例子所示：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: golang.fyi/ch07/slicetypes.go
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slicetypes.go
- en: 'The missing size attribute in the slice type indicates the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 切片类型中缺少的大小属性表示以下内容：
- en: Unlike arrays, the size of a slice is not fixed
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数组不同，切片的大小是不固定的
- en: A slice type represents all sets of the specified element type
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片类型表示指定元素类型的所有集合
- en: This means a slice can theoretically grow unbounded (though in practice this
    is not true as the slice is backed by an underlying bounded array). A slice of
    a given element type is considered to be the same type regardless of its underlying
    size. This removes the restriction found in arrays where the size determines the
    type.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着切片在理论上可以无限增长（尽管在实践中这并不是真的，因为切片由底层有界数组支持）。给定元素类型的切片被认为是相同类型，而不管其底层大小如何。这消除了数组中大小决定类型的限制。
- en: 'For instance, the following variables, `months` and `q1`, have the same type
    of `[]string` and will compile with no problem:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下变量`months`和`q1`具有相同的`[]string`类型，并且将编译没有问题：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch07/slicetypes.go
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slicetypes.go
- en: 'Similar to arrays, slice types may be nested to create multi-dimensional slices,
    as shown in the following code snippet. Each dimension can independently have
    its own size and must be initialized individually:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，切片类型可以嵌套以创建多维切片，如下面的代码片段所示。每个维度可以独立地具有自己的大小，并且必须单独初始化：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Slice initialization
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片初始化
- en: A slice is represented by the type system as a value (the next section explores
    the internal representation of a slice). However, unlike the array type, an uninitialized
    slice has a zero value of *nil*, which means any attempt to access elements of
    an uninitialized slice will cause a program to panic.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 切片在类型系统中表示为一个值（下一节将探讨切片的内部表示）。然而，与数组类型不同，未初始化的切片具有*nil*的零值，这意味着任何尝试访问未初始化切片的元素都会导致程序恐慌。
- en: 'One of the simplest ways to initialize a slice is with a composite literal
    value using the following format (similar to an array):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化切片的最简单方法之一是使用以下格式的复合文字值（类似于数组）：
- en: '*<slice_type>{<comma-separated list of element values>}*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*<slice_type>{<comma-separated list of element values>}*'
- en: 'The literal value for a slice is composed of the slice type followed by a set
    of comma-separated values, enclosed in curly brackets, that are assigned to the
    elements of the slice. The following code snippet illustrates several slice variables
    initialized with composite literal values:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的文字值由切片类型和一组逗号分隔的值组成，这些值被分配给切片的元素，并用大括号括起来。以下代码片段说明了用复合文字值初始化的几个切片变量：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: golang.fyi/ch07/sliceinit.go
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/sliceinit.go
- en: As mentioned, the composite literal value of a slice is expressed using a similar
    form as the array. However, the number of elements provided in the literal is
    not bounded by a fixed size. This implies that the literal can be as large as
    needed. Under the cover though, Go creates and manages an array of appropriate
    size to store the values expressed in the literal.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，切片的复合文字值使用与数组类似的形式表示。但是，文字中提供的元素数量不受固定大小的限制。这意味着文字可以根据需要很大。尽管如此，Go在幕后创建和管理一个适当大小的数组来存储文字中表达的值。
- en: Slice representation
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片表示
- en: 'Earlier it was mentioned that the slice value uses an underlying array to store
    data. The name *slice*, in fact, is a reference to a slice of data segment from
    the array. Internally, a slice is represented by a composite value with the followings
    three attributes:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到切片值使用基础数组来存储数据。实际上，*切片*这个名称是指数组中的数据段的引用。在内部，切片由以下三个属性表示：
- en: '| **Attribute** | **Description** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| a *pointer* | The pointer is the address of the first element of the slice
    stored in an underlying array. When the slice value is uninitialized, its pointer
    value is nil, indicating that it is not pointing to an array yet.Go uses the pointer
    as the zero value of the slice itself. An uninitialized slice will return nil
    as its zero value. However, the slice value is not treated as a reference value
    by the type system. This means certain functions can be applied to a nil slice
    while others will cause a panic.Once a slice is created, the pointer does not
    change. To point to a different starting point, a new slice must be created. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| a *指针* | 指针是存储在基础数组中的切片的第一个元素的地址。当切片值未初始化时，其指针值为nil，表示它尚未指向数组。Go使用指针作为切片本身的零值。未初始化的切片将返回nil作为其零值。但是，切片值在类型系统中不被视为引用值。这意味着某些函数可以应用于nil切片，而其他函数将导致恐慌。一旦创建了切片，指针就不会改变。要指向不同的起始点，必须创建一个新的切片。
    |'
- en: '| a *length* | The length indicates the number of contiguous elements that
    can be accessed starting with the first element. It is a dynamic value that can
    grow up to the capacity of the slice (see capacity next).The length of a slice
    is always less than or equal to its capacity. Attempts to access elements beyond
    the length of a slice, without resizing, will result in a panic. This is true
    even when the capacity is larger than the length. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| a *长度* | 长度表示可以从第一个元素开始访问的连续元素的数量。它是一个动态值，可以增长到切片的容量（见下文）。切片的长度始终小于或等于其容量。尝试访问超出切片长度的元素，而不进行调整大小，将导致恐慌。即使容量大于长度，这也是真的。
    |'
- en: '| a *capacity* | The capacity of a slice is the maximum number of elements
    that may be stored in the slice, starting from its first element. The capacity
    of a slice is bounded by the length of the underlying array. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| a *容量* | 切片的容量是可以从其第一个元素开始存储的最大元素数量。切片的容量受基础数组的长度限制。 |'
- en: 'So, when the following variable `halfyr` is initialized as shown:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当初始化以下变量`halfyr`时如下所示：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It will be stored in an array of type `[6]string` with a pointer to the first
    element, a length, and a capacity of `6`, as represented graphically in the following
    figure:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它将存储在类型为`[6]string`的数组中，具有指向第一个元素的指针，长度和容量为`6`，如下图形式地表示：
- en: '![Slice representation](img/B036376_07_02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![切片表示](img/B036376_07_02.jpg)'
- en: Slicing
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: 'Another way to create a slice value is by slicing an existing array or another
    slice value (or pointers to these values). Go provides an indexing format that
    makes it easy to express the slicing operation, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建切片值的方法是通过对现有数组或另一个切片值（或指向这些值的指针）进行切片。Go提供了一种索引格式，使得表达切片操作变得容易，如下所示：
- en: '*<slice or array value>[<low_index>:<high_index>]*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*<切片或数组值>[<低索引>:<高索引>]*'
- en: The slicing expression uses the [`:`] operator to specify the low and high bound
    indices, separated by a colon, for the slice segment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 切片表达式使用[`:`]运算符来指定切片段的低和高边界索引，用冒号分隔。
- en: The *low* value is the zero-based index where the slice segment starts
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*低*值是切片段开始的从零开始的索引'
- en: The *high* value is the *n^(th)* element offset where the segment stops
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高*值是段停止的第*n*个元素偏移量'
- en: 'The following table shows examples of slice expressions by re-slicing the following
    value: `halfyr := []string{"Jan","Feb","Mar","Apr","May","Jun"}`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了通过重新切片以下值的切片表达式的示例：`halfyr := []string{"Jan","Feb","Mar","Apr","May","Jun"}`。
- en: '| **Expression** | **Description** |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| `all := halfyr[:]` | Omitting the low and high indices in the expression
    is equivalent to the following:`all := halfyr[0 : 6]`This produces a new slice
    segment equal to the original, which starts at index position 0 and stops at offset
    position `6`:`["Jan","Feb","Mar","Apr","May","Jun"]` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `all := halfyr[:]` | 省略表达式中的低和高索引相当于以下操作：`all := halfyr[0 : 6]`这将产生一个新的切片段，与原始切片相等，从索引位置0开始，停在偏移位置`6`：`["Jan","Feb","Mar","Apr","May","Jun"]`
    |'
- en: '| `q1 := halfyr[:3]` | Here the slice expression omits low index value and
    specifies a slice segment length of `3`. It returns new slice, `["Jan","Feb","Mar"]`.
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `q1 := halfyr[:3]` | 这里的切片表达式省略了低索引值，并指定了长度为`3`的切片段。它返回新的切片，`["Jan","Feb","Mar"]`。
    |'
- en: '| `q2 := halfyr[3:]` | This creates a new slice segment with the last three
    elements by specifying the staring index position of `3` and omitting the high
    bound index value, which defaults to `6`. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `q2 := halfyr[3:]` | 这将通过指定起始索引位置为`3`并省略高边界索引值（默认为`6`）创建一个新的切片段，其中包含最后三个元素。
    |'
- en: '| `mapr := halfyr[2:4]` | To clear any confusion about slicing expressions,
    this example shows how to create a new slice with the months `"Mar"` and `"Apr"`.
    This returns a slice with the value `["Mar","Apr"]`. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `mapr := halfyr[2:4]` | 为了消除对切片表达式的任何困惑，这个例子展示了如何创建一个包含月份`"Mar"`和`"Apr"`的新切片。这将返回一个值为`["Mar","Apr"]`的切片。
    |'
- en: Slicing a slice
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片切片
- en: 'Slicing an existing slice or array value does not create a new underlying array.
    The new slice creates new pointer location to the underlying array. For instance,
    the following code shows the slicing of the slice value `halfyr` into two additional
    slices:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对现有切片或数组值进行切片操作不会创建新的基础数组。新的切片会创建指向基础数组的新指针位置。例如，以下代码显示了将切片值`halfyr`切片成两个额外切片的操作：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: golang.fyi/ch07/slice_reslice.go
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_reslice.go
- en: 'The backing array may have many slices projecting a particular view of its
    data. The following figure illustrates how slicing in the previous code may be
    represented visually:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 支持数组可能有许多投影其数据的切片。以下图示说明了在前面的代码中切片可能如何在视觉上表示：
- en: '![Slicing a slice](img/image_07_003.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![切片切片](img/image_07_003.jpg)'
- en: Notice that both slices `q1` and `q2` are pointing to different elements in
    the same underlying array. Slice `q1` has an initial length of `3` with a capacity
    of `6`. This implies `q1` can be resized up to `6` elements in total. Slice `q2`,
    however, has a size of `3` and a capacity of `3` and cannot grow beyond its initial
    size (slice resizing is covered later).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，切片`q1`和`q2`都指向同一基础数组中的不同元素。切片`q1`的初始长度为`3`，容量为`6`。这意味着`q1`可以调整大小，最多达到`6`个元素。然而，切片`q2`的大小为`3`，容量为`3`，不能超出其初始大小（切片调整大小将在后面介绍）。
- en: Slicing an array
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片数组
- en: 'As mentioned, an array can also be sliced directly. When that is the case,
    the provided array value becomes the underlying array. The capacity and the length
    the slices will be calculated using the provided array. The following source snippet
    shows the slicing of an existing array value called months:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，数组也可以直接进行切片。在这种情况下，提供的数组值将成为基础数组。使用提供的数组将计算切片的容量和长度。以下源代码片段显示了对名为months的现有数组值进行切片：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch07/slice_reslice_arr.go
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_reslice_arr.go
- en: Slice expressions with capacity
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有容量的切片表达式
- en: 'Lastly, Go''s slice expression supports a longer form where the maximum capacity
    of the slice is included in the expression, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Go的切片表达式支持更长的形式，其中包括切片的最大容量，如下所示：
- en: '*<slice_or_array_value>[<low_index>:<high_index>:max]*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*<slice_or_array_value>[<low_index>:<high_index>:max]*'
- en: 'The *max* attribute specifies the index value to be used as the maximum capacity
    of the new slice. That value may be less than, or equal to, the actual capacity
    of the underlying array. The following example slices an array with the max value
    included:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*max*属性指定要用作新切片的最大容量的索引值。该值可以小于或等于基础数组的实际容量。以下示例对包含最大值的数组进行切片：'
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: golang.fyi/ch07/slice_reslice_arr.go
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_reslice_arr.go
- en: The previous code snippet creates a new slice value `summer1` with size `3`
    (starting at index position `6` to `9`). The max index is set to position `9`,
    which means the slice has a capacity of `3`. If the max was not specified, the
    maximum capacity would automatically be set to the last position of the underlying
    array as before.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段创建了一个新的切片值`summer1`，大小为`3`（从索引位置`6`到`9`）。最大索引设置为位置`9`，这意味着切片的容量为`3`。如果未指定最大值，则最大容量将自动设置为基础数组的最后一个位置，与以前一样。
- en: Making a slice
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建切片
- en: 'A slice can be initialized at runtime using the built-in function `make`. This
    function creates a new slice value and initializes its elements with the zero
    value of the element type. An uninitialized slice has a nil zero value an indication
    that it is not pointing an underlying array. Without an explicitly initialization,
    with a composite literal value or using the `make()` function, attempts to access
    elements of a slice will cause a panic. The following snippet reworks the previous
    example to use the `make()` function to initialize the slice:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 切片可以在运行时使用内置函数`make`进行初始化。此函数创建一个新的切片值，并使用元素类型的零值初始化其元素。未初始化的切片具有零值nil，表示它不指向基础数组。如果没有显式初始化，使用复合文字值或使用`make()`函数，尝试访问切片的元素将导致恐慌。以下代码片段重新使用`make()`函数初始化切片的示例：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: golang.fyi/ch07/slicemake.go
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slicemake.go
- en: 'The `make()` function takes as an argument the type of the slice to be initialized
    and an initial size for the slice. Then it returns a slice value. In the previous
    snippet, `make()` does the followings:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`make()`函数以切片的类型作为参数进行初始化，并为切片设置初始大小。然后返回一个切片值。在前面的代码片段中，`make()`执行以下操作：'
- en: Creates an underlying array of type `[6]string`
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类型为`[6]string`的基础数组
- en: Creates the slice value with length and capacity of `6`
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建长度和容量为`6`的切片值
- en: Returns a slice value (not a pointer)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回切片值（而不是指针）
- en: 'After initialization with the `make()` function, access to a legal index position
    will return the zero value for the slice element instead of causing a program
    panic. The `make()` function can take an optional third parameter that specifies
    the maximum capacity of the slice, as shown in the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make()`函数初始化后，访问合法的索引位置将返回切片元素的零值，而不会导致程序恐慌。`make()`函数可以接受一个可选的第三个参数，指定切片的最大容量，如下例所示：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: golang.fyi/ch07/slicemake2.go
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slicemake2.go
- en: The preceding snippet will initialize the `months` variable with a slice value
    with an initial length of `6` and a maximum capacity of `12`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将使用初始长度为`6`和最大容量为`12`的切片值初始化`months`变量。
- en: Using slices
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用切片
- en: 'The simplest operation to do with a slice value is to access its elements.
    As was mentioned, slices use index notation to access its elements similar to
    arrays. The following example accesses element at index position 0 and updates
    to `15`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 切片值最简单的操作是访问其元素。正如前面提到的，切片使用索引表示法来访问其元素，类似于数组。以下示例访问索引位置0的元素并更新为`15`：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: golang.fyi/ch07/slice_use.go
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_use.go
- en: When the program runs, it prints the updated value using index expression `h[0]`
    to retrieve the value of the item at position `0`. Note that the slice expression
    with only the index number, `h[0]` for instance, returns the value of the item
    at that position. When, however, the expression includes a colon, say `h[2:]`
    or `h[:6]`, that expression returns a new slice.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行时，使用索引表达式`h[0]`打印更新后的值。请注意，仅使用索引号的切片表达式，例如`h[0]`，将返回该位置的项目的值。然而，如果表达式包括冒号，比如`h[2:]`或`h[:6]`，该表达式将返回一个新的切片。
- en: 'Slice traversal can be done using the traditional `for`statement or with the,
    more idiomatic, `for…range` statement as shown in the following code snippets:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 切片遍历可以使用传统的`for`语句，也可以使用更符合惯例的`for…range`语句，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: golang.fyi/ch07/slice_loop.go
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_loop.go
- en: In the previous code snippet, function `scale` uses index variable `i` to update
    the values in slice `factor` directly, while function `contains` uses the iteration-emitted
    value stored in `num` to access the slice element. If you need further detail
    on the `for…range` statement, see [Chapter 3](ch03.html "Chapter 3. Go Control
    Flow"), *Go Control Flow*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，函数`scale`使用索引变量`i`直接更新切片`factor`中的值，而函数`contains`使用存储在`num`中的迭代产生的值来访问切片元素。如果您需要关于`for…range`语句的更多细节，请参阅[第3章](ch03.html
    "第3章。Go控制流")*Go控制流*。
- en: Slices as parameters
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片作为参数
- en: 'When a function receives a slice as its parameter, the internal pointer of
    that slice points to the underlying array of the slice. Therefore, all updates
    to the slice, within the function, will be seen by the function''s caller. For
    instance, in the following code snippet, all changes to the `vector` parameter
    will be seen by the caller of function `scale`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数接收切片作为其参数时，该切片的内部指针将指向切片的基础数组。因此，在函数内部对切片的所有更新都将被函数的调用者看到。例如，在下面的代码片段中，对`vector`参数的所有更改都将被`scale`函数的调用者看到：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: golang.fyi/ch07/slice_loop.go
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_loop.go
- en: Length and capacity
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长度和容量
- en: 'Go provides two built-in functions to query the length and capacity attributes
    of a slice. Given a slice, its length and maximum capacity can be queried, using
    the `len` and `cap` functions respectively, as shown in the following example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了两个内置函数来查询切片的长度和容量属性。给定一个切片，可以使用`len`和`cap`函数分别查询其长度和最大容量，如下例所示：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Recall that a slice is a value (not a pointer) that has a nil as its zero-value.
    Therefore, the code is able to query the length (and capacity) of an uninitialized
    slice without causing a panic at runtime.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，切片是一个值（而不是指针），其零值为nil。因此，代码能够查询未初始化切片的长度（和容量），而不会在运行时引发恐慌。
- en: Appending to slices
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向切片添加元素
- en: 'The one indispensable feature of slice types is their ability to dynamically
    grow. By default, a slice has a static length and capacity. Any attempt to access
    an index beyond that limit will cause a panic. Go makes available the built-in
    variadic function `append` to dynamically add new values to a specified slice,
    growing its lengths and capacity, as necessary. The following code snippet shows
    how that is done:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 切片类型的一个不可或缺的特性是它们的动态增长能力。默认情况下，切片具有静态长度和容量。任何尝试访问超出该限制的索引都将引发恐慌。Go提供了内置的可变参数函数`append`，用于动态向指定的切片添加新值，根据需要增加其长度和容量。以下代码片段显示了如何实现这一点：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: golang.fyi/ch07/slice_append.go
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_append.go
- en: The previous snippet starts with a slice with a size and capacity of `3`. The
    `append` function is used to dynamically add new values to the slice beyond its
    initial size and capacity. Internally, `append` will attempt to fit the appended
    values within the target slice. If the slice has not been initialized or has an
    inadequate capacity, append will allocate a new underlying array, to store the
    values of the updated slice.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段以大小和容量为`3`的切片开始。`append`函数用于动态向切片添加新值，超出其初始大小和容量。在内部，`append`将尝试将附加的值适应目标切片。如果切片尚未初始化或容量不足，`append`将分配一个新的基础数组，以存储更新后的切片的值。
- en: Copying slices
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制切片
- en: 'Recall that assigning or slicing an existing slice value simply creates a new
    slice value pointing to the same underlying array structure. Go offers the `copy`
    function, which returns a deep copy of the slice along with a new underlying array.
    The following snippet shows a `clone()` function, which makes a new copy of a
    slice of numbers:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，分配或切片现有切片值只是创建一个指向相同基础数组结构的新切片值。Go提供了`copy`函数，它返回切片的深层副本以及一个新的基础数组。以下代码片段显示了一个`clone()`函数，它创建一个数字切片的新副本：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: golang.fyi/ch07/slice_use.go
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_use.go
- en: In the previous snippet, the `copy` function copies the content of `v` slice
    into `result`. Both source and target slices must be the same size and of the
    same type or the copy operation will fail.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，`copy`函数将`v`切片的内容复制到`result`中。源切片和目标切片必须具有相同的大小和相同的类型，否则复制操作将失败。
- en: Strings as slices
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串作为切片
- en: 'Internally, the string type is implemented as a slice using a composite value
    that points to an underlying array of rune. This affords the string type the same
    idiomatic treatment given to slices. For instance, the following code snippet
    uses index expressions to extract slices of strings from a given string value:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，字符串类型是使用指向rune的基础数组的复合值实现的切片。这使得字符串类型能够像切片一样进行惯用处理。例如，以下代码片段使用索引表达式从给定的字符串值中提取字符串切片：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: golang.fyi/ch07/slice_string.go
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_string.go
- en: 'The slice expression on a string will return a new string value pointing to
    its underlying array of runes. The string values can be converted to a slice of
    byte (or slice of rune) as shown in the following function snippet, which sorts
    the characters of a given string:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符串的切片表达式将返回一个指向其基础rune数组的新字符串值。可以将字符串值转换为字节切片（或rune切片），如下面的函数片段所示，该函数对给定字符串的字符进行排序：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch07/slice_string.go
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/slice_string.go
- en: The previous code shows the explicit conversion of a slice of bytes to a string
    value. Note that each character may be accessed using the index expression.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码显示了将字节切片显式转换为字符串值。请注意，可以使用索引表达式访问每个字符。
- en: The map type
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射类型
- en: 'The Go map is a composite type that is used as containers for storing unordered
    elements of the same type indexed by an arbitrary key value. The following code
    snippet shows a variety of map variables declarations with a variety of key types:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Go映射是一种复合类型，用作存储相同类型的无序元素的容器，由任意键值索引。以下代码片段显示了使用各种键类型声明的各种映射变量：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: golang.fyi/ch07/maptypes.go
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/maptypes.go
- en: 'The previous code snippet shows several variables declared as maps of different
    types with a variety of key types. In general, map type is specified as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段显示了几个变量声明为不同类型的映射，具有各种键类型。一般来说，映射类型的指定如下：
- en: '*map[<key_type>]<element_type>*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*map[<键类型>]<元素类型>*'
- en: The *key* specifies the type of a value that will be used to index the stored
    elements of the map. Unlike arrays and slices, map keys can be of any type, not
    just `int`. Map keys, however, must be of types that are comparable including
    numeric, string, Boolean, pointers, arrays, struct, and interface types (see [Chapter
    4](ch04.html "Chapter 4. Data Types")*, Data Types*, for discussion on comparable
    types).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*键*指定了将用于索引映射存储元素的值的类型。与数组和切片不同，映射键可以是任何类型，而不仅仅是`int`。然而，映射键必须是可比较的类型，包括数字、字符串、布尔、指针、数组、结构和接口类型（参见[第4章](ch04.html
    "第4章 数据类型")*，数据类型*，讨论可比较类型）。'
- en: Map initialization
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射初始化
- en: Similar to a slice, a map manages an underlying data structure, opaque to its
    user, to store its values. An uninitialized map has a nil zero-value as well.
    Attempts to insert into an uninitialized map will result in a program panic. Unlike
    a slice, however, it is possible to access elements from a nil map, which will
    return the zero value of the element.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与切片类似，映射管理一个底层数据结构，对其用户来说是不透明的，用于存储其值。未初始化的映射也具有零值为nil。尝试向未初始化的映射中插入值将导致程序恐慌。然而，与切片不同的是，可以从nil映射中访问元素，这将返回元素的零值。
- en: 'Like other composite types, maps may be initialized using a composite literal
    value of the following form:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他复合类型一样，映射可以使用以下形式的复合文字值进行初始化：
- en: '*<map_type>{<comma-separated list of key:value pairs>}*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*<map类型>{<逗号分隔的键:值对列表>}*'
- en: 'The following snippet shows variable initialization with map composite literals:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了使用映射复合文字进行变量初始化：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: golang.fyi/ch07/mapinit.go
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/mapinit.go
- en: The literal mapped values are specified using a colon-separated pair of key
    and value as shown in the previous example. The type of each key and value pair
    must match that of the declared elements in the map.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，使用以冒号分隔的键值对指定了文本映射的值。每个键和值对的类型必须与映射中声明的元素的类型匹配。
- en: Making Maps
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建映射
- en: 'Similar to a slice, a map value can also be initialized using the *make* function.
    Using the make function initializes the underlying storage allowing data to be
    inserted in the map as shown in the following short snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与切片类似，映射值也可以使用*make*函数进行初始化。使用make函数初始化底层存储，允许数据被插入到映射中，如下简短的代码片段所示：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: golang.fyi/ch07/maptypes.go
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/maptypes.go
- en: The `make` function takes as argument the type of the map and it returns an
    initialized map. In the previous example, the `make` function will initialize
    a map of type `map[int]string`. The `make` function can optionally take a second
    parameter to specify the capacity of the map. However, a map will continue to
    grow as needed ignoring the initial capacity specified.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`函数以映射的类型作为参数，并返回一个初始化的映射。在前面的例子中，`make`函数将初始化一个类型为`map[int]string`的映射。`make`函数还可以选择接受第二个参数来指定映射的容量。然而，映射将根据需要继续增长，忽略指定的初始容量。'
- en: Using maps
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用映射
- en: 'As is done with slice and arrays, index expressions are used to access and
    update the elements stored in maps. To set or update a `map` element, use the
    index expression, on the left side of an assignment, to specify the key of the
    element to update. The following snippet shows an element with the `"Jan"` key
    being updated with the value `100`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与切片和数组一样，索引表达式用于访问和更新映射中存储的元素。要设置或更新`map`元素，请使用索引表达式，在赋值的左侧，指定要更新的元素的键。以下代码片段显示了使用值`100`更新具有`"Jan"`键的元素：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Accessing an element with a given key is done with an index expression, placed
    on the right side of an assignment, as shown in the following example, where the
    value indexed with the `"Mar"` key is assigned the `val` variable:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引表达式访问具有给定键的元素，该表达式放置在赋值的右侧，如下例所示，在这个例子中，使用`"Mar"`键索引的值被赋给了`val`变量：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Earlier it was mentioned that accessing a non-existent key will return the
    zero-value for that element. For instance, the previous code would return 0 if
    the element with the key `"Mar"` does not exist in the map. As you can imagine,
    this can be a problem. How would you know whether you are getting an actual value
    or the zero-value? Fortunately, Go provides a way to explicitly test for the absence
    of an element by returning an optional Boolean value as part of the result of
    an index expression, as shown in the following snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到访问不存在的键将返回该元素的零值。例如，如果映射中不存在具有键`"Mar"`的元素，则前面的代码将返回0。可以想象，这可能是一个问题。你怎么知道你得到的是实际值还是零值？幸运的是，Go提供了一种明确测试元素缺失的方法，通过在索引表达式的结果中返回一个可选的布尔值，如下代码片段所示：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: golang.fyi/ch07/map_use.go
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/map_use.go
- en: The function in the preceding snippet tests the existence of a key before updating
    its value. Called the *comma-ok* idiom, the Boolean value stored in the `ok` variable
    is set to false when the value is not actually found. This allows the code to
    distinguish between the absence of a key and the zero value of the element.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，函数在更新值之前测试键的存在。称为*逗号-ok*习语，存储在`ok`变量中的布尔值在实际未找到值时设置为false。这允许代码区分键的缺失和元素的零值。
- en: Map traversal
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射遍历
- en: 'The `for…range` loop statement can be used to walk the content of a map value.
    The `range` expression emits values for both key and element values with each
    iteration. The following code snippet shows the traversal of map `hist`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`for…range`循环语句可以用来遍历映射值的内容。`range`表达式在每次迭代中发出键和元素值。以下代码片段显示了对映射`hist`的遍历：'
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: golang.fyi/ch07/map_use.go
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/map_use.go
- en: Each iteration returns a key and its associated element value. Iteration order,
    however, is not guaranteed. The internal map iterator may traverse the map in
    a different order with each run of the program. In order to maintain a predictable
    traversal order, keep (or generate) a copy of the keys in a separate structure,
    such as a slice for instance. During traversal, range over the slice of keys to
    traverse in a predictable manner.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代都会返回一个键及其关联的元素值。然而，迭代顺序并不保证。内部映射迭代器可能会在程序的每次运行中以不同的顺序遍历映射。为了保持可预测的遍历顺序，保留（或生成）键的副本在一个单独的结构中，比如一个切片。在遍历过程中，使用键的切片以可预测的方式进行遍历。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should be aware that update done to the emitted value during the iteration
    will be lost. Instead, use an index expression, such as `hist[key]` to update
    an element during iteration. For details on `for…range` loop, refer to [Chapter
    3](ch03.html "Chapter 3. Go Control Flow"), *Go Control Flow*, for a thorough
    explanation of Go `for` loops.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，在迭代期间对发出的值进行的更新将会丢失。而是使用索引表达式，比如`hist[key]`来在迭代期间更新元素。有关`for…range`循环的详细信息，请参阅[第3章](ch03.html
    "第3章。Go控制流")*Go控制流*，对Go`for`循环进行彻底的解释。
- en: Map functions
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射函数
- en: 'Besides the `make` function, discussed earlier, map types support two additional
    functions discussed in the following table:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前讨论的`make`函数，映射类型还支持以下表中讨论的两个附加函数：
- en: '| **Function** | **Description** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| len(map) | As with other composite types, the built-in `len()` function returns
    the number of entries in a map. For instance, the following would print **3**:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '| len(map) | 与其他复合类型一样，内置的`len()`函数返回映射中条目的数量。例如，以下内容将打印**3**：'
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `len` function will return zero for an uninitialized map. |
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未初始化的映射，`len`函数将返回零。|
- en: '| delete(map, key) | The built-in `delete` function deletes an element from
    a given map associated with the provided key. The following code snippet would
    print **2**:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '| delete(map, key) | 内置的`delete`函数从给定的映射中删除与提供的键关联的元素。以下代码片段将打印**2**：'
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Maps as parameters
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为参数的映射
- en: 'Because a map maintains an internal pointer to its backing storage structure,
    all updates to map parameter within a called function will be seen by the caller
    once the function returns. The following sample shows a call to the `remove` function
    to change the content of a map. The passed variable, `hist`, will reflect the
    change once the `remove` function returns:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因为映射维护了一个指向其后备存储结构的内部指针，所以在调用函数内对映射参数的所有更新将在函数返回后被调用者看到。下面的示例显示了调用`remove`函数来改变映射内容。传递的变量`hist`将在`remove`函数返回后反映出这一变化：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: golang.fyi/ch07/map_use.go
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/map_use.go
- en: The struct type
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体类型
- en: 'The last type discussed in this chapter is Go''s `struct`. It is a composite
    type that serves as a container for other named types known as fields. The following
    code snippet shows several variables declared as structs:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的最后一种类型是Go的`struct`。它是一种复合类型，用作其他命名类型（称为字段）的容器。以下代码片段显示了几个声明为结构体的变量：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: golang.fyi/ch07/structtypes.go
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/structtypes.go
- en: 'Note that the struct type has the following general format:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，结构体类型具有以下一般格式：
- en: '*struct{<field declaration set>}*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*struct{<field declaration set>}*'
- en: The `struct` type is constructed by specifying the keyword `struct` followed
    by a set of field declarations enclosed within curly brackets. In its most common
    form, a field is a unique identifier with an assigned type which follows Go's
    variable declaration conventions as shown in the previous code snippet (`struct`
    also support anonymous fields, covered later).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`类型是通过指定关键字`struct`后跟在花括号内的一组字段声明来构造的。在其最常见的形式中，字段是一个具有分配类型的唯一标识符，遵循Go的变量声明约定，如前面的代码片段所示（`struct`也支持匿名字段，稍后讨论）。'
- en: It is crucial to understand that the type definition for a `struct` includes
    all of its declared fields. For instance, the type for the person variable (see
    earlier code snippet) is the entire set of fields in the declaration `struct {
    name string; address struct { street string; city string; state string; postal
    string }}`. Therefore, any variable or expression requiring that type must repeat
    that long declaration. We will see later how that is mitigated by using named
    types for `struct`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解`struct`的类型定义包括其声明的所有字段。例如，person变量的类型（见前面的代码片段）是声明`struct { name string;
    address struct { street string; city string; state string; postal string }}`中的所有字段。因此，任何需要该类型的变量或表达式都必须重复这个长声明。我们将在后面看到，通过使用`struct`的命名类型来减轻这个问题。
- en: Accessing struct fields
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问结构字段
- en: 'A struct uses a *selector expression* (or dot notation) to access the values
    stored in fields. For instance, the following would print the value of the `name`
    field of the person struct variable from the previous code snippet:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体使用*选择器表达式*（或点表示法）来访问字段中存储的值。例如，以下内容将打印出先前代码片段中的person结构变量的`name`字段的值：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Selectors can be chained to access fields that are nested inside a struct.
    The following snippet would print the street and city for the nested address value
    of a `person` variable:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器可以链接以访问嵌套在结构体内部的字段。以下代码片段将打印出`person`变量的嵌套地址值的街道和城市：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Struct initialization
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构初始化
- en: Similar to arrays, structs are pure values with no additional underlying storage
    structure. The fields for an uninitialized struct are assigned their respective
    zero values. This means an uninitialized struct requires no further allocation
    and is ready to be used.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，结构体是纯值，没有额外的底层存储结构。未初始化的结构体的字段被分配它们各自的零值。这意味着未初始化的结构体不需要进一步分配，可以直接使用。
- en: 'Nevertheless, a struct variable can be explicitly initialized using a composite
    literal of the following form:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，结构体变量可以使用以下形式的复合字面量进行显式初始化：
- en: '*<struct_type>{<positional or named field values>}*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*<struct_type>{<positional or named field values>}*'
- en: 'The composite literal value for a struct can be initialized by a set of field
    values specified by their respective positions. Using this approach, all field
    values must be provided, to match their respective declared types, as shown in
    the following snippet:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 结构的复合文字值可以通过它们各自位置指定的一组字段值进行初始化。使用这种方法，必须提供所有字段值，以匹配它们各自声明的类型，如下面的片段所示：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: golang.fyi/ch07/structinit.go
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/structinit.go
- en: 'In the previous struct literal, all field values of the `struct` are provided,
    matching their declared field types. Alternatively, the composite literal value
    of a `struct` can be specified using a field indices and their associated value.
    As before, the index (the field name) and its value is separated by a colon, as
    shown in the following snippet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的结构文字中，提供了`struct`的所有字段值，与其声明的字段类型匹配。或者，可以使用字段索引及其关联值指定`struct`的复合文字值。与以前一样，索引（字段名称）及其值由冒号分隔，如下面的片段所示：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: golang.fyi/ch07/structinit.go
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/structinit.go
- en: As you can see, field values of the composite literal can be selectively specified
    when the index and its value are provided. For instance, in the initialization
    of the `node` variable, the `edge` field is initialized while `weight` is omitted.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当提供索引及其值时，结构文字的字段值可以被选择性地指定。例如，在初始化`node`变量时，`edge`字段被初始化，而`weight`被省略。
- en: Declaring named struct types
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明命名结构类型
- en: 'Attempting to reuse struct types can get unwieldy fast. For instance, having
    to write `struct { name string; address struct { street string; city string; state
    string; postal string }}` to express a struct type, every time it is needed, would
    not scale, would be error prone, and would make for grumpy Go developers. Luckily,
    the proper idiom to fix this is to use named types, as illustrated in the following
    source code snippet:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重用结构类型可能会变得难以控制。例如，每次需要时都必须编写`struct { name string; address struct { street
    string; city string; state string; postal string }}`来表示结构类型，这样做不会扩展，容易出错，并且会让Go开发人员感到不快。幸运的是，修复这个问题的正确习惯是使用命名类型，如下面的源代码片段所示：
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: golang.fyi/ch07/structtype_dec.go
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/structtype_dec.go
- en: The previous example binds struct type definitions to the identifiers person
    and address. This allows the struct types to be reused in different contexts without
    the need to carry around the long form of the type definitions. You can refer
    to [Chapter 4](ch04.html "Chapter 4. Data Types"), *Data Types*, to learn more
    about named types.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例将结构类型定义绑定到标识符`person`和`address`。这允许在不需要携带类型定义的长形式的情况下，在不同的上下文中重用结构类型。您可以参考[第4章](ch04.html
    "第4章。数据类型")，*数据类型*，了解更多有关命名类型的信息。
- en: The anonymous field
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名字段
- en: Previous definitions of struct types involved the use of named fields. However,
    it is also possible to define a field with only its type, omitting the identifier.
    This is known as an anonymous field. It has the effect of embedding the type directly
    into the struct.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的结构类型定义涉及使用命名字段。但是，还可以定义仅具有其类型的字段，省略标识符。这称为匿名字段。它的效果是将类型直接嵌入结构中。
- en: 'This concept is demonstrated in the following code snippet. Both types, `diameter`
    and the name, are embedded as `anonymous` fields in the `planet` type:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念在下面的代码片段中得到了演示。`diameter`和`name`两种类型都作为`planet`类型的`anonymous`字段嵌入：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: golang.fyi/ch07/struct_embed.go
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/struct_embed.go
- en: The `main` function in the previous snippet shows how the anonymous fields are
    accessed and updated, as is done in the `planet` struct. Notice the names of the
    embedded types become the field identifiers in the composite literal value for
    the struct.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 前面片段中的`main`函数展示了如何访问和更新匿名字段，就像在`planet`结构中所做的那样。请注意，嵌入类型的名称成为结构的复合文字值中的字段标识符。
- en: 'To simplify field name resolution, Go follows the following rules when using
    anonymous fields:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化字段名称解析，Go在使用匿名字段时遵循以下规则：
- en: The name of the type becomes the name of the field
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型的名称成为字段的名称
- en: The name of an anonymous field may not clash with other field names
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名字段的名称可能与其他字段名称冲突
- en: Use only the unqualified (omit package) type name of imported types
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用导入类型的未限定（省略包）类型名称
- en: 'These rules also hold when accessing the fields of embedded structs directly
    using selector expressions, as is shown in the following code snippet. Notice
    the name of the embedded types are resolved as fields names:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接使用选择器表达式访问嵌入结构的字段时，这些规则也适用，就像下面的代码片段中所示的那样。请注意，嵌入类型的名称被解析为字段名称：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: golang.fyi/ch07/struct_embed.go
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/struct_embed.go
- en: Promoted fields
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提升的字段
- en: 'Fields of an embedded struct can be *promoted* to its enclosing type. Promoted
    fields appear in selector expressions without the qualified name of their types,
    as shown in the following example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入结构的字段可以*提升*到其封闭类型。提升的字段出现在选择器表达式中，而不带有它们类型的限定名称，如下面的示例所示：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: golang.fyi/ch07/struct_embed.go
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/struct_embed.go
- en: In the previous snippet, the highlighted fields are promoted from the embedded
    type `name` by omitting it from the selector expression. The values of the fields
    `long`, `short`, and `symbol` come from embedded type `name`. Again, this will
    only work if the promotion does not cause any identifier clashes. In case of ambiguity,
    the fully qualified selector expression can be used.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，通过省略选择器表达式中的`name`，突出显示的字段是从嵌入类型`name`中提升的。字段`long`，`short`和`symbol`的值来自嵌入类型`name`。同样，只有在提升不会导致任何标识符冲突时才会起作用。在有歧义的情况下，可以使用完全限定的选择器表达式。
- en: Structs as parameters
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构作为参数
- en: 'Recall that struct variables store actual values. This implies that a new copy
    of a struct value is created whenever a `struct` variable is reassigned or passed
    in as a function parameter. For instance, the following will not update the value
    of name after the call to `updateName()`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，结构变量存储实际值。这意味着每当重新分配或作为函数参数传递`struct`变量时，都会创建结构值的新副本。例如，在调用`updateName()`之后，以下内容将不会更新名称的值：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: golang.fyi/ch07/struct_ptr.go
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/struct_ptr.go
- en: 'This can be remedied by passing a pointer to the `struct` value of the person
    type, as shown in the following snippet:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过将指针传递给person类型的struct值来解决，如下面的代码片段所示：
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: golang.fyi/ch07/struct_ptr2.go
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/struct_ptr2.go
- en: In this version, the `p` variable is declared as `*person` and is initialized
    using the built-in `new()` function. After `updateName()` returns, its changes
    are seen by the calling function.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，变量`p`声明为`*person`，并使用内置的`new()`函数进行初始化。在`updateName()`返回后，其更改将被调用函数看到。
- en: Field tags
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段标签
- en: The last topic on structs has to do with field tags. During the definition of
    a `struct` type, optional `string` values may be added to each field declaration.
    The value of the string is arbitrary and it can serve as hints to tools or other
    APIs that use reflection to consume the tags.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 关于结构的最后一个主题与字段标签有关。在定义`struct`类型时，可以在每个字段声明中添加可选的`string`值。字符串的值是任意的，它可以作为提示，供使用反射消费标签的工具或其他API使用。
- en: 'The following shows a definition of the Person and Address structs that are
    tagged with JSON annotation which can be interpreted by Go''s JSON encoder and
    decoder (found in the standard library):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了Person和Address结构的定义，它们带有JSON注释，可以被Go的JSON编码器和解码器解释（在标准库中找到）：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: golang.fyi/ch07/struct_ptr2.go
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch07/struct_ptr2.go
- en: Notice the tags are represented as raw string values (wrapped within a pair
    of ````). The tags are ignored by normal code execution. However, they can be
    collected using Go's reflection API as is done by the JSON library. You will encounter
    more on this subject in [Chapter 10](ch10.html "Chapter 10. Data IO in Go"), *Data
    IO in Go*, when the book discusses input and output streams.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，标签被表示为原始字符串值（包裹在一对``中）。标签在正常的代码执行中被忽略。但是，它们可以使用Go的反射API收集，就像JSON库所做的那样。当本书讨论输入和输出流时，您将在[第10章](ch10.html
    "第10章。Go中的数据IO")中遇到更多关于这个主题的内容，*Go中的数据IO*。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered a lot of ground as it walked through each of the composite
    types found in Go to provide insightful coverage of their characteristics. The
    chapter opened with a coverage of the array type, where readers learned how to
    declare, initialize, and use array values. Next, readers learned all about the
    slice type, specifically the declaration, initialization, and practical examples
    that uses slice index expressions to create new or re-slice existing slices. The
    chapter covered the map type, which included information on map initialization,
    access, update, and traversal. Lastly, the chapter provided information about
    the definition, initialization, and usage of the struct type.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Go中找到的每种复合类型，以提供对它们特性的深入覆盖。本章以数组类型的覆盖开篇，读者学习了如何声明、初始化和使用数组值。接下来，读者学习了关于切片类型的所有内容，特别是声明、初始化和使用切片索引表达式来创建新的或重新切片现有切片的实际示例。本章涵盖了映射类型，其中包括有关映射初始化、访问、更新和遍历的信息。最后，本章提供了有关结构类型的定义、初始化和使用的信息。
- en: Needless to say, this is probably one of the longest chapters of the book. However,
    the information covered here will prove to be invaluable as the book continues
    to explore new topics. The next chapter will introduce the idea of using Go to
    support object-like idioms using methods and interfaces.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，这可能是本书中最长的章节之一。然而，这里涵盖的信息将在书中继续探讨新主题时被证明是非常宝贵的。下一章将介绍使用Go支持对象式习语的想法，使用方法和接口。
