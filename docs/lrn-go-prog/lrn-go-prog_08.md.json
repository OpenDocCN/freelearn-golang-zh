["```go\npackage main \nimport \"fmt\" \n\ntype gallon float64 \n\nfunc (g gallon) quart() float64 { \n   return float64(g * 4) \n} \nfunc main(){ \n    gal := gallon(5) \n    fmt.Println(gal.quart()) \n} \n\n```", "```go\nfunc main(){ \n    gal := gallon(5) \n    fmt.Println(gal.quart()) \n} \n\n```", "```go\ntype gallon *float64    \nfunc (g gallon) quart() float64 {\n  return float64(g * 4)\n}\n\n```", "```go\npackage main \nimport \"fmt\" \n\ntype ounce float64 \nfunc (o ounce) cup() cup { \n   return cup(o * 0.1250) \n} \n\ntype cup float64 \nfunc (c cup) quart() quart { \n   return quart(c * 0.25) \n} \nfunc (c cup) ounce() ounce { \n   return ounce(c * 8.0) \n} \n\ntype quart float64 \nfunc (q quart) gallon() gallon { \n   return gallon(q * 0.25) \n} \nfunc (q quart) cup() cup { \n   return cup(q * 4.0) \n} \n\ntype gallon float64 \nfunc (g gallon) quart() quart { \n   return quart(g * 4) \n} \n\nfunc main() { \n    gal := gallon(5) \n    fmt.Printf(\"%.2f gallons = %.2f quarts\\n\", gal, gal.quart()) \n    ozs := gal.quart().cup().ounce() \n    fmt.Printf(\"%.2f gallons = %.2f ounces\\n\", gal, ozs) \n} \n\n```", "```go\ngal := gallon(5) \nozs := gal.quart().cup().ounce() \n\n```", "```go\npackage main\nimport \"fmt\" \ntype gallon float64 \nfunc (g gallon) quart() float64 { \n  return float64(g * 4) \n} \nfunc (g gallon) half() { \n  g = gallon(g * 0.5) \n} \nfunc (g *gallon) double() { \n  *g = gallon(*g * 2) \n} \nfunc main() { \n  var gal gallon = 5 \n  gal.half() \n  fmt.Println(gal) \n  gal.double() \n  fmt.Println(gal) \n} \n\n```", "```go\nfunc main() { \n   var gal gallon = 5 \n   gal.half() \n   fmt.Println(gal) \n} \n\n```", "```go\nfunc main() { \n   var gal gallon = 5 \n   gal.double() \n   fmt.Println(gal) \n} \n\n```", "```go\ntype fuel int \nconst ( \n    GASOLINE fuel = iota \n    BIO \n    ELECTRIC \n    JET \n) \ntype vehicle struct { \n    make string \n    model string \n} \n\ntype engine struct { \n   fuel fuel \n   thrust int \n} \nfunc (e *engine) start() { \n   fmt.Println (\"Engine started.\") \n} \n\ntype truck struct { \n   vehicle \n   engine \n   axels int \n   wheels int \n   class int \n} \nfunc (t *truck) drive() { \n   fmt.Printf(\"Truck %s %s, on the go!\\n\", t.make, t.model)           \n} \n\ntype plane struct { \n   vehicle \n   engine \n   engineCount int \n   fixedWings bool \n   maxAltitude int \n} \nfunc (p *plane) fly() { \n   fmt.Printf( \n          \"Aircraft %s %s clear for takeoff!\\n\", \n          p.make, p.model, \n       ) \n} \n\n```", "```go\nfunc main() { \n   t := &truck { \n         vehicle:vehicle{\"Ford\", \"F750\"}, \n         engine:engine{GASOLINE+BIO,700}, \n         axels:2, \n         wheels:6, \n         class:3,     \n   } \n   t.start() \n   t.drive() \n\n   p := &plane{} \n   p.make = \"HondaJet\" \n   p.model = \"HA-420\" \n   p.fuel = JET \n   p.thrust = 2050 \n   p.engineCount = 2 \n   p.fixedWings = true \n   p.maxAltitude = 43000 \n   p.start() \n   p.fly() \n\n} \n\n```", "```go\np.make = \"HondaJet\" \np.model = \"HA-420\" \np.fuel = JET \np.thrust = 2050 \n\n```", "```go\np.vehicle.make = \"HondaJet\" \np.vehicle.model = \"HA-420\" \np.engine.fuel = JET \np.engine.thrust = 2050 \n\n```", "```go\ntype truck struct { \n   vehicle \n   engine \n   axels int \n   wheels int \n   class int \n} \nfunc newTruck(mk, mdl string) *truck { \n   return &truck {vehicle:vehicle{mk, mdl}} \n} \n\ntype plane struct { \n   vehicle \n   engine \n   engineCount int \n   fixedWings bool \n   maxAltitude int \n}   \nfunc newPlane(mk, mdl string) *plane { \n   p := &plane{} \n   p.make = mk \n   p.model = mdl \n   return p \n} \n\n```", "```go\nvar shape interface { \n    area() float64 \n    perim() float64 \n} \n\n```", "```go\ntype shape interface { \n   area() float64 \n   perim() float64 \n} \nvar s shape \n\n```", "```go\ntype shape interface { \n   area() float64 \n   perim() float64 \n} \n\ntype rect struct { \n   name string \n   length, height float64 \n} \n\nfunc (r *rect) area() float64 { \n   return r.length * r.height \n} \n\nfunc (r *rect) perim() float64 { \n   return 2*r.length + 2*r.height \n} \n\n```", "```go\ntype triangle struct { \n   name string \n   a, b, c float64 \n} \n\nfunc (t *triangle) area() float64 { \n   return 0.5*(t.a * t.b) \n} \n\nfunc (t *triangle) perim() float64 { \n   return t.a + t.b + math.Sqrt((t.a*t.a) + (t.b*t.b)) \n} \n\nfunc (t *triangle) String() string { \n   return fmt.Sprintf( \n         \"%s[sides: a=%.2f b=%.2f c=%.2f]\", \n         t.name, t.a, t.b, t.c, \n   ) \n} \nfunc shapeInfo(s shape) string { \n   return fmt.Sprintf( \n         \"Area = %.2f, Perim = %.2f\", \n         s.area(), s.perim(), \n   ) \n} \n\nfunc main() { \n   r := &      rect{\"Square\", 4.0, 4.0} \n   fmt.Println(r, \"=>\", shapeInfo(r)) \n\n   t := &      triangle{\"Right Triangle\", 1,2,3} \n   fmt.Println(t, \"=>\", shapeInfo(t)) \n} \n\n```", "```go\ntype shape interface { \n   area() float64 \n} \n\ntype polygon interface { \n   perim() \n} \n\ntype curved interface { \n   circonf() \n} \ntype rect struct {...} \nfunc (r *rect) area() float64 { \n   return r.length * r.height \n} \nfunc (r *rect) perim() float64 { \n   return 2*r.length + 2*r.height \n} \n\ntype triangle struct {...} \nfunc (t *triangle) area() float64 { \n   return 0.5*(t.a * t.b) \n} \nfunc (t *triangle) perim() float64 { \n   return t.a + t.b + math.Sqrt((t.a*t.a) + (t.b*t.b)) \n} \n\ntype circle struct { ... } \nfunc (c *circle) area() float64 { \n   return math.Pi * (c.rad*c.rad) \n} \nfunc (c *circle) circonf() float64 { \n   return 2 * math.Pi * c.rad \n} \n\n```", "```go\ntype shape interface { \n   area() float64 \n} \n\ntype polygon interface { \n   shape \n   perim() \n} \n\ntype curved interface { \n   shape \n   circonf() \n} \n\n```", "```go\nfunc main() { \n   var anyType interface{} \n   anyType = 77.0 \n   anyType = \"I am a string now\" \n   fmt.Println(anyType) \n\n   printAnyType(\"The car is slow\") \n   m := map[string] string{\"ID\":\"12345\", \"name\":\"Kerry\"} \n   printAnyType(m) \n   printAnyType(1253443455) \n} \n\nfunc printAnyType(val interface{}) { \n   fmt.Println(val) \n} \n\n```", "```go\nanyType = 77.0 \nanyType = \"I am a string now\" \n\n```", "```go\nprintAnyType(\"The car is slow\") \nm := map[string] string{\"ID\":\"12345\", \"name\":\"Kerry\"} \nprintAnyType(m) \nprintAnyType(1253443455) \n\n```", "```go\ntype food interface { \n   eat() \n} \n\ntype veggie string \nfunc (v veggie) eat() { \n   fmt.Println(\"Eating\", v) \n} \n\ntype meat string \nfunc (m meat) eat() { \n   fmt.Println(\"Eating tasty\", m) \n} \n\nfunc eat(f food) { \n   veg, ok := f.(veggie) \n   if ok { \n         if veg == \"okra\" { \n               fmt.Println(\"Yuk! not eating \", veg) \n         }else{ \n               veg.eat() \n         } \n\n         return \n   } \n\n   mt, ok := f.(meat) \n   if ok { \n         if mt == \"beef\" { \n               fmt.Println(\"Yuk! not eating \", mt) \n         }else{ \n               mt.eat() \n         } \n         return \n   } \n\n   fmt.Println(\"Not eating whatever that is: \", f) \n} \n\n```", "```go\nmt, ok := f.(meat) \nif ok { \n   if mt == \"beef\" { \n         fmt.Println(\"Yuk! not eating \", mt) \n   }else{ \n         mt.eat() \n   } \n   return \n} \n\n```", "```go\nfunc eat(f food) { \n   swtich morsel := f.(type){ \n   case veggie: \n         if morsel == \"okra\" { \n               fmt.Println(\"Yuk! not eating \", mosel) \n         }else{ \n               mosel.eat() \n         } \n   case meat: \n         if morsel == \"beef\" { \n               fmt.Println(\"Yuk! not eating \", mosel) \n         }else{ \n               mosel.eat() \n         }            \n   default: \n         fmt.Println(\"Not eating whatever that is: \", f) \n   } \n} \n\n```"]