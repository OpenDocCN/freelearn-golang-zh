["```go\nfunc main() { \n   go count(10, 50, 10) \n   go count(60, 100, 10) \n   go count(110, 200, 20) \n} \nfunc count(start, stop, delta int) { \n   for i := start; i <= stop; i += delta { \n         fmt.Println(i) \n   } \n} \n\n```", "```go\nfunc main() { \n   go count(10, 30, 10) \n   go count(40, 60, 10) \n   go count(70, 120, 20) \n   fmt.Scanln() // blocks for kb input \n} \n\n```", "```go\nfunc main() { \n   go count(10, 30, 10) \n   go func() { \n         count(40, 60, 10) \n   }() \n   ... \n}  \n\n```", "```go\nfunc main() { \n   start := 0 \n   stop := 50 \n   step := 5 \n   go func() { \n         count(start, stop, step) \n   }() \n} \n\n```", "```go\nfunc main() { \n   starts := []int{10,40,70,100} \n   for _, j := range starts{ \n         go func() { \n               count(j, j+20, 10) \n         }() \n   } \n} \n\n```", "```go\nfunc main() { \n   starts := []int{10,40,70,100} \n   for _, j := range starts{ \n         go func(s int) { \n               count(s, s+20, 10) \n         }(j) \n   } \n} \n\n```", "```go\nfunc main() { \n   go count(10, 30, 10) \n   go count(40, 60, 10) \n   go count(70, 120, 20) \n   fmt.Scanln() // blocks for kb input \n} \nfunc count(start, stop, delta int) { \n   for i := start; i <= stop; i += delta { \n         fmt.Println(i) \n   } \n} \n\n```", "```go\n10\n70\n90\n110\n40\n50\n60\n20\n30\n\n```", "```go\nfunc main() { \n   var ch chan int \n   ... \n} \n\n```", "```go\nfunc main() { \n   ch := make(chan int) // unbuffered channel \n   ... \n} \n\n```", "```go\nfunc main() { \n   ch := make(chan int) \n   ch <- 12 // blocks   \n   fmt.Println(<-ch) \n} \n\n```", "```go\n$> go run chan-unbuff0.go\nfatal error: all goroutines are asleep - deadlock!\n\n```", "```go\nfunc main() { \n   ch := make(chan int) \n   go func() { ch <- 12 }() \n   fmt.Println(<-ch) \n} \n\n```", "```go\nfunc main \n   ch := make(chan int, 3) // buffered channel  \n} \n\n```", "```go\nfunc main() { \n   ch := make(chan int, 4) \n   ch <- 2 \n   ch <- 4 \n   ch <- 6 \n   ch <- 8 \n\n   fmt.Println(<-ch) \n   fmt.Println(<-ch) \n   fmt.Println(<-ch) \n   fmt.Println(<-ch) \n\n} \n\n```", "```go\nfunc main() { \n   ch := make(chan int, 4) \n   ch <- 2 \n   ch <- 4 \n   ch <- 6 \n   ch <- 8 \n   ch <- 10  \n   fmt.Println(<-ch) \n   ... \n} \n\n```", "```go\nvar inCh chan<- int\n```", "```go\nvar outCh <-chan int\n```", "```go\nfunc main() { \n   ch := make(chan int, 10) \n   makeEvenNums(4, ch) \n\n   fmt.Println(<-ch) \n   fmt.Println(<-ch) \n   fmt.Println(<-ch) \n   fmt.Println(<-ch) \n} \n\nfunc makeEvenNums(count int, in chan<- int) { \n   for i := 0; i < count; i++ { \n         in <- 2 * i \n   } \n} \n\n```", "```go\nfunc main() { \n   ch := make(chan int, 4) \n   ch <- 2 \n   ch <- 2 \n   fmt.Println(len(ch)) \n} \n\n```", "```go\nfunc main() { \n   ch := make(chan int, 4) \n   ch <- 2 \n   ch <- 4 \n   close(ch) \n   // ch <- 6 // panic, send on closed channel \n\n   fmt.Println(<-ch) \n   fmt.Println(<-ch) \n   fmt.Println(<-ch) // closed, returns zero value for element \n\n} \n\n```", "```go\nfunc main() { \n   ch := make(chan int, 4) \n   ch <- 2 \n   ch <- 4 \n   close(ch) \n\n   for i := 0; i < 4; i++ { \n         if val, opened := <-ch; opened { \n               fmt.Println(val) \n         } else { \n               fmt.Println(\"Channel closed!\") \n         } \n   } \n} \n\n```", "```go\nfunc main() { \n   data := []string{ \n         \"The yellow fish swims slowly in the water\", \n         \"The brown dog barks loudly after a drink ...\", \n         \"The dark bird bird of prey lands on a small ...\", \n   } \n\n   histogram := make(map[string]int) \n   done := make(chan bool) \n\n   // splits and count words \n   go func() { \n         for _, line := range data { \n               words := strings.Split(line, \" \") \n               for _, word := range words { \n                     word = strings.ToLower(word) \n                     histogram[word]++ \n               } \n         } \n         done <- true \n   }() \n\n   if <-done { \n         for k, v := range histogram { \n               fmt.Printf(\"%s\\t(%d)\\n\", k, v) \n         } \n   } \n} \n\n```", "```go\nfunc main() { \n... \n   histogram := make(map[string]int) \n   done := make(chan struct{}) \n\n   // splits and count \n   go func() { \n         defer close(done) // closes channel upon fn return \n         for _, line := range data { \n               words := strings.Split(line, \" \") \n               for _, word := range words { \n                     word = strings.ToLower(word) \n                     histogram[word]++ \n               } \n         } \n   }() \n\n   <-done // blocks until closed \n\n   for k, v := range histogram { \n         fmt.Printf(\"%s\\t(%d)\\n\", k, v) \n   } \n} \n\n```", "```go\nfunc main(){ \n... \n   histogram := make(map[string]int) \n   wordsCh := make(chan string) \n\n   // splits lines and sends words to channel \n   go func() { \n         defer close(wordsCh) // close channel when done \n         for _, line := range data { \n               words := strings.Split(line, \" \") \n               for _, word := range words { \n                     word = strings.ToLower(word) \n                     wordsCh <- word \n               } \n         } \n   }() \n\n   // process word stream and count words \n   // loop until wordsCh is closed \n   for { \n         word, opened := <-wordsCh \n         if !opened { \n               break \n         } \n         histogram[word]++ \n   } \n\n   for k, v := range histogram { \n         fmt.Printf(\"%s\\t(%d)\\n\", k, v) \n   } \n} \n\n```", "```go\nwordsCh := make(chan string)   \n\n```", "```go\nwordsCh <- word   \n\n```", "```go\ndefer close(wordsCh)   \n\n```", "```go\nfor {   \n  word, opened := <-wordsCh   \n  if !opened {   \n    break   \n  }   \n  histogram[word]++   \n}   \n\n```", "```go\nfunc main(){                           \n... \n   go func() { \n         defer close(wordsCh) \n         for _, line := range data { \n               words := strings.Split(line, \" \") \n               for _, word := range words { \n                     word = strings.ToLower(word) \n                     wordsCh <- word \n               } \n         } \n   }() \n\n   for word := range wordsCh { \n         histogram[word]++ \n   } \n... \n} \n\n```", "```go\nfunc main() { \n   data := []string{\"The yellow fish swims...\", ...} \n   histogram := make(map[string]int) \n\n   words := words(data) // returns handle to data channel \n   for word := range words { \n         histogram[word]++ \n   } \n... \n} \n\n// generator function that produces data \nfunc words(data []string) <-chan string { \n   out := make(chan string) \n   go func() { \n         defer close(out) // closes channel upon fn return \n         for _, line := range data { \n               words := strings.Split(line, \" \") \n               for _, word := range words { \n                     word = strings.ToLower(word) \n                     out <- word \n               } \n         } \n   }() \n   return out \n} \n\n```", "```go\nfunc main() { \n... \n   histogram := make(map[string]int) \n   stopCh := make(chan struct{}) // used to signal stop \n\n   words := words(stopCh, data) // returns handle to channel \n   for word := range words { \n         if histogram[\"the\"] == 3 { \n               close(stopCh) \n         } \n         histogram[word]++ \n   } \n... \n} \n\nfunc words(stopCh chan struct{}, data []string) <-chan string { \n   out := make(chan string) \n   go func() { \n         defer close(out) // closes channel upon fn return \n         for _, line := range data { \n               words := strings.Split(line, \" \") \n               for _, word := range words { \n                     word = strings.ToLower(word) \n                     select { \n                     case out <- word: \n                     case <-stopCh: // succeeds first when close \n                         return \n                     } \n               } \n         } \n   }() \n   return out \n} \n\n```", "```go\nfunc main() { \n   data := []string{...} \n   histogram := make(map[string]int) \n   done := make(chan struct{}) \n\n   go func() { \n         defer close(done) \n         words := words(data) // returns handle to channel \n         for word := range words { \n               histogram[word]++ \n         } \n         for k, v := range histogram { \n               fmt.Printf(\"%s\\t(%d)\\n\", k, v) \n         } \n   }() \n\n   select { \n   case <-done: \n         fmt.Println(\"Done counting words!!!!\") \n   case <-time.After(200 * time.Microsecond): \n         fmt.Println(\"Sorry, took too long to count.\") \n   } \n} \nfunc words(data []string) <-chan string {...} \n\n```", "```go\ntype Service struct { \n   started bool \n   stpCh   chan struct{} \n   mutex   sync.Mutex \n} \nfunc (s *Service) Start() { \n   s.stpCh = make(chan struct{}) \n   go func() { \n         s.mutex.Lock() \n         s.started = true \n         s.mutex.Unlock() \n         <-s.stpCh // wait to be closed. \n   }() \n} \nfunc (s *Service) Stop() { \n   s.mutex.Lock() \n   defer s.mutex.Unlock() \n   if s.started { \n         s.started = false \n         close(s.stpCh) \n   } \n} \nfunc main() { \n   s := &Service{} \n   s.Start() \n   time.Sleep(time.Second) // do some work \n   s.Stop() \n} \n\n```", "```go\ntype Service struct { \n   ... \n   sync.Mutex \n} \n\nfunc (s *Service) Start() { \n   s.stpCh = make(chan struct{}) \n   go func() { \n         s.Lock() \n         s.started = true \n         s.Unlock() \n         <-s.stpCh // wait to be closed. \n   }() \n} \n\nfunc (s *Service) Stop() { \n   s.Lock() \n   defer s.Unlock() \n   ... \n} \n\n```", "```go\ntype Service struct { \n   started bool \n   stpCh   chan struct{} \n   mutex   sync.RWMutex \n   cache   map[int]string \n} \n\nfunc (s *Service) Start() { \n   ... \n   go func() { \n         s.mutex.Lock() \n         s.started = true \n         s.cache[1] = \"Hello World\" \n         ... \n         s.mutex.Unlock() \n         <-s.stpCh // wait to be closed. \n   }() \n} \n... \nfunc (s *Service) Serve(id int) { \n   s.mutex.RLock() \n   msg := s.cache[id] \n   s.mutex.RUnlock() \n   if msg != \"\" { \n         fmt.Println(msg) \n   } else { \n         fmt.Println(\"Hello, goodbye!\") \n   } \n} \n\n```", "```go\nconst MAX = 1000 \n\nfunc main() { \n   values := make(chan int, MAX) \n   result := make(chan int, 2) \n   var wg sync.WaitGroup \n   wg.Add(2) \n   go func() { // gen multiple of 3 & 5 values \n         for i := 1; i < MAX; i++ { \n               if (i%3) == 0 || (i%5) == 0 { \n                     values <- i // push downstream \n               } \n         } \n         close(values) \n   }() \n\n   work := func() { // work unit, calc partial result \n         defer wg.Done() \n         r := 0 \n         for i := range values { \n               r += i \n         } \n         result <- r \n   } \n\n   // distribute work to two goroutines \n   go work() \n   go work() \n\n   wg.Wait()                    // wait for both groutines \n   total := <-result + <-result // gather partial results \n   fmt.Println(\"Total:\", total) \n} \n\n```", "```go\n$> go run -race sync1.go \n================== \nWARNING: DATA RACE \nRead by main goroutine: \n  main.main() \n/github.com/vladimirvivien/learning-go/ch09/sync1.go:28 +0x8c \n\nPrevious write by goroutine 5: \n  main.(*Service).Start.func1() \n/github.com/vladimirvivien/learning-go/ch09/sync1.go:13 +0x2e \n\nGoroutine 5 (running) created at: \n  main.(*Service).Start() \n/github.com/vladimirvivien/learning-go/ch09/sync1.go:15 +0x99 \n  main.main() \n/github.com/vladimirvivien/learning-go/ch09/sync1.go:26 +0x6c \n================== \nFound 1 data race(s) \nexit status 66 \n\n```", "```go\nconst MAX = 1000 \nconst workers = 2 \n\nfunc main() { \n   values := make(chan int) \n   result := make(chan int, workers) \n   var wg sync.WaitGroup \n\n   go func() { // gen multiple of 3 & 5 values \n         for i := 1; i < MAX; i++ { \n               if (i%3) == 0 || (i%5) == 0 { \n                     values <- i // push downstream \n               } \n         } \n         close(values) \n   }() \n\n   work := func() { // work unit, calc partial result \n         defer wg.Done() \n         r := 0 \n         for i := range values { \n               r += i \n         } \n         result <- r \n   } \n\n   //launch workers \n   wg.Add(workers) \n   for i := 0; i < workers; i++ { \n         go work() \n   } \n\n   wg.Wait() // wait for all groutines \n   close(result) \n   total := 0 \n   // gather partial results \n   for pr := range result { \n         total += pr \n   } \n   fmt.Println(\"Total:\", total) \n} \n\n```"]