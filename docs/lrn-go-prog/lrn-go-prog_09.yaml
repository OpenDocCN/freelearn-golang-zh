- en: Chapter 9. Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。并发性
- en: 'Concurrency is considered to be the one of the most attractive features of
    Go. Adopters of the language revel in the simplicity of its primitives to express
    correct concurrency implementations without the pitfalls that usually come with
    such endeavors. This chapter covers the necessary topics to understand and create
    concurrent Go programs, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 并发被认为是Go最吸引人的特性之一。语言的采用者沉迷于使用其原语来表达正确的并发实现的简单性，而不会出现通常伴随此类努力的陷阱。本章涵盖了理解和创建并发Go程序的必要主题，包括以下内容：
- en: Goroutines
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goroutines
- en: Channels
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道
- en: Writing concurrent programs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写并发程序
- en: The sync package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sync包
- en: Detecting race conditions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测竞争条件
- en: Parallelism in Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中的并行性
- en: Goroutines
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: If you have worked in other languages, such as Java or C/C++, you are probably
    familiar with the notion of concurrency. It is the ability of a program to run
    two or more paths of execution independently. This is usually done by exposing
    a thread primitive directly to the programmer to create and manage concurrency.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在其他语言中工作过，比如Java或C/C++，您可能熟悉并发的概念。这是程序能够独立运行两个或多个执行路径的能力。通常通过直接向程序员公开线程原语来创建和管理并发来实现这一点。
- en: Go has its own concurrency primitive called the *goroutine*, which allows a
    program to launch a function (routine) to execute independently from its calling
    function. Goroutines are lightweight execution contexts that are multiplexed among
    a small number of OS-backed threads and scheduled by Go's runtime scheduler. That
    makes them cheap to create without the overhead requirements of true kernel threads.
    As such, a Go program can initiate thousands (even hundreds of thousands) of goroutines
    with minimal impact on performance and resource degradation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go有自己的并发原语，称为*goroutine*，它允许程序启动一个函数（例程）以独立于其调用函数执行。Goroutines是轻量级的执行上下文，它们在少量OS支持的线程中进行多路复用，并由Go的运行时调度程序进行调度。这使它们可以在不需要真正的内核线程的开销要求的情况下轻松创建。因此，Go程序可以启动数千（甚至数十万）个goroutine，对性能和资源降级的影响很小。
- en: The go statement
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go语句
- en: 'Goroutines are launched using the `go` statement as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`go`语句启动goroutines如下所示：
- en: '*go <function or expression>*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*go <function or expression>*'
- en: 'A goroutine is created with the `go` keyword followed by the function to schedule
    for execution. The specified function can be an existing function, an anonymous
    function, or an expression that calls a function. The following code snippet shows
    an example of the use of goroutines:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`go`关键字后跟要安排执行的函数创建goroutine。指定的函数可以是现有函数、匿名函数或调用函数的表达式。以下代码片段显示了goroutines的使用示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch09/goroutine0.go
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine0.go
- en: In the previous code sample, when the `go count()` statement is encountered
    in the `main` function, it launches the `count` function in an independent execution
    context. Both the `main` and `count` functions will be executing concurrently.
    As a side effect, `main` will complete before any of the `count` functions get
    a chance to print anything to the console.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，当在`main`函数中遇到`go count()`语句时，它会在独立的执行上下文中启动`count`函数。`main`和`count`函数将同时执行。作为副作用，`main`将在任何`count`函数有机会向控制台打印任何内容之前完成。
- en: 'Later in the chapter, we will see how to handle synchronization idiomatically
    between goroutines. For now, let us use `fmt.Scanln()` to block and wait for keyboard
    input, as shown in the following sample. In this version, the concurrent functions
    get a chance to complete while waiting for keyboard input:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将看到如何在goroutines之间以惯用方式处理同步。现在，让我们使用`fmt.Scanln()`来阻塞并等待键盘输入，如下示例所示。在这个版本中，同时运行的函数有机会在等待键盘输入时完成：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch09/goroutine1.go
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine1.go
- en: 'Goroutines may also be defined as function literals directly in the `go` statement,
    as shown in this updated version of the example shown in the following code snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines也可以直接在`go`语句中定义为函数文字，如下面代码片段中所示的示例的更新版本：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch09/goroutine2.go
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine2.go
- en: 'The function literal provides a convenient idiom that allows programmers to
    assemble logic directly at the site of the `go` statement. When using the `go`
    statement with a function literal, it is treated as a regular closure with lexical
    access to non-local variables, as shown in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数文字提供了一个方便的习语，允许程序员直接在`go`语句的位置组装逻辑。当使用带有函数文字的`go`语句时，它被视为具有对非局部变量的词法访问权限的常规闭包，如下例所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch09/goroutine3.go
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine3.go
- en: In the previous code, the goroutine is able to access and use the variables
    `start`, `stop`, and `step`. This is safe as long as the variables captured in
    the closure are not expected to change after the goroutine starts. If these values
    are updated outside of the closure, it may create race conditions causing the
    goroutine to read unexpected values by the time it is scheduled to run.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，goroutine能够访问和使用变量`start`、`stop`和`step`。只要在闭包中捕获的变量在goroutine启动后不会发生更改，这是安全的。如果这些值在闭包之外更新，可能会导致竞争条件，从而导致goroutine在计划运行时读取意外值。
- en: 'The following snippet shows an example where the goroutine closure captures
    the variable `j` from the loop:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了一个示例，其中goroutine闭包捕获了循环中的变量`j`：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: golang.fyi/ch09/goroutine4.go
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine4.go
- en: 'Since `j` is updated with each iteration, it is impossible to determine what
    value will be read by the closure. In most cases, the goroutine closures will
    see the last updated value of `j` by the time they are executed. This can be easily
    fixed by passing the variable as a parameter in the function literal for the goroutine,
    as shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`j`在每次迭代中都会更新，所以不可能确定闭包将读取什么值。在大多数情况下，goroutine闭包将在执行时看到`j`的最后更新值。可以通过在goroutine的函数文字中将变量作为参数传递来轻松解决这个问题，如下所示：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch09/goroutine5.go
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine5.go
- en: The goroutine closures, invoked with each loop iteration, receive a copy of
    the `j` variable via the function parameter. This creates a local copy of the
    `j` value with the proper value to be used when the goroutine is scheduled to
    run.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环迭代时调用的goroutine闭包通过函数参数接收`j`变量的副本。这将创建`j`值的本地副本，并在调度运行goroutine时使用正确的值。
- en: Goroutine scheduling
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Goroutine调度
- en: 'In general, all goroutines run independently of each other, as depicted in
    the following illustration. A function that creates a goroutine does not wait
    for it to return, it continues with its own execution stream unless there is a
    blocking condition. Later, the chapter covers synchronization idioms to coordinate
    goroutines:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，所有的goroutine都是独立运行的，如下图所示。创建goroutine的函数不会等待它返回，除非有阻塞条件，它会继续执行自己的执行流。本章后面将介绍协调goroutine的同步习语：
- en: '![Goroutine scheduling](img/image_09_001.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Goroutine调度](img/image_09_001.jpg)'
- en: 'Go''s runtime scheduler uses a form of cooperative scheduling to schedule goroutines.
    By default, the scheduler will allow a running goroutine to execute to completion.
    However, the scheduler will automatically yield to another goroutine for execution
    if one of the following events occurs:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Go的运行时调度程序使用一种协作调度形式来调度goroutine。默认情况下，调度程序将允许运行的goroutine执行完成。但是，如果发生以下事件之一，调度程序将自动让出执行权给另一个goroutine：
- en: A `go` statement is encountered in the executing goroutine
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行goroutine中遇到`go`语句
- en: A channel operation is encountered (channels are covered later)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到通道操作（通道稍后会介绍）
- en: A blocking system call (file or network IO for instance) is encountered
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到阻塞的系统调用（例如文件或网络IO）
- en: After the completion of a garbage collection cycle
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在垃圾回收周期完成后
- en: 'The scheduler will schedule a queued goroutines ready to enter execution when
    one of the previous events is encountered in a running goroutine. It is important
    to point out that the scheduler makes no guarantee of the order of execution of
    goroutines. When the following code snippet is executed, for instance, the output
    will be printed in an arbitrary order for each run:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序将调度排队的goroutine，准备在运行的goroutine中遇到前面的事件之一时进入执行。重要的是要指出，调度程序不保证goroutine的执行顺序。例如，当执行以下代码片段时，输出将以任意顺序打印每次运行：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: golang.fyi/ch09/goroutine1.go
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine1.go
- en: 'The following shows possible output for the previous program:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了前一个程序的可能输出：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Channels
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道
- en: When talking about concurrency, one of the natural concerns that arises is that
    of data safety and synchronization among concurrently executing code. If you have
    done concurrent programming in languages such as Java or C/C++, you are likely
    familiar with the, sometimes brittle, choreography required to ensure running
    threads can safely access shared memory values to achieve communication and synchronization
    between threads.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论并发时，一个自然的关注点是数据的安全性和并发执行代码之间的同步。如果您在诸如Java或C/C++等语言中进行并发编程，您可能熟悉确保运行线程可以安全访问共享内存值以实现线程之间通信和同步所需的有时脆弱的协调。
- en: 'This is one area where Go diverges from its C lineage. Instead of having concurrent
    code communicate by using shared memory locations, Go uses channels as a conduit
    between running goroutines to communicate and share data. The blog post *Effective
    Go* ([https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html))
    has reduced this concept to the following slogan:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Go与其C血统不同的地方之一。Go不是通过使用共享内存位置让并发代码进行通信，而是使用通道作为运行的goroutine之间通信和共享数据的通道。博客文章*Effective
    Go*（[https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html)）将这个概念简化为以下口号：
- en: '*Do not communicate by sharing memory; instead, share memory by communicating.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要通过共享内存进行通信；相反，通过通信共享内存。*'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of channel has its roots in **communicating sequential processes**
    (**CSP**), work done by renowned computer scientist C. A. Hoare, to model concurrency
    using communication primitives. As will be discussed in this section, channels
    provide the means to synchronize and safely communicate data between running goroutines.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的概念源于著名计算机科学家C.A. Hoare的**通信顺序进程**（**CSP**）工作，用于使用通信原语对并发进行建模。正如本节将讨论的那样，通道提供了在运行的goroutine之间同步和安全地通信数据的手段。
- en: This section discusses the Go channel type and provides insights into its characteristics.
    Later, you will learn how to use channels to craft concurrent programs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了Go通道类型，并深入了解了其特性。稍后，您将学习如何使用通道来创建并发程序。
- en: The Channel type
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道类型
- en: 'The channel type declares a conduit within which only values of a given element
    type may be sent or received by the channel. The `chan` keyword is used to specify
    a channel type, as shown in the following declaration format:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通道类型声明了一个通道，其中只能通过通道发送或接收给定元素类型的值。`chan`关键字用于指定通道类型，如以下声明格式所示：
- en: '*chan <element type>*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*chan <element type>*'
- en: 'The following code snippet declares a bidirectional channel type, `chan int`,
    assigned to the variable `ch`, to communicate integer values:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个双向通道类型`chan int`，分配给变量`ch`，用于通信整数值：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Later in the chapter, we will learn how to use the channel to send data between
    concurrent portions of a running program.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将学习如何使用通道在运行程序的并发部分之间发送数据。
- en: The send and receive operations
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送和接收操作
- en: 'Go uses the `<-` (arrow) operator to indicate data movement within a channel.
    The following table summarizes how to send or receive data from a channel:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用`<-`（箭头）运算符来指示通道内的数据移动。以下表总结了如何从通道发送或接收数据：
- en: '| **Example** | **Operation** | **Description** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **示例** | **操作** | **描述** |'
- en: '| `intCh <- 12` | Send | When the arrow is placed to the left of the value,
    variable or expression, it indicates a send operation to the channel it points
    to. In this example, `12` is sent into channel `intCh`. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `intCh <- 12` | 发送 | 当箭头放置在值、变量或表达式的左侧时，表示向指向的通道进行发送操作。在这个例子中，`12`被发送到`intCh`通道中。|'
- en: '| `value := <- intCh` | Receive | When the `<-` operator is place to the left
    of a channel, it indicates a receive operation from the channel. The `value` variable
    is assigned the value received from the `intCh` channel. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `value := <- intCh` | 接收 | 当`<-`操作符放置在通道的左侧时，表示从通道接收操作。`value`变量被赋予从`intCh`通道接收到的值。|'
- en: An uninitialized channel has a *nil* zero value and must be initialized using
    the built-in *make* function. As will be discussed in the following sections,
    a channel can be initialized as either unbuffered or buffered, depending on its
    specified capacity. Each of type of channel has different characteristics that
    are leveraged in different concurrency constructs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 未初始化的通道具有*nil*零值，并且必须使用内置的*make*函数进行初始化。正如将在接下来的章节中讨论的那样，通道可以根据指定的容量初始化为无缓冲或带缓冲。每种类型的通道都有不同的特性，在不同的并发构造中得到利用。
- en: Unbuffered channel
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无缓冲通道
- en: 'When the `make` function is invoked without the capacity argument, it returns
    a bidirectional *unbuffered* channel. The following snippet shows the creation
    of an unbuffered channel of type `chan int`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当`make`函数在没有容量参数的情况下被调用时，它会返回一个双向*无缓冲*通道。以下代码片段展示了创建类型为`chan int`的无缓冲通道：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The characteristics of an unbuffered channel are illustrated in the following
    figure:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 无缓冲通道的特性如下图所示：
- en: '![Unbuffered channel](img/image_09_002.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![无缓冲通道](img/image_09_002.jpg)'
- en: 'The sequence in the preceding figure (from left to right) shows how the unbuffered
    channel works:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中（从左到右），显示了无缓冲通道的工作原理：
- en: If the channel is empty, the receiver blocks until there is data
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通道为空，接收方会阻塞，直到有数据
- en: The sender can send only to an empty channel and blocks until the next receive
    operation
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送方只能向空通道发送数据，并且会阻塞，直到下一个接收操作
- en: When the channel has data, the receiver can proceed to receive the data.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通道有数据时，接收方可以继续接收数据。
- en: 'Sending to an unbuffered channel can easily cause a *deadlock* if the operation
    is not wrapped in a goroutine. The following code will block after sending `12`
    to the channel:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 向无缓冲通道发送数据，如果操作没有包装在goroutine中，很容易导致*死锁*。以下代码在向通道发送`12`后将会阻塞：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: golang.fyi/ch09/chan-unbuff0.go
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan-unbuff0.go
- en: 'When you run the previous program, you will get the following result:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行前面的程序时，将得到以下结果：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Recall that the sender blocks immediately upon sending to an unbuffered channel.
    This means any subsequent statement, to receive from the channel for instance,
    becomes unreachable, causing a deadlock. The following code shows the proper way
    to send to an unbuffered channel:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，向无缓冲通道发送数据时，发送方会立即阻塞。这意味着任何后续的语句，例如接收通道的操作，都将无法到达，导致死锁。以下代码展示了向无缓冲通道发送数据的正确方式：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: golang.fyi/ch09/chan-unbuff1.go
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan-unbuff1.go
- en: Notice that the send operation is wrapped in an anonymous function invoked as
    a separate goroutine. This allows the `main` function to reach the receive operation
    without blocking. As you will see later, this blocking property of unbuffered
    channels is used extensively as a synchronization and coordination idioms between
    goroutines.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，发送操作被包装在一个匿名函数中，作为一个单独的goroutine调用。这允许`main`函数在不阻塞的情况下进行接收操作。正如您将在后面看到的，无缓冲通道的这种阻塞特性被广泛用作goroutine之间的同步和协调习语。
- en: Buffered channel
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带缓冲通道
- en: 'When the `make` function uses the capacity argument, it returns a bidirectional
    *buffered* channel, as shown in the following snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当`make`函数使用容量参数时，它会返回一个双向*带缓冲*通道，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The previous code will create a buffered channel with a capacity of `3`. The
    buffered channel operates as a first-in-first-out blocking queue, as illustrated
    in the following figure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将创建一个容量为`3`的带缓冲通道。带缓冲通道作为先进先出的阻塞队列进行操作，如下图所示：
- en: '![Buffered channel](img/image_09_003.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![带缓冲通道](img/image_09_003.jpg)'
- en: 'The buffered channel depicted in the preceding figure has the following characteristics:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中所示的带缓冲通道具有以下特性：
- en: When the channel is empty, the receiver blocks until there is at least one element
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通道为空时，接收方会阻塞，直到至少有一个元素
- en: The sender always succeeds as long as the channel is not at capacity
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要通道未达到容量，发送方就会成功
- en: When the channel is at capacity, the sender blocks until at least one element
    is received
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通道达到容量时，发送方会阻塞，直到至少接收到一个元素
- en: 'Using a buffered channel, it is possible to send and receive values within
    the same goroutine without causing a deadlock. The following shows an example
    of sending and receiving using a buffered channel with a capacity of `4` elements:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带缓冲的通道，可以在同一个goroutine中发送和接收值而不会导致死锁。以下是使用容量为`4`的带缓冲通道进行发送和接收的示例：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: golang.fyi/ch09/chan0.go
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan0.go
- en: 'The code in the previous example is able to send the values `2`, `4`, `6`,
    and `8` to the `ch` channel without the risk of blocking. The four `fmt.Println(<-ch)`
    statements are used to receive the values buffered in the channel successively.
    However, if a fifth send operation is added, prior to the first receive, the code
    will deadlock as highlighted in the following snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，该代码能够将值`2`、`4`、`6`和`8`发送到`ch`通道，而不会出现阻塞的风险。四个`fmt.Println(<-ch)`语句用于依次接收通道中的值。然而，如果在第一个接收操作之前添加第五个发送操作，代码将会出现死锁，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Later in the chapter, you will read more about idiomatic and safe ways to use
    channels for communications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，您将会了解更多关于使用通道进行通信的惯用且安全的方法。
- en: Unidirectional channels
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单向通道
- en: 'At declaration, a channel type may also include a unidirectional operator (using
    the `<-` arrow again) to indicate whether a channel is send-only or receive-only,
    as listed in the following table:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明时，通道类型还可以包括单向操作符（再次使用 `<-` 箭头）来指示通道是只发送还是只接收的，如下表所示：
- en: '| **Declaration** | **Operation** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **声明** | **操作** |'
- en: '| `<-` *chan <element type>* | Declares a receive-only channel as shown later.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '| `<-` *chan <element type>* | 声明一个只接收的通道，如后面所示。'
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| *chan* `<-`*<element type>* | Declares a send-only channel as shown later.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '| *chan* `<-`*<element type>* | 声明一个只发送的通道，如后面所示。'
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The following code snippet shows function `makeEvenNums` with a send-only channel
    argument of type `chan <- int`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了函数 `makeEvenNums`，它具有一个类型为 `chan <- int` 的只发送通道参数：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: golang.fyi/ch09/chan1.go
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan1.go
- en: Since the directionality of the channel is baked in the type, access violations
    will be detected at compile time. So in the previous example, the `in` channel
    can only be used for receive operations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通道的方向性已经在类型中确定，访问违规将在编译时被检测到。因此，在上一个示例中，`in` 通道只能用于接收操作。
- en: A bidirectional channel can be converted to a unidirectional channel explicitly
    or automatically. For instance, when `makeEvenNums()` is called from `main()`,
    it receives the bidirectional channel `ch` as a parameter. The compiler automatically
    converts the channel to the appropriate type.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 双向通道可以显式或自动地转换为单向通道。例如，当从 `main()` 调用 `makeEvenNums()` 时，它接收双向通道 `ch` 作为参数。编译器会自动将通道转换为适当的类型。
- en: Channel length and capacity
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道长度和容量
- en: 'The `len` and `cap` functions can be used to return a channel''s length and
    capacity respectively. The `len` function returns the current number of elements
    queued in the channel prior to being read by a receiver. For instance, the following
    code snippet will print **2**:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`len` 和 `cap` 函数可以分别用于返回通道的长度和容量。`len` 函数返回接收者读取通道之前通道中排队的元素的当前数量。例如，以下代码片段将打印
    **2**：'
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `cap` function returns the declared capacity of the channel type which,
    unlike length, remains constant throughout the life of the channel.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`cap` 函数返回通道类型的声明容量，与长度不同，容量在通道的整个生命周期中保持不变。'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An unbuffered channel has a length and a capacity of zero.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 非缓冲通道的长度和容量均为零。
- en: Closing a channel
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭通道
- en: 'Once a channel is initialized it is ready for send and receive operations.
    A channel will remain in that open state until it is forcibly closed using the
    built-in *close* function, as shown in the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通道初始化，它就准备好进行发送和接收操作。通道将保持在打开状态，直到使用内置的 *close* 函数强制关闭，如下例所示：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch09/chan2.go
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan2.go
- en: 'Once a channel is closed, it has the following properties:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通道关闭，它具有以下属性：
- en: Subsequent send operations will cause a program to panic
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后续的发送操作将导致程序恐慌
- en: Receive operations never block (regardless of whether buffered or unbuffered)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收操作永远不会阻塞（无论是缓冲还是非缓冲）
- en: All receive operations return the zero value of the channel's element type
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有接收操作都返回通道元素类型的零值
- en: In the previous snippet, the `ch` channel is closed after two send operations.
    As indicated in the comment, a third send operation would cause a panic because
    the channel is closed. On the receiving side, the code gets the two elements in
    the channel before it is closed. A third receive operation returns `0`, the zero
    value for the channel's elements.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，`ch` 通道在两次发送操作后关闭。如注释中所示，第三次发送操作将导致恐慌，因为通道已关闭。在接收端，代码在通道关闭之前获取了两个元素。第三次接收操作返回
    `0`，即通道元素的零值。
- en: 'Go offers a long form of the receive operation that returns the value read
    from the channel followed by a Boolean indicating the closed status of the channel.
    This can be used to properly handle the zero value from a closed channel, as shown
    in the following example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了接收操作的长形式，它返回从通道读取的值，后面跟着一个布尔值，指示通道的关闭状态。这可以用于正确处理从关闭通道中的零值，如下例所示：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: golang.fyi/ch09/chan3.go
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan3.go
- en: Writing concurrent programs
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写并发程序
- en: Up to this point, the discussions about goroutines and channels remained deliberately
    separated to ensure that each topic is properly covered. However, the true power
    of channels and goroutines are realized when they are combined to create concurrent
    programs, as covered in this section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，关于 goroutines 和通道的讨论一直故意分开，以确保每个主题都得到适当的覆盖。然而，当它们结合起来创建并发程序时，通道和 goroutines
    的真正力量才得以实现，正如本节所介绍的。
- en: Synchronization
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步
- en: 'One of the primary uses of channels is synchronization between running goroutines.
    To illustrate this use case, let us examine the following code, which implements
    a word histogram. The program reads the words from the `data` slice then, on a
    separate goroutine, collects the occurrence of each word:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的主要用途之一是在运行的 goroutines 之间进行同步。为了说明这个用例，让我们来看一下下面的代码，它实现了一个单词直方图。该程序从 `data`
    切片中读取单词，然后在一个单独的 goroutine 中收集每个单词的出现次数：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: golang.fyi/ch09/pattern0.go
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern0.go
- en: The code in the previous example uses `done := make(chan bool)` to create the
    channel that will be used to synchronize the two running goroutines in the program.
    The `main` function launches a secondary goroutine, which does the word counting,
    and then it continues execution until it blocks at the `<-done` expression, causing
    it to wait.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中的代码中，使用 `done := make(chan bool)` 创建了一个通道，该通道将用于同步程序中运行的两个 goroutines。`main`
    函数启动了一个次要的 goroutine，它执行单词计数，然后继续执行，直到在 `<-done` 表达式处阻塞，导致它等待。
- en: In the meantime, the secondary goroutine runs until it completes its loop. Then,
    it sends a value to the `done` channel with `done <- true`, causing the blocked
    `main` routine to become unblocked and continues with its execution.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，次要的 goroutine 运行直到完成其循环。然后，它向 `done` 通道发送一个值，使用 `done <- true`，导致被阻塞的 `main`
    例程变得不再阻塞，并继续执行。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The previous code has a bug that may cause a race condition. A correction will
    be introduced later in the chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码存在一个可能导致竞争条件的错误。在本章后面将介绍修正方法。
- en: 'In the previous example, the code allocates and actually sends a Boolean value
    that is used for the synchronization. Upon further inspection, it is clear that
    the value in the channel is irrelevant and we simply want it to signal. So, we
    can further distill the synchronization idiom into a colloquial form that is presented
    in the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，代码分配并实际发送了一个布尔值，用于同步。经过进一步检查，可以清楚地看到通道中的值是无关紧要的，我们只是希望它发出信号。因此，我们可以将同步习语进一步简化为一个俗语形式，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: golang.fyi/ch09/pattern1.go
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern1.go
- en: 'This version of the code achieves goroutine synchronization using:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码版本通过以下方式实现了goroutine同步：
- en: The done channel, declared as type `chan struct{}`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: done通道，声明为类型`chan struct{}`
- en: The main goroutine blocks at receive expression `<-done`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主goroutine在接收表达式`<-done`处阻塞
- en: When the done channel is closed, all receivers succeed without blocking
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当done通道关闭时，所有接收方都能成功接收，而不会阻塞。
- en: Although the signaling is done using different constructs, this version of the
    code is equivalent to the first version (`pattern0.go`). The emtpy `struct{}`
    type stores no value and it is used strictly for signaling. This version of the
    code closes the `done` channel (instead of sending a value). This has the effect
    of allowing the main goroutine to unblock and continue execution.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管信令是使用不同的结构完成的，但这个代码版本等同于第一个版本（`pattern0.go`）。空的`struct{}`类型不存储任何值，严格用于信令。这个代码版本关闭了`done`通道（而不是发送一个值）。这样做的效果是允许主goroutine解除阻塞并继续执行。
- en: Streaming data
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据流
- en: 'A natural use of channels is to stream data from one goroutine to another.
    This pattern is quite common in Go code and for it to work, the followings must
    be done:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的一个自然用途是从一个goroutine流式传输数据到另一个。这种模式在Go代码中非常常见，为了使其工作，必须完成以下工作：
- en: Continuously send data on a channel
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不断在通道上发送数据
- en: Continuously receive the incoming data from that channel
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不断接收来自该通道的传入数据
- en: Signal the end of the stream so the receiver may stop
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发出流的结束信号，以便接收方可以停止
- en: 'As you will see, all of this can be done using a single channel. The following
    code snippet is a rewrite of the previous example. It shows how to use a single
    channel to stream data from one goroutine to another. The same channel is also
    used as a signaling device to indicate the end of the stream:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，所有这些都可以使用一个单一的通道完成。以下代码片段是前一个示例的重写。它展示了如何使用单一通道从一个goroutine流式传输数据到另一个。同一个通道也被用作信令设备来指示流的结束：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: golang.fyi/ch09/pattern2.go
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern2.go
- en: 'This version of the code produces the word histogram as before, but introduces
    a different approach. This is accomplished using the highlighted portion of the
    code shown in the following table:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码版本与以前一样生成了单词直方图，但引入了不同的方法。这是通过下表中显示的代码部分实现的：
- en: '| **Code** | **Description** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **描述** |'
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| The channel used to stream data. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: 数据流使用的通道。
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| The sender goroutine loops through the text line and sends a word at a time.
    It then blocks until the word is received by the receiving (main) goroutine. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 发送goroutine循环遍历文本行并逐个发送单词。然后它会阻塞，直到单词被接收（主）goroutine接收到。|'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| As the words are continuously received (see later), the sender goroutine
    closes the channel when it is done. This will be the signal to the receiver that
    it should also stop. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 当单词不断被接收（见后文）时，发送goroutine在完成时关闭通道。这将是接收方应该停止的信号。|'
- en: '|'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '| This is the receiver code. It is placed in a loop since it is does not know
    ahead of time how much data to expect. With each iteration of the loop, the code
    does the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '| 这是接收方的代码。它被放在一个循环中，因为它不知道要预期多少数据。在每次循环迭代中，代码执行以下操作：'
- en: Pulls the data from the channel
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从通道中拉取数据
- en: Checks the open status of the channel
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查通道的开放状态
- en: If closed, break out of the loop
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果关闭了，就跳出循环
- en: Otherwise record histogram
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则记录直方图
- en: '|'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Using for…range to receive data
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`for…range`接收数据
- en: 'The previous pattern is so common in Go that the idiom is built into the language
    in the form of the following `for…range` statement:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个模式在Go中非常常见，这种习语已经内置到语言中，以`for…range`语句的形式存在：
- en: '*for <elemem> := range <channel>{...}*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*for <elemem> := range <channel>{...}*'
- en: 'With each iteration, this `for…range` statement will block until it receives
    incoming data from the indicated channel, as shown in the following snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，这个`for…range`语句将阻塞，直到它从指定的通道接收到传入的数据，就像下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: golang.fyi/ch09/pattern3.go
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern3.go
- en: The previous code shows the an updated version of the code using a for-range
    statement, `for word := range wordsCh`. It successively emits the received value
    from the `wordsCh` channel. When the channel is closed (from the goroutine), the
    loop automatically breaks.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了使用`for-range`语句的更新版本，`for word := range wordsCh`。它会连续地从`wordsCh`通道接收到值。当通道被关闭（来自goroutine），循环会自动中断。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always remember to close the channel so receivers are signaled properly. Otherwise,
    the program may enter into a deadlock which could cause a panic.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记得关闭通道，以便接收方得到适当的信号。否则，程序可能会陷入死锁，导致恐慌。
- en: Generator functions
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器函数
- en: Channels and goroutines provide a natural substrate for implementing a form
    of producer/producer pattern using generator functions. In this approach, a goroutine
    is wrapped in a function which generates values that are sent via a channel returned
    by the function. The consumer goroutine receives these values as they are generated.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通道和goroutine提供了一种自然的基础，用于使用生成器函数实现一种生产者/生产者模式。在这种方法中，一个goroutine被包装在一个函数中，该函数生成通过函数返回的通道发送的值。消费者goroutine接收这些值，因为它们被生成。
- en: 'The word histogram has been updated to use this pattern, as shown in the following
    code snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 单词直方图已经更新为使用这种模式，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: golang.fyi/ch09/pattern4.go
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern4.go
- en: In this example, the generator function, declared as `func words(data []string)
    <-chan string`, returns a receive-only channel of string elements. The consumer
    function, in this instance `main()`, receives the data emitted by the generator
    function, which is processed using a `for…range` loop.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，生成器函数声明为`func words(data []string) <-chan string`，返回一个只接收字符串元素的通道。消费者函数，在这种情况下是`main()`，接收生成器函数发出的数据，并使用`for…range`循环进行处理。
- en: Selecting from multiple channels
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从多个通道选择
- en: 'Sometimes it is necessary for concurrent programs to handle send and receive
    operations for multiple channels at the same time. To facilitate such endeavor,
    the Go language supports the `select` statement that multiplexes selection among
    multiple send and receive operations:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，并发程序需要同时处理多个通道的发送和接收操作。为了方便这样的努力，Go语言支持`select`语句，它可以在多个发送和接收操作之间进行选择：
- en: '*select {*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*select {*'
- en: '*case <send_ or_receive_expression>:*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*case <send_ or_receive_expression>:*'
- en: '*default:*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*default:*'
- en: '*}*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*}*'
- en: The `case` statement operates similarly to a `switch` statement with `case`
    clauses. The `select` statement, however, selects one of the send or receive cases
    which succeeded. If two or more communication cases happen to be ready at the
    same time, one will be selected at random. The default case is always selected
    when no other cases succeed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`语句类似于`switch`语句，具有`case`子句。但是，`select`语句会选择成功的发送或接收情况之一。如果两个或更多通信情况恰好在同一时间准备就绪，将随机选择一个。当没有其他情况成功时，默认情况总是被选择。'
- en: 'The following snippet updates the histogram code to illustrate the use of the
    `select` statement. The generator function `words` select between two channels,
    `out` to send data as before and a new channel `stopCh`, passed as a parameter,
    which is used to detect an interruption signal to stop sending data:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段更新了直方图代码，以说明`select`语句的使用。生成器函数`words`在两个通道`out`之间进行选择，以前发送数据的通道，以及作为参数传递的新通道`stopCh`，用于检测停止发送数据的中断信号：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch09/pattern5.go
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern5.go
- en: 'In the previous code snippet, the `words` generator function will select the
    first communication operation that succeeds: `out <- word` or `<-stopCh`. As long
    as the consumer code in `main()` continues to receive from the `out` channel,
    the send operation will succeed first. Notice, however, the code in `main()` closes
    the `stopCh` channel when it encounters the third instance of `"the"`. When that
    happens, it will cause the receive case, in the select statement, to proceed first
    causing the goroutine to return.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`words`生成器函数将选择成功的第一个通信操作：`out <- word`或`<-stopCh`。只要`main()`中的消费者代码继续从`out`通道接收数据，发送操作就会首先成功。但是请注意，当`main()`中的代码遇到第三个`"the"`实例时，它会关闭`stopCh`通道。当这种情况发生时，它将导致选择语句中的接收情况首先进行，从而导致goroutine返回。
- en: Channel timeout
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道超时
- en: One popular idiom that is commonly encountered with Go concurrency is the use
    of the select statement, introduced previously, to implement timeouts. This works
    by using the select statement to wait for a channel operation to succeed within
    a given time duration using the API from the `time` package ([https://golang.org/pkg/time/](https://golang.org/pkg/time/)).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Go并发中常见的一种习语是使用之前介绍的`select`语句来实现超时。这通过使用`select`语句在给定的时间段内等待通道操作成功来实现，使用`time`包的API（[https://golang.org/pkg/time/](https://golang.org/pkg/time/)）。
- en: 'The following code snippet shows a version of the word histogram example that
    times out if the program takes longer than 200 microseconds to count and print
    the words:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一个单词直方图示例的版本，如果程序计算和打印单词的时间超过200微秒，则会超时：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: golang.fyi/ch09/pattern6.go
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern6.go
- en: This version of the histogram example introduces the `done` channel, which is
    used to signal when processing is done. In the `select` statement, the receive
    operation `case``<-done:` blocks until the goroutine closes the `done` channel.
    Also in the `select` statement, the `time.After()` function returns a channel
    which will close after the indicated duration. If the 200 microseconds elapse
    before done is closed, the channel from `time.After()` will close first, causing
    the timeout case to succeed first.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个直方图示例的版本引入了`done`通道，用于在处理完成时发出信号。在`select`语句中，接收操作`case``<-done:`会阻塞，直到goroutine关闭`done`通道。同样在`select`语句中，`time.After()`函数返回一个通道，该通道将在指定的持续时间后关闭。如果在`done`关闭之前经过了200微秒，那么来自`time.After()`的通道将首先关闭，导致超时情况首先成功。
- en: The sync package
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sync包
- en: There are instances when accessing shared values using traditional methods are
    simpler and more appropriate then the use of channels. The *sync* package ([https://golang.org/pkg/sync/](https://golang.org/pkg/sync/))
    provides several synchronization primitives including mutual exclusion (mutex)
    locks and synchronization barriers for safe access to shared values, as discussed
    in this section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用传统方法访问共享值比使用通道更简单和更合适。*sync*包（[https://golang.org/pkg/sync/](https://golang.org/pkg/sync/)）提供了几种同步原语，包括互斥锁和同步屏障，用于安全访问共享值，如本节所讨论的。
- en: Synchronizing with mutex locks
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用互斥锁进行同步
- en: 'Mutex locks allow serial access of shared resources by causing goroutines to
    block and wait until locks are released. The following sample illustrates a typical
    code scenario with the `Service` type, which must be started before it is ready
    to be used. After the service has started, the code updates an internal bool variable,
    `started`, to store its current state:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁允许通过导致goroutine阻塞和等待直到锁被释放来串行访问共享资源。以下示例说明了具有`Service`类型的典型代码场景，必须在准备好使用之前启动。服务启动后，代码会更新内部布尔变量`started`，以存储其当前状态：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: golang.fyi/ch09/sync2.go
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/sync2.go
- en: The previous code snippet uses variable `mutex`, of type `sync.Mutex`, to synchronize
    access to the shared variable `started`. For this to work effectively, all contentious
    areas where the `started` variable is updated must use the same lock with successive
    calls to `mutex.Lock()` and `mutex.Unlock()`, as shown in the code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用了类型为`sync.Mutex`的变量`mutex`来同步访问共享变量`started`。为了使其有效工作，所有争议的区域，在这些区域中`started`变量被更新，必须使用相同的锁，连续调用`mutex.Lock()`和`mutex.Unlock()`，如代码所示。
- en: 'One idiom you will often encounter is to embed the `sync.Mutex` type directly
    inside a struct, as shown in the next code snippet. This has the effect of promoting
    the `Lock()` and `Unlock()`methods as part of the struct itself:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会遇到的一种习惯用法是直接在结构体中嵌入`sync.Mutex`类型，如下面的代码片段所示。这样做的效果是将`Lock()`和`Unlock()`方法作为结构体本身的一部分：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: golang.fyi/ch09/sync3.go
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/sync3.go
- en: The `sync` package also offers the RWMutex (read-write mutex), which can be
    used in cases where there is one writer that updates the shared resource, while
    there may be multiple readers. The writer would update the resource using a full
    lock, as before. However, readers use the `RLock()`/`RUnlock()` method pair (for
    read-lock/read-unlock respectively) to apply a read-only lock when reading the
    shared resource. The RWMutex type is used in the next section, *Synchronizing
    Access to Composite Values*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync`包还提供了RWMutex（读写互斥锁），可以在有一个写入者更新共享资源的情况下使用，同时可能有多个读取者。写入者会像以前一样使用完全锁定来更新资源。然而，读取者在读取共享资源时使用`RLock()`/`RUnlock()`方法对其进行只读锁定。RWMutex类型在下一节*同步访问复合值*中使用。'
- en: Synchronizing access to composite values
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步访问复合值
- en: 'The previous section discussed concurrency safety when sharing access to simple
    values. The same level of care must be applied when sharing access to composite
    type values such as maps and slices, since Go does not offer concurrency-safe
    version of these types, as illustrated in the following example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节讨论了在共享对简单值的访问时的并发安全性。在共享对复合类型值的访问时，必须应用相同程度的小心，比如映射和切片，因为Go语言没有提供这些类型的并发安全版本，如下面的例子所示：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: golang.fyi/ch09/sync4.go
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/sync4.go
- en: The preceding code uses a `sync.RWMutex` variable (see preceding section, *Synchronizing
    with Mutex Locks*) to manage the locks when accessing the map variable `cache`.
    The code wraps the update operation to the `cache` variable within a pair of method
    calls, `mutex.Lock()` and `mutex.Unlock()`. However, when reading values from
    the `cache` variable, the `mutex.RLock()` and `mutex.RUnlock()`methods are used
    to provide concurrency safety.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了`sync.RWMutex`变量（参见前面的章节，*使用Mutex Locks进行同步*）来管理访问`cache`映射变量时的锁。代码将对`cache`变量的更新操作包装在一对方法调用`mutex.Lock()`和`mutex.Unlock()`中。然而，当从`cache`变量中读取值时，使用`mutex.RLock()`和`mutex.RUnlock()`方法来提供并发安全性。
- en: Concurrency barriers with sync.WaitGroup
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sync.WaitGroup进行并发障碍
- en: 'Sometimes when working with goroutines, you may need to create a synchronization
    barrier where you wish to wait for all running goroutines to finish before proceeding.
    The `sync.WaitGroup` type is designed for such a scenario, allowing multiple goroutines
    to rendezvous at specific point in the code. Using WaitGroup requires three things:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在使用goroutine时，您可能需要创建一个同步障碍，希望在继续之前等待所有正在运行的goroutine完成。`sync.WaitGroup`类型就是为这种情况设计的，允许多个goroutine在代码中的特定点会合。使用WaitGroup需要三件事：
- en: The number of participants in the group via the Add method
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Add方法设置组中的参与者数量
- en: Each goroutine calls the Done method to signal completion
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个goroutine调用Done方法来表示完成
- en: Use the Wait method to block until all goroutines are done
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Wait方法阻塞，直到所有goroutine完成
- en: 'WaitGroup is often used as a way to implement work distribution patterns. The
    following code snippet illustrates work distribution to calculate the sum of multiples
    of `3` and `5` up to `MAX`. The code uses the `WaitGroup` variable, `wg`, to create
    a concurrency barrier that waits for two goroutines to calculate the partial sums
    of the numbers, then gathers the result after all goroutines are done:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: WaitGroup经常被用来实现工作分配模式。下面的代码片段演示了工作分配，计算`3`和`5`的倍数的和，直到`MAX`。代码使用`WaitGroup`变量`wg`创建并发障碍，等待两个goroutine计算数字的部分和，然后在所有goroutine完成后收集结果：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: golang.fyi/ch09/sync5.go
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/sync5.go
- en: In the previous code, the method call, `wg.Add(2)`, configures the `WaitGroup`
    variable `wg` because the work is distributed between two goroutines. The `work`
    function calls `defer wg.Done()` to decrement the WaitGroup counter by one every
    time it is completed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，方法调用`wg.Add(2)`配置了`WaitGroup`变量`wg`，因为工作在两个goroutine之间分配。`work`函数调用`defer
    wg.Done()`在每次完成时将WaitGroup计数器减一。
- en: Lastly, the `wg.Wait()`method call blocks until its internal counter reaches
    zero. As explained previously, this will happen when both goroutines' `work` running
    function complete successfully. When that happens, the program unblocks and gathers
    the partial results. It is important to remember that `wg.Wait()` will block indefinitely
    if its internal counter never reaches zero.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`wg.Wait()`方法调用会阻塞，直到其内部计数器达到零。如前所述，当两个goroutine的`work`运行函数都成功完成时，这将发生。当发生这种情况时，程序将解除阻塞并收集部分结果。重要的是要记住，如果内部计数器永远不达到零，`wg.Wait()`将无限期地阻塞。
- en: Detecting race conditions
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测竞争条件
- en: Debugging concurrent code with a race condition can be time consuming and frustrating.
    When a race condition occurs, it is usually inconsistent and displays little to
    no discernible pattern. Fortunately, since Version 1.1, Go has included a race
    detector as part of its command-line tool chain. When building, testing, installing,
    or running Go source code, simply add the `-race` command flag to enable the race
    detector instrumentation of your code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有竞争条件的并发代码进行调试可能是耗时且令人沮丧的。当竞争条件发生时，通常是不一致的，并且显示很少或没有可辨认的模式。幸运的是，自从1.1版本以来，Go已经将竞争检测器作为其命令行工具链的一部分。在构建、测试、安装或运行Go源代码时，只需添加`-race`命令标志即可启用代码的竞争检测器。
- en: 'For instance, when the source file `golang.fyi/ch09/sync1.go` (a code with
    a race condition) is executed with the `-race` flag, the compiler''s output shows
    the offending goroutine locations that caused the race condition, as shown in
    the following output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用`-race`标志执行源文件`golang.fyi/ch09/sync1.go`（一个带有竞争条件的代码）时，编译器的输出显示了导致竞争条件的冒犯性goroutine位置，如下面的输出所示：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The race detector lists the line numbers where there is concurrent access to
    shared values. It lists the *read* operations followed by the locations where
    *write* operations may happen concurrently. Racy conditions in code can go unnoticed,
    even in well-tested code, until it manifests itself randomly. If you are writing
    concurrent code, it is highly recommended that you integrate the race detector
    as part of your testing suite.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争检测器列出了共享值的并发访问的行号。它列出了*读取*操作，然后是可能同时发生*写入*操作的位置。即使在经过充分测试的代码中，代码中的竞争条件也可能被忽略，直到它随机地显现出来。如果您正在编写并发代码，强烈建议您将竞争检测器作为测试套件的一部分集成进去。
- en: Parallelism in Go
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的并行性
- en: 'So far, the discussion in this chapter has focused on synchronizing concurrent
    programs. As was mentioned earlier in the chapter, the Go runtime scheduler automatically
    multiplexes and schedules goroutines across available OS-managed threads. This
    means concurrent programs that can be parallelized have the ability to take advantage
    of the underlying processor cores with little to no configuration. For instance,
    the following code cleanly segregates its work unit (to calculate sums of multiples
    of 3 and 5) to be calculated by launching `workers` number of goroutines:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章的讨论重点是同步并发程序。正如本章前面提到的，Go运行时调度器会自动在可用的OS管理线程上多路复用和调度goroutine。这意味着可以并行化的并发程序可以利用底层处理器核心，几乎不需要配置。例如，以下代码通过启动`workers`数量的goroutine来清晰地分隔其工作单元（计算3和5的倍数的和）：
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: golang.fyi/ch09/sync6.go
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/sync6.go
- en: The previous code will automatically launch each goroutine, with `go work()`,
    in parallel when executed on a multi-core machine. The Go runtime scheduler, by
    default, will create a number of OS-backed threads for scheduling that is equal
    to the number of CPU cores. That quantity is identified by runtime value called
    *GOMAXPROCS*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在多核机器上执行时，上述代码将自动并行启动每个goroutine，使用`go work()`。默认情况下，Go运行时调度器将为调度创建一定数量的OS支持的线程，该数量等于CPU核心数。这个数量由运行时值*GOMAXPROCS*确定。
- en: The GOMAXPROCS value can be explicitly changed to influence the number threads
    that are made available to the scheduler. That value can be changed using a command-line
    environment variable with the same name. GOMAXPROCS can also be updated in the
    using function `GOMAXPROCS()` from the *runtime* package ([https://golang.org/pkg/runtime](https://golang.org/pkg/runtime)).
    Either approach allows programmers to fine-tune the number of threads that will
    participate in scheduling goroutines.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: GOMAXPROCS值可以被显式更改以影响可用于调度的线程数。该值可以使用相同名称的命令行环境变量进行更改。GOMAXPROCS也可以在*runtime*包的`GOMAXPROCS()`函数中进行更新（[https://golang.org/pkg/runtime](https://golang.org/pkg/runtime)）。任何一种方法都允许程序员微调将参与调度goroutine的线程数。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Concurrency can be a complex topic in any language. This chapter covered the
    major topics to guide readers around the use of concurrency primitives in the
    Go language. The first section of the chapter outlined the crucial properties
    of goroutines, including the creation and usage of the *go* statement. Next, the
    chapter covered the mechanism of Go's runtime scheduler and the notion of channels
    used for communication between running goroutines. Lastly, users were introduced
    to several concurrency patterns used to create concurrent programs using goroutines,
    channels, and the synchronization primitives from the sync package.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 并发在任何语言中都可能是一个复杂的话题。本章介绍了主要内容，以指导读者如何在Go语言中使用并发原语。本章的第一部分概述了goroutine的关键属性，包括*go*语句的创建和使用。接下来，本章介绍了Go运行时调度器的机制，以及用于在运行的goroutine之间进行通信的通道的概念。最后，用户被介绍了几种使用goroutine、通道和sync包中的同步原语创建并发程序的并发模式。
- en: Next, you will be introduced to the standard APIs to do data input and output
    in Go.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将介绍在Go中进行数据输入和输出的标准API。
