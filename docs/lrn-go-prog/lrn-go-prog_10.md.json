["```go\ntype Reader interface { \n        Read(p []byte) (n int, err error) \n} \n\n```", "```go\ntype alphaReader string \n\nfunc (a alphaReader) Read(p []byte) (int, error) { \n   count := 0 \n   for i := 0; i < len(a); i++ { \n         if (a[i] >= 'A' && a[i] <= 'Z') || \n               (a[i] >= 'a' && a[i] <= 'z') { \n               p[i] = a[i] \n         } \n         count++ \n   } \n   return count, io.EOF \n} \n\nfunc main() { \n   str := alphaReader(\"Hello! Where is the sun?\") \n   io.Copy(os.Stdout, &str) \n   fmt.Println() \n} \n\n```", "```go\ntype alphaReader struct { \n   src io.Reader \n} \n\nfunc NewAlphaReader(source io.Reader) *alphaReader { \n   return &alphaReader{source} \n} \n\nfunc (a *alphaReader) Read(p []byte) (int, error) { \n   if len(p) == 0 { \n         return 0, nil \n   } \n   count, err := a.src.Read(p) // p has now source data \n   if err != nil { \n         return count, err \n   } \n   for i := 0; i < len(p); i++ { \n         if (p[i] >= 'A' && p[i] <= 'Z') || \n               (p[i] >= 'a' && p[i] <= 'z') { \n               continue \n         } else { \n               p[i] = 0 \n         } \n   } \n   return count, io.EOF \n} \n\nfunc main() { \n   str := strings.NewReader(\"Hello! Where is the sun?\") \n   alpha := NewAlphaReader(str) \n   io.Copy(os.Stdout, alpha) \n   fmt.Println() \n} \n\n```", "```go\n... \nfunc main() { \n   file, _ := os.Open(\"./reader2.go\") \n   alpha := NewAlphaReader(file) \n   io.Copy(os.Stdout, alpha) \n   fmt.Println() \n} \n\n```", "```go\ntype Writer interface { \n   Write(p []byte) (n int, err error) \n} \n\n```", "```go\ntype channelWriter struct { \n   Channel chan byte \n} \n\nfunc NewChannelWriter() *channelWriter { \n   return &channelWriter{ \n         Channel: make(chan byte, 1024), \n   } \n} \n\nfunc (c *channelWriter) Write(p []byte) (int, error) { \n   if len(p) == 0 { \n         return 0, nil \n   } \n\n   go func() { \n         defer close(c.Channel) // when done \n         for _, b := range p { \n               c.Channel <- b \n         } \n   }() \n\n   return len(p), nil \n} \n\n```", "```go\nfunc main() { \n   cw := NewChannelWriter() \n   go func() { \n         fmt.Fprint(cw, \"Stream me!\") \n   }() \n\n   for c := range cw.Channel { \n         fmt.Printf(\"%c\\n\", c) \n   } \n} \n\n```", "```go\nfunc main() { \n   cw := NewChannelWriter() \n   file, err := os.Open(\"./writer2.go\") \n   if err != nil { \n         fmt.Println(\"Error reading file:\", err) \n         os.Exit(1) \n   } \n   _, err = io.Copy(cw, file) \n   if err != nil { \n         fmt.Println(\"Error copying:\", err) \n         os.Exit(1) \n   } \n\n   // consume channel \n   for c := range cw.Channel { \n         fmt.Printf(\"%c\\n\", c) \n   } \n} \n\n```", "```go\ndata := strings.NewReader(\"Write   me down.\")   \nfile, _ := os.Create(\"./iocopy.data\")   \nio.Copy(file, data)   \n\n```", "```go\nfile, _ := os.Create(\"./iopipe.data\")   \npr, pw := io.Pipe()    \ngo func() {   \n    fmt.Fprint(pw, \"Pipe   streaming\")   \n    pw.Close()   \n}()   \n\nwait := make(chan struct{})   \ngo func() {   \n    io.Copy(file, pr)   \n    pr.Close()   \n    close(wait)   \n}()   \n<-wait //wait for pr to finish   \n\n```", "```go\nfin, _ := os.Open(\"./ioteerdr.go\")   \ndefer fin.Close()   \nfout, _ := os.Create(\"./teereader.gz\")   \ndefer fout.Close()   \n\nzip := gzip.NewWriter(fout)   \ndefer zip.Close()   \nsha := sha1.New()   \ndata := io.TeeReader(fin, sha)    \nio.Copy(zip, data)   \n\nfmt.Printf(\"SHA1 hash %x\\n\",   sha.Sum(nil))   \n\n```", "```go\nsha := sha1.New()   \nmd := md5.New()   \ndata := io.TeeReader(\n  io.TeeReader(fin, md), sha,   \n)    \nio.Copy(zip, data)   \n\n```", "```go\nfout, err := os.Create(\"./iowritestr.data\")   \nif err != nil {   \n    fmt.Println(err)   \n    os.Exit(1)   \n}   \ndefer fout.Close()   \nio.WriteString(fout, \"Hello   there!\\n\")   \n\n```", "```go\nstr := strings.NewReader(\"The   quick brown \" +       \n    \"fox jumps over the lazy   dog\")   \nlimited :=   &io.LimitedReader{R: str, N: 19}   \nio.Copy(os.Stdout, limited)   \n\n```", "```go\n$> go run iolimitedrd.go   \nThe quick brown fox   \n\n```", "```go\nstr := strings.NewReader(\"The   quick brown\"+   \n    \"fox jumps over the lazy   dog\")   \nsection := io.NewSectionReader(str,   19, 23)   \nio.Copy(os.Stdout, section)   \n\n```", "```go\nfunc main() { \n   f1, err := os.Open(\"./file0.go\") \n   if err != nil { \n         fmt.Println(\"Unable to open file:\", err) \n         os.Exit(1) \n   } \n   defer f1.Close() \n\n   f2, err := os.Create(\"./file0.bkp\") \n   if err != nil { \n         fmt.Println(\"Unable to create file:\", err) \n         os.Exit(1) \n   } \n   defer f2.Close() \n\n   n, err := io.Copy(f2, f1) \n   if err != nil { \n         fmt.Println(\"Failed to copy:\", err) \n         os.Exit(1) \n   } \n\n   fmt.Printf(\"Copied %d bytes from %s to %s\\n\",  \n       n, f1.Name(), f2.Name()) \n} \n\n```", "```go\nfunc main() { \n   f1, err := os.OpenFile(\"./file0.go\", os.O_RDONLY, 0666) \n   if err != nil {...} \n   defer f1.Close() \n\n   f2, err := os.OpenFile(\"./file0.bkp\", os.O_WRONLY, 0666) \n   if err != nil {...} \n   defer f2.Close() \n\n   n, err := io.Copy(f2, f1) \n   if err != nil {...} \n\n   fmt.Printf(\"Copied %d bytes from %s to %s\\n\",  \n      n, f1.Name(), f2.Name()) \n} \n\n```", "```go\nfunc main() { \n   rows := []string{ \n         \"The quick brown fox\", \n         \"jumps over the lazy dog\", \n   } \n\n   fout, err := os.Create(\"./filewrite.data\") \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n   defer fout.Close() \n\n   for _, row := range rows { \n         fout.WriteString(row) \n   } \n} \n\n```", "```go\nfunc main() { \n   data := [][]byte{ \n         []byte(\"The quick brown fox\\n\"), \n         []byte(\"jumps over the lazy dog\\n\"), \n   } \n   fout, err := os.Create(\"./filewrite.data\") \n   if err != nil { ... } \n   defer fout.Close() \n\n   for _, out := range data { \n         fout.Write(out) \n   } \n} \n\n```", "```go\nfunc main() { \n   fin, err := os.Open(\"../ch05/dict.txt\") \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n   defer fin.Close() \n   p := make([]byte, 1024) \n   for { \n         n, err := fin.Read(p) \n         if err == io.EOF { \n               break \n         } \n         fmt.Print(string(p[:n])) \n   } \n} \n\n```", "```go\nfunc main() { \n   f1, err := os.Open(\"./file0.go\") \n   if err != nil { \n         fmt.Println(\"Unable to open file:\", err) \n         os.Exit(1) \n   } \n   defer f1.Close() \n\n   n, err := io.Copy(os.Stdout, f1) \n   if err != nil { \n         fmt.Println(\"Failed to copy:\", err) \n         os.Exit(1) \n   } \n\n   fmt.Printf(\"Copied %d bytes from %s \\n\", n, f1.Name()) \n} \n\n```", "```go\ntype metalloid struct { \n   name   string \n   number int32 \n   weight float64 \n} \n\nfunc main() { \n   var metalloids = []metalloid{ \n         {\"Boron\", 5, 10.81}, \n         ... \n         {\"Polonium\", 84, 209.0}, \n   } \n   file, _ := os.Create(\"./metalloids.txt\") \n   defer file.Close() \n\n   for _, m := range metalloids { \n         fmt.Fprintf( \n               file, \n               \"%-10s %-10d %-10.3f\\n\", \n               m.name, m.number, m.weight, \n         ) \n   } \n} \n\n```", "```go\ntype metalloid struct { ... } \nfunc main() { \n   var metalloids = []metalloid{ \n         {\"Boron\", 5, 10.81}, \n         ... \n         {\"Polonium\", 84, 209.0}, \n   } \n\n   for _, m := range metalloids { \n         fmt.Printf( \n               \"%-10s %-10d %-10.3f\\n\", \n               m.name, m.number, m.weight, \n         ) \n   } \n} \n\n```", "```go\nfunc main() { \n   var name, hasRing string \n   var diam, moons int \n\n   // read data \n   data, err := os.Open(\"./planets.txt\") \n   if err != nil { \n         fmt.Println(\"Unable to open planet data:\", err) \n         return \n   } \n   defer data.Close() \n\n   for { \n         _, err := fmt.Fscanf( \n               data, \n               \"%s %d %d %s\\n\", \n               &name, &diam, &moons, &hasRing, \n         ) \n         if err != nil { \n               if err == io.EOF { \n                     break \n               } else { \n                     fmt.Println(\"Scan error:\", err) \n                     return \n               } \n         } \n         fmt.Printf( \n               \"%-10s %-10d %-6d %-6s\\n\", \n               name, diam, moons, hasRing, \n         ) \n   } \n\n```", "```go\nfunc main() { \n   var choice int \n   fmt.Println(\"A square is what?\") \n   fmt.Print(\"Enter 1=quadrilateral 2=rectagonal:\") \n\n   n, err := fmt.Scanf(\"%d\", &choice) \n   if n != 1 || err != nil { \n         fmt.Println(\"Follow directions!\") \n         return \n   } \n   if choice == 1 { \n         fmt.Println(\"You are correct!\") \n   } else { \n         fmt.Println(\"Wrong, Google it.\") \n   } \n} \n\n```", "```go\n$> go run fmtscan1.go\nA square is what?\nEnter 1=quadrilateral 2=rectagonal: D\nFollow directions!\n\n```", "```go\nfunc main() { \n   rows := []string{ \n         \"The quick brown fox\", \n         \"jumps over the lazy dog\", \n   } \n\n   fout, err := os.Create(\"./filewrite.data\") \n   writer := bufio.NewWriter(fout) \n   if err != nil { \n         fmt.Println(err) \n         os.Exit(1) \n   } \n   defer fout.Close() \n\n   for _, row := range rows { \n         writer.WriteString(row) \n   } \n   writer.Flush() \n} \n\n```", "```go\nfunc main() { \n   file, err := os.Open(\"./bufread0.go\") \n   if err != nil { \n         fmt.Println(\"Unable to open file:\", err) \n         return \n   } \n   defer file.Close() \n\n   reader := bufio.NewReader(file) \n   for { \n         line, err := reader.ReadString('\\n') \n         if err != nil { \n               if err == io.EOF { \n                     break \n               } else { \n                     fmt.Println(\"Error reading:, err\") \n                     return \n               } \n         } \n         fmt.Print(line) \n   } \n} \n\n```", "```go\nfunc main() { \n   file, err := os.Open(\"./planets.txt\") \n   if err != nil { \n         fmt.Println(\"Unable to open file:\", err) \n         return \n   } \n   defer file.Close() \n\n   fmt.Printf( \n         \"%-10s %-10s %-6s %-6s\\n\", \n         \"Planet\", \"Diameter\", \"Moons\", \"Ring?\", \n   ) \n   scanner := bufio.NewScanner(file) \n   scanner.Split(bufio.ScanLines) \n   for scanner.Scan() { \n         fields := strings.Split(scanner.Text(), \" \") \n         fmt.Printf( \n               \"%-10s %-10s %-6s %-6s\\n\", \n               fields[0], fields[1], fields[2], fields[3], \n         ) \n   } \n} \n\n```", "```go\nfunc main() { \n   var books bytes.Buffer \n   books.WriteString(\"The Great Gatsby\") \n   books.WriteString(\"1984\") \n   books.WriteString(\"A Tale of Two Cities\") \n   books.WriteString(\"Les Miserables\") \n   books.WriteString(\"The Call of the Wild\") \n\n   books.WriteTo(os.Stdout) \n} \n\n```", "```go\nfunc main() { \n   var books bytes.Buffer \n   books.WriteString(\"The Great Gatsby\\n\") \n   books.WriteString(\"1984\\n\") \n   books.WriteString(\"A Take of Two Cities\\n\") \n   books.WriteString(\"Les Miserables\\n\") \n   books.WriteString(\"The Call of the Wild\\n\") \n\n   file, err := os.Create(\"./books.txt\") \n   if err != nil { \n         fmt.Println(\"Unable to create file:\", err) \n         return \n   } \n   defer file.Close() \n   books.WriteTo(file) \n} \n\n```", "```go\ntype Name struct { \n   First, Last string \n} \n\ntype Book struct { \n   Title       string \n   PageCount   int \n   ISBN        string \n   Authors     []Name \n   Publisher   string \n   PublishDate time.Time \n} \n\nfunc main() { \n   books := []Book{ \n         Book{ \n               Title:       \"Leaning Go\", \n               PageCount:   375, \n               ISBN:        \"9781784395438\", \n               Authors:     []Name{{\"Vladimir\", \"Vivien\"}}, \n               Publisher:   \"Packt\", \n               PublishDate: time.Date( \n                     2016, time.July, \n                     0, 0, 0, 0, 0, time.UTC, \n               ), \n         }, \n         Book{ \n               Title:       \"The Go Programming Language\", \n               PageCount:   380, \n               ISBN:        \"9780134190440\", \n               Authors:     []Name{ \n                     {\"Alan\", \"Donavan\"}, \n                     {\"Brian\", \"Kernighan\"}, \n               }, \n               Publisher:   \"Addison-Wesley\", \n               PublishDate: time.Date( \n                     2015, time.October, \n                     26, 0, 0, 0, 0, time.UTC, \n               ), \n         }, \n         ... \n   } \n\n   // serialize data structure to file \n   file, err := os.Create(\"book.dat\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   enc := gob.NewEncoder(file) \n   if err := enc.Encode(books); err != nil { \n         fmt.Println(err) \n   } \n} \n\n```", "```go\ntype Name struct { \n   First, Last string \n} \n\ntype Book struct { \n   Title       string \n   PageCount   int \n   ISBN        string \n   Authors     []Name \n   Publisher   string \n   PublishDate time.Time \n} \n\nfunc main() { \n   file, err := os.Open(\"book.dat\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n\n   var books []Book \n   dec := gob.NewDecoder(file) \n   if err := dec.Decode(&books); err != nil { \n         fmt.Println(err) \n         return \n   } \n} \n\n```", "```go\ntype Name struct { \n   First, Last string \n} \n\ntype Book struct { \n   Title       string \n   PageCount   int \n   ISBN        string \n   Authors     []Name \n   Publisher   string \n   PublishDate time.Time \n} \n\nfunc main() { \n   books := []Book{ \n         Book{ \n               Title:       \"Leaning Go\", \n               PageCount:   375, \n               ISBN:        \"9781784395438\", \n               Authors:     []Name{{\"Vladimir\", \"Vivien\"}}, \n               Publisher:   \"Packt\", \n               PublishDate: time.Date( \n                     2016, time.July, \n                     0, 0, 0, 0, 0, time.UTC), \n         }, \n         ... \n   } \n\n   file, err := os.Create(\"book.dat\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   enc := json.NewEncoder(file) \n   if err := enc.Encode(books); err != nil { \n         fmt.Println(err) \n   } \n} \n\n```", "```go\n[ \n {\n \"Title\":\"Leaning Go\",\n \"PageCount\":375,\n \"ISBN\":\"9781784395438\",\n \"Authors\":[{\"First\":\"Vladimir\",\"Last\":\"Vivien\"}],\n \"Publisher\":\"Packt\",\n \"PublishDate\":\"2016-06-30T00:00:00Z\"\n },\n {\n \"Title\":\"The Go Programming Language\",\n \"PageCount\":380,\n \"ISBN\":\"9780134190440\",\n \"Authors\":[\n {\"First\":\"Alan\",\"Last\":\"Donavan\"},\n                      {\"First\":\"Brian\",\"Last\":\"Kernighan\"}\n ],\n \"Publisher\":\"Addison-Wesley\",\n \"PublishDate\":\"2015-10-26T00:00:00Z\"\n },\n ...\n]\n\n```", "```go\nfunc main() { \n   file, err := os.Open(\"book.dat\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n\n   var books []Book \n   dec := json.NewDecoder(file) \n   if err := dec.Decode(&books); err != nil { \n         fmt.Println(err) \n         return \n   } \n} \n\n```", "```go\ntype Book struct { \n   Title       string      `json:\"book_title\"` \n   PageCount   int         `json:\"pages,string\"` \n   ISBN        string      `json:\"-\"` \n   Authors     []Name      `json:\"auths,omniempty\"` \n   Publisher   string      `json:\",omniempty\"` \n   PublishDate time.Time   `json:\"pub_date\"` \n} \n\n```", "```go\n... \n{ \n   \"book_title\":\"The Go Programming Language\", \n   \"pages\":\"380\", \n   \"auths\":[ \n         {\"First\":\"Alan\",\"Last\":\"Donavan\"}, \n         {\"First\":\"Brian\",\"Last\":\"Kernighan\"} \n   ], \n   \"Publisher\":\"Addison-Wesley\", \n   \"pub_date\":\"2015-10-26T00:00:00Z\" \n} \n... \n\n```", "```go\ntype Name struct { \n   First, Last string \n} \nfunc (n *Name) MarshalJSON() ([]byte, error) { \n   return []byte( \n         fmt.Sprintf(\"\"%s, %s\"\", n.Last, n.First) \n   ), nil \n} \n\ntype Book struct { \n   Title       string \n   PageCount   int \n   ISBN        string \n   Authors     []Name \n   Publisher   string \n   PublishDate time.Time \n} \nfunc main(){ \n   books := []Book{ \n         Book{ \n               Title:       \"Leaning Go\", \n               PageCount:   375, \n               ISBN:        \"9781784395438\", \n               Authors:     []Name{{\"Vladimir\", \"Vivien\"}}, \n               Publisher:   \"Packt\", \n               PublishDate: time.Date( \n                     2016, time.July, \n                     0, 0, 0, 0, 0, time.UTC), \n         }, \n         ... \n   } \n   ... \n   enc := json.NewEncoder(file) \n   if err := enc.Encode(books); err != nil { \n         fmt.Println(err) \n   } \n} \n\n```", "```go\n [\n ...\n {\n                \"Title\":\"Leaning Go\",\n                \"PageCount\":375,\n                \"ISBN\":\"9781784395438\",\n                \"Authors\":[\"Vivien, Vladimir\"],\n                \"Publisher\":\"Packt\",\n                \"PublishDate\":\"2016-06-30T00:00:00Z\"\n          },\n          ...\n    ] \n\n```", "```go\ntype Name struct { \n   First, Last string \n} \n\nfunc (n *Name) UnmarshalJSON(data []byte) error { \n   var name string \n   err := json.Unmarshal(data, &name) \n   if err != nil { \n         fmt.Println(err) \n         return err \n   } \n   parts := strings.Split(name, \", \") \n   n.Last, n.First = parts[0], parts[1] \n   return nil \n} \n\n```"]