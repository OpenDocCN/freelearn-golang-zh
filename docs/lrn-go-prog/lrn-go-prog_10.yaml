- en: Chapter 10. Data IO in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。Go中的数据IO
- en: 'Previous chapters of this book focused mainly on fundamentals. In this and
    future chapters, readers are introduced to some of the powerful APIs provided
    by Go''s standard library. This chapter discusses in detail how to input, process,
    transform, and output data using APIs from the standard library and their respective
    packages with the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前几章主要关注基础知识。在本章和以后的章节中，读者将介绍Go标准库提供的一些强大API。本章详细讨论了如何使用标准库及其各自的包的API输入、处理、转换和输出数据的主题：
- en: IO with readers and writers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用读取器和写入器的IO
- en: The io.Reader interface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: io.Reader接口
- en: The io.Writer interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: io.Writer接口
- en: Working with the io package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用io包
- en: Working with files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件
- en: Formatted IO with fmt
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fmt进行格式化IO
- en: Buffered IO
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲IO
- en: In-memory IO
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存IO
- en: Encoding and decoding data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码和解码数据
- en: IO with readers and writers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用读取器和写入器的IO
- en: 'Similar to other languages, such as Java, Go models data input and output as
    a stream that flows from sources to targets. Data resources, such as files, networked
    connections, or even some in-memory objects, can be modeled as streams of bytes
    from which data can be *read* or *written* to, as illustrated in the following
    figure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言类似，如Java，Go将数据输入和输出建模为从源到目标的流。数据资源，如文件、网络连接，甚至一些内存对象，都可以被建模为字节流，从中可以读取或写入数据，如下图所示：
- en: '![IO with readers and writers](img/image_10_001.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![使用读取器和写入器的IO](img/image_10_001.jpg)'
- en: The stream of data is represented as a **slice of bytes** (**[]byte**) that
    can be accessed for reading or writing. As we will explore in this chapter, the
    `*io*` package makes available the `io.Reader` interface to implement code that
    *reads* and transfers data from a source into a stream of bytes. Conversely, the
    `io.Writer` interface lets implementers create code that reads data from a provided
    stream of bytes and *writes* it as output to a target resource. Both interfaces
    are used extensively in Go as a standard idiom to express IO operations. This
    makes it possible to interchange readers and writers of different implementations
    and contexts with predictable results.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流表示为可以访问以进行读取或写入的**字节切片**（**[]byte**）。正如我们将在本章中探讨的，`*io*`包提供了`io.Reader`接口来实现从源到字节流的数据传输和读取的代码。相反，`io.Writer`接口让实现者创建从提供的字节流中读取数据并将其作为输出写入到目标资源的代码。这两个接口在Go中被广泛使用，作为表达IO操作的标准习语。这使得可以在不同实现和上下文中交换读取器和写入器，并获得可预测的结果。
- en: The io.Reader interface
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: io.Reader接口
- en: The `io.Reader` interface, as shown in the following listing, is simple. It
    consists of a single method, `Read([]byte)(int, error)`, intended to let programmers
    implement code that *reads* data, from an arbitrary source, and transfers it into
    the provided slice of bytes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如下列表所示，`io.Reader`接口很简单。它由一个方法`Read([]byte)(int, error)`组成，旨在让程序员实现从任意源读取数据，并将其传输到提供的字节切片中。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Read` method returns the total number of bytes transferred into the provided
    slice and an error value (if necessary). As a guideline, implementations of the
    `io.Reader` should return an error value of `io.EOF` when the reader has no more
    data to transfer into stream `p`. The following shows the type `alphaReader`,
    a trivial implementation of the `io.Reader` that filters out non-alpha characters
    from its string source:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read`方法返回传输到提供的切片中的总字节数和错误值（如果有必要）。作为指导，`io.Reader`的实现应在读取器没有更多数据传输到流`p`中时返回`io.EOF`的错误值。以下显示了类型`alphaReader`，这是`io.Reader`的一个简单实现，它从其字符串源中过滤掉非字母字符：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch10/reader0.go
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/reader0.go
- en: Since values of the `alphaReader` type implement the `io.Reader` interface,
    they can participate anywhere a reader is expected as shown in the call to `io.Copy(os.Stdout,
    &str)`. This copies the stream of bytes emitted by the `alphaReader` variable
    into a writer interface, `os.Stdout` (covered later).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`alphaReader`类型的值实现了`io.Reader`接口，它们可以在需要读取器的任何地方参与，如在对`io.Copy(os.Stdout,
    &str)`的调用中所示。这将`alphaReader`变量发出的字节流复制到写入器接口`os.Stdout`（稍后介绍）。
- en: Chaining readers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接读取器
- en: 'Chances are the standard library already has a reader that you can reuse -
    so it is common to wrap an existing reader and use its stream as the source for
    the new implementation. The following snippet shows an updated version of `alphaReader`.
    This time, it takes an `io.Reader` as its source as shown in the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中很可能已经有一个可以重用的读取器，因此常见的做法是包装现有的读取器，并使用其流作为新实现的源。以下代码片段显示了`alphaReader`的更新版本。这次，它以`io.Reader`作为其源，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch10/reader1.go
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/reader1.go
- en: The main change to note in this version of the code is that the `alphaReader`
    type is now a struct which embeds an `io.Reader` value. When `alphaReader.Read()`
    is invoked, it calls the wrapped reader as `a.src.Read(p)`, which will inject
    the source data into byte slice `p`. Then the method loops through `p` and applies
    the filter to the data. Now, to use the `alphaReader`, it must first be provided
    with an existing reader which is facilitated by the `NewAlphaReader()` constructor
    function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本代码的主要变化是`alphaReader`类型现在是一个嵌入了`io.Reader`值的结构。当调用`alphaReader.Read()`时，它会调用包装的读取器，如`a.src.Read(p)`，这将把源数据注入到字节切片`p`中。然后该方法循环遍历`p`并对数据应用过滤器。现在，要使用`alphaReader`，必须首先提供一个现有的读取器，这由`NewAlphaReader()`构造函数来实现。
- en: 'The advantages of this approach may not be obvious at first. However, by using
    an `io.Reader` as the underlying data source the `alphaReader` type is capable
    of reading from any reader implementation. For instance, the following code snippet
    shows how the `alphaReader` type can now be combined with an `os.File` to filter
    out non-alphabetic characters from a file (the Go source code itself):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点一开始可能并不明显。然而，通过使用`io.Reader`作为底层数据源，`alphaReader`类型能够从任何读取器实现中读取。例如，以下代码片段显示了如何将`alphaReader`类型与`os.File`结合使用，以过滤文件中的非字母字符（Go源代码本身）：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch10/reader2.go
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/reader2.go
- en: The io.Writer interface
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: io.Writer接口
- en: 'The `io.Writer` interface, as shown in the following code, is just as simple
    as its reader counterpart:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Writer`接口，如下代码所示，与其读取器对应的接口一样简单：'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The interface requires the implementation of a single method, `Write(p []byte)(c
    int, e error)`, that copies data from the provided stream `p` and *writes* that
    data to a sink resource such as an in-memory structure, standard output, a file,
    a network connection, or any number of `io.Writer` implementations that come with
    the Go standard library. The `Write` method returns the number of bytes copied
    from `p` followed by an `error` value if any was encountered.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口要求实现一个单一方法，即`Write(p []byte)(c int, e error)`，该方法从提供的流`p`中复制数据并将该数据*写入*到诸如内存结构、标准输出、文件、网络连接或任何Go标准库提供的`io.Writer`实现等汇聚资源。`Write`方法返回从`p`中复制的字节数，然后是遇到的`error`值。
- en: 'The following code snippet shows the implementation of the `channelWriter`
    type, a writer that decomposes and serializes its stream that is sent over a Go
    channel as consecutive bytes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`channelWriter`类型的实现，它是一个将其流分解并序列化为连续字节发送到Go通道的写入器：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch10/writer1.go
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/writer1.go
- en: The `Write` method uses a goroutine to copy each byte, from `p`, and sends it
    across the `c.Channel`. Upon completion, the goroutine closes the channel so that
    consumers are notified when to stop consuming from the channel. As an implementation
    convention, writers should not modify slice `p` or hang on to it. When an error
    occurs, the writer should return the current number of bytes processed and an
    error.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write`方法使用goroutine从`p`中复制每个字节，并将其发送到`c.Channel`。完成后，goroutine关闭通道，以便在何时停止从通道中消耗时通知消费者。作为实现约定，写入器不应修改切片`p`或保留它。发生错误时，写入器应返回已处理的当前字节数和错误。'
- en: 'Using the `channelWriter` type is simple. You can invoke the `Write()` method
    directly or, as is more common, use `channelWriter` with other IO primitives in
    the API. For instance, the following snippet uses the `fmt.Fprint` function to
    serialize the `"Stream me!"` string as a sequence of bytes over a channel using
    `channelWriter`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`channelWriter`类型很简单。您可以直接调用`Write()`方法，或者更常见的是，使用API中的其他IO原语与`channelWriter`一起使用。例如，以下代码片段使用`fmt.Fprint`函数将`"Stream
    me!"`字符串序列化为一系列字节，并使用`channelWriter`将其发送到通道：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: golang.fyi/ch10/writer1.go
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/writer1.go
- en: 'In the previous snippet, the serialized bytes, queued in the channel, are consumed
    using a `for…range` statement as they are successively printed. The following
    snippet shows another example where the content of a file is serialized over a
    channel using the same `channelWriter`. In this implementation, an `io.File` value
    and `io.Copy` function are used to source the data instead of the `fmt.Fprint`
    function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，通过`for…range`语句连续打印序列化的字节，排队在通道中。以下代码片段显示了另一个示例，其中文件的内容使用相同的`channelWriter`序列化到通道上。在此实现中，使用`io.File`值和`io.Copy`函数来源数据，而不是使用`fmt.Fprint`函数：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: golang.fyi/ch10/writer2.go.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/writer2.go.
- en: Working with the io package
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用io包
- en: The obvious place to start with IO is, well, the `io` package ([https://golang.org/pkg/io](https://golang.org/pkg/io)).
    As we have already seen, the `io` package defines input and output primitives
    as the `io.Reader` and `io.Writer` interfaces. The following table summarizes
    additional functions and types, available in the `io` package, that facilitate
    streaming IO operations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: IO的明显起点是，嗯，`io`包（[https://golang.org/pkg/io](https://golang.org/pkg/io)）。正如我们已经看到的，`io`包定义了输入和输出原语，如`io.Reader`和`io.Writer`接口。以下表格总结了`io`包中可用的其他函数和类型，这些函数和类型有助于流式IO操作。
- en: '| **Function** | **Description** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **描述** |'
- en: '| `io.Copy()` | The `io.Copy` function (and its variants `io.CopyBuffer` and
    `io.CopyN`) make it easy to copy data from an arbitrary `io.Reader` source into
    an equally arbitrary `io.Writer` sink as shown in the following snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.Copy()` | `io.Copy`函数（以及其变体`io.CopyBuffer`和`io.CopyN`）使得从任意`io.Reader`源复制数据到同样任意的`io.Writer`汇聚变得容易，如下代码片段所示：'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: golang.fyi/ch10/iocopy.go |
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iocopy.go |
- en: '| `PipeReader PipeWriter` | The `io` package includes the *PipeReader* and
    *PipeWriter* types that model IO operations as an in-memory pipe. Data is written
    to the pipe''s `io.Writer` and can independently be read at the pipe''s `io.Reader`.
    The following abbreviated snippet illustrates a simple pipe that writes a string
    to the writer `pw`. The data is then consumed with the `pr` reader and copied
    to a file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '| `PipeReader PipeWriter` | `io`包包括*PipeReader*和*PipeWriter*类型，将IO操作建模为内存管道。数据被写入管道的`io.Writer`，并且可以独立地从管道的`io.Reader`读取。以下简略代码片段说明了一个简单的管道，将字符串写入写入器`pw`。然后，数据通过读取器`pr`消耗，并复制到文件中：'
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: golang.fyi/ch10/iopipe.goNote that the pipe writer will block until the reader
    completely consumes the pipe content or an error is encountered. Therefore, both
    the reader and writer should be wrapped in a goroutine to avoid deadlocks. |
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iopipe.go请注意，管道写入器将阻塞，直到读取器完全消耗管道内容或遇到错误。因此，读取器和写入器都应包装在goroutine中，以避免死锁。|
- en: '| `io.TeeReader()` | Similar to the `io.Copy` function, `io.TeeReader` transfers
    content from a reader to a writer. However, the function also emits the copied
    bytes (unaltered) via a returned `io.Reader`.The TeeReader works well for composing
    multi-step IO stream processing. The following abbreviated snippet first calculates
    the SHA-1 hash of a file content using the `TeeReader`. The resulting reader,
    `data`, is then streamed to a gzip writer `zip`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.TeeReader()` | 与`io.Copy`函数类似，`io.TeeReader`将内容从读取器传输到写入器。但是，该函数还通过返回的`io.Reader`发出复制的字节（未更改）。TeeReader非常适用于组合多步IO流处理。以下简略代码片段首先使用`TeeReader`计算文件内容的SHA-1哈希。然后，结果读取器`data`被流式传输到gzip写入器`zip`：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'golang.fyi/ch10/ioteerdr0.goIf we wanted to calculate both SHA-1 and MD5, we
    can update the code to nest the two `TeeReader` values as shown in the following
    snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/ioteerdr0.go 如果我们想要计算 SHA-1 和 MD5，可以更新代码以嵌套两个 `TeeReader` 值，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: golang.fyi/ch10/ioteerdr1.go |
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/ioteerdr1.go |
- en: '| `io.WriteString()` | The `io.WriteString` function writes the content of
    string into a specified writer. The following writes the content of a string to
    a file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.WriteString()` | `io.WriteString` 函数将字符串的内容写入指定的写入器。以下代码将字符串的内容写入文件：'
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: golang.fyi/ch10/iowritestr.go |
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iowritestr.go |
- en: '| `io.LimitedReader` | As its name suggests, the `io.LimitedReader` struct is
    a reader that reads only *N* number of bytes from the specified `io.Reader`. The
    following snippet will print the first 19 bytes from the string:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.LimitedReader` | 正如其名称所示，`io.LimitedReader` 结构是一个从指定的 `io.Reader` 中仅读取
    *N* 个字节的读取器。以下代码段将打印字符串的前 19 个字节：'
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: golang.fyi/ch10/iolimitedrdr.go
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iolimitedrdr.go
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `io.SectionReader` | The `io.SectionReader` type implements seek and skip
    primitives by specifying an index (zero-based) where to start reading and an offset
    value indicating the number of bytes to read as shown in the following snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '| `io.SectionReader` | `io.SectionReader` 类型通过指定索引（从零开始）来实现 seek 和 skip 原语，指示从哪里开始读取和偏移值，指示要读取的字节数，如下面的代码片段所示：'
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch10/iosectionrdr.goThis example will print `jumps over the lazy
    dog`. |
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/iosectionrdr.go 这个例子将打印 `jumps over the lazy dog`。
- en: '| Package `io/ioutil` | The `io/ioutil` sub-package implements a small number
    of functions that provide utilitarian shortcuts to IO primitives such as file
    read, directory listing, temp directory creation, and file write. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 包 `io/ioutil` | `io/ioutil` 子包实现了一小部分函数，提供了 IO 原语的实用快捷方式，如文件读取、目录列表、临时目录创建和文件写入。|'
- en: Working with files
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件
- en: The `os` package ([https://golang.org/pkg/os/](https://golang.org/pkg/os/))
    exposes the `os.File` type which represents a file handle on the system. The `os.File`
    type implements several IO primitives, including the `io.Reader` and `io.Writer`
    interfaces, which allows file content to be processed using the standard streaming
    IO API.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`os` 包 ([https://golang.org/pkg/os/](https://golang.org/pkg/os/)) 暴露了 `os.File`
    类型，它表示系统上的文件句柄。`os.File` 类型实现了几个 IO 原语，包括 `io.Reader` 和 `io.Writer` 接口，允许使用标准的流式
    IO API 处理文件内容。'
- en: Creating and opening files
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和打开文件
- en: The `os.Create` function creates a new file with the specified path. If the
    file already exists, `os.Create` will overwrite it. The `os.Open` function, on
    the other hand, opens an existing file for reading.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Create` 函数创建具有指定路径的新文件。如果文件已经存在，`os.Create` 将覆盖它。另一方面，`os.Open` 函数打开现有文件进行读取。'
- en: 'The following source snippet opens an existing file and creates a copy of its
    content using the `io.Copy` function. One common, and recommended practice to
    notice is the deferred call to the method `Close` on the file. This ensures a
    graceful release of OS resources when the function exits:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下源代码片段打开现有文件并使用 `io.Copy` 函数创建其内容的副本。一个常见且推荐的做法是在文件上调用 `Close` 方法的延迟调用。这确保了在函数退出时对
    OS 资源的优雅释放：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: golang.fyi/ch10/file0.go
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/file0.go
- en: Function os.OpenFile
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数 os.OpenFile
- en: The `os.OpenFile` function provides generic low-level functionalities to create
    a new file or open an existing file with fine-grained control over the file's
    behavior and its permission. Nevertheless, the `os.Open` and `os.Create` functions
    are usually used instead as they provide a simpler abstraction then the `os.OpenFile`
    function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.OpenFile` 函数提供了通用的低级功能，用于创建新文件或以细粒度控制文件的行为和权限打开现有文件。然而，通常使用 `os.Open` 和
    `os.Create` 函数，因为它们提供了比 `os.OpenFile` 函数更简单的抽象。'
- en: The `os.OpenFile` function take three parameters. The first one is the path
    of the file, the second parameter is a masked bit-field value to indicate the
    behavior of the operation (for example, read-only, read-write, truncate, and so
    on) and the last parameter is a posix-compliant permission value for the file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.OpenFile` 函数有三个参数。第一个是文件的路径，第二个参数是一个掩码位字段值，用于指示操作的行为（例如，只读、读写、截断等），最后一个参数是文件的
    posix 兼容权限值。'
- en: 'The following abbreviated source snippet re-implements the file copy code,
    from earlier. This time, however, it uses the `os.FileOpen` function to demonstrate
    how it works:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下缩写的源代码片段重新实现了之前的文件复制代码。然而，这次它使用 `os.FileOpen` 函数来演示它的工作原理：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: golang.fyi/ch10/file1.go
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/file1.go
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you already have a reference to an OS file descriptor, you can also use the
    `os.NewFile` function to create a file handle in your program. The `os.NewFile`
    function is rarely used, as files are usually initialized using the file functions
    discussed previously.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经有一个对操作系统文件描述符的引用，还可以使用 `os.NewFile` 函数在程序中创建文件句柄。`os.NewFile` 函数很少使用，因为文件通常是使用前面讨论过的文件函数进行初始化的。
- en: Files writing and reading
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件写入和读取
- en: 'We have already seen how to use the `os.Copy` function to move data into or
    out of a file. Sometimes, however, it will be necessary to have complete control
    over the logic that writes or reads file data. The following code snippet, for
    instance, uses the `WriteString` method from the `os.File` variable, `fout,` to
    create a text file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用 `os.Copy` 函数将数据移入或移出文件。然而，有时需要完全控制写入或读取文件数据的逻辑。例如，以下代码片段使用 `os.File`
    变量 `fout` 的 `WriteString` 方法创建文本文件：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: golang.fyi/ch10/filewrite0.go
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/filewrite0.go
- en: 'If, however, the source of your data is not text, you can write raw bytes directly
    to the file as shown in the following source snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您的数据源不是文本，可以直接将原始字节写入文件，如下面的源代码片段所示：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: golang.fyi/ch10/filewrite0.go
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/filewrite0.go
- en: 'As an `io.Reader`, reading from of the `io.File` type directly can be done
    using the *Read* method. This gives access to the content of the file as a raw
    stream of byte slices. The following code snippet reads the content of file `../ch0r/dict.txt`
    as raw bytes assigned to slice `p` up to 1024-byte chunks at a time:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`io.Reader`，可以直接使用*Read*方法从`io.File`类型读取。这样可以访问文件的内容，将其作为原始的字节片流。以下代码片段将文件`../ch0r/dict.txt`的内容作为原始字节读取，并分配给切片`p`，每次最多1024字节：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch10/fileread.go
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/fileread.go
- en: Standard input, output, and error
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准输入、输出和错误
- en: 'The `os` package includes three pre-declared variables, `os.Stdin`, `os.Stdout`,
    and `os.Stderr`, that represent file handles for standard input, output, and error
    of the OS respectively. The following snippet reads the file `f1` and writes its
    content to `io.Stdout`, standard output, using the `os.Copy` function (standard
    input is covered later):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包包括三个预声明变量，`os.Stdin`、`os.Stdout`和`os.Stderr`，它们分别表示操作系统的标准输入、输出和错误的文件句柄。以下代码片段读取文件`f1`，并使用`os.Copy`函数将其内容写入`io.Stdout`，即标准输出（标准输入稍后介绍）：'
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: golang.fyi/ch10/osstd.go
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/osstd.go
- en: Formatted IO with fmt
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`fmt`进行格式化IO
- en: One of the most widely used packages for IO is `fmt` ([https://golang.org/pkg/fmt](https://golang.org/pkg/fmt)).
    It comes with an amalgam of functions designed for formatted input and output.
    The most common usage of the `fmt` package is for writing to standard output and
    reading from standard input. This section also highlights other functions that
    make `fmt` a great tool for IO.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 用于IO的最常用的包之一是`fmt`（[https://golang.org/pkg/fmt](https://golang.org/pkg/fmt)）。它带有一系列函数，用于格式化输入和输出。`fmt`包最常见的用法是写入标准输出和从标准输入读取。本节还突出了使`fmt`成为IO工具的其他函数。
- en: Printing to io.Writer interfaces
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向`io.Writer`接口打印
- en: 'The `fmt` package offers several functions designed to write text data to arbitrary
    implementations of io.Writer. The `fmt.Fprint` and `fmt.Fprintln` functions write
    text with the default format while `fmt.Fprintf` supports format specifiers. The
    following code snippet writes a columnar formatted list of `metalloid` data to
    a specified text file using the `fmt.Fprintf` function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt`包提供了几个函数，用于将文本数据写入任意`io.Writer`的实现。`fmt.Fprint`和`fmt.Fprintln`函数使用默认格式写入文本，而`fmt.Fprintf`支持格式说明符。以下代码片段使用`fmt.Fprintf`函数将`metalloid`数据的列格式化列表写入指定的文本文件：'
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: golang.fyi/ch10/fmtfprint0.go
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/fmtfprint0.go
- en: In the previous example, the `fmt.Fprintf` function uses format specifiers to
    write formatted text to the io.File `file` variable. The `fmt.Fprintf` function
    supports a large number of format specifiers whose proper treatment is beyond
    the scope of this text. Refer to the online documentation for complete coverage
    of these specifiers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的示例中，`fmt.Fprintf`函数使用格式说明符将格式化文本写入`io.File`变量`file`。`fmt.Fprintf`函数支持大量格式说明符，其正确处理超出了本文的范围。请参阅在线文档，了解这些说明符的完整覆盖范围。
- en: Printing to standard output
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印到标准输出
- en: The `fmt.Print`, `fmt.Printf`, and `fmt.Println` have the exact same characteristics
    as the previous `Fprint`-series of functions seen earlier. Instead of an arbitrary
    `io.Writer` however, they write text to the standard output file handle `os.Stdout`
    (see the section *Standard output, input, and error* covered earlier).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Print`、`fmt.Printf`和`fmt.Println`具有与先前`Fprint`系列函数完全相同的特性。但是，它们不是向任意的`io.Writer`写入文本，而是将文本写入标准输出文件句柄`os.Stdout`（请参阅前面介绍的*标准输出、输入和错误*部分）。'
- en: 'The following abbreviated code snippet shows an updated version of the previous
    example that writes the list of metalloids to a standard output instead of a regular
    file. Note that it is the same code except for the use of the `fmt.Printf` instead
    of the `fmt.Fprintf` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新后的代码片段，显示了先前示例的更新版本，它将metalloid的列表写入标准输出而不是常规文件。请注意，除了使用`fmt.Printf`而不是`fmt.Fprintf`函数之外，它与相同的代码：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: golang.fyi/ch10/fmtprint0.go
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/fmtprint0.go
- en: Reading from io.Reader
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从`io.Reader`读取
- en: The `fmt` package also supports formatted reading of textual data from `io.Reader`
    interfaces. The `fmt.Fscan` and `fmt.Fscanln` functions can be used to read multiple
    values, separated by spaces, into specified parameters. The `fmt.Fscanf` function
    supports format specifiers for a richer and flexible parsing of data input from
    `io.Reader` implementations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt`包还支持从`io.Reader`接口格式化读取文本数据。`fmt.Fscan`和`fmt.Fscanln`函数可用于将多个值（以空格分隔）读入指定的参数。`fmt.Fscanf`函数支持格式说明符，用于从`io.Reader`实现中解析数据输入。'
- en: 'The following abbreviated code snippet uses the function `fmt.Fscanf` for the
    formatted input of a space-delimited file (`planets.txt`) containing planetary
    data:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用函数`fmt.Fscanf`对包含行星数据的以空格分隔的文件（`planets.txt`）进行格式化输入的缩写代码片段：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: golang.fyi/ch10/fmtfscan0.go
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/fmtfscan0.go
- en: The code reads from the `io.File` variable `data`, until it encounters an `io.EOF`
    error indicating the end of the file. Each line of text it reads is parsed using
    format specifiers `"%s %d %d %s\n"` which matches the space-delimited layout of
    the records stored in the file. Each parsed token is then assigned to its respective
    variable `name`, `diam`, `moons`, and `hasRing,` which are printed to the standard
    output using the `fm.Printf` function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码从`io.File`变量`data`读取，直到遇到表示文件结束的`io.EOF`错误。它读取的每行文本都使用格式说明符`"%s %d %d %s\n"`进行解析，该格式与文件中存储的记录的以空格分隔的布局匹配。然后，将每个解析的标记分配给其相应的变量`name`、`diam`、`moons`和`hasRing`，并使用`fm.Printf`函数将其打印到标准输出。
- en: Reading from standard input
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从标准输入读取
- en: 'Instead of reading from an arbitrary `io.Reader`, the `fmt.Scan`, `fmt.Scanf`,
    and `fmt.Scanln` are used to read data from standard input file handle, `os.Stdin`.
    The following code snippet shows a simple program that reads text input from the
    console:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不是从任意的`io.Reader`读取，而是使用`fmt.Scan`、`fmt.Scanf`和`fmt.Scanln`从标准输入文件句柄`os.Stdin`读取数据。以下代码片段显示了从控制台读取文本输入的简单程序：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: golang.fyi/ch10/fmtscan1.go
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/fmtscan1.go
- en: 'In the previous program, the `fmt.Scanf` function parses the input using the
    format specifier `"%d"` to read an integer value from the standard input. The
    function will throw an error if the value read does not match exactly the specified
    format. For instance, the following shows what happens when character `D` is read
    instead of an integer:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，`fmt.Scanf`函数使用格式说明符`"%d"`从标准输入中读取整数值。如果读取的值与指定的格式不完全匹配，该函数将抛出错误。例如，以下显示了当读取字符`D`而不是整数时会发生什么：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Buffered IO
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲IO
- en: Most IO operations covered so far have been unbuffered. This implies that each
    read and write operation could be negatively impacted by the latency of the underlying
    OS to handle IO requests. Buffered operations, on the other hand, reduces latency
    by buffering data in internal memory during IO operations. The `bufio` package
    ([https://golang.org/pkg/bufio](https://golang.org/pkg/bufio)/) offers functions
    for buffered read and write IO operations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大多数IO操作都是无缓冲的。这意味着每个读取和写入操作都可能受到底层操作系统处理IO请求的延迟的负面影响。另一方面，缓冲操作通过在IO操作期间在内部存储器中缓冲数据来减少延迟。`bufio`包（[https://golang.org/pkg/bufio](https://golang.org/pkg/bufio)/）提供了用于缓冲读写IO操作的函数。
- en: Buffered writers and readers
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲写入器和读取器
- en: 'The `bufio` package offers several functions to do buffered writing of IO streams
    using an `io.Writer` interface. The following snippet creates a text file and
    writes to it using buffered IO:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufio`包提供了几个函数，使用`io.Writer`接口对IO流进行缓冲写入。以下代码片段创建一个文本文件，并使用缓冲IO进行写入：'
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: golang.fyi/ch10/bufwrite0.go
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/bufwrite0.go
- en: In general, the constructor functions in the `bufio` package create a buffered
    writer by wrapping an existing `io.Writer` as its underlying source. For instance,
    the previous code creates a buffered writer using the `bufio.NewWriter` function
    by wrapping the io.File variable, `fout`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`bufio`包中的构造函数通过包装现有的`io.Writer`来创建缓冲写入器。例如，前面的代码使用`bufio.NewWriter`函数通过包装io.File变量`fout`创建了一个缓冲写入器。
- en: To influence the size of the internal buffer, use the constructor function `bufio.NewWriterSize(w
    io.Writer, n int)` to specify the internal buffer size. The `bufio.Writer` type
    also offers the methods `Write` and `WriteByte` for writing raw bytes and `WriteRune`
    for writing Unicode-encoded characters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要影响内部缓冲区的大小，可以使用构造函数`bufio.NewWriterSize(w io.Writer, n int)`来指定内部缓冲区的大小。`bufio.Writer`类型还提供了`Write`和`WriteByte`方法用于写入原始字节，以及`WriteRune`方法用于写入Unicode编码字符。
- en: 'Reading buffered streams can be done simply by calling the constructor function
    *bufio.NewReader* to wrap an existing `io.Reader`. The following code snippet
    creates a `bufio.Reader` variable `reader` by wrapping the `file` variable as
    its underlying source:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用构造函数*bufio.NewReader*简单地对缓冲流进行读取，以包装现有的`io.Reader`。以下代码片段通过包装`file`变量作为其底层源创建了一个`bufio.Reader`变量`reader`：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: golang`.fyi/ch10/bufread0.go`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: golang`.fyi/ch10/bufread0.go`
- en: The previous code uses the `reader.ReadString` method to read a text file using
    the `'\n'` character as the content delimiter. To influence the size of the internal
    buffer, use the constructor function `bufio.NewReaderSize(w io.Reader, n int)`
    to specify the internal buffer size. The `bufio.Reader` type also offers the *Read*,
    *ReadByte*, and *ReadBytes* methods for reading raw bytes from a stream and the
    *ReadRune* method for reading Unicode-encoded characters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用`reader.ReadString`方法使用`'\n'`字符作为内容分隔符读取文本文件。要影响内部缓冲区的大小，可以使用构造函数`bufio.NewReaderSize(w
    io.Reader, n int)`来指定内部缓冲区的大小。`bufio.Reader`类型还提供了*Read*、*ReadByte*和*ReadBytes*方法用于从流中读取原始字节，以及*ReadRune*方法用于读取Unicode编码字符。
- en: Scanning the buffer
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描缓冲区
- en: 'The `bufio` package also makes available primitives that are used to scan and
    tokenize buffered input data from an `io.Reader` source. The `bufio.Scanner` type
    scans input data using the *Split* method to define tokenization strategies. The
    following code snippet shows a reimplementation of the planetary example (from
    earlier). This time, the code uses `bufio.Scanner` (instead of the `fmt.Fscan`
    function) to scan the content of the text file using the `bufio.ScanLines` function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufio`包还提供了用于从`io.Reader`源扫描和标记缓冲输入数据的原语。`bufio.Scanner`类型使用*Split*方法扫描输入数据以定义标记化策略。以下代码片段显示了对行星示例（之前的示例）的重新实现。这次，代码使用`bufio.Scanner`（而不是`fmt.Fscan`函数）来扫描文本文件的内容，使用`bufio.ScanLines`函数：'
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: golang.fyi/ch10/bufscan0.go
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/bufscan0.go
- en: 'Using `bufio.Scanner` is done in four steps as shown in the previous example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bufio.Scanner`有四个步骤，如前面的示例所示：
- en: First, use `bufio.NewScanner(io.Reader)` to create a scanner
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用`bufio.NewScanner(io.Reader)`创建一个扫描器
- en: Call the `scanner.Split` method to configure how the content is tokenized
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`scanner.Split`方法来配置内容的标记化方式
- en: Traverse the generated tokens with the `scanner.Scan` method
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`scanner.Scan`方法遍历生成的标记
- en: Read the tokenized data with the `scanner.Text` method
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`scanner.Text`方法读取标记化数据
- en: The code uses the pre-defined function `bufio.ScanLines` to parse the buffered
    content using a line-delimiter. The `bufio` package comes with several pre-defined
    splitter functions including *ScanBytes* to scan each byte as a token, *ScanRunes*
    to scan UTF-8 encoded tokens, and *ScanWords* which scan each space-separated
    words as tokens.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用预定义的函数`bufio.ScanLines`来使用行分隔符解析缓冲内容。`bufio`包提供了几个预定义的分隔函数，包括*ScanBytes*用于将每个字节作为标记扫描，*ScanRunes*用于扫描UTF-8编码的标记，以及*ScanWords*用于将每个以空格分隔的单词作为标记扫描。
- en: In-memory IO
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存IO
- en: The `bytes` package offers common primitives to achieve streaming IO on blocks
    of bytes, stored in memory, represented by the `bytes.Buffer` type. Since the
    `bytes.Buffer` type implements both `io.Reader` and `io.Writer` interfaces it
    is a great option to stream data into or out of memory using streaming IO primitives.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes`包提供了常见的原语，用于在内存中存储的字节块上进行流式IO，由`bytes.Buffer`类型表示。由于`bytes.Buffer`类型实现了`io.Reader`和`io.Writer`接口，因此它是将数据流入或流出内存的流式IO原语的绝佳选择。'
- en: 'The following snippet stores several string values in the `byte.Buffer` variable,
    `book`. Then the buffer is streamed to `os.Stdout`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将几个字符串值存储在`byte.Buffer`变量`book`中，然后将缓冲区流式传输到`os.Stdout`：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: golang.fyi/ch10/bytesbuf0.go
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/bytesbuf0.go
- en: 'The same example can easily be updated to stream the content to a regular file
    as shown in the following abbreviate code snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的示例很容易更新，以将内容流式传输到常规文件，如下面的简短代码片段所示：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch10/bytesbuf1.go
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/bytesbuf1.go
- en: Encoding and decoding data
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码和解码数据
- en: Another common aspect of IO in Go is the encoding of data, from one representation
    to another, as it is being streamed. The encoders and decoders of the standard
    library, found in the *encoding* package ([https://golang.org/pkg/encoding/](https://golang.org/pkg/encoding/)),
    use the `io.Reader` and `io.Writer` interfaces to leverage IO primitives as a
    way of streaming data during encoding and decoding.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Go中IO的另一个常见方面是对数据进行编码，从一种表示形式转换为另一种表示形式，因为它正在被流式传输。标准库中的编码器和解码器，位于*encoding*包中（[https://golang.org/pkg/encoding/](https://golang.org/pkg/encoding/)），使用`io.Reader`和`io.Writer`接口来利用IO原语作为在编码和解码过程中流式传输数据的一种方式。
- en: Go supports several encoding formats for a variety of purposes including data
    conversion, data compaction, and data encryption. This chapter will focus on encoding
    and decoding data using the *Gob* and *JSON* format for data conversion. In [Chapter
    11](ch11.html "Chapter 11. Writing Networked Services"), *Writing Networked Programs*,
    we will explore using encoders to convert data for client and server communication
    using **remote procedure calls** (**RPC**).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持多种编码格式，用于各种目的，包括数据转换、数据压缩和数据加密。本章将重点介绍使用*Gob*和*JSON*格式进行数据转换的编码和解码。在[第11章](ch11.html
    "第11章。编写网络服务")中，*编写网络程序*，我们将探讨使用编码器将数据转换为客户端和服务器通信的**远程过程调用**（**RPC**）。
- en: Binary encoding with gob
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用gob进行二进制编码
- en: The `gob` package ([*https://golang.org/pkg/encoding/gob*](https://golang.org/pkg/encoding/gob))
    provides an encoding format that can be used to convert complex Go data types
    into binary. Gob is self-describing, meaning each encoded data item is accompanied
    by a type description. The encoding process involves streaming the gob-encoded
    data to an io.Writer so it can be written to a resource for future consumption.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`gob`包（[*https://golang.org/pkg/encoding/gob*](https://golang.org/pkg/encoding/gob)）提供了一种编码格式，可用于将复杂的Go数据类型转换为二进制数据。Gob是自描述的，这意味着每个编码的数据项都附带有类型描述。编码过程涉及将gob编码的数据流式传输到io.Writer，以便将其写入资源以供将来使用。'
- en: 'The following snippet shows an example code that encodes variable `books`,
    a slice of the `Book` type with nested values, into the `gob` format. The encoder
    writes its generated binary data to an os.Writer instance, in this case the `file`
    variable of the `*os.File` type:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一个示例代码，将变量`books`（一个包含嵌套值的`Book`类型的切片）编码为`gob`格式。编码器将其生成的二进制数据写入到一个os.Writer实例，本例中是`*os.File`类型的变量`file`：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: golang.fyi/ch10/gob0.go
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/gob0.go
- en: Although the previous example is lengthy, it is mostly made of the definition
    of the nested data structure assigned to variable `books`. The last half-dozen
    or more lines are where the encoding takes place. The gob encoder is created with
    `enc := gob.NewEncoder(file)`. Encoding the data is done by simply calling `enc.Encode(books)`
    which streams the encoded data to the provide file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的示例很长，但它主要是由分配给变量`books`的嵌套数据结构的定义组成。最后的半打行或更多行是编码发生的地方。gob编码器是通过`enc :=
    gob.NewEncoder(file)`创建的。通过简单调用`enc.Encode(books)`来对数据进行编码，这将将编码的数据流式传输到提供的文件。
- en: 'The decoding process does the reverse by streaming the gob-encoded binary data
    using an `io.Reader` and automatically reconstructing it as a strongly-typed Go
    value. The following code snippet decodes the gob data that was encoded and stored
    in the `books.data` file in the previous example. The decoder reads the data from
    an `io.Reader`, in this instance the variable `file` of the `*os.File` type:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 解码过程通过使用`io.Reader`流式传输gob编码的二进制数据，并自动将其重构为强类型的Go值来进行反向操作。以下代码片段解码了在上一个示例中编码并存储在`books.data`文件中的gob数据。解码器从`io.Reader`读取数据，在本例中是`*os.File`类型的变量`file`：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: golang.fyi/ch10/gob1.go
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/gob1.go
- en: Decoding a previously encoded gob data is done by creating a decoder using `dec
    := gob.NewDecoder(file)`. The next step is to declare the variable that will store
    the decoded data. In our example, the `books` variable, of the `[]Book` type,
    is declared as the destination of the decoded data. The actual decoding is done
    by invoking `dec.Decode(&books)`. Notice the `Decode()` method takes the address
    of its target variable as an argument. Once decoded, the `books` variable will
    contain the reconstituted data structure streamed from the file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 解码以前编码的gob数据是通过使用`dec := gob.NewDecoder(file)`创建解码器来完成的。下一步是声明将存储解码数据的变量。在我们的示例中，`books`变量，类型为`[]Book`，被声明为解码数据的目标。实际解码是通过调用`dec.Decode(&books)`来完成的。请注意，`Decode()`方法将其目标变量的地址作为参数。一旦解码完成，`books`变量将包含从文件流式传输的重构数据结构。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As of this writing, gob encoder and decoder APIs are only available in the Go
    programming language. This means that data encoded as gob can only be consumed
    by Go programs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，gob编码器和解码器API仅在Go编程语言中可用。这意味着以gob编码的数据只能被Go程序使用。
- en: Encoding data as JSON
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据编码为JSON
- en: 'The encoding package also comes with a *json* encoder sub-package ([https://golang.org/pkg/encoding/json/](https://golang.org/pkg/encoding/json/))
    to support JSON-formatted data. This greatly broadens the number of languages
    with which Go programs can exchange complex data structures. JSON encoding works
    similarly as the encoder and decoder from the gob package. The difference is that
    the generated data takes the form of a clear text JSON-encoded format instead
    of a binary. The following code updates the previous example to encode the data
    as JSON:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 编码包还带有一个*json*编码器子包（[https://golang.org/pkg/encoding/json/](https://golang.org/pkg/encoding/json/)），用于支持JSON格式的数据。这极大地扩展了Go程序可以交换复杂数据结构的语言数量。JSON编码与gob包的编码器和解码器类似。不同之处在于生成的数据采用明文JSON编码格式，而不是二进制。以下代码更新了前一个示例，将数据编码为JSON：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: golang.fyi/ch10/json0.go
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/json0.go
- en: 'The code is exactly the same as before. It uses the same slice of nested structs
    assigned to the `books` variable. The only difference is the encoder is created
    with `enc := json.NewEncoder(file)` which creates a JSON encoder that will use
    the `file` variable as its `io.Writer` destination. When `enc.Encode(books)` is
    executed, the content of the variable `books` is serialized as JSON to the local
    file `books.dat`, shown in the following code (formatted for readability):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与之前完全相同。它使用分配给`books`变量的相同嵌套结构的切片。唯一的区别是创建了一个编码器`enc := json.NewEncoder(file)`，它创建一个JSON编码器，将`file`变量作为其`io.Writer`目标。当执行`enc.Encode(books)`时，变量`books`的内容将被序列化为JSON，显示在以下代码中（格式化以便阅读）：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: File books.dat (formatted)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 文件books.dat（格式化）
- en: The generated JSON-encoded content uses the name of the struct fields as the
    name for the JSON object keys by default. This behavior can be controlled using
    struct tags (see the section, *Controlling JSON mapping with struct tags*).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，生成的JSON编码内容使用结构字段的名称作为JSON对象键的名称。这种行为可以使用结构标签来控制（参见*使用结构标签控制JSON映射*部分）。
- en: 'Consuming the JSON-encoded data in Go is done using a JSON decoder that streams
    its source from an `io.Reader`. The following snippet decodes the JSON-encoded
    data, generated in the previous example, stored in the file `book.dat`. Note that
    the data structure (not shown in the following code) is the same as before:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中使用JSON解码器从`io.Reader`流式传输其源来消耗JSON编码的数据。以下代码片段解码了在前一个示例中生成的JSON编码数据，存储在文件`book.dat`中。请注意，数据结构（未在以下代码中显示）与之前相同：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: golang.fyi/ch10/json1.go
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/json1.go
- en: The data in the books.dat file is stored as an array of JSON objects. Therefore,
    the code must declare a variable capable of storing an indexed collection of nested
    struct values. In the previous example, the `books` variable, of the type `[]Book` is
    declared as the destination of the decoded data. The actual decoding is done by
    invoking `dec.Decode(&books)`. Notice the `Decode()` method takes the address
    of its target variable as an argument. Once decoded, the `books` variable will
    contain the reconstituted data structure streamed from the file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: books.dat文件中的数据存储为JSON对象的数组。因此，代码必须声明一个能够存储嵌套结构值的索引集合的变量。在前一个示例中，类型为`[]Book`的`books`变量被声明为解码数据的目标。实际解码是通过调用`dec.Decode(&books)`来完成的。请注意，`Decode()`方法将其目标变量的地址作为参数。一旦解码完成，`books`变量将包含从文件流式传输的重构数据结构。
- en: Controlling JSON mapping with struct tags
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用结构标签控制JSON映射
- en: 'By default, the name of a struct field is used as the key for the generated
    JSON object. This can be controlled using `struct` type tags to specify how JSON
    object key names are mapped during encoding and decoding of the data. For instance,
    the following code snippet declares struct fields with the `json:` tag prefix
    to specify how object keys are to be encoded and decoded:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，结构字段的名称用作生成的JSON对象的键。这可以使用`struct`类型标签来控制，以指定在编码和解码数据时如何映射JSON对象键名称。例如，以下代码片段声明了带有`json:`标签前缀的结构字段，以指定如何对对象键进行编码和解码：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: golang.fyi/ch10/json2.go
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/json2.go
- en: 'The tags and their meaning are summarized in the following table:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 标签及其含义总结如下表：
- en: '| **Tags** | **Description** |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: 标签 | 描述
- en: '| `Title string `json:"book_title"`` | Maps the `Title` struct field to the
    JSON object key, `"book_title"`. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '`Title string `json:"book_title"`` | 将`Title`结构字段映射到JSON对象键`"book_title"`。'
- en: '| `PageCount int `json:"pages,string"`` | Maps the `PageCount` struct field
    to the JSON object key, `"pages",` and outputs the value as a string instead of
    a number. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '`PageCount int `json:"pages,string"`` | 将`PageCount`结构字段映射到JSON对象键`"pages"`，并将值输出为字符串而不是数字。'
- en: '| `ISBN string `json:"-"`` | The dash causes the `ISBN` field to be skipped
    during encoding and decoding. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '`ISBN string `json:"-"`` | 破折号导致在编码和解码过程中跳过`ISBN`字段。'
- en: '| `Authors []Name `json:"auths,omniempty"`` | Maps the `Authors` field to the
    JSON object key, `"auths"`. The annotation, `omniempty,` causes the field to be
    omitted if its value is nil. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '`Authors []Name `json:"auths,omniempty"`` | 将`Authors`字段映射到JSON对象键`"auths"`。注释`omniempty`导致如果其值为nil，则省略该字段。'
- en: '| `Publisher string `json:",omniempty"`` | Maps the struct field name, `Publisher,`
    as the JSON object key name. The annotation, `omniempty,` causes the field to
    be omitted when empty. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '`Publisher string `json:",omniempty"`` | 将结构字段名`Publisher`映射为JSON对象键名。注释`omniempty`导致字段在为空时被省略。'
- en: '| `PublishDate time.Time `json:"pub_date"`` | Maps the field name, `PublishDate,`
    to the JSON object key, `"pub_date"`. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '`PublishDate time.Time `json:"pub_date"`` | 将字段名`PublishDate`映射到JSON对象键`"pub_date"`。'
- en: 'When the previous struct is encoded, it produces the following JSON output
    in the `books.dat` file (formatted for readability):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当编码前一个结构时，在`books.dat`文件中生成以下JSON输出（格式化以便阅读）：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice the JSON object keys are titled as specified in the `struct` tags. The
    object key `"pages"` (mapped to the struct field, `PageCount`) is encoded as a
    string. Finally, the struct field, `ISBN,` is omitted, as annotated in the `struct`
    tag.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JSON对象键的标题与“struct”标签中指定的相同。对象键“pages”（映射到结构字段“PageCount”）被编码为字符串。最后，结构字段“ISBN”被省略，如在“struct”标签中注释的那样。
- en: Custom encoding and decoding
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义编码和解码
- en: 'The JSON package uses two interfaces, *Marshaler* and *Unmarshaler*, to hook
    into encoding and decoding events respectively. When the encoder encounters a
    value whose type implements `json.Marshaler`, it delegates serialization of the
    value to the method `MarshalJSON` defined in the Marshaller interface. This is
    exemplified in the following abbreviated code snippet where the type `Name` is
    updated to implement `json.Marshaller` as shown:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: JSON包使用两个接口，“Marshaler”和“Unmarshaler”，分别用于编码和解码事件。当编码器遇到一个类型实现了“json.Marshaler”的值时，它将值的序列化委托给“MarshalJSON”方法，在Marshaller接口中定义。以下是一个缩写的代码片段，其中类型“Name”更新为实现“json.Marshaller”的示例：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: golang.fyi/ch10/json3.go
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/json3.go
- en: 'In the previous example, values of the `Name` type are serialized as a JSON
    string (instead of an object as earlier). The serialization is handled by the
    method `Name.MarshallJSON` which returns an array of bytes that contains the last
    and first name separated by a comma. The preceding code generates the following
    JSON output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，“Name”类型的值被序列化为JSON字符串（而不是之前的对象）。序列化由方法“Name.MarshallJSON”处理，该方法返回一个包含姓和名用逗号分隔的字节数组。前面的代码生成以下JSON输出：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For the inverse, when a decoder encounters a piece of JSON text that maps to
    a type that implements `json.Unmarshaler`, it delegates the decoding to the type''s
    `UnmarshalJSON` method. For instance, the following shows the abbreviated code
    snippet that implements `json.Unmarshaler` to handle the JSON output for the `Name` type:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于反向操作，当解码器遇到映射到实现“json.Unmarshaler”的类型的JSON文本时，它将解码委托给类型的“UnmarshalJSON”方法。例如，以下是实现“json.Unmarshaler”以处理“Name”类型的JSON输出的缩写代码片段：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: golang.fyi/ch10/json4.go
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch10/json4.go
- en: The `Name` type is an implementation of `json.Unmarshaler`. When the decoder
    encounters a JSON object with the key `"Authors"`, it uses the method `Name.Unmarshaler`
    to reconstitute the Go struct `Name` type from the JSON string.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: “Name”类型是“json.Unmarshaler”的实现。当解码器遇到具有键“Authors”的JSON对象时，它使用方法“Name.Unmarshaler”从JSON字符串重新构建Go结构“Name”类型。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Go standard libraries offer additional encoders (not covered here) including
    `base32`, `bas364`, `binary`, `csv`, `hex`, `xml`, `gzip`, and numerous encryption
    format encoders.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库提供了其他编码器（此处未涵盖），包括“base32”、“bas364”、“binary”、“csv”、“hex”、“xml”、“gzip”和众多加密格式编码器。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provides a high-level view of Go's data input and output idioms
    and the packages involved in implementing IO primitives. The chapter starts by
    covering the fundamentals of a stream-based IO in Go with the `io.Reader` and
    `io.Writer` interfaces. Readers are walked through the implementation strategies
    and examples for both an `io.Reader` and an `io.Writer`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了Go数据输入和输出习惯用法的高层视图，以及实现IO原语的包。本章首先介绍了Go中基于流的IO的基础知识，包括“io.Reader”和“io.Writer”接口。读者将了解“io.Reader”和“io.Writer”的实现策略和示例。
- en: The chapter goes on to cover packages, types, and functions that that support
    the streaming IO mechanism including working with files, formatted IO, buffered,
    and in-memory IO. The last portion of the chapter covers encoders and decoders
    that convert data as it is being streamed. In the next chapter, the IO theme is
    carried further when the discussion turns to creating programs that use IO to
    communicate via networking.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续介绍支持流式IO机制的包、类型和函数，包括处理文件、格式化IO、缓冲和内存IO。本章的最后部分涵盖了在数据流传输过程中转换数据的编码器和解码器。在下一章中，当讨论转向使用IO通过网络进行通信的程序时，IO主题将进一步展开。
