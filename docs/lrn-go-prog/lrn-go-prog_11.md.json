["```go\nfunc Dial(network, address string) (Conn, error) \n\n```", "```go\nfunc main() { \n   host, port := \"www.gutenberg.org\", \"80\" \n   addr := net.JoinHostPort(host, port) \n   httpRequest:=\"GET  /cache/epub/16328/pg16328.txt HTTP/1.1\\n\" + \n         \"Host: \" + host + \"\\n\\n\" \n\n   conn, err := net.Dial(\"tcp\", addr) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer conn.Close() \n\n   if _, err = conn.Write([]byte(httpRequest)); err != nil { \n         fmt.Println(err) \n         return \n   } \n\n   file, err := os.Create(\"beowulf.txt\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer file.Close() \n\n   io.Copy(file, conn) \n   fmt.Println(\"Text copied to file\", file.Name()) \n}\n\n```", "```go\nfunc Listen(network, laddr string) (net.Listener, error) \n\n```", "```go\nfunc main() { \n   listener, err := net.Listen(\"tcp\", \":4040\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer listener.Close() \n\n   for { \n         conn, err := listener.Accept() \n         if err != nil { \n               fmt.Println(err) \n               return \n         } \n         conn.Write([]byte(\"Nice to meet you!\")) \n         conn.Close() \n   } \n} \n\n```", "```go\n$> go run listen0.go & \n[1] 83884 \n\n$> telnet 127.0.0.1 4040 \nTrying 127.0.0.1... \nConnected to localhost. \nEscape character is '^]'. \nNice to meet you! Connection closed by foreign host.\n\n```", "```go\nimport ( \n   \"net\" \n   ... \n   curr \"https://github.com/vladimirvivien/learning-go/ch11/curr0\" \n) \n\nvar currencies = curr.Load(\"./data.csv\") \n\nfunc main() { \n   ln, _ := net.Listen(\"tcp\", \":4040\") \n   defer ln.Close() \n\n   // connection loop \n   for { \n         conn, err := ln.Accept() \n         if err != nil { \n               fmt.Println(err) \n               conn.Close() \n               continue \n         }      \n         go handleConnection(conn) \n   } \n} \n\n// handle client connection \nfunc handleConnection(conn net.Conn) { \n   defer conn.Close() \n\n   // loop to stay connected with client \n   for { \n         cmdLine := make([]byte, (1024 * 4)) \n         n, err := conn.Read(cmdLine) \n         if n == 0 || err != nil { \n               return \n         } \n         cmd, param := parseCommand(string(cmdLine[0:n])) \n         if cmd == \"\" { \n               continue \n         } \n\n         // execute command \n         switch strings.ToUpper(cmd) { \n         case \"GET\": \n               result := curr.Find(currencies, param) \n               // stream result to client \n               for _, cur := range result { \n                     _, err := fmt.Fprintf( \n                           conn, \n                           \"%s %s %s %s\\n\", \n                           cur.Name, cur.Code, \n                           cur.Number, cur.Country, \n                     ) \n                     if err != nil { \n                           return \n                     } \n                     // reset deadline while writing, \n                     // closes conn if client is gone \n                     conn.SetWriteDeadline( \n                           time.Now().Add(time.Second * 5)) \n               } \n               // reset read deadline for next read \n               conn.SetReadDeadline( \n                     time.Now().Add(time.Second * 300)) \n\n         default: \n               conn.Write([]byte(\"Invalid command\\n\")) \n         } \n   } \n} \n\nfunc parseCommand(cmdLine string) (cmd, param string) { \n   parts := strings.Split(cmdLine, \" \") \n   if len(parts) != 2 { \n         return \"\", \"\" \n   } \n   cmd = strings.TrimSpace(parts[0]) \n   param = strings.TrimSpace(parts[1]) \n   return \n} \n\n```", "```go\n$> telnet localhost 4040\nTrying ::1...\nConnected to localhost.\nEscape character is '^]'.\nGET Gourde\nGourde HTG 332 HAITI\nGET USD\nUS Dollar USD 840 AMERICAN SAMOA\nUS Dollar USD 840 BONAIRE, SINT EUSTATIUS AND SABA\nUS Dollar USD 840 GUAM\nUS Dollar USD 840 HAITI\nUS Dollar USD 840 MARSHALL ISLANDS (THE)\nUS Dollar USD 840 UNITED STATES OF AMERICA (THE)\n...\nget india\nIndian Rupee INR 356 BHUTAN\nUS Dollar USD 840 BRITISH INDIAN OCEAN TERRITORY (THE)\nIndian Rupee INR 356 INDIA\n\n```", "```go\nvar host, port = \"127.0.0.1\", \"4040\" \nvar addr = net.JoinHostPort(host, port) \nconst prompt = \"curr\" \nconst buffLen = 1024 \n\nfunc main() { \n   conn, err := net.Dial(\"tcp\", addr) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer conn.Close() \n   var cmd, param string \n   // repl - interactive shell for client \n   for { \n         fmt.Print(prompt, \"> \") \n         _, err = fmt.Scanf(\"%s %s\", &cmd, &param) \n         if err != nil { \n               fmt.Println(\"Usage: GET <search string or *>\") \n               continue \n         } \n         // send command line \n         cmdLine := fmt.Sprintf(\"%s %s\", cmd, param) \n         if n, err := conn.Write([]byte(cmdLine)); \n         n == 0 || err != nil { \n               fmt.Println(err) \n               return \n         } \n\n         // stream and display response \n         conn.SetReadDeadline( \n               time.Now().Add(time.Second * 5)) \n         for { \n               buff := make([]byte, buffLen) \n               n, err := conn.Read(buff) \n               if err != nil { break } \n               fmt.Print(string(buff[0:n])) \n               conn.SetReadDeadline( \n                     time.Now().Add(time.Millisecond * 700)) \n         } \n   } \n} \n\n```", "```go\n$> Connected to Global Currency Service\ncurr> get pound\nEgyptian Pound EGP 818 EGYPT\nGibraltar Pound GIP 292 GIBRALTAR\nSudanese Pound SDG 938 SUDAN (THE)\n...\nSyrian Pound SYP 760 SYRIAN ARAB REPUBLIC\nPound Sterling GBP 826 UNITED KINGDOM OF GREAT BRITAIN (THE)\ncurr>\n\n```", "```go\n         conbuf := bufio.NewReaderSize(conn, 1024) \n         for { \n               str, err := conbuf.ReadString('\\n') \n               if err != nil { \n                     break \n               } \n               fmt.Print(str) \n               conn.SetReadDeadline( \n                     time.Now().Add(time.Millisecond * 700)) \n         } \n\n```", "```go\nfunc main() { \n   client := http.Client{} \n   resp, err := client.Get( \n         \" http://gutenberg.org/cache/epub/16328/pg16328.txt\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer resp.Body.Close() \n   io.Copy(os.Stdout, resp.Body) \n} \n\n```", "```go\nGet(url string,   \n) (resp *http.Response, err   error)     \n\n```", "```go\nPost(   \n  url string,    \n  bodyType string,    \n  body io.Reader,   \n) (resp *http.Response, err error)   \n\n```", "```go\nPostForm(   \n  url string,    \n  data url.Values,   \n) (resp *http.Response, err error)   \n\n```", "```go\nHead(url string,   \n)(resp *http.Response, err error)   \n\n```", "```go\nfunc main() { \n   resp, err := http.Get( \n       \"http://gutenberg.org/cache/epub/16328/pg16328.txt\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer resp.Body.Close() \n   io.Copy(os.Stdout, resp.Body) \n} \n\n```", "```go\nfunc main() { \n   client := &http.Client{ \n         Timeout: 21 * time.Second \n   } \n   resp, err := client.Get( \n         \"http://tools.ietf.org/rfc/rfc7540.txt\") \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer resp.Body.Close() \n   io.Copy(os.Stdout, resp.Body) \n} \n\n```", "```go\nfunc main() { \n   client := &http.Client{ \n         Transport: &http.Transport{ \n               DisableKeepAlives: true, \n               Dial: (&net.Dialer{ \n                  Timeout:   30 * time.Second, \n               }).Dial, \n         }, \n   } \n... \n} \n\n```", "```go\nfunc main() { \n   client := &http.Client{} \n   req, err := http.NewRequest( \n         \"GET\", \"http://tools.ietf.org/rfc/rfc7540.txt\", nil, \n   ) \n   req.Header.Add(\"Accept\", \"text/plain\") \n   req.Header.Add(\"User-Agent\", \"SampleClient/1.0\") \n\n   resp, err := client.Do(req) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer resp.Body.Close() \n   io.Copy(os.Stdout, resp.Body) \n} \n\n```", "```go\nfunc NewRequest(method, uStr string, body io.Reader) (*http.Request, error) \n\n```", "```go\nDo(req *http.Request) (*http.Response, error) \n\n```", "```go\ntype Handler interface { \n        ServeHTTP(ResponseWriter, *Request) \n} \n\n```", "```go\ntype msg string \n\nfunc (m msg) ServeHTTP( \n   resp http.ResponseWriter, req *http.Request) { \n   resp.Header().Add(\"Content-Type\", \"text/html\") \n   resp.WriteHeader(http.StatusOK) \n   fmt.Fprint(resp, m) \n} \n\nfunc main() { \n   msgHandler := msg(\"Hello from high above!\") \n   server := http.Server{Addr: \":4040\", Handler: msgHandler} \n   server.ListenAndServe() \n} \n\n```", "```go\ntype msg string \nfunc (m msg) ServeHTTP( \n   resp http.ResponseWriter, req *http.Request) { \n   resp.Header().Add(\"Content-Type\", \"text/html\") \n   resp.WriteHeader(http.StatusOK) \n   fmt.Fprint(resp, m) \n} \nfunc main() { \n   msgHandler := msg(\"Hello from high above!\") \n   server := http.Server{ \n         Addr:         \":4040\", \n         Handler:      msgHandler, \n         ReadTimeout:  time.Second * 5, \n         WriteTimeout: time.Second * 3, \n   } \n   server.ListenAndServe() \n} \n\n```", "```go\ntype msg string \n\nfunc (m msg) ServeHTTP( \n    resp http.ResponseWriter, req *http.Request) { \n   resp.Header().Add(\"Content-Type\", \"text/html\") \n   resp.WriteHeader(http.StatusOK) \n   fmt.Fprint(resp, m) \n} \n\n   func main() { \n   msgHandler := msg(\"Hello from high above!\") \n   http.ListenAndServe(\":4040\", msgHandler) \n} \n\n```", "```go\nfunc main() { \n   mux := http.NewServeMux() \n   hello := func(resp http.ResponseWriter, req *http.Request) { \n         resp.Header().Add(\"Content-Type\", \"text/html\") \n         resp.WriteHeader(http.StatusOK) \n         fmt.Fprint(resp, \"Hello from Above!\") \n   } \n\n   goodbye := func(resp http.ResponseWriter, req *http.Request) { \n         resp.Header().Add(\"Content-Type\", \"text/html\") \n         resp.WriteHeader(http.StatusOK) \n         fmt.Fprint(resp, \"Goodbye, it's been real!\") \n   } \n\n   mux.HandleFunc(\"/hello\", hello) \n   mux.HandleFunc(\"/goodbye\", goodbye) \n\n   http.ListenAndServe(\":4040\", mux) \n} \n\n```", "```go\nfunc main() { \n   hello := func(resp http.ResponseWriter, req *http.Request) { \n   ... \n   } \n\n   goodbye := func(resp http.ResponseWriter, req *http.Request) { \n   ... \n   } \n\n   http.HandleFunc(\"/hello\", hello) \n   http.HandleFunc(\"/goodbye\", goodbye) \n\n   http.ListenAndServe(\":4040\", nil) \n}\n\n```", "```go\ntype Currency struct { \n   Code    string `json:\"currency_code\"` \n   Name    string `json:\"currency_name\"` \n   Number  string `json:\"currency_number\"` \n   Country string `json:\"currency_country\"` \n} \n\ntype CurrencyRequest struct { \n   Get   string `json:\"get\"` \n   Limit int    `json:limit` \n} \n\n```", "```go\nimport ( \n   \"encoding/json\" \n   \"fmt\" \n   \"net/http\" \n\n   \" github.com/vladimirvivien/learning-go/ch11/curr1\" \n) \nvar currencies = curr1.Load(\"./data.csv\") \n\nfunc currs(resp http.ResponseWriter, req *http.Request) { \n   var currRequest curr1.CurrencyRequest \n   dec := json.NewDecoder(req.Body) \n   if err := dec.Decode(&currRequest); err != nil { \n         resp.WriteHeader(http.StatusBadRequest) \n         fmt.Println(err) \n         return \n   } \n\n   result := curr1.Find(currencies, currRequest.Get) \n   enc := json.NewEncoder(resp) \n   if err := enc.Encode(&result); err != nil { \n         fmt.Println(err) \n         resp.WriteHeader(http.StatusInternalServerError) \n         return \n   } \n} \n\nfunc main() { \n   mux := http.NewServeMux() \n   mux.HandleFunc(\"/currency\", get) \n\n   if err := http.ListenAndServe(\":4040\", mux); err != nil { \n         fmt.Println(err) \n   } \n} \n\n```", "```go\nvar currRequest curr1.CurrencyRequest \ndec := json.NewDecoder(req.Body) \nif err := dec.Decode(&currRequest); err != nil { ... } \n\n```", "```go\nresult := curr1.Find(currencies, currRequest.Get) \nenc := json.NewEncoder(resp) \nif err := enc.Encode(&result); err != nil { ... } \n\n```", "```go\n$> curl -X POST -d '{\"get\":\"Euro\"}' http://localhost:4040/currency \n[ \n... \n  { \n    \"currency_code\": \"EUR\", \n    \"currency_name\": \"Euro\", \n    \"currency_number\": \"978\", \n    \"currency_country\": \"BELGIUM\" \n  }, \n  { \n    \"currency_code\": \"EUR\", \n    \"currency_name\": \"Euro\", \n    \"currency_number\": \"978\", \n    \"currency_country\": \"FINLAND\" \n  }, \n  { \n    \"currency_code\": \"EUR\", \n    \"currency_name\": \"Euro\", \n    \"currency_number\": \"978\", \n    \"currency_country\": \"FRANCE\" \n  }, \n... \n] \n\n```", "```go\nimport ( \n   \"bytes\" \n   \"encoding/json\" \n   \"fmt\" \n   \"net/http\" \n\n   \" github.com/vladimirvivien/learning-go/ch11/curr1\" \n) \n\nfunc main() { \n   var param string \n   fmt.Print(\"Currency> \") \n   _, err := fmt.Scanf(\"%s\", &param) \n\n   buf := new(bytes.Buffer) \n   currRequest := &curr1.CurrencyRequest{Get: param} \n   err = json.NewEncoder(buf).Encode(currRequest) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n\n   // send request \n   client := &http.Client{} \n   req, err := http.NewRequest( \n         \"POST\", \"http://127.0.0.1:4040/currency\", buf) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n\n   resp, err := client.Do(req) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   defer resp.Body.Close() \n\n   // decode response \n   var currencies []curr1.Currency \n   err = json.NewDecoder(resp.Body).Decode(&currencies) \n   if err != nil { \n         fmt.Println(err) \n         return \n   } \n   fmt.Println(currencies) \n} \n\n```", "```go\n// serves HTML gui \nfunc gui(resp http.ResponseWriter, req *http.Request) { \n   file, err := os.Open(\"./currency.html\") \n   if err != nil { \n         resp.WriteHeader(http.StatusInternalServerError) \n         fmt.Println(err) \n         return \n   } \n   io.Copy(resp, file) \n} \n\nfunc main() { \n   mux := http.NewServeMux() \n   mux.HandleFunc(\"/\", gui) \n   mux.HandleFunc(\"/currency\", currs) \n\n   if err := http.ListenAndServe(\":4040\", mux); err != nil { \n         fmt.Println(err) \n   } \n} \n\n```", "```go\n<body> \n<div class=\"container\"> \n  <h2>Global Currency Service</h2> \n  <p>Enter currency search string: <input id=\"in\"> \n     <button type=\"button\" class=\"btn btn-primary\" onclick=\"doRequest()\">Search</button> \n  </p>             \n  <table id=\"tbl\" class=\"table table-striped\"> \n    <thead> \n      <tr> \n           <th>Code</th> \n           <th>Name</th> \n           <th>Number</th> \n           <th>Country</th> \n      </tr> \n    </thead> \n    <tbody/> \n  </table> \n</div> \n\n<script> \n var tbl = document.getElementById(\"tbl\"); \n   function addRow(code, name, number, country) { \n         var rowCount = tbl.rows.length; \n         var row = tbl.insertRow(rowCount); \n         row.insertCell(0).innerHTML = code; \n         row.insertCell(1).innerHTML = name; \n         row.insertCell(2).innerHTML = number; \n         row.insertCell(3).innerHTML = country; \n   } \n\n    function doRequest() { \n   param = document.getElementById(\"in\").value \n        $.ajax('/currency', { \n            method: 'PUT', \n               contentType: 'application/json', \n               processData: false, \n               data: JSON.stringify({get:param}) \n         }).then( \n         function success(currencies) { \n               currs = JSON.parse(currencies) \n               for (i=0; i < currs.length; i++) { \n                     addRow( \n                           currs[i].currency_code, \n                           currs[i].currency_name, \n                           currs[i].currency_number, \n                           currs[i].currency_country \n                     ); \n               } \n\n         }); \n   } \n</script> \n\n```"]