- en: Chapter 11. Writing Networked Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。编写网络服务
- en: 'One of the many reasons for Go''s popularity, as a system language, is its
    inherent support for creating networked programs. The standard library exposes
    APIs ranging from low-level socket primitives to higher-level service abstractions
    such as HTTP and RPC. This chapter explores fundamental topics about creating
    connected applications including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统语言，Go流行的原因之一是它固有的支持创建网络程序。标准库提供了从低级套接字原语到更高级服务抽象（如HTTP和RPC）的API。本章探讨了创建连接应用程序的基本主题，包括以下内容：
- en: The net package
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络包
- en: A TCP API server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP API服务器
- en: The HTTP package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP包
- en: A JSON API server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON API服务器
- en: The net package
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络包
- en: The starting point for all networked programs in Go is the *net* package ([https://golang.org/pkg/net](https://golang.org/pkg/net)).
    It provides a rich API to handle low-level networking primitives as well as application-level
    protocols such as HTTP. Each logical component of a network is represented by
    a Go type including hardware interfaces, networks, packets, addresses, protocols,
    and connections. Furthermore, each type exposes a multitude of methods giving
    Go one of the most complete standard libraries for network programming supporting
    both IPv4 and IPv6.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Go中所有网络程序的起点是*net*包（[https://golang.org/pkg/net](https://golang.org/pkg/net)）。它提供了丰富的API来处理低级网络原语以及应用级协议，如HTTP。网络的每个逻辑组件都由Go类型表示，包括硬件接口、网络、数据包、地址、协议和连接。此外，每种类型都公开了大量方法，使得Go成为支持IPv4和IPv6的最完整的网络编程标准库之一。
- en: Whether creating a client or a server program, Go programmers will need, at
    a minimum, the network primitives covered in the following sections. These primitives
    are offered as functions and types to facilitate clients connecting to remote
    services and servers to handle incoming requests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是创建客户端还是服务器程序，Go程序员至少需要以下部分涵盖的网络原语。这些原语作为函数和类型提供，以便客户端连接到远程服务和服务器处理传入请求。
- en: Addressing
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻址
- en: One of the basic primitives, when doing network programming, is the *address*.
    The types and functions of the `net` package use a string literal to represent
    an address such as `"127.0.0.1"`. The address can also include a service port
    separated by a colon such as `"74.125.21.113:80"`. Functions and methods in the
    `net` package also support string literal representation for IPv6 addresses such
    as `"::1"` or `"[2607:f8b0:4002:c06::65]:80"` for an address with a service port
    of 80.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行网络编程时，基本原语之一是*地址*。`net`包的类型和函数使用字符串文字表示地址，例如`"127.0.0.1"`。地址还可以包括由冒号分隔的服务端口，例如`"74.125.21.113:80"`。`net`包中的函数和方法还支持IPv6地址的字符串文字表示，例如`"::1"`或`"[2607:f8b0:4002:c06::65]:80"`，用于带有服务端口80的地址。
- en: The net.Conn Type
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: net.Conn类型
- en: The `net.Conn` interface represents a generic connection established between
    two nodes on the network. It implements `io.Reader` and `io.Writer` interfaces
    which allow connected nodes to exchange data using streaming IO primitives. The
    `net` package offers network protocol-specific implementations of the `net.Conn`
    interface such as *IPConn*, *UDPConn*, and *TCPConn*. Each implementation exposes
    additional methods specific to its respective network and protocol. However, as
    we will see in this chapter, the default method set defined in net.Conn is adequate
    for most uses.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Conn`接口表示在网络上建立的两个节点之间的通用连接。它实现了`io.Reader`和`io.Writer`接口，允许连接的节点使用流式IO原语交换数据。`net`包提供了`net.Conn`接口的网络协议特定实现，如*IPConn*、*UDPConn*和*TCPConn*。每个实现都公开了特定于其各自网络和协议的附加方法。然而，正如我们将在本章中看到的，net.Conn中定义的默认方法集对于大多数用途都是足够的。'
- en: Dialing a connection
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拨号连接
- en: 'Client programs use the `net.Dial` function, which has the following signature, to
    connect to a host service over the network:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端程序使用`net.Dial`函数连接到网络上的主机服务，该函数具有以下签名：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The function takes two parameters where the first parameter, *network*, specifies
    the network protocol for the connection which can be:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受两个参数，其中第一个参数*network*指定连接的网络协议，可以是：
- en: '`tcp`, `tcp4`, `tcp6` : `tcp` defaults to `tcp4`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tcp`，`tcp4`，`tcp6`：`tcp`默认为`tcp4`'
- en: '`udp`, `udp4`, `udp6`: `udp` defaults to `udp4`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`udp`，`udp4`，`udp6`：`udp`默认为`udp4`'
- en: '`ip`, `ip4`, `ip6`: `ip` defaults to `ip4`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip`，`ip4`，`ip6`：`ip`默认为`ip4`'
- en: '`unix`, `unixgram`, `unixpacket`: for Unix domain sockets'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix`，`unixgram`，`unixpacket`：用于Unix域套接字'
- en: The latter parameter of the `net.Dial` function specifies a string value for
    the host address to which to connect. The address can be provided as IPv4 or IPv6
    addresses as discussed earlier. The `net.Dial` function returns an implementation
    of the `net.Conn` interface that matches the specified network parameter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Dial`函数的后一个参数指定要连接的主机地址的字符串值。如前所述，地址可以提供为IPv4或IPv6地址。`net.Dial`函数返回与指定网络参数匹配的`net.Conn`接口的实现。'
- en: 'For instance, the following code snippet dials a `"tcp"` network at the host
    address, [www.gutenberg.org:80](http://gutenberg.org/), which returns a TCP connection
    of the `*net.TCPConn` type. The abbreviated code uses the TCP connection to issue
    an `"HTTP GET"` request to retrieve the full text of the literary classic Beowulf
    from the Project Gutenberg''s website ([http://gutenberg.org/](http://gutenberg.org/)).
    The raw and unparsed HTTP response is subsequently written to a local file, `beowulf.txt`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段拨号到主机地址的“tcp”网络，[www.gutenberg.org:80](http://gutenberg.org/)，返回`*net.TCPConn`类型的TCP连接。简写代码使用TCP连接发出“HTTP
    GET”请求，以从Project Gutenberg的网站（[http://gutenberg.org/](http://gutenberg.org/)）检索文学经典《贝奥武夫》的完整文本。然后将原始和未解析的HTTP响应写入本地文件`beowulf.txt`：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch11/dial0.go
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/dial0.go
- en: Because the `net.Conn` type implements the `io.Reader` and `io.Writer`, it can
    be used to both send data and receive data using streaming IO semantics. In the
    preceding example, `conn.Write([]byte(httpRequest))` sends the HTTP request to
    the server. The response returned by the host is copied from the `conn` variable
    to the `file` variable using `io.Copy(file, conn)`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`net.Conn`类型实现了`io.Reader`和`io.Writer`，它可以用于使用流式IO语义发送数据和接收数据。在前面的例子中，`conn.Write([]byte(httpRequest))`将HTTP请求发送到服务器。主机返回的响应从`conn`变量复制到`file`变量，使用`io.Copy(file,
    conn)`。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the previous is an illustration that shows how to connect to an HTTP
    server using raw TCP. The Go standard library provides a separate package designed
    specifically for HTTP programming which abstracts away the low-level protocol
    details (covered later in the chapter).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的例子说明了如何使用原始TCP连接到HTTP服务器。Go标准库提供了一个专门设计用于HTTP编程的单独包，它抽象了低级协议细节（在本章后面介绍）。
- en: The `net` package also makes available network specific dialing functions such
    as `DialUDP`, `DiapTCP`, or `DialIP`, each returning its respective connection
    implementation. In most cases, the `net.Dial` function and the `net.Conn` interface
    provide adequate capabilities to connect and manage connections to a remote host.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`net`包还提供了网络特定的拨号函数，如`DialUDP`，`DiapTCP`或`DialIP`，每个函数返回其相应的连接实现。在大多数情况下，`net.Dial`函数和`net.Conn`接口提供了连接和管理远程主机连接的足够能力。'
- en: Listening for incoming connections
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听传入的连接
- en: 'When creating a service program, one the first steps is to announce the port
    which the service will use to listen for incoming requests from the network. This
    is done by invoking the `net.Listen` function which has the following signature:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务程序时，首先要做的一步是宣布服务将用于监听来自网络的传入请求的端口。这是通过调用`net.Listen`函数来完成的，该函数具有以下签名：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It takes two parameters where the first parameter specifies a protocol with
    valid values of `"tcp"`, `"tcp4"`, `"tcp6"`, `"unix"`, or `"unixpacket"`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要两个参数，第一个参数指定了一个协议，有效的值为`"tcp"`, `"tcp4"`, `"tcp6"`, `"unix"`, 或 `"unixpacket"`。
- en: The second parameter is the local host address for the service. The local address
    can be specified without an IP address such as `":4040"`. Omitting the IP address
    of the host means that the service is bound to all network card interfaces installed
    on the host. As an alternative, the service can be bound to a specific network
    hardware interface on the host by specifying its IP address on the network, that
    is, `"10.20.130.240:4040"`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是服务的本地主机地址。本地地址可以不带IP地址指定，如`":4040"`。省略主机的IP地址意味着服务绑定到主机上安装的所有网络卡接口。作为替代，服务可以绑定到主机上特定的网络硬件接口，通过在网络上指定其IP地址，即`"10.20.130.240:4040"`。
- en: A successful call to the `net.Listen` function returns a value of the `net.Listener`
    type (or a non-nil error if it fails). The `net.Listener` interface exposes methods
    used to manage the life cycle of incoming client connections. Depending on the
    value of the `network` parameter (`"tcp"`, `"tcp4"`, `"tcp6"`, and so on.), `net.Listen`
    will return either a `net.TCPListener` or `net.UnixListener` *,* both of which
    are concrete implementations of the `net.Listener` interface.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对`net.Listen`函数的成功调用返回一个`net.Listener`类型的值（或者如果失败，则返回一个非nil的错误）。`net.Listener`接口公开了用于管理传入客户端连接的生命周期的方法。根据`network`参数的值（`"tcp"`,
    `"tcp4"`, `"tcp6"`等），`net.Listen`将返回`net.TCPListener`或`net.UnixListener`，它们都是`net.Listener`接口的具体实现。
- en: Accepting client connections
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受客户端连接
- en: 'The `net.Listener` interface uses the *Accept* method to block indefinitely
    until a new connection arrives from a client. The following abbreviated code snippet
    shows a simple server that returns the string "Nice to meet you!" to each client
    connection and then disconnects immediately:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Listener`接口使用*Accept*方法无限期地阻塞，直到从客户端接收到一个新的连接。下面的简化代码片段显示了一个简单的服务器，它向每个客户端连接返回字符串"Nice
    to meet you!"，然后立即断开连接：'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch11/listen0.go
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/listen0.go
- en: 'In the code, the `listener.Accept` method returns a value of the `net.Conn`
    type to handle data exchange between the server and the client (or it returns
    a non-nil `error` if it fails). The `conn.Write([]byte("Nice to meet you!"))`
    method call is used to write the response to the client. When the server program
    is running, it can be tested using a *telnet* client as shown in the following
    output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，`listener.Accept`方法返回一个`net.Conn`类型的值，用于处理服务器和客户端之间的数据交换（或者如果失败，则返回一个非nil的`error`）。`conn.Write([]byte("Nice
    to meet you!"))`方法调用用于向客户端写入响应。当服务器程序正在运行时，可以使用*telnet*客户端进行测试，如下面的输出所示：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To ensure that the server program continues to run and handle subsequent client
    connections, the call to the `Accept` method is wrapped within an infinite for-loop.
    As soon as a connection is closed, the loop restarts the cycle to wait for the
    next client connection. Also notice that it is a good practice to close the listener
    when the server process is shutting down with a call to `Listener.Close()`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保服务器程序继续运行并处理后续的客户端连接，`Accept`方法的调用被包裹在一个无限的for循环中。一旦连接关闭，循环重新开始等待下一个客户端连接。还要注意，当服务器进程关闭时，最好调用`Listener.Close()`关闭监听器。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The observant reader may notice that this simple server will not scale as it
    cannot handle more than one client request at once. In the next section, we will
    see the techniques for creating a scalable server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者可能会注意到，这个简单的服务器无法扩展，因为它一次无法处理多个客户端请求。在下一节中，我们将看到创建可扩展服务器的技术。
- en: A TCP API server
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个TCP API服务器
- en: At this point, the chapter has covered the minimum networking components necessary
    to create client and service programs. The remainder of the chapter will discuss
    different versions of a server that implement a *monetary currency information*
    service. The service returns ISO 4217 monetary currency information with each
    request. The intent is to show the implications of creating networked services,
    along with their clients, using different application-level protocols.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经涵盖了创建客户端和服务程序所需的最小网络组件。本章的其余部分将讨论实现*货币信息*服务的服务器的不同版本。该服务在每个请求中返回ISO
    4217货币信息。目的是展示使用不同应用级协议创建网络服务及其客户端的影响。
- en: 'Earlier we introduced a very simple server to demonstrate the necessary steps
    required to set up a networked service. This section dives deeper into network
    programming by creating a TCP server that scales to handle many concurrent connections.
    The server code presented in this section has the following design goals:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们介绍了一个非常简单的服务器，以演示设置网络服务所需的必要步骤。本节通过创建一个能够处理许多并发连接的TCP服务器，深入探讨了网络编程。本节中呈现的服务器代码具有以下设计目标：
- en: Use raw TCP to communicate between client and server
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原始TCP在客户端和服务器之间进行通信
- en: Develop a simple text-based protocol, over TCP, for communication
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个简单的基于文本的协议，通过TCP进行通信
- en: Clients can query the server for global currency information with text commands
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以使用文本命令查询全球货币信息
- en: Use a goroutine per connection to handle connection concurrency
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用goroutine处理每个连接以处理连接并发
- en: Maintain connection until the client disconnects
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持连接直到客户端断开连接
- en: The following lists an abbreviated version of the server code. The program uses
    the `curr` package (found at [https://github.com/vladimirvivien/learning-go/ch11/curr0](https://github.com/vladimirvivien/learning-go/ch11/curr0)),
    not discussed here, to load monetary currency data from a local CSV file into
    slice `currencies`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务器代码的简化版本列表。该程序使用`curr`包（在[https://github.com/vladimirvivien/learning-go/ch11/curr0](https://github.com/vladimirvivien/learning-go/ch11/curr0)找到），这里不讨论，用于将货币数据从本地CSV文件加载到切片`currencies`中。
- en: 'Upon successful connection to a client, the server parses the incoming client
    commands specified with a simple text protocol with the format *GET <currency-filter-value>*
    where *<currency-filter-value>* specifies a string value used to search for currency
    information:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 成功连接到客户端后，服务器使用简单的文本协议解析传入的客户端命令，格式为*GET <currency-filter-value>*，其中*<currency-filter-value>*指定用于搜索货币信息的字符串值：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch11/tcpserv0.go
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/tcpserv0.go
- en: Unlike the simple server introduced in the last section, this server is able
    to service multiple client connections at the same time. Upon accepting a new
    connection, with `ln.Accept()`, it delegates the handling of new client connections
    to a goroutine with `go handleConnection(conn)`. The connection loop then continues
    immediately and waits for the next client connection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节介绍的简单服务器不同，这个服务器能够同时为多个客户端连接提供服务。在接受新连接时，使用`ln.Accept()`委托新客户端连接的处理给一个goroutine，使用`go
    handleConnection(conn)`。连接循环立即继续，并等待下一个客户端连接。
- en: The `handleConnection` function manages the server communication with the connected
    client. It first reads and parses a slice of bytes, from the client, into a command
    string using `cmd, param := parseCommand(string(cmdLine[0:n]))`. Next, the code
    tests the command with a `switch` statement. If the `cmd` is equal to `"GET"`,
    the code searches slice `currencies` for values that matches `param` with a call
    to `curr.Find(currencies, param)`. Finally, it streams the search result to the
    client's connection using `fmt.Fprintf(conn, "%s %s %s %s\n", cur.Name, cur.Code,
    cur.Number, cur.Country)`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleConnection`函数管理与连接的客户端的服务器通信。它首先读取并解析来自客户端的字节片段，将其转换为命令字符串，使用`cmd, param
    := parseCommand(string(cmdLine[0:n]))`。接下来，代码使用`switch`语句测试命令。如果`cmd`等于`"GET"`，则代码使用`curr.Find(currencies,
    param)`搜索切片`currencies`以匹配`param`的值。最后，它使用`fmt.Fprintf(conn, "%s %s %s %s\n",
    cur.Name, cur.Code, cur.Number, cur.Country)`将搜索结果流式传输到客户端的连接。'
- en: The simple text protocol supported by the server does not include any sort of
    session control or control messages. Therefore, the code uses the `conn.SetWriteDeadline`
    method to ensure the connection to the client does not linger unnecessarily for
    long periods of time. The method is called during the loop that streams out a
    response to the client. It is set for a deadline of 5 seconds to ensure the client
    is always ready to receive the next chunk of bytes within that time, otherwise
    it times the connection out.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器支持的简单文本协议不包括任何会话控制或控制消息。因此，代码使用`conn.SetWriteDeadline`方法来确保与客户端的连接不会在长时间内不必要地挂起。该方法在向客户端流出响应的循环中调用。它设置了一个5秒的截止期限，以确保客户端始终准备好在该时间内接收下一块字节，否则它会超时连接。
- en: Connecting to the TCP server with telnet
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用telnet连接到TCP服务器
- en: 'Because the currency server presented earlier uses a simple text-based protocol,
    it can be tested using a telnet client, assuming the server code has been compiled
    and running (and listening on port `4040`). The following shows the output of
    a telnet session querying the server for currency information:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为之前介绍的货币服务器使用了简单的基于文本的协议，所以可以使用telnet客户端进行测试，假设服务器代码已经编译并运行（并监听在端口`4040`上）。以下是telnet会话查询服务器货币信息的输出：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, you can query the server by using the `get` command followed
    by a filter parameter as explained earlier. The telnet client sends the raw text
    to the server which parses it and sends back raw text as the response. You can
    open multiple telnet sessions against the server and all request are served concurrently
    in their respective goroutine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以使用`get`命令查询服务器，后面跟随一个过滤参数，如前面所述。telnet客户端将原始文本发送到服务器，服务器解析后以原始文本作为响应发送回来。您可以打开多个telnet会话与服务器连接，并且所有请求都在各自的goroutine中同时处理。
- en: Connecting to the TCP server with Go
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Go连接到TCP服务器
- en: 'A simple TCP client can also be written in Go to connect to the TCP server.
    The client captures the command from the console''s standard input and sends it
    to the server as is shown in the following code snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Go编写一个简单的TCP客户端来连接TCP服务器。客户端从控制台的标准输入中捕获命令，并将其发送到服务器，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: golang.fyi/ch11/tcpclient0.go
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/tcpclient0.go
- en: The source code for the Go client follows the same pattern as we have seen in
    the earlier client example. The first portion of the code dials out to the server
    using `net.Dial()`. Once a connection is obtained, the code sets up an event loop
    to capture text commands from the standard input, parses it, and sends it as a
    request to the server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Go客户端的源代码遵循与之前客户端示例中相同的模式。代码的第一部分使用`net.Dial()`拨号到服务器。一旦获得连接，代码设置了一个事件循环来捕获标准输入中的文本命令，解析它，并将其作为请求发送到服务器。
- en: 'There is a nested loop that is set up to handle incoming responses from the
    server (see code comment). It continuously streams incoming bytes into variables `buff`
    with `conn.Read(buff)`. This continues until the `Read` method encounters an error.
    The following lists the sample output produced by the client when it is executed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了一个嵌套循环来处理从服务器接收的响应（参见代码注释）。它不断将传入的字节流到`buff`变量中，使用`conn.Read(buff)`。这将一直持续，直到`Read`方法遇到错误。以下列出了客户端执行时产生的示例输出：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An even better way of streaming the incoming bytes from the server is to use
    buffered IO as done in the following snippet of code. In the updated code, the
    `conbuf` variable, of the `bufio.Buffer` type, is used to read and split incoming
    streams from the server using the `conbuf.ReadString` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器流式传输传入的字节的更好方法是使用缓冲IO，就像下面的代码片段中所做的那样。在更新的代码中，`conbuf`变量，类型为`bufio.Buffer`，用于使用`conbuf.ReadString`方法读取和拆分从服务器传入的流：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: golang.fyi/ch11/tcpclient1.go
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/tcpclient1.go
- en: As you can see, writing networked services directly on top of raw TCP has some
    costs. While raw TCP gives the programmer complete control of the application-level
    protocol, it also requires the programmer to carefully handle all data processing
    which can be error-prone. Unless it is absolutely necessary to implement your
    own custom protocol, a better approach is to leverage an existing and proven protocols
    to implement your server programs. The remainder of this chapter continues to
    explore this topic using services that are based on HTTP as an application-level
    protocol.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，直接在原始TCP之上编写网络服务会产生一些成本。虽然原始TCP使程序员完全控制应用程序级协议，但它也要求程序员仔细处理所有数据处理，这可能容易出错。除非绝对必要实现自定义协议，否则更好的方法是利用现有和经过验证的协议来实现服务器程序。本章的其余部分将继续探讨这个主题，使用基于HTTP的服务作为应用级协议。
- en: The HTTP package
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP包
- en: Due to its importance and ubiquity, HTTP is one of a handful of protocols directly
    implemented in Go. The `net/http` package ([https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/))
    provides code to implement both HTTP clients and HTTP servers. This section explores
    the fundamentals of creating HTTP clients and servers using the `net/http` package.
    Later, we will return our attention back to building versions of our currency
    service using HTTP.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其重要性和普遍性，HTTP是Go中直接实现的少数协议之一。`net/http`包（[https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/)）提供了实现HTTP客户端和HTTP服务器的代码。本节探讨了使用`net/http`包创建HTTP客户端和服务器的基础知识。稍后，我们将把注意力转回使用HTTP构建货币服务的版本。
- en: The http.Client type
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: http.Client类型
- en: 'The `http.Client` struct represents an HTTP client and is used to create HTTP
    requests and retrieve responses from a server. The following illustrates how to
    retrieve the text content of Beowulf from Project Gutenberg''s website located
    at [http://gutenberg.org/cache/epub/16328/pg16328.txt](http://gutenberg.org/cache/epub/16328/pg16328.txt), using
    the `client` variable of the `http.Client` type and prints its content to a standard
    output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Client`结构表示一个HTTP客户端，用于创建HTTP请求并从服务器检索响应。以下说明了如何使用`http.Client`类型的`client`变量从Project
    Gutenberg网站的[http://gutenberg.org/cache/epub/16328/pg16328.txt](http://gutenberg.org/cache/epub/16328/pg16328.txt)检索Beowulf的文本内容，并将其内容打印到标准输出：'
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: golang.fyi/ch11/httpclient1.go
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpclient1.go
- en: The previous example uses the `client.Get` method to retrieve content from the
    remote server using the HTTP protocol method `GET` internally. The `GET` method
    is part of several convenience methods offered, by the Client type, to interact
    with HTTP servers as summarized in the following table. Notice that all of these
    methods return a value of the `*http.Response` type (discussed later) to handle
    responses returned by the HTTP server.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用`client.Get`方法使用HTTP协议的`GET`方法从远程服务器检索内容。`GET`方法是`Client`类型提供的几种方便方法之一，用于与HTTP服务器交互，如下表所总结的。请注意，所有这些方法都返回`*http.Response`类型的值（稍后讨论），以处理HTTP服务器返回的响应。
- en: '| **Method** | **Description** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Client.Get` | As discussed earlier, `Get` is a convenience method that issues
    an HTTP `GET` method to retrieve the resource specified by the `url` parameter
    from the server:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Client.Get` | 正如前面讨论的，`Get`是一个方便的方法，用于向服务器发出HTTP `GET`方法，以从服务器检索由`url`参数指定的资源：'
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Client.Post` | The `Post` method is a convenience method that issues an
    HTTP `POST` method to send the content specified by the `body` parameter to the
    server specified by the `url` parameter:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Client.Post` | `Post`方法是一个方便的方法，用于向服务器发出HTTP `POST`方法，以将`body`参数指定的内容发送到`url`参数指定的服务器：'
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Client.PostForm` | The `PostForm` method is a convenience method that uses
    the HTTP `POST` method to send form `data`, specified as mapped key/value pairs,
    to the server:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Client.PostForm` | `PostForm`方法是一个方便的方法，使用HTTP `POST`方法将表单`data`作为映射的键/值对发送到服务器：'
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Client.Head` | The `Head` method is a convenience method that issues an
    HTTP method, `HEAD`, to the remote server specified by the `url` parameter:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Client.Head` | `Head`方法是一个方便的方法，用于向由`url`参数指定的远程服务器发出HTTP方法`HEAD`：'
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Client.Do` | This method generalizes the request and response interaction
    with a remote HTTP server. It is wrapped internally by the methods listed in this
    table. Section *Handling client requests and responses* discusses how to use this
    method to talk to the server. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '`Client.Do` | 该方法概括了与远程HTTP服务器的请求和响应交互。它在内部被表中列出的方法包装。*处理客户端请求和响应*部分讨论了如何使用该方法与服务器通信。'
- en: 'It should be noted that the HTTP package uses an internal `http.Client` variable
    designed to mirror the preceding methods as package functions for further convenience.
    They include `http.Get`, `*http.Post*` , `http.PostForm`, and `http.Head`. The
    following snippet shows the previous example using `http.Get` instead of the method
    from the `http.Client`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，HTTP包使用内部的`http.Client`变量，设计为将前述方法作为包函数进一步方便地进行镜像。它们包括`http.Get`、`*http.Post*`、`http.PostForm`和`http.Head`。以下代码片段显示了前面的示例，使用`http.Get`而不是`http.Client`的方法：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch11/httpclient1a.go
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpclient1a.go
- en: Configuring the client
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置客户端
- en: 'Besides the methods to communicate with the remote server, the `http.Client`
    type exposes additional attributes that can be used to modify and control the
    behavior of the client. For instance, the following source snippet sets the timeout
    to handle a client request to complete within 21 seconds using the `Timeout` attribute
    of the `Client` type:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与远程服务器通信的方法之外，`http.Client`类型还公开了其他属性，可用于修改和控制客户端的行为。例如，以下源代码片段使用`Client`类型的`Timeout`属性将超时设置为21秒，以处理客户端请求的完成：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: golang.fyi/ch11/httpclient2.go
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpclient2.go
- en: 'The `Transport` field of the `Client` type provides further means of controlling
    the settings of a client. For instance, the following snippet creates a client
    that disables the connection reuse between successive HTTP requests with the `DisableKeepAlive`
    field. The code also uses the `Dial` function to specify further granular control
    over the HTTP connection used by the underlying client, setting its timeout value
    to 30 seconds:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client`类型的`Transport`字段提供了进一步控制客户端设置的手段。例如，以下代码片段创建了一个禁用连续HTTP请求之间连接重用的客户端，使用了`DisableKeepAlive`字段。该代码还使用`Dial`函数来进一步精细控制底层客户端使用的HTTP连接，将其超时值设置为30秒：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Handling client requests and responses
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理客户端请求和响应
- en: 'An `http.Request` value can be explicitly created using the `http.NewRequest`
    function. A request value can be used to configure HTTP settings, add headers,
    and specify the content body of the request. The following source snippet uses
    the `http.Request` type to create a new request which is used to specify the headers
    sent to the server:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`http.NewRequest`函数显式创建一个`http.Request`值。请求值可用于配置HTTP设置，添加头部并指定请求的内容主体。以下源代码片段使用`http.Request`类型创建一个新请求，该请求用于指定发送到服务器的头部：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: golang.fyi/ch11/httpclient3.go
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpclient3.go
- en: 'The `http.NewRequest` function has the following signature:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.NewRequest` 函数具有以下签名：'
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It takes a string that specifies the HTTP method as its first argument. The
    next argument specifies the destination URL. The last argument is an `io.Reader`
    that can be used to specify the content of the request (or set to nil if the request
    has no content). The function returns a pointer to a `http.Request` struct value
    (or a non-nil `error` if one occurs). Once the request value is created, the code
    uses the `Header` field to add HTTP headers to the request to be sent to the server.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它以一个字符串作为第一个参数，该字符串指定了HTTP方法。下一个参数指定了目标URL。最后一个参数是一个`io.Reader`，用于指定请求的内容（如果请求没有内容，则设置为nil）。该函数返回一个指向`http.Request`结构值的指针（如果发生错误，则返回非nil的`error`）。一旦请求值被创建，代码就可以使用`Header`字段向请求添加HTTP头，以便发送到服务器。
- en: 'Once a request is prepared (as shown in the previous source snippet), it is
    sent to the server using the *Do* method of the `http.Client` type and has the
    following signature:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求准备好（如前面源代码片段所示），就可以使用`http.Client`类型的*Do*方法将其发送到服务器，该方法具有以下签名：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The method accepts a pointer to an `http.Request` value, as discussed in the
    previous section. It then returns a pointer to an `http.Response` value or an
    error if the request fails. In the previous source code, `resp, err := client.Do(req)`
    is used to send the request to the server and assigns the response to the `resp`
    variable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个指向`http.Request`值的指针，如前一节所述。然后返回一个指向`http.Response`值的指针，或者如果请求失败则返回一个错误。在前面的源代码中，使用`resp,
    err := client.Do(req)`将请求发送到服务器，并将响应分配给`resp`变量。
- en: The response from the server is encapsulated in struct `http.Response` which
    contains several fields to describe the response including the HTTP response status,
    content length, headers, and the response body. The response body, exposed as
    the `http.Response.Body` field, implements the `io.Reader` which affords the use
    streaming IO primitives to consume the response content.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的响应封装在`http.Response`结构中，其中包含几个字段来描述响应，包括HTTP响应状态、内容长度、头部和响应体。响应体作为`http.Response.Body`字段公开，实现了`io.Reader`，可以使用流式IO原语来消耗响应内容。
- en: The `Body` field also implements `*io.Closer*` which allows the closing of IO
    resources. The previous source uses `defer resp.Body.Close()` to close the IO
    resource associated with the response body. This is a recommended idiom when the
    server is expected to return a non-nil body.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Body`字段还实现了`*io.Closer*`，允许关闭IO资源。前面的源代码使用`defer resp.Body.Close()`来关闭与响应体关联的IO资源。当服务器预期返回非nil主体时，这是一个推荐的习惯用法。'
- en: A simple HTTP server
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的HTTP服务器
- en: 'The HTTP package provides two main components to accept HTTP requests and serve
    responses:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP包提供了两个主要组件来接受HTTP请求和提供响应：
- en: The `http.Handler` interface
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.Handler` 接口'
- en: The `http.Server` type
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.Server`类型'
- en: 'The `http.Server` type uses the `http.Handler` interface type, defined in the
    following listing, to receive requests and server responses:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Server`类型使用`http.Handler`接口类型，如下列表所示，用于接收请求和服务器响应：'
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Any type that implements `http.Handler` can be registered (explained next)
    as a valid handler. The Go `http.Server` type is used to create a new server.
    It is a struct whose values can be configured, at a minimum, with the TCP address
    of the service and a handler that will respond to incoming requests. The following
    code snippet shows a simple HTTP server that defines the `msg` type as handler
    registered to handle incoming client requests:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现`http.Handler`的类型都可以注册（下面会解释）为有效的处理程序。Go `http.Server`类型用于创建一个新的服务器。它是一个结构体，其值可以被配置，至少包括服务的TCP地址和一个将响应传入请求的处理程序。以下代码片段显示了一个简单的HTTP服务器，将`msg`类型定义为注册的处理程序来处理传入的客户端请求：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: golang.fyi/ch11/httpserv0.go
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpserv0.go
- en: 'In the previous code, the `msg` type, which uses a string as its underlying
    type, implements the `ServeHTTP()` method making it a valid HTTP handler. Its
    `ServeHTTP` method uses the response parameter, `resp`, to print response headers
    `"200 OK"` and `"Content-Type: text/html"`. The method also writes the string
    value `m` to the response variable using `fmt.Fprint(resp, m)` which is sent back
    to the client.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，`msg`类型使用字符串作为其基础类型，实现了`ServeHTTP()`方法，使其成为有效的HTTP处理程序。它的`ServeHTTP`方法使用响应参数`resp`来打印响应头`"200
    OK"`和`"Content-Type: text/html"`。该方法还使用`fmt.Fprint(resp, m)`将字符串值`m`写入响应变量，然后发送回客户端。'
- en: 'In the code, the variable `server` is initialized as `http.Server{Addr: ":4040",
    Handler: msgHandler}`. This means the server will listen on all network interfaces
    at port `4040` and will use variable `msgHandler` as its `http.Handler` implementation.
    Once initialized, the server is started with the `server.ListenAndServe()` method
    call that is used to block and listen for incoming requests.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '在代码中，变量`server`被初始化为`http.Server{Addr: ":4040", Handler: msgHandler}`。这意味着服务器将在端口`4040`上监听所有网络接口，并将使用变量`msgHandler`作为其`http.Handler`实现。一旦初始化，服务器就会使用`server.ListenAndServe()`方法调用来启动，该方法用于阻塞并监听传入的请求。'
- en: 'Besides the `Addr` and `Handler`, the `http.Server` struct exposes several
    additional fields that can be used to control different aspects of the HTTP service
    such as connection, timeout values, header sizes, and TLS configuration. For instance,
    the following snippet shows an updated example which specifies the server''s read
    and write timeouts:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Addr`和`Handler`之外，`http.Server`结构还公开了几个额外的字段，可以用来控制HTTP服务的不同方面，例如连接、超时值、标头大小和TLS配置。例如，以下代码片段显示了一个更新后的示例，其中指定了服务器的读取和写入超时：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: golang.fyi/ch11/httpserv1.go
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpserv1.go
- en: The default server
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认服务器
- en: 'It should be noted that the HTTP package includes a default server that can
    be used in simpler cases when there is no need for configuration of the server.
    The following abbreviated code snippet starts a simple server without explicitly
    creating a server variable:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，HTTP包包括一个默认服务器，可以在不需要配置服务器的简单情况下使用。以下简化的代码片段启动了一个简单的服务器，而无需显式创建服务器变量：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: golang.fyi/ch11/httpserv2.go
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpserv2.go
- en: In the code, the `http.ListenAndServe(":4040", msgHandler)` function is used
    to start a server which is declared as a variable in the HTTP package. The server
    is configured with the local address `":4040"` and the handler `msgHandler` (as
    was done earlier) to handle all incoming requests.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，使用`http.ListenAndServe(":4040", msgHandler)`函数来启动一个服务器，该服务器被声明为HTTP包中的一个变量。服务器配置为使用本地地址`":4040"`和处理程序`msgHandler`（与之前一样）来处理所有传入的请求。
- en: Routing requests with http.ServeMux
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用http.ServeMux路由请求
- en: The `http.Handler` implementation introduced in the previous section is not
    sophisticated. No matter what URL path is sent with the request, it sends the
    same response back to the client. That is not very useful. In most cases, you
    want to map each path of a request URL to a different response.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节介绍的`http.Handler`实现并不复杂。无论请求中发送了什么URL路径，它都会向客户端发送相同的响应。这并不是很有用。在大多数情况下，您希望将请求URL的每个路径映射到不同的响应。
- en: 'Fortunately, the HTTP package comes with the `http.ServeMux` type which can
    multiplex incoming requests based on URL patterns. When an `http.ServeMux` handler
    receives a request, associated with a URL path, it dispatches a function that
    is mapped to that URL. The following abbreviated code snippet shows `http.ServeMux`
    variable `mux` configured to handle two URL paths `"/hello"` and `"/goodbye"`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，HTTP包带有`http.ServeMux`类型，它可以根据URL模式复用传入的请求。当`http.ServeMux`处理程序接收到与URL路径关联的请求时，它会分派一个映射到该URL的函数。以下简化的代码片段显示了`http.ServeMux`变量`mux`配置为处理两个URL路径`"/hello"`和`"/goodbye"`：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: golang.fyi/ch11/httpserv3.go
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpserv3.go
- en: The code declares two functions assigned to variables `hello` and `goodbye`.
    Each function is mapped to a path `"/hello"` and `"/goodbye"` respectively using
    the `mux.HandleFunc("/hello", hello)` and `mux.HandleFunc("/goodbye", goodbye)`
    method calls. When the server is launched, with `http.ListenAndServe(":4040",
    mux)`, its handler will route the request `"http://localhost:4040/hello"` to the
    `hello` function and requests with the path `"http://localhost:4040/goodbye"`
    to the `goodbye` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码声明了两个分配给变量`hello`和`goodbye`的函数。每个函数分别映射到路径`"/hello"`和`"/goodbye"`，使用`mux.HandleFunc("/hello",
    hello)`和`mux.HandleFunc("/goodbye", goodbye)`方法调用。当服务器启动时，使用`http.ListenAndServe(":4040",
    mux)`，其处理程序将将请求`"http://localhost:4040/hello"`路由到`hello`函数，并将路径为`"http://localhost:4040/goodbye"`的请求路由到`goodbye`函数。
- en: The default ServeMux
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认的ServeMux
- en: 'It is worth pointing out that the HTTP package makes available a default ServeMux
    internally. When used, it is not necessary to explicitly declare a ServeMux variable.
    Instead the code uses the package function, `http.HandleFunc,` to map a path to
    a handler function as illustrated in the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，HTTP包在内部提供了一个默认的ServeMux。当使用时，不需要显式声明ServeMux变量。相反，代码使用包函数`http.HandleFunc`将路径映射到处理程序函数，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: golang.fyi/ch11/httpserv4.go
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/httpserv4.go
- en: To launch the server, the code calls `http.ListenAndServe(":4040", nil)` where
    the ServerMux parameter is set to `nil`. This implies that the server will default
    to the per-declared package instance of http.ServeMux to handle incoming requests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动服务器，代码调用`http.ListenAndServe(":4040", nil)`，其中ServerMux参数设置为`nil`。这意味着服务器将默认使用预声明的http.ServeMux包实例来处理传入的请求。
- en: A JSON API server
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个JSON API服务器
- en: 'Armed with the information from the last section, it is possible to use the
    HTTP package to create services over HTTP. Earlier we discussed the perils of
    creating services using raw TCP directly when we created a server for our global
    monetary currency service. In this section, we explore how to create an API server
    for the same service using HTTP as the underlying protocol. The new HTTP-based
    service has the following design goals:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上一节的信息，可以使用HTTP包在HTTP上创建服务。早些时候，我们讨论了使用原始TCP直接创建服务的危险，当时我们为全球货币服务创建了一个服务器。在本节中，我们将探讨如何使用HTTP作为底层协议为相同的服务创建API服务器。新的基于HTTP的服务具有以下设计目标：
- en: Use HTTP as the transport protocol
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP作为传输协议
- en: Use JSON for structured communication between client and server
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON进行客户端和服务器之间的结构化通信
- en: Clients query the server for currency information using JSON-formatted requests
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端使用JSON格式的请求查询服务器的货币信息
- en: The server respond using JSON-formatted responses
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器使用JSON格式的响应
- en: The following shows the code involved in the implementation of the new service.
    This time, the server will use the `curr1` package (see [github.com/vladimirvivien/learning-go
    /ch11/curr1](https://github.com/vladimirvivien/learning-go%20/ch11/curr1)) to
    load and query ISO 4217 currency data from a local CSV file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了实现新服务所涉及的代码。这次，服务器将使用`curr1`包（参见[github.com/vladimirvivien/learning-go/ch11/curr1](https://github.com/vladimirvivien/learning-go%20/ch11/curr1)）从本地CSV文件加载和查询ISO
    4217货币数据。
- en: 'The code in the curr1 package defines two types, `CurrencyRequest` and `Currency`,
    intended to represent the client request and currency data returned by the server,
    respectively as listed here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: curr1包中的代码定义了两种类型，`CurrencyRequest`和`Currency`，分别用于表示客户端请求和服务器返回的货币数据，如下所示：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: golang.fyi/ch11/curr1/currency.go
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/curr1/currency.go
- en: 'Note that the preceding struct types shown are annotated with tags that describe
    the JSON properties for each field. This information is used by the JSON encoder
    to encode the key name of JSON objects (see [Chapter 10](ch10.html "Chapter 10. Data
    IO in Go"), *Data IO in Go*, for detail on encoding). The remainder of the code,
    listed in the following snippet, defines the functions that set up the server
    and the handler function for incoming requests:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述显示的结构类型带有标签，描述了每个字段的JSON属性。这些信息由JSON编码器用于编码JSON对象的键名（有关编码的详细信息，请参见[第10章](ch10.html
    "第10章。Go中的数据IO")，“Go中的数据IO”）。以下代码的其余部分定义了设置服务器和处理传入请求的函数：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: golang.fyi/ch11/jsonserv0.go
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/jsonserv0.go
- en: 'Since we are leveraging HTTP as the transport protocol for the service, you
    can see the code is now much smaller than the prior implementation which used
    pure TCP. The `currs` function implements the handler responsible for incoming
    requests. It sets up a decoder to decode the incoming JSON-encoded request to
    a value of the `curr1.CurrencyRequest` type as highlighted in the following snippet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在利用HTTP作为服务的传输协议，可以看到代码现在比之前使用纯TCP的实现要小得多。`currs`函数实现了处理传入请求的处理程序。它设置了一个解码器，用于将传入的JSON编码请求解码为`curr1.CurrencyRequest`类型的值，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, the function executes the currency search by calling `curr1.Find(currencies,
    currRequest.Get)` which returns the slice `[]Currency` assigned to the `result`
    variable. The code then creates an encoder to encode the `result` as a JSON payload,
    highlighted in the following snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，该函数通过调用`curr1.Find(currencies, currRequest.Get)`执行货币搜索，该函数返回分配给`result`变量的`[]Currency`切片。然后，代码创建一个编码器，将`result`编码为JSON有效载荷，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Lastly, the handler function is mapped to the `"/currency"` path in the `main`
    function with the call to `mux.HandleFunc("/currency", currs)`. When the server
    receives a request for that path, it automatically executes the `currs` function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，处理程序函数在`main`函数中通过调用`mux.HandleFunc("/currency", currs)`映射到`"/currency"`路径。当服务器收到该路径的请求时，它会自动执行`currs`函数。
- en: Testing the API server with cURL
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用cURL测试API服务器
- en: 'Because the server is implemented over HTTP, it can easily be tested with any
    client-side tools that support HTTP. For instance, the following shows how to
    use the `cURL` command line tool ([http://curl.haxx.se/](http://curl.haxx.se/)))
    to connect to the API end-point and retrieve currency information about the `Euro`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器是通过HTTP实现的，因此可以使用支持HTTP的任何客户端工具轻松测试。例如，以下显示了如何使用`cURL`命令行工具（[http://curl.haxx.se/](http://curl.haxx.se/)）连接到API端点并检索有关`Euro`的货币信息：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `cURL` command posts a JSON-formatted request object to the server using
    the `-X POST -d '{"get":"Euro"}'` parameters. The output (formatted for readability)
    from the server is comprised of a JSON array of the preceding currency items.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`cURL`命令使用`-X POST -d ''{"get":"Euro"}''`参数向服务器发布JSON格式的请求对象。服务器的输出（格式化以便阅读）由前述货币项目的JSON数组组成。'
- en: An API server client in Go
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go中的API服务器客户端
- en: 'An HTTP client can also be built in Go to consume the service with minimal
    efforts. As is shown in the following code snippet, the client code uses the `http.Client`
    type to communicate with the server. It also uses the `encoding/json` sub-package
    to decode incoming data (note that the client also makes use of the `curr1` package,
    shown earlier, which contains the types needed to communicate with the server):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP客户端也可以在Go中构建，以最小的努力来消耗服务。如下面的代码片段所示，客户端代码使用`http.Client`类型与服务器通信。它还使用`encoding/json`子包来解码传入的数据（请注意，客户端还使用了之前显示的`curr1`包，其中包含与服务器通信所需的类型）：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: golang.fyi/ch11/jsonclient0.go
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/jsonclient0.go
- en: 'In the previous code, an HTTP client is created to send JSON-encoded request
    values as `currRequest := &curr1.CurrencyRequest{Get: param}` where `param` is
    the currency string to retrieve. The response from the server is a payload that
    represents an array of JSON-encoded objects (see the JSON array in the section,
    *Testing the API Server with cURL*). The code then uses a JSON decoder, `json.NewDecoder(resp.Body).Decode(&currencies)`,
    to decode the payload from the response body into the slice, `[]curr1.Currency`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，创建了一个HTTP客户端以将JSON编码的请求值发送为`currRequest := &curr1.CurrencyRequest{Get:
    param}`，其中`param`是要检索的货币字符串。服务器的响应是表示JSON编码对象数组的有效负载（请参见*使用cURL测试API服务器*部分中的JSON数组）。然后代码使用JSON解码器`json.NewDecoder(resp.Body).Decode(&currencies)`将响应体中的有效负载解码为切片`[]curr1.Currency`。'
- en: A JavaScript API server client
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript API服务器客户端
- en: So far, we have seen how to use the API service using the `cURL` command-line
    tool and a native Go client. This section shows the versatility of using HTTP
    to implement networked services by showcasing a web-based JavaScript client. In
    this approach, the client is a web-based GUI that uses modern HTML, CSS, and JavaScript
    to create an interface that interacts with the API server.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用`cURL`命令行工具和本机Go客户端使用API服务。本节展示了使用HTTP实现网络服务的多功能性，通过展示基于Web的JavaScript客户端。在这种方法中，客户端是一个基于Web的GUI，使用现代HTML、CSS和JavaScript创建一个与API服务器交互的界面。
- en: 'First, the server code is updated with an additional handler to serve the static
    HTML file that renders the GUI on the browser. This is illustrated in the following
    code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，服务器代码更新为添加一个处理程序，以提供在浏览器上呈现GUI的静态HTML文件。以下是示例代码：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: golang.fyi/ch11/jsonserv1.go
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/jsonserv1.go
- en: 'The preceding code snippet shows the declaration of the `gui` handler function
    responsible for serving a static HTML file that renders the GUI for the client.
    The root URL path is then mapped to the function with `mux.HandleFunc("/", gui)`.
    So, in addition to the `"/currency"` path, which hosts the API end-point the `"/"`
    path will return the web page shown in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示了`gui`处理程序函数的声明，负责提供用于为客户端呈现GUI的静态HTML文件。然后将根URL路径映射到该函数，使用`mux.HandleFunc("/",
    gui)`。因此，除了`"/currency"`路径（托管API端点），`"/"`路径将返回以下截图中显示的网页：
- en: '![A JavaScript API server client](img/image_11_001.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![一个JavaScript API服务器客户端](img/image_11_001.jpg)'
- en: 'The next HTML page ([golang.fyi/ch11/currency.html](http://learning.golang.fyi/ch11/currency.html))
    is responsible for displaying the result of a currency search. It uses JavaScritpt
    functions along with the `jQuery.js` library (not covered here) to post JSON-encoded
    requests to the backend Go service as shown in the following abbreviated HTML
    and JavaScript snippets:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个HTML页面（[golang.fyi/ch11/currency.html](http://learning.golang.fyi/ch11/currency.html)）负责显示货币搜索结果。它使用JavaScritpt函数以及`jQuery.js`库（此处未涵盖）来将JSON编码的请求发送到后端Go服务，如下所示的缩写HTML和JavaScript片段：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: golang.fyi/ch11/currency.html
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch11/currency.html
- en: A line-by-line analysis of the HTML and JavaScript code in this example is beyond
    the scope of the book; however, it is worth pointing out that the JavaScript `doRequest`
    function is where the interaction between the client and the server happens. It
    uses the jQuery's `$.ajax` function to build an HTTP request with a `PUT` method
    and to specify a JSON-encoded currency request object, `JSON.stringify({get:param})`,
    to send to the server. The `then` method accepts the callback function, `success(currencies)`,
    which handles the response from the server that parses displays in an HTML table.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例中HTML和JavaScript代码的逐行分析超出了本书的范围；然而，值得指出的是，JavaScript的`doRequest`函数是客户端和服务器之间交互发生的地方。它使用jQuery的`$.ajax`函数构建一个带有`PUT`方法的HTTP请求，并指定一个JSON编码的货币请求对象`JSON.stringify({get:param})`发送到服务器。`then`方法接受回调函数`success(currencies)`，处理来自服务器的响应并在HTML表格中显示。
- en: 'When a search value is provided in the text box on the GUI, the page displays
    its results in the table dynamically as shown in the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当在GUI的文本框中提供搜索值时，页面会动态地在表格中显示其结果，如下截图所示：
- en: '![A JavaScript API server client](img/image_11_002.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![一个JavaScript API服务器客户端](img/image_11_002.jpg)'
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter condenses several important notions about creating networked services
    in Go. It starts with a walkthrough of Go's `net` package including the `net.Conn`
    type to create a connection between network nodes, the `net.Dial` function to
    connect to a remote service, and the `net.Listen` function to handle incoming
    connections from a client. The chapter continues to cover different implementations
    of clients and server programs and shows the implications of creating custom protocols
    directly over raw TCP versus using an existing protocol such as HTTP with JSON
    data format.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节总结了关于在Go中创建网络服务的几个重要概念。它从Go的`net`包开始，包括`net.Conn`类型用于在网络节点之间创建连接，`net.Dial`函数用于连接到远程服务，以及`net.Listen`函数用于处理来自客户端的传入连接。本章继续涵盖了客户端和服务器程序的不同实现，并展示了直接在原始TCP上创建自定义协议与使用现有协议（如带有JSON数据格式的HTTP）的影响。
- en: The next chapter takes a different direction. It explores the packages, types,
    functions, and tools that are available in Go to facilitate source code testing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章采取了不同的方向。它探讨了在Go中可用的包、类型、函数和工具，以便进行源代码测试。
