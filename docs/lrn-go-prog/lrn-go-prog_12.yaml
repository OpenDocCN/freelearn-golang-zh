- en: Chapter 12. Code Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。代码测试
- en: 'Testing is a critical ritual of modern software development practices. Go brings
    testing directly into the development cycle by offering an API and command-line
    tool to seamlessly create and integrate automated test code. Here we will cover
    the Go testing suite, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是现代软件开发实践的关键仪式。Go通过提供API和命令行工具，将测试直接融入开发周期，无缝创建和集成自动化测试代码。在这里，我们将介绍Go测试套件，包括以下内容：
- en: The Go test tool
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go测试工具
- en: Writing Go tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Go测试
- en: HTTP testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP测试
- en: Test coverage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: Code benchmark
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码基准
- en: The Go test tool
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go测试工具
- en: 'Prior to writing any test code, let''s take a detour to discuss the tooling
    for automated testing in Go. Similar to the `go build` command, the `go test`
    command is designed to compile and exercise test source files in specified packages,
    as illustrated in the following command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何测试代码之前，让我们先讨论一下Go中自动化测试的工具。与`go build`命令类似，`go test`命令旨在编译和执行指定包中的测试源文件，如下命令所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The previous command will exercise all test functions in the current package.
    Although it appears to be simple, the previous command accomplishes several complex
    steps, including:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将执行当前包中的所有测试函数。尽管看起来很简单，但上述命令完成了几个复杂的步骤，包括：
- en: The compilation of all test files found in the current package
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译当前包中找到的所有测试文件
- en: Generating an instrumented binary from the test file
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从测试文件生成一个带有仪器的二进制文件
- en: Executing the test functions in the code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行代码中的测试函数
- en: 'When the `go test` command targets multiple packages, the test tool generates
    multiple test binaries that are executed and tested independently, as shown in
    the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当`go test`命令针对多个包时，测试工具将生成多个测试二进制文件，这些二进制文件将独立执行和测试，如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Test file names
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试文件名称
- en: The test command uses the import path standard (see [Chapter 6](ch06.html "Chapter 6. Go
    Packages and Programs"), *Go Packages and Programs*) to specify which packages
    to test. Within a specified package, the test tool will compile all files with
    the `*_test.go` name pattern. For instance, assuming that we have a project that
    has a simple implementation of a mathematical vector type in a file called `vec.go`,
    a sensible name for its test file would be `vec_test.go`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 测试命令使用导入路径标准（请参阅[第6章](ch06.html "第6章。Go包和程序")，*Go包和程序*）来指定要测试的包。在指定的包内，测试工具将编译所有具有`*_test.go`名称模式的文件。例如，假设我们有一个项目，在名为`vec.go`的文件中有一个简单的数学向量类型的实现，那么它的测试文件的合理名称将是`vec_test.go`。
- en: Test organization
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试组织
- en: 'Traditionally, test files are kept in the same package (directory) as the code
    being tested. This is because there is no need to separate tests files, as they
    are excluded from the compiled program binary. The following shows the directory
    layout for a typical Go package, in this instance the `fmt` package from the standard
    library. It shows all of the test files for the package in the same directory
    as the regular source code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，测试文件保存在与被测试的代码相同的包（目录）中。这是因为不需要将测试文件分开，因为它们被排除在编译的程序二进制文件之外。以下显示了典型Go包的目录布局，本例中是标准库中的`fmt`包。它显示了包的所有测试文件与常规源代码在同一目录中：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Besides having a simpler project structure, keeping the files together gives
    test functions full visibility of the package being tested. This facilitates access
    to and verification of package elements that would otherwise be opaque to testing
    code. When your functions are placed in a separate package from the code to be
    tested, they lose access to non-exported elements of the code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拥有更简单的项目结构外，将文件放在一起使测试函数完全可见被测试的包。这有助于访问和验证否则对测试代码不透明的包元素。当您的函数放在与要测试的代码不同的包中时，它们将失去对代码的非导出元素的访问权限。
- en: Writing Go tests
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Go测试
- en: 'A Go test file is simply a set of functions with the following signature:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Go测试文件只是一组具有以下签名的函数：
- en: '*func Test<Name>(*testing.T)*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*func Test<Name>(*testing.T)*'
- en: Here, *<Name>* is an arbitrary name that reflects the purpose of the test. The
    test functions are intended to exercise a specific functional unit (or unit test)
    of the source code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*<Name>*是一个反映测试目的的任意名称。测试函数旨在执行源代码的特定功能单元（或单元测试）。
- en: 'Before we write the test functions, let us review the code that will be tested.
    The following source snippet shows a simple implementation of a mathematical vector
    with `Add`, `Sub`, and `Scale` methods (see the full source code listed at [https://github.com/vladimirvivien/learning-go/ch12/vector/vec.go](https://github.com/vladimirvivien/learning-go/ch12/vector/vec.go)).
    Notice that each method implements a specific behavior as a unit of functionality,
    which will make it easy to test:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试函数之前，让我们回顾一下将要测试的代码。以下源代码片段显示了一个简单的数学向量的实现，具有`Add`、`Sub`和`Scale`方法（请参阅[https://github.com/vladimirvivien/learning-go/ch12/vector/vec.go](https://github.com/vladimirvivien/learning-go/ch12/vector/vec.go)上列出的完整源代码）。请注意，每个方法都实现了特定的行为作为功能单元，这将使测试变得容易：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch12/vector/vec.go
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec.go
- en: The test functions
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试函数
- en: 'The test source code in file `vec_test.go` defines a series of functions that
    exercise the behavior of type `SimpleVector` (see the preceding section) by testing
    each of its methods independently:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`vec_test.go`中的测试源代码定义了一系列函数，通过独立测试其每个方法来执行`SimpleVector`类型（请参见前一节）的行为：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: golang.fyi/ch12/vector/vec_test.go
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec_test.go
- en: As shown in the previous code, all test source code must import the `"testing"`
    package. This is because each test function receives an argument of type `*testing.T`
    as its parameter. As is discussed further in the chapter, this allows the test
    function to interact with the Go test runtime.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，所有测试源代码必须导入`"testing"`包。这是因为每个测试函数都接收一个类型为`*testing.T`的参数。正如本章中进一步讨论的那样，这允许测试函数与Go测试运行时进行交互。
- en: It is crucial to realize that each test function should be idempotent, with
    no reliance on any previously saved or shared states. In the previous source code
    snippet, each test function is executed as a standalone piece of code. Your test
    functions should not make any assumption about the order of execution as the Go
    test runtime makes no such guarantee.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 至关重要的是要意识到每个测试函数都应该是幂等的，并且不依赖于任何先前保存或共享的状态。 在前面的源代码片段中，每个测试函数都作为独立的代码片段执行。 您的测试函数不应该假设执行的顺序，因为Go测试运行时不会做出这样的保证。
- en: 'The source code of a test function usually sets up an expected value, which
    is pre-determined based on knowledge of the tested code. That value is then compared
    to the calculated value returned by the code being tested. For instance, when
    adding two vectors, we can calculate the expected result using the rules of vector
    additions, as shown in the following snippet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数的源代码通常设置了一个预期值，该值是根据对被测试代码的了解而预先确定的。 然后将该值与被测试代码返回的计算值进行比较。 例如，当添加两个向量时，我们可以使用向量加法规则计算预期结果，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding source snippet, the expected value is calculated using two
    simple vector values, `v1` and `v2`, and stored in the variable `expect`. Variable
    `v3`, on the other hand, stores the actual value of the vector, as calculated
    by the tested code. This allows us to test the actual versus the expected, as
    shown in the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的源代码片段中，使用两个简单的向量值“v1”和“v2”计算预期值，并存储在变量“expect”中。 另一方面，变量“v3”存储了向量的实际值，由被测试代码计算得出。
    这使我们可以测试实际值与预期值，如下所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding source snippet, if the tested condition is `false`, then the
    test has failed. The code uses `t.Fail()` to signal the failure of the test function.
    Signaling failure is discussed in more detail in the Reporting failure section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的源代码片段中，如果测试的条件是“false”，那么测试就失败了。 代码使用`t.Fail()`来表示测试函数的失败。 关于信号失败的讨论将在报告失败部分详细讨论。
- en: Running the tests
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'As mentioned in the introductory section of this chapter, test functions are
    executed using the `go test` command-line tool. For instance, if we run the following
    command from within the package vector, it will automatically run all of the test
    functions of that package:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章的介绍部分所述，使用`go test`命令行工具执行测试函数。 例如，如果我们在包向量中运行以下命令，它将自动运行该包的所有测试函数：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The test can also be executed by specifying a sub-package (or all packages
    with package wildcard `./...`) relative to where the command is issued, as shown
    in the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过指定子包（或使用包通配符“./…”指定所有包）来执行测试，如下所示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Filtering executed tests
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤执行的测试
- en: 'During the development of a large set of test functions, it is often desirable
    to focus on a function (or set of functions) during debugging phases. The Go test
    command-line tool supports the `-run` flag, which specifies a regular expression
    that executes only functions whose names match the specified expression. The following
    command will only execute test function `TestVectorAdd`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发大量测试函数时，通常希望在调试阶段专注于一个函数（或一组函数）。 Go测试命令行工具支持“-run”标志，该标志指定一个正则表达式，只执行其名称与指定表达式匹配的函数。
    以下命令将只执行测试函数“TestVectorAdd”：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The use of the `-v` flag confirms that only one test function, `TestVectorAdd`,
    has been executed. As another example, the following executes all test functions
    that end with `VectorA.*$` or match function name `TestVectorMag`, while ignoring
    everything else:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“-v”标志确认只执行了一个测试函数“TestVectorAdd”。 例如，以下示例执行所有以“VectorA.*$”结尾或匹配函数名“TestVectorMag”的测试函数，同时忽略其他所有内容：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Test logging
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试日志
- en: 'When writing new or debugging existing test functions, it is often helpful
    to print information to a standard output. Type `testing.T` offers two logging
    methods: `Log`, which uses a default formatter, and `Logf`, which formats its
    output using formatting verbs (as defined in package to `fmt`). For instance,
    the following test function snippet from the vector example shows the code logging
    information with `t.Logf("Vector = %v; Unit vector = %v\n", v, expect)`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写新的或调试现有的测试函数时，将信息打印到标准输出通常是有帮助的。 类型`testing.T`提供了两种日志记录方法：`Log`使用默认格式化程序，`Logf`使用格式化动词（如在`fmt`包中定义）。
    例如，向量示例中的以下测试函数片段显示了使用`t.Logf("Vector = %v; Unit vector = %v\n", v, expect)`记录信息的代码：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: golang.fyi/ch12/vector/vec_test.go
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec_test.go
- en: 'As seen previously, the Go test tool runs tests with minimal output unless
    there is a test failure. However, the tool will output test logs when the verbose
    flag `*-v*` is provided. For instance, running the following in package vector
    will mute all logging statements:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，除非有测试失败，否则Go测试工具会以最小的输出运行测试。 但是，当提供详细标志“*-v*”时，该工具将输出测试日志。 例如，在包向量中运行以下命令将静音所有日志记录语句：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the verbose flag `-v` is provided, as shown in the following command,
    the test runtime prints the output of the logs as shown:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供了详细标志“-v”，如下命令所示，测试运行时会打印日志的输出，如下所示：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Reporting failure
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 报告失败
- en: 'By default, the Go test runtime considers a test a success if the test function
    runs and returns normally without a panic. For example, the following test function
    is broken, since its expected value is not properly calculated. The test runtime,
    however, will always report it as passing because it does not include any code
    to report the failure:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果测试函数正常运行并返回而没有发生panic，Go测试运行时将认为测试是成功的。 例如，以下测试函数是错误的，因为其预期值没有正确计算。
    但是，测试运行时将始终报告它通过，因为它不包括任何报告失败的代码：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: golang.fyi/ch12/vec_test.go
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vec_test.go
- en: 'This false positive condition may go unnoticed, especially if the verbose flag
    is turned off, minimizing any visual clues that it is broken:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种误报的情况可能会被忽视，特别是在关闭了详细标志的情况下，最大程度地减少了任何视觉线索表明它已经损坏：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One way the previous test can be fixed is by using the `Fail` method from type
    `testing.T` to signal failure, as shown in the following snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 修复前面的测试的一种方法是使用 `testing.T` 类型的 `Fail` 方法来表示失败，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So now, when the test is executed, it correctly reports that it is broken,
    as shown in the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当执行测试时，它会正确报告它是有问题的，如下面的输出所示：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is important to understand that method `Fail` only reports failure and does
    not halt the execution of a test function. On the other hand, when it makes sense
    to actually exit the function upon a failed condition, the test API offers the
    method `FailNow`, which signals failure and exits the currently executing test
    function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，`Fail` 方法只报告失败，不会终止测试函数的执行。另一方面，当在失败条件下实际上需要退出函数时，测试 API 提供了 `FailNow`
    方法，它表示失败并退出当前正在执行的测试函数。
- en: 'Type `testing.T` provides the convenience methods `Logf` and `Errorf`, which
    combine both logging and failure reporting. For instance, the following snippet
    uses the `Errorf` method, which is equivalent to calling the `Logf` and `Fail`
    methods:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`testing.T` 类型提供了方便的 `Logf` 和 `Errorf` 方法，结合了日志记录和失败报告。例如，以下代码片段使用了 `Errorf`
    方法，它相当于调用 `Logf` 和 `Fail` 方法：'
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: golang.fyi/ch12/vector/vec.go
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec.go
- en: Type `testing.T` also offers `Fatal` and `Formatf` methods as a way of combining
    the logging of a message and the immediate termination of a test function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`testing.T` 类型还提供了 `Fatal` 和 `Formatf` 方法，用于将消息记录和测试函数的立即终止结合在一起。'
- en: Skipping tests
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过测试
- en: 'It is sometimes necessary to skip test functions due to a number of factors
    such as environment constraints, resource availability, or inappropriate environment
    settings. The testing API makes it possible to skip a test function using the
    `SkipNow` method from type `testing.T`. The following source code snippet will
    only run the test function when the arbitrary operating system environment variable
    named `RUN_ANGLE` is set. Otherwise, it will skip the test:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时由于一些因素，如环境限制、资源可用性或不合适的环境设置，有必要跳过测试函数。测试 API 可以使用 `testing.T` 类型的 `SkipNow`
    方法来跳过测试函数。以下源代码片段只有在设置了名为 `RUN_ANGLE` 的任意操作系统环境变量时才会运行测试函数。否则，它将跳过测试：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice the code is using the `Skipf` method, which is a combination of the
    methods `SkipNow` and `Logf` from type `testing.T`. When the test is executed
    without the environment variable, it outputs the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码使用了 `Skipf` 方法，这是 `testing.T` 类型的 `SkipNow` 和 `Logf` 方法的组合。当测试在没有环境变量的情况下执行时，输出如下：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the environment variable is provided, as is done with the following Linux/Unix
    command, the test executes as expected (consult your OS on how to set environment
    variables):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供环境变量时，如下面的 Linux/Unix 命令所示，测试会按预期执行（请参考您的操作系统如何设置环境变量）：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Table-driven tests
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表驱动测试
- en: 'One technique you often encounter in Go is the use of table-driven tests. This
    is where a set of input and expected output is stored in a data structure, which
    is then used to cycle through different test scenarios. For instance, in the following
    test function, the `cases` variable, of type `[]struct{vec SimpleVector; expected
    float64}`, to store several vector values and their expected magnitude values
    used to test the vector method `Mag`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中经常遇到的一种技术是使用表驱动测试。这是指一组输入和期望的输出存储在一个数据结构中，然后用于循环执行不同的测试场景。例如，在下面的测试函数中，`cases`
    变量的类型为 `[]struct{vec SimpleVector; expected float64}`，用于存储多个矢量值及其预期的大小值，以测试矢量方法
    `Mag`：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: golang.fyi/ch12/vector/vec.go
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec.go
- en: With each iteration of the loop, the code tests the value calculated by the
    `Mag` method against an expected value. Using this approach, we can test several
    combinations of input and their respective output, as is done in the preceding
    code. This technique can be expanded as necessary to include more parameters.
    For instance, a name field can be used to name each case, which is useful when
    the number of test cases is large. Or, to be even more fancy, one can include
    a function field in the test case struct to specify custom logic to use for each
    respective case.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的每次迭代中，代码都会测试 `Mag` 方法计算出的值与预期值。使用这种方法，我们可以测试多种输入组合及其相应的输出，就像前面的代码所做的那样。这种技术可以根据需要扩展，以包括更多的参数。例如，可以使用一个名称字段来为每个案例命名，在测试案例数量较多时非常有用。或者，更加花哨的是，可以在测试案例结构中包含一个函数字段，用于指定每个相应案例使用的自定义逻辑。
- en: HTTP testing
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 测试
- en: In [Chapter 11](ch11.html "Chapter 11. Writing Networked Services"), *Writing
    Networked Services*, we saw that Go offers first-class APIs to build client and
    server programs using HTTP. The `net/http/httptest` sub-package, part of the Go
    standard library, facilitates the testing automation of both HTTP server and client
    code, as discussed in this section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ch11.html "第11章。编写网络服务")中，*编写网络服务*，我们看到 Go 提供了一流的 API 来使用 HTTP 构建客户端和服务器程序。`net/http/httptest`
    子包是 Go 标准库的一部分，它便于对 HTTP 服务器和客户端代码进行测试自动化，正如本节所讨论的那样。
- en: 'To explore this space, we will implement a simple API service that exposes
    the vector operations (covered in earlier sections) as HTTP endpoints. For instance,
    the following source snippet partially shows the methods that make up the server
    (for a complete listing, see [https://github.com/vladimirvivien/learning-go/ch12/service/serv.go](https://github.com/vladimirvivien/learning-go/ch12/service/serv.go)):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这个领域，我们将实现一个简单的 API 服务，该服务将矢量操作（在前面的章节中介绍）作为 HTTP 端点暴露出来。例如，以下源代码片段部分显示了构成服务器的方法（完整列表请参见
    [https://github.com/vladimirvivien/learning-go/ch12/service/serv.go](https://github.com/vladimirvivien/learning-go/ch12/service/serv.go)）：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: golang.fyi/ch12/service/serv.go
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/service/serv.go
- en: Each function (`add`, `sub`, `dotprod`, `mag`, and `unit`) implements the `http.Handler`
    interface. The functions are used to handle HTTP requests from the client to calculate
    the respective operations from the `vector` package. Both requests and responses
    are formatted using JSON for simplicity.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数（`add`、`sub`、`dotprod`、`mag`和`unit`）都实现了`http.Handler`接口。这些函数用于处理来自客户端的HTTP请求，以计算`vector`包中的相应操作。请求和响应都使用JSON格式进行格式化，以简化操作。
- en: Testing HTTP server code
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试HTTP服务器代码
- en: 'When writing HTTP server code, you will undoubtedly run into the need to test
    your code, in a robust and repeatable manner, without having to set up some fragile
    code harness to simulate end-to-end testing. Type `httptest.ResponseRecorder`
    is designed specifically to provide unit testing capabilities for exercising the
    HTTP handler methods by inspecting state changes to the http.ResponseWriter in
    the tested function. For instance, the following snippet uses `httptest.ResponseRecorder`
    to test the server''s `add` method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 编写HTTP服务器代码时，您无疑会遇到需要以稳健且可重复的方式测试代码的需求，而无需设置一些脆弱的代码来模拟端到端测试。`httptest.ResponseRecorder`类型专门设计用于通过检查测试函数中对`http.ResponseWriter`的状态更改来提供单元测试功能。例如，以下代码片段使用`httptest.ResponseRecorder`来测试服务器的`add`方法：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code uses `reg, err := http.NewRequest("POST", "http://0.0.0.0/", strings.NewReader(reqBody))`
    to create a new `*http.Request` value with a `"POST"` method, a fake URL, and
    a request body, variable `reqBody`, encoded as a JSON array. Later in the code,
    `w := httptest.NewRecorder()` is used to create an `httputil.ResponseRecorder`
    value, which is used to invoke the `add(w, req)` function along with the created
    request. The value recorded in `w`, during the execution of function `add`, is
    compared with expected value stored in `atual` with `if actual.String() != strings.TrimSpace(w.Body.String()){...}.`
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`reg, err := http.NewRequest("POST", "http://0.0.0.0/", strings.NewReader(reqBody))`创建一个新的`*http.Request`值，其中包括`"POST"`方法、一个虚假的URL和一个请求主体`reqBody`，编码为JSON数组。代码中后来使用`w
    := httptest.NewRecorder()`创建一个`httputil.ResponseRecorder`值，用于调用`add(w, req)`函数以及创建的请求。在执行`add`函数期间记录在`w`中的值与存储在`atual`中的预期值进行比较，`if
    actual.String() != strings.TrimSpace(w.Body.String()){...}`。
- en: Testing HTTP client code
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试HTTP客户端代码
- en: Creating test code for an HTTP client is more involved, since you actually need
    a server running for proper testing. Luckily, package `httptest` provides type
    `httptest.Server` to programmatically create servers to test client requests and
    send back mock responses to the client.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为HTTP客户端创建测试代码更为复杂，因为实际上需要运行服务器进行适当的测试。幸运的是，`httptest`包提供了类型`httptest.Server`，可以以编程方式创建服务器，以测试客户端请求并向客户端发送模拟响应。
- en: 'To illustrate, let us consider the following code, which partially shows the
    implementation of an HTTP client to the vector server presented earlier (see the
    full code listing at [https://github.com/vladimirvivien/learning-go/ch12/client/client.go](https://github.com/vladimirvivien/learning-go/ch12/client/client.go)).
    The `add` method encodes the parameters `vec0` and `vec2` of type `vector.SimpleVector`
    as JSON objects, which are sent to the server using `c.client.Do(req)`. The response
    is decoded from the JSON array into type `vector.SimpleVector` assigned to variable
    `result`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们考虑以下代码，它部分展示了早些时候介绍的向矢量服务器实现HTTP客户端的代码（请参阅完整的代码清单[https://github.com/vladimirvivien/learning-go/ch12/client/client.go](https://github.com/vladimirvivien/learning-go/ch12/client/client.go)）。`add`方法将类型为`vector.SimpleVector`的参数`vec0`和`vec2`编码为JSON对象，然后使用`c.client.Do(req)`将其发送到服务器。响应从JSON数组解码为类型为`vector.SimpleVector`的变量`result`：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: golang.fyi/ch12/client/client.go
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/client/client.go
- en: We can use type `httptest.Server` to create code to test the requests sent by
    a client and to return data to the client code for further inspection. Function
    `httptest.NewServer` takes a value of type `http.Handler`, where the test logic
    for the server is encapsulated. The function then returns a new running HTTP server
    ready to serve on a system-selected port.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类型`httptest.Server`创建用于测试客户端发送的请求并将数据返回给客户端代码以进行进一步检查的代码。函数`httptest.NewServer`接受类型为`http.Handler`的值，其中封装了服务器的测试逻辑。然后该函数返回一个新的运行中的HTTP服务器，准备在系统选择的端口上提供服务。
- en: 'The following test function shows how to use `httptest.Server` to exercise
    the `add` method from the client code presented earlier. Notice that when creating
    the server, the code uses type `http.HandlerFunc`, which is an adapter that takes
    a function value to produce an `http.Handler`. This convenience allows us to skip
    the creation of a separate type to implement a new `http.Handler`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试函数显示了如何使用`httptest.Server`来执行先前介绍的客户端代码中的`add`方法。请注意，创建服务器时，代码使用了类型`http.HandlerFunc`，这是一个适配器，它接受函数值以生成`http.Handler`。这种便利性使我们能够跳过创建一个单独的类型来实现新的`http.Handler`：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: golang.fyi/ch12/client/client_test.go
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/client/client_test.go
- en: The test function first sets up the `server` along with its handler function.
    Inside the function of `http.HandlerFunc`, the code first ensures that the client
    requests the proper path of `"/vec/add"`. Next, the code inspects the request
    body from the client, ensuring proper JSON format and valid parameters for the
    add operation. Finally, the handler function encodes the expected result as JSON
    and sends it as a response to the client.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数首先设置`server`及其处理函数。在`http.HandlerFunc`的函数内部，代码首先确保客户端请求了`"/vec/add"`的正确路径。接下来，代码检查来自客户端的请求主体，确保JSON格式正确，并且对于添加操作是有效的参数。最后，处理程序函数将期望的结果编码为JSON，并将其作为响应发送给客户端。
- en: The code uses the system-generated `server` address to create a new `client`
    with `newVecClient(server.URL)`. Method call `client.add(vector.New(1, 2), vector.New(3,
    4))` sends a request to the test server to calculate the vector addition of the
    two values in its parameter list. As shown earlier, the test server merely simulates
    the real server code and returns the calculated vector value. The `result` is
    inspected against the `expected` value to ensure proper working of the `add` method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用系统生成的`server`地址创建一个新的`client`，并使用`newVecClient(server.URL)`。方法调用`client.add(vector.New(1,
    2), vector.New(3, 4))`发送一个请求到测试服务器，计算其参数列表中两个值的向量加法。如前所示，测试服务器仅模拟真实服务器代码，并返回计算的向量值。检查`result`与`expected`值以确保`add`方法的正常工作。
- en: Test coverage
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: When writing tests, it is often important to know how much of the actual code
    is getting exercised (or covered) by the tests. That number is an indication of
    the penetration of the test logic against the source code. Whether you agree or
    not, in many software development practices, test coverage is a critical metric
    as it is a measure of how well the code is tested.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，了解实际代码有多少被测试覆盖通常很重要。这个数字是测试逻辑对源代码的渗透程度的指示。无论您是否同意，在许多软件开发实践中，测试覆盖率都是一个关键指标，因为它衡量了代码测试的程度。
- en: 'Fortunately, the Go test tool comes with a built-in coverage tool. Running
    the Go test command with the `-cover` flag instruments the original source code
    with coverage logic. It then runs the generated test binary, providing a summary
    of the overall coverage profile of the package, as shown in the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go测试工具自带了一个内置的覆盖工具。使用`-cover`标志运行Go测试命令会为原始源代码添加覆盖逻辑。然后运行生成的测试二进制文件，提供包的整体覆盖率概要，如下所示：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The result shows a well-tested code with a coverage number of `87.8%`. We can
    use the test tool to extract more details about the section of the code that is
    tested. To do this, we use the `-coverprofile` flag to record coverage metrics
    to a file, as shown:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了一个覆盖率为`87.8%`的经过充分测试的代码。我们可以使用测试工具提取有关已测试代码部分的更多详细信息。为此，我们使用`-coverprofile`标志将覆盖率指标记录到文件中，如下所示：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The cover tool
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖工具
- en: 'Once the coverage data is saved, it can be presented in a textual tab-formatted
    table using the `go tool cover` command. The following shows a partial output
    of the breakdown of the coverage metrics for each tested function in the coverage
    file generated previously:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 保存覆盖数据后，可以使用`go tool cover`命令以文本制表格式表格的形式呈现。以下显示了先前生成的覆盖文件中每个测试函数的覆盖指标的部分输出：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `cover` tool can overlay the coverage metrics over the actual code, providing
    a visual aid to show the covered (and uncovered) portion of the code. Use the
    `-html` flag to generate an HTML page using the coverage data gathered previously:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`cover`工具可以将覆盖率指标叠加在实际代码上，提供视觉辅助，显示代码的覆盖（和未覆盖）部分。使用`-html`标志生成使用先前收集的覆盖数据的HTML页面：'
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The command opens the installed default web browser and displays the coverage
    data, as shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令打开已安装的默认Web浏览器，并显示覆盖数据，如下截图所示：
- en: '![The cover tool](img/image_12_001.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![覆盖工具](img/image_12_001.jpg)'
- en: The preceding screenshot shows only a portion of the generated HTML page. It
    shows covered code in green and code that is not covered in red. Anything else
    is displayed in gray.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图只显示了生成的HTML页面的一部分。它显示覆盖的代码为绿色，未覆盖的代码为红色。其他任何内容显示为灰色。
- en: Code benchmark
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码基准
- en: 'The purpose of benchmarking is to measure a code''s performance. The Go test
    command-line tool comes with support for the automated generation and measurement
    of benchmark metrics. Similar to unit tests, the test tool uses benchmark functions
    to specify what portion of the code to measure. The benchmark function uses the
    following function naming pattern and signature:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的目的是衡量代码的性能。Go测试命令行工具支持自动生成和测量基准指标。与单元测试类似，测试工具使用基准函数来指定要测量的代码部分。基准函数使用以下函数命名模式和签名：
- en: '*func Benchmark<Name>(*testing.B)*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*func Benchmark<Name>(*testing.B)*'
- en: 'Benchmark functions are expected to have names that start with *benchmark*
    and accept a pointer value of type `*testing.B`. The following shows a function
    that benchmarks the `Add` method for type `SimpleVector` (introduced earlier):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 基准函数的名称应以*benchmark*开头，并接受类型为`*testing.B`的指针值。以下显示了一个基准`SimpleVector`类型的`Add`方法的函数（之前介绍过）：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch12/vector/vec_bench_test.go
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec_bench_test.go
- en: Go's test runtime invokes the benchmark functions by injecting pointer `*testing.B`
    as a parameter. That value defines methods for interacting with the benchmark
    framework such as logging, failure-signaling, and other functionalities similar
    to type `testing.T`. Type `testing.B` also offers additional benchmark-specific
    elements, including an integer field `N`. It is intended to be the number of iterations
    that the benchmark function should use for effective measurements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Go的测试运行时通过将指针`*testing.B`注入为参数来调用基准函数。该值定义了与基准框架交互的方法，如日志记录、失败信号和其他类似于类型`testing.T`的功能。类型`testing.B`还提供了额外的基准特定元素，包括整数字段`N`。它旨在是基准函数应使用的迭代次数的数量。
- en: The code being benchmarked should be placed within a `for` loop bounded by `N`,
    as illustrated in the previous example. For the benchmark to be effective, there
    should be no variances in the size of the input for each iteration of the loop.
    For instance, in the preceding benchmark, each iteration always uses a vector
    of size `2` (while the actual values of the vectors are randomized).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 被基准测试的代码应放在一个由`N`限定的`for`循环中，如前面的示例所示。为了使基准有效，每次循环迭代的输入大小不应有变化。例如，在前面的基准测试中，每次迭代始终使用大小为`2`的向量（虽然向量的实际值是随机的）。
- en: Running the benchmark
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行基准
- en: 'Benchmark functions are not executed unless the test command-line tool receives
    the flag `-bench`. The following command runs all the benchmarks functions in
    the current package:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除非测试命令行工具接收到 `-bench` 标志，否则不会执行基准测试函数。以下命令在当前包中运行所有基准测试函数：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Before dissecting the benchmark result, let us understand the previously issued
    command. The `go test -bench=.` command first executes all the test functions
    in the package followed by all the benchmark functions (you can verify this by
    adding the verbose flag `-v` to the command).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在剖析基准测试结果之前，让我们了解先前发出的命令。`go test -bench=.` 命令首先执行包中的所有测试函数，然后执行所有基准测试函数（您可以通过在命令中添加
    `-v` 标志来验证这一点）。
- en: 'Similar to the `-run` flag, the `-bench` flag specifies a regular expression
    used to select the benchmark functions that get executed. The `-bench=.` flag
    matches the name of all benchmark functions, as shown in the previous example.
    The following, however, only runs benchmark functions that contain the pattern
    `"VectorA"` in their names. This includes the `BenchmarkVectroAngle()` and `BenchmarkVectorAngle()` functions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `-run` 标志类似，`-bench` 标志指定了一个正则表达式，用于选择要执行的基准测试函数。`-bench=.` 标志匹配所有基准测试函数的名称，就像前面的示例中所示的那样。然而，以下示例只运行包含其名称中包含模式
    `"VectorA"` 的基准测试函数。这包括 `BenchmarkVectroAngle()` 和 `BenchmarkVectorAngle()` 函数：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Skipping test functions
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过测试函数
- en: 'As mentioned previously, when benchmarks are executed, the test tool will also
    run all test functions. This may be undesirable, especially if you have a large
    number of tests in your package. A simple way to skip the test functions during
    benchmark execution is to set the `-run` flag to a value that matches no test
    functions, as shown in the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当执行基准测试时，测试工具还将运行所有测试函数。这可能是不希望的，特别是如果您的包中有大量测试。在基准测试执行期间跳过测试函数的一个简单方法是将
    `-run` 标志设置为与没有测试函数匹配的值，如下所示：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The previous command only executes benchmark functions, as shown by the partial
    verbose output. The value of the `-run` flag is completely arbitrary and can be
    set to any value that will cause it to skip the execution of test functions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令只执行基准测试函数，如部分冗长输出所示。`-run` 标志的值是完全任意的，可以设置为任何值，使其跳过执行测试函数。
- en: The benchmark report
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试报告
- en: 'Unlike tests, a benchmark report is always verbose and displays several columns
    of metrics, as shown in the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试不同，基准测试报告始终是冗长的，并显示了几列度量标准，如下所示：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first column contains the names of the benchmark functions, with each name
    suffixed with a number that reflects the value of *GOMAXPROCS*, which can be set
    at test time using the `-cpu` flag (relevant for running benchmarks in parallel).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列包含基准测试函数的名称，每个名称都以一个反映 *GOMAXPROCS* 值的数字作为后缀，可以使用 `-cpu` 标志在测试时设置（用于并行运行基准测试）。
- en: The next column displays the number of iterations for each benchmark loop. For
    instance, in the previous report, the first two benchmark functions looped 2 million
    times, while the final benchmark function iterated 5 million times. The last column
    of the report shows the average time it takes to execute the tested function.
    For instance, the 5 million calls to the `Scale` method executed in benchmark
    function `BenchmarkVectorScale` took on average 266 nanoseconds to complete.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一列显示了每个基准测试循环的迭代次数。例如，在前面的报告中，前两个基准测试函数循环了 200 万次，而最后一个基准测试函数迭代了 500 万次。报告的最后一列显示了执行测试函数所需的平均时间。例如，对
    `Scale` 方法的 500 万次调用在基准测试函数 `BenchmarkVectorScale` 中平均需要 266 纳秒才能完成。
- en: Adjusting N
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整 N
- en: 'By default, the test framework gradually adjusts `N` to be large enough to
    arrive at stable and meaningful metrics over a period of *one second*. You cannot
    change `N` directly. However, you can use flag `-benchtime` to specify a benchmark
    run time and thus influence the number of iterations during a benchmark. For instance,
    the following runs the benchmark for a period of `5` seconds:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，测试框架会逐渐调整 `N` 的大小，以便在 *一秒* 的时间内获得稳定和有意义的度量标准。您不能直接更改 `N`。但是，您可以使用 `-benchtime`
    标志指定基准测试运行时间，从而影响基准测试期间的迭代次数。例如，以下示例运行基准测试 `5` 秒：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that even though there is a drastic jump in the number iterations (factor
    of five or more) for each benchmark, the average performance time for each benchmark
    function remains reasonably consistent. This information provides valuable insight
    into the performance of your code. It is a great way to observe the impact of
    code or load changes on performance, as discussed in the following section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使每个基准测试的迭代次数有很大的跳跃（每个基准测试的迭代次数增加了五倍或更多），每个基准测试函数的平均性能时间仍然保持相当一致。这些信息为您的代码的性能提供了宝贵的见解。这是观察代码或负载变化对性能的影响的好方法，如下一节所讨论的。
- en: Comparative benchmarks
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较基准测试
- en: Another useful aspect of benchmarking code is to compare the performance of
    different algorithms that implement similar functionalities. Exercising the algorithms
    using performance benchmarks will indicate which of the implementations may be
    more compute- and memory-efficient.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试代码的另一个有用方面是比较实现类似功能的不同算法的性能。使用性能基准测试来运行算法将表明哪种实现可能更具计算和内存效率。
- en: 'For instance, two vectors are said to be equal if they have the same magnitude
    and same direction (or have an angle value of zero between them). We can implement
    this definition using the following source snippet:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果两个向量的大小和方向相同（或它们之间的角度值为零），则它们被认为是相等的。我们可以使用以下源代码片段来实现这个定义：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: golang.fyi/ch12/vector/vec.go
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec.go
- en: 'When the preceding method is benchmarked, it yields to the following result.
    Each of its 3 million iterations takes an average of half a millisecond to run:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当对前述方法进行基准测试时，将得到以下结果。它的 300 万次迭代平均需要半毫秒才能运行：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The benchmark result is not bad, especially when compared to the other benchmarked
    methods that we saw earlier. However, suppose we want to improve on the performance
    of the `Eq` method (maybe because it is a critical part of a program). We can
    use the `-benchmem` flag to get additional information about the benchmarked test:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 基准结果并不差，特别是与我们之前看到的其他基准方法相比。然而，假设我们想要改进`Eq`方法的性能（也许因为它是程序的关键部分）。我们可以使用`-benchmem`标志来获取有关基准测试的额外信息：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `-benchmem` flag causes the test tool to reveal two additional columns,
    which provide memory allocation metrics, as shown in the previous output. We see
    that the `Eq` method allocates a total of 48 bytes, with two allocations calls
    per operation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`-benchmem`标志会导致测试工具显示两个额外的列，提供内存分配指标，如前面的输出所示。我们看到`Eq`方法总共分配了48字节，每个操作调用两次分配。'
- en: 'This does not tell us much until we have something else to compare it to. Fortunately,
    there is another equality algorithm that we can try. It is based on the fact that
    two vectors are also equal if they have the same number of elements and each element
    is equal. This definition can be implemented by traversing the vector and comparing
    its elements, as is done in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有告诉我们太多，直到我们有其他东西可以进行比较。幸运的是，我们还有另一种相等算法可以尝试。它基于这样一个事实，即如果两个向量具有相同数量的元素，并且每个元素相等，那么它们也是相等的。这个定义可以通过遍历向量并比较其元素来实现，就像在下面的代码中所做的那样：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: golang.fyi/ch12/vector/vec.go
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch12/vector/vec.go
- en: 'Now let us benchmark the `Eq` and `Eq2` equality methods to see which is more
    performant, as done in the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对`Eq`和`Eq2`相等方法进行基准测试，看看哪个性能更好，就像下面所做的那样：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: According to the benchmark report, method `Eq2` is more performant of the two
    equality methods. It runs in about half the time of the original method, with
    considerably less memory allocated. Since both benchmarks run with similar input
    data, we can confidently say the second method is a better choice than the first.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 根据基准报告，方法`Eq2`是这两种相等方法中性能更好的。它的运行时间大约是原始方法的一半，分配的内存要少得多。由于两个基准测试使用类似的输入数据，我们可以自信地说第二种方法比第一种更好。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on Go version and machine size and architecture, these benchmark numbers
    will vary. However, the result will always show that the Eq2 method is more performant.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Go版本和机器大小和架构，这些基准数字会有所不同。然而，结果总是会显示Eq2方法的性能更好。
- en: This discussion only scratches the surface of comparative benchmarks. For instance,
    the previous benchmark tests use the same size input. Sometimes it is useful to
    observe the change in performance as the input size changes. We could have compared
    the performance profile of the equality method as we change the size of the input,
    say, from 3, 10, 20, or 30 elements. If the algorithm is sensitive size, expanding
    the benchmark using such attributes will reveal any bottlenecks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这次讨论只是对比基准的皮毛。例如，先前的基准测试使用相同大小的输入。有时观察性能随输入大小变化的变化是有用的。我们可以比较相等方法的性能配置文件，比如当输入大小从3、10、20或30个元素变化时。如果算法对大小敏感，扩展基准测试使用这些属性将揭示任何瓶颈。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter provided a broad introduction to the practice of writing tests
    in Go. It discussed several key topics, including the use of the `go test` tool
    to compile and execute automated tests. Readers learned how to write test functions
    to ensure their code is properly tested and covered. The chapter also discussed
    the topic of testing HTTP clients and servers. Finally, the chapter introduced
    the topic of benchmarking as a way to automate, analyze, and measure code performance
    using built-in Go tools.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在Go中编写测试的实践的广泛介绍。它讨论了几个关键主题，包括使用`go test`工具来编译和执行自动化测试。读者学会了如何编写测试函数来确保他们的代码得到适当的测试和覆盖。本章还讨论了测试HTTP客户端和服务器的主题。最后，本章介绍了使用内置的Go工具自动化、分析和衡量代码性能的基准测试主题。
