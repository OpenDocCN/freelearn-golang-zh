# 第一章。介绍和设置 Go

开始使用 Go 时，您最常听到的一句话是它是一种系统语言。

事实上，Go 团队早期对 Go 的描述之一是，该语言是为了成为一种现代系统语言而构建的。它旨在将诸如 C 之类的语言的速度和功能与诸如 Python 之类的现代解释语言的语法优雅和节俭相结合。当您查看 Go 代码的一些片段时，您可以看到这个目标得以实现。

从 Go FAQ 中关于为什么创建 Go 的原因：

> *"Go 是出于对现有语言和系统编程环境的不满而诞生的。"*

也许当今系统编程的最大部分是设计后端服务器。显然，网络构成了其中的一个巨大但并非是唯一的部分。

直到最近，Go 还没有被认为是一种 Web 语言。毫不奇怪，开发人员花了几年时间涉足、试验，最终拥抱这种语言，开始将其引向新的领域。

虽然 Go 可以直接用于 Web，但它缺少许多人们在 Web 开发中经常视为理所当然的关键框架和工具。随着围绕 Go 的社区的增长，支架开始以许多新颖和令人兴奋的方式显现。结合现有的辅助工具，Go 现在是端到端 Web 开发的完全可行选择。但回到最初的问题：为什么选择 Go？公平地说，它并不适合每个 Web 项目，但任何可以从内置高性能、安全的 Web 服务以及美丽的并发模型的附加优势中受益的应用程序都是一个很好的选择。

在本书中，我们将探讨这些方面和其他方面，以概述 Go 是您的 Web 架构和应用程序的正确语言的原因。

我们不会涉及 Go 语言的许多低级方面。例如，我们假设您熟悉变量和常量声明。我们假设您了解控制结构。

在本章中，我们将涵盖以下主题：

+   安装 Go

+   项目结构

+   导入软件包

+   介绍 net 包

+   你好，Web

# 安装 Go

当然，最关键的第一步是确保 Go 可用并准备好启动我们的第一个 Web 服务器。

### 注意

虽然 Go 最大的卖点之一是其跨平台支持（在本地构建和使用时针对其他操作系统），但在 Nix 兼容平台上，您的生活会变得更加轻松。

如果您使用 Windows，不要害怕。在本地，您可能会遇到不兼容的软件包、使用`go run`命令时的防火墙问题以及其他一些怪癖，但 Go 生态系统的 95%将对您可用。您也可以非常容易地运行虚拟机，事实上，这是模拟潜在生产环境的一个很好的方法。

在[`golang.org/doc/install`](https://golang.org/doc/install)上提供了深入的安装说明，但在继续之前我们将在这里讨论一些古怪的地方。

对于 OS X 和 Windows，Go 作为二进制安装包的一部分提供。对于任何具有软件包管理器的 Linux 平台，事情可能会变得非常简单。

### 注意

**通过常见的 Linux 软件包管理器安装：**

Ubuntu：`sudo apt-get golang`

CentOS：`sudo yum install golang`

在 OS X 和 Linux 上，您需要将几行添加到您的路径中——`GOPATH`和`PATH`。首先，您需要找到 Go 二进制安装的位置。这因发行版而异。找到后，您可以配置`PATH`和`GOPATH`，如下所示：

```go
export PATH=$PATH:/usr/local/go/bin
export GOPATH="/usr/share/go"

```

虽然要使用的路径没有严格定义，但一些惯例已经形成，即从用户的主目录下的子目录开始，例如`$HOME/go`或`~Home/go`。只要这个位置被永久设置并且不改变，您就不会遇到冲突或缺少软件包的问题。

您可以通过运行`go env`命令来测试这些更改的影响。如果您在此方面遇到任何问题，这意味着您的目录不正确。

请注意，这可能不会阻止 Go 运行——这取决于 GOBIN 目录是否正确设置——但会阻止您在整个系统上全局安装软件包。

要测试安装，您可以通过`go get`命令获取任何 Go 软件包，并在某个地方创建一个 Go 文件。作为一个快速的例子，首先随机获取一个软件包，我们将使用 Gorilla 框架的一个软件包，因为我们将在本书中经常使用它。

```go
go get github.com/gorilla/mux

```

如果这一切顺利进行，Go 将正确找到您的`GOPATH`。为了确保 Go 能够访问您下载的软件包，请编写一个非常快速的软件包，该软件包将尝试使用 Gorilla 的 mux 软件包并运行它以验证软件包是否被找到。

```go
package main

import (
  "fmt"
  "github.com/gorilla/mux"
  "net/http"
)

func TestHandler(w http.ResponseWriter, r *http.Request) {

}

func main() {
  router := mux.NewRouter()
  router.HandleFunc("/test", TestHandler)
  http.Handle("/", router)
  fmt.Println("Everything is set up!")
}
```

在命令行中运行`go run test.go`。它不会做太多事情，但会像下面的截图所示一样传递好消息：

![安装 Go](img/B04294_01_01.jpg)

# 项目结构

当您刚开始并且大多数时间都在玩耍时，将应用程序设置为懒惰运行是没有问题的。

例如，为了尽快开始，您可以在任何喜欢的地方创建一个简单的`hello.go`文件，并且无需编译问题。

但是，当您进入需要多个或不同软件包（稍后会详细介绍）或具有更明确的跨平台要求的环境时，设计项目的方式以便利用 go 构建工具是有意义的。

以这种方式设置代码的价值在于 go 构建工具的工作方式。如果您有本地（针对您的项目）软件包，构建工具将首先查找`src`目录，然后查找您的`GOPATH`。当您为其他平台构建时，go build 将利用本地 bin 文件夹来组织二进制文件。

构建用于大规模使用的软件包时，您可能会发现在`GOPATH`目录下启动应用程序，然后将其符号链接到另一个目录，或者反过来，都可以让您在不需要随后获取自己的代码的情况下进行开发。

## 代码约定

与任何语言一样，成为 Go 社区的一部分意味着不断考虑他人创建代码的方式。特别是如果您要在开源存储库中工作，您将希望以其他人的方式生成代码，以减少其他人获取或包含您的代码时的摩擦量。

Go 团队包含的一个非常有用的工具是`go fmt`。这里的`fmt`当然是格式，这正是这个工具所做的，它会根据设计的约定自动格式化您的代码。

通过强制执行样式约定，Go 团队已经帮助减轻了许多其他语言中存在的最常见和普遍的争论之一。

虽然语言社区倾向于推动编码约定，但个人编写程序的方式总是有一些小怪癖。让我们使用一个最常见的例子——在哪里放开括号。

有些程序员喜欢将其放在与语句相同的一行上：

```go
for (int i = 0; i < 100; i++) {
  // do something
}
```

而其他人则更喜欢将其放在随后的一行上：

```go
for (int i = 0; i < 100; i++)
{
  // do something
}
```

这些微小的差异引发了重大的、近乎宗教性的争论。Gofmt 工具通过允许您遵循 Go 的指令来帮助缓解这一问题。

现在，Go 通过将您的代码格式化为前面讨论过的后一种样式来绕过这个明显的争议源。编译器会抱怨，您将得到一个致命错误。但其他样式选择具有一定的灵活性，这在您使用该工具进行格式化时会得到执行。

例如，这是一个在`go fmt`之前的 Go 代码片段：

```go
func Double(n int) int {

  if (n == 0) {
    return 0
  } else {
    return n * 2
  }
}
```

任意的空白可能是团队在共享和阅读代码时的噩梦，特别是当每个团队成员使用的 IDE 不同的时候。

通过运行`go fmt`，我们可以清理这些内容，从而根据 Go 的约定转换我们的空白：

```go
func Double(n int) int {
  if n == 0 {
    return 0
  } else {
    return n * 2
  }
}
```

长话短说：在发布或推送代码之前，始终运行`go fmt`。

# 导入包

除了绝对和最琐碎的应用程序之外——即连**Hello World**输出都不能产生的应用程序——您必须在 Go 应用程序中导入一些包。

举个例子，要说**Hello World**，我们需要一种生成输出的方式。与许多其他语言不同，即使核心语言库也可以通过命名空间包访问。在 Go 中，命名空间由存储库终端点 URL 处理，即[github.com/nkozyra/gotest](http://github.com/nkozyra/gotest)，可以直接在 GitHub（或任何其他公共位置）上进行审查。

## 处理私有存储库

go get 工具可以轻松处理托管在仓库中的包，例如 GitHub、Bitbucket 和 Google Code（以及其他一些）。您还可以在其他地方托管自己的项目，理想情况下是一个 git 项目，尽管这可能会引入一些依赖和错误源，您可能希望避免。

但私有存储库呢？虽然 go get 是一个很好的工具，但如果没有一些额外的配置、SSH 代理转发等，您会发现自己面临错误。

您可以通过几种方法解决这个问题，但一个非常简单的方法是直接在本地克隆存储库，使用您的版本控制软件。

## 处理版本控制

当您阅读关于 Go 应用程序中命名空间的定义和导入方式时，您可能会停顿。如果您正在使用应用程序的版本 1，但想引入版本 2 会发生什么？在大多数情况下，这必须在`import`的路径中明确定义。例如：

```go
import (
  "github.com/foo/foo-v1"
)
```

与之相对：

```go
import (
  "github.com/foo/foo-v2"
)
```

正如您所想象的那样，这可能是 Go 处理远程包的一个特别棘手的方面。

与许多其他包管理器不同，go get 是去中心化的——也就是说，没有人维护包和版本的官方参考库。这有时可能会让新开发人员感到头疼。

在大多数情况下，包始终通过`go get`命令导入，该命令读取远程存储库的主分支。这意味着在同一终端点维护多个版本的包在大多数情况下是不可能的。

正是利用 URL 终端点作为命名空间，才实现了去中心化，但也导致了对版本控制的内部支持的缺乏。

作为开发人员，您最好将每个包视为执行`go get`命令时最新的版本。如果需要更新版本，您可以始终遵循作者决定的任何模式，例如前面的例子。

作为您自己包的创建者，请确保您也遵守这一理念。保持您的主分支 HEAD 最新将确保您的代码符合其他 Go 作者的约定。

# 介绍 net 包

在 Go 中，所有网络通信的核心是名为 net 的包，其中包含了非常相关的 HTTP 操作，以及其他 TCP/UDP 服务器、DNS 和 IP 工具的子包。

简而言之，您需要创建一个强大的服务器环境。

当然，我们关心的主要是`net/http`包，但我们将看一下其他一些使用该包的函数，比如 TCP 连接以及 WebSockets。

让我们快速看一下执行我们一直在谈论的 Hello World（或 Web，在这种情况下）示例。

# 你好，Web

以下应用程序作为位置`/static`的静态文件服务，并在位置`/dynamic`提供动态`response`：

```go
package main

import (
  "fmt"
  "net/http"
  "time"
)

const (
  Port = ":8080"
)

func serveDynamic(w http.ResponseWriter, r *http.Request) {
  response := "The time is now " + time.Now().String()
  fmt.Fprintln(w,response)
}
```

就像`fmt.Println`会在控制台级别产生所需的内容一样，`Fprintln`允许你将输出定向到任何写入器。我们将在第二章中更多地讨论写入器，*服务和路由*，但它们代表了一个在许多 Go 应用程序中使用的基本灵活接口，不仅仅是用于 Web：

```go
func serveStatic(w http.ResponseWriter, r *http.Request) {
  http.ServeFile(w, r, "static.html")
}
```

我们的`serveStatic`方法只服务一个文件，但可以轻松地允许它直接服务任何文件，并使用 Go 作为一个老式的 Web 服务器，只提供静态内容：

```go
func main() {
  http.HandleFunc("/static",serveStatic)
  http.HandleFunc("/",serveDynamic)
  http.ListenAndServe(Port,nil)
}
```

请随意选择可用的端口——较高的端口将更容易绕过内置的安全功能，特别是在 Nix 系统中。

如果我们采用上述示例并访问相应的 URL——在这种情况下是根目录`/`和静态页面`/static`，我们应该看到预期的输出如下所示：

在根目录`/`，输出如下：

![Hello, Web](img/B04294_01_02.jpg)

在`/static`，输出如下：

![Hello, Web](img/B04294_01_03.jpg)

正如你所看到的，用 Go 为 Web 制作一个非常简单的输出是非常简单的。内置的包允许我们只用几行代码就能在 Go 中创建一个基本但非常快速的网站。

这可能并不是很令人兴奋，但在我们能够奔跑之前，我们必须先学会走路。生成上述输出引入了一些关键概念。

首先，我们看到了`net/http`如何使用 URI 或 URL 端点将请求定向到必须实现`http.ResponseWriter`和`http.Request`方法的辅助函数。如果它们没有实现，我们会在那一端得到一个非常清晰的错误。

以下是一个尝试以这种方式实现的示例：

```go
func serveError() {
  fmt.Println("There's no way I'll work!")
}

func main() {
  http.HandleFunc("/static", serveStatic)
  http.HandleFunc("/", serveDynamic)
  http.HandleFunc("/error",serveError)
  http.ListenAndServe(Port, nil)
}
```

以下截图显示了 Go 返回的错误：

![Hello, Web](img/B04294_01_04.jpg)

你可以看到`serveError`没有包括所需的参数，因此导致编译错误。

# 总结

本章作为 Go 的最基本概念和在 Go 中为 Web 制作的介绍，但这些要点是语言和社区中的关键基础元素，对于提高生产力至关重要。

我们已经看过编码规范和包的设计和组织，我们也制作了我们的第一个程序——司空见惯的 Hello, World 应用程序——并通过本地主机访问了它。

显然，我们离真正成熟的网络应用还有很长的路要走，但构建基础是到达目标的关键。

在第二章中，*服务和路由*，我们将看看如何使用 Go 的内置路由功能以及一些第三方路由器包将不同的请求定向到不同的应用逻辑。
