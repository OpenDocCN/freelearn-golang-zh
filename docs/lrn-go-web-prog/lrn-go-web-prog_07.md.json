["```go\nimport (\n  \"bufio\"\n  \"crypto/rand\"\n  \"crypto/sha1\"\n  \"database/sql\"\n  \"encoding/base64\"\n  \"encoding/json\"\n  \"fmt\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"github.com/gorilla/mux\"\n  \"github.com/gorilla/sessions\"\n  \"github.com/streadway/amqp\"\n  \"html/template\"\n  \"io\"\n  \"log\"\n  \"net/http\"\n  \"regexp\"\n  \"text/template\"\n  \"time\"\n)\n```", "```go\nvar WelcomeTitle = \"You've successfully registered!\"\nvar WelcomeEmail = \"Welcome to our CMS, {{Email}}!  We're glad you could join us.\"\n```", "```go\nconst (\n  DBHost  = \"127.0.0.1\"\n  DBPort  = \":3306\"\n  DBUser  = \"root\"\n  DBPass  = \"\"\n  DBDbase = \"cms\"\n  PORT    = \":8080\"\n  MQHost  = \"127.0.0.1\"\n  MQPort  = \":5672\"\n)\n```", "```go\nfunc MQConnect() (*amqp.Connection, *amqp.Channel, error) {\n  url := \"amqp://\" + MQHost + MQPort\n  conn, err := amqp.Dial(url)\n  if err != nil {\n    return nil, nil, err\n  }\n  channel, err := conn.Channel()\n  if err != nil {\n    return nil, nil, err\n  }\n  if _, err := channel.QueueDeclare(\"\", false, true, false, false, nil); err != nil {\n    return nil, nil, err\n  }\n  return conn, channel, nil\n}\n```", "```go\ntype RegistrationData struct {\n  Email   string `json:\"email\"`\n  Message string `json:\"message\"`\n}\n```", "```go\n  res, err := database.Exec(\"INSERT INTO users SET user_name=?, user_guid=?, user_email=?, user_password=?\", name, guid, email, password)\n\n  if err != nil {\n    fmt.Fprintln(w, err.Error)\n  } else {\n    Email := RegistrationData{Email: email, Message: \"\"}\n    message, err := template.New(\"email\").Parse(WelcomeEmail)\n    var mbuf bytes.Buffer\n    message.Execute(&mbuf, Email)\n    MQPublish(json.Marshal(mbuf.String()))\n    http.Redirect(w, r, \"/page/\"+pageGUID, 301)\n  }\n```", "```go\nfunc MQPublish(message []byte) {\n  err = channel.Publish(\n    \"email\", // exchange\n    \"\",      // routing key\n    false,   // mandatory\n    false,   // immediate\n    amqp.Publishing{\n      ContentType: \"text/plain\",\n      Body:        []byte(message),\n    })\n}\n```", "```go\nimport pika\nimport json\nimport smtplib\nfrom email.mime.text import MIMEText\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters( host='localhost'))\nchannel = connection.channel()\nchannel.queue_declare(queue='email')\n\nprint ' [*] Waiting for messages. To exit press CTRL+C'\n\ndef callback(ch, method, properties, body):\n    print \" [x] Received %r\" % (body,)\n    parsed = json.loads(body)\n    msg = MIMEText()\n    msg['From'] = 'Me'\n    msg['To'] = parsed['email']\n    msg['Subject'] = parsed['message']\n    s = smtplib.SMTP('localhost')\n    s.sendmail('Me', parsed['email'], msg.as_string())\n    s.quit()\n\nchannel.basic_consume(callback,\n                      queue='email',\n                      no_ack=True)\n\nchannel.start_consuming()\n```"]