["```go\npackage main\n\nimport (\n  \"fmt\"\n  \"time\"\n)\n\ntype Job struct {\n  i int\n  max int\n  text string\n}\n\nfunc outputText(j *Job) {\n  for j.i < j.max {\n    time.Sleep(1 * time.Millisecond)\n    fmt.Println(j.text)\n    j.i++\n  }\n}\n\nfunc main() {\n  hello := new(Job)\n  world := new(Job)\n\n  hello.text = \"hello\"\n  hello.i = 0\n  hello.max = 3\n\n  world.text = \"world\"\n  world.i = 0\n  world.max = 5\n\n  go outputText(hello)\n  outputText(world)\n\n}\n```", "```go\n  go outputText(hello)\n  go outputText(world)\n```", "```go\nfor {}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"sync\"\n  \"time\"\n)\n\ntype Job struct {\n  i int\n  max int\n  text string\n}\n\nfunc outputText(j *Job, goGroup *sync.WaitGroup) {\n  for j.i < j.max {\n    time.Sleep(1 * time.Millisecond)\n    fmt.Println(j.text)\n    j.i++\n  }\n  goGroup.Done()\n}\n\nfunc main() {\n\n  goGroup := new(sync.WaitGroup)\n  fmt.Println(\"Starting\")\n\n  hello := new(Job)\n  hello.text = \"hello\"\n  hello.i = 0\n  hello.max = 2\n\n  world := new(Job)\n  world.text = \"world\"\n  world.i = 0\n  world.max = 2\n\n  go outputText(hello, goGroup)\n  go outputText(world, goGroup)\n\n  goGroup.Add(2)\n  goGroup.Wait()\n\n}\n```", "```go\n  goGroup := new(sync.WaitGroup)\n```", "```go\n  goGroup.Add(2)\n```", "```go\n  goGroup.Wait()\n```", "```go\nfunc outputText(j *Job, goGroup *sync.WaitGroup) {\n  for j.i < j.max {\n    time.Sleep(1 * time.Millisecond)\n    fmt.Println(j.text)\n    j.i++\n  }\n  goGroup.Done()\n}\n```", "```go\nx = file.open('test.txt')\nint longFunction() {\n\u2026\n}\nx.close();\n```", "```go\npackage main\n\nimport(\n\"os\"\n)\n\nfunc main() {\n\n  file, _ := os.Create(\"/defer.txt\")\n\n  defer file.Close()\n\n  for {\n\n    break\n\n  }\n\n}\n```", "```go\nfunc main() {\n\n  aValue := new(int)\n\n  defer fmt.Println(*aValue)\n\n  for i := 0; i < 100; i++ {\n    *aValue++\n  }\n\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"time\"\n  \"io/ioutil\"\n)\n\ntype Job struct {\n  i int\n  max int\n  text string\n}\n\nfunc outputText(j *Job) {\n  fileName := j.text + \".txt\"\n  fileContents := \"\"\n  for j.i < j.max {\n    time.Sleep(1 * time.Millisecond)\n    fileContents += j.text\n    fmt.Println(j.text)\n    j.i++\n  }\n  err := ioutil.WriteFile(fileName, []byte(fileContents), 0644)\n  if (err != nil) {\n    panic(\"Something went awry\")\n  }\n\n}\n\nfunc main() {\n\n  hello := new(Job)\n  hello.text = \"hello\"\n  hello.i = 0\n  hello.max = 3\n\n  world := new(Job)\n  world.text = \"world\"\n  world.i = 0\n  world.max = 5\n\n  go outputText(hello)\n  go outputText(world)\n\n}\n```", "```go\npackage main\n\nimport(\n  \"runtime\"\n  \"fmt\"\n)\n\nfunc showNumber(num int) {\n  fmt.Println(num)\n}\n\nfunc main() {\n  iterations := 10\n\n  for i := 0; i<=iterations; i++ {\n\n    go showNumber(i)\n\n  }\n  //runtime.Gosched()\n  fmt.Println(\"Goodbye!\")\n\n}\n```", "```go\nfunc main() {\n\n  runtime.GOMAXPROCS(2)\n```", "```go\n  tstamp := strconv.FormatInt(time.Now().UnixNano(), 10)\n  fmt.Println(num, tstamp)\n```", "```go\nfunc showNumber(num int) {\n  tstamp := strconv.FormatInt(time.Now().UnixNano(), 10)\n  fmt.Println(num,tstamp)\n  time.Sleep(time.Millisecond * 10)\n}\n```", "```go\n  runtime.GOMAXPROCS(0)\n  iterations := 10\n\n  for i := 0; i<=iterations; i++ {\n    showNumber(i)\n  }\n```", "```go\ngo showNumber(i)\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"runtime\"\n)\n\nfunc listThreads() int {\n\n  threads := runtime.GOMAXPROCS(0)\n  return threads\n}\n\nfunc main() {\n  runtime.GOMAXPROCS(2)\n  fmt.Printf(\"%d thread(s) available to Go.\", listThreads())\n\n}\n```", "```go\n2 thread(s) available to Go.\n\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"runtime\"\n  \"strings\"\n)\nvar loremIpsum string\nvar finalIpsum string\nvar letterSentChan chan string\n\nfunc deliverToFinal(letter string, finalIpsum *string) {\n  *finalIpsum += letter\n}\n\nfunc capitalize(current *int, length int, letters []byte, \n  finalIpsum *string) {\n  for *current < length {\n    thisLetter := strings.ToUpper(string(letters[*current]))\n\n    deliverToFinal(thisLetter, finalIpsum)\n    *current++\n  }\n}\n\nfunc main() {\n\n  runtime.GOMAXPROCS(2)\n\n  index := new(int)\n  *index = 0\n  loremIpsum = \"Lorem ipsum dolor sit amet, consectetur adipiscing \n  elit. Vestibulum venenatis magna eget libero tincidunt, ac \n  condimentum enim auctor. Integer mauris arcu, dignissim sit amet \n  convallis vitae, ornare vel odio. Phasellus in lectus risus. Ut \n  sodales vehicula ligula eu ultricies. Fusce vulputate fringilla \n  eros at congue. Nulla tempor neque enim, non malesuada arcu \n  laoreet quis. Aliquam eget magna metus. Vivamus lacinia \n  venenatis dolor, blandit faucibus mi iaculis quis. Vestibulum \n  sit amet feugiat ante, eu porta justo.\"\n\n  letters := []byte(loremIpsum)\n  length := len(letters)\n\n  go capitalize(index, length, letters, &finalIpsum)\n  go func() {\n    go capitalize(index, length, letters, &finalIpsum)\n  }()\n\n  fmt.Println(length, \" characters.\")\n  fmt.Println(loremIpsum)\n  fmt.Println(*index)\n  fmt.Println(finalIpsum)\n\n}\n```", "```go\npackage main\n\nimport(\n  \"fmt\"\n  \"sync\"\n  \"runtime\"\n  \"strings\"\n)\n\nvar initialString string\nvar finalString string\n\nvar stringLength int\n\nfunc addToFinalStack(letterChannel chan string, wg \n  *sync.WaitGroup) {\n  letter := <-letterChannel\n  finalString += letter\n  wg.Done()\n}\n\nfunc capitalize(letterChannel chan string, currentLetter string, \n  wg *sync.WaitGroup) {\n\n  thisLetter := strings.ToUpper(currentLetter)\n  wg.Done()\n  letterChannel <- thisLetter  \n}\n\nfunc main() {\n\n  runtime.GOMAXPROCS(2)\n  var wg sync.WaitGroup\n\n  initialString = \"Four score and seven years ago our fathers \n  brought forth on this continent, a new nation, conceived in \n  Liberty, and dedicated to the proposition that all men are \n  created equal.\"\n  initialBytes := []byte(initialString)\n\n  var letterChannel chan string = make(chan string)\n\n  stringLength = len(initialBytes)\n\n  for i := 0; i < stringLength; i++ {\n    wg.Add(2)\n\n    go capitalize(letterChannel, string(initialBytes[i]), &wg)\n    go addToFinalStack(letterChannel, &wg)\n\n    wg.Wait()\n  }\n\n  fmt.Println(finalString)\n\n}\n```", "```go\ngo run alpha-channel.go\nFOUR SCORE AND SEVEN YEARS AGO OUR FATHERS BROUGHT FORTH ON THIS \n CONTINENT, A NEW NATION, CONCEIVED IN LIBERTY, AND DEDICATED TO THE \n PROPOSITION THAT ALL MEN ARE CREATED EQUAL.\n\n```", "```go\nvar wg sync.WaitGroup\n...\nfor i := 0; i < stringLength; i++ {\n  wg.Add(2)\n\n  go capitalize(letterChannel, string(initialBytes[i]), &wg)\n  go addToFinalStack(letterChannel, &wg)\n\n  wg.Wait()\n}\n```", "```go\n  var letterChannel chan string = make(chan string)\n```", "```go\nletterChannel <- thisLetter\n```", "```go\npackage main\n\nfunc doNothing()(string) {\n\n  return \"nothing\"\n}\n\nfunc main() {\n\n  var channel chan string = make(chan string)\n  channel <- doNothing()\n\n}\n```", "```go\nswitch, familiar to Go users and common among other languages:\n```", "```go\nswitch {\n\n  case 'x':\n\n  case 'y':\n\n}\n```", "```go\nselect statement:\n```", "```go\nselect {\n\n  case <- channelA:\n\n  case <- channelB:\n\n}\n```", "```go\npackage main\n\nimport(\n  \"fmt\"  \n  \"strings\"\n)\n\nvar initialString string\nvar initialBytes []byte\nvar stringLength int\nvar finalString string\nvar lettersProcessed int\nvar applicationStatus bool\nvar wg sync.WaitGroup\n\nfunc getLetters(gQ chan string) {\n\n  for i := range initialBytes {\n    gQ <- string(initialBytes[i])  \n\n  }\n\n}\n\nfunc capitalizeLetters(gQ chan string, sQ chan string) {\n\n  for {\n    if lettersProcessed >= stringLength {\n      applicationStatus = false\n      break\n    }\n    select {\n      case letter := <- gQ:\n        capitalLetter := strings.ToUpper(letter)\n        finalString += capitalLetter\n        lettersProcessed++\n    }\n  }\n}\n\nfunc main() {\n\n  applicationStatus = true;\n\n  getQueue := make(chan string)\n  stackQueue := make(chan string)\n\n  initialString = \"Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.\"\n  initialBytes = []byte(initialString)\n  stringLength = len(initialString)\n  lettersProcessed = 0\n\n  fmt.Println(\"Let's start capitalizing\")\n\n  go getLetters(getQueue)\n  capitalizeLetters(getQueue,stackQueue)\n\n  close(getQueue)\n  close(stackQueue)\n\n  for {\n\n    if applicationStatus == false {\n      fmt.Println(\"Done\")\n      fmt.Println(finalString)\n      break\n    }\n\n  }\n}\n```", "```go\nfunc getLetters(gQ chan string) {\n\n  for i := range initialBytes {\n    gQ <- string(initialBytes[i])  \n\n  }\n\n}\n```", "```go\nfunc capitalizeLetters(gQ chan string, sQ chan string) {\n\n  for {\n    if lettersProcessed >= stringLength {\n      applicationStatus = false\n      break\n    }\n    select {\n      case letter := <- gQ:\n        capitalLetter := strings.ToUpper(letter)\n        finalString += capitalLetter\n        lettersProcessed++\n    }\n  }\n}\n```", "```go\n  go func() {\n    go capitalize(index, length, letters, &finalIpsum)\n  }()\n```", "```go\nimport(\n  \"fmt\"\n  \"strings\"\n)\n\nfunc shortenString(message string) func() string {\n\n  return func() string {\n    messageSlice := strings.Split(message,\" \")\n    wordLength := len(messageSlice)\n    if wordLength < 1 {\n      return \"Nothingn Left!\"\n    }else {\n      messageSlice = messageSlice[:(wordLength-1)]\n      message = strings.Join(messageSlice, \" \")\n      return message\n    }\n  }\n}\n\nfunc main() {\n\n  myString := shortenString(\"Welcome to concurrency in Go! ...\")\n\n  fmt.Println(myString())\n  fmt.Println(myString())  \n  fmt.Println(myString())  \n  fmt.Println(myString())  \n  fmt.Println(myString())  \n  fmt.Println(myString())\n}\n```", "```go\npackage main\n\nimport(\n  \"fmt\"\n  \"io/ioutil\"\n  \"net/http\"\n  \"time\"\n)\n\nvar applicationStatus bool\nvar urls []string\nvar urlsProcessed int\nvar foundUrls []string\nvar fullText string\nvar totalURLCount int\nvar wg sync.WaitGroup\n\nvar v1 int\n```", "```go\nfunc readURLs(statusChannel chan int, textChannel chan string) {\n\n  time.Sleep(time.Millisecond * 1)\n  fmt.Println(\"Grabbing\", len(urls), \"urls\")\n  for i := 0; i < totalURLCount; i++ {\n\n    fmt.Println(\"Url\", i, urls[i])\n    resp, _ := http.Get(urls[i])\n    text, err := ioutil.ReadAll(resp.Body)\n\n    textChannel <- string(text)\n\n    if err != nil {\n      fmt.Println(\"No HTML body\")\n    }\n\n    statusChannel <- 0\n\n  }\n\n}\n```", "```go\nfunc addToScrapedText(textChannel chan string, processChannel chan bool) {\n\n  for {\n    select {\n    case pC := <-processChannel:\n      if pC == true {\n        // hang on\n      }\n      if pC == false {\n\n        close(textChannel)\n        close(processChannel)\n      }\n    case tC := <-textChannel:\n      fullText += tC\n\n    }\n\n  }\n\n}\n```", "```go\nfunc evaluateStatus(statusChannel chan int, textChannel chan string, processChannel chan bool) {\n\n  for {\n    select {\n    case status := <-statusChannel:\n\n      fmt.Print(urlsProcessed, totalURLCount)\n      urlsProcessed++\n      if status == 0 {\n\n        fmt.Println(\"Got url\")\n\n      }\n      if status == 1 {\n\n        close(statusChannel)\n      }\n      if urlsProcessed == totalURLCount {\n        fmt.Println(\"Read all top-level URLs\")\n        processChannel <- false\n        applicationStatus = false\n\n      }\n    }\n\n  }\n}\n```", "```go\nfunc main() {\n  applicationStatus = true\n  statusChannel := make(chan int)\n  textChannel := make(chan string)\n  processChannel := make(chan bool)\n  totalURLCount = 0\n\n  urls = append(urls, \"http://www.mastergoco.com/index1.html\")\n  urls = append(urls, \"http://www.mastergoco.com/index2.html\")\n  urls = append(urls, \"http://www.mastergoco.com/index3.html\")\n  urls = append(urls, \"http://www.mastergoco.com/index4.html\")\n  urls = append(urls, \"http://www.mastergoco.com/index5.html\")\n\n  fmt.Println(\"Starting spider\")\n\n  urlsProcessed = 0\n  totalURLCount = len(urls)\n\n  go evaluateStatus(statusChannel, textChannel, processChannel)\n\n  go readURLs(statusChannel, textChannel)\n\n  go addToScrapedText(textChannel, processChannel)\n\n  for {\n    if applicationStatus == false {\n      fmt.Println(fullText)\n      fmt.Println(\"Done!\")\n      break\n    }\n    select {\n    case sC := <-statusChannel:\n      fmt.Println(\"Message on StatusChannel\", sC)\n\n    }\n  }\n\n}\n```", "```go\n  for {\n    if applicationStatus == false {\n      fmt.Println(fullText)\n      fmt.Println(\"Done!\")\n      break\n    }\n    select {\n      case sC := <- statusChannel:\n        fmt.Println(\"Message on StatusChannel\",sC)\n\n    }\n  }\n```"]