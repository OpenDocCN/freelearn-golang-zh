["```go\ngo get github.com/ajstarks/svgo\n\n```", "```go\nexport GOPATH=/usr/yourpathhere\n\n```", "```go\npackage main\n\nimport (\n    \"github.com/ajstarks/svgo\"\n    \"net/http\"\n    \"fmt\"\n    \"log\"\n    \"time\"\n    \"strconv\"\n)\n\nvar width = 800\nvar height = 400\nvar startTime = time.Now().UnixNano()\n\nfunc drawPoint(osvg *svg.SVG, pnt int, process int) {\n  sec := time.Now().UnixNano()\n  diff := ( int64(sec) - int64(startTime) ) / 100000\n\n  pointLocation := 0\n\n  pointLocation = int(diff)\n  pointLocationV := 0\n  color := \"#000000\"\n  switch {\n    case process == 1:\n      pointLocationV = 60\n      color = \"#cc6666\"\n    default:\n      pointLocationV = 180\n      color = \"#66cc66\"\n\n  }\n\n  osvg.Rect(pointLocation,pointLocationV,3,5,\"fill:\"+color+\";stroke:\n  none;\")\n  time.Sleep(150 * time.Millisecond)\n}\n\nfunc visualize(rw http.ResponseWriter, req *http.Request) {\n  startTime = time.Now().UnixNano()\n  fmt.Println(\"Request to /visualize\")\n  rw.Header().Set(\"Content-Type\", \"image/svg+xml\")\n\n  outputSVG := svg.New(rw)\n\n  outputSVG.Start(width, height)\n  outputSVG.Rect(10, 10, 780, 100, \"fill:#eeeeee;stroke:none\")\n  outputSVG.Text(20, 30, \"Process 1 Timeline\", \"text-\n    anchor:start;font-size:12px;fill:#333333\")\n  outputSVG.Rect(10, 130, 780, 100, \"fill:#eeeeee;stroke:none\")    \n  outputSVG.Text(20, 150, \"Process 2 Timeline\", \"text-\n    anchor:start;font-size:12px;fill:#333333\")  \n\n  for i:= 0; i < 801; i++ {\n    timeText := strconv.FormatInt(int64(i),10)\n    if i % 100 == 0 {\n      outputSVG.Text(i,380,timeText,\"text-anchor:middle;font-\n        size:10px;fill:#000000\")      \n    }else if i % 4 == 0 {\n      outputSVG.Circle(i,377,1,\"fill:#cccccc;stroke:none\")  \n    }\n\n    if i % 10 == 0 {\n      outputSVG.Rect(i,0,1,400,\"fill:#dddddd\")\n    }\n    if i % 50 == 0 {\n      outputSVG.Rect(i,0,1,400,\"fill:#cccccc\")\n    }\n\n  }\n\n  for i := 0; i < 100; i++ {\n    go drawPoint(outputSVG,i,1)\n    drawPoint(outputSVG,i,2)    \n  }\n\n  outputSVG.Text(650, 360, \"Run without goroutines\", \"text-\n    anchor:start;font-size:12px;fill:#333333\")      \n  outputSVG.End()\n}\n\nfunc main() {\n  http.Handle(\"/visualize\", http.HandlerFunc(visualize))\n\n    err := http.ListenAndServe(\":1900\", nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe:\", err)\n    }  \n\n}\n```", "```go\n    drawPoint(outputSVG,i,1)\n    drawPoint(outputSVG,i,2)  \n```", "```go\noutputSVG.Text(650, 360, \"Run with goroutines\", \"text-\n  anchor:start;font-size:12px;fill:#333333\")  \n```", "```go\ngo get github.com/jteeuwen/go-pkg-rss\n\n```", "```go\npackage main\n\nimport(\n  \"github.com/ajstarks/svgo\"\n  rss \"github.com/jteeuwen/go-pkg-rss\"    \n  \"net/http\"\n  \"log\"\n  \"fmt\"\n  \"strconv\"\n  \"time\"\n  \"os\"\n  \"sync\"\n  \"runtime\"\n)\n\ntype Feed struct {\n  url string\n  status int\n  itemCount int\n  complete bool\n  itemsComplete bool\n  index int\n}\n```", "```go\ntype FeedItem struct {\n  feedIndex int\n  complete bool\n  url string\n}\n```", "```go\nvar feeds []Feed\nvar height int\nvar width int\nvar colors []string\nvar startTime int64\nvar timeout int\nvar feedSpace int\n\nvar wg sync.WaitGroup\n\nfunc grabFeed(feed *Feed, feedChan chan bool, osvg *svg.SVG) {\n\n  startGrab := time.Now().Unix()\n  startGrabSeconds := startGrab - startTime\n\n  fmt.Println(\"Grabbing feed\",feed.url,\" \n    at\",startGrabSeconds,\"second mark\")\n\n  if feed.status == 0 {\n    fmt.Println(\"Feed not yet read\")\n    feed.status = 1\n\n    startX := int(startGrabSeconds * 33);\n    startY := feedSpace * (feed.index)\n\n    fmt.Println(startY)\n    wg.Add(1)\n\n    rssFeed := rss.New(timeout, true, channelHandler, \n      itemsHandler);\n\n    if err := rssFeed.Fetch(feed.url, nil); err != nil {\n      fmt.Fprintf(os.Stderr, \"[e] %s: %s\", feed.url, err)\n      return\n    } else {\n\n      endSec := time.Now().Unix()    \n      endX := int( (endSec - startGrab) )\n      if endX == 0 {\n        endX = 1\n      }\n      fmt.Println(\"Read feed in\",endX,\"seconds\")\n      osvg.Rect(startX,startY,endX,feedSpace,\"fill: \n        #000000;opacity:.4\")\n      wg.Wait()\n\n      endGrab := time.Now().Unix()\n      endGrabSeconds := endGrab - startTime\n      feedEndX := int(endGrabSeconds * 33);      \n\n      osvg.Rect(feedEndX,startY,1,feedSpace,\"fill:#ff0000;opacity:.9\")\n\n      feedChan <- true\n    }\n\n  }else if feed.status == 1{\n    fmt.Println(\"Feed already in progress\")\n  }\n\n}\n```", "```go\nfunc channelHandler(feed *rss.Feed, newchannels []*rss.Channel) {\n\n}\n\nfunc itemsHandler(feed *rss.Feed, ch *rss.Channel, newitems []*rss.Item) {\n\n  fmt.Println(\"Found\",len(newitems),\"items in\",feed.Url)\n\n  for i := range newitems {\n    url := *newitems[i].Guid\n    fmt.Println(url)\n\n  }\n\n  wg.Done()\n}\n```", "```go\nfunc getRSS(rw http.ResponseWriter, req *http.Request) {\n  startTime = time.Now().Unix()  \n  rw.Header().Set(\"Content-Type\", \"image/svg+xml\")\n  outputSVG := svg.New(rw)\n  outputSVG.Start(width, height)\n\n  feedSpace = (height-20) / len(feeds)\n\n  for i:= 0; i < 30000; i++ {\n    timeText := strconv.FormatInt(int64(i/10),10)\n    if i % 1000 == 0 {\n      outputSVG.Text(i/30,390,timeText,\"text-anchor:middle;font-\n        size:10px;fill:#000000\")      \n    }else if i % 4 == 0 {\n      outputSVG.Circle(i,377,1,\"fill:#cccccc;stroke:none\")  \n    }\n\n    if i % 10 == 0 {\n      outputSVG.Rect(i,0,1,400,\"fill:#dddddd\")\n    }\n    if i % 50 == 0 {\n      outputSVG.Rect(i,0,1,400,\"fill:#cccccc\")\n    }\n\n  }\n\n  feedChan := make(chan bool, 3)\n\n  for i := range feeds {\n\n    outputSVG.Rect(0, (i*feedSpace), width, feedSpace, \n      \"fill:\"+colors[i]+\";stroke:none;\")\n    feeds[i].status = 0\n    go grabFeed(&feeds[i], feedChan, outputSVG)\n    <- feedChan\n  }\n\n  outputSVG.End()\n}\n```", "```go\nfunc main() {\n\n  runtime.GOMAXPROCS(2)\n\n  timeout = 1000\n\n  width = 1000\n  height = 400\n\n  feeds = append(feeds, Feed{index: 0, url: \n    \"https://groups.google.com/forum/feed/golang-\n    nuts/msgs/rss_v2_0.xml?num=50\", status: 0, itemCount: 0, \n    complete: false, itemsComplete: false})\n  feeds = append(feeds, Feed{index: 1, url: \n    \"http://www.reddit.com/r/golang/.rss\", status: 0, itemCount: \n    0, complete: false, itemsComplete: false})\n  feeds = append(feeds, Feed{index: 2, url: \n    \"https://groups.google.com/forum/feed/golang-\n    dev/msgs/rss_v2_0.xml?num=50\", status: 0, itemCount: 0, \n    complete: false, itemsComplete: false })\n```", "```go\n  colors = append(colors,\"#ff9999\")\n  colors = append(colors,\"#99ff99\")\n  colors = append(colors,\"#9999ff\")  \n```", "```go\n  http.Handle(\"/getrss\", http.HandlerFunc(getRSS))\n    err := http.ListenAndServe(\":1900\", nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe:\", err)\n    }  \n}\n```", "```go\n  url := *newitems[i].Guid\n      response, _, err := http.Get(url)\n      if err != nil {\n\n      }\n```", "```go\n  feedChan := make(chan bool, 3)\n\n  for i := range feeds {\n\n    outputSVG.Rect(0, (i*feedSpace), width, feedSpace, \n      \"fill:\"+colors[i]+\";stroke:none;\")\n    feeds[i].status = 0\n    go grabFeed(&feeds[i], feedChan, outputSVG)\n    <- feedChan\n  }\n\n  outputSVG.End()\n```", "```go\n    wg.Add(1)\n    rssFeed := rss.New(timeout, true, channelHandler, \n      itemsHandler);\n    \u2026\n    wg.Wait()\n```", "```go\ntype Philosopher struct {\n  leftHand bool\n  rightHand bool\n  status int\n  name string\n}\n\nfunc main() {\n\n  philosophers := [...]Philospher{\"Kant\", \"Turing\", \n    \"Descartes\",\"Kierkegaard\",\"Wittgenstein\"}\n\n  evaluate := func() {\n    for {\n\n      select {\n        case <- forkUp:\n          // philosophers think!\n        case <- forkDown:\n          // next philospher eats in round robin\n      }\n\n    }\n\n  }\n\n}\n```", "```go\na = new Actor\nb = new Actor\na -> b(\"message\")\n```", "```go\na = new Actor\nb = new Actor\nc = new Channel\na -> c(\"sending something\")\nb <- c(\"receiving something\")\n```", "```go\ntype intInterface struct {\n\n}\n\ntype stringInterface struct {\n\n}\n\nfunc (number intInterface) Add (a int, b int) int {\n  return a + b;\n}\n\nfunc (text stringInterface) Add (a string, b string) string {\n  return a + b\n}\n\nfunc main() {\n\n  number := new (intInterface)\n    fmt.Println( number.Add(1,2) )\n\n  text := new (stringInterface)\n    fmt.Println( text.Add(\"this old man\",\" he played one\"))\n\n}\n```", "```go\npackage main\n\nimport(\n  \"fmt\"\n  \"sync\"\n)\n\nfunc main() {\n  current := 0\n  iterations := 100\n  wg := new (sync.WaitGroup);\n\n  for i := 0; i < iterations; i++ {\n    wg.Add(1)\n\n    go func() {\n      current++\n      fmt.Println(current)\n      wg.Done()\n    }()\n    wg.Wait()\n  }\n\n}\n```", "```go\nfunc main() {\n  runtime.GOMAXPROCS(2)\n  current := 0\n  iterations := 100\n  wg := new (sync.WaitGroup);\n  wg.Add(iterations)\n  for i := 0; i < iterations; i++ {\n    go func() {\n      current++\n      fmt.Println(current)\n      wg.Done()\n    }()\n\n  }\n  wg.Wait()\n\n}\n```", "```go\n95\n96\n98\n99\n100\n3\n4\n\n```", "```go\n  for i := 0; i < iterations; i++ {\n    go func() {\n      mutex.Lock()\n      fmt.Println(current)\n      current++\n      mutex.Unlock()\n      fmt.Println(current)\n      wg.Done()\n    }()\n\n  }\n```"]