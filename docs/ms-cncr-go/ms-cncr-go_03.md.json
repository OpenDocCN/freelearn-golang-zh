["```go\npackage main\n\nimport(\n  \"fmt\"\n  \"time\"\n  \"sync\"\n  \"runtime\"\n  \"math/rand\"\n)  \n\nvar balance int\nvar transactionNo int\n\nfunc main() {\n  rand.Seed(time.Now().Unix())\n  runtime.GOMAXPROCS(2)\n  var wg sync.WaitGroup\n\n  tranChan := make(chan bool)\n\n  balance = 1000\n  transactionNo = 0\n  fmt.Println(\"Starting balance: $\",balance)\n\n  wg.Add(1)\n  for i := 0; i < 100; i++ {\n    go func(ii int, trChan chan(bool)) {\n      transactionAmount := rand.Intn(25)\n      transaction(transactionAmount)\n      if (ii == 99) {\n        trChan <- true\n      }\n\n    }(i,tranChan)\n  }\n\n  go transaction(0)\n  select {\n\n    case <- tranChan:\n      fmt.Println(\"Transactions finished\")\n      wg.Done()\n\n  }\n\n  wg.Wait()\n  close(tranChan)\n  fmt.Println(\"Final balance: $\",balance)\n}\n\nfunc transaction(amt int) (bool) {\n\n  approved := false  \n  if (balance-amt) < 0 {\n    approved = false\n  }else {\n    approved = true\n    balance = balance - amt\n  }\n\n  approvedText := \"declined\"\n  if (approved == true) {\n    approvedText = \"approved\"\n  }else {\n\n  }\n  transactionNo = transactionNo + 1\n  fmt.Println(transactionNo,\"Transaction for $\",amt,approvedText)\n  fmt.Println(\"\\tRemaining balance $\",balance)\n  return approved\n}\n```", "```go\ngo run -race race-test.go\n\n```", "```go\n>> Final balance: $0\n>> Found 2 data race(s)\n\n```", "```go\n==================\nWARNING: DATA RACE\nWrite by goroutine 5: main.transaction()   /var/go/race.go:75 +0xbd \n main.func\u252c\u2556001()   /var/go/race.go:31 +0x44\n\nPrevious write by goroutine 4: main.transaction() \n /var/go/race.go:75 +0xbd main.func\u252c\u2556001()   /var/go/race.go:31 \n +0x44\n\nGoroutine 5 (running) created at: main.main()   /var/go/race.go:36 \n +0x21c\n\nGoroutine 4 (finished) created at: main.main()   /var/go/race.go:36 \n +0x21c\n\n```", "```go\n  messageOutput := os.Stdout\n  logOut := log.New(messageOutput,\"Message: \",log.\n  Ldate|log.Ltime|log.Llongfile);\n  logOut.Println(\"This is a message from the \n  application!\")\n```", "```go\nMessage: 2014/01/21 20:59:11 /var/go/log.go:12: This is a message from the application!\n\n```", "```go\npackage main\n\nimport(\n  \"fmt\"\n  \"time\"\n  \"sync\"\n  \"runtime\"\n  \"math/rand\"\n)  \n\nvar balance int\nvar transactionNo int\n\nfunc main() {\n  rand.Seed(time.Now().Unix())\n  runtime.GOMAXPROCS(2)\n  var wg sync.WaitGroup\n  balanceChan := make(chan int)\n  tranChan := make(chan bool)\n\n  balance = 1000\n  transactionNo = 0\n  fmt.Println(\"Starting balance: $\",balance)\n\n  wg.Add(1)\n  for i:= 0; i<100; i++ {\n\n    go func(ii int) {\n\n      transactionAmount := rand.Intn(25)\n      balanceChan <- transactionAmount\n\n      if ii == 99 {\n        fmt.Println(\"Should be quittin time\")\n        tranChan <- true\n        close(balanceChan)\n        wg.Done()\n      }\n\n    }(i)\n\n  }\n\n  go transaction(0)\n\n    breakPoint := false\n    for {\n      if breakPoint == true {\n        break\n      }\n      select {\n        case amt:= <- balanceChan:\n          fmt.Println(\"Transaction for $\",amt)\n          if (balance - amt) < 0 {\n            fmt.Println(\"Transaction failed!\")\n          }else {\n            balance = balance - amt\n            fmt.Println(\"Transaction succeeded\")\n          }\n          fmt.Println(\"Balance now $\",balance)\n\n        case status := <- tranChan:\n          if status == true {\n            fmt.Println(\"Done\")\n            breakPoint = true\n            close(tranChan)\n\n          }\n      }\n    }\n\n  wg.Wait()\n\n  fmt.Println(\"Final balance: $\",balance)\n}\n\nfunc transaction(amt int) (bool) {\n\n  approved := false  \n  if (balance-amt) < 0 {\n    approved = false\n  }else {\n    approved = true\n    balance = balance - amt\n  }\n\n  approvedText := \"declined\"\n  if (approved == true) {\n    approvedText = \"approved\"\n  }else {\n\n  }\n  transactionNo = transactionNo + 1\n  fmt.Println(transactionNo,\"Transaction for $\",amt,approvedText)\n  fmt.Println(\"\\tRemaining balance $\",balance)\n  return approved\n}\n```", "```go\ntransactionAmount := rand.Intn(25)\nbalanceChan <- transactionAmount\n```", "```go\ncase amt:= <- balanceChan:\nfmt.Println(\"Transaction for $\",amt)\nif (balance - amt) < 0 {\n  fmt.Println(\"Transaction failed!\")\n}else {\n  balance = balance - amt\n  fmt.Println(\"Transaction succeeded\")\n}\nfmt.Println(\"Balance now $\",balance)\n```", "```go\nRead by goroutine 5: main.transaction()   /var/go/race.go:62 +0x46\n\n```", "```go\nfunc transaction(amt int) (bool) {\n  mutex.Lock()\n\n  approved := false\n  if (balance-amt) < 0 {\n    approved = false\n  }else {\n    approved = true\n    balance = balance - amt\n  }\n\n  approvedText := \"declined\"\n  if (approved == true) {\n    approvedText = \"approved\"\n  }else {\n\n  }\n  transactionNo = transactionNo + 1\n  fmt.Println(transactionNo,\"Transaction for $\",amt,approvedText)\n  fmt.Println(\"\\tRemaining balance $\",balance)\n\n  mutex.Unlock()\n  return approved\n}\n```", "```go\nvar mutex sync.Mutex\n```", "```go\nfunc main() {\n\n  ourCh := make(chan string,1)\n\n  go func() {\n\n  }()\n\n  select {\n    case <-time.After(10 * time.Second):\n      fmt.Println(\"Enough's enough\")\n      close(ourCh)\n  }\n\n}\n```", "```go\n<ul>\n{{range .Users}}\n<li>A User </li>\n{{end}}\n</ul>\n```", "```go\ntype User struct {\n  Name string\n  email string\n  times[int] bool\n}\n```", "```go\ntype Page struct {\n  Title string\n  Body string\n}\n```", "```go\nfunc users(w http.ResponseWriter, r *http.Request) {\n}\nfunc register(w http.ResponseWriter, r *http.Request) {\n}\nfunc schedule(w http.ResponseWriter, r *http.Request) {\n}\n```", "```go\npackage main\n\nimport(\n  \"net/http\"\n  \"html/template\"\n  \"fmt\"\n  \"github.com/gorilla/mux\"\n  \"sync\"\n  \"strconv\"\n)\n\ntype User struct {\n  Name string\n  Times map[int] bool\n  DateHTML template.HTML\n}\n\ntype Page struct {\n  Title string\n  Body template.HTML\n  Users map[string] User\n}\n\nvar usersInit map[string] bool\nvar userIndex int\nvar validTimes []int\nvar mutex sync.Mutex\nvar Users map[string]User\nvar templates = template.Must(template.New(\"template\").ParseFiles(\"view_users.html\", \"register.html\"))\n\nfunc register(w http.ResponseWriter, r *http.Request){\n  fmt.Println(\"Request to /register\")\n  params := mux.Vars(r)\n  name := params[\"name\"]\n\n  if _,ok := Users[name]; ok {\n    t,_ := template.ParseFiles(\"generic.txt\")\n    page := &Page{ Title: \"User already exists\", Body: \n      template.HTML(\"User \" + name + \" already exists\")}\n    t.Execute(w, page)\n  }  else {\n          newUser := User { Name: name }\n          initUser(&newUser)\n          Users[name] = newUser\n          t,_ := template.ParseFiles(\"generic.txt\")\n          page := &Page{ Title: \"User created!\", Body: \n            template.HTML(\"You have created user \"+name)}\n          t.Execute(w, page)\n    }\n\n}\n\nfunc dismissData(st1 int, st2 bool) {\n\n// Does nothing in particular for now other than avoid Go compiler \n  errors\n}\n\nfunc formatTime(hour int) string {\n  hourText := hour\n  ampm := \"am\"\n  if (hour > 11) {\n    ampm = \"pm\"\n  }\n  if (hour > 12) {\n    hourText = hour - 12;\n  }\nfmt.Println(ampm)\n  outputString := strconv.FormatInt(int64(hourText),10) + ampm\n\n  return outputString\n}\n\nfunc (u User) FormatAvailableTimes() template.HTML { HTML := \"\" \n  HTML += \"<b>\"+u.Name+\"</b> - \"\n\n  for k,v := range u.Times { dismissData(k,v)\n\n    if (u.Times[k] == true) { formattedTime := formatTime(k) HTML \n      += \"<a href='/schedule/\"+u.Name+\"/\"+strconv.FormatInt(int64(k),10)+\"' class='button'>\"+formattedTime+\"</a> \"\n\n    } else {\n\n    }\n\n } return template.HTML(HTML)\n}\n\nfunc users(w http.ResponseWriter, r *http.Request) {\n  fmt.Println(\"Request to /users\")\n\n  t,_ := template.ParseFiles(\"users.txt\")\n  page := &Page{ Title: \"View Users\", Users: Users}\n  t.Execute(w, page)\n}\n\nfunc schedule(w http.ResponseWriter, r *http.Request) {\n  fmt.Println(\"Request to /schedule\")\n  params := mux.Vars(r)\n  name := params[\"name\"]\n  time := params[\"hour\"]\n  timeVal,_ := strconv.ParseInt( time, 10, 0 )\n  intTimeVal := int(timeVal)\n\n  createURL := \"/register/\"+name\n\n  if _,ok := Users[name]; ok {\n    if Users[name].Times[intTimeVal] == true {\n      mutex.Lock()\n      Users[name].Times[intTimeVal] = false\n      mutex.Unlock()\n      fmt.Println(\"User exists, variable should be modified\")\n      t,_ := template.ParseFiles(\"generic.txt\")\n      page := &Page{ Title: \"Successfully Scheduled!\", Body: \n        template.HTML(\"This appointment has been scheduled. <a \n          href='/users'>Back to users</a>\")}\n\n      t.Execute(w, page)\n\n    }  else {\n            fmt.Println(\"User exists, spot is taken!\")\n            t,_ := template.ParseFiles(\"generic.txt\")\n            page := &Page{ Title: \"Booked!\", Body: \n              template.HTML(\"Sorry, \"+name+\" is booked for \n              \"+time+\" <a href='/users'>Back to users</a>\")}\n      t.Execute(w, page)\n\n    }\n\n  }  else {\n          fmt.Println(\"User does not exist\")\n          t,_ := template.ParseFiles(\"generic.txt\")\n          page := &Page{ Title: \"User Does Not Exist!\", Body: \n            template.HTML( \"Sorry, that user does not exist. Click \n              <a href='\"+createURL+\"'>here</a> to create it. <a \n                href='/users'>Back to users</a>\")}\n    t.Execute(w, page)\n  }\n  fmt.Println(name,time)\n}\n\nfunc defaultPage(w http.ResponseWriter, r *http.Request) {\n\n}\n\nfunc initUser(user *User) {\n\n  user.Times = make(map[int] bool)\n  for i := 9; i < 18; i ++ {\n    user.Times[i] = true\n  }\n\n}\n\nfunc main() {\n  Users = make(map[string] User)\n  userIndex = 0\n  bill := User {Name: \"Bill\"  }\n  initUser(&bill)\n  Users[\"Bill\"] = bill\n  userIndex++\n\n  r := mux.NewRouter()  r.HandleFunc(\"/\", defaultPage)\n    r.HandleFunc(\"/users\", users)  \n      r.HandleFunc(\"/register/{name:[A-Za-z]+}\", register)\n        r.HandleFunc(\"/schedule/{name:[A-Za-z]+}/{hour:[0-9]+}\", \n          schedule)     http.Handle(\"/\", r)\n\n  err := http.ListenAndServe(\":1900\", nil)  if err != nil {    // \n    log.Fatal(\"ListenAndServe:\", err)    }\n\n}\n```", "```go\nTotal registered appointments: 8\n\n```", "```go\n<html>\n<head>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-\n    8\"> \n  <title>{{.Title}}</title>\n</head>\n<body>\n\n<h1>{{.Title}}</h1>\n\n{{range .Users}}\n<div class=\"user-row\">\n\n  {{.FormatAvailableTimes}}\n\n</div>\n{{end}}\n\n</body>\n</html>\n```", "```go\nfunc (u User) FormatAvailableTimes() template.HTML {\n```", "```go\nif _,ok := Users[name]; ok {\n  if Users[name].Times[intTimeVal] == true {\n    mutex.Lock()\n    Users[name].Times[intTimeVal] = false\n    mutex.Unlock()\n```", "```go\nfunc main() {\n\n  testString := \"Watch your top / resource monitor\"\n  for i:= 0; i < 1000; i++ {\n\n    testString = string(i)\n\n  }\n  doNothing(testString)  \n\n  time.Sleep(10 * time.Second)\n\n}\n```", "```go\nfor i:= 0; i < 100000000; i++ {\n```"]