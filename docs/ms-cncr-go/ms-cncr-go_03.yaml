- en: Chapter 3. Developing a Concurrent Strategy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。制定并发策略
- en: In the previous chapter, we looked at the concurrency model that Go relies on
    to make your life as a developer easier. We also saw a visual representation of
    parallelism and concurrency. These help us to understand the differences and overlaps
    between serialized, concurrent, and parallel applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了Go依赖的并发模型，以使开发人员的生活更轻松。我们还看到了并行性和并发性的可视化表示。这些帮助我们理解串行、并发和并行应用程序之间的差异和重叠。
- en: However, the most critical part of any concurrent application is not the concurrency
    itself but communication and coordination between the concurrent processes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任何并发应用程序中最关键的部分不是并发本身，而是并发进程之间的通信和协调。
- en: In this chapter, we'll look at creating a plan for an application that heavily
    factors communication between processes and how a lack of coordination can lead
    to significant issues with consistency. We'll look at ways we can visualize our
    concurrent strategy on paper so that we're better equipped to anticipate potential
    problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将着重考虑创建一个应用程序的计划，该计划严重考虑了进程之间的通信，以及缺乏协调可能导致一致性方面的重大问题。我们将探讨如何在纸上可视化我们的并发策略，以便更好地预见潜在问题。
- en: Applying efficiency in complex concurrency
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用复杂并发的效率
- en: When designing applications, we often eschew complex patterns for simplicity,
    with the assumption that simple systems are often the fastest and most efficient.
    It seems only logical that a machine with fewer moving parts will be more efficient
    than one with more.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序时，我们经常放弃复杂的模式，选择简单性，假设简单的系统通常是最快和最有效的。似乎只有逻辑上，机器的移动部分越少，效率就会比移动部分更多的机器更高。
- en: The paradox here, as it applies to concurrency, is that adding redundancy and
    significantly more movable parts often leads to a more efficient application.
    If we consider concurrent schemes, such as goroutines, to be infinitely scalable
    resources, employing more should always result in some form of efficiency benefit.
    This applies not just to parallel concurrency but to single core concurrency as
    well.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的悖论是，对并发的应用，增加冗余和更多的可移动部分通常会导致更高效的应用。如果我们认为并发方案（如goroutines）是无限可扩展的资源，那么使用更多的资源应该总是会带来某种形式的效率收益。这不仅适用于并行并发，也适用于单核并发。
- en: If you find yourself designing an application that utilizes concurrency at the
    cost of efficiency, speed, and consistency, you should ask yourself whether the
    application truly needs concurrency at all.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己设计的应用程序利用并发，却牺牲了效率、速度和一致性，你应该问问自己这个应用程序是否真的需要并发。
- en: When we talk about efficiency, we aren't just dealing with speed. Efficiency
    should also weigh the CPU and memory overhead and the cost to ensure data consistency.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论效率时，我们不仅仅是在处理速度。效率还应该考虑CPU和内存开销以及确保数据一致性的成本。
- en: For example, should an application marginally benefit from concurrency but require
    an elaborate and/or computationally expensive process to guarantee data consistency,
    it's worth re-evaluating the strategy entirely.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个应用程序在一定程度上受益于并发，但需要一个复杂和/或计算昂贵的过程来保证数据一致性，那么重新评估整个策略是值得的。
- en: Keeping your data reliable and up to date should be paramount; while having
    unreliable data may not always have a devastating effect, it will certainly compromise
    the reliability of your application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 保持数据的可靠性和最新性应该是最重要的；虽然不可靠的数据可能并不总是会产生灾难性的影响，但它肯定会损害你的应用程序的可靠性。
- en: Identifying race conditions with race detection
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用竞争检测识别竞争条件
- en: If you've ever written an application that depends on the exact timing and sequencing
    of functions or methods to create a desired output, you're already quite familiar
    with race conditions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经编写过一个依赖于函数或方法的确切时间和顺序来创建期望输出的应用程序，你对竞争条件已经非常熟悉了。
- en: These are particularly common anytime you deal with concurrency and far more
    so when parallelism is introduced. We've actually encountered a few of them in
    the first few chapters, specifically with our incrementing number function.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在处理并发时特别常见，当引入并行时更加常见。在前几章中，我们确实遇到了一些问题，特别是在我们的递增数字函数中。
- en: The most commonly used educational example of race conditions is that of a bank
    account. Assume that you start with $1,000 and attempt 200 $5 transactions. Each
    transaction requires a query on the current balance of the account. If it passes,
    the transaction is approved and $5 is removed from the balance. If it fails, the
    transaction is declined and the balance remains unchanged.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件最常用的教育示例是银行账户。假设你从1000美元开始，尝试进行200笔5美元的交易。每笔交易都需要查询账户的当前余额。如果通过，交易将获批准，从余额中扣除5美元。如果失败，交易将被拒绝，余额保持不变。
- en: This is all well and good until the query happens at some point during a concurrent
    transaction (in most cases in another thread). If, for example, a thread asks
    "Do you have $5 in your account?" as another thread is in the process of removing
    $5 but has not yet completed, you can end up with an approved transaction that
    should have been declined.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，直到查询在并发事务中的某个时刻发生（在大多数情况下是在另一个线程中）。例如，一个线程在另一个线程正在移除5美元但尚未完成的过程中询问“你的账户里有5美元吗？”这样，你最终可能会得到一个本应该被拒绝的交易。
- en: Tracking down the cause of race conditions can be—to say the least—a gigantic
    headache. With Version 1.1 of Go, Google introduced a race detection tool that
    can help you locate potential issues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪竞争条件的原因可能是一个巨大的头痛。在Go的1.1版本中，Google引入了一种竞争检测工具，可以帮助你找到潜在的问题。
- en: Let's take a very basic example of a multithreaded application with race conditions
    and see how Golang can help us debug it. In this example, we'll build a bank account
    that starts with $1,000 and runs 100 transactions for a random amount between
    $0 and $25.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个具有竞争条件的多线程应用程序的非常基本的例子为例，看看Golang如何帮助我们调试它。在这个例子中，我们将建立一个银行账户，初始金额为1000美元，进行100笔随机金额在0到25美元之间的交易。
- en: 'Each transaction will be run in its own goroutine, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个交易将在自己的goroutine中运行，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Depending on your environment (and whether you enable multiple processors),
    you might have the previous goroutine operate successfully with a $0 or more final
    balance. You might, on the other hand, simply end up with transactions that exceed
    the balance at the time of transaction, resulting in a negative balance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的环境（以及是否启用多个处理器），您可能会发现先前的goroutine成功地操作了$0或更多的最终余额。另一方面，您可能最终只会得到超出交易时余额的交易，导致负余额。
- en: So how do we know for sure?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们怎么知道呢？
- en: 'For most applications and languages, this process often involves a lot of running,
    rerunning, and logging. It''s not unusual for race conditions to present a daunting
    and laborious debugging process. Google knows this and has given us a race condition
    detection tool. To test this, simply use the `–race` flag when testing, building,
    or running your application, as shown:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用程序和语言来说，这个过程通常涉及大量的运行、重新运行和日志记录。竞态条件往往会导致令人望而生畏和费力的调试过程。Google知道这一点，并为我们提供了一个竞态条件检测工具。要测试这一点，只需在测试、构建或运行应用程序时使用`-race`标志，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When run on the previous code, Go will execute the application and then report
    any possible race conditions, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当在先前的代码上运行时，Go将执行应用程序，然后报告任何可能的竞态条件，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, Go is telling us there are two potential race conditions with data. It
    isn't telling us that these will surely create data consistency issues, but if
    you run into such problems, this may give you some clue as to why.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Go告诉我们数据存在两种潜在的竞态条件。它并没有告诉我们这些一定会导致数据一致性问题，但如果您遇到这样的问题，这可能会给您一些线索。
- en: 'If you look at the top of the output, you''ll get more detailed notes on what''s
    causing a race condition. In this example, the details are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看输出的顶部，您将得到有关导致竞态条件的详细说明。在这个例子中，详细信息如下：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We get a detailed, full trace of where our potential race conditions exist.
    Pretty helpful, huh?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得到详细的、完整的跟踪，了解我们的潜在竞态条件存在的位置。相当有帮助，对吧？
- en: The race detector is guaranteed to not produce false positives, so you can take
    the results as strong evidence that there is a potential problem in your code.
    The potential is stressed here because a race condition can go undetected in normal
    conditions very often—an application may work as expected for days, months, or
    even years before a race condition can surface.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态检测器保证不会产生错误的阳性结果，因此您可以将结果视为您的代码中存在潜在问题的有力证据。这里强调潜在性，因为竞态条件在正常情况下很容易被忽略——一个应用程序可能在几天、几个月甚至几年内都能正常工作，然后才会出现竞态条件。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'We''ve mentioned logging, and if you aren''t intimately familiar with Go''s
    core language, your mind might go in a number of directions—stdout, file logs,
    and so on. So far we''ve stuck to stdout, but you can use the standard library
    to handle this logging. Go''s log package allows you to write to io or stdout
    as shown:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了日志记录，如果您对Go的核心语言不是非常熟悉，您的想法可能会有很多方向——stdout、文件日志等等。到目前为止，我们一直使用stdout，但您可以使用标准库来处理这些日志记录。Go的log包允许您按照以下方式写入io或stdout：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will produce the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, what's the advantage of the log package versus rolling your own? In addition
    to being standardized, this package is also synchronized in terms of output.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，log包相对于自己编写的优势在哪里呢？除了标准化之外，这个包在输出方面也是同步的。
- en: So what now? Well, there are a few options. You can utilize your channels to
    ensure data integrity with a buffered channel, or you can use the `sync.Mutex`
    struct to lock your data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么现在呢？嗯，有几种选择。您可以利用通道来确保数据的完整性，使用缓冲通道，或者您可以使用`sync.Mutex`结构来锁定您的数据。
- en: Using mutual exclusions
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用互斥
- en: Typically, mutual exclusion is considered a low-level and best-known approach
    to synchronicity in your application—you should be able to address data consistency
    within communication between your channels. However, there will be instances where
    you need to truly block read/write on a value while you work with it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，互斥被认为是在应用程序中实现同步的一种低级和最为人熟知的方法——您应该能够在通道之间的通信中解决数据一致性。然而，在某些情况下，您需要真正地在处理数据时阻止读/写。
- en: At the CPU level, a mutex represents an exchange of binary integer values across
    registers to acquire and release locks. We'll deal with something on a much higher
    level, of course.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPU级别，互斥表示在寄存器之间交换二进制整数值以获取和释放锁。当然，我们将处理更高级别的东西。
- en: We're already familiar with the sync package from our use of the `WaitGroup`
    struct, but the package also contains the conditional variables `struct Cond`
    and `Once`, which will perform an action just one time, and the mutual exclusion
    locks `RWMutex` and `Mutex`. As the name `RWMutex` implies, it is open to multiple
    readers and/or writers to lock and unlock; there is more on this later in this
    chapter and in [Chapter 5](part0048_split_000.html#page "Chapter 5. Locks, Blocks,
    and Better Channels"), *Locks, Blocks, and Better Channels*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了sync包，因为我们使用了`WaitGroup`结构，但该包还包含了条件变量`struct Cond`和`Once`，它们将执行一次操作，以及互斥锁`RWMutex`和`Mutex`。正如`RWMutex`的名称所暗示的那样，它对多个读取者和/或写入者进行锁定和解锁；本章后面和[第5章](part0048_split_000.html#page
    "第5章。锁、块和更好的通道")中还有更多内容，*锁、块和更好的通道*。
- en: All of these—as the package name implies—empower you to prevent race conditions
    on data that may be accessed by any number of goroutines and/or threads. Using
    any of the methods in this package does not ensure atomicity within data and structures,
    but it does give you the tools to manage atomicity effectively. Let's look at
    a few ways we can solidify our account balance in concurrent, threadsafe applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如包名所暗示的那样，所有这些都赋予您防止可能被任意数量的goroutines和/或线程访问的数据发生竞态条件的能力。使用此包中的任何方法都不能确保数据和结构的原子性，但它确实为您提供了有效管理原子性的工具。让我们看看我们可以在并发的、线程安全的应用程序中巩固我们的账户余额的一些方法。
- en: As mentioned previously, we can coordinate data changes at the channel level
    whether that channel is buffered or unbuffered. Let's offload the logic and data
    manipulation to the channel and see what the `–race` flag presents.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以在通道级别协调数据更改，无论该通道是缓冲还是非缓冲。让我们将逻辑和数据操作卸载到通道，并查看`-race`标志呈现了什么。
- en: 'If we modify our main loop, as shown in the following code, to utilize messages
    received by the channel to manage the balance value, we will avoid race conditions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改我们的主循环，如下面的代码所示，以利用通道接收的消息来管理余额值，我们将避免竞态条件：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This time, we let the channel manage the data entirely. Let''s look at what
    we''re doing:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们让通道完全管理数据。让我们看看我们在做什么：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This still generates a random integer between 0 and 25, but instead of passing
    it to a function, we pass the data along the channel. Channels allow you to control
    the ownership of data neatly. We then see the select/listener, which largely mirrors
    our `transaction()` function defined earlier in this chapter:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然会生成0到25之间的随机整数，但我们不是将其传递给函数，而是通过通道传递数据。通道允许您整洁地控制数据的所有权。然后我们看到选择/监听器，它在很大程度上与本章前面定义的`transaction()`函数相似：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To test whether we've averted a race condition, we can run `go run` with the
    `-race` flag again and see no warnings.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们是否避免了竞态条件，我们可以再次使用`-race`标志运行`go run`，并且不会收到警告。
- en: Channels can be seen as the sanctioned go-to way of handling synchronized `dataUse
    Sync.Mutex()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通道可以被视为处理同步`dataUse Sync.Mutex()`的官方方式。
- en: As mentioned, having a built-in race detector is a luxury not afforded to developers
    in most languages, and having it allows us to test methodologies and get real-time
    feedback on each.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，拥有内置的竞态检测器是大多数语言的开发人员无法享受的奢侈品，拥有它使我们能够测试方法并获得实时反馈。
- en: We noted that using an explicit mutex is discouraged in favor of channels of
    goroutines. This isn't always exactly true because there is a right time and place
    for everything, and mutexes are no exclusion. What's worth noting is that mutexes
    are implemented internally by Go for channels. As was previously mentioned, you
    can use explicit channels to handle reads and writes and juggle the data between
    them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，使用显式互斥锁不鼓励使用goroutines的通道。这并不总是完全正确，因为每件事都有正确的时间和地点，互斥锁也不例外。值得注意的是，互斥锁在Go中是由通道内部实现的。正如之前提到的，您可以使用显式通道来处理读取和写入，并在它们之间搬移数据。
- en: However, this doesn't mean there is no use for explicit locks. An application
    that has many reads and very few writes might benefit from explicit locks for
    writes; this doesn't necessarily mean that the reads will be dirty reads, but
    it could result in faster and/or more concurrent execution.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着显式锁没有用处。一个具有许多读取和很少写入的应用程序可能会受益于显式锁定写入；这并不一定意味着读取将是脏读取，但可能会导致更快和/或更多并发的执行。
- en: 'For the sake of demonstration, let''s remove our race condition using an explicit
    lock. Our `-race` flag tells us where it encounters read/write race conditions,
    as shown:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示起见，让我们使用显式锁来消除我们的竞态条件。我们的`-race`标志告诉我们它在哪里遇到读/写竞态条件，如下所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previous line is just one among several others we''ll get from the race
    detection report. If we look at line 62 in our code, we''ll find a reference to
    `balance`. We''ll also find a reference to `transactionNo`, our second race condition.
    The easiest way to address both is to place a mutual exclusion lock around the
    contents of the `transaction` function as this is the function that modifies the
    `balance` and `transactionNo` variables. The `transaction` function is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行只是我们从竞态检测报告中得到的几行中的一行。如果我们查看代码中的第62行，我们会找到对`balance`的引用。我们还会找到对`transactionNo`的引用，我们的第二个竞态条件。解决这两个问题最简单的方法是在`transaction`函数的内容周围放置一个互斥锁，因为这是修改`balance`和`transactionNo`变量的函数。`transaction`函数如下所示：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also need to define `mutex` as a global variable at the top of our application,
    as shown:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在应用程序顶部将`mutex`定义为全局变量，如下所示：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we run our application now with the `-race` flag, we get no warnings.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在使用`-race`标志运行我们的应用程序，我们将不会收到警告。
- en: The `mutex` variable is, for practical purposes, an alternative to the `WaitGroup`
    struct, which functions as a conditional synchronization mechanism. This is also
    the way that the channels operate—data that moves along channels is contained
    and isolated between goroutines. A channel can effectively work as a first-in,
    first-out tool in this way by binding goroutine state to `WaitGroup`; data accessed
    across the channel can then be provided safety via the lower-level mutex.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex`变量在实际目的上是`WaitGroup`结构的替代品，它作为条件同步机制。这也是通道操作的方式——沿通道移动的数据在goroutines之间是受限和隔离的。通过将goroutine状态绑定到`WaitGroup`，通道可以有效地作为先进先出工具工作；然后通过低级互斥锁为通道上跨通道访问的数据提供安全性。'
- en: Another worthwhile thing to note is the versatility of a channel—we have the
    ability to share a channel among an array of goroutines to receive and/or send
    data, and as a first-class citizen, we can pass them along in functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的事情是通道的多功能性——我们有能力在一系列goroutines之间共享通道以接收和/或发送数据，并且作为一等公民，我们可以在函数中传递它们。
- en: Exploring timeouts
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索超时
- en: Another noteworthy thing we can do with channels is explicitly kill them after
    a specified amount of time. This is an operation that will be a bit more involved
    should you decide to manually handle mutual exclusions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用通道显式在指定的时间后终止它们。如果决定手动处理互斥锁，这将是一个更复杂的操作。
- en: 'The ability to kill a long-running routine through the channel is extremely
    helpful; consider a network-dependent operation that should not only be restricted
    to a short time period but also not allowed to run for a long period. In other
    words, you want to offer the process a few seconds to complete; but if it runs
    for more than a minute, our application should know that something has gone wrong
    enough to stop attempting to listen or send on that channel. The following code
    demonstrates using a timeout channel in a `select` call:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过通道终止长时间运行的例程的能力非常有帮助；考虑一个依赖网络的操作，不仅应该受限于短时间段，而且也不允许长时间运行。换句话说，你想给这个过程几秒钟来完成；但如果它运行超过一分钟，我们的应用程序应该知道出了什么问题，以至于停止尝试在该通道上监听或发送。以下代码演示了在`select`调用中使用超时通道：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we run the previous simple application, we'll see that our goroutine will
    be allowed to do nothing for exactly 10 seconds, after which we implement a timeout
    safeguard that bails us out.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的简单应用程序，我们会看到我们的goroutine将被允许在10秒钟后什么都不做，之后我们实施一个超时保障，让我们退出。
- en: You can see this as being particularly useful in network applications; even
    in the days of blocking and thread-dependent servers, timeouts like these were
    implemented to prevent a single misbehaving request or process to gum up the entire
    server. This is the very basis of a classic web server problem that we'll revisit
    in more detail later.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这看作在网络应用程序中特别有用；即使在阻塞和依赖线程的服务器时代，像这样的超时也被实施以防止单个行为不端的请求或进程阻塞整个服务器。这正是我们稍后将更详细讨论的经典网络服务器问题的基础。
- en: Importance of consistency
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一致性的重要性
- en: In our example, we'll build an events scheduler. If we are available for a meeting
    and we get two concurrent requests for a meeting invite, we'll get double-booked
    should a race condition exist. Alternately, locked data across two goroutines
    may cause both the requests to be denied or will result in an actual deadlock.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将构建一个事件调度程序。如果我们可以参加会议，并且我们收到两个并发的会议邀请请求，如果存在竞争条件，我们将被重复预订。或者，两个goroutine之间的锁定数据可能会导致两个请求都被拒绝，或者导致实际死锁。
- en: We want to guarantee that any request for availability is consistent—there should
    neither be double-booking nor should a request for an event be blocked incorrectly
    (because two concurrent or parallel routines lock the data simultaneously).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望保证任何可用性请求都是一致的——既不应该出现重复预订，也不应该错误地阻止事件请求（因为两个并发或并行例程同时锁定数据）。
- en: Synchronizing our concurrent operations
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步我们的并发操作
- en: The word synchronization literally refers to temporal existence—things occurring
    at the same time. It seems then that the most apt demonstration of synchronicity
    will be something involving time itself.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 同步一词字面上指的是时间存在-事情同时发生。因此，同步性最恰当的演示似乎将涉及时间本身。
- en: 'When we think about the ways time impacts us, it''s generally a matter of scheduling,
    due dates, and coordination. Going back to our preliminary example from the Preface,
    if one wishes to plan their grandmother''s birthday party, the following types
    of scheduled tasks can take several forms:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑时间如何影响我们时，通常涉及安排、截止日期和协调。回到前言中的初步示例，如果有人想要计划他们祖母的生日派对，以下类型的安排任务可以采取多种形式：
- en: Things that must be done by a certain time (the actual party)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在某个时间之前完成的事情（实际派对）
- en: Things that cannot be done until another task is completed (putting up decorations
    before they're purchased)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直到另一个任务完成后才能完成的事情（在购买装饰品之前放置装饰品）
- en: Things that can be done in any particular order without impacting the outcome
    (cleaning the house)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以按任何特定顺序完成的事情而不会影响结果（打扫房子）
- en: Things that can be done in any order but may well impact the outcome (buying
    a cake before finding out what cake your grandmother likes the most)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以按任何顺序完成但可能会影响结果的事情（在弄清楚你祖母最喜欢的蛋糕之前买蛋糕）
- en: With these in mind, we'll attempt to handle some rudimentary human scheduling
    by designing an appointment calendar that can handle any number of people with
    one hour timeslots between 9 a.m. and 5 p.m.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些想法，我们将尝试通过设计一个预约日历来处理一些基本的人类安排，该日历可以处理任意数量的人，每个人在上午9点到下午5点之间有一个小时的时间段。
- en: The project – multiuser appointment calendar
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这个项目-多用户预约日历
- en: What do you do when you decide to write a program?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定写一个程序时，你会做什么？
- en: If you're like a lot of people, you think about the program; perhaps you and
    a team will write up a spec or requirements document, and then you'll get to coding.
    Sometimes, there will be a drawing representing some facsimile of the way the
    application will work.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和很多人一样，你会考虑这个程序；也许你和团队会起草一份规范或需求文档，然后你就开始编码。有时，会有一张图表示应用程序的工作方式的某种类似物。
- en: Quite often, the best way to nail down the architecture and the inner workings
    of an application is to put pencil to paper and visually represent the way the
    program will work. For a lot of linear or serial applications, this is often an
    unnecessary step as things will work in a predictable fashion that should not
    require any specific coordination within the application logic itself (although
    coordinating third-party software likely benefits from specification).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，确定应用程序的架构和内部工作方式的最佳方法是拿起铅笔和纸，直观地表示程序的工作方式。对于许多线性或串行应用程序来说，这通常是一个不必要的步骤，因为事情将以可预测的方式进行，不需要在应用程序逻辑内部进行任何特定的协调（尽管协调第三方软件可能会受益于规范）。
- en: 'You may be familiar with some logic that looks something like the following
    diagram:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉类似以下图表的一些逻辑：
- en: '![The project – multiuser appointment calendar](img/00012.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![该项目-多用户预约日历](img/00012.jpeg)'
- en: The logic here makes sense. If you remember from our Preface, when humans draw
    out processes, we tend to serialize them. Visually, going from step one to step
    two with a finite number of processes is easy to understand.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的逻辑是有道理的。如果您还记得我们的前言，当人类绘制流程时，我们倾向于将它们串行化。从视觉上看，从第一步到第二步，有限数量的流程是容易理解的。
- en: However, when designing a concurrent application, it's essential that we at
    least account for innumerable and concurrent requests, processes, and logic to
    make sure our application ends where we want, with the data and results we expect.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在设计并发应用程序时，至少要考虑无数的并发请求、流程和逻辑，以确保我们的应用程序最终达到我们想要的位置，并获得我们期望的数据和结果。
- en: In the previous example, we completely ignore the possibility that "Is User
    Available" could fail or report old or erroneous data. Does it make more sense
    to address such problems if and when we find them, or should we anticipate them
    as part of a control flow? Adding complexity to the model can help us reduce the
    odds of data integrity issues down the road.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们完全忽略了“用户是否可用”的可能失败或报告旧或错误数据的可能性。如果我们发现这些问题，是否更有意义去解决它们，或者应该预见它们作为控制流的一部分？向模型添加复杂性可以帮助我们减少未来数据完整性问题的几率。
- en: Let's visualize this again, taking into account availability pollers that will
    request availability for a user with any given request for a time/user pair.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次进行可视化，考虑到可用性轮询器将请求用户的可用性与任何给定的时间/用户对。
- en: Visualizing a concurrent pattern
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化并发模式
- en: 'As we have already discussed, we wish to create a basic blueprint of how our
    application should function as a starting point. Here, we''ll implement some control
    flow, which relates to user activity, to help us decide what functionality we''ll
    need to include. The following diagram illustrates how the control flow may look
    like:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，我们希望创建一个应用程序应该如何运行的基本蓝图。在这里，我们将实现一些控制流，这与用户活动有关，以帮助我们决定我们需要包含哪些功能。以下图表说明了控制流可能是什么样子：
- en: '![Visualizing a concurrent pattern](img/00013.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![可视化并发模式](img/00013.jpeg)'
- en: In the previous diagram, we anticipate where data can be shared using concurrent
    and parallel processes to locate points of failure. If we design concurrent applications
    in such graphical ways, we're less likely to find race conditions later on.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的图表中，我们预见到数据可以使用并发和并行流程共享，以找到故障点。如果我们以这种图形方式设计并发应用程序，我们就不太可能在以后发现竞争条件。
- en: While we talked about how Go helps you to locate these after the application
    has completed running, our ideal development workflow is to attempt to cut these
    problems off at the start.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们谈到了Go如何帮助您在应用程序完成运行后找到这些问题，但我们理想的开发工作流程是尝试在开始时解决这些问题。
- en: Developing our server requirements
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发我们的服务器需求
- en: 'Now that we have an idea of how the scheduling process should work, we need
    to identify components that our application will need. In this case, the components
    are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了调度过程应该如何工作的想法，我们需要确定应用程序将需要的组件。在这种情况下，组件如下：
- en: A web server handler
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器处理程序
- en: A template for output
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出的模板
- en: A system for determining dates and times
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于确定日期和时间的系统
- en: Web server
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web服务器
- en: 'In our visualizing concurrency example from the previous chapter, we used Go''s
    built-in `http` package, and we''ll do the same here. There are a number of good
    frameworks out there for this, but they primarily extend the core Go functionality
    rather than reinventing the wheel. The following are a few of these functionalities,
    listed from lightest to heaviest:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前章节的可视化并发示例中，我们使用了Go的内置`http`包，我们在这里也会这样做。有许多出色的框架可以实现这一点，但它们主要是扩展核心Go功能，而不是重新发明轮子。以下是其中一些功能，从轻到重列出：
- en: 'Web.go: [http://webgo.io/](http://webgo.io/)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web.go：[http://webgo.io/](http://webgo.io/)
- en: Web.go is very lightweight and lean, and it provides some routing functionality
    not available in the `net`/`http` package.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Web.go非常轻量级和精简，并提供了一些在`net`/`http`包中不可用的路由功能。
- en: 'Gorilla: [http://www.gorillatoolkit.org/](http://www.gorillatoolkit.org/)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大猩猩：[http://www.gorillatoolkit.org/](http://www.gorillatoolkit.org/)
- en: Gorilla is a Swiss army knife to augment the `net`/`http` package. It's not
    particularly heavy, and it is fast, utilitarian, and very clean.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla是一个瑞士军刀，用于增强`net`/`http`包。它并不特别沉重，而且速度快，实用，非常干净。
- en: 'Revel: [http://robfig.github.io/revel/](http://robfig.github.io/revel/)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Revel：[http://robfig.github.io/revel/](http://robfig.github.io/revel/)
- en: Revel is the heaviest of the three, but it focuses on a lot of intuitive code,
    caching, and performance. Look for it if you need something mature that will face
    a lot of traffic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Revel是这三者中最沉重的，但它专注于直观的代码、缓存和性能。如果您需要一个成熟的、将面临大量流量的东西，可以考虑它。
- en: In [Chapter 6](part0054_split_000.html#page "Chapter 6. C10K – A Non-blocking
    Web Server in Go"), *C10K – A Non-blocking Web Server in Go*, we'll roll our own
    web server and framework with the sole goal of extreme high performance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](part0054_split_000.html#page "Chapter 6. C10K – A Non-blocking Web Server
    in Go")中，*C10K – A Non-blocking Web Server in Go*，我们将自己开发一个旨在实现极高性能的Web服务器和框架。
- en: The Gorilla toolkit
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大猩猩工具包
- en: 'For this application, we''ll partially employ the Gorilla web toolkit. Gorilla
    is a fairly mature web-serving platform that fulfills a few of our needs here
    natively, namely the ability to include regular expressions in our URL routing.
    (Note: Web.Go also extends some of this functionality.) Go''s internal HTTP routing
    handler is rather simplistic; you can extend this, of course, but we''ll take
    a shortcut down a well-worn and reliable path here.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们将部分使用Gorilla Web工具包。 Gorilla是一个相当成熟的Web服务器平台，在这里本地实现了我们的一些需求，即能够在URL路由中包含正则表达式的能力。（注意：Web.Go还扩展了部分功能。）Go的内部HTTP路由处理程序相当简单；当然您可以扩展这个，但在这里我们将走一条经过磨练和可靠的捷径。
- en: We'll use this package solely for ease of URL routing, but the Gorilla web toolkit
    also includes packages to handle cookies, sessions, and request variables. We'll
    examine this package a little closer in [Chapter 6](part0054_split_000.html#page
    "Chapter 6. C10K – A Non-blocking Web Server in Go"), *C10K – A Non-blocking Web
    Server in Go*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅使用这个包来方便URL路由，但Gorilla Web Toolkit还包括处理cookies、会话和请求变量的包。我们将在[第6章](part0054_split_000.html#page
    "第6章。C10K – 一个Go中的非阻塞Web服务器")中更详细地研究这个包，*C10K – 一个Go中的非阻塞Web服务器*。
- en: Using templates
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模板
- en: As Go is intended as a system language, and as system languages often deal with
    the creation of servers with clients, some care was put into making it a well-featured
    alternative to create web servers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go被设计为一种系统语言，而系统语言通常涉及创建服务器和客户端，因此我们在创建Web服务器时非常注重使其成为一个功能齐全的替代方案。
- en: Anyone who's dealt with a "web language" will know that on top of that you'll
    need a framework, ideally one that handles the presentation layer for the web.
    While it's true that if you take on such a project you'll likely look for or build
    your own framework, Go makes the templating side of things very easy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 任何处理过“网络语言”的人都会知道，除此之外你还需要一个框架，理想情况下是一个处理网络呈现层的框架。虽然如果你接手这样的项目，你可能会寻找或构建自己的框架，但Go使得模板方面的事情非常容易。
- en: 'The template package comes in two varieties: `text` and `http`. Though they
    both serve different end points, the same properties—affording dynamism and flexibility—apply
    to the presentation layer rather than strictly the application layer.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 模板包有两种类型：`text`和`http`。虽然它们都服务于不同的端点，但相同的属性——提供动态性和灵活性——适用于呈现层，而不仅仅是应用层。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `text` template package is intended for general plaintext documents, while
    the `http` template package handles the generation of HTML and related documents.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`text`模板包用于一般纯文本文档，而`http`模板包用于生成HTML和相关文档。'
- en: These templating paradigms are all too common these days; if you look at the
    `http`/`template` package, you'll find some very strong similarities to Mustache,
    one of the more popular variants. While there is a Mustache port in Go, there's
    nothing there that isn't handled by default in the template package.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模板范式在今天太常见了；如果你看一下`http`/`template`包，你会发现它与Mustache有很强的相似之处，Mustache是更受欢迎的变体之一。虽然Go中有一个Mustache端口，但在模板包中默认处理了所有这些。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on Mustache, visit [http://mustache.github.io/](http://mustache.github.io/).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Mustache的更多信息，请访问[http://mustache.github.io/](http://mustache.github.io/)。
- en: 'One potential advantage to Mustache is its availability in other languages.
    If you ever feel the need to port some of your application logic to another language
    (or existing templates into Go), utilizing Mustache could be advantageous. That
    said, you sacrifice a lot of the extended functionality of Go templates, namely
    the ability to take out Go code from your compiled package and move it directly
    into template control structures. While Mustache (and its variants) has control
    flows, they may not mirror Go''s templating system. Take the following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache的一个潜在优势是它在其他语言中也是可用的。如果你曾经感到有必要将应用逻辑转移到另一种语言（或将现有模板转移到Go中），使用Mustache可能是有利的。也就是说，你牺牲了Go模板的许多扩展功能，即从编译包中取出Go代码并将其直接移入模板控制结构的能力。虽然Mustache（及其变体）有控制流，但它们可能不会与Go的模板系统相匹配。看下面的例子：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Given the familiarity with Go's logic structures, it makes sense to keep them
    consistent in our templating language as well.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于对Go逻辑结构的熟悉程度，保持它们在我们的模板语言中保持一致是有意义的。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We won't show all the specific templates in this thread, but we will show the
    output. If you wish to peruse them, they're available at [mastergoco.com/chapters/3/templates](http://mastergoco.com/chapters/3/templates).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这个帖子中展示所有具体的模板，但我们会展示输出。如果你想浏览它们，它们可以在[mastergoco.com/chapters/3/templates](http://mastergoco.com/chapters/3/templates)上找到。
- en: Time
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间
- en: We're not doing a whole lot of math here; time will be broken into hour blocks
    and each will be set to either occupied or available. At this time, there aren't
    a lot of external `date`/`time` packages for Go. We're not doing any heavy-date
    math, but it doesn't really matter because Go's `time` package should suffice
    even if we were.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有做太多的数学运算；时间将被分成小时块，每个小时块将被设置为占用或可用。目前，Go中没有太多外部的`date`/`time`包。我们没有进行任何复杂的日期数学运算，但这并不重要，因为即使我们需要，Go的`time`包也应该足够。
- en: In fact, as we have literal hour blocks from 9 a.m. to 5 p.m., we just set these
    to the 24-hour time values of 9-17, and invoke a function to translate them into
    linguistic dates.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由于我们从上午9点到下午5点有文字的时间段，我们只需将它们设置为9-17的24小时时间值，并调用一个函数将它们转换为语言日期。
- en: Endpoints
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端点
- en: 'We''ll want to identify the REST endpoints (via `GET` requests) and briefly
    describe how they''ll work. You can think of these as modules or methods in the
    model-view-controller architecture. The following is a list of the endpoint patterns
    we''ll use:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想要识别REST端点（通过`GET`请求）并简要描述它们的工作原理。你可以将它们看作是模型-视图-控制器架构中的模块或方法。以下是我们将使用的端点模式列表：
- en: '`entrypoint/register/{name}`: This is where we''ll go to add a name to the
    list of users. If the user exists, it will fail.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entrypoint/register/{name}`：这是我们将要去的地方，添加一个名字到用户列表中。如果用户存在，它将失败。'
- en: '`entrypoint/viewusers`: Here, we''ll present a list of users with their timeslots,
    both available and occupied.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entrypoint/viewusers`：在这里，我们将展示一个用户列表，包括他们的时间段，可用和占用。'
- en: '`entrypoint/schedule/{name}/{time}`: This will initialize an attempt to schedule
    an appointment.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entrypoint/schedule/{name}/{time}`：这将初始化一个预约的尝试。'
- en: Each will have an accompanying template that will report the status of the intended
    action.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都将有一个相应的模板，报告预期动作的状态。
- en: Custom structs
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义结构
- en: 'We''ll deal with users and responses (web pages), so we need two structs to
    represent each. One struct is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理用户和响应（网页），所以我们需要两个结构来表示每个。一个结构如下：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The other struct is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个结构如下：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will keep the page as simple as possible. Rather than doing a lot of iterative
    loops, we will produce the HTML within the code for the most part.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尽量保持页面尽可能简单。我们将在代码中生成大部分HTML，而不是进行大量的迭代循环。
- en: 'Our endpoints for requests will relate to our previous architecture, using
    the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的请求端点将与我们之前的架构相关联，使用以下代码：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A multiuser Appointments Calendar
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多用户预约日历
- en: 'In this section, we''ll quickly look at our sample Appointments Calendar application,
    which attempts to control consistency of specific elements to avoid obvious race
    conditions. The following is the full code, including the routing and templating:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速查看我们的样本预约日历应用程序，该应用程序试图控制特定元素的一致性，以避免明显的竞争条件。以下是完整的代码，包括路由和模板：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that we seeded our application with a user, Bill. If you attempt to hit
    `/register/bill|bill@example.com`, the application will report that the user exists.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们用一个名为Bill的用户种子化了我们的应用程序。如果您尝试访问`/register/bill|bill@example.com`，应用程序将报告该用户已存在。
- en: As we control the most sensitive data through channels, we avoid any race conditions.
    We can test this in a couple of ways. The first and easiest way is to keep a log
    of how many successful appointments are registered, and run this with Bill as
    the default user.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通过渠道控制了最敏感的数据，我们避免了任何竞争条件。我们可以通过几种方式来测试这一点。第一种最简单的方法是记录成功预约的数量，并以Bill作为默认用户运行。
- en: We can then run a concurrent load tester against the action. There are a number
    of such testers available, including Apache's ab and Siege. For our purposes,
    we'll use JMeter, primarily because it permits us to test against multiple URLs
    concurrently.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以对该操作运行并发负载测试器。有许多这样的测试器可用，包括Apache的ab和Siege。为了我们的目的，我们将使用JMeter，主要是因为它允许我们同时对多个URL进行测试。
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although we're not necessarily using JMeter for load testing (rather, we use
    it to run concurrent tests), load testers can be extraordinarily valuable ways
    to find bottlenecks in applications at scales that don't yet exist.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们并不一定使用JMeter进行负载测试（而是用它来运行并发测试），但负载测试工具可以是发现应用程序中尚不存在的规模的瓶颈的非常有价值的方式。
- en: For example, if you built a web application that had a blocking element and
    had 5,000-10,000 requests per day, you may not notice it. But at 5 million-10
    million requests per day, it might result in the application crashing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您构建了一个具有阻塞元素并且每天有5,000-10,000个请求的Web应用程序，您可能不会注意到它。但是在每天500万-1000万次请求时，它可能导致应用程序崩溃。
- en: In the dawn of network servers, this is what happened; servers scaled until
    one day, suddenly, they couldn't scale further. Load/stress testers allow you
    to simulate traffic in order to better detect these issues and inefficiencies.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络服务器的黎明时代，情况就是这样；服务器扩展到某一天，突然间，它们无法再扩展。负载/压力测试工具允许您模拟流量，以更好地检测这些问题和低效。
- en: 'Given that we have one user and eight hours in a day, we should end our script
    with no more than eight total successful appointments. Of course, if you hit the
    `/register` endpoint, you will see eight times as many users as you''ve added.
    The following screenshot shows our benchmark test plan in JMeter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们有一个用户和一天八个小时，我们应该在脚本结束时最多有八个成功的预约。当然，如果您访问`/register`端点，您将看到比您添加的用户多八倍的用户。以下截图显示了我们在JMeter中的基准测试计划：
- en: '![A multiuser Appointments Calendar](img/00014.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![多用户预约日历](img/00014.jpeg)'
- en: 'When you run your application, keep an eye on your console; at the end of our
    load test, we should see the following message:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，请注意您的控制台；在我们的负载测试结束时，我们应该会看到以下消息：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Had we designed our application as per the initial graphical mockup representation
    in this chapter (with race conditions), it's plausible—and in fact likely—that
    we'd register far more appointments than actually existed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照本章中最初的图形模拟表示设计我们的应用程序（存在竞争条件），那么我们可能会注册比实际存在的预约要多得多。
- en: 'By isolating potential race conditions, we guarantee data consistency and ensure
    that nobody is waiting on an appointment with an otherwise occupied attendee.
    The following screenshot is the list we present of all the users and their available
    appointment times:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过隔离潜在的竞争条件，我们保证数据一致性，并确保没有人在等待与其他人预约时间冲突的预约。以下截图是我们呈现的所有用户及其可用预约时间的列表：
- en: '![A multiuser Appointments Calendar](img/00015.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![多用户预约日历](img/00015.jpeg)'
- en: The previous screenshot is our initial view that shows us available users and
    their available time slots. By selecting a timeslot for a user, we'll attempt
    to book them for that particular time. We'll start with Nathan at 5 p.m.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个截图是我们的初始视图，显示了可用用户及其可用的时间段。通过为用户选择一个时间段，我们将尝试为其预约该特定时间。我们将从下午5点开始尝试Nathan。
- en: 'The following screenshot shows what happens when we attempt to schedule with
    an available user:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当我们尝试与一个可用用户安排时会发生什么：
- en: '![A multiuser Appointments Calendar](img/00016.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![多用户预约日历](img/00016.jpeg)'
- en: 'However, if we attempt to book again (even simultaneously), we''ll be greeted
    with a sad message that Nathan cannot see us at 5 p.m, as shown in the following
    screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们再次尝试预约（甚至同时），我们将收到一个悲伤的消息，即Nathan无法在下午5点见我们，如下面的截图所示：
- en: '![A multiuser Appointments Calendar](img/00017.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![多用户预约日历](img/00017.jpeg)'
- en: With that, we have a multiuser calendar app that allows for creating new users,
    scheduling, and blocking double-bookings.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们有了一个允许创建新用户、安排和阻止重复预约的多用户日历应用程序。
- en: Let's look at a few interesting new points in this application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个应用程序中一些有趣的新点。
- en: 'First, you will notice that we use a template called `generic.txt` for most
    parts of the application. There''s not much to this, only a page title and body
    filled in by each handler. However, on the `/users` endpoint, we use `users.txt`
    as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您会注意到我们在大部分应用程序中使用了一个名为`generic.txt`的模板。这并不复杂，只有一个页面标题和每个处理程序填写的正文。然而，在`/users`端点上，我们使用`users.txt`如下：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We mentioned the range-based functionality in templates, but how does `{{.FormatAvailableTimes}}`
    work? In any given context, we can have type-specific functions that process the
    data in more complex ways than are available strictly in the template lexer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模板中提到了基于范围的功能，但是`{{.FormatAvailableTimes}}`是如何工作的呢？在任何给定的上下文中，我们可以有特定于类型的函数，以比模板词法分析器严格可用的更复杂的方式处理数据。
- en: 'In this case, the `User` struct is passed to the following line of code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`User`结构体被传递到以下代码行：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This line of code then performs some conditional analysis and returns a string
    with some time conversion.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这行代码执行一些条件分析，并返回一些时间转换的字符串。
- en: 'In this example, you can use either a channel to control the flow of `User.times`
    or an explicit mutex as we have here. We don''t want to limit all locks, unless
    absolutely necessary, so we only invoke the `Lock()` function if we''ve determined
    the request has passed the tests necessary to modify the status of any given user/time
    pair. The following code shows where we set the availability of a user within
    a mutual exclusion:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以使用一个通道来控制`User.times`的流程，或者像我们这样使用一个显式的互斥锁。除非绝对必要，我们不希望限制所有锁，因此只有在确定请求已经通过必要的测试来修改任何给定用户/时间对的状态时，我们才调用`Lock()`函数。下面的代码显示了我们在互斥锁中设置用户的可用性的地方：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The outer evaluation checks that a user by that name (key) exists. The second
    evaluation checks that the time availability exists (true). If it does, we lock
    the variable, set it to `false`, and then move onto output rendering.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 外部评估检查是否存在具有该名称（键）的用户。第二次评估检查时间可用性是否存在（true）。如果是，我们锁定变量，将其设置为`false`，然后继续输出渲染。
- en: Without the `Lock()` function, many concurrent connections can compromise the
    consistency of data and cause the user to have more than one appointment in a
    given hour.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`Lock()`函数，许多并发连接可能会损害数据的一致性，并导致用户在特定小时内有多个预约。
- en: A note on style
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 风格注意事项
- en: 'You''ll note that despite preferring camelCase for most of our variables, we
    have some uppercase variables within structs. This is an important Go convention
    worth mentioning: any struct variable that begins with a capital letter is **public**.
    Any variable that begins with a lowercase letter is **private**.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们更喜欢大多数变量使用驼峰命名法，但在结构体中有一些大写变量。这是一个重要的Go约定，值得一提：任何以大写字母开头的结构体变量都是**公共的**。任何以小写字母开头的变量都是**私有的**。
- en: If you attempt to output a private (or nonexistent) variable in your template
    files, template rendering will fail.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在模板文件中输出私有（或不存在的）变量，模板渲染将失败。
- en: A note on immutability
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于不可变性的说明
- en: Note that whenever possible, we'll avoid using the string type for comparative
    operations, especially in multithreaded environments. In the previous example,
    we use integers and Booleans to decide availability for any given user. In some
    languages, you may feel empowered to assign the time values to a string for ease
    of use. For the most part, this is fine, even in Go; but assuming that we have
    an infinitely scalable, shared calendar application, we run the risk of introducing
    memory issues if we utilize strings in this way.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽可能避免在模板文件中使用字符串类型进行比较操作，特别是在多线程环境中。在前面的例子中，我们使用整数和布尔值来决定任何给定用户的可用性。在某些语言中，您可能会感到有能力将时间值分配给字符串以便使用。在大多数情况下，这是可以的，即使在Go中也是如此；但是假设我们有一个无限可扩展的共享日历应用程序，如果我们以这种方式使用字符串，就会引入内存问题的风险。
- en: 'The string type is the sole immutable type in Go; this is noteworthy if you
    end up assigning and reassigning values to a string. Assuming that memory is yielded
    after a string is converted to a copy, this is not a problem. However, in Go (and
    a couple of other languages), it''s entirely possible to keep the original value
    in memory. We can test this using the following example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，字符串类型是唯一的不可变类型；如果您最终将值分配和重新分配给字符串，这是值得注意的。假设在将字符串转换为副本后释放内存，这不是问题。然而，在Go（以及其他几种语言）中，完全有可能保留原始值在内存中。我们可以使用以下示例进行测试：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When run in Ubuntu, this takes approximately 1.0 MB of memory; some of that
    no doubt overhead, but a useful reference point. Let''s up the ante a bit—though
    having 1,000 relatively small pointers won''t have much impact—using the following
    line of code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu中运行时，这大约需要1.0 MB的内存；其中一些无疑是开销，但这是一个有用的参考点。让我们稍微加大一点——虽然有1,000个相对较小的指针不会产生太大影响——使用以下代码行：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, having gone through 100 million memory assignments, you can see the impact
    on memory (it doesn't help that the string itself is at this point longer than
    the initial, but it doesn't account for the full effect). Garbage collection takes
    place here too, which impacts CPU. On our initial test here, both CPU and memory
    spiked. If we substitute this for an integer or a Boolean assignment, we get much
    smaller footprints.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，经过1亿次内存分配，您可以看到对内存的影响（此时字符串本身比初始值更长并不会占据全部影响）。垃圾回收也会在这里发生，这会影响CPU。在我们的初始测试中，CPU和内存都会飙升。如果我们将其替换为整数或布尔值分配，我们会得到更小的印记。
- en: This is not exactly a real-world scenario, but it's worth noting in a concurrent
    environment where garbage collection must happen so we can evaluate the properties
    and types of our logic.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个真实的场景，但在并发环境中，垃圾回收必须发生，以便我们可以评估我们的逻辑的属性和类型，这是值得注意的。
- en: It's also entirely possible, depending on your current version of Go, your machine(s),
    and so on, and this could run as efficiently in either scenario. While that might
    seem fine, part of our concurrent strategy planning should involve the possibility
    that our application will scale in input, output, physical resources, or all of
    them. Just because something works well now doesn't mean it's not worth implementing
    efficiencies that will keep it from causing performance problems at a 100x scale.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您当前的Go版本、您的机器等情况，这两种情况可能都能够以高效方式运行。虽然这可能看起来不错，但是我们的并发策略规划的一部分应该包括我们的应用程序将在输入、输出、物理资源或所有这些方面扩展的可能性。现在能够很好地工作并不意味着不值得实施效率，以避免在100倍规模时引起性能问题。
- en: If you ever encounter a place where a string is logical, but you want or could
    benefit from a mutable type, consider a byte slice instead.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一个地方，那里一个字符串是合乎逻辑的，但你想要或者可以从可变类型中受益，考虑使用字节切片。
- en: A constant is, of course, also immutable, but given that's the implied purpose
    of a constant variable, you should already know this. A mutable constant variable
    is, after all, an oxymoron.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 常量当然也是不可变的，但鉴于常量变量的暗含目的，你应该已经知道这一点。可变的常量变量毕竟是一个矛盾。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has hopefully directed you towards exploring methods to plan and
    chart out your concurrent applications before delving in. By briefly touching
    on race conditions and data consistency, we attempted to highlight the importance
    of anticipatory design. At the same time, we utilized a few tools for identifying
    such issues, should they occur.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本章希望引导您在深入研究之前探索规划和绘制并发应用程序的方法。通过简要介绍竞争条件和数据一致性，我们试图突出预期设计的重要性。同时，我们利用了一些工具来识别这些问题，如果它们发生的话。
- en: Creating a robust script flowchart with concurrent processes will help you locate
    possible pitfalls before you create them, and it will give you a better sense
    of how (and when) your application should be making decisions with logic and data.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个具有并发进程的健壮脚本流程图将帮助你在创建之前找到可能的陷阱，并且它将让你更好地了解你的应用程序应该如何（以及何时）根据逻辑和数据做出决策。
- en: In the next chapter, we'll examine data consistency issues and look at advanced
    channel communication options in an effort to avoid needless and often expensive
    mitigating functions, mutexes, and external processes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究数据一致性问题，并探讨高级通道通信选项，以避免不必要且经常昂贵的缓解功能、互斥锁和外部进程。
