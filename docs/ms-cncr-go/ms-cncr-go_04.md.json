["```go\npackage main\n\nimport (\n  \"fmt\"\n  \"sync\"\n  \"time\"\n)\n\ntype TimeStruct struct {\n  totalChanges int\n  currentTime time.Time\n  rwLock sync.RWMutex\n}\n\nvar TimeElement TimeStruct\n\nfunc updateTime() {\n  TimeElement.rwLock.Lock()\n  defer TimeElement.rwLock.Unlock()\n  TimeElement.currentTime = time.Now()\n  TimeElement.totalChanges++\n}\n\nfunc main() {\n\n  var wg sync.WaitGroup\n\n  TimeElement.totalChanges = 0\n  TimeElement.currentTime = time.Now()\n  timer := time.NewTicker(1 * time.Second)\n  writeTimer := time.NewTicker(10 * time.Second)\n  endTimer := make(chan bool)\n\n  wg.Add(1)\n  go func() {\n\n    for {\n      select {\n      case <-timer.C:\n        fmt.Println(TimeElement.totalChanges, \n          TimeElement.currentTime.String())\n      case <-writeTimer.C:\n        updateTime()\n      case <-endTimer:\n        timer.Stop()\n        return\n      }\n\n    }\n\n  }()\n\n  wg.Wait()\n  fmt.Println(TimeElement.currentTime.String())\n}\n```", "```go\nfor i:= 0; i < 1000000000; i++ {\n  go someFunction()\n}\n```", "```go\npackage main\n\nimport(\n  \"fmt\"\n  \"io/ioutil\"\n  \"strconv\"\n  \"sync\"\n)\n\nfunc writeFile(i int) {\n\n  rwLock.RLock();\n  ioutil.WriteFile(\"test.txt\", \n    []byte(strconv.FormatInt(int64(i),10)), 0x777)\n  rwLock.RUnlock();\n\n  writer<-true\n\n}\n\nvar writer chan bool\nvar rwLock sync.RWMutex\n\nfunc main() {\n\n  writer = make(chan bool)\n\n  for i:=0;i<10;i++ {\n    go writeFile(i)\n  }\n\n  <-writer\n  fmt.Println(\"Done!\")\n}\n```", "```go\nimport \"C\"\n```", "```go\npackage main\n\n// #include <stdio.h>\n// #include <string.h>\n//  int string_length (char* str) {\n//    return strlen(str);\n//  }\nimport \"C\"\nimport \"fmt\"\nfunc main() {\n  v := C.CString(\"Don't Forget My Memory Is Not Visible To Go!\")\n  x := C.string_length(v)\n  fmt.Println(\"A C function has determined your string \n    is\",x,\"characters in length\")\n}\n```", "```go\n/*\n  int addition(int a, int b) {\n    return a + b;\n  }\n```", "```go\npackage main\n\nfunc MyGoFunction(num C.int) int {\n\n  squared := num * num\n  fmt.Println(num,\"squared is\",squared)\n  return squared\n}\n```", "```go\n#include <stdio.h>\n\nextern int square_it(int) __asm__ (\"cross.main.MyGoFunction\")\n\nint main() {\n\n  int output = square_it(5)\n  printf(\"Output: %d\",output)\n  return 0;\n}\n```", "```go\nall: main\n\nmain: cpart.o cpart.c\n    gcc cpart.o cpart.c -o main\n\ngopart.o: gopart.go\n    gccgo -c gopart.go -o gopart.o -fgo-prefix=cross\n\nclean:\n    rm -f main *.o\n```", "```go\npackage output\n\nimport \"C\"\n\n//export MyGoFunction\nfunc MyGoFunction(num int) int {\n\n  squared := num * num\n  return squared\n}\n```", "```go\ngo tool cgo goback.go\n```", "```go\n#include <stdio.h>\n#include \"_obj/_cgo_export.h\"\n\nextern int MyGoFunction(int num);\n\nint main() {\n\n  int result = MyGoFunction(5);\n  printf(\"Output: %d\",result);\n  return 0;\n\n}\n```", "```go\n/* Created by cgo - DO NOT EDIT. */\n#include \"_cgo_export.h\"\n\nextern void crosscall2(void (*fn)(void *, int), void *, int);\n\nextern void _cgoexp_d133c8d0d35b_MyGoFunction(void *, int);\n\nGoInt64 MyGoFunction(GoInt p0)\n{\n  struct {\n    GoInt p0;\n    GoInt64 r0;\n  } __attribute__((packed)) a;\n  a.p0 = p0;\n  crosscall2(_cgoexp_d133c8d0d35b_MyGoFunction, &a, 16);\n  return a.r0;\n}\n```", "```go\npackage main\n\n/*\n#include <stdio.h>\n\nvoid asmCall() {\n\n__asm__( \"\" );\n    printf(\"I come from a %s\",\"C function with embedded asm\\n\");\n\n}\n*/\nimport \"C\"\n\nfunc main() {\n\n    C.asmCall()\n\n}\n```", "```go\npackage main\n\n/*\nint increment(int i) {\n  i++;\n  return i;\n}\n*/\nimport \"C\"\nimport \"fmt\"\n\nvar myNumber int\n\nfunc main() {\n  fmt.Println(myNumber)\n\n  for i:=0;i<100;i++ {\n    myNumber = int( C.increment(C.int(myNumber)) )\n    fmt.Println(myNumber)\n  }\n\n}\n```", "```go\npackage main\n\nimport(\n  \"fmt\"\n)\n\nvar comm = make(chan bool)\nvar done = make(chan bool)\n\nfunc producer() {\n  for i:=0; i< 10; i++ {\n    comm <- true\n  }\n  done <- true\n}\nfunc consumer() {\n  for {\n    communication := <-comm\n    fmt.Println(\"Communication from producer \n      received!\",communication)\n  }\n}\n\nfunc main() {\n  go producer()\n  go consumer()\n  <- done\n  fmt.Println(\"All Done!\")\n}\n```", "```go\npackage main\n\nimport (\n  \"github.com/bradfitz/gomemcache/memcache\"\n  \"fmt\"\n)\n\nfunc main() {\n     mC := memcache.New(\"10.0.0.1:11211\", \"10.0.0.2:11211\", \n       \"10.0.0.3:11211\", \"10.0.0.4:11211\")\n     mC.Set(&memcache.Item{Key: \"data\", Value: []byte(\"30\") })\n\n     dataItem, err := mc.Get(\"data\")\n}\n```", "```go\nhomeChannel := make(chan bool)\n\ncircuit.Spawn(\"etphonehome.example.com\",func() {\n  homeChannel <- true\n})\n\nfor {\n  select {\n    case response := <- homeChannel:\n      fmt.Print(\"E.T. has phoned home with:\",response)\n\n  }\n}\n```"]