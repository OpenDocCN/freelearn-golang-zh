- en: Chapter 4. Data Integrity in an Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 应用程序中的数据完整性
- en: By now, you should be comfortable with the models and tools provided in Go's
    core to provide mostly race-free concurrency.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经熟悉了Go核心中提供的模型和工具，以提供大部分无竞争的并发。
- en: We can now create goroutines and channels with ease, manage basic communication
    across channels, coordinate data without race conditions, and detect such conditions
    as they arise.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松创建goroutines和通道，管理通道之间的基本通信，协调数据而不会出现竞争条件，并在出现这些条件时检测到。
- en: However, we can neither manage larger distributed systems nor deal with potentially
    lower-level consistency problems. We've utilized a basic and simplistic mutex,
    but we are about to look at a more complicated and expressive way of handling
    mutual exclusions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们既不能管理更大的分布式系统，也不能处理潜在的较低级别的一致性问题。我们使用了基本和简单的互斥锁，但我们将要看一种更复杂和富有表现力的处理互斥排他的方法。
- en: By the end of this chapter, you should be able to expand your concurrency patterns
    from the previous chapter into distributed systems using a myriad of concurrency
    models and systems from other languages. We'll also look—at a high level—at some
    consistency models that you can utilize to further express your precoding strategies
    for single-source and distributed applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您应该能够将上一章中的并发模式扩展到使用其他语言的多种并发模型和系统构建分布式系统。我们还将从高层次上看一些一致性模型，您可以利用这些模型来进一步表达您的单源和分布式应用程序的预编码策略。
- en: Getting deeper with mutexes and sync
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解互斥锁和同步
- en: In [Chapter 2](part0021_split_000.html#page "Chapter 2. Understanding the Concurrency
    Model"), *Understanding the Concurrency Model*, we introduced `sync.mutex` and
    how to invoke a mutual exclusion lock within your code, but there's some more
    nuance to consider with the package and the mutex type.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0021_split_000.html#page "第2章。理解并发模型")*理解并发模型*中，我们介绍了`sync.mutex`以及如何在代码中调用互斥锁，但在考虑包和互斥锁类型时还有一些微妙之处。
- en: We've mentioned that in an ideal world, you should be able to maintain synchronization
    in your application by using goroutines alone. In fact, this would probably be
    best described as the canonical method within Go, although the `sync` package
    does provide a few other utilities, including mutexes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，您应该能够仅使用goroutines来维护应用程序中的同步。实际上，这可能最好被描述为Go中的规范方法，尽管`sync`包提供了一些其他实用程序，包括互斥锁。
- en: Whenever possible, we'll stick with goroutines and channels to manage consistency,
    but the mutex does provide a more traditional and granular approach to lock and
    access data. If you've ever managed another concurrent language (or package within
    a language), odds are you've had experience with either a mutex or a philosophical
    analog. In the following chapters, we'll look at ways of extending and exploiting
    mutexes to do a little more out of the box.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我们将坚持使用goroutines和通道来管理一致性，但互斥锁确实提供了一种更传统和细粒度的方法来锁定和访问数据。如果您曾经管理过另一种并发语言（或语言内的包），很可能您已经使用过互斥锁或类似的东西。在接下来的章节中，我们将探讨如何扩展和利用互斥锁，以便更多地发挥其作用。
- en: If we look at the `sync` package, we'll see there are a couple of different
    mutex structs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`sync`包，我们会看到有几种不同的互斥锁结构。
- en: The first is `sync.mutex`, which we've explored—but another is `RWMutex`. The
    `RWMutex` struct provides a multireader, single-writer lock. These can be useful
    if you want to allow reads to resources but provide mutex-like locks when a write
    is attempted. They can be best utilized when you expect a function or subprocess
    to do frequent reads but infrequent writes, but it still cannot afford a dirty
    read.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`sync.mutex`，我们已经探讨过了，但另一个是`RWMutex`。`RWMutex`结构提供了多读单写锁。如果您希望允许对资源进行读取，但在尝试写入时提供类似互斥锁的锁定，这些锁可能很有用。当您期望函数或子进程频繁读取但很少写入时，它们可以最好地利用，但仍然不能承受脏读。
- en: 'Let''s look at an example that updates the date/time every 10 seconds (acquiring
    a lock), yet outputs the current value every other second, as shown in the following
    code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，每隔10秒更新一次日期/时间（获取锁定），然后每隔两秒输出当前值，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We don't explicitly run `Done()` on our `WaitGroup` struct, so this will run
    in perpetuity.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在`WaitGroup`结构上显式运行`Done()`，因此这将永久运行。
- en: 'There are two different methods for performing locks/unlocks on `RWMutex`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RWMutex`上执行锁定/解锁的两种不同方法：
- en: '`Lock()`: This will block variables for both reading and writing until an `Unlock()`
    method is called'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lock()`: 这将阻止变量进行读取和写入，直到调用`Unlock()`方法'
- en: '`happenedRlock()`: This locks bound variables solely for reads'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`happenedRlock()`: 这将仅为读取锁定绑定变量'
- en: The second method is what we've used for this example, because we want to simulate
    a real-world lock. The net effect is the `interval` function that outputs the
    current time that will return a single dirty read before `rwLock` releases the
    read lock on the `currentTime` variable. The `Sleep()` method exists solely to
    give us time to witness the lock in motion. An `RWLock` struct can be acquired
    by many readers or by a single writer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是我们用于此示例的方法，因为我们希望模拟真实世界的锁定。净效果是`interval`函数输出当前时间，然后在`rwLock`释放对`currentTime`变量的读取锁之前返回一个脏读。`Sleep()`方法仅用于给我们时间来观察锁定的运动。`RWLock`结构可以被多个读取者或单个写入者获取。
- en: The cost of goroutines
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: goroutines的成本
- en: 'As you work with goroutines, you might get to a point where you''re spawning
    dozens or even hundreds of them and wonder if this is going to be expensive. This
    is particularly true if your previous experience with concurrent and/or parallel
    programming was primarily thread-based. It''s commonly accepted that maintaining
    threads and their respective stacks can begin to bog down a program with performance
    issues. There are a few reasons for this, which are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用goroutines时，你可能会到达一个点，你会产生几十甚至几百个goroutines，并且会想知道这是否会很昂贵。如果你之前的并发和/或并行编程经验主要是基于线程的，这是特别真实的。通常认为，维护线程及其各自的堆栈可能会导致程序性能问题。这有几个原因，如下所示：
- en: Memory is required just for the creation of a thread
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为线程的创建需要内存
- en: Context switching at the OS level is more complex and expensive than in-process
    context switching
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作系统级别进行上下文切换比进程内上下文切换更复杂和昂贵
- en: Very often, a thread is spawned for a very small process that could be handled
    otherwise
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很多时候，一个线程被创建用于处理本来可以以其他方式处理的非常小的进程
- en: It's for these reasons that a lot of modern concurrent languages implement something
    akin to goroutines (C# uses the async and await mechanism, Python has greenlets/green
    threads, and so on) that simulate threads using small-scale context switching.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为这些原因，许多现代并发语言实现了类似goroutines的东西（C#使用async和await机制，Python有greenlets/green
    threads等），这些机制使用小规模的上下文切换来模拟线程。
- en: However, it's worth knowing that while goroutines are (or can be) cheap and
    cheaper than OS threads, they are not free. At a large (perhaps enormous) measure,
    even cheap and light goroutines can impact performance. This is particularly important
    to note as we begin to look at distributed systems, which often scale larger and
    at faster rates.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得知道的是，虽然goroutines是（或者可以是）廉价的，比操作系统线程更便宜，但它们并不是免费的。在大规模（也许是巨大规模）下，即使是廉价和轻量级的goroutines也会影响性能。这在我们开始研究分布式系统时尤为重要，因为这些系统通常规模更大，速度更快。
- en: 'The difference between running a function directly and running it in a goroutine
    is negligible of course. However, keep in mind that Go''s documentation states:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 直接运行函数和在goroutine中运行函数之间的差异当然是可以忽略的。然而，要记住Go的文档中指出：
- en: '*It is practical to create hundreds of thousands of goroutines in the same
    address space.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*在同一个地址空间中创建数十万个goroutines是实际可行的。*'
- en: 'Given that stack creation uses a few kilobytes per goroutine, in a modern environment,
    it''s easy to see how that could be perceived as a nonfactor. However, when you
    start talking about thousands (or millions) of goroutines running, it can and
    likely will impact the performance of any given subprocess or function. You can
    test this by wrapping functions in an arbitrary number of goroutines and benchmarking
    the average execution time and—more importantly—memory usage. At approximately
    5KB per goroutine, you may find that memory can become a factor, particularly
    on low-RAM machines or instances. If you have an application that runs heavy on
    a high-powered machine, imagine it reaching criticality in one or more lower-powered
    machines. Consider the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到每个goroutine使用几千字节的堆栈，现代环境中，很容易看出这可能被视为一个不重要的因素。然而，当你开始谈论成千上万（或者百万）个goroutines在运行时，它可能会影响任何给定子进程或函数的性能。你可以通过将函数包装在任意数量的goroutines中并对平均执行时间和——更重要的是——内存使用进行基准测试来测试这一点。每个goroutine大约占用5KB的内存，你可能会发现内存可能成为一个因素，特别是在低RAM的机器或实例上。如果你有一个在高性能机器上运行的应用程序，想象一下它在一个或多个低功率机器上达到临界点。考虑以下例子：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even if the overhead for the goroutine is cheap, what happens at 100 million
    or—as we have here—a billion goroutines running?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 即使goroutine的开销很小，但是当有1亿个或者——就像我们这里有的——10亿个goroutines在运行时会发生什么？
- en: As always, doing this in an environment that utilizes more than a single core
    can actually increase the overhead of this application due to the costs of OS
    threading and subsequent context switching.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如以往一样，在一个利用多个核心的环境中进行这样的操作实际上可能会增加应用程序的开销，因为涉及到操作系统线程和随后的上下文切换的成本。
- en: These issues are almost always the ones that are invisible unless and until
    an application begins to scale. Running on your machine is one thing, running
    at scale across a distributed system with what amounts to low-powered application
    servers is quite another.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题几乎总是在应用程序开始扩展之前是看不见的。在你的机器上运行是一回事，但在一个分布式系统中运行，尤其是在低功率应用服务器上运行，就是另一回事了。
- en: The relationship between performance and data consistency is important, particularly
    if you start utilizing a lot of goroutines with mutual exclusions, locks, or channel
    communication.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 性能和数据一致性之间的关系很重要，特别是当你开始使用大量的goroutines进行互斥、锁定或通道通信时。
- en: This becomes a larger issue when dealing with external, more permanent memory
    sources.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理外部、更持久的内存来源时，这就成为一个更大的问题。
- en: Working with files
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件
- en: 'Files are a great example of areas where data consistency issues such as race
    conditions can lead to more permanent and catastrophic problems. Let''s look at
    a piece of code that might continuously attempt to update a file to see where
    we could run into race conditions, which in turn could lead to bigger problems
    such as an application failing or losing data consistency:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 文件是数据一致性问题的一个很好的例子，比如竞争条件可能导致更加持久和灾难性的问题。让我们看一个可能不断尝试更新文件的代码片段，看看我们可能会遇到竞争条件的地方，这反过来可能会导致更大的问题，比如应用程序失败或数据一致性丢失：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Code involving file operations are rife for these sorts of potential issues,
    as mistakes are specifically *not ephemeral* and can be locked in time forever.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及文件操作的代码很容易出现这种潜在问题，因为错误通常*不是短暂的*，并且可能永远被固定在时间中。
- en: If our goroutines block at some critical point or the application fails midway
    through, we could end up with a file that has invalid data in it. In this case,
    we're simply iterating through some numbers, but you can also apply this situation
    to one involving database or datastore writes—the potential exists for persistent
    bad data instead of temporary bad data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的goroutines在某个关键点阻塞，或者应用程序在中途失败，我们可能会得到一个文件中包含无效数据的结果。在这种情况下，我们只是在一些数字中进行迭代，但您也可以将这种情况应用到涉及数据库或数据存储写入的情况——存在永久性的坏数据而不是临时的坏数据的潜在可能。
- en: This is not a problem that is exclusively solved by channels or mutual exclusions;
    rather, it requires some sort of sanity check at every step to make certain that
    data is where you and the application expect it to be at every step in the execution.
    Any operation involving `io.Writer` relies on primitives, which Go's documentation
    explicitly notes that we should not assume they are safe for parallel execution.
    In this case, we have wrapped the file writing in a mutex.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是仅通过通道或互斥来解决的问题；相反，它需要在每一步进行某种理智检查，以确保数据在执行的每一步中都在您和应用程序期望的位置。任何涉及`io.Writer`的操作都依赖于原语，Go的文档明确指出我们不应该假设它们对并行执行是安全的。在这种情况下，我们已经在互斥体中包装了文件写入。
- en: Getting low – implementing C
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降低实现C
- en: One of the most interesting developments in language design in the past decade
    or two is the desire to implement lower-level languages and language features
    via API. Java lets you do this purely externally, and Python provides a C library
    for interaction between the languages. It warrants mentioning that the reasons
    for doing this vary—among them applying Go's concurrency features as a wrapper
    for legacy C code—and you will likely have to deal with some of the memory management
    associated with introducing unmanaged code to garbage-collected applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年或二十年中，语言设计中最有趣的发展之一是希望通过API实现低级语言和语言特性。Java允许您纯粹在外部进行这样的操作，而Python提供了一个C库，用于在这两种语言之间进行交互。值得一提的是，这样做的原因各不相同——其中包括将Go的并发特性作为对遗留C代码的包装——您可能需要处理与引入非托管代码到垃圾收集应用程序相关的一些内存管理。
- en: 'Go takes a hybrid approach, allowing you to call a C interface through an import,
    which requires a frontend compiler such as GCC:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Go采取了混合方法，允许您通过导入调用C接口，这需要一个前端编译器，比如GCC：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So why would we want to do this?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们为什么要这样做呢？
- en: There are some good and bad reasons to implement C directly in your project.
    An example of a good reason might be to have direct access to the inline assembly,
    which you can do in C but not directly in Go. A bad reason could be any that has
    a solution inherent in Golang itself.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中直接实现C有一些好的和坏的原因。一个好的原因可能是直接访问内联汇编，这在C中可以做到，但在Go中不能直接做到。一个坏的原因可能是任何一个在Golang本身中有解决方案的原因。
- en: To be fair, even a bad reason is not bad if you build your application reliably,
    but it does impose an additional level of complexity to anyone else who might
    use your code. If Go can satisfy the technical and performance requirements, it's
    always better to use a single language in a single project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，即使是一个坏的原因，如果您构建应用程序可靠，也不是坏事，但它确实给可能使用您的代码的其他人增加了额外的复杂性。如果Go能满足技术和性能要求，最好在单个项目中使用单一语言。
- en: 'There''s a famous quote from C++ creator Bjarne Stroustrup on C and C++:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: C++的创造者Bjarne Stroustrup有一句著名的关于C和C++的引语：
- en: '*C makes it easy to shoot yourself in the foot; C++ makes it harder, but when
    you do, it blows your whole leg off.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*C使得自己开枪变得容易；C++使得更难，但当你这样做时，它会把你的整条腿都炸掉。*'
- en: Jokes aside (Stroustrup has a vast collection of such quips and quotes), the
    fundamental reasoning is that the complexity of C often prevents people from accidentally
    doing something catastrophic.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 开玩笑的时候（Stroustrup有大量这样的笑话和引语），基本的推理是C的复杂性经常阻止人们意外地做出灾难性的事情。
- en: As Stroustrup says, C makes it easy to make big mistakes, but the repercussions
    are often smaller due to language design than higher-level languages. Issues dealing
    with security and stability are easy to be introduced in any low-level language.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Stroustrup所说，C使犯大错变得容易，但由于语言设计，后果通常比高级语言要小。处理安全和稳定性问题很容易在任何低级语言中引入。
- en: By simplifying the language, C++ provides abstractions that make low-level operations
    easier to carry out. You can see how this might apply to using C directly in Go,
    given the latter language's syntactical sweetness and programmer friendliness.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简化语言，C++提供了使低级操作更容易进行的抽象。您可以看到这可能如何应用于在Go中直接使用C，鉴于后者语法上的甜美和程序员友好性。
- en: 'That said, working with C can highlight some of the potential pitfalls with
    regard to memory, pointers, deadlocks, and consistency, so we''ll touch upon a
    simple example as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，使用C可以突出显示关于内存、指针、死锁和一致性的潜在陷阱，所以我们将以一个简单的例子来说明：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Touching memory in cgo
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在cgo中触及内存
- en: The most important takeaway from the preceding example is to remember that anytime
    you go into or out of C, you need to manage memory manually (or at least more
    directly than with Go alone). If you've ever worked in C (or C++), you know that
    there's no automatic garbage collection, so if you request memory space, you must
    also free it. Calling C from Go does not preclude this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中最重要的收获是要记住，每当您进入或退出C时，您都需要手动管理内存（或者至少比仅使用Go更直接地管理）。如果您曾经在C（或C++）中工作过，您就会知道没有自动垃圾收集，所以如果您请求内存空间，您也必须释放它。从Go调用C并不排除这一点。
- en: The structure of cgo
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cgo的结构
- en: Importing C into Go will take you down a syntactical side route, as you probably
    noticed in the preceding code. The first thing that will appear glaringly different
    is the actual implementation of C code within your application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将C导入Go将使您走上一个语法侧路，正如您可能在前面的代码中注意到的。最显眼的不同之处是在您的应用程序中实际实现C代码。
- en: 'Any code (in comments to stop Go''s compiler from failing) directly above the
    `import "C"` directive will be interpreted as C code. The following is an example
    of a C function declared above our Go code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 任何位于`import "C"`指令上方的代码（在注释中阻止Go编译器失败）将被解释为C代码。以下是一个在我们的Go代码上方声明的C函数的示例：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Bear in mind that Go won't validate this, so if you make an error in your C
    code, it could lead to silent failure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Go不会验证这一点，因此如果您在C代码中出现错误，可能会导致静默失败。
- en: Another related warning is to remember your syntax. While Go and C share a lot
    of syntactical overlap, leave off a curly bracket or a semicolon and you could
    very well find yourself in one of those silent failure situations. Alternately,
    if you're working in the C part of your application and you go back to Go, you
    will undoubtedly find yourself wrapping loop expressions in parentheses and ending
    your lines with semicolons.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相关的警告是记住您的语法。虽然Go和C有很多语法上的重叠，但如果少了一个花括号或一个分号，您很可能会发现自己处于其中一个静默失败的情况。或者，如果您在应用程序的C部分工作，然后回到Go，您肯定会发现自己需要在循环表达式中加上括号，并在行尾加上分号。
- en: Also remember that you'll frequently have to handle type conversions between
    C and Go that don't have one-to-one analogs. For example, C does not have a built-in
    string type (you can, of course, include additional libraries for types), so you
    may need to convert between strings and char arrays. Similarly, `int` and `int64`
    might need some nonimplicit conversion, and again, you may not get the debugging
    feedback that you might expect when compiling these.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，您经常需要处理C和Go之间没有一对一对应的类型转换。例如，C没有内置的字符串类型（当然，您可以包含其他类型的库），因此您可能需要在字符串和char数组之间进行转换。同样，`int`和`int64`可能需要一些非隐式转换，而且在编译这些代码时，您可能无法获得您期望的调试反馈。
- en: The other way around
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一种方式
- en: Using C within Go is obviously a potentially powerful tool for code migration,
    implementing lower-level code, and roping in other developers, but what about
    the inverse? Just as you can call C from within Go, you can call Go functions
    as external functions within your embedded C.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中使用C显然是一个潜在的强大工具，用于代码迁移，实现低级代码，并吸引其他开发人员，但反过来呢？就像您可以从Go中调用C一样，您也可以在嵌入的C中将Go函数作为外部函数调用。
- en: The end game here is the ability to work with and within C and Go in the same
    application. By far the easiest way to handle this is by using gccgo, which is
    a frontend for GCC. This is different than the built-in Go compiler; it is possible
    to go back and forth between C and Go without gccgo, but using it makes this process
    much simpler.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最终目标是能够在同一个应用程序中与C和Go一起工作。到目前为止，处理这个问题最简单的方法是使用gccgo，它是GCC的前端。这与内置的Go编译器不同；当然，可以在C和Go之间来回切换，但使用gccgo可以使这个过程更简单。
- en: '**gopart.go**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**gopart.go**'
- en: 'The following is the code for the Go part of the interaction, which the C part
    will call as an external function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互的Go部分的代码，C部分将作为外部函数调用：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**cpart.c**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**cpart.c**'
- en: 'Now for the C part, where we make our call to our Go application''s exported
    function `MyGoFunction`, as shown in the following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是C部分的时间，我们在下面的代码片段中调用我们的Go应用程序的导出函数`MyGoFunction`。
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Makefile**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Makefile**'
- en: 'Unlike using C directly in Go, at present, doing the inverse requires the use
    of a makefile for C compilation. Here''s one that you can use to get an executable
    from the earlier simple example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接在Go中使用C不同，目前，对反向操作需要使用C编译的makefile。以下是一个您可以使用的示例，用于从之前的简单示例中获取可执行文件：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Running the makefile here should produce an executable file that calls the function
    from within C.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里运行makefile应该会生成一个可执行文件，该文件调用了C中的函数。
- en: 'However, more fundamentally, cgo allows you to define your functions as external
    functions for C directly:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更根本的是，cgo允许您直接将函数定义为C的外部函数：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, you''ll need to use the `cgo` tool directly to generate header files
    for C as shown in the following line of code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要直接使用`cgo`工具为C生成头文件，如下面的代码行所示：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point, the Go function is available for use in your C application:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Go函数可以在您的C应用程序中使用：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that if you export a Go function that contains more than one return value,
    it will be available as a struct in C rather than a function, as C does not provide
    multiple variables returned from a function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果导出一个包含多个返回值的Go函数，它将在C中作为结构体而不是函数可用，因为C不提供从函数返回多个变量的功能。
- en: At this point, you may be realizing that the true power of this functionality
    is the ability to interface with a Go application directly from existing C (or
    even C++) applications.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能意识到这种功能的真正力量是直接从现有的C（甚至C++）应用程序中与Go应用程序进行接口交互的能力。
- en: While not necessarily a true API, you can now treat Go applications as linked
    libraries within C apps and vice versa.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不一定是真正的API，但现在您可以将Go应用程序视为C应用程序中的链接库，反之亦然。
- en: 'One caveat about using `//export` directives: if you do this, your C code must
    reference these as extern-declared functions. As you may know, extern is used
    when a C application needs to call a function from another linked C file.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用`//export`指令的一个警告：如果这样做，您的C代码必须引用这些作为extern声明的函数。如您所知，当C应用程序需要从另一个链接的C文件中调用函数时，会使用extern。
- en: 'When we build our Go code in this manner, cgo generates the header file `_cgo_export.h`,
    as you saw earlier. If you want to take a look at that code, it can help you understand
    how Go translates compiled applications into C header files for this type of use:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式构建我们的Go代码时，cgo会生成头文件`_cgo_export.h`，就像您之前看到的那样。如果您想查看该代码，它可以帮助您了解Go如何将编译的应用程序转换为C头文件以供此类用途使用：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may also run into a rare scenario wherein the C code is not exactly as you
    expect, and you're unable to cajole the compiler to produce what you expect. In
    that case, you're always free to modify the header file before the compilation
    of your C application, despite the `DO NOT EDIT` warning.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会遇到一个罕见的情况，即C代码不完全符合你的期望，你无法诱使编译器产生你期望的结果。在这种情况下，你可以在编译C应用程序之前自由修改头文件，尽管会有“请勿编辑”的警告。
- en: Getting even lower – assembly in Go
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步降低 - 在Go中进行汇编
- en: If you can shoot your foot off with C and you can blow your leg off with C++,
    just imagine what you can do with assembly in Go.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以用C射击自己的脚，用C++炸掉自己的腿，那么想象一下你在Go中使用汇编可以做些什么。
- en: It isn't possible to use assembly directly in Go, but as Go provides access
    to C directly and C provides the ability to call inline assembly, you can indirectly
    use it in Go.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中直接使用汇编是不可能的，但是由于Go直接提供对C的访问，而C提供了调用内联汇编的能力，你可以间接地在Go中使用它。
- en: But again, just because something is possible doesn't mean it should be done—if
    you find yourself in need of assembly in Go, you should consider using assembly
    directly and connecting via an API.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但同样，仅仅因为某件事是可能的，并不意味着应该这样做——如果你发现自己需要在Go中使用汇编，你应该考虑直接使用汇编，并通过API连接。
- en: Among the many roadblocks that you may encounter with assembly in (C and then
    in) Go is the lack of portability. Writing inline C is one thing—your code should
    be relatively transferable between processor instruction sets and operating systems—but
    assembly is obviously something that requires a lot of specificity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用汇编语言（首先是在C中，然后是在Go中）时，你可能会遇到许多障碍，其中之一就是缺乏可移植性。编写内联C是一回事——你的代码应该在处理器指令集和操作系统之间相对可移植——但是汇编显然需要很多具体性。
- en: All that said, it's certainly better to have the option to shoot yourself in
    the foot whether you choose to take the shot or not. Use great care when considering
    whether you need C or assembly directly in your Go application. If you can get
    away with communicating between dissonant processes through an API or interprocess
    conduit, always take that route first.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，当你考虑是否需要在Go应用程序中直接使用C或汇编时，最好还是有自毁的选择，无论你选择射击与否。在考虑是否需要C或汇编直接在你的Go应用程序中时，一定要非常小心。如果你可以通过API或进程间通道在不协调的进程之间进行通信，总是首选这种方式。
- en: One very obvious drawback of using assembly in Go (or on its own or in C) is
    you lose the cross-compilation capabilities that Go provides, so you'd have to
    modify your code for every destination CPU architecture. For this reason, the
    only practical times to use Go in C are when there is a single platform on which
    your application should run.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中（或独立使用或在C中）使用汇编的一个非常明显的缺点是，你失去了Go提供的交叉编译能力，因此你必须为每个目标CPU架构修改你的代码。因此，使用Go在C中的唯一实际时机是当你的应用程序应该在单个平台上运行时。
- en: 'Here''s an example of what an ASM-in-C-in-Go application might look like. Keep
    in mind that we''ve included no ASM code, because it varies from one processor
    type to another. Experiment with some boilerplate assembly in the following `__asm__`
    section:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个ASM-in-C-in-Go应用程序的示例。请记住，我们没有包含ASM代码，因为它因处理器类型而异。在以下的`__asm__`部分尝试一些样板汇编：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If nothing else, this may provide an avenue for delving deeper into ASM even
    if you're familiar with neither assembly nor C itself. The more high-level you
    consider C and Go to be, the more practical you might see this.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有其他办法，即使你对汇编和C本身都不熟悉，这可能也会为你提供一个深入研究ASM的途径。你认为C和Go越高级，你可能会看到这一点越实际。
- en: 'For most uses, Go (and certainly C) is low-level enough to be able to squeeze
    out any performance hiccups without landing at assembly. It''s worth noting again
    that while you do lose some immediate control of memory and pointers in Go when
    you invoke C applications, that caveat applies tenfold with assembly. All of those
    nifty tools that Go provides may not work reliably or not work at all. If you
    think about the Go race detector, consider the following application:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用途来说，Go（当然还有C）的层次足够低，可以在不使用汇编的情况下解决任何性能问题。值得再次注意的是，当你调用C应用程序时，虽然你失去了对Go中内存和指针的一些直接控制，但是在调用汇编时，这个警告适用十倍。Go提供的所有这些巧妙的工具可能无法可靠地工作，或者根本无法工作。如果你考虑Go竞争检测器，可以考虑以下应用程序：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see how tossing your pointers around between Go and C might leave you
    out in the dark when you don't get what you expect out of the program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在Go和C之间抛来抛去指针可能会让你在程序没有得到你期望的结果时一筹莫展。
- en: Keep in mind that here there is a somewhat unique and perhaps unexpected kicker
    to using goroutines with cgo; they are treated by default as blocking. This isn't
    to say that you can't manage concurrency within C, but it won't happen by default.
    Instead, Go may well launch another system thread. You can manage this to some
    degree by utilizing the runtime function `runtime.LockOSThread()`. Using `LockOSThread`
    tells Go that a particular goroutine should stay within the present thread and
    no other concurrent goroutine may use this thread until `runtime.UnlockOSThread()`
    is called.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在这里使用goroutines与cgo有一个有点独特且可能意想不到的地方；它们默认被视为阻塞。这并不是说你不能在C中管理并发，但这不会默认发生。相反，Go可能会启动另一个系统线程。你可以通过利用运行时函数`runtime.LockOSThread()`在一定程度上管理这一点。使用`LockOSThread`告诉Go特定的goroutine应该留在当前线程中，直到调用`runtime.UnlockOSThread()`之前，没有其他并发的goroutine可以使用这个线程。
- en: The usefulness of this depends heavily on the necessity to call C or a C library
    directly; some libraries will play happily as new threads are created, a few others
    may segfault.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于直接调用C或C库的必要性；一些库将愉快地作为新线程被创建，而另一些可能会导致段错误。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another useful runtime call you should find useful within your Go code is `NumGcoCall()`.
    This returns the number of cgo calls made by a current process. If you need to
    lock and unlock threads, you can also use this to build an internal queue report
    to detect and prevent deadlocks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Go代码中，另一个有用的运行时调用是`NumGcoCall()`。它返回当前进程所做的cgo调用次数。如果你需要锁定和解锁线程，你也可以使用它来构建一个内部队列报告，以检测和防止死锁。
- en: None of this precludes the possibility of race conditions should you choose
    to mix and match Go and C within goroutines.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不排除如果您选择在goroutines中混合使用Go和C时可能会发生竞争条件的可能性。
- en: Of course, C itself has a few race detector tools available. Go's race detector
    itself is based on the `ThreadSanitizer` library. It should go without saying
    that you probably do not want several tools that accomplish the same thing within
    a single project.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，C本身有一些可用的竞争检测工具。Go的竞争检测器本身是基于`ThreadSanitizer`库的。毋庸置疑，您可能不希望在单个项目中使用几个完成相同任务的工具。
- en: Distributed Go
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式Go
- en: So far, we've talked quite a bit about managing data within single machines,
    though with one or more cores. This is complicated enough as is. Preventing race
    conditions and deadlocks can be hard to begin with, but what happens when you
    introduce more machines (virtual or real) to the mix?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经谈了很多关于在单个机器内管理数据的内容，尽管有一个或多个核心。这已经足够复杂了。防止竞争条件和死锁本来就很困难，但是当您引入更多的机器（虚拟或真实）时会发生什么？
- en: 'The first thing that should come to mind is that you can throw out a lot of
    the inherent tools that Go provides, and to a large degree that''s true. You can
    mostly guarantee that Go can handle internal locking and unlocking of data within
    its own, singular goroutines and channels, but what about one or more additional
    instances of an application running? Consider the following model:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先应该想到的是，您可以放弃Go提供的许多固有工具，而且在很大程度上是真的。您可以基本上保证Go可以处理其自己的、单一的goroutines和通道内的数据的内部锁定和解锁，但是如果有一个或多个额外的应用程序实例在运行呢？考虑以下模型：
- en: '![Distributed Go](img/00018.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![分布式Go](img/00018.jpeg)'
- en: Here we see that either of these threads across either process could be reading
    from or writing to our **Critical Data** at any given point. With that in mind,
    there exists a need to coordinate access to that data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到这两个进程中的任何一个线程都可能在任何给定时间点从我们的**关键数据**中读取或写入。考虑到这一点，存在协调对该数据的访问的需要。
- en: At a very high level, there are two direct strategies for handling this, a distributed
    lock or consistency hash table (consistent hashing).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常高的层面上，有两种直接的策略来处理这个问题，分布式锁或一致性哈希表（一致性哈希）。
- en: The first strategy is an extension of mutual exclusions except that we do not
    have direct and shared access to the same address space, so we need to create
    an abstraction. In other words, it's our job to concoct a lock mechanism that's
    visible to all available external entities.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种策略是互斥的扩展，只是我们没有直接和共享访问相同的地址空间，所以我们需要创建一个抽象。换句话说，我们的工作是设计一个对所有可用的外部实体可见的锁机制。
- en: The second strategy is a pattern designed specifically for caching and cache
    validation/invalidation, but it has relevancy here as well, because you can use
    it to manage where data lives in the more global address space.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种策略是一种专门设计用于缓存和缓存验证/失效的模式，但它在这里也具有相关性，因为您可以使用它来管理数据在更全局的地址空间中的位置。
- en: However, when it comes to ensuring consistency across these systems, we need
    to go deeper than this general, high-level approach.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当涉及确保这些系统之间的一致性时，我们需要比这种一般的高层方法更深入。
- en: 'Split this model down the middle and it becomes easy: channels will handle
    the concurrent flow of data and data structures, and where they don''t, you can
    use mutexes or low-level atomicity to add additional safeguards.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个模型一分为二就变得容易了：通道将处理数据和数据结构的并发流动，而在它们不处理的地方，您可以使用互斥锁或低级原子性来添加额外的保障。
- en: However, look to the right. Now you have another VM/instance or machine attempting
    to work with the same data. How can we make sure that we do not encounter reader/writer
    problems?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，看向右边。现在你有另一个VM/实例或机器试图处理相同的数据。我们如何确保我们不会遇到读者/写者问题？
- en: Some common consistency models
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些常见的一致性模型
- en: Luckily, there are some non-core Go solutions and strategies that we can utilize
    to improve our ability to control data consistency.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一些非核心的Go解决方案和策略，可以帮助我们提高控制数据一致性的能力。
- en: Let's briefly look at a few consistency models that we can employ to manage
    our data in distributed systems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看一下我们可以使用的一些一致性模型来管理分布式系统中的数据。
- en: Distributed shared memory
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式共享内存
- en: On its own, a **Distributed Shared Memory** (**DSM**) system does not intrinsically
    prevent race conditions, as it is merely a method for more than one system to
    share real or partitioned memory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式共享内存**（**DSM**）系统本身并不固有地防止竞争条件，因为它只是一种多个系统共享实际或分区内存的方法。'
- en: 'In essence, you can imagine two systems with 1 GB of memory, each allocating
    500 MB to a shared memory space that is accessible and writable by each. Dirty
    reads are possible as are race conditions unless explicitly designed. The following
    figure is a visual representation of how two systems can coordinate using shared
    memory:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，您可以想象两个具有1GB内存的系统，每个系统将500MB分配给一个可由每个系统访问和写入的共享内存空间。脏读是可能的，竞争条件也是可能的，除非明确设计。以下图表示了两个系统如何使用共享内存进行协调的视觉表示：
- en: '![Distributed shared memory](img/00019.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![分布式共享内存](img/00019.jpeg)'
- en: We'll look at one prolific but simple example of DSM shortly, and play with
    a library available to Go for test driving it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将看一下DSM的一个著名但简单的例子，并使用Go可用的库进行测试。
- en: First-in-first-out – PRAM
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先进先出 - PRAM
- en: '**Pipelined RAM** (**PRAM**) consistency is a form of first-in-first-out methodology,
    in which data can be read in order of the queued writes. This means that writes
    read by any given, separate process may be different. The following figure represents
    this concept:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**流水线RAM**（**PRAM**）一致性是一种先进先出的方法，其中数据可以按照排队写入的顺序读取。这意味着任何给定的、独立的进程读取的写入可能是不同的。以下图表示了这个概念：'
- en: '![First-in-first-out – PRAM](img/00020.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![先进先出 - PRAM](img/00020.jpeg)'
- en: Looking at the master-slave model
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 看看主从模型
- en: 'The master-slave consistency model is similar to the leader/follower model
    that we''ll look at shortly, except that the master manages all operations on
    data and broadcasts rather than receiving write operations from a slave. In this
    case, replication is the primary method of transmission of changes to data from
    the master to the slave. In the following diagram, you will find a representation
    of the master-slave model with a master server and four slaves:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 主从一致性模型与我们即将看到的领导者/追随者模型类似，只是主服务器管理数据和广播的所有操作，而不是从追随者接收写操作。在这种情况下，复制是从主服务器到从服务器传输数据更改的主要方法。在下图中，您将找到一个具有主服务器和四个从服务器的主从模型的表示：
- en: '![Looking at the master-slave model](img/00021.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![查看主从模型](img/00021.jpeg)'
- en: While we can simply duplicate this model in Go, we have more elegant solutions
    available to us.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以简单地在Go中复制这个模型，但我们有更优雅的解决方案可供选择。
- en: The producer-consumer problem
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生产者-消费者问题
- en: 'In the classic producer-consumer problem, the producer writes chunks of data
    to a conduit/buffer, while a consumer reads chunks. The issue arises when the
    buffer is full: if the producer adds to the stack, the data read will not be what
    you intend. To avoid this, we employ a channel with waits and signals. This model
    looks a bit like the following figure:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的生产者-消费者问题中，生产者将数据块写入到传送带/缓冲区，而消费者读取数据块。问题出现在缓冲区满时：如果生产者添加到堆栈，读取的数据将不是您想要的。为了避免这种情况，我们使用了带有等待和信号的通道。这个模型看起来有点像下面的图：
- en: '![The producer-consumer problem](img/00022.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![生产者-消费者问题](img/00022.jpeg)'
- en: 'If you''re looking for the semaphore implementation in Go, there is no explicit
    usage of the semaphore. However, think about the language here—fixed-size channels
    with waits and signals; sounds like a buffered channel. Indeed, by providing a
    buffered channel in Go, you give the conduit here an explicit length; the channel
    mechanism gives you the communication for waits and signals. This is incorporated
    in Go''s concurrency model. Let''s take a quick look at a producer-consumer model
    as shown in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找Go中的信号量实现，那么并没有显式使用信号量。但是，想想这里的语言——具有等待和信号的固定大小通道；听起来像是一个缓冲通道。事实上，通过在Go中提供一个缓冲通道，您为这里的传送带提供了一个明确的长度；通道机制为您提供了等待和信号的通信。这已经纳入了Go的并发模型中。让我们快速看一下下面的代码中所示的生产者-消费者模型。
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Looking at the leader-follower model
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看领导者-追随者模型
- en: 'In the leader/follower model, writes are broadcasted from a single source to
    any followers. Writes can be passed through any number of followers or be restricted
    to a single follower. Any completed writes are then broadcasted to the followers.
    This can be visually represented as the following figure:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在领导者/追随者模型中，写操作从单一源广播到任何追随者。写操作可以通过任意数量的追随者传递，也可以限制在单个追随者。任何完成的写操作然后被广播到追随者。这可以在以下图中进行可视化表示：
- en: '![Looking at the leader-follower model](img/00023.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![查看领导者-追随者模型](img/00023.jpeg)'
- en: We can see a channel analog here in Go as well. We can, and have, utilized a
    single channel to handle broadcasts to and from other followers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Go中也可以看到一个通道的类比。我们可以利用一个单一通道来处理对其他追随者的广播。
- en: Atomic consistency / mutual exclusion
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子一致性/互斥
- en: We've looked at atomic consistency quite a bit. It ensures that anything that
    is not created and used at essentially the same time will require serialization
    to guarantee the strongest form of consistency. If a value or dataset is not atomic
    in nature, we can always use a mutex to force linearizability on that data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经非常详细地研究了原子一致性。它确保任何不是在基本上同时创建和使用的东西都需要串行化，以确保最强形式的一致性。如果一个值或数据集不是原子性的，我们总是可以使用互斥锁来强制对该数据进行线性化。
- en: Serial or sequential consistency is inherently strong, but can also lead to
    performance issues and degradation of concurrency.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 串行或顺序一致性本质上是强大的，但也可能导致性能问题和并发性的降低。
- en: Atomic consistency is often considered the strongest form of ensuring consistency.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 原子一致性通常被认为是确保一致性的最强形式。
- en: Release consistency
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布一致性
- en: 'The release consistency model is a DSM variant that can delay a write''s modifications
    until the time of first acquisition from a reader. This is known as lazy release
    consistency. We can visualize lazy release consistency in the following serialized
    model:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 发布一致性模型是一种DSM变体，可以延迟写操作的修改，直到第一次从读者那里获取。这被称为延迟发布一致性。我们可以在以下序列化模型中可视化延迟发布一致性：
- en: '![Release consistency](img/00024.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![发布一致性](img/00024.jpeg)'
- en: This model as well as an eager release consistency model both require an announcement
    of a release (as the name implies) when certain conditions are met. In the eager
    model, that condition requires that a write would be read by all read processes
    in a consistent manner.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型以及急切的发布一致性模型都需要在满足某些条件时宣布发布（正如其名称所示）。在急切模型中，该条件要求写操作将以一致的方式被所有读取进程读取。
- en: In Go, there exists alternatives for this, but there are also packages out there
    if you're interested in playing with it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，存在替代方案，但如果您有兴趣尝试，也有相关的软件包。
- en: Using memcached
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用memcached
- en: If you're not familiar with memcache(d), it's a wonderful and seemingly obvious
    way to manage data across distributed systems. Go's built-in channels and goroutines
    are fantastic to manage communication and data integrity within a single machine's
    processes, but neither are built for distributed systems out of the box.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉memcache(d)，它是一种管理分布式系统中数据的美妙而显而易见的方式。Go的内置通道和goroutines非常适合管理单台机器进程中的通信和数据完整性，但它们都不是为分布式系统而设计的。
- en: Memcached, as the name implies, allows data sharing memory among multiple instances
    or machines. Initially, memcached was intended to store data for quick retrieval.
    This is useful for caching data for systems with high turnover such as web applications,
    but it's also a great way to easily share data across multiple servers and/or
    to utilize shared locking mechanisms.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，Memcached 允许在多个实例或机器之间共享内存数据。最初，memcached 旨在存储数据以便快速检索。这对于具有高周转率的系统（如
    Web 应用程序）缓存数据很有用，但也是一种轻松地在多个服务器之间共享数据和利用共享锁机制的好方法。
- en: In our earlier models, memcached falls under DSM. All available and invoked
    instances share a common, mirrored memory space within their respective memories.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的模型中，memcached 属于 DSM。所有可用和调用的实例在各自的内存中共享一个公共的镜像内存空间。
- en: 'It''s worth pointing out that race conditions can and do exist within memcached,
    and you still need a way to deal with that. Memcached provides one method to share
    data across distributed systems, but does not guarantee data atomicity. Instead,
    memcached operates on one of two methods for invalidating cached data as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，memcached 中确实存在竞争条件，你仍然需要一种处理的方法。Memcached 提供了一种在分布式系统中共享数据的方法，但并不保证数据的原子性。相反，memcached
    采用以下两种方法之一来使缓存数据失效：
- en: Data is explicitly assigned a maximum age (after which, it is removed from the
    stack)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据被明确分配了一个最大年龄（之后，它将从堆栈中删除）
- en: Or data is pushed from the stack due to all available memory being used by newer
    data
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者由于新数据使用了所有可用内存而导致数据从堆栈中被推出
- en: It's important to note that storage within memcache(d) is, obviously, ephemeral
    and not fault resistant, so it should only be used where data should be passed
    without threat of critical application failure.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，memcache(d) 中的存储显然是短暂的，而且不具有容错能力，因此它只能在不会导致关键应用程序故障的情况下使用。
- en: 'At the point where either of these conditions is met, the data disappears and
    the next call to this data will fail, meaning the data needs to be regenerated.
    Of course, you can work with some elaborate lock generation methods to make memcached
    operate in a consistent manner, although this is not standard built-in functionality
    of memcached itself. Let''s look at a quick example of memcached in Go using Brad
    Fitz''s gomemcache interface ([https://github.com/bradfitz/gomemcache](https://github.com/bradfitz/gomemcache)):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在满足这两个条件之一的时候，数据会消失，对该数据的下一次调用将失败，这意味着需要重新生成数据。当然，你可以使用一些复杂的锁生成方法来使 memcached
    以一致的方式运行，尽管这不是 memcached 本身的标准内置功能。让我们通过使用 Brad Fitz 的 gomemcache 接口 ([https://github.com/bradfitz/gomemcache](https://github.com/bradfitz/gomemcache))
    在 Go 中快速看一下 memcached 的一个例子：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you might note from the preceding example, if any of these memcached clients
    are writing to the shared memory at the same time, a race condition could still
    exist.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能从前面的例子中注意到的，如果任何这些 memcached 客户端同时写入共享内存，仍然可能存在竞争条件。
- en: The key data can exist across any of the clients that have memcached connected
    and running at the same time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关键数据可以存在于任何已连接并同时运行 memcached 的客户端中。
- en: Any client can also unset or overwrite the data at any time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 任何客户端也可以在任何时候取消或覆盖数据。
- en: Unlike a lot of implementations, you can set some more complex types through
    memcached, such as structs, assuming they are serialized. This caveat means that
    we're somewhat limited with the data we can share directly. We are obviously unable
    to use pointers as memory locations will vary from client to client.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多实现不同，你可以通过 memcached 设置一些更复杂的类型，比如结构体，假设它们已经被序列化。这个警告意味着我们在直接共享数据方面受到了一定的限制。显然，我们无法使用指针作为内存位置会因客户端而异。
- en: One method to handle data consistency is to design a master-slave system wherein
    only one node is responsible for writes and the other clients listen for changes
    via a key's existence.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据一致性的一种方法是设计一个主从系统，其中只有一个节点负责写入，而其他客户端通过键的存在来监听更改。
- en: We can utilize any other earlier mentioned models to strictly manage a lock
    on this data, although it can get especially complicated. In the next chapter,
    we'll explore some ways by which we can build distributed mutual exclusion systems,
    but for now, we'll briefly look at an alternative option.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用之前提到的任何其他模型来严格管理这些数据的锁，尽管这可能会变得特别复杂。在下一章中，我们将探讨一些构建分布式互斥系统的方法，但现在，我们简要地看一下另一种选择。
- en: Circuit
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电路
- en: An interesting third-party library to handle distributed concurrency that has
    popped up recently is Petar Maymounkov's Go' circuit. Go' circuit attempts to
    facilitate distributed coroutines by assigning channels to listen to one or more
    remote goroutines.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最近出现的一个处理分布式并发的第三方库是 Petar Maymounkov 的 Go' circuit。Go' circuit 试图通过为一个或多个远程
    goroutine 分配通道来促进分布式协程。
- en: The coolest part of Go' circuit is that simply including the package makes your
    application ready to listen and operate on remote goroutines and work with channels
    with which they are associated.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Go' circuit 最酷的部分是，只需包含该包就可以使你的应用程序准备好监听和操作远程 goroutine，并处理与它们相关联的通道。
- en: Go' circuit is in use at Tumblr, which proves it has some viability as a large-scale
    and relatively mature solutions platform.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Go' circuit 在 Tumblr 中使用，这证明它作为一个大规模和相对成熟的解决方案平台具有一定的可行性。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Go' circuit can be found at [https://github.com/gocircuit/circuit](https://github.com/gocircuit/circuit).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Go' circuit 可以在 [https://github.com/gocircuit/circuit](https://github.com/gocircuit/circuit)
    找到。
- en: Installing Go' circuit is not simple—you cannot run a simple `go get` on it—and
    requires Apache Zookeeper and building the toolkit from scratch.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Go' circuit 并不简单——你不能简单地运行 `go get`，它需要 Apache Zookeeper 并且需要从头构建工具包。
- en: 'Once done, it''s relatively simple to have two machines (or two processes if
    running locally) running Go code to share a channel. Each cog in this system falls
    under a sender or listener category, just as with goroutines. Given that we''re
    talking about network resources here, the syntax is familiar with some minor modifications:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，就可以相对简单地让两台机器（或者在本地运行时的两个进程）运行Go代码来共享一个通道。这个系统中的每个齿轮都属于发送者或监听者类别，就像goroutines一样。鉴于我们在这里谈论的是网络资源，语法与一些微小的修改是熟悉的：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see how this might make the communication between disparate machines
    playing with the same data a lot cleaner, whereas we used memcached primarily
    as a networked in-memory locking system. We're dealing with native Go code directly
    here; we have the ability to use circuits like we would in channels, without worrying
    about introducing new data management or atomicity issues. In fact, the circuit
    is built upon a goroutine itself.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这可能会使不同机器之间共享相同数据的通信变得更加清晰，而我们主要使用memcached作为网络内存锁定系统。在这里，我们直接处理原生的Go代码；我们有能力像在通道中一样使用电路，而不必担心引入新的数据管理或原子性问题。事实上，电路本身就是建立在一个goroutine之上的。
- en: 'This does, of course, still introduce some additional management issues, primarily
    as it pertains to knowing what remote machines are out there, whether they are
    active, updating the machines'' statuses, and so on. These types of issues are
    best suited for a suite such as Apache Zookeeper to handle coordination of distributed
    resources. It''s worth noting that you should be able to produce some feedback
    from a remote machine to a host: the circuit operates via passwordless SSH.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也引入了一些额外的管理问题，主要是关于了解远程机器的情况，它们是否活跃，更新机器的状态等等。这些问题最适合由Apache Zookeeper这样的套件来处理分布式资源的协调。值得注意的是，您应该能够从远程机器向主机产生一些反馈：电路通过无密码SSH运行。
- en: That also means you may need to make sure that user rights are locked down and
    that they meet with whatever security policies you may have in place.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着您可能需要确保用户权限被锁定，并且符合您可能已经制定的安全策略。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find Apache Zookeeper at [http://zookeeper.apache.org/](http://zookeeper.apache.org/).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://zookeeper.apache.org/](http://zookeeper.apache.org/)找到Apache Zookeeper。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Equipped now with some methods and models to manage not only local data across
    single or multithreaded systems, but also distributed systems, you should start
    to feel pretty comfortable with protecting the validity of data in concurrent
    and parallel processes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经掌握了一些方法和模型，不仅可以管理单个或多线程系统中的本地数据，还可以管理分布式系统，您应该开始感到对保护并发和并行进程中数据的有效性相当自信。
- en: We've looked at both forms of mutual exclusions for read and read/write locks,
    and we have started to apply these to distributed systems to prevent blocks and
    race conditions across multiple networked systems.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了读和读/写锁的两种互斥形式，并开始将其应用于分布式系统，以防止在多个网络系统中出现阻塞和竞争条件。
- en: In the next chapter, we'll explore these exclusion and data consistency concepts
    a little deeper, building non-blocking networked applications and learn to work
    with timeouts and give parallelism with channels a deeper look.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨这些排除和数据一致性概念，构建非阻塞的网络应用程序，并学习如何处理超时并深入研究通道的并行性。
- en: We'll also dig a little deeper into the sync and OS packages, in particular
    looking at the `sync.atomic` operations.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更深入地研究sync和OS包，特别是查看`sync.atomic`操作。
