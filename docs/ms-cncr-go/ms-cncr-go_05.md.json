["```go\nfunc thinkAboutKeys() {\n  for {\n    fmt.Println(\"Still Thinking\")\n    time.Sleep(1 * time.Second)\n  }\n}\n\nfunc main() {\n  fmt.Println(\"Where did I leave my keys?\")\n\n  blockChannel := make(chan int)\n  go thinkAboutKeys()\n\n  <-blockChannel\n\n  fmt.Println(\"OK I found them!\")\n}\n```", "```go\nfunc thinkAboutKeys(bC chan int) {\n  i := 0\n  max := 10\n  for {\n    if i >= max {\n      bC <- 1\n    }\n    fmt.Println(\"Still Thinking\")\n    time.Sleep(1 * time.Second)\n    i++\n  }\n}\n```", "```go\nfunc abstractListener(fxChan chan func() string ) {\n\n  fxChan <- func() string {\n\n    return \"Sent!\"\n  }\n}\n\nfunc main() {\n\n  fxChan := make (chan func() string)\n  defer close(fxChan)\n  go abstractListener(fxChan)\n  select {\n    case rfx := <- fxChan:\n    msg := rfx()\n    fmt.Println(msg)      \n    fmt.Println(\"Received!\")\n\n  }\n\n}\n```", "```go\ntype Messenger interface {\n  Relay() string\n}\n\ntype Message struct {\n  status string\n}\n\nfunc (m Message) Relay() string {\n  return m.status\n}\n\nfunc alertMessages(v chan Messenger, i int) {\n  m := new(Message)\n  m.status = \"Done with \" + strconv.FormatInt(int64(i),10)\n  v <- m\n}\n\nfunc main () {\n\n  msg := make(chan Messenger)\n\n  for i:= 0; i < 10; i++ {\n    go alertMessages(msg,i)\n  }\n\n  select {\n    case message := <-msg:\n      fmt.Println (message.Relay())\n  }\n  <- msg\n}\n```", "```go\nif Users[user.name] {\n  fmt.Fprintln(conn, \"Unfortunately, that username is in use!\");\n}\n```", "```go\n  listener, err := net.Listen(\"tcp\", \":9000\")\n  if err != nil {\n    fmt.Println (\"Could not start server!\")\n  }\n```", "```go\n  conn, err := net.Dial(\"tcp\",\"127.0.0.1:9000\")\n  if err != nil {\n    fmt.Println(\"Could not connect to server!\")\n  }\n```", "```go\nsendMessage := []byte(cM.name + \": \" + \n  strings.TrimRight(string(buf),\" \\t\\r\\n\"))\n```", "```go\nmessBuff := make([]byte,1024)\nn, err := conn.Read(messBuff)\nif err != nil {\n\n}\nmessage := string(messBuff[:n])\n```", "```go\n./chat-client nathan\nchat-client.exe nathan\n\n```", "```go\nchat-server.go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"strings\"\n  \"net\"\n  \"strconv\"\n  \"regexp\"\n)\n\nvar connectionCount int\nvar messagePool chan(string)\n\nconst (\n  INPUT_BUFFER_LENGTH = 140\n)\n```", "```go\ntype User struct {\n  Name string\n  ID int\n  Initiated bool\n```", "```go\n  UChannel chan []byte\n  Connection *net.Conn\n}\nThe User struct contains all of the information we will maintain \n  for each connection. Keep in mind here we don't do any sanity \n  checking to make sure a user doesn't exist \u2013 this doesn't \n  necessarily pose a problem in an example, but a real chat client \n  would benefit from a response should a user name already be \n  in use.\n\nfunc (u *User) Listen() {\n  fmt.Println(\"Listening for\",u.Name)\n  for {\n    select {\n      case msg := <- u.UChannel:\n        fmt.Println(\"Sending new message to\",u.Name)\n        fmt.Fprintln(*u.Connection,string(msg))\n\n    }\n  }\n}\n```", "```go\ntype ConnectionManager struct {\n  name      string\n  initiated bool\n}\n\nfunc Initiate() *ConnectionManager {\n  cM := &ConnectionManager{\n    name:      \"Chat Server 1.0\",\n    initiated: false,\n  }\n\n  return cM\n}\n```", "```go\nfunc evalMessageRecipient(msg []byte, uName string) bool {\n  eval := true\n  expression := \"@\"\n  re, err := regexp.MatchString(expression, string(msg))\n  if err != nil {\n    fmt.Println(\"Error:\", err)\n  }\n  if re == true {\n    eval = false\n    pmExpression := \"@\" + uName\n    pmRe, pmErr := regexp.MatchString(pmExpression, string(msg))\n    if pmErr != nil {\n      fmt.Println(\"Regex error\", err)\n    }\n    if pmRe == true {\n      eval = true\n    }\n  }\n  return eval\n}\n```", "```go\nfunc (cM *ConnectionManager) Listen(listener net.Listener) {\n  fmt.Println(cM.name, \"Started\")\n  for {\n\n    conn, err := listener.Accept()\n    if err != nil {\n      fmt.Println(\"Connection error\", err)\n    }\n    connectionCount++\n    fmt.Println(conn.RemoteAddr(), \"connected\")\n    user := User{Name: \"anonymous\", ID: 0, Initiated: false}\n    Users = append(Users, &user)\n    for _, u := range Users {\n      fmt.Println(\"User online\", u.Name)\n    }\n    fmt.Println(connectionCount, \"connections active\")\n    go cM.messageReady(conn, &user)\n  }\n}\n\nfunc (cM *ConnectionManager) messageReady(conn net.Conn, user \n  *User) {\n  uChan := make(chan []byte)\n\n  for {\n\n    buf := make([]byte, INPUT_BUFFER_LENGTH)\n    n, err := conn.Read(buf)\n    if err != nil {\n      conn.Close()\n      conn = nil\n    }\n    if n == 0 {\n      conn.Close()\n      conn = nil\n    }\n    fmt.Println(n, \"character message from user\", user.Name)\n    if user.Initiated == false {\n      fmt.Println(\"New User is\", string(buf))\n      user.Initiated = true\n      user.UChannel = uChan\n      user.Name = string(buf[:n])\n      user.Connection = &conn\n      go user.Listen()\n\n      minusYouCount := strconv.FormatInt(int64(connectionCount-1), \n        10)\n      conn.Write([]byte(\"Welcome to the chat, \" + user.Name + \", \n        there are \" + minusYouCount + \" other users\"))\n\n    } else {\n\n      sendMessage := []byte(user.Name + \": \" + \n        strings.TrimRight(string(buf), \" \\t\\r\\n\"))\n\n      for _, u := range Users {\n        if evalMessageRecipient(sendMessage, u.Name) == true {\n          u.UChannel <- sendMessage\n        }\n\n      }\n\n    }\n\n  }\n}geReady (per connectionManager) function instantiates new \n  connections into a User struct, utilizing first sent message as \n  the user's name.\n\nvar Users []*User\nThis is our unbuffered array (or slice) of user structs.\nfunc main() {\n  connectionCount = 0\n  serverClosed := make(chan bool)\n\n  listener, err := net.Listen(\"tcp\", \":9000\")\n  if err != nil {\n    fmt.Println (\"Could not start server!\",err)\n  }\n\n  connManage := Initiate()  \n  go connManage.Listen(listener)\n\n  <-serverClosed\n}\n```", "```go\ntype User struct {\n  name string\n}\nvar Users map[string] *User\n\nfunc main() {\n  Users := make(map[string] *User)\n}\n```", "```go\nchat-client.go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"net\"\n  \"os\"\n  \"bufio\"\n  \"strings\"\n)\ntype Message struct {\n  message string\n  user string\n}\n\nvar recvBuffer [140]byte\n\nfunc listen(conn net.Conn) {\n  for {\n\n      messBuff := make([]byte,1024)\n      n, err := conn.Read(messBuff)\n      if err != nil {\n        fmt.Println(\"Read error\",err)\n      }\n      message := string(messBuff[:n])\n      message = message[0:]\n\n      fmt.Println(strings.TrimSpace(message))\n      fmt.Print(\"> \")\n  }\n\n}\n\nfunc talk(conn net.Conn, mS chan Message) {\n\n      for {\n      command := bufio.NewReader(os.Stdin)\n        fmt.Print(\"> \")        \n                line, err := command.ReadString('\\n')\n\n                line = strings.TrimRight(line, \" \\t\\r\\n\")\n        _, err = conn.Write([]byte(line))                       \n                if err != nil {\n                        conn.Close()\n                        break\n\n                }\n      doNothing(command)  \n        }  \n\n}\n\nfunc doNothing(bf *bufio.Reader) {\n  // A temporary placeholder to address io reader usage\n\n}\nfunc main() {\n\n  messageServer := make(chan Message)\n\n  userName := os.Args[1]\n\n  fmt.Println(\"Connecting to host as\",userName)\n\n  clientClosed := make(chan bool)\n\n  conn, err := net.Dial(\"tcp\",\"127.0.0.1:9000\")\n  if err != nil {\n    fmt.Println(\"Could not connect to server!\")\n  }\n  conn.Write([]byte(userName))\n  introBuff := make([]byte,1024)    \n  n, err := conn.Read(introBuff)\n  if err != nil {\n\n  }\n  message := string(introBuff[:n])  \n  fmt.Println(message)\n\n  go talk(conn,messageServer)\n  go listen(conn)\n\n  <- clientClosed\n}\n```", "```go\nselect {\n  case mc := <- myChannel:\n    // do something\n}\n```", "```go\n<-youMayNotNeedToDoThis\nclose(youmayNotNeedToDoThis)\n```", "```go\nv := <-youMayNotNeedToDoThis\n```", "```go\npackage main\n\nimport (\n \"fmt\"\n)\n\ntype master chan Item\n\nvar feedChannel chan master\nvar done chan bool\n\ntype Item struct {\n Url  string\n Data []byte\n}\ntype Feed struct {\n Url   string\n Name  string\n Items []Item\n}\n\nvar Feeds []Feed\n\nfunc process(feedChannel *chan master, done *chan bool) {\n for _, i := range Feeds {\n  fmt.Println(\"feed\", i)\n  item := Item{}\n  item.Url = i.Url\n  itemChannel := make(chan Item)\n  *feedChannel <- itemChannel\n  itemChannel <- item\n }\n *done <- true\n}\nfunc processItem(url string) {\n // deal with individual feed items here\n fmt.Println(\"Got url\", url)\n}\n\nfunc main() {\n done := make(chan bool)\n Feeds = []Feed{Feed{Name: \"New York Times\", Url: \"http://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml\"},\n  Feed{Name: \"Wall Street Journal\", Url: \"http://feeds.wsjonline.com/wsj/xml/rss/3_7011.xml\"}}\n feedChannel := make(chan master)\n go func(done chan bool, feedChannel chan master) {\n  for {\n   select {\n   case fc := <-feedChannel:\n    select {\n    case item := <-fc:\n     processItem(item.Url)\n    }\n   default:\n   }\n  }\n }(done, feedChannel)\n go process(&feedChannel, &done)\n <-done\n fmt.Println(\"Done!\")\n}\n```", "```go\nimport\n(\n  \"fmt\"\n...\n  _ \"runtime/pprof\"\n)\n```", "```go\n./chat-server -cpuprofile=chat.prof\n```", "```go\npackage main\n\nimport (\n  \"flag\"\n  \"fmt\"\n  \"math/rand\"\n  \"os\"\n  \"runtime\"\n  \"runtime/pprof\"\n)\n\nconst ITERATIONS = 99999\nconst STRINGLENGTH = 300\n\nvar profile = flag.String(\"cpuprofile\", \"\", \"output pprof data to \n  file\")\n\nfunc generateString(length int, seed *rand.Rand, chHater chan \n  string) string {\n  bytes := make([]byte, length)\n  for i := 0; i < length; i++ {\n    bytes[i] = byte(rand.Int())\n  }\n  chHater <- string(bytes[:length])\n  return string(bytes[:length])\n}\n\nfunc generateChannel() <-chan int {\n  ch := make(chan int)\n  return ch\n}\n\nfunc main() {\n\n  goodbye := make(chan bool, ITERATIONS)\n  channelThatHatesLetters := make(chan string)\n\n  runtime.GOMAXPROCS(2)\n  flag.Parse()\n  if *profile != \"\" {\n    flag, err := os.Create(*profile)\n    if err != nil {\n      fmt.Println(\"Could not create profile\", err)\n    }\n    pprof.StartCPUProfile(flag)\n    defer pprof.StopCPUProfile()\n\n  }\n  seed := rand.New(rand.NewSource(19))\n\n  initString := \"\"\n\n  for i := 0; i < ITERATIONS; i++ {\n    go func() {\n      initString = generateString(STRINGLENGTH, seed, \n        channelThatHatesLetters)\n      goodbye <- true\n    }()\n\n  }\n  select {\n  case <-channelThatHatesLetters:\n\n  }\n  <-goodbye\n\n  fmt.Println(initString)\n\n}\n```", "```go\ngo tool pprof chat-server chat-server.prof \n\n```", "```go\nimport(_(_ \n  \"net/http/pprof\"\n  \"log\"\n  \"net/http\"\n)\n```", "```go\n  go func() {\n    log.Println(http.ListenAndServe(\"localhost:6060\", nil))\n  }()\n```", "```go\n#       0x7765e         net/http.HandlerFunc.ServeHTTP+0x3e     /usr/local/go/src/pkg/net/http/server.go:1149\n#       0x7896d         net/http.(*ServeMux).ServeHTTP+0x11d /usr/local/go/src/pkg/net/http/server.go:1416\n```", "```go\n#       0x139541        runtime/pprof.writeHeap+0x731           /usr/local/go/src/pkg/runtime/pprof/pprof.go:447\n#       0x137aa2        runtime/pprof.(*Profile).WriteTo+0xb2   /usr/local/go/src/pkg/runtime/pprof/pprof.go:229\n#       0x9f55f         net/http/pprof.handler.ServeHTTP+0x23f  /usr/local/go/src/pkg/net/http/pprof/pprof.go:165\n#       0x9f6a5         net/http/pprof.Index+0x135              /usr/local/go/src/pkg/net/http/pprof/pprof.go:177\n```", "```go\n#       0x18d96 runtime.starttheworld+0x126 \n  /usr/local/go/src/pkg/runtime/proc.c:451\n```", "```go\npackage main\n\nimport\n(\n  \"os\"\n)\n\nfunc main() {\n  panic(\"Oh No, we forgot to write a program!\")\n  os.Exit(1)\n}\n```"]