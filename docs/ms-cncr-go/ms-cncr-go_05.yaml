- en: Chapter 5. Locks, Blocks, and Better Channels
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。锁，块和更好的通道
- en: Now that we're starting to get a good grasp of utilizing goroutines in safe
    and consistent ways, it's time to look a bit more at what causes code blocking
    and deadlocks. Let's also explore the `sync` package and dive into some profiling
    and analysis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始对安全和一致地利用goroutines有了很好的把握，是时候更深入地了解是什么导致了代码的阻塞和死锁。让我们也探索一下`sync`包，并深入一些分析和分析。
- en: So far, we've built some relatively basic goroutines and complementary channels,
    but we now need to utilize some more complex communication channels between our
    goroutines. To do this, we'll implement more custom data types and apply them
    directly to channels.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一些相对基本的goroutines和互补的通道，但现在我们需要在goroutines之间利用一些更复杂的通信通道。为了做到这一点，我们将实现更多的自定义数据类型，并直接应用它们到通道中。
- en: We've not yet looked at some of Go's lower-level tools for synchronization and
    analysis, so we'll explore `sync.atomic`, a package that—along with `sync.Mutex`—allows
    for more granular control over state.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看过Go的一些用于同步和分析的低级工具，因此我们将探索`sync.atomic`，这是一个包，它与`sync.Mutex`一起允许更细粒度地控制状态。
- en: Finally, we'll delve into pprof, a fabulous tool provided by Go that lets us
    analyze our binaries for detailed information about our goroutines, threads, overall
    heap, and blocking profiles.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将深入研究pprof，这是Go提供的一个神奇的工具，它让我们分析我们的二进制文件，以获取有关我们的goroutines、线程、整体堆和阻塞概况的详细信息。
- en: Armed with some new tools and methods to test and analyze our code, we'll be
    ready to generate a robust, highly-scalable web server that can be used to safely
    and quickly handle any amount of traffic thrown at it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借一些新的工具和方法来测试和分析我们的代码，我们将准备好生成一个强大的，高度可扩展的Web服务器，可以安全快速地处理任何数量的流量。
- en: Understanding blocking methods in Go
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Go中的阻塞方法
- en: So far, we've encountered a few pieces of blocking code, intentional and unintentional,
    through our exploration and examples. At this point, it's prudent to look at the
    various ways we can introduce (or inadvertently fall victim to) blocking code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，通过我们的探索和示例，我们已经遇到了一些阻塞代码的片段，有意的和无意的。在这一点上，看看我们可以引入（或无意中成为）阻塞代码的各种方式是明智的。
- en: By looking at the various ways Go code can be blocked, we can also be better
    prepared to debug cases when concurrency is not operating as expected in our application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察Go代码被阻塞的各种方式，我们也可以更好地准备调试并发在我们的应用程序中未按预期运行的情况。
- en: Blocking method 1 – a listening, waiting channel
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞方法1-一个监听，等待的通道
- en: 'The most concurrently-focused way to block your code is by leaving a serial
    channel listening to one or more goroutines. We''ve seen this a few times by now,
    but the basic concept is shown in the following code snippet:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞代码的最具并发性的方法是通过让一个串行通道监听一个或多个goroutines。到目前为止，我们已经看到了几次，但基本概念如下代码片段所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Despite the fact that all of our looping code is concurrent, we''re waiting
    on a signal for our `blockChannel` to continue linear execution. We can, of course,
    see this in action by sending along the channel, thus continuing code execution
    as shown in the following code snippet:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们所有的循环代码都是并发的，但我们正在等待一个信号，以便我们的`blockChannel`继续线性执行。当然，我们可以通过发送通道来看到这一点，从而继续代码执行，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we've modified our goroutine function to accept our blocking channel and
    deliver an end message to it when we've hit our maximum. These kinds of mechanisms
    are important for long-running processes because we may need to know when and
    how to kill them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们修改了我们的goroutine函数，以接受我们的阻塞通道，并在达到最大值时向其发送结束消息。这些机制对于长时间运行的进程非常重要，因为我们可能需要知道何时以及如何终止它们。
- en: Sending more data types via channels
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过通道发送更多的数据类型
- en: Go's use of channels (structs and functions) as first-class citizens provides
    us with a lot of interesting ways of executing, or at least trying, new approaches
    of communication between channels.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用通道（结构和函数）作为一流公民，为我们提供了许多有趣的执行方式，或者至少尝试新的通道之间通信方式的方法。
- en: One such example is to create a channel that handles translation through a function
    itself, and instead of communicating directly through the standard syntax, the
    channel executes its function. You can even do this on a slice/array of functions
    iterating through them in the individual functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个这样的例子是创建一个通过函数本身处理翻译的通道，而不是通过标准语法直接进行通信，通道执行其函数。您甚至可以在单个函数中对它们进行迭代的函数的切片/数组上执行此操作。
- en: Creating a function channel
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个函数通道
- en: 'So far, we''ve almost exclusively worked in single data type and single value
    channels. So, let''s try sending a function across a channel. With first-class
    channels, we need no abstraction to do this; we can just send almost anything
    directly over a channel as shown in the following code snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们几乎完全是在单一数据类型和单一值通道中工作。因此，让我们尝试通过通道发送一个函数。有了一流的通道，我们不需要抽象来做到这一点；我们可以直接通过通道发送几乎任何东西，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is like a callback function. However, it also is intrinsically different,
    as it is not just the method called after the execution of a function, but also
    serves as the mode of communication between functions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像一个回调函数。然而，它也是本质上不同的，因为它不仅是在函数执行后调用的方法，而且还作为函数之间的通信方式。
- en: Keep in mind that there are often alternatives to passing functions across channels,
    so this will likely be something very specific to a use case rather than a general
    practice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，通常有替代方法可以通过通道传递函数，因此这可能是一个非常特定于用例而不是一般实践的东西。
- en: Since your channel's type can be virtually any available type, this functionality
    opens up a world of possibilities, which can be potentially confusing abstractions.
    A struct or interface as a channel type is pretty self-explanatory, as you can
    make application-related decisions on any of its defined properties.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通道的类型可以是几乎任何可用类型，这种功能性打开了一系列可能令人困惑的抽象。作为通道类型的结构或接口是相当不言自明的，因为您可以对其定义的任何属性做出与应用程序相关的决策。
- en: Let's see an example of using an interface in this way in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看一个使用接口的例子。
- en: Using an interface channel
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用接口通道
- en: 'As with our function channel, being able to pass an interface (which is a complementary
    data type) across a channel can be incredibly useful. Let''s look at an example
    of sending across an interface:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的函数通道一样，能够通过通道传递接口（这是一种补充的数据类型）可能非常有用。让我们看一个通过接口发送的例子：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a very basic example of how to utilize interfaces as channels; in the
    previous example, the interface itself is largely ornamental. In actuality, we're
    passing newly-created message types through the interface's channel rather than
    interacting directly with the interface.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何利用接口作为通道的一个非常基本的例子；在前面的例子中，接口本身在很大程度上是装饰性的。实际上，我们通过接口的通道传递新创建的消息类型，而不是直接与接口交互。
- en: Using structs, interfaces, and more complex channels
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用结构体、接口和更复杂的通道
- en: Creating a custom type for our channel allows us to dictate the way our intra-channel
    communication will work while still letting Go dictate the context switching and
    behind-the-scenes scheduling.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的通道创建一个自定义类型，可以让我们决定我们的通道内部通信的方式，同时让Go决定上下文切换和幕后调度。
- en: Ultimately, this is mostly a design consideration. In the previous examples,
    we used individual channels for specific pieces of communication in lieu of a
    one-size-fits-all channel that passes a multitude of data. However, you may also
    find it advantageous to use a single channel to handle a large amount of communication
    between goroutines and other channels.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这主要是一个设计考虑。在前面的例子中，我们使用单独的通道来处理特定的通信片段，而不是使用一个通道来传递大量的数据。然而，您可能还会发现使用单个通道来处理goroutines和其他通道之间的大量通信是有利的。
- en: The primary consideration in deciding whether to segregate channels into individual
    bits of communication or a package of communications depends on the aggregate
    mutability of each.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 决定是否将通道分隔为单独的通信片段或通信包的主要考虑因素取决于每个通道的总体可变性。
- en: For example, if you'll always want to send a counter along with a function or
    string and they will always be paired in terms of data consistency, such a method
    might make sense. If any of those components can lose synchronicity en route,
    it's more logical to keep each piece independent.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您总是想要发送一个计数器以及一个函数或字符串，并且它们在数据一致性方面总是成对出现，这样的方法可能是有意义的。如果其中任何组件在途中失去同步，保持每个片段独立更合乎逻辑。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '**Maps in Go**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Go中的映射**'
- en: As mentioned, maps in Go are like hash tables elsewhere and immediately related
    to slices or arrays.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Go中的映射就像其他地方的哈希表，与切片或数组密切相关。
- en: 'In the previous example we were checking to see if a username/key exists already;
    for this purpose Go provides a simple method for doing so. When attempting to
    retrieve a hash with a nonexistent key, a zero value is returned, as shown in
    the following lines of code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们正在检查用户名/密钥是否已经存在；为此，Go提供了一个简单的方法。当尝试检索一个不存在的键的哈希时，会返回一个零值，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This makes it syntactically simple and clean to test against a map and its keys.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得对映射及其键进行语法上的简单和清晰的测试。
- en: One of the best features of maps in Go is the ability to make keys out of any
    comparable type, which includes strings, integers, Booleans as well as any map,
    struct, slice, or channel that is comprised exclusively of those types.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Go中映射的最佳特性之一是能够使用任何可比较类型作为键，包括字符串、整数、布尔值以及任何仅由这些类型组成的映射、结构体、切片或通道。
- en: This one-to-many channel can work as a master-slave or broadcaster-subscriber
    model. We'll have a channel that listens for messages and routes them to appropriate
    users and a channel that listens for broadcast messages and queues them to all
    users.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种一对多的通道可以作为主从或广播-订阅模型。我们将有一个通道监听消息并将其路由到适当的用户，以及一个通道监听广播消息并将其排队到所有用户。
- en: To best demonstrate this, we'll create a simple multiuser chat system that allows
    Twitter style `@user` communication with a single user, with the ability to broadcast
    standard messages to all users and creates a universal broadcast chat note that
    can be read by all users. Both will be simple, custom type struct channels, so
    we can delineate various communication pieces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地演示这一点，我们将创建一个简单的多用户聊天系统，允许Twitter风格的`@user`通信与单个用户，具有向所有用户广播标准消息的能力，并创建一个可以被所有用户阅读的通用广播聊天记录。这两者都将是简单的自定义类型结构体通道，因此我们可以区分各种通信片段。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '**Structs in Go**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Go中的结构体**'
- en: As a first-class, anonymous, and extensible type, a struct is one of the most
    versatile and useful data constructs available. It's simple to create analogs
    to other data structures such as databases and data stores, and while we hesitate
    to call them objects they can certainly be viewed as such.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种一流、匿名和可扩展的类型，结构体是最多才和有用的数据结构之一。它很容易创建类似于数据库和数据存储的模拟，虽然我们不愿称它们为对象，但它们确实可以被视为对象。
- en: 'The rule of thumb as it pertains to using structs within functions is to pass
    by reference rather than by value if the struct is particularly complex. Two points
    of clarification are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就结构体在函数中的使用而言，一个经验法则是，如果结构体特别复杂，应该通过引用而不是值来传递。澄清的两点如下：
- en: Reference is in quotations because (and this is validated by Go's FAQ) technically
    everything in Go is passed by value. By that we mean that though a reference to
    a pointer still exists, at some step in the process the value(s) is copied.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用在引号中是因为（这是Go的FAQ所验证的）从技术上讲，Go中的一切都是按值传递的。这意味着虽然指针的引用仍然存在，但在过程的某个步骤中，值被复制了。
- en: '"Particularly complex" is, understandably, tough to quantify, so personal judgment
    might come into play. However, we can consider a simple struct one with no more
    than five methods or properties.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “特别复杂”是可以理解的，所以个人判断可能会起作用。然而，我们可以认为一个简单的结构体最多有五个方法或属性。
- en: You can think of this in terms of a help desk system, and while in the present
    day we'd be unlikely to create a command-line interface for such a thing, eschewing
    the web portion allows us to gloss over all of the client-side code that isn't
    necessarily relevant to Go.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这个想象成一个帮助台系统，虽然在当今，我们不太可能为这样的事情创建一个命令行界面，但是避开Web部分让我们忽略了所有与Go不相关的客户端代码。
- en: You could certainly take such an example and extrapolate it to the Web utilizing
    some frontend libraries for asynchronous functionality (such as `backbone.js`
    or `socket.io`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以拿这样的例子并将其推广到利用一些前端库进行Web的异步功能（比如`backbone.js`或`socket.io`）。
- en: To accomplish this, we'll need to create both a client and a server application,
    and we'll try to keep each as bare bone as possible. You can clearly and simply
    augment this to include any functionality you see fit such as making Git comments
    and updating a website.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要创建一个客户端和一个服务器应用程序，并尽量保持每个应用程序尽可能简单。你可以清楚简单地扩展这个功能，包括任何你认为合适的功能，比如进行Git评论和更新网站。
- en: We'll start with the server, which will be the most complicated part. The client
    application will mostly receive messages back through the socket, so much of the
    reading and routing logic will be invisible to the client-side of the process.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从服务器开始，这将是最复杂的部分。客户端应用程序将主要通过套接字接收消息，因此大部分的读取和路由逻辑对于客户端来说是不可见的。
- en: The net package – a chat server with interfaced channels
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: net包 - 一个带有接口通道的聊天服务器
- en: Here, we'll need to introduce a relevant package that will be required to handle
    most of the communication for our application(s). We've touched on the `net` package
    a bit while dabbling in the SVG output generation example to show concurrency—`net`/`http`
    is just a small part of a broader, more complex, and more feature-full package.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要引入一个相关的包，这个包将被需要来处理我们应用程序的大部分通信。我们在SVG输出生成示例中稍微涉及了一下`net`包，以展示并发性 -
    `net`/`http`只是更广泛、更复杂和更功能丰富的包的一小部分。
- en: The basic components that we'll be using will be a TCP listener (server) and
    a TCP dialer (client). Let's look at the basic setup for these.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的基本组件将是TCP监听器（服务器）和TCP拨号器（客户端）。让我们来看看这些基本设置。
- en: '**Server**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器**'
- en: 'Listening on a TCP port couldn''t be easier. Simply initiate the `net.Listen()`
    method and handle the error as shown in the following lines of code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP端口上监听不能更简单。只需启动`net.Listen()`方法并处理错误，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you get an error starting the server, check your firewall or modify the port—it's
    possible that something is utilizing port 9000 on your system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动服务器时出现错误，请检查防火墙或修改端口 - 可能有某些东西正在使用您系统上的端口9000。
- en: As easy as that is, it's just as simple on our client/dialer side.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样简单，我们的客户端/拨号器端也是一样简单的。
- en: '**Client**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端**'
- en: 'In this case, we have everything running on localhost as shown in the following
    lines of code. However, in a real-world application we''d probably have an intranet
    address used here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在localhost上运行所有内容，如下面的代码所示。然而，在实际应用中，我们可能会在这里使用一个内部网地址：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this application, we demonstrate two different ways to handle byte buffers
    of unknown lengths on `Read()`. The first is a rather crude method of trimming
    a string using `strings.TrimRight()`. This method allows you to define characters
    you aren't interested in counting as part of the input as shown in the following
    line of code. Mostly, it's whitespace characters that we can assume are unused
    parts of the buffer length.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们演示了处理未知长度的字节缓冲区的两种不同方法。第一种是使用`strings.TrimRight()`来修剪字符串的相当粗糙的方法。这种方法允许您定义您不感兴趣的字符作为输入的一部分，如下面的代码所示。大多数情况下，这是我们可以假设是缓冲区长度的未使用部分的空白字符。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Dealing with strings this way is often both inelegant and unreliable. What happens
    if we get something we don't expect here? The string will be the length of the
    buffer, which in this case is 140 bytes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式处理字符串通常既不优雅又不可靠。如果我们在这里得到了意料之外的东西会发生什么？字符串将是缓冲区的长度，在这种情况下是140个字节。
- en: 'The other way we deal with this is by using the end of the buffer directly.
    In this case, we assign the `n` variable to the `conn.Read()` function, and then
    can use that as a buffer length in the string to buffer conversion as shown in
    the following lines of code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理这个的另一种方式是直接使用缓冲区的末尾。在这种情况下，我们将`n`变量分配给`conn.Read()`函数，然后可以将其用作字符串到缓冲区转换中的缓冲区长度，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we're taking the first `n` bytes of the message buffer's received value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在接收消息缓冲区的前`n`个字节。
- en: This is more reliable and efficient, but you will certainly run into text ingestion
    cases where you will want to remove certain characters to create cleaner input.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这更加可靠和高效，但你肯定会遇到文本摄入案例，你会想要删除某些字符以创建更清洁的输入。
- en: Each connection in this application is a struct and each user is as well. We
    keep track of our users by pushing them to the `Users` slice as they join.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序中的每个连接都是一个结构，每个用户也是如此。当他们加入时，我们通过将他们推送到`Users`切片来跟踪我们的用户。
- en: 'The selected username is a command-line argument as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所选的用户名是一个命令行参数，如下所示：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We do not check to to ensure there is only one user with that name, so that
    logic might be required, particularly if chats with direct messages contain sensitive
    information.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不检查以确保只有一个用户使用该名称，因此可能需要该逻辑，特别是如果包含敏感信息的直接消息。
- en: Handling direct messages
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理直接消息
- en: For the most part, this chat client is a simple echo server, but as mentioned,
    we also include an ability to do non-globally broadcast messages by invoking the
    Twitter style `@` syntax.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这个聊天客户端是一个简单的回声服务器，但正如前面提到的，我们还包括了通过调用Twitter风格的`@`语法来进行非全局广播消息的功能。
- en: We handle this mainly through regular expressions, wherein if a message matches
    `@user` then only that user will see the message; otherwise, it's broadcasted
    to all. This is somewhat inelegant, because senders of the direct message will
    not see their own direct message if their usernames do not match the intended
    names of the users.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要通过正则表达式来处理这个问题，如果消息匹配`@user`，那么只有该用户会看到消息；否则，消息将广播给所有人。这有点不够优雅，因为直接消息的发送者如果用户名与用户的预期名称不匹配，将看不到自己的直接消息。
- en: To do this, we direct every message through a `evalMessageRecipient()` function
    before broadcasting. As this is relying on user input to create the regular expression
    (in the form of the username), please take note that we should escape this with
    the `regexp.QuoteMeta()` method to prevent regex failures.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们在广播之前将每条消息都通过`evalMessageRecipient（）`函数。由于这依赖于用户输入来创建正则表达式（以用户名的形式），请注意我们应该使用`regexp.QuoteMeta（）`方法来转义这些内容，以防止正则表达式失败。
- en: 'Let''s first examine our chat server, which is responsible for maintaining
    all connections and passing them to goroutines to listen and receive, as shown
    in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先检查一下我们的聊天服务器，它负责维护所有连接并将它们传递给goroutine来监听和接收，如下所示：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We utilize a maximum character buffer. This restricts our chat messages to
    no more than 140 characters. Let''s look at our `User` struct to see the information
    we might keep about a user that joins, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了最大字符缓冲区。这将限制我们的聊天消息不超过140个字符。让我们看看我们的“User”结构，以了解有关加入用户的信息，如下所示：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The initiated variable tells us that `User` is connected after a connection
    and announcement. Let''s examine the following code to understand the way we''d
    listen on a channel for a logged-in user:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: initiated变量告诉我们，在连接和公告之后，“User”已连接。让我们检查以下代码，以了解我们如何监听已登录用户的通道：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the core of our server: each `User` gets its own `Listen()` method,
    which maintains the `User` struct''s channel and sends and receives messages across
    it. Put simply, each user gets a concurrent channel of his or her own. Let''s
    take a look at the `ConnectionManager` struct and the `Initiate()` function that
    creates our server in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们服务器的核心：每个“用户”都有自己的“Listen（）”方法，该方法维护“User”结构的通道并在其间发送和接收消息。简单地说，每个用户都有自己的并发通道。让我们看一下以下代码中的“ConnectionManager”结构和创建服务器的“Initiate（）”函数：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our `ConnectionManager` struct is initiated just once. This sets some relatively
    ornamental attributes, some of which could be returned on request or on chat login.
    We''ll examine the `evalMessageRecipient` function that attempts to roughly identify
    the intended recipient of any message sent as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ConnectionManager`结构只初始化一次。这设置了一些相对装饰的属性，其中一些可以在请求或聊天登录时返回。我们将检查`evalMessageRecipient`函数，该函数试图粗略地确定任何发送的消息的预期接收者，如下所示：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is our router of sorts taking the `@` part of the string and using it to
    detect an intended recipient to hide from public consumption. We do not return
    an error if the user doesn't exist or has left the chat.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的路由器，它从字符串中获取`@`部分，并用它来检测一个预期的接收者，以便隐藏不被公开。如果用户不存在或已离开聊天室，我们不会返回错误。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The format for regular expressions using the `regexp` package relies on the
    `re2` syntax, which is described at [https://code.google.com/p/re2/wiki/Syntax](https://code.google.com/p/re2/wiki/Syntax).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`regexp`包的正则表达式格式依赖于`re2`语法，该语法在[https://code.google.com/p/re2/wiki/Syntax](https://code.google.com/p/re2/wiki/Syntax)中有描述。
- en: 'Let''s take a look at the code for the `Listen()` method of the `ConnectionManager`
    struct:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下“ConnectionManager”结构的“Listen（）”方法的代码：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As expected, `main()` primarily handles the connection and error and keeps our
    server open and nonblocked with the `serverClosed` channel.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，`main（）`主要处理连接和错误，并使用`serverClosed`通道保持我们的服务器开放和非阻塞。
- en: 'There are a number of methods we could employ to improve the way we route messages.
    The first method would be to invoke a map (or hash table) bound to a username.
    If the map''s key exists, we could return some error functionality if a user already
    exists, as shown in the following code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用许多方法来改进消息路由的方式。第一种方法是调用绑定到用户名的映射（或哈希表）。如果映射的键存在，我们可以返回一些错误功能，如果用户已经存在，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Examining our client
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查我们的客户端
- en: Our client application is a bit simpler primarily because we don't care as much
    about blocking code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端应用程序相对简单，主要是因为我们不太关心阻塞代码。
- en: While we do have two concurrent operations (wait for the message and wait for
    user input to send the message), this is significantly less complicated than our
    server, which needs to concurrently listen to each created user and distribute
    sent messages, respectively.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有两个并发操作（等待消息和等待用户输入以发送消息），但这比我们的服务器要简单得多，后者需要同时监听每个创建的用户并分发发送的消息。
- en: 'Let''s now compare our chat client to our chat server. Obviously, the client
    has less overall maintenance of connections and users, and so we do not need to
    use nearly as many channels. Let''s take a look at our chat client''s code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将我们的聊天客户端与我们的聊天服务器进行比较。显然，客户端对连接和用户的整体维护要少得多，因此我们不需要使用那么多的通道。让我们看看我们的聊天客户端的代码：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Blocking method 2 – the select statement in a loop
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞方法2-循环中的select语句
- en: Have you noticed yet that the `select` statement itself blocks? Fundamentally,
    the `select` statement is not different from an open listening channel; it's just
    wrapped in conditional code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否已经注意到`select`语句本身会阻塞？从根本上讲，`select`语句与开放的监听通道没有什么不同；它只是包装在条件代码中。
- en: 'The `<- myChannel` channel operates the same way as the following code snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`<- myChannel`通道的操作方式与以下代码片段相同：'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: An open listening channel is not a deadlock as long as there are no goroutines
    sleeping. You'll find this on channels that are listening but will never receive
    anything, which is another method of basically waiting.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 开放的监听通道只要没有goroutine在睡眠，就不会造成死锁。您会发现这种情况发生在那些正在监听但永远不会接收任何东西的通道上，这是另一种基本上在等待的方法。
- en: These are useful shortcuts for long-running applications you wish to keep alive
    but you may not necessarily need to send anything along that channel.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对于长时间运行的应用程序是有用的快捷方式，你希望保持其活动状态，但你可能不一定需要沿着通道发送任何东西。
- en: Cleaning up goroutines
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理goroutines
- en: Any channel that is left waiting and/or left receiving will result in a deadlock.
    Luckily, Go is pretty adept at recognizing these and you will almost without fail
    end up in a panic when running or building the application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 任何等待和/或接收的通道都会导致死锁。幸运的是，Go在识别这些方面相当擅长，当运行或构建应用程序时，你几乎肯定会陷入恐慌。
- en: Many of our examples so far have utilized the deferred `close()` method of immediately
    and cleanly grouping together similar pieces of code that should execute at different
    points.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的许多示例都利用了立即和清晰地将相似的代码组合在一起的延迟`close()`方法，这些代码应该在不同的时间点执行。
- en: While garbage collection handles a lot of the cleanup, we're largely left to
    take care of open channels to ensure we don't have a process waiting to receive
    and/or something waiting to send, both waiting at the same time for each other.
    Luckily, we'll be unable to compile any such program with a detectable deadlock
    condition, but we also need to manage closing channels that are left waiting.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管垃圾回收处理了大部分的清理工作，但我们大部分时间需要确保关闭通道，以确保我们没有一个等待接收和/或等待发送的进程，两者同时等待对方。幸运的是，我们将无法编译任何具有可检测死锁条件的程序，但我们也需要管理关闭等待的通道。
- en: 'Quite a few of the examples so far have ended with a generic integer or Boolean
    channel that just waits—this is employed almost exclusively for the channel''s
    blocking effect and allows us to demonstrate the effects and output of concurrent
    code while the application is still running. In many cases, this generic channel
    is an unnecessary bit of syntactical cruft as shown in the following lines of
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，相当多的示例都以一个通用的整数或布尔通道结束，它只是等待——这几乎完全是为了通道的阻塞效果，这样可以在应用程序仍在运行时演示并发代码的效果和输出。在许多情况下，这种通用通道是不必要的语法垃圾，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The fact that there''s no assignment happening is a good indicator this is
    an example of such cruft. If we had instead modified that to include an assignment,
    the previous code would be changed to the following instead:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 没有赋值发生的事实是一个很好的指示，表明这是这种语法垃圾的一个例子。如果我们改为包括一个赋值，前面的代码将改为以下代码：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It might indicate that the value is useful and not just arbitrary blocking code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能表明该值是有用的，而不仅仅是任意的阻塞代码。
- en: Blocking method 3 – network connections and reads
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞方法3 – 网络连接和读取
- en: If you run the code from our earlier chat server's client without starting the
    server, you'll notice that the `Dial` function blocks any subsequent goroutine.
    We can test this by imposing a longer-than-normal timeout on the connection or
    by simply closing the client application after logging in, as we did not implement
    a method for closing the TCP connection.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在没有启动服务器的情况下运行我们之前的聊天服务器客户端的代码，你会注意到`Dial`函数会阻塞任何后续的goroutine。我们可以通过在连接上施加比正常更长的超时，或者在登录后简单地关闭客户端应用程序来测试这一点，因为我们没有实现关闭TCP连接的方法。
- en: As the network reader we're using for the connection is buffered, we'll always
    have a blocking mechanism while waiting for data via TCP.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们用于连接的网络读取器是缓冲的，所以在通过TCP等待数据时，我们将始终具有阻塞机制。
- en: Creating channels of channels
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建通道的通道
- en: The preferred and sanctioned way of managing concurrency and state is exclusively
    through channels.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 管理并发和状态的首选和授权方式是完全通过通道进行。
- en: 'We''ve demonstrated a few more complex types of channels, but we haven''t looked
    at what can become a daunting but powerful implementation: channels of channels.
    This might at first sound like some unmanageable wormhole, but in some situations
    we want a concurrent action to generate more concurrent actions; thus, our goroutines
    should be capable of spawning their own.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经演示了一些更复杂类型的通道，但我们还没有看到可能成为令人生畏但强大的实现的东西：通道的通道。这起初可能听起来像一些难以管理的虫洞，但在某些情况下，我们希望一个并发动作生成更多的并发动作；因此，我们的goroutines应该能够产生自己的。
- en: As always, the way you manage this is through design while the actual code may
    simply be an aesthetic byproduct here. Building an application this way should
    make your code more concise and clean most of the time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，你通过设计来管理这一切，而实际的代码可能只是一个美学副产品。这种方式构建应用程序应该会使你的代码大部分时间更加简洁和清晰。
- en: 'Let''s revisit a previous example of an RSS feed reader to demonstrate how
    we could manage this, as shown in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新访问之前的一个RSS订阅阅读器的示例，以演示我们如何管理这一点，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we manage `feedChannel` as a custom struct that is itself a channel for
    our `Item` type. This allows us to rely exclusively on channels for synchronization
    handled through a semaphore-esque construct.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`feedChannel`管理为一个自定义结构，它本身是我们`Item`类型的通道。这使我们能够完全依赖通道进行同步，通过类似信号量的构造处理。
- en: If we want to look at another way of handling a lower-level synchronization,
    `sync.atomic` provides some simple iterative patterns that allow you to manage
    synchronization directly in memory.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想看看另一种处理低级同步的方法，`sync.atomic`提供了一些简单的迭代模式，允许你直接在内存中管理同步。
- en: As per Go's documentation, these operations require great care and are prone
    to data consistency errors, but if you need to touch memory directly, this is
    the way to do it. When we talk about advanced concurrency features, we'll utilize
    this package directly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Go的文档，这些操作需要非常小心，并且容易出现数据一致性错误，但如果你需要直接操作内存，这就是做到这一点的方法。当我们谈论高级并发特性时，我们将直接使用这个包。
- en: Pprof – yet another awesome tool
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pprof – 又一个令人敬畏的工具
- en: Just when you think you've seen the entire spectrum of Go's amazing tool set,
    there's always one more utility that, once you realize it exists, you'll wonder
    how you ever survived without it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就在你以为你已经看到了Go令人惊叹的工具集的全部范围时，总会有一个更多的实用程序，一旦你意识到它的存在，你会想知道你以前是如何生存下来的。
- en: Go format is great for cleaning up your code; the `-race` flag is essential
    for detecting possible race conditions, but an even more robust, hands-in-the-dirt
    tool exists that is used to analyze your final application, and that is pprof.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Go格式非常适合清理您的代码；`-race`标志对于检测可能的竞争条件至关重要，但是还存在一个更健壮的、更实用的工具，用于分析您的最终应用程序，那就是pprof。
- en: Google created pprof initially to analyze loop structures and memory allocation
    (and related types) for C++ applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Google最初创建pprof来分析C++应用程序的循环结构和内存分配（以及相关类型）。
- en: It's particularly useful if you think you have performance issues not uncovered
    by the testing tools provided in the Go runtime. It's also a fantastic way to
    generate a visual representation of the data structures in any application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为性能问题没有被Go运行时提供的测试工具发现，这将非常有用。这也是生成任何应用程序中数据结构的可视化表示的绝佳方式。
- en: Some of this functionality also exists as part of the Go testing package and
    its benchmarking tools—we'll explore that more in [Chapter 7](part0060_split_000.html#page
    "Chapter 7. Performance and Scalability"), *Performance and Scalability*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些功能也作为Go测试包及其基准测试工具的一部分存在-我们将在[第7章](part0060_split_000.html#page "第7章。性能和可伸缩性")中更多地探讨这一点，*性能和可伸缩性*。
- en: Getting the runtime version of pprof to work requires a few pieces of setup
    first. We'll need to include the `runtime.pprof` package and the `flag` package,
    which allows command-line parsing (in this case, for the output of pprof).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使pprof运行时版本起作用需要先进行一些设置。我们需要包括`runtime.pprof`包和`flag`包，它允许命令行解析（在这种情况下，用于pprof的输出）。
- en: If we take our chat server code, we can add a couple of lines and have the application
    prepped for performance profiling.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拿我们的聊天服务器代码来说，我们可以添加几行代码，使应用程序准备好进行性能分析。
- en: 'Let''s make sure we include those two packages along with our other packages.
    We can use the underscore syntax to indicate to the compiler that we''re only
    interested in the package''s side effects (meaning we get the package''s initialization
    functions and global variables) as shown in the following lines of code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们将这两个包与其他包一起包含。我们可以使用下划线语法来告诉编译器我们只对包的副作用感兴趣（这意味着我们获得包的初始化函数和全局变量），如下面的代码所示：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This tells our application to generate a CPU profiler if it does not exist,
    start the profiling at the beginning of the execution, and defer the end of the
    profiling until the application exits successfully.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们的应用程序生成一个CPU分析器（如果不存在），在执行开始时开始分析，并在应用程序成功退出时推迟分析的结束。
- en: 'With this created, we can run our binary with the `cpuprofile` flag, which
    tells the program to generate a profile file as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以使用`cpuprofile`标志运行我们的二进制文件，告诉程序生成一个配置文件，如下所示：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the sake of variety (and exploiting more resources arbitrarily), we''ll
    abandon the chat server for a moment and create a loop generating scores of goroutines
    before exiting. This should give us a more exciting demonstration of profiling
    data than a simple and long-living chat server would, although we''ll return to
    that briefly:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了多样化（并任意地利用更多资源），我们将暂时放弃聊天服务器，并在退出之前创建一个循环生成大量的goroutines。这应该给我们一个比简单而长期的聊天服务器更激动人心的性能分析数据演示，尽管我们会简要地回到那个话题：
- en: 'Here is our example code that generates more detailed and interesting profiling
    data:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的示例代码，它生成了更详细和有趣的性能分析数据：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we generate a profile file out of this, we can run the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从中生成一个配置文件时，我们可以运行以下命令：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will start the pprof application itself. This gives us a few commands
    that report on the static, generated file as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动pprof应用程序本身。这给了我们一些命令，报告静态生成的文件，如下所示：
- en: '`topN`: This shows the top *N* samples from the profile file, where *N* represents
    the explicit number you want to see.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`topN`：这显示配置文件中的前*N*个样本，其中*N*表示您想要查看的显式数字。'
- en: '`web`: This creates a visualization of data, exports it to SVG, and opens it
    in a web browser. To get the SVG output, you''ll need to install Graphviz as well
    ([http://www.graphviz.org/](http://www.graphviz.org/)).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web`：这将创建数据的可视化，将其导出为SVG，并在Web浏览器中打开。要获得SVG输出，您还需要安装Graphviz（[http://www.graphviz.org/](http://www.graphviz.org/)）。'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also run pprof with some flags directly to output in several formats
    or launch a browser as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以直接运行pprof并使用一些标志以多种格式输出，或者启动浏览器，如下所示：
- en: '`--text`: This generates a text report'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--text`：这将生成文本报告'
- en: '`--web`: This generates an SVG and opens in the browser'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--web`：这将生成SVG并在浏览器中打开'
- en: '`--gv`: This generates the Ghostview postscript'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--gv`：这将生成Ghostview后置文件'
- en: '`--pdf`: This generates the PDF to output'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--pdf`：这将生成PDF输出'
- en: '`--SVG`: This generates the SVG to output'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--SVG`：这将生成SVG输出'
- en: '`--gif`: This generates the GIF to output'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--gif`：这将生成GIF输出'
- en: The command-line results will be telling enough, but it's especially interesting
    to see the blocking profile of your application presented in a descriptive, visual
    way as shown in the following figure. When you're in the pprof tool, just type
    in `web` and a browser will spawn with the CPU profiling detailed in SVG form.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '命令行结果将足够说明问题，但是以描述性的、可视化的方式呈现应用程序的阻塞配置文件尤其有趣，如下图所示。当您在pprof工具中时，只需输入`web`，浏览器将以SVG形式显示CPU分析的详细信息。 '
- en: '![Pprof – yet another awesome tool](img/00025.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![Pprof-又一个令人惊叹的工具](img/00025.jpeg)'
- en: The idea here is less about the text and more about the complexity
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法不是关于文本，而是关于复杂性
- en: And voila, we suddenly have an insight into how our program utilizes the CPU
    time consumption and a general view of how our application executes, loops, and
    exits.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们突然对程序如何利用CPU时间消耗以及我们的应用程序执行、循环和退出的一般视图有了深入了解。
- en: In typical Go fashion, the pprof tool also exists in the `net`/`http` package,
    although it's more data-centric than visual. This means that rather than dealing
    exclusively with a command-line tool, you can output the results directly to the
    Web for analysis.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的Go风格，pprof工具也存在于`net`/`http`包中，尽管它更注重数据而不是可视化。这意味着，您可以将结果直接输出到Web进行分析，而不仅仅是处理命令行工具。
- en: 'Like the command-line tool, you''ll see block, goroutine, heap, and thread
    profiles as well as a full stack outline directly through localhost, as shown
    in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令行工具一样，您将看到块、goroutine、堆和线程配置文件，以及通过localhost直接查看完整堆栈轮廓，如下面的屏幕截图所示：
- en: '![Pprof – yet another awesome tool](img/00026.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Pprof – yet another awesome tool](img/00026.jpeg)'
- en: To generate this server, you just need to include a few key lines of code in
    your application, build it, and then run it. For this example, we've included
    the code in our chat server application, which allows us to get the Web view of
    an otherwise command-line-only application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成此服务器，您只需在应用程序中包含几行关键代码，构建它，然后运行它。在本例中，我们已经在我们的聊天服务器应用程序中包含了代码，这使我们可以在原本只能在命令行中使用的应用程序中获得Web视图。
- en: 'Make sure you have the `net`/`http` and `log` packages included. You''ll also
    need the `http`/`pprof` package. The code snippet is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 确保包括`net`/`http`和`log`包。您还需要`http`/`pprof`包。代码片段如下：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then simply include this code somewhere in your application, ideally, near
    the top of the `main()` function, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后只需在应用程序的某个地方包含此代码，最好是在`main()`函数的顶部附近，如下所示：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As always, the port is entirely a matter of preference.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，端口完全是个人偏好的问题。
- en: 'You can then find a number of profiling tools at `localhost:6060`, including
    the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在`localhost:6060`找到许多配置工具，包括以下内容：
- en: All tools can be found at `http://localhost:6060/debug/pprof/`
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有工具都可以在`http://localhost:6060/debug/pprof/`找到
- en: Blocking profiles cab be found at `http://localhost:6060/debug/pprof/block?debug=1`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞配置文件可以在`http://localhost:6060/debug/pprof/block?debug=1`找到
- en: A profile of all goroutines can be found at `http://localhost:6060/debug/pprof/goroutine?debug=1`
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有goroutine的配置文件可以在`http://localhost:6060/debug/pprof/goroutine?debug=1`找到
- en: A detailed profile of the heap can be found at `http://localhost:6060/debug/pprof/heap?debug=1`
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆的详细配置文件可以在`http://localhost:6060/debug/pprof/heap?debug=1`找到
- en: A profile of threads created can be found at `http://localhost:6060/debug/pprof/threadcreate?debug=1`
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程创建的配置文件可以在`http://localhost:6060/debug/pprof/threadcreate?debug=1`找到
- en: In addition to the blocking profile, you may find a utility to track down inefficiency
    in your concurrent strategy through the thread creation profile. If you find a
    seemingly abnormal amount of threads created, you can toy with the synchronization
    structure as well as runtime parameters to streamline this.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阻塞配置文件外，您还可以通过线程创建配置文件找到并发策略中的低效性。如果发现创建的线程数量异常，可以尝试调整同步结构和运行时参数以优化。
- en: 'Keep in mind that using pprof this way will also include some analyses and
    profiles that can be attributed to the `http` or `pprof` packages rather than
    your core code. You will find certain lines that are quite obviously not part
    of your application; for example, a thread creation analysis of our chat server
    includes a few telling lines, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用pprof这种方式也会包括一些分析和配置文件，这些可以归因于`http`或`pprof`包，而不是您的核心代码。您会发现某些明显不属于您应用程序的行；例如，我们的聊天服务器的线程创建分析包括一些显著的行，如下所示：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Given that we specifically eschewed delivering our chat application via HTTP
    or web sockets in this iteration, this should be fairly evident.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们在这个迭代中明确避免通过HTTP或网络套接字传递我们的聊天应用程序，这应该是相当明显的。
- en: 'On top of that, there are even more obvious smoking guns, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有更明显的迹象，如下所示：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Some system and Go core mechanisms we will never be able to reduce out of our
    final compiled binaries are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远无法从最终编译的二进制文件中减少一些系统和Go核心机制，如下所示：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The hexadecimal value represents the address in the memory of the function when
    run.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制值表示运行时函数在内存中的地址。
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'A note for Windows users: pprof is a breeze to use in *nix environments but
    may take some more arduous tweaking under Windows. Specifically, you may need
    a bash replacement such as Cygwin. You may also find some necessary tweaks to
    pprof itself (in actuality, a Perl script) may be in order. For 64-bit Windows
    users, make sure you install ActivePerl and execute the pprof Perl script directly
    using the 64-bit version of Perl.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户：在*nix环境中使用pprof非常简单，但在Windows下可能需要一些更费力的调整。具体来说，您可能需要一个类似Cygwin的bash替代工具。您可能还需要对pprof本身（实际上是一个Perl脚本）进行一些必要的调整。对于64位Windows用户，请确保安装ActivePerl，并使用Perl的64位版本直接执行pprof
    Perl脚本。
- en: At publish time, there are also some issues running this on 64-bit OSX.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布时，在64位OSX上也存在一些问题。
- en: Handling deadlocks and errors
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理死锁和错误
- en: Anytime you encounter a deadlock error upon compilation in your code, you'll
    see the familiar string of semi-cryptic errors explaining which goroutine was
    left holding the bag, so to speak.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在代码编译时遇到死锁错误时，您将看到熟悉的一串半加密的错误，解释了哪个goroutine被留下来处理问题。
- en: 'However, keep in mind you always have the ability to invoke your own panic
    using Go''s built-in panic, and this can be incredibly useful for building your
    own error-catching safeguards to ensure data consistency and ideal operation.
    The code is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，您始终可以使用Go的内置panic来触发自己的panic，这对于构建自己的错误捕获保障以确保数据一致性和理想操作非常有用。代码如下：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This can be utilized anywhere you wish to give detailed exit information to
    either developers or end users.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在任何您希望向开发人员或最终用户提供详细退出信息的地方使用。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Having explored some new ways to examine the way that Go code can block and
    deadlock, we also have some tools at our disposal that can be used to examine
    CPU profiles and resource usage now.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了一些检查Go代码阻塞和死锁的新方法之后，我们现在还有一些工具可供使用，用于检查CPU配置文件和资源使用情况。
- en: Hopefully, by this point, you can build some complex concurrent systems with
    simple goroutines and channels all the way up to multiplexed channels of structs,
    interfaces, and other channels.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到这一点，你可以用简单的goroutines和通道构建一些复杂的并发系统，一直到结构体、接口和其他通道的复用通道。
- en: We've built some somewhat-functional applications so far, but next we're going
    to utilize everything we've done to build a usable web server that solves a classic
    problem and can be used to design intranets, file storage systems, and more.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一些功能上比较完善的应用程序，但接下来我们将利用我们所做的一切来构建一个可用的Web服务器，解决一个经典问题，并可用于设计内部网络、文件存储系统等。
- en: 'In the next chapter, we''ll take what we''ve done in this chapter with regard
    to extensible channels and apply it to solving one of the oldest challenges the
    Internet has to offer: concurrently serving 10,000 (or more) connections.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们在本章中所做的关于可扩展通道的工作应用到解决互联网所面临的最古老的挑战之一：同时为10,000（或更多）个连接提供服务。
