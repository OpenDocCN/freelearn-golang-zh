["```go\npackage main\n\nimport (\n\"os\"\n\"flag\"\n\"fmt\"\n\"runtime/pprof\"\n)\n\nconst TESTLENGTH = 100000\ntype CPUHog struct {\n  longByte []byte\n}\n\nfunc makeLongByte() []byte {\n  longByte := make([]byte,TESTLENGTH)\n\n  for i:= 0; i < TESTLENGTH; i++ {\n    longByte[i] = byte(i)\n  }\n  return longByte\n}\n\nvar profile = flag.String(\"cpuprofile\", \"\", \"output pprof data to \n  file\")\n\nfunc main() {\n  var CPUHogs []CPUHog\n\n  flag.Parse()\n    if *profile != \"\" {\n      flag,err := os.Create(*profile)\n      if err != nil {\n        fmt.Println(\"Could not create profile\",err)\n      }\n      pprof.StartCPUProfile(flag)\n      defer pprof.StopCPUProfile()\n\n    }\n\n  for i := 0; i < TESTLENGTH; i++ {\n    hog := CPUHog{}\n    hog.longByte = makeLongByte()\n    _ = append(CPUHogs,hog)\n  }\n}\n```", "```go\ntype MemoryHog struct {\n  a,b,c,d,e,f,g int64\n  h,i,j,k,l,m,n float64\n  longByte []byte\n}\n```", "```go\ntype MemoryHog struct {\n  a,b,c,d,e,f,g int64\n  h,i,j,k,l,m,n float64\n  longByte []byte\n}\n\nfunc makeMemoryHog() []MemoryHog {\n\n  memoryHogs := make([]MemoryHog,TESTLENGTH)\n\n  for i:= 0; i < TESTLENGTH; i++ {\n    m := MemoryHog{}\n    _ = append(memoryHogs,m)\n  }\n\n  return memoryHogs\n}\n\nvar profile = flag.String(\"cpuprofile\", \"\", \"output pprof data to \n  file\")\n\nfunc main() {\n  var CPUHogs []CPUHog\n\n  flag.Parse()\n    if *profile != \"\" {\n      flag,err := os.Create(*profile)\n      if err != nil {\n        fmt.Println(\"Could not create profile\",err)\n      }\n      pprof.StartCPUProfile(flag)\n      defer pprof.StopCPUProfile()\n\n    }\n\n  for i := 0; i < TESTLENGTH; i++ {\n    hog := CPUHog{}\n    hog.mHog = makeMemoryHog()\n    _ = append(CPUHogs,hog)\n  }\n}\n```", "```go\nconst TESTLENGTH = 20000\n\ntype DataType struct {\n  a,b,c,d,e,f,g int64\n  longByte []byte  \n}\n\nfunc (dt DataType) init() {\n\n}\n\nvar profile = flag.String(\"cpuprofile\", \"\", \"output pprof data to \n  file\")\n\nfunc main() {\n\n  flag.Parse()\n    if *profile != \"\" {\n      flag,err := os.Create(*profile)\n      if err != nil {\n        fmt.Println(\"Could not create profile\",err)\n      }\n      pprof.StartCPUProfile(flag)\n      defer pprof.StopCPUProfile()\n    }\n  var wg sync.WaitGroup\n\n  numCPU := runtime.NumCPU()\n  runtime.GOMAXPROCS(numCPU)\n\n  wg.Add(TESTLENGTH)\n\n  for i := 0; i < TESTLENGTH; i++ {\n    go func() {\n      for y := 0; y < TESTLENGTH; y++ {\n        dT := DataType{}\n        dT.init()\n      }\n      wg.Done()\n    }()\n  }\n\n  wg.Wait()\n\n  fmt.Println(\"Complete.\")\n}\n```", "```go\npprof.Lookup(\"goroutine\").WriteTo(os.Stdout, 1)\n```", "```go\n  go func() {\n    log.Println(http.ListenAndServe(\"localhost:6000\", nil))\n  }()\n```", "```go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"net\"\n\n)\n```", "```go\ntype Subscriber struct {\n  Address net.Addr\n  Connection net.Conn\n  do chan Task  \n}\n\ntype Task struct {\n  name string\n}\n```", "```go\nvar SubscriberCount int\nvar Subscribers []Subscriber\nvar CurrentSubscriber int\nvar taskChannel chan Task\n\nfunc (sb Subscriber) awaitTask() {\n  select {\n    case t := <-sb.do:\n      fmt.Println(t.name,\"assigned\")\n\n  }\n}\n\nfunc serverListen (listener net.Listener) {\n  for {\n    conn,_ := listener.Accept()\n\n    SubscriberCount++\n\n    subscriber := Subscriber{ Address: conn.RemoteAddr(), \n      Connection: conn }\n    subscriber.do = make(chan Task)\n    subscriber.awaitTask()\n    _ = append(Subscribers,subscriber)\n\n  }\n}\n\nfunc doTask() {\n  for {\n    select {\n      case task := <-taskChannel:\n        fmt.Println(task.name,\"invoked\")\n        Subscribers[CurrentSubscriber].do <- task\n        if (CurrentSubscriber+1) > SubscriberCount {\n          CurrentSubscriber = 0\n        }else {\n          CurrentSubscriber++\n        }\n    }\n\n  }\n}\n\nfunc main() {\n\n  destinationStatus := make(chan int)\n\n  SubscriberCount = 0\n  CurrentSubscriber = 0\n\n  taskChannel = make(chan Task)\n\n  listener, err := net.Listen(\"tcp\", \":9000\")\n  if err != nil {\n    fmt.Println (\"Could not start server!\",err)\n  }\n  go serverListen(listener)  \n  go doTask()\n\n  <-destinationStatus\n}\n```", "```go\nif (CurrentSubscriber+1) > SubscriberCount {\n  CurrentSubscriber = 0\n}else {\n  CurrentSubscriber++\n}\n```", "```go\nfunc serverListen (listener net.Listener) {\n  for {\n    conn,_ := listener.Accept()\n\n    SubscriberCount++\n\n    subscriber := Subscriber{ Address: conn.RemoteAddr(), \n      Connection: conn }\n    subscriber.awaitTask()\n    _ = append(Subscribers,subscriber)\n    broadcast()\n  }\n}\n```", "```go\nfunc broadcast() {\n  for i:= range Subscribers {\n    for j:= range Subscribers {\n      Subscribers[i].Connection.Write\n        ([]byte(\"Subscriber:\",Subscriber[j].Address))  \n    }\n  }\n}\n```", "```go\ntype URL struct {\n  URI string\n  Status int\n  Assigned Subscriber\n  SubscriberID int\n}\n```", "```go\n  URLs = []URL{ {Status:0,URL:\"http://golang.org/\"}, \n    {Status:0,URL:\"http://play.golang.org/\"}, \n      {Status:0,URL:\"http://golang.org/doc/\"}, \n        {Status:0,URL:\"http://blog.golang.org/\"} }\n```", "```go\ntype Assignment struct {\n  command string\n  data string\n  successResponse string\n  errorResponse string\n}\n...\n  asmnt := Assignment{command:\"process\",\n    url:\"http://www.golang.org\",successResponse:\"success\",\n      errorResponse:\"error\"}\n  json, _ := json.Marshal(asmnt )\n  send(string(json))\n```", "```go\nfrom subprocess import call\ncall([remoteCode])\n```", "```go\n      var mem runtime.MemProfileRecord\n      obj := mem.InUseObjects();\n      bytes := mem.InUseBytes();\n      stack := mem.Stack();\n      fmt.Println(i,obj,bytes)\n```"]