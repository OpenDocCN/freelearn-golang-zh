["```go\nimport\n(\n    \"labix.org/v2/mgo\"\n    \"labix.org/v2/mgo/bson\"\n)\n\ntype User struct {\n  name string\n}\n\nfunc main() {\n  servers, err := mgo.Dial(\"localhost\")\n  defer servers.Close()\n  data := servers.DB(\"test\").C(\"users\")\n  result := User{}\n  err = c.Find(bson.M{\"name\": \"John\"}).One(&result)\n}\n```", "```go\n    go get github.com/fzzy/radix/redis\n\n    ```", "```go\n    go get github.com/garyburd/redigo/redis\n\n    ```", "```go\npackage main\n\nimport\n(\n    \"fmt\"\n    \"github.com/garyburd/redigo/redis\"\n)\n\nfunc main() {\n\n  connection,_ := dial()\n  defer connection.Close()\n\n  data, err := redis.Values(connection.Do(\"SORT\", \"Users\", \"BY\", \"User:*->name\", \n    \"GET\", \"User:*->name\"))\n\n  if (err) {\n    fmt.Println(\"Error getting values\", err)\n  }\n\n  for i:= range data {\n    var Uname string\n    data,err := redis.Scan(data, &Uname)\n    if (err) {\n      fmt.Println(\"Error getting value\",err)\n    }else {\n      fmt.Println(\"Name Uname\")\n    }\n  }\n}\n```", "```go\n  data, err := redis.Values(connection.Do(\"SORT\", \"Users\", \"BY\", \"User:*->name\", \n    \"GET\", \"User:*->name\"))\n```", "```go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"json\"\n  \"http\"\n)\n\ntype Collection struct {\n  Name string\n}\n```", "```go\nfunc main() {\n\n  Col := Collection{\n    Name: ''\n  }\n\n  data, err := http.Get(\"http://localhost:8080/all\")\n  if (err != nil) {\n    fmt.Println(\"Error accessing tiedot\")\n  }\n  collections,_ = json.Unmarshal(data,&Col)\n}\n```", "```go\npackage main\n\nimport\n(\n    \"github.com/gocql/gocql\"\n    \"log\"\n)\n\nfunc main() {\n\n  cass := gocql.NewCluster(\"127.0.0.1\")\n  cass.Keyspace = \"filemaster\"\n  cass.Consistency = gocql.LocalQuorum\n\n  session, _ := cass.CreateSession()\n  defer session.Close()\n\n  var fileTime int;\n\n  if err := session.Query(`SELECT file_modified_time FROM filemaster \n  WHERE filename = ? LIMIT 1`, \"test.txt\").Consistency(gocql.One).Scan(&fileTime); err != nil {\n    log.Fatal(err)\n  }\n  fmt.Println(\"Last modified\",fileTime)\n}\n```", "```go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"github.com/couchbaselabs/go-couchbase\"\n)\n\nfunc main() {\n\n    conn, err := couchbase.Connect(\"http://localhost:8091\")\n    if err != nil {\n      fmt.Println(\"Error:\",err)\n    }\n    for _, pn := range conn.Info.Pools {\n        fmt.Printf(\"Found pool:  %s -> %s\\n\", pn.Name, pn.URI)\n    }\n}\n```", "```go\n{\n  \"file_name\": \"test.txt\",\n  \"hash\": \"\",\n  \"created\": 1,\n  \"created_user\": 0,\n  \"last_modified\": \"\",\n  \"last_modified_user\": \"\",\n  \"revisions\": [],\n  \"version\": 1\n}\n```", "```go\npackage main\n\nimport (\n    \"github.com/howeyc/fsnotify\"\"fmt\"\n  \"log\"\"\n)\n\nfunc main() {\n\n    scriptDone := make(chan bool)\n    dirSpy, err := fsnotify.NewWatcher()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    go func() {\n        for {\n            select {\n            case fileChange := <-dirSpy.Event:\n                log.Println(\"Something happened to a file:\", \n                  fileChange)\n            case err := <-dirSpy.Error:\n                log.Println(\"Error with fsnotify:\", err)\n            }\n        }\n    }()\n\n    err = dirSpy.Watch(\"/mnt/sharedir\")\n    if err != nil {\n      fmt.Println(err)\n    }\n\n    <-scriptDone\n\n    dirSpy.Close()\n}\n```", "```go\ngo get code.google.com/p/log4go\n\n```", "```go\npackage main\n\nimport\n(\n  logger \"code.google.com/p/log4go\"\n)\nfunc main() {\n  logMech := make(logger.Logger);\n  logMech.AddFilter(\"stdout\", logger.DEBUG, \n    logger.NewConsoleLogWriter())\n\n  fileLog := logger.NewFileLogWriter(\"log_manager.log\", false)\n  fileLog.SetFormat(\"[%D %T] [%L] (%S) %M\")\n  fileLog.SetRotate(true)\n  fileLog.SetRotateSize(256)\n  fileLog.SetRotateLines(20)\n  fileLog.SetRotateDaily(true)\n  logMech.AddFilter(\"file\", logger.FINE, fileLog)\n\n  logMech.Trace(\"Received message: %s)\", \"All is well\")\n  logMech.Info(\"Message received: \", \"debug!\")\n  logMech.Error(\"Oh no!\",\"Something Broke\")\n}\n```", "```go\n[revisions]\ncount = 2\nrevisionsuffix = .rev\nlockfiles = false\n\n[logs]\nrotatelength = 86400\n\n[alarms]\nemails = sysadmin@example.com,ceo@example.com\n```", "```go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"code.google.com/p/gcfg\"\n)\n\ntype Configuration struct {\n  Revisions struct {\n    Count int\n    Revisionsuffix string\n    Lockfiles bool\n  }\n  Logs struct {\n    Rotatelength int\n  }\n  Alarms struct {\n    Emails string\n  }\n}\n\nfunc main() {\n  configFile := Configuration{}\n  err := gcfg.ReadFileInto(&configFile, \"example.ini\")\n  if err != nil {\n    fmt.Println(\"Error\",err)\n  }\n  fmt.Println(\"Rotation duration:\",configFile.Logs.Rotatelength)\n}\n```", "```go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"github.com/howeyc/fsnotify\"\n  \"net\"\n  \"time\"\n  \"io\"  \n  \"io/ioutil\"\n  \"github.com/couchbaselabs/go-couchbase\"\n  \"crypto/md5\"\n  \"encoding/hex\"\n  \"encoding/json\"  \n  \"strings\"\n\n)\n\nvar listenFolder = \"mnt/sharedir\"\n\ntype Client struct {\n  ID int\n  Connection *net.Conn  \n}\n```", "```go\ntype File struct {\n  Hash string \"json:hash\"\n  Name string \"json:file_name\"\n  Created int64 \"json:created\"\n  CreatedUser  int \"json:created_user\"\n  LastModified int64 \"json:last_modified\"\n  LastModifiedUser int \"json:last_modified_user\"\n  Revisions int \"json:revisions\"\n  Version int \"json:version\"\n}\n```", "```go\ntype Message struct {\n  Hash string \"json:hash\"\n  Action string \"json:action\"\n  Location string \"json:location\"  \n  Name string \"json:name\"\n  Version int \"json:version\"\n}\n```", "```go\nfunc generateHash(name string) string {\n\n  hash := md5.New()\n  io.WriteString(hash,name)\n  hashString := hex.EncodeToString(hash.Sum(nil))\n\n  return hashString\n}\n```", "```go\nfunc alertServers(hash string, name string, action string, location string, version int) {\n\n  msg := Message{Hash:hash,Action:action,Location:location,Name:name,Version:version}\n  msgJSON,_ := json.Marshal(msg)\n\n  fmt.Println(string(msgJSON))\n\n  for i := range Clients {\n    fmt.Println(\"Sending to clients\")\n    fmt.Fprintln(*Clients[i].Connection,string(msgJSON))\n  }\n}\n```", "```go\nfunc startServer(listener net.Listener) {\n  for {  \n    conn,err := listener.Accept()\n    if err != nil {\n\n    }\n    currentClient := Client{ ID: 1, Connection: &conn}\n    Clients = append(Clients,currentClient)\n      for i:= range Clients {\n        fmt.Println(\"Client\",Clients[i].ID)\n      }    \n  }  \n\n}\n```", "```go\nfunc removeFile(name string, bucket *couchbase.Bucket) {\n  bucket.Delete(generateHash(name))\n}\n```", "```go\nfunc updateExistingFile(name string, bucket *couchbase.Bucket) int {\n  fmt.Println(name,\"updated\")\n  hashString := generateHash(name)\n\n  thisFile := Files[hashString]\n  thisFile.Hash = hashString\n  thisFile.Name = name\n  thisFile.Version = thisFile.Version + 1\n  thisFile.LastModified = time.Now().Unix()\n  Files[hashString] = thisFile\n  bucket.Set(hashString,0,Files[hashString])\n  return thisFile.Version\n}\n```", "```go\nfunc evalFile(event *fsnotify.FileEvent, bucket *couchbase.Bucket) {\n  fmt.Println(event.Name,\"changed\")\n  create := event.IsCreate()\n  fileComponents := strings.Split(event.Name,\"\\\\\")\n  fileComponentSize := len(fileComponents)\n  trueFileName := fileComponents[fileComponentSize-1]\n  hashString := generateHash(trueFileName)\n\n  if create == true {\n    updateFile(trueFileName,bucket)\n    alertServers(hashString,event.Name,\"CREATE\",event.Name,0)\n  }\n  delete := event.IsDelete()\n  if delete == true {\n    removeFile(trueFileName,bucket)\n    alertServers(hashString,event.Name,\"DELETE\",event.Name,0)    \n  }\n  modify := event.IsModify()\n  if modify == true {\n    newVersion := updateExistingFile(trueFileName,bucket)\n    fmt.Println(newVersion)\n    alertServers(hashString,trueFileName,\"MODIFY\",event.Name,newVersion)\n  }\n  rename := event.IsRename()\n  if rename == true {\n\n  }\n}\n```", "```go\nfunc updateFile(name string, bucket *couchbase.Bucket) {\n  thisFile := File{}\n  hashString := generateHash(name)\n\n  thisFile.Hash = hashString\n  thisFile.Name = name\n  thisFile.Created = time.Now().Unix()\n  thisFile.CreatedUser = 0\n  thisFile.LastModified = time.Now().Unix()\n  thisFile.LastModifiedUser = 0\n  thisFile.Revisions = 0\n  thisFile.Version = 1\n\n  Files[hashString] = thisFile\n\n  checkFile := File{}\n  err := bucket.Get(hashString,&checkFile)\n  if err != nil {\n    fmt.Println(\"New File Added\",name)\n    bucket.Set(hashString,0,thisFile)\n  }\n}\n```", "```go\nvar Clients []Client\nvar Files map[string] File\n\nfunc main() {\n  Files = make(map[string]File)\n  endScript := make(chan bool)\n\n  couchbaseClient, err := couchbase.Connect(\"http://localhost:8091/\")\n    if err != nil {\n      fmt.Println(\"Error connecting to Couchbase\", err)\n    }\n  pool, err := couchbaseClient.GetPool(\"default\")\n    if err != nil {\n      fmt.Println(\"Error getting pool\",err)\n    }\n  bucket, err := pool.GetBucket(\"file_manager\")\n    if err != nil {\n      fmt.Println(\"Error getting bucket\",err)\n    }  \n\n  files, _ := ioutil.ReadDir(listenFolder)\n  for _, file := range files {\n    updateFile(file.Name(),bucket)\n  }\n\n    dirSpy, err := fsnotify.NewWatcher()\n    defer dirSpy.Close()\n\n  listener, err := net.Listen(\"tcp\", \":9000\")\n  if err != nil {\n    fmt.Println (\"Could not start server!\",err)\n  }\n\n  go func() {\n        for {\n            select {\n            case ev := <-dirSpy.Event:\n                evalFile(ev,bucket)\n            case err := <-dirSpy.Error:\n                fmt.Println(\"error:\", err)\n            }\n        }\n    }()\n    err = dirSpy.Watch(listenFolder)  \n  startServer(listener)\n\n  <-endScript\n}\n```", "```go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"net\"\n  \"io\"\n  \"os\"\n  \"strconv\"\n  \"encoding/json\"\n)\n\nvar backupFolder = \"mnt/backup/\"\n```", "```go\ntype Message struct {\n  Hash string \"json:hash\"\n  Action string \"json:action\"\n  Location string \"json:location\"\n  Name string \"json:name\"  \n  Version int \"json:version\"\n}\n\nfunc backup (location string, name string, version int) {\n\n  newFileName := backupFolder + name + \".\" + \n    strconv.FormatInt(int64(version),10)\n  fmt.Println(newFileName)\n  org,_ := os.Open(location)\n  defer org.Close()\n  cpy,_ := os.Create(newFileName)\n  defer cpy.Close()\n  io.Copy(cpy,org)\n}\n```", "```go\nfunc listen(conn net.Conn) {\n  for {\n\n      messBuff := make([]byte,1024)\n    n, err := conn.Read(messBuff)\n    if err != nil {\n\n    }\n\n    resultMessage := Message{}\n    json.Unmarshal(messBuff[:n],&resultMessage)\n\n    if resultMessage.Action == \"MODIFY\" {\n      fmt.Println(\"Back up file\",resultMessage.Location)\n      newVersion := resultMessage.Version + 1\n      backup(resultMessage.Location,resultMessage.Name,newVersion)\n    }\n\n  }\n\n}\n```", "```go\nfunc main() {\n  endBackup := make(chan bool)\n  conn, err := net.Dial(\"tcp\",\"127.0.0.1:9000\")\n  if err != nil {\n    fmt.Println(\"Could not connect to File Listener!\")\n  }\n  go listen(conn)\n\n  <- endBackup\n}\n```", "```go\npackage main\n\nimport\n(\n  \"net\"\n  \"net/http\"\n  \"html/template\"\n  \"log\"\n  \"io\"\n  \"os\"\n  \"io/ioutil\"\n  \"github.com/couchbaselabs/go-couchbase\"\n  \"time\"  \n  \"fmt\"\n  \"crypto/md5\"\n  \"encoding/hex\"\n  \"encoding/json\"\n)\n\ntype File struct {\n  Hash string \"json:hash\"\n  Name string \"json:file_name\"\n  Created int64 \"json:created\"\n  CreatedUser  int \"json:created_user\"\n  LastModified int64 \"json:last_modified\"\n  LastModifiedUser int \"json:last_modified_user\"\n  Revisions int \"json:revisions\"\n  Version int \"json:version\"\n}\n```", "```go\ntype Page struct {\n  Title string\n  Files map[string] File\n}\n```", "```go\ntype ItemWrapper struct {\n\n  Items []File\n  CurrentTime int64\n  PreviousTime int64\n\n}\n\ntype Message struct {\n  Hash string \"json:hash\"\n  Action string \"json:action\"\n  Location string \"json:location\"\n  Name string \"json:name\"  \n  Version int \"json:version\"\n}\n```", "```go\nfunc updateFile(name string, bucket *couchbase.Bucket) {\n  thisFile := File{}\n  hashString := generateHash(name)\n\n  thisFile.Hash = hashString\n  thisFile.Name = name\n  thisFile.Created = time.Now().Unix()\n  thisFile.CreatedUser = 0\n  thisFile.LastModified = time.Now().Unix()\n  thisFile.LastModifiedUser = 0\n  thisFile.Revisions = 0\n  thisFile.Version = 1\n\n  Files[hashString] = thisFile\n\n  checkFile := File{}\n  err := bucket.Get(hashString,&checkFile)\n  if err != nil {\n    fmt.Println(\"New File Added\",name)\n    bucket.Set(hashString,0,thisFile)\n  }else {\n    Files[hashString] = checkFile\n  }\n}\n```", "```go\nfunc listen(conn net.Conn) {\n  for {\n\n      messBuff := make([]byte,1024)\n    n, err := conn.Read(messBuff)\n    if err != nil {\n\n    }\n    message := string(messBuff[:n])\n    message = message[0:]\n\n    resultMessage := Message{}\n    json.Unmarshal(messBuff[:n],&resultMessage)\n\n    updateHash := resultMessage.Hash\n    tmp := Files[updateHash]\n    tmp.LastModified = time.Now().Unix()\n    Files[updateHash] = tmp\n  }\n\n}\n```", "```go\nfunc main() {\n  lastChecked := time.Now().Unix()\n  Files = make(map[string]File)\n  fileChange = make(chan File)\n  couchbaseClient, err := couchbase.Connect(\"http://localhost:8091/\")\n    if err != nil {\n      fmt.Println(\"Error connecting to Couchbase\", err)\n    }\n  pool, err := couchbaseClient.GetPool(\"default\")\n    if err != nil {\n      fmt.Println(\"Error getting pool\",err)\n    }\n  bucket, err := pool.GetBucket(\"file_manager\")\n    if err != nil {\n      fmt.Println(\"Error getting bucket\",err)\n    }    \n\n  files, _ := ioutil.ReadDir(listenFolder)\n  for _, file := range files {\n    updateFile(file.Name(),bucket)\n  }\n\n  conn, err := net.Dial(\"tcp\",\"127.0.0.1:9000\")\n  if err != nil {\n    fmt.Println(\"Could not connect to File Listener!\")\n  }\n  go listen(conn)\n\n  http.HandleFunc(\"/api\", func(w http.ResponseWriter, r \n    *http.Request) {\n    apiOutput := ItemWrapper{}\n    apiOutput.PreviousTime = lastChecked\n    lastChecked = time.Now().Unix()\n    apiOutput.CurrentTime = lastChecked\n\n    for i:= range Files {\n      apiOutput.Items = append(apiOutput.Items,Files[i])\n    }\n    output,_ := json.Marshal(apiOutput)\n    fmt.Fprintln(w,string(output))\n\n  })\n  http.HandleFunc(\"/\", func(w http.ResponseWriter, r \n    *http.Request) {\n    output := Page{Files:Files,Title:\"File Manager\"}\n    tmp, _ := template.ParseFiles(\"ch8_html.html\")\n    tmp.Execute(w, output)\n  })\n  http.HandleFunc(\"/upload\", func(w http.ResponseWriter, r \n    *http.Request) {\n    err := r.ParseMultipartForm(10000000)\n    if err != nil {\n      return\n    }\n    form := r.MultipartForm\n\n    files := form.File[\"file\"]\n    for i, _ := range files {\n      newFileName := listenFolder + files[i].Filename\n      org,_:= files[i].Open()\n      defer org.Close()\n      cpy,_ := os.Create(newFileName)\n      defer cpy.Close()\n      io.Copy(cpy,org)\n    }\n  })  \n\n  log.Fatal(http.ListenAndServe(\":8080\",nil))\n\n}\n```", "```go\nvar liveFolder = \"/mnt/sharedir \"\nvar backupFolder = \"/mnt/backup\n\nfunc generateHash(name string) string {\n\n  hash := md5.New()\n  io.WriteString(hash,name)\n  hashString := hex.EncodeToString(hash.Sum(nil))\n\n  return hashString\n}\n\nfunc main() {\n  revision := flag.Int(\"r\",0,\"Number of versions back\")\n  fileName := flag.String(\"f\",\"\",\"File Name\")\n  flag.Parse()\n\n  if *fileName == \"\" {\n\n    fmt.Println(\"Provide a file name to use!\")\n    os.Exit(0)\n  }\n\n  couchbaseClient, err := couchbase.Connect(\"http://localhost:8091/\")\n    if err != nil {\n      fmt.Println(\"Error connecting to Couchbase\", err)\n    }\n  pool, err := couchbaseClient.GetPool(\"default\")\n    if err != nil {\n      fmt.Println(\"Error getting pool\",err)\n    }\n  bucket, err := pool.GetBucket(\"file_manager\")\n    if err != nil {\n      fmt.Println(\"Error getting bucket\",err)\n    }  \n\n  hashString := generateHash(*fileName)\n  checkFile := File{}    \n  bucketerr := bucket.Get(hashString,&checkFile)\n  if bucketerr != nil {\n\n  }else {\n    backupLocation := backupFolder + checkFile.Name + \".\" + strconv.FormatInt(int64(checkFile.Version-*revision),10)\n    newLocation := liveFolder + checkFile.Name\n    fmt.Println(backupLocation)\n    org,_ := os.Open(backupLocation)\n      defer org.Close()\n    cpy,_ := os.Create(newLocation)\n      defer cpy.Close()\n    io.Copy(cpy,org)\n    fmt.Println(\"Revision complete\")\n  }\n\n}\n```", "```go\nfileversion -f example.txt -r -3\n\n```"]