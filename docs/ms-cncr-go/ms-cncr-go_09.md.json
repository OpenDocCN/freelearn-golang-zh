["```go\nfunc Add(x int, y int) int {\n  return x + y\n}\n```", "```go\npackage main\nimport\n(\n  \"fmt\"\n  \"errors\"\n  \"reflect\"\n)\n\nfunc Add(x int, y int) (int, error) {\n  var err error\n\n  xType := reflect.TypeOf(x).Kind()\n  yType := reflect.TypeOf(y).Kind()\n  if xType != reflect.Int || yType != reflect.Int {\n    fmt.Println(xType)\n    err = errors.New(\"Incorrect type for integer a or b!\")\n  }\n  return x + y, err\n}\n\nfunc main() {\n\n  sum,err := Add(\"foo\",2)\n  if err != nil {\n    fmt.Println(\"Error\",err)\n  }\n  fmt.Println(sum)\n}\n```", "```go\ntype Alpha struct {\n\n}\n\ntype Numeric struct {\n\n}\n```", "```go\nfunc (a Alpha) Add(x string, y string) (string, error) {\n  var err error\n  xType := reflect.TypeOf(x).Kind()\n  yType := reflect.TypeOf(y).Kind()\n  if xType != reflect.String || yType != reflect.String {\n    err = errors.New(\"Incorrect type for strings a or b!\")\n  }\n  finalString := x + y\n  return finalString, err\n}\n\nfunc (n Numeric) Add(x int, y int) (int, error) {\n  var err error\n\n  xType := reflect.TypeOf(x).Kind()\n  yType := reflect.TypeOf(y).Kind()\n  if xType != reflect.Int || yType != reflect.Int {\n    err = errors.New(\"Incorrect type for integer a or b!\")\n  }\n  return x + y, err\n}\nfunc main() {\n  n1 := Numeric{}\n  a1 := Alpha{}\n  z,err := n1.Add(5,2)\t\n  if err != nil {\n    log.Println(\"Error\",err)\n  }\n  log.Println(z)\n\n  y,err := a1.Add(\"super\",\"lative\")\n  if err != nil {\n    log.Println(\"Error\",err)\n  }\n  log.Println(y)\n}\n```", "```go\npackage main\n\nimport\n(\n  \"log\"\n  \"os\"\n  \"strconv\"\n)\n\nconst totalGoroutines = 5\n\ntype Worker struct {\n  wLog *log.Logger\n  Name string\n}\n```", "```go\nfunc main() {\n  done := make(chan bool)\n\n  for i:=0; i< totalGoroutines; i++ {\n\n    myWorker := Worker{}\n    myWorker.Name = \"Goroutine \" + strconv.FormatInt(int64(i),10) + \"\"\n    myWorker.wLog = log.New(os.Stderr, myWorker.Name, 1)\n    go func(w *Worker) {\n\n        w.wLog.Print(\"Hmm\")\n\n        done <- true\n    }(&myWorker)\n  }\n```", "```go\n  log.Println(\"...\")\n\n  <- done\n}\n```", "```go\nfmt.Println(\"Horrible error:\",err)\n```", "```go\nmyLogger.Println(\"Horrible error:\", err)\n```", "```go\nlog.Print(\"Message\")\n```", "```go\npackage main\n\nimport (\n  \"log\"\n  \"os\"\n)\n\nfunc main() {\n  logFile, _ := os.OpenFile(\"/var/www/test.log\", os.O_RDWR, 0755)\n\n  log.SetOutput(logFile)\n  log.Println(\"Sending an entry to log!\")\n\n  logFile.Close()\n}\n```", "```go\n  for i:=0; i< totalGoroutines; i++ {\n\n    myWorker := Worker{}\n    myWorker.Name = \"Goroutine \" + strconv.FormatInt(int64(i),10) \n      + \"\"\n    myWorker.FileName = \"/var/www/\"+strconv.FormatInt(int64(i),10) \n      + \".log\"\n    tmpFile,_ :=   os.OpenFile(myWorker.FileName, os.O_CREATE, \n      0755)\n    myWorker.File = tmpFile\n    myWorker.wLog = log.New(myWorker.File, myWorker.Name, 1)\n    go func(w *Worker) {\n\n        w.wLog.Print(\"Hmm\")\n\n        done <- true\n    }(&myWorker)\n  }\n```", "```go\npackage main\n\nimport\n(\n  \"github.com/couchbaselabs/go-couchbase\"\n  \"io\"\n  \"time\"\n  \"fmt\"\n  \"os\"\n  \"net/http\"\n  \"crypto/md5\"\n  \"encoding/hex\"\n)\ntype LogItem struct {\n  ServerID string \"json:server_id\"\n  Goroutine int \"json:goroutine\"\n  Timestamp time.Time \"json:time\"\n  Message string \"json:message\"\n  Page string \"json:page\"\n}\n```", "```go\nvar currentGoroutine int\n\nfunc (li LogItem) logRequest(bucket *couchbase.Bucket) {\n\n  hash := md5.New()\n  io.WriteString(hash,li.ServerID+li.Page+li.Timestamp.Format(\"Jan \n    1, 2014 12:00am\"))\n  hashString := hex.EncodeToString(hash.Sum(nil))\n  bucket.Set(hashString,0,li)\n  currentGoroutine = 0\n}\n```", "```go\nfunc main() {\n  hostName, _ := os.Hostname()\n  currentGoroutine = 0\n\n  logClient, err := couchbase.Connect(\"http://localhost:8091/\")\n    if err != nil {\n      fmt.Println(\"Error connecting to logging client\", err)\n    }\n  logPool, err := logClient.GetPool(\"default\")\n    if err != nil {\n      fmt.Println(\"Error getting pool\",err)\n    }\n  logBucket, err := logPool.GetBucket(\"logs\")\n    if err != nil {\n      fmt.Println(\"Error getting bucket\",err)\n    }\n  http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    request := LogItem{}\n    request.Goroutine = currentGoroutine\n    request.ServerID = hostName\n    request.Timestamp = time.Now()\n    request.Message = \"Request to \" + r.URL.Path\n    request.Page = r.URL.Path\n    go request.logRequest(logBucket)\n\n  })\n\n  http.ListenAndServe(\":8080\",nil)\n\n}\n```", "```go\npackage main\n\nimport (\n  \"code.google.com/p/log4go\"\n  \"net/http\"\n  \"fmt\"\n  \"github.com/gorilla/mux\"\n)\nvar errorLog log4go.Logger\nvar errorLogWriter log4go.FileLogWriter\n\nvar accessLog log4go.Logger\nvar accessLogWriter *log4go.FileLogWriter\n\nvar screenLog log4go.Logger\n\nvar networkLog log4go.Logger\n```", "```go\nfunc init() {\n  fmt.Println(\"Web Server Starting\")\n}\n\nfunc pageHandler(w http.ResponseWriter, r *http.Request) {\n  pageFoundMessage := \"Page found: \" + r.URL.Path\n  accessLog.Info(pageFoundMessage)\n  networkLog.Info(pageFoundMessage)\n  w.Write([]byte(\"Valid page\"))\n}\n```", "```go\nfunc notFound(w http.ResponseWriter, r *http.Request) {\n  pageNotFoundMessage := \"Page not found / 404: \" + r.URL.Path\n  errorLog.Info(pageNotFoundMessage)\n  w.Write([]byte(\"Page not found\"))\n}\n```", "```go\nfunc restricted(w http.ResponseWriter, r *http.Request) {\n  message := \"Restricted directory access attempt!\"\n  errorLog.Info(message)\n  accessLog.Info(message)\n  screenLog.Info(message)\n  networkLog.Info(message)\n  w.Write([]byte(\"Restricted!\"))\n\n}\n```", "```go\nfunc main() {\n\n  screenLog = make(log4go.Logger)\n  screenLog.AddFilter(\"stdout\", log4go.DEBUG, log4go.NewConsoleLogWriter())\n\n  errorLogWriter := log4go.NewFileLogWriter(\"web-errors.log\", \n    false)\n    errorLogWriter.SetFormat(\"%d %t - %M (%S)\")\n    errorLogWriter.SetRotate(false)\n    errorLogWriter.SetRotateSize(0)\n    errorLogWriter.SetRotateLines(0)\n    errorLogWriter.SetRotateDaily(true)\n```", "```go\n04/13/14 10:46 - Page found%!(EXTRA string=/valid) (main.pageHandler:24)\n```", "```go\n  errorLog = make(log4go.Logger)\n  errorLog.AddFilter(\"file\", log4go.DEBUG, errorLogWriter)\n\n  networkLog = make(log4go.Logger)\n  networkLog.AddFilter(\"network\", log4go.DEBUG, log4go.NewSocketLogWriter(\"tcp\", \"localhost:3000\"))\n```", "```go\n  accessLogWriter = log4go.NewFileLogWriter(\"web-access.log\",false)\n    accessLogWriter.SetFormat(\"%d %t - %M (%S)\")\n    accessLogWriter.SetRotate(true)\n    accessLogWriter.SetRotateSize(0)\n    accessLogWriter.SetRotateLines(500)\n    accessLogWriter.SetRotateDaily(false)\n```", "```go\n  accessLog = make(log4go.Logger)\n  accessLog.AddFilter(\"file\",log4go.DEBUG,accessLogWriter)\n\n  rtr := mux.NewRouter()\n  rtr.HandleFunc(\"/valid\", pageHandler)\n  rtr.HandleFunc(\"/.git/\", restricted)\n  rtr.NotFoundHandler = http.HandlerFunc(notFound)\n```", "```go\n  http.Handle(\"/\", rtr)\n  http.ListenAndServe(\":8080\", nil)\n}\n```", "```go\npackage main\n\nimport\n(\n  \"net\"\n  \"fmt\"\n)\n\ntype Connection struct {\n\n}\n\nfunc (c Connection) Listen(l net.Listener) {\n  for {\n    conn,_ := l.Accept()\n    go c.logListen(conn)\n  }\n}\n```", "```go\nfunc (c *Connection) logListen(conn net.Conn) {\n  for {\n    buf := make([]byte, 1024)\n    n, _ := conn.Read(buf)\n    fmt.Println(\"Log Message\",string(n))\n  }\n}\n```", "```go\nfunc main() {\n  serverClosed := make(chan bool)\n\n  listener, err := net.Listen(\"tcp\", \":3000\")\n  if err != nil {\n    fmt.Println (\"Could not start server!\",err)\n  }\n\n  Conn := Connection{}\n\n  go Conn.Listen(listener)\n\n  <-serverClosed\n}\n```", "```go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"os\"\n)\n\nfunc processNumber(un int) {\n\n  if un < 1 || un > 4 {\n    fmt.Println(\"Now you've done it!\")\n    os.Exit(1)\n  }else {\n    fmt.Println(\"Good, you can read simple instructions.\")\n  }\n}\n\nfunc main() {\n  userNum := 0\n  fmt.Println(\"Enter a number between 1 and 4.\")\n  _,err := fmt.Scanf(\"%d\",&userNum)\n    if err != nil {}\n\n  processNumber(userNum)\n}\n```", "```go\nfunc getFileDetails(fileName string) error {\n  return err\n}\n\nfunc openFile(fileName string) error {\n  details,err := getFileDetails(fileName)\n  return err\n}\n\nfunc main() {\n\n  file,err := openFile(fileName)\n\n}\n```", "```go\npackage main\n\nimport\n(\n  \"os\"\n  \"fmt\"\n  \"strconv\"\n)\n\nfunc gatherPanics() {\n  if rec := recover(); rec != nil {\n    fmt.Println(\"Critical Error:\", rec)\n  }\n}\n```", "```go\nfunc getFileDetails(fileName string) {\n  defer gatherPanics()\n  finfo,err := os.Stat(fileName)\n  if err != nil {\n    panic(\"Cannot access file\")\n  }else {\n    fmt.Println(\"Size: \", strconv.FormatInt(finfo.Size(),10))\n  }\n}\n\nfunc openFile(fileName string) {\n  defer gatherPanics()\n  if _, err := os.Stat(fileName); err != nil {\n    panic(\"File does not exist\")\n  }\n\n}\n```", "```go\nfunc main() {\n  var fileName string\n  fmt.Print(\"Enter filename>\")\n  _,err := fmt.Scanf(\"%s\",&fileName)\n  if err != nil {}\n  fmt.Println(\"Getting info for\",fileName)\n\n  openFile(fileName)\n  getFileDetails(fileName)\n\n}\n```", "```go\ntype LogItem struct {\n  Message string\n  Function string\n}\n\nvar Logs []LogItem\n```", "```go\nfunc SaveLogs() {\n  logFile := log4go.NewFileLogWriter(\"errors.log\",false)\n    logFile.SetFormat(\"%d %t - %M (%S)\")\n    logFile.SetRotate(true)\n    logFile.SetRotateSize(0)\n    logFile.SetRotateLines(500)\n    logFile.SetRotateDaily(false)\n\n  errorLog := make(log4go.Logger)\n  errorLog.AddFilter(\"file\",log4go.DEBUG,logFile)\n  for i:= range Logs {\n    errorLog.Info(Logs[i].Message + \" in \" + Logs[i].Function)\n  }\n\n}\n```", "```go\nfunc registerError(block chan bool) {\n\n  Log := LogItem{ Message:\"An Error Has Occurred!\", Function: \"registerError()\"}\n  Logs = append(Logs,Log)\n  block <- true\n}\n```", "```go\nfunc separateFunction() {\n  panic(\"Application quitting!\")\n}\n```", "```go\nfunc main() {\n  block := make(chan bool)\n  defer SaveLogs()\n  go func(block chan bool) {\n\n    registerError(block)\n\n  }(block)\n\n  separateFunction()\n\n}\n```", "```go\npackage main\n\nimport\n(\n  \"os\"\n  \"fmt\"\n  \"runtime\"\n  \"strconv\"\n  \"code.google.com/p/log4go\"\n)\n\ntype LogItem struct {\n  Message string\n}\n\nvar LogItems []LogItem\n\nfunc saveLogs() {\n  logFile := log4go.NewFileLogWriter(\"stack.log\", false)\n    logFile.SetFormat(\"%d %t - %M (%S)\")\n    logFile.SetRotate(false)\n    logFile.SetRotateSize(0)\n    logFile.SetRotateLines(0)\n    logFile.SetRotateDaily(true)\n\n  logStack := make(log4go.Logger)\n  logStack.AddFilter(\"file\", log4go.DEBUG, logFile)\n  for i := range LogItems {\n    fmt.Println(LogItems[i].Message)\n    logStack.Info(LogItems[i].Message)\n  }\n}\n```", "```go\nfunc goDetails(done chan bool) {\n  i := 0\n  for {\n    var message string\n    stackBuf := make([]byte,1024)\n    stack := runtime.Stack(stackBuf, false)\n    stack++\n    _, callerFile, callerLine, ok := runtime.Caller(0)\n    message = \"Goroutine from \" + string(callerLine) + \"\" + \n      string(callerFile) + \" stack:\" + \tstring(stackBuf)\n    openGoroutines := runtime.NumGoroutine()\n\n    if (ok == true) {\n      message = message + callerFile\n    }\n\n    message = message + strconv.FormatInt(int64(openGoroutines),10) + \" goroutines \n        active\"\n\n    li := LogItem{ Message: message}\n\n    LogItems = append(LogItems,li)\n    if i == 20 {\n      done <- true\n      break\n    }\n\n    i++\n  }\n}\n```", "```go\nfunc main() {\n  done := make(chan bool)\n\n  go goDetails(done)\n  for i:= 0; i < 10; i++ {\n    go goDetails(done)\n  }\n\n  for {\n    select {\n      case d := <-done:\n        if d == true {\n          saveLogs()\n          os.Exit(1)\n        }\n    }\n  }\n\n}\n```", "```go\n04/16/14 23:25 - Goroutine from + /var/log/go/ch9_11_stacktrace.goch9_11_stacktrace.go stack:goroutine 4 [running]:\nmain.goDetails(0xc08400b300)\n  /var/log/go/ch9_11_stacktrace.goch9_11_stacktrace.go:41 +0x8e\ncreated by main.main\n  /var/log/go/ch9_11_stacktrace.goch9_11_stacktrace.go:69 +0x4c\n\n  /var/log/go/ch9_11_stacktrace.goch9_11_stacktrace.go14 goroutines active (main.saveLogs:31)\n```"]