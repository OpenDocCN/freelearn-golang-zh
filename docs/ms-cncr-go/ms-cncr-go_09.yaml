- en: Chapter 9. Logging and Testing Concurrency in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。Go中的日志记录和测试并发
- en: At this stage, you should be fairly comfortable with concurrency in Go and should
    be able to implement basic goroutines and concurrent mechanisms with ease.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该对Go中的并发感到相当舒适，并且应该能够轻松地实现基本的goroutines和并发机制。
- en: We have also dabbled in some distributed concurrency patterns that are managed
    not only through the application itself, but also through third-party data stores
    for networked applications that operate concurrently in congress.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涉足了一些分布式并发模式，这些模式不仅通过应用程序本身管理，还通过第三方数据存储管理网络应用程序的并发操作。
- en: Earlier in this book, we examined some preliminary and basic testing and logging.
    We looked at the simpler implementations of Go's internal test tool, performed
    some race condition testing using the race tool, and performed some rudimentary
    load and performance testing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前面，我们研究了一些初步和基本的测试和日志记录。我们研究了Go内部测试工具的简单实现，使用race工具进行了一些竞争条件测试，并进行了一些基本的负载和性能测试。
- en: However, there's much more to be looked at here, particularly as it relates
    to the potential black hole of concurrent code—we've seen unexpected behavior
    among code that runs in goroutines and is non-blocking.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里还有更多需要考虑的地方，特别是与潜在的并发代码黑洞有关——我们已经看到了在goroutines中运行的非阻塞代码之间出现了意外行为。
- en: In this chapter, we'll further investigate load and performance testing, look
    at unit testing in Go, and experiment with more advanced tests and debugging.
    We'll also look at best practices for logging and reporting, as well as take a
    closer look at panicking and recovering.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步研究负载和性能测试，在Go中进行单元测试，并尝试更高级的测试和调试。我们还将探讨日志记录和报告的最佳实践，并更仔细地研究panic和recover。
- en: Lastly, we'll want to see how all of these things can be applied not just to
    our standalone concurrent code, but also to distributed systems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看到所有这些东西不仅可以应用于我们独立的并发代码，还可以应用于分布式系统。
- en: Along the way, we'll introduce a couple of frameworks for unit testing in a
    variety of different styles.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将介绍一些不同风格的单元测试框架。
- en: Handling errors and logging
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误和日志记录
- en: Though we haven't specifically mentioned it, the idiomatic nature of error handling
    in Go makes debugging naturally easier by mandate.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有明确提到，但Go中错误处理的成语性质使得调试自然更容易。
- en: One good practice for any large-scale function inside Go code is to return an
    error as a return value—for many smaller methods and functions, this is potentially
    burdensome and unnecessary. Still, it's a matter for consideration whenever we're
    building something that involves a lot of moving pieces.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go代码中，任何大规模函数的一个良好实践是将错误作为返回值返回——对于许多较小的方法和函数来说，这可能是繁琐和不必要的。但是，每当我们构建涉及许多移动部件的东西时，这都是需要考虑的问题。
- en: 'For example, consider a simple `Add()` function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个简单的`Add()`函数：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we wish to follow the general rule of "always return an error value", we
    may be tempted to convert this function to the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望遵循“始终返回错误值”的一般规则，我们可能会诱使将这个函数转换为以下代码：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that we're (very poorly) reinventing the wheel. Go's internal compiler
    kills this long before we ever see it. So, we should focus on things that the
    compiler may not catch and that can cause unexpected behavior in our applications,
    particularly when it comes to channels and listeners.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们（非常糟糕地）在重新发明轮子。Go的内部编译器在我们看到它之前就已经杀死了它。因此，我们应该专注于编译器可能无法捕捉到的事情，这可能会导致我们的应用程序出现意外行为，特别是在涉及通道和监听器时。
- en: 'The takeaway is to let Go handle the errors that the compiler would handle,
    unless you wish to handle the exceptions yourself, without causing the compiler
    specific grief. In the absence of true polymorphism, this is often cumbersome
    and requires the invocation of interfaces, as shown in the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要点是让Go处理编译器会处理的错误，除非你希望自己处理异常，而不引起编译器特定的困扰。在真正的多态性缺失的情况下，这通常很麻烦，并且需要调用接口，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You may recall that creating interfaces and structs allows us to route our
    function calls separately based on type. This is shown in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，创建接口和结构允许我们根据类型分别路由我们的函数调用。这在下面的代码中显示：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This still reports what will eventually be caught by the compiler, but also
    handles some form of error on what the compiler cannot see: external input. We''re
    routing our `Add()` function through an interface, which provides some additional
    standardization by directing the struct''s parameters and methods more explicitly.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然报告了最终会被编译器捕获的内容，但也处理了编译器无法看到的某种错误：外部输入。我们通过接口路由我们的`Add()`函数，这通过更明确地指导结构的参数和方法提供了一些额外的标准化。
- en: If, for example, we take user input for our values and need to evaluate the
    type of that input, we may wish to report an error in this way as the compiler
    will never know that our code can accept the wrong type.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们为我们的值输入用户输入并需要评估该输入的类型，我们可能希望以这种方式报告错误，因为编译器永远不会知道我们的代码可以接受错误的类型。
- en: Breaking out goroutine logs
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打破goroutine日志
- en: One way of handling messaging and logging that keeps a focus on concurrency
    and isolation is to shackle our goroutine with its own logger that will keep everything
    separate from the other goroutines.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 保持关注并发和隔离的消息处理和日志记录的一种方法是用自己的日志记录器束缚我们的goroutine，这将使一切与其他goroutines分开。
- en: At this point, we should note that this may not scale—that is, it may at some
    point become expensive to create thousands or tens of thousands of goroutines
    that have their own loggers, but at a minimal size, this is totally doable and
    manageable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该注意到这可能不会扩展——也就是说，创建成千上万个拥有自己日志记录器的goroutines可能会变得昂贵，但在最小规模下，这是完全可行和可管理的。
- en: 'To do this logging individually, we''ll want to tie a `Logger` instance to
    each goroutine, as shown in the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了单独进行这种日志记录，我们将希望将一个`Logger`实例绑定到每个goroutine，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ll create a generic `Worker` struct that will ironically do no work (at
    least not in this example) other than hold onto its own `Logger` object. The code
    is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个通用的`Worker`结构，讽刺的是它在这个示例中不会做任何工作（至少在这个示例中不会），只是保存它自己的`Logger`对象。代码如下：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Each goroutine is saddled with its own log routine through `Worker`. While
    we''re spitting our output straight to the console, this is largely unnecessary.
    However, if we want to siphon each to its own logfile, we could do so by using
    the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个goroutine通过`Worker`都负责自己的日志例程。虽然我们直接将输出发送到控制台，但这在很大程度上是不必要的。但是，如果我们想将每个输出到自己的日志文件中，我们可以使用以下代码来实现：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the LiteIDE for richer and easier debugging
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LiteIDE进行更丰富和更容易的调试
- en: In the earlier chapters of this book, we briefly addressed IDEs and gave a few
    examples of IDEs that have a tight integration with Go.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，我们简要讨论了IDE，并举了一些与Go紧密集成的IDE的例子。
- en: As we're examining logging and debugging, there's one IDE we previously and
    specifically didn't mention before, primarily because it's intended for a very
    small selection of languages—namely, Go and Lua. However, if you end up working
    primarily or exclusively in Go, you'll find it absolutely essential, primarily
    as it relates to debugging, logging, and feedback capabilities.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们审查日志记录和调试时，有一个IDE我们之前并没有特别提到，主要是因为它是为一小部分语言——即Go和Lua而设计的。然而，如果你最终主要或专门使用Go，你会发现它绝对是必不可少的，特别是因为它与调试、日志记录和反馈功能相关。
- en: '**LiteIDE** is cross-platform and works well on OS X, Linux, and Windows. The
    number of debugging and testing benefits it presents in a GUI form are invaluable,
    particularly if you''re already very comfortable with Go. That last part is important
    because developers often benefit most from "learning the hard way" before diving
    in with tools that simplify the programming process. It''s almost always better
    to know how and why something works or doesn''t work at the core before being
    presented with pretty icons, menus, and pop-up windows. Having said that, LiteIDE
    is a fantastic, free tool for the advanced Go programmer.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**LiteIDE**跨平台，在OS X、Linux和Windows上运行良好。它以GUI形式提供的调试和测试优势是无价的，特别是如果你已经非常熟悉Go。最后一部分很重要，因为开发人员在深入使用简化编程过程的工具之前，通常会从“学习艰难的方式”中受益最多。在被呈现出漂亮的图标、菜单和弹出窗口之前，了解某件事情的工作原理或不工作原理是几乎总是更好的。话虽如此，LiteIDE是一款非常棒的免费工具，适用于高级Go程序员。'
- en: By formalizing a lot of the tools and error reporting from Go, we can easily
    plow through some of the more vexing debugging tasks by seeing them onscreen.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从Go中形式化许多工具和错误报告，我们可以通过在屏幕上看到它们来轻松地解决一些更棘手的调试任务。
- en: 'LiteIDE also brings context awareness, code completion, `go fmt`, and more
    into our workspace. You can imagine how an IDE tuned specifically for Go can help
    you keep your code clean and bug free. Refer to the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: LiteIDE还带来了上下文感知、代码完成、`go fmt`等功能到我们的工作空间。你可以想象一下，专门针对Go调优的IDE如何帮助你保持代码的清晰和无错。参考以下截图：
- en: '![Using the LiteIDE for richer and easier debugging](img/00055.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![使用LiteIDE进行更丰富和更容易的调试](img/00055.jpeg)'
- en: LiteIDE showing output and automatic code completion on Windows
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: LiteIDE在Windows上显示输出和自动代码完成
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: LiteIDE for Linux, OS X, and Windows can be found at [https://code.google.com/p/liteide/](https://code.google.com/p/liteide/).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: LiteIDE适用于Linux、OS X和Windows，可以在[https://code.google.com/p/liteide/](https://code.google.com/p/liteide/)找到。
- en: Sending errors to screen
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将错误发送到屏幕
- en: Throughout this book, we have usually handled soft errors, warnings, and general
    messages with the `fmt.Println` syntax by sending a message to the console.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们通常使用`fmt.Println`语法处理软错误、警告和一般消息，通过向控制台发送消息。
- en: While this is quick and easy for demonstration purposes, it's probably ideal
    to use the `log` package to handle these sorts of things. This is because we have
    more versatility, as `log` relates to where we want our messages to end up.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对于演示目的来说快速简单，但最好使用`log`包来处理这些事情。这是因为我们在`log`包中有更多的灵活性，可以决定消息的最终目的地。
- en: As for our purposes so far, the messages are ethereal. Switching out a simple
    `Println` statement to `Logger` is extremely simple.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们目前的目的而言，这些消息都是虚幻的。将简单的`Println`语句切换到`Logger`非常简单。
- en: 'We''ve been relaying messages before using the following line of code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用以下代码来传递消息：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You''ll notice the change to `Logger` proves pretty similar:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到对`Logger`的更改非常相似：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is especially useful for goroutines, as we can create either a global `Logger`
    interface that can be accessed anywhere or pass the logger's reference to individual
    goroutines and ensure our logging is handled concurrently.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于goroutines特别有用，因为我们可以创建一个全局的`Logger`接口，可以在任何地方访问，或者将记录器的引用传递给单独的goroutines，并确保我们的日志记录是并发处理的。
- en: One consideration for having a single logger for use across our entire application
    is the possibility that we may want to log individual processes separately for
    clarity in analysis. We'll talk a bit more about that later in this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个应用程序中使用单个记录器的一个考虑是，我们可能希望单独记录每个过程，以便更清晰地进行分析。我们稍后会在本章中更详细地讨论这一点。
- en: 'To replicate passing messages to the command line, we can simply use the following
    line of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制将消息传递给命令行，我们可以简单地使用以下代码：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With defaults to `stdout` as its `io.writer`—recall that we can set any `io.writer`
    as the log's destination.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它的`io.writer`是`stdout`——回想一下，我们可以将任何`io.writer`设置为日志的目的地。
- en: However, we will also want to be able to log to file quickly and easily. After
    all, any application running in the background or as a daemon will need to have
    something a little more permanent.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还希望能够快速轻松地记录到文件中。毕竟，任何在后台运行或作为守护程序运行的应用程序都需要有一些更持久的东西。
- en: Logging errors to file
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将错误记录到文件
- en: There are a lot of ways to send an error to a logfile—we can, after all, handle
    this with built-in file operation OS calls. In fact, this is what many people
    do.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种方法可以将错误发送到日志文件中——毕竟，我们可以使用内置的文件操作OS调用来处理这个问题。事实上，这就是许多人所做的。
- en: However, the `log` package offers some standardization and potential symbiosis
    between the command-line feedback and more permanent storage of errors, warnings,
    and general information.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`log`包提供了一些标准化和潜在的命令行反馈与错误、警告和一般信息的更持久存储之间的共生关系。
- en: The simplest way to do this is to open a file using the `os.OpenFile()` method
    (and not the `os.Open()` method) and pass that reference to our log instantiation
    as `io.Writer`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的最简单方法是使用`os.OpenFile()`方法（而不是`os.Open()`方法）打开一个文件，并将该引用传递给我们的日志实例化作为`io.Writer`。
- en: 'Let''s take a look at such functionality in the following example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下面的示例中看看这样的功能：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In our preceding goroutine package, we could assign each goroutine its own
    file and pass a file reference as an io Writer (we''ll need to have write access
    to the destination folder). The code is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的goroutine包中，我们可以为每个goroutine分配一个自己的文件，并将文件引用作为io Writer传递（我们需要对目标文件夹具有写访问权限）。代码如下：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Logging errors to memory
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将错误记录到内存
- en: When we talk about logging errors to memory, we're really referring to a data
    store, although there's certainly no reason other than volatility and limited
    resources to reject logging to memory as a viable option.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论将错误记录到内存时，我们实际上是在谈论数据存储，尽管除了易失性和有限的资源之外，没有理由拒绝将日志记录到内存作为一种可行的选择。
- en: While we'll look at a more direct way to handle networked logging through another
    package in the next section, let's delineate our various application errors in
    a concurrent, distributed system without a lot of hassle. The idea is to use shared
    memory (such as Memcached or a shared memory data store) to pass our log messages.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在下一节中看一种更直接的处理网络日志记录的方法，但让我们在一个并发的分布式系统中划分各种应用程序错误而不费太多力气。这个想法是使用共享内存（比如Memcached或共享内存数据存储）来传递我们的日志消息。
- en: While these will technically still be logfiles (most data stores keep individual
    records or documents as JSON-encoded hard files), it has a distinctively different
    feel than traditional logging.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些技术上仍然是日志文件（大多数数据存储将单独的记录或文档保存为JSON编码的硬文件），但与传统日志记录有着明显不同的感觉。
- en: 'Going back to our old friend from the previous chapter—CouchDB—passing our
    logging messages to a central server can be done almost effortlessly, and it allows
    us to track not just individual machines, but their individual concurrent goroutines.
    The code is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 回到上一章的老朋友CouchDB，将我们的日志消息传递到中央服务器几乎可以毫不费力地完成，这样我们就可以跟踪不仅是单个机器，还有它们各自的并发goroutines。代码如下：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is what will eventually become our JSON document that will be sent to
    our Couchbase server. We''ll use the `Page`, `Timestamp`, and `ServerID` as a
    combined, hashed key to allow multiple, concurrent requests to the same document
    against separate servers to be logged separately, as shown in the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将最终成为我们将发送到Couchbase服务器的JSON文档。我们将使用`Page`，`Timestamp`和`ServerID`作为组合的哈希键，以允许对同一文档的多个并发请求在不同服务器上分别记录日志，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we reset `currentGoroutine` to `0`, we use an intentional race condition
    to allow goroutines to report themselves by numeric ID while executing concurrently.
    This allows us to debug an application that appears to work correctly until it
    invokes some form of concurrent architecture. Since goroutines will be self-identified
    by an ID, it allows us to add more granular routing of our messages.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`currentGoroutine`重置为`0`时，我们使用了一个有意的竞争条件，允许goroutines在并发执行时通过数字ID报告自己。这使我们能够调试一个看起来正常工作的应用程序，直到它调用某种形式的并发架构。由于goroutines将通过ID自我识别，这使我们能够更加精细地路由我们的消息。
- en: 'By designating a different log location by goroutine `ID`, `timestamp`, and
    `serverID`, any concurrency issues that arise can be quickly plucked from logfiles.
    This is done using the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为goroutine `ID`，`timestamp`和`serverID`指定不同的日志位置，可以快速从日志文件中提取任何并发问题。使用以下代码完成：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using the log4go package for robust logging
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用log4go包进行强大的日志记录
- en: As with most things in Go, where there's something satisfactory and extensible
    in the core page, it can be taken to the next level by a third party—Go's wonderful
    logging package is truly brought to life with **log4go**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与Go中的大多数事物一样，在核心页面中有令人满意和可扩展的东西，可以通过第三方（Go的精彩日志包真正地与**log4go**结合在一起。
- en: Using log4go greatly simplifies the process of file logging, console logging,
    and logging via TCP/UDP.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用log4go极大地简化了文件记录、控制台记录和通过TCP/UDP记录的过程。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more information on log4go, visit [https://code.google.com/p/log4go/](https://code.google.com/p/log4go/).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有关log4go的更多信息，请访问[https://code.google.com/p/log4go/](https://code.google.com/p/log4go/)。
- en: 'Each instance of a `log4go Logger` interface can be configured by an XML configuration
    file and can have filters applied to it to dictate where messaging goes. Let''s
    look at a simple HTTP server to show how we can direct specific logs to location,
    as shown in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`log4go Logger`接口的实例都可以通过XML配置文件进行配置，并且可以对其应用过滤器以指示消息的去向。让我们看一个简单的HTTP服务器，以展示如何将特定的日志定向到位置，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we created four distinct log objects—one that writes
    errors to a logfile, one that writes accesses (page requests) to a separate file,
    one that sends directly to console (for important notices), and one that passes
    a log message across the network.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了四个不同的日志对象——一个将错误写入日志文件，一个将访问（页面请求）写入到一个单独的文件，一个直接发送到控制台（用于重要通知），一个将日志消息传递到网络。
- en: 'The last two obviously do not need `FileLogWriter`, although it''s entirely
    possible to replicate the network logging using a shared drive if we can mitigate
    issues with concurrent access, as shown in the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个显然不需要`FileLogWriter`，尽管完全可以使用共享驱动器来复制网络记录，如果我们可以减轻并发访问的问题，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Any request to a valid page goes here, sending the message to the `web-access.log`
    file `accessLog`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对有效页面的请求都会发送消息到`web-access.log`文件`accessLog`。
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As with the `accessLog` file, we''ll take any `404 / page not found` request
    and route it directly to the `notFound()` method, which saves a fairly generic
    error message along with the invalid `/` missing URL requested. Let''s look at
    what we''ll do with extremely important errors and messages in the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与`accessLog`文件一样，我们将接受任何`404 /页面未找到`的请求，并直接将其路由到`notFound()`方法，该方法保存了一个相当通用的错误消息以及无效的`/`丢失的URL请求。让我们看看在下面的代码中我们将如何处理非常重要的错误和消息：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `restricted()` function and corresponding `screenLog` represents a message
    we deem as *critical* and worthy of going to not only the error and the access
    logs, but also to screen and passed across the wire as a `networkLog` item. In
    other words, it's a message so important that everybody gets it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`restricted()`函数和相应的`screenLog`表示我们认为是*关键*的消息，并且值得不仅发送到错误和访问日志，而且还发送到屏幕并作为`networkLog`项目传递。换句话说，这是一个非常重要的消息，每个人都会收到。'
- en: In this case, we're detecting attempts to get at our `.git` folder, which is
    a fairly common accidental security vulnerability that people have been known
    to commit in automatic file uploads and updates. Since we have cleartext passwords
    represented in files and may expose that to the outside world, we'll catch this
    on request and pass to our critical and noncritical logging mechanisms.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在检测尝试访问我们的`.git`文件夹，这是一个相当常见的意外安全漏洞，人们已知在自动文件上传和更新中犯过这种错误。由于我们在文件中表示明文密码，并且可能将其暴露给外部世界，我们将在请求时捕获这些并传递给我们的关键和非关键日志记录机制。
- en: 'We might also look at this as a more open-ended bad request notifier—one worthy
    of immediate attention from a network developer. In the following code, we''ll
    start creating a few loggers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将其视为一个更开放的坏请求通知器-值得网络开发人员立即关注。在下面的代码中，我们将开始创建一些日志记录器：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since log4go opens up a bevy of additional logging options, we can play a bit
    with how our logs rotate and are formatted without having to draw that out specifically
    with `Sprintf` or something similar.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于log4go提供了许多额外的日志选项，我们可以稍微调整我们的日志轮换和格式，而不必专门使用`Sprintf`或类似的东西来绘制出来。
- en: 'The options here are simple and expressive:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的选项简单而富有表现力：
- en: '`SetFormat`: This allows us to specify how our individual log lines will look.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetFormat`：这允许我们指定我们的单独日志行的外观。'
- en: '`SetRotate`: This permits automatic rotation based on the size of the file
    and/or the number of lines in `log`. The `SetRotateSize()` option sets rotation
    on bytes in the message and `SetRotateLines()` sets the maximum number of `lines`.The
    `SetRotateDaily()` function lets us create new logfiles based on the day regardless
    of our settings in the previous functions. This is a fairly common logging technique
    and can generally be burdensome to code by hand.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetRotate`：这允许根据文件大小和/或`log`中的行数自动旋转。`SetRotateSize()`选项设置消息中的字节旋转，`SetRotateLines()`设置最大的`行数`。`SetRotateDaily()`函数让我们根据前面函数中的设置在每天创建新的日志文件。这是一个相当常见的日志记录技术，通常手工编码会很繁琐。'
- en: 'The output of our logging format ends up looking like the following line of
    code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的日志格式的输出最终看起来像以下一行代码：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `%S` part is the source, and that gives us the line number and our method
    trace for the part of our application that invoked the log:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`%S`部分是源，它为我们提供了调用日志的应用程序部分的行号和方法跟踪：'
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our network log sends JSON-encoded messages via TCP to the address we provide.
    We''ll show a very simple handling server for this in the next section of code
    that translates the log messages into a centralized logfile:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络日志通过TCP发送JSON编码的消息到我们提供的地址。我们将在下一节的代码中展示一个非常简单的处理服务器，将日志消息转换为一个集中的日志文件：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our `accessLogWriter` is similar to the `errorLogWriter` except that instead
    of rotating daily, we rotate it every 500 lines. The idea here is that access
    logs would of course be more frequently touched than an error log—hopefully. The
    code is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`accessLogWriter`与`errorLogWriter`类似，只是它不是每天轮换一次，而是每500行轮换一次。这里的想法是访问日志当然会比错误日志更频繁地被访问-希望如此。代码如下：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, we used the Gorilla Mux package for routing. This gives
    us easier access to the `404` handler, which is less than simplistic to modify
    in the basic `http` package built directly into Go. The code is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了Gorilla Mux包进行路由。这使我们更容易访问`404`处理程序，在基本的直接内置到Go中的`http`包中修改起来不那么简单。代码如下：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Building the receiving end of a network logging system like this is also incredibly
    simple in Go, as we're building nothing more than another TCP client that can
    handle the JSON-encoded messages.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样构建网络日志系统的接收端在Go中也非常简单，因为我们构建的只是另一个可以处理JSON编码消息的TCP客户端。
- en: 'We can do this with a receiving server that looks remarkably similar to our
    TCP chat server from an earlier chapter. The code is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个接收服务器来做到这一点，这个接收服务器看起来与我们早期章节中的TCP聊天服务器非常相似。代码如下：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As with our chat server, we bind our listener to a `Connection` struct, as
    shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的聊天服务器一样，我们将我们的监听器绑定到一个`Connection`结构，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we receive log messages delivered via JSON. At this point,
    we're not unmarshalling the JSON, but we've shown how to do that in an earlier
    chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过JSON接收日志消息。在这一点上，我们还没有解析JSON，但我们已经在早期的章节中展示了如何做到这一点。
- en: Any message sent will be pushed into the buffer—for this reason, it may make
    sense to expand the buffer's size depending on how detailed the information is.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 发送的任何消息都将被推送到缓冲区中-因此，根据信息的详细程度，扩展缓冲区的大小可能是有意义的。
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can imagine how network logging can be useful, particularly in server clusters
    where you might have a selection of, say, web servers and you don't want to reconcile
    individual logfiles into a single log.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象网络日志记录在哪里会很有用，特别是在服务器集群中，你可能有一系列的，比如，Web服务器，你不想将单独的日志文件合并成一个日志。
- en: Panicking
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恐慌
- en: With all the discussion of capturing errors and logging them, we should probably
    consider the `panic()` and `recover()` functionality in Go.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论捕获错误并记录它们时，我们可能应该考虑Go中的`panic()`和`recover()`功能。
- en: As briefly discussed earlier, `panic()` and `recover()` operate as a more basic,
    immediate, and explicit error detection methodology than, say, `try`/`catch`/`finally`
    or even Go's built-in error return value convention. As designed, `panic()` unwinds
    the stack and leads to program exit unless `recover()` is invoked. This means
    that unless you explicitly recover, your application will end.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面简要讨论的，`panic()`和`recover()`作为一种更基本、即时和明确的错误检测方法，比如`try`/`catch`/`finally`甚至Go的内置错误返回值约定。按设计，`panic()`会解开堆栈并导致程序退出，除非调用`recover()`。这意味着除非你明确地恢复，否则你的应用程序将结束。
- en: 'So, how is this useful other than for stopping execution? After all, we can
    catch an error and simply end the application manually through something similar
    to the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，除了停止执行之外，这有什么用处呢？毕竟，我们可以捕获错误并通过类似以下代码手动结束应用程序：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: However, while this function does sanity checking and enacts a permanent, irreversible
    application exit, `panic()` and `recover()` allow us to reflect errors from a
    specific package and/or method, save those, and then resume gracefully.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然这个函数进行了健全性检查并执行了永久的、不可逆转的应用程序退出，`panic()`和`recover()`允许我们从特定包和/或方法中反映错误，保存这些错误，然后优雅地恢复。
- en: This is very useful when we're dealing with methods that are called from other
    methods that are called from other methods, and so on. The types of deeply embedded
    or recursive functions that make it hard to discern a specific error are where
    `panic()` and `recover()` are most advantageous. You can also imagine how well
    this functionality can play with logging.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理从其他方法调用的方法时，这是非常有用的，这些方法又是从其他方法调用的，依此类推。深度嵌套或递归函数的类型使得很难辨别特定错误，这就是`panic()`和`recover()`最有优势的地方。你也可以想象这种功能与日志记录的结合有多么好。
- en: Recovering
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复
- en: The `panic()` function on its own is fairly simple, and it really becomes useful
    when paired with `recover()` and `defer()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`panic()`函数本身相当简单，当与`recover()`和`defer()`配对时，它真正变得有用。'
- en: Take, for example, an application that returns meta information about a file
    from the command line. The main part of the application will listen for user input,
    pass this into a function that will open the file, and then pass that file reference
    to another function that will get the file's details.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，一个应用程序从命令行返回有关文件的元信息。应用程序的主要部分将监听用户输入，将其传递到一个打开文件的函数中，然后将该文件引用传递给另一个函数，该函数将获取文件的详细信息。
- en: Now, we can obviously stack errors as return elements straight through the process,
    or we can panic along the way, recover back down the steps, and gather our errors
    at the bottom for logging and/or reporting directly to console.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，显然我们可以直接通过过程堆叠错误作为返回元素，或者我们可以在途中发生panic，恢复回到步骤，然后在底部收集我们的错误以进行日志记录和/或直接报告到控制台。
- en: 'Avoiding spaghetti code is a welcomed side effect of this approach versus the
    former one. Think of this in a general sense (this is pseudo code):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 避免意大利面代码是这种方法与前一种方法相比的一个受欢迎的副作用。以一般意义来考虑（这是伪代码）：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With a single error, it''s entirely manageable to approach our application
    in this way. However, when each individual function has one or more points of
    failure, we will require more and more return values and a way of reconciling
    them all into a single overall error message or messages. Check the following
    code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个错误时，完全可以以这种方式处理我们的应用程序。然而，当每个单独的函数都有一个或多个失败点时，我们将需要更多的返回值以及一种将它们全部整合成单个整体错误消息或多个消息的方法。检查以下代码：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is our general recovery function, which is called before every method
    on which we wish to capture any panic. Let''s look at a function to deduce the
    file''s details:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的一般恢复函数，在我们希望捕获任何panic之前调用每个方法。让我们看一个推断文件详细信息的函数：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The two functions from the preceding code are merely an attempt to open a file
    and panic if the file does not exist. The second method, `getFileDetails()`, is
    called from the `main()` function such that it will always execute, regardless
    of a blocking error in `openFile()`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的两个函数仅仅是尝试打开一个文件并在文件不存在时发生panic。第二个方法`getFileDetails()`被从`main()`函数中调用，这样它将始终执行，而不管`openFile()`中是否有阻塞错误。
- en: 'In the real world, we will often develop applications where a nonfatal error
    stops just a portion of the application from working, but will not cause the application
    as a whole to break. Check the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们经常会开发应用程序，其中非致命错误只会导致应用程序的部分功能停止工作，但不会导致整个应用程序崩溃。检查以下代码：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we were to remove the `recover()` code from our `gatherPanics()` method,
    the application would crash if/when the file didn't exist.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从`gatherPanics()`方法中删除`recover()`代码，那么如果/当文件不存在，应用程序将崩溃。
- en: This may seem ideal, but imagine a scenario where a user selects a nonexistent
    file for a directory that they lack the rights to view. When they solve the first
    problem, they will be presented with the second instead of seeing all potential
    issues at one time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很理想，但想象一下一个用户选择了一个不存在的文件作为他们没有权限查看的目录。当他们解决了第一个问题时，他们将被呈现第二个问题，而不是一次看到所有潜在的问题。
- en: The value of expressive errors can't be overstated from a user experience standpoint.
    Gathering and presenting expressive errors is made easier through this methodology—even
    a `try`/`catch`/`finally` requires that we (as developers) explicitly do something
    with the returned error in the catch clause.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户体验的角度来看，表达错误的价值无法被过分强调。通过这种方法，收集和呈现表达性错误变得更加容易——即使`try`/`catch`/`finally`也要求我们（作为开发人员）在catch子句中明确地处理返回的错误。
- en: Logging our panics
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录我们的panic
- en: In the preceding code, we can integrate a logging mechanism pretty simply in
    addition to catching our panics.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以很简单地集成一个日志记录机制，除了捕获我们的panic。
- en: One consideration about logging that we haven't discussed is the notion of when
    to log. As our previous examples illustrate, we can sometimes run into problems
    that should be logged but may be mitigated by future user action. As such, we
    can choose to log our errors immediately or save it until the end of execution
    or a greater function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于日志记录，我们还没有讨论的一个考虑是何时记录。正如我们之前的例子所说明的，有时我们可能遇到应该记录但可能会被未来用户操作所缓解的问题。因此，我们可以选择立即记录错误或将其保存到执行结束或更大的函数结束时再记录。
- en: 'The primary benefit of logging immediately is that we''re not susceptible to
    an actual crash preventing our log from being saved. Take the following example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 立即记录日志的主要好处是我们不容易受到实际崩溃的影响，从而无法保存日志。举个例子：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We''ve created a log `struct` and a slice of `LogItems` using the following
    code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码创建了一个日志`struct`和一个`LogItems`的切片：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This, ostensibly, is where all of our captured `LogItems` will be turned into
    a good collection of line items in a logfile. There is a problem, however, as
    illustrated in the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们捕获的所有`LogItems`将被转换为日志文件中的一系列好的行项目。然而，如下代码所示，存在问题：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Executed in a goroutine, this function is non-blocking and allows the main
    thread''s execution to continue. The problem is with the following code that runs
    after the goroutine, which causes us to log nothing at all:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在goroutine中执行此函数是非阻塞的，并允许主线程的执行继续。问题出在goroutine之后运行的以下代码，导致我们根本没有记录任何内容：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Whether invoked manually or by the binary itself, the application quitting
    prematurely precludes our logfiles from being written, as that method is deferred
    until the end of the `main()` method. The code is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是手动调用还是由二进制文件本身调用，应用程序过早退出都会导致我们的日志文件无法写入，因为该方法被延迟到`main()`方法结束。代码如下：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The tradeoff here, however, is performance. If we execute a file operation every
    time we want to log something, we're potentially introducing a bottleneck into
    our application. In the preceding code, errors are sent via goroutine but written
    in blocking code—if we introduce the log writing directly into `registerError()`,
    it can slow down our final application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里的权衡是性能。如果我们每次想要记录日志时执行文件操作，就可能在应用程序中引入瓶颈。在前面的代码中，错误是通过goroutine发送的，但在阻塞代码中写入——如果我们直接将日志写入`registerError()`中，可能会减慢我们最终应用程序的速度。
- en: As mentioned previously, one opportunity to mitigate these issues and allow
    the application to still save all of our log entries is to utilize either memory
    logging or network logging.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，缓解这些问题并允许应用程序仍然保存所有日志条目的一个机会是利用内存日志或网络日志。
- en: Catching stack traces with concurrent code
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获并发代码的堆栈跟踪
- en: In earlier Go releases, the ability to properly execute a stack trace from our
    source was a daunting task, which is emblematic of some of the many complaints
    and concerns users had early on about general error handling in Go.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的Go版本中，从源代码正确执行堆栈跟踪是一项艰巨的任务，这体现了用户在Go语言早期对一般错误处理的许多抱怨和担忧。
- en: While the Go team has remained vigilant about the *right* way to do this (as
    they have with several other key language features such as a lack of generics),
    stack traces and stack info have been tweaked a bit as the language has grown.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go团队一直对*正确*的方法保持警惕（就像他们对其他一些关键语言特性如泛型的处理一样），但随着语言的发展，堆栈跟踪和堆栈信息已经有所调整。
- en: Using the runtime package for granular stack traces
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用runtime包进行细粒度堆栈跟踪
- en: In an effort to capture stack traces directly, we can glean some helpful pieces
    of information from the built-in runtime package.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了直接捕获堆栈跟踪，我们可以从内置的runtime包中获取一些有用的信息。
- en: 'Specifically, Go provides a couple of tools to give us insight into the invocation
    and/or breakpoints of a goroutine. The following are the functions within the
    runtime package:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，Go语言提供了一些工具，可以帮助我们了解goroutine的调用和/或断点。以下是runtime包中的函数：
- en: '`runtime.Caller()`: This returns information about the parent function of a
    goroutine'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime.Caller()`: 返回goroutine的父函数的信息'
- en: '`runtime.Stack()`: This allocates a buffer for the amount of data in a stack
    trace and then fills that with the trace'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime.Stack()`: 为堆栈跟踪中的数据分配一个缓冲区，然后填充该缓冲区'
- en: '`runtime.NumGoroutine()`: This returns the total number of open goroutines'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime.NumGoroutine()`: 返回当前打开的goroutine的总数'
- en: We can utilize all three preceding tools to better describe the inner workings
    of any given goroutine and related errors.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用前面提到的三种工具来更好地描述任何给定goroutine的内部工作和相关错误。
- en: 'Using the following code, we''ll spawn some random goroutines doing random
    things and log not only the goroutine''s log message, but also the stack trace
    and the goroutine''s caller:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码，我们将生成一些随机的goroutine执行随机的操作，并记录不仅goroutine的日志消息，还有堆栈跟踪和goroutine的调用者：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `saveLogs()` function merely takes our map of `LogItems` and applies them
    to file per log4go, as we did earlier in the chapter. Next, we''ll look at the
    function that supplies details on our goroutines:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveLogs()`函数只是将我们的`LogItems`映射到文件中，就像我们在本章前面做的那样。接下来，我们将看一下提供有关我们goroutines详细信息的函数：'
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is where we gather more details about a goroutine. The `runtime.Caller()`
    function provides a few returned values: its pointer, the filename of the caller,
    the line of the caller. The last return value indicates whether the caller could
    be found.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们收集有关goroutine的更多细节的地方。`runtime.Caller()`函数提供了一些返回值：指针、调用者的文件名、调用者的行号。最后一个返回值指示是否找到了调用者。
- en: As mentioned previously, `runtime.NumGoroutine()` gives us the number of extant
    goroutines that have not yet been closed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`runtime.NumGoroutine()`给出了尚未关闭的现有goroutine的数量。
- en: Then, in `runtime.Stack(stackBuf, false)`, we fill our buffer with the stack
    trace. Note that we're not trimming this byte array to length.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`runtime.Stack(stackBuf, false)`中，我们用堆栈跟踪填充我们的缓冲区。请注意，我们没有将这个字节数组修剪到指定长度。
- en: 'All three are passed into `LogItem.Message` for later use. Let''s look at the
    setup in the `main()` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三个都被传递到 `LogItem.Message` 中以供以后使用。让我们看看 `main()` 函数中的设置：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, we loop through some goroutines that are doing loops themselves and
    exit upon completion.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们循环遍历一些正在执行循环的 goroutines，并在完成后退出。
- en: 'When we examine our logfile, we''re given far more verbose details on our goroutines
    than we have previously, as shown in the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查日志文件时，我们得到的关于 goroutines 的详细信息比以前要多得多，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more information on the runtime package, go to [http://golang.org/pkg/runtime/](http://golang.org/pkg/runtime/).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有关运行时包的更多信息，请访问 [http://golang.org/pkg/runtime/](http://golang.org/pkg/runtime/)。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Debugging, testing, and logging concurrent code can be particularly cumbersome,
    often when concurrent goroutines fail in a seemingly silent fashion or fail to
    execute whatsoever.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 调试、测试和记录并发代码可能特别麻烦，尤其是当并发的 goroutines 以一种看似无声的方式失败或根本无法执行时。
- en: We looked at various methods of logging, from file to console to memory to network
    logging, and examined how concurrent application pieces can fit into these various
    implementations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了各种记录方法，从文件到控制台到内存到网络记录，并研究了并发应用程序组件如何适应这些不同的实现。
- en: By now, you should be comfortable and natural in creating robust and expressive
    logs that rotate automatically, impose no latency or bottlenecks, and assist in
    debugging your applications.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经可以轻松自然地创建健壮且表达力强的日志，这些日志会自动轮换，不会产生延迟或瓶颈，并有助于调试您的应用程序。
- en: You should feel comfortable with the basics of the runtime package. We'll dive
    into the testing package, controlling goroutines more explicitly, and unit testing
    as we dig deeper in the next chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该对运行时包的基础知识感到满意。随着我们在下一章中深入挖掘，我们将深入探讨测试包、更明确地控制 goroutines 和单元测试。
- en: In addition to further examining the testing and runtime packages, in our final
    chapter, we'll also broach the topic of more advanced concurrency topics in Go
    as well as review some overall best practices as they relate to programming in
    the Go language.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了进一步检查测试和运行时包之外，在我们的最后一章中，我们还将涉及更高级的并发主题，以及审查一些与在 Go 语言中编程相关的总体最佳实践。
