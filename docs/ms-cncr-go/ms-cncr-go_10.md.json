["```go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"time\"\n  \"net/http\"\n)\n\nconst INIT_DELAY = 3000\nconst MAX_DELAY = 60000\nconst MAX_RETRIES = 4\nconst DELAY_INCREMENT = 5000\n```", "```go\nvar Servers []Server\n\ntype Server struct {\n  Name string\n  URI string\n  LastChecked time.Time\n  Status bool\n  StatusCode int\n  Delay int\n  Retries int\n  Channel chan bool\n}\n```", "```go\nfunc (s *Server) checkServerStatus(sc chan *Server) {\n  var previousStatus string\n\n    if s.Status == true {\n      previousStatus = \"OK\"\n    }else {\n      previousStatus = \"down\"\n    }\n\n    fmt.Println(\"Checking Server\",s.Name)\n    fmt.Println(\"\\tServer was\",previousStatus,\"on last check at\",s.LastChecked)\n\n    response, err := http.Get(s.URI)\n    if err != nil {\n      fmt.Println(\"\\tError: \",err)\n      s.Status = false\n      s.StatusCode = 0\n    }else {\n      fmt.Println(response.Status)\n      s.StatusCode = response.StatusCode\n      s.Status = true\n    }\n\n    s.LastChecked = time.Now()\n    sc <- s\n}\n```", "```go\nfunc cycleServers(sc chan *Server) {\n\n  for i := 0; i < len(Servers); i++ {\n    Servers[i].Channel = make(chan bool)\n    go Servers[i].updateDelay(sc)\n    go Servers[i].checkServerStatus(sc)\n  }\n\n}\n```", "```go\nfunc (s *Server) updateDelay(sc chan *Server) {\n  for {\n    select {\n      case msg := <- s.Channel:\n\n        if msg == false {\n          s.Delay = s.Delay + DELAY_INCREMENT\n          s.Retries++\n          if s.Delay > MAX_DELAY {\n            s.Delay = MAX_DELAY\n          }\n\n        }else {\n          s.Delay = INIT_DELAY\n        }\n        newDuration := time.Duration(s.Delay)\n\n        if s.Retries <= MAX_RETRIES {\n          fmt.Println(\"\\tWill check server again\")\n          time.Sleep(newDuration * time.Millisecond)\n          s.checkServerStatus(sc)\n        }else {\n          fmt.Println(\"\\tServer not reachable after\",MAX_RETRIES,\"retries\")\n        }\n\n      default:\n    }\n  }\n}\n```", "```go\nfunc main() {\n\n  endChan := make(chan bool)\n  serverChan := make(chan *Server)\n\nServers = []Server{ {Name: \"Google\", URI: \"http://www.google.com\", Status: true, Delay: INIT_DELAY}, {Name: \"Yahoo\", URI: \"http://www.yahoo.com\", Status: true, Delay: INIT_DELAY}, {Name: \"Bad Amazon\", URI: \"http://amazon.zom\", Status: true, Delay: INIT_DELAY} }\n```", "```go\n  go cycleServers(serverChan)\n\n  for {\n    select {\n      case currentServer := <- serverChan:\n        currentServer.Channel <- false\n      default:\n\n    }\n  }\n\n  <- endChan\n\n}\n```", "```go\nChecking Server Google\n Server was OK on last check at 0001-01-01 00:00:00 +0000 UTC\n 200 OK\n Will check server again\nChecking Server Yahoo\n Server was OK on last check at 0001-01-01 00:00:00 +0000 UTC\n 200 OK\n Will check server again\nChecking Server Amazon\n Server was OK on last check at 0001-01-01 00:00:00 +0000 UTC\n Error:  Get http://amazon.zom: dial tcp: GetAddrInfoW: No such host is known.\n Will check server again\nChecking Server Google\n Server was OK on last check at 2014-04-23 12:49:45.6575639 -0400 EDT\n\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"time\"\n)\n\nconst CONSUMERS = 5\n\nfunc main() {\n\n  Producer := make(chan (chan int))\n\n  for i := 0; i < CONSUMERS; i++ {\n    go func() {\n      time.Sleep(1000 * time.Microsecond)\n      conChan := make(chan int)\n\n      go func() {\n        for {\n          select {\n          case _,ok := <-conChan:\n            if ok  {\n              Producer <- conChan\n            }else {\n              return\n            }\n          default:\n          }\n        }\n      }()\n\n      conChan <- 1\n      close(conChan)\n    }()\n  }\n```", "```go\n  for {\n    select {\n    case consumer, ok := <-Producer:\n      if ok == false {\n        fmt.Println(\"Goroutine closed?\")\n        close(Producer)\n      } else {\n        log.Println(consumer)\n        // consumer <- 1\n      }\n      fmt.Println(\"Got message from secondary channel\")\n    default:\n    }\n  }\n}\n```", "```go\nfunc main() {\n\n  var channel chan int\n\n    channel <- 1\n\n  for {\n    select {\n      case <- channel:\n\n      default:\n    }\n  }\n\n}\n```", "```go\n  var done chan int\n  defer close(done)\n  defer log.Println(\"End of script\")\n  go func() {\n    time.Sleep(time.Second * 5)\n    done <- 1\n  }()\n\n  for {\n    select {\n      case <- done:\n        log.Println(\"Got transmission\")\n        return\n      default:\n    }\n  }\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n  \"launchpad.net/tomb\"\n  \"net/http\"\n  \"strconv\"\n  \"sync\"\n  \"time\"\n)\n\nvar URLS []URL\n\ntype GoTomb struct {\n  tomb tomb.Tomb\n}\n```", "```go\ntype URL struct {\n  Status bool\n  URI    string\n  Body   string\n}\n```", "```go\nfunc (gt GoTomb) Kill() {\n\n  gt.tomb.Kill(nil)\n\n}\n```", "```go\nfunc (gt *GoTomb) TombListen(i int) {\n\n  for {\n    select {\n    case <-gt.tomb.Dying():\n      fmt.Println(\"Got kill command from tomb!\")\n      if URLS[i].Status == false {\n        fmt.Println(\"Never got data for\", URLS[i].URI)\n      }\n      return\n    }\n  }\n}\n```", "```go\nfunc (gt *GoTomb) Fetch() {\n  for i := range URLS {\n    go gt.TombListen(i)\n\n    go func(ii int) {\n\n      timeDelay := 5 * ii\n      fmt.Println(\"Waiting \", strconv.FormatInt(int64(timeDelay), 10), \" seconds to get\", URLS[ii].URI)\n      time.Sleep(time.Duration(timeDelay) * time.Second)\n      response, _ := http.Get(URLS[ii].URI)\n      URLS[ii].Status = true\n      fmt.Println(\"Got body for \", URLS[ii].URI)\n      responseBody, _ := ioutil.ReadAll(response.Body)\n      URLS[ii].Body = string(responseBody)\n    }(i)\n  }\n}\n```", "```go\nfunc main() {\n\n  done := make(chan int)\n\n  URLS = []URL{{Status: false, URI: \"http://www.google.com\", Body: \"\"}, {Status: false, URI: \"http://www.amazon.com\", Body: \"\"}, {Status: false, URI: \"http://www.ubuntu.com\", Body: \"\"}}\n\n  var MasterChannel GoTomb\n  MasterChannel.Fetch()\n\n  go func() {\n\n    time.Sleep(10 * time.Second)\n    MasterChannel.Kill()\n    done <- 1\n  }()\n\n  for {\n    select {\n    case <-done:\n      fmt.Println(\"\")\n      return\n    default:\n    }\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"log\"\n  \"time\"\n)\n\nfunc main() {\n\n  timeout := time.NewTimer(5 * time.Second)\n  defer log.Println(\"Timed out!\")\n\n  for {\n    select {\n    case <-timeout.C:\n      return\n    default:\n    }\n  }\n\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"time\"\n)\n\nfunc main() {\n\n  myChan := make(chan int)\n\n  go func() {\n    time.Sleep(6 * time.Second)\n    myChan <- 1\n  }()\n\n  for {\n    select {\n      case <-time.After(5 * time.Second):\n        fmt.Println(\"This took too long!\")\n        return\n      case <-myChan:\n        fmt.Println(\"Too little, too late\")\n    }\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"net/http/httputil\"\n  \"net/url\"\n  \"strconv\"\n  \"time\"\n)\n\nconst MAX_SERVER_FAILURES = 10\nconst DEFAULT_TIMEOUT_SECONDS = 5\nconst MAX_TIMEOUT_SECONDS = 60\nconst TIMEOUT_INCREMENT = 5\nconst MAX_RETRIES = 5\n```", "```go\ntype Server struct {\n  Name        string\n  Failures    int\n  InService   bool\n  Status      bool\n  StatusCode  int\n  Addr        string\n  Timeout     int\n  LastChecked time.Time\n  Recheck     chan bool\n}\n```", "```go\nfunc (s *Server) serverListen(serverChan chan bool) {\n  for {\n    select {\n    case msg := <-s.Recheck:\n      var statusText string\n      if msg == false {\n        statusText = \"NOT in service\"\n        s.Failures++\n        s.Timeout = s.Timeout + TIMEOUT_INCREMENT\n        if s.Timeout > MAX_TIMEOUT_SECONDS {\n          s.Timeout = MAX_TIMEOUT_SECONDS\n        }\n      } else {\n        if ServersAvailable == false {\n          ServersAvailable = true\n          serverChan <- true\n        }\n        statusText = \"in service\"\n        s.Timeout = DEFAULT_TIMEOUT_SECONDS\n      }\n\n      if s.Failures >= MAX_SERVER_FAILURES {\n        s.InService = false\n        fmt.Println(\"\\tServer\", s.Name, \"failed too many times.\")\n      } else {\n        timeString := strconv.FormatInt(int64(s.Timeout), 10)\n        fmt.Println(\"\\tServer\", s.Name, statusText, \"will check again in\", timeString, \"seconds\")\n        s.InService = true\n        time.Sleep(time.Second * time.Duration(s.Timeout))\n        go s.checkStatus()\n      }\n\n    }\n  }\n}\n```", "```go\nfunc (s *Server) checkStatus() {\n  previousStatus := \"Unknown\"\n  if s.Status == true {\n    previousStatus = \"OK\"\n  } else {\n    previousStatus = \"down\"\n  }\n  fmt.Println(\"Checking Server\", s.Name)\n  fmt.Println(\"\\tServer was\", previousStatus, \"on last check at\", s.LastChecked)\n  response, err := http.Get(s.Addr)\n  if err != nil {\n    fmt.Println(\"\\tError: \", err)\n    s.Status = false\n    s.StatusCode = 0\n  } else {\n    s.StatusCode = response.StatusCode\n    s.Status = true\n  }\n\n  s.LastChecked = time.Now()\n  s.Recheck <- s.Status\n}\n```", "```go\nfunc healthCheck(sc chan bool) {\n  fmt.Println(\"Running initial health check\")\n  for i := range Servers {\n    Servers[i].Recheck = make(chan bool)\n    go Servers[i].serverListen(sc)\n    go Servers[i].checkStatus()\n  }\n}\n```", "```go\nfunc roundRobin() Server {\n  var AvailableServer Server\n\n  if nextServerIndex > (len(Servers) - 1) {\n    nextServerIndex = 0\n  }\n\n  if Servers[nextServerIndex].InService == true {\n    AvailableServer = Servers[nextServerIndex]\n  } else {\n    serverReady := false\n    for serverReady == false {\n      for i := range Servers {\n        if Servers[i].InService == true {\n          AvailableServer = Servers[i]\n          serverReady = true\n        }\n      }\n\n    }\n  }\n  nextServerIndex++\n  return AvailableServer\n}\n```", "```go\nvar Servers []Server\nvar nextServerIndex int\nvar ServersAvailable bool\nvar ServerChan chan bool\nvar Proxy *httputil.ReverseProxy\nvar ResetProxy chan bool\n```", "```go\nfunc handler(p *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) {\n  Proxy = setProxy()\n  return func(w http.ResponseWriter, r *http.Request) {\n\n    r.URL.Path = \"/\"\n\n    p.ServeHTTP(w, r)\n\n  }\n}\n```", "```go\nfunc setProxy() *httputil.ReverseProxy {\n\n  nextServer := roundRobin()\n  nextURL, _ := url.Parse(nextServer.Addr)\n  log.Println(\"Next proxy source:\", nextServer.Addr)\n  prox := httputil.NewSingleHostReverseProxy(nextURL)\n\n  return prox\n}\n```", "```go\nfunc startListening() {\n  http.HandleFunc(\"/index.html\", handler(Proxy))\n  _ = http.ListenAndServe(\":8080\", nil)\n\n}\n\nfunc main() {\n  nextServerIndex = 0\n  ServersAvailable = false\n  ServerChan := make(chan bool)\n  done := make(chan bool)\n\n  fmt.Println(\"Starting load balancer\")\n  Servers = []Server{{Name: \"Web Server 01\", Addr: \"http://www.google.com\", Status: false, InService: false}, {Name: \"Web Server 02\", Addr: \"http://www.amazon.com\", Status: false, InService: false}, {Name: \"Web Server 03\", Addr: \"http://www.apple.zom\", Status: false, InService: false}}\n\n  go healthCheck(ServerChan)\n\n  for {\n    select {\n    case <-ServerChan:\n      Proxy = setProxy()\n      startListening()\n      return\n\n    }\n  }\n\n  <-done\n}\n```", "```go\nconst TOTAL_RANDOMS = 100\n\nfunc concurrentNumbers(ch chan int) {\n  for i := 0; i < TOTAL_RANDOMS; i++ {\n    ch <- i\n  }\n}\n\nfunc main() {\n\n  ch := make(chan int)\n\n  go concurrentNumbers(ch)\n\n  for {\n    select {\n      case num := <- ch:\n        fmt.Println(num)\n        if num == 98 {\n          close(ch)\n        }\n      default:\n    }\n  }\n}\n```", "```go\npackage main\n\nimport (\n\n  \"fmt\"\n  \"time\"\n)\n\nfunc main() {\n\n  acceptingChannel := make(chan interface{})\n\n  go func() {\n\n    acceptingChannel <- \"A text message\"\n    time.Sleep(3 * time.Second)\n    acceptingChannel <- false\n  }()\n\n  for {\n    select {\n      case msg := <- acceptingChannel:\n        switch typ := msg.(type) {\n          case string:\n            fmt.Println(\"Got text message\",typ)\n          case bool:\n            fmt.Println(\"Got boolean message\",typ)\n            if typ == false {\n              return\n            }\n          default:\n          fmt.Println(\"Some other type of message\")\n        }\n\n      default:\n\n    }\n\n  }\n\n  <- acceptingChannel\n}\n```", "```go\nmathematics.go\npackage mathematics\n\nfunc Square(x int) int {\n\n  return x * 3\n}\nmathematics_test.go\npackage mathematics\n\nimport\n(\n  \"testing\"\n)\n\nfunc Test_Square_1(t *testing.T) {\n  if Square(2) != 4 {\n    t.Error(\"Square function failed one test\")\n  }\n}\n```", "```go\nfunc Square(x int) int {\n\n  return x * x\n}\n```", "```go\n/projects/\n  thisproject/\n    bin/\n    pkg/\n    src/\n      package/\n        mypackage.go\n```", "```go\n// A demo documentation package\npackage documentation\n\n// The documentation struct object\n// Chapter int represents a document's chapter\n// Content represents the text of the documentation\ntype Documentation struct {\n  Chapter int\n  Content string\n}\n\n//  Display() outputs the content of any given Document by chapter\nfunc (d Documentation) Display() {\n\n}\n```"]