["```go\nALTER TABLE `users`\n  ADD UNIQUE INDEX `user_email` (`user_email`);\n```", "```go\nCREATE TABLE `users_relationships` (\n  `users_relationship_id` INT(13) NOT NULL,\n  `from_user_id` INT(10) NOT NULL,\n  `to_user_id` INT(10) unsigned NOT NULL,\n  `users_relationship_type` VARCHAR(10) NOT NULL,\n  `users_relationship_timestamp` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  PRIMARY KEY (`users_relationship_id`),\n  INDEX `from_user_id` (`from_user_id`),\n  INDEX `to_user_id` (`to_user_id`),\n  INDEX `from_user_id_to_user_id` (`from_user_id`, `to_user_id`),\n\n  INDEX `from_user_id_to_user_id_users_relationship_type` (`from_user_id`, `to_user_id`, `users_relationship_type`)\n)\n```", "```go\npackage main\n\nimport\n(\n  \"encoding/json\"\n  \"net/http\"\n  \"fmt\"\n)\n\ntype User struct {\n  Name string `json:\"name\"`\n  Email string `json:\"email\"`\n  ID int `json:\"int\"`\n}\n\nfunc userRouter(w http.ResponseWriter, r *http.Request) {\n  ourUser := User{}\n  ourUser.Name = \"Bill Smith\"\n  ourUser.Email = \"bill.smith@example.com\"\n  ourUser.ID = 100\n\n  output,_ := json.Marshal(&ourUser)\n  fmt.Fprintln(w, string(output))\n}\n\nfunc main() {\n\n  fmt.Println(\"Starting JSON server\")\n  http.HandleFunc(\"/user\", userRouter)\n  http.ListenAndServe(\":8080\",nil)\n\n}\n```", "```go) characters, this represents a rune. Although a string is represented in double quotes and a char in single, the accent represents Unicode data that should remain constant. Technically, this content is held in an `int32` value.\n\nIn a struct, a third parameter in a variable/type declaration is called a tag. These are noteworthy for encoding because they have direct translations to JSON variables or XML tags.\n\nWithout a tag, we'll get our variable names returned directly.\n\n## XML\n\nAs mentioned earlier, XML was once the format of choice for developers. And although it's taken a step back, almost all APIs today still present XML as an option. And of course, RSS is still the number one syndication format.\n\nAs we saw earlier in our SOAP example, marshaling data into XML is simple. Let's take the data structure that we used in the earlier JSON response and similarly marshal it into the XML data in the following example.\n\nOur `User` struct is as follows:\n\n```", "```go\n\nAnd our obtained output is as follows:\n\n```", "```go\n\n## YAML\n\n**YAML** was an earlier attempt to make a human-readable serialized format similar to JSON. There does exist a Go-friendly implementation of YAML in a third-party plugin called `goyaml`.\n\nYou can read more about `goyaml` at [https://godoc.org/launchpad.net/goyaml](https://godoc.org/launchpad.net/goyaml). To install `goyaml`, we'll call a `go get launchpad.net/goyaml` command.\n\nAs with the default XML and JSON methods built into Go, we can also call `Marshal` and `Unmarshal` on YAML data. Using our preceding example, we can generate a YAML document fairly easily, as follows:\n\n```", "```go\n\nThe obtained output is as shown in the following screenshot:\n\n![YAML](img/1304OS_02_02.jpg)\n\n## CSV\n\nThe **Comma Separated Values** (**CSV**) format is another stalwart that's fallen somewhat out of favor, but it still persists as a possibility in some APIs, particularly legacy APIs.\n\nNormally, we wouldn't recommend using the CSV format in this day and age, but it may be particularly useful for business applications. More importantly, it's another encoding format that's built right into Go.\n\nCoercing your data into CSV is fundamentally no different than marshaling it into JSON or XML in Go because the `encoding/csv` package operates with the same methods as these subpackages.\n\n# Comparing the HTTP actions and methods\n\nAn important aspect to the ethos of REST is that data access and manipulation should be restricted by verb/method.\n\nFor example, the `GET` requests should not allow the user to modify, update, or create the data within. This makes sense. `DELETE` is fairly straightforward as well. So, what about creating and updating? However, no such directly translated verbs exist in the HTTP nomenclature.\n\nThere is some debate on this matter, but the generally accepted method for handling this is to use `PUT` to update a resource and `POST` to create it.\n\n### Note\n\nHere is the relevant information on this as per the W3C protocol for HTTP 1.1:\n\nThe fundamental difference between the `POST` and `PUT` requests is reflected in the different meaning of the Request-URI. The URI in a `POST` request identifies the resource that will handle the enclosed entity. This resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a `PUT` request identifies the entity enclosed with the request\u2014the user agent knows which URI is intended and the server *MUST NOT* attempt to apply the request to some other resource. If the server desires that the request to be applied to a different URI, it MUST send a 301 (Moved Permanently) response; the user agent MAY then make its own decision regarding whether or not to redirect the request.\n\nSo, if we follow this, we can assume that the following actions will translate to the following HTTP verbs:\n\n| Actions | HTTP verbs |\n| --- | --- |\n| Retrieving data | `GET` |\n| Creating data | `POST` |\n| Updating data | `PUT` |\n| Deleting data | `DELETE` |\n\nThus, a `PUT` request to, say, `/api/users/1234` will tell our web service that we're accepting data that will update or overwrite the user resource data for our user with the ID `1234`.\n\nA `POST` request to `/api/users/1234` will tell us that we'll be creating a new user resource based on the data within.\n\n### Note\n\nIt is very common to see the update and create methods switched, such that `POST` is used to update and `PUT` is used for creation. On the one hand, it's easy enough to do it either way without too much complication. On the other hand, the W3C protocol is fairly clear.\n\n## The PATCH method versus the PUT method\n\nSo, you might think after going through the last section that everything is wrapped up, right? Cut and dry? Well, as always, there are hitches and unexpected behaviors and conflicting rules.\n\nIn 2010, there was a proposed change to HTTP that would include a `PATCH` method. The difference between `PATCH` and `PUT` is somewhat subtle, but, the shortest possible explanation is that `PATCH` is intended to supply only partial changes to a resource, whereas `PUT` is expected to supply a complete representation of a resource.\n\nThe `PATCH` method also provides the potential to essentially *copy* a resource into another resource given with the modified data.\n\nFor now, we'll focus just on `PUT`, but we'll look at `PATCH` later on, particularly when we go into depth about the `OPTIONS` method on the server side of our API.\n\n# Bringing in CRUD\n\nThe acronym **CRUD** simply stands for **Create, Read (or Retrieve), Update, and Delete**. These verbs might seem noteworthy because they closely resemble the HTTP verbs that we wish to employ to manage data within our application.\n\nAs we discussed in the last section, most of these verbs have seemingly direct translations to HTTP methods. We say \"seemingly\" because there are some points in REST that keep it from being entirely analogous. We will cover this a bit more in later chapters.\n\n`CREATE` obviously takes the role of the `POST` method, `RETRIEVE` takes the place of `GET`, `UPDATE` takes the place of `PUT`/`PATCH`, and `DELETE` takes the place of, well, `DELETE`.\n\nIf we want to be fastidious about these translations, we must clarify that `PUT` and `POST` are not direct analogs to `UPDATE` and `CREATE`. In some ways this relates to the confusion behind which actions `PUT` and `POST` should provide. This all relies on the critical concept of idempotence, which means that any given operation should respond in the same way if it is called an indefinite number of times.\n\n### Tip\n\n**Idempotence** is the property of certain operations in mathematics and computer science that can be applied multiple times without changing the result beyond the initial application.\n\nFor now, we'll stick with our preceding translations and come back to the nitty-gritty of `PUT` versus `POST` later in the book.\n\n# Adding more endpoints\n\nGiven that we now have a way of elegantly handling our API versions, let's take a step back and revisit user creation. Earlier in this chapter, we created some new datasets and were ready to create the corresponding endpoints.\n\nKnowing what you know now about HTTP verbs, we should restrict access to user creation through the POST method. The example we built in the first chapter did not work exclusively with the POST request (or with POST requests at all). Good API design would dictate that we have a single URI for creating, retrieving, updating, and deleting any given resource.\n\nWith all of this in mind, let's lay out our endpoints and what they should allow a user to accomplish:\n\n| Endpoint | Method | Purpose |\n| --- | --- | --- |\n| `/api` | `OPTIONS` | To outline the available actions within the API |\n| `/api/users` | `GET` | To return users with optional filtering parameters |\n| `/api/users` | `POST` | To create a user |\n| `/api/user/123` | `PUT` | To update a user with the ID `123` |\n| `/api/user/123` | `DELETE` | To delete a user with the ID `123` |\n\nFor now, let's just do a quick modification of our initial API from [Chapter 1](ch01.html \"Chapter\u00a01.\u00a0Our First API in Go\"), *Our First API in Go*, so that we allow user creation solely through the `POST` method.\n\nRemember that we've used **Gorilla web toolkit** to do routing. This is helpful for handling patterns and regular expressions in requests, but it is also helpful now because it allows you to delineate based on the HTTP verb/method.\n\nIn our example, we created the `/api/user/create` and `/api/user/read` endpoints, but we now know that this is not the best practice in REST. So, our goal now is to change any resource requests for a user to `/api/users`, and to restrict creation to `POST` requests and retrievals to `GET` requests.\n\nIn our main function, we'll change our handlers to include a method as well as update our endpoint:\n\n```", "```go\n\nYou'll note that we also changed our function names to `UserCreate` and `UsersRetrieve`. As we expand our API, we'll need methods that are easy to understand and can relate directly to our resources.\n\nLet's take a look at how our application changes:\n\n```", "```go\n\nUp to this point everything is the same\u2014we require the same imports and connections to the database. However, the following code is the change:\n\n```", "```go\n\nWe're creating a struct for a group of users to represent our generic `GET` request to `/api/users`. This supplies a slice of the `User{}` struct:\n\n```", "```go\n\nNot much has changed with our actual user creation function, at least for now. Next, we'll look at the user data retrieval method.\n\n```", "```go\n\nOn the `UsersRetrieve()` function, we're now grabbing a set of users and scanning them into our `Users{}` struct. At this point, there isn't yet a header giving us further details nor is there any way to accept a starting point or a result count. We'll do that in the next chapter.\n\nAnd finally we have our basic routes and MySQL connection in the main function:\n\n```", "```go\n\nAs mentioned earlier, the biggest differences in `main` are that we've renamed our functions and are now relegating certain actions using the `HTTP` method. So, even though the endpoints are the same, we're able to direct the service depending on whether we use the `POST` or `GET` verb in our requests.\n\nWhen we visit `http://localhost:8080/api/users` (by default, a `GET` request) now in our browser, we'll get a list of our users (although we still just have one technically), as shown in the following screenshot:\n\n![Adding more endpoints](img/1304OS_02_03.jpg)\n\n# Handling API versions\n\nBefore we go nay further with our API, it's worth making a point about versioning our API.\n\nOne of the all-too-common problems that companies face when updating an API is changing the version without breaking the previous version. This isn't simply a matter of valid URLs, but it is also about the best practices in REST and graceful upgrades.\n\nTake our current API for example. We have an introductory `GET` verb to access data, such as `/api/users` endpoint. However, what this really should be is a clone of a versioned API. In other words, `/api/users` should be the same as `/api/{current-version}/users`. This way, if we move to another version, our older version will still be supported but not at the `{current-version}` address.\n\nSo, how do we tell users that we've upgraded? One possibility is to dictate these changes via HTTP status codes. This will allow consumers to continue accessing our API using older versions such as `/api/2.0/users`. Requests here will also let the consumer know that there is a new version.\n\nWe'll create a new version of our API in [Chapter 3](ch03.html \"Chapter\u00a03.\u00a0Routing and Bootstrapping\"), *Routing and Bootstrapping*.\n\n# Allowing pagination with the link header\n\nHere's another REST point that can sometimes be difficult to handle when it comes to statelessness: how do you pass the request for the next set of results?\n\nYou might think it would make sense to do this as a data element. For example:\n\n```", "```go\n\nAlthough this may work, it violates some principles of REST. First, unless we're explicitly returning hypertext, it is likely that we will not be supplying a direct URL. For this reason, we may not want to include this value in the body of our response.\n\nSecondly, we should be able to do even more generic requests and get information about the other actions and available endpoints.\n\nIn other words, if we hit our API simply at `http://localhost:8080/api`, our application should return some basic information to consumers about potential next steps and all the available endpoints.\n\nOne way to do this is with the link header. A **link** header is simply another header key/value that you set along with your response.\n\n### Tip\n\nJSON responses are often not considered RESTful because they are not in a hypermedia format. You'll see APIs that embed `self`, `rel`, and `next` link headers directly in the response in unreliable formats.\n\nJSON's primary shortcoming is its inability to support hyperlinks inherently. This is a problem that is solved by JSON-LD, which provides, among other things, linked documents and a stateless context.\n\n**Hypertext** **Application Language** (**HAL**) attempts to do the same thing. The former is endorsed by W3C but both have their supporters. Both formats extend JSON, and while we won't go too deep into either, you can modify responses to produce either format.\n\nHere's how we could do it in our `/api/users` `GET` request:\n\n```"]