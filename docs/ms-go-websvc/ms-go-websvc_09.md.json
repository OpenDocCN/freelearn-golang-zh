["```go\nbin/\n  api # Our API binary\n\npkg/\n\nsrc/\n  github.com/\n    nkozyra/\n    api/\n      /api/api.go\n        /interface/interface.go\n        /password/password.go\n        /pseudoauth/pseudoauth.go\n        /services/services.go\n        /specification/specification.go\n        /v1/v1.go\n        /v2/v2.go\n```", "```go\n[program:socialnetwork]\ncommand=/var/app/api\nautostart=true\nautorestart=true\nstderr_logfile=/var/log/api.log\nstdout_logfile=/var/log/api.log\n```", "```go\nsupervisorctl restart program:socialnetwork\n```", "```go\npackage main\n\nimport\n(\n  \"github.com/braintree/manners\"\n  \"net/http\"\n  \"os\"\n  \"os/signal\"\n)\n\nvar Server *GracefulServer\n\nfunc SignalListener() {\n  sC := make(chan os.signal, 1)\n  signal.Notify(sC, syscall.SIGUSR1, syscall.SIGUSR2)\n  s := <- sC\n  Server.Shutdown <- true\n}\n```", "```go\nfunc Init(allowedDomains []string) {\n  for _, domain := range allowedDomains {\n    PermittedDomains = append(PermittedDomains, domain)\n  }\n  Routes = mux.NewRouter()\n  Routes.HandleFunc(\"/interface\", APIInterface).Methods(\"GET\", \"POST\", \"PUT\", \"UPDATE\")\n  Routes.HandleFunc(\"/api/user\",UserLogin).Methods(\"POST\",\"GET\")\n  ...\n}\n```", "```go\nfunc main() {\n\n  go func() {\n    SignalListener()\n  }()\n  Server = manners.NewServer()\n  Server.ListenAndServe(HTTPport, Routes)\n}\n```", "```go\nFROM golang:1.3.1-onbuild\n\nRUN go install github.com/go-sql-driver/mysql\nRUN go install github.com/gorilla/mux\nRUN go install github.com/gorilla/sessions\nRUN go install github.com/nkozyra/api/password\nRUN go install github.com/nkozyra/api/pseudoauth\nRUN go install github.com/nkozyra/api/services\nRUN go install github.com/nkozyra/api/specification\nRUN go install github.com/nkozyra/api/api\n\nEXPOSE 80 443\n```", "```go\ndocker build -t api .\ndocker run --name api-running api -it --rm\n```", "```go\npackage main\nimport (\n    \"launchpad.net/goamz/aws\"\n    \"launchpad.net/goamz/ec2\"\n)\n```", "```go\n    AWSAuth, err := aws.EnvAuth()\n    if err != nil {\n        fmt.Println(err.Error())\n    }\n    instance := ec2.New(AWSAuth, aws.USEast)\n    instanceOptions := ec2.RunInstances({\n        ImageId:      \"ami-9eaa1cf6\",\n        InstanceType: \"t2.micro\",\n    })\n```", "```go\npackage main\n\nimport\n(\n  \"fmt\"\n    \"launchpad.net/goamz/aws\"\n    \"launchpad.net/goamz/s3\"\n)\n\nfunc main() {\n  Auth := aws.Auth { AccessKey: `-----------`, SecretKey: `-----------`, }\n  AWSConnection := s3.New(Auth, aws.USEast)\n\n  Bucket := AWSConnection.Bucket(\"social-images\")\n\n    bucketList, err := Bucket.List(\"\", \"\", \"\", 100)\n    fmt.Println(AWSConnection,Bucket,bucketList,err)  \n    if err != nil {\n        fmt.Println(err.Error())\n    }\n    for _, item := range bucketList.Contents {\n        fmt.Println(item.Key)\n    }\n}\n```", "```go\n func UsersUpdate(w http.ResponseWriter, r *http.Request) {\n  Response := UpdateResponse{}\n  params := mux.Vars(r)\n  uid := params[\"id\"]\n  email := r.FormValue(\"email\")\n  img, _, err := r.FormFile(\"user_image\")\n  if err != nil {\n    fmt.Println(\"Image error:\")\n    fmt.Println(err.Error())\n```", "```go\n  }\n  imageData, ierr := ioutil.ReadAll(img)\n  if err != nil {\n    fmt.Println(\"Error reading image:\")\n    fmt.Println(err.Error())\n```", "```go\n  } else {\n    mimeType, _, mimerr := mime.ParseMediaType(string(imageData))\n    if mimerr != nil {\n      fmt.Println(\"Error detecting mime:\")\n      fmt.Println(mimerr.Error())\n    } else {\n      Auth := aws.Auth { AccessKey: `-----------`, SecretKey: `-----------`, }\n      AWSConnection := s3.New(Auth, aws.USEast)\n      Bucket := AWSConnection.Bucket(\"social-images\")\n      berr := Bucket.Put(\"FILENAME-HERE\", imageData, \"\", \"READ\")\n      if berr != nil {\n        fmt.Println(\"Error saving to bucket:\")\n        fmt.Println(berr.Error())\n      }\n    }\n  }\n```", "```go\n    f, _, err := r.FormFile(\"image1\")\n    if err != nil {\n      fmt.Println(err.Error())\n    }\n    fileData,_ := ioutil.ReadAll(f)\n```", "```go\npackage main\n\nimport\n(\n  \"encoding/json\"\n  \"fmt\"\n  \"net\"\n)\n\nconst\n(\n  port = \":9000\"\n)\n\ntype Message struct {\n  Title string `json:\"title\"`\n  Body string `json:\"body\"`\n  To string `json:\"recipient\"`\n  From string `json:\"sender\"`\n}\n\nfunc (m Message) Send() {\n\n}\nfunc main() {\n\n  emailQueue,_ := net.Listen(\"tcp\",port)\n  for {\n    conn, err := emailQueue.Accept()\n    if err != nil {\n\n    }\n    var message []byte\n    var NewEmail Message\n    fmt.Fscan(conn,message)\n    json.Unmarshal(message,NewEmail)\n    NewEmail.Send()\n  }\n\n}\n```", "```go\nfunc (m Message) Send() {\n  mailServer := \"mail.example.com\"\n  mailServerQualified := mailServer + \":25\"\n  mailAuth := smtp.PlainAuth(\n        \"\",\n        \"[email]\",\n        \"[password]\",\n        mailServer,\n      )\n  recip := mail.Address(\"Nathan Kozyra\",\"nkozyra@gmail.com\")\n  body := m.Body\n\n  mailHeaders := make(map[string] string)\n  mailHeaders[\"From\"] = m.From\n  mailHeaders[\"To\"] = recip.toString()\n  mailHeaders[\"Subject\"] = m.Title\n  mailHeaders[\"Content-Type\"] = \"text/plain; charset=\\\"utf-8\\\"\"\n  mailHeaders[\"Content-Transfer-Encoding\"] = \"base64\"\n  fullEmailHeader := \"\"\n  for k, v := range mailHeaders {\n    fullEmailHeader += base64.StdEncoding.EncodeToString([]byte(body))\n  }\n\n  err := smtp.SendMail( mailServerQualified, mailAuth, m.From, m.To, []byte(fullEmailHeader))\n  if err != nil {\n    fmt.Println(\"could not send email\")\n    fmt.Println(err.Error())\n  }\n}\n```", "```go\ntype EmailMessage struct {\n  Recipient string `json:\"to\"`\n  Sender string `json:\"from\"`\n  Title string `json:\"title\"`\n  Body string `json:\"body\"`\n  SendTime time.Time `json:\"sendtime\"`\n  ContentType string `json:\"content-type\"`\n}\n```", "```go\nfunc Listen() {\n\n  qConn, err := amqp.Dial(\"amqp://user:pass@domain:port/\")\n  if err != nil {\n    log.Fatal(err)\n  }\n```", "```go\n  qC,err := qConn.Channel()\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  queue, err := qC.QueueDeclare(\"messages\", false, false, false, false, nil)\n  if err != nil {\n    log.Fatal(err)\n  }\n```", "```go\n  messages, err := qC.Consume( queue.Name, \"\", true, false, false, false, nil)\n  waitChan := make(chan int)\n  go func() {\n    for m := range messages {\n      var tmpM Message\n      json.Unmarshal(d.Body,tmpM)\n      log.Println(tmpM.Title,\"message received\")\n      tmpM.Send()\n    }\n```", "```go\n  }()\n\n  <- waitChan\n\n}\n```", "```go\nfunc main() {\n\n  Listen()\n```", "```go\npackage emailQueue\n\nimport\n(\n  \"fmt\"\n  \"log\"\n  \"github.com/streadway/amqp\"\n)\n\nconst\n(\n  QueueCredentials = \"amqp://user:pass@host:port/\"\n  QueueName = \"email\"\n)\n\nfunc Listen() {\n\n}\n\nfunc Send(Recipient string, EmailSubject string, EmailBody string) {\n\n}\n```", "```go\nfunc UserCreate(w http.ResponseWriter, r *http.Request) {\n\n  ...\n\n  q, err := Database.Exec(\"INSERT INTO users set user_nickname=?, user_first=?, user_last=?, user_email=?, user_password=?, user_salt=?\",NewUser.Name,NewUser.First, NewUser.Last,NewUser.Email,hash,salt)\n  if err != nil {\n    errorMessage, errorCode := dbErrorParse(err.Error())\n    fmt.Println(errorMessage)\n    error, httpCode, msg := ErrorMessages(errorCode)\n    Response.Error = msg\n        Response.ErrorCode = error\n    http.Error(w, \"Conflict\", httpCode)\n  } else {\n\n    emailQueue.Send(NewUser.Email,\"Welcome to the Social Network\",\"Thanks for joining the Social Network!  Your personal data will help us become billionaires!\")\n\n  }\n```", "```go\nemailQueue.Listen()\n```"]