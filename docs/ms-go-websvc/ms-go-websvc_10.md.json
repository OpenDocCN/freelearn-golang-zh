["```go\nfunc UsersRetrieve(w http.ResponseWriter, r *http.Request) {\n  CheckRateLimit()\n```", "```go\nfunc UsersUpdate( w http.ResponseWriter, r *http.Request) {\n  CheckRateLimit()\n  CheckAuthentication()\n}\n```", "```go\nfunc UserLogin(w http.ResponseWriter, r *http.Request) {\n\n  CheckLogin(w,r)\n```", "```go\nfunc UserCreate(w http.ResponseWriter, r *http.Request) {\n\n w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n for _, domain := range PermittedDomains {\n fmt.Println(\"allowing\", domain)\n w.Header().Set(\"Access-Control-Allow-Origin\", domain)\n  }\n```", "```go\nfirstFunction().then(nextFunction()).then(thirdFunction())\n```", "```go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"net/http\"\n)\n\nfunc PrimaryHandler(w http.ResponseWriter, r *http.Request) {\n  fmt.Fprintln(w, \"I am the final response\")\n}\n\nfunc MiddlewareHandler(h http.HandlerFunc) http.HandlerFunc {\n  fmt.Println(\"I am middleware\")\n  return func(w http.ResponseWriter, r *http.Request) {\n    h.ServeHTTP(w, r)\n  }\n}\n\nfunc middleware(ph http.HandlerFunc, middleHandlers ..func(http.HandlerFunc) (http.HandlerFunc) ) http.HandlerFunc {\n  var next http.HandlerFunc = ph\n  for _, mw := range middleHandlers {\n    next = mw(ph)\n  }\n  return next\n}\n\nfunc main() {\n  http.HandleFunc(\"/middleware\", middleware(PrimaryHandler,MiddlewareHandler))\n  http.ListenAndServe(\":9000\",nil)\n}\n```", "```go\npackage diskcache\n\nimport\n(\n)\n\ntype CacheItem struct {\n\n}\n```", "```go\nfunc SetCache() {\n\n}\n```", "```go\nfunc GetCache() (bool, CacheItem) {\n\n}\n```", "```go\nfunc Evaluate(context string, value string, in ...[]string) (bool, CacheItem) {\n\n}\n```", "```go\n  start := 0\n  limit := 10\n\n  next := start + limit\n```", "```go\n  start := 0\n  if len(r.URL.Query()[\"start\"]) > 0 {\n    start = r.URL.Query()[\"start\"][0]\n  }\n  limit := 10\n  if len(r.URL.Query()[\"limit\"]) > 0 {\n    start = r.URL.Query()[\"limit\"][0]\n  }\n  if limit > 50 {\n    limit = 50\n  }\n```", "```go\npackage diskcache\n\nimport\n(\n  \"errors\"\n  \"io/ioutil\"\n  \"log\"\n  \"os\"\n  \"strings\"\n  \"sync\"\n  \"time\"\n)\n\nconst(\n CACHEDIR = \"/var/www/cache/\"\n)\n```", "```go\nvar MaxAge int64  = 60\nvar(\n  ErrMissingFile = errors.New(\"File Does Not Exist\")\n  ErrMissingStats = errors.New(\"Unable To Get File Stats\")\n  ErrCannotWrite = errors.New(\"Cannot Write Cache File\")\n  ErrCannotRead = errors.New(\"Cannot Read Cache File\")\n)\n\ntype CacheItem struct {\n  Name string\n  Location string\n  Cached bool\n  Contents string\n  Age int64\n}\n```", "```go\nfunc (ci *CacheItem) IsValid(fn string) bool {\n  lo := CACHEDIR + fn\n  ci.Location = lo\n\n  f, err := os.Open(lo)\n  defer f.Close()\n  if err != nil {\n    log.Println(ErrMissingFile)\n    return false\n  }\n\n  st, err := f.Stat()\n  if err != nil {\n    log.Println(ErrMissingStats)\n    return false\n  }\n\n  ci.Age := int64(time.Since(st.ModTime()).Seconds())\n  return (ci.Age <= MaxAge)\n}\n```", "```go\nfunc (ci *CacheItem) SetCache() {\n  f, err := os.Create(ci.Location)\n  defer f.Close()\n  if err != nil {\n    log.Println(err.Error())\n  } else {\n    FileLock.Lock()\n    defer FileLock.Unlock()\n    _, err := f.WriteString(ci.Contents)\n    if err != nil {\n      log.Println(ErrCannotWrite)\n    } else {\n      ci.Age = 0\n    }\n  }\n  log.Println(f)\n}\n```", "```go\nfunc (ci *CacheItem) GetCache() error {\n  var e error\n  d, err := ioutil.ReadFile(ci.Location)\n  if err == nil {\n    ci.Contents = string(d)\n  }\n  return err\n}\n\nfunc Evaluate(context string, value string, expireAge int64, qu ...string) (error, CacheItem) {\n\n  var err error\n  var ci CacheItem\n  ci.Contents = value\n  ci.Name = context + strings.Join(qu,\"-\")\n  valid := ci.IsValid(ci.Name)\n```", "```go\n  if !valid {\n    ci.SetCache()\n    ci.Cached = false\n  } else {\n    err = ci.GetCache()\n    ci.Cached = true\n  }\n\n  return err, ci\n}\n```", "```go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"github.com/nkozyra/api/diskcache\"\n)\n\nfunc main() {\n  err,c := diskcache.Evaluate(\"test\",\"Here is a value that will only live for 1 minute\",60)\n  fmt.Println(c)\n  if err != nil {\n    fmt.Println(err)\n  }\n  fmt.Println(\"Returned value is\",c.Age,\"seconds old\")\n  fmt.Println(c.Contents)\n}\n```", "```go\npackage memorycache\n```", "```go\nimport\n(\n  \"errors\"\n  \"log\"\n  mgo \"gopkg.in/mgo.v2\"\n  bson \"gopkg.in/mgo.v2/bson\"\n  _ \"strings\"\n  \"sync\"\n  \"time\"\n)\n```", "```go\nconst(\n  MONGOLOC = \"localhost\"\n)\n\nvar MaxAge int64  = 60\nvar Session mgo.Session\nvar Collection *mgo.Collection\n\nvar(\n  ErrMissingFile = errors.New(\"File Does Not Exist\")\n  ErrMissingStats = errors.New(\"Unable To Get File Stats\")\n  ErrCannotWrite = errors.New(\"Cannot Write Cache File\")\n  ErrCannotRead = errors.New(\"Cannot Read Cache File\")\n\n  FileLock sync.RWMutex\n)\n\ntype CacheItem struct {\n  Name string\n  Location string\n  Contents string\n  Age int64\n  Parameters map[string] string\n}\n```", "```go\ntype CacheRecord struct {\n  Id bson.ObjectId `json:\"id,omitempty\" bson:\"_id,omitempty\"`\n  Page string\n  Search string\n  Contents string\n  Modified int64\n}\n```", "```go\nfunc (ci *CacheItem) IsValid(fn string) bool {\n  now := time.Now().Unix()\n  old := now - MaxAge\n\n  var cr CacheRecord\n  err := Collection.Find(bson.M{\"page\":\"1\", \"modified\": bson.M{\"$gt\":old} }).One(&cr)\n  if err != nil {\n    return false\n  } else {\n    ci.Contents = cr.Contents\n    return true\n  }\n\n  return false\n}\n```", "```go\nfunc (ci *CacheItem) SetCache() {\n  err := Collection.Insert(&CacheRecord{Id: bson.NewObjectId(), Page:ci.Parameters[\"page\"],Search:ci.Parameters[\"search\"],Contents:ci.Contents,Modified:time.Now().Unix()})\n  if err != nil {\n    log.Println(err.Error())\n  }\n}\n```", "```go\nfunc init() {\n  Session, err := mgo.Dial(MONGOLOC)\n  if err != nil {\n    log.Println(err.Error())\n  }\n  Session.SetMode(mgo.Monotonic, true)\n  Collection = Session.DB(\"local\").C(\"cache\")\n  defer Session.Ping()\n}\n\nfunc Evaluate(context string, value string, expireAge int64, param map[string]string) (error, CacheItem) {\n\n  MaxAge = expireAge\n  defer Session.Close()\n\n  var ci CacheItem\n  ci.Parameters = param\n  ci.Contents = value\n  valid := ci.IsValid(\"bah:\")\n  if !valid {\n    ci.SetCache()\n  }\n\n  var err error\n\n  return err, ci\n}\n```", "```go\npackage main\n\nimport\n(\n  \"fmt\"\n  \"github.com/nkozyra/api/memorycache\"\n)\n\nfunc main() {\n  parameters := make( map[string]string )\n  parameters[\"page\"] = \"1\"\n  parameters[\"search\"] = \"nathan\"\n  err,c := memorycache.Evaluate(\"test\",\"Here is a value that will only live for 1 minute\",60,parameters)\n  fmt.Println(c)\n  if err != nil {\n    fmt.Println(err)\n  }\n  fmt.Println(\"Returned value is\",c.Age,\"seconds old\")\n  fmt.Println(c.Contents)\n}\n```", "```go\n  Routes.HandleFunc(\"/api/users\", middleware(DiskCache, UsersRetrieve, DiskCacheSave) ).Methods(\"GET\")\n```", "```go\nfunc DiskCache(h http.HandlerFunc) http.HandlerFunc {\n  start := 0\n  q := r.URL.Query()\n  if len(r.URL.Query()[\"start\"]) > 0 {\n    start = r.URL.Query()[\"start\"][0]\n  }\n  limit := 10\n  if len(r.URL.Query()[\"limit\"]) > 0 {\n    limit = q[\"limit\"][0]\n  }\n  valid, check := diskcache.Evaluate(\"GetUsers\", \"\", MaxAge, start, limit)\n  fmt.Println(\"Cache valid\",valid)\n  if check.Cached  {\n    return func(w http.ResponseWriter, r *http.Request) {\n      fmt.Fprintln(w, check.Contents)\n    }\n  } else {\n    return func(w http.ResponseWriter, r *http.Request) {\n      h.ServeHTTP(w, r)\n    }\n  }\n}\n```", "```go\n  r.CacheContents = string(output)\n  fmt.Fprintln(w, string(output))\n}\n```", "```go\nfunc DiskCacheSave(h http.HandlerFunc) http.HandlerFunc {\n  start := 0\n  if len(r.URL.Query()[\"start\"]) > 0 {\n    start = r.URL.Query()[\"start\"][0]\n  }\n  limit := 10\n  if len(r.URL.Query()[\"limit\"]) > 0 {\n    start = r.URL.Query()[\"limit\"][0]\n  }\n  valid, check := diskcache.Evaluate(\"GetUsers\", r.CacheContents, MaxAge, start, limit)\n  fmt.Println(\"Cache valid\",valid)\n  return func(w http.ResponseWriter, r *http.Request) {\n    h.ServeHTTP(w, r)\n  }\n\n}\n```", "```go\npackage ratelimit\n\nimport\n(\n  \"errors\"\n  \"log\"\n  mgo \"gopkg.in/mgo.v2\"\n  bson \"gopkg.in/mgo.v2/bson\"\n  _ \"strings\"\n  \"time\"\n)\n\nconst(\n  MONGOLOC = \"localhost\"\n)\n```", "```go\ntype Requester struct {\n  Id bson.ObjectId `json:\"id,omitempty\" bson:\"_id,omitempty\"`\n  IP string\n  APIKey string\n  Requests int\n  Timestamp int64\n  Valid bool\n}\n\ntype DateBounds struct {\n  Start int64\n  End int64\n}\n```", "```go\nvar (\n  MaxDailyRequests = 15\n  TooManyRequests = errors.New(\"You have exceeded your daily limit of requests.\")\n  Bounds DateBounds\n  Session mgo.Session\n  Collection *mgo.Collection\n)\n\nfunc createDateBounds() {\n  today := time.Now()\n  Bounds.Start = time.Date(today.Year(), today.Month(), today.Day(), 0, 0, 0, 0, time.UTC).Unix()\n  Bounds.End = Bounds.Start + 86400\n}\n```", "```go\nfunc (r *Requester) CheckDaily() {\n\n  count, err := Collection.Find(bson.M{\"ip\": r.IP, \"timestamp\": bson.M{\"$gt\":Bounds.Start, \"$lt\":Bounds.End } }).Count()\n  if err != nil {\n    log.Println(err.Error())\n  }\n  r.Valid = (count <= MaxDailyRequrests)\n}\n\nfunc (r Requester) RegisterRequest() {\n  err := Collection.Insert(&Requester{Id: bson.NewObjectId(), IP: r.IP, Timestamp: time.Now().Unix()})\n  if err != nil {\n    log.Println(err.Error())\n  }\n\n}\n```", "```go\nfunc init() {\n  Session, err := mgo.Dial(MONGOLOC)\n  if err != nil {\n    log.Println(err.Error())\n  }\n  Session.SetMode(mgo.Monotonic, true)\n  Collection = Session.DB(\"local\").C(\"requests\")\n  defer Session.Ping()\n  createDateBounds()\n}\n```", "```go\nfunc CheckRequest(ip string) (bool) {\n  req := Requester{ IP: ip }\n  req.CheckDaily()\n  req.RegisterRequest()\n\n  return req.Valid\n}\n```", "```go\n  Routes.HandleFunc(\"/api/users/{id:[0-9]+}\", middleware(RateLimit,UsersUpdate)).Methods(\"PUT\")\n```", "```go\nfunc RateLimit(h http.HandlerFunc) http.HandlerFunc {\n  return func(w http.ResponseWriter, r *http.Request) {\n    if (ratelimit.CheckRequest(r.RemoteAddr) == false {\n      fmt.Fprintln(w,\"Rate limit exceeded\")\n    } else {\n      h.ServeHTTP(w,r)\n    }\n  }\n}\n```", "```go\n  wg.Add(1)\n  go func() {\n    //http.ListenAndServeTLS(SSLport, \"cert.pem\", \"key.pem\", Routes)\n    spdy.ListenAndServeTLS(SSLport, \"cert.pem\", \"key.pem\", Routes)\n    wg.Done()\n  }()\n```"]