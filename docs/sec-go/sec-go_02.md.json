["```go\n// Line comment, everything after slashes ignored\n/* General comment, can be in middle of line or span multiple lines */\n```", "```go\nvar customFlag bool = false  \n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   // Decimal for 15\n   number0 := 15\n\n   // Octal for 15\n   number1 := 017 \n\n   // Hexadecimal for 15\n   number2 := 0x0F\n\n   fmt.Println(number0, number1, number2)\n} \n```", "```go\u00a0(backticks)\u00a0symbol to encapsulate strings that span multiple lines. Here is a short example of string usage:\n\n```", "```go\n\n# Array\n\nArrays are made up of sequenced elements of a specific type. An array can be created for any data type. The length of an array cannot be changed and must be specified at the time of declaration. Arrays are seldom used directly, but are used mostly through the slice type covered in the next section. Arrays are always one-dimensional, but you can create an array of arrays to create multidimensional objects.\n\nTo create an array of 128 bytes, this syntax can be used:\n\n```", "```go\n\nIndividual elements of an array can be accessed by its 0-based numeric index. For example, to get the fifth element from the byte array, the syntax is as follows:\n\n```", "```go\n\n# Slice\n\nSlices use arrays as the underlying data type. The main advantage is that slices can be resized, unlike arrays. Think of slices as a viewing window in to an underlying array. The **capacity** refers to the size of the underlying array, and the maximum possible length of a slice. The **length** of a slice refers to its current length which can be resized.\n\nSlices are created using the `make()` function. The `make()` function will create a slice of a certain type with a certain length and capacity. The `make()` function can be used two ways when creating a slice. With only two parameters, the length and capacity are the same. With three parameters, you can specify a maximum capacity larger than the length. Here are two of the `make()` function declarations:\n\n```", "```go\n\nA nil slice can be created with a capacity and length of 0\\. There is no underlying array associated with a nil slice. Here is a short example program demonstrating how to create and inspect a slice:\n\n```", "```go\n\nYou can also append to a slice using the built-in `append()` function.\n\nAppend can add one or more elements at a time. The underlying array will be resized if necessary. This means that the maximum capacity of a slice can be increased. When a slice increases its underlying capacity, creating a larger underlying array, it will create the array with some extra space. This means that if you surpass a slice's capacity by one, it might increase the array size by four. This is done so that the underlying array has room to grow to reduce the number of times the underlying array has to be resized, which may require moving memory around to accommodate the larger array. It could be expensive to resize an array every time just to add a single element. The slice mechanics will automatically determine the best size for resizing.\n\nThis code sample provides various examples of working with slices:\n\n```", "```go\n\n# Struct\n\nIn Go, a struct or data structure is a collection of variables. The variables can be of different types. We will look at an example of creating a custom struct type.\n\nGo uses case-based scoping to declare a variable either `public` or `private`. Variables and methods that are capitalized are exported and accessible from other packages. Lowercase values are private and only accessible within the same package.\n\nThe following example creates a simple struct named `Person` and one named `Hacker`. The `Hacker` type has a `Person` type embedded within it. An instance of each type is then created and the information about them is printed to standard output:\n\n```", "```go\n\nYou can create *private* variables by starting their name with a lowercase letter. I use quotation marks because private variables work slightly different than in other languages. The privacy works at the package level and not at the *class* or type level.\n\n# Pointer\n\nGo provides a pointer type that stores the memory location where data of a specific type is stored. Pointers can be used to pass a struct to a function by reference without creating a copy. This also allows a function to modify an object in-place.\n\nThere is no pointer arithmetic allowed in Go. Pointers are considered *safe* because Go does not even define the addition operator on the pointer type. They can only be used to reference an existing object.\n\nThis example demonstrates basic pointer usage. It first creates an integer, and then creates a pointer to the integer. It then prints out the data type of the pointer, the address stored in the pointer, and then the value of data being pointed at:\n\n```", "```go\n\n# Function\n\nFunctions are defined with the `func` keyword. Functions can have multiple parameters. All parameters are positional and there are no named parameters. Go supports variadic parameters allowing for an unknown number of parameters. Functions are first-class citizens in Go, and can be used anonymously and returned as a variable. Go also supports multiple return values from a function. The underscore can be used to ignore a return variable.\n\nAll of these examples are demonstrated in the following code source:\n\n```", "```go\n\n# Interface\n\nInterfaces are a special type that define a collection of function signatures. You can think of an interface as saying, \"a type must implement function X and function Y to satisfy this interface.\" If you create any type and implement the functions needed to satisfy the interface, your type can be used anywhere that the interface is expected. You don't have to specify that you are trying to satisfy an interface, the compiler will determine if it satisfies the requirements.\n\nYou can add as many other functions as you want to your custom type. The interface defines the functions that are required, but it does not mean that your type is limited to implementing only those functions.\n\nThe most commonly used interface is the `error` interface. The `error` interface only requires a single function to be implemented, a function named `Error()` that returns a string with the error message. Here is the interface definition:\n\n```", "```go\n\nThis makes it very easy for you to implement your own error interfaces. This example creates a `customError` type and then implements the `Error()` function needed to satisfy the interface. Then, a sample function is created, which returns the custom error:\n\n```", "```go\n\nOther frequently used interfaces are the `Reader` and `Writer` interfaces. Each one only requires one function to be implemented in order to satisfy the interface requirements. The big benefit here is that you can create your own custom types that reads and writes data in some arbitrary way. The implementation details are not important to the interface. The interface won't care whether you are reading and writing to a hard disk, a network connection, storage in memory, or `/dev/null`. As long as you implement the function signatures that are required, you can use your type anywhere the interface is used. Here is the definition of the `Reader` and `Writer` interfaces:\n\n```", "```go\n\n# Map\n\nA map is a hash table or dictionary that stores key and value pairs. The key and value can be any data types, including maps themselves, creating multiple dimensions.\n\nThe order is not guaranteed. You can iterate over a map multiple times and it might be different. Additionally, maps are not concurrent safe. If you must share a map between threads, use a mutex.\n\nHere are some example map usages:\n\n```", "```go\n\n# Channel\n\nChannels are used to communicate between threads. Channels are **first-in, first-out** (**FIFO**) queues. You can push objects on to the queue and pull from the front asynchronously. Each channel can only support one data type. Channels are blocking by default, but can be made nonblocking with a `select` statement. Like slices and maps, channels must be initialized before use with the `make()` function.\n\nThe saying in Go is\u00a0*Do not communicate by sharing memory; instead, share memory by communicating*. Read more about this philosophy at [https://blog.golang.org/share-memory-by-communicating](https://blog.golang.org/share-memory-by-communicating).\n\nHere is an example program that demonstrates basic channel usage:\n\n```", "```go\n\n# Control structures\n\nControl structures are used to control the flow of program execution. The most common forms are the\u00a0`if` statements, `for` loops, and `switch` statements. Go also supports the `goto` statement, but should be reserved for cases of extreme performance and not used regularly. Let's look briefly at each of these to understand the syntax.\n\n# if\n\nThe `if` statement comes with the `if`, `else if`, and `else` clauses, just like most other languages. The one interesting feature that Go has is the ability to put a statement before the condition, creating temporary variables that are discarded after the `if` statement has completed.\n\nThis example demonstrates the various ways to use an `if` statement:\n\n```", "```go\n\n# for\n\nThe `for` loop has three components, and can be used just like a `for` loop in C or Java. Go has no `while` loop because the `for` loop serves the same purpose when used with a single condition. Refer to the following example for more clarity:\n\n```", "```go\n\n# range\n\nThe `range` keyword is used to iterate over a slice, map, or other data structure. The `range`\u00a0keyword is used in combination with the `for` loop, to operate on an iterable data structure. The `range` keyword returns the key and value variables. Here are some basic examples of using the `range` keyword:\n\n```", "```go\n\n# switch, case, fallthrough, and default\n\nThe `switch` statement allows you to branch execution based on the state of a variable. It is similar to the `switch` statement in C and other languages.\n\nThere is no `fallthrough` by default. This means once the end of a case is reached, the code exits the `switch` statement completely unless an explicit `fallthrough` command is provided. A `default` case can be provided if none of the cases are matched.\n\nYou can put a statement in front of the variable to be switched, such as the `if` statement. This creates a variable whose scope is limited to the `switch` statement.\n\nThis example demonstrates two `switch` statements. The first one uses hardcoded values and includes a `default` case. The second `switch` statement uses an alternate syntax that allows for a statement in the first line:\n\n```", "```go\n\n# goto\n\nGo does have a `goto` statement, but it is very rarely used. Create a label with a name and a colon, then *go to* it using the `goto` keyword. Here is a basic example:\n\n```", "```go\n\n# Defer\n\nBy deferring a function, it will run whenever the current function is exited. This is a convenient way to ensure that a function will get executed before exiting, which is useful for cleaning up or closing files. It is convenient because a deferred function will get executed no matter where the surrounding function exits if there are multiple return locations.\n\nCommon use cases are deferring calls to close a file or database connection. Right after opening a file, you can defer a call to close. This will ensure that a file is closed whenever the function is exited, even if there are multiple return statements and you can't be sure about when and where the current function will exit.\n\nThis example demonstrates a simple use case for the `defer` keyword. It creates a file and then defers a call to `file.Close()`:\n\n```", "```go\n\nBe sure to properly check and handle errors. The `defer` call will panic if using a nil pointer.\n\nIt is also important to understand that deferred functions are run when the surrounding function is exited. If you put a `defer` call inside a `for` loop, it will not get called at the end of each `for` loop iteration.\n\n# Packages\n\nPackages are just directories. Every directory is its own package. Creating subdirectories creates a new package. Having no subpackages leads to a flat hierarchy. Subdirectories are used just for organizing code.\n\nPackages should be stored in the `src` folder of your `$GOPATH` variable.\n\nA package name should match the folder name or be named `main`. A `main` package means that it is not intended to be imported into another application, but meant to compile and run as a program. Packages are imported using the `import` keyword.\n\nYou can import packages individually:\n\n```", "```go\n\nAlternatively, you can import multiple packages at once by wrapping them with parenthesis:\n\n```", "```go\n\n# Classes\n\nGo technically does not have classes, but there are only a few subtle distinctions that keep it from being called an object-oriented language. Conceptually, I do consider it an object-oriented programming language, though it only supports the most basic features of an object-oriented language. It does not come with all of the features many people have come to associate with object-oriented programming, such as inheritance and polymorphism, which are replaced with other features such as embedded types and interfaces. Perhaps you could call it a *microclass* system, because it is a minimalistic implementation with none of the extra features or baggage, depending on your perspective.\n\nThroughout this book, the terms *object* and *class* may be used to illustrate a point using familiar terms, but be aware that these are not formal terms in Go. A type definition in combination with the functions that operate on that type are like the class, and the object is an instance of a type.\n\n# Inheritance\n\nThere is no inheritance in Go, but you can embed types. Here is an example of a `Person`\u00a0and\u00a0`Doctor` types, which embeds the `Person` type. Instead of inheriting the behavior of `Person` directly, it stores the `Person` object as a variable, which brings with it all of its expected `Person` methods and attributes:\n\n```", "```go\n\n# Polymorphism\n\nThere is no polymorphism in Go, but you can use interfaces to create common abstraction that can be used by multiple types. Interfaces define one or more method declarations that must be satisfied to be compatible with the interface. Interfaces were covered earlier in this chapter.\n\n# Constructors\n\nThere are no constructors in Go, but there are `New()` functions that act like factories initializing an object. You simply have to create a function named `New()` that returns your data type. Here is an example:\n\n```", "```go\n\nThere are no deconstructors in Go, since everything is garbage collected and you do not manually destroy objects. Defer is the closest you can get by deferring a function call to perform some cleanup when the current function ends.\n\n# Methods\n\nMethods are functions that belong to a specific type, and are called using the dot notation, for example:\n\n```", "```go\n\nThe dot notation is widely used in C++ and other object-oriented languages. The dot notation and the class system stemmed from a common pattern that was used in C. The common pattern is to define a set of functions that all operate on a specific data type. All of the related functions have the same first parameter, which is the data to be operated on. Since this is such a common pattern, Go built it into the language. Instead of passing the object to be manipulated as the first argument, there is a special place to designate the receiver in a Go function definition. The receiver is specified between a set of parenthesis before the function name. The next example demonstrates how to use function receivers.\n\nInstead of writing a large set of functions that all took a pointer as their first parameter, you can write functions that have a special *receiver*. The receiver can either be a type or a pointer to a type:\n\n```", "```go\n\nIn Go, you do not encapsulate all of the variables and methods inside a monolithic pair of braces. You define a type, and then define methods that operate on that type. This allows you to define all of your structs and data types in one place, and define the methods elsewhere in your package. You also have the option of defining a type and the methods right next to each other. It's pretty simple and straightforward, and it creates a slightly clearer distinction between the state (data) and the logic.\n\n# Operator overloading\n\nThere is no operator overloading in Go, so you can't add to structs together with the `+` sign, but you can easily define an `Add()` function on the type and then call something like `dataSet1.Add(dataSet2)`. By omitting operator overloading from the language, we can confidently use the operators without worrying about unexpected behavior due to operator behavior being overloaded somewhere else in code without realizing it.\n\n# Goroutines\n\nGoroutines are lightweight threads built into the language. You simply have to put the word `go` in front of a function call to have the function execute in a thread. Goroutines may also be referred to as threads in this book.\n\nGo does provide mutexes, but they are avoidable in most cases and will not be covered in this book. You can read more about mutexes in the `sync` package documentation at [https://golang.org/pkg/sync/](https://golang.org/pkg/sync/). Channels should be used instead for sharing data and communicating between threads. Channels were covered earlier in this chapter.\n\nNote that the `log` package is safe to use concurrently, but the `fmt` package is not. Here is a short example of using goroutines:\n\n```", "```go\n\n# Getting help and documentation\n\nGo has both online and offline help documentation. The offline documentation is built-in for Go and is the same documentation that is hosted online. These next sections will walk you through accessing both forms of documentation.\n\n# Online Go documentation\n\nThe online documentation is available at [https://golang.org/](https://golang.org/), and has all the formal documentation, specifications, and help files. Language documentation specifically is at [https://golang.org/doc/](https://golang.org/doc/), and information about the standard library is at [https://golang.org/pkg/](https://golang.org/pkg/).\n\n# Offline Go documentation\n\nGo also comes with offline documentation with the `godoc` command-line tool. You can use it on the command line, or have it run a web server where it serves the same website that\u00a0[https://golang.org/](https://golang.org/) hosts. It is quite handy to have the full website documentation available locally. Here are a few examples that get documentation for the `fmt` package. Replace `fmt` with whatever package you are interested in:\n\n```"]