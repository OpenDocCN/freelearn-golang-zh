["```go\npackage main \n\nimport ( \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   newFile, err := os.Create(\"test.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   log.Println(newFile) \n   newFile.Close() \n} \n```", "```go\npackage main \n\nimport ( \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Truncate a file to 100 bytes. If file \n   // is less than 100 bytes the original contents will remain \n   // at the beginning, and the rest of the space is \n   // filled will null bytes. If it is over 100 bytes, \n   // Everything past 100 bytes will be lost. Either way \n   // we will end up with exactly 100 bytes. \n   // Pass in 0 to truncate to a completely empty file \n\n   err := os.Truncate(\"test.txt\", 100) \n   if err != nil { \n      log.Fatal(err) \n   } \n} \n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Stat returns file info. It will return \n   // an error if there is no file. \n   fileInfo, err := os.Stat(\"test.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   fmt.Println(\"File name:\", fileInfo.Name()) \n   fmt.Println(\"Size in bytes:\", fileInfo.Size()) \n   fmt.Println(\"Permissions:\", fileInfo.Mode()) \n   fmt.Println(\"Last modified:\", fileInfo.ModTime()) \n   fmt.Println(\"Is Directory: \", fileInfo.IsDir()) \n   fmt.Printf(\"System interface type: %T\\n\", fileInfo.Sys()) \n   fmt.Printf(\"System info: %+v\\n\\n\", fileInfo.Sys()) \n} \n```", "```go\npackage main \n\nimport ( \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   originalPath := \"test.txt\" \n   newPath := \"test2.txt\" \n   err := os.Rename(originalPath, newPath) \n   if err != nil { \n      log.Fatal(err) \n   } \n} \n```", "```go\npackage main \n\nimport ( \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   err := os.Remove(\"test.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n} \n```", "```go\npackage main \n\nimport ( \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Simple read only open. We will cover actually reading \n   // and writing to files in examples further down the page \n   file, err := os.Open(\"test.txt\") \n   if err != nil { \n      log.Fatal(err) \n   }  \n   file.Close() \n\n   // OpenFile with more options. Last param is the permission mode \n   // Second param is the attributes when opening \n   file, err = os.OpenFile(\"test.txt\", os.O_APPEND, 0666) \n   if err != nil { \n      log.Fatal(err) \n   } \n   file.Close() \n\n   // Use these attributes individually or combined \n   // with an OR for second arg of OpenFile() \n   // e.g. os.O_CREATE|os.O_APPEND \n   // or os.O_CREATE|os.O_TRUNC|os.O_WRONLY \n\n   // os.O_RDONLY // Read only \n   // os.O_WRONLY // Write only \n   // os.O_RDWR // Read and write \n   // os.O_APPEND // Append to end of file \n   // os.O_CREATE // Create is none exist \n   // os.O_TRUNC // Truncate file when opening \n} \n```", "```go\npackage main \n\nimport ( \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Stat returns file info. It will return \n   // an error if there is no file. \n   fileInfo, err := os.Stat(\"test.txt\") \n   if err != nil { \n      if os.IsNotExist(err) { \n         log.Fatal(\"File does not exist.\") \n      } \n   } \n   log.Println(\"File does exist. File information:\") \n   log.Println(fileInfo) \n} \n```", "```go\npackage main \n\nimport ( \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Test write permissions. It is possible the file \n   // does not exist and that will return a different \n   // error that can be checked with os.IsNotExist(err) \n   file, err := os.OpenFile(\"test.txt\", os.O_WRONLY, 0666) \n   if err != nil { \n      if os.IsPermission(err) { \n         log.Println(\"Error: Write permission denied.\") \n      } \n   } \n   file.Close() \n\n   // Test read permissions \n   file, err = os.OpenFile(\"test.txt\", os.O_RDONLY, 0666) \n   if err != nil { \n      if os.IsPermission(err) { \n         log.Println(\"Error: Read permission denied.\") \n      } \n   } \n   file.Close()\n} \n```", "```go\npackage main \n\nimport ( \n   \"log\" \n   \"os\" \n   \"time\" \n) \n\nfunc main() { \n   // Change permissions using Linux style \n   err := os.Chmod(\"test.txt\", 0777) \n   if err != nil { \n      log.Println(err) \n   } \n\n   // Change ownership \n   err = os.Chown(\"test.txt\", os.Getuid(), os.Getgid()) \n   if err != nil { \n      log.Println(err) \n   } \n\n   // Change timestamps \n   twoDaysFromNow := time.Now().Add(48 * time.Hour) \n   lastAccessTime := twoDaysFromNow \n   lastModifyTime := twoDaysFromNow \n   err = os.Chtimes(\"test.txt\", lastAccessTime, lastModifyTime) \n   if err != nil { \n      log.Println(err) \n   } \n} \n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Create a hard link \n   // You will have two file names that point to the same contents \n   // Changing the contents of one will change the other \n   // Deleting/renaming one will not affect the other \n   err := os.Link(\"original.txt\", \"original_also.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n\n   fmt.Println(\"Creating symlink\") \n   // Create a symlink \n   err = os.Symlink(\"original.txt\", \"original_sym.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n\n   // Lstat will return file info, but if it is actually \n   // a symlink, it will return info about the symlink. \n   // It will not follow the link and give information \n   // about the real file \n   // Symlinks do not work in Windows \n   fileInfo, err := os.Lstat(\"original_sym.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   fmt.Printf(\"Link info: %+v\", fileInfo) \n\n   // Change ownership of a symlink only \n   // and not the file it points to \n   err = os.Lchown(\"original_sym.txt\", os.Getuid(), os.Getgid()) \n   if err != nil { \n      log.Fatal(err) \n   } \n} \n```", "```go\npackage main \n\nimport ( \n   \"io\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Open original file \n   originalFile, err := os.Open(\"test.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   defer originalFile.Close() \n\n   // Create new file \n   newFile, err := os.Create(\"test_copy.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   defer newFile.Close() \n\n   // Copy the bytes to destination from source \n   bytesWritten, err := io.Copy(newFile, originalFile) \n   if err != nil { \n      log.Fatal(err) \n   } \n   log.Printf(\"Copied %d bytes.\", bytesWritten) \n\n   // Commit the file contents \n   // Flushes memory to disk \n   err = newFile.Sync() \n   if err != nil { \n      log.Fatal(err) \n   }  \n} \n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   file, _ := os.Open(\"test.txt\") \n   defer file.Close() \n\n   // Offset is how many bytes to move \n   // Offset can be positive or negative \n   var offset int64 = 5 \n\n   // Whence is the point of reference for offset \n   // 0 = Beginning of file \n   // 1 = Current position \n   // 2 = End of file \n   var whence int = 0 \n   newPosition, err := file.Seek(offset, whence) \n   if err != nil { \n      log.Fatal(err) \n   } \n   fmt.Println(\"Just moved to 5:\", newPosition) \n\n   // Go back 2 bytes from current position \n   newPosition, err = file.Seek(-2, 1) \n   if err != nil { \n      log.Fatal(err) \n   } \n   fmt.Println(\"Just moved back two:\", newPosition) \n\n   // Find the current position by getting the \n   // return value from Seek after moving 0 bytes \n   currentPosition, err := file.Seek(0, 1) \n   fmt.Println(\"Current position:\", currentPosition) \n\n   // Go to beginning of file \n   newPosition, err = file.Seek(0, 0) \n   if err != nil { \n      log.Fatal(err) \n   } \n   fmt.Println(\"Position after seeking 0,0:\", newPosition) \n} \n```", "```go\npackage main \n\nimport ( \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Open a new file for writing only \n   file, err := os.OpenFile( \n      \"test.txt\", \n      os.O_WRONLY|os.O_TRUNC|os.O_CREATE, \n      0666, \n   ) \n   if err != nil { \n      log.Fatal(err) \n   } \n   defer file.Close() \n\n   // Write bytes to file \n   byteSlice := []byte(\"Bytes!\\n\") \n   bytesWritten, err := file.Write(byteSlice) \n   if err != nil { \n      log.Fatal(err) \n   } \n   log.Printf(\"Wrote %d bytes.\\n\", bytesWritten) \n} \n```", "```go\npackage main \n\nimport ( \n   \"io/ioutil\" \n   \"log\" \n) \n\nfunc main() { \n   err := ioutil.WriteFile(\"test.txt\", []byte(\"Hi\\n\"), 0666) \n   if err != nil { \n      log.Fatal(err) \n   } \n} \n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Open file for writing \n   file, err := os.OpenFile(\"test.txt\", os.O_WRONLY, 0666) \n   if err != nil { \n      log.Fatal(err) \n   } \n   defer file.Close() \n\n   // Create a buffered writer from the file \n   bufferedWriter := bufio.NewWriter(file) \n\n   // Write bytes to buffer \n   bytesWritten, err := bufferedWriter.Write( \n      []byte{65, 66, 67}, \n   ) \n   if err != nil { \n      log.Fatal(err) \n   } \n   log.Printf(\"Bytes written: %d\\n\", bytesWritten) \n\n   // Write string to buffer \n   // Also available are WriteRune() and WriteByte() \n   bytesWritten, err = bufferedWriter.WriteString( \n      \"Buffered string\\n\", \n   ) \n   if err != nil { \n      log.Fatal(err) \n   } \n   log.Printf(\"Bytes written: %d\\n\", bytesWritten) \n\n   // Check how much is stored in buffer waiting \n   unflushedBufferSize := bufferedWriter.Buffered() \n   log.Printf(\"Bytes buffered: %d\\n\", unflushedBufferSize) \n\n   // See how much buffer is available \n   bytesAvailable := bufferedWriter.Available() \n   if err != nil { \n      log.Fatal(err) \n   } \n   log.Printf(\"Available buffer: %d\\n\", bytesAvailable) \n\n   // Write memory buffer to disk \n   bufferedWriter.Flush() \n\n   // Revert any changes done to buffer that have \n   // not yet been written to file with Flush() \n   // We just flushed, so there are no changes to revert \n   // The writer that you pass as an argument \n   // is where the buffer will output to, if you want \n   // to change to a new writer \n   bufferedWriter.Reset(bufferedWriter) \n\n   // See how much buffer is available \n   bytesAvailable = bufferedWriter.Available() \n   if err != nil { \n      log.Fatal(err) \n   } \n   log.Printf(\"Available buffer: %d\\n\", bytesAvailable) \n\n   // Resize buffer. The first argument is a writer \n   // where the buffer should output to. In this case \n   // we are using the same buffer. If we chose a number \n   // that was smaller than the existing buffer, like 10 \n   // we would not get back a buffer of size 10, we will \n   // get back a buffer the size of the original since \n   // it was already large enough (default 4096) \n   bufferedWriter = bufio.NewWriterSize( \n      bufferedWriter, \n      8000, \n   ) \n\n   // Check available buffer size after resizing \n   bytesAvailable = bufferedWriter.Available() \n   if err != nil { \n      log.Fatal(err) \n   } \n   log.Printf(\"Available buffer: %d\\n\", bytesAvailable) \n} \n```", "```go\npackage main \n\nimport ( \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Open file for reading \n   file, err := os.Open(\"test.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   defer file.Close() \n\n   // Read up to len(b) bytes from the File \n   // Zero bytes written means end of file \n   // End of file returns error type io.EOF \n   byteSlice := make([]byte, 16) \n   bytesRead, err := file.Read(byteSlice) \n   if err != nil { \n      log.Fatal(err) \n   } \n   log.Printf(\"Number of bytes read: %d\\n\", bytesRead) \n   log.Printf(\"Data read: %s\\n\", byteSlice) \n} \n```", "```go\npackage main \n\nimport ( \n   \"io\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Open file for reading \n   file, err := os.Open(\"test.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n\n   // The file.Read() function will happily read a tiny file in to a    \n   // large byte slice, but io.ReadFull() will return an \n   // error if the file is smaller than the byte slice. \n   byteSlice := make([]byte, 2) \n   numBytesRead, err := io.ReadFull(file, byteSlice) \n   if err != nil { \n      log.Fatal(err) \n   } \n   log.Printf(\"Number of bytes read: %d\\n\", numBytesRead) \n   log.Printf(\"Data read: %s\\n\", byteSlice) \n} \n```", "```go\npackage main \n\nimport ( \n   \"io\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Open file for reading \n   file, err := os.Open(\"test.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n\n   byteSlice := make([]byte, 512) \n   minBytes := 8 \n   // io.ReadAtLeast() will return an error if it cannot \n   // find at least minBytes to read. It will read as \n   // many bytes as byteSlice can hold. \n   numBytesRead, err := io.ReadAtLeast(file, byteSlice, minBytes) \n   if err != nil { \n      log.Fatal(err) \n   } \n   log.Printf(\"Number of bytes read: %d\\n\", numBytesRead) \n   log.Printf(\"Data read: %s\\n\", byteSlice) \n} \n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"io/ioutil\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Open file for reading \n   file, err := os.Open(\"test.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n\n   // os.File.Read(), io.ReadFull(), and \n   // io.ReadAtLeast() all work with a fixed \n   // byte slice that you make before you read \n\n   // ioutil.ReadAll() will read every byte \n   // from the reader (in this case a file), \n   // and return a slice of unknown slice \n   data, err := ioutil.ReadAll(file) \n   if err != nil { \n      log.Fatal(err) \n   } \n\n   fmt.Printf(\"Data as hex: %x\\n\", data) \n   fmt.Printf(\"Data as string: %s\\n\", data) \n   fmt.Println(\"Number of bytes read:\", len(data)) \n} \n```", "```go\npackage main \n\nimport ( \n   \"io/ioutil\" \n   \"log\" \n) \n\nfunc main() { \n   // Read file to byte slice \n   data, err := ioutil.ReadFile(\"test.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n\n   log.Printf(\"Data read: %s\\n\", data) \n} \n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Open file and create a buffered reader on top \n   file, err := os.Open(\"test.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   bufferedReader := bufio.NewReader(file) \n\n   // Get bytes without advancing pointer \n   byteSlice := make([]byte, 5) \n   byteSlice, err = bufferedReader.Peek(5) \n   if err != nil { \n      log.Fatal(err) \n   } \n   fmt.Printf(\"Peeked at 5 bytes: %s\\n\", byteSlice) \n\n   // Read and advance pointer \n   numBytesRead, err := bufferedReader.Read(byteSlice) \n   if err != nil { \n      log.Fatal(err) \n   } \n   fmt.Printf(\"Read %d bytes: %s\\n\", numBytesRead, byteSlice) \n\n   // Ready 1 byte. Error if no byte to read \n   myByte, err := bufferedReader.ReadByte() \n   if err != nil { \n      log.Fatal(err) \n   }  \n   fmt.Printf(\"Read 1 byte: %c\\n\", myByte) \n\n   // Read up to and including delimiter \n   // Returns byte slice \n   dataBytes, err := bufferedReader.ReadBytes('\\n') \n   if err != nil { \n      log.Fatal(err) \n   } \n   fmt.Printf(\"Read bytes: %s\\n\", dataBytes) \n\n   // Read up to and including delimiter \n   // Returns string \n   dataString, err := bufferedReader.ReadString('\\n') \n   if err != nil { \n      log.Fatal(err) \n   } \n   fmt.Printf(\"Read string: %s\\n\", dataString) \n\n   // This example reads a few lines so test.txt \n   // should have a few lines of text to work correct \n} \n```", "```go\ntype SplitFuncfunc(data []byte, atEOF bool) (advance int, token []byte, \n   err error)\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Open file and create scanner on top of it \n   file, err := os.Open(\"test.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   scanner := bufio.NewScanner(file) \n\n   // Default scanner is bufio.ScanLines. Lets use ScanWords. \n   // Could also use a custom function of SplitFunc type \n   scanner.Split(bufio.ScanWords) \n\n   // Scan for next token. \n   success := scanner.Scan() \n   if success == false { \n      // False on error or EOF. Check error \n      err = scanner.Err() \n      if err == nil { \n         log.Println(\"Scan completed and reached EOF\") \n      } else { \n         log.Fatal(err) \n      } \n   } \n\n   // Get data from scan with Bytes() or Text() \n   fmt.Println(\"First word found:\", scanner.Text()) \n\n   // Call scanner.Scan() manually, or loop with for \n   for scanner.Scan() { \n      fmt.Println(scanner.Text()) \n   } \n} \n```", "```go\n// This example uses zip but standard library \n// also supports tar archives \npackage main \n\nimport ( \n   \"archive/zip\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Create a file to write the archive buffer to \n   // Could also use an in memory buffer. \n   outFile, err := os.Create(\"test.zip\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   defer outFile.Close() \n\n   // Create a zip writer on top of the file writer \n   zipWriter := zip.NewWriter(outFile) \n\n   // Add files to archive \n   // We use some hard coded data to demonstrate, \n   // but you could iterate through all the files \n   // in a directory and pass the name and contents \n   // of each file, or you can take data from your \n   // program and write it write in to the archive without \n   var filesToArchive = []struct { \n      Name, Body string \n   }{ \n      {\"test.txt\", \"String contents of file\"}, \n      {\"test2.txt\", \"\\x61\\x62\\x63\\n\"}, \n   } \n\n   // Create and write files to the archive, which in turn \n   // are getting written to the underlying writer to the \n   // .zip file we created at the beginning \n   for _, file := range filesToArchive { \n      fileWriter, err := zipWriter.Create(file.Name) \n      if err != nil { \n         log.Fatal(err) \n      } \n      _, err = fileWriter.Write([]byte(file.Body)) \n      if err != nil { \n         log.Fatal(err) \n      } \n   } \n\n   // Clean up \n   err = zipWriter.Close() \n   if err != nil { \n      log.Fatal(err) \n   } \n} \n```", "```go\n// This example uses zip but standard library \n// also supports tar archives \npackage main \n\nimport ( \n   \"archive/zip\" \n   \"io\" \n   \"log\" \n   \"os\" \n   \"path/filepath\" \n) \n\nfunc main() { \n   // Create a reader out of the zip archive \n   zipReader, err := zip.OpenReader(\"test.zip\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   defer zipReader.Close() \n\n   // Iterate through each file/dir found in \n   for _, file := range zipReader.Reader.File { \n      // Open the file inside the zip archive \n      // like a normal file \n      zippedFile, err := file.Open() \n      if err != nil { \n         log.Fatal(err) \n      } \n      defer zippedFile.Close() \n\n      // Specify what the extracted file name should be. \n      // You can specify a full path or a prefix \n      // to move it to a different directory. \n      // In this case, we will extract the file from \n      // the zip to a file of the same name. \n      targetDir := \"./\" \n      extractedFilePath := filepath.Join( \n         targetDir, \n         file.Name, \n      ) \n\n      // Extract the item (or create directory) \n      if file.FileInfo().IsDir() { \n         // Create directories to recreate directory \n         // structure inside the zip archive. Also \n         // preserves permissions \n         log.Println(\"Creating directory:\", extractedFilePath) \n         os.MkdirAll(extractedFilePath, file.Mode()) \n      } else { \n         // Extract regular file since not a directory \n         log.Println(\"Extracting file:\", file.Name) \n\n         // Open an output file for writing \n         outputFile, err := os.OpenFile( \n            extractedFilePath, \n            os.O_WRONLY|os.O_CREATE|os.O_TRUNC, \n            file.Mode(), \n         ) \n         if err != nil { \n            log.Fatal(err) \n         } \n         defer outputFile.Close() \n\n         // \"Extract\" the file by copying zipped file \n         // contents to the output file \n         _, err = io.Copy(outputFile, zippedFile) \n         if err != nil { \n            log.Fatal(err) \n         } \n      }  \n   } \n} \n```", "```go\n// This example uses gzip but standard library also \n// supports zlib, bz2, flate, and lzw \npackage main \n\nimport ( \n   \"compress/gzip\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Create .gz file to write to \n   outputFile, err := os.Create(\"test.txt.gz\") \n   if err != nil { \n      log.Fatal(err) \n   } \n\n   // Create a gzip writer on top of file writer \n   gzipWriter := gzip.NewWriter(outputFile) \n   defer gzipWriter.Close() \n\n   // When we write to the gzip writer \n   // it will in turn compress the contents \n   // and then write it to the underlying \n   // file writer as well \n   // We don't have to worry about how all \n   // the compression works since we just \n   // use it as a simple writer interface \n   // that we send bytes to \n   _, err = gzipWriter.Write([]byte(\"Gophers rule!\\n\")) \n   if err != nil { \n      log.Fatal(err) \n   } \n\n   log.Println(\"Compressed data written to file.\") \n} \n```", "```go\n// This example uses gzip but standard library also \n// supports zlib, bz2, flate, and lzw \npackage main \n\nimport ( \n   \"compress/gzip\" \n   \"io\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Open gzip file that we want to uncompress \n   // The file is a reader, but we could use any \n   // data source. It is common for web servers \n   // to return gzipped contents to save bandwidth \n   // and in that case the data is not in a file \n   // on the file system but is in a memory buffer \n   gzipFile, err := os.Open(\"test.txt.gz\") \n   if err != nil { \n      log.Fatal(err) \n   } \n\n   // Create a gzip reader on top of the file reader \n   // Again, it could be any type reader though \n   gzipReader, err := gzip.NewReader(gzipFile) \n   if err != nil { \n      log.Fatal(err) \n   } \n   defer gzipReader.Close() \n\n   // Uncompress to a writer. We'll use a file writer \n   outfileWriter, err := os.Create(\"unzipped.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   defer outfileWriter.Close() \n\n   // Copy contents of gzipped file to output file \n   _, err = io.Copy(outfileWriter, gzipReader) \n   if err != nil { \n      log.Fatal(err) \n   } \n} \n```", "```go\npackage main \n\nimport ( \n   \"fmt\" \n   \"io/ioutil\" \n   \"log\" \n   \"os\" \n) \n\nfunc main() { \n   // Create a temp dir in the system default temp folder \n   tempDirPath, err := ioutil.TempDir(\"\", \"myTempDir\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   fmt.Println(\"Temp dir created:\", tempDirPath) \n\n   // Create a file in new temp directory \n   tempFile, err := ioutil.TempFile(tempDirPath, \"myTempFile.txt\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   fmt.Println(\"Temp file created:\", tempFile.Name()) \n\n   // ... do something with temp file/dir ... \n\n   // Close file \n   err = tempFile.Close() \n   if err != nil { \n      log.Fatal(err) \n   } \n\n   // Delete the resources we created \n   err = os.Remove(tempFile.Name()) \n   if err != nil { \n      log.Fatal(err) \n   } \n   err = os.Remove(tempDirPath) \n   if err != nil { \n      log.Fatal(err) \n   } \n}\n```", "```go\npackage main \n\nimport ( \n   \"io\" \n   \"log\" \n   \"net/http\" \n   \"os\" \n) \n\nfunc main() { \n   // Create output file \n   newFile, err := os.Create(\"devdungeon.html\") \n   if err != nil { \n      log.Fatal(err) \n   } \n   defer newFile.Close() \n\n   // HTTP GET request devdungeon.com \n   url := \"http://www.devdungeon.com/archive\" \n   response, err := http.Get(url) \n   defer response.Body.Close() \n\n   // Write bytes from HTTP response to file. \n   // response.Body satisfies the reader interface. \n   // newFile satisfies the writer interface. \n   // That allows us to use io.Copy which accepts \n   // any type that implements reader and writer interface \n   numBytesWritten, err := io.Copy(newFile, response.Body) \n   if err != nil { \n      log.Fatal(err) \n   } \n   log.Printf(\"Downloaded %d byte file.\\n\", numBytesWritten) \n} \n```"]