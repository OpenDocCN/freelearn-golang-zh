["```go\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"os\"\n)\n\nvar (\n   fileInfo os.FileInfo\n   err error\n)\n\nfunc main() {\n   // Stat returns file info. It will return\n   // an error if there is no file.\n   fileInfo, err = os.Stat(\"test.txt\")\n   if err != nil {\n      log.Fatal(err)\n   }\n   fmt.Println(\"File name:\", fileInfo.Name())\n   fmt.Println(\"Size in bytes:\", fileInfo.Size())\n   fmt.Println(\"Permissions:\", fileInfo.Mode())\n   fmt.Println(\"Last modified:\", fileInfo.ModTime())\n   fmt.Println(\"Is Directory: \", fileInfo.IsDir())\n   fmt.Printf(\"System interface type: %T\\n\", fileInfo.Sys())\n   fmt.Printf(\"System info: %+v\\n\\n\", fileInfo.Sys())\n}\n```", "```go\npackage main\n\nimport (\n   \"container/list\"\n   \"fmt\"\n   \"io/ioutil\"\n   \"log\"\n   \"os\"\n   \"path/filepath\"\n)\n\ntype FileNode struct {\n   FullPath string\n   Info os.FileInfo\n}\n\nfunc insertSorted(fileList *list.List, fileNode FileNode) {\n   if fileList.Len() == 0 { \n      // If list is empty, just insert and return\n      fileList.PushFront(fileNode)\n      return\n   }\n\n   for element := fileList.Front(); element != nil; element =    \n      element.Next() {\n      if fileNode.Info.Size() < element.Value.(FileNode).Info.Size()       \n      {\n         fileList.InsertBefore(fileNode, element)\n         return\n      }\n   }\n   fileList.PushBack(fileNode)\n}\n\nfunc getFilesInDirRecursivelyBySize(fileList *list.List, path string) {\n   dirFiles, err := ioutil.ReadDir(path)\n   if err != nil {\n      log.Println(\"Error reading directory: \" + err.Error())\n   }\n\n   for _, dirFile := range dirFiles {\n      fullpath := filepath.Join(path, dirFile.Name())\n      if dirFile.IsDir() {\n         getFilesInDirRecursivelyBySize(\n            fileList,\n            filepath.Join(path, dirFile.Name()),\n         )\n      } else if dirFile.Mode().IsRegular() {\n         insertSorted(\n            fileList,\n            FileNode{FullPath: fullpath, Info: dirFile},\n         )\n      }\n   }\n}\n\nfunc main() {\n   fileList := list.New()\n   getFilesInDirRecursivelyBySize(fileList, \"/home\")\n\n   for element := fileList.Front(); element != nil; element =   \n      element.Next() {\n      fmt.Printf(\"%d \", element.Value.(FileNode).Info.Size())\n      fmt.Printf(\"%s\\n\", element.Value.(FileNode).FullPath)\n   }\n}\n```", "```go\npackage main\n\nimport (\n   \"container/list\"\n   \"fmt\"\n   \"io/ioutil\"\n   \"log\"\n   \"os\"\n   \"path/filepath\"\n)\n\ntype FileNode struct {\n   FullPath string\n   Info os.FileInfo\n}\n\nfunc insertSorted(fileList *list.List, fileNode FileNode) {\n   if fileList.Len() == 0 { \n      // If list is empty, just insert and return\n      fileList.PushFront(fileNode)\n      return\n   }\n\n   for element := fileList.Front(); element != nil; element = \n      element.Next() {\n      if fileNode.Info.ModTime().Before(element.Value.\n        (FileNode).Info.ModTime()) {\n            fileList.InsertBefore(fileNode, element)\n            return\n        }\n    }\n\n    fileList.PushBack(fileNode)\n}\n\nfunc GetFilesInDirRecursivelyBySize(fileList *list.List, path string) {\n    dirFiles, err := ioutil.ReadDir(path)\n    if err != nil {\n        log.Println(\"Error reading directory: \" + err.Error())\n    }\n\n    for _, dirFile := range dirFiles {\n        fullpath := filepath.Join(path, dirFile.Name())\n        if dirFile.IsDir() {\n            GetFilesInDirRecursivelyBySize(\n            fileList,\n            filepath.Join(path, dirFile.Name()),\n            )\n        } else if dirFile.Mode().IsRegular() {\n           insertSorted(\n              fileList,\n              FileNode{FullPath: fullpath, Info: dirFile},\n           )\n        }\n    }\n}\n\nfunc main() {\n    fileList := list.New()\n    GetFilesInDirRecursivelyBySize(fileList, \"/\")\n\n    for element := fileList.Front(); element != nil; element =    \n       element.Next() {\n        fmt.Print(element.Value.(FileNode).Info.ModTime())\n        fmt.Printf(\"%s\\n\", element.Value.(FileNode).FullPath)\n    }\n}\n```", "```go\npackage main\n\n// Device is typically /dev/sda but may also be /dev/sdb, /dev/sdc\n// Use mount, or df -h to get info on which drives are being used\n// You will need sudo to access some disks at this level\n\nimport (\n   \"io\"\n   \"log\"\n   \"os\"\n)\n\nfunc main() {\n   path := \"/dev/sda\"\n   log.Println(\"[+] Reading boot sector of \" + path)\n\n   file, err := os.Open(path)\n   if err != nil {\n      log.Fatal(\"Error: \" + err.Error())\n   }\n\n   // The file.Read() function will read a tiny file in to a large\n   // byte slice, but io.ReadFull() will return an\n   // error if the file is smaller than the byte slice.\n   byteSlice := make([]byte, 512)\n   // ReadFull Will error if 512 bytes not available to read\n   numBytesRead, err := io.ReadFull(file, byteSlice)\n   if err != nil {\n      log.Fatal(\"Error reading 512 bytes from file. \" + err.Error())\n   }\n\n   log.Printf(\"Bytes read: %d\\n\\n\", numBytesRead)\n   log.Printf(\"Data as decimal:\\n%d\\n\\n\", byteSlice)\n   log.Printf(\"Data as hex:\\n%x\\n\\n\", byteSlice)\n   log.Printf(\"Data as string:\\n%s\\n\\n\", byteSlice)\n}\n```", "```go\npackage main\n\nimport (\n   \"image\"\n   \"image/jpeg\"\n   \"log\"\n   \"math/rand\"\n   \"os\"\n)\n\nfunc main() {\n   // 100x200 pixels\n   myImage := image.NewRGBA(image.Rect(0, 0, 100, 200))\n\n   for p := 0; p < 100*200; p++ {\n      pixelOffset := 4 * p\n      myImage.Pix[0+pixelOffset] = uint8(rand.Intn(256)) // Red\n      myImage.Pix[1+pixelOffset] = uint8(rand.Intn(256)) // Green\n      myImage.Pix[2+pixelOffset] = uint8(rand.Intn(256)) // Blue\n      myImage.Pix[3+pixelOffset] = 255 // Alpha\n   }\n\n   outputFile, err := os.Create(\"test.jpg\")\n   if err != nil {\n      log.Fatal(err)\n   }\n\n   jpeg.Encode(outputFile, myImage, nil)\n\n   err = outputFile.Close()\n   if err != nil {\n      log.Fatal(err)\n   }\n}\n```", "```go\npackage main\n\nimport (\n   \"crypto/md5\"\n   \"crypto/sha1\"\n   \"crypto/sha256\"\n   \"crypto/sha512\"\n   \"fmt\"\n   \"io/ioutil\"\n   \"log\"\n   \"os\"\n)\n\nfunc printUsage() {\n   fmt.Println(\"Usage: \" + os.Args[0] + \" <filepath>\")\n   fmt.Println(\"Example: \" + os.Args[0] + \" document.txt\")\n}\n\nfunc checkArgs() string {\n   if len(os.Args) < 2 {\n      printUsage()\n      os.Exit(1)\n   }\n   return os.Args[1]\n}\n\nfunc main() {\n   filename := checkArgs()\n\n   // Get bytes from file\n   data, err := ioutil.ReadFile(filename)\n   if err != nil {\n      log.Fatal(err)\n   }\n\n   // Hash the file and output results\n   fmt.Printf(\"Md5: %x\\n\\n\", md5.Sum(data))\n   fmt.Printf(\"Sha1: %x\\n\\n\", sha1.Sum(data))\n   fmt.Printf(\"Sha256: %x\\n\\n\", sha256.Sum256(data))\n   fmt.Printf(\"Sha512: %x\\n\\n\", sha512.Sum512(data))\n}\n```", "```go\npackage main\n\nimport (\n   \"io\"\n   \"log\"\n   \"os\"\n)\n\nfunc main() {\n   // Open original file\n   firstFile, err := os.Open(\"test.jpg\")\n   if err != nil {\n      log.Fatal(err)\n   }\n   defer firstFile.Close()\n\n   // Second file\n   secondFile, err := os.Open(\"test.zip\")\n   if err != nil {\n      log.Fatal(err)\n   }\n   defer secondFile.Close()\n\n   // New file for output\n   newFile, err := os.Create(\"stego_image.jpg\")\n   if err != nil {\n      log.Fatal(err)\n   }\n   defer newFile.Close()\n\n   // Copy the bytes to destination from source\n   _, err = io.Copy(newFile, firstFile)\n   if err != nil {\n      log.Fatal(err)\n   }\n   _, err = io.Copy(newFile, secondFile)\n   if err != nil {\n      log.Fatal(err)\n   }\n}\n\n```", "```go\npackage main\n\nimport (\n   \"bufio\"\n   \"bytes\"\n   \"log\"\n   \"os\"\n)\n\nfunc main() {\n   // Zip signature is \"\\x50\\x4b\\x03\\x04\"\n   filename := \"stego_image.jpg\"\n   file, err := os.Open(filename)\n   if err != nil {\n      log.Fatal(err)\n   }\n   bufferedReader := bufio.NewReader(file)\n\n   fileStat, _ := file.Stat()\n   // 0 is being cast to an int64 to force i to be initialized as\n   // int64 because filestat.Size() returns an int64 and must be\n   // compared against the same type\n   for i := int64(0); i < fileStat.Size(); i++ {\n      myByte, err := bufferedReader.ReadByte()\n      if err != nil {\n         log.Fatal(err)\n      }\n\n      if myByte == '\\x50' { \n         // First byte match. Check the next 3 bytes\n         byteSlice := make([]byte, 3)\n         // Get bytes without advancing pointer with Peek\n         byteSlice, err = bufferedReader.Peek(3)\n         if err != nil {\n            log.Fatal(err)\n         }\n\n         if bytes.Equal(byteSlice, []byte{'\\x4b', '\\x03', '\\x04'}) {\n            log.Printf(\"Found zip signature at byte %d.\", i)\n         }\n      }\n   }\n}\n```", "```go\nexport GODEBUG=netdns=go # force pure Go resolver (Default)\nexport GODEBUG=netdns=cgo # force cgo resolver\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"net\"\n   \"os\"\n)\n\nfunc main() {\n   if len(os.Args) != 2 {\n      log.Fatal(\"No IP address argument provided.\")\n   }\n   arg := os.Args[1]\n\n   // Parse the IP for validation\n   ip := net.ParseIP(arg)\n   if ip == nil {\n      log.Fatal(\"Valid IP not detected. Value provided: \" + arg)\n   }\n\n   fmt.Println(\"Looking up hostnames for IP address: \" + arg)\n   hostnames, err := net.LookupAddr(ip.String())\n   if err != nil {\n      log.Fatal(err)\n   }\n   for _, hostnames := range hostnames {\n      fmt.Println(hostnames)\n   }\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"net\"\n   \"os\"\n)\n\nfunc main() {\n   if len(os.Args) != 2 {\n      log.Fatal(\"No hostname argument provided.\")\n   }\n   arg := os.Args[1]\n\n   fmt.Println(\"Looking up IP addresses for hostname: \" + arg)\n\n   ips, err := net.LookupHost(arg)\n   if err != nil {\n      log.Fatal(err)\n   }\n   for _, ip := range ips {\n      fmt.Println(ip)\n   }\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"net\"\n   \"os\"\n)\n\nfunc main() {\n   if len(os.Args) != 2 {\n      log.Fatal(\"No domain name argument provided\")\n   }\n   arg := os.Args[1]\n\n   fmt.Println(\"Looking up MX records for \" + arg)\n\n   mxRecords, err := net.LookupMX(arg)\n   if err != nil {\n      log.Fatal(err)\n   }\n   for _, mxRecord := range mxRecords {\n      fmt.Printf(\"Host: %s\\tPreference: %d\\n\", mxRecord.Host,   \n         mxRecord.Pref)\n   }\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"net\"\n   \"os\"\n)\n\nfunc main() {\n   if len(os.Args) != 2 {\n      log.Fatal(\"No domain name argument provided\")\n   }\n   arg := os.Args[1]\n\n   fmt.Println(\"Looking up nameservers for \" + arg)\n\n   nameservers, err := net.LookupNS(arg)\n   if err != nil {\n      log.Fatal(err)\n   }\n   for _, nameserver := range nameservers {\n      fmt.Println(nameserver.Host)\n   }\n}\n```"]