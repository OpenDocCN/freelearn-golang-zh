["```go\nsudo apt-get install git libpcap-dev\n```", "```go\ngo get github.com/google/gopacket  \n```", "```go\ntcpdump -D\n```", "```go\ntcpdump --list-interfaces\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"github.com/google/gopacket/pcap\"\n)\n\nfunc main() {\n   // Find all devices\n   devices, err := pcap.FindAllDevs()\n   if err != nil {\n      log.Fatal(err)\n   }\n\n   // Print device information\n   fmt.Println(\"Devices found:\")\n   for _, device := range devices {\n      fmt.Println(\"\\nName: \", device.Name)\n      fmt.Println(\"Description: \", device.Description)\n      fmt.Println(\"Devices addresses: \", device.Description)\n      for _, address := range device.Addresses {\n         fmt.Println(\"- IP address: \", address.IP)\n         fmt.Println(\"- Subnet mask: \", address.Netmask)\n      }\n   }\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"github.com/google/gopacket\"\n   \"github.com/google/gopacket/pcap\"\n   \"log\"\n   \"time\"\n)\n\nvar (\n   device            = \"eth0\"\n   snapshotLen int32 = 1024\n   promiscuous       = false\n   err         error\n   timeout     = 30 * time.Second\n   handle      *pcap.Handle\n)\n\nfunc main() {\n   // Open device\n   handle, err = pcap.OpenLive(device, snapshotLen, promiscuous,  \n      timeout)\n   if err != nil {\n      log.Fatal(err)\n   }\n   defer handle.Close()\n\n   // Use the handle as a packet source to process all packets\n   packetSource := gopacket.NewPacketSource(handle, handle.LinkType())\n   for packet := range packetSource.Packets() {\n      // Process packet here\n      fmt.Println(packet)\n   }\n}\n```", "```go\ntcpdump -i eth0\n```", "```go\ntcpdump -i eth0 tcp port 80\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"github.com/google/gopacket\"\n   \"github.com/google/gopacket/pcap\"\n   \"log\"\n   \"time\"\n)\n\nvar (\n   device            = \"eth0\"\n   snapshotLen int32 = 1024\n   promiscuous       = false\n   err         error\n   timeout     = 30 * time.Second\n   handle      *pcap.Handle\n)\n\nfunc main() {\n   // Open device\n   handle, err = pcap.OpenLive(device, snapshotLen, promiscuous,  \n      timeout)\n   if err != nil {\n      log.Fatal(err)\n   }\n   defer handle.Close()\n\n   // Set filter\n   var filter string = \"tcp and port 80\" // or os.Args[1]\n   err = handle.SetBPFFilter(filter)\n   if err != nil {\n      log.Fatal(err)\n   }\n   fmt.Println(\"Only capturing TCP port 80 packets.\")\n\n   packetSource := gopacket.NewPacketSource(handle, handle.LinkType())\n   for packet := range packetSource.Packets() {\n      // Do something with a packet here.\n      fmt.Println(packet)\n   }\n}\n```", "```go\ntcpdump -i eth0 -w my_capture.pcap\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"os\"\n   \"time\"\n\n   \"github.com/google/gopacket\"\n   \"github.com/google/gopacket/layers\"\n   \"github.com/google/gopacket/pcap\"\n   \"github.com/google/gopacket/pcapgo\"\n)\n\nvar (\n   deviceName        = \"eth0\"\n   snapshotLen int32 = 1024\n   promiscuous       = false\n   err         error\n   timeout     = -1 * time.Second\n   handle      *pcap.Handle\n   packetCount = 0\n)\n\nfunc main() {\n   // Open output pcap file and write header\n   f, _ := os.Create(\"test.pcap\")\n   w := pcapgo.NewWriter(f)\n   w.WriteFileHeader(uint32(snapshotLen), layers.LinkTypeEthernet)\n   defer f.Close()\n\n   // Open the device for capturing\n   handle, err = pcap.OpenLive(deviceName, snapshotLen, promiscuous, \n      timeout)\n   if err != nil {\n      fmt.Printf(\"Error opening device %s: %v\", deviceName, err)\n      os.Exit(1)\n   }\n   defer handle.Close()\n\n   // Start processing packets\n   packetSource := gopacket.NewPacketSource(handle, handle.LinkType())\n   for packet := range packetSource.Packets() {\n      // Process packet here\n      fmt.Println(packet)\n      w.WritePacket(packet.Metadata().CaptureInfo, packet.Data())\n      packetCount++\n\n      // Only capture 100 and then stop\n      if packetCount > 100 {\n         break\n      }\n   }\n}\n```", "```go\npackage main\n\n// Use tcpdump to create a test file\n// tcpdump -w test.pcap\n// or use the example above for writing pcap files\n\nimport (\n   \"fmt\"\n   \"github.com/google/gopacket\"\n   \"github.com/google/gopacket/pcap\"\n   \"log\"\n)\n\nvar (\n   pcapFile = \"test.pcap\"\n   handle   *pcap.Handle\n   err      error\n)\n\nfunc main() {\n   // Open file instead of device\n   handle, err = pcap.OpenOffline(pcapFile)\n   if err != nil {\n      log.Fatal(err)\n   }\n   defer handle.Close()\n\n   // Loop through packets in file\n   packetSource := gopacket.NewPacketSource(handle, handle.LinkType())\n   for packet := range packetSource.Packets() {\n      fmt.Println(packet)\n   }\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"github.com/google/gopacket\"\n   \"github.com/google/gopacket/layers\"\n   \"github.com/google/gopacket/pcap\"\n   \"log\"\n   \"strings\"\n   \"time\"\n)\n\nvar (\n   device            = \"eth0\"\n   snapshotLen int32 = 1024\n   promiscuous       = false\n   err         error\n   timeout     = 30 * time.Second\n   handle      *pcap.Handle\n)\n\nfunc main() {\n   // Open device\n   handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, \n      timeout)\n   if err != nil {\n      log.Fatal(err)\n   }\n   defer handle.Close()\n\n   packetSource := gopacket.NewPacketSource(handle, handle.LinkType())\n   for packet := range packetSource.Packets() {\n      printPacketInfo(packet)\n   }\n}\n\nfunc printPacketInfo(packet gopacket.Packet) {\n   // Let's see if the packet is an ethernet packet\n   ethernetLayer := packet.Layer(layers.LayerTypeEthernet)\n   if ethernetLayer != nil {\n      fmt.Println(\"Ethernet layer detected.\")\n      ethernetPacket, _ := ethernetLayer.(*layers.Ethernet)\n      fmt.Println(\"Source MAC: \", ethernetPacket.SrcMAC)\n      fmt.Println(\"Destination MAC: \", ethernetPacket.DstMAC)\n      // Ethernet type is typically IPv4 but could be ARP or other\n      fmt.Println(\"Ethernet type: \", ethernetPacket.EthernetType)\n      fmt.Println()\n   }\n\n   // Let's see if the packet is IP (even though the ether type told \n   //us)\n   ipLayer := packet.Layer(layers.LayerTypeIPv4)\n   if ipLayer != nil {\n      fmt.Println(\"IPv4 layer detected.\")\n      ip, _ := ipLayer.(*layers.IPv4)\n\n      // IP layer variables:\n      // Version (Either 4 or 6)\n      // IHL (IP Header Length in 32-bit words)\n      // TOS, Length, Id, Flags, FragOffset, TTL, Protocol (TCP?),\n      // Checksum, SrcIP, DstIP\n      fmt.Printf(\"From %s to %s\\n\", ip.SrcIP, ip.DstIP)\n      fmt.Println(\"Protocol: \", ip.Protocol)\n      fmt.Println()\n   }\n\n   // Let's see if the packet is TCP\n   tcpLayer := packet.Layer(layers.LayerTypeTCP)\n   if tcpLayer != nil {\n      fmt.Println(\"TCP layer detected.\")\n      tcp, _ := tcpLayer.(*layers.TCP)\n\n      // TCP layer variables:\n      // SrcPort, DstPort, Seq, Ack, DataOffset, Window, Checksum, \n      //Urgent\n      // Bool flags: FIN, SYN, RST, PSH, ACK, URG, ECE, CWR, NS\n      fmt.Printf(\"From port %d to %d\\n\", tcp.SrcPort, tcp.DstPort)\n      fmt.Println(\"Sequence number: \", tcp.Seq)\n      fmt.Println()\n   }\n\n   // Iterate over all layers, printing out each layer type\n   fmt.Println(\"All packet layers:\")\n   for _, layer := range packet.Layers() {\n      fmt.Println(\"- \", layer.LayerType())\n   }\n\n   // When iterating through packet.Layers() above,\n   // if it lists Payload layer then that is the same as\n   // this applicationLayer. applicationLayer contains the payload\n   applicationLayer := packet.ApplicationLayer()\n   if applicationLayer != nil {\n      fmt.Println(\"Application layer/Payload found.\")\n      fmt.Printf(\"%s\\n\", applicationLayer.Payload())\n\n      // Search for a string inside the payload\n      if strings.Contains(string(applicationLayer.Payload()), \"HTTP\")    \n      {\n         fmt.Println(\"HTTP found!\")\n      }\n   }\n\n   // Check for errors\n   if err := packet.ErrorLayer(); err != nil {\n      fmt.Println(\"Error decoding some part of the packet:\", err)\n   }\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"github.com/google/gopacket\"\n)\n\n// Create custom layer structure\ntype CustomLayer struct {\n   // This layer just has two bytes at the front\n   SomeByte    byte\n   AnotherByte byte\n   restOfData  []byte\n}\n\n// Register the layer type so we can use it\n// The first argument is an ID. Use negative\n// or 2000+ for custom layers. It must be unique\nvar CustomLayerType = gopacket.RegisterLayerType(\n   2001,\n   gopacket.LayerTypeMetadata{\n      \"CustomLayerType\",\n      gopacket.DecodeFunc(decodeCustomLayer),\n   },\n)\n\n// When we inquire about the type, what type of layer should\n// we say it is? We want it to return our custom layer type\nfunc (l CustomLayer) LayerType() gopacket.LayerType {\n   return CustomLayerType\n}\n\n// LayerContents returns the information that our layer\n// provides. In this case it is a header layer so\n// we return the header information\nfunc (l CustomLayer) LayerContents() []byte {\n   return []byte{l.SomeByte, l.AnotherByte}\n}\n\n// LayerPayload returns the subsequent layer built\n// on top of our layer or raw payload\nfunc (l CustomLayer) LayerPayload() []byte {\n   return l.restOfData\n}\n\n// Custom decode function. We can name it whatever we want\n// but it should have the same arguments and return value\n// When the layer is registered we tell it to use this decode function\nfunc decodeCustomLayer(data []byte, p gopacket.PacketBuilder) error {\n   // AddLayer appends to the list of layers that the packet has\n   p.AddLayer(&CustomLayer{data[0], data[1], data[2:]})\n\n   // The return value tells the packet what layer to expect\n   // with the rest of the data. It could be another header layer,\n   // nothing, or a payload layer.\n\n   // nil means this is the last layer. No more decoding\n   // return nil\n   // Returning another layer type tells it to decode\n   // the next layer with that layer's decoder function\n   // return p.NextDecoder(layers.LayerTypeEthernet)\n\n   // Returning payload type means the rest of the data\n   // is raw payload. It will set the application layer\n   // contents with the payload\n   return p.NextDecoder(gopacket.LayerTypePayload)\n}\n\nfunc main() {\n   // If you create your own encoding and decoding you can essentially\n   // create your own protocol or implement a protocol that is not\n   // already defined in the layers package. In our example we are    \n   // just wrapping a normal ethernet packet with our own layer.\n   // Creating your own protocol is good if you want to create\n   // some obfuscated binary data type that was difficult for others\n   // to decode. Finally, decode your packets:\n   rawBytes := []byte{0xF0, 0x0F, 65, 65, 66, 67, 68}\n   packet := gopacket.NewPacket(\n      rawBytes,\n      CustomLayerType,\n      gopacket.Default,\n   )\n   fmt.Println(\"Created packet out of raw bytes.\")\n   fmt.Println(packet)\n\n   // Decode the packet as our custom layer\n   customLayer := packet.Layer(CustomLayerType)\n   if customLayer != nil {\n      fmt.Println(\"Packet was successfully decoded.\")\n      customLayerContent, _ := customLayer.(*CustomLayer)\n      // Now we can access the elements of the custom struct\n      fmt.Println(\"Payload: \", customLayerContent.LayerPayload())\n      fmt.Println(\"SomeByte element:\", customLayerContent.SomeByte)\n      fmt.Println(\"AnotherByte element:\",  \n         customLayerContent.AnotherByte)\n   }\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"github.com/google/gopacket\"\n   \"github.com/google/gopacket/layers\"\n)\n\nfunc main() {\n   payload := []byte{2, 4, 6}\n   options := gopacket.SerializeOptions{}\n   buffer := gopacket.NewSerializeBuffer()\n   gopacket.SerializeLayers(buffer, options,\n      &layers.Ethernet{},\n      &layers.IPv4{},\n      &layers.TCP{},\n      gopacket.Payload(payload),\n   )\n   rawBytes := buffer.Bytes()\n\n   // Decode an ethernet packet\n   ethPacket :=\n      gopacket.NewPacket(\n         rawBytes,\n         layers.LayerTypeEthernet,\n         gopacket.Default,\n      )\n\n   // with Lazy decoding it will only decode what it needs when it \n   //needs it\n   // This is not concurrency safe. If using concurrency, use default\n   ipPacket :=\n      gopacket.NewPacket(\n         rawBytes,\n         layers.LayerTypeIPv4,\n         gopacket.Lazy,\n      )\n\n   // With the NoCopy option, the underlying slices are referenced\n   // directly and not copied. If the underlying bytes change so will\n   // the packet\n   tcpPacket :=\n      gopacket.NewPacket(\n         rawBytes,\n         layers.LayerTypeTCP,\n         gopacket.NoCopy,\n      )\n\n   fmt.Println(ethPacket)\n   fmt.Println(ipPacket)\n   fmt.Println(tcpPacket)\n}\n```", "```go\npackage main\n\nimport (\n   \"github.com/google/gopacket\"\n   \"github.com/google/gopacket/layers\"\n   \"github.com/google/gopacket/pcap\"\n   \"log\"\n   \"net\"\n   \"time\"\n)\n\nvar (\n   device            = \"eth0\"\n   snapshotLen int32 = 1024\n   promiscuous       = false\n   err         error\n   timeout     = 30 * time.Second\n   handle      *pcap.Handle\n   buffer      gopacket.SerializeBuffer\n   options     gopacket.SerializeOptions\n)\n\nfunc main() {\n   // Open device\n   handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, \n      timeout)\n   if err != nil {\n      log.Fatal(\"Error opening device. \", err)\n   }\n   defer handle.Close()\n\n   // Send raw bytes over wire\n   rawBytes := []byte{10, 20, 30}\n   err = handle.WritePacketData(rawBytes)\n   if err != nil {\n      log.Fatal(\"Error writing bytes to network device. \", err)\n   }\n\n   // Create a properly formed packet, just with\n   // empty details. Should fill out MAC addresses,\n   // IP addresses, etc.\n   buffer = gopacket.NewSerializeBuffer()\n   gopacket.SerializeLayers(buffer, options,\n      &layers.Ethernet{},\n      &layers.IPv4{},\n      &layers.TCP{},\n      gopacket.Payload(rawBytes),\n   )\n   outgoingPacket := buffer.Bytes()\n   // Send our packet\n   err = handle.WritePacketData(outgoingPacket)\n   if err != nil {\n      log.Fatal(\"Error sending packet to network device. \", err)\n   }\n\n   // This time lets fill out some information\n   ipLayer := &layers.IPv4{\n      SrcIP: net.IP{127, 0, 0, 1},\n      DstIP: net.IP{8, 8, 8, 8},\n   }\n   ethernetLayer := &layers.Ethernet{\n      SrcMAC: net.HardwareAddr{0xFF, 0xAA, 0xFA, 0xAA, 0xFF, 0xAA},\n      DstMAC: net.HardwareAddr{0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD},\n   }\n   tcpLayer := &layers.TCP{\n      SrcPort: layers.TCPPort(4321),\n      DstPort: layers.TCPPort(80),\n   }\n   // And create the packet with the layers\n   buffer = gopacket.NewSerializeBuffer()\n   gopacket.SerializeLayers(buffer, options,\n      ethernetLayer,\n      ipLayer,\n      tcpLayer,\n      gopacket.Payload(rawBytes),\n   )\n   outgoingPacket = buffer.Bytes()\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"github.com/google/gopacket\"\n   \"github.com/google/gopacket/layers\"\n   \"github.com/google/gopacket/pcap\"\n   \"log\"\n   \"time\"\n)\n\nvar (\n   device            = \"eth0\"\n   snapshotLen int32 = 1024\n   promiscuous       = false\n   err         error\n   timeout     = 30 * time.Second\n   handle      *pcap.Handle\n   // Reuse these for each packet\n   ethLayer layers.Ethernet\n   ipLayer  layers.IPv4\n   tcpLayer layers.TCP\n)\n\nfunc main() {\n   // Open device\n   handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, \n   timeout)\n   if err != nil {\n      log.Fatal(err)\n   }\n   defer handle.Close()\n\n   packetSource := gopacket.NewPacketSource(handle, handle.LinkType())\n   for packet := range packetSource.Packets() {\n      parser := gopacket.NewDecodingLayerParser(\n         layers.LayerTypeEthernet,\n         &ethLayer,\n         &ipLayer,\n         &tcpLayer,\n      )\n      foundLayerTypes := []gopacket.LayerType{}\n\n      err := parser.DecodeLayers(packet.Data(), &foundLayerTypes)\n      if err != nil {\n         fmt.Println(\"Trouble decoding layers: \", err)\n      }\n\n      for _, layerType := range foundLayerTypes {\n         if layerType == layers.LayerTypeIPv4 {\n            fmt.Println(\"IPv4: \", ipLayer.SrcIP, \"->\", ipLayer.DstIP)\n         }\n         if layerType == layers.LayerTypeTCP {\n            fmt.Println(\"TCP Port: \", tcpLayer.SrcPort,               \n               \"->\", tcpLayer.DstPort)\n            fmt.Println(\"TCP SYN:\", tcpLayer.SYN, \" | ACK:\", \n               tcpLayer.ACK)\n         }\n      }\n   }\n}\n```"]