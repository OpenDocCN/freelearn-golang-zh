["```go\npackage main\n\nimport (\n   \"crypto/md5\"\n   \"crypto/sha1\"\n   \"crypto/sha256\"\n   \"crypto/sha512\"\n   \"fmt\"\n   \"io/ioutil\"\n   \"log\"\n   \"os\"\n)\n\nfunc printUsage() {\n   fmt.Println(\"Usage: \" + os.Args[0] + \" <filepath>\")\n   fmt.Println(\"Example: \" + os.Args[0] + \" document.txt\")\n}\n\nfunc checkArgs() string {\n   if len(os.Args) < 2 {\n      printUsage()\n      os.Exit(1)\n   }\n   return os.Args[1]\n}\n\nfunc main() {\n   filename := checkArgs()\n\n   // Get bytes from file\n   data, err := ioutil.ReadFile(filename)\n   if err != nil {\n      log.Fatal(err)\n   }\n\n   // Hash the file and output results\n   fmt.Printf(\"Md5: %x\\n\\n\", md5.Sum(data))\n   fmt.Printf(\"Sha1: %x\\n\\n\", sha1.Sum(data))\n   fmt.Printf(\"Sha256: %x\\n\\n\", sha256.Sum256(data))\n   fmt.Printf(\"Sha512: %x\\n\\n\", sha512.Sum512(data))\n}\n```", "```go\npackage main\n\nimport (\n   \"crypto/md5\"\n   \"fmt\"\n   \"io\"\n   \"log\"\n   \"os\"\n)\n\nfunc printUsage() {\n   fmt.Println(\"Usage: \" + os.Args[0] + \" <filename>\")\n   fmt.Println(\"Example: \" + os.Args[0] + \" diskimage.iso\")\n}\n\nfunc checkArgs() string {\n   if len(os.Args) < 2 {\n      printUsage()\n      os.Exit(1)\n   }\n   return os.Args[1]\n}\n\nfunc main() {\n   filename := checkArgs()\n\n   // Open file for reading\n   file, err := os.Open(filename)\n   if err != nil {\n      log.Fatal(err)\n   }\n   defer file.Close()\n\n   // Create new hasher, which is a writer interface\n   hasher := md5.New()\n\n   // Default buffer size for copying is 32*1024 or 32kb per copy\n   // Use io.CopyBuffer() if you want to specify the buffer to use\n   // It will write 32kb at a time to the digest/hash until EOF\n   // The hasher implements a Write() function making it satisfy\n   // the writer interface. The Write() function performs the digest\n   // at the time the data is copied/written to it. It digests\n   // and processes the hash one chunk at a time as it is received.\n   _, err = io.Copy(hasher, file)\n   if err != nil {\n      log.Fatal(err)\n   }\n\n   // Now get the final sum or checksum.\n   // We pass nil to the Sum() function because\n   // we already copied the bytes via the Copy to the\n   // writer interface and don't need to pass any new bytes\n   checksum := hasher.Sum(nil)\n\n   fmt.Printf(\"Md5 checksum: %x\\n\", checksum)\n}\n```", "```go\npackage main\n\nimport (\n   \"crypto/hmac\"\n   \"crypto/rand\"\n   \"crypto/sha256\"\n   \"encoding/base64\"\n   \"encoding/hex\"\n   \"fmt\"\n   \"io\"\n   \"os\"\n)\n\nfunc printUsage() {\n   fmt.Println(\"Usage: \" + os.Args[0] + \" <password>\")\n   fmt.Println(\"Example: \" + os.Args[0] + \" Password1!\")\n}\n\nfunc checkArgs() string {\n   if len(os.Args) < 2 {\n      printUsage()\n      os.Exit(1)\n   }\n   return os.Args[1]\n}\n\n// secretKey should be unique, protected, private,\n// and not hard-coded like this. Store in environment var\n// or in a secure configuration file.\n// This is an arbitrary key that should only be used \n// for example purposes.\nvar secretKey = \"neictr98y85klfgneghre\"\n\n// Create a salt string with 32 bytes of crypto/rand data\nfunc generateSalt() string {\n   randomBytes := make([]byte, 32)\n   _, err := rand.Read(randomBytes)\n   if err != nil {\n      return \"\"\n   }\n   return base64.URLEncoding.EncodeToString(randomBytes)\n}\n\n// Hash a password with the salt\nfunc hashPassword(plainText string, salt string) string {\n   hash := hmac.New(sha256.New, []byte(secretKey))\n   io.WriteString(hash, plainText+salt)\n   hashedValue := hash.Sum(nil)\n   return hex.EncodeToString(hashedValue)\n}\n\nfunc main() {\n   // Get the password from command line argument\n   password := checkArgs()\n   salt := generateSalt()\n   hashedPassword := hashPassword(password, salt)\n   fmt.Println(\"Password: \" + password)\n   fmt.Println(\"Salt: \" + salt)\n   fmt.Println(\"Hashed password: \" + hashedPassword)\n}\n```", "```go\npackage main\n\nimport (\n   \"crypto/rand\"\n   \"encoding/binary\"\n   \"fmt\"\n   \"log\"\n   \"math\"\n   \"math/big\"\n)\n\nfunc main() {\n   // Generate a random int\n   limit := int64(math.MaxInt64) // Highest random number allowed\n   randInt, err := rand.Int(rand.Reader, big.NewInt(limit))\n   if err != nil {\n      log.Fatal(err)\n   }\n   fmt.Println(\"Random int value: \", randInt)\n\n   // Alternatively, you could generate the random bytes\n   // and turn them into the specific data type needed.\n   // binary.Read() will only read enough bytes to fill the data type\n   var number uint32\n   err = binary.Read(rand.Reader, binary.BigEndian, &number)\n   if err != nil {\n      log.Fatal(err)\n   }\n   fmt.Println(\"Random uint32 value: \", number)\n\n   // Or just generate a random byte slice\n   numBytes := 4\n   randomBytes := make([]byte, numBytes)\n   rand.Read(randomBytes)\n   fmt.Println(\"Random byte values: \", randomBytes)\n}\n```", "```go\npackage main\n\nimport (\n   \"crypto/aes\"\n   \"crypto/cipher\"\n   \"crypto/rand\"\n   \"fmt\"\n   \"io\"\n   \"io/ioutil\"\n   \"os\"\n   \"log\"\n)\n\nfunc printUsage() {\n   fmt.Printf(os.Args[0] + `\n\nEncrypt or decrypt a file using AES with a 256-bit key file.\nThis program can also generate 256-bit keys.\n\nUsage:\n  ` + os.Args[0] + ` [-h|--help]\n  ` + os.Args[0] + ` [-g|--genkey]\n  ` + os.Args[0] + ` <keyFile> <file> [-d|--decrypt]\n\nExamples:\n  # Generate a 32-byte (256-bit) key\n  ` + os.Args[0] + ` --genkey\n\n  # Encrypt with secret key. Output to STDOUT\n  ` + os.Args[0] + ` --genkey > secret.key\n\n  # Encrypt message using secret key. Output to ciphertext.dat\n  ` + os.Args[0] + ` secret.key message.txt > ciphertext.dat\n\n  # Decrypt message using secret key. Output to STDOUT\n  ` + os.Args[0] + ` secret.key ciphertext.dat -d\n\n  # Decrypt message using secret key. Output to message.txt\n  ` + os.Args[0] + ` secret.key ciphertext.dat -d > cleartext.txt\n`)\n}\n\n// Check command-line arguments.\n// If the help or generate key functions are chosen\n// they are run and then the program exits\n// otherwise it returns keyFile, file, decryptFlag.\nfunc checkArgs() (string, string, bool) {\n   if len(os.Args) < 2  || len(os.Args) > 4 {\n      printUsage()\n      os.Exit(1)\n   }\n\n   // One arg provided\n   if len(os.Args) == 2 {\n      // Only -h, --help and --genkey are valid one-argument uses\n      if os.Args[1] == \"-h\" || os.Args[1] == \"--help\" {\n         printUsage() // Print help text\n         os.Exit(0) // Exit gracefully no error\n      }\n      if os.Args[1] == \"-g\" || os.Args[1] == \"--genkey\" {\n         // Generate a key and print to STDOUT\n         // User should redirect output to a file if needed\n         key := generateKey()\n         fmt.Printf(string(key[:])) // No newline\n         os.Exit(0) // Exit gracefully\n      }\n   }\n\n   // The only use options left is\n   // encrypt <keyFile> <file> [-d|--decrypt]\n   // If there are only 2 args provided, they must be the\n   // keyFile and file without a decrypt flag.\n   if len(os.Args) == 3 {\n      // keyFile, file, decryptFlag\n      return os.Args[1], os.Args[2], false \n   }\n   // If 3 args are provided,\n   // check that the last one is -d or --decrypt\n   if len(os.Args) == 4 {\n      if os.Args[3] != \"-d\" && os.Args[3] != \"--decrypt\" {\n         fmt.Println(\"Error: Unknown usage.\")\n         printUsage()\n         os.Exit(1) // Exit with error code\n      }\n      return os.Args[1], os.Args[2], true\n   }\n    return \"\", \"\", false // Default blank return\n}\n\nfunc generateKey() []byte {\n   randomBytes := make([]byte, 32) // 32 bytes, 256 bit\n   numBytesRead, err := rand.Read(randomBytes)\n   if err != nil {\n      log.Fatal(\"Error generating random key.\", err)\n   }\n   if numBytesRead != 32 {\n      log.Fatal(\"Error generating 32 random bytes for key.\")\n   }\n   return randomBytes\n}\n\n// AES encryption\nfunc encrypt(key, message []byte) ([]byte, error) {\n   // Initialize block cipher\n   block, err := aes.NewCipher(key)\n   if err != nil {\n      return nil, err\n   }\n\n   // Create the byte slice that will hold encrypted message\n   cipherText := make([]byte, aes.BlockSize+len(message))\n\n   // Generate the Initialization Vector (IV) nonce\n   // which is stored at the beginning of the byte slice\n   // The IV is the same length as the AES blocksize\n   iv := cipherText[:aes.BlockSize]\n   _, err = io.ReadFull(rand.Reader, iv)\n   if err != nil {\n      return nil, err\n   }\n\n   // Choose the block cipher mode of operation\n   // Using the cipher feedback (CFB) mode here.\n   // CBCEncrypter also available.\n   cfb := cipher.NewCFBEncrypter(block, iv)\n   // Generate the encrypted message and store it\n   // in the remaining bytes after the IV nonce\n   cfb.XORKeyStream(cipherText[aes.BlockSize:], message)\n\n   return cipherText, nil\n}\n\n// AES decryption\nfunc decrypt(key, cipherText []byte) ([]byte, error) {\n   // Initialize block cipher\n   block, err := aes.NewCipher(key)\n   if err != nil {\n      return nil, err\n   }\n\n   // Separate the IV nonce from the encrypted message bytes\n   iv := cipherText[:aes.BlockSize]\n   cipherText = cipherText[aes.BlockSize:]\n\n   // Decrypt the message using the CFB block mode\n   cfb := cipher.NewCFBDecrypter(block, iv)\n   cfb.XORKeyStream(cipherText, cipherText)\n\n   return cipherText, nil\n}\n\nfunc main() {\n   // if generate key flag, just output a key to stdout and exit\n   keyFile, file, decryptFlag := checkArgs()\n\n   // Load key from file\n   keyFileData, err := ioutil.ReadFile(keyFile)\n   if err != nil {\n      log.Fatal(\"Unable to read key file contents.\", err)\n   }\n\n   // Load file to be encrypted or decrypted\n   fileData, err := ioutil.ReadFile(file)\n   if err != nil {\n      log.Fatal(\"Unable to read key file contents.\", err)\n   }\n\n   // Perform encryption unless the decryptFlag was provided\n   // Outputs to STDOUT. User can redirect output to file.\n   if decryptFlag {\n      message, err := decrypt(keyFileData, fileData)\n      if err != nil {\n         log.Fatal(\"Error decrypting. \", err)\n      }\n      fmt.Printf(\"%s\", message)\n   } else {\n      cipherText, err := encrypt(keyFileData, fileData)\n      if err != nil {\n         log.Fatal(\"Error encrypting. \", err)\n      }\n      fmt.Printf(\"%s\", cipherText)\n   }\n}\n```", "```go\n# Generate the private key  \nopenssl genrsa -out priv.pem 2048 \n# Extract the public key from the private key \nopenssl rsa -in priv.pem -pubout -out public.pem \n```", "```go\npackage main\n\nimport (\n   \"crypto/rand\"\n   \"crypto/rsa\"\n   \"crypto/x509\"\n   \"encoding/pem\"\n   \"fmt\"\n   \"log\"\n   \"os\"\n   \"strconv\"\n)\n\nfunc printUsage() {\n   fmt.Printf(os.Args[0] + `\n\nGenerate a private and public RSA keypair and save as PEM files.\nIf no key size is provided, a default of 2048 is used.\n\nUsage:\n  ` + os.Args[0] + ` <private_key_filename> <public_key_filename>       [keysize]\n\nExamples:\n  # Store generated private and public key in privkey.pem and   pubkey.pem\n  ` + os.Args[0] + ` priv.pem pub.pem\n  ` + os.Args[0] + ` priv.pem pub.pem 4096`)\n}\n\nfunc checkArgs() (string, string, int) {\n   // Too many or too few arguments\n   if len(os.Args) < 3 || len(os.Args) > 4 {\n      printUsage()\n      os.Exit(1)\n   }\n\n   defaultKeySize := 2048\n\n   // If there are 2 args provided, privkey and pubkey filenames\n   if len(os.Args) == 3 {\n      return os.Args[1], os.Args[2], defaultKeySize\n   }\n\n   // If 3 args provided, privkey, pubkey, keysize\n   if len(os.Args) == 4 {\n      keySize, err := strconv.Atoi(os.Args[3])\n      if err != nil {\n         printUsage()\n         fmt.Println(\"Invalid keysize. Try 1024 or 2048.\")\n         os.Exit(1)\n      }\n      return os.Args[1], os.Args[2], keySize\n   }\n\n   return \"\", \"\", 0 // Default blank return catch-all\n}\n\n// Encode the private key as a PEM file\n// PEM is a base-64 encoding of the key\nfunc getPrivatePemFromKey(privateKey *rsa.PrivateKey) *pem.Block {\n   encodedPrivateKey := x509.MarshalPKCS1PrivateKey(privateKey)\n   var privatePem = &pem.Block {\n      Type: \"RSA PRIVATE KEY\",\n      Bytes: encodedPrivateKey,\n   }\n   return privatePem\n}\n\n// Encode the public key as a PEM file\nfunc generatePublicPemFromKey(publicKey rsa.PublicKey) *pem.Block {\n   encodedPubKey, err := x509.MarshalPKIXPublicKey(&publicKey)\n   if err != nil {\n      log.Fatal(\"Error marshaling PKIX pubkey. \", err)\n   }\n\n   // Create a public PEM structure with the data\n   var publicPem = &pem.Block{\n      Type:  \"PUBLIC KEY\",\n      Bytes: encodedPubKey,\n   }\n   return publicPem\n}\n\nfunc savePemToFile(pemBlock *pem.Block, filename string) {\n   // Save public pem to file\n   publicPemOutputFile, err := os.Create(filename)\n   if err != nil {\n      log.Fatal(\"Error opening pubkey output file. \", err)\n   }\n   defer publicPemOutputFile.Close()\n\n   err = pem.Encode(publicPemOutputFile, pemBlock)\n   if err != nil {\n      log.Fatal(\"Error encoding public PEM. \", err)\n   }\n}\n\n// Generate a public and private RSA key in PEM format\nfunc main() {\n   privatePemFilename, publicPemFilename, keySize := checkArgs()\n\n   // Generate private key\n   privateKey, err := rsa.GenerateKey(rand.Reader, keySize)\n   if err != nil {\n      log.Fatal(\"Error generating private key. \", err)\n   }\n\n   // Encode keys to PEM format\n   privatePem := getPrivatePemFromKey(privateKey)\n   publicPem := generatePublicPemFromKey(privateKey.PublicKey)\n\n   // Save the PEM output to files\n   savePemToFile(privatePem, privatePemFilename)\n   savePemToFile(publicPem, publicPemFilename)\n\n   // Print the public key to STDOUT for convenience\n   fmt.Printf(\"%s\", pem.EncodeToMemory(publicPem))\n}\n```", "```go\npackage main\n\nimport (\n   \"crypto\"\n   \"crypto/rand\"\n   \"crypto/rsa\"\n   \"crypto/sha256\"\n   \"crypto/x509\"\n   \"encoding/pem\"\n   \"fmt\"\n   \"io/ioutil\"\n   \"log\"\n   \"os\"\n)\n\nfunc printUsage() {\n   fmt.Println(os.Args[0] + `\n\nCryptographically sign a message using a private key.\nPrivate key should be a PEM encoded RSA key.\nSignature is generated using SHA256 hash.\nOutput signature is stored in filename provided.\n\nUsage:\n  ` + os.Args[0] + ` <privateKeyFilename> <messageFilename>   <signatureFilename>\n\nExample:\n  # Use priv.pem to encrypt msg.txt and output to sig.txt.256\n  ` + os.Args[0] + ` priv.pem msg.txt sig.txt.256\n`)\n}\n\n// Get arguments from command line\nfunc checkArgs() (string, string, string) {\n   // Need exactly 3 arguments provided\n   if len(os.Args) != 4 {\n      printUsage()\n      os.Exit(1)\n   }\n\n   // Private key file name and message file name\n   return os.Args[1], os.Args[2], os.Args[3]\n}\n\n// Cryptographically sign a message= creating a digital signature\n// of the original message. Uses SHA-256 hashing.\nfunc signMessage(privateKey *rsa.PrivateKey, message []byte) []byte {\n   hashed := sha256.Sum256(message)\n\n   signature, err := rsa.SignPKCS1v15(\n      rand.Reader,\n      privateKey,\n      crypto.SHA256,\n      hashed[:],\n   )\n   if err != nil {\n      log.Fatal(\"Error signing message. \", err)\n   }\n\n   return signature\n}\n\n// Load the message that will be signed from file\nfunc loadMessageFromFile(messageFilename string) []byte {\n   fileData, err := ioutil.ReadFile(messageFilename)\n   if err != nil {\n      log.Fatal(err)\n   }\n   return fileData\n}\n\n// Load the RSA private key from a PEM encoded file\nfunc loadPrivateKeyFromPemFile(privateKeyFilename string) *rsa.PrivateKey {\n   // Quick load file to memory\n   fileData, err := ioutil.ReadFile(privateKeyFilename)\n   if err != nil {\n      log.Fatal(err)\n   }\n\n   // Get the block data from the PEM encoded file\n   block, _ := pem.Decode(fileData)\n   if block == nil || block.Type != \"RSA PRIVATE KEY\" {\n      log.Fatal(\"Unable to load a valid private key.\")\n   }\n\n   // Parse the bytes and put it in to a proper privateKey struct\n   privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)\n   if err != nil {\n      log.Fatal(\"Error loading private key.\", err)\n   }\n\n   return privateKey\n}\n\n// Save data to file\nfunc writeToFile(filename string, data []byte) error {\n   // Open a new file for writing only\n   file, err := os.OpenFile(\n      filename,\n      os.O_WRONLY|os.O_TRUNC|os.O_CREATE,\n      0666,\n   )\n   if err != nil {\n      return err\n   }\n   defer file.Close()\n\n   // Write bytes to file\n   _, err = file.Write(data)\n   if err != nil {\n      return err\n   }\n\n   return nil\n}\n\n// Sign a message using a private RSA key\nfunc main() {\n   // Get arguments from command line\n   privateKeyFilename, messageFilename, sigFilename := checkArgs()\n\n   // Load message and private key files from disk\n   message := loadMessageFromFile(messageFilename)\n   privateKey := loadPrivateKeyFromPemFile(privateKeyFilename)\n\n   // Cryptographically sign the message\n   signature := signMessage(privateKey, message)\n\n   // Output to file\n   writeToFile(sigFilename, signature)\n}\n```", "```go\npackage main\n\nimport (\n   \"crypto\"\n   \"crypto/rsa\"\n   \"crypto/sha256\"\n   \"crypto/x509\"\n   \"encoding/pem\"\n   \"fmt\"\n   \"io/ioutil\"\n   \"log\"\n   \"os\"\n)\n\nfunc printUsage() {\n    fmt.Println(os.Args[0] + `\n\nVerify an RSA signature of a message using SHA-256 hashing.\nPublic key is expected to be a PEM file.\n\nUsage:\n  ` + os.Args[0] + ` <publicKeyFilename> <signatureFilename> <messageFilename>\n\nExample:\n  ` + os.Args[0] + ` pubkey.pem signature.txt message.txt\n`)\n}\n\n// Get arguments from command line\nfunc checkArgs() (string, string, string) {\n   // Expect 3 arguments: pubkey, signature, message file names\n   if len(os.Args) != 4 {\n      printUsage()\n      os.Exit(1)\n   }\n\n   return os.Args[1], os.Args[2], os.Args[3]\n}\n\n// Returns bool whether signature was verified\nfunc verifySignature(\n   signature []byte,\n   message []byte,\n   publicKey *rsa.PublicKey) bool {\n\n   hashedMessage := sha256.Sum256(message)\n\n   err := rsa.VerifyPKCS1v15(\n      publicKey,\n      crypto.SHA256,\n      hashedMessage[:],\n      signature,\n   )\n\n   if err != nil {\n      log.Println(err)\n      return false\n   }\n   return true // If no error, match.\n}\n\n// Load file to memory\nfunc loadFile(filename string) []byte {\n   fileData, err := ioutil.ReadFile(filename)\n   if err != nil {\n      log.Fatal(err)\n   }\n   return fileData\n}\n\n// Load a public RSA key from a PEM encoded file\nfunc loadPublicKeyFromPemFile(publicKeyFilename string) *rsa.PublicKey {\n   // Quick load file to memory\n   fileData, err := ioutil.ReadFile(publicKeyFilename)\n   if err != nil {\n      log.Fatal(err)\n   }\n\n   // Get the block data from the PEM encoded file\n   block, _ := pem.Decode(fileData)\n   if block == nil || block.Type != \"PUBLIC KEY\" {\n      log.Fatal(\"Unable to load valid public key. \")\n   }\n\n   // Parse the bytes and store in a public key format\n   publicKey, err := x509.ParsePKIXPublicKey(block.Bytes)\n   if err != nil {\n      log.Fatal(\"Error loading public key. \", err)\n   }\n\n   return publicKey.(*rsa.PublicKey) // Cast interface to PublicKey\n}\n\n// Verify a cryptographic signature using RSA PKCS#1 v1.5 with SHA-256\n// and a PEM encoded PKIX public key.\nfunc main() {\n   // Parse command line arguments\n   publicKeyFilename, signatureFilename, messageFilename :=   \n      checkArgs()\n\n   // Load all the files from disk\n   publicKey := loadPublicKeyFromPemFile(publicKeyFilename)\n   signature := loadFile(signatureFilename)\n   message := loadFile(messageFilename)\n\n   // Verify signature\n   valid := verifySignature(signature, message, publicKey)\n\n   if valid {\n      fmt.Println(\"Signature verified.\")\n   } else {\n      fmt.Println(\"Signature could not be verified.\")\n   }\n}\n```", "```go\nfunc CreateCertificate (rand io.Reader, template, parent *Certificate, pub, \n   priv interface{}) (cert []byte, err error)\n```", "```go\npackage main\n\nimport (\n   \"crypto/rand\"\n   \"crypto/rsa\"\n   \"crypto/x509/pkix\"\n   \"crypto/x509\"\n   \"encoding/pem\"\n   \"fmt\"\n   \"io/ioutil\"\n   \"log\"\n   \"math/big\"\n   \"net\"\n   \"os\"\n   \"time\"\n)\n\nfunc printUsage() {\n   fmt.Println(os.Args[0] + ` - Generate a self signed TLS certificate\n\nUsage:\n  ` + os.Args[0] + ` <privateKeyFilename> <certOutputFilename> [-ca|--cert-authority]\n\nExample:\n  ` + os.Args[0] + ` priv.pem cert.pem\n  ` + os.Args[0] + ` priv.pem cacert.pem -ca\n`)\n}\n\nfunc checkArgs() (string, string, bool) {\n   if len(os.Args) < 3 || len(os.Args) > 4 {\n      printUsage()\n      os.Exit(1)\n   }\n\n   // See if the last cert authority option was passed\n   isCA := false // Default\n   if len(os.Args) == 4 {\n      if os.Args[3] == \"-ca\" || os.Args[3] == \"--cert-authority\" {\n         isCA = true\n      }\n   }\n\n   // Private key filename, cert output filename, is cert authority\n   return os.Args[1], os.Args[2], isCA\n}\n\nfunc setupCertificateTemplate(isCA bool) x509.Certificate {\n   // Set valid time frame to start now and end one year from now\n   notBefore := time.Now()\n   notAfter := notBefore.Add(time.Hour * 24 * 365) // 1 year/365 days\n\n   // Generate secure random serial number\n   serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)\n   randomNumber, err := rand.Int(rand.Reader, serialNumberLimit)\n   if err != nil {\n      log.Fatal(\"Error generating random serial number. \", err)\n   }\n\n   nameInfo := pkix.Name{\n      Organization: []string{\"My Organization\"},\n      CommonName: \"localhost\",\n      OrganizationalUnit: []string{\"My Business Unit\"},\n      Country:        []string{\"US\"}, // 2-character ISO code\n      Province:       []string{\"Texas\"}, // State\n      Locality:       []string{\"Houston\"}, // City\n   }\n\n   // Create the certificate template\n   certTemplate := x509.Certificate{\n      SerialNumber: randomNumber,\n      Subject: nameInfo,\n      EmailAddresses: []string{\"test@localhost\"},\n      NotBefore: notBefore,\n      NotAfter: notAfter,\n      KeyUsage: x509.KeyUsageKeyEncipherment |   \n         x509.KeyUsageDigitalSignature,\n      // For ExtKeyUsage, default to any, but can specify to use\n      // only as server or client authentication, code signing, etc\n      ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageAny},\n      BasicConstraintsValid: true,\n      IsCA: false,\n   }\n\n   // To create a certificate authority that can sign cert signing   \n   // requests, set these\n   if isCA {\n      certTemplate.IsCA = true\n      certTemplate.KeyUsage = certTemplate.KeyUsage |  \n         x509.KeyUsageCertSign\n   }\n\n   // Add any IP addresses and hostnames covered by this cert\n   // This example only covers localhost\n   certTemplate.IPAddresses = []net.IP{net.ParseIP(\"127.0.0.1\")}\n   certTemplate.DNSNames = []string{\"localhost\", \"localhost.local\"}\n\n   return certTemplate\n}\n\n// Load the RSA private key from a PEM encoded file\nfunc loadPrivateKeyFromPemFile(privateKeyFilename string) *rsa.PrivateKey {\n   // Quick load file to memory\n   fileData, err := ioutil.ReadFile(privateKeyFilename)\n   if err != nil {\n      log.Fatal(\"Error loading private key file. \", err)\n   }\n\n   // Get the block data from the PEM encoded file\n   block, _ := pem.Decode(fileData)\n   if block == nil || block.Type != \"RSA PRIVATE KEY\" {\n      log.Fatal(\"Unable to load a valid private key.\")\n   }\n\n   // Parse the bytes and put it in to a proper privateKey struct\n   privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)\n   if err != nil {\n      log.Fatal(\"Error loading private key. \", err)\n   }\n\n   return privateKey\n}\n\n// Save the certificate as a PEM encoded file\nfunc writeCertToPemFile(outputFilename string, derBytes []byte ) {\n   // Create a PEM from the certificate\n   certPem := &pem.Block{Type: \"CERTIFICATE\", Bytes: derBytes}\n\n   // Open file for writing\n   certOutfile, err := os.Create(outputFilename)\n   if err != nil {\n      log.Fatal(\"Unable to open certificate output file. \", err)\n   }\n   pem.Encode(certOutfile, certPem)\n   certOutfile.Close()\n}\n\n// Create a self-signed TLS/SSL certificate for localhost \n// with an RSA private key\nfunc main() {\n   privPemFilename, certOutputFilename, isCA := checkArgs()\n\n   // Private key of signer - self signed means signer==signee\n   privKey := loadPrivateKeyFromPemFile(privPemFilename)\n\n   // Public key of signee. Self signing means we are the signer and    \n   // the signee so we can just pull our public key from our private key\n   pubKey := privKey.PublicKey\n\n   // Set up all the certificate info\n   certTemplate := setupCertificateTemplate(isCA)\n\n   // Create (and sign with the priv key) the certificate\n   certificate, err := x509.CreateCertificate(\n      rand.Reader,\n      &certTemplate,\n      &certTemplate,\n      &pubKey,\n      privKey,\n   )\n   if err != nil {\n      log.Fatal(\"Failed to create certificate. \", err)\n   }\n\n   // Format the certificate as a PEM and write to file\n   writeCertToPemFile(certOutputFilename, certificate)\n}\n```", "```go\n# Create CSR \nopenssl req -new -key priv.pem -out csr.pem \n# View details to verify request was created properly \nopenssl req -verify -in csr.pem -text -noout \n```", "```go\npackage main\n\nimport (\n   \"crypto/rand\"\n   \"crypto/rsa\"\n   \"crypto/x509\"\n   \"crypto/x509/pkix\"\n   \"encoding/pem\"\n   \"fmt\"\n   \"io/ioutil\"\n   \"log\"\n   \"net\"\n   \"os\"\n)\n\nfunc printUsage() {\n   fmt.Println(os.Args[0] + ` - Create a certificate signing request  \n   with a private key.\n\nPrivate key is expected in PEM format. Certificate valid for localhost only.\nCertificate signing request is created using the SHA-256 hash.\n\nUsage:\n  ` + os.Args[0] + ` <privateKeyFilename> <csrOutputFilename>\n\nExample:\n  ` + os.Args[0] + ` priv.pem csr.pem\n`)\n}\n\nfunc checkArgs() (string, string) {\n   if len(os.Args) != 3 {\n      printUsage()\n      os.Exit(1)\n   }\n\n   // Private key filename, cert signing request output filename\n   return os.Args[1], os.Args[2]\n}\n\n// Load the RSA private key from a PEM encoded file\nfunc loadPrivateKeyFromPemFile(privateKeyFilename string) *rsa.PrivateKey {\n   // Quick load file to memory\n   fileData, err := ioutil.ReadFile(privateKeyFilename)\n   if err != nil {\n      log.Fatal(\"Error loading private key file. \", err)\n   }\n\n   // Get the block data from the PEM encoded file\n   block, _ := pem.Decode(fileData)\n   if block == nil || block.Type != \"RSA PRIVATE KEY\" {\n      log.Fatal(\"Unable to load a valid private key.\")\n   }\n\n   // Parse the bytes and put it in to a proper privateKey struct\n   privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)\n   if err != nil {\n      log.Fatal(\"Error loading private key.\", err)\n   }\n\n   return privateKey\n}\n\n// Create a CSR PEM and save to file\nfunc saveCSRToPemFile(csr []byte, filename string) {\n   csrPem := &pem.Block{\n      Type:  \"CERTIFICATE REQUEST\",\n      Bytes: csr,\n   }\n   csrOutfile, err := os.Create(filename)\n   if err != nil {\n      log.Fatal(\"Error opening \"+filename+\" for saving. \", err)\n   }\n   pem.Encode(csrOutfile, csrPem)\n}\n\n// Create a certificate signing request with a private key \n// valid for localhost\nfunc main() {\n   // Load parameters\n   privKeyFilename, csrOutFilename := checkArgs()\n   privKey := loadPrivateKeyFromPemFile(privKeyFilename)\n\n   // Prepare information about organization the cert will belong to\n   nameInfo := pkix.Name{\n      Organization:       []string{\"My Organization Name\"},\n      CommonName:         \"localhost\",\n      OrganizationalUnit: []string{\"Business Unit Name\"},\n      Country:            []string{\"US\"}, // 2-character ISO code\n      Province:           []string{\"Texas\"},\n      Locality:           []string{\"Houston\"}, // City\n   }\n\n   // Prepare CSR template\n   csrTemplate := x509.CertificateRequest{\n      Version:            2, // Version 3, zero-indexed values\n      SignatureAlgorithm: x509.SHA256WithRSA,\n      PublicKeyAlgorithm: x509.RSA,\n      PublicKey:          privKey.PublicKey,\n      Subject:            nameInfo,\n\n      // Subject Alternate Name values.\n      DNSNames:       []string{\"Business Unit Name\"},\n      EmailAddresses: []string{\"test@localhost\"},\n      IPAddresses:    []net.IP{},\n   }\n\n   // Create the CSR based off the template\n   csr, err := x509.CreateCertificateRequest(rand.Reader,  \n      &csrTemplate, privKey)\n   if err != nil {\n      log.Fatal(\"Error creating certificate signing request. \", err)\n   }\n   saveCSRToPemFile(csr, csrOutFilename)\n}\n```", "```go\nfunc CreateCertificate(rand io.Reader, template, parent *Certificate, pub, \n   priv interface{}) (cert []byte, err error)\n```", "```go\n# Create signed certificate using\n# the CSR, CA certificate, and private key \nopenssl x509 -req -in csr.pem -CA cacert.pem \\\n-CAkey capriv.pem -CAcreateserial \\\n-out cert.pem -sha256\n# Print info about cert \nopenssl x509 -in cert.pem -text -noout  \n```", "```go\npackage main\n\nimport (\n   \"bufio\"\n   \"crypto/tls\"\n   \"fmt\"\n   \"log\"\n   \"net\"\n   \"os\"\n)\n\nfunc printUsage() {\n   fmt.Println(os.Args[0] + ` - Start a TLS echo server\n\nServer will echo one message received back to client.\nProvide a certificate and private key file in PEM format.\nHost string in the format: hostname:port\n\nUsage:\n  ` + os.Args[0] + ` <certFilename> <privateKeyFilename> <hostString>\n\nExample:\n  ` + os.Args[0] + ` cert.pem priv.pem localhost:9999\n`)\n}\n\nfunc checkArgs() (string, string, string) {\n  if len(os.Args) != 4 {\n     printUsage()\n     os.Exit(1)\n  }\n\n  return os.Args[1], os.Args[2], os.Args[3]\n}\n\n// Create a TLS listener and echo back data received by clients.\nfunc main() {\n   certFilename, privKeyFilename, hostString := checkArgs()\n\n   // Load the certificate and private key\n   serverCert, err := tls.LoadX509KeyPair(certFilename, privKeyFilename)\n   if err != nil {\n      log.Fatal(\"Error loading certificate and private key. \", err)\n   }\n\n   // Set up certificates, host/ip, and port\n   config := &tls.Config{\n      // Specify server certificate\n      Certificates: []tls.Certificate{serverCert},\n\n      // By default no client certificate is required.\n      // To require and validate client certificates, specify the\n      // ClientAuthType to be one of:\n      //    NoClientCert, RequestClientCert, RequireAnyClientCert,\n      //    VerifyClientCertIfGiven, RequireAndVerifyClientCert)\n\n      // ClientAuth: tls.RequireAndVerifyClientCert\n\n      // Define the list of certificates you will accept as\n      // trusted certificate authorities with ClientCAs.\n\n      // ClientCAs: *x509.CertPool\n   }\n\n   // Create the TLS socket listener\n   listener, err := tls.Listen(\"tcp\", hostString, config)\n   if err != nil {\n      log.Fatal(\"Error starting TLS listener. \", err)\n   }\n   defer listener.Close()\n\n   // Listen forever for connections\n   for {\n      clientConnection, err := listener.Accept()\n      if err != nil {\n         log.Println(\"Error accepting client connection. \", err)\n         continue\n      }\n      // Launch a goroutine(thread)go-1.6 to handle each connection\n      go handleConnection(clientConnection)\n   }\n}\n\n// Function that gets launched in a goroutine to handle client connection\nfunc handleConnection(clientConnection net.Conn) {\n   defer clientConnection.Close()\n   socketReader := bufio.NewReader(clientConnection)\n   for {\n      // Read a message from the client\n      message, err := socketReader.ReadString('\\n')\n      if err != nil {\n         log.Println(\"Error reading from client socket. \", err)\n         return\n      }\n      fmt.Println(message)\n\n      // Echo back the data to the client.\n      numBytesWritten, err := clientConnection.Write([]byte(message))\n      if err != nil {\n         log.Println(\"Error writing data to client socket. \", err)\n         return\n      }\n      fmt.Printf(\"Wrote %d bytes back to client.\\n\", numBytesWritten)\n   }\n}\n```", "```go\npackage main\n\nimport (\n   \"crypto/tls\"\n   \"fmt\"\n   \"log\"\n   \"os\"\n)\n\nfunc printUsage() {\n   fmt.Println(os.Args[0] + ` - Send and receive a message to a TLS server\n\nUsage:\n  ` + os.Args[0] + ` <hostString>\n\nExample:\n  ` + os.Args[0] + ` localhost:9999\n`)\n}\n\nfunc checkArgs() string {\n   if len(os.Args) != 2 {\n      printUsage()\n      os.Exit(1)\n   }\n\n   // Host string e.g. localhost:9999\n   return os.Args[1]\n}\n\n// Simple TLS client that sends a message and receives a message\nfunc main() {\n   hostString := checkArgs()\n   messageToSend := \"Hello?\\n\"\n\n   // Configure TLS settings\n   tlsConfig := &tls.Config{\n      // Required to accept self-signed certs\n      InsecureSkipVerify: true, \n      // Provide your client certificate if necessary\n      // Certificates: []Certificate\n\n      // ServerName is used to verify the hostname (unless you are     \n      // skipping verification)\n      // It is also included in the handshake in case the server uses   \n      // virtual hosts Can also just be an IP address \n      // instead of a hostname.\n      // ServerName: string,\n\n      // RootCAs that you are willing to accept\n      // If RootCAs is nil, the host's default root CAs are used\n      // RootCAs: *x509.CertPool\n   }\n\n   // Set up dialer and call the server\n   connection, err := tls.Dial(\"tcp\", hostString, tlsConfig)\n   if err != nil {\n      log.Fatal(\"Error dialing server. \", err)\n   }\n   defer connection.Close()\n\n   // Write data to socket\n   numBytesWritten, err := connection.Write([]byte(messageToSend))\n   if err != nil {\n      log.Println(\"Error writing to socket. \", err)\n      os.Exit(1)\n   }\n   fmt.Printf(\"Wrote %d bytes to the socket.\\n\", numBytesWritten)\n\n   // Read data from socket and print to STDOUT\n   buffer := make([]byte, 100)\n   numBytesRead, err := connection.Read(buffer)\n   if err != nil {\n      log.Println(\"Error reading from socket. \", err)\n      os.Exit(1)\n   }\n   fmt.Printf(\"Read %d bytes to the socket.\\n\", numBytesRead)\n   fmt.Printf(\"Message received:\\n%s\\n\", buffer)\n}\n```"]