- en: Cryptography
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学
- en: Cryptography is the practice of securing communications even when a third-party
    can view those communications. There are two-way symmetric and asymmetric encryption
    methods, as well as one-way hashing algorithms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是一种在第三方可以查看通信时保护通信的实践。有双向对称和非对称加密方法，以及单向哈希算法。
- en: Encryption is a critical part of the modern internet. With services such as [LetsEncrypt.com](http://www.LetsEncrypt.com),
    everyone has access to trusted SSL certificates. Our entire infrastructure relies
    on and trusts encryption to work to keep all our confidential data secret. It
    is important to properly encrypt and hash data correctly, and it is easy to misconfigure
    a service, leaving it vulnerable or exposed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是现代互联网的关键部分。有了[LetsEncrypt.com](http://www.LetsEncrypt.com)等服务，每个人都可以获得受信任的SSL证书。我们的整个基础设施都依赖于加密来保护所有机密数据。正确加密和正确哈希数据非常重要，而且很容易配置错误的服务，使其容易受到攻击或暴露。
- en: 'This chapter covers examples and use cases for the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下示例和用例：
- en: Symmetric and asymmetric encryption
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称和非对称加密
- en: Signing and verifying messages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名和验证消息
- en: Hashing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希处理
- en: Storing passwords securely
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全存储密码
- en: Generating secure random numbers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成安全的随机数
- en: Creating and using TLS/SSL certificates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用TLS/SSL证书
- en: Hashing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希处理
- en: Hashing is when a variable length message is transformed into a unique fixed-length
    alphanumeric string. There are various hashing algorithms available, such as MD5
    and SHA1\. Hashes are one-way and non-invertible, unlike symmetric encryption
    functions, such as AES, which can recover the original message if you have the
    key. Because hashes cannot be reversed, most of them are cracked by brute force.
    Crackers will build power-sucking rigs with several GPUs to hash every possible
    character combination until they find a hash that matches. They will also generate
    rainbow tables or files containing all of the hash outputs generated for quick
    lookup.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是将可变长度消息转换为唯一的固定长度的字母数字字符串。有各种可用的哈希算法，如MD5和SHA1。哈希是单向且不可逆的，不像对称加密函数（如AES），如果您有密钥，可以恢复原始消息。由于哈希无法被反转，大多数哈希都会被暴力破解。破解者将构建功耗巨大的装置，配备多个GPU，以对每个可能的字符组合进行哈希，直到找到与之匹配的哈希。他们还会生成彩虹表或包含所有已生成哈希输出的文件，以进行快速查找。
- en: Salting your hashes is important for this reason. Salting is the process of
    adding a random string to the end of the password, provided by a user, to add
    more randomness or entropy. Consider an application that stores user login information
    and hashed passwords for authentication. If two users had the same password, then
    their hash output would be identical. Without salts, a cracker might find multiple
    people who use the same password and would only need to crack the hash one time.
    By adding a unique salt to each user's password, you ensure that each user has
    a unique hash value. Salting reduces the effectiveness of rainbow tables because,
    even if they knew the salt that goes with each hash, they would have to generate
    a rainbow able to each salt, which is time consuming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对哈希进行加盐很重要。加盐是向用户提供的密码末尾添加随机字符串的过程，以增加更多的随机性或熵。考虑一个存储用户登录信息和哈希密码以进行身份验证的应用程序。如果两个用户使用相同的密码，则它们的哈希输出将相同。没有盐，破解者可能会找到多个使用相同密码的人，并且只需要破解一次哈希。通过为每个用户的密码添加唯一的盐，您确保每个用户都具有唯一的哈希值。加盐减少了彩虹表的有效性，因为即使他们知道与每个哈希相关的盐，他们也必须为每个盐生成一个彩虹表，这是耗时的。
- en: Hashes are commonly used to validate passwords. Another common use is for file
    integrity. Large downloads often come with an MD5 or SHA1 hash of the file. After
    downloading you can hash the file to make sure that it matches the expected value.
    If it doesn't match, then the download was modified in some way. Hashing is also
    used as a way of recording indicators of compromise or IOCs. Files that are known
    to be malicious or dangerous are hashed, and that hash is stored in a catalog.
    These are often shared publicly so people can check suspicious files against known
    risks. It is much more efficient to store and compare a hash than the entire file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希通常用于验证密码。另一个常见用途是用于文件完整性。大型下载通常附带文件的MD5或SHA1哈希。下载后，您可以对文件进行哈希处理，以确保其与预期值匹配。如果不匹配，则下载文件已被修改。哈希还用作记录妥协指标或IOC的一种方式。已知恶意或危险的文件会被哈希处理，并且该哈希将存储在目录中。这些通常是公开共享的，以便人们可以检查可疑文件是否存在已知风险。与整个文件相比，存储和比较哈希要高效得多。
- en: Hashing small files
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对小文件进行哈希处理
- en: 'If a file is small enough to be contained in memory, the `ReadFile()` method
    works quickly. It loads the whole file into memory and then digests the data.
    The sum will be calculated with multiple different hash algorithms for demonstration:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件小到可以包含在内存中，`ReadFile()`方法可以快速工作。它将整个文件加载到内存中，然后对数据进行摘要。将使用多种不同的哈希算法进行计算：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Hashing large files
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对大文件进行哈希处理
- en: 'In the previous hashing example, the entire file to be hashed was loaded into
    memory before hashing. This is not practical or even possible when files reach
    a certain size. Physical memory limitations will come into play. Because the hashes
    are implemented as a block cipher, it will operate on one chunk at a time without
    the need to load the entire file in memory at once:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的哈希示例中，要进行哈希处理的整个文件在哈希之前被加载到内存中。当文件达到一定大小时，这是不切实际甚至不可能的。物理内存限制将起作用。因为哈希是作为块密码实现的，它将一次操作一个块，而无需一次性将整个文件加载到内存中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Storing passwords securely
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全存储密码
- en: Now that we know how to hash, we can talk about securely storing passwords.
    Hashing is an important factor when it comes to protecting passwords. Other important
    factors are salting, using a cryptographically strong hash function, and the optional
    use of **hash-based message authentication code** (**HMAC**), which all add an
    additional secret key into the hashing algorithm.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何哈希，我们可以谈论安全地存储密码。哈希是保护密码的重要因素。其他重要因素是加盐，使用密码学强哈希函数，以及可选使用**基于哈希的消息认证码**（HMAC），这些都在哈希算法中添加了一个额外的秘密密钥。
- en: HMAC is an added layer that uses a secret key; so, even if an attacker got your
    database of hashed passwords with the salts, they would still have a difficult
    time cracking them without the secret key. The secret key should be stored in
    a separate location such as an environment variable rather than in the database
    with the hashed passwords and salts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: HMAC是一个使用秘钥的附加层；因此，即使攻击者获得了带有盐的哈希密码数据库，没有秘密密钥，他们仍然会很难破解它们。秘密密钥应该存储在一个单独的位置，比如环境变量，而不是与哈希密码和盐一起存储在数据库中。
- en: This example application has limited use as it is. Use it as a reference for
    your own applications
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应用程序的用途有限。将其用作您自己应用程序的参考。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Encryption
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密
- en: Encryption is different from hashing because it is reversible and the original
    message can be recovered. There are symmetric encryption methods that use a password
    or a shared key to encrypt and decrypt. There are also asymmetric encryption algorithms
    that operate with a public and private key pair. AES is an example of symmetric
    encryption, and it is used to encrypt ZIP files, PDF files, or an entire filesystem.
    RSA is an example of asymmetric encryption and is used for SSL, SSH keys, and
    PGP.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 加密与哈希不同，因为它是可逆的，原始消息可以被恢复。有对称加密方法使用密码或共享密钥进行加密和解密。还有非对称加密算法使用公钥和私钥对。AES是对称加密的一个例子，用于加密ZIP文件、PDF文件或整个文件系统。RSA是非对称加密的一个例子，用于SSL、SSH密钥和PGP。
- en: Cryptographically secure pseudo-random number generator (CSPRNG)
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学安全伪随机数生成器（CSPRNG）
- en: The `math` and `rand` packages do not provide the same amount of randomness
    that the `crypto/rand` package offers. Do not use `math/rand` for cryptographic
    applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`和`rand`包提供的随机性不如`crypto/rand`包。不要将`math/rand`用于加密应用。'
- en: Read more about Go's `crypto/rand` package at [https://golang.org/pkg/crypto/rand/](https://golang.org/pkg/crypto/rand/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://golang.org/pkg/crypto/rand/](https://golang.org/pkg/crypto/rand/)上了解更多关于Go的`crypto/rand`包的信息。
- en: 'The following example will demonstrate how to generate random bytes, a random
    integer, or any other signed or unsigned type of integer:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将演示如何生成随机字节、随机整数或任何其他有符号或无符号类型的整数：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Symmetric encryption
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称加密
- en: Symmetric encryption is when the same key or password is used to encrypt and
    decrypt the data. Advanced Encryption Standard, also known as AES or Rijndael,
    is a symmetric encryption algorithm made standard by NIST in 2001.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密是指使用相同的密钥或密码来加密和解密数据。高级加密标准，也称为AES或Rijndael，是NIST在2001年制定的对称加密算法标准。
- en: Data Encryption Standard, or DES, is another symmetric encryption algorithm
    that is older and less secure than AES. It should not be used over AES unless
    there is a specific requirement or specification to do so. Go standard library
    includes AES and DES packages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加密标准（DES）是另一种对称加密算法，比AES更老且不太安全。除非有特定要求或规范，否则不应该使用DES而不是AES。Go标准库包括AES和DES包。
- en: AES
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AES
- en: This program will encrypt and decrypt a file using a key, which is basically
    a 32-byte (256-bit) password.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将使用一个32字节（256位）的密码来加密和解密文件。
- en: When generating a key, encrypting, or decrypting, the output is sent to `STDOUT`
    or the Terminal typically. You can easily redirect the output to a file or another
    program using the `>` operator. Refer to the usage patterns for examples. If you
    need to store the key or the encrypted data as an ASCII encoded string, use base64
    encoding.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成密钥、加密或解密时，输出通常发送到`STDOUT`或终端。您可以使用`>`运算符将输出轻松重定向到文件或另一个程序。请参考用法模式以获取示例。如果需要将密钥或加密数据存储为ASCII编码的字符串，请使用base64编码。
- en: At some point in this example, you will see the message being split into two
    pieces, the IV, and the cipher text. The initialization vector, or IV, is a random
    value that gets prepended to the actual encrypted message. Every time a message
    is encrypted with AES, a random value is generated and used as part of the encryption.
    The random value is called a nonce, which means simply a number that is only used
    once.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中的某个时候，您会看到消息被分成两部分，IV和密文。初始化向量或IV是一个随机值，它被预置到实际加密的消息之前。每次使用AES加密消息时，都会生成并使用一个随机值作为加密的一部分。这个随机值被称为一次性号码，简单地意味着只使用一次的数字。
- en: Why are these one time values created? Especially, if they aren't kept secret
    and are put right in front of the encrypted message, what purpose does it serve?
    The random IV is used in a similar fashion to a salt. It is used primarily so
    that when the same message is encrypted repeatedly, the cipher text is different
    each time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要创建这些一次性值？特别是如果它们不保密，并且直接放在加密消息的前面，它有什么作用？随机IV的使用方式类似于盐。它主要用于当相同的消息被重复加密时，每次的密文都是不同的。
- en: To use **Galois/Counter Mode** (**GCM**) instead of CFB, change the encrypt
    and decrypt methods. GCM has better performance and efficiency because it allows
    parallel processing. Read more about GCM at [https://en.wikipedia.org/wiki/Galois/Counter_Mode](https://en.wikipedia.org/wiki/Galois/Counter_Mode).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用**Galois/Counter Mode**（GCM）而不是CFB，请更改加密和解密方法。GCM具有更好的性能和效率，因为它允许并行处理。在[https://en.wikipedia.org/wiki/Galois/Counter_Mode](https://en.wikipedia.org/wiki/Galois/Counter_Mode)上了解更多关于GCM的信息。
- en: 'Start with an AES cipher and call `cipher.NewCFBEncrypter(block, iv)`. Then
    depending on whether you need to encrypt or decrypt, you will either call `.Seal()` with
    a nonce you generate, or call `.Open()` and pass it the separated nonce and cipher
    text:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从AES密码开始，并调用`cipher.NewCFBEncrypter(block, iv)`。然后根据您是否需要加密或解密，您将使用您生成的nonce调用`.Seal()`，或者调用`.Open()`并传递分离的nonce和密文：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Asymmetric encryption
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非对称加密
- en: Asymmetric is when there are two keys for each party. A public and private key
    pair is required on each side. Asymmetric encryption algorithms include RSA, DSA,
    and ECDSA. The Go standard library has packages for RSA, DSA, and ECDSA. Some
    applications that use asymmetric encryption include **Secure Shell** (**SSH**),
    **Secure Sockets Layer** (**SSL**), and **Pretty Good Privacy** (**PGP**).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个方都有两个密钥时，就是非对称的。每一方都需要一个公钥和私钥对。非对称加密算法包括RSA，DSA和ECDSA。Go标准库中有RSA，DSA和ECDSA的包。一些使用非对称加密的应用包括**安全外壳**（**SSH**），**安全套接字层**（**SSL**）和**很好的隐私**（**PGP**）。
- en: SSL is the **Secure Sockets Layer** originally developed by Netscape, and version
    2 was publicly released in 1995\. It is used to encrypt communication between
    a server and a client providing confidentiality, integrity, and authentication.
    **TLS**, or **Transport Layer Security**, is the new version of SSL, with 1.2
    being defined in 2008 as RFC 5246\. The Go package for TLS does not completely
    implement the specification, but it implements the major parts. Read more about
    Go's `crypto/tls` package at [https://golang.org/pkg/crypto/tls/](https://golang.org/pkg/crypto/tls/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SSL是由网景公司最初开发的**安全套接字层**，版本2于1995年公开发布。它用于加密服务器和客户端之间的通信，提供机密性，完整性和认证。**TLS**，或**传输层安全**，是SSL的新版本，1.2版于2008年作为RFC
    5246定义。Go的TLS包并未完全实现规范，但实现了主要部分。了解有关Go的`crypto/tls`包的更多信息，请访问[https://golang.org/pkg/crypto/tls/](https://golang.org/pkg/crypto/tls/)。
- en: You can only encrypt things smaller than the key size, which is frequently 2048
    bits. Because of this size limitation, asymmetric RSA encryption is not practical
    for encrypting entire documents, which easily exceed 2048 bits or 256 bytes. On
    the other hand, symmetric encryption such as AES can encrypt large documents,
    but it requires a shared key by both parties. TLS/SSL uses a combination of asymmetric
    and symmetric encryption. The initial connection and handshake is done using asymmetric
    encryption with the public and private keys of each party. Once the connection
    is established, a shared key is generated and shared. Once the shared key is known
    by both parties, the asymmetric encryption is dropped, and the rest of the communication
    is done using symmetric encryption such as AES using the shared key.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能加密小于密钥大小的东西，这通常是2048位。由于这种大小限制，非对称RSA加密不适用于加密整个文档，这些文档很容易超过2048位或256字节。另一方面，例如AES的对称加密可以加密大型文档，但它需要双方共享的密钥。TLS/SSL使用非对称和对称加密的组合。初始连接和握手使用每一方的公钥和私钥进行非对称加密。一旦建立连接，将生成并共享一个共享密钥。一旦双方都知道共享密钥，非对称加密将被丢弃，其余的通信将使用对称加密，例如使用共享密钥的AES。
- en: The examples here will use RSA keys. We will cover generating your own public
    and private keys and saving them as PEM encoded files, digitally signing messages
    and verifying signatures. In the next section, we will use the keys to create
    a self-signed certificate and establish secure TLS connections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的示例将使用RSA密钥。我们将介绍如何生成自己的公钥和私钥，并将它们保存为PEM编码的文件，数字签名消息和验证签名。在下一节中，我们将使用这些密钥创建自签名证书并建立安全的TLS连接。
- en: Generating a public and private key pair
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成公钥和私钥对
- en: Before using asymmetric encryption, you need a public and private key pair.
    The private key must be kept secure and not shared with anyone. The public key
    should be shared with others.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用非对称加密之前，您需要一个公钥和私钥对。私钥必须保密并且不与任何人共享。公钥应与他人共享。
- en: '**RSA** (**Rivest-Shamir-Adleman**) and **ECDSA** (**Elliptic Curve Digital
    Signing Algorithm**) algorithms are available in the Go standard library. ECDSA
    is considered more secure, but RSA is the most common algorithm used in SSL certificates.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**RSA**（**Rivest-Shamir-Adleman**）和**ECDSA**（**椭圆曲线数字签名算法**）算法在Go标准库中可用。ECDSA被认为更安全，但RSA是SSL证书中最常用的算法。'
- en: You have the option to password protect your private key. You don't need to
    do it, but it is an extra layer of security. Because the private key is so sensitive,
    it is recommended that you use password protection.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择对私钥进行密码保护。您不需要这样做，但这是额外的安全层。由于私钥非常敏感，建议您使用密码保护。
- en: If you want to password protect your private key file using a symmetric encryption
    algorithm, such as AES, you can use some of the standard library functions. The
    primary functions you will need are `x509.EncryptPEMBlock()`, `x509.DecryptPEMBlock()`,
    and `x509.IsEncryptedPEMBlock()`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用对称加密算法（例如AES）对私钥文件进行密码保护，可以使用一些标准库函数。您将需要的主要函数是`x509.EncryptPEMBlock()`，`x509.DecryptPEMBlock()`和`x509.IsEncryptedPEMBlock()`。
- en: 'To perform the equivalent operation of generating a private and public key
    file using OpenSSL, use the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行使用OpenSSL生成私钥和公钥文件的等效操作，请使用以下内容：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can learn more about PEM encoding with Go at [https://golang.org/pkg/encoding/pem/](https://golang.org/pkg/encoding/pem/).
    Refer to the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://golang.org/pkg/encoding/pem/](https://golang.org/pkg/encoding/pem/)了解有关Go的PEM编码的更多信息。参考以下代码：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Digitally signing a message
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字签名消息
- en: The purpose of signing a message is to let the recipient know the message came
    from the correct person. To sign a message, first generate the hash of the message
    and then use your private key to encrypt the hash. The encrypted hash is your
    signature.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 签署消息的目的是让接收者知道消息来自正确的人。要签署消息，首先生成消息的哈希，然后使用您的私钥加密哈希。加密的哈希就是您的签名。
- en: The recipient will decrypt your signature to get the original hash you provided,
    then they will hash the message themselves and see if the hash they generated
    themselves from the message matches the decrypted value of the signature. If they
    match, the recipient knows that the signature is valid and it came from the correct
    sender.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者将解密你的签名以获得你提供的原始哈希，然后他们将对消息进行哈希处理，看看他们自己从消息中生成的哈希是否与签名的解密值匹配。如果匹配，接收者就知道签名是有效的，并且来自正确的发送者。
- en: Note that signing a message does not actually encrypt the message. You will
    still need to encrypt the message before sending it, if needed. You may not want
    to encrypt the message itself, if you want to post your message publicly. Others
    can still use the signature to verify who posted the message.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，签署一条消息实际上并不加密消息。如果需要，你仍然需要在发送消息之前对消息进行加密。如果你想公开发布你的消息，你可能不想加密消息本身。其他人仍然可以使用签名来验证发布消息的人。
- en: Only messages smaller than the RSA key size can be signed. Because the SHA-256
    hash always has the same output length, we can be sure that it is within the acceptable
    size limit. In this example, we are using the RSA PKCS#1 v1.5 standard signature
    with a SHA-256 hashing method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 只有小于RSA密钥大小的消息才能被签名。因为SHA-256哈希总是具有相同的输出长度，我们可以确保它在可接受的大小限制内。在这个例子中，我们使用了RSA
    PKCS#1 v1.5标准签名和SHA-256哈希方法。
- en: The Go programming language comes with functions in the core packages to handle
    signing and verifying. The primary function is `rsa.VerifyPKCS1v5`. This function
    takes care of hashing the message and then encrypting it with the private key.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Go编程语言提供了核心包中的函数来处理签名和验证。主要函数是`rsa.VerifyPKCS1v5`。这个函数负责对消息进行哈希处理，然后用私钥对其进行加密。
- en: 'The following program will take a message and a private key and create a signature
    output to `STDOUT`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将接收一条消息和一个私钥，并将签名输出到`STDOUT`：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Verifying a signature
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证签名
- en: In the previous example, we learned how to create a signature of a message for
    the recipient to verify. Now let's look at the process of verifying a signature.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们学习了如何为接收者创建一条消息的签名以进行验证。现在让我们来看看验证签名的过程。
- en: If you receive a message and a signature, you must first decrypt the signature
    using the sender's public key. Then hash the original message and see if your
    hash matches the decrypted signature. If your hash matches the decrypted signature,
    then you can be sure that the sender is the person who owns the private key that
    is paired with the public key you used to verify.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到一条消息和一个签名，你必须首先使用发送者的公钥解密签名。然后对原始消息进行哈希处理，看看你的哈希是否与解密的签名匹配。如果你的哈希与解密的签名匹配，那么你可以确定发送者是拥有与你用来验证的公钥配对的私钥的人。
- en: To verify the signature, we are using the same algorithms (RSA PKCS#1 v1.5 with
    SHA-256) that were used to create the signature.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证签名，我们使用了与创建签名相同的算法（RSA PKCS#1 v1.5 with SHA-256）。
- en: This example requires two command-line arguments. The first argument is the
    public key of the person who created the signate and the second argument is the
    file with the signature. To create a signature file, use the sign program from
    the previous example and redirect the output to a file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子需要两个命令行参数。第一个参数是创建签名的人的公钥，第二个参数是带有签名的文件。要创建一个签名文件，可以使用前面例子中的签名程序，并将输出重定向到一个文件中。
- en: 'Similar to the previous section, Go has a function in the standard library
    for verifying a signature. We can use `rsa.VerifyPKCS1v5()` to compare the message
    hash to the decrypted value of the signature and see whether they match:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一节类似，Go语言在标准库中有一个用于验证签名的函数。我们可以使用`rsa.VerifyPKCS1v5()`来比较消息哈希与签名的解密值，并查看它们是否匹配：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: TLS
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS
- en: We usually don't encrypt whole messages with RSA because it can only encrypt
    messages smaller than the key size. The solution to this is typically to begin
    the communication with small messages that use the RSA keys to encrypt. When they
    have established a secure channel, they can safely exchange a shared key that
    they can use to symmetrically encrypt the rest of their messages without the size
    limitations. This is the approach SSL and TLS take to establish a secure communication.
    The handshake takes cares of negotiating which encryption algorithms will be used
    when generating and sharing a symmetric key.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常不会使用RSA加密整个消息，因为它只能加密小于密钥大小的消息。解决这个问题的方法通常是从使用RSA密钥加密的小消息开始通信。当它们建立了一个安全通道后，它们可以安全地交换一个共享密钥，用于对其余消息进行对称加密，而不受大小限制。这是SSL和TLS用来建立安全通信的方法。握手过程负责协商在生成和共享对称密钥时将使用哪些加密算法。
- en: Generating a self-signed certificate
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成自签名证书
- en: To create a self-signed certificate with Go, you need a public and private key
    pair. The x509 package has a function for creating a certificate. It requires
    the public and private key along with a template certificate with all the information.
    Since we are self-signing, the template certificate is also going to be used as
    the parent certificate doing the signing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Go创建自签名证书，你需要一个公钥和私钥对。x509包中有一个用于创建证书的函数。它需要公钥和私钥以及一个包含所有信息的模板证书。由于我们是自签名的，模板证书也将用作执行签名的父证书。
- en: Each application can treat self-signed certificates differently. Some applications
    will warn you if a certificate is self-signed, some will refuse to accept it,
    and others will happily use it without warning you. When you write your own applications,
    you will have to decide if you want to verify certificates or accept self-signed
    ones.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序可以以不同的方式处理自签名证书。有些应用程序会在证书是自签名时警告你，有些会拒绝接受它，而其他一些则会在不警告你的情况下使用它。当你编写自己的应用程序时，你将不得不决定是否要验证证书或接受自签名证书。
- en: 'The important function is `x509.CreateCertificate()`, referenced at [https://golang.org/pkg/crypto/x509/#CreateCertificate](https://golang.org/pkg/crypto/x509/#CreateCertificate).
    Here is the function signature:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的函数是`x509.CreateCertificate()`，在[https://golang.org/pkg/crypto/x509/#CreateCertificate](https://golang.org/pkg/crypto/x509/#CreateCertificate)中有引用。以下是函数签名：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example will take a private key and generate a certificate signed by it.
    It will save it to a file in PEM format. Once you create a self-signed certificate,
    you can use that certificate along with the private key to run secure TLS socket
    listeners and web servers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将使用私钥生成一个由它签名的证书，并将其保存为PEM格式的文件。一旦你创建了一个自签名证书，你就可以将该证书与私钥一起使用，运行安全的TLS套接字监听器和Web服务器。
- en: For the sake of brevity, this example hardcodes the certificate owner information
    and the hostname IP to be localhost. This is good enough for testing on your local
    machine.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，这个例子将证书所有者信息和主机名IP硬编码为localhost。这对于在本地机器上进行测试已经足够了。
- en: 'Modify these to suit your needs, customize the values, have them input through
    command-line arguments, or use standard input to get the values from the user
    dynamically, as shown in the following code block:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要修改这些内容，自定义值，通过命令行参数输入，或者使用标准输入动态获取用户的值，如下面的代码块所示：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating a certificate signing request
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建证书签名请求
- en: If you don't want to create a self-signed certificate, you have to create a
    certificate signing request and have it signed by a trusted certificate authority.
    You create a certificate request by calling `x509.CreateCertificateRequest()`
    and passing it an `x509.CertificateRequest` object with the private key.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想创建自签名证书，你必须创建一个证书签名请求，并让受信任的证书颁发机构对其进行签名。你可以通过调用`x509.CreateCertificateRequest()`并传递一个带有私钥的`x509.CertificateRequest`对象来创建一个证书请求。
- en: 'The equivalent operation using OpenSSL is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenSSL进行等效操作如下：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example demonstrates how to create a certificate signing request:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了如何创建证书签名请求：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Signing a certificate request
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签署证书请求
- en: In the previous example, when generating a self-signed certificate, we already
    demonstrated the process for creating a signed certificate. In the self-signed
    example, we just used the same certificate template as the signee and the signer.
    For this reason, there is not a separate code example. The only difference is
    that the parent certificate doing the signing or the template to be signed should
    be swapped out to a different certificate.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当生成自签名证书时，我们已经演示了创建签名证书的过程。在自签名的例子中，我们只是使用了与签名者相同的证书模板。因此，没有单独的代码示例。唯一的区别是进行签名的父证书或要签名的模板应该被替换为不同的证书。
- en: 'This is the function definition for `x509.CreateCertificate()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`x509.CreateCertificate()`的函数定义：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the self-signed example, the template and parent certificates were the same
    object. To sign a certificate request, create a new certificate object and populate
    the fields with the information from the signing request. Pass the new certificate
    as the template, and use the signer's certificate as the parent. The `pub` parameter
    is the signee's public key and the `priv` parameter is the signer's private key.
    The signer is the certificate authority and the signee is the requester. You can
    read more about this function at [https://golang.org/pkg/crypto/x509/#CreateCertificate](https://golang.org/pkg/crypto/x509/#CreateCertificate).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在自签名的例子中，模板和父证书是同一个对象。要签署证书请求，创建一个新的证书对象，并用签名请求中的信息填充字段。将新证书作为模板，使用签名者的证书作为父证书。`pub`参数是受让人的公钥，`priv`参数是签名者的私钥。签名者是证书颁发机构，受让人是请求者。你可以在[https://golang.org/pkg/crypto/x509/#CreateCertificate](https://golang.org/pkg/crypto/x509/#CreateCertificate)了解更多关于这个函数的信息。
- en: 'The  `X509.CreateCertificate()` parameters are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`X509.CreateCertificate()`的参数如下：'
- en: '`rand`: This is the cryptographically secure pseudorandom number generator'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rand`：这是密码学安全的伪随机数生成器'
- en: '`template`: This is the certificate template populated with info from CSR'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`：这是使用CSR中的信息填充的证书模板'
- en: '`parent`: This is the certificate of the signer'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`：这是签名者的证书'
- en: '`pub`: This is the public key of the signee'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pub`：这是受让人的公钥'
- en: '`priv`: This is the private key of the signer'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`priv`：这是签名者的私钥'
- en: 'The equivalent operation using OpenSSL is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenSSL进行等效操作如下：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: TLS server
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS服务器
- en: You can set up a listener just like a normal socket connection, but with encryption.
    Just call the TLS `Listen()` function, and provide it your certificate and private
    key. The certificate and key generated using the previous examples will work.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像设置普通套接字连接一样设置监听器，但是加密。只需调用TLS的`Listen()`函数，并提供你的证书和私钥。使用前面示例中生成的证书和密钥将起作用。
- en: 'The following program will create a TLS server and echo back any data received,
    then close the connection. The server will not require or verify client certificates,
    but the code to do so is left commented out for reference in case you want to
    authenticate clients with certificates:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将创建一个TLS服务器，并回显接收到的任何数据，然后关闭连接。服务器不需要或验证客户端证书，但是用于进行验证的代码被注释掉，以供参考，以防你想要使用证书对客户端进行身份验证：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: TLS client
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS客户端
- en: TCP sockets are a simple and common way of communicating over a network. Adding
    the TLS layer on top of a standard TCP socket is simple with Go's standard library.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: TCP套接字是在网络上进行通信的一种简单而常见的方式。在标准库中使用Go的TLS层覆盖标准TCP套接字非常简单。
- en: A client dials a TLS server just like a standard socket. Clients typically aren't
    required to have any sort of key or certificate, but a server could implement
    client-side authentication and only allow certain users to connect.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端拨号TLS服务器就像标准套接字一样。客户端通常不需要任何类型的密钥或证书，但服务器可以实现客户端身份验证，并只允许特定用户连接。
- en: This program will connect to a TLS server and send the contents of STDIN to
    the remote server and read the response. We can use this program to test our basic
    TLS echo server created in the previous section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将连接到一个TLS服务器，并将STDIN的内容发送到远程服务器并读取响应。我们可以使用这个程序来测试在上一节中创建的基本TLS回显服务器。
- en: Before running this program, make sure that the TLS server from the previous
    section is running so that you can connect.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此程序之前，请确保上一节中的TLS服务器正在运行，以便您可以连接。
- en: Note that this is a raw socket-level server. It is not an HTTP server. In [Chapter
    9](f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml), *Web Applications* there are examples
    of running an HTTPS TLS web server.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个原始的套接字级服务器。它不是一个HTTP服务器。在[第9章](f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml)
    *Web应用*中，有一些运行HTTPS TLS Web服务器的示例。
- en: By default, the client verifies that the server's certificate is signed by a
    trusted authority. We have to override this default and tell the client not to
    verify the certificate because we signed it ourselves. The list of trusted certificate
    authorities is loaded from the system, but can be overridden by populating the
    RootCAs variable in `tls.Config`. This example will not verify the server certificate,
    but the code to provide a list of trusted RootCAs is provided, but commented out
    for reference.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，客户端会验证服务器的证书是否由受信任的机构签名。我们必须覆盖这个默认设置，并告诉客户端不要验证证书，因为我们自己签名了它。受信任的证书颁发机构列表是从系统中加载的，但可以通过在`tls.Config`中填充RootCAs变量来覆盖。这个例子不会验证服务器证书，但提供了提供一组受信任的RootCAs的代码，供参考时注释掉。
- en: You can see how Go is loading the certificate pool for each system by looking
    through the `root_*.go` files in [https://golang.org/src/crypto/x509/](https://golang.org/src/crypto/x509/).
    For example, `root_windows.go` and `root_linux.go` load the system's default certificates.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看[https://golang.org/src/crypto/x509/](https://golang.org/src/crypto/x509/)中的`root_*.go`文件来了解Go如何为每个系统加载证书池。例如，`root_windows.go`和`root_linux.go`加载系统的默认证书。
- en: 'If you wanted to connect to a server and inspect or store its certificate,
    you would connect and then inspect client''s `net.Conn.ConnectionState().PeerCertificates`.
    It comes in a standard `x509.Certificate` struct. To do so, refer to the following
    block of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想连接到服务器并检查或存储其证书，您可以连接，然后检查客户端的`net.Conn.ConnectionState().PeerCertificates`。它以标准的`x509.Certificate`结构形式呈现。要这样做，请参考以下代码块：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Other encryption packages
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他加密包
- en: There are no source code examples for the following sections, but they are worth
    mentioning. These packages provided by Go are built on top of the principles demonstrated
    in the previous examples.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分没有源代码示例，但值得一提。这些由Go提供的包是建立在前面示例中演示的原则之上的。
- en: OpenPGP
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenPGP
- en: PGP stands for **Pretty Good Privacy**, and OpenPGP is standard RFC 4880\. PGP
    is a convenient suite for encrypting text, files, directories, and disks. All
    the principles are the same as discussed in the previous section with SSL and
    TLS key/certificates. The encrypting, signing, and verification are all the same.
    Go provides an OpenPGP package. Read more about it at [https://godoc.org/golang.org/x/crypto/openpgp](https://godoc.org/golang.org/x/crypto/openpgp).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PGP代表**相当好的隐私**，而OpenPGP是标准RFC 4880。PGP是一个方便的套件，用于加密文本、文件、目录和磁盘。所有原则都与前一节中讨论的SSL和TLS密钥/证书相同。加密、签名和验证都是一样的。Go提供了一个OpenPGP包。在[https://godoc.org/golang.org/x/crypto/openpgp](https://godoc.org/golang.org/x/crypto/openpgp)上阅读更多关于它的信息。
- en: Off The Record (OTR) messaging
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离线记录（OTR）消息
- en: '**Off The Record** or **OTR** messaging is a form of end-to-end encryption
    for users to encrypt their communication over whatever message medium is being
    used. It is convenient because you can implement an encrypted layer over any protocol
    even if the protocol itself is unencrypted. For example, OTR messaging works over
    XMPP, IRC, and many other chat protocols. Many chat clients such as Pidgin, Adium,
    and Xabber have support for OTR either natively or via plugin. Go provides a package
    for implementing OTR messaging. Read more about Go''s OTR support at [https://godoc.org/golang.org/x/crypto/otr/](https://godoc.org/golang.org/x/crypto/otr/).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**离线记录**或**OTR**消息是一种端到端加密，用户可以加密他们在任何消息媒介上的通信。这很方便，因为你可以在任何协议上实现加密层，即使协议本身是未加密的。例如，OTR消息可以在XMPP、IRC和许多其他聊天协议上运行。许多聊天客户端，如Pidgin、Adium和Xabber，都支持OTR，无论是本地支持还是通过插件支持。Go提供了一个用于实现OTR消息的包。在[https://godoc.org/golang.org/x/crypto/otr/](https://godoc.org/golang.org/x/crypto/otr/)上阅读更多关于Go的OTR支持的信息。'
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter, you should have a good understanding of what the
    Go cryptography packages are capable of. Using the examples given in this chapter
    as a reference, you should feel comfortable performing basic hash operations,
    encrypting, decrypting, generating keys, and using keys.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您应该对Go密码包的功能有很好的理解。使用本章中提供的示例作为参考，您应该能够轻松地执行基本的哈希操作、加密、解密、生成密钥和使用密钥。
- en: Additionally, you should understand the difference between symmetric and asymmetric
    encryption, and how it is different from hashing. You should feel comfortable
    with the basics of running a TLS server and connecting with a TLS client.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您应该了解对称加密和非对称加密之间的区别，以及它与哈希的不同之处。您应该对运行TLS服务器和与TLS客户端连接的基础有所了解。
- en: Remember, the goal is not to memorize every detail, but to remember what options
    are available so that you can choose the best tool for the job.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，目标不是记住每一个细节，而是记住有哪些选项可供选择，以便您可以选择最适合工作的工具。
- en: In the next chapter, we will look at using secure shell, also known as SSH.
    Authenticating with public and private key pairs and passwords is covered first,
    along with how to verify the remote host's key. We will also look at how to execute
    commands on a remote server and how to create an interactive shell. Secure shell
    makes use of the encryption techniques discussed in this chapter. It is one of
    the most common and practical applications of encryption. Continue reading to
    learn more about using SSH in Go.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论使用安全外壳（也称为SSH）。首先介绍了使用公钥和私钥对以及密码进行身份验证，以及如何验证远程主机的密钥。我们还将介绍如何在远程服务器上执行命令以及如何创建交互式外壳。安全外壳利用了本章讨论的加密技术。这是加密的最常见和实用的应用之一。继续阅读，了解更多关于在Go中使用SSH的内容。
