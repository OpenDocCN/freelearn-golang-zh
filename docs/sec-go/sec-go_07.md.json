["```go\ngo get golang.org/x/crypto/ssh\n```", "```go\nssh-keygen\n```", "```go\nssh-copy-id yourserver.com\n```", "```go\npackage main\n\nimport (\n   \"golang.org/x/crypto/ssh\"\n   \"log\"\n)\n\nvar username = \"username\"\nvar password = \"password\"\nvar host = \"example.com:22\"\n\nfunc main() {\n   config := &ssh.ClientConfig{\n      User: username,\n      Auth: []ssh.AuthMethod{\n         ssh.Password(password),\n      },\n      HostKeyCallback: ssh.InsecureIgnoreHostKey(),\n   }\n   client, err := ssh.Dial(\"tcp\", host, config)\n   if err != nil {\n      log.Fatal(\"Error dialing server. \", err)\n   }\n\n   log.Println(string(client.ClientVersion()))\n} \n```", "```go\nssh-copy-id example.com \n```", "```go\npackage main\n\nimport (\n   \"golang.org/x/crypto/ssh\"\n   \"io/ioutil\"\n   \"log\"\n)\n\nvar username = \"username\"\nvar host = \"example.com:22\"\nvar privateKeyFile = \"/home/user/.ssh/id_rsa\"\n\nfunc getKeySigner(privateKeyFile string) ssh.Signer {\n   privateKeyData, err := ioutil.ReadFile(privateKeyFile)\n   if err != nil {\n      log.Fatal(\"Error loading private key file. \", err)\n   }\n\n   privateKey, err := ssh.ParsePrivateKey(privateKeyData)\n   if err != nil {\n      log.Fatal(\"Error parsing private key. \", err)\n   }\n   return privateKey\n}\n\nfunc main() {\n   privateKey := getKeySigner(privateKeyFile)\n   config := &ssh.ClientConfig{\n      User: username,\n      Auth: []ssh.AuthMethod{\n         ssh.PublicKeys(privateKey), // Pass 1 or more key\n      },\n      HostKeyCallback: ssh.InsecureIgnoreHostKey(),\n   }\n\n   client, err := ssh.Dial(\"tcp\", host, config)\n   if err != nil {\n      log.Fatal(\"Error dialing server. \", err)\n   }\n\n   log.Println(string(client.ClientVersion()))\n} \n```", "```go\nssh-keyscan yourserver.com\n```", "```go\npackage main\n\nimport (\n   \"golang.org/x/crypto/ssh\"\n   \"io/ioutil\"\n   \"log\"\n)\n\nvar username = \"username\"\nvar host = \"example.com:22\"\nvar privateKeyFile = \"/home/user/.ssh/id_rsa\"\n\n// Known hosts only reads FIRST entry\nvar knownHostsFile = \"/home/user/.ssh/known_hosts\"\n\nfunc getKeySigner(privateKeyFile string) ssh.Signer {\n   privateKeyData, err := ioutil.ReadFile(privateKeyFile)\n   if err != nil {\n      log.Fatal(\"Error loading private key file. \", err)\n   }\n\n   privateKey, err := ssh.ParsePrivateKey(privateKeyData)\n   if err != nil {\n      log.Fatal(\"Error parsing private key. \", err)\n   }\n   return privateKey\n}\n\nfunc loadServerPublicKey(knownHostsFile string) ssh.PublicKey {\n   publicKeyData, err := ioutil.ReadFile(knownHostsFile)\n   if err != nil {\n      log.Fatal(\"Error loading server public key file. \", err)\n   }\n\n   _, _, publicKey, _, _, err := ssh.ParseKnownHosts(publicKeyData)\n   if err != nil {\n      log.Fatal(\"Error parsing server public key. \", err)\n   }\n   return publicKey\n}\n\nfunc main() {\n   userPrivateKey := getKeySigner(privateKeyFile)\n   serverPublicKey := loadServerPublicKey(knownHostsFile)\n\n   config := &ssh.ClientConfig{\n      User: username,\n      Auth: []ssh.AuthMethod{\n         ssh.PublicKeys(userPrivateKey),\n      },\n      HostKeyCallback: ssh.FixedHostKey(serverPublicKey),\n      // Acceptable host key algorithms (Allow all)\n      HostKeyAlgorithms: []string{\n         ssh.KeyAlgoRSA,\n         ssh.KeyAlgoDSA,\n         ssh.KeyAlgoECDSA256,\n         ssh.KeyAlgoECDSA384,\n         ssh.KeyAlgoECDSA521,\n         ssh.KeyAlgoED25519,\n      },\n   }\n\n   client, err := ssh.Dial(\"tcp\", host, config)\n   if err != nil {\n      log.Fatal(\"Error dialing server. \", err)\n   }\n\n   log.Println(string(client.ClientVersion()))\n} \n```", "```go\ndf -h; ps aux; pwd; whoami;\n```", "```go\npackage main\n\nimport (\n   \"golang.org/x/crypto/ssh\"\n   \"io/ioutil\"\n   \"log\"\n   \"os\"\n)\n\nvar username = \"username\"\nvar host = \"example.com:22\"\nvar privateKeyFile = \"/home/user/.ssh/id_rsa\"\nvar commandToExecute = \"hostname\"\n\nfunc getKeySigner(privateKeyFile string) ssh.Signer {\n   privateKeyData, err := ioutil.ReadFile(privateKeyFile)\n   if err != nil {\n      log.Fatal(\"Error loading private key file. \", err)\n   }\n\n   privateKey, err := ssh.ParsePrivateKey(privateKeyData)\n   if err != nil {\n      log.Fatal(\"Error parsing private key. \", err)\n   }\n   return privateKey\n}\n\nfunc main() {\n   privateKey := getKeySigner(privateKeyFile)\n   config := &ssh.ClientConfig{\n      User: username,\n      Auth: []ssh.AuthMethod{\n         ssh.PublicKeys(privateKey),\n      },\n      HostKeyCallback: ssh.InsecureIgnoreHostKey(),\n   }\n\n   client, err := ssh.Dial(\"tcp\", host, config)\n   if err != nil {\n      log.Fatal(\"Error dialing server. \", err)\n   }\n\n   // Multiple sessions per client are allowed\n   session, err := client.NewSession()\n   if err != nil {\n      log.Fatal(\"Failed to create session: \", err)\n   }\n   defer session.Close()\n\n   // Pipe the session output directly to standard output\n   // Thanks to the convenience of writer interface\n   session.Stdout = os.Stdout\n\n   err = session.Run(commandToExecute)\n   if err != nil {\n      log.Fatal(\"Error executing command. \", err)\n   }\n} \n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"golang.org/x/crypto/ssh\"\n   \"io/ioutil\"\n   \"log\"\n   \"os\"\n)\n\nfunc checkArgs() (string, string, string) {\n   if len(os.Args) != 4 {\n      printUsage()\n      os.Exit(1)\n   }\n   return os.Args[1], os.Args[2], os.Args[3]\n}\n\nfunc printUsage() {\n   fmt.Println(os.Args[0] + ` - Open an SSH shell\n\nUsage:\n  ` + os.Args[0] + ` <username> <host> <privateKeyFile>\n\nExample:\n  ` + os.Args[0] + ` nanodano devdungeon.com:22 ~/.ssh/id_rsa\n`)\n}\n\nfunc getKeySigner(privateKeyFile string) ssh.Signer {\n   privateKeyData, err := ioutil.ReadFile(privateKeyFile)\n   if err != nil {\n      log.Fatal(\"Error loading private key file. \", err)\n   }\n\n   privateKey, err := ssh.ParsePrivateKey(privateKeyData)\n   if err != nil {\n      log.Fatal(\"Error parsing private key. \", err)\n   }\n   return privateKey\n}\n\nfunc main() {\n   username, host, privateKeyFile := checkArgs()\n\n   privateKey := getKeySigner(privateKeyFile)\n   config := &ssh.ClientConfig{\n      User: username,\n      Auth: []ssh.AuthMethod{\n         ssh.PublicKeys(privateKey),\n      },\n      HostKeyCallback: ssh.InsecureIgnoreHostKey(),\n   }\n\n   client, err := ssh.Dial(\"tcp\", host, config)\n   if err != nil {\n      log.Fatal(\"Error dialing server. \", err)\n   }\n\n   session, err := client.NewSession()\n   if err != nil {\n      log.Fatal(\"Failed to create session: \", err)\n   }\n   defer session.Close()\n\n   // Pipe the standard buffers together\n   session.Stdout = os.Stdout\n   session.Stdin = os.Stdin\n   session.Stderr = os.Stderr\n\n   // Get psuedo-terminal\n   err = session.RequestPty(\n      \"vt100\", // or \"linux\", \"xterm\"\n      40,      // Height\n      80,      // Width\n      // https://godoc.org/golang.org/x/crypto/ssh#TerminalModes\n      // POSIX Terminal mode flags defined in RFC 4254 Section 8.\n      // https://tools.ietf.org/html/rfc4254#section-8\n      ssh.TerminalModes{\n         ssh.ECHO: 0,\n      })\n   if err != nil {\n      log.Fatal(\"Error requesting psuedo-terminal. \", err)\n   }\n\n   // Run shell until it is exited\n   err = session.Shell()\n   if err != nil {\n      log.Fatal(\"Error executing command. \", err)\n   }\n   session.Wait()\n} \n```"]