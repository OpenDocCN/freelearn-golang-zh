- en: Secure Shell (SSH)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全外壳（SSH）
- en: '**Secure Shell** (**SSH**) is a cryptographic network protocol for communicating
    on an unsecure network. The most common use of SSH is in connecting to a remote
    server and interacting with a shell. File transfer is also used via SCP and SFTP
    over the SSH protocol. SSH was created to replace the plaintext protocol, Telnet.
    Over time, there have been numerous RFCs to define SSH. Here is a partial list
    to give you an idea of what is defined. Since it is such a common and critical
    protocol, it is worth taking the time to understand the details. The following
    are some of the RFCs:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全外壳**（**SSH**）是一种用于在不安全网络上通信的加密网络协议。 SSH最常见的用途是连接到远程服务器并与shell进行交互。文件传输也通过SSH协议上的SCP和SFTP进行。
    SSH是为了取代明文协议Telnet而创建的。 随着时间的推移，已经有了许多RFC来定义SSH。 以下是部分列表，以便让您了解定义的内容。 由于它是如此常见和关键的协议，值得花时间了解细节。
    以下是一些RFC：'
- en: '*RFC 4250* ([https://tools.ietf.org/html/rfc4250](https://tools.ietf.org/html/rfc4250)):
    *The Secure Shell (SSH) Protocol Assigned Numbers*'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4250* ([https://tools.ietf.org/html/rfc4250](https://tools.ietf.org/html/rfc4250)):
    *安全外壳（SSH）协议分配的数字*'
- en: '*RFC 4251* ([https://tools.ietf.org/html/rfc4251](https://tools.ietf.org/html/rfc4251)):
    *The Secure Shell (SSH) Protocol Architecture*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4251* ([https://tools.ietf.org/html/rfc4251](https://tools.ietf.org/html/rfc4251)):
    *安全外壳（SSH）协议架构*'
- en: '*RFC 4252* ([https://tools.ietf.org/html/rfc4252](https://tools.ietf.org/html/rfc4252)):
    *The Secure Shell (SSH) Authentication Protocol*'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4252* ([https://tools.ietf.org/html/rfc4252](https://tools.ietf.org/html/rfc4252)):
    *安全外壳（SSH）认证协议*'
- en: '*RFC 4253* ([https://tools.ietf.org/html/rfc4253](https://tools.ietf.org/html/rfc4253)):
    *The Secure Shell (SSH) Transport Layer Protocol*'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4253* ([https://tools.ietf.org/html/rfc4253](https://tools.ietf.org/html/rfc4253)):
    *安全外壳（SSH）传输层协议*'
- en: '*RFC 4254* ([https://tools.ietf.org/html/rfc4254](https://tools.ietf.org/html/rfc4254)):
    *The Secure Shell (SSH) Connection Protocol*'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4254* ([https://tools.ietf.org/html/rfc4254](https://tools.ietf.org/html/rfc4254)):
    *安全外壳（SSH）连接协议*'
- en: '*RFC 4255* ([https://tools.ietf.org/html/rfc4255](https://tools.ietf.org/html/rfc4255)):
    *Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints*'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4255* ([https://tools.ietf.org/html/rfc4255](https://tools.ietf.org/html/rfc4255)):
    *使用DNS安全发布安全外壳（SSH）密钥指纹*'
- en: '*RFC 4256* ([https://tools.ietf.org/html/rfc4256](https://tools.ietf.org/html/rfc4256)):
    *Generic Message Exchange Authentication for the Secure Shell Protocol (SSH)*'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4256* ([https://tools.ietf.org/html/rfc4256](https://tools.ietf.org/html/rfc4256)):
    *安全外壳协议（SSH）的通用消息交换认证*'
- en: '*RFC 4335* ([https://tools.ietf.org/html/rfc4335](https://tools.ietf.org/html/rfc4335)):
    **The Secure Shell (SSH) Session Channel Break Extension**'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4335* ([https://tools.ietf.org/html/rfc4335](https://tools.ietf.org/html/rfc4335)):
    **安全外壳（SSH）会话通道中断扩展**'
- en: '*RFC 4344* ([https://tools.ietf.org/html/rfc4344](https://tools.ietf.org/html/rfc4344)):
    *The Secure Shell (SSH) Transport Layer Encryption Modes*'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4344* ([https://tools.ietf.org/html/rfc4344](https://tools.ietf.org/html/rfc4344)):
    *安全外壳（SSH）传输层加密模式*'
- en: '*RFC 4345* ([https://tools.ietf.org/html/rfc4345](https://tools.ietf.org/html/rfc4345)):
    *Improved Arcfour Modes for the Secure Shell (SSH) Transport Layer Protocol*'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4345* ([https://tools.ietf.org/html/rfc4345](https://tools.ietf.org/html/rfc4345)):
    *安全外壳（SSH）传输层协议的改进Arcfour模式*'
- en: There were also additional expansions later to the standard, which you can read
    about at [https://en.wikipedia.org/wiki/Secure_Shell#Standards_documentation](https://en.wikipedia.org/wiki/Secure_Shell#Standards_documentation).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后还对标准进行了额外的扩展，您可以在[https://en.wikipedia.org/wiki/Secure_Shell#Standards_documentation](https://en.wikipedia.org/wiki/Secure_Shell#Standards_documentation)上阅读相关内容。
- en: SSH is a common target for brute force and default credential attacks across
    the internet. For this reason, you might consider putting SSH on a nonstandard
    port, but keep it to a system port (less than 1024) so that a low-privileged user
    cannot potentially hijack the port if the service goes down. If you leave SSH
    on the default port, services such as `fail2ban` can be invaluable for rate limiting
    and blocking brute force attacks. Ideally, password authentication is disabled
    completely and key authentication is required.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SSH是互联网上常见的暴力破解和默认凭据攻击目标。 因此，您可能考虑将SSH放在非标准端口上，但保持在系统端口（小于1024）上，以便低特权用户在服务关闭时无法潜在地劫持端口。
    如果将SSH保留在默认端口上，则诸如`fail2ban`之类的服务对于限制速率和阻止暴力破解攻击至关重要。 理想情况下，应完全禁用密码身份验证，并要求密钥身份验证。
- en: 'The SSH package does not come packaged with the standard library, although
    it was written by the Go team. It is officially part of the Go project, but outside
    of the main Go source tree, so it is not installed with Go by default. It is available
    from [https://golang.org/](https://golang.org/) and can be installed using this
    command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SSH包并不随标准库一起打包，尽管它是由Go团队编写的。 它正式是Go项目的一部分，但在主Go源树之外，因此默认情况下不会随Go一起安装。 它可以从[https://golang.org/](https://golang.org/)获取，并且可以使用以下命令进行安装：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this chapter, we will cover how to use the SSH client to connect, execute
    commands, and use an interactive shell. We will also cover the different methods
    of authentication such as using a password or a private key. The SSH package provides
    functions for creating a server, but we'll cover only the client in this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何使用SSH客户端进行连接，执行命令和使用交互式shell。 我们还将介绍使用密码或私钥等不同的身份验证方法。 SSH包提供了用于创建服务器的函数，但本书中我们只涵盖客户端。
- en: 'This chapter will specifically cover the following for SSH:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专门涵盖SSH的以下内容：
- en: Authenticating with a password
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用密码进行身份验证
- en: Authenticating with a private key
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用私钥进行身份验证
- en: Verifying the key of a remote host
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证远程主机的密钥
- en: Executing a command over SSH
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SSH执行命令
- en: Starting an interactive shell
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动交互式shell
- en: Using the Go SSH client
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go SSH客户端
- en: The `golang.org/x/crypto/ssh` package provides an SSH client that is compatible
    with SSH version 2—the latest version. The client will work with the OpenSSH servers
    and any other server that follows the SSH specifications. It supports the traditional
    client features such as subprocesses, port forwarding, and tunneling.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`golang.org/x/crypto/ssh`包提供了一个与SSH版本2兼容的SSH客户端，这是最新版本。该客户端将与OpenSSH服务器以及遵循SSH规范的任何其他服务器一起工作。它支持传统的客户端功能，如子进程、端口转发和隧道。'
- en: Authentication methods
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证方法
- en: Authentication is not just the first step but also the most critical. Improper
    authentication can lead to potential loss of confidentiality, integrity, and availability.
    A man-in-the-middle attack can occur if the remote server is not verified, leading
    to spying, manipulation, or blocking of data. Weak password authentication can
    be exploited by brute force attacks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证不仅是第一步，也是最关键的一步。不正确的身份验证可能导致机密性、完整性和可用性的潜在损失。如果未验证远程服务器，可能会发生中间人攻击，导致窃听、操纵或阻止数据。弱密码身份验证可能会被暴力攻击利用。
- en: Three examples are provided here. The first example covers password authentication,
    which is common, but not recommended due to the low entropy and bit count of passwords
    compared with that of cryptographic keys. The second example demonstrates how
    to use a private key to authenticate with a remote server. Both of these examples
    ignore the public key provided by the remote host. This is insecure, because you
    may end up connecting to a remote host you do not trust, but is good enough for
    testing. The third example of authentication is the ideal flow. It authenticates
    with a key and verifies the remote server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了三个例子。第一个例子涵盖了密码认证，这是常见的，但由于密码的熵和位数与加密密钥相比较低，因此不建议使用。第二个例子演示了如何使用私钥对远程服务器进行身份验证。这两个例子都忽略了远程主机提供的公钥。这是不安全的，因为您可能最终连接到一个您不信任的远程主机，但对于测试来说已经足够了。身份验证的第三个例子是理想的流程。它使用密钥进行身份验证并验证远程服务器。
- en: Note that this chapter does not use PEM formatted key files as in [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*. This uses SSH formatted keys, which is naturally the most common
    format for working with SSH. These examples are compatible with the OpenSSH tools
    and keys such as `ssh`, `sshd`, `ssh-keygen`, `ssh-copy-id`, and `ssh-keyscan`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本章不使用PEM格式的密钥文件，而是使用SSH格式的密钥，这是处理SSH最常见的格式。这些例子与OpenSSH工具和密钥兼容，如`ssh`、`sshd`、`ssh-keygen`、`ssh-copy-id`和`ssh-keyscan`。
- en: 'I recommend that you use `ssh-keygen` to generate a public and private key
    pair for authentication. This will generate the `id_rsa` and `id_rsa.pub` files
    in the SSH key format. The `ssh-keygen` tool is part of the OpenSSH project and
    is packed with Ubuntu by default:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您使用`ssh-keygen`生成用于身份验证的公钥和私钥对。这将以SSH密钥格式生成`id_rsa`和`id_rsa.pub`文件。`ssh-keygen`工具是OpenSSH项目的一部分，并且默认情况下已经打包到Ubuntu中：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use `ssh-copy-id` to copy your public key (`id_rsa.pub`) to the remote server''s
    `~/.ssh/authorized_keys` file so that you can authenticate using the private key:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ssh-copy-id`将您的公钥（`id_rsa.pub`）复制到远程服务器的`~/.ssh/authorized_keys`文件中，以便您可以使用私钥进行身份验证：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Authenticating with a password
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用密码进行身份验证
- en: 'Password authentication over SSH is the simplest method. This example demonstrates
    how to configure an SSH client with the `ssh.ClientConfig` struct and then connect
    to an SSH server using `ssh.Dial()`. The client is configured to use a password
    by specifying `ssh.Password()` as the authentication function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SSH进行密码身份验证是最简单的方法。此示例演示了如何使用`ssh.ClientConfig`结构配置SSH客户端，然后使用`ssh.Dial()`连接到SSH服务器。客户端被配置为使用密码，通过指定`ssh.Password()`作为身份验证函数：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Authenticating with private key
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用私钥进行身份验证
- en: A private key has a few advantages over password. It is much longer than a password,
    making it exponentially more difficult to brute force. It also eliminates the
    need to type in a password, making it convenient to connect to remote servers.
    Passwordless authentication is also helpful for cron jobs and other services that
    need to run automatically without human intervention. Some servers disable password
    authentication completely and require a key.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与密码相比，私钥具有一些优势。它比密码长得多，使得暴力破解变得更加困难。它还消除了输入密码的需要，使连接到远程服务器变得更加方便。无密码身份验证对于需要在没有人为干预的情况下自动运行的cron作业和其他服务也是有帮助的。一些服务器完全禁用密码身份验证并要求使用密钥。
- en: The remote server will need to have your public key as an authorized key before
    you can authenticate using the private key.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用私钥进行身份验证之前，远程服务器将需要您的公钥作为授权密钥。
- en: 'You can use the `ssh-copy-id` tool if it is available on your system. It will
    copy your public key to the remote server, place it in your home folder SSH directory
    (`~/.ssh/authorized_keys`), and set the correct permissions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统上有`ssh-copy-id`工具，您可以使用它。它将把您的公钥复制到远程服务器，放置在您的家目录SSH目录（`~/.ssh/authorized_keys`）中，并设置正确的权限：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following example is similar to the previous example, where we authenticate
    using a password, but `ssh.ClientConfig` is configured to use `ssh.PublicKeys()`
    as the authentication function, instead of `ssh.Password()`. We will also create
    a special function named `getKeySigner()` in order to load the private key for
    the client from a file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子与前面的例子类似，我们使用密码进行身份验证，但`ssh.ClientConfig`被配置为使用`ssh.PublicKeys()`作为身份验证函数，而不是`ssh.Password()`。我们还将创建一个名为`getKeySigner()`的特殊函数，以便从文件中加载客户端的私钥：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that you can pass more than a single private key to the `ssh.PublicKeys()`
    function. It accepts an unlimited number of keys. If you provide multiple keys,
    and only one works for the server, it will automatically use the one key that
    works.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以将多个私钥传递给`ssh.PublicKeys()`函数。它接受无限数量的密钥。如果您提供多个密钥，但只有一个适用于服务器，它将自动使用适用的密钥。
- en: This is useful if you want to use the same configuration to connect to a number
    of servers. You may want to connect to 1,000 different hosts using 1,000 unique
    private keys. Instead of having to create multiple SSH client configs, you can
    reuse a single config that contains all of the private keys.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用相同的配置连接到多台服务器，这将非常有用。您可能希望使用1,000个唯一的私钥连接到1,000个不同的主机。您可以重用包含所有私钥的单个配置，而不必创建多个SSH客户端配置。
- en: Verifying remote host
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证远程主机
- en: To verify the remote host, in `ssh.ClientConfig`, set `HostKeyCallback` to `ssh.FixedHostKey()`
    and pass it the public key of the remote host. If you attempt to connect to the
    server and it provides a different public key, the connection will be aborted.
    This is important for ensuring that you are connecting to the expected server
    and not a malicious server. If DNS is compromised, or an attacker performs a successful
    ARP spoof, it's possible that your connection will be redirected or will be a
    victim of the man-in-the-middle attack, but an attacker will not be able to imitate
    the real server without the corresponding private key for the server. For testing
    purposes, you may choose to ignore the key provided by the remote host.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证远程主机，在`ssh.ClientConfig`中，将`HostKeyCallback`设置为`ssh.FixedHostKey()`，并传递远程主机的公钥。如果您尝试连接到服务器并提供了不同的公钥，连接将被中止。这对于确保您连接到预期的服务器而不是恶意服务器非常重要。如果DNS受到损害，或者攻击者执行了成功的ARP欺骗，您的连接可能会被重定向或成为中间人攻击的受害者，但攻击者将无法模仿真实服务器而没有相应的服务器私钥。出于测试目的，您可以选择忽略远程主机提供的密钥。
- en: This example is the most secure way to connect. It uses a key to authenticate,
    as opposed to a password, and it verifies the public key of the remote server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是连接最安全的方式。它使用密钥进行身份验证，而不是密码，并验证远程服务器的公钥。
- en: This method will use `ssh.ParseKnownHosts()`. This uses the standard `known_hosts`
    file. The `known_hosts` format is the standard for OpenSSH. The format is documented
    in the *sshd(8)* manual page.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将使用`ssh.ParseKnownHosts()`。这使用标准的`known_hosts`文件。`known_hosts`格式是OpenSSH的标准。该格式在*sshd(8)*手册页中有文档记录。
- en: Note that Go's `ssh.ParseKnownHosts()` will only parse a single entry, so you
    should create a unique file with a single entry for the server or ensure that
    the desired entry is at the top of the file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Go的`ssh.ParseKnownHosts()`只会解析单个条目，因此您应该创建一个包含服务器单个条目的唯一文件，或者确保所需的条目位于文件顶部。
- en: 'To obtain the remote server''s public key for verification, use `ssh-keyscan`.
    This returns the server key in the `known_hosts` format that will be used in the
    following example. Remember, the Go `ssh.ParseKnownHosts` command only reads the
    first entry from a `known_hosts` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取远程服务器的公钥以进行验证，请使用`ssh-keyscan`。这将以`known_hosts`格式返回服务器密钥，将在以下示例中使用。请记住，Go的`ssh.ParseKnownHosts`命令只读取`known_hosts`文件的第一个条目：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `ssh-keyscan` program will return multiple key types unless a key type
    is specified with the `-t` flag. Make sure that you choose the one with the desired
    key algorithm and that `ssh.ClientConfig()` has `HostKeyAlgorithm` listed to match.
    This example includes every possible `ssh.KeyAlgo*` option. I recommend that you
    choose the highest-strength algorithm possible and only allow that option:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssh-keyscan`程序将返回多个密钥类型，除非使用`-t`标志指定密钥类型。确保选择具有所需密钥算法的密钥类型，并且`ssh.ClientConfig()`中列出的`HostKeyAlgorithm`与之匹配。此示例包括每个可能的`ssh.KeyAlgo*`选项。我建议您选择尽可能高强度的算法，并且只允许该选项：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that, in addition to the `ssh.KeyAlgo*` constants, there are `ssh.CertAlgo*`
    constants if certificates are used.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了`ssh.KeyAlgo*`常量之外，如果使用证书，还有`ssh.CertAlgo*`常量。
- en: Executing a command over SSH
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过SSH执行命令
- en: Now that we have established multiple ways of authenticating and connecting
    to a remote SSH server, we need to put `ssh.Client` to work. So far we have only
    been printing out the client version. The first goal is to execute a single command
    and view the output.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了多种身份验证和连接到远程SSH服务器的方式，我们需要让`ssh.Client`开始工作。到目前为止，我们只是打印出客户端版本。第一个目标是执行单个命令并查看输出。
- en: Once `ssh.Client` is created, you can begin creating sessions. A client supports
    multiple sessions at once. A session has its own standard input, output, and error.
    They are standard reader and writer interfaces.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了`ssh.Client`，就可以开始创建会话。一个客户端可以同时支持多个会话。会话有自己的标准输入、输出和错误。它们是标准的读取器和写入器接口。
- en: 'To execute a command there are a few options: `Run()`, `Start()`, `Output()`,
    and `CombinedOutput()`. They are all very similar, but behave a little differently:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行命令，有几个选项：`Run()`、`Start()`、`Output()`和`CombinedOutput()`。它们都非常相似，但行为略有不同：
- en: '`session.Output(cmd)`: The `Output()` function will execute the command, and
    return `session.Stdout` as a byte slice.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.Output(cmd)`: `Output()`函数将执行命令，并将`session.Stdout`作为字节片返回。'
- en: '`session.CombinedOutput(cmd)`: This does the same as `Output()`, but it returns
    both standard output and standard error combined.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.CombinedOutput(cmd)`: 这与`Output()`相同，但它返回标准输出和标准错误的组合。'
- en: '`session.Run(cmd)`: The `Run()` function will execute the command and wait
    for it to finish. It will fill the standard output and error buffers, but it won''t
    do anything with them. You have to manually read the buffers or set the session
    output to go to the Terminal output before calling `Run()` (for example, `session.Stdout
    = os.Stdout`). It will only return without an error if the program exited with
    an error code of `0` and there were no issues copying the standard output buffers.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.Run(cmd)`: `Run()`函数将执行命令并等待其完成。它将填充标准输出和错误缓冲区，但不会对其进行任何操作。您必须手动读取缓冲区，或在调用`Run()`之前将会话输出设置为转到终端输出（例如，`session.Stdout
    = os.Stdout`）。只有在程序以错误代码`0`退出并且没有复制标准输出缓冲区时，它才会返回而不出现错误。'
- en: '`session.Start(cmd)`: The `Start()` function is similar to `Run()`, except
    that it will not wait for the command to finish. You must explicitly call `session.Wait()`
    if you want to block execution until the command is complete. This is useful for
    starting long running commands or if you want more control over the application
    flow.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.Start(cmd)`: `Start()`函数类似于`Run()`，但它不会等待命令完成。如果要阻塞执行直到命令完成，必须显式调用`session.Wait()`。这对于启动长时间运行的命令或者对应用程序流程有更多控制的情况非常有用。'
- en: 'A session can only perform one action. Once you call `Run()`, `Output()`, `CombinedOutput()`,
    `Start()`, or `Shell()`, you can''t use the session for executing any other commands.
    If you need to run multiple commands, you can string them together separated with
    a semicolon. For example, you can pass multiple commands in a single command string
    like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个会话只能执行一个操作。一旦调用`Run()`、`Output()`、`CombinedOutput()`、`Start()`或`Shell()`，就不能再使用该会话执行任何其他命令。如果需要运行多个命令，可以用分号将它们串联在一起。例如，可以像这样在单个命令字符串中传递多个命令：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Otherwise, you can create a new session for each command you need to run. One
    session equates to one command.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以为需要运行的每个命令创建一个新会话。一个会话等同于一个命令。
- en: 'The following example connects to a remote SSH server using key authentication,
    and then it creates a session using `client.NewSession()`. The standard output
    from the session is then connected to our local Terminal standard output before
    calling `session.Run()`, which will execute the command on the remote server:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用密钥认证连接到远程SSH服务器，然后使用`client.NewSession()`创建一个会话。然后将会话的标准输出连接到我们本地终端的标准输出，然后调用`session.Run()`，这将在远程服务器上执行命令：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Starting an interactive shell
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动交互式shell
- en: In the previous example, we demonstrated how to run command strings. There is
    also an option to open a shell. By calling `session.Shell()`, an interactive login
    shell is executed, loading whatever default shell the user has and loading the
    default profile (for example, `.profile`). The call to `session.RequestPty()`
    is optional, but the shell works much better when requesting a psuedoterminal.
    You can set the terminal name to `xterm`, `vt100`, `linux`, or something custom.
    If you have issues with jumbled output due to color values being output, try `vt100`,
    and if that still does not work, use a nonstandard terminal name or a terminal
    name you know does not support colors. Many programs will disable color output
    if they do not recognize the terminal name. Some programs will not work at all
    with an unknown terminal type, such as `tmux`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们演示了如何运行命令字符串。还有一个选项可以打开一个shell。通过调用`session.Shell()`，可以执行一个交互式登录shell，加载用户的默认shell和默认配置文件（例如`.profile`）。调用`session.RequestPty()`是可选的，但是当请求一个伪终端时，shell的工作效果要好得多。您可以将终端名称设置为`xterm`、`vt100`、`linux`或其他自定义名称。如果由于输出颜色值而导致输出混乱的问题，可以尝试使用`vt100`，如果仍然不起作用，可以使用非标准的终端名称或您知道不支持颜色的终端名称。许多程序会在不识别终端名称时禁用颜色输出。一些程序在未知的终端类型下根本无法工作，比如`tmux`。
- en: More information about Go terminal mode constants is available at [https://godoc.org/golang.org/x/crypto/ssh#TerminalModes](https://godoc.org/golang.org/x/crypto/ssh#TerminalModes).
    Terminal mode flags are a POSIX standard and are defined in *RFC 4254*,* Encoding
    of Terminal Modes* (section 8), which you can find at [https://tools.ietf.org/html/rfc4254#section-8](https://tools.ietf.org/html/rfc4254#section-8).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Go终端模式常量的更多信息，请访问[https://godoc.org/golang.org/x/crypto/ssh#TerminalModes](https://godoc.org/golang.org/x/crypto/ssh#TerminalModes)。终端模式标志是POSIX标准，并在*RFC
    4254*，*终端模式的编码*（第8节）中定义，您可以在[https://tools.ietf.org/html/rfc4254#section-8](https://tools.ietf.org/html/rfc4254#section-8)找到。
- en: 'The following example connects to an SSH server using key authentication, and
    then creates a new session with `client.NewSession()`. Instead of executing a
    command with `session.Run()` like the previous example, we will use `session.RequestPty()`
    to get an interactive shell. Standard input, output, and error streams from the
    remote session are all connected to the local Terminal, so you can interact with
    it in real time just like any other SSH client (for example, PuTTY):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用密钥认证连接到SSH服务器，然后使用`client.NewSession()`创建一个新会话。与前面的例子不同，我们将使用`session.RequestPty()`来获取一个交互式shell，远程会话的标准输入、输出和错误流都连接到本地终端，因此您可以像与任何其他SSH客户端（例如PuTTY）一样实时交互：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter, you should now understand how to use the Go SSH
    client to connect and authenticate using a password or a private key. In addition,
    you should now understand how to execute a command on a remote server or how to
    begin an interactive session.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您现在应该了解如何使用Go SSH客户端连接和使用密码或私钥进行身份验证。此外，您现在应该了解如何在远程服务器上执行命令或开始交互式会话。
- en: How would you apply an SSH client programmatically? Can you think of any use
    cases? Do you manage multiple remote servers? Could you automate any tasks?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何以编程方式应用SSH客户端？您能想到任何用例吗？您管理多个远程服务器吗？您能自动化任何任务吗？
- en: The SSH package also contains types and functions for creating an SSH server,
    but we have not covered them in this book. Read more about creating an SSH server
    at [https://godoc.org/golang.org/x/crypto/ssh#NewServerConn](https://godoc.org/golang.org/x/crypto/ssh#NewServerConn)
    and more about the SSH package overall at [https://godoc.org/golang.org/x/crypto/ssh](https://godoc.org/golang.org/x/crypto/ssh).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: SSH包还包含用于创建SSH服务器的类型和函数，但我们在本书中没有涵盖它们。阅读有关创建SSH服务器的更多信息，请访问[https://godoc.org/golang.org/x/crypto/ssh#NewServerConn](https://godoc.org/golang.org/x/crypto/ssh#NewServerConn)，以及有关SSH包的更多信息，请访问[https://godoc.org/golang.org/x/crypto/ssh](https://godoc.org/golang.org/x/crypto/ssh)。
- en: In the next chapter, we'll look at brute force attacks, where passwords are
    guessed until eventually a correct password is found. Brute forcing is something
    we can do with the SSH client, as well as other protocols and applications. Continue
    reading the next chapter to learn how to execute a brute force attack.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论暴力攻击，即猜测密码，直到最终找到正确的密码为止。暴力破解是我们可以使用SSH客户端以及其他协议和应用程序进行的操作。继续阅读下一章，了解如何执行暴力攻击。
