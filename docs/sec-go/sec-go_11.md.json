["```go\npackage main\n\nimport (\n   \"net\"\n   \"fmt\"\n   \"log\"\n)\n\nvar protocol = \"tcp\" // tcp or udp\nvar listenAddress = \"localhost:3000\"\n\nfunc main() {\n   listener, err := net.Listen(protocol, listenAddress)\n   if err != nil {\n      log.Fatal(\"Error creating listener. \", err)\n   }\n   log.Printf(\"Now listening for connections.\")\n\n   for {\n      conn, err := listener.Accept()\n      if err != nil {\n         log.Println(\"Error accepting connection. \", err)\n      }\n      go handleConnection(conn)\n   }\n}\n\nfunc handleConnection(conn net.Conn) {\n   incomingMessageBuffer := make([]byte, 4096)\n\n   numBytesRead, err := conn.Read(incomingMessageBuffer)\n   if err != nil {\n      log.Print(\"Error reading from client. \", err)\n   }\n\n   fmt.Fprintf(conn, \"Thank you. I processed %d bytes.\\n\", \n      numBytesRead)\n} \n```", "```go\npackage main\n\nimport (\n   \"net\"\n   \"log\"\n)\n\nvar protocol = \"tcp\" // tcp or udp\nvar remoteHostAddress = \"localhost:3000\"\n\nfunc main() {\n   conn, err := net.Dial(protocol, remoteHostAddress)\n   if err != nil {\n      log.Fatal(\"Error creating listener. \", err)\n   }\n   conn.Write([]byte(\"Hello, server. Are you there?\"))\n\n   serverResponseBuffer := make([]byte, 4096)\n   numBytesRead, err := conn.Read(serverResponseBuffer)\n   if err != nil {\n      log.Print(\"Error reading from server. \", err)\n   }\n   log.Println(\"Message recieved from server:\")\n   log.Printf(\"%s\\n\", serverResponseBuffer[0:numBytesRead])\n} \n```", "```go\npackage main\n\nimport (\n   \"strconv\"\n   \"log\"\n   \"net\"\n   \"time\"\n)\n\nvar ipToScan = \"127.0.0.1\"\nvar minPort = 0\nvar maxPort = 1024\n\nfunc main() {\n   activeThreads := 0\n   doneChannel := make(chan bool)\n\n   for port := minPort; port <= maxPort ; port++ {\n      go testTcpConnection(ipToScan, port, doneChannel)\n      activeThreads++\n   }\n\n   // Wait for all threads to finish\n   for activeThreads > 0 {\n      <- doneChannel\n      activeThreads--\n   }\n}\n\nfunc testTcpConnection(ip string, port int, doneChannel chan bool) {\n   _, err := net.DialTimeout(\"tcp\", ip + \":\" + strconv.Itoa(port), \n      time.Second*10)\n   if err == nil {\n      log.Printf(\"Port %d: Open\\n\", port)\n   }\n   doneChannel <- true\n} \n```", "```go\npackage main\n\nimport (\n   \"strconv\"\n   \"log\"\n   \"net\"\n   \"time\"\n)\n\nvar ipToScan = \"127.0.0.1\"\n\nfunc main() {\n   activeThreads := 0\n   doneChannel := make(chan bool)\n\n   for port := 0; port <= 1024 ; port++ {\n      go grabBanner(ipToScan, port, doneChannel)\n      activeThreads++\n   }\n\n   // Wait for all threads to finish\n   for activeThreads > 0 {\n      <- doneChannel\n      activeThreads--\n   }\n}\n\nfunc grabBanner(ip string, port int, doneChannel chan bool) {\n   connection, err := net.DialTimeout(\n      \"tcp\", \n      ip + \":\"+strconv.Itoa(port),  \n      time.Second*10)\n   if err != nil {\n      doneChannel<-true\n      return\n   }\n\n   // See if server offers anything to read\n   buffer := make([]byte, 4096)\n   connection.SetReadDeadline(time.Now().Add(time.Second*5)) \n   // Set timeout\n   numBytesRead, err := connection.Read(buffer)\n   if err != nil {\n      doneChannel<-true\n      return\n   }\n   log.Printf(\"Banner from port %d\\n%s\\n\", port,\n      buffer[0:numBytesRead])\n\n   doneChannel <- true\n} \n```", "```go\npackage main\n\nimport (\n   \"net\"\n   \"log\"\n)\n\nvar localListenAddress = \"localhost:9999\"\nvar remoteHostAddress = \"localhost:3000\" // Not required to be remote\n\nfunc main() {\n   listener, err := net.Listen(\"tcp\", localListenAddress)\n   if err != nil {\n      log.Fatal(\"Error creating listener. \", err)\n   }\n\n   for {\n      conn, err := listener.Accept()\n      if err != nil {\n         log.Println(\"Error accepting connection. \", err)\n      }\n      go handleConnection(conn)\n   }\n}\n\n// Forward the request to the remote host and pass response \n// back to client\nfunc handleConnection(localConn net.Conn) {\n   // Create remote connection that will receive forwarded data\n   remoteConn, err := net.Dial(\"tcp\", remoteHostAddress)\n   if err != nil {\n      log.Fatal(\"Error creating listener. \", err)\n   }\n   defer remoteConn.Close()\n\n   // Read from the client and forward to remote host\n   buf := make([]byte, 4096) // 4k buffer\n   numBytesRead, err := localConn.Read(buf)\n   if err != nil {\n      log.Println(\"Error reading from client.\", err)\n   }\n   log.Printf(\n      \"Forwarding from %s to %s:\\n%s\\n\\n\",\n      localConn.LocalAddr(),\n      remoteConn.RemoteAddr(),\n      buf[0:numBytesRead],\n   )\n   _, err = remoteConn.Write(buf[0:numBytesRead])\n   if err != nil {\n      log.Println(\"Error writing to remote host. \", err)\n   }\n\n   // Read response from remote host and pass it back to our client\n   buf = make([]byte, 4096)\n   numBytesRead, err = remoteConn.Read(buf)\n   if err != nil {\n      log.Println(\"Error reading from remote host. \", err)\n   }\n   log.Printf(\n      \"Passing response back from %s to %s:\\n%s\\n\\n\",\n      remoteConn.RemoteAddr(),\n      localConn.LocalAddr(),\n      buf[0:numBytesRead],\n   )\n   _, err = localConn.Write(buf[0:numBytesRead])\n   if err != nil {\n      log.Println(\"Error writing back to client.\", err)\n   }\n}\n```", "```go\nexport GODEBUG=netdns=go    # Use pure Go resolver (default)\nexport GODEBUG=netdns=cgo   # Use cgo resolver\n```", "```go\npackage main\n\nimport (\n   \"strconv\"\n   \"log\"\n   \"net\"\n   \"strings\"\n)\n\nvar subnetToScan = \"192.168.0\" // First three octets\n\nfunc main() {\n   activeThreads := 0\n   doneChannel := make(chan bool)\n\n   for ip := 0; ip <= 255; ip++ {\n      fullIp := subnetToScan + \".\" + strconv.Itoa(ip)\n      go resolve(fullIp, doneChannel)\n      activeThreads++\n   }\n\n   // Wait for all threads to finish\n   for activeThreads > 0 {\n      <- doneChannel\n      activeThreads--\n   }\n}\n\nfunc resolve(ip string, doneChannel chan bool) {\n   addresses, err := net.LookupAddr(ip)\n   if err == nil {\n      log.Printf(\"%s - %s\\n\", ip, strings.Join(addresses, \", \"))\n   }\n   doneChannel <- true\n} \n```", "```go\npackage main\n\nimport (\n   \"crypto/rand\"\n   \"log\"\n   \"net\"\n   \"strconv\"\n   \"time\"\n)\n\nvar ipToScan = \"www.devdungeon.com\"\nvar port = 80\nvar maxFuzzBytes = 1024\n\nfunc main() {\n   activeThreads := 0\n   doneChannel := make(chan bool)\n\n   for fuzzSize := 1; fuzzSize <= maxFuzzBytes; \n      fuzzSize = fuzzSize * 2 {\n      go fuzz(ipToScan, port, fuzzSize, doneChannel)\n      activeThreads++\n   }\n\n   // Wait for all threads to finish\n   for activeThreads > 0 {\n      <- doneChannel\n      activeThreads--\n   }\n}\n\nfunc fuzz(ip string, port int, fuzzSize int, doneChannel chan bool) {\n   log.Printf(\"Fuzzing %d.\\n\", fuzzSize)\n\n   conn, err := net.DialTimeout(\"tcp\", ip + \":\" + strconv.Itoa(port), \n      time.Second*10)\n   if err != nil {\n      log.Printf(\n         \"Fuzz of %d attempted. Could not connect to server. %s\\n\", \n         fuzzSize, \n         err,\n      )\n      doneChannel <- true\n      return\n   }\n\n   // Write random bytes to server\n   randomBytes := make([]byte, fuzzSize)\n   rand.Read(randomBytes)\n   conn.SetWriteDeadline(time.Now().Add(time.Second * 5))\n   numBytesWritten, err := conn.Write(randomBytes)\n   if err != nil { // Error writing\n      log.Printf(\n         \"Fuzz of %d attempted. Could not write to server. %s\\n\", \n         fuzzSize,\n         err,\n      )\n      doneChannel <- true\n      return\n   }\n   if numBytesWritten != fuzzSize {\n      log.Printf(\"Unable to write the full %d bytes.\\n\", fuzzSize)\n   }\n   log.Printf(\"Sent %d bytes:\\n%s\\n\\n\", numBytesWritten, randomBytes)\n\n   // Read up to 4k back\n   readBuffer := make([]byte, 4096)\n   conn.SetReadDeadline(time.Now().Add(time.Second *5))\n   numBytesRead, err := conn.Read(readBuffer)\n   if err != nil { // Error reading\n      log.Printf(\n         \"Fuzz of %d attempted. Could not read from server. %s\\n\", \n         fuzzSize,\n         err,\n      )\n      doneChannel <- true\n      return\n   }\n\n   log.Printf(\n      \"Sent %d bytes to server. Read %d bytes back:\\n,\n      fuzzSize,\n      numBytesRead, \n   )\n   log.Printf(\n      \"Data:\\n%s\\n\\n\",\n      readBuffer[0:numBytesRead],\n   )\n   doneChannel <- true\n} \n```"]