["```go\npackage main\n\nimport (\n   \"encoding/json\"\n   \"fmt\"\n   \"io/ioutil\"\n   \"log\"\n   \"net/http\"\n   \"os\"\n   \"time\"\n)\n\n// Define the structure of the JSON response\n// The json variable names are specified on\n// the right since they do not match the\n// struct variable names exactly\ntype redditUserJsonResponse struct {\n   Data struct {\n      Posts []struct { // Posts & comments\n         Data struct {\n            Subreddit  string  `json:\"subreddit\"`\n            Title      string  `json:\"link_title\"`\n            PostedTime float32 `json:\"created_utc\"`\n            Body       string  `json:\"body\"`\n         } `json:\"data\"`\n      } `json:\"children\"`\n   } `json:\"data\"`\n}\n\nfunc printUsage() {\n   fmt.Println(os.Args[0] + ` - Print recent Reddit posts by a user\n\nUsage: ` + os.Args[0] + ` <username>\nExample: ` + os.Args[0] + ` nanodano\n`)\n}\n\nfunc main() {\n   if len(os.Args) != 2 {\n      printUsage()\n      os.Exit(1)\n   }\n   url := \"https://www.reddit.com/user/\" + os.Args[1] + \".json\"\n\n   // Make HTTP request and read response\n   response, err := http.Get(url)\n   if err != nil {\n      log.Fatal(\"Error making HTTP request. \", err)\n   }\n   defer response.Body.Close()\n   body, err := ioutil.ReadAll(response.Body)\n   if err != nil {\n      log.Fatal(\"Error reading HTTP response body. \", err)\n   }\n\n   // Decode response into data struct\n   var redditUserInfo redditUserJsonResponse\n   err = json.Unmarshal(body, &redditUserInfo)\n   if err != nil {\n      log.Fatal(\"Error parson JSON. \", err)\n   }\n\n   if len(redditUserInfo.Data.Posts) == 0 {\n      fmt.Println(\"No posts found.\")\n      fmt.Printf(\"Response Body: %s\\n\", body)\n   }\n\n   // Iterate through all posts found\n   for _, post := range redditUserInfo.Data.Posts {\n      fmt.Println(\"Subreddit:\", post.Data.Subreddit)\n      fmt.Println(\"Title:\", post.Data.Title)\n      fmt.Println(\"Posted:\", time.Unix(int64(post.Data.PostedTime), \n         0))\n      fmt.Println(\"Body:\", post.Data.Body)\n      fmt.Println(\"========================================\")\n   }\n} \n```", "```go\npackage main\n\nimport (\n   \"log\"\n   \"net/smtp\"\n   \"strings\"\n)\n\nvar (\n   smtpHost   = \"smtp.gmail.com\"\n   smtpPort   = \"587\"\n   sender     = \"sender@gmail.com\"\n   password   = \"SecretPassword\"\n   recipients = []string{\n      \"recipient1@example.com\",\n      \"recipient2@example.com\",\n   }\n   subject = \"Subject Line\"\n)\n\nfunc main() {\n   auth := smtp.PlainAuth(\"\", sender, password, smtpHost)\n\n   textEmail := []byte(\n      `To: ` + strings.Join(recipients, \", \") + `\nMime-Version: 1.0\nContent-Type: text/plain; charset=\"UTF-8\";\nSubject: ` + subject + `\n\nHello,\n\nThis is a plain text email.\n`)\n\n   htmlEmail := []byte(\n      `To: ` + strings.Join(recipients, \", \") + `\nMime-Version: 1.0\nContent-Type: text/html; charset=\"UTF-8\";\nSubject: ` + subject + `\n\n<html>\n<h1>Hello</h1>\n<hr />\n<p>This is an <strong>HTML</strong> email.</p>\n</html>\n`)\n\n   // Send text version of email\n   err := smtp.SendMail(\n      smtpHost+\":\"+smtpPort,\n      auth,\n      sender,\n      recipients,\n      textEmail,\n   )\n   if err != nil {\n      log.Fatal(err)\n   }\n\n   // Send HTML version\n   err = smtp.SendMail(\n      smtpHost+\":\"+smtpPort,\n      auth,\n      sender,\n      recipients,\n      htmlEmail,\n   )\n   if err != nil {\n      log.Fatal(err)\n   }\n}\n```", "```go\ngo get github.com/skip2/go-qrcode/...\n```", "```go\npackage main \n\nimport (\n   \"encoding/base64\"\n   \"fmt\"\n   \"github.com/skip2/go-qrcode\"\n   \"log\"\n   \"os\"\n)\n\nvar (\n   pngData        []byte\n   imageSize      = 256 // Length and width in pixels\n   err            error\n   outputFilename string\n   dataToEncode   string\n)\n\n// Check command line arguments. Print usage\n// if expected arguments are not present\nfunc checkArgs() {\n   if len(os.Args) != 3 {\n      fmt.Println(os.Args[0] + `\n\nGenerate a QR code. Outputs a PNG file in <outputFilename>.\nAlso outputs an HTML img tag with the image base64 encoded to STDOUT.\n\n Usage: ` + os.Args[0] + ` <outputFilename> <data>\n Example: ` + os.Args[0] + ` qrcode.png https://www.devdungeon.com`)\n      os.Exit(1)\n   }\n   // Because these variables were above, at the package level\n   // we don't have to return them. The same variables are\n   // already accessible in the main() function\n   outputFilename = os.Args[1]\n   dataToEncode = os.Args[2]\n}\n\nfunc main() {\n   checkArgs()\n\n   // Generate raw binary data for PNG\n   pngData, err = qrcode.Encode(dataToEncode, qrcode.Medium, \n      imageSize)\n   if err != nil {\n      log.Fatal(\"Error generating QR code. \", err)\n   }\n\n   // Encode the PNG data with base64 encoding\n   encodedPngData := base64.StdEncoding.EncodeToString(pngData)\n\n   // Output base64 encoded image as HTML image tag to STDOUT\n   // This img tag can be embedded in an HTML page\n   imgTag := \"<img src=\\\"data:image/png;base64,\" + \n      encodedPngData + \"\\\"/>\"\n   fmt.Println(imgTag) // For use in HTML\n\n   // Generate and write to file with one function\n   // This is a standalone function. It can be used by itself\n   // without any of the above code\n   err = qrcode.WriteFile(\n      dataToEncode,\n      qrcode.Medium,\n      imageSize,\n      outputFilename,\n   )\n   if err != nil {\n      log.Fatal(\"Error generating QR code to file. \", err)\n   }\n} \n```", "```go\npackage main\n\nimport (\n   \"encoding/base64\"\n   \"fmt\"\n   \"log\"\n)\n\nfunc main() {\n   data := []byte(\"Test data\")\n\n   // Encode bytes to base64 encoded string.\n   encodedString := base64.StdEncoding.EncodeToString(data)\n   fmt.Printf(\"%s\\n\", encodedString)\n\n   // Decode base64 encoded string to bytes.\n   decodedData, err := base64.StdEncoding.DecodeString(encodedString)\n   if err != nil {\n      log.Fatal(\"Error decoding data. \", err)\n   }\n   fmt.Printf(\"%s\\n\", decodedData)\n} \n```", "```go\npackage main\n\nimport (\n   \"bytes\"\n   \"log\"\n   \"net\"\n)\n\nfunc handleConnection(conn net.Conn) {\n   log.Printf(\"Received connection from %s.\\n\", conn.RemoteAddr())\n   buff := make([]byte, 1024)\n   nbytes, err := conn.Read(buff)\n   if err != nil {\n      log.Println(\"Error reading from connection. \", err)\n   }\n   // Always reply with a fake auth failed message\n   conn.Write([]byte(\"Authentication failed.\"))\n   trimmedOutput := bytes.TrimRight(buff, \"\\x00\")\n   log.Printf(\"Read %d bytes from %s.\\n%s\\n\",\n      nbytes, conn.RemoteAddr(), trimmedOutput)\n   conn.Close()\n}\n\nfunc main() {\n   portNumber := \"9001\" // or os.Args[1]\n   ln, err := net.Listen(\"tcp\", \"localhost:\"+portNumber)\n   if err != nil {\n       log.Fatalf(\"Error listening on port %s.\\n%s\\n\",\n          portNumber, err.Error())\n   }\n   log.Printf(\"Listening on port %s.\\n\", portNumber)\n   for {\n      conn, err := ln.Accept()\n      if err != nil {\n         log.Println(\"Error accepting connection.\", err)\n      }\n      go handleConnection(conn)\n   }\n}\n```", "```go\npackage main\n\nimport (\n   \"bytes\"\n   \"fmt\"\n   \"log\"\n   \"net\"\n   \"os\"\n)\n\nfunc checkArgs() string {\n   if len(os.Args) != 2 {\n      fmt.Println(\"Usage: \" + os.Args[0] + \" <targetAddress>\")\n      fmt.Println(\"Example: \" + os.Args[0] + \" localhost:9001\")\n      os.Exit(0)\n   }\n   return os.Args[1]\n}\n\nfunc main() {\n   var err error\n   targetAddress := checkArgs()\n   conn, err := net.Dial(\"tcp\", targetAddress)\n   if err != nil {\n      log.Fatal(err)\n   }\n   buf := make([]byte, 1024)\n\n   _, err = os.Stdin.Read(buf)\n   trimmedInput := bytes.TrimRight(buf, \"\\x00\")\n   log.Printf(\"%s\\n\", trimmedInput)\n\n   _, writeErr := conn.Write(trimmedInput)\n   if writeErr != nil {\n      log.Fatal(\"Error sending data to remote host. \", writeErr)\n   }\n\n   _, readErr := conn.Read(buf)\n   if readErr != nil {\n      log.Fatal(\"Error when reading from remote host. \", readErr)\n   }\n   trimmedOutput := bytes.TrimRight(buf, \"\\x00\")\n   log.Printf(\"%s\\n\", trimmedOutput)\n} \n```", "```go\npackage main \n\nimport (\n   \"fmt\"\n   \"log\"\n   \"net/http\"\n)\n\n// Correctly formatted function declaration to satisfy the\n// Go http.Handler interface. Any function that has the proper\n// request/response parameters can be used to process an HTTP request.\n// Inside the request struct we have access to the info about\n// the HTTP request and the remote client.\nfunc logRequest(response http.ResponseWriter, request *http.Request) {\n   // Write output to file or just redirect output of this \n   // program to file\n   log.Println(request.Method + \" request from \" +  \n      request.RemoteAddr + \". \" + request.RequestURI)\n   // If POST not empty, log attempt.\n   username := request.PostFormValue(\"username\")\n   password := request.PostFormValue(\"pass\")\n   if username != \"\" || password != \"\" {\n      log.Println(\"Username: \" + username)\n      log.Println(\"Password: \" + password)\n   }\n\n   fmt.Fprint(response, \"<html><body>\")\n   fmt.Fprint(response, \"<h1>Login</h1>\")\n   if request.Method == http.MethodPost {\n      fmt.Fprint(response, \"<p>Invalid credentials.</p>\")\n   }\n   fmt.Fprint(response, \"<form method=\\\"POST\\\">\")\n   fmt.Fprint(response, \n      \"User:<input type=\\\"text\\\" name=\\\"username\\\"><br>\")\n   fmt.Fprint(response, \n      \"Pass:<input type=\\\"password\\\" name=\\\"pass\\\"><br>\")\n   fmt.Fprint(response, \"<input type=\\\"submit\\\"></form><br>\")\n   fmt.Fprint(response, \"</body></html>\")\n}\n\nfunc main() {\n   // Tell the default server multiplexer to map the landing URL to\n   // a function called logRequest\n   http.HandleFunc(\"/\", logRequest)\n\n   // Kick off the listener using that will run forever\n   err := http.ListenAndServe(\":8080\", nil)\n   if err != nil {\n      log.Fatal(\"Error starting listener. \", err)\n   }\n} \n```"]