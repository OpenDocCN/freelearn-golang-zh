# 8

# 通用算法超级能力

概述

本章将讨论 Go 的类型参数语法为开发者带来的灵活性和表达力。随着我们探索本章内容，我们将揭示创建超越单一变量类型限制的算法的方法。通过利用类型参数的力量，开发者能够创建代码的泛型版本，使其能够无缝地在多种类型上运行。本章将强调减少代码重复的同时，保留 Go 强类型系统内固有的稳健安全性的总体目标。

本章还将带您进入约束的世界，展示 Go 语言如何通过加固通用算法来防止意外错误，并帮助您了解何时使用通用算法而不是接口。通过实际示例和活动，您将掌握设计通用算法的技巧，并了解通用算法的超级能力。到本章结束时，您将具备深刻理解在 Go 语言中何时、为什么以及如何运用通用算法超级能力的知识。我们还将介绍一些最佳实践，并阐明何时使用接口与通用类型。

# Google 的 Go 团队始终在思考如何让 Go 开发者的生活更轻松，以及我们未来需要哪些工具、包和支持——始终以完全向后兼容的方式。在本章中，我们将扩展我们迄今为止获得的知识，并讨论 Go 泛型。

对于本章，您需要 Go 版本 1.21 或更高版本。本章的代码可以在[`github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08`](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08)找到。

# 简介

技术要求

泛型在 Go 1.18 版本中正式成为语言的一部分。Go 泛型提供了一种强大的开发代码的方法，可以消除重复，简化可读性，并使开发者能够在函数中使用多种类型。然而，权力越大，责任越大。让我们进一步讨论泛型。

# 何时使用泛型？

最终决定将泛型引入 Go 编程语言的决定并非易事。由于它们对语言的影响如此之大，因此记住我们作为开发者的根源，并不要让泛型这样的支持改变我们编写代码的方式。换句话说，您应该继续编写正常的 Go 代码，而不是从一开始就过度设计类型。这些都是根植于简单性和可读性的基本 Go 哲学，这些是语言的核心原则。

在将 Go 泛型集成到代码库时需要考虑的见解如下：

+   **编写正常的 Go 代码，不要设计类型**：从你典型的具体类型和简单函数开始，利用 Go 强大的静态类型和简洁性。泛型从未打算取代指导语言使用的根本原则，而是一个需要明智应用的工具。

+   **避免样板代码**：这是引入泛型到语言中的主要动机之一。当你发现自己为不同的类型编写重复且几乎相同的代码时，那么这是一个信号，表明泛型可以帮助简化你的实现。而不是为各种数据结构和类型重复逻辑，你可以创建与不同类型无缝工作的泛型函数或类型。这消除了代码冗余并提高了开发者对逻辑的维护性。

+   **考虑代码复杂性**：如果你的项目涉及复杂的数据结构或算法，泛型可以帮助抽象复杂性，使你的代码更易于理解。然而，要小心不要过度设计；只有在泛型真正简化你的代码时才引入泛型。

+   **增强代码灵活性**：泛型允许函数和数据结构与各种类型一起工作。如果你的代码需要适应不同的数据类型，同时不牺牲性能或安全性，那么泛型可以是一个宝贵的补充。

+   **对未来代码进行加固**：如果你预计会有变化或扩展，其中引入新类型很可能是必然的，那么尽早采用泛型可以加固你的代码，并减少未来大量重构的需求。

要查看泛型在 Go 中的实际应用，让我们首先看看一个常规函数的实现，使用直观的方法找到一个函数传入的整数值的最大值：

```go
package main
import "fmt"
func findMaxInt(nums []int) int {
    if len(nums) == 0 {
        return -1
    }
    max := nums[0]
    for _, num := range nums {
        if num > max {
            max = num
        }
    }
    return max
}
func main() {
    max := findMaxInt([]int{1, 32, 5, 8, 10, 11})
    fmt.Printf("max integer value: %v\n", max)
}
```

如果我们想要现在找到不同类型输入的最大值，例如浮点值，那么我们就必须添加一个包含重复逻辑的新函数：

```go
func findMaxFloat(nums []float64) float64 {
    if len(nums) == 0 {
        return -1
    }
    max := nums[0]
    for _, num := range nums {
        if num > max {
            max = num
        }
    }
    return max
}
```

你可以看到这已经重复了。如果我们想要检查额外类型的最大值，那么到目前为止，我们会有一大堆重复的逻辑。然而，现在我们可以看看拥有一个泛型最大值函数在这里如何有益：

```go
func findMaxGenericNum int | float64 Num {
    if len(nums) == 0 {
        return -1
    }
    max := nums[0]
    for _, num := range nums {
        if num > max {
            max = num
        }
    }
    return max
}
```

虽然这是一个简单的例子来寻找最大值，但我们通过将扩展代码转换为添加泛型并去除代码重复，使得代码更加简洁。你还可以看到，前面的函数签名使用了不同的符号，利用 Go 中的泛型允许函数接受整数输入或浮点数输入。现在，让我们引入类型参数，这是泛型的一个基本方面，有助于开发者提高代码的清晰度和可维护性，这将在我们前面的泛型函数签名中解释不同的符号。

# 类型参数

Go 函数的类型参数允许你使用支持泛型输入的类型来参数化一个函数。这是一种向编译器指定调用泛型函数时允许的类型的方式，并在给定函数中代表类型的占位符。类型参数列表看起来像正常的参数列表，但被方括号包围。例如，`[T any]` 声明了一个可以是任何类型的 `T` 类型参数。`any` 关键字在前一章中已经提到。

为了继续理解类型参数，让我们回到先前的示例代码中的最大泛型函数签名：

```go
func findMaxGenericNum int | float64 Num {
```

这表明我们的函数，名为 `findMaxGeneric`，包含一个类型参数 `Num`，它可以由整数或 float64 类型实例化。它将接受一个 `Num` 的切片，并返回结果的最大整数或 float64 值。

与类型参数相关的一个有趣的概念是类型集。在先前的示例函数签名中，我们讨论了 `Num` 可以由整数或 float64 类型实例化。这意味着 `Num` 类型参数的类型集是整数和 float64 类型的并集。因此，我们的 `findMaxGeneric` 函数可以用这些受约束允许的类型为 `Num` 调用。类型约束将在本章进一步讨论。

注意

类型参数通常使用大写字母来强调它们确实是类型。

我们可以使用以下代码调用泛型函数并传入我们的输入：

```go
maxGenericInt := findMaxGeneric([]int{1, 32, 5, 8, 10, 11})
```

我们传递给函数的数字被称为我们的类型参数。向函数提供类型参数称为实例化。在泛型中，当你为类型参数提供类型参数时，实例化很重要。类型参数是使用泛型函数时提供的或推断的实际类型。它是泛型代码实例化或调用时替换类型参数的具体类型。

此外，如果我们为我们的类型参数传递无效的类型参数，Go 编译器会报错。例如，如果我们尝试传递字符串值，我们会看到错误：

```go
string does not satisfy int | float64 (string missing in int | float64)
```

我们的代码没有正确编译，因为 Go 的类型系统阻止我们为我们的类型参数传递无效的类型参数。

## 活动 8.01 – 最小值

在这个活动中，我们编写一个简单的函数来计算最小值，其中输入可以是整数或 float64 类型：

1.  创建一个 `findMinGeneric` 函数，用于计算输入切片的最小值。

    输入只能为整数或 float64 类型。

1.  打印出整数和浮点值的结果最小值。

对于使用 `[]int{1, 32, 5, 8, 10, 11}` 的输入，你的输出应该如下所示：

```go
min value: 1
```

对于使用 `[]float64{1.1, 32.1, 5.1, 8.1, 10.1, 11.1}` 的输入，你的输出应该如下所示：

```go
min value: 1.1
```

注意

本活动的解决方案可以在本章的 GitHub 仓库文件夹中找到：[`github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08/Activity08.01`](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08/Activity08.01)。

类型参数在处理操作任何元素类型的切片、映射和通道的函数时很有用。此外，当函数具有这些类型的参数且不基于元素类型做出假设时，它可以被泛化——例如，返回任何映射类型的键。这在与通用数据结构（如链表或二叉树）一起使用时也很有用。用类型参数替换元素类型可以提供更通用的数据结构，这种结构具有更高的可重用性。你不应该过早地使用类型参数。等到你即将编写样板代码时再使用。过早的抽象可能导致不必要的复杂性，并使代码更难被他人理解。建议等到你遇到对泛型解决方案的具体需求时再使用，尤其是在面对重复模式或样板代码时。这种方法与 Go 的简单性和渐进式设计哲学相吻合，确保泛型引入代码库是有目的和合理的。

现在，让我们来探讨类型约束以及它们如何为我们提供一种指定类型参数必须具备的能力或属性的方法，以便与泛型函数一起使用。

# 类型约束

类型约束是函数类型参数的一种元类型。类型约束规定了任何给定类型参数允许的类型参数。

Go 泛型中的类型约束指的是定义类型集合的接口。这些接口在指定类型参数在处理泛型函数或类型时必须满足的要求或能力方面发挥着强大的作用。为了有效地使用这些接口，它们必须放置在所谓的“约束位置”中，具体是在类型参数列表中声明类型参数的地方。

在此约束位置，当声明泛型函数或类型时，约束是通过使用接口类型来定义类型参数的预期行为来表达的。这确保了提供的类型遵守指定的约束，允许泛型代码安全地操作它们。通过强制执行这些约束，Go 编译器可以在编译时进行彻底的类型检查，增强代码的可靠性和可维护性。

当处理更复杂类型时，通常您会声明约束为接口。约束允许任何实现了该接口的类型与函数一起使用。约束接口可以引用特定的更基本类型。使用约束接口可以帮助将类型约束提取为更易于阅读的形式。

包含对 Go 编程语言中添加的泛型约束的独立逻辑集，一个名为 `constraints` 的标准库包已被实验性地添加，您可以探索它以获取更多关于在处理类型参数时定义约束的见解。

## 练习 8.01 – 使用接口计算最大值

让我们看看如何将之前的最大逻辑扩展为更易于阅读的形式，使用接口作为我们的类型约束。现在，我们仍然只允许整数和 float64 值：

1.  创建一个新的文件夹并添加一个 `main.go` 文件。

1.  在 `main.go` 文件中，将主包名添加到文件顶部：

    ```go
    package main
    ```

1.  现在，添加我们将在此文件中使用的导入：

    ```go
    import (
      "fmt"
    )
    ```

1.  创建一个 `Number` 接口，它将代表我们允许作为输入的类型：

    ```go
    type Number interface {
        int | float64
    }
    ```

1.  创建一个函数，它接受一个数字切片并返回最大值：

    ```go
    func findMaxGenericNum Number Num {
    ```

1.  通过验证是否向函数传递了输入来确保有效输入：

    ```go
        if len(nums) == 0 {
            return -1
        }
    ```

1.  获取第一个值以设置一个占位符最大值，然后再检查剩余的值：

    ```go
        max := nums[0]
    ```

1.  遍历数字：

    ```go
        for _, num := range nums {
    ```

1.  检查当前数字是否大于占位符最大值，并在需要时将最大值重置为当前值：

    ```go
            if num > max {
                max = num
            }
    ```

1.  关闭 `for` 循环：

    ```go
        }
    ```

1.  返回最大值：

    ```go
        return max
    ```

1.  关闭函数：

    ```go
    }
    ```

1.  定义主函数：

    ```go
    func main() {
    ```

1.  调用我们的函数并打印出整数和 float64 输入的结果：

    ```go
        maxGenericInt := findMaxGeneric([]int{1, 32, 5, 8, 10, 11})
        fmt.Printf("max generic int: %v\n", maxGenericInt)
        maxGenericFloat := findMaxGeneric([]float64{1.1, 32.1, 5.1, 8.1, 10.1, 11.1})
        fmt.Printf("max generic float: %v\n", maxGenericFloat)
    ```

1.  关闭主函数：

    ```go
    }
    ```

运行前面的代码将显示以下输出：

```go
max generic int: 32
max generic float: 32.1
```

我们现在已经看到了如何通过定义一个 `Number` 接口来查找最大值，使我们的类型约束接口更易于阅读。您可以看到定义一个可以用于整数和 float64 值的函数的好处。

在上一章中，我们学习了大量的接口知识以及它们如何定义一组类型必须实现的方法。当使用泛型时，您可以通过指定它们必须满足某些接口要求来表达对用作类型参数的类型的约束。

对于类型参数，您可能会看到如 `comparable` 或定义特定方法的自定义接口等约束。让我们看看如何利用一个更复杂的 `comparable` 示例。

## 练习 8.02 – 计算农场物品的最大库存

假设有一个仓库，里面存放着不同的库存物品。我们可以使用泛型来计算农场不同物品的最大库存：

1.  创建一个新的文件夹并添加一个 `main.go` 文件。

1.  在 `main.go` 文件中，将主包名添加到文件顶部：

    ```go
    package main
    ```

1.  现在，添加我们将在此文件中使用的导入：

    ```go
    import (
      "fmt"
    )
    ```

1.  定义一个使用泛型查找最大农场库存的函数：

    ```go
    func FindLargestRanchStockK comparable, V int | float64 K {
    ```

1.  定义变量以保存迄今为止找到的最大库存和库存物品的名称：

    ```go
        var stock V
        var name K
    ```

1.  遍历映射，如果找到的新值大于当时的最大库存，则更新值为最大值并保存物品名称：

    ```go
        for k, v := range m {
            if v > stock {
                stock = v
                name = k
            }
        }
    ```

1.  返回牧场中库存量最大的物品的名称：

    ```go
        return name
    ```

1.  关闭函数：

    ```go
    }
    ```

1.  定义`main`函数：

    ```go
    func main() {
    ```

1.  定义我们的牧场库存物品：

    ```go
        animalStock := map[string]int{
            "Chicken": 5,
            "Cattle": 20,
            "Horses": 4,
         }
        miscStock := map[string]float64{
            "Hay": 5.5,
            "Feed": 1.2,
            "Fertilizer": 4.5,
         }
    ```

1.  调用我们的函数，并打印出牧场中库存量最大的物品的结果：

    ```go
        largestStockOnRanchInt := FindLargestRanchStock(animalStock)
        fmt.Printf("The largest stocked item on the ranch is %s\n", largestStockOnRanchInt)
        largestStockOnRanchFloat := FindLargestRanchStock(miscStock)
        fmt.Printf("The largest stocked item on the ranch is %s\n", largestStockOnRanchFloat)
    ```

1.  关闭`main`函数：

    ```go
    }
    ```

运行前面的代码显示以下输出：

```go
The largest stocked item on the ranch is Cattle
The largest stocked item on the ranch is Hay
```

我们现在看到了一个使用`comparable`的泛型示例。在函数中，我们对`K`类型参数的约束是`comparable`。这得益于 Go 使用`comparable`标准库提供的辅助器启用的常用约束类型。`comparable`允许任何值可以作为比较运算符（如`==`和`!=`）的操作数。Go 要求映射的键是可比较的，因此我们的映射键类型上的`comparable`声明对于在牧场映射中使用`K`作为键是必要的。如果我们没有声明`K`为`comparable`，那么 Go 编译器将拒绝在函数参数中引用`map[K]V`。

如您所见，Go 允许一种非常强大的接口类型形式来表达约束。我们可以轻松地扩展这个例子，使其适用于更复杂的接口和约束。

值得注意的是，用类型参数替换接口类型可以使数据的底层存储更高效。这也可能意味着代码可以避免类型断言，并在编译时进行全面类型检查。

既然我们已经讨论了类型参数和类型约束，让我们看看类型推断时发生了什么。

# 类型推断

Go 编译器从函数参数中推断我们想要使用的类型。这被称为类型推断。编译器将从类型参数约束中推断类型参数。

类型推断要么成功，要么失败。当编译器发现问题时，它会抱怨，并提供了需要纠正的类型参数。使用泛型旨在简单；然而，类型推断的底层细节非常复杂。这也是作者们正在迭代以改进的内容。

到目前为止，当我们谈到调用泛型函数时，我们已经介绍了如何通过在方括号中指定类型名称来指定类型参数。这允许编译器知道在您调用的函数中替换类型参数。然而，您可以选择省略类型参数，因为大多数情况下 Go 可以推断它们。但是，通过省略类型参数来简化代码并不总是可能的。当编译器运行您的代码时，它会将每个类型参数替换为具体的类型。

这可以通过我们许多函数签名中的具体例子来看到，我们允许编译器推断我们的类型。例如，在上一个练习中，我们讨论了牧场物品库存。我们的函数签名在代码中如下所示：

```go
largestStockOnRanchInt := FindLargestRanchStock(animalStock)
```

此调用允许编译器推断 `animalStock` 的类型。然而，它也等同于以下：

```go
largestStockOnRanchInt := FindLargestRanchStockstring, int
```

在这里，我们明确声明了传递给我们的键和值的类型。在处理泛型函数时，有一些情况下可能无法或不建议依赖编译器推断类型：

+   `PrintType` 函数用于打印值的类型。如果你传入一个字符串，它应该识别为字符串；如果你传入一个整数，它应该识别为整数。在调用此函数时，你明确使用 `PrintType("Hello")`、`PrintType(42)`、`PrintType(3.14)` 等方式声明类型。

+   `PrintTwoTypes` 函数接受两个可能不同类型的参数。在调用此函数时，你可能出于各种原因明确指定类型。然后，`PrintTwoTypes` 可以定义为一个整数和一个字符串参数，并按此方式使用 - `PrintTwoTypes(42, "Hello")`。

+   `ChainCalls`，处理一个值然后调用另一个函数 `AnotherFunction`。在这里，你可能明确声明链式调用的类型以确保流畅性。

你还可以添加显式类型以在复杂场景中增加清晰度或提高可读性，减少在类型推断时花费的调试时间。

# 何时使用泛型与接口

在 Go 中何时使用泛型与接口的问题通常取决于你解决问题的本质和代码的具体要求。

Go 中的泛型允许你编写可以在多种类型上操作的功能或数据结构，而不会牺牲类型安全。使用泛型，你可以创建与不同类型一起工作的函数或结构，无需代码重复，同时保持编译时的安全检查。

Go 中的接口定义了一组方法签名。任何实现接口所有方法的类型都被说成是满足接口的。接口提供了一种在 Go 中实现多态的方法，使代码能够与共享一组共同行为的不同类型一起工作。接口在技术上是一种泛型编程的形式，允许开发者捕获不同类型的共同方面并将它们作为方法表达。这不仅提供了一个很好的抽象层，还避免了重复逻辑。

当你的工作需要其他可能实现或你希望捕获的特定行为时，你应该使用接口。泛型在编写类型无关函数和方法时，对于在静态类型语言中保持编译时的类型安全非常有用。对于不同的用例，还可以考虑性能和优化基准测试等其他因素。

# 有哪些最佳实践？

在处理泛型代码时，以下是一些值得考虑的最佳实践：

+   **优先使用函数而非方法**：方法是与类型关联的函数，并通过接收者调用；因此，在泛型的上下文中，函数更灵活，因为它不受特定类型的限制。这允许更容易的重用，以及将不同类型的函数组合在一起的能力。

+   **转换的简便性**：将方法转换为函数比向类型中添加函数要容易。函数可以独立于特定类型定义。在泛型的上下文中，你可以使用满足所需约束的任何类型的泛型函数。如果后来有理由将其转换为方法，那么你可以更容易地这样做，而无需修改原始函数。

+   `comparable`。这为未来在处理类型参数和更广泛类型的函数使用中提供了灵活性。

在 Go 中使用泛型时，也要注意可能涉及的复杂性。它们是我们工具箱中的工具，要明智和正确地使用。通过这样做，你可以利用泛型的力量，而不会损害定义 Go 编程语言的简洁性和可读性。

# 摘要

在本章中，我们探讨了 Go 泛型的世界，这是语言的一项突破性增强，提供了诸如类型参数、约束和类型推断等关键特性。类型参数，封装在方括号内，作为多才多艺的占位符出现，使得在不了解它们将要与之交互的具体类型的情况下，也能创建函数和数据结构。引入如`comparable`之类的约束增强了类型安全性和清晰度，确保泛型构造遵循特定的规则或接口。此外，编译器的类型推断开启了一个简洁和精简代码的新时代，开发者可以借助静态类型而不必承担显式类型注解的负担。

虽然 Go 泛型仍在不断完善和添加中，但它是一项强大的补充，旨在赋予开发者以前所未有的轻松程度编写高效、可重用代码的能力。现在我们知道了如何利用泛型编写最优和可重用代码，我们可以在下一章中扩展这一知识。在那里，我们将通过涵盖 Go 模块和了解如何在大规模和协作努力中重用代码来加深我们的理解。

# 第三部分：模块

模块作为各种应用程序使用的可重用代码的存储库。无论大小，模块都使得代码组织高效，并提高了可重用性。在本节中，你将学习如何有效地创建和管理模块，利用包和外部模块来简化你的开发过程。

本部分包含以下章节：

+   *第九章*，*使用 Go 模块定义项目*

+   *第十章*, *保持项目可管理*

+   *第十一章*, *解决虫害的调试技巧*,

+   *第十二章*, *关于时间*
