# 3. 核心类型

概述

本章旨在向你展示如何使用 Go 的基本核心类型来设计你的软件数据。我们将逐一研究每种类型，以展示它们有什么用以及如何在你的软件中使用它们。理解这些核心类型为你提供了学习如何创建复杂数据设计所需的基础。

在本章结束时，你将能够为 Go 程序创建不同类型的变量，并将值分配给不同类型的变量。你将学会识别并选择任何编程情况下的合适类型。你还将编写一个程序来测量密码复杂度并实现空值类型。

# 简介

在上一章中，我们学习了如何在 Go 中使用 `if`、`if-else`、`switch`、`continue` 和 `break`。

Go 是一种强类型语言，所有数据都被分配了一个类型。这个类型是固定的，不能更改。你可以和不能对你的数据做的事情受到你分配的类型所限制。准确理解定义 Go 每个核心类型的因素对于成功使用 Go 语言至关重要。

在后面的章节中，我们将讨论 Go 的更复杂类型，但这些类型是基于本章定义的核心类型构建的。

Go 的核心类型经过深思熟虑，一旦你了解了细节，它们就很容易理解。需要理解细节意味着 Go 的类型系统并不总是直观的。例如，Go 最常见的数字类型 `int` 的大小可能是 32 位或 64 位，这取决于编译代码所使用的计算机。

类型是使数据对人类更容易处理所必需的。计算机只考虑二进制数据。二进制对人类来说很难处理。通过在二进制数据上添加一层抽象并将其标记为数字或某些文本，人类更容易对其进行分析。减少认知负担使得人们能够构建更复杂的软件，因为他们不会被管理二进制数据细节所淹没。

编程语言需要定义数字或文本是什么。编程语言定义了你可以称为数字的内容，并定义了你可以在数字上使用的操作。例如，整数 10 和浮点数 3.14 是否都可以存储为同一类型？虽然显然你可以乘以数字，但你能否乘以文本？随着我们进入本章，我们将明确定义每种类型的规则以及你可以与它们一起使用的操作。

数据的存储方式也是定义 `type` 的重要组成部分。为了允许构建高效的软件，Go 对其某些类型的大小施加了限制。例如，Go 核心类型中数字的最大存储量是 64 位内存。这允许存储任何高达 18,446,744,073,709,551,615 的数字。理解这些类型限制对于构建无错误的代码至关重要。

定义类型的因素包括：

+   你可以在其中存储的数据类型

+   你可以使用哪些操作

+   这些操作对其有何影响

+   它能使用多少内存

本章将为你提供使用 Go 类型系统正确编写代码的知识和信心。

# 真和假

使用布尔类型`bool`表示真和假逻辑。当你在代码中需要一个开/关切换时使用此类型。`bool`的值只能是`true`或`false`。`bool`的零值是`false`。

当使用比较运算符如`==`或`>`时，该比较的结果是一个`bool`值。

在此代码示例中，我们在两个数字上使用比较运算符。你会看到结果是`bool`：

```go
package main
import "fmt"
func main() {
  fmt.Println(10 > 5)
  fmt.Println(10 == 5)
}
```

运行前面的代码将显示以下输出：

```go
true
false
```

## 练习 3.01：测量密码复杂性的程序

在此练习中，我们将编写一个程序，用于创建用户账户并接受长度为 8-15 个字符的密码。该门户的密码要求如下：

+   包含一个小写字母

+   包含一个大写字母

+   包含一个数字

+   包含一个符号

+   至少 8 个字符长

为了完成此练习，我们将使用一些新功能。如果你不完全理解它们的作用，不要担心；我们将在下一章中详细讲解。这只是一个预览。我们将随着解释逐步解释每一件事，但你的主要焦点应该是布尔逻辑：

1.  创建一个新的文件夹并添加一个`main.go`文件。

1.  在`main.go`中，将主包名添加到文件顶部：

    ```go
    package main
    ```

1.  现在添加我们将在此文件中使用的导入：

    ```go
    import (
      "fmt"
      "unicode"
    )
    ```

1.  创建一个接受字符串参数并返回`bool`的函数：

    ```go
    func passwordChecker(pw string) bool {
    ```

1.  将密码字符串转换为`rune`，这是一个适用于多字节（UTF-8）字符的安全类型：

    ```go
      pwR := []rune(pw)
    ```

    我们将在本章后面更详细地讨论`rune`。

1.  使用`len`计算多字节字符的数量。此代码产生一个可用于`if`语句的`bool`结果：

    ```go
      if len(pwR) < 8 {
        return false
      }
    ```

1.  定义一些`bool`变量。我们将在最后检查这些变量：

    ```go
      hasUpper := false
      hasLower := false
      hasNumber := false
      hasSymbol := false
    ```

1.  逐个遍历多字节字符：

    ```go
      for _, v := range pwR {
    ```

1.  使用`unicode`包检查该字符是否为大写。此函数返回一个`bool`，我们可以在`if`语句中直接使用：

    ```go
      if unicode.IsUpper(v) {
    ```

1.  如果是，我们将设置`hasUpper` `bool`变量为`true`：

    ```go
        hasUpper = true
      }
    ```

1.  对于小写字母也做同样的事情：

    ```go
      if unicode.IsLower(v) {
        hasLower = true
      }
    ```

1.  同样也应用于数字：

    ```go
      if unicode.IsNumber(v) {
        hasNumber = true
      }
    ```

1.  对于符号，我们还将接受标点符号。使用`or`运算符，它与`Booleans`一起工作，如果这些函数中的任何一个返回`true`，则结果为`true`：

    ```go
      if unicode.IsPunct(v) || unicode.IsSymbol(v)  {
        hasSymbol = true
      }
      }
    ```

1.  为了通过所有检查，所有变量都必须是`true`。在这里，我们使用多个`and`运算符创建一个检查所有四个变量的单行语句：

    ```go
      return hasUpper && hasLower && hasNumber && hasSymbol
    ```

1.  关闭函数：

    ```go
    }
    ```

1.  创建`main()`函数：

    ```go
    func main() {
    ```

1.  使用无效密码调用`passwordChecker()`函数。由于它返回一个`bool`，可以直接在`if`语句中使用：

    ```go
      if passwordChecker("") {
      fmt.Println("password good")
      } else {
      fmt.Println("password bad")
      }
    ```

1.  现在，使用有效密码调用该函数：

    ```go
      if passwordChecker("This!I5A") {
      fmt.Println("password good")
      } else {
      fmt.Println("password bad")
      }
    ```

1.  关闭`main()`函数：

    ```go
    }
    ```

1.  保存文件并在新文件夹中运行以下命令：

    ```go
    go run main.go
    ```

    运行前面的代码会显示以下输出：

```go
password bad
password good
```

在这个练习中，我们强调了`bool`值在代码中表现出的各种方式。`Bool`值对于赋予你的代码选择能力和动态响应能力至关重要。没有`bool`，你的代码将很难做任何事情。

接下来，我们将看看数字以及 Go 如何对它们进行分类。

# 数字

Go 有两种不同的数字类型：整数，也称为整数，和浮点数。浮点数允许一个数既有整数部分也有分数部分。

1、54 和 5,436 是整数示例。1.5、52.25、33.333 和 64,567.00001 都是浮点数示例。

备注

所有数字类型的默认值和空值都是 0。

接下来，我们将从查看整数开始我们的数字之旅。

## 整数

整数类型根据以下条件分为两种：

+   是否可以存储负数

+   它们能存储的最小和最大数字

可以存储负数的类型称为有符号整数。不能存储负数的类型称为无符号整数。每种类型可以存储的数字大小通过它们内部存储的字节数来表示。

这里是 Go 语言规范中所有相关整数类型的一段摘录：

![图 3.01：Go 语言规范及相关整数类型](img/B14177_03_01.jpg)

图 3.01：Go 语言规范及相关整数类型

以下是一些特殊的整数类型：

![图 3.02：特殊整数类型](img/B14177_03_02.jpg)

图 3.02：特殊整数类型

`uint`和`int`的位数取决于你是否为 32 位系统或 64 位系统编译代码。现在在 32 位系统上运行应用程序的情况很少见，因此大多数时候它们是 64 位的。

在 64 位系统上的`int`不是`int64`。虽然这两种类型是相同的，但它们不是同一整数类型，你不能将它们一起使用。如果 Go 允许这样做，当相同的代码在 32 位机器上编译时会出现问题，因此将它们分开可以确保代码的可靠性。

这种不兼容性不仅仅是`int`的问题；你不能将任何整数类型一起使用。

在定义变量时选择正确的整数类型很容易：使用`int`。在编写应用程序代码时，`int`大多数时候都能完成任务。只有当`int`导致问题时才考虑使用其他类型。你看到的与`int`相关的问题通常与内存使用有关。

例如，假设你有一个内存即将耗尽的程序。该程序使用大量的整数，但这些整数永远不会是负数，并且不会超过 255。一个可能的解决方案是将`int`的使用切换到`uint8`。这样做可以将每个数字的内存使用从 64 位（8 字节）减少到 8 位（1 字节）。

我们可以通过创建这两种类型的集合然后询问 Go 语言它正在使用多少堆内存来展示这一点。输出可能会因您的计算机而异，但效果应该是相似的。此代码创建了一个 `int` 或 `int8` 类型的集合。然后它向集合中添加了 1000 万个值。一旦完成，它使用运行时包来给我们一个正在使用的堆内存的读数。我们将该读数转换为 MB 并打印出来：

```go
package main
import (
  "fmt"
  "runtime"
)
func main() {
  var list []int
  //var list []int8
  for i := 0; i < 10000000; i++ {
    list = append(list, 100)
  }
  var m runtime.MemStats
  runtime.ReadMemStats(&m)
  fmt.Printf("TotalAlloc (Heap) = %v MiB\n", m.TotalAlloc/1024/1024)
}
```

这是使用 `int` 的输出：

```go
TotalAlloc (Heap) = 403 MiB 
```

这是使用 `int8` 的输出：

```go
TotalAlloc (Heap) = 54 MiB 
```

我们在这里节省了相当多的内存，但我们需要 1000 万个变量才能使其变得值得。希望现在您已经相信，从 `int` 类型开始是完全可以的，只有在有问题时才关注性能，而不是在之前。

接下来，我们将查看浮点数。

## 浮点数

Go 语言有两种浮点数类型，`float32` 和 `float64`。较大的 `float64` 类型允许在数字上提供更高的精度。`float32` 类型有 32 位存储空间，而 `float64` 类型有 64 位存储空间。浮点数将它们的存储空间分配给整数部分（小数点左侧的所有内容）和小数部分（小数点右侧的所有内容）。用于整数部分或小数部分的存储空间量因存储的数字而异。例如，9,999.9 会为整数部分使用更多的存储空间，而 9.9999 会为小数部分使用更多的存储空间。由于 `float64` 类型有更大的存储空间，它可以存储比 `float32` 类型更多的整数和/或小数。

## 练习 3.02：浮点数精度

在这个练习中，我们将比较当我们对不能整除的数字进行除法运算时会发生什么。我们将用 100 除以 3。表示结果的一种方式是 33 ⅓。大多数计算机无法计算这样的分数。相反，它们使用十进制表示法，即 33.3 重复，小数点后的 3 永远重复。如果我们让计算机这样做，它会耗尽所有内存，这并不很有帮助。

幸运的是，我们不需要担心这种情况发生，因为浮点数类型有存储限制。缺点是这会导致一个不反映真实结果的数字；结果有一定的误差。您对误差的容忍度和您想要为浮点数提供的存储空间量必须得到平衡：

1.  创建一个新的文件夹并添加一个 `main.go` 文件。

1.  在 `main.go` 文件中，将主包名添加到文件顶部：

    ```go
    package main
    ```

1.  现在添加我们将在此文件中使用的导入：

    ```go
    import "fmt"
    ```

1.  创建 `main()` 函数：

    ```go
    func main() {
    ```

1.  声明一个 `int` 类型并初始化它为 100：

    ```go
      var a int = 100
    ```

1.  声明一个 `float32` 类型并初始化它为 100：

    ```go
      var b float32 = 100
    ```

1.  声明一个 `float64` 类型并初始化它为 100：

    ```go
      var c float64 = 100
    ```

1.  将每个变量除以 3 并将结果打印到控制台：

    ```go
      fmt.Println(a / 3)
      fmt.Println(b / 3)
      fmt.Println(c / 3)
    }
    ```

1.  保存文件并在新文件夹中运行以下命令：

    ```go
    go run main.go
    ```

    运行前面的代码会显示以下输出，显示 `int`、`float32` 和 `float64` 的值：

    ```go
    33
    33.333332
    33.333333333333336
    ```

在这个练习中，我们可以看到计算机不能给出这种类型除法的完美答案。你还可以看到，在进行这种整数数学运算时，你不会得到错误。Go 会忽略数字的任何分数部分，这通常不是你想要的。我们还可以看到`float64`比`float32`给出了更精确的答案。

虽然这个限制看起来可能会导致精度问题，但在现实世界的商业工作中，它大多数时候都能很好地完成任务。

让我们看看如果我们尝试通过乘以 3 将数字恢复到 100 会发生什么：

```go
package main
import "fmt"
func main() {
  var a int = 100
  var b float32 = 100
  var c float64 = 100
  fmt.Println((a / 3) * 3)
  fmt.Println((b / 3) * 3)
  fmt.Println((c / 3) * 3)
}
```

运行前面的代码会显示以下输出：

```go
99
100
100
```

在这个例子中，我们看到精度的影响并没有像你预期的那样大。乍一看，浮点数学可能看起来很简单，但它很快就会变得复杂。当定义你的浮点变量时，通常`float64`应该是你的首选，除非你需要更高效的内存使用。

接下来，我们将看看当你超出数字类型的限制时会发生什么。

## 溢出和环绕

当你尝试用一个超出我们使用的类型值的数字初始化时，你会得到一个溢出错误。`int8`中可以有的最大数字是 127。在下面的代码中，我们将尝试用 128 初始化它并看看会发生什么：

```go
package main
import "fmt"
func main() {
  var a int8 = 128
  fmt.Println(a)
}
```

运行前面的代码会得到以下输出：

![图 3.03：初始化为 128 后的输出](img/B14177_03_03.jpg)

图 3.03：初始化为 128 后的输出

这个错误很容易修复，不会引起任何隐藏的问题。真正的问题是当编译器无法捕获它时。当这种情况发生时，数字将".环绕"。环绕意味着数字从它的可能最大值变为可能的最小值。在开发你的代码时，环绕可能很容易被忽略，并可能对你的用户造成重大问题。

## 练习 3.03：触发数字环绕

在这个练习中，我们将声明两个小的整数类型：`int8`和`uint8`。我们将它们初始化在它们可能的最大值附近。然后我们将使用循环语句每次循环增加 1，然后将它们的值打印到控制台。我们将能够看到它们何时环绕。

1.  创建一个新的文件夹并添加一个`main.go`文件。

1.  在`main.go`文件顶部添加主包名：

    ```go
    package main
    ```

1.  现在添加我们将在这个文件中使用的导入：

    ```go
    import "fmt"
    ```

1.  创建主函数：

    ```go
    func main() {
    ```

1.  声明一个初始值为 125 的`int8`变量：

    ```go
      var a int8 = 125
    ```

1.  声明一个初始值为 253 的`uint8`变量：

    ```go
      var b uint8 = 253
    ```

1.  创建一个运行五次的`for i`循环：

    ```go
      for i := 0; i < 5; i++ {
    ```

1.  将两个变量增加 1：

    ```go
        a++
        b++
    ```

1.  将变量的值打印到控制台：

    ```go
        fmt.Println(i, ")", "int8", a, "uint8", b)
    ```

1.  关闭循环：

    ```go
      }
    ```

1.  关闭`main()`函数：

    ```go
    }
    ```

1.  保存文件，并在新文件夹中运行以下命令：

    ```go
    go run main.go
    ```

    运行前面的代码会显示以下输出：

![图 3.04：环绕后的输出](img/B14177_03_04.jpg)

图 3.04：环绕后的输出

在这个练习中，我们看到，对于有符号整数，你最终会得到一个负数，而对于无符号整数，它会回绕到 0。你必须始终考虑变量的最大可能数值，并确保有适当的数据类型来支持该数值。

接下来，我们将查看当你需要一个比核心类型能提供的数值更大的数值时，你可以做什么。

## 大数

如果你需要一个比`int64`或`uint64`能提供的数值更高或更低的数值，你可以使用`math/big`包。与处理整数类型相比，这个包使用起来可能有些别扭，但你可以使用它的 API 完成所有通常可以用整数完成的事情。

## 练习 3.04：大数

在这个练习中，我们将创建一个比 Go 语言核心数字类型所能提供的更大的数值。为了展示这一点，我们将使用加法操作。我们还将对`int`做同样的操作以展示差异。然后，我们将打印结果到控制台：

1.  创建一个新的文件夹并添加一个`main.go`文件。

1.  在`main.go`文件中，将主包名添加到文件顶部：

    ```go
    package main
    ```

1.  现在添加我们将在这个文件中使用的导入：

    ```go
    import (
      "fmt"
      "math"
      "math/big"
    )
    ```

1.  创建`main()`函数：

    ```go
    func main() { 
    ```

1.  声明一个`int`类型变量并将其初始化为`math.MaxInt64`，这是 Go 语言中`int64`类型可能的最大值，它被定义为常量：

    ```go
      intA := math.MaxInt64
    ```

1.  将 1 加到`int`上：

    ```go
      intA = intA + 1
    ```

1.  现在我们将创建一个`big`类型的`int`。这是一个自定义类型，它不是基于 Go 语言的`int`类型。我们还将使用 Go 语言的最大数值来初始化它：

    ```go
      bigA := big.NewInt(math.MaxInt64)
    ```

1.  我们将给我们的`big`类型的`int`加 1。你可以看到这感觉有些笨拙：

    ```go
      bigA.Add(bigA, big.NewInt(1))
    ```

1.  打印出最大`int`大小以及我们的 Go `int`和`big` `int`的值：

    ```go
      fmt.Println("MaxInt64: ", math.MaxInt64)
      fmt.Println("Int   :", intA)
      fmt.Println("Big Int : ", bigA.String())
    ```

1.  关闭`main()`函数：

    ```go
    }
    ```

1.  保存文件，并在新文件夹中运行以下命令：

    ```go
    go run main.go
    ```

    运行前面的代码将显示以下输出：

![图 3.5：使用 Go 的数字类型显示大数的输出![图片](img/B14177_03_05.jpg)

图 3.5：使用 Go 的数字类型显示大数的输出

在这个练习中，我们看到`int`已经溢出，而`big.Int`正确地添加了数值。

如果你有一个数值高于 Go 能够处理的数值的情况，那么你需要使用标准库中的`big`包。接下来，我们将查看一个用于表示原始数据的特殊 Go 语言数字类型。

# 字节

Go 语言中的`byte`类型只是`uint8`的别名，它是一个有 8 位存储空间的数值。实际上，`byte`是一个重要的类型，你会在很多地方看到它。位是一个单一的二进制值，一个单一的开关。将位分组为 8 位是早期计算中的常见标准，并成为几乎通用的数据编码方式。8 位有 256 种“关闭”和“开启”的组合，`uint8`有从 0 到 255 的 256 个可能的整数值。所有开启和关闭的组合都可以用这种类型表示。

你会在读取和写入网络连接以及读取和写入文件时看到`byte`的使用。

到这里，我们关于数字的部分就结束了。现在，让我们看看 Go 如何存储和管理文本。

# 文本

Go 有一个单一的类型来表示一些文本，即 `string`。

当你为 `string` 写一些文本时，它被称为字符串字面量。在 Go 中有两种字符串字面量：

+   原始 – 通过将文本包裹在一对 `` ` ``

+   解释过的 – 通过将文本包裹在一对 `"`

使用原始字符串，最终出现在你的变量中的正是你在屏幕上看到的文本。使用解释过的字符串，Go 会扫描你所写的文本，然后根据它自己的规则集应用转换。

这看起来是这样的：

```go
package main

import "fmt"

func main() {
  comment1 := `This is the BEST
thing ever!`
  comment2 := `This is the BEST\nthing ever!`
  comment3 := "This is the BEST\nthing ever!"

  fmt.Print(comment1, "\n\n")
  fmt.Print(comment2, "\n\n")
  fmt.Print(comment3, "\n")
}
```

运行前面的代码会得到以下输出：

![图 3.6：输出打印文本](img/B14177_03_06.jpg)

图 3.6：输出打印文本

在解释过的字符串中，`\n` 表示换行。在我们的原始字符串中，`\n` 不会做任何事情。要在原始字符串中获得换行，我们必须在我们的代码中添加一个实际的新行。解释过的字符串必须使用 `\n` 来获得换行，因为在解释过的字符串中不允许有实际的换行。

虽然你可以用解释过的字符串字面量做很多事情，但在实际代码中，你更常见的是 `\n` 用于换行，偶尔 `\t` 用于制表符。

解释过的字符串字面量在现实世界的代码中是最常见的，但原始字面量也有其位置。如果你需要复制和粘贴包含大量换行符、`"` 或 `\` 的文本，使用 **原始** 更容易。

在下面的示例中，你可以看到使用原始字符串如何使代码更易读：

```go
package main
import "fmt"
func main() {
  comment1 := `In "Windows" the user directory is "C:\Users\"`
  comment2 := "In \"Windows\" the user directory is \"C:\\Users\\\""
  fmt.Println(comment1)
  fmt.Println(comment2)
}
```

运行前面的代码会显示以下输出：

![图 3.7：更易读的代码输出](img/B14177_03_07.jpg)

图 3.7：更易读的代码输出

在原始字面量中你不能有 `` ` ``。如果你需要一个包含 `` ` `` 的字面量，你必须使用解释过的字符串字面量。

字符串字面量只是将一些文本放入 `string` 类型变量的方式。一旦你有了变量的值，就没有区别了。

接下来，我们将探讨如何安全地处理多字节字符串。

## Rune

`rune` 是一种类型，它有足够的存储空间来存储单个 UTF-8 多字节字符。字符串字面量使用 UTF-8 编码。UTF-8 是一种非常流行和常见的多字节文本编码标准。`string` 类型本身并不限于 UTF-8，因为 Go 需要支持除了 UTF-8 以外的其他文本编码类型。`string` 不限于 UTF-8 意味着在处理字符串时，你通常需要额外的一步来防止错误。

不同的编码使用不同数量的字节来编码文本。旧标准使用一个字节来编码一个字符。UTF-8 最多使用四个字节来编码一个字符。当文本在`string`类型中时，为了允许这种可变性，Go 将所有字符串存储为`byte`集合。为了能够安全地对任何类型的文本执行操作，无论是单字节还是多字节编码，它应该从`byte`集合转换为`rune`集合。

注意

如果你不知道文本的编码，通常将其转换为 UTF-8 是安全的。此外，UTF-8 与单字节编码的文本向后兼容。

Go 使得访问字符串的各个字节变得容易，如下面的示例所示：

1.  首先，我们定义包，导入所需的库，并创建`main()`函数：

    ```go
    package main
    import "fmt"
    func main() {
    ```

1.  我们将创建一个包含多字节字符的字符串：

    ```go
      username := "Sir_King_Über"
    ```

1.  我们将使用一个`for i`循环来打印字符串中的每个字节：

    ```go
      for i := 0; i < len(username); i++ {
        fmt.Print(username[i], " ")
      }
    ```

1.  然后，我们将关闭`main()`函数：

    ```go
    }
    ```

运行前面的代码会得到以下输出：

![图 3.8：根据输入长度显示字节的输出]

![img/B14177_03_08.jpg]

![图 3.8：根据输入长度显示字节的输出]

打印出的数字是字符串的字节值。我们的字符串中只有 13 个字母。然而，它包含一个多字节字符，所以我们打印出了 14 个字节值。

让我们将字节转换回字符串。这种转换使用类型转换，我们将在后面详细讲解：

```go
package main
import "fmt"
func main() {
  username := "Sir_King_Über"
  for i := 0; i < len(username); i++ {
    fmt.Print(string(username[i]), " ")
  }
}
```

运行前面的代码会得到以下输出：

![图 3.9：根据字符串显示转换后的字节]

![img/B14177_03_09.jpg]

![图 3.9：根据字符串显示转换后的字节]

输出与预期相符，直到我们到达“Ü”字符。这是因为“Ü”字符使用了多个字节进行编码，单独的字节本身不再有意义。

为了安全地处理多字节字符串的个体字符，你首先必须将`byte`类型的字符串切片转换为`rune`类型的切片。

考虑以下示例：

```go
package main
import "fmt"
func main() {
  username := "Sir_King_Über"
  runes := []rune(username)
  for i := 0; i < len(runes); i++ {
    fmt.Print(string(runes[i]), " ")
  }
}
```

运行前面的代码会得到以下输出：

![图 3.10：根据字符串显示的输出]

![img/B14177_03_10.jpg]

![图 3.10：根据字符串显示的输出]

如果我们确实希望像这样在循环中处理每个字符，那么使用`range`会是一个更好的选择。当使用`range`时，它不是一次移动一个`byte`，而是每次移动字符串中的一个`rune`。索引是字节偏移量，值是一个`rune`。

## 练习 3.05：安全地遍历字符串

在这个练习中，我们将声明一个字符串，并用多字节字符串值初始化它。然后，我们将使用`range`遍历字符串，一次提供一个字符。然后，我们将打印出字节索引和字符到控制台：

1.  创建一个新的文件夹，并添加一个`main.go`文件。

1.  在`main.go`文件中，将主包名添加到文件顶部：

    ```go
    package main
    ```

1.  现在添加我们将在此文件中使用的导入：

    ```go
    import "fmt"
    ```

1.  创建`main()`函数：

    ```go
    func main() {
    ```

1.  声明一个具有多字节字符串值的字符串：

    ```go
      logLevel := "デバッグ"
    ```

1.  创建一个 `range` 循环来遍历字符串，然后捕获变量中的 `index` 和 `rune`：

    ```go
      for index, runeVal := range logLevel {
    ```

1.  将 `index` 和 `rune` 打印到控制台，将 rune 转换为字符串：

    ```go
        fmt.Println(index, string(runeVal))
    ```

1.  关闭循环：

    ```go
      }
    ```

1.  关闭 `main()` 函数：

    ```go
    }
    ```

1.  保存文件，并在新文件夹中运行以下命令：

    ```go
    go run main.go
    ```

运行前面的代码会得到以下输出：

![图 3.11：安全遍历字符串后的输出]

![图片 B14177_03_11.jpg](img/B14177_03_11.jpg)

![图 3.11：安全遍历字符串后的输出]

在这个练习中，我们展示了在多字节安全的方式中遍历字符串是直接嵌入到语言中的。使用这种方法可以防止你得到无效的字符串数据。

另一种常见的查找错误的方法是检查字符串中有多少个字符，通过直接在字符串上使用 `len`。以下是一些常见的多字节字符串被错误处理的方式的例子：

```go
package main
import "fmt"
func main() {
  username := "Sir_King_Über"
  // Length of a string
  fmt.Println("Bytes:", len(username))
  fmt.Println("Runes:", len([]rune(username)))
  // Limit to 10 characters
  fmt.Println(string(username[:10]))
  fmt.Println(string([]rune(username)[:10]))
}
```

运行前面的代码会得到以下输出：

![图 3.12：使用 len 函数后显示错误的输出]

![图片 B14177_03_12.jpg](img/B14177_03_12.jpg)

图 3.12：使用 len 函数后显示错误的输出

你可以看到，当直接在字符串上使用 `len` 时，你会得到错误的结果。以这种方式使用 `len` 检查数据输入的长度会导致无效数据。例如，如果我们需要输入正好是 8 个字符长，而有人输入了多字节字符，直接在输入上使用 `len` 将允许他们输入少于 8 个字符。

当处理字符串时，请务必首先检查 `strings` 包。它充满了可能已经完成你所需要的有用工具。

接下来，让我们仔细看看 Go 语言的特殊 `nil` 值。

# 空值

`nil` 在 Go 语言中不是一个类型，而是一个特殊值。它表示没有类型的空值。当与指针、映射和接口（我们将在下一章中介绍这些）一起工作时，你需要确保它们不是 `nil`。如果你尝试与一个 `nil` 值交互，你的代码将会崩溃。

如果你不能确定一个值是 `nil` 还是不是，你可以这样检查：

```go
package main
import "fmt"
func main() {
  var message *string
  if message == nil {
    fmt.Println("error, unexpected nil value")
    return
  }
  fmt.Println(&message)
}
```

运行前面的代码会显示以下输出：

```go
error, unexpected nil value
```

## 活动 3.01：销售税计算器

在这个活动中，我们创建了一个购物车应用程序，其中必须添加销售税来计算总额：

1.  创建一个计算单个商品销售税的计算器。

1.  计算器必须接受商品的成本及其销售税率。

1.  将销售税相加并打印出以下商品的所需销售税总额：

![图 3.13：包含销售税率的商品列表]

![图片 B14177_03_13.jpg](img/B14177_03_13.jpg)

图 3.13：包含销售税率的商品列表

你的输出应该看起来像这样：

```go
Sales Tax Total:  0.1329
```

注意

这个活动的解决方案可以在第 691 页找到。

## 活动 3.02：贷款计算器

在这个活动中，我们必须为在线财务顾问平台创建一个贷款计算器。我们的计算器应该遵循以下规则：

1.  良好的信用评分是 450 分或以上。

1.  如果信用评分良好，你的利率是 15%。

1.  如果分数不高，你的利率是 20%。

1.  对于良好的信用评分，月供不得超过月收入的 20%。

1.  对于信用评分较低的借款人，月供不得超过月收入的 10%。

1.  如果信用评分、月收入、贷款金额或贷款期限小于 0，则返回错误。

1.  如果贷款期限不能被 12 个月整除，则返回错误。

1.  利息支付将是一个简单的计算，即贷款金额 * 利率 * 贷款期限。

1.  在完成这些计算后，向用户显示以下详细信息：

    ```go
    Applicant X
    -----------
    Credit Score    : X
    Income          : X
    Loan Amount     : X
    Loan Term       : X
    Monthly Payment : X
    Rate            : X
    Total Cost      : X
    Approved        : X
    ```

这是预期的输出：

![图 3.14：贷款计算器输出](img/B14177_03_14.jpg)

图 3.14：贷款计算器输出

注意

本活动的解决方案可在第 692 页找到。

# 摘要

在本章中，我们在使用 Go 语言类型系统方面迈出了重要一步。我们花时间定义了类型是什么以及为什么需要它们。然后我们探讨了 Go 语言中的每个核心类型。我们从简单的`bool`类型开始，并展示了它在我们的代码中是多么关键。然后我们转向数字类型。Go 语言提供了许多数字类型，反映了 Go 语言在内存使用和精度方面喜欢给予开发者的控制。在数字之后，我们研究了字符串的工作原理以及它们与`rune`类型的紧密关系。随着多字节字符的出现，很容易搞乱文本数据。Go 语言提供了强大的内置功能来帮助你正确处理。最后，我们探讨了`nil`及其在 Go 语言中的使用。

你在本章中学到的概念为你提供了应对 Go 语言更复杂类型（如集合和结构体）所需的知识。我们将在下一章探讨这些复杂类型。
