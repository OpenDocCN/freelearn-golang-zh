# 4. 复杂类型

概述

本章介绍了 Go 语言中更复杂的类型。这将基于我们在上一章中学到的关于 Go 核心类型的知识。当构建更复杂的软件时，这些复杂类型是必不可少的，因为它们允许你逻辑上分组相关数据。这种分组数据的能力使得你的代码更容易理解、维护和修复。

到本章结束时，你将能够使用数组、切片和映射来分组数据。你将学习根据核心类型创建自定义类型。你还将学习使用结构体来创建由任何其他类型的命名字段组成的结构，并解释`interface{}`的重要性。

# 简介

在上一章中，我们介绍了 Go 的核心类型。这些类型对于你在 Go 中做的所有事情都是至关重要的，但建模更复杂的数据可能具有挑战性。在现代计算机软件中，我们希望能够尽可能地将数据和逻辑分组在一起。我们还希望我们的逻辑能够反映我们正在构建的现实世界解决方案。

如果你正在为汽车编写软件，你理想情况下想要一个体现汽车的定制类型。这个类型应该命名为"car"，并且它应该有可以存储关于汽车类型信息的属性。影响汽车的逻辑，如启动和停止，应该与汽车类型相关联。如果我们需要管理多辆汽车，我们需要能够将所有汽车分组在一起。

在本章中，我们将学习 Go 语言中允许我们建模此挑战数据部分的特性。然后，在下一章中，我们将解决行为部分。通过使用自定义类型，你可以扩展 Go 的核心类型，而使用结构体则允许你组合由其他类型组成的类型，并将逻辑与它们关联。集合让你可以将数据分组在一起，并允许你遍历并对其执行操作。

随着任务复杂性的增加，Go 的复杂类型帮助你保持代码易于理解和维护。如`arrays`、`slices`和`maps`之类的集合允许你将相关数据分组在一起。Go 的`struct`类型允许你创建由其他字符串、数字和布尔值组成的单一类型，这让你能够构建复杂现实世界概念的模型。结构体还允许你将逻辑附加到它们上；这允许你将控制模型的逻辑紧密地联系在一起。

当类型变得复杂时，我们需要知道如何使用类型转换和断言来正确地管理类型不匹配。我们还将探讨 Go 的`interface{}`类型。这种类型几乎是神奇的，因为它允许你克服 Go 的结构类型系统，但以一种仍然类型安全的方式。

# 集合类型

如果你只处理一个电子邮件地址，你会定义一个字符串变量来为你保存该值。现在，考虑如果你需要处理 0 到 100 个电子邮件地址，你的代码应该如何结构。你可以为每个电子邮件地址定义一个单独的变量，但 Go 有其他我们可以使用的东西。

当处理大量相似数据时，我们将它们放入集合中。Go 的集合类型是数组、切片和映射。Go 的集合类型是强类型的，并且易于遍历，但它们各自都有独特的特性，意味着它们更适合不同的用例。

# 数组

Go 语言中最基本的集合类型是数组。当你定义一个数组时，你必须指定它可以包含的数据类型以及数组的大小，以下形式：`[<size>]<type>`。例如，`[10]int` 是一个大小为 10 的包含整数的数组，而 `[5]string` 是一个大小为 5 的包含字符串的数组。

使其成为数组的关键是指定大小。如果你的定义没有大小，它看起来可能像它工作，但它不会是一个数组——它将是一个切片。切片是不同、更灵活的集合类型，我们将在数组之后讨论。你可以设置元素值为任何类型，包括指针和数组。

你可以使用以下形式使用数据初始化数组：`[<size>]<type>{<value1>,<value2>,…<valueN>}`。例如，`[5]string{1}` 会将数组初始化为第一个值为 1，而 `[5]string{9,9,9,9,9}` 会将每个元素填充为值 9。当使用数据初始化时，你可以让 Go 根据你初始化时使用的元素数量来设置数组的大小。你可以通过将长度数字替换为 `...` 来利用这一点。例如，`[...]string{9,9,9,9,9}` 会创建一个长度为 5 的数组，因为我们用 5 个元素初始化了它。就像所有数组一样，长度在编译时设置，在运行时不可更改。

## 练习 4.01：定义数组

在这个练习中，我们将定义一个大小为 10 的简单整数数组，然后打印其内容。让我们开始吧：

1.  在新文件夹中创建一个名为 `main.go` 的文件。

1.  在 `main.go` 中添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  创建一个函数，该函数定义一个数组然后返回它：

    ```go
    func defineArray() [10]int {
      var arr [10]int
      return arr
    }
    ```

1.  定义 `main()` 函数，调用该函数并打印结果。我们将使用 `fmt.Printf` 与 `%#v` 来获取关于值的额外详细信息，包括其类型：

    ```go
    func main() {
      fmt.Printf("%#v\n", defineArray())
    }
    ```

1.  保存文件。然后，在新的文件夹内，运行以下命令：

    ```go
    go run .
    ```

    运行前面的代码会给我们以下输出：

    ```go
    [10]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    ```

在这个练习中，我们定义了一个数组，但没有向其中填充任何数据。由于所有数组都有固定的大小，当数组被打印出来时，它包含 10 个值。这些值是数组接受类型为空的值。

## 比较数组

数组的长度是其类型定义的一部分。如果你有两个接受相同类型的数组，但它们的大小不同，它们是不兼容的，并且不能相互比较。不同长度的不同类型的数组不能相互比较。

## 练习 4.02：比较数组

在这个练习中，我们将比较数组。首先，我们将定义一些数组；一些是可比较的，而另一些则不是。然后，我们将运行代码并修复出现的任何问题。让我们开始吧：

1.  在新文件夹中创建一个 `main.go` 文件。

1.  在 `main.go` 中，添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  创建一个函数，定义四个数组：

    ```go
    func compArrays() (bool, bool, bool) {
      var arr1 [5]int
      arr2 := [5]int{0}
      arr3 := [...]int{0, 0, 0, 0, 0}
      arr4 := [9]int{0, 0, 0, 0, 9}
    ```

1.  比较数组并返回比较的结果。这完成了这个函数：

    ```go
      return arr1 == arr2, arr1 == arr3, arr1 == arr4
    }
    ```

1.  定义 `main` 以打印出结果：

    ```go
    func main() {
      comp1, comp2, comp3 := compArrays()
      fmt.Println("[5]int == [5]int{0}        :", comp1)
      fmt.Println("[5]int == [...]int{0, 0, 0, 0, 0}:", comp2)
      fmt.Println("[5]int == [9]int{0, 0, 0, 0, 9}  :", comp3)
    }
    ```

1.  保存并运行代码：

    ```go
    go run .
    ```

    运行前面的代码产生以下输出：

    ![图 4.1：数组类型不匹配错误](img/B14177_04_01.jpg)

    ](img/B14177_04_02.jpg)

    图 4.1：数组类型不匹配错误

    你应该看到一个错误。这个错误告诉你，`arr1`，它是一个 `[5] int` 类型的数组，和 `arr4`，它是一个 `[9] int` 类型的数组，不是同一类型，也不兼容。让我们来修复这个问题。

1.  这里，我们有以下内容：

    ```go
      arr4 := [9]int{0, 0, 0, 0, 9}
    ```

    我们需要将其替换为以下内容：

    ```go
      arr4 := [9]int{0, 0, 0, 0, 9}
    ```

1.  我们还有以下代码：

    ```go
      fmt.Println("[5]int == [9]int{0, 0, 0, 0, 9}  :", comp3)
    ```

    我们需要将其替换为以下内容：

    ```go
      fmt.Println("[5]int == [5]int{0, 0, 0, 0, 9}  :", comp3)
    ```

1.  保存并再次使用以下命令运行代码：

    ```go
    go run .
    ```

    运行前面的代码产生以下输出：

![图 4.2：无错误输出](img/B14177_04_01.jpg)

](img/B14177_04_02.jpg)

图 4.2：无错误输出

在我们的练习中，我们定义了一些数组，并且它们都是用稍微不同的方式定义的。起初，我们有一个错误，因为我们试图比较不同长度的数组，在 Go 中这意味着它们是不同类型的。我们修复了这个问题，并再次运行了代码。然后，我们可以看到，尽管前三个数组是用不同的方法定义的，但它们最终是相同的或相等的。最后一个数组，现在类型已修复，包含不同的数据，所以它不与其它数组相同或相等。其他集合类型，即切片和映射，不能以这种方式比较。在使用映射和切片时，你必须遍历你要比较的两个集合的内容，并手动进行比较。这种能力给数组带来了优势，如果你的代码中比较集合数据是一个热点路径。

## 使用键初始化数组

到目前为止，当我们用数据初始化数组时，我们让 Go 为我们选择键。如果你想要使用 `[<大小>]<类型>{<键 1>:<值 1>,…<键 N>:<值 N>}` 来选择你想要的数据键，Go 允许你这样做。Go 是灵活的，允许你设置带有间隔的键，并且可以按任何顺序设置。如果你定义了一个数组，其中数字键具有特定的含义，并且你想为特定的键设置值，但不需要设置其他任何值，这种用键设置值的能力是有帮助的。

## 练习 4.03：使用键初始化数组

在这个练习中，我们将使用一些键初始化几个数组，并将它们相互比较。然后，我们将打印出一个数组并查看其内容。让我们开始吧：

1.  在新文件夹中创建一个名为`main.go`的文件。

1.  在`main.go`中添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  创建一个函数，该函数定义了三个数组：

    ```go
    func compArrays() (bool, bool, [10]int) {
      var arr1 [10]int
      arr2 := [...]int{9: 0}
      arr3 := [10]int{1, 9: 10, 4: 5}
    ```

1.  比较数组并返回最后一个，这样我们就可以稍后打印它：

    ```go
      return arr1 == arr2, arr1 == arr3, arr3
    }
    ```

1.  创建一个`main`函数并调用`compArrays`。然后，打印出结果：

    ```go
    func main() {
      comp1, comp2, arr3 := compArrays()
      fmt.Println("[10]int == [...]{9:0}        :", comp1)
      fmt.Println("[10]int == [10]int{1, 9: 10, 4: 5}}:", comp2)
      fmt.Println("arr3                 :", arr3)
    }
    ```

1.  保存文件。然后，在新文件夹中运行以下命令：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

![图 4.3：使用键初始化的数组](img/B14177_04_03.jpg)

图 4.3：使用键初始化的数组

在这个练习中，我们初始化数组数据时使用了键。对于`arr2`，我们结合了`...`快捷键和设置键，使数组长度直接与设置的键相关联。对于`arr3`，我们混合了使用键和不使用键的情况，并且我们还使用了顺序不正确的键。Go 在使用键时的灵活性很强，这使得以这种方式使用数组变得愉快。

## 从数组中读取

到目前为止，我们已经定义了一个数组并用一些数据初始化了它。现在，让我们读取这些数据。可以使用`<array>[<index>]`来访问数组的单个元素。例如，这访问了数组的第一个元素，`arr[0]`。我知道 0 是数组的第一个元素，因为数组始终使用零索引的整数键。零索引意味着数组的第一个索引始终是 0，最后一个索引始终是数组的长度减 1。

数组中项目的顺序是有保证的。顺序稳定性意味着放置在索引 0 处的项目始终是数组中的第一个项目。

能够访问数组的具体部分在几种情况下可能会有所帮助。通常需要通过检查数组的第一个和/或最后一个元素来验证数组中的数据。有时，数据在数组中的位置很重要，这样你就可以知道你可以从第三个索引获取，例如，一个产品的名称。这种位置的重要性在读取**逗号分隔值**（**CSV**）文件或其他类似分隔符分隔的值文件时很常见。CSV 仍然被广泛使用，因为它是从电子表格文档导出数据的一个流行选择。

## 练习 4.04：从数组中读取单个项目

在这个练习中，我们将定义一个数组并用一些单词初始化它。然后，我们将以消息的形式读取这些单词并打印它们。让我们开始吧：

1.  在新文件夹中创建一个名为`main.go`的文件。

1.  在`main.go`中添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  创建一个函数，该函数定义了一个包含我们的单词的数组。单词的顺序很重要：

    ```go
    func message() string {
      arr := [...]string{
      "ready",
      "Get",
      "Go",
      "to",
      }
    ```

1.  现在，通过按特定顺序连接单词并返回它来创建一条消息。我们在这里使用`fmt.Sprintln`函数，因为它允许我们在打印之前捕获格式化的文本：

    ```go
      return fmt.Sprintln(arr[1], arr[0], arr[3], arr[2])
    }
    ```

1.  创建我们的`main()`函数，调用`message()`函数，并将其打印到控制台：

    ```go
    func main() {
      fmt.Print(message())
    }
    ```

1.  保存并运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

    ```go
    Get ready to Go
    ```

## 向数组中写入

一旦定义了数组，你就可以使用它们的索引来更改单个元素，格式为`<array>[<index>] = <value>`。这种赋值方式与核心类型变量相同。

在现实世界的代码中，你通常需要在定义了集合后根据输入或逻辑修改数据。

## 练习 4.05：向数组中写入

在这个练习中，我们将定义一个数组并用一些单词初始化它。然后，我们将对单词进行一些更改。最后，我们将读取单词以形成消息并打印它。让我们开始吧：

1.  创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。

1.  在`main.go`中添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  创建一个函数，定义一个包含我们的单词的数组。单词的顺序很重要：

    ```go
    func message() string {
      arr := [4]string{"ready", "Get", "Go", "to"}
    ```

1.  我们将通过使用数组索引分配新值来更改数组中的某些单词。这种操作的顺序并不重要：

    ```go
      arr[1] = "It's"
      arr[0] = "time"
    ```

1.  现在，通过按特定顺序连接单词来创建一个消息并返回它：

    ```go
      return fmt.Sprintln(arr[1], arr[0], arr[3], arr[2])
    }
    ```

1.  创建我们的`main()`函数，调用`message()`函数，并将其打印到控制台：

    ```go
    func main() {
      fmt.Print(message())
    }
    ```

1.  保存并运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

    ```go
    It's time to Go
    ```

## 循环遍历数组

你最常使用数组的方式是通过在循环中使用它们。由于数组索引的工作方式，它们很容易进行循环遍历。索引总是从 0 开始，没有间隔，最后一个元素是数组的长度减 1。

由于这个原因，使用循环创建一个变量来表示索引并手动递增也是常见的。这种类型的循环通常被称为`for i`循环，因为`i`是分配给索引变量的名称。

如你从上一章所记得，`for`循环有三个可能的部分：循环前可以运行的逻辑、每次循环交互时运行的逻辑以检查循环是否应该继续，以及每次循环迭代结束时运行的逻辑。一个`for i`循环看起来像`i := 0; i < len(arr); i++ {`。发生的事情是我们将`i`定义为零，这也意味着`i`只存在于循环的作用域内。然后，在循环的每次迭代中检查`i`以确保它小于数组的长度。我们检查它是否小于数组的长度，因为长度总是比最后一个索引键多 1。最后，我们在每次循环中递增`i`，这样我们就可以逐个遍历数组中的每个元素。

当涉及到数组的长度时，可能会诱使你直接硬编码最后一个索引的值，而不是使用`len`，因为你知道数组的长度始终相同。硬编码长度是一个糟糕的想法。硬编码会使你的代码更难维护。数据的变化和演变是很常见的。如果你需要回来更改数组的尺寸，硬编码的数组长度会引入难以发现的错误，甚至可能导致运行时崩溃。

使用循环与数组一起使用，允许你对每个元素重复相同的逻辑，即验证数据、修改数据或输出数据，而无需为多个变量重复相同的代码。

## 练习 4.06：使用“for i”循环遍历数组

在这个练习中，我们将定义一个数组，并用一些数字初始化它。我们将遍历这些数字，对每个数字执行一个操作，并将结果放入消息中。然后，我们将返回消息并打印它。让我们开始吧：

1.  创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。

1.  在`main.go`中添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  创建一个函数。在循环之前，我们将使用数据定义数组和一个`m`变量：

    ```go
    func message() string {
      m := ""
      arr := [4]int{1,2,3,4}
    ```

1.  定义循环的开始。这管理索引和循环：

    ```go
      for i := 0; i < len(arr); i++ {
    ```

1.  然后，编写循环体，它对数组的每个元素执行一个操作，并将其添加到消息中：

    ```go
      arr[i] = arr[i] * arr[i]
      m += fmt.Sprintf("%v: %v\n", i, arr[i])
    ```

1.  现在，关闭循环，返回消息，并关闭函数：

    ```go
      }
      return m
    }
    ```

1.  创建我们的`main`函数，调用`message`函数，并将其打印到控制台：

    ```go
    func main() {
      fmt.Print(message())
    }
    ```

1.  保存此代码。然后，从新文件夹中运行代码：

    ```go
    go run .
    ```

    运行前面的代码，使用`for i`循环遍历数组后，会得到以下输出：

    ```go
    0: 1
    1: 4
    2: 9
    3: 16
    ```

`for i`循环非常常见，所以请特别注意第 4 步，即我们定义循环的地方，并确保理解三个部分各自的作用。

注意

`len`。这个特性也适用于其他集合类型，即切片和映射。

## 在循环中修改数组的元素

除了在循环中从数组中读取数据外，你还可以在循环中更改数组的元素。处理每个元素中的数据就像处理变量一样。你也会使用相同的`for i`循环。

就像从数组中读取数据一样，能够更改集合中的数据可以减少你需要编写的代码量，如果每个元素都是一个独立的变量。

## 练习 4.07：在循环中修改数组的元素

在这个练习中，我们将定义一个空数组，填充数据，然后修改这些数据。最后，我们将打印填充和修改后的数组到控制台。让我们开始吧：

1.  创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。

1.  在`main.go`中添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  创建一个函数，用于将数字从 1 到 10 填充到数组中：

    ```go
    func fillArray(arr [10]int) [10]int {
      for i := 0; i < len(arr); i++ {
      arr[i] = i + 1
      }
      return arr
    }
    ```

1.  创建一个函数，该函数将数组中的数字自乘，然后将结果设置回数组：

    ```go
    func opArray(arr [10]int) [10]int {
      for i := 0; i < len(arr); i++ {
        arr[i] = arr[i] * arr[i]
      }
      return arr
    }
    ```

1.  在我们的`main()`函数中，我们需要定义我们的空数组，填充它，修改它，然后将其内容打印到控制台：

    ```go
    func main() {
      var arr [10]int
      arr = fillArray(arr)
      arr = opArray(arr)
      fmt.Println(arr)
    }
    ```

1.  保存此代码。然后，从新文件夹中运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

    ```go
    [1 4 9 16 25 36 49 64 81 100]
    ```

一旦你了解了如何在`for i`循环中使用数组，处理数组中的数据就变得简单了。与处理其他集合相比，数组的一个优点是它们的长度是固定的。使用数组时，不可能意外地改变数组的大小，从而导致无限循环，这是一种无法结束的循环，会导致软件无限期地运行并消耗大量资源。

## 活动四.01：填充数组

在这个活动中，我们将定义一个数组，并使用 for-i 循环填充它。以下是本活动的步骤：

1.  创建一个新的 Go 应用程序。

1.  定义一个包含 10 个元素的数组。

1.  使用 for-i 循环用数字 1 到 10 填充该数组。

1.  使用`fmt.Println`将数组打印到控制台。

    预期的输出如下：

    ```go
    [1 2 3 4 5 6 7 8 9 10]
    ```

    注意

    本活动的解决方案可在第 696 页找到

# 切片

数组很棒，但它们在大小上的僵化可能会引起问题。如果你想要创建一个接受数组并对其中的数据进行排序的函数，它只能适用于一种数组大小。这需要你为每种数组大小创建一个函数。这种对大小的严格性使得使用数组感觉像是一种麻烦和不吸引人的体验。数组的另一面是，它们是管理排序数据集合的高效方式。如果有一种方法可以同时获得数组的效率和更多的灵活性，那岂不是很好？Go 通过切片的形式为你提供了这种功能。

切片是围绕数组的一层薄薄的外壳，让你拥有一个排序的数值索引集合，而无需担心大小。在薄薄的外壳下面仍然是 Go 数组，但 Go 为你管理所有细节，例如使用多大的数组。你使用切片的方式就像使用数组一样；它只包含一个类型的值，你可以使用`[`和`]`读取和写入每个元素，并且它们使用`for i`循环进行循环时很容易。

切片还能做的另一件事是使用内置的`append`函数轻松扩展。这个函数接受你的切片和你要添加的值，并返回一个包含所有内容的新切片。通常，我们会从一个空切片开始，并根据需要扩展它。

由于切片是围绕数组的一层薄薄的外壳，这意味着它不是一个真正的类型，就像数组一样。你需要了解 Go 如何使用切片后面的隐藏数组。如果你不了解这一点，可能会导致微妙且难以调试的错误。

在现实世界的代码中，你应该使用切片作为所有排序集合的首选。这将使你更加高效，因为你不需要像使用数组那样编写那么多代码。在现实世界的项目中，你将看到的代码大多数都使用了大量的切片，而很少使用数组。数组仅在需要确切长度时使用，即使在这种情况下，切片也通常被使用，因为它们可以更容易地在代码中传递。

## 练习 4.08：处理切片

在这个练习中，我们将通过从切片中读取一些数据、将切片传递给函数、遍历切片、从切片中读取值以及向切片末尾添加值来展示切片的灵活性。让我们开始吧：

1.  创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。

1.  在`main.go`中添加包和导入：

    ```go
    package main
    import (
      "fmt"
      "os"
    )
    ```

1.  创建一个函数，它接受一个`int`类型的参数并返回一个字符串切片：

    ```go
    func getPassedArgs(minArgs int) []string {
    ```

1.  在函数体中，检查是否通过命令行传递了正确的参数数量。如果没有，我们以错误退出程序。传递给 Go 的所有参数都放在`os.Args`中，它是一个字符串切片：

    ```go
      if len(os.Args) < minArgs {
        fmt.Printf("At least %v arguments are needed\n", minArgs)
        os.Exit(1)
      }
    ```

1.  切片的第一个元素是代码的调用方式，而不是一个参数，所以我们将移除它：

    ```go
      var args []string
      for i := 1; i < len(os.Args); i++ {
        args = append(args, os.Args[i])
      }
    ```

1.  然后，我们将返回这些参数：

    ```go
      return args
    }
    ```

1.  现在，创建一个函数，它遍历一个切片并找到最长的字符串。当两个单词长度相同时，返回第一个单词：

    ```go
    func findLongest(args []string) string {
      var longest string
      for i := 0; i < len(args); i++ {
        if len(args[i]) > len(longest) {
          longest = args[i]
      }
      }
      return longest
    }
    ```

1.  在`main()`函数中，我们调用函数并检查错误：

    ```go
    func main() {
      if longest := findLongest(getPassedArgs(3)); len(longest) > 0 {
        fmt.Println("The longest word passed was:", longest)
      } else {
        fmt.Println("There was an error")
        os.Exit(1)
      }
    }
    ```

1.  保存文件。然后，在保存文件的文件夹中，使用以下命令运行代码：

    ```go
    go run . Get ready to Go
    ```

    运行前面的代码会产生以下输出：

    ```go
    The longest word passed was: ready
    ```

在这个练习中，我们能够看到切片的灵活性以及它们如何像数组一样工作。这种使用切片的方式是 Go 感觉像是一种动态语言的原因之一。

## 活动 4.02：根据用户输入打印用户姓名

现在轮到你了，开始使用地图。我们将定义一个地图，并创建逻辑来根据传递给应用程序的键打印地图中的数据。以下是这个活动的步骤：

1.  创建一个新的 Go 应用程序。

1.  定义一个包含以下键值对的`map`：

    键：305，值：Sue

    键：204，值：Bob

    键：631，值：Jake

    键：073，值：Tracy

1.  使用`os.Args`读取传递进来的键并打印相应的名字；例如，`go run . 073`。

1.  正确处理没有传递参数或传递的参数不匹配`map`中的值的情况。

1.  向用户打印包含在值中的名字的消息。

    预期输出如下：

    ```go
    Hi, Tracy
    ```

    注意

    这个活动的解决方案可以在第 697 页找到

## 向切片中添加多个项目

内置的`append`函数可以向切片添加多个值。你可以向`append`添加任意多的参数，因为最后一个参数是可变参数。由于它是可变参数，这意味着你也可以使用`...`表示法将切片用作可变参数，允许你向`append`传递动态数量的参数。

在现实世界的代码中，经常需要向`append`传递多个参数，并且拥有它可以使 Go 代码紧凑，因为它不需要多次调用或循环来添加多个值。

## 练习 4.09：向切片中添加多个项目

在这个练习中，我们将使用 `append` 的可变参数来向切片中添加以预定义数据形式存在的多个值。然后，我们将根据用户输入向同一个切片中添加动态数量的数据。让我们开始吧：

1.  创建一个新的文件夹，并向其中添加一个名为 `main.go` 的文件。

1.  在 `main.go` 中添加包和导入：

    ```go
    package main
    import (
      "fmt"
      "os"
    )
    ```

1.  创建一个安全获取用户输入的函数：

    ```go
    func getPassedArgs() []string {
      var args []string
      for i := 1; i < len(os.Args); i++ {
        args = append(args, os.Args[i])
      }
      return args
    }
    ```

1.  创建一个接受字符串切片作为参数并返回字符串切片的函数。然后，定义一个字符串切片变量：

    ```go
    func getLocals(extraLocals []string) []string {
      var locales []string
    ```

1.  使用 `append` 方法向切片中添加多个字符串：

    ```go
      locales = append(locales, "en_US", "fr_FR")
    ```

1.  从参数中添加更多数据：

    ```go
      locales = append(locales, extraLocals...)
    ```

1.  返回变量并关闭函数定义：

    ```go
      return locales
    }
    ```

1.  在 `main()` 函数中，获取用户输入，将其传递给我们的函数，然后打印结果：

    ```go
    func main() {
      locales := getLocals(getPassedArgs())
      fmt.Println("Locales to use:", locales)
    }
    ```

1.  保存文件。然后，在步骤 1 中创建的文件夹中，使用以下命令运行代码：

    ```go
    go run . fr_CN en_AU
    ```

    运行前面的代码会产生以下输出：

    ```go
    Locales to use: [en_US fr_FR fr_CN en_AU]
    ```

在这个练习中，我们使用了两种向切片添加多个值的方法。如果你需要将两个切片合并在一起，你也会使用这种技术。

虽然将切片像这样展开以添加到另一个切片可能看起来效率不高，但 Go 运行时可以检测到你正在执行 append 操作，并在后台优化调用以确保不浪费资源。

## 活动 4.03：创建区域检查器

在这个活动中，我们将创建一个区域验证器。区域是一个国际化本地化概念，它是语言和国家的组合。我们将创建一个表示区域的结构。之后，我们将定义代码支持的区域列表。然后，我们将从命令行读取一些区域代码，并打印出我们的代码是否接受该区域。

下面是这个活动的步骤：

1.  创建一个新的 Go 应用程序。

1.  定义一个具有语言字段和单独的国家或地区字段的结构。

1.  创建一个集合来存储至少五个区域的本地定义，例如，"en_US"、"en_CN"、"fr_CN"、"fr_FR" 和 "ru_RU"。

1.  使用 `os.Args` 等方法从命令行读取本地，确保有错误检查和验证。

1.  将传递的区域字符串加载到一个新的区域结构中。

1.  使用该结构来检查传递的结构是否受支持。

1.  向控制台打印一条消息，说明是否支持该区域。

    预期的输出如下：

![图 4.4：预期输出](img/B14177_04_04.jpg)

![img/B14177_04_04.jpg](img/B14177_04_04.jpg)

图 4.4：预期输出

注意

本活动的解决方案可以在第 698 页找到。

## 从切片和数组创建切片

通过使用与访问数组或切片中单个元素类似的符号，你可以创建从数组或切片内容派生的新切片。最常用的符号是 `[<low>:<high>]`。这个符号告诉 Go 创建一个新的切片，其值类型与源切片或数组相同，并通过从低索引开始填充新切片，直到但不包括高索引的值。低和高是可选的。如果你省略了低，那么 Go 默认为源中的第一个元素。如果你省略了高，那么它将一直到最后一个值。你可以同时省略两者，如果你这样做，那么新切片将包含源中的所有值。

当你以这种方式创建新的切片时，Go 不会复制值。如果源是数组，那么该源数组是新切片的隐藏数组。如果源是切片，那么新切片的隐藏数组与源切片使用的相同隐藏数组。

## 练习 4.10：从切片创建切片

在这个练习中，我们将使用切片范围符号创建具有各种初始值的切片。通常，在实际代码中，你需要处理切片或数组的一小部分。`range` 符号是一种快速直接的方法，可以只获取你需要的数据。让我们开始吧：

1.  创建一个新的文件夹并添加一个名为 `main.go` 的文件。

1.  在 `main.go` 中添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  创建一个函数并定义一个包含九个 `int` 值的切片：

    ```go
    func message() string {
      s := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    ```

1.  我们将提取第一个值，首先直接作为一个 int，然后作为一个使用低和高，最后只使用高并省略低切片。我们将值写入消息字符串：

    ```go
      m := fmt.Sprintln("First   :", s[0], s[0:1], s[:1])
    ```

1.  现在，我们将获取最后一个元素。为了获取 int，我们将使用长度并从索引中减去 1。我们使用相同的逻辑来设置范围符号的低。对于高，我们可以使用切片的长度。最后，我们可以省略高并得到相同的结果：

    ```go
      m += fmt.Sprintln("Last  :", s[len(s)-1], s[len(s)-1:len(s)], s[len(s)-1:])
    ```

1.  现在，让我们获取前五个值并将它们添加到消息中：

    ```go
      m += fmt.Sprintln("First 5 :", s[:5])
    ```

1.  接下来，我们将获取最后四个值并将它们也添加到消息中：

    ```go
      m += fmt.Sprintln("Last 4  :", s[5:])
    ```

1.  最后，我们将从切片的中间提取五个值并将它们也放入消息中：

    ```go
      m += fmt.Sprintln("Middle 5:", s[2:7])
    ```

1.  然后，我们将返回消息并关闭函数：

    ```go
      return m
    }
    ```

1.  在 `main` 中，我们将打印消息：

    ```go
    func main() {
      fmt.Print(message())
    }
    ```

1.  保存文件。然后，在你在 *步骤 1* 中创建的文件夹中，使用以下命令运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

![图 4.5：从切片创建切片后的输出](img/B14177_04_05.jpg)

图 4.5：从切片创建切片后的输出

在这个练习中，我们尝试了几种从另一个切片创建切片的方法。你也可以将这些相同的技巧用于数组作为源。我们注意到起始索引和停止索引都是可选的。如果你没有起始索引，它将从源切片或数组的开始处开始。如果你没有停止索引，那么它将在数组的末尾停止。如果你跳过了起始索引和停止索引，它将复制切片或数组。这个技巧对于将数组转换为切片很有用，但对于复制切片没有帮助，因为两个切片共享同一个隐藏数组。

## 理解切片内部机制

切片很棒，当你需要有序列表时应该首选使用，但如果你不知道它们在底层是如何工作的，它们会导致难以发现的错误。

数组是一种类似于字符串或`int`的值类型。值类型可以被复制并与其自身进行比较。这些值类型一旦被复制，就不再与它们的源值连接。切片不像值类型那样工作；它们更像指针，但它们也不是指针。

使用切片保持安全的关键在于理解存在一个隐藏数组来存储值，并且对切片的更改可能需要或不要求用更大的一个替换隐藏数组。隐藏数组的管理在后台发生的事实使得很难很好地推理切片中正在发生的事情。

切片有三个隐藏属性：长度、指向隐藏数组的指针以及它在隐藏数组中的起始位置。当你向切片添加内容时，这些属性之一或全部会更新。哪些属性会更新取决于隐藏数组是否已满。

隐藏数组的尺寸和切片的尺寸并不总是相同的。切片的尺寸是其长度，我们可以通过使用`len`内置函数来找出它。隐藏数组的尺寸是切片的容量。还有一个内置函数可以告诉你切片的容量，即`cap`。当你使用`append`向切片添加新值时，会发生两件事之一：如果切片有额外的容量，即隐藏数组还没有满，它将值添加到隐藏数组中，然后更新切片的长度属性。如果隐藏数组已满，Go 将创建一个新的更大的数组。然后，Go 将所有值从旧数组复制到新数组中，并添加新值。然后，Go 更新切片，使其指向新数组，并更新切片的长度以及可能的位置。

起始点仅在切片是数组或从第一个元素开始不是的切片的值子集时才会发挥作用，例如，在我们获取切片最后五个元素的例子中。其余时间，它将是隐藏数组中的第一个元素。

当您定义一个切片时，可以控制隐藏数组的尺寸。Go 的内置 `make` 函数允许您在创建切片时设置其长度和容量。语法看起来像 `make(<sliceType>, <length>, <capacity>)`。当使用 `make` 创建切片时，容量是可选的，但长度是必需的。

## 练习 4.11：使用 `make` 控制切片的容量

在这个练习中，使用 `make` 函数，我们将创建一些切片并显示它们的长度和容量。让我们开始吧：

1.  在新文件夹中创建一个名为 `main.go` 的文件。

1.  在 `main.go` 中添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  创建一个返回三个 `int` 切片的函数：

    ```go
    func genSlices() ([]int, []int, []int) {
    ```

1.  使用 `var` 语法定义一个切片：

    ```go
      var s1 []int
    ```

1.  使用 `make` 定义一个切片并仅设置长度：

    ```go
      s2 := make([]int, 10)
    ```

1.  定义一个同时使用切片长度和容量的切片：

    ```go
      s3 := make([]int, 10, 50)
    ```

    返回三个切片并关闭函数定义：

    ```go
      return s1, s2, s3
    }
    ```

1.  在 `main()` 函数中，调用我们创建的函数并捕获返回的值。对于每个切片，将其长度和容量打印到控制台：

    ```go
    func main() {
      s1, s2, s3 := genSlices()
      fmt.Printf("s1: len = %v cap = %v\n", len(s1), cap(s1))
      fmt.Printf("s2: len = %v cap = %v\n", len(s2), cap(s2))
      fmt.Printf("s3: len = %v cap = %v\n", len(s3), cap(s3))
    }
    ```

1.  保存文件。然后，在您创建的 *步骤 1* 中的文件夹中，使用以下命令运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

![图 4.6：显示切片的输出](img/B14177_04_06.jpg)

图 4.6：显示切片的输出

在这个练习中，我们使用了 `make`、`len` 和 `cap` 来在定义切片时控制和显示其长度和容量。

如果您知道切片的大小，通常需要为设置容量进行操作，这可以提高性能，因为 Go 需要管理隐藏数组的工作更少。

## 切片的后台行为

由于切片是什么以及它是如何工作的复杂性，您不能相互比较切片。如果您尝试这样做，Go 会给您一个错误。您可以比较一个切片与 nil，但仅此而已。

切片不是一个值，也不是一个指针，那么它是什么？切片是 Go 中的一个特殊构造。切片不会直接存储其自己的值。在后台，它使用一个您无法直接访问的数组。切片存储的是指向那个隐藏数组的指针、在该数组中的起始点、切片的长度以及切片的容量。这些值为切片提供了一个查看隐藏数组的窗口。这个窗口可以是整个隐藏数组，也可以是它的一部分。隐藏数组的指针可以被多个切片共享。这种指针共享可以导致多个切片可以共享同一个隐藏数组，即使不是所有的切片都包含相同的数据。这意味着其中一个切片可能包含比其他切片更多的数据。

当一个切片需要超出其隐藏数组时，它会创建一个新的更大的数组，并将旧数组的内容复制到新数组中，并将切片指向新数组。这种数组交换是我们之前切片断开连接的原因。最初，它们都指向同一个隐藏数组，但当我们扩展第一个切片时，它所指向的数组发生了变化。这种变化意味着扩展的切片的更改不再影响其他切片，因为它们仍然指向旧的、较小的数组。

如果你需要复制一个切片并确保它们不连接，你有几种选择。你可以使用 `append` 将源切片的内容复制到另一个数组中，或者使用内置的 `copy` 函数。当使用 `copy` 时，Go 不会改变目标切片的大小，所以请确保它有足够的空间来存放你想要复制的所有元素。

## 练习 4.12：控制内部切片行为

在这个练习中，我们将探索五种不同的从切片到切片复制数据的方法以及这对切片的内部行为有何影响。让我们开始吧：

1.  创建一个新的文件夹，并向其中添加一个名为 `main.go` 的文件。

1.  在 `main.go` 文件中，添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  创建一个返回三个整数的函数：

    ```go
    func linked() (int, int, int) {
    ```

1.  定义一个初始化了一些数据的整数切片：

    ```go
      s1 := []int{1, 2, 3, 4, 5}
    ```

1.  然后，我们将创建该切片的一个简单变量副本：

    ```go
      s2 := s1
    ```

1.  通过复制第一个切片的所有值作为切片范围操作的一部分创建一个新的切片：

    ```go
      s3 := s1[:]
    ```

1.  修改第一个切片中的某些数据。稍后，我们将看到这如何影响第二个和第三个切片：

    ```go
      s1[3] = 99
    ```

1.  为每个切片返回相同的索引并关闭函数定义：

    ```go
      return s1[3], s2[3], s3[3]
    }
    ```

1.  创建一个将返回两个整数的函数：

    ```go
    func noLink() (int, int) {
    ```

1.  定义一个包含一些数据的切片，并再次进行简单的复制：

    ```go
      s1 := []int{1, 2, 3, 4, 5}
      s2 := s1
    ```

1.  这次，在执行其他任何操作之前，我们将向第一个切片中追加数据。这个操作会改变切片的长度和容量：

    ```go
      s1 = append(s1, 6)
    ```

1.  然后，我们将更改第一个切片，从两个切片中返回相同的索引，并关闭函数：

    ```go
      s1[3] = 99
      return s1[3], s2[3]
    }
    ```

1.  在我们的下一个函数中，我们将返回两个整数：

    ```go
    func capLinked() (int, int) {
    ```

1.  这次我们将使用 `make` 定义我们的第一个切片。在这样做的时候，我们将设置一个比其长度更大的容量：

    ```go
      s1 := make([]int, 5, 10)
    ```

1.  让我们用之前相同的数据填充第一个数组：

    ```go
      s1[0], s1[1], s1[2], s1[3], s1[4] = 1, 2, 3, 4, 5
    ```

1.  现在，我们将创建一个新的切片，就像我们之前做的那样，通过复制第一个切片：

    ```go
      s2 := s1
    ```

1.  我们将向第一个切片中追加一个新值，这会改变其长度但不会改变其容量：

    ```go
      s1 = append(s1, 6)
    ```

1.  然后，我们将更改第一个切片，从两个切片中返回相同的索引，并关闭函数：

    ```go
      s1[3] = 99
      return s1[3], s2[3]
    }
    ```

1.  在这个函数中，我们将再次使用 `make` 来设置容量，但我们将使用 `append` 来添加超出该容量的元素：

    ```go
    func capNoLink() (int, int) {
      s1 := make([]int, 5, 10)
      s1[0], s1[1], s1[2], s1[3], s1[4] = 1, 2, 3, 4, 5
      s2 := s1
      s1 = append(s1, []int{10: 11}...)
      s1[3] = 99
      return s1[3], s2[3]
    }
    ```

1.  在下一个函数中，我们将使用 `copy` 来将第一个切片的元素复制到第二个切片。`copy` 返回从一个切片复制到另一个切片的元素数量，因此我们也将返回这个值：

    ```go
    func copyNoLink() (int, int, int) {
      s1 := []int{1, 2, 3, 4, 5}
      s2 := make([]int, len(s1))
      copied := copy(s2, s1)
      s1[3] = 99
      return s1[3], s2[3], copied
    }
    ```

1.  在最后一个函数中，我们将使用 `append` 将值复制到第二个切片。以这种方式使用 `append` 会导致值被复制到一个新的隐藏数组中：

    ```go
    func appendNoLink() (int, int) {
      s1 := []int{1, 2, 3, 4, 5}
      s2 := append([]int{}, s1...)
      s1[3] = 99
      return s1[3], s2[3]
    }
    ```

1.  在`main`函数中，我们将打印出我们返回的所有数据，并将其打印到控制台：

    ```go
    func main() {
      l1, l2, l3 := linked()
      fmt.Println("Linked    :", l1, l2, l3)
      nl1, nl2 := noLink()
      fmt.Println("No Link   :", nl1, nl2)
      cl1, cl2 := capLinked()
      fmt.Println("Cap Link  :", cl1, cl2)
      cnl1, cnl2 := capNoLink()
      fmt.Println("Cap No Link :", cnl1, cnl2)
      copy1, copy2, copied := copyNoLink()
      fmt.Print("Copy No Link: ", copy1, copy2)
      fmt.Printf(" (Number of elements copied %v)\n", copied)
      a1, a2 := appendNoLink()
      fmt.Println("Append No Link:", a1, a2)
    }
    ```

1.  保存文件。然后，在您在*步骤 1*中创建的文件夹中，使用以下命令运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

![图 4.7：显示数据的输出![图 4.7：显示数据的输出](img/B14177_04_07.jpg)

图 4.7：显示数据的输出

在这个练习中，我们逐步分析了五种不同的场景，在这些场景中我们复制了切片数据。在`链接`场景中，我们对第一个切片进行了简单的复制，然后对其进行了范围复制。虽然切片本身是不同的，不再是同一个切片，但在现实中，它们所持有的数据并没有区别。每个切片都指向同一个隐藏数组，所以当我们对第一个切片进行更改时，它会影响所有切片。

在`无链接`场景中，第一和第二个切片的设置相同，但在我们对第一个切片进行更改之前，我们向其中添加了一个值。当我们向其中添加这个值时，在后台，Go 需要创建一个新的数组来存储现在的大量值。由于我们是在向第一个切片追加，其指针指向了新的、更大的切片。第二个切片没有更新其指针。这就是为什么当第一个切片的值发生变化时，第二个切片没有受到影响。第二个切片不再指向同一个隐藏数组，这意味着它们不再链接。

对于`带链接`场景，第一个切片是使用`make`和过大的容量定义的。这个额外的容量意味着当第一个切片被追加一个值时，隐藏数组中已经有了额外的空间。这个额外的容量意味着不需要替换隐藏数组。结果是，当我们更新第一个切片上的值时，它和第二个切片仍然指向同一个隐藏数组，这意味着更改会影响两者。

在`无链接`场景中，设置与上一个场景相同，但在我们追加值时，我们追加的值超过了可用的容量。尽管有额外的容量，但仍然不够，第一个切片中的隐藏数组被替换。结果是，两个切片之间的链接断裂。

在`无链接`中，我们使用了内置的`copy`函数来为我们复制值。虽然这会将值复制到一个新的隐藏数组中，但`copy`不会改变切片的长度。这个事实意味着在您进行复制之前，目标切片必须具有正确的长度。在现实世界的代码中您很少看到`copy`的使用；这可能是由于它很容易被误用。

最后，使用 `Append No Link`，我们使用 `append` 来执行类似于 `copy` 的操作，但无需担心长度。这种方法在现实世界的代码中最为常见，当你需要确保获取到与源不链接的值的副本时。这很容易理解，因为 `append` 被广泛使用，并且它是一个单行解决方案。还有一个稍微高效一些的解决方案，可以避免在 `append` 的第一个参数中分配空切片的额外内存。你可以通过创建一个 0 容量的范围副本来重用第一个切片。这个替代方案如下：

```go
  s1 := []int{1, 2, 3, 4, 5}
  s2 := append(s1[:0:0], s1...)
```

你在这里看到了什么新东西吗？这里使用了很少使用的切片范围表示法 `<slice>[<low>:<high>:<capacity>]`。在当前的 Go 编译器中，这是复制切片最节省内存的方法。

## Map 基础知识

虽然 数组和切片 相似，有时可以互换使用，但 Go 的其他集合类型 map 则相当不同，不能与数组和切片互换。Go 的 map 类型服务于不同的目的。

Go 的 map 在计算机科学术语中是一个哈希表。map 与其他集合类型的区别主要在于其键。在数组或切片中，键是一个占位符，它本身没有意义。它仅仅作为计数器存在，与值没有直接关系。

在 map 中，键是数据——与值有真实关系的数据。例如，你可以在 map 中有一个用户账户记录的集合。键将是用户的员工 ID。员工 ID 是真实数据，而不仅仅是一个任意的占位符。如果有人给你他们的员工 ID，你就能查找到他们的账户记录，而无需遍历数据来找到它。使用 map，你可以快速地设置、获取和删除数据。

你可以像访问切片或数组中的单个元素一样访问 map 的单个元素：使用 `[` 和 `]`。map 的键可以是任何可以直接比较的类型，如 int 或 string。你不能比较切片，因此它们不能作为键。map 的值可以是任何类型，包括指针、切片和 map。

你不应该将 map 用作有序列表。即使你打算使用 int 作为 map 的键，map 也不保证始终从索引 0 开始，也不保证键之间没有空隙。即使你想要 int 键，这个特性也可能是一个优势。如果你有稀疏填充的数据，即在切片或数组中键之间有间隙的值，它将包含大量零数据。在 map 中，它只会包含你设置的数据。

要定义一个地图，你使用以下表示法：`map[<key_type>]<value_type>`。你可以使用 `make` 来创建地图，但使用 `make` 创建地图时的参数是不同的。Go 不能为地图创建键，因此你不能像使用切片那样创建任意长度的地图。你可以建议一个容量，编译器可以使用这个容量来创建你的地图。为地图建议容量是可选的，并且不能使用 `cap` 来检查其容量。

地图就像切片一样，它们既不是值也不是指针。地图是 Go 中的一个特殊构造。在复制变量或值时，你需要采取相同的谨慎。由于你不能控制或检查地图的容量，因此当你想知道添加元素时会发生什么时，它们更具挑战性。

由于 Go 不使用地图帮助你管理键，这意味着你必须指定键来初始化包含数据的地图。它的表示法与其他集合相同，即 `map[<key_type>]<value_type>{<key1>: <value>, … <keyN>: <valueN>}`。

一旦定义，你就可以设置值，而无需担心地图的长度，就像你处理数组和切片时那样。设置值就像其他集合一样，即 `<map>[<key>] = <value>`。在设置地图的值之前，你需要确保已经初始化了它。如果你尝试设置未初始化地图的值，会导致运行时恐慌。为了避免这种情况，一个好的做法是避免使用 `var` 来定义地图。如果你用数据初始化地图或使用 `make` 来创建你的地图，你就不会遇到这个问题。

## 练习 4.13：创建、读取和写入地图

在这个练习中，我们将定义一个包含一些数据的地图，然后向其中添加一个新元素。最后，我们将打印地图到控制台。让我们开始吧：

1.  创建一个新文件夹，并向其中添加一个名为 `main.go` 的文件。

1.  在 `main.go` 中，添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  创建一个返回具有字符串键和字符串值的 `map` 的函数：

    ```go
    func getUsers() map[string]string {
    ```

1.  定义一个具有字符串键和字符串值的 `map` 并用一些元素初始化它：

    ```go
      users := map[string]string{
        "305": "Sue",
        "204": "Bob",
        "631": "Jake",
      }
    ```

1.  接下来，我们将向 `map` 中添加一个新元素：

    ```go
      users["073"] = "Tracy"
    ```

1.  返回 `map` 并关闭函数：

    ```go
      return users
    }
    ```

1.  在 `main` 函数中，将 `map` 打印到控制台：

    ```go
    func main() {
      fmt.Println("Users:", getUsers())
    }
    ```

1.  保存文件。然后，在你在 *步骤 1* 中创建的文件夹中，使用以下命令运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

    ```go
    Users: map[073:Tracy 204:Bob 305:Sue 631:Jake]
    ```

在这个练习中，我们创建了一个地图，用数据初始化它，然后添加了一个新元素。这个练习表明，使用地图与使用数组切片类似。当你应该使用地图时，这取决于你将存储在其中的数据类型，以及你的访问模式是否需要访问单个项目而不是项目列表。

## 从地图中读取

在需要使用键获取值之前，你并不总是知道该键是否存在于映射中。当你为映射中不存在的键获取值时，Go 会返回映射值类型的零值。使用零值逻辑的代码是 Go 中的有效编程方式，但并不总是可行。如果你不能使用零值逻辑，当需要时，映射可以返回一个额外的返回值。该表示法看起来像 `<value>, <exists_value> := <map>[<key>]`。在这里，`exists` 是一个布尔值，如果键存在于映射中则为真，否则为假。当遍历映射时，你应该使用 `range` 关键字。当遍历映射时，永远不要依赖于其中项的顺序。Go 不保证映射中项的顺序。为了确保没有人依赖于元素的顺序，Go 故意随机化了当你遍历映射时的顺序。如果你确实需要按特定顺序遍历映射中的元素，你需要使用数组或切片来帮助你完成这项工作。

## 练习 4.14：从映射中读取

在这个练习中，我们将使用直接访问和循环从映射中读取。我们还将检查键是否存在于映射中。让我们开始吧：

1.  创建一个新的文件夹，并向其中添加一个名为 `main.go` 的文件。

1.  在 `main.go` 中添加包和导入：

    ```go
    package main
    import (
      "fmt"
      "os"
    )
    ```

1.  创建一个返回具有字符串键和字符串值的 `map` 的函数：

    ```go
    func getUsers() map[string]string {
    ```

1.  定义一个 `map` 并用数据初始化它。然后，返回 `map` 并关闭函数：

    ```go
      return map[string]string{
      "305": "Sue",
      "204": "Bob",
      "631": "Jake",
      "073": "Tracy",
      }
    }
    ```

1.  在这个函数中，我们将接受一个字符串作为输入。该函数还将返回一个字符串和一个布尔值：

    ```go
    func getUser(id string) (string, bool) {
    ```

1.  从我们之前的功能中获取 `users` 映射的副本：

    ```go
      users := getUsers()
    ```

1.  使用传入的 ID 作为键从 `users` 映射中获取一个值。捕获值和 `exists` 值：

    ```go
      user, exists := users[id]
    ```

1.  返回两个值并关闭函数：

    ```go
      return user, exists
    }
    ```

1.  创建 `main` 函数：

    ```go
    func main() {
    ```

1.  确保至少传入了一个参数。如果没有，退出：

    ```go
      if len(os.Args) < 2 {
        fmt.Println("User ID not passed")
        os.Exit(1)
      }
    ```

1.  捕获传入的参数并调用获取用户函数：

    ```go
      userID := os.Args[1]
      name, exists := getUser(userID)
    ```

1.  如果找不到键，打印一条消息，然后使用 `range` 循环打印所有用户。之后，退出：

    ```go
      if !exists {
        fmt.Printf("Passed user ID (%v) not found.\nUsers:\n", userID)
        for key, value := range getUsers() {
          fmt.Println("  ID:", key, "Name:", value)
        }
        os.Exit(1)
      }
    ```

1.  如果一切正常，打印我们找到的名称：

    ```go
      fmt.Println("Name:", name)
    }
    ```

1.  保存文件。然后，在你在 *步骤 1* 中创建的文件夹中，使用以下命令运行代码：

    ```go
    go run . 123
    ```

1.  然后，运行以下命令：

    ```go
    go run . 305
    ```

    运行前面的代码会产生以下输出：

![图 4.8：显示所有用户及其找到的名称的输出![img/B14177_04_08.jpg](img/B14177_04_08.jpg)

图 4.8：显示所有用户及其找到的名称的输出

在这个练习中，我们学习了如何检查一个键是否存在于映射中。从需要先检查键的存在性才能获取值的语言中来看，这可能会显得有些奇怪，不是在获取值之后。这种做事方式确实意味着运行时错误的可能性要小得多。如果你的领域逻辑中零值是不可能的，那么你可以使用这个事实来检查键是否存在。

我们使用 `range` 循环来优雅地打印出我们映射中的所有用户。你的输出可能与前面截图中的输出顺序不同，这是因为当你使用 `range` 时，Go 会随机化映射中元素的顺序。

## 活动四.04：切片一周

在本活动中，我们将创建一个切片，并用一些数据初始化它。然后，我们将使用我们学到的关于子切片的知识来修改这个切片。以下是本活动的步骤：

1.  创建一个新的 Go 应用。

1.  创建一个切片，并用一周中的所有天初始化它，从周一开始到周日结束。

1.  使用切片范围更改切片，使其从周日开始，周六结束。

1.  将切片打印到控制台。

    预期的输出如下：

    ```go
    [Sunday Monday Tuesday Wednesday Thursday Friday Saturday]
    ```

    注意

    本活动的解决方案可以在第 700 页找到

## 从映射中删除元素

如果你需要从映射中删除一个元素，你需要做不同于数组或切片的事情。在数组中，你不能删除元素，因为长度是固定的；你最好的办法是将值置零。在切片中，你可以将值置零，但也可以使用切片范围和追加的组合来删除一个或多个元素。在映射中，你可以将值置零，但元素仍然存在，所以在你的逻辑中检查键是否存在时会导致问题。你也不能在映射上使用切片范围来删除元素。

要移除一个元素，我们需要使用内置的 `delete` 函数。当与映射一起使用时，`delete` 函数的函数签名是 `delete(<map>, <key>)`。`delete` 函数不返回任何内容，如果键不存在，则不执行任何操作。

## 练习 4.15：从映射中删除元素

在这个练习中，我们将定义一个映射，然后使用用户输入从其中删除一个元素。然后，我们将打印现在可能更小的映射到控制台。让我们开始吧：

1.  在新文件夹中创建一个名为 `main.go` 的文件。

1.  在 `main.go` 中添加包和导入：

    ```go
    package main
    import (
      "fmt"
      "os"
    )
    ```

1.  我们将在包作用域内定义我们的 `users` 映射：

    ```go
    var users = map[string]string{
      "305": "Sue",
      "204": "Bob",
      "631": "Jake",
      "073": "Tracy",
    }
    ```

1.  创建一个函数，使用传递的字符串作为键从 `users` 映射中删除：

    ```go
    func deleteUser(id string){
      delete(users, id)
    }
    ```

1.  在 `main` 中，我们将获取传递的 `userID` 并将 `users` 映射打印到控制台：

    ```go
    func main() {
      if len(os.Args) < 2 {
        fmt.Println("User ID not passed")
        os.Exit(1)
      }
      userID := os.Args[1]
      deleteUser(userID)
      fmt.Println("Users:", users)
    }
    ```

1.  保存文件。然后，在你在 *步骤 1* 中创建的文件夹中，使用以下命令运行代码：

    ```go
    go run . 305
    ```

    运行前面的代码会产生以下输出：

    ```go
    Users: map[073:Tracy 204:Bob 631:Jake]
    ```

在这个练习中，我们使用了内置的 `delete` 函数来完全从映射中移除一个元素。这个要求对映射来说是独特的；你不能在数组或切片上使用 `delete`。

## 活动四.05：从切片中移除元素

Go 没有内置的从切片中移除元素的功能，但你可以使用你学到的技术来实现。在本活动中，我们将设置一个包含一些数据和要移除的一个元素的切片。然后，你需要想出如何做到这一点。有许多方法可以完成这项工作，但你能否找到最紧凑的方法？

这里是这个活动的步骤：

1.  创建一个新的 Go 应用程序。

1.  创建一个包含以下元素的切片：

    Good

    Good

    Bad

    Good

    Good

1.  编写代码从切片中删除“Bad”元素。

1.  将结果打印到控制台。

    以下是我们预期的输出：

    ```go
    [Good Good Good Good]
    ```

    注意

    该活动的解决方案可以在第 701 页找到

# 简单自定义类型

你可以使用 Go 的简单类型作为起点来创建自定义类型。表示法是`type <name> <type>`。如果我们基于字符串创建一个 ID 类型，它将看起来像`type id string`。自定义类型与其基于的类型表现相同，包括获得相同的零值和具有与其他相同类型值比较的相同能力。自定义类型与其基类型不兼容，但你可以将自定义类型转换回其基于的类型，以允许交互。

## 练习 4.16：创建简单自定义类型

在这个练习中，我们将定义一个映射，然后使用用户输入从其中删除一个元素。然后，我们将打印现在可能更小的映射到控制台。让我们开始吧：

1.  创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。

1.  在`main.go`中添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  定义一个基于字符串类型的自定义类型`id`：

    ```go
    type id string
    ```

1.  创建一个返回三个 id 的函数：

    ```go
    func getIDs() (id, id, id) {
    ```

1.  对于`id1`，我们将初始化它并保留其零值：

    ```go
      var id1 id
    ```

1.  对于`id2`，我们将使用字符串字面量来初始化它：

    ```go
      var id2 id = "1234-5678"
    ```

1.  最后，对于`id3`，我们将将其初始化为零，然后单独设置一个值：

    ```go
      var id3 id
      id3 = "1234-5678"
    ```

1.  现在，返回 ids 并关闭函数：

    ```go
      return id1, id2, id3
    }
    ```

1.  在`main`中调用我们的函数并进行一些比较：

    ```go
    func main() {
      id1, id2, id3 := getIDs()
      fmt.Println("id1 == id2    :", id1 == id2)
      fmt.Println("id2 == id3    :", id2 == id3)
    ```

1.  对于这个先前的比较，我们将 id 转换回字符串：

    ```go
      fmt.Println("id2 == \"1234-5678\":", string(id2) == "1234-5678")
    }
    ```

1.  保存文件。然后，在你在*步骤 1*中创建的文件夹中，使用以下命令运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

![图 4.9：比较后的输出](img/B14177_04_09.jpg)

图 4.9：比较后的输出

在这个练习中，我们创建了一个自定义类型，为其设置数据，然后将其与相同类型和基类型的数据进行比较。

简单的自定义类型是构建现实世界中遇到的数据问题的基础部分。拥有旨在反映你需要处理的数据的类型可以帮助保持你的代码易于理解和维护。

# 结构体

集合非常适合将相同类型和目的的值分组在一起。在 Go 中，还有另一种方式将数据分组在一起，用于不同的目的。通常，一个简单的字符串、数字或布尔值并不能完全捕捉到你将拥有的数据的本质。

例如，对于我们的用户映射，一个用户通过他们的唯一 ID 和他们的名字来表示。这很少会有足够的信息来处理用户记录。你可以关于一个人捕获的数据几乎是无限的，比如他们的给定名、中间名和姓氏。他们偏好的前缀和后缀，他们的出生日期，他们的身高、体重或他们工作的地方也可以被捕获。将数据存储在多个具有相同键的映射中是可能的，但这很难处理和维护。

理想的做法是将所有这些不同的数据收集到一个单一的数据结构中，你可以设计和控制它。这就是 Go 的结构体类型：它是一个可以命名并指定字段属性及其类型的自定义类型。

结构体的表示法如下：

```go
type <name> struct {
  <fieldName1> <type>
  <fieldName2> <type>
  …
  <fieldNameN> <type>
}
```

字段名必须在结构体内部是唯一的。你可以为字段使用任何类型，包括指针、集合和其他结构体。

你可以使用以下表示法访问结构体上的字段：`<structValue>.<fieldName>`。要设置值，你使用以下表示法：`<structValue>.<fieldName> = <value>`。要读取值，你使用以下表示法：`value = <structValue>.<fieldName>`。

结构体是 Go 语言中与其它语言中所谓的类最接近的东西，但 Go 的设计者故意将结构体简化。一个关键的区别是结构体没有任何形式的继承。Go 的设计者认为，继承在现实世界的代码中带来的问题比解决的问题更多。

一旦你定义了自定义的结构体类型，你就可以用它来创建一个值。你有几种从结构体类型创建值的方法。现在让我们看看它们：

## 练习 4.17：创建结构体类型和值

在这个练习中，我们将定义一个用户结构体。我们将定义不同类型的字段。然后，我们将使用几种不同的方法创建一些结构体值。让我们开始吧：

1.  创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。

1.  在`main.go`中，添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  我们首先要做的是定义我们的结构体类型。你通常在包作用域内这样做。我们需要给它一个在包级作用域中唯一的名字：

    ```go
    type user struct {
    ```

1.  我们将添加不同类型的字段，然后关闭结构体定义：

    ```go
      name  string
      age   int
      balance float64
      member  bool
    }
    ```

1.  我们将创建一个返回我们新定义的结构体类型的切片的函数：

    ```go
    func getUsers() []user {
    ```

1.  我们首先使用键值表示法初始化第一个用户。这是初始化结构体的最常见形式：

    ```go
      u1 := user{
      name:  "Tracy",
      age:   51,
      balance: 98.43,
      member:  true,
      }
    ```

1.  当使用键值表示法时，字段的顺序无关紧要，你省略的任何字段都将获得其类型的零值：

    ```go
      u2 := user{
      age:  19,
      name: "Nick",
      }
    ```

1.  只用值来初始化一个结构体是可能的。如果你这样做，所有字段都必须存在，并且它们的顺序必须与你在结构体中定义它们的顺序相匹配：

    ```go
      u3 := user{
      "Bob",
      25,
      0,
      false,
      }
    ```

1.  这个`var`表示法将创建一个所有字段都为零值的结构体：

    ```go
      var u4 user
    ```

1.  现在，我们可以使用`.`和字段名来设置字段的值：

    ```go
      u4.name = "Sue"
      u4.age = 31
      u4.member = true
      u4.balance = 17.09
    ```

1.  现在，我们将返回包含值的切片并关闭函数：

    ```go
      return []user{u1, u2, u3, u4}
    }
    ```

1.  在`main`中，我们将获取`users`的切片，遍历它并将它打印到控制台：

    ```go
    func main() {
      users := getUsers()
      for i := 0; i < len(users); i++ {
      fmt.Printf("%v: %#v\n", i, users[i])
      }
    }
    ```

1.  保存文件。然后，在您在*步骤 1*中创建的文件夹中，使用以下命令运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

![图 4.10：根据新结构体的输出](img/B14177_04_10.jpg)

图 4.10：根据新结构体的输出

在这个练习中，您定义了一个包含多个字段的自定义结构体类型，每个字段类型不同。然后，我们使用几种不同的方法从该结构体创建值。这些方法都是有效的，在不同的上下文中都有用。

我们在包作用域中定义了结构体，虽然这不是典型做法，但您也可以在函数作用域中定义结构体类型。如果您在函数中定义了结构体类型，它将只在该函数中有效。当在包级别定义类型时，它可以在整个包中使用。

也可以同时定义和初始化一个结构体。如果您这样做，就不能重用该类型，但这仍然是一种有用的技术。记法如下：

```go
type <name> struct {
  <fieldName1> <type>
  <fieldName2> <type>
  …
  <fieldNameN> <type>
}{
  <value1>,
  <value2>,
  …
  <valueN>,
}
```

您也可以使用键值记法进行初始化，但仅使用值进行初始化在这种情况下是最常见的。

## 比较结构体

如果一个结构体的所有字段都是可比较的类型，那么整个结构体也是可比较的。所以，如果你的结构体由字符串和整数组成，那么你可以比较整个结构体。如果你的结构体中有一个切片，那么就不能。Go 是强类型语言，所以您只能比较相同类型的值，但结构体有一点点灵活性。如果结构体是匿名定义的，并且它与命名结构体具有相同的结构，那么 Go 允许比较。

## 练习 4.18：比较结构体

在这个练习中，我们将定义一个可比较的结构体并使用它创建一个值。我们还将定义具有与我们的命名结构体相同结构体的匿名结构体，并使用它们创建值。最后，我们将比较它们并将结果打印到控制台。让我们开始吧：

1.  创建一个新的文件夹，并向其中添加一个名为`main.go`的文件：

1.  在`main.go`中添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  让我们定义一个简单、可比较的结构体：

    ```go
    type point struct {
      x int
      y int
    }
    ```

1.  现在，我们将创建一个返回两个布尔值的函数：

    ```go
    func compare() (bool, bool) {
    ```

1.  创建我们的第一个匿名结构体：

    ```go
      point1 := struct {
        x int
        y int
      }{
        10,
        10,
      }
    ```

1.  使用第二个匿名结构体，我们将其初始化为零，然后在初始化后更改其值：

    ```go
      point2 := struct {
        x int
        y int
      }{}
      point2.x = 10
      point2.y = 5
    ```

1.  最后要创建的结构体使用了我们之前创建的命名结构体类型：

    ```go
      point3 := point{10, 10}
    ```

1.  比较它们。然后，返回并关闭函数：

    ```go
      return point1 == point2, point1 == point3
    }
    ```

1.  在`main`中，我们将调用我们的函数并打印结果：

    ```go
    func main() {
      a, b := compare()
      fmt.Println("point1 == point2:", a)
      fmt.Println("point1 == point3:", b)
    }
    ```

1.  保存文件。然后，在您在*步骤 1*中创建的文件夹中，使用以下命令运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

![图 4.11：比较结构体的输出](img/B14177_04_11.jpg)

图 4.11：比较结构体的输出

在这个练习中，我们看到了我们可以像处理命名结构体类型一样处理匿名结构体值，包括比较它们。对于命名类型，你只能比较相同类型的结构体。当你比较 Go 中的类型时，Go 会比较所有字段以检查匹配。Go 允许比较这些匿名结构体，因为字段名称和类型匹配。Go 在比较这种结构体时有点灵活。

## 使用内嵌的结构体组合

虽然 Go 结构体不支持继承，但 Go 的设计者确实包含了一个令人兴奋的替代方案。这个替代方案是将类型嵌入到结构体类型中。使用内嵌，你可以从其他结构体向结构体添加字段。这种组合功能的效果是让你可以使用其他结构体作为组件来向结构体添加内容。内嵌与有一个结构体类型的字段不同。当你内嵌时，内嵌结构体的字段会被提升。一旦提升，字段就像是在目标结构体上定义的一样。

要嵌入一个结构体，你就像添加一个字段一样添加它，但不要指定名称。为此，你将结构体类型名称添加到另一个结构体中，而不给它一个字段名称，这看起来是这样的：

```go
type <name> struct {
  <Type>
}
```

虽然不常见，但你可以在结构体中内嵌任何其他类型。没有需要推广的内容，因此要访问内嵌类型，你需要使用类型的名称来访问它，例如，`<structValue>.<type>`。通过类型名称访问内嵌类型的方式也适用于结构体。这意味着与内嵌类型和根字段名称相比，类型的名称必须是唯一的。在嵌入指针类型时，类型的名称是不带指针表示的类型名称，因此`*<type>`名称变为`<type>`。字段仍然是指针，只是名称不同。

当涉及到推广时，如果你与结构体的字段名称有任何重叠，Go 允许你内嵌，但重叠字段的推广不会发生。你仍然可以通过类型名称路径来访问该字段。

在使用内嵌类型初始化结构体时，不能使用推广。为了初始化数据，你必须使用内嵌类型的名称。

## 练习 4.19：结构体内嵌和初始化

在这个练习中，我们将定义一些结构体和自定义类型。我们将将这些类型嵌入到结构体中。让我们开始吧：

1.  创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。

1.  在`main.go`中添加包和导入：

    ```go
    package main
    import "fmt"
    ```

1.  创建一个名为 name 的自定义字符串类型：

    ```go
    type name string
    ```

1.  创建一个名为 location 的结构体，包含两个 int 字段，即`x`和`y`：

    ```go
    type location struct {
      x int
      y int
    }
    ```

1.  创建一个包含两个 int 字段的大小结构体，即`width`和`height`：

    ```go
    type size struct {
      width  int
      height int
    }
    ```

1.  创建一个名为`dot`的结构体。它将前面提到的每个结构体嵌入其中：

    ```go
    type dot struct {
      name
      location
      size
    }
    ```

1.  创建一个返回 dots 切片的函数：

    ```go
    func getDots() []dot {
    ```

1.  我们第一个`dot`使用`var`表示法。这将导致所有字段都具有零值：

    ```go
      var dot1 dot
    ```

1.  在`dot2`中，我们也在使用零值进行初始化：

    ```go
      dot2 := dot{}
    ```

1.  要设置名称，我们使用类型的名称，就像它是一个字段一样：

    ```go
      dot2.name = "A"
    ```

1.  对于大小和位置，我们将使用提升的字段来设置它们的值：

    ```go
      dot2.x = 5
      dot2.y = 6
      dot2.width = 10
      dot2.height = 20
    ```

1.  在初始化内嵌类型时，不能使用提升。对于名称，结果是相同的，但对于位置和大小，你需要在这方面多下功夫：

    ```go
      dot3 := dot{
      name: "B",
      location: location{
        x: 13,
        y: 27,
      },
      size: size{
        width:  5,
        height: 7,
      },
      }
    ```

1.  对于`dot4`，我们将使用类型名称来设置数据：

    ```go
      dot4 := dot{}
      dot4.name = "C"
      dot4.location.x = 101
      dot4.location.y = 209
      dot4.size.width = 87
      dot4.size.height = 43
    ```

1.  返回切片中的所有点并关闭函数：

    ```go
      return []dot{dot1, dot2, dot3, dot4}
    }
    ```

1.  在`main`函数中调用该函数。然后，遍历切片并将其打印到控制台：

    ```go
    func main() {
      dots := getDots()
      for i := 0; i < len(dots); i++ {
        fmt.Printf("dot%v: %#v\n", i+1, dots[i])
      }
    }
    ```

1.  保存文件。然后，在你在*步骤 1*中创建的文件夹中，使用以下命令运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

![图 4.12：结构体内嵌和初始化后的输出![图 4.12：结构体内嵌和初始化后的输出图 4.12：结构体内嵌和初始化后的输出在这个练习中，我们能够通过将其他类型嵌入其中来定义一个复杂的结构体。内嵌允许你通过减少重复代码来重用常见的结构，同时仍然给你的结构体提供一个扁平的 API。在现实世界的 Go 代码中，我们不会看到很多内嵌。它确实会出现，但由于复杂性和异常，Go 开发者更喜欢将其他结构体作为命名字段。## 类型转换有时候你的类型可能不匹配，在 Go 的严格类型系统中，如果类型不相同，它们就不能相互交互。在这些情况下，你有两个选择。如果两种类型是兼容的，你可以进行类型转换——也就是说，你可以通过将一种类型转换为另一种类型来创建一个新的值。进行这种转换的表示法是`<value>.(<type>)`。当处理字符串时，我们使用这个表示法将字符串转换为 runes 或 bytes 的切片，然后再转换回来。这是因为字符串是一个特殊类型，它将字符串的数据存储为一个字节的切片。字符串类型转换是有损的，但并非所有类型转换都是这样。当处理数值类型转换时，数值可能会从原始值改变。例如，如果你将一个大的`int`类型，比如`int64`，转换为一个较小的`int`类型，比如`int8`，这会导致数值溢出。如果你要将无符号整数，比如`uint64`，转换为一个有符号整数，比如`int64`，这种溢出会发生，因为无符号整数可以存储比有符号的`int`更高的数值。当将`int`转换为`float`时，这种溢出也会发生，因为`float`将其存储空间分割为整数部分和小数部分。当从`float`转换为`int`时，小数部分会被截断。进行这类有损转换仍然非常合理，这些转换在现实世界的代码中经常发生。如果你知道你处理的数据不会跨越这些阈值，那么就没有必要担心。Go 会尽力猜测需要转换的类型。这被称为隐式类型转换。例如，`math.MaxInt8`是一个`int`，如果您尝试将其赋值给一个非`int`类型的数字，Go 会为您进行隐式类型转换。## 练习 4.20：数值类型转换在这个练习中，我们将进行一些数值类型转换，并故意造成一些数据问题。让我们开始吧：1.  创建一个新的文件夹，并在其中添加一个名为`main.go`的文件。1.  在`main.go`中添加包和导入：    ```go    package main    import (      "fmt"      "math"    )    ```1.  创建一个返回字符串的函数：    ```go    func convert() string{    ```1.  定义一些变量来完成我们的工作。Go 会将`int`类型的`math.MaxInt8`隐式转换为`int8`：    ```go      var i8 int8 = math.MaxInt8      i := 128      f64 := 3.14    ```1.  在这里，我们将从较小的`int`类型转换为较大的`int`类型。这始终是一个安全的操作：    ```go      m := fmt.Sprintf("int8  = %v  > in64  = %v\n", i8, int64(i8))    ```1.  现在，我们将从比`int8`最大值大 1 的`int`类型进行转换。这将导致溢出到`int8`的最小值：    ```go      m += fmt.Sprintf("int   = %v  > in8   = %v\n", i, int8(i))    ```1.  接下来，我们将`int8`转换为`float64`。这不会导致溢出，数据保持不变：    ```go      m += fmt.Sprintf("int8  = %v  > float32 = %v\n", i8, float64(i8))    ```1.  在这里，我们将一个浮点数转换为`int`。所有的小数数据都会丢失，但整数部分会保持不变：    ```go      m += fmt.Sprintf("float64 = %v > int   = %v\n", f64, int(f64))    ```1.  返回消息然后关闭函数：    ```go      return m    }    ```1.  在`main()`函数中，调用函数并将输出打印到控制台：    ```go    func main() {      fmt.Print(convert())    }    ```1.  保存文件。然后，在您创建的文件夹中，使用以下命令运行代码：    ```go    go run .    ```    运行前面的代码会产生以下输出：![图 4.13：转换后的输出](img/B14177_04_13.jpg)

图 4.13：转换后的输出

## 类型断言和 interface{}

我们已经大量使用了`fmt.Print`及其兄弟函数来编写我们的代码，但 Go 是强类型语言，那么像`fmt.Print`这样的函数是如何接受任何类型的值呢？让我们看看`fmt.Print`的实际 Go 标准库代码：

```go
// Print formats using the default formats for its operands and writes to standard output.
// Spaces are added between operands when neither is a string.
// It returns the number of bytes written and any write error encountered.
func Print(a ...interface{}) (n int, err error) {
  return Fprint(os.Stdout, a...)
}
```

希望您能看出查看 Go 的源代码并不可怕——这是一个了解您应该如何做事的好方法，我建议您在好奇他们是如何做某事的时候查看它。

通过查看这段代码，我们可以看到 `fmt.Print` 有一个 `interface{}` 类型的可变参数。我们将在稍后更详细地介绍接口，但就现在而言，你需要知道的是，Go 中的接口描述了一个类型必须具有哪些函数才能符合该接口。Go 中的接口不描述字段，也不描述类型的核心值，例如字符串或数字。在 Go 中，任何类型都可以有函数，包括字符串和数字。`interface{}` 描述的是一个没有函数的类型。没有函数、字段和核心值的值有什么用？没有用，但它仍然是一个值，并且仍然可以被传递。这个接口不是设置值的类型，而是控制它将允许哪些值作为具有该接口的变量。Go 中哪些类型符合 `interface{}`？所有类型都符合！Go 的任何类型或你创建的任何自定义类型都符合 `interface{}`，这就是 `fmt.Print` 可以接受任何类型的原因。你还可以在你的代码中使用 `interface{}` 来实现相同的结果。

一旦你有了符合 `interface{}` 的变量，你能用它做什么？即使你的 `interface{}` 变量的底层值有函数、字段或核心值，你也不能使用它们，因为 Go 正在强制执行接口的合约，这就是为什么这仍然是所有类型安全的。

为了解锁被 `interface{}` 遮盖的值的特性，我们需要使用类型断言。类型断言的表示法是 `<value>.(<type>)`。类型断言会产生一个请求的类型值，以及一个可选的 bool 值，表示是否成功。这看起来像 `<value> := <value>.(<type>)` 或 `<value>, <ok> := <value>.(type)`。如果你省略布尔值，并且类型断言失败，Go 会引发恐慌。

当你将值放入 `interface{}` 变量中时，Go 不会从值中移除任何内容。发生的情况是 Go 编译器阻止你使用它，因为它无法在编译时执行其类型安全检查。使用类型断言是你的指令，告诉 Go 你想要解锁这个值。当你进行类型断言时，Go 会执行它在编译时本应执行的类型安全检查，这些检查可能会失败。然后，你必须负责处理类型安全检查失败的情况。类型断言是一个会导致运行时错误和恐慌的特性，这意味着你必须格外小心地处理它们。

## 练习 4.21：类型断言

在这个练习中，我们将执行一些类型断言，并确保我们在执行类型断言时所有安全检查都到位。让我们开始吧：

1.  在新文件夹中创建一个名为 `main.go` 的文件。

1.  在 `main.go` 中添加包和导入：

    ```go
    package main
    import (
      "errors"
      "fmt"
    )
    ```

1.  创建一个接受 `interface{}` 并返回字符串和错误的函数：

    ```go
    func doubler(v interface{}) (string, error) {
    ```

1.  首先，我们将检查我们的参数是否为 int，如果是，我们将将其乘以 `2` 并返回它：

    ```go
      if i, ok := v.(int); ok {
        return fmt.Sprint(i * 2), nil
      }
    ```

1.  在这里，我们将检查它是否为字符串，如果是，我们将将其与自身连接并返回它：

    ```go
      if s, ok := v.(string); ok {
        return s + s, nil
      }
    ```

1.  如果我们没有匹配到任何内容，返回一个错误。然后，关闭函数：

    ```go
      return "", errors.New("unsupported type passed")
    }
    ```

1.  在`main`中，用各种数据调用`doubler`，并将结果打印到控制台：

    ```go
    func main() {
      res, _ := doubler(5)
      fmt.Println("5   :", res)
      res, _ = doubler("yum")
      fmt.Println("yum :", res)
      _, err := doubler(true)
      fmt.Println("true:", err)
    }
    ```

1.  保存文件。然后，在你在*步骤 1*中创建的文件夹中，使用以下命令运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

![图 4.14：显示匹配的输出](img/B14177_04_14.jpg)

图 4.14：显示匹配的输出

`interface{}`和类型断言的组合允许你克服 Go 的严格类型控制，从而允许你创建可以处理任何类型变量的函数。挑战在于，你失去了 Go 在编译时为你提供的类型安全保护。仍然可能做到安全，但现在责任在你身上——如果你做错了，你将得到一个讨厌的运行时错误。

## 类型切换

如果我们想将`doubler`函数扩展到包括所有`int`类型，我们最终会有很多重复的逻辑。Go 有一种处理更复杂类型断言情况的方法，称为类型切换。下面是这个样子：

```go
switch <value> := <value>.(type) {
case <type>:
  <statement>
case <type>, <type>:
  <statement>
default:
  <statement>
}
```

类型切换仅在匹配你寻找的类型时运行你的逻辑，并将值设置为该类型。你可以在 case 中匹配多个类型，但 Go 不能为你更改值的类型，所以你仍然需要进行类型断言。使这成为类型切换而不是表达式切换的其中一个特点是`<value>.(type)`记法。你只能将其用作类型切换的一部分。类型切换独有的另一个特点是，你不能使用`fallthrough`语句。

## 练习 4.22：类型切换

在这个练习中，我们将更新我们的`doubler`函数，使其使用类型切换并扩展其功能以处理更多类型。让我们开始吧：

1.  创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。

1.  在`main.go`中添加包和导入：

    ```go
    package main
    import (
      "errors"
      "fmt"
    )
    ```

1.  创建我们的函数，它接受一个`inferface{}`参数，并返回一个字符串和一个错误：

    ```go
    func doubler(v interface{}) (string, error) {
    ```

1.  使用我们的参数创建一个类型切换：

    ```go
      switch t := v.(type) {
    ```

1.  对于`string`和`bool`，由于我们只匹配一个类型，我们不需要进行任何额外的安全检查，可以直接处理值：

    ```go
      case string:
      return t + t, nil
      case bool:
      if t {
        return "truetrue", nil
      }
      return "falsefalse", nil
    ```

1.  对于浮点数，我们匹配了多个类型。这意味着我们需要进行类型断言才能处理该值：

    ```go
      case float32, float64:
      if f, ok := t.(float64); ok {
        return fmt.Sprint(f * 2), nil
      }
    ```

1.  如果这个类型断言失败，我们会得到一个恐慌，但我们可以依赖这样一个逻辑：只有`float32`可以直接与类型断言的结果一起工作：

    ```go
      return fmt.Sprint(t.(float32) * 2), nil
    ```

1.  匹配所有的`int`和`uint`类型。我们通过不需要自己进行类型安全检查，在这里删除了很多代码：

    ```go
      case int:
      return fmt.Sprint(t * 2), nil
      case int8:
      return fmt.Sprint(t * 2), nil
      case int16:
      return fmt.Sprint(t * 2), nil
      case int32:
      return fmt.Sprint(t * 2), nil
      case int64:
      return fmt.Sprint(t * 2), nil
      case uint:
      return fmt.Sprint(t * 2), nil
      case uint8:
      return fmt.Sprint(t * 2), nil
      case uint16:
      return fmt.Sprint(t * 2), nil
      case uint32:
      return fmt.Sprint(t * 2), nil
      case uint64:
      return fmt.Sprint(t * 2), nil
    ```

1.  我们将使用默认值返回一个错误。然后，我们将关闭 switch 语句和函数：

    ```go
      default:
      return "", errors.New("unsupported type passed")
      }
    }
    ```

1.  在`main()`函数中，用更多数据调用我们的函数，并将结果打印到控制台：

    ```go
    func main() {
      res, _ := doubler(-5)
      fmt.Println("-5  :", res)
      res, _ = doubler(5)
      fmt.Println("5   :", res)
      res, _ = doubler("yum")
      fmt.Println("yum :", res)
      res, _ = doubler(true)
      fmt.Println("true:", res)
      res, _ = doubler(float32(3.14))
      fmt.Println("3.14:", res)
    }
    ```

1.  保存文件。然后，在你在*步骤 1*中创建的文件夹中，使用以下命令运行代码：

    ```go
    go run .
    ```

    运行前面的代码会产生以下输出：

![图 4.15：调用函数后的输出](img/B14177_04_15.jpg)

图 4.15：调用函数后的输出

在这个练习中，我们使用类型选择（type switch）构建了一个复杂类型断言场景。使用类型选择仍然让我们对类型断言有完全的控制，同时也让我们在不需要这种控制级别时简化了类型安全逻辑。

## 活动四.06：类型检查器

在这个活动中，你将编写一些包含切片或不同类型数据的逻辑。这些数据类型如下：

+   一个整数

+   一个浮点数

+   一个字符串

+   一个布尔值

+   一个结构体

创建一个接受任何类型值的函数。该函数返回一个包含类型名称的字符串：

+   对于 int、int32 和 int64，它返回`int`。

+   对于所有浮点数，它返回`float`。

+   对于字符串，它返回`string`。

+   对于布尔值，它返回`bool`。

+   对于其他任何东西，它返回`unknown`。

+   通过将每个数据传递给函数来遍历所有数据。

+   然后，将数据和其类型名称打印到控制台。

    预期输出如下：

![图 4.16：预期输出](img/B14177_04_16.jpg)

图 4.16：预期输出

注意

本活动的解决方案可以在第 702 页找到

# 摘要

在本章中，我们探讨了 Go 中变量和类型的进阶用法。现实世界的代码很快就会变得复杂，因为现实世界本身就是复杂的。能够准确地对数据进行建模并在代码中逻辑上组织这些数据有助于将代码的复杂性降低到最小。

你现在知道如何将类似的数据分组，无论是使用数组在固定长度有序列表中，还是在动态长度有序列表中使用切片，或者在使用映射的键值哈希中。

我们学习了如何超越 Go 的核心类型，并开始创建基于核心类型或通过创建一个结构体（struct）的自定义类型，结构体是一个包含在单个类型和值中的其他类型的集合。

有时会遇到类型不匹配的情况，因此 Go 赋予我们转换兼容类型的能力，以便它们可以以类型安全的方式交互。

Go 还让我们摆脱了其类型安全规则，并赋予我们完全的控制权。通过使用类型断言，我们可以使用`interface{}`的魔力接受任何类型，然后获取这些类型。

在下一章中，我们将探讨如何将我们的逻辑分组为可重用组件，并将它们附加到我们的自定义类型上，从而使我们的代码更加直接且易于维护。
