# 2

# Protobuf 初学者指南

既然我们已经理解了 gRPC 背后的基本网络概念，我们可以触及构建你的 gRPC API 的另一个支柱。这个支柱是 **协议缓冲区**，更通俗地称为 **Protobuf**。它是通信过程中的一个重要部分，因为我们看到，在上一章中，每条消息都被编码成二进制，这正是 Protobuf 在 gRPC 中为我们所做的事情。在本章中，目标是理解 Protobuf 是什么以及为什么它对于高效通信是必需的。最后，我们将探讨一些关于消息序列化和反序列化的细节。

在本章中，我们将涵盖以下主要主题：

+   Protobuf 是一种 **接口描述** **语言**（**IDL**）

+   序列化/反序列化

+   Protobuf 与 JSON 的比较

+   编码细节

+   常见类型

+   服务

# 前提条件

你可以在 https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter2 找到本章的代码。在本章中，我们将讨论 Protocol Buffers 如何序列化和反序列化数据。虽然这可以通过编写代码来完成，但我们将避免这样做，以便学习如何使用 protoc 编译器来调试和优化我们的 Protobuf 模式。因此，如果你想重现指定的示例，你需要从 Protobuf GitHub *发布* 页面（https://github.com/protocolbuffers/protobuf/releases）下载 protoc 编译器。开始的最简单方法是下载二进制发布版本。这些发布版本按照以下约定命名：`protoc-${VERSION}-${OS}-{ARCHITECTURE}`。解压缩 zip 文件，并遵循 `readme.txt` 指示（注意：我们打算在未来使用已知类型，所以请确保你也安装了包含文件）。之后，你应该能够运行以下命令：

```go
$ protoc --version
```

最后，像往常一样，你可以在 GitHub 仓库当前章节文件夹（`chapter2`）下找到配套代码。

# Protobuf 是一种 IDL

Protobuf 是一种语言。更确切地说，它是一种 IDL。做出这种区分很重要，因为正如我们稍后会更详细地看到的那样，在 Protobuf 中，我们不会像在编程语言中那样编写任何逻辑，而是编写数据模式，这些模式是用于序列化的合约，并且需要在反序列化时得到满足。因此，在我们解释编写 `.proto` 文件时需要遵循的所有规则，并详细了解序列化和反序列化的所有细节之前，我们首先需要了解什么是 IDL 以及这种语言的目标。

如我们之前所看到的，IDL 是*接口描述语言*的缩写，我们可以看到，名称包含三个部分。第一部分是**接口**，描述了一段代码，位于两个或更多应用程序之间，隐藏了实现的复杂性。因此，我们不对应用程序运行的硬件、运行的操作系统以及用哪种编程语言编写的假设。这个接口按设计是硬件无关、操作系统无关和语言无关的。这对于 Protobuf 和几个其他序列化数据模式来说很重要，因为它允许开发者一次编写代码，并且可以在不同的项目中使用。

第二部分是包含 ID、用户名和该账户拥有的权限的`Account`，我们可以编写以下内容：

```go
syntax = "proto3";
enum AccountRight {
  ACCOUNT_RIGHT_UNSPECIFIED = 0;
  ACCOUNT_RIGHT_READ = 1;
  ACCOUNT_RIGHT_READ_WRITE = 2;
  ACCOUNT_RIGHT_ADMIN = 3;
}
message Account {
  uint64 id = 1;
  string username = 2;
  AccountRight right = 3;
}
```

如果我们跳过一些在这个阶段不重要的细节，我们可以看到我们定义了以下内容：

+   一个列出所有可能权限的枚举和一个额外的角色`ACCOUNT_RIGHT_UNSPECIFIED`

+   一个消息（相当于类或结构体），列出`Account`类型应该拥有的三个属性

再次，不查看细节，它也是可读的，并且`Account`和`AccountRight`之间的关系很容易理解。

最后，最后一部分是之前定义的`Account`类型在 Go 中的表示：

```go
type AccountRight int32
const (
  AccountRight_ACCOUNT_RIGHT_UNSPECIFIED AccountRight = 0
  AccountRight_ACCOUNT_RIGHT_READ AccountRight = 1
  AccountRight_ACCOUNT_RIGHT_READ_WRITE AccountRight = 2
  AccountRight_ACCOUNT_RIGHT_ADMIN AccountRight = 3
)
type Account struct {
  Id uint64 `protobuf:"varint,1,…`
  Username string `protobuf:"bytes,2,…`
  Right AccountRight `protobuf:"varint,3,…`
}
```

在此代码中，有一些重要的事情需要注意。让我们将此代码分解成几个部分：

```go
type AccountRight int32
const (
  AccountRight_ACCOUNT_RIGHT_UNSPECIFIED AccountRight = 0
  AccountRight_ACCOUNT_RIGHT_READ AccountRight = 1
  AccountRight_ACCOUNT_RIGHT_READ_WRITE AccountRight = 2
  AccountRight_ACCOUNT_RIGHT_ADMIN AccountRight = 3
)
```

我们的`AccountRight`枚举定义为具有`int32`类型的值的常量。每个枚举变体的名称都以前缀枚举的名称开头，每个常量都有我们在 Protobuf 代码中等于号后面的设置值。这些值被称为字段标签，我们将在本章后面介绍它们。

现在，看一下以下代码：

```go
type Account struct {
  Id uint64 `protobuf:"varint,1,…`
  Username string `protobuf:"bytes,2,…`
  Right AccountRight `protobuf:"varint,3,…`
}
```

这里，我们的`Account`消息被转换为一个具有`Id`、`Username`和`Right`导出字段的 struct。这些字段中的每个字段都有一个类型，该类型从 Protobuf 类型转换为 Golang 类型。在我们的例子中，Go 类型和 Protobuf 类型具有完全相同的名称，但重要的是要知道在某些情况下，类型将不同地转换。这样的例子是 Protobuf 中的`double`，它将转换为 Go 的`float64`。最后，我们还有字段标签，在字段后面的元数据中引用。再次，它们的含义将在本章后面解释。

因此，为了总结，IDL 是一段代码，位于不同的应用程序之间，通过遵循某些定义的规则来描述对象及其关系。在这种情况下，Protobuf 的 IDL 将被读取，并用于在另一种语言中生成代码。然后，生成的代码将被用户代码用于序列化和反序列化数据。

# 序列化和反序列化

序列化和反序列化是许多方式和许多类型的应用程序中使用的两个概念。本节将讨论这两个概念在 Protobuf 的背景下。因此，即使你对这两个概念的理解很有信心，了解它们也是非常重要的。一旦你做到了，处理*编码细节*部分就会更容易，我们将深入探讨 Protobuf 如何底层序列化和反序列化数据。

让我们从序列化开始，然后简要提及反序列化，它是一个相反的过程。序列化的目的是存储数据，通常以更紧凑或可读的表示形式，以便以后使用。对于 Protobuf，这种序列化发生在你生成的代码对象中设置的数据上。例如，如果我们设置了`Id`、`Username`和`Right`字段在我们的`Account`结构体中，这些数据将是 Protobuf 将要处理的数据。它将根据字段类型使用不同的算法将每个字段转换为二进制表示。然后，我们使用这个内存中的二进制数据，要么通过网络（例如使用 gRPC）发送数据，要么将其存储在更持久的存储中。

当我们再次使用这个序列化数据时，Protobuf 将执行反序列化。这是一个读取之前创建的二进制文件并将数据重新填充到你喜欢的编程语言中的对象的过程，以便能够对其采取行动。再次强调，Protobuf 将根据读取的数据类型使用不同的算法来读取底层的二进制文件，并知道如何设置或不设置相关对象的每个字段。

总结来说，Protobuf 通过二进制序列化使数据比其他格式（如 XML 或 JSON）更紧凑。为此，它将从生成的代码对象的各个字段中读取数据，将其转换为二进制，并使用不同的算法，然后当我们最终需要数据时，Protobuf 将读取数据并填充给定对象的字段。

# Protobuf 与 JSON

如果你已经在后端甚至前端工作过，有 99.99%的几率你已经使用过 JSON。这无疑是目前最受欢迎的数据模式，并且有原因使其成为如此。在本节中，我们将讨论 JSON 和 Protobuf 的优缺点，并解释哪种情况更适合哪种情况。我们的目标是保持客观，因为作为工程师，我们需要选择适合正确工作的正确工具。

由于我们可以为每种技术的优缺点写上章节，我们将缩小这些优缺点的范围到三个类别。这些类别是开发者在开发应用程序时最关心的，具体如下：

+   **序列化数据的大小**：我们希望在通过网络发送数据时减少带宽

+   **数据模式和序列化数据的可读性**：我们希望能够有一个描述性的模式，以便新来者或用户可以快速理解它，并且我们希望能够可视化序列化的数据，用于调试或编辑目的。

+   **模式严格性**：当 API 增长时，这迅速成为一项需求，我们需要确保不同应用程序之间发送和接收的数据类型是正确的

## 序列化数据大小

在序列化过程中，许多用例中的圣杯是减少数据的大小。这是因为我们通常希望将数据发送到网络上的另一个应用程序，负载越轻，它应该到达另一侧的速度就越快。*在这个领域，Protobuf 相对于 JSON 是明显的赢家*。这是因为 JSON 序列化为文本，而 Protobuf 序列化为二进制，因此有更多的空间来改进序列化数据的大小。一个例子是数字。如果你在 JSON 中将一个数字设置为`id`字段，你会得到类似以下的内容：

```go
{ id: 123 }
```

首先，我们有一些带有大括号的模板代码，但最重要的是我们有一个占用三个字符或三个字节的数字。在 Protobuf 中，如果我们对同一个字段设置相同的值，我们将在以下示例中看到其十六进制表示。

重要提示

在配套 GitHub 仓库的`chapter2`文件夹中，你可以找到复制本章所有结果所需的文件。使用 protoc，我们将能够显示我们序列化数据的十六进制表示。为此，你可以运行以下命令：

Linux/Mac: `cat ${INPUT_FILE_NAME}.txt | protoc --encode=${MESSAGE_NAME} ${PROTO_FILE_NAME}.proto |` `hexdump –C`

Windows (PowerShell): ``(Get-Content ${INPUT_FILE_NAME}.txt | protoc --encode=${MESSAGE_NAME} ${PROTO_FILE_NAME}.proto) -join "`n" |`` `Format-Hex`

例如：

`$ cat account.txt` `| protoc --encode=Account account.proto |` `hexdump -C`

`00000000 08 7b |.{|`

`00000002`

目前，这可能会看起来像是魔法数字，但我们在下一节将看到它是如何编码成两个字节的。现在，两个字节而不是三个字节可能看起来微不足道，但想象一下这种差异在规模上的影响，你就会浪费数百万字节。

## 可读性

数据模式序列化的下一个重要问题是可读性。然而，可读性这个概念有点过于宽泛，尤其是在 Protobuf 的上下文中。正如我们所见，与 JSON 相比，Protobuf 将模式与序列化数据分开。我们在`.proto`文件中编写模式，然后序列化将给我们一些二进制数据。在 JSON 中，模式就是实际的序列化数据。因此，为了更清晰和更精确地描述可读性，让我们将可读性分为两部分：模式的可读性和序列化数据的可读性。

至于方案的可读性，这是一个个人偏好的问题，但有一些要点使 Protobuf 脱颖而出。其中之一是 Protobuf 可以包含注释，这对于描述需求的额外文档来说是个好东西。JSON 不允许在方案中包含注释，因此我们必须找到不同的方式来提供文档。通常，这是通过 GitHub wiki 或其他外部文档平台来完成的。这是一个问题，因为当项目和团队变大时，这种类型的文档很快就会过时。一个简单的疏忽，你的文档就不会描述你的 API 的真实状态。使用 Protobuf，尽管仍然可能存在过时的文档，但文档与代码更接近，这提供了更多激励和意识来更改相关的注释。

Protobuf 更易读的第二个特性是它具有显式的类型。JSON 有类型，但它们是隐式的。你知道如果一个字段的值被双引号包围，那么它包含一个字符串；如果值仅是数字，那么它是一个数字，等等。在 Protobuf 中，尤其是对于数字，我们从类型中获得了更多信息。如果我们有一个`int32`类型，我们可以明显知道这是一个数字，但除此之外，我们还知道它可以接受负数，并且我们可以知道可以存储在这个字段中的数字范围。显式类型不仅对于安全性（稍后会更详细地讨论）很重要，而且还可以让开发者了解每个字段的详细信息，并让他们能够准确地描述其模式以满足业务需求。

*为了方案的易读性，我认为我们可以一致认为 Protobuf 在这里是赢家*，因为它可以被编写为自文档化的代码，并且我们为对象中的每个字段都获得了显式的类型。

*至于序列化数据的可读性，JSON 在这里是明显的赢家*。如前所述，JSON 既是数据模式也是序列化数据。你所看到的就是你所得到的。然而，Protobuf 将数据序列化为二进制，即使你知道如何序列化和反序列化 Protobuf 数据，阅读起来也相当困难。最终，这是可读性和序列化数据大小之间的权衡。在序列化数据方面，Protobuf 将优于 JSON，并且在数据模式的可读性方面更加明确。然而，如果你需要可以手动编辑的人可读数据，Protobuf 可能不是你的用例的最佳选择。

## 方案严格性

最后，最后一个类别是方案的严格性。当你的团队和项目规模扩大时，这通常是一个很好的特性，因为它确保了方案被正确填充，并且对于某些目标语言，它缩短了开发者的反馈循环。

模式总是有效的，因为每个字段都有一个明确的类型，只能包含特定的值。我们绝对不能将字符串传递给期望数字的字段，或者将负数传递给期望正数的字段。这种约束在生成的代码中通过动态语言的运行时检查或类型语言的编译时检查来执行。在我们的情况下，由于 Go 是一种类型语言，我们将有编译时检查。

最后，在类型语言中，模式缩短了反馈循环，因为我们不再需要可能触发或可能不触发错误的运行时检查，我们只需要一个编译错误。这使得我们的软件更加可靠，开发者可以确信，如果他们能够编译，那么放入对象中的数据集将是有效的。

在纯 JSON 中，我们无法确保在编译时我们的模式是正确的。通常，开发者会添加额外的配置，如 JSON Schema，以便在运行时获得这种保证。这增加了我们项目的复杂性，并要求每个开发者都应自律，因为他们可以简单地编写代码而不开发模式。在 Protobuf 中，我们进行模式驱动开发。模式首先出现，然后我们的应用程序围绕生成的类型展开。此外，我们在编译时确保我们设置的值是正确的，我们不需要将设置复制到所有我们的微服务或子项目中。最终，我们在配置上花费的时间更少，我们在数据模式和数据编码上的思考时间更多。

# 编码细节

到目前为止，我们谈论了很多关于“算法”的内容；然而，我们并没有深入到具体的细节。在本节中，我们将探讨在 Protobuf 中序列化和反序列化过程中所涉及的 主要算法。我们首先将查看我们可以用于字段的全部类型，然后根据这些类型，我们将它们分为三个类别，最后我们将解释每个类别所使用的算法。

在 Protobuf 中，被认为是简单且由 Protobuf 自带提供的类型被称为**标量类型**。我们可以使用这里列出的 15 种此类类型：

+   `int32`

+   `int64`

+   `uint32`

+   `uint64`

+   `sint32`

+   `sint64`

+   `fixed32`

+   `fixed64`

+   `sfixed32`

+   `sfixed64`

+   `double`

+   `float`

+   `string`

+   `bytes`

+   `bool`

在这 15 种类型中，有 10 种是用于整数的（前 10 种）。这些类型一开始可能看起来有些令人畏惧，但请不要过于担心如何在这之间做出选择，我们将在本节中讨论这一点。现在最重要的理解是，三分之二的类型是用于整数的，这显示了 Protobuf 的优势——编码整数。

现在我们已经了解了标量类型，让我们将这些类型分为三个类别。然而，我们在这里不是为了创建简单的类别，比如数字、数组等等。我们想要创建与 Protobuf 序列化算法相关的类别。总共有三个：固定大小数字、可变大小整数（varints）和长度限定类型。以下是一个包含每个类别的表格：

| **固定大小数字** | **Varints** | **Length-delimited types** |
| --- | --- | --- |
| `fixed32` | `int32` | `string` |
| `fixed64` | `int64` | `bytes` |
| `sfixed32` | `uint32` |  |
| `sfixed64` | `uint64` |  |
| `double` | `bool` |  |
| `float` |  |  |

让我们逐一介绍。

## 固定大小数字

对于习惯于静态语言的开发者来说，最容易理解的是固定大小数字。如果你在尝试优化存储空间的底层语言中工作过，你知道在大多数硬件上，我们可以用 32 位（4 字节）或 64 位（8 字节）存储一个整数。`fixed32` 和 `fixed64` 只是正常数字的二进制表示，这些数字在允许你控制整数存储大小的语言中（例如 Go、C++、Rust 等）会有。如果我们把数字 42 序列化为 `fixed32` 类型，我们将得到以下结果：

```go
$ cat fixed.txt | protoc --encode=Fixed32Value
  wrappers.proto | hexdump -C
00000000  0d 2a 00 00 00                          |.*...|
00000005
```

在这里，`2a` 是 `42`，而 `0d` 是字段标签和字段类型的组合（关于这一点将在本节后面详细介绍）。以同样的方式，如果我们以 `fixed64` 类型序列化 `42`，我们将得到以下结果：

```go
$ cat fixed.txt | protoc --encode=Fixed64Value
  wrappers.proto | hexdump -C
00000000  09 2a 00 00 00 00 00 00  00         |.*.......|
00000009
```

唯一改变的是字段类型和字段标签的组合（`09`）。这主要是因为我们将类型更改为 64 位数字。

两种易于理解的标量类型是 `float` 和 `double`。再次强调，Protobuf 会生成这些类型的二进制表示。如果我们把 `42.42` 编码为 `float`，将会得到以下输出：

```go
$ cat floating_point.txt | protoc --encode=FloatValue
  wrappers.proto | hexdump -C
00000000  0d 14 ae 29 42                          |...)B|
00000005
```

在这种情况下，解码稍微复杂一些，但这仅仅是因为浮点数以不同的方式编码。如果你对这种数据存储感兴趣，可以查看 *IEEE 浮点算术标准* (*IEEE 754*)，它解释了浮点数在内存中的形成方式。这里需要注意的是，浮点数以 4 个字节编码，前面是我们的标签 + 类型。而对于值为 `42.42` 的 `double` 类型，我们将得到以下结果：

```go
$ cat floating_point.txt | protoc --encode=DoubleValue
  wrappers.proto | hexdump -C
00000000  09 f6 28 5c 8f c2 35 45  40         |..(\..5E@|
00000009
```

这以 8 字节编码，并带有标签 + 类型。请注意，标签 + 类型在这里也发生了变化，因为我们现在处于 64 位数字的领域。

最后，我们剩下 `sfixed32` 和 `sfixed64`。我们之前没有提到它，但 `fixed32` 和 `fixed64` 是无符号数。这意味着我们无法在具有这些类型的字段中存储负数。`sfixed32` 和 `sfixed64` 解决了这个问题。因此，如果我们把 `-42` 编码为 `sfixed32` 类型，我们将得到以下结果：

```go
$ cat sfixed.txt | protoc --encode=SFixed32Value
  wrappers.proto | hexdump -C
00000000  0d d6 ff ff ff                          |.....|
00000005
```

这是通过取 42 的二进制表示，翻转所有位（1 的补码），然后加 1（2 的补码）得到的。否则，如果你序列化一个正数，你将得到与`fixed32`类型相同的二进制表示。然后，如果我们用类型为`sfixed64`的字段编码-42，我们将得到以下结果：

```go
$ cat sfixed.txt | protoc --encode=SFixed64Value
  wrappers.proto | hexdump -C
00000000  09 d6 ff ff ff ff ff ff  ff         |.........|
00000009
```

这类似于`sfixed32`类型，只是标签+类型发生了变化。

总结一下，固定整数是整数在大多数计算机内存中存储方式的简单二进制表示。正如其名所示，它们的序列化数据将始终序列化成相同数量的字节。对于某些用例，使用这种表示是可行的；然而，在大多数情况下，我们希望减少仅用于填充的比特数。在这些用例中，我们将使用称为 varints 的东西。

## Varints

现在我们已经看到了固定整数，让我们转向另一种数字序列化类型：可变长度整数。正如其名所示，在序列化整数时，我们不会得到固定数量的字节。

为了更精确，整数越小，它序列化成的字节数就越少，整数越大，它序列化成的字节数就越多。让我们看看算法是如何工作的。

在这个例子中，让我们序列化数字 300。首先，我们将取这个数字的二进制表示：

```go
100101100
```

使用这个二进制，我们现在可以将其分成 7 位一组，并在需要时用零填充：

```go
0000010
0101100
```

现在，由于我们缺少 2 个比特来创建 2 个字节，我们将为除了第一个组之外的所有组添加 1 作为**最高有效位**（**MSB**），并且我们将为第一个组添加 0 作为 MSB：

```go
00000010
10101100
```

这些 MSB 是连续位。这意味着，当我们有 1 时，我们后面还有 7 个比特要读取，如果我们有 0，这就是要读取的最后一个组。最后，我们将这个数字放入小端序，我们得到以下：

```go
10101100 00000010
```

或者，我们会在十六进制中表示为`AC 02`。现在我们已经将 300 序列化为`AC 02`，并且考虑到反序列化是序列化的相反过程，我们可以反序列化这些数据。我们取`AC 02`的二进制表示，丢弃连续位（MSB），并反转字节的顺序。最后，我们得到以下二进制：

```go
100101100
```

这与我们的起始二进制相同。它等于 300。

现在，在现实世界中，你可能会遇到更大的数字。关于正数的快速参考，以下是一个列表，列出了字节数量增加的阈值：

| **阈值值** | **字节大小** |
| --- | --- |
| 0 | 0 |
| 1 | 1 |
| 128 | 2 |
| 16,384 | 3 |
| 2,097,152 | 4 |
| 268,435,456 | 5 |
| 34,359,738,368 | 6 |
| 4,398,046,511,104 | 7 |
| 562,949,953,421,312 | 8 |
| 72,057,594,037,927,936 | 9 |
| 9,223,372,036,854,775,807 | 9 |

一个敏锐的读者可能会注意到，使用 varint 通常是有益的，但在某些情况下，我们可能将值编码成比所需更多的字节。例如，如果我们把 720,575,904,037,927,936 编码成`int64`类型，它将被序列化为 9 字节，而使用`fixed64`类型，它将被编码为 8 字节。此外，我们刚才看到的编码问题之一是负数将被编码成一个大的正数，因此将被编码成 9 字节。这引出了以下问题：*我们如何有效地在不同的整数类型之间进行选择？*

### 如何选择？

答案是，一如既往，这取决于具体情况。然而，我们可以系统地做出选择，以避免许多错误。我们主要需要根据我们想要序列化的数据做出以下三个选择：

+   需要的数字范围

+   负数的需要

+   数据分布

#### 范围

到现在为止，你可能已经注意到我们类型上的 32 和 64 后缀并不总是关于我们的数据将被序列化成多少位。对于 varints，这更多的是关于可以序列化的数字范围。这些范围取决于用于序列化的算法。

对于固定、有符号和可变长度的整数，数字的范围与开发者在 32 位和 64 位上所习惯的范围相同。这意味着我们得到以下：

```go
[-2^(NUMBER_OF_BITS – 1), 2^(NUMBER_OF_BITS – 1) – 1]
```

在这里，`NUMBER_OF_BITS`取决于你想要使用的类型，是 32 还是 64。

对于无符号数字（`uint`）——这又像是开发者所期望的那样——我们将得到以下范围：

```go
[0, 2 * 2^(NUMBER_OF_BITS – 1) - 1]
```

#### 负数的需要

在你根本不需要负数的情况下（例如，对于 ID），理想的使用类型是无符号整数（`uint32`，`uint64`）。这将防止你编码负数，与有符号整数相比，它在正数上有两倍的取值范围，并且将使用 varint 算法进行序列化。

你可能还会遇到另一种类型，即用于有符号整数的类型（`sint32`，`sint64`）。我们不会深入讲解如何序列化它们，但算法会将任何负数转换成正数（ZigZag 编码），然后使用 varint 算法序列化正数。这对于序列化负数来说更有效率，因为我们可以利用 varint 编码，而不是将负数序列化为一个大的正数（9 字节），现在我们使用 varint 编码。然而，对于序列化正数来说，这就不太有效率了，因为现在我们混合了之前是负数的数字和正数。这意味着对于相同的正数，我们可能会有不同数量的编码字节。

#### 数据分布

最后，值得一提的一点是，编码效率高度依赖于你的数据分布。你可能根据某些假设选择了某些类型，但你的实际数据可能不同。两个常见的例子是选择`int32`或`int64`类型，因为我们预计很少会有负值，以及选择`int64`类型，因为我们预计很少会有非常大的数字。在这两种情况下，都可能导致显著的低效，因为在这两种情况下，我们可能会将很多值序列化为 9 个字节。

不幸的是，没有一种方法可以决定一个始终完美匹配数据的类型。在这种情况下，最好的办法是在代表你整个数据集的真实数据上做实验。这将给你一个关于你做对了什么和做错了什么的想法。

## 长度限定类型

现在我们已经看到了数字的所有类型，我们剩下的是长度限定类型。这些类型，如字符串和字节，我们在编译时无法知道它们的长度。将这些视为动态数组。

要序列化这种动态结构，我们只需在随后的原始数据前加上该数据的长度。这意味着如果我们有一个长度为 10 的字符串，内容为“0123456789”，我们将有以下字节序列：

```go
$ cat length-delimited.txt | protoc --encode=StringValue
  wrappers.proto | hexdump -C
00000000  0a 0a 30 31 32 33 34 35  36 37 38
  39              |..0123456789|
0000000c
```

在这里，第一个`0a`实例是字段标签+类型，第二个`0a`实例是 10 的十六进制表示，然后是我们每个字符的 ASCII 值。要了解为什么 0 变成 30，你可以在你的终端中输入`man ascii`并查找十六进制集，以查看 ASCII 手册。你应该会有以下类似的输出：

```go
30  0    31  1    32  2    33  3    34  4
35  5    36  6    37  7    38  8    39  9
```

在这里，每一对中的第一个数字是第二个数字的十六进制值。

另一种将被序列化为长度限定类型的消息字段是重复字段。重复字段相当于列表。要写入这样的字段，我们只需在字段类型前加上`repeated`关键字。如果我们想序列化 ID 列表，我们可以写出以下内容：

```go
repeated uint64 ids = 1;
```

有了这个，我们可以存储 0 个或多个 ID。

同样，这些字段将以长度作为前缀进行序列化。如果我们取`ids`字段并将数字从 1 到 9 进行序列化，我们将有以下序列：

```go
$ cat repeated.txt | protoc --encode=RepeatedUInt64Values
  wrappers.proto | hexdump -C
00000000  0a 09 01 02 03 04 05 06  07 08 09 |...........|
0000000b
```

这是一个包含 9 个元素的列表，后面跟着 1，2，……等等。

重要提示

重复字段仅在存储标量类型（除了字符串和字节）时作为长度限定类型进行序列化。这些重复字段被认为是打包的。对于复杂类型或用户定义的类型（消息），值将以不太优化的方式进行编码。每个值都将单独编码，并以前面加上类型+标签字节（而不是只序列化一次类型+标签）。

## 字段标签和线类型

到目前为止，你多次读取了“标签+类型”，但我们并没有真正看到这意味着什么。正如之前提到的，每个序列化字段的第一个字节（或字节）将是一个字段类型和字段标签的组合。让我们先看看字段标签是什么。你肯定注意到了字段语法的不同之处。每次我们定义一个字段时，我们都会添加一个等号，然后是一个递增的数字。以下是一个例子：

```go
uint64 id = 1;
```

虽然它们看起来像是将值分配给字段，但它们只是在这里为字段提供一个唯一的标识符。这些标识符，称为标签，可能看起来微不足道，但它们是序列化最重要的信息。它们用于告诉 Protobuf 将哪些数据反序列化到哪个字段。正如我们在不同序列化算法的展示中看到的，字段名称不会被序列化——只有类型和标签会被序列化。因此，当反序列化开始时，它会看到一个数字，并知道将后续的数据重定向到何处。

现在我们知道这些标签只是标识符，让我们看看这些值是如何编码的。标签简单地作为 varint 序列化，但它们与线缆类型一起序列化。线缆类型是分配给 Protobuf 中一组类型的数字。以下是线缆类型的列表：

| **类型** | **含义** | **用于** |
| --- | --- | --- |
| 0 | Varint | `int32`、`int64`、`uint32`、`uint64`、`sint32`、`sint64`、`bool`、`enum` |
| 1 | 64 位 | `fixed64`、`sfixed64`、`double` |
| 2 | 长度限定 | 字符串、字节、打包重复字段 |
| 5 | 32 位 | `fixed32`、`sfixed32`、`float` |

这里，0 是 varint 的类型，1 是 64 位，以此类推。

为了将标签和线缆类型组合起来，Protobuf 使用了一个称为位打包的概念。这是一种旨在减少数据序列化所需位数的技巧。在我们的例子中，数据是字段元数据（著名的标签+类型）。所以，这是它的工作方式。序列化元数据的最后 3 位是保留给线缆类型的，其余的是标签。如果我们拿我们在“固定大小数字”部分提到的第一个例子，在那里我们使用标签 1 将 42 序列化到`fixed32`字段中，我们得到以下内容：

```go
0d 2a 00 00 00
```

这次我们只对`0d`部分感兴趣。这是字段的元数据。为了看到它是如何序列化的，让我们将`0d`转换为二进制（使用 0 填充）：

```go
00001101
```

在这里，我们为线缆类型有 101（5）——这是 32 位线缆类型——并且为标签 1 有 00001（1）。现在，由于标签被序列化为 varint，这意味着该元数据的字节可能超过 1 个。以下是一个参考，了解字节数量增加的阈值：

| **字段标签** | **大小（**位**）** |
| --- | --- |
| 1 | 5 |
| 16 | 13 |
| 2,048 | 21 |
| 262,144 | 29 |
| 33,554,432 | 37 |
| 536,870,911 | 37 |

这意味着，由于没有设置值的字段将不会被序列化，我们需要保留最低的标签给那些最常填充的字段。这将降低存储元数据所需的开销。一般来说，15 个标签就足够了，但如果您遇到需要更多标签的情况，您可能需要考虑将一组数据移动到一个具有更低标签的新消息中。

# 常见类型

到目前为止，如果您检查了配套代码，您会看到我们定义了很多“无聊”的类型，它们只是围绕一个字段进行包装。需要注意的是，我们是手动编写的，只是为了简单地给出如何检查某些数据序列化的示例。大多数时候，您将能够使用已经定义的、做同样事情的类型。

## 已知类型

Protobuf 本身自带了一组已经定义的类型。我们称它们为 *已知类型*。虽然其中许多类型在 Protobuf 库本身或高级用例之外很少有用，但其中一些类型很重要，我们将在本书中使用一些这些类型。

我们可以很容易理解的类型是包装器。我们之前手动编写了一些。它们通常以它们所包装的类型名称开头，并以 `Value` 结尾。以下是一个包装器的列表：

+   `BoolValue`

+   `BytesValue`

+   `DoubleValue`

+   `EnumValue`

+   `FloatValue`

+   `Int32Value`

+   `Int64Value`

+   `StringValue`

+   `UInt32Value`

+   `UInt64Value`

这些类型可能对调试用例很有趣，比如我们之前看到的那些，或者只是序列化简单的数据，比如数字、字符串等。

然后，还有一些表示时间的类型，如 `Duration` 和 `Timestamp`。这两个类型是以完全相同的方式定义的（[Duration | Timestamp] 不是一个正确的 Protobuf 语法，它的意思是我们可以用其中的任何一个术语来替换）：

```go
message [Duration | Timestamp] {
  // Represents seconds of UTC time since Unix epoch
  // 1970-01-01T00:00:00Z. Must be from 0001-01-
    01T00:00:00Z to
  // 9999-12-31T23:59:59Z inclusive.
  int64 seconds = 1;
  // Non-negative fractions of a second at nanosecond
  // resolution. Negative
  // second values with fractions must still have non-
  // negative nanos values
  // that count forward in time. Must be from 0 to
  // 999,999,999
  // inclusive.
  int32 nanos = 2;
}
```

然而，正如它们的名称所暗示的，它们代表不同的概念。`Duration` 类型是开始时间和结束时间之间的差异，而 `Timestamp` 类型是一个简单的时间点。

最后，还有一个非常重要的已知类型是 `FieldMask`。这是一个表示在序列化另一个类型时应包含的字段集合的类型。为了理解这个类型，可能给出一个例子会更好。假设我们有一个 API 端点返回一个包含 `id`、`username` 和 `email` 的账户。如果您只想获取账户的电子邮件地址以准备一个您想要发送促销电子邮件的人的名单，您可以使用 `FieldMask` 类型告诉 Protobuf 只序列化 `email` 字段。这让我们减少了序列化和反序列化的额外成本，因为我们现在只处理一个字段而不是三个。

## Google 常见类型

在已知的类型之上，还有一些是由 Google 定义的类型。这些类型定义在 `googleapis/api-common-protos` GitHub 仓库下的 `google/type` 目录中，并且可以在 Golang 代码中轻松使用。我鼓励您检查所有类型，但我想要提及一些有趣的类型：

+   `LatLng`: 存储为双精度浮点数的纬度/经度对

+   `Money`: 带有按 ISO 4217 定义的货币的金额

+   `Date`: 年、月和日以 `int32` 存储的日期

再次提醒，前往仓库检查所有其他内容。这些类型已经过实战检验，并且在很多情况下比我们编写的简单类型更优化。然而，请注意，这些类型可能也不适合您的用例。没有一种适合所有情况的解决方案。

# 服务

最后，我们需要关注并将在本书中使用的最后一个结构是服务。在 Protobuf 中，一个服务是一组 RPC 端点，包含两个主要部分。第一部分是 RPC 的输入，第二部分是输出。因此，如果我们想为我们的账户定义一个服务，我们可以有如下所示的内容：

```go
message GetAccountRequest {…}
message GetAccountResponse {…}
service AccountService {
  rpc GetAccount(GetAccountRequest) returns (GetAccountResponse);
  //...
}
```

在这里，我们定义了一个表示请求的消息，另一个表示响应的消息，我们使用这些作为 `getAccount` RPC 调用的输入和输出。在下一章中，我们将介绍更多关于服务的先进用法，但当前重要的是要理解 Protobuf 定义了服务，但不会为它们生成代码。只有 gRPC 会这样做。

Protobuf 的服务在这里是为了描述一个合同，并且是 RPC 框架的工作在客户端和服务器端履行这个合同。请注意，我写的是 *一个 RPC 框架*，而不是简单的 gRPC。任何 RPC 框架都可以读取 Protobuf 服务提供的信息并从中生成代码。在这里，Protobuf 的目标是独立于任何语言和框架。应用程序对序列化数据所做的事情对 Protobuf 来说并不重要。

最后，这些服务是 gRPC 的支柱。正如我们将在本书后面看到的那样，我们将使用它们来发起请求，并在服务器端实现它们以返回响应。在客户端使用定义的服务将让我们感觉就像直接在服务器上调用一个函数。如果我们以 `AccountService` 为例，我们可以通过以下代码调用 `GetAccount`：

```go
res := client.GetAccount(req)
```

在这里，`client` 是 gRPC 客户端的实例，`req` 是 `GetAccountRequest` 的实例，而 `res` 是 `GetAccountResponse` 的实例。在这种情况下，这有点像我们在调用服务器端实现的 `GetAccount`。然而，这是 gRPC 的作用。它将隐藏所有复杂的序列化和反序列化对象以及将它们发送到客户端和服务器的过程。

# 摘要

在本章中，我们看到了如何编写消息和服务，以及标量类型是如何序列化和反序列化的。这为我们准备了一本书的其余部分，我们将广泛使用这些知识。

在下一章中，我们将讨论 gRPC，为什么它使用 Protobuf 进行序列化和反序列化，以及它在幕后做了什么，我们还将将其与 REST 和 GraphQL API 进行比较。

# 问答

1.  数字 32 在`int32`标量类型中代表什么？

    1.  序列化数据将存储的位数

    1.  可以适合标量类型的数字范围

    1.  类型是否可以接受负数

1.  varint 编码在做什么？

    1.  以这种方式压缩数据，使得序列化数据所需的字节数更少

    1.  将每个负数转换为正数

1.  ZigZag 编码在做什么？

    1.  以这种方式压缩数据，使得序列化数据所需的字节数更少

    1.  将每个负数转换为正数

1.  在以下代码中，`= 1`语法是什么，它用来做什么？

    ```go
    uint64 ids = 1;
    ```

    1.  这是在将值 1 赋给一个字段

    1.  1 是一个标识符，其唯一目的是帮助开发者

    1.  1 是一个标识符，它帮助编译器知道将二进制数据反序列化到哪个字段。

1.  消息是什么？

    1.  包含字段并代表实体的对象

    1.  API 端点集合

    1.  可能状态列表

1.  枚举是什么？

    1.  包含字段并代表实体的对象

    1.  API 端点集合

    1.  可能状态列表

1.  服务是什么？

    1.  包含字段并代表实体的对象

    1.  API 端点集合

    1.  可能状态列表

# 答案

1.  B

1.  A

1.  B

1.  C

1.  A

1.  C

1.  B
