

# 专家见解

随着我们接近本书的结尾，我们想要做一些特别的事情。与其写一个更传统的总结章节，重复主要观点并试图展望未来，我们做了些不同的事情，希望对您来说更有趣。

我们联系了多位在网络安全自动化领域有实际操作经验的人，或者正在使用 Go 语言进行网络相关任务和活动的人，以便他们能与我们分享他们的观点。

我们希望他们的思考、经验教训、想法和观点能为你提供指导，并使你对网络行业自动化在角色和重要性方面的认识更加深刻，同时强调 Go 语言不是一种晦涩难懂、小众的语言，而是一种广泛用于各种网络相关用例的语言。

不再拖延，我们现在向您展示“专家见解”章节。

# David Barroso

*David 是一位在基础设施和软件工程交叉领域工作的资深工程师。他负责创建了许多开源项目，如 NAPALM、Nornir 和 Gornir。*

传统上，网络空间一直非常稳定。大多数创新都是通过标准机构实现的，这些机构需要数年才能获得批准。此外，厂商还推广了具有明确和结构化学习指南和课程的认证。这意味着网络工程师有明确的职业发展路径，可以成为认证专家，而无需过多担心被误导，甚至无需费心去想下一步是什么；其他人已经为他们决定了。

然而，现在是 2022 年，我们的日常词汇已经从 MPLS-over-GRE-over-IPSec 这样的缩写词转变为 IaC、CI、PR 和 DevSecOps 等。我们那种由厂商驱动、缓慢变化、舒适的生活已经一去不复返，现在我们需要跟上最新的行业术语和我们所选择的框架/库的最新更新中的重大变化（幸运的是，目前我们不需要跟上 JavaScript 框架）。但不要绝望——选择红色药丸，准备好选择自己的道路。

对于如何跟上这个不断变化且疯狂的世界，我的建议如下：除非是工作硬性要求，否则尽量减少对厂商驱动的认证的依赖。相反，阅读像你现在正在读的这样的书籍。熟悉其中的思想和概念，不必过于担心细节。与其设置不可能的实验室场景，不如与开源项目合作，从社区中学习，学习项目开发和维护所使用的工具，流程，框架，思想等等。最后，不要感到不知所措。人们会不断提出新的术语，库，项目等等，但如果你专注于思想，你会很快注意到事情并没有他们所说的那样震撼，行业的发展也没有广告中所说的那么快。

# Stuart Clark

*斯图尔特是社区 AWS 的高级开发者倡导者，Cisco Press 的作者，以及 Cisco 认证的 DevNet 专家 #20220005。*

公平地说，如果没有网络自动化，我现在不会处于这个位置。虽然我不是“自动化一切”这辆车的第一个乘客，但我完全承认我在 2014 年才加入这场游戏，或者至少我那时是这样感觉的。自从 2008 年开始从事网络工作以来，很多人都说他们可以自动化他们许多日常任务，但我的自负却说我仍然认为我的 CLI 更好。是什么阻止了我？主要是恐惧、失败和不知道从何开始。直到 2014 年的夏天，我才卷起袖子说：“我现在就要掌握它。”作为一个网络天才，我很容易做到这一点！不。这让我感到羞愧，我发现我不能像学习网络工程那样通过暴力学习编码。对我来说，需要一种更逻辑的方法。这最初只是每天早上大脑清醒时的一小时，那时我的客户网络问题和网络项目开始了。我经常发现我会被困在某个地方好几天。我可以完成实验室或复制示例，但理解概念我经常感到困难，所以我开始根据当天的任务制作小型项目。这通常是一个相同的脚本，但我每天都在添加和构建，添加更好的错误处理或验证。让有经验的人审阅你的工作并获得反馈也很好。过了一段时间，你的代码已经演变成整个团队现在都在使用的工具，这也启动了许多其他令人兴奋的新工作流程。这需要时间，但一年或两年后才会出现。

当有人问我关于职业、学习新事物或申请新角色的问题时，我总是问：*你希望在两年后和五年后处于什么位置？* 你的技能总是需要磨砺的，为此，你需要磨练你的技能并学习新事物。我们今天所准备的，不是今天，而是我们的未来，每一步都需要纪律和一致性。这就是你身上所有神奇之处所在。我不相信我们生来就拥有某种技能。当然，我们可能比其他人更快地学会某些东西。我相信我们可以成为我们想要成为的人，如果你有激情、有欲望并且愿意付出努力，你就能实现任何目标。

在你所做的一切中祝你好运。

# 克劳迪娅·德·卢纳

*克劳迪娅在斯坦福大学毕业后，最初在 NASA JPL 工作，从事软件开发，后来转向企业网络。2006 年，她离开了 JPL，在多个领域工作，包括生物技术和金融。2015 年，在为最大的 Cisco VAR 之一工作时，她开始自动化网络工作流程。如今，她在一家精品咨询公司，企业基础设施加速公司，帮助企业 500 强公司快速部署网络和安全计划。*

## 网络自动化真理...到目前为止...

### 1 – 自动化不会取代网络工程师

千万不要误会，网络工程这一学科是不会消失的。我们与设备的互动确实正处于革命之中，但关于 TCP 三次握手如何进行或路由协议如何工作这些知识，现在和将来都将是至关重要的。实际上，随着需要深入理解网络工作流程的脚本编写，这种知识的深度可能会增加。直到我编写了一个完整的数据中心 ACI 网络构建脚本，我才真正理解了思科的**应用中心基础设施**（**ACI**）。

### 2 – 文本和版本控制的力量

这一点并不经常被提及（或从未被提及），但文本是无所不能的。它是最低的共同分母，也是传达书面语言（编程或其他）的丰富排版输出的输入。在制作一本格式丰富的书籍或计算机脚本时，你可以简单地记录文本随时间的演变。这样，你可以确切地知道每一次变化的本质。这就是版本控制。最初是为了跟踪代码变化而开发的，如今，正如网络自动化一样，你可以将配置、配置模板、状态、图表、文档和几乎所有东西都置于版本控制之下。在你开始脚本编写之前，花点时间学习 Git 和 GitHub 等版本控制系统。

当我们谈论文本时，请使用真正的文本编辑器！只有在没有其他选择的情况下（并且学习`vi`——见第九部分“Linux 和正则表达式”），记事本和 TextEdit 才方便。花时间熟悉更高级的文本编辑器，如 Sublime 或 Atom。

### 3 – 立刻开始

面对新鲜和不熟悉的事物可能会感到害怕。只需开始行动。如果你是编程新手，可以搜索有关基本编程概念或编程基础的资源。如果你不熟悉变量、作用域、运算符、控制结构和命名空间等概念，这是一个重要的步骤。

一旦你掌握了这些概念，写下你想要解决的问题，选择一种语言，然后**立刻深入其中**。对我来说，是生成配置。实际上，对于我学习的每一种新编程语言，我都会解决第一个问题。我只是处理文本，而不是实际设备，所以我不太可能陷入麻烦。如果你在工作中遇到一个小问题，你愿意解决，就从那里开始。明确定义问题，详细说明期望的结果，然后开始。记下具体步骤，并逐一解决。

假设你想要为 10 台设备配置相同的 VLAN 生成配置命令，为了简单起见，将每个设备上需要运行的必要命令输出到屏幕上。你的第一个脚本可能就像以下这样，简单地列出设备并打印出以下配置：

```go
!Switch01 vlan 10
name Vlan10_on_Switch01
```

一旦你有了这些，你就会想要将输出保存到文本文件中。之后，你将想要为每个开关创建一个文件。之后，你将开始为每个开关进行定制。你明白了。每一次增强都会让你学到新的东西。每一个新特性都会扩展你的经验。

### 4 – 拥抱变化

更令人畏惧的是，你正在尝试学习新事物，但有很多东西要学！参见*3 – J**ust start*。从学习某事物然后放弃它以获得更好的事物中获得的经验是无价的。能够阐述你为什么喜欢一个解决方案而不是另一个，或者为什么你推荐特定的方法，将立即让你脱颖而出，并立即产生可信度。这使得你成为一个真正的工程师。

我认为尝试某事然后放弃它和尝试某事然后采纳它一样有价值。这个过程使你变得可信。它让你从那种说“你应该使用 X。为什么？嗯...因为...”的人转变为那种说“对于你试图做的事情，你应该使用 X，因为 X 具有这些特性或更容易在你的环境中得到支持或...”的人。培养阐述你为什么推荐某事物，以及为什么你不推荐某事物的能力。

那种经验，那种可信度，作为一个在男性主导的行业中的女性，对我大有裨益。我去面试或参加会议时，客户只和我的男性同事说话。那种可信度和基于事实的建议总是能赢得胜利。他们可能一开始只和我男性同事交谈，但最终他们会和我交谈。这始终是真理，而不仅仅是性别问题。

### 5 – 分享和打包

为自己编写代码很有诱惑力，但想想如果你赋予你的团队力量，你可以产生多大的影响。为此，当你编写脚本时，想想如果你不得不分享它们，你会如何编写它们。想想教一个没有任何编程或甚至 CLI 经验的同学执行你的一个脚本。这将让你思考如何打包你的脚本。有许多选择，包括如果你的受众是 Windows 用户，将你的脚本转换为 Windows 可执行文件，或者如果你的团队使用不同的操作系统，通过 GUI 或网页来前端你的脚本。

### 6 – 无限可能

在网络自动化中，很容易只关注基础设施的自动化。不要这样做！考虑一个环境，其中你的最终文档是由配置自动生成的。需要处理许多经常相似的变化控制票据？考虑一个环境，其中你的变化控制信息是由脚本生成的。关闭工作也是由脚本生成的。想要在你的文档中添加图表？考虑一个世界，其中你的图表是从新的拓扑自动生成的。需要与另一个团队接口并共享信息？如果他们只需要以一致格式共享所需信息，而不是让他们在邮件线程或令人沮丧的 Excel 电子表格中挣扎，他们会多么感激？

### 7 – 理解数据结构

你如何组合你的数据有着深远的影响。熟悉复杂的数据结构。这里所说的数据结构，是指列表、字典以及它们的任何组合。问问自己：如果我从字典列表中迭代或从键集合中选取数据，我的代码会更清晰吗？当这些数据结构高度嵌套时，要习惯提取所需的数据。关于这个话题的更多内容，请参阅我的文章《分解数据结构》（在“进一步阅读”部分）。

### 8 – 了解并使用 API

许多现代网络设备现在提供 API。这些 API 通常以结构化数据的形式返回查询结果（参见“7 – 理解数据结构”）。如果你不需要登录交换机、拉取配置或以半格式化文本显示命令，然后解析该文本，请不要这样做！使用 API。除了基础设施设备和网络设备提供的 API 之外，还有大量数据可用，通常带有开放和免费的 API。

需要查找 MAC 地址的供应商 OUI？有一个公开免费的 API 可以做到这一点。需要查找 IP 地址的物理位置？也有一个公开免费的 API 可以做到这一点。用 API 丰富你的数据、报告和信息。

### 9 – Linux 和正则表达式

我无法强调这一点的重要性。Unix 背景是无价的。许多基础设施设备最初都是以 Unix 或 Linux 为基础的。拥有这样的背景将使你与普通网络工程师区别开来。拥有一些 Linux 知识应包括对正则表达式的了解。因为网络自动化不可避免地需要一些解析，熟悉正则表达式将帮助你进行自己的解析，并帮助你与其它解析模块协同工作。更高级的文本编辑器理解正则表达式以方便你的搜索。

### 10 – 漫游和探索

最后，留出时间进行探索。我尽量每个月留出至少两个星期天早上，用来探索我听说、读到或看到的东西，或者我选择一个问题并研究解决方案。没有特定的目的地，我只是看看它将我带到哪里。一半的时间，我从一件事开始，最后基本上到了另一个星球。我打算参加一个关于 MongoDB 的 Udemy 课程，结果我试图创建一个尽可能好的正则表达式来匹配 IP 地址。*我对完成这件事并不执着*（至少在星期天是这样）。

# 亚历克斯·德·塔尔胡埃特

*亚历克斯·德·塔尔胡埃特是一位热衷于网络自动化领域的专家，他总是试图通过参与开源社区来降低网络复杂性；他主要参与了由 Linux 基金会主办的 OpenDaylight (ODL) 和 Open Network Automation Platform (ONAP)，在那里他担任技术指导委员会成员。*

我最初是以 Java 开发者的身份开始我的职业生涯的，对网络有着极大的热情。起初，感觉非常奇怪，在并不真正理解网络的情况下构建自动化网络的系统。但经过多年的努力，我学会了在足够精通网络的基础上，围绕它构建自动化平台。这种知识可以通过构建实验室、参加研讨会，或者对于幸运的人来说，在网络运营中心工作一段时间来获得。

最让我印象深刻，并且至今仍然如此的是，如果你来自软件开发背景而不是网络工程背景，网络自动化的路径可以有多么不同。两者都有自己的缩写、流程、标准等等，然而，随着云原生、基础设施即代码、网络即代码、GitOps 等的兴起，我们看到了这两个世界都在采用类似的概念、方法和工具来进行初始配置和操作自动化的整个生命周期。因此，从高层次来看，*如何进行自动化*变得相当普遍，而*要自动化什么*仍然相对特定于领域。当我们开始这样的旅程时，我们应该真正利用这个生态系统来加速我们的自动化策略。

在我看来，网络自动化的基础是对配置进行设置，应用一个（黄金）模板，该模板具有定义良好的（类型化）参数，以及应用该配置所使用的协议。对于服务保证而言，另一个非常重要的元素是遥测的概念，用于检索运行状态并获取状态变化和状态的更新。

穿上我的开发者帽子，最重要的是网络设备/网络功能暴露的 API/合同；这些通常由设备 YANG 模型表示。主要问题是，鉴于网络是非同质化的，每个供应商都有自己的模型，并或多或少地暴露其功能。尽管在标准化网络设备的配置和监控（OpenConfig、OpenROADM 和 IETF）方面投入了大量努力，但这肯定还没有得到全面采用，因此仍然需要大量的*一刀切*处理。

网络自动化策略必须考虑到这一点，并相应地设计其平台以接受任何类型的网络自动化技术。当然，该平台试图抽象这种非同质化环境的程度越高，维护工作就越多，因为将设备原生 API 转换为高级业务 API 的适配层必须跟上设备升级和设备型号变化的步伐。

这提出了以下设计决策：你是否应该努力为整个网络实现一个抽象层，并维护一个与设备南向通信的适配层？

如果是的话，你最好配备一个开发团队来构建和维护这个抽象。

如果不是，我建议通过让网络工程师为每个网络服务构建黄金模板，并有一个平台来加载、版本控制和与之交互来解决该问题。这种交互可能是一个 shell 脚本、一个 Python 片段、一个 Go 程序、一个 Ansible 剧本等等：只要该平台能够暴露一个能够执行它的 REST API，对特定团队来说什么都可以。这样，网络团队就可以通过暴露 API 来自动化，并停止担心平台。保持这些黄金模板和脚本的责任就落在了他们身上。

另一个重要方面是拥有一个编排引擎，它能够定义一个使用这些特定领域 API 的工作流程。随着成熟度和治理的加强，强制执行预检查和后检查任务应成为这些工作流程的必备项。同时，始终考虑如果后检查不成功，如何回滚。在网络范围内的交易中应用和回滚配置可能会很棘手；考虑构建辅助函数以增加可重用性。

这些编排引擎可以是分布式的，也可以是集中的，但通常会有一个端到端的服务编排来消费这些公开的特定领域工作流程。

最后，需要牢记的一个关键组件是网络元素/功能的清单。一旦工作流程执行了某些操作，就非常重要地保持清单更新，以便服务保证工作流程可以正确地针对网络的活动和可用状态采取行动。

考虑到目前大多数网络自动化都是通过 NETCONF 或 gNxI 南向协议完成的，YANG 已经成为定义和表达设备配置的事实上的模型标准，围绕 YANG 的工具已经足够成熟，可以依赖 XML/JSON 作为黄金模板。无论使用什么技术，渲染这些模板都是一件容易做到的事情，即使是在强制执行 YANG 定义的类型的情况下。考虑到所有这些，当开始网络自动化之旅时，我不会提倡特定的编程/脚本语言，而是让每个团队自己管理。但我肯定会提倡尽可能标准化南向协议和交互。随着旅程的成熟，当你感觉到作为一个组织，你对某种特定技术有了更好的掌握时，那么你可以构建更多的助手，并开始提出一些公司范围内的自动化实践。

随着网络自动化领域的演变，基础设施配置也在演变。随着 Kubernetes 的兴起，最新的趋势是将 Kubernetes API 扩展以提供**自定义资源定义**（**CRD**），抽象硬件和软件配置，并通过使用 Operator 支持它们的整个生命周期。Operator 将 CRD 公开为 K8S 原生 API，并包含管理 CRD 实例端到端生命周期的逻辑。这正在将操作责任转移到 Operator 提供商，并促进了以意图驱动的自动化。随着网络设备厂商采用这一概念，网络自动化将更加接近应用生命周期管理。随着这一趋势，被提出的主要编程语言之一是 Go。

值得一看的项目是 Nephio，这是 Linux 基金会的最新网络倡议，旨在通过 Kubernetes API 扩展提供网络控制器。

开心编码！

# 约翰·道克

*约翰·道克是微软的高级软件工程师经理，前谷歌网络系统工程师（SRE），前 LucasArts/Lucasfilm 网络工程师。*

在我询问 IT 总监我的下一步职业发展是什么之后，我在 LucasArts 开始了我的网络生涯。他立刻让我成为了一名网络工程师，并让我去买一本思科的书，配置我们刚刚获得的新的 T1 路由器。没有什么比在壁橱里盯着一个盒子，希望你放在头顶上的思科书通过渗透作用给你知识更令人印象深刻了。我在那里度过了接下来的几年，通过自动化我的工作（例如，重置网络 MAC 安全参数的门户，将端口移动到新的 VLAN，使用路由图自动平衡入站的 BGP 流量等等）。

我从那里转到谷歌，在那里我大部分时间都在自动化名为**后端骨干**（**B2**）的供应商骨干。我编写了第一个自动化的服务，该服务可以编程各种路由器。然后，我和一些非常有才华的软件工程师（Sridhar Srinivasan、Benjamin Helsley 和 Wencheng Lu）一起建立了网络的第一套工作流程编排系统，然后我又继续构建下一个版本（因为你永远不会第一次就做对）。第一版和第二版之间最大的变化是从 Python 迁移到 Go。我们能够减少错误，将工作流程数量增加 10 倍，并使代码重构成为可能而不破坏一切。接下来几年，我将所有 NetOps 从 Python 迁移到 Go，并构建了每天配置网络的自动化（BGP 网状部署、LSP 度量、SRLG 配置部署、边缘路由器启动、BGP-LU 更新、ISIS 度量、LSP 优化等）。使这一过程可扩展的关键是我编写的一个服务，它允许发送一个 RPC 来配置我们支持的任何供应商路由器（例如配置 BGP 对等体）。

现在，我在微软工作，我不再从事网络工作，而是编写 Go SDK 并管理一个软件团队，该团队部署软件以验证数据、提供门控控制、审计数据源等。这包括运行 Kubernetes 集群、部署软件和构建运行这些系统的工具。

最后，我是《Go for DevOps》一书的作者。

如果我能给网络自动化提一条建议：使用中心化的工作流程编排系统。中心化工作流程系统的益处，包括允许了解网络中正在发生的事情、允许紧急控制和提供策略执行，已经被一次又一次地证明。

那么，我所说的中心化工作流程执行是什么意思呢？你想要一个存在的 RPC 服务，并且该服务有一系列可以执行的操作。你的工具提交一个描述操作集的 RPC，并从服务器监控其运行。

这意味着所有执行都在同一个地方运行。然后你可以构建紧急工具来停止有问题的网络执行（或者简单地暂停它们）。你可以强制限制在一段时间内可以接触多少网络设备。你可以在自动化运行之前提供网络健康检查。

中心化是控制网络自动化关键。当你在小团队中时，很容易了解正在发生的事情。当你的团队人数远远超过五人时，这开始变得不可能。

我在谷歌见证的最大两次故障中，都是由于工程师在他们的桌面电脑上运行脚本，在他们的时区外工作时改变了网络。要回溯到谁/什么导致了问题，需要扫描 TACACS 日志以找到罪魁祸首。如果脚本一直在进行持续更改，没有人能够在找到安全部门的人禁用他们的凭证之前停止它。那宝贵的时间可能意味着你的整个网络都会中断。

如果你想看看一个可以用于网络操作的基本工作流程系统，请参阅我在*Go For DevOps*书中的*Designing for Chaos*章节。

数据包必须流动！

# Roman Dodin

*Roman 是一位戴着诺基亚产品管理帽的网络自动化工程师。除了他的专业关系外，他还是网络自动化领域的知名开源领导者、维护者和贡献者。你可能认识他作为 Containerlab 项目的当前维护者，你将在本书提供的实践练习中遇到这个项目。*

我假设你已经对 Go 有所了解，并想看看 Go 如何应用于网络自动化问题领域，或者你对为什么选择 Go 进行网络自动化感到好奇。让我分享一下我为什么曾经转向 Go，这次转变的主要驱动因素，以及为什么我认为现在是网络工程师开始关注 Go 的绝佳时机。

在深入研究 Go 之前，我使用 Python 进行所有网络自动化工作；这里没有太大的惊喜。在过去几十年里，*通常*的网络自动化工作流程围绕着编写/制作 CLI 命令模板，通过 SSH/Telnet 将它们发送到网络设备的 CLI 进程，解析回复并处理它们。当时，能拥有任何类型的供应商提供的 REST API 就已经很幸运了。因此，大多数自动化项目都使用了屏幕抓取库，并承受着以临时方式处理非结构化数据的痛苦。

同时，在 IT 领域，容器化、微分段和基础设施即代码（Infra-as-Code）范式的普及与 Go 语言的稳步发展相辅相成。该语言语法简洁，结合丰富的标准库、编译特性、一流的并发性和良好的性能，使得 Go 赢得了众多开发者的青睐。不久，我们见证了新生态系统的诞生——**云原生计算基金会**（**CNCF**），它提出了一套新的要求，关于应用程序的部署、运行和相互交互的方式。因此，社区重新审视了网络层，以适应在以 API 优先、云原生环境下的新应用程序运行方式。

随着时间的推移，在 IT 海洋中掀起的波浪也触及了网络岛屿。如今，任何不错的网络操作系统都在其上运行一套管理 API，为任何人提供结构化和模型化的数据。现代自动化工作流程假设仅以并发、高性能和云原生的方式利用这些 API。正如你所猜想的：能够编写利用大量云原生工具和库的并发、高性能、易于部署的应用程序，这正是 Go 为网络自动化工程师提供的现成解决方案。

即使在网络领域我们拥有如此大的惯性，以网络为中心的项目生态系统也在快速发展。正如您自己会看到的，通过这本书的章节，已经为 Go 语言创建了典型的网络相关库。

网络自动化/管理领域的另一个关键参与者是 OpenConfig 联盟。由谷歌牵头，网络运营商参与，OpenConfig 构想了许多围绕 Go 语言的网络自动化项目，包括`goyang`、`ygot`、`kne`、`ondatra`和`featureprofiles`。那些想要了解这些项目能提供什么的人将不得不掌握 Go 语言。正如经常发生的那样，我们未来可能视为商品的工具和库正在由超大规模公司今天塑造。

总结来说，如果你的网络自动化活动具有以下任何特性，你可能需要考虑 Go 作为这项工作的工具：

+   需要在规模上保持高性能。

+   具有强大的并发执行用例。

+   使用基于 YANG 模型生成的数据类。

+   利用 Kubernetes 控制平面。

+   与 CNCF 工具和项目集成。

+   利用 OpenConfig 项目。

与他人一样，Go 不是终极答案或 Python/Java 等的替代品。然而，它是一种具有强大优势、庞大社区和繁荣生态系统的编程语言。在我看来，它在网络自动化领域有着光明的未来，这本书应该是对那些想要了解今天使用 Go 进行网络自动化实际方面的一个极好的辅助。

# 大卫·吉

*大卫·吉是 Juniper Networks 的产品管理总监。他在 dave.dev（之前是 ipengineer.net）上写博客。他是 JUNOS Terraform Automation Framework（JTAF）的创造者，以及其他事物。Twitter: @davedotdev*

如果你已经在网络领域建立了知识，那么你很可能已经购买了并吸收了来自*Cisco Press*书籍的知识。这些书籍大部分结构良好，提供像花朵一样展开的知识。对于那些想要建立自动化知识的人来说，难以找到多厂商友好的知识来源。该行业本身相对不成熟，网络工程师在网络安全域垂直发展软件技能时往往会做出非常可疑的决定。这不是网络自动化工程师的过错，而是由于行业存在的缺乏纪律。在普通的网络中，如果你配置 BGP 不当，会话可能无法建立。如果你不小心泄露了前缀，那么有人会很快纠正你的知识。下次你配置 BGP 时，你可能不会再犯同样的错误！

网络领域的软件纪律非常必要，许多组织仍处于网络自动化的初级阶段。在这个阶段的不良经历通常会对信心水平造成灾难性的影响，要么证实这太难了，要么为一次伟大的起飞铺平道路。仍然有很多人在参加训练营，多亏了 Udemy、Pluralsight 以及其他众多学习平台，今天进入软件领域比以往任何时候都要容易。这是一个有争议的话题，我在这里要小心谨慎，但软件并不是只是不断地向某个东西扔代码直到它在边缘上工作。它是一门学科，一种心态，需要严谨。

## 我走向十年 Go 之旅

Go 是一种伟大的语言，对许多人来说，它不仅是主要的编程语言，也是工具语言。Go 提供了一种“双重保险的方法”，即使编译器也会提醒你做正确的事情。当然，你可以写出杂乱的代码，但整个 Go 生态系统都是为了帮助你避免这样做而设计的。市场上的大多数 IDE 都拥有出色的 Go 工具，并将进一步检查和格式化你的代码，帮助你成为一个更好的开发者。Grafana Labs 的 Mat Ryer 和“Go Time”播客曾经说过：“*由于 Go 工具，我可以阅读其他人的代码，感觉就像是我自己写的。*”这要归功于 Go 社区将最佳实践融入工具链的方式。你可以免费获得这些。

为了娱乐，同时也是为了说明一个观点，我想分享我过去职业生涯中的一个时刻。当时我使用 C 语言（C99）编写代码，在 Microsoft Windows Notepad 中编写，将其链接，并使用单独的工具编译成二进制文件，然后需要将其烧录到嵌入式系统的 EPROM 上。我管理着数千行纯文本，当时写作时甚至没有一点线索能说明什么会起作用。测试设备有所帮助，但现实世界总是真理。有一天，我被叫到一个工业单位，我的一个系统导致一个水储备罐爆炸。在那一刻和压力之下，我设法找到了一个错误，因为我已经写下了算法，并在代码中留下了关键注释，这样我就能在压力下跟踪。优秀的工具和坚实的编码工程方法可以让你免于被解雇，甚至更糟糕的是，被起诉。如果所有的代码都是意大利面式的（其中一些确实是——我不是英雄），我可能已经被监禁了。从那时起，我们手头上有优秀的 IDE，Go 吸取了 C 语言（在我看来）的精华，为你提供了一个在其他地方找不到的开发之旅。甚至在风险生产运行之前，编译器就能告诉我关于竞争条件、指针问题以及我等待了几十年的一系列问题。

除了 IDE、编译器和 Go 工具链之外，Go 还因为诸如错误处理和期望的重复等因素，使得编写清晰、可读和可维护的代码变得容易。避免使用魔法是一个关键原则，你应该能够导入一个包，并在自己的代码中确定性地初始化它，因为 Go 社区内部有纪律。

Go 提供了如此多的开箱即用功能，新手往往容易陷入 Go 的“醉酒”状态。看到 goroutines 到处都是，以及在不必要的情况下使用 channels 是很常见的。Ardan Labs 的 Bill Kennedy 有一些关于这个主题的精彩材料，如果你认为你需要一个 goroutine，那么你很可能并不需要。在构建不需要的东西之前，使用 `pprof` 分析你的代码，并通过 Go 的测试能力进行一些基准测试是值得的。以最简单的形式，Go 可能会超越你的使用场景，而在早期就决定保持你的设计架构简单，将防止未来出现复杂的头痛问题。

## Go 的类型系统

Go 的类型系统在处理时可能比较严格，但它提供了你绝对需要的严谨性和结构。网络操作系统通常基于结构化数据，例如 NETCONF 引擎具有从 YANG 模型化的 API 模式。通过消费`.proto`文件，在构建客户端代码时免费获得程序性合同对齐。同样的原则也适用于 XML、gRPC 和 GPB。有许多工具可用于构建数据结构，一些 IDE 具有从 JSON 到结构体的转换能力。在可用时使用这些工具，但永远不要放弃熵和漂移的机会。仅就这一点而言，版本控制非常重要。最后，关于数据编码和模式的一则说明，XML 丰富且程序化强大。JSON 可能是一种时尚的东西，但 XML 对于为 Junos 等平台生成配置来说非常好用。如果你对 XML 感到舒适，那么与 NETCONF 一起工作就只是一小步之遥。在用 Go 构建类型时，编码 XML 与 JSON 一样简单。以下是一个例子：

```go
package main
import (
     "encoding/json"
     "encoding/xml"
     "fmt"
)
type DataEncodingExample struct {
     /*
           Example payload
           {
                "_key": "blah",
                "_value": "42",
                "_type": "string",
           },
     */
     Key   string `json:"_key",xml:"_key"`
     Value string `json:"_value",xml:"_value"`
     VType string `json:"_type",xml:"_type"`
}
func main() {
     dataInput := DataEncodingExample{
           Key:   "blah",
           Value: "42",
           VType: "string",
     }
     jsonEncoded, _ := json.Marshal(dataInput)
     xmlEncoded, _ := xml.Marshal(dataInput)
     // This is example code. What errors? :)
     fmt.Println("JSON Encoded: ", string(jsonEncoded))
     fmt.Println("XML Encoded: ", string(xmlEncoded))
}
```

输出如下：

```go
JSON Encoded:  {"_key":"blah","_value":"42","_type":"string"}
XML Encoded:  <DataEncodingExample><Key>blah</Key><Value>42</Value><VType>string</VType></DataEncodingExample>
```

## 关于版本控制的一则说明

接下来是版本控制，它不仅对你的代码很重要，而且对 Go 的包管理系统也很重要。核心 Go 团队已经尝试了超过 10 次包管理，但截至`1.13`版本，Go 模块系统似乎终于做对了。如果你对`go mod`及其用法不熟悉，那么投入时间是很值得的。能够以正确的包确定性地重新构建 Go 程序至关重要，了解如何使用语义版本控制和`go mod`系统来加强你的开发习惯是值得的。在 DevOps 和 SRE 领域有许多著名的故事，讲述了一个补丁版本出错，代码变得完全不可预测。虽然这些故事在聚会时讲述起来很棒，但在当时并不有趣，而且可以通过锁定代码以使用特定版本，并相信在 CI/CD 管道或构建系统中，代码将以与开发时相同的方式重新组合来避免这种情况。

## 代码的增长

在进入网络领域并学习汇编语言和 C 语言之前，我是一名电子工程师，对此我感到非常感激。我发现，通过在串行端口中输入命令，我能比构建一个带有串行端口的系统赚到更多的钱。向前滚动二十年（哎呀），我的许多旧习惯仍然存在。如果我开始编写一个新的工具或软件服务，我会先构建想法的核心，而不考虑实现。这个工具使得在探索的早期阶段，无需进行大量的繁琐代码更改，就能进行实验和学习。算法似乎是自己成长的，随着时间的推移，我会嵌入到论坛和博客上找到的有用 API 代码或注释，等等：

```go
package main
import (
     "context"
     "fmt"
     uuid2 "github.com/google/uuid"
     "github.com/sethvargo/go-envconfig"
     log "github.com/sirupsen/logrus"
)
const _VERSION = "0.0.1"
/*
This code logs into the auth service for X and then updates the remote status with the local status measurement.
It is triggered when the remote state is changed.
Each invocation generates a UUID which can be used by the ops team.
*/
type Config struct {
     APIUser string `env:"PROG1_API_USER_ID"`
     APIKey  string `env:"PROG1_API_USER_ID"`
}
// GetToken retrieves a JWT from the external auth service
func (c *Config) GetToken(URL, uuid string) (string, error) {
     // Initiate thing
     log.Info(fmt.Sprintf("system: updater, uuid: %v,
      message: logging into device with key %v\n", uuid,
      c.APIUser))
     // Imagine this is implemented!
     return "JWT 42.42.42", nil
}
func main() {
     // Set log level, normally this would be from config
     log.SetLevel(log.DebugLevel)
     // Get UUID for this instantiation
     uuid := uuid2.New().String()
     // Show the world what we are
     log.Info(fmt.Sprintf("system: updater, uuid: %v,
      version: %v, maintainer: davedotdev\n", uuid,
      _VERSION))
     ctx := context.Background()
     // Get the config from env vars
     var c Config
     if err := envconfig.Process(ctx, &c); err != nil {
           log.Fatal(err)
     }
     // GetToken will get a JWT from the thing upstream
     token, err := c.GetToken(
            "https://example.com/api/v1/auth", uuid)
     if err != nil {
           log.Fatal(err)
     }
      log.Debug(fmt.Sprintf(
      "TODO: Got token from external provider: %v\n",
      token))
     log.Debug("TODO: Got the local state")
      log.Debug(
      "TODO: Logged in to remote service with token and updated the state")
     log.Debug(
      "TODO: Update success: ID from remote update is: 42")
     log.Debug("TODO: Our work here is done.")
}
```

输出如下：

```go
go build
./main
INFO[0000] system: updater, uuid: 6cb60c9b-<snip>, version: 0.0.1, maintainer: davedotdev 
INFO[0000] system: updater, uuid: 6cb60c9b-<snip>, message: logging into device with key testuser 
DEBU[0000] TODO: Got token from external provider: JWT 42.42.42 
DEBU[0000] TODO: Got the local state                    
DEBU[0000] TODO: Logged in to remote service with token and updated the state 
DEBU[0000] TODO: Update success: ID from remote update is: 42 
DEBU[0000] TODO: Our work here is done. Exit Go routines cleanly if there are any.
```

前面的代码中有几个项目值得提及。第一个提及是关于外部包的使用。我倾向于在一个给定的项目中标准化日志库和配置处理方法。这使得代码易于使用，在本质上具有可预测性。此外，优秀的库是持续给予的礼物。Logrus 就是这样一个很好的例子。想要 JSON？没问题。想要更改日志目标？简单。日志不仅在开发中很重要，而且在发布工具或将软件服务投入生产时也非常重要。对于低使用工具来说，有一个 UUID 系统可能看起来很愚蠢，但如果是一个每天有多次调用的软件服务，当运维告诉你跟踪你的创造物的行为是多么令人愉快时，你可以给我一个合适的礼物。

## 注释

注释的价值是一个古老的争论主题。请善待未来的自己或任何需要维护你代码的可怜人。如果注释只是指出显而易见的事情，那么它们就是无价值的，所以我写了一些注释风格的微小变化。他们说你写的时候要*了解你的受众*，对于阅读代码来说，所需的专长是对 Go 的基本理解，因此你不需要指出一个字符串就是一个字符串。以下是一些你可以包含的要点：

+   **未来提示**：这是当存在一个已知瓶颈或问题可能在某个用户基础或请求速率下出现，但当时不值得解决的情况。

+   **待办事项**：在探索问题空间时，留下一些心理钩子以便你可以重新定位你的思想是没有错的。随着时间的推移，随着算法变得更加具体，它们应该会减少，所以当你通过待办事项列表工作时，应该删除它们并在更大的注释块中改进解释。

+   当事情变得复杂时，写出算法。这就像在阅读企业文档中的执行摘要。从技术备忘录的注释中理解代码试图做什么比阅读代码本身更容易，尤其是如果代码复杂且涉及递归等问题。总是值得留下一个日期，这样读者可以对照注释来核对版本。

## 被突然袭击

因为用 Go 编写代码会迫使你养成好习惯，它也可能让你措手不及。Go 非常强大，功能丰富，这些功能很快就被转化为看不见的防护栏。想象一下与用 Python 编写的 API 交互。想象一下，负载被编码到一个切片中，每个项目都是一个小的映射——像这样简单的东西：

```go
[
     { 
           "key": "blah", 
           "val": 42
     }
]
```

立刻，我们可以看到如何进行序列化和反序列化，但一个常见的陷阱，尤其是在强类型语言和动态类型语言之间进行接口时，是数据类型管理纪律不佳。以下示例将在尝试在 Go 中序列化它时触发错误，因为类型系统，但不幸的是，这种情况很常见：

```go
[
     {
           "key": "blah1",
           "key": 42
     },
     {
           "key": "blah2",
           "val": "42",
     },
]
```

一些软件工程师使用 TLV 风格的编码方式（见下文）来处理这些场景，但如果你遇到这个问题，可以使用 Go 的`反射`功能来检查数据，并在你的代码中以定制化的方式反序列化它。你可以使用前面的代码通过反射来实例化以下类型。这种方法已经多次救了我的命，并且在动态数据场景中特别有用，在这些场景中，像 Python 这样的语言使得操作变得非常容易。下划线用户通常是一个提示，表明这是一个 TLV 风格的数据实例，用于进程间通信：

```go
/*
     {
           "_key": "blah",
           "_value": "42",
           "_type": "string",
     },
*/
type BadDataManagement struct {
     Key   string `json:"_key"`
     Value string `json:"_value"`
     VType string `json:"_type"`
}
```

Go 是一种优秀的语言，我强烈建议你在使用标准化接口（如 NETCONF、REST 和 gRPC）的同时，努力避免使用银弹式的*网络 API*风格包和中间件。像避免魔法这样的简单规则将在未来带来回报，而且我记忆力像筛子一样，我总是努力记住这一点。

写这个部分是一种荣幸，我相信这本书为你铺平了道路，让你能够为这个行业急需的纪律、严谨和技能发展自己的领域。如果没有提供学习路径的闪电战努力，我们将发现网络自动化领域在未来几年将严重碎片化，而这本书将极大地帮助这一旅程。非常感谢作者们让我分享这些想法。

# 丹尼尔·赫茨伯格

*丹尼尔是 Arista Networks 的高级技术市场营销工程师。他在这个领域工作了十多年的时间，并且一直在这个网络和自动化/可编程性的门槛上。由于他在网络自动化、云原生技术和 OpenConfig 方面的成功，他每周多次在 Visual Studio Code 上编写 Go 语言。*

我开始自动化时并不是从网络设备开始的，而是从网络叠加和网络安全（使用 VMware NSX）开始的。NSX 提供了太多的选项可以点击，以至于很容易破坏系统。就像一个网络人员可能会犯错并误操作交换机一样，这让我很容易在同一个网络中输入相同的 OSPF 路由器 ID...哎呀！这是一个使用 XML 编码的 REST API，使用 Python 请求与之通信。当时，大多数人使用 PowerShell 来完成这项工作，所以在这个社区中，Python 的使用也远远超出了正常范围。

快进几年后——我们开始看到很多使用供应商 API 的场景。鉴于有大量的“入门”示例，只需导入`requests`库并执行典型的 RESTful 操作（即发送请求并获取响应），我发现 Python 几乎无处不在。我发现使用所有正常的 Python 对象（如字典、列表、元组等）进行操作非常简单。

在每一次旅程中，你都会遇到扩展性问题，如果 Python 能满足你的需求，那么它就没有问题。我开始更多地参与到云原生项目中，比如 Kubernetes 和 OpenConfig。所有这些最终都使用了 Go。我感觉学习曲线比 Python 陡峭一些，因为网络社区对它的兴趣没有像对 Python 那样浓厚。然而，它的好处超过了我所知道的 Python 的任何东西：

+   类型化系统

+   编译系统

+   并发

+   模块（`go mod`非常棒，可以打开它并查看整个项目中使用了什么）

+   无空格

+   垃圾回收

我可能还能再补充一些，但这些都是我喜欢 Go 的原因。有了这本书的早期访问权和看到示例，我可以预见几代网络工程师会很容易地采用这本书，并用 Go 替换 Python。

Go 总体上极大地帮助了我的职业生涯，因为客户越来越多地要求用 Go 编写通用网络项目代码，包括 Kubernetes 操作员、网络自动化和 OpenConfig 流。祝你好运，网络 Goer 们！

# 马库斯·海因斯（Marcus Hines）

*马库斯（Marcus）在其职业生涯中一直专注于网络设备测试、测试框架开发、测试自动化，以及通常询问为什么事情不能以不同的方式完成。他最初是一名网络工程师，现在他专注于其组织内的工程生产力。他帮助维护了 OpenConfig 组织的大部分仓库。*

## 简而言之

我已经成为了 Go 在几个关键方面的强烈支持者：

+   语言提供的工具的易用性

+   加入项目工程师的快速上手速度

+   编译速度和跨平台支持

+   强类型语言用于静态分析，具有出色的构建时验证

## 自动化的推理

+   **测试和自动化基本上是同一件事。**

测试和自动化可以简化为一系列有序的操作和验证，以将输入状态和意图转换为预期的输出状态。

+   **字节流不是一个 API。**

包含供应商特定细节的 SSH 和 shell 脚本不适合异构环境。

+   在 API 定义上的灵活性，它侧重于迭代版本和非破坏性更改。

Go 对 gRPC 有强大的第一类支持，这是一个丰富的序列化和 RPC 框架，支持大多数流行的编程语言。

+   自动化应该始终只有一层模板和一层配置。其他所有东西都应该是代码。

+   一个持续运行的自动化测试相当于 1,000 个手动测试。

+   自动化系统本身需要生命周期管理。

为系统开发的第一个测试应该是如何以密封、可重复的方式安装、版本控制和拆除系统本身。

一旦拥有了这个生态系统，你就可以解锁你的开发团队，让他们快速迭代开发，同时信任他们不会使基础设施退化。

## 背景

我来到今天这个位置，经历了一条非常漫长和曲折的道路。

我从 TCL/Expect 和 Perl 开始我的网络自动化*脚本*编写。这两个生态系统至少允许一致的重复操作；然而，其他一切都是混乱的。Python 通过围绕库和版本系统添加了一个健壮的生态系统，以允许一个更封闭和可重复的世界。

然而，Python 代码库存在一些问题，这使得维护变得困难。代码本身的测试相当直接。然而，由于缺乏类型，我们经常不得不在代码中写入大量的类型验证，并且只能在运行时找到这些错误。此外，由于过分关注使用模拟来提高覆盖率数字，而没有对公共契约进行充分测试，导致测试相当脆弱，从长远来看，这减缓了开发速度。我不怪 Python 本身，但如果没有适当的工具来强制执行良好的实践，很容易陷入这种模式。

我是在 2014 年左右的一个项目上接触到 Go 语言的，对其强类型、内置工具和编译速度印象深刻。在此之前，我一直在为一个项目开发 C++测试框架。我总是对构建*灵活*的 C++代码感到沮丧，它已经变成了一个模板的元编程噩梦，以支持我们所有的用例。Go 通过为我们提供用例的接口定义来解决这些问题的大部分。

从那时起，我为不同的组织编写了三个基于 Go 的测试框架，它们都有不同的系统需求。第一个框架在解决方案测试方面代表了一些独特的挑战。它需要能够开源。它需要控制由四个不同团队编写的组件，这些团队使用三种不同的语言在两个不同的构建生态系统中开发代码。测试本身必须在 Linux 和 Windows 测试运行器上运行。Go 使我们能够仅使用标准的 Go 工具来编译这个生态系统。

下一个框架用于基于 Kubernetes 的云解决方案测试。由于工具和库对基于 k8s 的项目支持，我们能够迅速取得进展。我们可以利用基础设施进行集群启动、k8s 部署、操作员部署以及应用程序生命周期。

我目前参与的项目框架是 Ondatra（参见*进一步阅读*部分）。这个框架专注于为网络解决方案提供开源的功能性、集成性和解决方案测试框架。它目前通过功能配置文件（参见*进一步阅读*部分）被我的组织内部团队使用，以向供应商描述我们的网络设备需求。

## 影响行业的能力

我还想提到的一点是个体改变行业的能力。

这个行业长期以来一直被供应商和认为 IETF 会解决你问题的观念所主导。当涉及到自动化时，供应商缺乏帮助的动力。每个可以创建的特定于供应商的旋钮和 API 都会让操作员进一步陷入供应商解决方案，这最终转化为他们的**采购订单**（**POs**）。

通过开始围绕软件自动化和 API 来塑造这个行业，我们正在将网络从一门艺术转变为计算机科学。我们正在走向网络设备不过是带有花哨网络接口卡的通用计算设备的地方。有了可以表达意图的通用 API，例如通过 gNMI 的 OpenConfig，操作员可以构建一个单一配置和遥测系统，它可以支持任意数量的供应商。有了围绕引导、安全、软件和文件管理的附加操作 API，操作员可以统一构建他们的基础设施。这变成了一层非常一致且可测试的层，然后可以用来在单元测试层单独测试北向服务和下游设备。构建一个强大的分层测试策略可以给你信心，并在你的开发周期中更快地发现故障。

不要等待他人解决你的需求；这不会发生。如果你想要某样东西，就向供应商提出要求。如果他们不做，就向标准机构提出要求。如果他们还不做，那就自己动手。不要假设你的想法是错误的，或者其他人比你更了解生态系统。进入开源世界，提出你的想法。软件开发和协作的模式在过去 20 年中发生了巨大变化，更不用说仅仅是过去 5 年了。网络自动化有许多机会开发出可以在操作员意图和网络设备状态之间进行最小转换的生态系统。

# Sneha Inguva

*Sneha 是 Fastly 公司网络控制和优化团队的软件工程师，同时也是 DigitalOcean 公司的前网络工程师。*

我编写网络代码的旅程始于 DigitalOcean 的内部 Kubernetes 和可观察性团队，DigitalOcean 是一家云托管提供商。在我接触任何一行网络代码或配置逻辑之前，我就了解到，在一家全球规模的公司背后，存在着由数百甚至数千个服务组成的分布式系统，这些服务由许多工程师团队提供。构建和部署可维护的服务需要适当的 CI/CD 设置、监控和可操作的警报。当我过渡到在各个网络团队用 Go 编写底层网络代码时，我的经历也反映了这一点。当你编写的代码旨在部署到世界各地数千个虚拟机或服务器上，并且该代码控制着基本的数据包进出网络时，自动化是关键。在 Fastly，一个全球有多个节点的 CDN 提供商，我的这一经验得以延续。

不论是自研的网络软件还是第三方开源软件，如 BIRD 路由守护进程，我都了解到我们绝对需要能够轻松地向前或向后回滚更改。我也是可操作警报和运行手册的强烈支持者；从经验来看，与特定操作没有直接关联的嘈杂警报永远不应该被页码化。我也开始欣赏 Go 在编写网络代码时所提供的功能；与 C 语言等语言相比，使用 Go 快速迭代代码和为各种平台交叉编译应用程序要容易得多。Go 还有一个有用的网络标准库和不断增长的包生态系统，它简化了从第 2 层和包套接字到第 7 层使用 HTTP 编写代码的过程。

总结来说，如果我要给一个刚刚进入网络和 Go 软件工程领域的初学者提建议，我会说以下内容：

+   在任何大型公司编写软件时，我的信条是保持其简单性。编写易于阅读、模块化、可扩展且文档良好的代码，这样即使一个对 Go 语言非常熟悉但对公司生态系统不熟悉的工程师也能轻松加入并做出贡献。我相信，优秀的文档和清晰、简单的代码总是优于巧妙的代码。

+   当涉及到 CI/CD 和基础设施即代码时，有众多选项可供选择，这通常取决于具体用例。软件是否将在主机上作为二进制文件运行？能否进行容器化？我们是否在构建 Debian 软件包？无论你使用什么，确保可以轻松部署和回滚服务的版本。

+   学习 Go 的特性和公司仓库的一些公认的最佳实践。

+   虽然我绝对欣赏 Go 网络生态系统中的第三方包（如`netaddr`、`gobgp`等），但我还是喜欢阅读代码并确认我对其功能的理解。这通常也允许我们找到错误和上游贡献。

+   确保您已为您的服务配置了白盒监控和可操作的警报。

并且，带着这些提示，我鼓励每个人都拥抱 Gopher 生活！

# 安东尼奥·奥耶亚

安东尼奥·奥耶亚（Antonio Ojea）是红帽（Red Hat）的软件工程师，在那里他从事 Kubernetes 和其他开源项目的工作，主要关注云计算、网络和容器技术。他目前是 Kubernetes 和 KIND 项目的维护者和贡献者，并且过去曾为其他项目如 OpenStack 和 MidoNet 做出贡献。

在我作为专业人士的早期岁月里，我开始在一家电信公司的网络部门工作。我们负责内部网络及其服务（DNS、电子邮件、WWW 等）。当时，我们的自动化基本上包括以下内容：

+   **配置**: 连接到网络设备以应用不同配置的 TCL/Expect 脚本

+   **监控**: 通过 SNMP 轮询网络设备并存储数据的 Perl 脚本，存储在 **轮询数据库**（**RRD**）文件中

+   `cron`

+   `cat`、`grep`、`cut`、`awk`、`sed`、`sort` 等命令，并将结果通过电子邮件发送

如果我们回顾过去，从后视镜来看，一切改善得多么令人难以置信，其演变多么有趣，尤其是在开源领域。

在 2000 年代初，开源软件正在积聚力量，Apache 许可证为 FOSS 和企业之间的互动开辟了新的途径，并且已经有几个稳定的 Linux 发行版提供了企业所需的支持、维护、安全和可靠性。

在 2000 年代，一些项目开始蓬勃发展，改进了现有的网络自动化。其中一些项目至今仍然存在：

+   **真正令人惊叹的新思科配置差异工具**（**RANCID**）：监控设备配置，并使用版本控制后端，如 CVS、Subversion 或 Git 来维护更改的历史记录。

+   **Nagios**: 它曾是监控和警报的行业标准。

+   **仙人掌**: 一个完整的网络绘图解决方案，旨在利用 RRDTool 的数据存储和绘图功能。

然而，直到 2000 年代末，开源才进入公众视野，关于免费软件许可证的规定更加明确，开源生态系统更加稳固和稳定。公司开始使用并贡献开源，被其增长和变革潜力以及与现有私有软件许可模式相比的经济效益所吸引。

在这个时期，由于企业和公司需要更加敏捷，基础设施变得更加灵活：虚拟机、容器、软件定义网络等等。所有这些变化都导致了行业的演变。这是云的开始，网络工程师开始能够通过 OpenFlow 等技术访问网络数据平面，或者通过 API 访问物理或虚拟设备配置。网络变得更加开放和可编程，为软件开发者创造了无限的机会。

我的职业生涯遵循着这一演变。我开始编写简单的脚本，并使用其他软件项目来帮助我自动化我的工作。然而，一旦你意识到你可以构建自己的工具，与他人合作添加你需要的功能，或者修复影响你的限制或错误，你就无法停止。这就是我成为 Kubernetes 贡献者和 SIG-Network 维护者的原因。没有秘密：学习、实践……重复。

现在，多亏了开源项目和协作工具的爆炸式增长，实践变得容易。每个项目都会欢迎愿意帮忙的人，或者你也可以创建自己的项目。总会有感兴趣的人。同样的事情也发生在学习上；有很多材料对每个人都是可访问的——视频、教程和博客——但我总是建议手头有一些关键书籍，不仅用于阅读，也用于咨询。好书永远不会过时。

记住，编程语言只是工具。没有一种语言可以统治所有。有些工具你可能会觉得更舒适，或者更适合某些工作或解决某些特定问题。Go 是容器生态系统的核心语言；像 Kubernetes、Docker 等主要项目都是使用 Go 构建的。如果你计划从事网络自动化和容器工作，Go 无疑是适合你的语言。

# 卡尔·蒙特纳里

*卡尔将自己定义为前网络人士。他是一位 Python 和 Go 开发者，也是 Scrapli(go) 的创造者，这是一个在本书中使用的 Go 包。*

当我最初开始参与网络自动化社区时，除了 Python 之外进行网络自动化的想法似乎有点疯狂。*当然*，有些人使用的是其他语言——也许他们有一些 Perl 或 Ruby，或者也许有些疯狂的人使用 C 或其他语言，但感觉 Python 通常是那个可以统治所有语言的“一统江山”。我倾向于 Python，就像许多人一样，我很快就爱上了它。Python 是一种非常棒的语言，对于像我这样没有任何编程或计算机科学背景的人来说，它为我提供了进入软件世界的惊人且相对温和的入门途径。

很长一段时间，我总觉得那些宣扬 Go 的网络自动化人士生活在幻想中！你还需要什么其他东西呢？当然，Python 的开发速度/便捷性超过了 Go 的一般速度。当然，Python 中庞大的网络自动化生态系统给了 Go 一个巨大的优势，Go 根本无法竞争！也许，我想，Go 网络自动化倡导者只有最新最酷的工具，可以 100%支持他们使用 RESTCONF 或 gRPC 所需的一切。他们可能只喝最好的手冲咖啡和啤酒，拥有令人羡慕的胡须和/或五彩斑斓、花哨的头发！

自然，这些想法都是愚蠢的，最终我开始留起一个花哨的胡须，学习 Go。开玩笑——我无法留胡须，至少不是一个令人羡慕的胡须，但我确实深入研究了 Go！

当然，我从未有过幻想 Python 真的是那个可以统治一切的“一环”，但学习一门语言已经足够困难，所以也许我只是保护我的理智，避免尝试学习另一门语言！我是否保持了理智还不清楚，但我确实觉得在过去的几年里我对 Go 学到了很多！对于像我一样正在旅途中并希望深入研究 Go 的人，以下是我会推荐的一些事情：

+   深入 Python 的打字生态系统。`mypy`非常棒——你将发现你从未意识到的错误。你将学到很多关于类型的信息，而且最好的部分是：如果你的类型全部出错，你的程序仍然可以运行！作为一个狂热的类型提示爱好者，我觉得这在我转向 Go 时帮了我很多。

+   抽出时间真正理解接口及其用法。起初，对我来说，它们只是有点笨拙的抽象基类，但当然，它们实际上远不止于此。当我们谈论接口时，确保你理解空接口以及如何使用和滥用它！

+   停止试图继承所有事物！这对我来说（是吗？！）一直很困难——我非常喜欢继承（也许太过分了，也许现在这已经是一种禁忌了？），所以有时摆脱这种模式是一种挑战。当然，这里和那里嵌入一个结构体，但通常尽量摆脱这种继承风格的心态。

+   让机器人（代码检查器）大声告诉你你的代码有多糟糕！我喜欢`golangci-lint`，这是一个运行大量代码检查器的代码检查器聚合器。获取大量错误，并通过搜索引擎工程师的方式理解错误存在的原因以及如何做得更好。虽然很烦人，但我从这种方式创建的所有错误中学到了很多！

我怀疑 Go 将继续在自动化社区中变得越来越普遍。这种语言的优点——速度、小体积、编译的二进制文件等等——很难忽视。此外，随着网络自动化生态系统的持续扩展和增长，我相信网络自动化角色将越来越以软件为中心，而不是以网络为中心，或者自动化/软件只是网络角色的附属品；随着这种情况的发生，Go 将因本书中阐述的所有原因而变得越来越重要！当然，就像 Python 不是“统治一切的那个戒指”一样，Go 也不会是，但两者都是你应该绝对拥有的工具……或者某些陈词滥调。祝 Gopher 们快乐！

# 布伦特·萨利文

*布伦特是一位拥有 20 多年网络和计算经验的资深软件工程师。他从网络运营和架构开始，逐渐过渡到网络软件开发。他对年轻工程师进入网络行业的前景仍然充满信心。*

我们见证了网络趋势的起伏，在互联网仍处于年轻的生命周期中，在几次创新周期繁荣与萧条期间，项目成功与失败。在这些重要的迭代过程中，一个将持久存在的范式转变是网络中 DevOps 实践的采用。DevOps 的核心组件是自动化。为了扩展网络自动化，重要的是要拥有既强大又不过于复杂，便于操作员使用的工具。作者们出色地阐述了为什么 Go 在过去的几年中，随着库的成熟，以及一些最大的开源项目是用 Go 编写的，已经成为基础设施编程的既定语言。

不论你是网络工程师还是经验丰富的开发者，人们常说一种特定的语言只是工具，我们不应该过分依赖某一种特定技术。虽然这个前提有一定的真实性，但在像 Go 这样的网络语言的具体情况下，我认为适合这项工作的正确工具至关重要。我们预计大量网络专业人士将转变为网络 DevOps 工程师。如果我们期待工程师技能集的重构，我们应该尽可能使这条路径变得容易。与同行语言相比，Go 的学习曲线、打包和基准性能都表现出色，使其成为新人和经验丰富的开发者进行编程和自动化的绝佳选择。

这里为那些刚开始网络编程和自动化旅程的人们提供一些建议：

+   拥抱开源。

+   学习 Linux 和 Linux 网络。

+   选择 Go 等语言开始编程。

+   熟悉开源自动化工具，如 Ansible 和 Jinja。

+   学习如何使用 Git 及其对配置管理可能产生的影响。

+   从一个只读项目开始，这样在你熟悉自动化和编码的同时，不会对网络造成损害。例如，网络监控/遥测或配置管理/备份是相对安全的起点。

+   通过编程方式提高对网络状态的理解。停止使用后视镜驾驶！

+   了解当前的开发者工具和部署机制（Kubernetes、容器、流行库等）。

+   探索如何为您的网络创建 CI/CD 管道。

开始将您的网络配置视为代码。自动化的故障越来越多地成为一些最近高调故障的根源。利用您的运营经验，创建测试和保障措施，以防止那些没有网络背景的人在进行自动化时可能不会意识到的常见错误。网络工程师不是濒危物种；理解网络的工作原理以及如何大规模构建网络需要多年的时间。通过结合新的学科，如编程，它使您在连接今天日益复杂的网络环境方面更具价值。

最后，您的目标应该是确保网络不会成为业务速度的阻碍。需要几周时间才能实施的网络更改必须成为过去式。当然，说起来容易做起来难，因为网络正常运行时间是，并将始终是，网络团队将被评判的第一项指标。如果我看任何项目、部署或产品，成功的是那些我们简化了复杂性并使其变得稍微简单一些的项目。随着网络专业人士的不断发展，功能强大且易于使用的工具，如 Go，结合自动化项目将是关键推动力。最后，不要害怕失败。找到你的优势，克服你的弱点。网络是一艘大船，很难驾驭，但我坚信我们在自动化方面正朝着正确的方向前进。

# 马克西米利安·威尔海姆

*马克西米利安（Max—Wilhelm）是一位整体（网络）自动化倡导者，试图将软件工程方法引入网络自动化，并帮助克服供应商锁定。*

*他早期就对网络、IPv6 和路由产生了兴趣，是一位热衷于开源的爱好者、共同创始人、维护者和贡献者，是开源和网络会议的常客，FrOSCon 网络轨道的创始人，以及 virtualNOG.net 会议的联合主持人。*

*他目前在 Cloudflare 担任网络自动化工程师，同时作为高级基础设施顾问兼职工作。他的第二职业是作为广泛自动化的 Freifunk Hochstift 社区网络的负责人，他在那里使用 ifupdown2 以及 ifupdown-ng、VXLAN、Linux VRFs、BGP 和 OSPF，以及使用 Salt Stack 进行基础设施自动化，并且自那时起就害怕商业 SDN 解决方案。*

## 一点历史

由于我来自 Linux 管理员/系统工程师的背景，自从 2004 年初在帕德伯恩大学数学研究所的 IT 中心的第一份工作以来，我就习惯了拥有自制的自动化解决方案来管理大量——当时对我来说是大量——的服务器和客户端。

我们有一个本地开发的软件套件，叫做 SDeployment——如果我记得正确的话，是用 Shell 编写的——它负责将正确的软件包和期望的配置文件状态部署到基于 Linux 的服务器和客户端，并强制执行期望状态保持不变。

这甚至帮助检测到一个入侵者，他成功交换了`sshd`二进制文件，该二进制文件不支持 Kerberos，因此他需要更改`sshd_config`，这个配置在 1 小时后被覆盖，服务再也没有启动。

当时，这比 CFEngine 等解决方案具有巨大的优势，这些解决方案可以对配置文件进行增量更改，但不能整体维护；Puppet 那时还没有出现（根据维基百科）。

随着 Bcfg2、Puppet、Chef、Salt 和 Ansible 的兴起，我们看到整个行业从增量配置更改转向基于意图的配置管理，其中操作员描述了期望状态（意图），并编写模板来生成整个配置文件的内容，而配置管理解决方案的任务就是使这一状态成为现实并保持这种状态。

## 思维转变至整体自动化

系统工程/SRE 领域很早就经历了这种思维方式的转变，但感觉大多数网络自动化解决方案仍然遵循着对现有路由器和交换机进行增量更改的想法，同时，这些设备也可能被操作员手动管理，他们通过在 CLI 中输入（或复制）魔法咒语来操作。

这使得设备配置成为同步点，我们实际上没有检查设备的情况下，真的不知道这个配置将是什么样子。

我认为我们作为网络（自动化）工程师，需要效仿，进行整体方法的思维转变，让 Perl、Shell 和 Expect 脚本保持原样，并将软件工程方法引入网络自动化。这样，我们才能在抽象层面上解决手头的问题，构建可以推理、自行测试并且能够扩展到我们需求的解决方案（参见*第五章*，*网络自动化*）。

对于配置管理的最大难题，这意味着将一些系统连接起来，构建一个生成并拥有完整设备配置的解决方案。

自动化可能需要依赖多个输入来获取拓扑结构、操作覆盖、订阅者和服务的全面知识，以及从所有这些中推导出配置的规则。

这是为了遵循总体目标，尽可能少地进行配置更改，并利用诸如 BGP 和 BMP 之类的协议在需要更多动态更改的地方提取/观察状态或操纵设备状态。

## 这是方法

拥有所有这些，你需要的唯一设备 API 是一个上传新完整配置的功能，并让设备确定从当前配置到新配置的路径。

处理整个舰队中的配置差异部分，仔细清理旧的配置 X 的方法，进行增量更改，并找出如何与平台 API、NETCONF 方言、YANG 等交互，这些都将成为过去——那不是很好吗？

我相信我们面前有一个光明的未来！

正是这本书和 Go 的伟大和鼓舞人心之处！

使用 Go，你有一个非常坚实的基础来构建可靠、可扩展、并且相对容易测试和观察的软件。Prometheus 集成触手可及。

这样，你可以构建工具来监控你的网络（例如通过 BMP 或流遥测），通过 BGP 注入路由，或者构建自己的整体网络配置生成器和部署管道，如前所述。

现有的开源套件，如 Bio-Routing，可以帮助你在第一部分（使用 BMP/RIS）中，并作为构建遵循您业务逻辑的路由注入器的基石。

你正在阅读这篇文章的事实表明，你正在考虑构建自己的自动化解决方案来解决你组织的需要——那太好了！

如果可以的话，请将其作为开源分享，并在您当地的 NOG 或 VirtualNOG 上进行展示，这样其他人也能从中受益和学习。祝你好运！

# 马特·奥斯沃特

*马特是 Cloudflare 的系统工程师，在那里他从事代理和控制平面系统的工作。他在 https://oswalt.dev 上写博客，偶尔在 Twitter 上以@Mierdin 的身份发帖。*

我很感激在我生命中大约同一时间接触到了软件开发以及像网络这样的基础设施技术。虽然我在高中时在我的 TI-82 计算器上玩弄了类似 BASIC 的语言（好吧，*玩弄*这个词有点夸张——我在几何学不及格的同时创建了一个基本的 Galaga 克隆），并且在上大学之前只学过一学期的 Visual Basic 编程，但直到大学我才第一次接触到 Linux、网络和现代编程环境。

在接下来的几年里，我在看似相当孤立的技术领域之间来回跳动。这样做往往让我觉得自己在每件事上都是新手，在每件事上都不是专家。我有过不少焦虑的时刻，担心我在职业生涯中做的事情不正确。然而，回顾起来，这可能是我能得到的最好的经验。它让我感到不舒服，在这种状态下，我磨练了我最珍视的技能，那就是学习能力。这种技能有滚雪球效应——有一个正式的学习体系让我有信心尝试新的、更具挑战性的事情，这通常迫使我在学习过程中更加严格和高效，等等。

这些天，有许多东西要学习，虽然可能很有诱惑力去学习所有这些，但我们无法做到。我仍在努力的是寻找那些真正影响我的职业和行业的技能。在我的经验中，那些具有持久力的技术和技能并不总是那些在社交媒体或 GitHub 上获得炒作或明星的——通常，这些是更基础的技术或思维方式，让你能更快地理解那些想法的最新表现形式。

如果你刚刚开始你的职业生涯，或者如果你觉得自己可能有点停滞不前，但不确定该往哪里去，希望以下建议对你有所帮助：

+   保持好奇心。学习的工作永远不会结束。不要过于专注于获得认证 *X* 或能在简历上添加技术 *Y*——这些都是短暂的。相反，为建立一个持续改进的学习体系感到自豪，并磨练你高效获取新技能的能力。

+   我们在生活中和职业生涯中往往紧紧抓住的东西，往往是令人痛苦的干扰。将关键的少数与琐碎的多数区分开来，专注于能让你做出最高贡献的事情。做好几件事情远比创造大量平庸的工作要好。

+   有许多更多的高技能工程师正在构建高效、可扩展的系统，但你永远不会听说他们；然后，还有人在社交媒体上发布关于技术 *X* 的内容，并得到 *所有点赞*。社交媒体上大多数关于技术的热门观点都不值得用来传输它们的比特数。

+   学习曲线最陡峭的技术技能往往（但并非总是）能带来最大的回报。务必非常小心，不要基于一项技术可能被采用/接近的程度做出限制你职业生涯的技术决策；通常，改变行业的创新在最初可能不会提供完美的用户体验，而对于那些不等待完美用户手册的人来说，机会要多得多。同时，也不要陷入认为越复杂或越难学，就一定越好的陷阱。就像生活中大多数事情一样，真相可能就在中间某个地方。

+   没有任何技术是万能的；它们都是基于特定的权衡来设计的，包括 Go。如果你还没有找到这些权衡，那么你可能还没有足够深入地研究。作为工程师，你的工作是理解这些权衡，并选择一个最适合你当前情况所希望做出的权衡的技术。

快乐学习！

# 进一步阅读

+   *分解数据* *结构*：https://gratuitous-arp.net/decomposing-complex-json-data-structures/

+   Ondatra：[`github.com/openconfig/ondatra`](https://github.com/openconfig/ondatra)

+   功能配置文件：[`github.com/openconfig/featureprofiles`](https://github.com/openconfig/featureprofiles)

+   FrOSCon 网络轨道：[`myfirst.network`](https://myfirst.network)
