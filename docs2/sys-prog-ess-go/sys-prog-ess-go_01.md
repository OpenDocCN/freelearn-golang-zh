

# 为什么选择 Go？

在你的编程旅程中某个时刻，你的程序执行了与 I/O 相关的任务，例如创建和删除文件和目录。它们可能已经编排了新进程的创建和其他程序的执行，甚至促进了在同一台计算机上运行的线程和进程之间以及通过网络连接的不同计算机上的进程之间的通信。

当我们的程序集中在使用一组低级任务时，我们将它们归类为系统编程。

据说系统编程是乏味的。但我根本不这么认为！事实上，它完全相反——是一种愉快和有趣的体验。它就像是一个魔术师。你可以控制操作系统和硬件，你可以让事情发生，这在其他语言中是不可能的。

在本章中，我们讨论为什么 Go 语言非常适合构建高效、高性能的系统软件以支持现实世界的场景。

在本章中，我们将涵盖以下主要主题：

+   选择 Go

+   并发和 goroutines

+   与操作系统交互

+   工具

+   使用 Go 进行跨平台开发

到本章结束时，你将了解 Go 在系统编程生态系统中的位置，Go 并发模型对于构建高效和高性能系统软件的重要性，Go 如何选择与操作系统交互，Go 的跨平台开发方法以及 Go 内置工具的主要命令。

# 选择 Go

现在系统编程空间中有许多语言：一些已经建立得很好，如 C 和 C++；一些是新来的浪潮，如 Zig、Rust 和 Odin；还有一些声称是“C/C++ 杀手”，承诺有令人印象深刻的性能。

当然，我们可以使用所有这些工具并取得出色的成果。然而，我们可能会陷入隐藏的陷阱，例如陡峭的学习曲线、高认知负荷、缺乏社区和支持、不一致的 API 以及频繁的破坏性更改，以及缺乏采用。

Go 的设计哲学强调简单性、表达性、健壮性和效率。其对并发的支持、强大的依赖管理以及对其组合的关注，使其成为系统编程的一个有吸引力的选择。其创造者旨在构建一个提供强大构建块而不需要不必要复杂性的语言，这使得编写、阅读、理解和维护系统级代码变得更加容易。有编程经验的人通常需要两周时间来熟悉 Go。虽然他们可能不被认为是专家，但他们可以自信地阅读标准的 Go 代码，并编写基本到中等复杂性的程序而不会感到困难。

此外，Go 对于系统编程来说非常出色，因为该语言具有 Unix 风格的设计，通过检查所有简化项。许多熟练掌握 Python 和 Ruby 的程序员通常会转向 Go，因为它允许他们保持表达性水平的同时，实现性能的提升和并发工作的能力。

值得注意的是，Go 的哲学并不优先考虑 CPU 使用上的零成本。相反，该语言旨在减少程序员所需付出的努力，这被认为更为重要，并且作为副产品，使得体验更加愉快。

使用 Go 进行系统编程的主要批评之一是垃圾回收器（**垃圾回收器**）（**GC**），特别是其暂停和显式内存限制。如果你对 Go 仍然有这种小烦恼，不用担心。在*第六章*中，我们将看到从 Go 1.20 及以上版本提供了更细粒度的内存管理。

注意

在垃圾回收暂停的最坏情况下，停止世界的时间通常小于 100 微秒。

# 并发和 goroutines

Go 最基本的功能之一是其并发模型。并发是同时运行多个任务的能力。在系统编程中，并行执行多个任务是提高程序性能和响应性的关键。

## 并发

实时系统需要精确性，其中并发是一个关键因素。这些系统以出色的时机协调任务，尤其是在即使是毫秒也重要的场景中。并发通过增加吞吐量（衡量系统在给定时间内可以处理多少信息单位）的同时减少任务完成时间，提供了显著的优势。现实生活中的实例显示了并发如何提高响应性，使系统更加灵活，任务更加高效。此外，并发的隔离能力通过防止干扰来保证数据完整性。

系统编程涉及各种任务，从 CPU 密集型到 I/O 密集型。并发通过允许 CPU 密集型任务进行的同时，I/O 密集型任务等待资源，来协调这种多样性。

在后面的*第十章*中，当我们讨论分布式系统时，并发的重要性将变得明显。它协调应用程序或甚至网络中不同节点的任务，这对于管理大规模并发是理想的。

## Goroutines

Go 的并发模型依赖于 goroutines 和 channels。Goroutines 是轻量级的执行线程，通常被称为绿色线程。创建它们是成本效益的。与传统的线程不同，它们表现出非凡的效率，使得成千上万的 goroutines 可以在仅几个操作系统线程上同时运行。

另一方面，通道为 goroutines 提供了一个无需求助于锁的通信和同步机制。这种方法受到了**通信顺序进程**（**CSP**）[`www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf`](https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf)形式主义的启发，强调并发组件之间的协调交互。

与许多依赖外部库或线程结构的并发编程语言不同，Go 将并发无缝地融入其核心语言设计。这个设计决策不仅使代码更容易理解，而且更不容易出错，因为线程的复杂性被抽象化了。

## CSP 启发的模型

Go 的并发模型从并发系统描述的正式语言 CSP（Communicating Sequential Processes）中汲取了灵感。CSP 专注于并发执行实体之间的通信和同步。与传统的多线程编程不同，CSP 和 Go 优先考虑通过通道进行通信，而不是共享内存，这减少了复杂性和潜在风险。同步和协调是必不可少的，CSP 使用通道进行进程同步，而 Go 使用类似的通道来协调 goroutines。安全和隔离是关键，因为这两种语言都确保通过通道进行安全交互，增强了可预测性和可靠性。Go 的通道直接实现了 CSP 基于通信的方法，为 goroutines 提供了一个安全的数据交换方式，避免了共享内存和锁的陷阱。

## 通过沟通来共享

著名的围棋谚语，“不要通过共享记忆来沟通，要通过沟通来共享记忆”常常是讨论和误解的来源。然而，将其理解为“通过沟通来共享，而不是通过锁定”会更加精确，主要是因为主流语言通常依赖于锁来保护共享数据，这可能导致死锁和竞态条件等潜在问题。Go 鼓励一种不同的范式：*通过发送和接收消息在通道中共享数据*。这种“通过沟通来共享”的哲学减少了显式锁的需求，并促进了一个更安全的并发环境。

如果你热衷于函数式编程，我有个好消息要告诉你。在 Go 中，数据不是在 goroutines 之间隐式共享的。换句话说，数据是被复制的。你注意到数据不可变性的问题了吗？这与那些共享内存是线程间通信默认模式的语言形成对比。Go 强调通过通道进行显式通信，有助于避免在传统线程模型中可能出现的意外数据共享和竞态条件。这种模型的另一个好处是，没有回调地狱，因为与并发代码的每次交互通常都是按程序方式读取的。一个常规的 Go 函数可以在程序代码中使用，而不需要将签名与额外的关键字绑定。

注意

回调地狱，也称为“死亡金字塔”，是编程中用来描述嵌套和相互依赖的回调函数使代码难以阅读、理解和维护的一个术语。这种情况通常发生在使用回调处理异步操作的异步编程环境中，如 JavaScript。

在下一章中，我们将刷新并发及其构建块的所有概念，以便为您与操作系统接口的交互做好准备。

除了其并发模型外，Go 还提供了一种与操作系统在低级别交互的方式。这对于系统编程至关重要，在系统编程中，您通常需要控制操作系统和硬件。

# 与操作系统交互

Go 对系统调用的方法旨在安全高效，尤其是在其并发模型背景下。

在 Go 中，与某些其他编程语言相比，系统调用相对较低级。如果您需要精细控制系统资源，这可能很有帮助，但也意味着您正在处理更多低级细节。

调用系统通常需要理解底层操作系统 API 和约定。副作用是，如果您是系统编程或低级开发的新手，它可能会引入一个更陡峭的学习曲线。

不熟悉系统调用？不用担心！本书的第二部分将详细探索和实验它们，以涵盖我们在系统编程之旅中需要进步的主要方面。

# 工具

Go 就像一个工具箱。它拥有我们构建优秀软件所需的一切，因此我们不需要比其标准工具更多的东西来创建我们的程序。

让我们探索便于构建、测试、运行、错误检查和代码格式化的主要工具。

## go build

使用 `go build` 命令将 Go 代码编译成可执行的二进制文件，您可以直接运行。

让我们看看一个例子。

假设您有一个名为 `main.go` 的 Go 源文件，其中包含以下代码：

```go
package main
import "fmt"
func main() {
    fmt.Println("Hello, Go!")
}
```

您可以使用 `go build` 命令来编译它：

```go
go build main.go
```

这将生成一个名为 `main` 的可执行二进制文件（在 Windows 上为 `main.exe`）。然后您可以运行该二进制文件以查看输出：

```go
./main
```

## go test

`go test` 命令用于在您的 Go 代码上运行测试。它自动找到测试文件并运行相关的测试函数。

这里有一个例子。

假设您有一个名为 `math.go` 的 Go 源文件，其中包含一个用于添加两个数字的函数：

```go
package math
func Add(a, b int) int {
    return a + b
}
```

您可以创建一个名为 `math_test.go` 的测试文件来为 `Add` 函数编写测试：

```go
package math
import "testing"
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    if result != 5 {
        t.Errorf("Expected 5, but got %d", result)
    }
}
```

使用 `go test` 命令运行测试：

```go
go test
```

## go run

`go run` 命令允许您直接运行 Go 代码，而无需显式将其编译成可执行文件。

让我们用一个例子来看看。

假设您有一个名为 `hello.go` 的 Go 源文件，其中包含以下代码：

```go
package main
import "fmt"
func main() {
    fmt.Println("Hello, Go!")
}
```

您可以使用 `go run` 命令直接运行代码：

```go
go run hello.go
```

这将执行代码并将 `Hello, Go!` 打印到控制台。

## go vet

我们使用 `go vet` 命令来检查我们的 Go 代码中可能存在的错误或可疑结构。它使用启发式方法，可能无法确保所有报告都是实际的问题，但它可以揭示编译器未捕获的错误。

这里有一个例子。

假设你有一个名为 `error.go` 的 Go 源文件，其中包含以下代码，并故意引入了错误：

```go
package main
import "fmt"
func main() {
    movie_year := 1999
    movie_title := "The Matrix"
    fmt.Printf("In %s, %s was released.\n", movie_year, movie_title)
}
```

你可以使用 `go vet` 命令来检查错误：

```go
go vet error.go
```

它可能会报告如下警告：`Printf 格式 %s 有 arg 1999 错误的类型 int`。

## go fmt

`go fmt` 命令用于根据 Go 编程风格指南格式化你的 Go 代码。它自动调整代码缩进、间距等。

让我们看看这个例子。

假设你有一个名为 `unformatted.go` 的 Go 源文件，其中包含格式不正确的代码：

```go
package main
import "fmt"
func main() {
        msg:="Hello"
        fmt.Println(msg) 
}
```

你可以使用 `go fmt` 命令格式化代码：

```go
go fmt unformatted.go
```

它将更新代码以匹配标准格式化约定：

```go
package main
import "fmt"
func main() {
        msg := "Hello"
        fmt.Println(msg)
}
```

现在我们已经很好地掌握了基本工具，我们可以开始熟悉 Go 的跨平台功能。

# 使用 Go 进行跨平台开发

使用 Go 进行跨平台开发非常简单。你可以轻松编写在多种操作系统和架构上运行的代码。

使用 `GOOS` 和 `GOARCH` 环境变量可以实现 Go 的跨平台开发。`GOOS` 环境变量指定了你想要的目标操作系统，而 `GOARCH` 环境变量指定了你的目标架构。

例如，假设你有一个名为 `main.go` 的 Go 源文件：

```go
package main
import "fmt"
func main() {
    fmt.Println("This program runs in any OS!")
}
```

要为 Linux 编译代码，你需要将 `GOOS` 环境变量设置为 `linux`，将 `GOARCH` 环境变量设置为 `amd64`：

```go
GOOS=linux GOARCH=amd64 go build
```

这个命令将为 Linux 编译代码。

你还可以使用 `GOOS` 和 `GOARCH` 环境变量在不同的平台上运行代码。例如，要运行你在 Linux 上编译的代码在 macOS 上，你需要将 `GOOS` 环境变量设置为 `darwin`，将 `GOARCH` 环境变量设置为 `amd64`。

```go
GOOS=darwin GOARCH=amd64 go run
```

这个命令将在 macOS 上运行代码。

注意

虽然 Go 努力实现跨各种平台的可移植性，但通过系统调用与操作系统交互本质上会将你的代码绑定到特定的操作系统功能。高度依赖这些操作的代码在针对不同平台时可能需要进行条件编译或调整。

利用 Go 中的构建标志允许你根据特定的条件（如目标操作系统或架构）有选择性地编译代码的特定部分。

这在创建与 `golang.org/x/sys` 包交互的程序时可能很有用，该包用于 Windows 和类 Unix 系统。

假设你有两个名为 `main_windows.go` 和 `main_linux.go` 的 Go 源文件，并且你想要使用构建标签来确保代码分段。

这里是一个使用构建标签对 Windows 进行分段的代码示例：

```go
// go:build windows
package main
import "fmt"
func main() {
    fmt.Println("This is Windows!")
}
```

我们可以这样做，但这次目标是 Linux：

```go
// go:build linux
package main
import "fmt"
func main() {
    fmt.Println("This is Linux!")
}
```

这些是编译这些程序的相应命令：

```go
GOOS=windows go build -o app.exe
GOOS=linux go build -o app
```

当我们在 Linux 环境中执行`app`时，它应该打印`This is Linux!`。同时，在 Windows 系统上运行`app.exe`将显示`This` `is Windows!`。

# 摘要

本章全面介绍了为什么 Go 是系统编程的首选，以及 Go 的设计哲学的见解，强调简洁、健壮和高效。我们学习了 Go 的并发模型，它与操作系统的交互方式，以及如何与跨平台开发的工具交互。这些课程对我们很有帮助，因为它们为我们提供了编写、阅读和维护使用 Go 编写的系统级代码所需的知识，从而提高了性能并使我们能够处理并发。

在下一章中，我们将探讨并发概念，刷新所有相关概念和构建块。这将为我们准备更高级的与操作系统接口的交互，增强我们创建强大和响应性程序的能力。
