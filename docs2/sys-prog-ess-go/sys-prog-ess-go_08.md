# 8

# 内存管理

在本章中，我们将深入 Go 的内存管理世界，重点关注支撑垃圾回收的机制和策略。在我们导航垃圾回收概念的同时，包括其在 Go 中的演变，以及堆栈和堆内存分配之间的区别，以及用于有效管理内存的高级技术，你将了解 Go 内存管理系统的内部工作原理。

在本章中，我们将涵盖以下主要内容：

+   垃圾回收

+   内存区域

到本章结束时，你应该能够优化你的代码以减少内存使用，最小化垃圾回收开销，并最终提高应用程序的可扩展性和响应性。

# 技术要求

本章中展示的所有代码都可以在我们的 GitHub 仓库的`ch8`目录中找到。

# 垃圾回收

在垃圾回收语言之前，我们需要自己处理内存管理。尽管这个学科需要集中的关注，但我们努力避免的主要问题是内存泄漏、悬垂指针和重复释放。

Go 中的垃圾回收器有一些任务来避免常见的错误和事故：它跟踪堆上的分配，释放不再需要的分配，并保持正在使用的分配。这些任务在学术界通常被称为内存推断，或“我应该释放哪些内存？”。处理内存推断的两种主要策略是跟踪和引用计数。

Go 使用跟踪垃圾回收器（简称 GC），这意味着 GC 将跟踪从“根”对象通过一系列引用可达的对象，将其余的视为“垃圾”，并回收它们。Go 的垃圾回收器经历了一段漫长的优化和学习过程。你可以在 Go 开发团队的这篇博客文章中找到通往今天这一先进状态的完整路径：[`go.dev/blog/ismmkeynote`](https://go.dev/blog/ismmkeynote)。

在这篇博客文章中，Go 团队报告了巨大的进步。例如，一个垃圾回收周期从 300 毫秒（Go 1.0）降至令人震惊的 0.5 毫秒的最新版本。

你至少在技术社区中听说过一次：“Go 中的垃圾回收是自动的，所以你可以忘记内存管理。”是的，我还有一些月球上的优质地产要卖给你。相信这一点就像认为你的房子会自己打扫，因为你有一个 Roomba。在 Go 中，理解垃圾回收不仅仅是一个好主意；它是你编写高效、高性能代码的入场券。所以，系好安全带，我们将深入一个“自动”并不意味着“神奇”的世界。

想象一下，一个软件开发团队从不审查代码，因为他们有一个代码检查器。这就像有些人对待 Go 的垃圾收集器一样。它就像把整个代码库的质量托付给一个检查额外空格的程序。当然，Go 中的垃圾收集器是一个整洁的小清洁工，不知疲倦地清理你的内存混乱。但误解其*操作模式*就像认为你的代码检查器会把你的意大利面代码重构成一个米其林星级的美味佳肴。

要为更高级的 GC 知识铺路，首先，我们需要了解两个内存区域：栈和堆。

## 栈和堆分配

Go 中的栈分配用于那些生命周期可预测且与创建它们的函数调用相关的变量。这些是你的局部变量、函数参数和返回值。由于栈的**后进先出**（**LIFO**）特性，栈非常高效。在这里分配和释放内存只是移动栈指针上下的事情。这种简单性使得栈分配快速，但并非没有限制。栈的大小相对较小，试图在栈上放置太多东西可能会导致可怕的栈溢出。

相比之下，堆分配用于那些生命周期不太可预测且与它们创建的位置没有严格关联的变量。这些通常是必须超出它们创建的函数作用域的变量。堆是一个更灵活、动态的空间，这里的变量可以全局访问。然而，这种灵活性是有代价的。由于需要更复杂的账目记录，堆上的内存分配较慢，并且管理这种内存的责任落在垃圾收集器上，这增加了开销。

Go 的编译器执行一个叫做“逃逸分析”的巧妙技巧（关于这个话题的更多内容请参考*第九章*，*分析性能*)，以决定一个变量应该存在于栈上还是堆上。如果编译器确定变量的生命周期不会超出其所在函数，那么它就会进入栈。但如果变量的引用在函数间传递或从函数返回，那么它就会“逃逸”到堆上。

这个自动决策过程对开发者来说是一个福音，因为它优化了内存使用和性能，而不需要手动干预。栈和堆分配之间的区别对性能有重大影响。由于其直接的分配和释放机制，栈分配通常会导致更好的性能。

堆分配的内存，虽然对于更复杂和动态的数据是必要的，但由于垃圾回收的开销，它会产生性能成本。作为一名 Go 开发者，注意你的变量如何分配可以帮助你编写更高效的代码。虽然 Go 抽象了大部分内存管理复杂性，但了解堆和栈分配的工作原理可以极大地影响你应用程序的性能。

作为一条经验法则，尽可能缩小变量的作用域，并且对可能引起不必要的堆分配的指针和引用保持谨慎。

好的，让我们来深入探讨技术细节。Go 的垃圾回收基于并发、三色标记-清除算法。现在，在你眼前像甜甜圈一样失去光泽之前，让我们来分解一下。

## GC 算法

*并发*意味着它与你的程序并行运行，而不是停止一切来清理。这对于性能至关重要，尤其是在实时系统中，暂停进行维护就像在发布日冻结屏幕一样不受欢迎。

*三色*的概念是关于 GC 如何看待对象。把它想象成内存的交通灯：绿色代表“正在使用中”，红色代表“准备删除”，黄色代表“可能，也可能不”。

最后的部分，*标记和清除*，是这个过程两个主要阶段的定义。简单来说：在“标记”阶段，GC 扫描你的对象，根据可访问性翻转它们的颜色。在“清除”阶段，它移除垃圾——红色对象。这个两步过程有助于高效地管理内存，同时不会干扰正在运行的程序。一旦我们有了整体概念，我们就可以轻松地探讨这两个阶段的细节。

### 标记阶段

“标记”阶段分为两部分。在初始部分，GC 短暂地暂停程序（小于 0.3 毫秒）——想象成潜水前的快速吸气。在这个被称为**停止世界**（**STW**）的阶段，GC 识别根集。这些根实际上是直接从栈、全局变量和其他特殊位置可访问的变量。换句话说，这是 GC 开始搜索识别使用情况和未使用情况的时刻。

识别根集后，GC 继续进行实际的标记，*这发生在程序执行的同时进行*。这就是“三色”隐喻大放异彩的地方。对象最初被标记为“白色”，意味着它们的命运尚未确定。随着 GC 从根遇到这些对象，它将它们标记为“灰色”，表示需要进一步探索，一旦完全处理，最终将它们标记为“黑色”，表示它们正在使用中。这种颜色编码系统确保 GC 全面评估每个对象的可访问性。

在这个过程中还有更多关键细节需要展开。由于我们希望创建高性能的系统，我们需要掌握我们的垃圾回收（GC）知识，而不是仅仅停留在理论层面。

在标记阶段，Go 运行时故意分配大约 **25%** 的可用 CPU 资源。这种分配是一个经过计算的决策，确保垃圾回收器足够高效，以控制内存使用，同时不会压倒系统。这是一个平衡行为，类似于一个确保每个球都能得到足够时间的杂技演员，但不会独占聚光灯。这个 25% 的分配对于保持垃圾回收器的工作稳定和隐蔽至关重要。

除了标准的 CPU 分配外，还预留了额外的 **5%** CPU 用于标记辅助。这些标记辅助在程序在垃圾回收周期中进行内存分配时触发。如果垃圾回收落后了，分配 goroutines 就会伸出援手（在这种情况下，是一些 CPU 循环）以协助标记过程。这额外的 5% 可以被视为一支预备队，在需要时被调用，确保垃圾回收器与内存分配率保持同步。

### 扫描

进入扫描阶段，这是释放操作开始发挥作用的地方。在标记阶段确定了哪些对象不再需要（那些仍然标记为“白色”）之后，扫描阶段开始释放这些内存的过程。这一阶段至关重要，因为这是实际内存回收发生的地方，为未来的分配腾出空间。这一阶段的效率直接影响应用程序的内存占用和整体性能。但并非全是彩虹和蝴蝶。垃圾回收器仍然可能导致性能问题，如延迟峰值，尤其是在处理大型堆或内存密集型应用程序时。了解如何优化你的代码以与垃圾回收器良好协作是一门艺术。它涉及到深入指针管理、避免内存泄漏，有时只是知道何时对垃圾回收器说，“嘿，GC，你可以休息一下；我自己能行。”

## GOGC

Go 中的 `GOGC` 环境变量是垃圾回收器的调节旋钮。它就像你家中供暖系统的恒温器，控制你想要房间有多热或多冷。在 Go 的上下文中，`GOGC` 决定了垃圾回收过程的积极性。它决定了在垃圾回收器触发另一个周期之前，允许分配多少新内存。理解和调整这个变量可以显著影响你的 Go 应用程序的内存使用和性能。默认值是 `100`，这意味着垃圾回收器试图在新的垃圾回收周期后至少留下 100% 的初始堆内存可用。调整 `GOGC` 的值允许你根据应用程序的具体需求定制垃圾回收。

### Go 环境

`GOGC` 是一个影响垃圾回收的环境变量，但它不是特定于 Go 工具链或编译器的配置选项。

将`GOGC`设置为较低的值，比如`50`，意味着 GC 将更频繁地运行，保持堆的大小更小，但使用更多的 CPU 时间。另一方面，将其设置得更高，例如`200`，意味着 GC 将运行得更少，允许更多的内存分配，但可能导致不希望的内存使用增加。

`GOGC`变量可以取*任何大于 0 的整数值*。将其设置为非常低的值可能导致性能下降，因为 GC 运行过于频繁，就像一个清洁工不断地整理到令人烦恼的程度。相反，设置得太高可能导致应用程序使用比必要的更多内存，这在内存受限的环境中可能不是理想的。找到适合你应用程序内存和性能特性的最佳点很重要。

`GOGC`也有特殊的值。将其设置为`off`将完全禁用自动垃圾回收。这可能在程序生命周期短暂，不需要 GC 开销的场景中很有用。然而，权力越大，责任越大；禁用 GC 可能导致内存增长不受控制。这有点像关闭你家的自动恒温器——在适当的条件下可能会有好处，但需要更多的关注来防止问题发生。

在实践中，调整`GOGC`是一个理解你的应用程序内存配置文件和性能需求的问题。这需要仔细的实验和监控。调整这个变量可以带来显著的性能提升，尤其是在具有大堆或实时约束的系统上。

## GC 调节器

Go 中的 GC 调节器可以比作一个乐队的指挥，确保每个部分都能在正确的时间进入，以创造和谐的交响乐。它的任务是调节垃圾回收周期的时机，平衡回收内存的需要与保持程序高效运行的需要。调节器的决策基于当前的堆大小、分配率和维持程序性能的目标。

调节器的主要作用是确定何时开始一个新的垃圾回收周期。它通过监控内存分配率和活动堆的大小（由 GOGC 暗示）——无法回收的正在使用的内存来实现这一点。调节器的策略是在程序分配太多内存之前触发 GC 周期，这可能导致延迟增加或内存压力。这是一个预防措施，类似于在你车变成大问题之前更换机油。

垃圾回收节拍器的一个关键特性是其适应性。它根据应用程序的行为持续调整其阈值。如果一个应用程序快速分配内存，节拍器会通过更频繁地触发垃圾回收周期来做出响应，以保持同步。相反，如果应用程序的分配速率减慢，节拍器将允许在启动垃圾回收周期之前分配更多的内存。这种适应性确保了节拍器的行为与应用程序当前的需求保持一致。

节拍器与`GOGC`环境变量协同工作。`GOGC`设置在触发垃圾回收周期之前堆增长的百分比。节拍器使用这个值作为指导，以确定其阈值。

垃圾回收节拍器的有效性直接影响应用程序的性能。一个调优良好的节拍器确保垃圾回收过程平稳进行，不会导致显著的暂停或延迟峰值。然而，如果节拍器的阈值没有与应用程序的行为良好对齐，可能会导致过多的垃圾回收周期，从而降低性能，或者延迟收集，从而增加内存使用。这就像找到巡航控制正确的速度一样——太快或太慢都可能造成不舒适的驾驶体验。

Go 中的垃圾回收节拍器是确保垃圾回收过程效率的关键组件。这不仅仅是编写代码；这是理解代码运行的环境，而垃圾回收节拍器是那个环境的重要组成部分。

## GODEBUG

Go 语言中的`GODEBUG`环境变量是开发者的一项强大工具，它能够提供关于 Go 运行时内部运作的洞察。具体来说，`GODEBUG=gctrace=1`设置通常用于获取关于垃圾回收过程的详细信息。让我们深入探讨这一点。

Go 中的`GODEBUG`就像是你汽车的诊断工具包。就像你可能插入一个诊断工具来了解你汽车引擎盖下发生了什么一样，`GODEBUG`提供了关于 Go 运行时的洞察。在其各种功能中，最常用的是`gctrace`。当设置为`1`（`GODEBUG=gctrace=1`）时，它启用了垃圾回收活动的跟踪，为你提供了一个窗口，可以看到在你的 Go 应用程序中垃圾回收是如何以及何时发生的。

将`gctrace`设置为`1`会输出每个垃圾回收周期的详细信息，包括其开始时间、持续时间、回收前后的堆大小以及回收的内存量。这些数据对于理解垃圾回收对应用程序性能的影响至关重要。这就像获得关于垃圾回收如何管理内存的逐点评论，这对于性能调整可能是至关重要的。

`gctrace=1`的输出可能相当密集，一开始可能看起来令人畏惧。它包括多个指标，例如 STW 时间，这些指标表明您的应用程序在 GC 期间暂停了多长时间。其他细节包括正在运行的 goroutine 数量、堆大小和 GC 周期数。阅读这个输出就像解读一张藏宝图；一旦您理解了符号和数字，它就会揭示有关如何提高应用程序性能的有价值信息。以下是一个示例输出：

```go
gc 1 @0.019s 2%: 0.015+2.5+0.003 ms clock, 0.061+0.5/2.0/3.0+0.012 ms cpu, 4->4->1 MB, 5 MB goal, 4 P
```

让我们分解这个输出：

+   `gc 1`: 这表示垃圾收集周期的序列号

+   `@0.019s`: 从程序开始到此次 GC 周期开始的时间（以秒为单位）

+   `2%`: 在 GC 上花费的总程序运行时间的百分比

+   `0.015+2.5+0.003 ms clock`: GC 周期时间的分解

    +   `0.015 ms`: STW 清除终止阶段时间

    +   `2.5 ms`: 并发标记和扫描阶段时间

    +   `0.003 ms`: STW 标记终止阶段时间

+   `0.061+0.5/2.0/3.0+0.012 ms cpu`: GC 周期的 CPU 时间

    +   `0.061 ms`: STW 清除终止的 CPU 时间

    +   `0.5/2.0/3.0`: 并发阶段（标记/扫描、辅助、后台）的 CPU 时间

    +   `0.012 ms`: STW 标记终止的 CPU 时间

+   `4->4->1 MB`: GC 开始、中点和结束时的堆大小

+   `5 MB goal`: 下一个 GC 周期的目标堆大小

+   `4 P`: 使用的处理器数量

我们可以通过以下数据观察到：

+   **频繁的高百分比**：如果 GC 花费的时间百分比高且频繁，这可能表明存在性能问题

+   **STW 时间**：较长的 STW 时间可能表明需要优化以减少 GC 暂停

+   **堆大小趋势**：GC 周期后没有类似减少的堆大小增长可能表明存在内存泄漏

+   **CPU 时间**：更高的 CPU 时间可能表明 GC 比预期工作得更努力，这可能是由于内存使用效率低下

在怀疑内存泄漏或尝试优化内存使用和 GC 开销的情况下，设置`GODEBUG=gctrace=1`特别有用。例如，如果您观察到较长的 STW 时间，这可能表明您的应用程序在垃圾收集上花费了太多时间，导致性能瓶颈。同样，如果堆大小持续增长，这可能是一个内存泄漏的迹象。这种程度的洞察力对于做出关于代码优化和内存管理的明智决策至关重要。然而，像任何强大的工具一样，它应该被理解和谨慎地使用。通过利用`gctrace`，开发者可以显著提高 Go 应用程序的效率和性能。

# 内存压舱物

在 Go 中，内存压舱物，从本质上讲，就像在汽车的行李箱中放一个重的行李箱，以防止它太轻并在冰上打滑。在 Go 的上下文中，内存压舱物是指大量分配的内存，这些内存从未使用过，但用于影响垃圾收集器的行为。

传统上，Go 的垃圾回收（GC）会在上一次收集结束时的堆大小加倍时触发（`GOGC=100`）。在堆大小较大的应用程序中，这可能导致 GC 周期之间出现长时间的间隔，随后是大型且破坏性的收集。

开发者使用内存压舱作为缓冲区，人为地增加堆大小以提示更频繁、但更小且更不破坏性的 GC 周期。这是一种手动调优方法，用于优化性能，尤其是在高吞吐量、低延迟系统中。这项技术是由流媒体公司 Twitch 在 2019 年在其后 *How I learnt to stop worrying and love the* *heap* ([`blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/`](https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/)) 文章中开发的。

Twitch 有一个名为 Visage 的服务，充当 API 前端，是所有外部发起的 API 流量的中心网关。它是用 Go 编写的，并在 AWS EC2 上运行。他们面临着处理大量流量波动的挑战，尤其是在“刷新风暴”期间，当一位受欢迎的广播者的直播掉线并重新启动时，观众会反复刷新他们的页面。Visage 应用程序每秒会触发大量垃圾回收周期，这消耗了大量的 CPU 周期，并在高峰负载期间增加了 API 延迟。该应用程序的堆大小相对较小，在流量波动期间，GC 周期的数量会增加，从而进一步降低性能。

当他们引入内存压舱时，它增加了堆的基数大小，延迟了 GC 触发，并随着时间的推移减少了 GC 周期的数量。这是通过分配一个非常大的字节数组来实现的，由于它仍然被应用程序引用，因此不会被回收。这个数组创建如下代码片段：

```go
ballast := make([]byte, 10<<30)
```

非常简单但强大，对吧？他们的结果如下：

+   引入内存压舱导致 GC 周期减少了约 99%。

    +   API 前端服务器的 CPU 利用率降低了约 30%，并且在高峰负载期间，API 的 99% 分位延迟降低了约 45%

+   压舱石有效地允许堆在触发 GC 之前增长更大，这提高了每台主机的吞吐量，并在负载下提供了更可靠的每请求处理。

+   压舱石分配主要位于虚拟内存中，使其成为一种成本效益高的解决方案

尽管在 Twitch 等某些场景中非常强大，但内存压舱技术并不适用于所有情况，应避免或谨慎使用：

+   **内存敏感型应用程序**：在内存资源稀缺的环境中，分配一大块内存作为压舱石可能不可行。这对于在内存有限的硬件上运行或在高密度容器化环境中运行的应用程序尤其如此，在这些环境中，内存开销是一个关键因素。

+   **具有动态内存使用的应用程序**：如果应用程序的内存使用高度动态且不可预测，设置固定大小的内存平衡器可能会导致内存利用效率低下。

+   **低延迟系统**：虽然内存平衡器可以减少垃圾回收的频率，从而提高吞吐量，但它并不总是有利于低延迟系统，在这些系统中，垃圾回收暂停的可预测性更为关键。平衡技术主要优化吞吐量，可能会以增加垃圾回收触发前的堆大小为代价，从而增加延迟。

+   **小堆内存占用应用程序**：自然保持小堆内存占用的应用程序可能不会从内存平衡器中受益。在这种情况下，管理大量未使用的内存分配的开销可能超过了减少垃圾回收频率的好处。

+   (`GOGC` 环境变量) 可以在不使用内存平衡器的情况下实现所需的性能改进。这种方法应该首先考虑，因为它是一种侵入性较小的优化 GC 行为的方法。

+   **当它掩盖了潜在的性能问题时**：使用内存平衡器来提高性能可能会掩盖应用程序代码或架构中潜在的低效。直接解决这些基本问题比依赖内存平衡器作为权宜之计更为重要。

内存平衡器是管理这些关键场景的绝佳选择，但它仅适用于 Go 版本 1.19 及之前。从版本 1.20 开始，有一个标准化的方法可以通过 `GOMEMLIMIT` 环境变量设置应用程序的“软”内存限制。

# GOMEMLIMIT

使用 `GOMEMLIMIT`，您为 Go 运行时的内存使用设置了一个软上限，包括堆和其他运行时管理的内存。这个上限就像告诉您的应用程序：“这是您的内存预算；明智地使用它。”

自从 Go 1.20 以来，战略重点已经从手动调整，如内存平衡器，转向利用内置的运行时功能进行内存管理。`GOMEMLIMIT` 提供了一种更直接、更易于管理的限制内存使用的方法。

`GOMEMLIMIT` 变量用于为运行时设置一个软内存限制。这个限制包括 Go 堆以及运行时管理的所有其他内存，但不包括外部内存源，例如二进制的映射、其他语言中管理的内存，或操作系统代表 Go 程序持有的内存。`GOMEMLIMIT` 是一个以字节为单位的数值，可以选择添加单位后缀以增加清晰度。支持的单位后缀包括 B、KiB、MiB、GiB 和 TiB，遵循 IEC 80000-13 标准。这些后缀表示基于 2 的幂的字节数量；例如，KiB 表示 2¹⁰ 字节，MiB 表示 2²⁰ 字节，依此类推。默认情况下，GOMEMLIMIT 设置为 `math.MaxInt64`，实际上禁用了内存限制。然而，您可以在运行时使用 `runtime/debug.SetMemoryLimit` 来更改此限制。关于 `GOMEMLIMIT` 的关键方面是它的“软上限”性质。与作为内存使用严格上限的硬限制不同，软上限更加灵活。`GOMEMLIMIT` 影响垃圾收集器的行为，当内存使用接近设定的限制时，会促使垃圾收集器更加积极地运行。然而，这并不意味着绝对防止超过限制。它就像道路上的速度警告标志；它建议一个安全速度，但不能实际上减慢你的车。

为什么不两者都要呢？

与 `GOMEMLIMIT` 一起使用内存压舱物可能是多余的，就像戴两只手表来告诉相同的时间一样。压舱物用于人为地增加堆的大小以改变垃圾收集器的行为，但有了 `GOMEMLIMIT`，您已经定义了堆的上限。

# 内存区域

Go 1.20 版本引入了一个实验性的区域包，它提供了内存区域。这些区域可以通过减少运行时需要进行的分配和释放次数来提高性能。

内存区域是分配对象并一次性释放它们（具有最小的内存管理或垃圾收集开销）的有用工具。它们在需要分配许多对象、处理一段时间后并在最后释放所有对象的函数中特别有用。重要的是要注意，内存区域是一个实验性功能，仅在 Go 1.20 中可用，前提是设置了 `GOEXPERIMENT=arenas` 环境变量。

警告

Go 团队不提供对内存区域 API 和实现的官方支持或兼容性保证，并且它可能不会出现在未来的版本中。

## 使用内存区域

一旦我们设置了 `GOEXPERIMENT=arenas` 环境变量，我们就可以导入 `arena` 包：

```go
import "arena"
```

要创建一个新的区域，我们可以使用 `NewArena()` 函数，它返回新的区域引用：

```go
mem := arena.NewArena()
```

一旦我们有了要使用的区域，我们就可以为我们的类型请求新的引用。在下一个片段中，我们正在为 `Person` 结构体类型在我们的区域中创建一个新的引用：

```go
mem := arena.NewArena()
p := arena.NewPerson
```

这与正常分配流程中的常规流程有一个重要的区别。我们不是创建新的引用并将它们放入区域。我们向区域请求新的引用。

区域包中引入了一些新的 API，例如 `MakeSlice`，它要求为区域请求一个预定的容量切片。如果我们想请求一个新的区域限制切片，我们可以使用以下代码：

```go
mem := arena.NewArena()
slice := arena.MakeSlicestring
```

我们可以重复这个过程并正常操作对象，但当我们完成我们的区域时，我们可以调用 `Free()`：

```go
mem := arena.NewArena()
p := arena.NewPerson
... other set of arena related operations
mem.Free()
```

记住，释放区域将一次性释放所有对象，而不是在正常 Go 的 GC 流程中的扫描阶段进行分散释放。

有时我们想在释放区域中的所有对象之前，将一些在区域中创建的对象发送到堆（垃圾回收）。这可以通过使用 `Clone` 函数来实现：

```go
mem := arena.NewArena()
p1 := arena.NewPerson // arena-allocated
p2 := arena.Clone(p1) // heap-allocated
```

在这个片段中，`p1` 是区域分配的，而 `p2` 是堆分配的。

### 新的解决方案，老问题

由于我们需要积极释放我们的区域。这个新的开发步骤可能会出错。最常见的问题是释放区域后继续使用区域对象。为了使事情更容易，Go 工具链在程序执行期间有一个标志来激活 **地址** **检查器**（**asan**）。

考虑这个程序：

```go
type T struct {
    Num int
}
func main() {
    mem := arena.NewArena()
    o := arena.NewT
    mem.Free()
    o.Num = 123 // <- this is a problem
}
```

因此，我们可以使用地址检查器执行程序：

```go
go run -asan main.go
```

输出将按预期显示问题：

```go
accessed data from freed user arena 0x40c0007ff7f8
```

### 机会

Go 开发中有几个领域可能会因内存区域而受益。最典型的例子是 gRPC。每当程序处理 RPC 请求时，在编码和解码消息的过程中会分配许多对象。正如我们之前看到的，这往往会对 GC 增加更多压力。这种策略某种程度上证明了它对性能的影响，因为 gRPC 的 C++ 实现已经使用了内存区域的概念（[`protobuf.dev/reference/cpp/arenas/`](https://protobuf.dev/reference/cpp/arenas/））。另一个使用内存区域（作为一个概念）以获得性能提升的例子是在 JSON 序列化过程中。fastjson 项目（[https://github.com/valyala/fastjson](https://github.com/valyala/fastjson)）使用内存区域来处理序列化，据说比 Go 标准库快 15 倍。

### 指南

在将区域引入你的项目之前，你可以问自己一些问题。

*我有关于我怀疑的问题的数据吗？*

如果你没有数据，你就是在猜测：

*我有多处分配还是只有几处？*

如果你没有很多分配，你的程序通过引入区域会使用更多内存。你可以使用这样一个经验法则：一个区域的大小是 8 MB。

*它有相同的小结构吗？*

也许你正在寻找错误的工具。考虑使用 `sync.Pool`。

*这是我的程序的“热点路径”吗？*

这可能是一种过早的优化。在考虑内存区域之前，先尝试几种 GC 和 `GOMEMLIMIT` 的组合。

是时候总结我们对内存管理的知识了。

# 摘要

我们已经探讨了垃圾回收（GC）、栈和堆分配之间的区别，以及优化内存使用以提高性能的方法。此外，我们还揭示了 Go 的垃圾回收器和其方法的发展，包括高级主题，如其算法（三色/并发/标记和清除）。

我们还讨论了实际的方法，包括使用环境变量如`GOGC`来微调垃圾回收，以及采用内存压舱和`GOMEMLIMIT`等技术来帮助 GC 管理程序内存。

在本章中，你可能自己问自己：通过调整 GC 和运行时参数，以及结合这些技术，我们获得了多少性能提升？

答案很简单：*性能不是一场猜测游戏。我们应该* *对其进行测量*。

在下一章（关于性能分析）中，我们将探讨如何从内存、CPU、分配等方面对应用程序进行性能分析。
