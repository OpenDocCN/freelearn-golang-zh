# 11

# 遥测

在本章中，我们将探讨实际世界的**遥测**领域，在这里，Go 的编程模型的优雅性与应用程序可观察性的关键需求相得益彰。我们正在为您提供日志记录、跟踪和度量的工具，以揭示您的 Go 应用程序的内部运作，让您能够确保它们高效且可靠地运行。

本章是您提升应用程序遥测艺术和科学指南。从结构化日志的全面实践，它为应用程序日志带来秩序和清晰，到跟踪提供的详细洞察，以及度量实现的彻底分析，本章涵盖了所有内容。

本章将涵盖以下关键主题：

+   日志

+   跟踪

+   度量

+   **OpenTelemetry**（**OTel**）项目

到本章结束时，您将掌握观察、理解和积极改进应用程序性能和可靠性的技能，这将激发您在工作中的参与感和动力。

# 技术要求

确保您的机器上已安装 Docker。您可以从官方 Docker 网站下载它（[`www.docker.com/get-started`](https://www.docker.com/get-started)）。

本章中展示的所有代码都可以在我们的 Git 仓库的 `ch11` 目录中找到。

# 日志

日志记录，系统编程中的不为人知的英雄，常常像软件更新中的“条款和条件”复选框一样被忽视。大多数开发者对待日志记录的方式就像青少年对待干净房间一样：理论上是个好主意，但不知为何，直到事情开始变得奇怪，才成为优先事项。这里的常见误解是什么？那就是日志记录只是事后想到的，只是代码偶尔记录的日记。剧透一下：事实并非如此！

想象一下，如果你愿意，一个软件开发版的考古挖掘。每一条日志条目都是精心挖掘出的文物，为曾经繁荣的文明（代码库）提供了线索。现在，想象一些开发者在这个挖掘现场，使用推土机（糟糕的日志记录实践）来挖掘这些脆弱的宝藏。结果呢？大量的破碎陶器和困惑的面孔。朋友们，这就是当将日志记录应用于 Go 语言时没有得到应有的尊重和精确度时会发生的事情。

在 Go 语言中，尤其是在系统编程的背景下，日志记录是理解应用程序行为的一个基本工具。它提供了对系统的可见性，使开发者能够追踪错误、监控性能和理解流量模式。Go 语言作为一门务实的语言，通过标准库中的日志包提供了内置的日志记录支持，但当系统级编程介入时，情况变得更加复杂。

对于系统编程，性能和资源优化至关重要，标准的`log`包可能并不总是能满足需求。这就是结构化日志受到关注的地方。与纯文本日志相比，结构化日志将日志条目组织成结构化格式，通常是 JSON。这种格式使得日志更容易查询、分析和理解，尤其是在你试图在大量数据中找到传说中的“海中针”时。

我们不仅要有言辞，还要有行动，用一段 Go 语言代码片段来展示结构化日志：

```go
package main
import (
     "os"
     "log/slog"
)
func main() {
     handler := slog.NewJSONHandler(os.Stdout)
     logger := slog.New(handler)
     logger.Info("A group of walrus emerges from the ocean", slog.Attr("animal", "walrus"), slog.Attr("size", 10))
}
```

此代码使用了 Go 1.21 中引入的实验性`slog`包。它位于`log`子包中（`log/slog`）。它提供了无需外部依赖的便利，简化了项目管理。

让我们探索这个片段的关键点：

+   `handler := slog.NewJSONHandler(os.Stdout`)：这一行创建了一个`slog.Handler`，负责格式化和可能路由日志条目。在这里，`slog.NewJSONHandler`生成一个 JSON 格式化器，而`os.Stdout`指定标准输出作为目的地。

+   `logger := slog.New(handler`)：这一行创建了一个`slog.Logger`实例。新创建的 JSON 处理器用于配置日志的输出格式和目的地。

+   `logger.Info("A group of walrus emerges from the ocean", slog.Attr("animal", "walrus"), slog.Attr("size", 10))`：这是使用`Info`方法记录一条信息性消息

+   `slog.Attr("animal", "walrus"), slog.Attr("size", 10`)：这些通过使用`slog.Attr`创建键值对（属性），以结构化数据增强日志消息。这使得日志更容易被工具或下游应用程序解析和分析。

在 Go 中，日志不仅仅是记录；它是逐条理解应用程序故事的过程。记住——就像任何好的故事一样，魔鬼在于细节（或者在这个案例中，是数据）。

在软件开发领域，日志是理解、诊断和跟踪应用程序行为的基础。它类似于著名童话故事《汉塞尔与格蕾特》中留下的面包屑路径，为你提供指导，穿越代码库的复杂森林，了解发生了什么，何时发生，以及为什么发生。

在本质上，日志涉及在程序执行过程中记录事件和数据。这些事件可能包括关于应用程序操作的一般信息，到错误和系统特定的消息，这些消息可以提供对其健康和性能的洞察。日志的重要性可以与航空中的飞行记录器或“黑匣子”的作用相提并论；它捕捉了事后分析事件发生前的事件或优化未来性能的关键信息。

有效的日志实践通过以下方式赋予开发者力量：

+   **调试和故障排除**：当出现问题的时候，日志是主要查看的地方。它们可以帮助确定错误发生的位置和情况，从而减少解决问题所需的时间。

+   **安全审计**：记录访问和交易数据可以帮助检测未授权的访问尝试、数据泄露和其他安全威胁，从而促进快速采取行动。

+   **合规性和记录保存**：在许多行业中，为了合规目的，详细记录是监管要求，作为正确处理数据和其它实践的证明。

+   **理解用户行为**：日志可以提供关于用户如何与你的应用程序交互、哪些功能最受欢迎以及用户可能遇到困难的见解。

尽管日志记录在关键作用中，但它并非没有挑战。它需要仔细平衡，以确保捕获到正确数量的信息——太少可能会错过重要线索；太多，你就像在寻找针一样在干草堆中翻找。日志记录的艺术和科学在于确定记录什么、如何记录以及如何理解收集到的数据，同时最大限度地减少对应用程序性能的影响。

当我们今天寻找性能时，uber/zap 是最快的日志库之一。让我们探讨使用 slog 与 zap 之间的主要区别。

## Zap 与 slog

当在 slog 和 zap 之间做出选择时，考虑你应用程序的具体需求。

对于性能至关重要的应用程序，并且你需要对日志进行精细控制，zap 提供了经过验证的速度和可配置性。

如果你正在寻找一个与现代、高效的日志解决方案集成良好，且强调简洁和灵活的 Go 的上下文包，slog 可能是正确的选择。

这里是相同示例的 zap 版本：

```go
package main
import (
    "os"
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
)
func main() {
    encoderConfig := zapcore.EncoderConfig{
        MessageKey: "message",
        LevelKey:    "level",
        EncodeLevel: zapcore.CapitalLevelEncoder,
        TimeKey:    "time",
        EncodeTime: zapcore.ISO8601TimeEncoder,
        CallerKey:    "caller",
        EncodeCaller: zapcore.ShortCallerEncoder,
    }
    consoleEncoder := zapcore.NewConsoleEncoder(encoderConfig)
    consoleSink := zapcore.AddSync(os.Stdout)
    core := zapcore.NewCore(consoleEncoder, consoleSink, zap.InfoLevel)
    logger := zap.New(core)
    sugar := logger.Sugar()
    sugar.Infow("A group of walrus emerges from the ocean",
        "animal", "walrus",
        "size", 10,
    )
}
```

这个例子故意夸张，以描绘 zap 库的可配置性。让我一步一步地解释这里发生了什么：

1.  使用 `go.uber.org/zap` 进行核心 zap 功能和 `go.uber.org/zap/zapcore` 进行低级配置。

1.  `encoderConfig` 配置用于具有可读键的 JSON 输出。

1.  `consoleEncoder`）和一个输出目的地（`consoleSink`），它将写入标准输出。

1.  `zapcore.NewCore` 函数构建了我们日志的核心，它结合了编码器、接收器和配置的日志级别（`zap.InfoLevel`）。

1.  使用 `zap.New`，我们基于 `core` 构建了一个 zap 日志记录器。

1.  使用 `Infow` 进行日志记录。它使得向日志消息中添加结构化数据变得更容易（并且比非糖化的版本运行得更慢）。

然而，slog 和 zap 都增强了 Go 的日志功能，超越了标准库，提供了结构化、高效和灵活的日志解决方案。选择它们取决于你应用程序的具体需求，包括性能考虑、对结构化日志的需求以及所需的定制程度。

## 用于调试或监控的日志？

调试日志主要用于开发阶段或诊断系统中的问题时。它们的主要目的是为开发者提供关于应用程序在特定时间点行为的详细、上下文信息，尤其是在出现错误或意外行为时。

这里是调试日志的特点：

+   **粒度**：调试日志通常非常详细，包括关于应用程序状态、变量值、执行路径和错误消息的冗长信息。

+   **临时性**：这些日志可能在开发环境中生成或在生产环境中临时启用以追踪特定问题。由于它们的冗长性质，它们通常不会在运行环境中永久运行。

+   **面向开发者**：调试日志的受众通常是熟悉应用程序代码库的开发者。信息是技术性的，需要深入了解应用程序的内部结构。

这些日志最常见的例子是堆栈跟踪和某些检查点的关键变量。

当我们为监控进行日志记录时，日志被设计用于对生产环境中应用程序的持续观察。它们有助于理解应用程序的健康状况和随时间变化的用法模式，从而促进主动维护和优化。

这里是监控日志的特点：

+   **易于聚合**：监控日志被设计成易于监控工具进行聚合和分析。它们通常遵循一致的格式，这使得提取指标和趋势变得更加简单。

+   **持久性**：这些日志在生产环境中的应用程序正常操作过程中持续生成和收集。与调试日志相比，它们的信息量较少，以平衡信息量和性能开销。

+   **运营洞察**：重点在于与应用程序的运营、用户活动和错误率相关的信息。受众不仅包括开发者，还包括系统管理员和运维团队。

例如，我们可以在包括方法、URL 和状态码的 HTTP 请求日志中看到这种日志策略。

这两种方法之间的主要区别在于目标、详细程度、受众和生命周期。

从本质上讲，调试和监控的日志在应用程序的生命周期中扮演着互补但不同的角色。有效的日志策略认识到这些差异，实施定制的方法以满足调试和监控的独特需求。

在日志记录方面，你选择的格式可以显著影响日志数据的可读性、处理速度和整体实用性。两种流行的格式是 JSON 日志和结构化文本日志。在它们之间进行选择需要了解它们的不同之处、优点以及您应用程序或环境的特定需求。让我们概述一个框架，以帮助我们做出明智的决定。

首先，我们应该考虑日志消费工具：

+   **JSON 日志**：如果你使用的是现代日志管理系统或旨在摄取和查询 JSON 数据的工具（如**Elasticsearch, Logstash, Kibana**（**ELK**）或 Splunk），JSON 日志可以非常有优势。这些工具可以原生解析 JSON，从而实现更高效的查询、过滤和分析。

+   **结构化文本日志**：如果你的日志消费主要涉及直接读取日志进行调试或使用不原生解析 JSON 的工具，结构化文本日志可能更受欢迎。结构化文本日志对于人类来说可能更容易阅读，尤其是在控制台跟踪日志时。

此外，我们评估日志数据复杂性：

+   **JSON 日志**：JSON 非常适合记录复杂和嵌套的数据结构。如果你的应用程序日志包含多种数据类型或需要分层组织的结构化数据，JSON 日志可以更有效地封装这种复杂性。

+   **结构化文本日志**：对于主要需要简单日志记录，日志内容主要是平面消息和一些键值对的情况，结构化文本日志可以满足需求，并且更易于处理。

在此评估之后，我们可以评估性能和开销：

+   **JSON 日志**：以 JSON 格式编写日志可能会因为序列化成本而引入额外的计算开销。对于性能至关重要的高吞吐量应用程序，评估你的系统是否能够在不造成重大影响的情况下处理这种开销。

+   **结构化文本日志**：通常，生成结构化文本日志比 JSON 序列化消耗的 CPU 资源更少。如果性能是首要关注点，并且你的日志数据相对简单，结构化文本日志可能是更有效的选择。

然后，我们可以制定日志分析和故障排除的计划。

+   **JSON 日志**：在需要广泛分析日志以深入了解应用程序行为、用户操作或故障排除复杂问题的场景中，JSON 日志提供了更结构化和“可查询”的格式。它们促进了更深入的分析，并且可以被许多工具自动处理。

+   **结构化文本日志**：如果你的日志分析需求简单，或者你主要使用日志进行实时故障排除而不进行复杂的查询，结构化文本日志可能就足够了。

最后，我们可以评估开发和维护环境：

+   **JSON 日志**：考虑你的开发团队是否熟悉 JSON 格式和解析，以及你的日志框架和基础设施是否有效地支持 JSON 日志。

+   **结构化文本日志**：对于寻求简单性和易用性的团队，特别是如果他们不使用高级日志处理工具，结构化文本日志可能更受欢迎。

一般性指南如下：

+   **日志消费工具**：选择 JSON 用于高级处理工具；选择结构化文本用于简单性或直接消费。

+   **数据复杂性**：对于复杂、嵌套的数据使用 JSON；对于简单的数据使用结构化文本。

+   **性能考虑**：当性能至关重要时选择结构化文本；考虑到性能影响使用 JSON。

+   **分析和故障排除**：对于深入分析需求选择 JSON；对于基本故障排除使用结构化文本。

+   **团队和基础设施**：考虑团队熟悉度和基础设施能力。

最终，在 JSON 和结构化文本日志之间的选择取决于平衡您应用的具体需求、日志处理基础设施的能力以及您团队的偏好和技能。系统在不同上下文或应用的不同层使用这两种类型以优化人类可读性和机器处理的情况并不少见。

理解应该记录什么和不应该记录什么对于维护高效、安全和有用的日志实践至关重要。

## 应该记录什么？

正确的日志记录可以帮助您调试问题、监控系统性能和理解用户行为。然而，过多的或不适当的日志记录可能导致性能下降、存储问题和安全漏洞。

这里有一份指南来帮助您做出这些决定：

+   **错误**：捕获发生的任何错误。包括堆栈跟踪以方便调试。

+   **系统状态变化**：记录应用中的重大状态变化，例如系统启动或关闭、配置更改以及关键组件的状态变化。

+   **用户行为**：记录关键用户行为，特别是那些修改数据或触发应用中重大流程的行为。这有助于理解用户行为和诊断问题。

+   **当您没有设置** **指标服务器**：

    +   **性能指标**：记录与性能相关的指标，如响应时间、吞吐量和资源利用率。这些信息对于监控系统的健康和性能至关重要。

    +   **安全事件**：记录与安全相关的事件，例如登录尝试、访问控制违规和其他可疑活动。这些日志对于安全监控和事件响应至关重要。

    +   **API 调用**：当您的应用通过 API 与外部服务交互时，记录这些调用有助于跟踪依赖关系和故障排除问题。

+   **当您没有审计系统来发送** **系统事件**：

    +   **关键业务交易**：记录重要的业务交易，以提供可用于合规、报告和商业智能目的的审计跟踪。

## 不应该记录什么？

有一些信息不适合记录，例如以下内容：

+   **敏感信息**：避免记录敏感信息，如密码、**个人身份信息**（**PII**）、信用卡号码和安全令牌。此类信息的泄露可能导致安全漏洞和合规违规。

+   **生产环境中的详细或调试信息**：虽然详细或调试级别的日志在开发期间非常有用，但它们可能会使生产系统不堪重负。使用适当的日志级别并考虑动态调整日志级别。

+   **冗余或不相关信息**：多次记录相同的信息或捕获不相关信息可能会使日志杂乱无章，并消耗不必要的存储空间。

+   **大量二进制数据**：避免记录大量二进制对象，例如文件或图像。这些可能会显著增加日志文件的大小并降低性能。

+   **未经净化的用户输入**：记录原始用户输入可能会引入安全风险，如注入攻击。在记录之前始终对输入进行净化。

最佳实践可以总结如下：

+   **使用结构化日志**：结构化日志使搜索和分析数据更加容易。在日志中使用一致的格式，如 JSON

+   **实施日志轮转和保留策略**：自动轮转日志并定义保留策略以管理磁盘空间并符合数据保留要求

+   **保护日志数据**：确保日志安全存储，控制访问，并加密日志数据的传输

+   **监控日志文件中的异常**：定期审查日志文件，寻找可能表明操作或安全问题的异常活动或错误

通过遵循这些指南，你可以确保你的日志实践对应用程序的维护、性能和安全产生积极贡献。

记住，目标是捕获足够的信息以供使用，同时不损害系统性能或安全。

通常，我们需要有关程序执行和记录系列（日志）的更多信息。这就是我们依赖跟踪的地方。

# 跟踪

所以，你听说在 Golang 中进行跟踪就像吃派一样简单，是吗？让我们别自欺欺人；在系统编程领域，跟踪更像是用微波炉烘焙松饼——当然，你可能会得到一些可以食用的东西，但几乎不可能赢得任何米其林星级。

这里有一个可能让你感兴趣的类比：想象你是一名软件开发的谋杀案侦探。受害者？系统性能。嫌疑人？一群可疑的 goroutines，一个比一个可疑。你破解这个案件唯一的希望在于复杂的跟踪分析艺术。但小心，这可不是儿戏。你需要所有的智慧、智慧和大量的讽刺来穿越堆栈跟踪和执行线程的泥潭。

对于那些不熟悉系统编程细节的人来说，Golang 中的跟踪是福尔摩斯调试工具。它允许开发者在程序执行期间观察程序的行为，为性能瓶颈和难以捉摸的虫子提供宝贵的见解，否则它们就像房间里摇椅上的好猫一样难以捉摸。

在其核心，Go 的跟踪框架利用 `runtime/trace` 包让您深入了解应用程序的运行灵魂。通过收集与 goroutines、堆分配、垃圾回收等相关的大量事件，它为深入挖掘代码的内部工作原理奠定了基础。

跟踪分析的力量在像 `go tool trace` 这样的工具的帮助下变得生动起来，这些工具可以解析由您的 Go 应用程序生成的跟踪文件，并以一个既揭示又迷人的网页界面提供它们。在这里，您可以可视化 goroutines 的执行，追踪延迟问题，并揭开那些让您夜不能寐的性能之谜。

让我们通过一个简单的代码示例来实际看看。假设您已经用跟踪调用包装了您的关键部分，如下所示：

```go
package main
import (
     "os"
     "runtime/trace"
)
func main() {
     trace.Start(os.Stderr)
     defer trace.Stop()
     // Your code here. Let's pretend it's something impressive.
}
```

当您运行这个程序时，它输出的是一种丑陋的输出，对吧？

此代码片段启动跟踪过程，将输出定向到 stderr，您可以在那里尽情分析。记住，这只是冰山一角。

让我们退后一步，学习如何在我们的程序中添加跟踪并正确检查输出。

如您所见，要开始跟踪，您需要导入 `runtime/trace` 包。此包提供了开始和停止跟踪的功能：

```go
import (
    "os"
    "runtime/trace"
)
```

我们需要在您代码中想要开始跟踪的点调用 `trace.Start`。同样，当您想要结束跟踪时，通常是在您感兴趣测量的特定操作之后，应该调用 `trace.Stop`：

```go
func main() {
    f, err := os.Create("trace.out")
    if err != nil {
        panic(err)
    }
    defer f.Close()
    err = trace.Start(f)
    if err != nil {
        panic(err)
    }
    defer trace.Stop()
    // Your program logic here
}
```

按照常规运行您的 Go 程序。程序将执行并在当前目录下生成一个名为 `trace.out` 的跟踪文件（或您命名的任何文件）：

```go
go run your_program.go
```

当您的程序运行后，您可以使用 `go tool trace` 分析跟踪文件。此命令将启动一个提供基于网页的用户界面的 Web 服务器，用于分析跟踪：

```go
go tool trace trace.out
```

当您运行此命令时，它将在控制台打印一个 URL。在您的网页浏览器中打开此 URL 以查看跟踪查看器。查看器提供了各种视图来分析程序执行的各个方面，例如 goroutine 分析、堆分析以及我们在 *第九章* 中探索的其他方面，*分析性能*。

对于带有 HTTP 服务器的程序，方法略有不同。让我们给这个简单的程序添加跟踪功能：

```go
package main
import (
    "fmt"
    "net/http"
)
func main() {
    http.HandleFunc("/", handler)
    fmt.Println("Server is listening on :8080")
    http.ListenAndServe(":8080", nil)
}
func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, Tracing!")
}
```

要跟踪 HTTP 端点，我们需要用开始和停止跟踪的函数包装您的处理器执行。您可以使用 `runtime/trace` 包进行跟踪，以及 `net/http/httptrace` 进行更详细的 HTTP 跟踪。

首先，让我们修改我们的主包以包含 `runtime/trace` 包，如前一个代码片段所示。然后，为您的 HTTP 处理器创建一个跟踪包装器：

```go
import (
    "net/http"
    "runtime/trace"
)
func TraceHandler(inner http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        ctx, task := trace.NewTask(r.Context(), r.URL.Path)
        defer task.End()
        trace.Log(ctx, "HTTP Method", r.Method)
        trace.Log(ctx, "URL", r.URL.String())
        inner(w, r.WithContext(ctx))
    }
}
```

然后，用 `TraceHandler` 包装您的 HTTP 处理器：

```go
func main() {
    http.HandleFunc("/", TraceHandler(handler))
    fmt.Println("Server is listening on :8080")
    http.ListenAndServe(":8080", nil)
}
```

按照上一个程序中的相同步骤开始和停止跟踪，然后运行您的应用程序。向您的服务器发送一些请求以确保有活动可以跟踪。

在停止跟踪并生成跟踪文件后，使用`go tool trace`命令来分析跟踪数据。特别关注与网络 I/O 和 HTTP 请求相关的部分，以了解您端点的性能。

## 有效的跟踪

不要跟踪整个程序，而要关注性能关键的部分。这种方法可以减小跟踪文件的大小，并使分析更容易。

在跟踪查看器中花些时间探索不同的视图。每个视图都能为您提供对程序执行特定方面的洞察。在分析跟踪时，寻找不寻常的模式或异常，例如长时间阻塞的 goroutines 或过度的垃圾回收暂停。

确保在请求处理期间，将包含跟踪的上下文传递给任何下游调用。这允许进行更全面的跟踪，包括整个请求生命周期。

在可能的情况下，使用中间件进行跟踪。对于更复杂的应用程序，考虑在您的 HTTP 服务器中实现跟踪作为中间件。这种方法可以在应用程序的不同部分提供更大的灵活性和可重用性。

回顾我使用 Golang 跟踪的种种尝试和挑战，我想起了一个项目，就像一辆豪华轿车陷入泥潭一样。经过数小时的仔细研究跟踪输出，我偶然发现了一个深刻的启示，就像在冰箱里找到你的车钥匙一样。我意识到，跟踪，就像一位技艺高超的品酒师一样，能够辨别出色表现和灾难性瓶颈之间的细微差别。最终，解决方案就像重新排列一些数据库调用那样简单，但它突显了 Golang 跟踪功能的微妙复杂性。

跟踪主要用于性能分析和调试。它特别有助于识别并发问题，了解系统在负载下的行为，以及确定分布式系统中的延迟来源。与记录相比，跟踪提供了更细粒度的程序执行视图。虽然记录记录离散的事件或状态，但 Go 中的跟踪可以提供连续、详细的程序执行记录，包括系统级事件。

记录与跟踪

此外，两种情况下都有性能考虑。记录和跟踪都可能影响 Go 应用程序的性能，但跟踪的影响通常更为显著，尤其是在生产环境中使用执行跟踪时。开发者需要在捕获的详细程度和性能开销之间进行权衡。

总结一下，将 Golang 中的追踪想象成解剖一个复杂的机械装置。没有合适的工具和知识，你只是一个拿着扳手的猴子。但如果你配备了 Golang 的追踪包，你就能变成一个大师级机械师，将你的应用程序调整得像一只蜷缩在温暖的膝盖上打呼噜的小猫一样。记住，魔鬼藏在细节中，有时，这些细节隐藏在你的代码的深处。

## 分布式追踪

分布式追踪涉及监控请求在分布式系统中穿越各种相互连接的服务时的完整旅程。想象一个复杂的电子商务应用程序，它有独立的产品搜索、购物车、支付处理和订单履行的服务。单个用户请求可能会触发与所有这些服务的交互。

你可能会问自己，它是如何工作的？这里有四个关键概念：唯一标识符、传播、跨度以及收集和分析。

为初始请求分配一个唯一标识符（追踪 ID）。这个 ID 成为连接所有后续日志和事件的线索，这些日志和事件与该特定请求相关。

追踪 ID 随后传播到处理请求的所有服务中。这可以通过 HTTP 请求中的头信息、队列中的消息或任何适合服务之间通信协议的机制来完成。

每个服务创建一个“跨度”，它捕获关于其在处理请求中角色的信息。这个跨度可能包括时间戳、服务名称、函数调用以及遇到的任何错误。

跨度是由一个中心追踪系统收集的，然后根据追踪 ID 将它们拼接在一起。这提供了一个对整个请求流的整体视图，包括所有涉及的服务。

分布式追踪的主要好处如下：

+   **增强的可观察性**：分布式追踪揭示了请求如何在您的系统中移动，揭示了潜在的瓶颈和低效。

+   **根本原因分析**：当发生错误时，追踪有助于确定负责该错误的确切服务或组件，即使错误在请求流中较晚出现。

+   **性能优化**：通过分析追踪数据，您可以识别缓慢的服务或服务之间的通信问题，从而实现性能优化努力。

+   **调试微服务**：有了分布式追踪提供的上下文，调试微服务之间的复杂交互变得显著更容易。

有多种开源和商业工具可用于实现分布式追踪。一些流行的选项包括 Zipkin、Jaeger、Honeycomb 和 Datadog。

但是，在没有对应用程序代码进行大量更改的情况下，在可观察性工具和后端提供商之间切换的自由在哪里呢？在本章的后面，我们将看到 OTel 项目正在试图填补的差距。

让我们继续通过遥测的下一个支柱——指标——来扩展我们的知识。

# 指标

没有什么能像在一种被设计成像在雨天看油漆干涸一样令人兴奋的语言中痴迷于性能数据那样，大声宣告“我已经成为了一名程序员”。但在这里，我们正准备进入 Go 度量标准的激动人心的世界，带着一种被镇静剂麻痹的树懒的热情。这是一次愉快的旅程，穿越了一个数字和图表的迷宫，你面对的弥诺陶洛斯是你的代码，以一种使量子物理学看起来简单的方式神秘地消耗资源。

现在，对于那些仍然与我同行、没有被即将到来的厄运的阴影所吓倒的勇敢者，让我们暂时认真一下。在 Go 的语境中，度量标准是理解您应用程序行为和性能的必要工具。它们提供了对系统各个方面的洞察，例如内存使用、CPU 负载和 goroutine 计数。Go 以其简约的魅力和并发模型，为系统程序员提供了大量机会在性能上“自食其果”。幸运的是，它还提供了内置和第三方库的“绷带”，旨在收集、报告和分析这些度量标准。例如，Go 运行时通过`runtime`和`net/http/pprof`包暴露了大量性能数据，允许程序员实时监控他们的应用程序。

更受欢迎的第三方库之一是 Prometheus，其 Go 客户端库提供了一套丰富的工具来定义和收集度量标准。它无缝集成到 Go 应用程序中，为监控不仅限于系统级度量标准，还包括有助于诊断性能瓶颈和理解用户行为的特定于应用程序的度量标准提供了强大的解决方案。

为了给您一个味觉，让我们考虑一个简单的示例，使用 Prometheus 在 Go 网络服务中收集 HTTP 请求计数：

```go
package main
import (
     "fmt"
     "net/http"
     "time"
     "github.com/prometheus/client_golang/prometheus"
     "github.com/prometheus/client_golang/prometheus/promhttp"
)
var (
     requestsProcessed = prometheus.NewCounterVec(
          prometheus.CounterOpts{
               Name: "http_requests_processed",
               Help: "Total number of processed HTTP requests.",
          },
          []string{"status_code"},
     )
)
func init() {
     // Register metrics with Prometheus
     prometheus.MustRegister(requestsProcessed)
}
func main() {
     http.Handle("/metrics", promhttp.Handler())
     http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
          time.Sleep(50 * time.Millisecond)
          code := http.StatusOK
          if time.Now().Unix()%2 == 0 {
               code = http.StatusInternalServerError
          }          requestsProcessed.WithLabelValues(fmt.Sprintf("%d", code)).Inc()
          w.WriteHeader(code)
          fmt.Fprintf(w, "Request processed.")
     })
     fmt.Println("Starting server on port 8080...")
     http.ListenAndServe(":8080", nil)
}
```

此代码片段使用`prometheus/client_golang`库与 Prometheus 交互。一个计数度量标准`http_requests_processed`用于跟踪 HTTP 请求的数量，按状态码标记。`/metrics`端点暴露了 Prometheus 抓取的度量标准。在 HTTP 处理程序内部，计数度量标准使用适当的状态码标记递增。

简单性

这是一个基本示例。现实世界中的应用程序将涉及更丰富的度量标准和仪表。

按照以下步骤运行我们的 Prometheus 服务器。

1.  创建一个 Prometheus 配置文件：

    +   创建一个新文件并命名为`prometheus.yml`

    +   将以下基本配置粘贴到文件中：

        ```go
        global:
          scrape_interval: 15s
        scrape_configs:
          - job_name: 'prometheus'
            static_configs:
              - targets: ['localhost:9090']
        ```

1.  拉取 Prometheus Docker 镜像：

    +   打开您的终端并运行以下命令以下载最新的 Prometheus Docker 镜像：

        ```go
        docker pull prom/prometheus
        ```

1.  运行 Prometheus 容器：

    +   使用以下命令运行 Prometheus，将`prometheus.yml`映射到容器：

        ```go
        docker run -p 9090:9090 -v <path_to_your_prometheus.yml>:/etc/prometheus/prometheus.yml prom/prometheus
        ```

    +   将`<path_to_your_prometheus.yml>`替换为您配置文件的实际路径。

1.  访问 Prometheus 网络界面：

    +   打开您的网络浏览器并转到`http://localhost:9090`。

    +   您现在应该看到 Prometheus 用户界面。

1.  探索 Prometheus：

    +   在表达式浏览器（点击`up`并点击**执行**。这应该会显示 Prometheus 本身是否正在运行。

    +   探索其他内置指标，尝试查询语言，并感受 Prometheus 的使用。

现在，我们可以执行我们的代码并查看指标。首先，我们需要保存代码并构建它：

```go
go build app.go && ./app
```

探索指标：

+   `http://localhost:8080/metrics`. 您应该看到原始的 Prometheus 指标输出。

+   `http://localhost:9090`），尝试以下查询：

    +   `http_requests_processed`: 查看按状态码分组的总请求数量

    +   `rate(http_requests_processed[1m])`: 查看过去一分钟的请求数量

我们现在可以看到我们的指标了，但我们能使用哪些指标，应该使用哪个指标呢？让我们来探讨这个问题！

## 我们应该使用哪个指标？

在您的应用程序中选择合适的指标类型进行监控，就像选择合适的工具来完成工作一样——用锤子敲钉子，而不是拧螺丝。在监控和可观察性的世界中，主要的指标类型——**计数器（Counter**）、**仪表（Gauge**）、**直方图（Histogram**）和**摘要（Summary**）——各自有不同的用途。理解这些用途对于有效地衡量和分析应用程序的行为和性能至关重要。

### 计数器

计数器是一种简单的指标，随着时间的推移只会增加（递增），并在重启时重置为零。它非常适合跟踪事件的发生。当您想计数事物时使用计数器，例如已服务的请求数、完成的任务数或发生的错误数。例如，统计用户在您的网站上执行特定动作的次数。

这里有一些用例：

+   **事件计数**：非常适合计数特定事件的次数。例如，您可以使用计数器来跟踪用户注册次数、完成任务数或遇到的错误数。

+   **速率测量**：尽管计数器本身只会增加，但您可以测量随时间增加的速率，这使得它适合了解事件发生的频率，例如每秒请求数。

### 仪表

仪表是一种表示单个数值的指标，该数值可以任意上下波动。它就像一个测量当前温度的温度计。

使用仪表（Gauge）来表示随时间波动的数据，例如当前内存使用量、并发会话数量或机器的温度。仪表非常适合监控那些在特定时间点的当前状态比变化速率更相关的资源。

这里有一些用例：

+   **资源水平**：仪表非常适合测量可以增加和减少的数量，例如当前内存使用量、剩余磁盘空间或活跃用户数量

+   **传感器读数**：任何随时间波动的实时测量值，例如温度传感器、CPU 负载或队列长度

### 直方图

直方图采样观察值（通常是请求持续时间或响应大小等），并在可配置的桶中进行计数。它还提供了所有观察值的总和。

当你需要了解一个指标的分布，而不仅仅是平均值时，请使用直方图。直方图非常适合跟踪应用程序中请求的延迟或响应的大小，因为它们不仅允许你看到平均值，还可以看到值的分布情况，例如第 95 个百分位数的延迟。

这里有一些用例：

+   **分布测量**：当需要捕捉指标值随时间变化的分布时，直方图表现卓越。这对于理解平均值、数据变异性和异常值至关重要。

+   **性能分析**：非常适合测量请求延迟或响应大小。直方图有助于识别可能不会对平均值产生太大影响但会显著影响用户体验的长尾延迟。

### 摘要

与直方图类似，摘要也会采样观察值。然而，它们计算滑动窗口的分位数（例如，第 50、90 和 99 个百分位数），而不是提供桶。由于它们在实时计算这些分位数，摘要可能比直方图计算量更大。

当你需要在一个滑动时间窗口中获取精确的分位数，尤其是对于长期准确性不如近期趋势重要的指标时，请使用摘要。它们在跟踪请求持续时间和响应大小时特别有用，因为它们可以动态地显示确切的分布。

这里有一些用例：

+   **动态分位数**：当你需要在滑动时间窗口中获取精确的分位数时，摘要是最优选择。它们提供了更详细的指标分布视图，并随着新数据的到来进行调整。

+   **近期趋势分析**：适用于近期性能比长期平均值更相关的场景，允许你快速响应模式的变化。

### 选择合适的指标

这个决策取决于你测量的是什么以及你打算如何使用这些数据：

+   计算发生次数？选择计数器（Counter）

+   测量增加和减少的值？仪表（Gauge）是你的朋友

+   需要理解分布？直方图在这里大放异彩

+   需要最近数据的动态分位数？摘要就是答案

记住，目标不仅仅是收集指标，而是从中提取可操作的见解。因此，选择正确的指标类型对于有效的监控和分析至关重要。这确保了你不仅仅是为了收集数据而收集数据，而是在收集可以真正提供关于应用程序性能和设计决策信息的信息。

想了解更多关于指标及其查询方法的信息，请参阅 Prometheus 文档（[`prometheus.io/docs/concepts/metric_types/`](https://prometheus.io/docs/concepts/metric_types/)）。

总之，Golang 中的指标就像是在潜艇上开始一场伟大的冒险。你身处水下，在代码的深暗海中，穿梭于性能的浑浊水域。你的指标就像声纳，对潜在问题进行探测，引导你穿越深渊，到达高效、可扩展软件的应许之地。记住，在系统编程的浩瀚海洋中，重要的是你的指标的力量，它为你规划成功的航线。

# OTel 项目

OTel 是一个开源的、供应商中立的 Cloud Native Computing Foundation（**CNCF**）下的项目。它提供了一套标准、API 和 SDK，用于仪器化、生成、收集和导出遥测数据。

这些数据包括跟踪（请求通过系统的流程）、指标（关于系统行为的测量）和日志（结构化事件记录）。此外，它旨在标准化应用程序的仪器化方式，使采用可观察性工具而无需供应商锁定变得更容易。

从成熟度的角度来看，Golang 是 OTel 内部主要支持的语言之一。基本上，它提供了一套全面的 SDK，包括以下库：

+   `go.opentelemetry.io/otel/trace`

+   `go.opentelemetry.io/otel/metric`

+   `go.opentelemetry.io/otel/propagation`

OTel 的 Go SDK 与流行的库和框架无缝集成，使您能够轻松地将仪器化添加到现有的 Golang 应用程序中。

此外，SDK 支持各种导出器，使您能够将您的遥测数据发送到不同的分析后端。可以在 OTel 网站上找到详尽的供应商列表（[`opentelemetry.io/ecosystem/vendors/`](https://opentelemetry.io/ecosystem/vendors/))。

采用 OTel 为 Go 项目带来的主要好处如下：

+   **供应商中立性**：你可以自由地在可观察性工具和后端提供商之间切换，而无需对应用程序的代码进行大量更改

+   **简化了仪器化**：OTel 使您更容易且不那么繁琐地对 Golang 服务进行仪器化

+   **统一的数据格式**：它提供了标准化的数据格式，确保您的跟踪和指标数据可以被多个平台和工具理解

+   **强大的社区**：Golang SDK 由一个活跃的社区支持，提供支持和持续改进

随着 OTel 获得更广泛的采用，它很可能会成为 Golang 应用程序中可观察性的事实标准。这种标准化通过促进供应商中立性、可移植性和更容易采用最佳实践，为整个生态系统带来好处。

# OTel

所以，你认为将 OTel 添加到你的程序就像拼接一些花哨的乐高积木一样，对吧？一点配置魔法，一点自动仪器化， voila – 瞬间可观察！好吧，让我们这么说，你朋友，你将大吃一惊。

现在，在您因挫败而扔掉键盘之前，让我们分析一下 OTel 是什么。把它想象成收集应用程序遥测数据的通用工具箱。OTel 反过来就像您应用程序的内心独白——其执行的跟踪、性能指标、日志以及其他内部工作的低语。OTel 让您能够将光线照进代码库最黑暗的角落，揭示事物变慢的地方、错误滋生的地方以及用户如何与您的创作互动。

日志尚未准备好

Go 语言的 Logs SDK 正在开发中，我们可以通过官方状态页面跟踪 SDK 的状态：[`opentelemetry.io/status/`](https://opentelemetry.io/status/)。因此，以下示例将使用 uber/zap 库进行日志记录。

OTel 本身是一套规范、API 和 SDK。它不会神奇地使您的应用程序可观察。您需要在代码中战略性地放置传感器（想想看它们就像高级探测器），这便是手动仪器化的“乐趣”所在，同时还需要决定最初要收集哪些数据。

让我们从头开始创建一个使用 Otel 的程序。以下步骤如下：

1.  **创建您的 Go 项目**：为您的项目创建一个新的目录并初始化一个 Go 模块：

    ```go
    mkdir telemetry-example
    cd telemetry-example
    go mod init telemetry-example
    ```

1.  **安装依赖项**：安装 OTel 和 zap 日志记录所需的必要包：

    ```go
    go get go.uber.org/zap
    go get go.opentelemetry.io/otel
    go get go.opentelemetry.io/otel/exporters/otlp/otlptrace
    go get go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp
    go get go.opentelemetry.io/otel/sdk/resource
    go get go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp
    go get go.opentelemetry.io/otel/semconv/v1.7.0
    ```

1.  在您的项目目录中的`main.go`文件。首先，让我们为高级日志记录设置 zap：

    ```go
    package main
    import (
        "go.uber.org/zap"
    )
    func main() {
        logger, _ := zap.NewProduction()
        defer logger.Sync() // Flushes buffer, if any
        sugar := logger.Sugar()
        sugar.Infow("This is an example log message", "location", "main", "type", "exampleLog")
    }
    ```

    此代码片段使用 zap 初始化了一个生产级别的日志记录器，它提供了结构化日志记录功能。

1.  **配置 OTel 跟踪**：接下来，将 OTel 跟踪添加到您的应用程序中，并将数据发送到 OTel 收集器：

    ```go
    import (
        "context"
        "net/http"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.7.0"
        "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    )
    func main() {
        // Previous Zap logger setup...
        ctx := context.Background()
        traceExporter, err := otlptrace.New(ctx, otlptracehttp.NewClient())
        if err != nil {
            sugar.Fatal("failed to create trace exporter: ", err)
        }
        tp := sdktrace.NewTracerProvider(
            sdktrace.WithBatcher(traceExporter),
            sdktrace.WithResource(resource.NewWithAttributes(
                semconv.SchemaURL,
                semconv.ServiceNameKey.String("ExampleService"),
            )),
        )
        otel.SetTracerProvider(tp)
    }
    ```

    本节添加了配置为通过**OTel** **协议**（**OTLP**）导出跟踪数据的跟踪。

1.  **添加一个示例 HTTP 处理器**：为了演示，添加一个简单的 HTTP 处理器，它会为每个请求发出跟踪和日志：

    ```go
    func exampleHandler(w http.ResponseWriter, r *http.Request) {
        _, span := otel.Tracer("example-tracer").Start(r.Context(), "handleRequest")
        defer span.End()
        zap.L().Info("Handling request")
        w.Write([]byte("Hello, World!"))
    }
    func main() {
        // Previous setup...
        http.Handle("/", otelhttp.NewHandler(http.HandlerFunc(exampleHandler), "Example"))
        sugar.Fatal(http.ListenAndServe(":8080", nil))
    }
    ```

1.  在终端中，使用`docker-compose`与位于`ch11/otel/`目录中的文件：

    ```go
    docker-compose up
    ```

    收集器应设置为在默认的 OTLP 端口接收跟踪，并将它们路由到您的跟踪后端。

    运行您的应用程序：

    ```go
    go run main.go
    ```

1.  使用浏览器或`curl`从`http://localhost:8080/`)访问：

    ```go
    curl http://localhost:8080/
    ```

    *Voilà*！我们创建了一个利用 OTel 无锁定特性的应用程序！

在我那个时代，我们使用打印语句和偶尔的恐慌咒骂来调试系统。OTel 是一种更为文明的方法。把它想象成在您的代码中建立自己的复杂情报网络。他们将会报告每一个细节，让您能够更快地定位问题，有时甚至可以在它们造成破坏之前。

这难道不是比传统的调试战斗更好吗？现在，是时候总结一下了。

# 摘要

随着本章关于 Go 中遥测的结束，我们已探索了照亮 Go 应用内部机制的基本实践和工具，增强了它们的可观察性。这次探索从对日志的深入分析开始，我们学会了超越基本的日志消息，采用结构化日志以提高其清晰度和易于分析性。然后，我们进入了复杂但至关重要的跟踪领域，揭示了应用程序的复杂执行路径，以识别和解决性能瓶颈。此外，我们还涉足了度量领域，定量数据测量使我们能够监控和调整应用程序以实现最佳性能。最后，我们结合了所有知识，在一个无供应商解决方案中，由 OTel 支持这些知识。

在下一章中，我们将开始探讨如何分发我们的应用程序。
