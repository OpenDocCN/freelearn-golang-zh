# 15

# 保持系统编程的敏锐度

本章将通过探索采用 Go 最著名的项目和公司的历史来结束我们的学习之旅。你还将接触到学习系统编程和保持与这个社区同步的最具代表性的资料。

本章将涵盖以下关键主题：

+   真实世界的应用

+   在系统编程领域中导航

+   持续学习的资源

到本章结束时，你将学会如何继续提升你的系统编程知识和其生态系统。

# 真实世界的应用

真正掌握 Go 在系统编程中的力量，最好的方式是看到它在野外的应用。让我们探索 Go 成功应用于构建稳健和高效系统的真实世界案例。

## Dropbox 的冒险尝试

“Python 适合一切，对吧？”啊，这是天真乐观的甜美声音。你知道——那种你会在你的单体 Python 代码库发生灾难性性能瓶颈之前听到的声音。但嘿，至少它写起来很快；我说的对吗？

你知道，从 Python 迁移到 Go 有点像用一辆 F1 赛车替换滑板。当然——两者都能让你从 A 点到 B 点，但一个做得更快更精确。而且说实话，谁不喜欢引擎轰鸣的刺激，尤其是当这意味着你的云存储服务可以处理数百万并发用户时？

Dropbox，这个备受喜爱的云存储巨头，发现自己陷入了类似的困境。他们的 Python 后端，虽然在早期很方便，但随着自身成功的增加，开始显得力不从心。正是在这个时候，他们做出了大胆的决定，用 Go 重写了后端的一部分。它速度快，效率高，并且有一个让可扩展性变得像玩儿一样简单的并发模型。好吧，可能不是像玩儿一样简单，但肯定比 Python 的线程模型更容易管理。

Dropbox 面临的一个主要挑战是处理大量的并发请求。使用 Python，这通常意味着为每个请求创建一个新的线程，这很快就会变成资源消耗者。然而，Go 使用 goroutines，它们更轻量级，创建成本更低。这使得 Dropbox 能够轻松扩展其后端，无需费劲就能处理数百万并发用户。

没有人能比 Dropbox 团队自己更好地讲述这个故事了。你可以在*Go at Dropbox*的演讲中看到更多细节（[`www.youtube.com/watch?v=JOx9enktnUM`](https://www.youtube.com/watch?v=JOx9enktnUM))。

## HashiCorp——从第一天开始使用 Go

基础设施即代码？更像是基础设施即一团乱麻。这是你在与复杂的配置管理工具搏斗的 DevOps 工程师中会听到的那种沮丧的叹息。但别担心，因为基础设施自动化的巫师 HashiCorp 有一个解决方案，就像一个润滑良好的 Kubernetes 集群一样顺畅。

想象一下，只用胶带和牙签来建造房子。这可能可行，但会显得脆弱、不稳定，容易倒塌。这就是传统基础设施管理可能给人的感觉。然而，HashiCorp 提供了一种不同的方法，这种方法基于代码、自动化和 Go 的力量。

HashiCorp，Terraform、Vault 和 Consul 等工具的创造者，在早期就做出了战略决策，将 Go 作为他们的主要编程语言。这并非一时冲动；这是一个经过深思熟虑的举动，与他们对更高效、可靠和可扩展的基础设施管理方法的愿景相一致。

在与 HashiCorp 的开发者 Nic Jackson 的访谈中，他讨论了为什么他们决定将 Go 作为产品的主要编程语言。

以下是 HashiCorp 决定使用 Go 的一些原因：

+   它简单易学，这使得开发者更容易开始并提高生产力。

+   对于构建小型、简洁的应用程序来说，这是一个不错的选择。HashiCorp 构建了许多微服务，这些微服务是小型、自包含的服务，它们可以协同工作。

+   它有一个丰富的标准库，这意味着 HashiCorp 需要的许多功能已经内置到语言中。这使得用 Go 编写程序变得更加容易。

+   它非常适合构建高度分布式的系统。HashiCorp 的产品设计用于在分布式环境中使用，Go 的并发模型使得编写可以在多台机器上运行的代码变得容易。

您可以在以下链接中完整查看访谈：[`youtu.be/qlwp0mHFLHU`](https://youtu.be/qlwp0mHFLHU)

## Grafana Labs – 使用 Go 可视化成功

在监控和可观察性的生态系统中，Grafana Labs 已经崛起为一股主导力量，帮助组织深入了解其复杂的系统。虽然 Grafana，他们的旗舰可视化平台，主要是一个前端应用程序，但公司的后端基础设施和众多支持工具都是建立在 Go 的基础之上。这个战略选择在他们的监控和可观察性解决方案的高性能、可扩展和可靠性方面发挥了关键作用。

现代系统会产生大量的数据，从指标和日志到跟踪。Grafana Labs 意识到需要一个能够高效地摄取、处理和存储这些数据的后端基础设施。Go 的固有性能优势，源于其编译特性和高效的并发模型，使其成为处理监控和可观察性需求繁重的工作负载的理想选择。

Grafana Labs 利用 Go 的 goroutines 和 channels 创建高度并发和高效的后端服务。轻量级的 goroutines 允许它们处理大量的并发操作，如数据摄取和查询处理，而无需传统线程的开销。channels 促进了 goroutines 之间的无缝通信和同步，确保数据完整性和高效资源利用。

除了 Grafana，Grafana Labs 还开发了一系列依赖 Go 能力的工具和组件。Loki，他们的日志聚合系统，利用 Go 高效的 I/O 处理和压缩算法来摄取和存储大量的日志数据。Tempo，他们的分布式跟踪后端，利用 Go 的网络能力实现跟踪代理和中央 Tempo 服务器之间的无缝通信。

他们定义了使用 Go 的主要优势：

+   **速度**：Go 运行速度快，虽然不如精心编写的 C 程序快，但它与 C 相比允许更快的开发。它在执行速度方面显著优于 Perl 或 Ruby 等语言。

+   **简化部署**：Go 创建的静态二进制文件部署起来非常简单。

+   **平衡的自由度**：Go 提供了相当大的灵活性，避免了不必要的复杂指针算术的诱惑，促进了简单而有效的编码实践。

+   **跨平台兼容性**：Go 支持在包括 Linux、Solaris、macOS、Windows 以及不同架构（如 amd64、i686 或 arm）上的 BSDs 等各个平台上构建应用程序。根据使用的库，甚至可能支持像 plan9 这样的不太为人所知的系统。对于非常不常见的平台，gccgo 可能提供一种可行的解决方案。

+   **编程的易用性**：Go 通过其强大而优雅的语法简化了后端和系统编程。

+   **性能分析工具**：Go 中的性能分析功能，如 CPU 和堆分析，强大且有价值。Go 1.5 中添加的跟踪分析特别有益。

+   **内置并发**：并发是 Go 的一个基本组成部分，这使得它易于管理和有效使用。

+   **强大的接口**：尽管 Go 的接口可能需要一些学习，但一旦掌握，它们就变得不可或缺。

在*Where and Why We Use Go*博客文章中，有关于 Grafana Labs 中 Go 使用情况的全面分析（[`grafana.com/blog/2015/08/21/where-and-why-we-use-go/`](https://grafana.com/blog/2015/08/21/where-and-why-we-use-go/))。

## Docker – 使用 Go 构建容器革命

Docker，这个通过其容器技术革新了软件开发和部署的平台，其成功很大程度上归功于一个相当不寻常的选择：Go。虽然像 Java 或 C++这样的成熟语言在构建如此复杂的系统时可能看起来更为明显，但 Docker 的创始人认识到 Go 为他们的雄心勃勃项目提供的独特优势。

在其核心，Docker 关注的是轻量级隔离和可移植性。Go 的简约语法和编译特性与这一理念完美契合。Go 的快速编译时间和能够生成静态链接的二进制文件简化了开发过程，并确保了在不同环境中的行为一致性，这使得打包和分发 Docker 容器变得更加容易。

Docker 的设计高度依赖于并发来同时管理多个容器。Go 的 goroutines 和 channels 提供了一个轻量级且高效的并发模型，使得 Docker 能够以最小的开销处理许多并发操作。这对于构建一个可扩展且响应迅速的平台至关重要，该平台能够高效地管理容器化应用程序。

Docker 的一个关键优势是其能够在各种平台上运行，从 Linux 到 Windows 再到 macOS。Go 的跨平台兼容性简化了开发过程，因为开发者可以编写一次代码，然后为不同的架构编译，而无需进行重大修改。这使得 Docker 能够迅速扩大其影响力，成为容器化的实际标准。

尽管 Go 在 Docker 创建时相对较新，但其不断增长的社区和快速发展的生态系统为构建复杂系统提供了必要的库和工具。Docker 团队积极为 Go 社区做出贡献，开发了如`libcontainer`等开源库，用于低级容器管理，进一步巩固了 Go 在容器生态系统中的地位。

回顾过去，Docker 决定拥抱 Go 似乎几乎是先知般的。Go 的独特优势与容器化的需求完美契合，使得 Docker 团队能够构建一个强大、高效且可移植的平台，从而改变了软件开发和部署的方式。虽然其他语言可能也足够用，但 Go 的简单性、性能、并发性和跨平台兼容性的结合，证明了它是构建容器革命的完美配方。

用 Go 编写的成功应用程序列表还在继续。为了更清楚地了解这一点，Golang 在**云原生计算基金会**（**CNCF**）中占据了主导地位。大多数云原生应用程序都是用 Go 编写的。

您可以浏览所有这些项目，请访问[`www.cncf.io/`](https://www.cncf.io/)。

## SoundCloud – 从 Ruby 到 Go

SoundCloud 最初使用 Ruby on Rails 构建了他们的平台，他们亲切地称之为“母舰”。这个单体应用程序处理了他们的公共 API，这些 API 被他们的客户端应用程序和数千个第三方应用程序使用，以及面向用户的 Web 应用程序。随着平台的增长，他们面临的复杂性和规模挑战也随之增加。随着数百万用户和每分钟大量音乐上传，单体架构的局限性变得越来越明显。

为了解决可扩展性问题，SoundCloud 决定过渡到微服务架构。这种方法允许他们将领域逻辑分解成更小、独立的微服务，每个微服务都有自己的明确定义的 API。微服务架构提供了更大的灵活性并提高了可扩展性，但也引入了新的挑战，例如管理服务间的通信和确保数据处理的一致性。

SoundCloud 的工程团队评估了多种编程语言以支持他们新的微服务架构。选择 Go 语言有几个关键原因：

+   **性能和并发性**：Go 语言高效的并发模型，由 goroutines 驱动，使得 SoundCloud 能够处理大量的并发连接，这对于他们高流量的平台至关重要。

+   **简洁性和可读性**：Go 语言简洁和极简主义的设计哲学使得工程师更容易理解和维护代码。该语言的**所见即所得**（WYSIWYG）特性帮助新工程师快速成为生产力，减少了从入职到做出有意义的贡献的时间。

+   **快速编译和部署**：Go 语言的快速编译时间和静态类型促进了开发过程中的快速迭代。这使得 SoundCloud 能够快速开发、测试和部署新功能，提高了他们的整体开发速度。

+   **社区和生态系统**：Go 库和工具不断增长的生态系统以及活跃的社区为 SoundCloud 提供了构建稳健应用程序所需资源和支持。

SoundCloud 逐步将服务迁移到 Go 语言，从非关键组件开始以最小化风险。他们开发了几个内部工具和库来支持新的架构，包括他们的部署平台 Bazooka。这种分阶段的方法允许他们逐步重构单体，而不影响现有服务。

向 Go 语言的过渡导致了系统性能和可靠性的显著提升。通过利用 Go 语言的并发特性，SoundCloud 可以用更少的资源处理更高的负载，从而降低服务器成本。Go 语言的语法和结构的简洁性也使得代码审查更加专注于问题域，而不是语言复杂性，增强了开发者之间的协作和生产力。

随着 SoundCloud 平台的增长，他们迁移到 Go 语言是由对更好性能、可扩展性和可维护性的需求驱动的。通过采用 Go 语言和微服务架构，他们成功地克服了单体 Ruby on Rails 应用程序的局限性，为未来的增长和创新奠定了坚实的基础。

# 探索系统编程领域

系统编程的世界不断在演变。为了保持技能的专业性，了解最新的发展至关重要。

## Go 发布说明和博客

严格遵守 Go 的发布说明。每个新版本通常都会为系统编程带来特定的增强，例如改进的内存管理或运行时优化。

官方的 Go 博客是了解与 Go 编程语言相关的最新新闻、公告和更新的绝佳资源。您可以在[`blog.golang.org/`](https://blog.golang.org/)找到它。

## 社区

虽然听起来有些过时，但加入如`golang-nuts`和`golang-dev`之类的邮件列表，可以让你了解 Go 社区中的讨论、公告和发展情况。

不论争议如何，关注有影响力的 Go 开发者、与 Go 相关的账户和标签，如 X 上的`#golang`，可以提供实时更新、讨论以及有趣的文章和资源的链接。

此外，参与在线论坛（如 Go 的 subreddit），Slack 频道和会议（如*GopherCon*）。与其他 Go 开发者互动，从他们的经验中学习，并分享你的知识。

## 贡献

我强烈建议你关注 GitHub 上与 Go 编程语言相关的仓库，特别是官方 Go 仓库和流行的 Go 库和框架，这可以让你了解正在进行的发展、问题和拉取请求。当你感到自信时，为开源 Go 项目做出贡献是学习和回馈社区的一种极好方式。

*提示*：从较小的贡献或错误修复开始，逐渐承担更具挑战性的任务。

## 实验

当新的 Go 功能和库可用时，不要犹豫去尝试它们。实际操作经验对于理解它们在你的项目中的潜力至关重要。

# 持续学习的资源

你的 Go 系统编程之旅不会就此结束。以下资源将帮助你扩展你的知识和技能。

系统编程更注重深化你对计算机系统基本层的理解，而不是追逐最新的技术或框架。这听起来可能有些反直觉，但目标是掌握核心原则，而不仅仅是跟上最新趋势。通过深入了解操作系统、硬件和系统库之间的交互，你将能够编写更高效和可靠的代码。

这个领域需要深入了解低级编程语言，如 C 和有时是汇编语言，因为这些语言提供了直接操作硬件所需的精细控制。系统程序员通常从事开发或修改操作系统、驱动程序、嵌入式系统和性能关键型应用程序的工作。他们需要了解内存管理、进程调度和文件系统实现等核心组件。

此外，系统编程强调对计算机架构的深入理解，包括 CPU 操作、缓存机制和 I/O 过程。这种知识使你能够优化软件，使其在目标硬件上高效运行，这对于性能和资源利用至关重要的应用程序至关重要。

系统编程的另一个方面是其稳定性和持久性。与可能随着新技术出现而变得过时的高级框架和库不同，系统编程的基本概念保持不变。掌握这些原则提供了一个坚实的基石，可以应用于各种技术和平台，确保在计算机科学这个不断发展的领域中具有长期的相关性。

我有一些书推荐给你，但与近期出版物相比，它们可能被认为是经典之作。

## 《UNIX 环境高级编程》由 W. Richard Stevens 著

通常被称为*APUE*，这本书是 Unix 系统编程的详细研究，涵盖了 Unix 操作系统的所有方面和系统编程的基础。它作为理解 Unix 系统工作原理的必备参考书，深入探讨了诸如文件 I/O、进程控制、信号处理和**进程间通信**（**IPC**）等主题。这本书以其清晰的解释和实用的例子而闻名，使复杂的概念对新手和经验丰富的程序员都易于理解。它还强调最佳实践和健壮的编程技术，为读者提供了开发可靠和高效 Unix 应用程序所需的技能。凭借其全面覆盖和权威见解，APUE 是任何严肃 Unix 程序员图书馆的基石。

## 《学习 C 编程 - 第二版：轻松掌握最强大、最通用的编程语言入门指南》

在系统编程中，你不可避免地会接触到一些 C 代码。在这种情况下，我建议选择平稳的骑行而不是山地自行车比赛。这本书就像是你的编程自行车上的辅助轮。它握住你的手，擦干你的眼泪，并温柔地引导你进入寒冷、残酷的 C 语言世界。

作者将 C 语言的混乱提炼成你可以理解的东西。这几乎就像魔法，但不够刺激。每一章都给你一些例子去咀嚼，确保你不会只是茫然地看着屏幕，不知道出了什么问题。这本书不会直接把你扔进深水区。相反，它一步一步地引导你走下楼梯，进入浅水区。

这不是你爷爷的 C 编程书。它包含了所有现代内容，让你看起来不会像古董。当你以为你已经掌握了它时，这本书会加入练习来提醒你，你还没有。这让你保持谦逊。

如果你是个新手或者只是需要刷新你的 C 语言技能，这本书为你提供了全面的覆盖。作者们使内容简单，但又不至于让你感到被轻视。就像是他们知道你很聪明，但可能有些迷茫。这是一项罕见的天赋。

这是你进入 C 语言狂野世界的首选指南。它直接、实用，并且略带轻视，让你想：也许我真的可以做到这一点。

## 《Linux 内核编程 - 第二版》：一本全面且实用的内核内部结构、编写模块和内核同步指南

所以，你已经决定挑战 Linux 内核。这是一个大胆的决定。拿起《Linux 内核编程 - 第二版》就像是穿上登山靴准备穿越喜马拉雅山脉。这是一片艰难的领域，但有了正确的指南，你将到达顶峰。

这本书的作者擅长使内核内部的迷宫看起来几乎可以导航。他们将复杂性分解成小块，使内核开发的浩瀚世界感觉不那么像火箭科学。而且他们不仅仅提供干燥的理论。哦不——他们给你提供实用的例子，就像面包屑一样，引导你穿过代码的密集森林。

这本书不仅仅把你扔进深水区让你自己挣扎。它带你一步步地走，从理解内核内部结构到编写模块和处理同步。这是一次有系统的旅程，确保你在旅途中不会迷失方向。而且它并不停留在过去。内容是更新、现代且相关的，所以你学习的是内核编程的最新和最优秀的内容。

当你开始感到自信时，这本书会给你带来练习和挑战，让你意识到还有许多东西需要学习。这些不仅仅是忙碌的工作——它们旨在让你批判性地思考并深化你的理解。

不论你是新手还是想要磨练你的内核技能，这本书都是你可靠的指南。作者们找到了完美的平衡点，简化了复杂的内容，但又不至于使内容变得肤浅。他们知道你很聪明，但可能在这个令人畏惧的领域中需要一点点的引导。

总结来说，这本书内容全面、实用且具有挑战性。如果你对掌握内核编程认真负责，这本书就是你的成功之路。

## 《Linux 系统编程技巧》：使用专家技巧和技巧成为熟练的 Linux 系统程序员

将这本书视为你的导师，准备好用一丝严厉的爱来传授 Linux 圣贤的智慧。

这本书充满了实用的技巧。这些技巧与那些普通的、按步骤操作的技巧不同。它们更像是代代相传的家族秘方，旨在为你提供基本技能和深入理解。每个例子都经过精心设计，旨在展示如何做某事以及为什么这样做是有效的。

你会欣赏这种实用方法。作者们不仅告诉你该做什么，还展示了如何像系统程序员一样思考。挑战和练习是魔法发生的地方。它们推动你应用你的知识，进行批判性思考，并解决实际问题。这就像有一个严厉但支持你的教练，他知道你有能力做到。

这本书是对洞察力、实用性和挑战性学习的最好证明。它提供了专家级的食谱和技术，将推动你的技能达到新的高度，激励你追求持续改进。

## 《操作系统：设计与实现》作者：安德鲁·S·坦南鲍姆

这本书常用于学术环境，为操作系统的理论和实践方面提供了坚实的基础。坦南鲍姆的方法包括使用他专门为教育目的开发的真实操作系统 MINIX 进行运行示例。本书涵盖了理解操作系统所必需的广泛主题，如进程管理、内存管理、文件系统、I/O 系统和安全性。

本书的一个显著特点是其实践方法。通过整合 MINIX，坦南鲍姆让读者能够探索和修改一个真实的工作操作系统。这种实践经验对于深入理解理论概念如何在现实世界系统中应用是极其宝贵的。文本还包括对操作系统原理的全面解释，辅以详细的图表和代码示例，展示了操作系统组件的内部工作原理。

《操作系统：设计与实现》结构旨在促进学习和教学，使其在学生和教育工作者中都非常受欢迎。坦南鲍姆清晰而引人入胜的写作风格，加上他在该领域的丰富经验，确保了复杂思想以易于理解的方式呈现。对于希望从理论和实践两个角度全面了解操作系统的人来说，这本书是必不可少的资源。

## 《Unix 网络编程》作者：W.理查德·斯蒂文斯

这是由斯蒂文斯创作的另一部经典之作，深入探讨了 Unix 环境下的网络编程细节。对于在 Unix 环境下使用网络应用程序的任何人来说，这本书都是必不可少的。本书提供了开发健壮和高效网络软件所需的概念、协议和技术全面指南。它涵盖了广泛的主题，包括套接字、TCP/IP、UDP、原始套接字和多播通信。

斯蒂文斯的详细且系统化的方法确保读者不仅能学习网络协议背后的理论，还能通过大量的示例和代码片段获得实际技能。本书针对网络编程中的常见挑战进行了探讨，例如错误处理、性能优化和可扩展性。它还探讨了高级主题，如非阻塞 I/O、信号驱动 I/O 以及使用 select 和 poll 进行多路复用。

《Unix 网络编程》被广泛认为是该主题的权威资源，以其清晰性、深度和实用性而闻名。通过遵循提供的指导和示例，读者可以深入理解网络编程原则，并将其应用于创建高效、可靠和高性能的网络应用程序。无论你是想学习基础的初学者，还是寻求提高技能的有经验的程序员，这本书都是 Unix 网络编程领域的不可或缺的参考书。

## 《Linux 系统编程技术：使用专家秘籍和技术成为熟练的 Linux 系统程序员》

准备揭开 Linux 系统编程的神秘面纱？《Linux 系统编程技术》是你掌握使用自己的程序扩展 Linux 操作系统的艺术的不二指南。这本书就像一个大师班，充满了实用的示例和专家秘籍，将使你成为一名熟练的 Linux 系统程序员。

作者从 Linux 文件系统和其基本命令开始，引导你了解内置的 man 页、**GNU 编译器集合**（**GCC**）和基本 Linux 系统调用。你不仅将学习如何编写程序，还将学会如何像专业人士一样处理错误，捕捉它们并打印相关信息。

本书提供了许多关于使用流和文件描述符读写文件的秘籍。你将亲身体验分叉、创建僵尸进程以及使用`systemd`管理守护进程。在你认为一切尽在掌握之中时，作者们将向你介绍创建共享库和 IPC 的微妙之处。

随着你不断进步，你将深入 POSIX 线程的世界，学习如何编写健壮的多线程程序。本书详细介绍了使用**GNU 调试器**（**GDB**）和 Valgrind 调试程序，确保你拥有所有必要的工具来消除那些讨厌的虫子。

到此旅程结束时，你将能够为 Linux 开发自己的系统程序，包括守护进程、工具、客户端和过滤器。本书承诺加深你对 Linux 系统编程的理解，使程序与 Linux 操作系统无缝集成。

你将发现如何使用各种系统调用编写程序，并深入了解 POSIX 函数。本书涵盖了诸如信号、管道、IPC 和进程管理等关键概念，为你提供了应对任何 Linux 系统编程挑战的全面工具包。本书还详细探讨了高级主题，如文件系统操作、创建共享库以及调试你的程序。

对于想要为 Linux 开发系统程序并深入了解操作系统的任何人来说，这是一本完美的书籍。无论你是在面对 Linux 系统编程的特定部分的问题，还是在寻找特定的食谱和解决方案，这本书都能满足你的需求。

## 《精通嵌入式 Linux 编程》- 第三版：使用 Linux 5.4 和 Yocto 项目 3.1（Dunfell）创建快速可靠的嵌入式解决方案

这是你的 Linux 5.4 和 Yocto 项目 3.1（Dunfell）创建多功能和稳健嵌入式解决方案的终极指南。对于任何认真从事嵌入式 Linux 开发的人来说，这本书就像是一个大师工具包，从基础知识到 Linux 的尖端特性。

作者首先从分解嵌入式 Linux 项目的核心元素开始：工具链、引导加载程序、内核和根文件系统。你将学习从头创建每个组件，并使用 Buildroot 和 Yocto 项目自动化这个过程。随着你的进步，本书将指导你实施有效的闪存存储策略，并在设备部署后远程更新你的设备。这不仅仅是让事情工作，而是让它们高效且安全地工作。

你将深入探索为嵌入式 Linux 编写代码的细节，从直接从你的应用程序访问硬件到多线程编程的复杂性以及高效的内存管理。最后几章致力于调试和性能分析，确保你拥有所有工具来定位性能瓶颈并优化你的系统。

在这次旅程结束时，你将能够使用 Linux 创建高效且安全的嵌入式设备。无论你是在处理智能电视、Wi-Fi 路由器、工业控制器或其他任何物联网设备，这本书都涵盖了所有内容。

你将学习如何使用 Buildroot 和 Yocto 项目创建嵌入式 Linux 系统，排查 BitBake 构建失败的问题，并简化你的 Yocto 开发工作流程。本书还涵盖了使用 Mender 或 Balena 等工具为物联网设备进行安全更新的内容。本书还详细介绍了原型外围设备添加、无需内核设备驱动程序与硬件交互、使用 BusyBox `runit` 将系统划分为受监督服务以及使用 GDB 进行远程调试等内容。本书还解释了性能测量工具，如 `perf`、`ftrace`、eBPF 和 Callgrind，以帮助你优化系统。

如果你是一名系统软件工程师或系统管理员，希望掌握嵌入式设备上的 Linux 实现，这本书适合你。它也适用于从低功耗微控制器过渡到高速芯片上运行的 Linux 系统的嵌入式系统工程师。任何需要开发需要运行 Linux 的新硬件的人都会发现这本书非常有价值。假设读者具备对 POSIX 标准、C 编程和 shell 脚本的基本了解，这使得这本书既易于接近又内容全面。

## 《现代操作系统》由安德鲁·S·坦能鲍姆著

此外，坦能鲍姆的书籍全面审视了现代计算机使用的操作系统，重点关注它们的操作机制和设计原则。本书全面审视了现代计算机使用的操作系统，重点关注它们的操作机制和设计原则。文本涵盖了理解当代操作系统如何运行的关键主题，包括进程和线程管理、内存管理、文件系统、I/O 系统和安全。

坦能鲍姆清晰而引人入胜的写作风格，结合他简化复杂概念的能力，使得这本书既适合学生也适合专业人士阅读。这本书以其详尽的解释和良好的组织结构而闻名，是学术课程和自学的好资源。它包括了许多流行操作系统的案例研究，如 Windows、Linux 和 Unix，提供了讨论原则的现实世界例子。

*现代操作系统* 还深入探讨了高级主题，例如分布式系统、多媒体系统和实时操作系统，反映了该领域的最新发展和趋势。每章末尾包含的实际例子、练习和复习问题有助于巩固学习，并提供对材料的实际操作经验。

对于任何希望理解现代操作系统的复杂性和其设计的人来说，这本书是必读的。它不仅提供了一个坚实的理论基础，还提供了对实际实施的见解，使其成为有抱负的和经验丰富的系统程序员的宝贵资源。

## 《UNIX 编程艺术》由埃里克·S·雷蒙德著

本书探讨了 Unix 编程的哲学和实践，展示了一套 Unix 多年来积累的设计规范和哲学。雷蒙德深入探讨了 Unix 文化及其对简洁、清晰和模块化的重视，这些都塑造了 Unix 系统和软件的发展。

本书分为三部分：基本原理、设计模式和案例研究。在第一部分，Raymond 讨论了 Unix 编程的基础原则，例如构建小型、可重用组件的重要性，基于文本的数据流的强大功能，以及对开源软件（OSS）的偏好。这些原则帮助读者理解指导 Unix 开发的核心理念。

第二部分涵盖了设计模式，Raymond 解释了在 Unix 编程中使用的常见模式和最佳实践。本节提供了如何构建程序、管理资源以及有效处理错误的见解。通过理解这些模式，程序员可以创建更易于维护和健壮的软件。

第三部分包括成功 Unix 程序案例研究，提供了原则和模式在实际应用中的实用示例。这些案例研究展示了经验丰富的 Unix 程序员如何解决问题和进行软件设计，为读者提供了宝贵的经验教训。

《UNIX 编程艺术》不仅是一本技术手册，也是对 Unix 文化和哲学方面的反思。Raymond 引人入胜的写作风格和深思熟虑的评论使它成为任何对 Unix 思维方式感兴趣的人的必读之作。无论你是新手程序员还是经验丰富的开发者，这本书都能让你对 Unix 传统及其对软件开发持久影响的欣赏更加深刻。

导师制

将导师视为你最后但同样重要的步骤。向经验丰富的 Go 开发者或导师寻求指导，他们可以在系统编程的背景下提供有价值的见解和建议。

# 你的系统编程之旅

多么一段旅程，不是吗？感谢你一直陪伴我走到这里。我希望你通过系统编程的视角对创建 Go 应用程序有了新的认识。

记住——Go 不仅仅是一种编程语言；它是通往系统开发世界中各种可能性的大门。通过拥抱持续学习，与社区保持互动，并将你的技能应用于现实世界的问题，你将准备好构建明天的高性能、可靠和可扩展的系统。

让这本书成为你的基石，愿你在 Go 驱动的系统编程之旅中充满成功和创新！

再见！

# 附录

# 硬件自动化

在本章中，你将了解硬件自动化，特别是关注与物理硬件设备（如可穿戴设备和闪存盘）的交互。本章探讨了程序如何响应 USB 和蓝牙设备触发的事件，以及构建自动化文件组织在闪存盘上的程序或对可穿戴设备距离做出反应的过程。

本章的目标是让你具备创建基于硬件事件自动执行任务的程序的知识和技能。

对于任何对硬件交互感兴趣的程序员来说，这些信息至关重要。在现实世界的背景下，随着这类设备的使用越来越普遍，了解如何使用硬件设备自动化任务变得越来越重要。这些知识可以导致数字资源的更有效和高效的管理，提高生产力，并为常见问题提供实际解决方案。

在本章中，我们将涵盖以下主要内容：

+   USB

+   蓝牙

+   XDG 和 freedesktop.org

# 系统编程中的自动化

自动化主要集中在物理硬件设备之间的交互以及基于这些设备状态或状态变化的任务自动化。这与软件自动化不同，软件自动化侧重于在软件环境中自动化数字过程和任务。

编程自动化就像牧猫。现在想象一下，每只猫都变成了一行代码，而牧猫的人戴着被称为“传统编程方法”的蒙眼布。在 Go 社区中，Go 就像一个高功率激光笔。突然，那些猫，或者说那些代码，整齐地排列起来，准备以同步游泳队的优雅姿态听从你的每一个命令。这就是 Go 的库生态系统的魔力——将曾经混乱的猫马戏团变成了一场精心编排的字节和数据流芭蕾舞。

能够编写简洁、高效的代码，直接与硬件接口，不仅是一大福音，而且是我们处理自动化任务方式的一次革命。无论是管理 USB 设备的数据还是处理蓝牙连接，Go 生态系统提供了充满活力的社区驱动的库，使这些任务变得可管理且异常简单。

因此，系好安全带，将物理世界与系统编程联系起来！本章探讨了两个日常使用的硬件设备：可穿戴设备和闪存盘。

# USB

在本节中，我们将探讨一个程序如何响应由 USB 设备触发的事件。有了这些知识，当特定的 USB 设备被插入时，我们可以采取几种行动——例如，自动启动备份过程，启动应用程序或执行自定义脚本。

## 应用程序

我喜欢保持我的文件井井有条，但每次我把我的闪存盘借给朋友时，他们总是把所有文件都放在根目录中，没有任何组织。现在，我有一个杂乱无章的存储设备和一段不稳定的友谊。想象一下（糟糕一百倍）根目录看起来如下：

```go
.
├── music_2.wav
├── picture_10.png
├── Book_2009.pdf
├── Manual_1.pdf
└── Manual_2.pdf
```

为了让我和朋友之间的关系保持融洽，我创建了一个程序来自动化我的闪存盘中的组织。

### 快速回顾

**通用串行总线**（通常称为**USB**），不仅仅是你的电脑或设备上的一个电缆和一个端口。它是一个全面的标准，定义了连接、通信和电源供应的电缆、连接器和通信协议，用于计算机、外围设备和其他计算机之间的连接、通信和电源供应。

USB 已经历了几次版本迭代，提供了速度、电源传输和功能改进。USB 的关键特性包括以下内容：

+   **即插即用**：设备可以在不重启系统的情况下连接和断开。

+   **电源供应**：USB 可以为连接的设备供电，消除了某些外围设备需要单独电源的需求

+   **数据传输**：USB 在设备和计算机之间传输数据

### U 盘

U 盘、闪存盘或 USB 棒是一种使用闪存并通过 USB 接口连接到计算机或其他设备的便携式存储设备。U 盘用于存储、传输和备份数据。它们因其尺寸、耐用性和速度而受到重视，尤其是与老式的便携式存储媒体（如软盘和 CD-ROM）相比。

让我与你分享构建这类程序的过程。首先，我们应该考虑构建模块：目标和自动化。

## 目标

不论是自动化的还是非自动化的，我们都需要保持文件组织，因此从这个部分开始似乎是个好主意。

让我们看看以下函数：

```go
func organizeFiles(paths []string) ([]string, error) {
   var err error
   events := make([]string, 0)
   for _, path := range paths {
      err := filepath.WalkDir(path, func(path string, dir os.DirEntry, err error) error {
         if err != nil {
            return err
         }
         if !dir.IsDir() {
            ext := filepath.Ext(path)
            destDir := filepath.Join(filepath.Dir(path), ext[1:]) // Remove the leading dot from the extension
            destPath := filepath.Join(destDir, dir.Name())
            // Create the destination directory if it doesn›t exist
            if err := os.MkdirAll(destDir, os.ModePerm); err != nil {
               return err
            }
            // Move the file to the destination
            if err := os.Rename(path, destPath); err != nil {
               return err
            }
            events = append(events, fmt.Sprintf("Moved %s to %s\n", path, destPath))
         }
         return nil
      })
      if err != nil {
         fmt.Printf("Error walking the path %v: %v\n", path, err)
      }
   }
   return events, err
}
```

我们应该注意以下事项：

1.  **处理多个路径**：该函数被设计来处理文件路径的一部分，允许它一次性操作多个目录或文件。

1.  使用 `filepath.WalkDir` 遍历输入路径中指定的每个目录树。

1.  **错误处理**：在遍历目录时，该函数处理遇到的任何错误。这包括访问目录内容时的错误以及与特定文件或目录相关的错误。

1.  **基于扩展名的文件组织**：对于遇到的每个文件（非目录），该函数根据其文件扩展名将其组织到新的目录中。这涉及到基于扩展名的文件组织。该函数采用详细的方法通过扩展名对文件（排除目录）进行组织。这个过程包括提取文件扩展名，为每个唯一的扩展名创建一个新的目录（如果尚未存在），并将文件移动到其新指定的目录中。这种系统化的组织使文件管理更加直观和易于访问。

1.  记录操作：该函数记录它执行的所有文件移动。每个将文件从原始位置移动到基于其扩展名的新目录的操作都被记录在事件切片中的字符串。

1.  返回结果：处理完所有路径后，该函数返回两个值：

    +   字符串切片（事件），每个描述对文件执行的操作

    +   一个错误值，如果没有遇到错误则为 nil，或者在处理路径过程中发生的最后一个错误

让我们测试这个函数！一旦我们开始操作文件，我们可以使用一个辅助函数来帮助我们处理代码重复：

```go
func createTempFileWithExt(dir, ext string) (string, error) {
   file, err := os.CreateTemp(dir, "*"+ext)
   if err != nil {
      return "", err
   }
   file.Close()
   return file.Name(), nil
}
```

此辅助函数创建一个具有给定扩展名的临时文件。`CreateTemp` 函数的一个巧妙细节是当字符串模式包含一个 `"*"` 并且随机字符串替换最后一个 `"*"` 时。例如，如果扩展名是 “.txt”，则文件名可能是“1217776936.txt”。

查看 git 仓库中针对 `"success"`、`"empty path"` 和 `"invalid path"` 的测试完整代码。

当从存储读取时，对于 `/temp` 路径，我们需要按如下方式通知程序：

```go
filepath.WalkDir("/tmp",...)
```

然而，我们需要发现设备挂载在闪存驱动器的哪个位置。一种手动执行的方法是使用 `df -h` 命令，输出将显示多行。尽管如此，我们感兴趣的行大致如下：

```go
/dev/sdc1        15G   16M   15G   1% /media/alexrios/usbtest
```

感到输出令人不知所措？让我们了解正在发生的事情：

+   `/dev/sdc1`：此字段表示与挂载的文件系统相对应的设备或块设备。在这种情况下，`/dev/sdc1` 是与文件系统关联的设备。

+   `15G`：此字段显示文件系统的总大小，在此示例中为 15 兆字节（GB）。

+   `16M`：此字段显示文件系统上使用的空间。在这里，它表示当前有 16 兆字节（MB）的磁盘空间被使用。

+   `15G`：此字段表示文件系统上的可用磁盘空间。在这种情况下，有 15 兆字节（MB）的空闲空间。

+   `1%`：此字段显示磁盘空间的使用百分比。在此示例中，只有 1% 的总文件系统空间被占用。

+   `/media/alexrios/usbtest`：此字段是文件系统的挂载点。它表示文件系统在目录层次结构中的挂载位置。在这种情况下，文件系统挂载在 `/media/alexrios/usbtest`。

由于一个设备在同一闪存驱动器中可能有多个挂载点（分区），我们将通过读取 `/proc/mounts` 文件以编程方式访问此信息。

## `/proc/mounts` 文件

`/proc/mounts` 文件是 Linux 操作系统中的一个特殊文件，它提供了当前挂载的文件系统的实时、动态视图。

在 `/proc/mounts` 文件中可以找到以下内容以及每个字段代表的意义：

+   设备或 UUID：第一个字段通常表示块设备或 `/dev/sda1` 或 `UUID=12345678-1234-5678-90ab-cdef01234567`。

+   挂载点：第二个字段显示文件系统挂载的目录。这是文件系统层次结构中可以访问挂载设备内容的位置。

+   文件系统类型：第三个字段指定挂载点上的文件系统类型。常见的例子包括 `ext4`、`ntfs`、`tmpfs`、`nfs` 以及许多其他类型。

+   挂载选项：第四个字段列出了挂载文件系统的挂载选项。这些选项控制文件系统行为的各个方面。常见的选项包括 `rw`（读写）、`ro`（只读）、`noexec`、`nosuid` 等。

+   导出标志：第五字段通常是`0`或`1`，表示是否应该使用 dump 命令备份文件系统。`0`表示不备份，而`1`表示应该包含在备份中。

+   文件系统检查顺序：第六字段由`fsck`实用程序使用，以确定在系统启动期间应检查文件系统的顺序。`0`表示没有自动文件系统检查。

`/proc/mounts`文件为用户和系统实用程序提供了一个方便的方式来检查 Linux 系统上挂载的文件系统的当前状态。各种系统管理工具、脚本和管理员经常使用它们来收集有关挂载设备和其配置的信息。

/proc/mounts

这不是磁盘上的实际文件，而是一个由 Linux 内核生成并更新以反映挂载的文件系统当前状态的虚拟文件。

## 读取闪存驱动器上的文件

现在是读取`/proc/mounts`以读取挂载点并发现程序将读取文件的位置。

这是程序的想法：列出系统上挂载的设备上的所有文件。此外，它应该接受一个设备路径作为输入参数，验证路径，从`/proc/mounts`读取挂载的文件系统，然后列出指定设备上的所有文件。让我们一步一步地分解代码，突出每个部分的关键片段。

**第 1 步：读取第一个参数作为** **路径**

```go
path := os.Args[1]
if !strings.HasPrefix(path, "/dev/") {
    fmt.Println("Path must start with /dev/")
    return
}
```

在这个初始步骤中，程序读取第一个命令行参数作为设备的路径。然后检查提供的路径是否以`/dev/`开头，以确保它是一个有效的设备路径。如果路径不符合标准，程序将打印错误信息并退出。

**第 2 步：打开和** **读取 /proc/mounts**

```go
file, err := os.Open("/proc/mounts")
if err != nil {
    fmt.Printf("Error opening /proc/mounts: %v\n", err)
    return
}
defer file.Close()
```

程序打开`/proc/mounts`文件以读取挂载的文件系统列表。如果打开文件时发生错误，它将打印错误信息并退出。`defer`语句确保在完成所有文件操作后关闭文件，防止资源泄露。

**第 3 步：扫描** **/proc/mounts**

```go
scanner := bufio.NewScanner(file)
for scanner.Scan() {
    line := scanner.Text()
    fields := strings.Fields(line)
    if len(fields) >= 2 {
        device := fields[0]
        mountPoint := fields[1]
```

使用扫描器，程序从`/proc/mounts`读取每一行。它将每一行分割成字段，其中第一个字段是设备，第二个字段是其挂载点。这一步对于识别用户指定的设备的挂载点至关重要。

**第 4 步：匹配设备并** **列出文件**

```go
if strings.HasPrefix(device, path) {
    mountPoint = strings.ReplaceAll(mountPoint, "\\040", " ")
    fmt.Printf("Device: %s is mounted on: %s\n", device, mountPoint)
    fmt.Println("Files:")
    err := filepath.Walk(mountPoint, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return filepath.SkipDir
        }
        fmt.Println(path)
        return nil
    })
    if err != nil {
        fmt.Printf("Error walking the path %v: %v\n", mountPoint, err)
    }
}
}
}
```

如果`/proc/mounts`中的设备与用户提供的路径匹配，程序将纠正挂载点路径中的任何空格编码，并宣布设备及其挂载点。它使用`filepath.Walk`从挂载点开始遍历文件系统，列出所有文件。如果在遍历过程中发生错误，它将打印错误信息。

**第 5 步：处理** **扫描器错误**

```go
if err := scanner.Err(); err != nil {
    fmt.Printf("Error reading /proc/mounts: %v\n", err)
}
```

完成对 `/proc/mounts` 的扫描后，程序会检查扫描过程中可能发生的任何错误，并将它们报告出来。这确保了在读取文件时遇到的任何问题都会得到认可和处理。

仔细关注 `mountPoint = strings.ReplaceAll(mountPoint, "\\040", " ")` 这一行。这在处理 Unix-like 系统上 `/proc/mounts` 文件中的特定格式化约定时是必要的。

在 `/proc/mounts` 中，它列出了所有挂载的文件系统，文件路径中的空格（在挂载点中很常见）由 `\040` 转义序列表示。该文件使用空格字符来分隔每行的不同字段。例如，挂载点路径 `/media/My Drive` 在 `/proc/mounts` 中表示为 `/media/My\040Drive`。

## 分区与块与设备与磁盘

在系统编程和硬件自动化中，有效地管理存储至关重要。为了有效地掌握这个主题，我们应该了解分区、块、设备和磁盘的基本概念。

### 分区 – 划分存储

分区是物理存储设备（如硬盘或 SSD）的逻辑划分。创建分区是为了将单个物理设备分割成多个独立的区域，每个区域作为一个独立的存储单元运行。这些划分有以下几个目的：

+   **操作系统隔离**：分区允许在单个物理磁盘上安装不同的操作系统，使用户在启动时可以选择它们。

+   **数据组织**：分区有助于将用户数据与系统数据分开，便于高效的数据管理和备份。

+   **安全性**：在单独的分区上隔离数据可以通过限制对存储设备特定部分的访问来增强安全性

### 块 – 固定大小的存储单元

块是用于在存储设备上存储和检索数据的固定大小数据单元。包括硬盘和 SSD 在内的存储设备被组织成块，每个块通常具有预定义的大小，如 512 字节或 4 KB。块的关键方面包括以下内容：

+   **数据处理**：操作系统通过在块中读取和写入数据与存储设备交互。这种基于块的策略确保了数据的一致性和高效的 I/O 操作。

+   **文件系统管理**：文件系统在这些块中管理数据，跟踪哪些块分配给了特定的文件和目录。

+   **优化存储**：使用固定大小的块可以有效地利用存储空间并最小化碎片化。

### 设备 – 物理或虚拟存储媒体

在系统编程和硬件自动化的背景下，设备指的是物理存储设备（如硬盘或 SSD）或由软件表示的虚拟设备。设备可以看作是操作系统和应用程序与存储资源交互的接口。以下是一些关键方面：

+   **物理和虚拟设备**：设备可以是连接到计算机的物理硬件组件，或由软件层创建的虚拟表示

+   **设备识别**：检测和识别存储设备是硬件自动化的关键任务，允许进行设备初始化和维护

+   **资源分配**：管理设备包括分配设备驱动程序、处理设备故障和确保高效数据访问的任务

### 磁盘 – 存储硬件

磁盘，一个经常与存储设备互换使用的术语，是负责数据存储的物理硬件组件。这些可以是**硬盘驱动器**（**HDDs**）、**固态驱动器**（**SSDs**）、光盘驱动器或**网络附加存储**（**NAS**）设备。关键方面包括以下内容：

+   **磁盘类型**：各种类型的磁盘可供选择，每种磁盘都有其独特的特性，包括容量、速度和耐用性

+   **存储容量**：磁盘提供了存储数据、应用程序和操作系统的所需存储容量

+   **性能**：不同类型的磁盘提供不同级别的性能，影响数据访问速度和整体系统响应速度

我们仍然想知道闪存盘何时被插入 USB 并采取行动（组织文件）。我们是否有标准化的方法来做这件事？幸运的是，有！

## 开源拯救！

在 Linux 动态且不断演变的领域中，随着 XDG 和 freedesktop.org 的出现，一个关于协作和创新的故事展开了。

### freedesktop.org 的诞生

2000 年春天，随着 Havoc Pennington 和他的愿景，一个新的篇章开始了。他认识到 Linux 桌面环境的碎片化状态，因此建立了 freedesktop.org。这不仅仅是一个组织；它是一个合作的灯塔，邀请 GNOME、KDE 和其他项目的开发者携手合作。他们的使命是什么？在各个桌面环境之间编织一个互操作性共享技术的锦缎。

### XDG – 标准的旗手

与此同时，**X 桌面小组**（**XDG**）出现了，专注于制定将成为不同桌面环境之间桥梁的标准。他们不仅仅是创建指南；他们正在构建 Linux 桌面世界的通用语言。他们的贡献，如 XDG 基本目录和桌面菜单规范，就像完美拼凑的拼图碎片，为曾经混乱的景象带来了秩序和兼容性。

### 协作交响曲

freedesktop.org 和 XDG 与众不同的地方在于他们的方法。他们没有发号施令；他们进行了合作。他们倾听并适应，创造了在各种平台上产生共鸣的解决方案。这不仅仅关乎技术，还关乎人、思想和当它们聚集在一起时产生的魔力。

在这个统一的传说中，XDG 和 freedesktop.org 作为灯塔，照亮了通往更集成和用户友好的 Linux 体验的道路。它们的遗产不仅在于他们创建的代码和标准，还在于他们在开源社区中培养的合作精神。

为了实现我们的目标，我们正在使用 freedesktop.org 的核心组件之一：D-Bus。

### D-Bus – 通信通道

D-Bus，freedesktop.org 生态系统中孕育的另一个产物，是一个消息总线系统，为应用程序之间以及与系统之间的通信提供了一种简单的方式。它就像 Linux 世界的邮政服务，在应用程序之间传递消息，确保它们可以和谐地一起工作。

在我们与 USB 事件交互之前，让我们先从一个更简单的例子开始：发送系统通知。

首先，我们需要添加`dbus`库的导入，`github.com/godbus/dbus/v5`，之后我们应该连接到会话总线并确保我们正在延迟释放资源：

```go
conn, err := dbus.ConnectSessionBus()
if err != nil {
   fmt.Errorf("failed to connect to session bus: %v", err)
}
defer conn.Close()
```

查看通知的规范([`specifications.freedesktop.org/notification-spec/notification-spec-latest.html`](https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html))

现在我们需要使用连接来访问通知对象以对其进行调用：

```go
call := obj.Call("org.freedesktop.Notifications.Notify", 0, appName, replacesID, appIcon, summary, body, actions, hints, expireTimeout)
if call.Err != nil {
    fmt.Sprintf("Error: %v", call.Err)
    return
}
```

正如我们在通知规范中可以看到的，参数如下：

| **名称** | **类型** | **必需** | **描述** |
| --- | --- | --- | --- |
| `app_name` | `STRING` | False | 发送通知的应用程序名称。可以是空白。 |
| `replaces_id` | `UINT32` | False | 此通知替换的通知 ID。值为`0`表示此通知不会替换现有通知。 |
| `app_icon` | `STRING` | False | 调用应用程序的程序图标。可以是空字符串，表示没有图标。 |
| `summary` | `STRING` | True | 简要描述通知的摘要文本。 |
| `body` | `STRING` | False | 详细正文。可以是空的。 |
| `actions` | `as` (字符串数组) | False | 以成对列表形式发送的操作。列表中的每个偶数元素（从索引 0 开始）代表操作的标识符。每个奇数元素是显示给用户的本地化字符串。 |
| `hints` | `a{sv}` (字符串-变体对数组) | False | 可以从客户端程序传递给服务器的提示。它们可以传递信息，例如进程 PID 或窗口 ID。可以是空的。 |
| `expire_timeout` | `INT32` | True | 从通知显示开始，通知应自动关闭的毫秒超时时间。 |

这里每个变量代表什么以及它如何影响通知：

+   `appName := "Organizer"`: `appName`指定发送通知的应用程序名称。在这种情况下，通知将显示为来自名为“Super App”的应用程序。

+   `replacesID := uint32(0)`: `replacesID` 用于替换现有的通知。值为 `0` 表示这个新的通知不会替换任何现有的通知。如果是一个非零值，它将尝试替换具有该 ID 的通知。

+   `appIcon := "view-refresh"`: `appIcon` 指定发送通知的应用程序的图标。一个空字符串 `""` 表示不会使用任何图标。如果提供了路径或图标名称，它将显示与通知一起的该图标。

+   `summary := "Organizer is done!"`: `summary` 是描述通知的简短文本。在这种情况下，摘要为“Organizer is done!”，这很可能会作为通知的标题或标题显示。

+   `body := fmt.Sprintf("The files at %s were successfully organized.", "/dev/sdc")`: `body` 是通知的详细文本，提供了更多信息。

+   `actions := []string{}`: `actions` 用于定义通知中的交互元素或按钮。一个空的 `[]string{}` 切片表示不会添加任何操作或按钮到通知中。

+   `hints := map[string]dbus.Variant{}`: `hints` 是可以用来修改通知外观或行为的附加属性或数据。一个空的 `map[string]dbus.Variant{}` 映射表示没有提供额外的提示。提示可以包括播放的声音文件、紧急程度等级等。

+   `expireTimeout := int32(5000)`: `expireTimeout` 指定了通知自动关闭前的时间（以毫秒为单位）。值为 `5000` 表示通知将在五秒后关闭。值为 `-1` 表示通知的过期取决于通知服务器的设置，而 `0` 表示通知永远不会自动过期。

应用图标

你可以在规范页面上找到更多关于应用图标的信息（[`specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html`](https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html)）。

最后，我们调用对象：

```go
call := obj.Call("org.freedesktop.Notifications.Notify", 0, appName, replacesID, appIcon, summary, body, actions, hints, expireTimeout)
if call.Err != nil {
    fmt.Sprintf("Error: %v", call.Err)
    return
}
```

在 `usb/example2` 目录中，我们通过执行以下命令来运行程序：

```go
go run main.go
```

屏幕上会弹出一个新的系统通知！这很酷，不是吗？

## 与 USB 事件交互

我们已经有了通过文件扩展名组织闪存驱动器的方法，一个发现文件挂载的功能，以及通知用户任务完成的方式。现在，我们准备与连接新闪存驱动器时触发的系统事件交互。

再次，我们需要使用 `dbus` 包：

```go
"github.com/godbus/dbus/v5"
```

我们需要连接到总线：

```go
conn, err := dbus.SystemBus()
if err != nil {
   fmt.Sprintf("Failed to connect to system bus: %v\n", err)
  return
}
defer conn.Close()
```

由于我们感兴趣的是监听 D-Bus 事件，我们需要给 D-Bus 连接提供一个通知我们程序的方式。我们通过一个类型为 `*dbus.Signal` 的通道来实现这一点：

```go
ch := make(chan *dbus.Signal)
conn.Signal(ch)
```

记住，我们感兴趣的并不是总线上的所有信号；我们只想得到表示 USB 设备插入的事件。在我们的例子中，信号名称是 `"org.freedesktop.DBus.ObjectManager.InterfacesAdded"`。

在 D-Bus 中，我们有一个特殊的实体来做这件事。它被称为匹配规则：

`matchRule := "``type='signal',sender='org.freedesktop.UDisks2',interface='org.freedesktop.DBus.ObjectManager',path='/org/freedesktop/UDisks2'"`

在我们的程序中，`matchRule`是一个字符串，用于定义 D-Bus 匹配规则。匹配规则的组成部分如下：

+   `type='signal'`: 表示你的程序想要监听信号（与 D-Bus 消息的其他类型，如方法调用或错误不同）。

+   `sender='org.freedesktop.UDisks2'`: 指定信号应来自`org.freedesktop.UDisks2`，这是 UDisks2 提供的 D-Bus 服务（一个用于管理 Linux 中磁盘驱动器和相关资源的服务）。

+   `interface='org.freedesktop.DBus.ObjectManager'`: 过滤由实现`org.freedesktop.DBus.ObjectManager`接口的对象发出的信号。此接口用于管理并枚举在特定 D-Bus 服务下的对象（如磁盘驱动器、分区等）。

+   `path='/org/freedesktop/UDisks2'`: 指定应接收信号的对象的路径。此路径对应于 UDisks2 服务。

以下行使用建立的 D-Bus 连接（`conn`）在 D-Bus 守护进程上调用`AddMatch`方法。`AddMatch`是 D-Bus 提供的方法，告诉总线守护进程开始转发匹配给定规则的消息（在这种情况下是信号）到你的应用程序。

```go
call := conn.BusObject().Call("org.freedesktop.DBus.AddMatch", 0, matchStr)
```

详细情况如下：

+   `conn.BusObject()`: 获取与总线守护进程本身通信的代理对象

+   `.Call(...)`: 在总线守护进程上调用方法

+   `"org.freedesktop.DBus.AddMatch"`: 用于告诉 D-Bus 系统的中央服务只向调用此方法的程序发送满足特定标准的消息的方法

+   `0`: 方法调用的标志，在典型用例中通常设置为`0`

+   `matchStr`: 之前定义的匹配规则，作为方法的参数传递

在以下代码中有一个循环，用于监听特定的 D-Bus 信号并相应地处理它们。它特别关注与 UDisks2 中添加的新接口相关的信号，UDisks2 是一个用于管理 Linux 中磁盘驱动器的服务。

让我们一步一步地分解代码。

**步骤 1 – 监听信号**：

```go
   for signal := range ch {
       ...
   }
```

这个`for`循环遍历接收 D-Bus 信号的通道（`ch`）。通过通道接收到的每个项目都是一个`signal`，代表已发送到你的应用程序的 D-Bus 信号。

**步骤 2 – 检查信号名称**：

```go
   if signal.Name == "org.freedesktop.DBus.ObjectManager.InterfacesAdded" {
       ...
   }
```

代码检查信号的名称是否为`"org.freedesktop.DBus.ObjectManager.InterfacesAdded"`。当在 UDisks2 的对象管理器中添加新接口（如新的块设备）时，会发出此信号。

**步骤 3 – 提取对象路径**：

```go
path := signal.Body[0].(dbus.ObjectPath)
```

这行代码提取了信号主体的第一个元素，应该是新添加接口的对象路径。对象路径标识了 UDisks2 中特定的对象（如磁盘或分区）。

**步骤 4 – 检查** **路径前缀**：

```go
   if strings.HasPrefix(string(path), "/org/freedesktop/UDisks2/block_devices/") {
       ...
   }
```

代码检查新接口的路径是否以 `"/org/freedesktop/UDisks2/block_devices/"` 开头。这个前缀表示该接口是一个块设备，例如硬盘或 USB 闪存驱动器。

**步骤 5 – 访问** **设备属性**：

```go
   deviceObj := conn.Object("org.freedesktop.UDisks2", path)
   deviceProps := deviceObj.Call("org.freedesktop.DBus.Properties.Get", 0, "org.freedesktop.UDisks2.Block", "Device")
```

如果路径匹配，代码将继续与该特定设备交互。它是通过在设备对象上调用 `org.freedesktop.DBus.Properties.Get` 方法来获取其属性来实现的。感兴趣的属性来自 `"org.freedesktop.UDisks2.Block"` 接口，特别是 `"Device"` 属性。

**步骤 6 –** **错误处理**：

```go
   if deviceProps.Err != nil {
       ...
   }
```

这检查了获取设备属性的方法调用中是否有错误。如果有错误，它将打印错误消息并继续到下一个信号。

**步骤 7 – 打印** **挂载点**：

```go
   mountPoints := deviceProps.Body[0].(dbus.Variant)
   fmt.Println(fmt.Sprintf("%s", mountPoints.Value()))
```

这从响应中提取 `Device` 属性 (`deviceProps.Body[0]`)。该属性被转换为 `dbus.Variant` 类型，这是一个用于任何 D-Bus 数据类型的通用容器。然后打印出该值。此值通常表示设备节点的文件路径（例如磁盘分区的 `/dev/sda1`）。

在 `appendix-a/usb/example4` 目录中，我们执行程序：

```go
go run main.go
```

我们应该看到类似以下的名字：

```go
/dev/sdc
/dev/sdc1
```

要理解这个输出，我们应该明确存储设备和分区的区别。

Linux 中 `/dev/sdc` 和 `/dev/sdc1` 输出的区别与存储设备和其分区在文件系统中的表示方式有关。

`/dev/sdc` 表示整个物理存储设备。在 Linux（以及其他类 Unix 操作系统）中，硬盘、SSD 和 USB 闪存驱动器等存储设备在 `/dev` 目录中表示为文件。名称 `sdc` 通常根据系统识别设备的顺序分配（在 `sda`、`sdb` 等之后）。

当程序输出显示 `/dev/sdc` 时，它指的是整个存储设备，包括其所有分区和数据。

`/dev/sdc1` 表示存储设备上的一个特定分区。末尾的数字（本例中的 `1`）表示 `sdc` 设备上的第一个分区。

如我们之前讨论的，分区是物理存储设备的细分。它们允许您将设备分割成不同的部分，每个部分都可以使用不同的文件系统格式化或用于不同的目的。

换句话说，`/dev/sdc1` 是 `/dev/sdc` 存储设备上的第一个分区。

在实际应用中，访问两者的区别如下：

+   访问 `/dev/sdc` 将用于影响整个磁盘的操作，例如磁盘格式化、分区以及获取磁盘范围的信息（例如总大小、磁盘健康状态等）。

+   访问 `/dev/sdc1` 将用于针对该分区的特定操作，例如挂载分区以访问其文件系统、检查文件系统健康状态或仅格式化该分区。

请记住，我们选择此路径是为了检查所有可用的分区。

但等等！由于 D-Bus 有关于分区的信息，如果我们能从它那里访问挂载点信息而不是解析 `/proc/mounts` 文件，那就太好了。

幸运的是，我们可以！

让我们看看我们如何在全新的 `mountPoints` 函数中做到这一点：

```go
func mountPoints(deviceNames []string) ([]string, error) {
   conn, err := dbus.ConnectSystemBus()
   if err != nil {
      return nil, fmt.Errorf("failed to connect to system bus: %v", err)
   }
   defer conn.Close()
   var mountPoints []string
   for _, deviceName := range deviceNames {
      objPath := path.Join("/org/freedesktop/UDisks2/block_devices", deviceName)
      obj := conn.Object("org.freedesktop.UDisks2", dbus.ObjectPath(objPath))
      var result map[string]dbus.Variant
      err = obj.Call("org.freedesktop.DBus.Properties.GetAll", 0, "org.freedesktop.UDisks2.Filesystem").Store(&result)
      if err != nil {
         return nil, fmt.Errorf("failed to call method: %v", err)
      }
      if mountPointsVariant, exists := result["MountPoints"]; exists {
         mountPointsValue := mountPointsVariant.Value().([][]byte)
         for _, mp := range mountPointsValue {
            mountPoints = append(mountPoints, string(mp))
         }
      }
   }
   if len(mountPoints) == 0 {
      return nil, fmt.Errorf("no mount points found")
   }
   return mountPoints, nil
}
```

这里是关于函数如何工作的解释：

+   连接到 D-Bus：它首先使用 `dbus.ConnectSystemBus()` 建立与 D-Bus 系统总线的连接。系统总线用于与系统级服务（如 UDisks2）交互。如果连接到系统总线时发生错误，它返回一个错误。

+   初始化：它初始化一个空的 `mountPoints` 切片以存储为提供的设备找到的挂载点。

+   设备名称迭代：使用 `for` 循环，函数随后遍历 `deviceNames` 切片中的每个设备名称。

+   D-Bus 对象路径：对于每个设备名称，它通过将 UDisks2 块设备路径与之连接来构造 D-Bus 对象路径。这是通过 `path.Join("/org/freedesktop/UDisks2/block_devices", deviceName)` 实现的。此对象路径指定了代表具有给定名称的块设备的 D-Bus 对象。

+   D-Bus 对象和方法调用：它使用 `conn.Object` 和 UDisks2 服务名称以及构造的对象路径创建一个 D-Bus 对象。然后，它调用对象上的 `"org.freedesktop.DBus.Properties.GetAll"` D-Bus 方法来检索 `"org.freedesktop.UDisks2.Filesystem"` 接口的所有属性。结果存储在结果映射中。

+   挂载点提取：函数使用 `result["MountPoints"]` 检查结果映射中是否存在 `"MountPoints"` 属性。如果存在，它从属性中提取挂载点作为字节切片的切片 (`[][]byte`)。

+   转换为字符串：然后它遍历挂载点的字节切片并将它们转换为字符串。这些字符串代表设备的挂载点。挂载点被追加到 `mountPoints` 切片中。

+   错误处理：如果没有找到设备的挂载点或 D-Bus 方法调用中发生错误，它返回一个错误，指示没有找到挂载点。

+   结果返回：最后，如果至少找到一个挂载点，函数返回包含所有挂载点的 `mountPoints` 切片和 nil 作为错误。

现在我们知道了如何组织文件，监听存储设备事件，并找到挂载点。我们准备好将这些事情粘合在一起。

完整功能示例可在 git 仓库中找到。试着整理一下混乱的闪存驱动器！

# 蓝牙

想象一下，在一个世界里，你那可靠的智能手表不仅仅能计数你的步数或提醒你会议。在这个世界里，我的 Samsung Galaxy Watch Active 2 成为了我的工作站的保护者，一个忠诚的盟友，确保我的数据免受过于好奇的同事的窥视。是的，你没听错。

欢迎来到我将简单可穿戴设备变成巧妙工作站安全工具的旅程。

那时，我正坐在我的隔间里，隔间里装饰着必不可少的科技配件，突然一个想法闪过我的脑海。在一个“偷窥”常常伪装成“偶然一瞥”的办公室里，我能否利用我钟爱的智能手表来增强我的工作站的安全性？任务已经设定：当我离开时自动锁定我的屏幕，让好奇的同事们只能盯着一个干净的锁屏。

该策略简单而优雅。我会使用一个程序勤勉地监控我的 Linux 机器和我的智能手表之间的蓝牙信号强度（RSSI）。一旦信号下降到某个阈值以下——这是一个我可能已经离开办公桌、可能是在寻找另一杯咖啡的微妙暗示——脚本就会英勇地锁定我的工作站。纯粹的天才，不是吗？

## 检测智能手表

第一步很简单。以下程序将使用`github.com/muka/go-bluetooth/api`蓝牙库：

```go
package main
import (
    "fmt"
    "github.com/muka/go-bluetooth/api"
)
func main() {
    adapter, err := api.GetDefaultAdapter()
    if err != nil {
        panic(err)
    }
    err = adapter.StartDiscovery()
    if err != nil {
        panic(err)
    }
    devices, err := adapter.GetDevices()
    if err != nil {
        panic(err)
    }
    for _, device := range devices {
        info, err := device.GetProperties()
        if err != nil {
            continue
        }
        if info.Name == "Galaxy Watch Active2(207D)" {
            fmt.Println("Found the watch:", info.Name)
        }
    }
}
```

这是你可以获取默认蓝牙适配器的方法：

```go
adapter, err := api.GetDefaultAdapter()
if err != nil {
    fmt.Printf("Failed to find default adapter: %s\n", err)
}
```

使用适配器，让我们开始设备发现：

```go
err = adapter.StartDiscovery()
if err != nil {
    fmt.Printf("Failed to start discovery: %s\n", err)
}
```

我们现在可以开始检索和显示设备信息：

```go
devices, err := adapter.GetDevices()
if err != nil {
    fmt.Printf("Failed to get devices: %s\n", err)
}
for _, device := range devices {
    info, err := device.GetProperties()
    if err != nil {
        fmt.Printf("Failed to get properties: %s\n", err)
        continue
    }
    fmt.Println(info.Name, info.Address, info.RSSI)
}
```

让我们检查这个代码片段：

+   `adapter.GetDevices()`:

    +   这将检索到已发现的所有蓝牙设备列表。

    +   如果无法检索到设备，则会打印一条错误信息。

    +   程序随后会迭代（`for`循环）遍历每个设备。

+   `device.GetProperties()`:

    +   这将获取每个设备的属性，例如名称、地址和**接收信号强度** **指示器**（**RSSI**）。

    +   如果获取设备的属性失败，它会打印一条错误消息并继续下一个设备。

    +   最后，它打印出每个设备的名称、地址和 RSSI。RSSI 衡量你的设备能够从接入点或路由器接收信号的好坏，这有助于确定设备与之间的距离。

等一下！RSSI 是什么？这是个好问题！让我们来探索这个概念。

### 理解 RSSI

将 RSSI 想象成办公室的八卦——当你靠近源头时（0 dB，办公室的谣言工厂），你会听到它清晰而响亮。然而，当你漫步到你的隔间堡垒时，细节会变得模糊，直到它们只是耳语（-100 dB，几乎就是神话和传说的领域）。这个 RSSI，一个分贝的生物，从 0（八卦中心）到-100（被遗忘的故事领域）游荡，其强度根据它骑乘的蓝牙生物而变化——每个都有其怪癖。

#### 距离估算

RSSI，就像我们听到办公室八卦的能力一样，暗示了我们离源头有多近。较高的值（更少负值，比如说-30 dB）表明你可能正悬浮在某人肩膀上，而较低的值（更多负值，比如-80 dB）意味着你安全地坐在你的隔间里，远离了闲聊。但是，这里有个问题——RSSI 在测量精确距离上的可靠性，就像用咖啡香气导航到厨房一样。它是一个信号强度、办公室墙壁的情绪以及微波炉是否在干扰中的混乱混合体。

#### 设置邻近度阈值

现在，让我们来谈谈设置这个所谓的邻近度阈值。这就像决定你得多近才能听到八卦。比如说，-70 dBm——足够近以捕捉到要点，但又足够远以假装无知。这是一场试错游戏，就像在办公室找到一个完美的位置来捕捉 Wi-Fi 信号但避免尴尬的对话一样。而且记住，就像办公室布局会变化（多亏了我们那不安分的办公室经理），这个阈值可能偶尔需要调整。

#### 应用

RSSI 不仅仅是窃听办公室八卦。在我们的技术天堂里，它是悄无声息的忍者，在设备靠近时触发动作——比如当你走近时神奇地解锁门（不再需要翻找钥匙！）或者因为考勤系统如此狡猾而记录你的出勤。至于室内定位？它就像是现代版的“魔戒地图”，只是没有足够的精确度来捕捉某人偷偷溜进休息室。

#### 局限性

但这里有趣的部分是——基于 RSSI 的邻近度检测就像我们办公室的天气预报一样精确。它更少关于测量精确距离，更多的是关于对“接近”的狂野猜测。而且，由于墙壁、微波炉和其他技术小玩意儿闹脾气，RSSI 的值比我们老板改变会议日程还要频繁地改变主意。

#### 实施考虑因素

如果你打算利用 RSSI 的力量，准备好进行一些校准巫术——因为每个设备和办公室角落都有自己的故事要讲述。为了平息 RSSI 的情绪波动，一点过滤魔法（比如移动平均法术）可以防止你的邻近度检测像过山车一样起伏。

运行这个程序几次之后，我发现 RSSI -70 dBm 效果非常好。所以，让我们更新我们的程序来使用这个值。

首先，让我们进行周期性检查：

```go
ticker := time.NewTicker(10 * time.Second)
defer ticker.Stop()
```

然后，改变我们进行轮询和处理设备的方式：

```go
for {
    select {
    case <-ticker.C:
        devices, err := adapter.GetDevices()
        if err != nil {
            fmt.Printf("Failed to get devices: %s\n", err)
            continue
        }
        for _, device := range devices {
            info, err := device.GetProperties()
            if err != nil {
                fmt.Printf("Failed to get properties: %s\n", err)
                continue
            }
            if info.RSSI < -70 && info.Name == "Galaxy Watch Active2(207D) LE" {
                fmt.Println(info.Name, info.RSSI)
            }
        }
    }
}
```

更新后的程序与之前的版本相比，包含了一些关键变化，重点在于使用计时器实现周期性轮询。以下是与之前程序相比的变化：程序执行了一次性扫描蓝牙设备然后退出。它没有持续监控设备的存在或变化。设备扫描和检查其属性是在程序运行时立即且仅执行一次。程序没有机制来周期性地检查蓝牙设备的状态。

因此，在更新的程序中，我们使用 `time.Ticker` 每隔 10 秒创建周期性事件，使其能够随着时间的推移监控变化和新设备。

使用 `defer` 确保在程序退出时调用 `ticker.Stop()`，这有助于有效管理资源并避免潜在泄漏。

这使得程序能够持续监控蓝牙环境。以下是代码：

```go
   ticker := time.NewTicker(10 * time.Second)
   defer ticker.Stop()
```

此外，我们使用 `select` 语句进行同步。程序现在使用 `select` 语句等待 ticker 的通道。这是在 Go 中处理异步、周期性事件的一种更有效的方法：

```go
   select {
   case <-ticker.C:
       // Device scanning logic
   }
```

注意

对设备和它们属性的扫描现在被放置在一个无限循环中，该循环由 ticker 的通道触发。

这些更改使程序更适合我们的场景，其中需要持续监控蓝牙设备。

现在是采取行动的时候了：锁定屏幕！

## 锁定屏幕

随着这个自动化故事的发展，我们达到了它的高潮——动态检测智能手表并实时响应。情节简单而有效：如果手表的 RSSI 超过 -70 dBm 的阈值，就像走出一个无形圆圈一样，我的工作站会自动锁定。

每当 RSSI 低于 -70 dBm 时，就会到来关键时刻。程序会执行锁定命令。这个功能应该绰绰有余：

```go
func lockScreen() error {
   _, err := exec.Command("xdg-screensaver", "lock").Output()
   if err != nil {
      return err
   }
   return nil
}
```

现在我们应该在我们的提议条件下调用这个函数：

```go
if info.RSSI < -70 && info.Name == "Galaxy Watch Active2(207D) LE" {
   err := lockScreen()
   if err != nil {
      fmt.Printf("Failed to lock screen: %s\n", err)
      continue
   }
}
```

输入 xdg-screensaver

xdg-screensaver 是一个命令行工具，它源于在不同的桌面环境中以标准化方式控制屏保的需求。在过去，每个环境都有自己处理屏保的方式，这给开发者和用户都带来了兼容性问题。

xdg-screensaver 作为一个统一者介入。它提供了一个通用接口，允许应用程序无缝地与屏保交互，无论底层桌面环境如何。这个工具是 XDG 所倡导的标准化努力的直接受益者，展示了抽象标准如何导致具体、用户友好的解决方案。

这是我交响乐的高潮——屏幕锁定，就像在引人入胜的一章之后合上书本一样无缝。这是一场技术和逻辑的舞蹈，在我的工作站的大舞台上上演。

## XDG 困境

我的创造像野火一样迅速在隔间中传播。同事们，被它提供的便利性和安全性所吸引，开始纷纷涌向我的桌子，他们的眼睛充满好奇。“我们也能用这个吗？”他们急切地问道，他们的声音中充满了兴奋和一丝嫉妒。

在自我表扬创建了一个当我的智能手表移开时锁定电脑的自动化程序后，我遇到了一个难题：我用来锁定屏幕的命令 xdg-screensaver 对所有人都不起作用。以下是我发现的内容及其含义的简单说明。

将 xdg-screensaver 视为一种在大多数 Linux 计算机上应该工作的通用工具。但，就像不同国家的人说不同的语言一样，我们办公室的计算机使用不同类型的系统或“环境”。结果发现，xdg-screensaver 无法与这些系统中的某些系统“交流”。

## Wayland 难题

随着前卫系统 Wayland 的引入，许多人都采用了这个系统，剧情变得更加复杂。这个游戏中的新参与者与 xdg-screensaver 配合不佳，让那些用户感到孤立无援。这个曾经是时下英雄的程序，现在面临着它的局限性，它的致命弱点。

这次旅行让我深入到蓝牙协议、信号波动和各种桌面环境的特殊性之中。每一次发现都像是剥去一层皮，揭示了更多关于蓝牙交互神秘本质以及创造一刀切解决方案的挑战。

也许这次旅行的真正目的不是提供即时解决方案，而是揭开蓝牙自动化的神秘面纱。真正的胜利在于我们正在获得的集体理解——探索技术细微差别，这些技术支配着我们的日常互动。

现在，每次关于自动化的查询都会引发关于蓝牙自动化复杂性的深思熟虑的对话。办公室里充满了对创造适应不同环境的技术的挑战和复杂性的新认识。

# 摘要

在本章中，我们学习了硬件自动化的基础知识，特别是在系统编程的背景下。关键课程包括理解软件与物理硬件设备（如可穿戴设备和 USB 闪存驱动器）之间的交互，USB 技术的基础，以及开发用于在闪存驱动器上自动化文件组织的程序。此外，你还了解了一个涉及用于锁定屏幕的蓝牙应用程序的实验，展示了硬件-软件交互的实际应用。

本章涵盖了实际方面，如从存储中读取，理解 Linux 中的`/proc/mounts`文件，以及分区、块、设备和磁盘之间的区别。它还包括如何使用蓝牙根据 RSSI 确定距离。

理解硬件自动化，特别是在 USB 和蓝牙技术背景下，是现代从事自动化工作的程序员的常识。这些技能使你能够为日常技术挑战开发实用解决方案。
