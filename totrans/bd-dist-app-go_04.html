<html><head></head><body>
		<div id="_idContainer074">
			<h1 id="_idParaDest-31"><a id="_idTextAnchor037"/>Chapter 2: Setting Up API Endpoints</h1>
			<p>In the previous chapter, we learned how to build our first Gin web application. In this one, we're going to build a complete RESTful API from scratch. Along the way, we will explore HTTP methods and advanced routing features. We'll also cover how to write the OpenAPI Specification and how to generate API documentation.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Exploring API functionality</li>
				<li>Implementing HTTP routes</li>
				<li>Writing the OpenAPI Specification</li>
			</ul>
			<p>By the end of this chapter, you'll be familiar with the routing mechanisms of Gin, HTTP methods, and data validation.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>To follow along with this chapter, you'll need the following:</p>
			<ul>
				<li>A laptop (Windows, Linux, or macOS) with Golang version 1.15.6 set up so that you can easily execute the commands provided</li>
				<li>A general understanding of the RESTful API and the Go programming language</li>
			</ul>
			<p>The code bundle for this chapter is hosted on GitHub at <a href="https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter02">https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter02</a><a href="https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter2."/></p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor039"/>Exploring API functionality</h1>
			<p>To illustrate how to <a id="_idIndexMarker069"/>build a RESTful API, we will build a cooking application. We will cover how to integrate, deploy, and test the app using the Gin framework. The application will do the following:</p>
			<ul>
				<li>Display the recipes that are submitted by the users, along with their ingredients and instructions.</li>
				<li>Allow anyone to post a new recipe.</li>
			</ul>
			<p>The application architecture and flow are shown in the following diagram:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B17115_02_01.jpg" alt="Figure 2.1 – Recipes application architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Recipes application architecture</p>
			<p>The architecture is composed of a microservice written with the Gin framework and a database for data persistency. The microservice exposes a RESTful API to manage the recipes through the HTTP protocol.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Later in this book, we will cover how to build a frontend application with the React web framework so that we can consume the RESTful API.</p>
			<p>Before we get started, we need to create a GitHub repository where the code source will be stored. To structure the code within Git branches, we will use the GitFlow model. This approach consists of the following branches:</p>
			<ul>
				<li><strong class="bold">master</strong>: This branch <a id="_idIndexMarker070"/>corresponds to the current production code. You can't commit directly, except for hotfixes. Git tags can be used to tag all the commits in the master branch with a version number (for instance, for using the semantic versioning convention, <a href="https://semver.org/">https://semver.org/</a>, which has <a id="_idIndexMarker071"/>three parts: major, minor, and patch, so a tag with version 1.2.3 has 1 as its major version, 2 as its minor version, and 3 as its patch version).</li>
				<li><strong class="bold">preprod</strong>: This is a <a id="_idIndexMarker072"/>release branch and is a mirror of production. It can be used to test all the new features that are developed on the develop branch before they are merged to the master branch.</li>
				<li><strong class="bold">develop</strong>: This is the <a id="_idIndexMarker073"/>development integration branch, which contains the latest integrated development code.</li>
				<li><strong class="bold">feature/X</strong>: This is an <a id="_idIndexMarker074"/>individual feature <a id="_idIndexMarker075"/>branch that's being developed. Each new feature resides in its own branch, and they're generally created for the latest develop branch.</li>
				<li><strong class="bold">hotfix/X</strong>: When you <a id="_idIndexMarker076"/>need to solve something in production code, you can use the hotfix branch and open a pull request for the master branch. This branch is based on the master branch.</li>
			</ul>
			<p>The following schema illustrates the GitFlow approach:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B17115_02_02.jpg" alt="Figure 2.2 – GitFlow model – main branches&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – GitFlow model – main branches</p>
			<p>Once the GitHub <a id="_idIndexMarker077"/>repository has been created, clone it to your Go workspace and create three main branches called <strong class="source-inline">develop</strong>, <strong class="source-inline">preprod</strong>, and <strong class="source-inline">master</strong> . This will help you organize the project and isolate the code under development from the code running in production. This branching strategy is a slimmer version of the GitFlow workflow branching model (don't forget to replace the GitHub URL with a link to your repository):</p>
			<p class="source-code">git clone https://github.com/mlabouardy/recipes-api.git </p>
			<p class="source-code">cd recipes-api </p>
			<p class="source-code">touch README.md </p>
			<p class="source-code">git checkout -b preprod </p>
			<p class="source-code">git push origin preprod </p>
			<p class="source-code">git checkout –b develop </p>
			<p class="source-code">git push origin develop</p>
			<p>This will create a new directory called <strong class="source-inline">recipes-api</strong>. Let's make this directory the root of a module by executing the following command. This will enable us to manage project dependencies with the <strong class="source-inline">go.mod</strong> and <strong class="source-inline">go.sum</strong> files:</p>
			<p class="source-code">go mod init</p>
			<p>Open the project folder on VSCode and create a <strong class="source-inline">main.go</strong> file with the following code. The <strong class="source-inline">main</strong> function will initialize a new Gin router and run an HTTP server on port <strong class="source-inline">8080</strong> by invoking the <strong class="source-inline">Run()</strong> method of our Gin instance:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "github.com/gin-gonic/gin"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">   router := gin.Default()</p>
			<p class="source-code">   router.Run()</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Make sure that you install the <strong class="source-inline">gin</strong> package with the <strong class="source-inline">go get</strong> command. Refer to the previous chapter for a step-by-step guide.</p>
			<p>Push the changes to the <a id="_idIndexMarker078"/>Git remote repository. For now, we will push the changes directly to the <strong class="source-inline">develop</strong> branch. We will learn how to open pull requests in the next section:</p>
			<p class="source-code">git add .</p>
			<p class="source-code">git commit –m "boilerplate"</p>
			<p class="source-code">git push origin develop</p>
			<p>The updated repository should look as follows:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B17115_02_03.jpg" alt="Figure 2.3 – GitHub branches&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – GitHub branches</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you're working with a team of developers, you will need to issue the <strong class="source-inline">go mod download</strong> command to install the required dependencies after cloning the project from GitHub.</p>
			<p>In the <a id="_idIndexMarker079"/>next sub-section, we'll see how you can define the data model.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor040"/>Defining the data model</h2>
			<p>Before digging into the <a id="_idIndexMarker080"/>routes definition, we need to <a id="_idIndexMarker081"/>define a model that will hold information about a recipe. We can create our model by defining a Go struct. This model will contain the properties/fields of a recipe. Declare the following struct in the <strong class="source-inline">main.go</strong> file:</p>
			<p class="source-code">type Recipe struct {</p>
			<p class="source-code">   Name         string    `json:"name"`</p>
			<p class="source-code">   Tags         []string  `json:"tags"`</p>
			<p class="source-code">   Ingredients  []string  `json:"ingredients"`</p>
			<p class="source-code">   Instructions []string  `json:"instructions"`</p>
			<p class="source-code">   PublishedAt  time.Time `json:"publishedAt"`</p>
			<p class="source-code">}</p>
			<p>Our <strong class="source-inline">Recipe</strong> model is <a id="_idIndexMarker082"/>self-explanatory. Each recipe should have a name, a list of ingredients, a list of instructions or steps, and a publication date. Moreover, each recipe <a id="_idIndexMarker083"/>belongs to a set of categories or tags (for example, vegan, Italian, pastry, salads, and so on), as well as an ID, which is a unique identifier to differentiate each recipe in the database. We will also specify the tags on each field using backtick annotation; for example, <strong class="source-inline">`json:"NAME"`</strong>. This allows us to map each field to a different name when we send them as responses, since JSON and Go have different naming conventions.</p>
			<p>Once the struct has been defined, push the changes to a new branch based on the <strong class="source-inline">develop</strong> branch:</p>
			<p class="source-code">git checkout -b feature/datamodel</p>
			<p class="source-code">git add main.go</p>
			<p class="source-code">git commit -m "recipe data model"</p>
			<p class="source-code">git push origin feature/datamodel</p>
			<p>Once you've pushed these changes to your repository, the <strong class="bold">Compare &amp; pull request</strong> button will appear in GitHub. Click on it and open a pull request by clicking on the <strong class="bold">Create pull request</strong> button to merge <strong class="source-inline">feature/datamodel</strong> with the <strong class="source-inline">develop</strong> branch:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B17115_02_04.jpg" alt="Figure 2.4 – GitHub pull request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – GitHub pull request</p>
			<p>Merge the <a id="_idIndexMarker084"/>changes <a id="_idIndexMarker085"/>to the <strong class="source-inline">develop</strong> branch and delete the <strong class="source-inline">feature/datamodel</strong> branch:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B17115_02_05.jpg" alt="Figure 2.5 – Merging the pull request into the develop branch&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – Merging the pull request into the develop branch</p>
			<p>With the data model defined, we can look at the route handler definitions. The API will expose various endpoints. Let's take a look at them now.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor041"/>HTTP endpoints</h2>
			<p>The <a id="_idIndexMarker086"/>following table <a id="_idIndexMarker087"/>shows the list of HTTP endpoints that we can use:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/011.jpg" alt=""/>
				</div>
			</div>
			<p>Now, we are <a id="_idIndexMarker088"/>going to establish the endpoints of our API. We will set this up by <a id="_idIndexMarker089"/>creating all our endpoints in the <strong class="source-inline">main</strong> function. Every endpoint needs a separate function to handle the request. We will define them in the <strong class="source-inline">main.go</strong> file.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the next chapter, we will cover how to structure the Go project according to the standard Go layout.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor042"/>Implementing HTTP routes</h1>
			<p>In this section, we <a id="_idIndexMarker090"/>will create function handlers to handle POST, GET, PUT, and DELETE HTTP requests. So, let's jump right into it.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor043"/>POST /recipes</h2>
			<p>First, let's <a id="_idIndexMarker091"/>implement the <a id="_idIndexMarker092"/>endpoint responsible for creating a new recipe. Create a POST method on the <strong class="source-inline">/recipes</strong> resource. Then, define a <strong class="source-inline">NewRecipeHandler</strong> method for that path. The <strong class="source-inline">main.go</strong> file should look something like this: </p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">   "time"</p>
			<p class="source-code">   "github.com/gin-gonic/gin"</p>
			<p class="source-code">)</p>
			<p class="source-code">type Recipe struct {</p>
			<p class="source-code">  ID           string    `json:"id"`</p>
			<p class="source-code">  Name         string    `json:"name"`</p>
			<p class="source-code">  Tags         []string  `json:"tags"`</p>
			<p class="source-code">  Ingredients  []string  `json:"ingredients"`</p>
			<p class="source-code">  Instructions []string  `json:"instructions"`</p>
			<p class="source-code">  PublishedAt  time.Time `json:"publishedAt"`</p>
			<p class="source-code">}</p>
			<p class="source-code">func NewRecipeHandler(c *gin.Context) {</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">   router := gin.Default()</p>
			<p class="source-code">   router.POST("/recipes", NewRecipeHandler)</p>
			<p class="source-code">   router.Run()</p>
			<p class="source-code">}</p>
			<p>Before writing the code of the <strong class="source-inline">NewRecipeHandler</strong> method, we need to define a global variable called <strong class="source-inline">recipes</strong> to store the list of recipes. This variable will be used temporarily and will be replaced in the next chapter with a database for data persistency. To initialize the <strong class="source-inline">recipes</strong> variable, we can use the <strong class="source-inline">init()</strong> method, which will be executed during the startup of the application:</p>
			<p class="source-code">var recipes []Recipe</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">   recipes = make([]Recipe, 0)</p>
			<p class="source-code">}</p>
			<p>Here, we will <a id="_idIndexMarker093"/>define the <a id="_idIndexMarker094"/>logic behind <strong class="source-inline">NewRecipeHandler</strong>. The <strong class="source-inline">c.ShouldBindJSON</strong> function marshals the incoming request body into a <strong class="source-inline">Recipe</strong> struct and then assigns a unique identifier with an external package called <strong class="source-inline">xid</strong>. Next, it assigns a publication date with the <strong class="source-inline">time.Now()</strong> function and appends the recipe to the list of recipes, which will keep it in memory. If the request body is invalid, then the handler will return an error (400 status code). Otherwise, the handler will return a 200 status code:</p>
			<p class="source-code">func NewRecipeHandler(c *gin.Context) {</p>
			<p class="source-code">   var recipe Recipe</p>
			<p class="source-code">   if err := c.ShouldBindJSON(&amp;recipe); err != nil {</p>
			<p class="source-code">       c.JSON(http.StatusBadRequest, gin.H{</p>
			<p class="source-code">          "error": err.Error()})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   }</p>
			<p class="source-code">   recipe.ID = xid.New().String()</p>
			<p class="source-code">   recipe.PublishedAt = time.Now()</p>
			<p class="source-code">   recipes = append(recipes, recipe)</p>
			<p class="source-code">   c.JSON(http.StatusOK, recipe)</p>
			<p class="source-code">}</p>
			<p>In the previous code, we used a built-in status code constants such as <strong class="source-inline">http.StatusOK</strong> and <strong class="source-inline">http.StatusBadRequest</strong> instead of a hardcoded HTTP status code. We're also setting the response type to JSON.</p>
			<p>Before running the <a id="_idIndexMarker095"/>application, we need to download the <strong class="source-inline">xid</strong> package, which <a id="_idIndexMarker096"/>is used to generate a unique ID:</p>
			<p class="source-code">go get github.com/rs/xid</p>
			<p>The new dependency will be added automatically to the <strong class="source-inline">go.sum</strong> and <strong class="source-inline">go.mod</strong> files. Run the server, as follows:</p>
			<p class="source-code">go run main.go</p>
			<p>An HTTP server will be deployed on port <strong class="source-inline">8080</strong>:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B17115_02_06.jpg" alt="Figure 2.6 – Gin server logs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – Gin server logs</p>
			<p>To test it out, issue a POST request with the Postman client at http://localhost:8080/recipes with the following JSON in the request body:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B17115_02_07.jpg" alt="Figure 2.7 – Issuing a POST request with the Postman client&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Issuing a POST request with the Postman client</p>
			<p>The preceding <a id="_idIndexMarker097"/>command will add the recipe to the array of recipes and return it <a id="_idIndexMarker098"/>with an assigned ID and publication date.</p>
			<p>Another alternative to Postman is to use the <strong class="source-inline">cURL</strong> command. Use the following <strong class="source-inline">cURL </strong>command with the <strong class="source-inline">POST</strong> verb, followed by a JSON document:</p>
			<p class="source-code">curl --location --request POST 'http://localhost:8080/recipes' \</p>
			<p class="source-code">--header 'Content-Type: application/json' \</p>
			<p class="source-code">--data-raw '{</p>
			<p class="source-code">   "name": "Homemade Pizza",</p>
			<p class="source-code">   "tags" : ["italian", "pizza", "dinner"],</p>
			<p class="source-code">   "ingredients": [</p>
			<p class="source-code">       "1 1/2 cups (355 ml) warm water (105°F-115°F)",</p>
			<p class="source-code">       "1 package (2 1/4 teaspoons) of active dry yeast",</p>
			<p class="source-code">       "3 3/4 cups (490 g) bread flour",</p>
			<p class="source-code">       "feta cheese, firm mozzarella cheese, grated"</p>
			<p class="source-code">   ],</p>
			<p class="source-code">   "instructions": [</p>
			<p class="source-code">       "Step 1.",</p>
			<p class="source-code">       "Step 2.",</p>
			<p class="source-code">       "Step 3."</p>
			<p class="source-code">   ]</p>
			<p class="source-code">}' | jq -r</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">jq</strong> utility <a href="https://stedolan.github.io/jq/">https://stedolan.github.io/jq/</a> is used to format the response body in JSON format. It's a powerful command-line JSON processor.</p>
			<p>With the POST endpoint <a id="_idIndexMarker099"/>working as expected, we can push the <a id="_idIndexMarker100"/>code changes to a new feature branch:</p>
			<p class="source-code">git checkout -b feature/new_recipe</p>
			<p class="source-code">git add .</p>
			<p class="source-code">git commit -m "new recipe endpoint"</p>
			<p class="source-code">git push origin feature/new_recipe</p>
			<p>Once committed, raise a pull request to merge the <strong class="source-inline">feature/new_recipe</strong> branch with the <strong class="source-inline">develop</strong> branch:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B17115_02_08.jpg" alt="Figure 2.8 – Merging a new recipe endpoint feature branch into the develop branch&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – Merging a new recipe endpoint feature branch into the develop branch</p>
			<p>Make sure to <a id="_idIndexMarker101"/>delete the <a id="_idIndexMarker102"/>feature branch once the changes have been merged.</p>
			<p>Now that the <strong class="source-inline">POST /recipes</strong> endpoint has been created, we can implement a <strong class="source-inline">GET /recipes</strong> endpoint to list all the recipes we have added using the <strong class="source-inline">POST/recipes</strong> endpoint. </p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor044"/>GET /recipes</h2>
			<p>Similar to the <a id="_idIndexMarker103"/>previous endpoint, register a <strong class="source-inline">GET</strong> method on the <strong class="source-inline">/recipes</strong> resource and attach <strong class="source-inline">ListRecipesHandler</strong>. The function will be invoked when <a id="_idIndexMarker104"/>an incoming GET request is received on the <strong class="source-inline">/recipes</strong> resource. The code is straightforward; it marshals the <strong class="source-inline">recipes</strong> array to JSON with the <strong class="source-inline">c.JSON()</strong> method:</p>
			<p class="source-code">func ListRecipesHandler(c *gin.Context) {</p>
			<p class="source-code">   c.JSON(http.StatusOK, recipes)</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">   router := gin.Default()</p>
			<p class="source-code">   router.POST("/recipes", NewRecipeHandler)</p>
			<p class="source-code">   router.GET("/recipes", ListRecipesHandler)</p>
			<p class="source-code">   router.Run()</p>
			<p class="source-code">}</p>
			<p>Redeploy the <a id="_idIndexMarker105"/>app with <a id="_idIndexMarker106"/>the <strong class="source-inline">go run main.go</strong> command:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B17115_02_09.jpg" alt="Figure 2.9 – Exposing a GET endpoint&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – Exposing a GET endpoint</p>
			<p>To test the endpoint, issue a GET request on <strong class="source-inline">http://localhost:8080/recipes</strong>. Here, an empty array will be returned:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B17115_02_10.jpg" alt="Figure 2.10 – Fetching a list of recipes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – Fetching a list of recipes</p>
			<p>The corresponding <strong class="source-inline">cURL</strong> command is as follows:</p>
			<p class="source-code">curl -s --location --request GET 'http://localhost:8080/recipes' \</p>
			<p class="source-code">--header 'Content-Type: application/json'</p>
			<p>The empty <a id="_idIndexMarker107"/>array is due to the fact the <strong class="source-inline">recipes</strong> variable is only available <a id="_idIndexMarker108"/>during the runtime of the application. In the next chapter, we will cover how to connect the RESTful API to a database such as MongoDB for data persistency. But for now, we can initialize the <strong class="source-inline">recipes</strong> array upon starting the application by placing the initialization code in the <strong class="source-inline">init()</strong> method.</p>
			<p>The loading mechanism will be based on a JSON file that contains a list of recipes that I have created in advance. The complete list is available in this book's GitHub repository:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B17115_02_11.jpg" alt="Figure 2.11 – List of recipes in JSON format&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – List of recipes in JSON format</p>
			<p>We will read the JSON file with the <strong class="source-inline">ioutil.ReadFile()</strong> method and then convert the content into an array of recipes with the following code snippet:</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">   recipes = make([]Recipe, 0)</p>
			<p class="source-code">   file, _ := ioutil.ReadFile("recipes.json")</p>
			<p class="source-code">   _ = json.Unmarshal([]byte(file), &amp;recipes)</p>
			<p class="source-code">}</p>
			<p>Don't forget to <a id="_idIndexMarker109"/>import <strong class="source-inline">encoding/json </strong>and <strong class="source-inline">io/ioutil</strong> before you <a id="_idIndexMarker110"/>rerun the application and issue a GET request on the <strong class="source-inline">/recipes</strong> endpoint. This time, a list of recipes will be returned in JSON format:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B17115_02_12.jpg" alt="Figure 2.12 – GET /recipes returning a list of recipes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.12 – GET /recipes returning a list of recipes</p>
			<p>You can use the <strong class="source-inline">curl</strong> and <strong class="source-inline">jq</strong> commands to count the number of recipes that are returned by the request:</p>
			<p class="source-code">curl -s -X GET 'http://localhost:8080/recipes' | jq length</p>
			<p>The <strong class="source-inline">recipes.json</strong> file contains 492 recipes; therefore, the HTTP request should return 492 recipes:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B17115_02_13.jpg" alt="Figure 2.13 – Using jq to count JSON items&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.13 – Using jq to count JSON items</p>
			<p>Commit the <a id="_idIndexMarker111"/>new endpoint code to Git by creating a new feature branch <a id="_idIndexMarker112"/>with the following commands:</p>
			<p class="source-code">git checkout -b feature/fetch_all_recipes</p>
			<p class="source-code">git add .</p>
			<p class="source-code">git commit -m "list recipes endpoint"</p>
			<p class="source-code">git push origin feature/fetch_all_recipes</p>
			<p>Once the changes have been pushed, create a pull request and merge the branch into <strong class="source-inline">develop</strong>:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B17115_02_14.jpg" alt="Figure 2.14 – Merging the list of recipes endpoint feature branch into the develop branch&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.14 – Merging the list of recipes endpoint feature branch into the develop branch</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor045"/>PUT /recipes/{id}</h2>
			<p>To update an <a id="_idIndexMarker113"/>existing recipe, we <a id="_idIndexMarker114"/>will use the <strong class="source-inline">PUT</strong> verb with a path query parameter called ID, representing the identifier of the recipe to be updated. Register an endpoint on the <strong class="source-inline">/recipes/:id</strong> resource inside your main function:</p>
			<p class="source-code">router.PUT("/recipes/:id", UpdateRecipeHandler)</p>
			<p>The <strong class="source-inline">UpdateRecipeHandler</strong> endpoint's handler code is provided in the following snippet. It fetches the recipe ID from the request URL with the <strong class="source-inline">c.Param()</strong> method, converts the request body into a <strong class="source-inline">Recipe</strong> struct, and loops through the list of recipes, looking for the recipe to update. If it's not found, an error message is sent with a 404 code error; otherwise, the <a id="_idIndexMarker115"/>recipe is updated with the new values from the <a id="_idIndexMarker116"/>request body:</p>
			<p class="source-code">func UpdateRecipeHandler(c *gin.Context) {</p>
			<p class="source-code">   id := c.Param("id")</p>
			<p class="source-code">   var recipe Recipe</p>
			<p class="source-code">   if err := c.ShouldBindJSON(&amp;recipe); err != nil {</p>
			<p class="source-code">       c.JSON(http.StatusBadRequest, gin.H{</p>
			<p class="source-code">          "error": err.Error()})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   }</p>
			<p class="source-code">   index := -1</p>
			<p class="source-code">   for i := 0; i &lt; len(recipes); i++ {</p>
			<p class="source-code">       if recipes[i].ID == id {</p>
			<p class="source-code">           index = i</p>
			<p class="source-code">       }</p>
			<p class="source-code">   }</p>
			<p class="source-code">   if index == -1 {</p>
			<p class="source-code">       c.JSON(http.StatusNotFound, gin.H{</p>
			<p class="source-code">          "error": "Recipe not found"})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   }</p>
			<p class="source-code">   recipes[index] = recipe</p>
			<p class="source-code">   c.JSON(http.StatusOK, recipe)</p>
			<p class="source-code">}</p>
			<p>Relaunch the server, then <a id="_idIndexMarker117"/>issue a POST request to create a new recipe. To illustrate <a id="_idIndexMarker118"/>how the update endpoint is working, we will create a recipe for a margherita pizza with the following sample JSON:</p>
			<p class="source-code">{</p>
			<p class="source-code">   "name": "Homemade Pizza",</p>
			<p class="source-code">   "tags" : ["italian", "pizza", "dinner"],</p>
			<p class="source-code">   "ingredients": [</p>
			<p class="source-code">       "pizza dough",</p>
			<p class="source-code">       "tomato sauce",</p>
			<p class="source-code">       "olive oil",</p>
			<p class="source-code">       "7 ounces fresh mozzarella cheese, cut into </p>
			<p class="source-code">        1/2-inch cubes",</p>
			<p class="source-code">       "5 - 6 large fresh basil leaves"</p>
			<p class="source-code">   ],</p>
			<p class="source-code">   "instructions": []</p>
			<p class="source-code">}</p>
			<p>To test it out, once again with the Postman client, issue a new POST request on <strong class="source-inline">http://localhost:8080/recipes</strong> with this JSON document:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B17115_02_15.jpg" alt="Figure 2.15 – Adding a new recipe&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.15 – Adding a new recipe</p>
			<p>The <strong class="source-inline">Homemade Pizza</strong> recipe <a id="_idIndexMarker119"/>will be created, and you will have <a id="_idIndexMarker120"/>received the ID of the new recipe (in our example, it is <strong class="source-inline">c2inb6q3k1kc2p0uqetg</strong>). Let's say we want to update the recipe and change it to <strong class="source-inline">Shrimp scampi pizza</strong>. This time, we can use the <strong class="source-inline">PUT</strong> method and provide the ID of the recipe as a <strong class="source-inline">path</strong> parameter:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B17115_Figure_2.16.jpg" alt="Figure 2.16 – Updating an existing recipe&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.16 – Updating an existing recipe</p>
			<p>The request will <a id="_idIndexMarker121"/>return a 200 status code. To verify that the <a id="_idIndexMarker122"/>changes have taken effect, we can use the <strong class="source-inline">GET /recipes</strong> endpoint:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B17115_Figure_2.17.jpg" alt="Figure 2.17 – Verifying the changes are being applied to the recipe&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.17 – Verifying the changes are being applied to the recipe</p>
			<p>Push the new endpoint to a new feature branch and merge the branch into <strong class="source-inline">develop</strong>:</p>
			<p class="source-code">git checkout -b feature/update_recipe</p>
			<p class="source-code">git add .</p>
			<p class="source-code">git commit -m "update recipe endpoint"</p>
			<p class="source-code">git push origin feature/update_recipe</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor046"/>DELETE /recipes/{id}</h2>
			<p>To delete a recipe, we <a id="_idIndexMarker123"/>need to <a id="_idIndexMarker124"/>register the <strong class="source-inline">DELETE</strong> HTTP route inside our main function, as follows:</p>
			<p class="source-code">router.DELETE("/recipes/:id", DeleteRecipeHandler)</p>
			<p>The <strong class="source-inline">DeleteRecipeHandler</strong> function's code will get the target recipe ID from the request parameter and loop through the list of recipes. If no matching recipe is found, an error message of <strong class="source-inline">"Recipe not found"</strong> will be sent with a 404 status code. Otherwise, the recipe index on the array will be used and the recipe will be deleted based on the index:</p>
			<p class="source-code">func DeleteRecipeHandler(c *gin.Context) {</p>
			<p class="source-code">   id := c.Param("id")</p>
			<p class="source-code">   index := -1</p>
			<p class="source-code">   for i := 0; i &lt; len(recipes); i++ {</p>
			<p class="source-code">       if recipes[i].ID == id {</p>
			<p class="source-code">           index = i</p>
			<p class="source-code">       }</p>
			<p class="source-code">   }</p>
			<p class="source-code">   if index == -1 {</p>
			<p class="source-code">       c.JSON(http.StatusNotFound, gin.H{</p>
			<p class="source-code">          "error": "Recipe not found"})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   }</p>
			<p class="source-code">   recipes = append(recipes[:index], recipes[index+1:]...)</p>
			<p class="source-code">   c.JSON(http.StatusOK, gin.H{</p>
			<p class="source-code">      "message": "Recipe has been deleted"))</p>
			<p class="source-code">}</p>
			<p>To test the delete endpoint, use the <a id="_idIndexMarker125"/>Postman client or issue a <strong class="source-inline">cURL</strong> command in <a id="_idIndexMarker126"/>the terminal session:</p>
			<p class="source-code">curl -v -sX DELETE http://localhost:8080/recipes/c0283p3d0cvuglq85log | jq -r</p>
			<p>If the target recipe exists, then it will be deleted, and you will see that a success message is returned:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B17115_02_18.jpg" alt="Figure 2.18 – Deleting a recipe&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.18 – Deleting a recipe</p>
			<p>Otherwise, an error message will be returned:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B17115_02_19.jpg" alt="Figure 2.19 – An error 404 message is returned if the recipe is not found&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.19 – An error 404 message is returned if the recipe is not found</p>
			<p>Once again, store the changes in a <a id="_idIndexMarker127"/>feature branch and merge the <a id="_idIndexMarker128"/>changes into <strong class="source-inline">develop</strong>:</p>
			<p class="source-code">git checkout -b feature/delete_recipe</p>
			<p class="source-code">git add .</p>
			<p class="source-code">git commit -m "delete recipe endpoint"</p>
			<p class="source-code">git push origin feature/delete_recipe</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor047"/>GET /recipes/search</h2>
			<p>The final <a id="_idIndexMarker129"/>endpoint allows users to <a id="_idIndexMarker130"/>search for recipes based on tags or keywords:</p>
			<p class="source-code">router.GET("/recipes/search", SearchRecipesHandler)</p>
			<p>The <strong class="source-inline">SearchRecipesHandler</strong> handler code snippet is as follows (don't forget to import <strong class="source-inline">strings</strong>):</p>
			<p class="source-code">func SearchRecipesHandler(c *gin.Context) {</p>
			<p class="source-code">   tag := c.Query("tag")</p>
			<p class="source-code">   listOfRecipes := make([]Recipe, 0)</p>
			<p class="source-code">   for i := 0; i &lt; len(recipes); i++ {</p>
			<p class="source-code">       found := false</p>
			<p class="source-code">       for _, t := range recipes[i].Tags {</p>
			<p class="source-code">           if strings.EqualFold(t, tag) {</p>
			<p class="source-code">               found = true</p>
			<p class="source-code">           }</p>
			<p class="source-code">       }</p>
			<p class="source-code">       if found {</p>
			<p class="source-code">           listOfRecipes = append(listOfRecipes, </p>
			<p class="source-code">              recipes[i])</p>
			<p class="source-code">       }</p>
			<p class="source-code">   }</p>
			<p class="source-code">   c.JSON(http.StatusOK, listOfRecipes)</p>
			<p class="source-code">}</p>
			<p>The HTTP <a id="_idIndexMarker131"/>handler fetches the <a id="_idIndexMarker132"/>tag value given in the query parameter with the <strong class="source-inline">c.Query</strong> method.</p>
			<p>You can test the endpoint by looking for Italian recipes with a GET request at <a href="http://localhost:8080/recipes/search?tag=italian">http://localhost:8080/recipes/search?tag=italian</a>:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B17115_02_20.jpg" alt="Figure 2.20 – Searching for recipes with a query parameter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.20 – Searching for recipes with a query parameter</p>
			<p>Finally, push <a id="_idIndexMarker133"/>the search <a id="_idIndexMarker134"/>endpoint code to the remote repository by creating a new feature branch:</p>
			<p class="source-code">git checkout -b feature/search_recipe</p>
			<p class="source-code">git add .</p>
			<p class="source-code">git commit -m "search recipe by tag"</p>
			<p class="source-code">git push origin feature/search_recipe</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before each commit, make sure to run the <strong class="source-inline">go mod tidy</strong> command to ensure your <strong class="source-inline">go.mod</strong> and <strong class="source-inline">go.sum</strong> files are clean and accurate.</p>
			<p>So far, we have <a id="_idIndexMarker135"/>covered how to build a RESTful API in Golang <a id="_idIndexMarker136"/>with the Gin framework. However, without meaningful documentation of the API, users won't be able to use it.</p>
			<p>Documentation should be part of your development cycle, to help you maintain a scalable API. That's why, in the next section, we will explore how to use the <strong class="bold">OpenAPI Specification</strong> (<strong class="bold">OAS</strong>).</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor048"/>Writing the OpenAPI Specification</h1>
			<p>The OpenAPI Specification (formerly known as the Swagger Specification) is an API description format or API definition language. It <a id="_idIndexMarker137"/>allows you to describe an API, including the following information:</p>
			<ul>
				<li>General information about the API</li>
				<li>The available paths and operations (HTTP methods)</li>
				<li>The expected inputs (query or path parameters, request body, and so on) and responses (HTTP status code, response body, and so on) for each operation</li>
			</ul>
			<p>Finding an easy way to generate the OpenAPI definition from an existing API can be challenging. The good news is that Swagger tools can help you do this with ease.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor049"/>Installing Go Swagger</h2>
			<p>To get <a id="_idIndexMarker138"/>started, install the <strong class="source-inline">go-swagger</strong> tool from the official <a id="_idIndexMarker139"/>guide at <a href="https://goswagger.io/install.html">https://goswagger.io/install.html</a> or download the binary from GitHub at <a href="https://github.com/go-swagger/go-swagger/releases">https://github.com/go-swagger/go-swagger/releases</a>. At the time of writing this book, the latest stable version is v0.25.0:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B17115_02_21.jpg" alt="Figure 2.21 – Go Swagger binary – latest release&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.21 – Go Swagger binary – latest release</p>
			<p>Make sure to <a id="_idIndexMarker140"/>add it to the <strong class="source-inline">PATH</strong> environment variable. Then, issue the following command to verify the installation:</p>
			<p class="source-code">go-swagger version</p>
			<p>The preceding command should display the following output:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B17115_02_22.jpg" alt="Figure 2.22 – Go Swagger version&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.22 – Go Swagger version</p>
			<p>Now, it's time to write our OpenAPI Specification for the recipes API.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">An <a id="_idIndexMarker141"/>alternative to <strong class="source-inline">go-swagger</strong> is <strong class="source-inline">swag</strong> (<a href="https://github.com/swaggo/swag">https://github.com/swaggo/swag</a>). This tool can be used to convert Go annotations into Swagger documentation.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor050"/>Swagger metadata</h2>
			<p>We'll start by providing <a id="_idIndexMarker142"/>some basic <a id="_idIndexMarker143"/>information about the API with the <strong class="source-inline">swagger:meta</strong> annotation. This annotation has the following properties:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/02.jpg" alt=""/>
				</div>
			</div>
			<p>Add the following comments at the top of the <strong class="source-inline">main</strong> package:</p>
			<p class="source-code">// Recipes API</p>
			<p class="source-code">//</p>
			<p class="source-code">// This is a sample recipes API. You can find out more about the API at https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin.</p>
			<p class="source-code">//</p>
			<p class="source-code">//  Schemes: http</p>
			<p class="source-code">//  Host: localhost:8080</p>
			<p class="source-code">//  BasePath: /</p>
			<p class="source-code">//  Version: 1.0.0</p>
			<p class="source-code">//  Contact: Mohamed Labouardy </p>
			<p class="source-code">// &lt;mohamed@labouardy.com&gt; https://labouardy.com</p>
			<p class="source-code">//</p>
			<p class="source-code">//  Consumes:</p>
			<p class="source-code">//  - application/json</p>
			<p class="source-code">//</p>
			<p class="source-code">//  Produces:</p>
			<p class="source-code">//  - application/json</p>
			<p class="source-code">// swagger:meta</p>
			<p class="source-code">package main</p>
			<p>These <a id="_idIndexMarker144"/>comments include <a id="_idIndexMarker145"/>things such as the API's description, version, base URL, and so on. There are more fields that you can include (a full list is available at <a href="https://goswagger.io/use/spec/meta.html">https://goswagger.io/use/spec/meta.html</a>).</p>
			<p>To generate the OpenAPI Specification, we will use the <strong class="source-inline">swagger</strong> command-line tool. The CLI will parse the <strong class="source-inline">main.go</strong> file. If the parser encounters a comment that matches the Swagger annotation or any supported tags, it will generate the corresponding block of the specification.</p>
			<p>On your Terminal, issue the following command to generate a <strong class="source-inline">spec</strong> file:</p>
			<p class="source-code">swagger generate spec –o ./swagger.json</p>
			<p>This command will generate the specification in JSON format. You can generate the spec in YAML format as well by just appending the output with the <strong class="source-inline">.yml</strong> or <strong class="source-inline">.yaml</strong> extension.</p>
			<p>The content of the <a id="_idIndexMarker146"/>generated <strong class="source-inline">swagger.json</strong> file will <a id="_idIndexMarker147"/>look as follows:</p>
			<p class="source-code">{</p>
			<p class="source-code">"consumes": [</p>
			<p class="source-code">   "application/json"</p>
			<p class="source-code">],</p>
			<p class="source-code">"produces": [</p>
			<p class="source-code">   "application/json"</p>
			<p class="source-code">],</p>
			<p class="source-code">"schemes": [</p>
			<p class="source-code">   "http"</p>
			<p class="source-code">],</p>
			<p class="source-code">"swagger": "2.0",</p>
			<p class="source-code">"info": {</p>
			<p class="source-code">   "description": "This is a sample recipes API. You can </p>
			<p class="source-code">    find out more about the API at https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin.",</p>
			<p class="source-code">   "title": "Recipes API",</p>
			<p class="source-code">   "contact": {</p>
			<p class="source-code">     "name": "Mohamed Labouardy",</p>
			<p class="source-code">     "url": "https://labouardy.com",</p>
			<p class="source-code">     "email": "mohamed@labouardy.com"</p>
			<p class="source-code">   },</p>
			<p class="source-code">   "version": "1.0.0"</p>
			<p class="source-code">},</p>
			<p class="source-code">"host": "localhost:8080",</p>
			<p class="source-code">"basePath": "/",</p>
			<p class="source-code">"paths": {}</p>
			<p class="source-code">} </p>
			<p>Another cool thing <a id="_idIndexMarker148"/>with the Swagger command line is its embedded UI. You can <a id="_idIndexMarker149"/>load the generated spec in the Swagger UI locally with the following command:</p>
			<p class="source-code">swagger serve ./swagger.json</p>
			<p>The UI will be exposed on port <strong class="source-inline">http://localhost:49566</strong>:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B17115_02_23.jpg" alt="Figure 2.23 – Loading the Swagger specs in the UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.23 – Loading the Swagger specs in the UI</p>
			<p>If you point your browser to that URL, you should see the UI based on the Redoc template. The UI comes in two two flavors – Redoc and the Swagger UI:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B17115_02_24.jpg" alt="Figure 2.24 – Swagger with a Redoc flavor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.24 – Swagger with a Redoc flavor</p>
			<p>If you're a fan of the Swagger UI, you can set the flavor flag to <strong class="source-inline">swagger</strong> with the following command:</p>
			<p class="source-code">swagger serve -F swagger ./swagger.json</p>
			<p>This time, the API specification will be served from the Swagger UI:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B17115_02_25.jpg" alt="Figure 2.25 – Swagger UI mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.25 – Swagger UI mode</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also <a id="_idIndexMarker150"/>use the Swagger Online Editor (<a href="https://editor.swagger.io/">https://editor.swagger.io/</a>) to edit and load your OpenAPI Specification file.</p>
			<p>Next, we <a id="_idIndexMarker151"/>will define a <strong class="source-inline">swagger:operation</strong> for listing recipe endpoints. The <a id="_idIndexMarker152"/>annotation has the following attributes:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/03.jpg" alt=""/>
				</div>
			</div>
			<p>You can find all the properties at <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject">https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject</a>.</p>
			<p>Annotate the <strong class="source-inline">ListRecipesHandler</strong> function, as <a id="_idIndexMarker153"/>shown here. The annotation <a id="_idIndexMarker154"/>takes the HTTP method, path pattern, and operation ID as parameters:</p>
			<p class="source-code">// swagger:operation GET /recipes recipes listRecipes</p>
			<p class="source-code">// Returns list of recipes</p>
			<p class="source-code">// ---</p>
			<p class="source-code">// produces:</p>
			<p class="source-code">// - application/json</p>
			<p class="source-code">// responses:</p>
			<p class="source-code">//     '200':</p>
			<p class="source-code">//         description: Successful operation</p>
			<p class="source-code">func ListRecipesHandler(c *gin.Context) {</p>
			<p class="source-code">   c.JSON(http.StatusOK, recipes)</p>
			<p class="source-code">}</p>
			<p>For each operation, you can describe the HTTP response that matches an HTTP status code (200, 404, and so on) in the <strong class="source-inline">responses</strong> section. For this endpoint, we'll only return a 200 success code when responding to <strong class="source-inline">GET</strong> /<strong class="source-inline">recipes</strong>. The <strong class="source-inline">description</strong> field explains what this response means.</p>
			<p>Generate the specification with the Swagger CLI and reload <strong class="source-inline">swagger.json</strong>. This time, the <strong class="source-inline">GET</strong> /recipes operation will be added:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B17115_02_26.jpg" alt="Figure 2.26 – Adding a new Swagger operation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.26 – Adding a new Swagger operation</p>
			<p>Define another <a id="_idIndexMarker155"/>Swagger operation for the <strong class="source-inline">PUT /recipes/{id}</strong> endpoint. Similar to <a id="_idIndexMarker156"/>the previous operation, we can define responses based on the handled response code. We can also define the ID as a <strong class="source-inline">path</strong> parameter in the <strong class="source-inline">parameters</strong> section. As well as provide an optional description, as follows:</p>
			<p class="source-code">// swagger:operation PUT /recipes/{id} recipes updateRecipe</p>
			<p class="source-code">// Update an existing recipe</p>
			<p class="source-code">// ---</p>
			<p class="source-code">// parameters:</p>
			<p class="source-code">// - name: id</p>
			<p class="source-code">//   in: path</p>
			<p class="source-code">//   description: ID of the recipe</p>
			<p class="source-code">//   required: true</p>
			<p class="source-code">//   type: string</p>
			<p class="source-code">// produces:</p>
			<p class="source-code">// - application/json</p>
			<p class="source-code">// responses:</p>
			<p class="source-code">//     '200':</p>
			<p class="source-code">//         description: Successful operation</p>
			<p class="source-code">//     '400':</p>
			<p class="source-code">//         description: Invalid input</p>
			<p class="source-code">//     '404':</p>
			<p class="source-code">//         description: Invalid recipe ID</p>
			<p class="source-code">func UpdateRecipeHandler(c *gin.Context) {}</p>
			<p>Regenerate <a id="_idIndexMarker157"/>the <strong class="source-inline">swagger.json</strong> file and reload <a id="_idIndexMarker158"/>the Swagger UI:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B17115_02_27.jpg" alt="Figure 2.27 – PUT operation in Swagger&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.27 – PUT operation in Swagger</p>
			<p>Define the rest of the operations. You should have something similar to the following:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B17115_02_28.jpg" alt="Figure 2.28 – Recipes API operations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.28 – Recipes API operations</p>
			<p>With that, you have learned the basics of the OpenAPI Specification.</p>
			<p>Being a simple JSON file, the <a id="_idIndexMarker159"/>OpenAPI Specification file can be shared and managed <a id="_idIndexMarker160"/>within any SCM, just like the application source code. Commit the <strong class="source-inline">spec</strong> file to GitHub with the following commands:</p>
			<p class="source-code">git checkout -b feature/openapi</p>
			<p class="source-code">git add .</p>
			<p class="source-code">git commit -m "added openapi specs"</p>
			<p class="source-code">git push origin feature/openapi</p>
			<p>The updated repository will look as follows:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B17115_02_29.jpg" alt="Figure 2.29 – Storing the OpenAPI Specification on GitHub&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.29 – Storing the OpenAPI Specification on GitHub</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor051"/>Summary</h1>
			<p>In this chapter, you learned how to build a RESTful API from scratch with the Gin framework. We also covered how to validate incoming HTTP requests with Gin data binding and validation methods. Then, we provided an introduction to the OpenAPI Specification and learned how to generate it from an existing API. You should now be familiar with exposing HTTP methods (GET, POST, DELETE, PUT, and so on) to handle HTTP requests.</p>
			<p>In the next chapter, we will use MongoDB as a NoSQL database to manage data persistency for our API.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor052"/>Questions</h1>
			<ol>
				<li>What's the GitFlow strategy?</li>
				<li>How can we define a data model in Go?</li>
				<li>How can we validate a POST request body in Gin?</li>
				<li>Define an API endpoint that can get one recipe by ID.</li>
				<li>Define a body parameter of the new recipe endpoint with OpenAPI.</li>
			</ol>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor053"/>Further reading</h1>
			<ul>
				<li><em class="italic">Hands-On RESTful API Design Patterns and Best Practices</em>, by Harihara Subramanian, Pethuru Raj, Packt Publishing</li>
				<li><em class="italic">DevOps with GIT(Flow) Jenkins, Artifactory, Sonar, ELK, JIRA [Video]</em>, by Nand Venegalla, Packt Publishing</li>
			</ul>
		</div>
	</body></html>