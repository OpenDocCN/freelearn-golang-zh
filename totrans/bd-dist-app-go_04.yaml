- en: 'Chapter 2: Setting Up API Endpoints'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to build our first Gin web application.
    In this one, we're going to build a complete RESTful API from scratch. Along the
    way, we will explore HTTP methods and advanced routing features. We'll also cover
    how to write the OpenAPI Specification and how to generate API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring API functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing HTTP routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the OpenAPI Specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll be familiar with the routing mechanisms of
    Gin, HTTP methods, and data validation.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you''ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A laptop (Windows, Linux, or macOS) with Golang version 1.15.6 set up so that
    you can easily execute the commands provided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A general understanding of the RESTful API and the Go programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter02](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter02)
  prefs: []
  type: TYPE_NORMAL
- en: Exploring API functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate how to build a RESTful API, we will build a cooking application.
    We will cover how to integrate, deploy, and test the app using the Gin framework.
    The application will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Display the recipes that are submitted by the users, along with their ingredients
    and instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow anyone to post a new recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The application architecture and flow are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Recipes application architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Recipes application architecture
  prefs: []
  type: TYPE_NORMAL
- en: The architecture is composed of a microservice written with the Gin framework
    and a database for data persistency. The microservice exposes a RESTful API to
    manage the recipes through the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book, we will cover how to build a frontend application with the
    React web framework so that we can consume the RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started, we need to create a GitHub repository where the code
    source will be stored. To structure the code within Git branches, we will use
    the GitFlow model. This approach consists of the following branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**master**: This branch corresponds to the current production code. You can''t
    commit directly, except for hotfixes. Git tags can be used to tag all the commits
    in the master branch with a version number (for instance, for using the semantic
    versioning convention, [https://semver.org/](https://semver.org/), which has three
    parts: major, minor, and patch, so a tag with version 1.2.3 has 1 as its major
    version, 2 as its minor version, and 3 as its patch version).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**preprod**: This is a release branch and is a mirror of production. It can
    be used to test all the new features that are developed on the develop branch
    before they are merged to the master branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**develop**: This is the development integration branch, which contains the
    latest integrated development code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**feature/X**: This is an individual feature branch that''s being developed.
    Each new feature resides in its own branch, and they''re generally created for
    the latest develop branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hotfix/X**: When you need to solve something in production code, you can
    use the hotfix branch and open a pull request for the master branch. This branch
    is based on the master branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following schema illustrates the GitFlow approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – GitFlow model – main branches'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – GitFlow model – main branches
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the GitHub repository has been created, clone it to your Go workspace
    and create three main branches called `develop`, `preprod`, and `master` . This
    will help you organize the project and isolate the code under development from
    the code running in production. This branching strategy is a slimmer version of
    the GitFlow workflow branching model (don''t forget to replace the GitHub URL
    with a link to your repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new directory called `recipes-api`. Let''s make this directory
    the root of a module by executing the following command. This will enable us to
    manage project dependencies with the `go.mod` and `go.sum` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the project folder on VSCode and create a `main.go` file with the following
    code. The `main` function will initialize a new Gin router and run an HTTP server
    on port `8080` by invoking the `Run()` method of our Gin instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you install the `gin` package with the `go get` command. Refer
    to the previous chapter for a step-by-step guide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Push the changes to the Git remote repository. For now, we will push the changes
    directly to the `develop` branch. We will learn how to open pull requests in the
    next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The updated repository should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – GitHub branches'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – GitHub branches
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you're working with a team of developers, you will need to issue the `go
    mod download` command to install the required dependencies after cloning the project
    from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sub-section, we'll see how you can define the data model.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before digging into the routes definition, we need to define a model that will
    hold information about a recipe. We can create our model by defining a Go struct.
    This model will contain the properties/fields of a recipe. Declare the following
    struct in the `main.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our `Recipe` model is self-explanatory. Each recipe should have a name, a list
    of ingredients, a list of instructions or steps, and a publication date. Moreover,
    each recipe belongs to a set of categories or tags (for example, vegan, Italian,
    pastry, salads, and so on), as well as an ID, which is a unique identifier to
    differentiate each recipe in the database. We will also specify the tags on each
    field using backtick annotation; for example, `` `json:"NAME"` ``. This allows
    us to map each field to a different name when we send them as responses, since
    JSON and Go have different naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the struct has been defined, push the changes to a new branch based on
    the `develop` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve pushed these changes to your repository, the `feature/datamodel`
    with the `develop` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – GitHub pull request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – GitHub pull request
  prefs: []
  type: TYPE_NORMAL
- en: 'Merge the changes to the `develop` branch and delete the `feature/datamodel`
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Merging the pull request into the develop branch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Merging the pull request into the develop branch
  prefs: []
  type: TYPE_NORMAL
- en: With the data model defined, we can look at the route handler definitions. The
    API will expose various endpoints. Let's take a look at them now.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table shows the list of HTTP endpoints that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are going to establish the endpoints of our API. We will set this up
    by creating all our endpoints in the `main` function. Every endpoint needs a separate
    function to handle the request. We will define them in the `main.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how to structure the Go project according
    to the standard Go layout.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing HTTP routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create function handlers to handle POST, GET, PUT,
    and DELETE HTTP requests. So, let's jump right into it.
  prefs: []
  type: TYPE_NORMAL
- en: POST /recipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s implement the endpoint responsible for creating a new recipe.
    Create a POST method on the `/recipes` resource. Then, define a `NewRecipeHandler`
    method for that path. The `main.go` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Before writing the code of the `NewRecipeHandler` method, we need to define
    a global variable called `recipes` to store the list of recipes. This variable
    will be used temporarily and will be replaced in the next chapter with a database
    for data persistency. To initialize the `recipes` variable, we can use the `init()`
    method, which will be executed during the startup of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will define the logic behind `NewRecipeHandler`. The `c.ShouldBindJSON`
    function marshals the incoming request body into a `Recipe` struct and then assigns
    a unique identifier with an external package called `xid`. Next, it assigns a
    publication date with the `time.Now()` function and appends the recipe to the
    list of recipes, which will keep it in memory. If the request body is invalid,
    then the handler will return an error (400 status code). Otherwise, the handler
    will return a 200 status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we used a built-in status code constants such as `http.StatusOK`
    and `http.StatusBadRequest` instead of a hardcoded HTTP status code. We're also
    setting the response type to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the application, we need to download the `xid` package, which
    is used to generate a unique ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The new dependency will be added automatically to the `go.sum` and `go.mod`
    files. Run the server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'An HTTP server will be deployed on port `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Gin server logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Gin server logs
  prefs: []
  type: TYPE_NORMAL
- en: 'To test it out, issue a POST request with the Postman client at http://localhost:8080/recipes
    with the following JSON in the request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Issuing a POST request with the Postman client'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Issuing a POST request with the Postman client
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command will add the recipe to the array of recipes and return
    it with an assigned ID and publication date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another alternative to Postman is to use the `cURL` command. Use the following
    `cURL` command with the `POST` verb, followed by a JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `jq` utility [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)
    is used to format the response body in JSON format. It's a powerful command-line
    JSON processor.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the POST endpoint working as expected, we can push the code changes to
    a new feature branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once committed, raise a pull request to merge the `feature/new_recipe` branch
    with the `develop` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Merging a new recipe endpoint feature branch into the develop
    branch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Merging a new recipe endpoint feature branch into the develop branch
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to delete the feature branch once the changes have been merged.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `POST /recipes` endpoint has been created, we can implement a `GET
    /recipes` endpoint to list all the recipes we have added using the `POST/recipes`
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: GET /recipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the previous endpoint, register a `GET` method on the `/recipes`
    resource and attach `ListRecipesHandler`. The function will be invoked when an
    incoming GET request is received on the `/recipes` resource. The code is straightforward;
    it marshals the `recipes` array to JSON with the `c.JSON()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Redeploy the app with the `go run main.go` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Exposing a GET endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Exposing a GET endpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the endpoint, issue a GET request on `http://localhost:8080/recipes`.
    Here, an empty array will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Fetching a list of recipes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Fetching a list of recipes
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding `cURL` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The empty array is due to the fact the `recipes` variable is only available
    during the runtime of the application. In the next chapter, we will cover how
    to connect the RESTful API to a database such as MongoDB for data persistency.
    But for now, we can initialize the `recipes` array upon starting the application
    by placing the initialization code in the `init()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loading mechanism will be based on a JSON file that contains a list of
    recipes that I have created in advance. The complete list is available in this
    book''s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – List of recipes in JSON format'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – List of recipes in JSON format
  prefs: []
  type: TYPE_NORMAL
- en: 'We will read the JSON file with the `ioutil.ReadFile()` method and then convert
    the content into an array of recipes with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to import `encoding/json` and `io/ioutil` before you rerun the
    application and issue a GET request on the `/recipes` endpoint. This time, a list
    of recipes will be returned in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – GET /recipes returning a list of recipes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – GET /recipes returning a list of recipes
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `curl` and `jq` commands to count the number of recipes that
    are returned by the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `recipes.json` file contains 492 recipes; therefore, the HTTP request should
    return 492 recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Using jq to count JSON items'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 – Using jq to count JSON items
  prefs: []
  type: TYPE_NORMAL
- en: 'Commit the new endpoint code to Git by creating a new feature branch with the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the changes have been pushed, create a pull request and merge the branch
    into `develop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Merging the list of recipes endpoint feature branch into the
    develop branch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14 – Merging the list of recipes endpoint feature branch into the develop
    branch
  prefs: []
  type: TYPE_NORMAL
- en: PUT /recipes/{id}
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update an existing recipe, we will use the `PUT` verb with a path query
    parameter called ID, representing the identifier of the recipe to be updated.
    Register an endpoint on the `/recipes/:id` resource inside your main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UpdateRecipeHandler` endpoint''s handler code is provided in the following
    snippet. It fetches the recipe ID from the request URL with the `c.Param()` method,
    converts the request body into a `Recipe` struct, and loops through the list of
    recipes, looking for the recipe to update. If it''s not found, an error message
    is sent with a 404 code error; otherwise, the recipe is updated with the new values
    from the request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Relaunch the server, then issue a POST request to create a new recipe. To illustrate
    how the update endpoint is working, we will create a recipe for a margherita pizza
    with the following sample JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To test it out, once again with the Postman client, issue a new POST request
    on `http://localhost:8080/recipes` with this JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Adding a new recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 – Adding a new recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Homemade Pizza` recipe will be created, and you will have received the
    ID of the new recipe (in our example, it is `c2inb6q3k1kc2p0uqetg`). Let''s say
    we want to update the recipe and change it to `Shrimp scampi pizza`. This time,
    we can use the `PUT` method and provide the ID of the recipe as a `path` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Updating an existing recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_Figure_2.16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.16 – Updating an existing recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'The request will return a 200 status code. To verify that the changes have
    taken effect, we can use the `GET /recipes` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Verifying the changes are being applied to the recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_Figure_2.17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17 – Verifying the changes are being applied to the recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'Push the new endpoint to a new feature branch and merge the branch into `develop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: DELETE /recipes/{id}
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete a recipe, we need to register the `DELETE` HTTP route inside our
    main function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DeleteRecipeHandler` function''s code will get the target recipe ID from
    the request parameter and loop through the list of recipes. If no matching recipe
    is found, an error message of `"Recipe not found"` will be sent with a 404 status
    code. Otherwise, the recipe index on the array will be used and the recipe will
    be deleted based on the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the delete endpoint, use the Postman client or issue a `cURL` command
    in the terminal session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If the target recipe exists, then it will be deleted, and you will see that
    a success message is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Deleting a recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.18 – Deleting a recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, an error message will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – An error 404 message is returned if the recipe is not found'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.19 – An error 404 message is returned if the recipe is not found
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, store the changes in a feature branch and merge the changes into
    `develop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: GET /recipes/search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final endpoint allows users to search for recipes based on tags or keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SearchRecipesHandler` handler code snippet is as follows (don''t forget
    to import `strings`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP handler fetches the tag value given in the query parameter with the
    `c.Query` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test the endpoint by looking for Italian recipes with a GET request
    at [http://localhost:8080/recipes/search?tag=italian](http://localhost:8080/recipes/search?tag=italian):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Searching for recipes with a query parameter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.20 – Searching for recipes with a query parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, push the search endpoint code to the remote repository by creating
    a new feature branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before each commit, make sure to run the `go mod tidy` command to ensure your
    `go.mod` and `go.sum` files are clean and accurate.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered how to build a RESTful API in Golang with the Gin framework.
    However, without meaningful documentation of the API, users won't be able to use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation should be part of your development cycle, to help you maintain
    a scalable API. That's why, in the next section, we will explore how to use the
    **OpenAPI Specification** (**OAS**).
  prefs: []
  type: TYPE_NORMAL
- en: Writing the OpenAPI Specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The OpenAPI Specification (formerly known as the Swagger Specification) is
    an API description format or API definition language. It allows you to describe
    an API, including the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: General information about the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The available paths and operations (HTTP methods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expected inputs (query or path parameters, request body, and so on) and
    responses (HTTP status code, response body, and so on) for each operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding an easy way to generate the OpenAPI definition from an existing API
    can be challenging. The good news is that Swagger tools can help you do this with
    ease.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Go Swagger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, install the `go-swagger` tool from the official guide at [https://goswagger.io/install.html](https://goswagger.io/install.html)
    or download the binary from GitHub at [https://github.com/go-swagger/go-swagger/releases](https://github.com/go-swagger/go-swagger/releases).
    At the time of writing this book, the latest stable version is v0.25.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21 – Go Swagger binary – latest release'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.21 – Go Swagger binary – latest release
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to add it to the `PATH` environment variable. Then, issue the following
    command to verify the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command should display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – Go Swagger version'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.22 – Go Swagger version
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to write our OpenAPI Specification for the recipes API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to `go-swagger` is `swag` ([https://github.com/swaggo/swag](https://github.com/swaggo/swag)).
    This tool can be used to convert Go annotations into Swagger documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by providing some basic information about the API with the `swagger:meta`
    annotation. This annotation has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following comments at the top of the `main` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These comments include things such as the API's description, version, base URL,
    and so on. There are more fields that you can include (a full list is available
    at [https://goswagger.io/use/spec/meta.html](https://goswagger.io/use/spec/meta.html)).
  prefs: []
  type: TYPE_NORMAL
- en: To generate the OpenAPI Specification, we will use the `swagger` command-line
    tool. The CLI will parse the `main.go` file. If the parser encounters a comment
    that matches the Swagger annotation or any supported tags, it will generate the
    corresponding block of the specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your Terminal, issue the following command to generate a `spec` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This command will generate the specification in JSON format. You can generate
    the spec in YAML format as well by just appending the output with the `.yml` or
    `.yaml` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the generated `swagger.json` file will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Another cool thing with the Swagger command line is its embedded UI. You can
    load the generated spec in the Swagger UI locally with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI will be exposed on port `http://localhost:49566`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – Loading the Swagger specs in the UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.23 – Loading the Swagger specs in the UI
  prefs: []
  type: TYPE_NORMAL
- en: 'If you point your browser to that URL, you should see the UI based on the Redoc
    template. The UI comes in two two flavors – Redoc and the Swagger UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24 – Swagger with a Redoc flavor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.24 – Swagger with a Redoc flavor
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re a fan of the Swagger UI, you can set the flavor flag to `swagger`
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the API specification will be served from the Swagger UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.25 – Swagger UI mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.25 – Swagger UI mode
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the Swagger Online Editor ([https://editor.swagger.io/](https://editor.swagger.io/))
    to edit and load your OpenAPI Specification file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will define a `swagger:operation` for listing recipe endpoints. The
    annotation has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can find all the properties at [https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject).
  prefs: []
  type: TYPE_NORMAL
- en: 'Annotate the `ListRecipesHandler` function, as shown here. The annotation takes
    the HTTP method, path pattern, and operation ID as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For each operation, you can describe the HTTP response that matches an HTTP
    status code (200, 404, and so on) in the `responses` section. For this endpoint,
    we'll only return a 200 success code when responding to `GET` /`recipes`. The
    `description` field explains what this response means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the specification with the Swagger CLI and reload `swagger.json`.
    This time, the `GET` /recipes operation will be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.26 – Adding a new Swagger operation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.26 – Adding a new Swagger operation
  prefs: []
  type: TYPE_NORMAL
- en: 'Define another Swagger operation for the `PUT /recipes/{id}` endpoint. Similar
    to the previous operation, we can define responses based on the handled response
    code. We can also define the ID as a `path` parameter in the `parameters` section.
    As well as provide an optional description, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Regenerate the `swagger.json` file and reload the Swagger UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.27 – PUT operation in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.27 – PUT operation in Swagger
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the rest of the operations. You should have something similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.28 – Recipes API operations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.28 – Recipes API operations
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have learned the basics of the OpenAPI Specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being a simple JSON file, the OpenAPI Specification file can be shared and
    managed within any SCM, just like the application source code. Commit the `spec`
    file to GitHub with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The updated repository will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.29 – Storing the OpenAPI Specification on GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_02_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.29 – Storing the OpenAPI Specification on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to build a RESTful API from scratch with the
    Gin framework. We also covered how to validate incoming HTTP requests with Gin
    data binding and validation methods. Then, we provided an introduction to the
    OpenAPI Specification and learned how to generate it from an existing API. You
    should now be familiar with exposing HTTP methods (GET, POST, DELETE, PUT, and
    so on) to handle HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use MongoDB as a NoSQL database to manage data
    persistency for our API.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the GitFlow strategy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we define a data model in Go?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we validate a POST request body in Gin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an API endpoint that can get one recipe by ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a body parameter of the new recipe endpoint with OpenAPI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Hands-On RESTful API Design Patterns and Best Practices*, by Harihara Subramanian,
    Pethuru Raj, Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DevOps with GIT(Flow) Jenkins, Artifactory, Sonar, ELK, JIRA [Video]*, by
    Nand Venegalla, Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
