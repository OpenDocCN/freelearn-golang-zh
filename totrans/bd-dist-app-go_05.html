<html><head></head><body>
		<div id="_idContainer119">
			<h1 id="_idParaDest-48"><a id="_idTextAnchor054"/>Chapter 3: Managing Data Persistence with MongoDB</h1>
			<p>In the previous chapter, we learned how to build a RESTful API with the Gin web framework. In this one, we will integrate MongoDB into the backend for data storage, and we will also cover how to optimize database queries with Redis as a caching layer.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Setting up MongoDB with Docker</li>
				<li>Configuring Go MongoDB driver</li>
				<li>Implementing MongoDB queries &amp; and CRUD operations</li>
				<li>Standard Go project layout</li>
				<li>Deploying Redis with Docker</li>
				<li>Optimizing API response time with caching</li>
				<li>Performance benchmark with Apache Benchmark</li>
			</ul>
			<p>By the end of this chapter, you will be able to perform CRUD operations on a MongoDB database using Go.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor055"/>Technical requirements</h1>
			<p>To follow the content in this chapter, you will need the following:</p>
			<ul>
				<li>You must have a complete understanding of the previous chapter since this chapter is a follow-up of the previous one; it will use the same source code. Hence, some snippets won't be explained to avoid repetition.</li>
				<li>Some knowledge of NoSQL concepts and MongoDB basic queries.</li>
			</ul>
			<p>The code bundle for this chapter is hosted on GitHub at <a href="https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter03">https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter03</a>.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor056"/>Running a MongoDB Server</h1>
			<p>The API we've built so far is <a id="_idIndexMarker161"/>not connected to a database. For a real-world application, we need to use a form of data storage; otherwise, data will be lost if the API crashes or the server hosting the API goes down. MongoDB is one of the most popular NoSQL databases.</p>
			<p>The following schema shows how MongoDB will be integrated into the API architecture:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B17115_03_01.jpg" alt="Figure 3.1 – API architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – API architecture</p>
			<p>Before we get started, we need to deploy a MongoDB server. There are plenty of deployment options:</p>
			<ul>
				<li>You can download the MongoDB Community Edition binary from the following URL: <a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a>. Select a package based on your OS:</li>
			</ul>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B17115_03_02.jpg" alt="Figure 3.2 – MongoDB Community Server&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – MongoDB Community Server</p>
			<ul>
				<li>You can use the <a id="_idIndexMarker162"/>MongoDB as a Service solution, known as <a id="_idIndexMarker163"/>MongoDB Atlas (<a href="https://www.mongodb.com/cloud/atlas">https://www.mongodb.com/cloud/atlas</a>), to run a free 500 MB database on the cloud. You can deploy a fully managed MongoDB server on AWS, Google Cloud Platform, or Microsoft Azure.</li>
				<li>You can run MongoDB locally with a containerization solution such as Docker. Multiple Docker images are available on DockerHub with a MongoDB server configured and ready to use out of the box.</li>
			</ul>
			<p>I opted to go with Docker due to its popularity and simplicity in running ephemeral environments.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor057"/>Installing Docker CE</h2>
			<p>Docker (<a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a>) is an <a id="_idIndexMarker164"/>open source project that allows you to run, build, and manage <a id="_idIndexMarker165"/>containers. A container is like a separate OS, but not virtualized; it only contains the dependencies needed for that one application, which makes the container portable and deployable on-premises or on the cloud.</p>
			<p>The following diagram shows the main difference between containers and virtual machines in their architecture approach:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B17115_03_03.jpg" alt="Figure 3.3 – Virtual machines versus containers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Virtual machines versus containers</p>
			<p>Virtualization <a id="_idIndexMarker166"/>happens at the hardware level for virtual machines, while for containers, it happens at the application layer. Therefore, containers can share the OS kernel and libraries, which makes them very lightweight and resource-efficient (CPU, RAM, disk, and so on).</p>
			<p>To get started, you need to install Docker Engine on your machine. Navigate to <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a> and install Docker for your platform:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B17115_03_04.jpg" alt="Figure 3.4 – Docker installation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Docker installation</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Mac users can also use the Homebrew utility to install Docker with the <strong class="source-inline">brew install docker</strong> command.</p>
			<p>Follow the <a id="_idIndexMarker167"/>installation wizard and, once completed, verify that everything works fine by executing the following command:</p>
			<p class="source-code">docker version</p>
			<p>At the time of writing this book, I'm <a id="_idIndexMarker168"/>using Docker <strong class="bold">Community Edition</strong> (<strong class="bold">CE</strong>) version 20.10.2, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B17115_03_05.jpg" alt="Figure 3.5 – Docker Community Edition (CE) version&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Docker Community Edition (CE) version</p>
			<p>With Docker installed, you <a id="_idIndexMarker169"/>can deploy your first container. Issue the following command in your terminal session:</p>
			<p class="source-code">docker run hello-world</p>
			<p>The preceding command will deploy a container based on the <strong class="source-inline">hello-world</strong> image. When the container runs, it will print a <em class="italic">Hello from Docker</em>! message and exit:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B17115_03_06.jpg" alt="Figure 3.6 – Docker hello-world container&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Docker hello-world container</p>
			<p>Congratulations! You are <a id="_idIndexMarker170"/>now successfully running Docker.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor058"/>Running a MongoDB container</h2>
			<p>MongoDB's official image can be found on DockerHub (<a href="https://hub.docker.com/_/mongo">https://hub.docker.com/_/mongo</a>). There are <a id="_idIndexMarker171"/>numerous images available, each representing different versions of MongoDB. You can use the <strong class="source-inline">latest</strong> tag to find them; however, it's recommended to specify the target version. At the time of writing this book, MongoDB 4.4.3 is the latest stable version. Execute the following command to deploy a container based on that version:</p>
			<p class="source-code">docker run -d --name mongodb -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=password -p 27017:27017 mongo:4.4.3</p>
			<p>This command will run a MongoDB container in detached mode (the <strong class="source-inline">-d</strong> flag). We're also mapping the container port to the host port so that we can access the database from the host level. Finally, we must create a new user and set that user's password through the <strong class="source-inline">MONGO_INITDB_ROOT_USERNAME</strong> and <strong class="source-inline">MONGO_INITDB_ROOT_PASSWORD</strong> environment variables.</p>
			<p>For now, the <a id="_idIndexMarker172"/>MongoDB credentials are in plain text. Another way of passing sensitive information via environment variables is by using Docker Secrets. If you're running in Swarm mode, you can execute the following command:</p>
			<p class="source-code">openssl rand -base64 12 | docker secret create mongodb_password -</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Docker Swarm mode is natively integrated in Docker engine. It's a container orchestration platform used to build, deploy, and scale containers across a cluster of nodes.</p>
			<p>This command will generate a random password for a MongoDB user and set it as a Docker secret.</p>
			<p>Next, update the <strong class="source-inline">docker run</strong> command so that it uses the Docker Secret instead of the password in plain text:</p>
			<p class="source-code">-e MONGO_INITDB_ROOT_PASSWORD_FILE=/run/secrets/mongodb_password</p>
			<p>The <strong class="source-inline">docker run</strong> command's output is as follows. It downloads the image from DockerHub and creates an instance (container) from it:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B17115_03_07.jpg" alt="Figure 3.7 – Pulling a MongoDB image from DockerHub&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Pulling a MongoDB image from DockerHub</p>
			<p>It's worth mentioning <a id="_idIndexMarker173"/>that if you're already running the MongoDB container, make sure that you remove it before executing the previous command; otherwise, you'll receive a "Container already exists" error. To remove an existing container, issue the following command:</p>
			<p class="source-code">docker rm -f container_name || true </p>
			<p>Once the container has been created, check the logs by typing the following:</p>
			<p class="source-code">docker logs –f CONTAINER_ID</p>
			<p>The logs should display the MongoDB server's health check:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B17115_03_08.jpg" alt="Figure 3.8 – MongoDB container runtime logs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – MongoDB container runtime logs</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It's recommended that you use Docker volumes to map the <strong class="source-inline">/data/db</strong> directory within the container with the underlying host system. That way, if the MongoDB server fails or your laptop restarts, the data won't be lost (data persistency). Create a data directory on the host system and mount the directory to the <strong class="source-inline">/data/db</strong> directory with the following commands:</p>
			<p class="callout"><strong class="source-inline">mkdir /home/data </strong></p>
			<p class="callout"><strong class="source-inline">docker run -d --name mongodb –v /home/data:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=password -p 27017:27017 mongo:4.4.3</strong></p>
			<p>To interact with the <a id="_idIndexMarker174"/>MongoDB server, you can use the MongoDB shell to issue queries and view data on the command line. However, there is a better alternative: MongoDB Compass.</p>
			<p>Installing MongoDB Compass</p>
			<p>MongoDB Compass is a GUI tool that <a id="_idIndexMarker175"/>allows you to easily build queries, understand your database schema, and analyze your indexes, all without having to know MongoDB's query syntax.</p>
			<p>Download Compass from <a href="https://www.mongodb.com/try/download/compass?tck=docs_compass">https://www.mongodb.com/try/download/compass?tck=docs_compass</a> based on your OS:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B17115_03_09.jpg" alt="Figure 3.9 – MongoDB Compass download page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – MongoDB Compass download page</p>
			<p>Once you've <a id="_idIndexMarker176"/>downloaded the package relevant to your OS, run the installer and follow the steps that come after it. Once installed, open Compass, click on <strong class="bold">New Connection</strong>, then enter the following URI in the input field (replace the given credentials with your own): <strong class="source-inline">mongodb://admin:password@localhost:27017/test</strong>.</p>
			<p>MongoDB is running locally, so the hostname will be localhost and the port will be 27017:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B17115_03_10.jpg" alt="Figure 3.10 – MongoDB Compass – New Connection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – MongoDB Compass – New Connection</p>
			<p>Click on the <strong class="bold">CONNECT</strong> button. Now, you are connected to your MongoDB server. You will see a list of databases that are available:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B17115_03_11.jpg" alt="Figure 3.11 – MongoDB default databases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – MongoDB default databases</p>
			<p>At this point, we <a id="_idIndexMarker177"/>have a functional MongoDB deployment. In the next section, we're going to interact with the database using the Recipes API we built in the previous chapter.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To stop MongoDB server, run <strong class="source-inline">docker ps</strong> command to see the list of the running containers and <strong class="source-inline">docker stop CONTAINER_ID</strong> to stop the container.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor059"/>Configuring Go's MongoDB driver</h1>
			<p>The Recipes API we <a id="_idIndexMarker178"/>implemented in the previous chapter is written in Golang. Therefore, we need to install the official MongoDB Go driver (<a href="https://github.com/mongodb/mongo-go-driver">https://github.com/mongodb/mongo-go-driver</a>) to <a id="_idIndexMarker179"/>interact with the MongoDB server. The driver fully integrates with the MongoDB API and supports all the main queries and aggregation features of the API.</p>
			<p>Issue the following command to install the package from GitHub:</p>
			<p class="source-code">go get go.mongodb.org/mongo-driver/mongo</p>
			<p>This will add the package as a dependency in the <strong class="source-inline">require</strong> section, under the <strong class="source-inline">go.mod</strong> file:</p>
			<p class="source-code">module github.com/mlabouardy/recipes-api</p>
			<p class="source-code">go 1.15</p>
			<p class="source-code">require (</p>
			<p class="source-code">   github.com/gin-gonic/gin v1.6.3</p>
			<p class="source-code">   github.com/rs/xid v1.2.1 </p>
			<p class="source-code">   go.mongodb.org/mongo-driver v1.4.5 </p>
			<p class="source-code">)</p>
			<p>To get started, import <a id="_idIndexMarker180"/>the following packages in the <strong class="source-inline">main.go</strong> file:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">   "go.mongodb.org/mongo-driver/mongo"</p>
			<p class="source-code">   "go.mongodb.org/mongo-driver/mongo/options"</p>
			<p class="source-code">   "go.mongodb.org/mongo-driver/mongo/readpref"</p>
			<p class="source-code">)</p>
			<p>In the <strong class="source-inline">init()</strong> method, create a <strong class="source-inline">mongo.Client</strong> with the <strong class="source-inline">Connect</strong> function. This function takes a context as a parameter and the connection string, which is provided with an environment variable called <strong class="source-inline">MONGO_URI</strong>. Also, create the following global variables; they will be used across all the CRUD operation functions: </p>
			<p class="source-code">var ctx context.Context</p>
			<p class="source-code">var err error</p>
			<p class="source-code">var client *mongo.Client</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">   ...</p>
			<p class="source-code">   ctx = context.Background()</p>
			<p class="source-code">   client, err = mongo.Connect(ctx, </p>
			<p class="source-code">       options.Client().ApplyURI(os.Getenv("MONGO_URI")))</p>
			<p class="source-code">   if err = client.Ping(context.TODO(), </p>
			<p class="source-code">           readpref.Primary()); err != nil {</p>
			<p class="source-code">       log.Fatal(err)</p>
			<p class="source-code">   }</p>
			<p class="source-code">   log.Println("Connected to MongoDB")</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">I have omitted some of the code to make the example readable and easy to follow. The full source code is available in this book's GitHub repository, under the <strong class="source-inline">chapter03</strong> folder.</p>
			<p>Once the <strong class="source-inline">Connect</strong> method <a id="_idIndexMarker181"/>returns the client object, we can use the <strong class="source-inline">Ping</strong> method to check whether the connection was successful or not.</p>
			<p>Pass the <strong class="source-inline">MONGO_URI</strong> environment variable to the <strong class="source-inline">go run</strong> command and check if the application can successfully connect to your MongoDB server:</p>
			<p class="source-code">MONGO_URI="mongodb://admin:password@localhost:27017/test?authSource=admin" go run main.go</p>
			<p>If successful, a <strong class="bold">Connected to MongoDB</strong> message will be shown:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B17115_03_12.jpg" alt="Figure 3.12 – MongoDB connection with the Go driver&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – MongoDB connection with the Go driver</p>
			<p>Now, let's populate a <a id="_idIndexMarker182"/>fresh database with some data.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor060"/>Exploring MongoDB queries</h1>
			<p>In this section, we will interact <a id="_idIndexMarker183"/>with the MongoDB server using CRUD operations, but first, let's create a database where the API data will be stored.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can view the full documentation for the MongoDB Go driver on the GoDoc website (<a href="https://godoc.org/go.mongodb.org/mongo-driver">https://godoc.org/go.mongodb.org/mongo-driver</a>).</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor061"/>The InsertMany operation</h2>
			<p>Let's initialize the <a id="_idIndexMarker184"/>database with the <strong class="source-inline">recipes.json</strong> file we <a id="_idIndexMarker185"/>created in the previous chapter. First, retrieve a <strong class="source-inline">Database</strong> and then a <strong class="source-inline">Collection</strong> instance from <strong class="source-inline">Client</strong>. The <strong class="source-inline">Collection</strong> instance will be used to insert documents:</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">   recipes = make([]Recipe, 0)</p>
			<p class="source-code">   file, _ := ioutil.ReadFile("recipes.json")</p>
			<p class="source-code">   _ = json.Unmarshal([]byte(file), &amp;recipes)</p>
			<p class="source-code">   ctx = context.Background()</p>
			<p class="source-code">   client, err = mongo.Connect(ctx, </p>
			<p class="source-code">       options.Client().ApplyURI(os.Getenv("MONGO_URI")))</p>
			<p class="source-code">   if err = client.Ping(context.TODO(), </p>
			<p class="source-code">           readpref.Primary()); err != nil {</p>
			<p class="source-code">       log.Fatal(err)</p>
			<p class="source-code">   }</p>
			<p class="source-code">   log.Println("Connected to MongoDB")</p>
			<p class="source-code">   var listOfRecipes []interface{}</p>
			<p class="source-code">   for _, recipe := range recipes {</p>
			<p class="source-code">       listOfRecipes = append(listOfRecipes, recipe)</p>
			<p class="source-code">   }</p>
			<p class="source-code">   collection := client.Database(os.Getenv(</p>
			<p class="source-code">       "MONGO_DATABASE")).Collection("recipes")</p>
			<p class="source-code">   insertManyResult, err := collection.InsertMany(</p>
			<p class="source-code">       ctx, listOfRecipes)</p>
			<p class="source-code">   if err != nil {</p>
			<p class="source-code">       log.Fatal(err)</p>
			<p class="source-code">   }</p>
			<p class="source-code">   log.Println("Inserted recipes: ", </p>
			<p class="source-code">               len(insertManyResult.InsertedIDs))</p>
			<p class="source-code">}</p>
			<p>The preceding code reads a JSON file (<a href="https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/recipes.json">https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/recipes.json</a>), which contains a list of recipes, and encodes it into an array of the <strong class="source-inline">Recipe</strong> struct. Then, it establishes a connection with the MongoDB server and inserts the recipes into the <strong class="source-inline">recipes</strong> collection.</p>
			<p>To insert multiple <a id="_idIndexMarker186"/>documents at a time, we can use the <strong class="source-inline">InsertMany()</strong> method. This method accepts an interface slice as a parameter. Therefore, we <a id="_idIndexMarker187"/>must map the <strong class="source-inline">Recipes</strong> struct slice to the interface slice.</p>
			<p>Rerun the application, but this time, set the <strong class="source-inline">MONGO_URI and MONGO_DATABASE</strong> variables as follows:</p>
			<p class="source-code">MONGO_URI="mongodb://USER:PASSWORD@localhost:27017/test?authSource=admin" MONGO_DATABASE=demo go run main.go</p>
			<p>Make sure to replace <strong class="source-inline">USER</strong> with your database user and <strong class="source-inline">PASSWORD</strong> with the user password we created while deploying the MongoDB container.</p>
			<p>The application will be launched; the <strong class="source-inline">init()</strong> method will be executed first and the recipes items will be inserted into the MongoDB collection:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B17115_03_13.jpg" alt="Figure 3.13 – Inserting recipes during startup&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – Inserting recipes during startup</p>
			<p>To verify that the data has been loaded into the recipes collection, refresh MongoDB Compass. You should see the entries that you created:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B17115_03_14.jpg" alt="Figure 3.14 – Recipes collection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Recipes collection</p>
			<p>Now that the <strong class="source-inline">recipes</strong> collection <a id="_idIndexMarker188"/>has been prepared, we need to <a id="_idIndexMarker189"/>update each API endpoint's code so that they use the collection instead of the hardcoded recipes list. But first, we need to update the <strong class="source-inline">init()</strong> method to remove the loading and encoding of the <strong class="source-inline">recipes.json</strong> file:</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">   ctx = context.Background()</p>
			<p class="source-code">   client, err = mongo.Connect(ctx, </p>
			<p class="source-code">       options.Client().ApplyURI(os.Getenv("MONGO_URI")))</p>
			<p class="source-code">   if err = client.Ping(context.TODO(), </p>
			<p class="source-code">                        readpref.Primary()); err != nil {</p>
			<p class="source-code">       log.Fatal(err)</p>
			<p class="source-code">   }</p>
			<p class="source-code">   log.Println("Connected to MongoDB")</p>
			<p class="source-code">}</p>
			<p>It's worth mentioning that you can use the <strong class="source-inline">mongoimport</strong> utility to load the <strong class="source-inline">recipe.json</strong> file directly into the <strong class="source-inline">recipes</strong> collection without writing a single line of code in Golang. The command for this is as follows:</p>
			<p class="source-code">mongoimport --username admin --password password --authenticationDatabase admin --db demo --collection recipes --file recipes.json --jsonArray</p>
			<p>This command <a id="_idIndexMarker190"/>will import the content from the JSON file <a id="_idIndexMarker191"/>into the <strong class="source-inline">recipes</strong> collection:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B17115_03_15.jpg" alt="Figure 3.15 – Importing data with mongoimport&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – Importing data with mongoimport</p>
			<p>In the next section, we will update the existing function handlers to read and write from/to the <strong class="source-inline">recipes</strong> collection.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor062"/>The Find operation</h2>
			<p>To get started, we need to implement the <a id="_idIndexMarker192"/>function responsible for <a id="_idIndexMarker193"/>returning a list of recipes. Update <strong class="source-inline">ListRecipesHandler</strong> so that it uses the <strong class="source-inline">Find()</strong> method to fetch all the items from the <strong class="source-inline">recipes</strong> collection:</p>
			<p class="source-code">func ListRecipesHandler(c *gin.Context) {</p>
			<p class="source-code">   cur, err := collection.Find(ctx, bson.M{})</p>
			<p class="source-code">   if err != nil {</p>
			<p class="source-code">       c.JSON(http.StatusInternalServerError, </p>
			<p class="source-code">              gin.H{"error": err.Error()})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   }</p>
			<p class="source-code">   defer cur.Close(ctx)</p>
			<p class="source-code">   recipes := make([]Recipe, 0)</p>
			<p class="source-code">   for cur.Next(ctx) {</p>
			<p class="source-code">       var recipe Recipe</p>
			<p class="source-code">       cur.Decode(&amp;recipe)</p>
			<p class="source-code">       recipes = append(recipes, recipe)</p>
			<p class="source-code">   }</p>
			<p class="source-code">   c.JSON(http.StatusOK, recipes)</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Find()</strong> method <a id="_idIndexMarker194"/>returns a cursor, which is a stream of documents. We must <a id="_idIndexMarker195"/>go through the stream of documents and decode one at a time into the <strong class="source-inline">Recipe</strong> struct. Then, we must append the document to a list of recipes.</p>
			<p>Run the application, then issue a GET request on the <strong class="source-inline">/recipes</strong> endpoint; a <strong class="source-inline">find()</strong> operation will be executed on the <strong class="source-inline">recipes</strong> collection. As a result, a list of recipes will be returned:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B17115_03_16.jpg" alt="Figure 3.16 – Getting all the recipes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – Getting all the recipes</p>
			<p>The endpoint is <a id="_idIndexMarker196"/>working and fetching the recipe's items <a id="_idIndexMarker197"/>from the collection.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor063"/>The InsertOne operation</h2>
			<p>The second function to be <a id="_idIndexMarker198"/>implemented will be <a id="_idIndexMarker199"/>responsible for saving a new recipe. Update the <strong class="source-inline">NewRecipeHandler</strong> function so that it calls the <strong class="source-inline">InsertOne()</strong> method on the <strong class="source-inline">recipes</strong> collection:</p>
			<p class="source-code">func NewRecipeHandler(c *gin.Context) {</p>
			<p class="source-code">   var recipe Recipe</p>
			<p class="source-code">   if err := c.ShouldBindJSON(&amp;recipe); err != nil {</p>
			<p class="source-code">       c.JSON(http.StatusBadRequest, gin.H{"error": </p>
			<p class="source-code">           err.Error()})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   }</p>
			<p class="source-code">   recipe.ID = primitive.NewObjectID()</p>
			<p class="source-code">   recipe.PublishedAt = time.Now()</p>
			<p class="source-code">   _, err = collection.InsertOne(ctx, recipe)</p>
			<p class="source-code">   if err != nil {</p>
			<p class="source-code">       fmt.Println(err)</p>
			<p class="source-code">       c.JSON(http.StatusInternalServerError, </p>
			<p class="source-code">           gin.H{"error": "Error while inserting</p>
			<p class="source-code">                  a new recipe"})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   }</p>
			<p class="source-code">   c.JSON(http.StatusOK, recipe)</p>
			<p class="source-code">}</p>
			<p>Here, we set a <a id="_idIndexMarker200"/>unique identifier using the <strong class="source-inline">primitive.NewObjectID()</strong> method <a id="_idIndexMarker201"/>ahead of saving the item in the collection. Therefore, we need to change the ID type of the <strong class="source-inline">Recipe</strong> struct. Also, note the usage of the <strong class="source-inline">bson</strong> tags to map a <strong class="source-inline">struct</strong> field to the <strong class="source-inline">document</strong> attribute in the MongoDB collection:</p>
			<p class="source-code">// swagger:parameters recipes newRecipe</p>
			<p class="source-code">type Recipe struct {</p>
			<p class="source-code">   //swagger:ignore</p>
			<p class="source-code">   ID primitive.ObjectID `json:"id" bson:"_id"`</p>
			<p class="source-code">   Name string `json:"name" bson:"name"`</p>
			<p class="source-code">   Tags []string `json:"tags" bson:"tags"`</p>
			<p class="source-code">   Ingredients []string `json:"ingredients" bson:"ingredients"`</p>
			<p class="source-code">   Instructions []string `json:"instructions"                           bson:"instructions"`</p>
			<p class="source-code">   PublishedAt time.Time `json:"publishedAt"                           bson:"publishedAt"`</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">By default, Go lowercases the struct field names when encoding struct values. If a different name is needed, you can override the default mechanism with <strong class="source-inline">bson</strong> tags.</p>
			<p>Insert a new <a id="_idIndexMarker202"/>recipe by <a id="_idIndexMarker203"/>calling the following POST request with the Postman client:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B17115_03_17.jpg" alt="Figure 3.17 – Creating a new recipe&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.17 – Creating a new recipe</p>
			<p>Verify that the recipe has <a id="_idIndexMarker204"/>been inserted into the <a id="_idIndexMarker205"/>MongoDB collection, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B17115_03_18.jpg" alt="Figure 3.18 – Getting the last inserted recipe&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.18 – Getting the last inserted recipe</p>
			<p>To get the last <a id="_idIndexMarker206"/>inserted <a id="_idIndexMarker207"/>recipe, we use the <strong class="source-inline">sort()</strong> operation.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor064"/>The UpdateOne operation</h2>
			<p>Finally, in order to <a id="_idIndexMarker208"/>update an item from the collection, update the <strong class="source-inline">UpdateRecipeHandler</strong> function so that it calls the <strong class="source-inline">UpdateOne()</strong> method. This <a id="_idIndexMarker209"/>method requires a filter document to match documents in the database and an updater document to describe the update operation. You can build a <a id="_idIndexMarker210"/>filter using <strong class="source-inline">bson.D{}</strong> – a <strong class="bold">Binary-encoded JSON</strong> (<strong class="bold">BSON</strong>) document:</p>
			<p class="source-code">func UpdateRecipeHandler(c *gin.Context) {</p>
			<p class="source-code">   id := c.Param("id")</p>
			<p class="source-code">   var recipe Recipe</p>
			<p class="source-code">   if err := c.ShouldBindJSON(&amp;recipe); err != nil {</p>
			<p class="source-code">       c.JSON(http.StatusBadRequest, gin.H{"error":                                            err.Error()})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   }</p>
			<p class="source-code">   objectId, _ := primitive.ObjectIDFromHex(id)</p>
			<p class="source-code">   _, err = collection.UpdateOne(ctx, bson.M{</p>
			<p class="source-code">       "_id": objectId,</p>
			<p class="source-code">   }, bson.D{{"$set", bson.D{</p>
			<p class="source-code">       {"name", recipe.Name},</p>
			<p class="source-code">       {"instructions", recipe.Instructions},</p>
			<p class="source-code">       {"ingredients", recipe.Ingredients},</p>
			<p class="source-code">       {"tags", recipe.Tags},</p>
			<p class="source-code">   }}})</p>
			<p class="source-code">   if err != nil {</p>
			<p class="source-code">       fmt.Println(err)</p>
			<p class="source-code">       c.JSON(http.StatusInternalServerError, </p>
			<p class="source-code">           gin.H{"error": err.Error()})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   }</p>
			<p class="source-code">   c.JSON(http.StatusOK, gin.H{"message": "Recipe </p>
			<p class="source-code">                               has been updated"})</p>
			<p class="source-code">}</p>
			<p>This method filters <a id="_idIndexMarker211"/>documents by their Object ID. We get the <a id="_idIndexMarker212"/>Object ID by applying <strong class="source-inline">ObjectIDFromHex</strong> to the route parameter ID. This updates the matched recipe's fields with the new values coming from the request body.</p>
			<p>Verify the endpoint is working by calling a PUT request on an existing recipe:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B17115_03_19.jpg" alt="Figure 3.19 – Updating a recipe&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.19 – Updating a recipe</p>
			<p>The request will match the recipe where <strong class="source-inline">ID</strong> is <strong class="source-inline">600dcc85a65917cbd1f201b0</strong> and will update its <strong class="source-inline">name</strong> from "<strong class="source-inline">Homemade Pizza</strong>" to "<strong class="source-inline">Homemade Pepperoni Pizza</strong>", and the <strong class="source-inline">instructions</strong> field with additional steps to make a "<strong class="source-inline">Pepperoni Pizza</strong>".</p>
			<p>With that, the recipe has <a id="_idIndexMarker213"/>been successfully updated. You <a id="_idIndexMarker214"/>can confirm these changes with MongoDB Compass:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B17115_03_20.jpg" alt="Figure 3.20 – UpdateOne operation results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.20 – UpdateOne operation results</p>
			<p>You should now be familiar with the basic MongoDB queries. Go ahead and implement the remaining CRUD operations.</p>
			<p>Finally, make sure that you push the changes to the remote repository with the following commands:</p>
			<p class="source-code">git checkout –b feature/mongo_integration</p>
			<p class="source-code">git add .</p>
			<p class="source-code">git commit –m "added mongodb integration"</p>
			<p class="source-code">git push origin feature/mongo_integration</p>
			<p>Then, create a pull request to merge the <strong class="source-inline">feature</strong> branch into <strong class="source-inline">develop</strong>:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B17115_03_21.jpg" alt="Figure 3.21 – New pull request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.21 – New pull request</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A full implementation of the endpoints can be found in this book's GitHub repository (<a href="https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/main.go">https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/main.go</a>).</p>
			<p>You just saw <a id="_idIndexMarker215"/>how to integrate MongoDB into the <a id="_idIndexMarker216"/>application architecture. In the next section, we will cover how to refactor the source code of our application so that it's maintainable, scalable, and extendable in the long run.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor065"/>Designing the project's layout</h1>
			<p>So far, all the <a id="_idIndexMarker217"/>code we've written is in the <strong class="source-inline">main.go</strong> file. While this works fine, it's important to make sure the code is well structured; otherwise, you'll end up with a lot of hidden dependencies and messy code (spaghetti code) when the project grows.</p>
			<p>We will start with the data model. Let's create a <strong class="source-inline">models</strong> folder so that we can store all the models structs. For now, we have one model, which is the <strong class="source-inline">Recipe</strong> struct. Create a <strong class="source-inline">recipe.go</strong> file under the <strong class="source-inline">models</strong> folder and paste the following content:</p>
			<p class="source-code">package models</p>
			<p class="source-code">import (</p>
			<p class="source-code">   "time"</p>
			<p class="source-code">   "go.mongodb.org/mongo-driver/bson/primitive"</p>
			<p class="source-code">)</p>
			<p class="source-code">// swagger:parameters recipes newRecipe</p>
			<p class="source-code">type Recipe struct {</p>
			<p class="source-code">   //swagger:ignore</p>
			<p class="source-code">   ID           primitive.ObjectID `json:"id" bson:"_id"`</p>
			<p class="source-code">   Name         string             `json:"name" </p>
			<p class="source-code">                                               bson:"name"`</p>
			<p class="source-code">   Tags         []string           `json:"tags" </p>
			<p class="source-code">                                               bson:"tags"`</p>
			<p class="source-code">   Ingredients  []string           `json:"ingredients" </p>
			<p class="source-code">                                      bson:"ingredients"`</p>
			<p class="source-code">   Instructions []string           `json:"instructions" </p>
			<p class="source-code">                                      bson:"instructions"`</p>
			<p class="source-code">   PublishedAt  time.Time          `json:"publishedAt" </p>
			<p class="source-code">                                      bson:"publishedAt"`</p>
			<p class="source-code">}</p>
			<p>Then, create a <strong class="source-inline">handlers</strong> folder <a id="_idIndexMarker218"/>with the <strong class="source-inline">handler.go</strong> file. This folder, as its name indicts, handles any incoming HTTP requests by exposing the right function to be called for each HTTP request:</p>
			<p class="source-code">package handlers</p>
			<p class="source-code">import (</p>
			<p class="source-code">   "fmt"</p>
			<p class="source-code">   "net/http"</p>
			<p class="source-code">   "time"</p>
			<p class="source-code">   "github.com/gin-gonic/gin"</p>
			<p class="source-code">   "github.com/mlabouardy/recipes-api/models"</p>
			<p class="source-code">   "go.mongodb.org/mongo-driver/bson"</p>
			<p class="source-code">   "go.mongodb.org/mongo-driver/bson/primitive"</p>
			<p class="source-code">   "go.mongodb.org/mongo-driver/mongo"</p>
			<p class="source-code">   "golang.org/x/net/context"</p>
			<p class="source-code">)</p>
			<p class="source-code">type RecipesHandler struct {</p>
			<p class="source-code">   collection *mongo.Collection</p>
			<p class="source-code">   ctx        context.Context</p>
			<p class="source-code">}</p>
			<p class="source-code">func NewRecipesHandler(ctx context.Context, collection *mongo.Collection) *RecipesHandler {</p>
			<p class="source-code">   return &amp;RecipesHandler{</p>
			<p class="source-code">       collection: collection,</p>
			<p class="source-code">       ctx:        ctx,</p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p>This code creates a <strong class="source-inline">RecipesHandler</strong> struct with the MongoDB collection and context instances <a id="_idIndexMarker219"/>encapsulated. In our early simple implementations, we tended to keep these variables global within the main package. Here, we are keeping these variables in the struct. Next, we must define a <strong class="source-inline">NewRecipesHandler</strong> so that we can create an instance from the <strong class="source-inline">RecipesHandler</strong> struct.</p>
			<p>Now, we can define the endpoints handlers of the <strong class="source-inline">RecipesHandler</strong> type. The handlers can access all the variables of the struct such as the database connection because it is a <a id="_idIndexMarker220"/>method of the <strong class="source-inline">RecipesHandler</strong> type:</p>
			<p class="source-code">func (handler *RecipesHandler) ListRecipesHandler(c *gin.Context) {</p>
			<p class="source-code">   cur, err := handler.collection.Find(handler.ctx, bson.M{})</p>
			<p class="source-code">   if err != nil {</p>
			<p class="source-code">       c.JSON(http.StatusInternalServerError, </p>
			<p class="source-code">           gin.H{"error": err.Error()})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   }</p>
			<p class="source-code">   defer cur.Close(handler.ctx)</p>
			<p class="source-code"> </p>
			<p class="source-code">   recipes := make([]models.Recipe, 0)</p>
			<p class="source-code">   for cur.Next(handler.ctx) {</p>
			<p class="source-code">       var recipe models.Recipe</p>
			<p class="source-code">       cur.Decode(&amp;recipe)</p>
			<p class="source-code">       recipes = append(recipes, recipe)</p>
			<p class="source-code">   }</p>
			<p class="source-code"> </p>
			<p class="source-code">   c.JSON(http.StatusOK, recipes)</p>
			<p class="source-code">}</p>
			<p>From our <strong class="source-inline">main.go</strong> file, we'll provide all the database credentials and connect to the MongoDB server:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">   "context"</p>
			<p class="source-code">   "log"</p>
			<p class="source-code">   "os"</p>
			<p class="source-code">   "github.com/gin-gonic/gin"</p>
			<p class="source-code">   handlers "github.com/mlabouardy/recipes-api/handlers"</p>
			<p class="source-code">   "go.mongodb.org/mongo-driver/mongo"</p>
			<p class="source-code">   "go.mongodb.org/mongo-driver/mongo/options"</p>
			<p class="source-code">   "go.mongodb.org/mongo-driver/mongo/readpref"</p>
			<p class="source-code">)</p>
			<p>Then, we must create a <a id="_idIndexMarker221"/>global variable to access the endpoints handlers. Update the <strong class="source-inline">init()</strong> method, as follows:</p>
			<p class="source-code">var recipesHandler *handlers.RecipesHandler</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">   ctx := context.Background()</p>
			<p class="source-code">   client, err := mongo.Connect(ctx, </p>
			<p class="source-code">       options.Client().ApplyURI(os.Getenv("MONGO_URI")))</p>
			<p class="source-code">   if err = client.Ping(context.TODO(), </p>
			<p class="source-code">           readpref.Primary()); err != nil {</p>
			<p class="source-code">       log.Fatal(err)</p>
			<p class="source-code">   }</p>
			<p class="source-code">   log.Println("Connected to MongoDB")</p>
			<p class="source-code">   collection := client.Database(os.Getenv(</p>
			<p class="source-code">       "MONGO_DATABASE")).Collection("recipes")</p>
			<p class="source-code">   recipesHandler = handlers.NewRecipesHandler(ctx, </p>
			<p class="source-code">       collection)</p>
			<p class="source-code">}</p>
			<p>Finally, use the <strong class="source-inline">recipesHandler</strong> variable <a id="_idIndexMarker222"/>to access the handler for each HTTP endpoint:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">   router := gin.Default()</p>
			<p class="source-code">   router.POST("/recipes", recipesHandler.NewRecipeHandler)</p>
			<p class="source-code">   router.GET("/recipes", </p>
			<p class="source-code">       recipesHandler.ListRecipesHandler)</p>
			<p class="source-code">   router.PUT("/recipes/:id", </p>
			<p class="source-code">       recipesHandler.UpdateRecipeHandler)</p>
			<p class="source-code">   router.Run()</p>
			<p class="source-code">}</p>
			<p>Run the application. This time, run all the <strong class="source-inline">.go</strong> files within the current directory:</p>
			<p class="source-code">MONGO_URI="mongodb://admin:password@localhost:27017/test?authSource=admin" MONGO_DATABASE=demo go run *.go</p>
			<p>The application will be working as expected. The server logs are as follows:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B17115_03_22.jpg" alt="Figure 3.22 – Gin debug logs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.22 – Gin debug logs</p>
			<p>Now, your project structure should look like this:</p>
			<p class="source-code">.</p>
			<p class="source-code">├── go.mod</p>
			<p class="source-code">├── go.sum</p>
			<p class="source-code">├── handlers</p>
			<p class="source-code">│   └── handler.go</p>
			<p class="source-code">├── main.go</p>
			<p class="source-code">├── models</p>
			<p class="source-code">│   └── recipe.go</p>
			<p class="source-code">├── recipes.json</p>
			<p class="source-code">└── swagger.json</p>
			<p>This is a basic layout for a <a id="_idIndexMarker223"/>Go application project. There are Go directories that we will cover in upcoming chapters.</p>
			<p>Push the changes to GitHub on a feature branch and merge the branch into <strong class="source-inline">develop</strong>:</p>
			<p class="source-code">git checkout –b fix/code_refactoring</p>
			<p class="source-code">git add .</p>
			<p class="source-code">git commit –m "code refactoring"</p>
			<p class="source-code">git push origin fix/code_refactoring</p>
			<p>When running a service that interacts with a database, its operations may become bottlenecks, thus degrading the user experience and impacting your business. That is why response time is one of the most important metrics to evaluate when developing a RESTful API.</p>
			<p>Luckily, we can add a cache layer to store frequently accessed data in memory to speed things up, thus reducing the number of operations/queries on the database.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor066"/>Caching an API with Redis</h1>
			<p>In this section, we will cover <a id="_idIndexMarker224"/>how to add a caching mechanism to our API. Let's imagine that we have a tremendous number of recipes in our MongoDB database. Every <a id="_idIndexMarker225"/>time we try to query a list of recipes, we struggle with performance issues. What we can do instead is use an in-memory database, such as Redis, to reuse previously retrieved recipes and avoiding hitting the MongoDB database on each request.</p>
			<p>Redis is consistently faster at retrieving data because it is always in RAM – that's why it's an excellent choice for caching. On the other hand, MongoDB might have to retrieve data from disk for advancing queries.</p>
			<p>According to the <a id="_idIndexMarker226"/>official documentation (<a href="https://redis.io/">https://redis.io/</a>), Redis is an open source, distributed, in-memory, key-value database, cache, and message broker. The following diagram illustrates how Redis fits in our API architecture:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B17115_03_23.jpg" alt="Figure 3.23 – API new architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.23 – API new architecture</p>
			<p>Let's say we want to get a list of recipes. First, the API will look around in Redis. If a list of recipes exists, it will be <a id="_idIndexMarker227"/>returned (this is called a <strong class="bold">cache hit</strong>). If the cache is <a id="_idIndexMarker228"/>empty (this is called a <strong class="bold">cache miss</strong>), then a MongoDB <strong class="source-inline">find({})</strong> query will be issued, and the results will be returned and also saved in the cache for future requests.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor067"/>Running Redis in Docker</h2>
			<p>The easiest <a id="_idIndexMarker229"/>way to set up Redis is through Docker. We will use the Redis <a id="_idIndexMarker230"/>official image available at DockerHub for this (<a href="https://hub.docker.com/_/redis">https://hub.docker.com/_/redis</a>). At the time of writing this book, the latest stable version is 6.0. Run a container based on that image:</p>
			<p class="source-code">docker run -d --name redis -p 6379:6379 redis:6.0</p>
			<p>This command does the following two main things:</p>
			<ul>
				<li>The <strong class="source-inline">–d</strong> flag runs the Redis container as a daemon.</li>
				<li>The <strong class="source-inline">–p</strong> flag maps port 6379 of the container to port 6379 of the host. Port 6379 is the port where the Redis server is exposed.</li>
			</ul>
			<p>The command's output is as follows:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B17115_03_24.jpg" alt="Figure 3.24 – Pulling a Redis image from DockerHub&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.24 – Pulling a Redis image from DockerHub</p>
			<p>Always check the Docker log to see the chain of events:</p>
			<p class="source-code">docker logs –f CONTAINER_ID</p>
			<p>The logs provide a wealth of useful information, such as the default configuration and the exposed server port:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B17115_03_25.jpg" alt="Figure 3.25 – Redis server logs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.25 – Redis server logs</p>
			<p>The Redis container <a id="_idIndexMarker231"/>uses the basic caching policy. For production usage, it's recommended to <a id="_idIndexMarker232"/>configure an eviction policy. You can configure the policy with a <strong class="source-inline">redis.conf</strong> file:</p>
			<p class="source-code">maxmemory-policy allkeys-lru</p>
			<p class="source-code">maxmemory 512mb</p>
			<p>This config allocates 512 MB of <a id="_idIndexMarker233"/>memory for Redis and sets the eviction policy to the <strong class="bold">Least Recently Used</strong> (<strong class="bold">LRU</strong>) algorithm, which deletes the cache items that were the least recently used. As a result, we only keep the items with the highest chances of getting read again.</p>
			<p>You can then pass the config at the runtime of the container with the following command:</p>
			<p class="source-code">docker run -d -v $PWD/conf:/usr/local/etc/redis --name redis -p 6379:6379 redis:6.0</p>
			<p>Here, <strong class="source-inline">$PWD/conf</strong> is the folder containing the <strong class="source-inline">redis.conf</strong> file.</p>
			<p>Now that Redis is running, we can use it to cache API data. But first, let's install the official Redis Go driver (<a href="https://github.com/go-redis/redis">https://github.com/go-redis/redis</a>) by executing the following command:</p>
			<p class="source-code">go get github.com/go-redis/redis/v8</p>
			<p>Import the following package in the <strong class="source-inline">main.go</strong> file:</p>
			<p class="source-code">import "github.com/go-redis/redis"</p>
			<p>Now, on the <strong class="source-inline">init()</strong> method, initialize the Redis client with <strong class="source-inline">redis.NewClient()</strong>. This method takes the server address, password, and database as parameters. Next, we will call the <strong class="source-inline">Ping()</strong> method on the Redis client to check the connection status to the Redis server:</p>
			<p class="source-code">redisClient := redis.NewClient(&amp;redis.Options{</p>
			<p class="source-code">       Addr:     "localhost:6379",</p>
			<p class="source-code">       Password: "",</p>
			<p class="source-code">       DB:       0,</p>
			<p class="source-code">})</p>
			<p class="source-code">status := redisClient.Ping()</p>
			<p class="source-code">fmt.Println(status)</p>
			<p>This code will set up a <a id="_idIndexMarker234"/>connection <a id="_idIndexMarker235"/>with the Redis server after deployment:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B17115_03_26.jpg" alt="Figure 3.26 – Checking the connection with the Redis server&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.26 – Checking the connection with the Redis server</p>
			<p>If the connection is successful, a <strong class="source-inline">ping: PONG</strong> message will be displayed, as shown in the preceding screenshot.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor068"/>Optimizing MongoDB queries</h2>
			<p>With a connection being <a id="_idIndexMarker236"/>established with the Redis server, we can update the <strong class="source-inline">RecipesHandler</strong> struct to store an instance of the Redis client so that the handlers can interact with Redis:</p>
			<p class="source-code">type RecipesHandler struct {</p>
			<p class="source-code">   collection  *mongo.Collection</p>
			<p class="source-code">   ctx         context.Context</p>
			<p class="source-code">   redisClient *redis.Client</p>
			<p class="source-code">}</p>
			<p class="source-code">func NewRecipesHandler(ctx context.Context, collection </p>
			<p class="source-code">    *mongo.Collection, redisClient *redis.Client) </p>
			<p class="source-code">     *RecipesHandler {</p>
			<p class="source-code">   return &amp;RecipesHandler{</p>
			<p class="source-code">       collection:  collection,</p>
			<p class="source-code">       ctx:         ctx,</p>
			<p class="source-code">       redisClient: redisClient,</p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p>Make sure that you pass the <a id="_idIndexMarker237"/>Redis client instance to the <strong class="source-inline">RecipesHandler</strong> instance in the <strong class="source-inline">init()</strong> method:</p>
			<p class="source-code">recipesHandler = handlers.NewRecipesHandler(ctx, collection,        	                                            redisClient)</p>
			<p>Next, we must update <strong class="source-inline">ListRecipesHandler</strong> to check if the recipes have been cached in Redis. If they are, we return a list. If not, we will retrieve the data from MongoDB and cache it in Redis. The new changes we must make to the code are as follows:</p>
			<p class="source-code">func (handler *RecipesHandler) ListRecipesHandler(c       *gin.Context) {</p>
			<p class="source-code">   val, err := handler.redisClient.Get("recipes").Result()</p>
			<p class="source-code">   if err == redis.Nil {</p>
			<p class="source-code">       log.Printf("Request to MongoDB")</p>
			<p class="source-code">       cur, err := handler.collection.Find(handler.ctx, </p>
			<p class="source-code">                                           bson.M{})</p>
			<p class="source-code">       if err != nil {</p>
			<p class="source-code">           c.JSON(http.StatusInternalServerError, </p>
			<p class="source-code">                  gin.H{"error": err.Error()})</p>
			<p class="source-code">           return</p>
			<p class="source-code">       }</p>
			<p class="source-code">       defer cur.Close(handler.ctx)</p>
			<p class="source-code">       recipes := make([]models.Recipe, 0)</p>
			<p class="source-code">       for cur.Next(handler.ctx) {</p>
			<p class="source-code">           var recipe models.Recipe</p>
			<p class="source-code">           cur.Decode(&amp;recipe)</p>
			<p class="source-code">           recipes = append(recipes, recipe)</p>
			<p class="source-code">       }</p>
			<p class="source-code">       data, _ := json.Marshal(recipes)</p>
			<p class="source-code">       handler.redisClient.Set("recipes", string(data), 0)</p>
			<p class="source-code">       c.JSON(http.StatusOK, recipes)</p>
			<p class="source-code">   } else if err != nil {</p>
			<p class="source-code">       c.JSON(http.StatusInternalServerError, </p>
			<p class="source-code">              gin.H{"error": err.Error()})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   } else {</p>
			<p class="source-code">       log.Printf("Request to Redis")</p>
			<p class="source-code">       recipes := make([]models.Recipe, 0)</p>
			<p class="source-code">       json.Unmarshal([]byte(val), &amp;recipes)</p>
			<p class="source-code">       c.JSON(http.StatusOK, recipes)</p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p>It's worth mentioning that the Redis value has to be a string, so we had to encode the <strong class="source-inline">recipes</strong> slice into a string with the <strong class="source-inline">json.Marshal()</strong> method.</p>
			<p>To test out the new <a id="_idIndexMarker238"/>changes, run the application. Then, issue a GET request on the <strong class="source-inline">/recipes</strong> endpoint with Postman client or with a <strong class="source-inline">cURL</strong> command. Flip back to your Terminal and view the Gin logs. You should see a message in the console for the first request corresponding to getting data from MongoDB:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B17115_03_27.jpg" alt="Figure 3.27 – Getting data from MongoDB&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.27 – Getting data from MongoDB</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For a step-by-step guide on how to use the Postman client or <strong class="source-inline">cURL</strong> command, check out <a href="B17115_01_Final_JM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Gin</em>.</p>
			<p>If you hit a second HTTP request, this time, data will be returned from Redis because it was cached in the first request:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B17115_03_28.jpg" alt="Figure 3.28 – Getting data from Redis&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.28 – Getting data from Redis</p>
			<p>As we can see, retrieving <a id="_idIndexMarker239"/>data from memory (Redis) is wicked fast compared to retrieving data from disk (MongoDB).</p>
			<p>We can verify that data is being cached in Redis by running the Redis CLI from the container. Run the following commands:</p>
			<p class="source-code">docker ps</p>
			<p class="source-code">docker exec –it CONTAINER_ID bash</p>
			<p>These commands will connect to the Redis container using the interactive terminal and start the bash shell. You'll notice that you're now using your terminal as if you were inside your container, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B17115_03_29.jpg" alt="Figure 3.29 – Running an interactive session inside a Redis container&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.29 – Running an interactive session inside a Redis container</p>
			<p>Now that we're attached to the Redis container, we can use the Redis command line:</p>
			<p class="source-code">redis-cli</p>
			<p>From there, we can use the <strong class="source-inline">EXISTS</strong> command to check if the <strong class="source-inline">recipes</strong> key exists:</p>
			<p class="source-code">EXISTS recipes</p>
			<p>This command will return <strong class="source-inline">1</strong> (if the key exists) or <strong class="source-inline">0</strong> (if the key doesn't exist). In our case, the list of recipes has been cached in Redis:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B17115_03_30.jpg" alt="Figure 3.30 – Checking if a key exists in Redis&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.30 – Checking if a key exists in Redis</p>
			<p>There is a lot that you can <a id="_idIndexMarker240"/>accomplish with the shell client, but you've got the general idea. Type <strong class="source-inline">exit</strong> to leave the MongoDB shell and then <strong class="source-inline">exit</strong> once again to leave the interactive shell.</p>
			<p>For GUI fans, you can use Redis Insights (<a href="https://redislabs.com/fr/redis-enterprise/redis-insight/">https://redislabs.com/fr/redis-enterprise/redis-insight/</a>). It provides an intuitive interface to explore Redis and interact with its data. Similar to the Redis server, you can deploy Redis Insights with Docker:</p>
			<p class="source-code">docker run -d --name redisinsight --link redis -p 8001:8001 redislabs/redisinsight</p>
			<p>This command will run a container based on the Redis Insight official image and expose the interface on port 8001.</p>
			<p>Navigate with your browser to <strong class="source-inline">http://localhost:8081</strong>. The Redis Insights home page should appear. Click on <strong class="bold">I already have a database</strong> and then on the <strong class="bold">Connect to Redis database</strong> button:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B17115_03_31.jpg" alt="Figure 3.31 – Configuring the Redis database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.31 – Configuring the Redis database</p>
			<p>Set the <strong class="bold">Host</strong> to <strong class="source-inline">redis</strong>, <strong class="bold">port</strong> to <strong class="source-inline">6379</strong>, and name <a id="_idIndexMarker241"/>the database. The settings are as follows:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B17115_03_32.jpg" alt="Figure 3.32 – New Redis settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.32 – New Redis settings</p>
			<p>Next, click on <strong class="bold">ADD REDIS DATABASE</strong>. The <strong class="bold">local</strong> database <a id="_idIndexMarker242"/>will be saved; click on it:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B17115_03_33.jpg" alt="Figure 3.33 – Redis Insights databases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.33 – Redis Insights databases</p>
			<p>You will be redirected to the <strong class="bold">Summary</strong> page, which contains real metrics and stats about the Redis server:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B17115_03_34.jpg" alt="Figure 3.34 – Redis server metrics&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.34 – Redis server metrics</p>
			<p>If you click on <strong class="bold">BROWSE</strong>, you will <a id="_idIndexMarker243"/>see a list of all the keys that have been stored in Redis. As shown in the following screenshot, the recipes key has been cached:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B17115_03_35.jpg" alt="Figure 3.35 – Redis list of keys&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.35 – Redis list of keys</p>
			<p>Now, you can use <a id="_idIndexMarker244"/>the interface to explore, manipulate, and visualize data within Redis.</p>
			<p>So far, the API we've built is working as a charm, right? Not really; imagine that you add a new recipe to the database:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B17115_03_36.jpg" alt="Figure 3.36 – Creating a new recipe&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.36 – Creating a new recipe</p>
			<p>Now, if you <a id="_idIndexMarker245"/>issue a <strong class="source-inline">GET /recipes</strong> request, the new recipe won't be found. This is because the data is being returned from the cache:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B17115_03_37.jpg" alt="Figure 3.37 – Recipe not found&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.37 – Recipe not found</p>
			<p>One of the issues that caching introduces is that of keeping the cache up to date when  data changes:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B17115_03_38.jpg" alt="Figure 3.38 – All future requests are hitting Redis&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.38 – All future requests are hitting Redis</p>
			<p>There are two group rules in <a id="_idIndexMarker246"/>this case to fix inconsistencies. First, we <a id="_idIndexMarker247"/>can add a <strong class="bold">Time to Live</strong> (<strong class="bold">TTL</strong>) field for the recipes key in Redis. Second we can clear the <strong class="bold">recipes</strong> key in Redis each time a new recipe is inserted or updated.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The time to retain the cache's TTL depends on your application logic. You may need to save it for an hour or days, depending on how often the data gets updated.</p>
			<p>We can implement the second solution by updating the <strong class="source-inline">NewRecipeHandler</strong> function so that it deletes the <strong class="source-inline">recipes</strong> key when a new recipe is being inserted. In this case, the implementation will be as follows:</p>
			<p class="source-code">func (handler *RecipesHandler) NewRecipeHandler(c *gin.Context) {</p>
			<p class="source-code">   var recipe models.Recipe</p>
			<p class="source-code">   if err := c.ShouldBindJSON(&amp;recipe); err != nil {</p>
			<p class="source-code">       c.JSON(http.StatusBadRequest, </p>
			<p class="source-code">              gin.H{"error":err.Error()})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   }</p>
			<p class="source-code">   recipe.ID = primitive.NewObjectID()</p>
			<p class="source-code">   recipe.PublishedAt = time.Now()</p>
			<p class="source-code">   _, err := handler.collection.InsertOne(handler.ctx, </p>
			<p class="source-code">                                          recipe)</p>
			<p class="source-code">   if err != nil {</p>
			<p class="source-code">       c.JSON(http.StatusInternalServerError, </p>
			<p class="source-code">       gin.H{"error": "Error while inserting </p>
			<p class="source-code">             a new recipe"})</p>
			<p class="source-code">       return</p>
			<p class="source-code">   }</p>
			<p class="source-code">   log.Println("Remove data from Redis")</p>
			<p class="source-code">   handler.redisClient.Del("recipes")</p>
			<p class="source-code">   c.JSON(http.StatusOK, recipe)</p>
			<p class="source-code">}</p>
			<p>Redeploy the <a id="_idIndexMarker248"/>application. Now, if you hit a <strong class="source-inline">GET /recipes</strong> request, the data will be returned from MongoDB as expected; then, it will be cached in Redis. The second GET request will return data from Redis. However, now, if we issue a <strong class="source-inline">POST /recipes</strong> request to insert a new recipe, the <strong class="source-inline">recipes</strong> key in Redis will be cleared, as confirmed by the <strong class="source-inline">Remove data from Redis</strong> message. This means that the next <strong class="source-inline">GET /recipes</strong> request will fetch data from MongoDB:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B17115_03_39.jpg" alt="Figure 3.39 – Clearing the cache upon inserting a request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.39 – Clearing the cache upon inserting a request</p>
			<p>Now, the new recipe will be returned in the list of recipes:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B17115_03_40.jpg" alt="Figure 3.40 – New inserted recipe&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.40 – New inserted recipe</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Update <strong class="source-inline">UpdateRecipeHandler</strong> to clear the cache when a PUT request is occurring on the <strong class="source-inline">/recipes/{id}</strong> endpoint.</p>
			<p>While caching offers <a id="_idIndexMarker249"/>great benefits for applications with heavy reads, it may not be as beneficial for applications that perform a lot of database updates and can slow down writes.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor069"/>Performance benchmark</h2>
			<p>We can take this <a id="_idIndexMarker250"/>further and see how the API will behave under a huge volume of requests. We can simulate multiple requests with Apache Benchmark (<a href="https://httpd.apache.org/docs/2.4/programs/ab.html">https://httpd.apache.org/docs/2.4/programs/ab.html</a>).</p>
			<p>First, let's test the API without the caching layer. You can run 2,000 GET requests in total on the <strong class="source-inline">/recipes</strong> endpoint with 100 concurrent requests with the following command:</p>
			<p class="source-code">ab -n 2000 -c 100 -g without-cache.data <a href="http://localhost:8080/recipes ">http://localhost:8080/recipes</a></p>
			<p>It should take a few <a id="_idIndexMarker251"/>minutes for all the requests to be completed. Once done, you should see the following results:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B17115_03_41.jpg" alt="Figure 3.41 – API without a caching layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.41 – API without a caching layer</p>
			<p>The important thing to take from this output is as follows:</p>
			<ul>
				<li><strong class="bold">Time taken for tests</strong>: This means the total time to complete the 2,000 requests.</li>
				<li><strong class="bold">Time per request</strong>: This means how many milliseconds it takes to complete one request.</li>
			</ul>
			<p>Next, we will issue the same requests but this time on the API with caching (Redis):</p>
			<p class="source-code">ab -n 2000 -c 100 -g with-cache.data http://localhost:8080/recipes</p>
			<p>It should take a few seconds for the 2,000 requests to be completed:</p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B17115_03_42.jpg" alt="Figure 3.42 – API with a caching layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.42 – API with a caching layer</p>
			<p>To compare both results, we <a id="_idIndexMarker252"/>can use the <strong class="source-inline">gnuplot</strong> utility to plot a chart based on the <strong class="source-inline">without-cache.data</strong> and <strong class="source-inline">with-cache.data</strong> files. But first, create an <strong class="source-inline">apache-benchmark.p</strong> file to render data into a graph:</p>
			<p class="source-code">set terminal png</p>
			<p class="source-code">set output "benchmark.png"</p>
			<p class="source-code">set title "Cache benchmark"</p>
			<p class="source-code">set size 1,0.7</p>
			<p class="source-code">set grid y</p>
			<p class="source-code">set xlabel "request"</p>
			<p class="source-code">set ylabel "response time (ms)"</p>
			<p class="source-code">plot "with-cache.data" using 9 smooth sbezier with lines title "with cache", "without-cache.data" using 9 smooth sbezier with lines title "without cache"</p>
			<p>These commands will draw two plots on the same graph based on the <strong class="source-inline">.data</strong> files and save the output as a PNG image. Next, run the <strong class="source-inline">gnuplot</strong> command to create the image:</p>
			<p class="source-code">gnuplot apache-benchmark.p</p>
			<p>A <strong class="source-inline">benchmark.png</strong> image will be created, as follows:</p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B17115_03_43.jpg" alt="Figure 3.43 – Benchmark of APIs with and without caches&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.43 – Benchmark of APIs with and without caches</p>
			<p>The API's <a id="_idIndexMarker253"/>response time with the caching mechanism enabled is wicked fast compared to API's response time without caching.</p>
			<p>Make sure that you push the changes to GitHub with a feature branch. Then, create a pull request to merge into <strong class="source-inline">develop</strong>:</p>
			<p class="source-code">git checkout –b feature/redis_integration</p>
			<p class="source-code">git add .</p>
			<p class="source-code">git commit –m "added redis integration"</p>
			<p class="source-code">git push origin feature/redis_integration</p>
			<p>By the end of this chapter, your GitHub repository should look like this:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B17115_03_44.jpg" alt="Figure 3.44 – Project's GitHub repository&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.44 – Project's GitHub repository</p>
			<p>Great! Now, you <a id="_idIndexMarker254"/>should be able to integrate a MongoDB database into your API architecture to manage data persistency.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor070"/>Summary</h1>
			<p>In this chapter, we learned how to build a RESTful API that leverages the Gin framework and Go driver for creating queries and querying in a NoSQL database such as MongoDB.</p>
			<p>We also explored how to speed up the API by caching the data it accesses with Redis. It is definitely a great addition to your application if your data is mostly static and does not change constantly. Finally, we covered how to run performance benchmarks with Apache Benchmark.</p>
			<p>The RESTful API we have built so far works like a charm and is open to the public (if deployed on a remote server). If you leave the API unauthenticated, then anybody can hit any endpoint, which may very undesirable as your data could be damaged by users. Even worse, you might expose sensitive information from your database to the whole internet. That's why, in the next chapter, we will cover how to secure the API with authentication, such as JWT. </p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor071"/>Questions</h1>
			<ol>
				<li>Implement a delete recipe operation when a <strong class="source-inline">DELETE</strong> request occurs.</li>
				<li>Implement a GET /<strong class="source-inline">recipes/{id}</strong> endpoint using the <strong class="source-inline">FindOne</strong> operation.</li>
				<li>How are JSON documents stored in MongoDB?</li>
				<li>How does the LRU eviction policy work in Redis?</li>
			</ol>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor072"/>Further reading</h1>
			<ul>
				<li><em class="italic">MongoDB Fundamentals</em>, by Amit Phaltankar, Juned Ahsan, Michael Harrison, and Liviu Nedov, Packt Publishing</li>
				<li><em class="italic">Learn MongoDB 4.x</em>, by Doug Bierer, Packt Publishing</li>
				<li><em class="italic">Hands-On RESTful Web Services with Go – Second Edition</em>, by Naren Yellavula, Packt Publishing</li>
			</ul>
		</div>
	</body></html>