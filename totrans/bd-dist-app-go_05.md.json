["```go\ndocker version\n```", "```go\ndocker run hello-world\n```", "```go\ndocker run -d --name mongodb -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=password -p 27017:27017 mongo:4.4.3\n```", "```go\nopenssl rand -base64 12 | docker secret create mongodb_password -\n```", "```go\n-e MONGO_INITDB_ROOT_PASSWORD_FILE=/run/secrets/mongodb_password\n```", "```go\ndocker rm -f container_name || true \n```", "```go\ndocker logs –f CONTAINER_ID\n```", "```go\ngo get go.mongodb.org/mongo-driver/mongo\n```", "```go\nmodule github.com/mlabouardy/recipes-api\ngo 1.15\nrequire (\n   github.com/gin-gonic/gin v1.6.3\n   github.com/rs/xid v1.2.1 \n   go.mongodb.org/mongo-driver v1.4.5 \n)\n```", "```go\npackage main\nimport (\n   \"go.mongodb.org/mongo-driver/mongo\"\n   \"go.mongodb.org/mongo-driver/mongo/options\"\n   \"go.mongodb.org/mongo-driver/mongo/readpref\"\n)\n```", "```go\nvar ctx context.Context\nvar err error\nvar client *mongo.Client\nfunc init() {\n   ...\n   ctx = context.Background()\n   client, err = mongo.Connect(ctx, \n       options.Client().ApplyURI(os.Getenv(\"MONGO_URI\")))\n   if err = client.Ping(context.TODO(), \n           readpref.Primary()); err != nil {\n       log.Fatal(err)\n   }\n   log.Println(\"Connected to MongoDB\")\n}\n```", "```go\nMONGO_URI=\"mongodb://admin:password@localhost:27017/test?authSource=admin\" go run main.go\n```", "```go\nfunc init() {\n   recipes = make([]Recipe, 0)\n   file, _ := ioutil.ReadFile(\"recipes.json\")\n   _ = json.Unmarshal([]byte(file), &recipes)\n   ctx = context.Background()\n   client, err = mongo.Connect(ctx, \n       options.Client().ApplyURI(os.Getenv(\"MONGO_URI\")))\n   if err = client.Ping(context.TODO(), \n           readpref.Primary()); err != nil {\n       log.Fatal(err)\n   }\n   log.Println(\"Connected to MongoDB\")\n   var listOfRecipes []interface{}\n   for _, recipe := range recipes {\n       listOfRecipes = append(listOfRecipes, recipe)\n   }\n   collection := client.Database(os.Getenv(\n       \"MONGO_DATABASE\")).Collection(\"recipes\")\n   insertManyResult, err := collection.InsertMany(\n       ctx, listOfRecipes)\n   if err != nil {\n       log.Fatal(err)\n   }\n   log.Println(\"Inserted recipes: \", \n               len(insertManyResult.InsertedIDs))\n}\n```", "```go\nMONGO_URI=\"mongodb://USER:PASSWORD@localhost:27017/test?authSource=admin\" MONGO_DATABASE=demo go run main.go\n```", "```go\nfunc init() {\n   ctx = context.Background()\n   client, err = mongo.Connect(ctx, \n       options.Client().ApplyURI(os.Getenv(\"MONGO_URI\")))\n   if err = client.Ping(context.TODO(), \n                        readpref.Primary()); err != nil {\n       log.Fatal(err)\n   }\n   log.Println(\"Connected to MongoDB\")\n}\n```", "```go\nmongoimport --username admin --password password --authenticationDatabase admin --db demo --collection recipes --file recipes.json --jsonArray\n```", "```go\nfunc ListRecipesHandler(c *gin.Context) {\n   cur, err := collection.Find(ctx, bson.M{})\n   if err != nil {\n       c.JSON(http.StatusInternalServerError, \n              gin.H{\"error\": err.Error()})\n       return\n   }\n   defer cur.Close(ctx)\n   recipes := make([]Recipe, 0)\n   for cur.Next(ctx) {\n       var recipe Recipe\n       cur.Decode(&recipe)\n       recipes = append(recipes, recipe)\n   }\n   c.JSON(http.StatusOK, recipes)\n}\n```", "```go\nfunc NewRecipeHandler(c *gin.Context) {\n   var recipe Recipe\n   if err := c.ShouldBindJSON(&recipe); err != nil {\n       c.JSON(http.StatusBadRequest, gin.H{\"error\": \n           err.Error()})\n       return\n   }\n   recipe.ID = primitive.NewObjectID()\n   recipe.PublishedAt = time.Now()\n   _, err = collection.InsertOne(ctx, recipe)\n   if err != nil {\n       fmt.Println(err)\n       c.JSON(http.StatusInternalServerError, \n           gin.H{\"error\": \"Error while inserting\n                  a new recipe\"})\n       return\n   }\n   c.JSON(http.StatusOK, recipe)\n}\n```", "```go\n// swagger:parameters recipes newRecipe\ntype Recipe struct {\n   //swagger:ignore\n   ID primitive.ObjectID `json:\"id\" bson:\"_id\"`\n   Name string `json:\"name\" bson:\"name\"`\n   Tags []string `json:\"tags\" bson:\"tags\"`\n   Ingredients []string `json:\"ingredients\" bson:\"ingredients\"`\n   Instructions []string `json:\"instructions\"                           bson:\"instructions\"`\n   PublishedAt time.Time `json:\"publishedAt\"                           bson:\"publishedAt\"`\n}\n```", "```go\nfunc UpdateRecipeHandler(c *gin.Context) {\n   id := c.Param(\"id\")\n   var recipe Recipe\n   if err := c.ShouldBindJSON(&recipe); err != nil {\n       c.JSON(http.StatusBadRequest, gin.H{\"error\":                                            err.Error()})\n       return\n   }\n   objectId, _ := primitive.ObjectIDFromHex(id)\n   _, err = collection.UpdateOne(ctx, bson.M{\n       \"_id\": objectId,\n   }, bson.D{{\"$set\", bson.D{\n       {\"name\", recipe.Name},\n       {\"instructions\", recipe.Instructions},\n       {\"ingredients\", recipe.Ingredients},\n       {\"tags\", recipe.Tags},\n   }}})\n   if err != nil {\n       fmt.Println(err)\n       c.JSON(http.StatusInternalServerError, \n           gin.H{\"error\": err.Error()})\n       return\n   }\n   c.JSON(http.StatusOK, gin.H{\"message\": \"Recipe \n                               has been updated\"})\n}\n```", "```go\ngit checkout –b feature/mongo_integration\ngit add .\ngit commit –m \"added mongodb integration\"\ngit push origin feature/mongo_integration\n```", "```go\npackage models\nimport (\n   \"time\"\n   \"go.mongodb.org/mongo-driver/bson/primitive\"\n)\n// swagger:parameters recipes newRecipe\ntype Recipe struct {\n   //swagger:ignore\n   ID           primitive.ObjectID `json:\"id\" bson:\"_id\"`\n   Name         string             `json:\"name\" \n                                               bson:\"name\"`\n   Tags         []string           `json:\"tags\" \n                                               bson:\"tags\"`\n   Ingredients  []string           `json:\"ingredients\" \n                                      bson:\"ingredients\"`\n   Instructions []string           `json:\"instructions\" \n                                      bson:\"instructions\"`\n   PublishedAt  time.Time          `json:\"publishedAt\" \n                                      bson:\"publishedAt\"`\n}\n```", "```go\npackage handlers\nimport (\n   \"fmt\"\n   \"net/http\"\n   \"time\"\n   \"github.com/gin-gonic/gin\"\n   \"github.com/mlabouardy/recipes-api/models\"\n   \"go.mongodb.org/mongo-driver/bson\"\n   \"go.mongodb.org/mongo-driver/bson/primitive\"\n   \"go.mongodb.org/mongo-driver/mongo\"\n   \"golang.org/x/net/context\"\n)\ntype RecipesHandler struct {\n   collection *mongo.Collection\n   ctx        context.Context\n}\nfunc NewRecipesHandler(ctx context.Context, collection *mongo.Collection) *RecipesHandler {\n   return &RecipesHandler{\n       collection: collection,\n       ctx:        ctx,\n   }\n}\n```", "```go\nfunc (handler *RecipesHandler) ListRecipesHandler(c *gin.Context) {\n   cur, err := handler.collection.Find(handler.ctx, bson.M{})\n   if err != nil {\n       c.JSON(http.StatusInternalServerError, \n           gin.H{\"error\": err.Error()})\n       return\n   }\n   defer cur.Close(handler.ctx)\n\n   recipes := make([]models.Recipe, 0)\n   for cur.Next(handler.ctx) {\n       var recipe models.Recipe\n       cur.Decode(&recipe)\n       recipes = append(recipes, recipe)\n   }\n\n   c.JSON(http.StatusOK, recipes)\n}\n```", "```go\npackage main\nimport (\n   \"context\"\n   \"log\"\n   \"os\"\n   \"github.com/gin-gonic/gin\"\n   handlers \"github.com/mlabouardy/recipes-api/handlers\"\n   \"go.mongodb.org/mongo-driver/mongo\"\n   \"go.mongodb.org/mongo-driver/mongo/options\"\n   \"go.mongodb.org/mongo-driver/mongo/readpref\"\n)\n```", "```go\nvar recipesHandler *handlers.RecipesHandler\nfunc init() {\n   ctx := context.Background()\n   client, err := mongo.Connect(ctx, \n       options.Client().ApplyURI(os.Getenv(\"MONGO_URI\")))\n   if err = client.Ping(context.TODO(), \n           readpref.Primary()); err != nil {\n       log.Fatal(err)\n   }\n   log.Println(\"Connected to MongoDB\")\n   collection := client.Database(os.Getenv(\n       \"MONGO_DATABASE\")).Collection(\"recipes\")\n   recipesHandler = handlers.NewRecipesHandler(ctx, \n       collection)\n}\n```", "```go\nfunc main() {\n   router := gin.Default()\n   router.POST(\"/recipes\", recipesHandler.NewRecipeHandler)\n   router.GET(\"/recipes\", \n       recipesHandler.ListRecipesHandler)\n   router.PUT(\"/recipes/:id\", \n       recipesHandler.UpdateRecipeHandler)\n   router.Run()\n}\n```", "```go\nMONGO_URI=\"mongodb://admin:password@localhost:27017/test?authSource=admin\" MONGO_DATABASE=demo go run *.go\n```", "```go\n.\n├── go.mod\n├── go.sum\n├── handlers\n│   └── handler.go\n├── main.go\n├── models\n│   └── recipe.go\n├── recipes.json\n└── swagger.json\n```", "```go\ngit checkout –b fix/code_refactoring\ngit add .\ngit commit –m \"code refactoring\"\ngit push origin fix/code_refactoring\n```", "```go\ndocker run -d --name redis -p 6379:6379 redis:6.0\n```", "```go\ndocker logs –f CONTAINER_ID\n```", "```go\nmaxmemory-policy allkeys-lru\nmaxmemory 512mb\n```", "```go\ndocker run -d -v $PWD/conf:/usr/local/etc/redis --name redis -p 6379:6379 redis:6.0\n```", "```go\ngo get github.com/go-redis/redis/v8\n```", "```go\nimport \"github.com/go-redis/redis\"\n```", "```go\nredisClient := redis.NewClient(&redis.Options{\n       Addr:     \"localhost:6379\",\n       Password: \"\",\n       DB:       0,\n})\nstatus := redisClient.Ping()\nfmt.Println(status)\n```", "```go\ntype RecipesHandler struct {\n   collection  *mongo.Collection\n   ctx         context.Context\n   redisClient *redis.Client\n}\nfunc NewRecipesHandler(ctx context.Context, collection \n    *mongo.Collection, redisClient *redis.Client) \n     *RecipesHandler {\n   return &RecipesHandler{\n       collection:  collection,\n       ctx:         ctx,\n       redisClient: redisClient,\n   }\n}\n```", "```go\nrecipesHandler = handlers.NewRecipesHandler(ctx, collection,        \t                                            redisClient)\n```", "```go\nfunc (handler *RecipesHandler) ListRecipesHandler(c       *gin.Context) {\n   val, err := handler.redisClient.Get(\"recipes\").Result()\n   if err == redis.Nil {\n       log.Printf(\"Request to MongoDB\")\n       cur, err := handler.collection.Find(handler.ctx, \n                                           bson.M{})\n       if err != nil {\n           c.JSON(http.StatusInternalServerError, \n                  gin.H{\"error\": err.Error()})\n           return\n       }\n       defer cur.Close(handler.ctx)\n       recipes := make([]models.Recipe, 0)\n       for cur.Next(handler.ctx) {\n           var recipe models.Recipe\n           cur.Decode(&recipe)\n           recipes = append(recipes, recipe)\n       }\n       data, _ := json.Marshal(recipes)\n       handler.redisClient.Set(\"recipes\", string(data), 0)\n       c.JSON(http.StatusOK, recipes)\n   } else if err != nil {\n       c.JSON(http.StatusInternalServerError, \n              gin.H{\"error\": err.Error()})\n       return\n   } else {\n       log.Printf(\"Request to Redis\")\n       recipes := make([]models.Recipe, 0)\n       json.Unmarshal([]byte(val), &recipes)\n       c.JSON(http.StatusOK, recipes)\n   }\n}\n```", "```go\ndocker ps\ndocker exec –it CONTAINER_ID bash\n```", "```go\nredis-cli\n```", "```go\nEXISTS recipes\n```", "```go\ndocker run -d --name redisinsight --link redis -p 8001:8001 redislabs/redisinsight\n```", "```go\nfunc (handler *RecipesHandler) NewRecipeHandler(c *gin.Context) {\n   var recipe models.Recipe\n   if err := c.ShouldBindJSON(&recipe); err != nil {\n       c.JSON(http.StatusBadRequest, \n              gin.H{\"error\":err.Error()})\n       return\n   }\n   recipe.ID = primitive.NewObjectID()\n   recipe.PublishedAt = time.Now()\n   _, err := handler.collection.InsertOne(handler.ctx, \n                                          recipe)\n   if err != nil {\n       c.JSON(http.StatusInternalServerError, \n       gin.H{\"error\": \"Error while inserting \n             a new recipe\"})\n       return\n   }\n   log.Println(\"Remove data from Redis\")\n   handler.redisClient.Del(\"recipes\")\n   c.JSON(http.StatusOK, recipe)\n}\n```", "```go\nab -n 2000 -c 100 -g without-cache.data http://localhost:8080/recipes\n```", "```go\nab -n 2000 -c 100 -g with-cache.data http://localhost:8080/recipes\n```", "```go\nset terminal png\nset output \"benchmark.png\"\nset title \"Cache benchmark\"\nset size 1,0.7\nset grid y\nset xlabel \"request\"\nset ylabel \"response time (ms)\"\nplot \"with-cache.data\" using 9 smooth sbezier with lines title \"with cache\", \"without-cache.data\" using 9 smooth sbezier with lines title \"without cache\"\n```", "```go\ngnuplot apache-benchmark.p\n```", "```go\ngit checkout –b feature/redis_integration\ngit add .\ngit commit –m \"added redis integration\"\ngit push origin feature/redis_integration\n```"]