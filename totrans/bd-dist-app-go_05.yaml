- en: 'Chapter 3: Managing Data Persistence with MongoDB'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to build a RESTful API with the Gin
    web framework. In this one, we will integrate MongoDB into the backend for data
    storage, and we will also cover how to optimize database queries with Redis as
    a caching layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MongoDB with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Go MongoDB driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing MongoDB queries & and CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard Go project layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Redis with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing API response time with caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance benchmark with Apache Benchmark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to perform CRUD operations on a
    MongoDB database using Go.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the content in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You must have a complete understanding of the previous chapter since this chapter
    is a follow-up of the previous one; it will use the same source code. Hence, some
    snippets won't be explained to avoid repetition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some knowledge of NoSQL concepts and MongoDB basic queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter03](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Running a MongoDB Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API we've built so far is not connected to a database. For a real-world
    application, we need to use a form of data storage; otherwise, data will be lost
    if the API crashes or the server hosting the API goes down. MongoDB is one of
    the most popular NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following schema shows how MongoDB will be integrated into the API architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – API architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – API architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started, we need to deploy a MongoDB server. There are plenty
    of deployment options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the MongoDB Community Edition binary from the following URL:
    [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).
    Select a package based on your OS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – MongoDB Community Server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – MongoDB Community Server
  prefs: []
  type: TYPE_NORMAL
- en: You can use the MongoDB as a Service solution, known as MongoDB Atlas ([https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas)),
    to run a free 500 MB database on the cloud. You can deploy a fully managed MongoDB
    server on AWS, Google Cloud Platform, or Microsoft Azure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can run MongoDB locally with a containerization solution such as Docker.
    Multiple Docker images are available on DockerHub with a MongoDB server configured
    and ready to use out of the box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I opted to go with Docker due to its popularity and simplicity in running ephemeral
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker CE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker ([https://www.docker.com/get-started](https://www.docker.com/get-started))
    is an open source project that allows you to run, build, and manage containers.
    A container is like a separate OS, but not virtualized; it only contains the dependencies
    needed for that one application, which makes the container portable and deployable
    on-premises or on the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the main difference between containers and virtual
    machines in their architecture approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Virtual machines versus containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Virtual machines versus containers
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization happens at the hardware level for virtual machines, while for
    containers, it happens at the application layer. Therefore, containers can share
    the OS kernel and libraries, which makes them very lightweight and resource-efficient
    (CPU, RAM, disk, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, you need to install Docker Engine on your machine. Navigate
    to [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)
    and install Docker for your platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Docker installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Docker installation
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Mac users can also use the Homebrew utility to install Docker with the `brew
    install docker` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the installation wizard and, once completed, verify that everything
    works fine by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'At the time of writing this book, I''m using Docker **Community Edition** (**CE**)
    version 20.10.2, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Docker Community Edition (CE) version'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Docker Community Edition (CE) version
  prefs: []
  type: TYPE_NORMAL
- en: 'With Docker installed, you can deploy your first container. Issue the following
    command in your terminal session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will deploy a container based on the `hello-world` image.
    When the container runs, it will print a *Hello from Docker*! message and exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Docker hello-world container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Docker hello-world container
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You are now successfully running Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Running a MongoDB container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoDB''s official image can be found on DockerHub ([https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)).
    There are numerous images available, each representing different versions of MongoDB.
    You can use the `latest` tag to find them; however, it''s recommended to specify
    the target version. At the time of writing this book, MongoDB 4.4.3 is the latest
    stable version. Execute the following command to deploy a container based on that
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command will run a MongoDB container in detached mode (the `-d` flag).
    We're also mapping the container port to the host port so that we can access the
    database from the host level. Finally, we must create a new user and set that
    user's password through the `MONGO_INITDB_ROOT_USERNAME` and `MONGO_INITDB_ROOT_PASSWORD`
    environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, the MongoDB credentials are in plain text. Another way of passing
    sensitive information via environment variables is by using Docker Secrets. If
    you''re running in Swarm mode, you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm mode is natively integrated in Docker engine. It's a container
    orchestration platform used to build, deploy, and scale containers across a cluster
    of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: This command will generate a random password for a MongoDB user and set it as
    a Docker secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update the `docker run` command so that it uses the Docker Secret instead
    of the password in plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker run` command''s output is as follows. It downloads the image from
    DockerHub and creates an instance (container) from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Pulling a MongoDB image from DockerHub'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Pulling a MongoDB image from DockerHub
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth mentioning that if you''re already running the MongoDB container,
    make sure that you remove it before executing the previous command; otherwise,
    you''ll receive a "Container already exists" error. To remove an existing container,
    issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the container has been created, check the logs by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The logs should display the MongoDB server''s health check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – MongoDB container runtime logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – MongoDB container runtime logs
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s recommended that you use Docker volumes to map the `/data/db` directory
    within the container with the underlying host system. That way, if the MongoDB
    server fails or your laptop restarts, the data won''t be lost (data persistency).
    Create a data directory on the host system and mount the directory to the `/data/db`
    directory with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mkdir /home/data`'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker run -d --name mongodb –v /home/data:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin
    -e MONGO_INITDB_ROOT_PASSWORD=password -p 27017:27017 mongo:4.4.3`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To interact with the MongoDB server, you can use the MongoDB shell to issue
    queries and view data on the command line. However, there is a better alternative:
    MongoDB Compass.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing MongoDB Compass
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB Compass is a GUI tool that allows you to easily build queries, understand
    your database schema, and analyze your indexes, all without having to know MongoDB's
    query syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Compass from [https://www.mongodb.com/try/download/compass?tck=docs_compass](https://www.mongodb.com/try/download/compass?tck=docs_compass)
    based on your OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – MongoDB Compass download page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – MongoDB Compass download page
  prefs: []
  type: TYPE_NORMAL
- en: Once you've downloaded the package relevant to your OS, run the installer and
    follow the steps that come after it. Once installed, open Compass, click on `mongodb://admin:password@localhost:27017/test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB is running locally, so the hostname will be localhost and the port
    will be 27017:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – MongoDB Compass – New Connection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – MongoDB Compass – New Connection
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **CONNECT** button. Now, you are connected to your MongoDB server.
    You will see a list of databases that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – MongoDB default databases'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – MongoDB default databases
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a functional MongoDB deployment. In the next section,
    we're going to interact with the database using the Recipes API we built in the
    previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To stop MongoDB server, run `docker ps` command to see the list of the running
    containers and `docker stop CONTAINER_ID` to stop the container.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Go's MongoDB driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Recipes API we implemented in the previous chapter is written in Golang.
    Therefore, we need to install the official MongoDB Go driver ([https://github.com/mongodb/mongo-go-driver](https://github.com/mongodb/mongo-go-driver))
    to interact with the MongoDB server. The driver fully integrates with the MongoDB
    API and supports all the main queries and aggregation features of the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Issue the following command to install the package from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add the package as a dependency in the `require` section, under the
    `go.mod` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To get started, import the following packages in the `main.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `init()` method, create a `mongo.Client` with the `Connect` function.
    This function takes a context as a parameter and the connection string, which
    is provided with an environment variable called `MONGO_URI`. Also, create the
    following global variables; they will be used across all the CRUD operation functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I have omitted some of the code to make the example readable and easy to follow.
    The full source code is available in this book's GitHub repository, under the
    `chapter03` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `Connect` method returns the client object, we can use the `Ping` method
    to check whether the connection was successful or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass the `MONGO_URI` environment variable to the `go run` command and check
    if the application can successfully connect to your MongoDB server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If successful, a **Connected to MongoDB** message will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – MongoDB connection with the Go driver'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – MongoDB connection with the Go driver
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's populate a fresh database with some data.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring MongoDB queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will interact with the MongoDB server using CRUD operations,
    but first, let's create a database where the API data will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can view the full documentation for the MongoDB Go driver on the GoDoc website
    ([https://godoc.org/go.mongodb.org/mongo-driver](https://godoc.org/go.mongodb.org/mongo-driver)).
  prefs: []
  type: TYPE_NORMAL
- en: The InsertMany operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s initialize the database with the `recipes.json` file we created in the
    previous chapter. First, retrieve a `Database` and then a `Collection` instance
    from `Client`. The `Collection` instance will be used to insert documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code reads a JSON file ([https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/recipes.json](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/recipes.json)),
    which contains a list of recipes, and encodes it into an array of the `Recipe`
    struct. Then, it establishes a connection with the MongoDB server and inserts
    the recipes into the `recipes` collection.
  prefs: []
  type: TYPE_NORMAL
- en: To insert multiple documents at a time, we can use the `InsertMany()` method.
    This method accepts an interface slice as a parameter. Therefore, we must map
    the `Recipes` struct slice to the interface slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerun the application, but this time, set the `MONGO_URI and MONGO_DATABASE`
    variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to replace `USER` with your database user and `PASSWORD` with the
    user password we created while deploying the MongoDB container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will be launched; the `init()` method will be executed first
    and the recipes items will be inserted into the MongoDB collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Inserting recipes during startup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Inserting recipes during startup
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the data has been loaded into the recipes collection, refresh
    MongoDB Compass. You should see the entries that you created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Recipes collection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Recipes collection
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the `recipes` collection has been prepared, we need to update each
    API endpoint''s code so that they use the collection instead of the hardcoded
    recipes list. But first, we need to update the `init()` method to remove the loading
    and encoding of the `recipes.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s worth mentioning that you can use the `mongoimport` utility to load the
    `recipe.json` file directly into the `recipes` collection without writing a single
    line of code in Golang. The command for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will import the content from the JSON file into the `recipes`
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Importing data with mongoimport'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – Importing data with mongoimport
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will update the existing function handlers to read and
    write from/to the `recipes` collection.
  prefs: []
  type: TYPE_NORMAL
- en: The Find operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, we need to implement the function responsible for returning
    a list of recipes. Update `ListRecipesHandler` so that it uses the `Find()` method
    to fetch all the items from the `recipes` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Find()` method returns a cursor, which is a stream of documents. We must
    go through the stream of documents and decode one at a time into the `Recipe`
    struct. Then, we must append the document to a list of recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application, then issue a GET request on the `/recipes` endpoint; a
    `find()` operation will be executed on the `recipes` collection. As a result,
    a list of recipes will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Getting all the recipes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – Getting all the recipes
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint is working and fetching the recipe's items from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: The InsertOne operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second function to be implemented will be responsible for saving a new
    recipe. Update the `NewRecipeHandler` function so that it calls the `InsertOne()`
    method on the `recipes` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we set a unique identifier using the `primitive.NewObjectID()` method
    ahead of saving the item in the collection. Therefore, we need to change the ID
    type of the `Recipe` struct. Also, note the usage of the `bson` tags to map a
    `struct` field to the `document` attribute in the MongoDB collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By default, Go lowercases the struct field names when encoding struct values.
    If a different name is needed, you can override the default mechanism with `bson`
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert a new recipe by calling the following POST request with the Postman
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Creating a new recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – Creating a new recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the recipe has been inserted into the MongoDB collection, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Getting the last inserted recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Getting the last inserted recipe
  prefs: []
  type: TYPE_NORMAL
- en: To get the last inserted recipe, we use the `sort()` operation.
  prefs: []
  type: TYPE_NORMAL
- en: The UpdateOne operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, in order to update an item from the collection, update the `UpdateRecipeHandler`
    function so that it calls the `UpdateOne()` method. This method requires a filter
    document to match documents in the database and an updater document to describe
    the update operation. You can build a filter using `bson.D{}` – a **Binary-encoded
    JSON** (**BSON**) document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This method filters documents by their Object ID. We get the Object ID by applying
    `ObjectIDFromHex` to the route parameter ID. This updates the matched recipe's
    fields with the new values coming from the request body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the endpoint is working by calling a PUT request on an existing recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Updating a recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – Updating a recipe
  prefs: []
  type: TYPE_NORMAL
- en: The request will match the recipe where `ID` is `600dcc85a65917cbd1f201b0` and
    will update its `name` from "`Homemade Pizza`" to "`Homemade Pepperoni Pizza`",
    and the `instructions` field with additional steps to make a "`Pepperoni Pizza`".
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, the recipe has been successfully updated. You can confirm these
    changes with MongoDB Compass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – UpdateOne operation results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 – UpdateOne operation results
  prefs: []
  type: TYPE_NORMAL
- en: You should now be familiar with the basic MongoDB queries. Go ahead and implement
    the remaining CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, make sure that you push the changes to the remote repository with
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a pull request to merge the `feature` branch into `develop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – New pull request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.21 – New pull request
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A full implementation of the endpoints can be found in this book's GitHub repository
    ([https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/main.go](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/main.go)).
  prefs: []
  type: TYPE_NORMAL
- en: You just saw how to integrate MongoDB into the application architecture. In
    the next section, we will cover how to refactor the source code of our application
    so that it's maintainable, scalable, and extendable in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the project's layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, all the code we've written is in the `main.go` file. While this works
    fine, it's important to make sure the code is well structured; otherwise, you'll
    end up with a lot of hidden dependencies and messy code (spaghetti code) when
    the project grows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the data model. Let''s create a `models` folder so that
    we can store all the models structs. For now, we have one model, which is the
    `Recipe` struct. Create a `recipe.go` file under the `models` folder and paste
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a `handlers` folder with the `handler.go` file. This folder, as
    its name indicts, handles any incoming HTTP requests by exposing the right function
    to be called for each HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a `RecipesHandler` struct with the MongoDB collection and
    context instances encapsulated. In our early simple implementations, we tended
    to keep these variables global within the main package. Here, we are keeping these
    variables in the struct. Next, we must define a `NewRecipesHandler` so that we
    can create an instance from the `RecipesHandler` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can define the endpoints handlers of the `RecipesHandler` type. The
    handlers can access all the variables of the struct such as the database connection
    because it is a method of the `RecipesHandler` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'From our `main.go` file, we''ll provide all the database credentials and connect
    to the MongoDB server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must create a global variable to access the endpoints handlers. Update
    the `init()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, use the `recipesHandler` variable to access the handler for each HTTP
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application. This time, run all the `.go` files within the current
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will be working as expected. The server logs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Gin debug logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.22 – Gin debug logs
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, your project structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is a basic layout for a Go application project. There are Go directories
    that we will cover in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Push the changes to GitHub on a feature branch and merge the branch into `develop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When running a service that interacts with a database, its operations may become
    bottlenecks, thus degrading the user experience and impacting your business. That
    is why response time is one of the most important metrics to evaluate when developing
    a RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we can add a cache layer to store frequently accessed data in memory
    to speed things up, thus reducing the number of operations/queries on the database.
  prefs: []
  type: TYPE_NORMAL
- en: Caching an API with Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover how to add a caching mechanism to our API. Let's
    imagine that we have a tremendous number of recipes in our MongoDB database. Every
    time we try to query a list of recipes, we struggle with performance issues. What
    we can do instead is use an in-memory database, such as Redis, to reuse previously
    retrieved recipes and avoiding hitting the MongoDB database on each request.
  prefs: []
  type: TYPE_NORMAL
- en: Redis is consistently faster at retrieving data because it is always in RAM
    – that's why it's an excellent choice for caching. On the other hand, MongoDB
    might have to retrieve data from disk for advancing queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the official documentation ([https://redis.io/](https://redis.io/)),
    Redis is an open source, distributed, in-memory, key-value database, cache, and
    message broker. The following diagram illustrates how Redis fits in our API architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – API new architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.23 – API new architecture
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we want to get a list of recipes. First, the API will look around
    in Redis. If a list of recipes exists, it will be returned (this is called a `find({})`
    query will be issued, and the results will be returned and also saved in the cache
    for future requests.
  prefs: []
  type: TYPE_NORMAL
- en: Running Redis in Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to set up Redis is through Docker. We will use the Redis official
    image available at DockerHub for this ([https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)).
    At the time of writing this book, the latest stable version is 6.0\. Run a container
    based on that image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This command does the following two main things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `–d` flag runs the Redis container as a daemon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `–p` flag maps port 6379 of the container to port 6379 of the host. Port
    6379 is the port where the Redis server is exposed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The command''s output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Pulling a Redis image from DockerHub'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.24 – Pulling a Redis image from DockerHub
  prefs: []
  type: TYPE_NORMAL
- en: 'Always check the Docker log to see the chain of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The logs provide a wealth of useful information, such as the default configuration
    and the exposed server port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Redis server logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.25 – Redis server logs
  prefs: []
  type: TYPE_NORMAL
- en: 'The Redis container uses the basic caching policy. For production usage, it''s
    recommended to configure an eviction policy. You can configure the policy with
    a `redis.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This config allocates 512 MB of memory for Redis and sets the eviction policy
    to the **Least Recently Used** (**LRU**) algorithm, which deletes the cache items
    that were the least recently used. As a result, we only keep the items with the
    highest chances of getting read again.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then pass the config at the runtime of the container with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, `$PWD/conf` is the folder containing the `redis.conf` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that Redis is running, we can use it to cache API data. But first, let''s
    install the official Redis Go driver ([https://github.com/go-redis/redis](https://github.com/go-redis/redis))
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the following package in the `main.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on the `init()` method, initialize the Redis client with `redis.NewClient()`.
    This method takes the server address, password, and database as parameters. Next,
    we will call the `Ping()` method on the Redis client to check the connection status
    to the Redis server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will set up a connection with the Redis server after deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 – Checking the connection with the Redis server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.26 – Checking the connection with the Redis server
  prefs: []
  type: TYPE_NORMAL
- en: 'If the connection is successful, a `ping: PONG` message will be displayed,
    as shown in the preceding screenshot.'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing MongoDB queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a connection being established with the Redis server, we can update the
    `RecipesHandler` struct to store an instance of the Redis client so that the handlers
    can interact with Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that you pass the Redis client instance to the `RecipesHandler` instance
    in the `init()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must update `ListRecipesHandler` to check if the recipes have been
    cached in Redis. If they are, we return a list. If not, we will retrieve the data
    from MongoDB and cache it in Redis. The new changes we must make to the code are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It's worth mentioning that the Redis value has to be a string, so we had to
    encode the `recipes` slice into a string with the `json.Marshal()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test out the new changes, run the application. Then, issue a GET request
    on the `/recipes` endpoint with Postman client or with a `cURL` command. Flip
    back to your Terminal and view the Gin logs. You should see a message in the console
    for the first request corresponding to getting data from MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27 – Getting data from MongoDB'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.27 – Getting data from MongoDB
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For a step-by-step guide on how to use the Postman client or `cURL` command,
    check out [*Chapter 1*](B17115_01_Final_JM_ePub.xhtml#_idTextAnchor015), *Getting
    Started with Gin*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you hit a second HTTP request, this time, data will be returned from Redis
    because it was cached in the first request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.28 – Getting data from Redis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.28 – Getting data from Redis
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, retrieving data from memory (Redis) is wicked fast compared to
    retrieving data from disk (MongoDB).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify that data is being cached in Redis by running the Redis CLI from
    the container. Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands will connect to the Redis container using the interactive terminal
    and start the bash shell. You''ll notice that you''re now using your terminal
    as if you were inside your container, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.29 – Running an interactive session inside a Redis container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.29 – Running an interactive session inside a Redis container
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re attached to the Redis container, we can use the Redis command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, we can use the `EXISTS` command to check if the `recipes` key exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will return `1` (if the key exists) or `0` (if the key doesn''t
    exist). In our case, the list of recipes has been cached in Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.30 – Checking if a key exists in Redis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.30 – Checking if a key exists in Redis
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot that you can accomplish with the shell client, but you've got
    the general idea. Type `exit` to leave the MongoDB shell and then `exit` once
    again to leave the interactive shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'For GUI fans, you can use Redis Insights ([https://redislabs.com/fr/redis-enterprise/redis-insight/](https://redislabs.com/fr/redis-enterprise/redis-insight/)).
    It provides an intuitive interface to explore Redis and interact with its data.
    Similar to the Redis server, you can deploy Redis Insights with Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This command will run a container based on the Redis Insight official image
    and expose the interface on port 8001.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate with your browser to `http://localhost:8081`. The Redis Insights home
    page should appear. Click on **I already have a database** and then on the **Connect
    to Redis database** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.31 – Configuring the Redis database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.31 – Configuring the Redis database
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `redis`, `6379`, and name the database. The settings are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.32 – New Redis settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.32 – New Redis settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click on **ADD REDIS DATABASE**. The **local** database will be saved;
    click on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.33 – Redis Insights databases'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.33 – Redis Insights databases
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be redirected to the **Summary** page, which contains real metrics
    and stats about the Redis server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.34 – Redis server metrics'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.34 – Redis server metrics
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on **BROWSE**, you will see a list of all the keys that have been
    stored in Redis. As shown in the following screenshot, the recipes key has been
    cached:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.35 – Redis list of keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.35 – Redis list of keys
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can use the interface to explore, manipulate, and visualize data within
    Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, the API we''ve built is working as a charm, right? Not really; imagine
    that you add a new recipe to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.36 – Creating a new recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.36 – Creating a new recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you issue a `GET /recipes` request, the new recipe won''t be found.
    This is because the data is being returned from the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.37 – Recipe not found'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.37 – Recipe not found
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the issues that caching introduces is that of keeping the cache up to
    date when data changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.38 – All future requests are hitting Redis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.38 – All future requests are hitting Redis
  prefs: []
  type: TYPE_NORMAL
- en: There are two group rules in this case to fix inconsistencies. First, we can
    add a **Time to Live** (**TTL**) field for the recipes key in Redis. Second we
    can clear the **recipes** key in Redis each time a new recipe is inserted or updated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The time to retain the cache's TTL depends on your application logic. You may
    need to save it for an hour or days, depending on how often the data gets updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement the second solution by updating the `NewRecipeHandler` function
    so that it deletes the `recipes` key when a new recipe is being inserted. In this
    case, the implementation will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Redeploy the application. Now, if you hit a `GET /recipes` request, the data
    will be returned from MongoDB as expected; then, it will be cached in Redis. The
    second GET request will return data from Redis. However, now, if we issue a `POST
    /recipes` request to insert a new recipe, the `recipes` key in Redis will be cleared,
    as confirmed by the `Remove data from Redis` message. This means that the next
    `GET /recipes` request will fetch data from MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.39 – Clearing the cache upon inserting a request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.39 – Clearing the cache upon inserting a request
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the new recipe will be returned in the list of recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.40 – New inserted recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.40 – New inserted recipe
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Update `UpdateRecipeHandler` to clear the cache when a PUT request is occurring
    on the `/recipes/{id}` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: While caching offers great benefits for applications with heavy reads, it may
    not be as beneficial for applications that perform a lot of database updates and
    can slow down writes.
  prefs: []
  type: TYPE_NORMAL
- en: Performance benchmark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can take this further and see how the API will behave under a huge volume
    of requests. We can simulate multiple requests with Apache Benchmark ([https://httpd.apache.org/docs/2.4/programs/ab.html](https://httpd.apache.org/docs/2.4/programs/ab.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s test the API without the caching layer. You can run 2,000 GET
    requests in total on the `/recipes` endpoint with 100 concurrent requests with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It should take a few minutes for all the requests to be completed. Once done,
    you should see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.41 – API without a caching layer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.41 – API without a caching layer
  prefs: []
  type: TYPE_NORMAL
- en: 'The important thing to take from this output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time taken for tests**: This means the total time to complete the 2,000 requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time per request**: This means how many milliseconds it takes to complete
    one request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will issue the same requests but this time on the API with caching
    (Redis):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'It should take a few seconds for the 2,000 requests to be completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.42 – API with a caching layer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.42 – API with a caching layer
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare both results, we can use the `gnuplot` utility to plot a chart based
    on the `without-cache.data` and `with-cache.data` files. But first, create an
    `apache-benchmark.p` file to render data into a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands will draw two plots on the same graph based on the `.data` files
    and save the output as a PNG image. Next, run the `gnuplot` command to create
    the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A `benchmark.png` image will be created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.43 – Benchmark of APIs with and without caches'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.43 – Benchmark of APIs with and without caches
  prefs: []
  type: TYPE_NORMAL
- en: The API's response time with the caching mechanism enabled is wicked fast compared
    to API's response time without caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that you push the changes to GitHub with a feature branch. Then,
    create a pull request to merge into `develop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'By the end of this chapter, your GitHub repository should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.44 – Project''s GitHub repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_03_44.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.44 – Project's GitHub repository
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now, you should be able to integrate a MongoDB database into your API
    architecture to manage data persistency.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to build a RESTful API that leverages the Gin
    framework and Go driver for creating queries and querying in a NoSQL database
    such as MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored how to speed up the API by caching the data it accesses with
    Redis. It is definitely a great addition to your application if your data is mostly
    static and does not change constantly. Finally, we covered how to run performance
    benchmarks with Apache Benchmark.
  prefs: []
  type: TYPE_NORMAL
- en: The RESTful API we have built so far works like a charm and is open to the public
    (if deployed on a remote server). If you leave the API unauthenticated, then anybody
    can hit any endpoint, which may very undesirable as your data could be damaged
    by users. Even worse, you might expose sensitive information from your database
    to the whole internet. That's why, in the next chapter, we will cover how to secure
    the API with authentication, such as JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement a delete recipe operation when a `DELETE` request occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a GET /`recipes/{id}` endpoint using the `FindOne` operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are JSON documents stored in MongoDB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the LRU eviction policy work in Redis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*MongoDB Fundamentals*, by Amit Phaltankar, Juned Ahsan, Michael Harrison,
    and Liviu Nedov, Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learn MongoDB 4.x*, by Doug Bierer, Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On RESTful Web Services with Go – Second Edition*, by Naren Yellavula,
    Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
