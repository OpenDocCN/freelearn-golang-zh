["```go\nfunc (handler *RecipesHandler) NewRecipeHandler(\n             c *gin.Context) {\n   if c.GetHeader(\"X-API-KEY\") != os.Getenv(\"X_API_KEY\") {\n       c.JSON(http.StatusUnauthorized, gin.H{\n          \"error\": \"API key not provided or invalid\"})\n       return\n   }\n}\n```", "```go\nX_API_KEY=eUbP9shywUygMx7u  MONGO_URI=\"mongodb://admin:password@localhost:27017/test?authSource=admin\" MONGO_DATABASE=demo go run *.go\n```", "```go\ncurl --location --request POST 'http://localhost:8080/recipes' \\\n--header 'X-API-KEY: eUbP9shywUygMx7u' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n   \"name\": \"Homemade Pizza\",\n   \"ingredients\": [\"...\"],\n   \"instructions\": [\"...\"],\n   \"tags\": [\"dinner\", \"fastfood\"]\n}'\n```", "```go\nfunc AuthMiddleware() gin.HandlerFunc {\n   return func(c *gin.Context) {\n       if c.GetHeader(\"X-API-KEY\") != \n               os.Getenv(\"X_API_KEY\") {\n           c.AbortWithStatus(401)\n       }\n       c.Next()\n   }\n}\n```", "```go\nauthorized := router.Group(\"/\")\nauthorized.Use(AuthMiddleware()){\n       authorized.POST(\"/recipes\", \n                       recipesHandler.NewRecipeHandler)\n       authorized.GET(\"/recipes\", \n                      recipesHandler.ListRecipesHandler)\n       authorized.PUT(\"/recipes/:id\", \n                      recipesHandler.UpdateRecipeHandler)\n       authorized.DELETE(\"/recipes/:id\", \n                        recipesHandler.DeleteRecipeHandler)\n}\n```", "```go\nfunc main() {\n   router := gin.Default()\n   router.GET(\"/recipes\", \n              recipesHandler.ListRecipesHandler)\n   authorized := router.Group(\"/\")\n   authorized.Use(AuthMiddleware())\n   {\n       authorized.POST(\"/recipes\", \n                       recipesHandler.NewRecipeHandler)\n       authorized.PUT(\"/recipes/:id\", \n                      recipesHandler.UpdateRecipeHandler)\n       authorized.DELETE(\"/recipes/:id\",   \n                        recipesHandler.DeleteRecipeHandler)\n       authorized.GET(\"/recipes/:id\", \n                      recipesHandler.GetOneRecipeHandler)\n   }\n\n  router.Run()\n}\n```", "```go\ngo get github.com/dgrijalva/jwt-go\n```", "```go\nmodule github.com/mlabouardy/recipes-api\ngo 1.15\nrequire (\n   github.com/dgrijalva/jwt-go v3.2.0+incompatible \n   // indirect\n   github.com/gin-gonic/gin v1.6.3\n   github.com/go-redis/redis v6.15.9+incompatible\n   github.com/go-redis/redis/v8 v8.4.10\n   go.mongodb.org/mongo-driver v1.4.5\n   golang.org/x/net v0.0.0-20201202161906-c7110b5ffcbb\n)\n```", "```go\npackage handlers\nimport (\n   \"net/http\"\n   \"os\"\n   \"time\"\n   \"github.com/dgrijalva/jwt-go\"\n)\ntype AuthHandler struct{}\ntype Claims struct {\n   Username string `json:\"username\"`\n   jwt.StandardClaims\n}\ntype JWTOutput struct {\n   Token   string    `json:\"token\"`\n   Expires time.Time `json:\"expires\"`\n}\nfunc (handler *AuthHandler) SignInHandler(c *gin.Context) {}\n```", "```go\npackage models\ntype User struct {\n   Password string `json:\"password\"`\n   Username string `json:\"username\"`\n}\n```", "```go\nfunc (handler *AuthHandler) SignInHandler(c *gin.Context) {\n   var user models.User\n   if err := c.ShouldBindJSON(&user); err != nil {\n       c.JSON(http.StatusBadRequest, gin.H{\"error\": \n           err.Error()})\n       return\n   }\n   if user.Username != \"admin\" || user.Password != \n          \"password\" {\n       c.JSON(http.StatusUnauthorized, gin.H{\"error\": \n          \"Invalid username or password\"})\n       return\n   }\n   expirationTime := time.Now().Add(10 * time.Minute)\n   claims := &Claims{\n       Username: user.Username,\n       StandardClaims: jwt.StandardClaims{\n           ExpiresAt: expirationTime.Unix(),\n       },\n   }\n   token := jwt.NewWithClaims(jwt.SigningMethodHS256, \n                              claims)\n   tokenString, err := token.SignedString([]byte(\n                       os.Getenv(\"JWT_SECRET\")))\n   if err != nil {\n       c.JSON(http.StatusInternalServerError, \n              gin.H{\"error\": err.Error()})\n       return\n   }\n   jwtOutput := JWTOutput{\n       Token:   tokenString,\n       Expires: expirationTime,\n   }\n   c.JSON(http.StatusOK, jwtOutput)\n}\n```", "```go\npackage main\nimport (\n   ...\n)\nvar authHandler *handlers.AuthHandler\nvar recipesHandler *handlers.RecipesHandler\nfunc init() {\n   ...\n   recipesHandler = handlers.NewRecipesHandler(ctx, \n      collection, redisClient)\n   authHandler = &handlers.AuthHandler{}\n}\nfunc main() {\n   router := gin.Default()\n   router.GET(\"/recipes\", \n              recipesHandler.ListRecipesHandler)\n   router.POST(\"/signin\", authHandler.SignInHandler)\n   ...\n}\n```", "```go\nfunc (handler *AuthHandler) AuthMiddleware() gin.HandlerFunc {\n   return func(c *gin.Context) {\n       tokenValue := c.GetHeader(\"Authorization\")\n       claims := &Claims{}\n       tkn, err := jwt.ParseWithClaims(tokenValue, claims, \n              func(token *jwt.Token) (interface{}, error) {\n           return []byte(os.Getenv(\"JWT_SECRET\")), nil\n       })\n       if err != nil {\n           c.AbortWithStatus(http.StatusUnauthorized)\n       }\n       if tkn == nil ||!tkn.Valid {\n           c.AbortWithStatus(http.StatusUnauthorized)\n       }\n       c.Next()\n   }\n}\n```", "```go\nJWT_SECRET=eUbP9shywUygMx7u MONGO_URI=\"mongodb://admin:password@localhost:27017/test?authSource=admin\" MONGO_DATABASE=demo go run *.go\n```", "```go\nfunc (handler *AuthHandler) RefreshHandler(c *gin.Context) {\n   tokenValue := c.GetHeader(\"Authorization\")\n   claims := &Claims{}\n   tkn, err := jwt.ParseWithClaims(tokenValue, claims, \n          func(token *jwt.Token) (interface{}, error) {\n       return []byte(os.Getenv(\"JWT_SECRET\")), nil\n   })\n   if err != nil {\n       c.JSON(http.StatusUnauthorized, gin.H{\"error\": \n          err.Error()})\n       return\n   }\n   if tkn == nil ||!tkn.Valid {\n       c.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid\t                                              token\"})\n       return\n   }\n   if time.Unix(claims.ExpiresAt, 0).Sub(time.Now()) > \n            30*time.Second {\n       c.JSON(http.StatusBadRequest, gin.H{\"error\": \n            \"Token is not expired yet\"})\n       return\n   }\n   expirationTime := time.Now().Add(5 * time.Minute)\n   claims.ExpiresAt = expirationTime.Unix()\n   token := jwt.NewWithClaims(jwt.SigningMethodHS256, \n                              claims)\n   tokenString, err := token.SignedString(os.Getenv(\n                       \"JWT_SECRET\"))\n   if err != nil {\n       c.JSON(http.StatusInternalServerError, \n           gin.H{\"error\": err.Error()})\n       return\n   }\n   jwtOutput := JWTOutput{\n       Token:   tokenString,\n       Expires: expirationTime,\n   }\n   c.JSON(http.StatusOK, jwtOutput)\n}\n```", "```go\nrouter.POST(\"/refresh\", authHandler.RefreshHandler)\n```", "```go\ntype AuthHandler struct {\n   collection *mongo.Collection\n   ctx        context.Context\n}\nfunc NewAuthHandler(ctx context.Context, collection \n          *mongo.Collection) *AuthHandler {\n   return &AuthHandler{\n       collection: collection,\n       ctx:        ctx,\n   }\n}\n```", "```go\nfunc (handler *AuthHandler) SignInHandler(c *gin.Context) {\n\n   h := sha256.New()\n   cur := handler.collection.FindOne(handler.ctx, bson.M{\n       \"username\": user.Username,\n       \"password\": string(h.Sum([]byte(user.Password))),\n   })\n   if cur.Err() != nil {\n       c.JSON(http.StatusUnauthorized, gin.H{\"error\": \n           \"Invalid username or password\"})\n       return\n   }\n   ...\n}\n```", "```go\ncollectionUsers := client.Database(os.Getenv(\n                   \"MONGO_DATABASE\")).Collection(\"users\")\nauthHandler = handlers.NewAuthHandler(ctx, collectionUsers)\n```", "```go\nfunc main() {\n   users := map[string]string{\n       \"admin\":      \"fCRmh4Q2J7Rseqkz\",\n       \"packt\":      \"RE4zfHB35VPtTkbT\",\n       \"mlabouardy\": \"L3nSFRcZzNQ67bcc\",\n   }\n   ctx := context.Background()\n   client, err := mongo.Connect(ctx, \n       options.Client().ApplyURI(os.Getenv(\"MONGO_URI\")))\n   if err = client.Ping(context.TODO(), \n          readpref.Primary()); err != nil {\n       log.Fatal(err)\n   }\n   collection := client.Database(os.Getenv(\n       \"MONGO_DATABASE\")).Collection(\"users\")\n   h := sha256.New()\n   for username, password := range users {\n       collection.InsertOne(ctx, bson.M{\n           \"username\": username,\n           \"password\": string(h.Sum([]byte(password))),\n       })\n   }\n}\n```", "```go\n    go get github.com/gin-contrib/sessions\n    ```", "```go\n    store, _ := redisStore.NewStore(10, \"tcp\", \n          \"localhost:6379\", \"\", []byte(\"secret\"))\n    router.Use(sessions.Sessions(\"recipes_api\", store))\n    ```", "```go\n    func (handler *AuthHandler) SignInHandler(c *gin.Context) {\n       var user models.User\n       if err := c.ShouldBindJSON(&user); err != nil {\n           c.JSON(http.StatusBadRequest, gin.H{\"error\": \n               err.Error()})\n           return\n       }\n       h := sha256.New()\n       cur := handler.collection.FindOne(handler.ctx, bson.M{\n           \"username\": user.Username,\n           \"password\": string(h.Sum([]byte(user.Password))),\n       })\n       if cur.Err() != nil {\n           c.JSON(http.StatusUnauthorized, gin.H{\"error\": \n               \"Invalid username or password\"})\n           return\n       }\n       sessionToken := xid.New().String()\n       session := sessions.Default(c)\n       session.Set(\"username\", user.Username)\n       session.Set(\"token\", sessionToken)\n       session.Save()\n       c.JSON(http.StatusOK, gin.H{\"message\":                                \"User signed in\"})\n    }\n    ```", "```go\n    func (handler *AuthHandler) AuthMiddleware() gin.\t  \t      HandlerFunc {\n       return func(c *gin.Context) {\n           session := sessions.Default(c)\n           sessionToken := session.Get(\"token\")\n           if sessionToken == nil {\n               c.JSON(http.StatusForbidden, gin.H{\n                   \"message\": \"Not logged\",\n               })\n               c.Abort()\n           }\n           c.Next()\n       }\n    }\n    ```", "```go\n    curl -c cookies.txt -X POST http://localhost:8080/signin -d '{\"username\":\"admin\", \"password\":\"fCRmh4Q2J7Rseqkz\"}'\n    ```", "```go\n    curl -b cookies.txt -X POST http://localhost:8080/recipes -d '{\"name\":\"Homemade Pizza\", \"steps\":[], \"instructions\":[]}'\n    ```", "```go\n    func (handler *AuthHandler) SignOutHandler(c       *gin.Context) {\n       session := sessions.Default(c)\n       session.Clear()\n       session.Save()\n       c.JSON(http.StatusOK, gin.H{\"message\":                                \"Signed out...\"})\n    }\n    ```", "```go\n    router.POST(\"/signout\", authHandler.SignOutHandler)\n    ```", "```go\ngit add .\ngit commit -m \"session based authentication\"\ngit checkout -b feature/session\ngit push origin feature/session\n```", "```go\n    go get -v gopkg.in/square/go-jose.v2\n    go get -v github.com/auth0-community/go-auth0\n    ```", "```go\n    func (handler *AuthHandler) AuthMiddleware() gin.HandlerFunc {\n       return func(c *gin.Context) {\n           var auth0Domain = \"https://\" + os.Getenv(\n               \"AUTH0_DOMAIN\") + \"/\"\n           client := auth0.NewJWKClient(auth0.JWKClientOptions{\n               URI: auth0Domain + \".well-known/jwks.json\"}, \n               nil)\n           configuration := auth0.NewConfiguration(client, \n               []string{os.Getenv(\"AUTH0_API_IDENTIFIER\")}, \n               auth0Domain, jose.RS256)\n           validator := auth0.NewValidator(configuration, \t                                       nil)\n           _, err := validator.ValidateRequest(c.Request)\n           if err != nil {\n               c.JSON(http.StatusUnauthorized,  \t \t          \t                  gin.H{\"message\": \"Invalid token\"})\n               c.Abort()\n               return\n           }\n           c.Next()\n       }\n    }\n    ```", "```go\n    AUTH0_DOMAIN=DOMAIN.eu.auth0.com  AUTH0_API_IDENTIFIER=\"https://api.recipes.io\" MONGO_URI=\"mongodb://admin:password@localhost:27017/test?authSource=admin\" MONGO_DATABASE=demo go run *.go\n    ```", "```go\n    curl --request POST \\\n      --url https://recipesapi-packt.eu.auth0.com/oauth/token \\\n      --data '{\"client_id\":\"MyFRmUZS\",\"client_secret\":\"7fArWGkSva\",\"audience\":\"https://api.recipes.io\",\"grant_type\":\"client_credentials\"}'\n    ```", "```go\n    {\n     \"access_token\":\"eyJhbGciOiJSUzI1NiIsInR5cCI 6IkpXVCIsImtpZCI6IkZ5T19SN2dScDdPakp3RmJQRVB3dCDz\",\n       \"expires_in\":86400,\n       \"token_type\":\"Bearer\"\n    }\n    ```", "```go\n    curl --request POST \\\n      --url http://localhost:8080/recipes \\\n      --header 'Authorization: Bearer ACCESS_TOKEN'\\\n      --data '{\"name\":\"Pizza \"}'\n    ```", "```go\n    unzip ngrok-stable-darwin-amd64.zip\n    cp ngrok /usr/local/bin/\n    chmod +x /usr/local/bin/ngrok\n    ```", "```go\n    ngrok version\n    ```", "```go\n    ngrok http 8080\n    ```", "```go\n    mkdir certs\n    openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout certs/localhost.key -out certs/localhost.crt\n    ```", "```go\n    router.RunTLS(\":443\", \"certs/localhost.crt\", \"certs/localhost.key\")\n    ```", "```go\n    curl --cacert certs/localhost.crt https://localhost/recipes\n    ```", "```go\n    curl -k https://localhost/recipes\n    ```", "```go\n     127.0.0.1 api.recipes.io\n    ```", "```go\n    // Recipes API\n    //\n    // This is a sample recipes API. You can find out more \n       about the API at \n       https://github.com/PacktPublishing/Building-\n       Distributed-Applications-in-Gin.\n    //\n    //  Schemes: http\n    //  Host: api.recipes.io:8080\n    //  BasePath: /\n    //  Version: 1.0.0\n    //  Contact: Mohamed Labouardy \n    //  <mohamed@labouardy.com> https://labouardy.com\n    //  SecurityDefinitions:\n    //  api_key:\n    //    type: apiKey\n    //    name: Authorization\n    //    in: header\n    //\n    //  Consumes:\n    //  - application/json\n    //\n    //  Produces:\n    //  - application/json\n    // swagger:meta\n    package main\n    ```", "```go\n    // swagger:operation POST /signin auth signIn\n    // Login with username and password\n    // ---\n    // produces:\n    // - application/json\n    // responses:\n    //     '200':\n    //         description: Successful operation\n    //     '401':\n    //         description: Invalid credentials\n    func (handler *AuthHandler) SignInHandler(c *gin.Context) {}\n    ```", "```go\n    // swagger:operation POST /refresh auth refresh\n    // Get new token in exchange for an old one\n    // ---\n    // produces:\n    // - application/json\n    // responses:\n    //     '200':\n    //         description: Successful operation\n    //     '400':\n    //         description: Token is new and doesn't need \n    //                      a refresh\n    //     '401':\n    //         description: Invalid credentials\n    func (handler *AuthHandler) RefreshHandler(c *gin.Context) \n    {}\n    ```", "```go\n    // API user credentials\n    // It is used to sign in\n    //\n    // swagger:model user\n    type User struct {\n      // User's password\n      //\n      // required: true\n      Password string `json:\"password\"`\n      // User's login\n      //\n      // required: true\n      Username string `json:\"username\"`\n    }\n    ```", "```go\n    /refresh and /signin) should be added to the list of operations, as shown in the following screenshot:![Figure 4.39 – Authentication operations\n    ](img/Figure_4.39_B17115.jpg)Figure 4.39 – Authentication operations\n    ```"]