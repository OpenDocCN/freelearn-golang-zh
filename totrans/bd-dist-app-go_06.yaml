- en: 'Chapter 4: Building API Authentication'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to the best practices and recommendations to follow
    while building a public **REpresentational State Transfer** (**REST**) **application
    programming interface** (**API**). It explores how to write an authentication
    middleware to secure the access to the API endpoints and how to serve them through
    **HyperText Transfer Protocol Secure** (**HTTPS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing **JavaScript Object Notation** (**JSON**) **Web Tokens** (**JWTs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting client sessions and cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating with Auth0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an HTTPS server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to build a RESTful API with both
    private and public endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A complete understanding of the previous chapter—this chapter is a follow-up
    of the previous one and it will use the same source code. Hence, some snippets
    won't be explained, to avoid repetition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic understanding of API authentication concepts and the HTTPS protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter04](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, the API we built exposed multiple endpoints. For now,
    those endpoints are public and don't require any authentication. In a real-world
    scenario, you would need to secure those endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the endpoints to be secured by the end of
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Securing RESTful API endpoints'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Securing RESTful API endpoints
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing** recipes will require no authentication, while the endpoints responsible
    for **adding**, **updating**, or **deleting** a recipe will require authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple methods can be used to secure the preceding endpoints—here are a few
    of the methods we could use: API keys, Basic Auth, client sessions, OpenID Connect,
    **Open Authorization** (**OAuth**) 2.0, and so on. The most basic authentication
    mechanism is the usage of API keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Using API keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this method, the client provides a secret, called an `X-API-KEY` header
    in the HTTP request; if the key is wrong or not found in the request header, then
    an unauthorized error (`401`) is thrown, as illustrated in the following code
    snippet (the full code has been cropped for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application after running the MongoDB and Redis containers, but this
    time set the `X-API-KEY` environment variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use OpenSSL to generate a random secret string with the following command:
    `openssl rand` `-base64 16`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to add a new recipe, a `401` error message will be returned, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – New recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – New recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you include a valid `X-API-KEY` header in the `POST` request, the
    recipe will be inserted, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – X-API-KEY header in POST request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.3_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – X-API-KEY header in POST request
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re not a fan of Postman as an HTTP/s client, you can execute the following
    cURL command on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, only the `POST /recipes` request is secured. To avoid repeating the
    same code snippet in other HTTP endpoints, create an authentication middleware
    by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the router definition, use the authentication middleware. Lastly, regroup
    the endpoints in a single group, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, rerun the application. If you issue a `GET /recipes` request,
    a `401` error will be returned, as illustrated in the following screenshot. This
    is normal because the route handler for list recipes is behind the authentication
    middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – API key required on GET /recipes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – API key required on GET /recipes
  prefs: []
  type: TYPE_NORMAL
- en: 'You want the `GET /recipes` request to be public, therefore register the endpoint
    outside of the group router, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you test it out, this time the endpoint will return a list of recipes, as
    illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – List of recipes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – List of recipes
  prefs: []
  type: TYPE_NORMAL
- en: API keys are simple; however, anyone who makes a request to an API transmits
    their key, and in theory, the key can be picked up easily with a **man-in-the-middle**
    (**MITM**) attack when no encryption is in use. That's why, in the next section,
    we will cover a more secure authentication mechanism known as JWTs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'MITM refers to a situation where an attacker positions themself in a conversation
    between two parties in order to steal their credentials. For more details, check
    out the following link: [https://snyk.io/learn/man-in-the-middle-attack/](https://snyk.io/learn/man-in-the-middle-attack/).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing JWTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to **Request for Comments** (**RFC**) *7519* ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A JSON Web Token (JWT) is an open standard that defines a compact and self-contained
    way for securely transmitting information between parties as a JSON object. This
    information can be verified and trusted because it is digitally signed. JWTs can
    be signed using a secret or a public/private key pair."*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A JWT token consists of three parts separated by dots, as depicted in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – JWT parts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.6_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – JWT parts
  prefs: []
  type: TYPE_NORMAL
- en: The **header** indicates the algorithm used to generate the signature. The **payload**
    contains information about the user, along with the token expiration date. Finally,
    the **signature** is the result of hashing the header and payload parts with a
    secret key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen how JWT works, let''s integrate it into our API. To get
    started, install the JWT Go implementation with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The package will be automatically added to the `go.mod` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Before getting your hands dirty, let me explain how the JWT authentication will
    be implemented. Basically, the client will need to sign in using a username and
    password. If those credentials are valid, a JWT token will be generated and returned.
    The client will use the token in future requests by including an `Authorization`
    header. If a request is issued to the API, the token will be verified by comparing
    its signature against a signature generated with the secret key, and the API will
    return the target response. Otherwise, a `401` error will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequence diagram illustrates the communication between the client
    and the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Sequence diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.7_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Sequence diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'With that being said, create an `auth.go` file under the `handlers` folder.
    This file will expose the functions that will handle the authentication workflow.
    Here is the code to do this (the full code has been cropped for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to define an entity model for user credentials. In the `models`
    folder, create a `user.go` struct with username and password attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the model being defined, we can go ahead and implement the authentication
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Sign-in HTTP handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SignInHandler` will encode the request body into a `User` struct and verify
    the credentials are correct. Then, it will issue a JWT token with an expiration
    time of 10 minutes. The signature of the JWT is the output of combining the Base64
    representation of the header and payload along with a secret key (notice the usage
    of the `JWT_SECRET` environment variable). The combination is then passed to an
    `HS256` hashing algorithm. It''s worth mentioning that you must keep your credentials
    out of the source code as a security measure. The implementation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on how the hashing algorithm works, check out the official
    RFC: [https://tools.ietf.org/html/rfc7518](https://tools.ietf.org/html/rfc7518).'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `SignInHandler` handler created, let''s register this handler on the
    `POST /signin` endpoint by updating the `main.go` file, as follows (the code has
    been cropped for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we update the authentication middleware in `handler/auth.go` to check
    for the `Authorization` header instead of the `X-API-KEY` attribute. The header
    is then passed to the `ParseWithClaims` method. It generates a signature using
    the header and payload from the `Authorization` header and the secret key. Then,
    it verifies if the signature matches the one on the JWT. If not, the JWT is not
    considered valid, and a `401` status code is returned. The Go implementation is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The server logs are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Application logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.8_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Application logs
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you try to insert a new recipe, a `401` error will be returned, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Unauthorized endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.9_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Unauthorized endpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to sign in first using the `admin/password` credentials by executing
    a `POST` request on the `/signin` endpoint. Once successful, the endpoint will
    return a token that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Sign-in endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.10_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – Sign-in endpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'The token consists of three parts separated by a dot. You can decode the token
    by going to [https://jwt.io/](https://jwt.io/) to return the following output
    (your results might look different):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Decoding a JWT token'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.11_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Decoding a JWT token
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The header and payload parts are Base64-encoded, but you can use the `base64`
    command to decode their value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for further requests, you need to include the token in the `Authorization`
    header to be able to access secured endpoints such as posting a new recipe, as
    illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Posting a new recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.12_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – Posting a new recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, everything is going well—however, in 10 minutes, the token will expire.
    If, for instance, you try to post a new recipe, a `401` unauthorized message will
    be thrown even though you have included the `Authorization` header, as we can
    see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Expired JWT'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.13_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Expired JWT
  prefs: []
  type: TYPE_NORMAL
- en: So, let's check out how you can renew this token after it expires.
  prefs: []
  type: TYPE_NORMAL
- en: Renewing a JWT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can increase the expiration time to make a JWT token last; however, this
    is not a permanent solution. What you can do instead is to expose an endpoint
    to allow the user to refresh a token, which will let the client application refresh
    the token without asking the user for the username and password again. The function
    handler is shown in the following code snippet—it takes the previous token and
    returns a new token with a renewed expiry time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In a web application, the `/refresh` endpoint can be used to refresh the JWT
    token in the background without asking the user to sign in every couple of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Register the `RefreshHandler` handler on the `POST /refresh` endpoint with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you rerun the app, the `/refresh` endpoint will be exposed, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – /refresh endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.14_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – /refresh endpoint
  prefs: []
  type: TYPE_NORMAL
- en: You can now issue a `POST` request on the `/refresh` endpoint, and a new token
    will be generated and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome—you now have a working authentication workflow! However, the user credentials
    are still hardcoded in the application code source. You can improve this by storing
    them in your **MongoDB** server. An updated sequence diagram is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Storing credentials in MongoDB'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.15_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – Storing credentials in MongoDB
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to interact with the MongoDB server, you need to add the MongoDB
    collection to the `AuthHandler` struct in the `auth.go` file, as illustrated in
    the following code snippet. Then, you can issue a `FindOne` operation on the `users`
    collection to verify if the given credentials exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update the `SignInHandler` method to verify if the user credentials are
    valid by comparing them with entries in the database. Here is how it should be
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `init()` method, you need to set up a connection to the `users` collection
    then pass the collection instance to the `AuthHandler` instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to save the `main.go` changes, and the API is then ready!
  prefs: []
  type: TYPE_NORMAL
- en: Hashing and salting passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before running the app, we need to initialize the *users* collection with some
    users. Create a new project in `main.go` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will insert three users (`admin`, `packt`, `mlabouardy`)
    into the `users`collection. The passwords are **hashed** and **salted** before
    they are saved into MongoDB using the *SHA256* algorithm for security purposes.
    The algorithm generates a unique 256-bit signature for the password that can be
    decrypted back to the original password. That way, sensitive information can remain
    secure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Storing plaintext passwords in the database is not recommended. By hashing and
    salting users' passwords, we make sure that hackers are not able to sign in, as
    the stolen data won't contain the credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the code with the `MONGO_URI="mongodb://admin:password@localhost:27017/test?authSource=admin"
    MONGO_DATABASE=demo go run main.go` command. Check if the users have been inserted
    using MongoDB Compass (for a step-by-step guide on how to use MongoDB Compass,
    head back to [*Chapter 3*](B17115_03_Final_JM_ePub.xhtml#_idTextAnchor054)*, Managing
    Data Persistence with MongoDB*), as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Users collection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.16_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – Users collection
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might notice, the passwords are hashed and salted. With the users being
    inserted into MongoDB, we can test out the sign-in endpoint by issuing a `POST`
    request with the following payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Sign-in endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.17_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – Sign-in endpoint
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can improve the JWT implementation by setting a cookie on the client side
    with the JWT value. That way, the cookie is sent along with the request.
  prefs: []
  type: TYPE_NORMAL
- en: You can take this further and create a sign-up endpoint to create a new user
    and save it to the MongoDB database. You should now be familiar with how to implement
    an authentication mechanism with JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting client sessions and cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, you had to include the `Authorization` header on each request. A
    better solution is to generate a **session cookie**. Session cookies allow users
    to be recognized within an application without having to authenticate every time.
    Without a cookie, every time you issue an API request, the server will treat you
    like a completely new visitor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a session cookie, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install *Gin middleware* for session management with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure *Redis* as a store for users'' sessions with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Instead of hardcoding the Redis **Uniform Resource Identifier** (**URI**), you
    can use an environment variable. That way, you can keep configuration out of the
    API source code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, update `SignInHandler` to generate a session with a unique ID, as illustrated
    in the following code snippet. The session starts once a user logs in and expires
    sometime after that. The session information of the logged-in user will be stored
    in the Redis cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update `AuthMiddleware` to obtain the token from the request cookie.
    If the cookie is not set, we return a `403` code (`Forbidden`) by returning an
    `http.StatusForbidden` response, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the server on port 8080, and issue a `POST` request on the `/signin`
    endpoint with a valid username and password. A cookie should be generated, like
    the one shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Session cookie'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.18_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18 – Session cookie
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the session will be persisted across all other API routes. Therefore, you
    can interact with API endpoints without including any authorization header, as
    illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Session-based authentication'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.19_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19 – Session-based authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example uses the Postman client, but if you''re a `cURL` fan,
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to store the generated cookie in a text file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, inject the `cookies.txt` file in future requests, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can implement a refresh route to generate a new session cookie with a renewed
    expiry time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All the sessions generated by the API will be persisted in Redis. You can use
    the Redis Insight **user interface** (**UI**) (hosted on a Docker container) to
    browse the saved session, as illustrated in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.20 – List of sessions stored in Redis'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.20_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.20 – List of sessions stored in Redis
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To log out, you can implement the `SignOutHandler` handler to clear the session
    cookie with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember to register the handler on the `main.go` file, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application, and a sign-out endpoint should be exposed, as illustrated
    in the following screenshot:![Figure 4.21 – Sign-out handler
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.21_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.21 – Sign-out handler
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, test it out with the Postman client by executing a `POST` request, like
    so:![Figure 4.22 – Signing out
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.22_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.22 – Signing out
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The session cookie will be deleted, and if you now try to add a new recipe,
    a `403` error will be returned, as illustrated in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Adding a new recipe'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.23_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.23 – Adding a new recipe
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make sure to commit the changes to GitHub by creating a new feature branch.
    Then, merge the branch into development mode, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the pull requests containing the JWT and cookie
    authentication features:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – Pull requests on GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.24_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.24 – Pull requests on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! The API endpoints are now secured and can be served to the public.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with Auth0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the authentication mechanism is built in within the application. Maintaining
    such a system might be a bottleneck in the long run, which is why you might need
    to consider an external service such as **Auth0**. This is an all-in-one authentication
    solution that gives you access to powerful reporting and analytics as well as
    a **role-based access control** (**RBAC**) system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a free account ([https://auth0.com/signup](https://auth0.com/signup)).
    Once created, set up a tenant domain in the region where you're located, as illustrated
    in the following screenshot:![Figure 4.25 – Auth0 tenant domain
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.25_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.25 – Auth0 tenant domain
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, create a new API called `Recipes API`. Set the identifier to [https://api.recipes](https://api.recipes)`.io`
    and the signing algorithm to `RS256`, as illustrated in the following screenshot:![Figure
    4.26 – Auth0 new API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.26_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.26 – Auth0 new API
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the API is created, you need to integrate the Auth0 service into the API.
    Download the following Go packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update `AuthMiddleware`, as illustrated in the following code snippet.
    The middleware will check if an access token exists and if this is valid. If it
    passes the checks, the request will proceed. If not, a `401 Authorization` error
    is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Auth0 uses RS256 algorithm-signing access tokens. The verification process uses
    a public key (located at `AUTH0_DOMAIN/.well-known/jwks.json`) in **JSON Web Key
    Set** (**JWKS**) format to verify the given token.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the application with `AUTH0_DOMAIN` and `AUTH0_API_IDENTIFIER`, as illustrated
    in the following code snippet. Make sure to replace those variables with the values
    you copied from your Auth0 dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you try to issue a request to your API without sending an access token,
    you will see this message:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.27 – Unauthorized access'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.27_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.27 – Unauthorized access
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To generate an access token. Head back to the **Auth0** dashboard, click on
    **APIs**, then select **Recipes API**. From there, click on the **Test** tab and
    copy the cURL command shown in the following screenshot:![Figure 4.28 – Generating  access
    token with cURL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.28_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.28 – Generating access token with cURL
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the following command on your terminal session to generate an access
    token that you can use to communicate with your backend API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An access token will be generated, as follows (you should have a different
    value):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, update your API request to include the access token, as shown in the following
    screenshot:![Figure 4.29 – Authorized access
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.29_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.29 – Authorized access
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This can also be tested straight from the command line with cURL. Just replace
    the `ACCESS_TOKEN` value shown in the following code snippet with your test token
    and then paste it into your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Awesome! You just developed a secure API with Go and the Gin framework.
  prefs: []
  type: TYPE_NORMAL
- en: Building an HTTPS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the API is served locally through HTTP, but for a real-world application,
    it should be served under a domain name through HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set this up, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `ngrok` solution to serve our local web API with a public **Uniform
    Resource Locator** (**URL**) that supports both HTTP and HTTPS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In advanced chapters, we will explore how to purchase a domain name and set
    up HTTPS for free on a cloud provider such as **Amazon Web Services** (**AWS**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Download the ZIP file based on your **operating system** (**OS**) from the
    official Ngrok page at [https://ngrok.com/download](https://ngrok.com/download).
    In this book, we will work with version 2.3.35\. Once downloaded, unzip Ngrok
    from a terminal with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify if it''s properly installed by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It should output the following message:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.30 – Ngrok version'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.30_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.30 – Ngrok version
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Configure Ngrok to listen and forward requests into port 8080, which is the
    port where the RESTful API is exposed, by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A public URL will be generated that can be used as a proxy to interact with
    the API from the internet, as illustrated here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.31 – Ngrok forwarding'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.31_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.31 – Ngrok forwarding
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate to the forwarding URL using the HTTPS protocol. A **Connection is
    secure** message should be displayed next to the URL, as illustrated in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.32 – Serving through HTTPS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.32_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.32 – Serving through HTTPS
  prefs: []
  type: TYPE_NORMAL
- en: You can now access the API from another machine or device or share it with others.
    In the next section, we will cover how to create your own **Secure Sockets Layer**
    (**SSL**) certificates to secure a domain name running locally.
  prefs: []
  type: TYPE_NORMAL
- en: Self-signed certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSL certificates are what websites use to move from HTTP and HTTPS. The certificate
    uses SSL/**Transport Layer Security** (**TLS**) encryption to keep user data secure,
    verify ownership of the website, prevent attackers from creating a fake version
    of the site, and gain user trust.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create self-signed certificates, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory where the certificates will be stored and use the OpenSSL
    command line to generate public and private keys, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You'll need to fill a simple questionnaire—make sure to set the fully qualified
    hostname to `localhost`, as shown here:![Figure 4.33 – Generating self-signed
    certificates
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.33_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.33 – Generating self-signed certificates
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In doing so, two files will be generated, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`localhost.crt`: Self-signed certificate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`localhost.key`: Private key'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In advanced chapters, we will cover how to retrieve a valid certificate for
    production with Let's Encrypt ([https://letsencrypt.org](https://letsencrypt.org))
    for free.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `main.go` to run the server on HTTPS by utilizing the self-signed certificates,
    as follows (note that we use port 443 now, which is the default HTTPS port):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application, and the logs will confirm the API is served through HTTPS,
    as illustrated here:![Figure 4.34 – Listening and serving HTTPS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.34_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.34 – Listening and serving HTTPS
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Head to your browser, and then navigate to [https://localhost/recipes](https://localhost/recipes).
    A secure-website icon will be shown on the left side of the URL bar, as illustrated
    in the following screenshot:![Figure 4.35 – Encrypted connection to localhost
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.35_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, you can use a `–k` flag to skip the SSL verification, as follows (not recommended
    if interacting with external websites):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For development, simply keep using the localhost, or access the API from a
    custom domain. You can create an alias with a domain name locally by adding the
    following entry to your `/etc/hosts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the changes are saved, you can test it out by executing a `ping` command
    on `api.recipes.io`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.37 – ping output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.37_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.37 – ping output
  prefs: []
  type: TYPE_NORMAL
- en: 'The domain name is reachable and points to `127.0.0.1`. You can now access
    the RESTful API by navigating to [https://api.recipes.io:8080](https://api.recipes.io:8080),
    as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.38 – Alias domain name'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.38_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.38 – Alias domain name
  prefs: []
  type: TYPE_NORMAL
- en: Great! You will now be able to secure your API endpoints with authentication
    and serve your API through a custom domain name locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we wrap up this chapter, you need to update the API documentation to
    include the authentication endpoints we implemented throughout the chapter, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update the general metadata to include an `Authorization` header in
    the API requests, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, write a `swagger:operation` annotation on top of the `SignInHandler`
    handler, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a `swagger:operation` annotation on top of the `RefreshHandler` handler,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The operation expects a request body with the following attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate the OpenAPI specification, then serve the JSON file with the Swagger
    UI by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, click on the `signin` endpoint, and you will be able to fill the username
    and password attributes directly from the Swagger UI, as illustrated in the following
    screenshot:![Figure 4.40 – Sign-in credentials
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.40_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.40 – Sign-in credentials
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, click on `Authorization` header to interact with endpoints that require
    authorization, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.41 – Authorization header'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.41_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.41 – Authorization header
  prefs: []
  type: TYPE_NORMAL
- en: You now are able to build a secure Gin RESTful API and serve it through the
    HTTPS protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned a few of the best practices and recommendations
    for building a secure RESTful API based on the Gin web framework. You also covered
    how to implement JWT in Golang and how to persist session cookies across API requests.
  prefs: []
  type: TYPE_NORMAL
- en: You have also explored how a third-party solution such as Auth0 can be used
    as an authentication provider and how it can be integrated with Golang to secure
    API endpoints. Finally, you learned how to serve an API through the HTTPS protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build a user-friendly UI (also known as a frontend)
    on top of the RESTful API with the React web framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How would you implement a sign-up endpoint to create a new user account?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you implement a profile endpoint to return a user profile?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you generate a Swagger specification for a sign-out endpoint?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*OAuth 2.0 Cookbook* by Adolfo Eloy Nascimento, Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SSL Complete Guide -* HTTP to HTTPS by Bogdan Stashchuk, Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
