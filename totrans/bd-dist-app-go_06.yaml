- en: 'Chapter 4: Building API Authentication'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：构建API身份验证
- en: This chapter is dedicated to the best practices and recommendations to follow
    while building a public **REpresentational State Transfer** (**REST**) **application
    programming interface** (**API**). It explores how to write an authentication
    middleware to secure the access to the API endpoints and how to serve them through
    **HyperText Transfer Protocol Secure** (**HTTPS**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于介绍在构建公共**表示状态转移**（**REST**）**应用程序编程接口**（**API**）时需要遵循的最佳实践和建议。它探讨了如何编写一个身份验证中间件来保护API端点的访问，以及如何通过**超文本传输协议安全**（**HTTPS**）来提供服务。
- en: 'In this chapter, we will focus on the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将重点关注以下主要主题：
- en: Exploring authentication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索身份验证
- en: Introducing **JavaScript Object Notation** (**JSON**) **Web Tokens** (**JWTs**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍**JavaScript对象表示法**（**JSON**）**Web令牌**（**JWT**）
- en: Persisting client sessions and cookies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化客户端会话和cookie
- en: Authenticating with Auth0
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Auth0进行认证
- en: Building an HTTPS server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建HTTPS服务器
- en: By the end of this chapter, you will be able to build a RESTful API with both
    private and public endpoints.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够构建一个具有私有和公开端点的RESTful API。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，你需要以下内容：
- en: A complete understanding of the previous chapter—this chapter is a follow-up
    of the previous one and it will use the same source code. Hence, some snippets
    won't be explained, to avoid repetition.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全理解上一章的内容——本章是上一章的后续，它将使用相同的源代码。因此，一些代码片段将不会进行解释，以避免重复。
- en: A basic understanding of API authentication concepts and the HTTPS protocol.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对API认证概念和HTTPS协议有基本了解。
- en: The code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter04](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter04).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包托管在GitHub上，网址为[https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter04](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter04)。
- en: Exploring authentication
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索身份验证
- en: In the previous chapter, the API we built exposed multiple endpoints. For now,
    those endpoints are public and don't require any authentication. In a real-world
    scenario, you would need to secure those endpoints.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建的API公开了多个端点。目前，这些端点是公开的，不需要任何认证。在现实世界的场景中，你需要保护这些端点。
- en: 'The following diagram illustrates the endpoints to be secured by the end of
    this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了本章结束时需要保护的所有端点：
- en: '![Figure 4.1 – Securing RESTful API endpoints'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – 保护RESTful API端点'
- en: '](img/Figure_4.1_B17115.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_B17115.jpg)'
- en: Figure 4.1 – Securing RESTful API endpoints
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 保护RESTful API端点
- en: '**Listing** recipes will require no authentication, while the endpoints responsible
    for **adding**, **updating**, or **deleting** a recipe will require authentication.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**列出**菜谱不需要认证，而负责**添加**、**更新**或**删除**菜谱的端点则需要认证。'
- en: 'Multiple methods can be used to secure the preceding endpoints—here are a few
    of the methods we could use: API keys, Basic Auth, client sessions, OpenID Connect,
    **Open Authorization** (**OAuth**) 2.0, and so on. The most basic authentication
    mechanism is the usage of API keys.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用多种方法来保护前面的端点——以下是我们可能使用的一些方法：API密钥、基本认证、客户端会话、OpenID Connect、**开放授权**（**OAuth**）2.0等。最基本的认证机制是使用API密钥。
- en: Using API keys
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用API密钥
- en: 'In this method, the client provides a secret, called an `X-API-KEY` header
    in the HTTP request; if the key is wrong or not found in the request header, then
    an unauthorized error (`401`) is thrown, as illustrated in the following code
    snippet (the full code has been cropped for brevity):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，客户端提供一个秘密，称为HTTP请求中的`X-API-KEY`头；如果密钥错误或请求头中没有找到密钥，则会抛出一个未经授权的错误（`401`），如下面的代码片段所示（为了简洁，完整的代码已被裁剪）：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the application after running the MongoDB and Redis containers, but this
    time set the `X-API-KEY` environment variable as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行MongoDB和Redis容器之后运行应用程序，但这次需要设置以下`X-API-KEY`环境变量：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can use OpenSSL to generate a random secret string with the following command:
    `openssl rand` `-base64 16`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令使用OpenSSL生成一个随机的秘密字符串：`openssl rand` `-base64 16`。
- en: 'If you try to add a new recipe, a `401` error message will be returned, as
    shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加一个新的菜谱，将会返回一个`401`错误消息，如下面的屏幕截图所示：
- en: '![Figure 4.2 – New recipe'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 新菜谱'
- en: '](img/Figure_4.2_B17115.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.2](img/Figure_4.2_B17115.jpg)'
- en: Figure 4.2 – New recipe
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 新食谱
- en: 'However, if you include a valid `X-API-KEY` header in the `POST` request, the
    recipe will be inserted, as shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果在 `POST` 请求中包含有效的 `X-API-KEY` 头部，食谱将被插入，如下面的截图所示：
- en: '![Figure 4.3 – X-API-KEY header in POST request'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – POST 请求中的 X-API-KEY 头部'
- en: '](img/Figure_4.3_B17115.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.3](img/Figure_4.3_B17115.jpg)'
- en: Figure 4.3 – X-API-KEY header in POST request
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – POST 请求中的 X-API-KEY 头部
- en: 'If you''re not a fan of Postman as an HTTP/s client, you can execute the following
    cURL command on your terminal:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢 Postman 作为 HTTP/s 客户端，你可以在你的终端上执行以下 cURL 命令：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For now, only the `POST /recipes` request is secured. To avoid repeating the
    same code snippet in other HTTP endpoints, create an authentication middleware
    by writing the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只有 `POST /recipes` 请求是受保护的。为了避免在其他 HTTP 端点中重复相同的代码片段，通过编写以下代码创建一个身份验证中间件：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the router definition, use the authentication middleware. Lastly, regroup
    the endpoints in a single group, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由定义中，使用身份验证中间件。最后，将端点重新组合成一个组，如下所示：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this stage, rerun the application. If you issue a `GET /recipes` request,
    a `401` error will be returned, as illustrated in the following screenshot. This
    is normal because the route handler for list recipes is behind the authentication
    middleware:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，重新运行应用程序。如果你发出 `GET /recipes` 请求，将返回 `401` 错误，如下面的截图所示。这是正常的，因为列表食谱的路由处理程序位于身份验证中间件之后：
- en: '![Figure 4.4 – API key required on GET /recipes'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – GET /recipes 需要API密钥'
- en: '](img/Figure_4.4_B17115.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.4](img/Figure_4.4_B17115.jpg)'
- en: Figure 4.4 – API key required on GET /recipes
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – GET /recipes 需要API密钥
- en: 'You want the `GET /recipes` request to be public, therefore register the endpoint
    outside of the group router, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望 `GET /recipes` 请求是公开的，因此将端点注册在组路由之外，如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you test it out, this time the endpoint will return a list of recipes, as
    illustrated in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你测试它，这次端点将返回食谱列表，如下面的截图所示：
- en: '![Figure 4.5 – List of recipes'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 菜单列表'
- en: '](img/Figure_4.5_B17115.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.5](img/Figure_4.5_B17115.jpg)'
- en: Figure 4.5 – List of recipes
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 菜单列表
- en: API keys are simple; however, anyone who makes a request to an API transmits
    their key, and in theory, the key can be picked up easily with a **man-in-the-middle**
    (**MITM**) attack when no encryption is in use. That's why, in the next section,
    we will cover a more secure authentication mechanism known as JWTs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: API 密钥很简单；然而，任何向 API 发送请求的人都会传输他们的密钥，在理论上，当不使用加密时，密钥很容易通过中间人攻击（**MITM**）被捕获。这就是为什么在下一节中，我们将介绍一种称为
    JWT 的更安全的身份验证机制。
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: 'MITM refers to a situation where an attacker positions themself in a conversation
    between two parties in order to steal their credentials. For more details, check
    out the following link: [https://snyk.io/learn/man-in-the-middle-attack/](https://snyk.io/learn/man-in-the-middle-attack/).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: MITM 指的是攻击者在两个当事人之间的对话中定位自己，以窃取他们的凭证的情况。更多详情，请查看以下链接：[https://snyk.io/learn/man-in-the-middle-attack/](https://snyk.io/learn/man-in-the-middle-attack/).
- en: Introducing JWTs
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 JWT
- en: 'According to **Request for Comments** (**RFC**) *7519* ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '根据 **请求评论** (**RFC**) *7519* ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)):'
- en: '*"A JSON Web Token (JWT) is an open standard that defines a compact and self-contained
    way for securely transmitting information between parties as a JSON object. This
    information can be verified and trusted because it is digitally signed. JWTs can
    be signed using a secret or a public/private key pair."*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*"JSON Web Token (JWT) 是一个开放标准，它定义了一种紧凑且自包含的方式，用于以 JSON 对象的形式在各方之间安全地传输信息。由于它是数字签名的，因此该信息可以验证并受到信任。JWT
    可以使用密钥或公钥/私钥对进行签名。"*'
- en: 'A JWT token consists of three parts separated by dots, as depicted in the following
    screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 令牌由三个部分组成，由点分隔，如下面的截图所示：
- en: '![Figure 4.6 – JWT parts'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – JWT 的组成部分'
- en: '](img/Figure_4.6_B17115.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.6](img/Figure_4.6_B17115.jpg)'
- en: Figure 4.6 – JWT parts
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – JWT 的组成部分
- en: The **header** indicates the algorithm used to generate the signature. The **payload**
    contains information about the user, along with the token expiration date. Finally,
    the **signature** is the result of hashing the header and payload parts with a
    secret key.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**头部**指示用于生成签名的算法。**载荷**包含有关用户的信息，以及令牌过期日期。最后，**签名**是使用密钥对头部和载荷部分进行散列的结果。'
- en: 'Now that we''ve seen how JWT works, let''s integrate it into our API. To get
    started, install the JWT Go implementation with the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了JWT的工作原理，让我们将其集成到我们的API中。要开始，使用以下命令安装JWT Go实现：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The package will be automatically added to the `go.mod` file, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该包将自动添加到`go.mod`文件中，如下所示：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before getting your hands dirty, let me explain how the JWT authentication will
    be implemented. Basically, the client will need to sign in using a username and
    password. If those credentials are valid, a JWT token will be generated and returned.
    The client will use the token in future requests by including an `Authorization`
    header. If a request is issued to the API, the token will be verified by comparing
    its signature against a signature generated with the secret key, and the API will
    return the target response. Otherwise, a `401` error will be returned.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在动手之前，让我解释一下JWT认证将如何实现。基本上，客户端需要使用用户名和密码进行登录。如果这些凭证有效，将生成JWT令牌并返回。客户端将在未来的请求中通过包含`Authorization`头来使用该令牌。如果向API发出请求，将通过将令牌的签名与使用密钥生成的签名进行比较来验证令牌。如果签名不匹配，则JWT被视为无效，并返回`401`错误。
- en: 'The following sequence diagram illustrates the communication between the client
    and the API:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的序列图展示了客户端和API之间的通信：
- en: '![Figure 4.7 – Sequence diagram'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7 – 序列图'
- en: '](img/Figure_4.7_B17115.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.7_B17115.jpg)'
- en: Figure 4.7 – Sequence diagram
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 序列图
- en: 'With that being said, create an `auth.go` file under the `handlers` folder.
    This file will expose the functions that will handle the authentication workflow.
    Here is the code to do this (the full code has been cropped for brevity):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在`handlers`文件夹下创建一个`auth.go`文件。这个文件将暴露处理认证工作流程的函数。以下是实现此功能的代码（为了简洁，已裁剪完整代码）：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, you need to define an entity model for user credentials. In the `models`
    folder, create a `user.go` struct with username and password attributes, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要定义一个用户凭证的实体模型。在`models`文件夹中，创建一个具有用户名和密码属性的`user.go`结构体，如下所示：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the model being defined, we can go ahead and implement the authentication
    handler.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 模型定义完成后，我们可以继续实现认证处理器。
- en: Sign-in HTTP handler
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录HTTP处理器
- en: '`SignInHandler` will encode the request body into a `User` struct and verify
    the credentials are correct. Then, it will issue a JWT token with an expiration
    time of 10 minutes. The signature of the JWT is the output of combining the Base64
    representation of the header and payload along with a secret key (notice the usage
    of the `JWT_SECRET` environment variable). The combination is then passed to an
    `HS256` hashing algorithm. It''s worth mentioning that you must keep your credentials
    out of the source code as a security measure. The implementation is shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignInHandler`将请求体编码为`User`结构体，并验证凭证是否正确。然后，它将颁发一个有效期为10分钟的JWT令牌。JWT的签名是头部和有效载荷的Base64表示形式以及一个密钥的组合输出（注意`JWT_SECRET`环境变量的使用）。然后将组合传递给`HS256`哈希算法。值得一提的是，你必须为了安全起见，将凭证从源代码中移除。实现方式如下：'
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on how the hashing algorithm works, check out the official
    RFC: [https://tools.ietf.org/html/rfc7518](https://tools.ietf.org/html/rfc7518).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哈希算法的工作原理的更多信息，请查看官方RFC：[https://tools.ietf.org/html/rfc7518](https://tools.ietf.org/html/rfc7518)。
- en: 'With the `SignInHandler` handler created, let''s register this handler on the
    `POST /signin` endpoint by updating the `main.go` file, as follows (the code has
    been cropped for brevity):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`SignInHandler`处理器后，让我们通过更新`main.go`文件在`POST /signin`端点上注册此处理器，如下所示（为了简洁，已裁剪代码）：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we update the authentication middleware in `handler/auth.go` to check
    for the `Authorization` header instead of the `X-API-KEY` attribute. The header
    is then passed to the `ParseWithClaims` method. It generates a signature using
    the header and payload from the `Authorization` header and the secret key. Then,
    it verifies if the signature matches the one on the JWT. If not, the JWT is not
    considered valid, and a `401` status code is returned. The Go implementation is
    shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新`handler/auth.go`中的认证中间件，以检查`Authorization`头而不是`X-API-KEY`属性。然后将头传递给`ParseWithClaims`方法。它使用`Authorization`头部的头部和有效载荷以及密钥生成签名。然后，它验证签名是否与JWT上的签名匹配。如果不匹配，则JWT被视为无效，并返回`401`状态码。Go实现如下：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Rerun the application with the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令重新运行应用程序：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The server logs are shown in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器日志如下所示：
- en: '![Figure 4.8 – Application logs'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – 应用程序日志'
- en: '](img/Figure_4.8_B17115.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.8_B17115.jpg)'
- en: Figure 4.8 – Application logs
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 应用程序日志
- en: 'Now, if you try to insert a new recipe, a `401` error will be returned, as
    follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试插入一个新的食谱，将会返回一个 `401` 错误，如下所示：
- en: '![Figure 4.9 – Unauthorized endpoint'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – 未授权端点'
- en: '](img/Figure_4.9_B17115.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.9_B17115.jpg)'
- en: Figure 4.9 – Unauthorized endpoint
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 未授权端点
- en: 'You need to sign in first using the `admin/password` credentials by executing
    a `POST` request on the `/signin` endpoint. Once successful, the endpoint will
    return a token that looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要首先使用 `admin/password` 凭证通过在 `/signin` 端点上执行 `POST` 请求来登录。一旦成功，端点将返回一个看起来像这样的令牌：
- en: '![Figure 4.10 – Sign-in endpoint'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10 – 登录端点'
- en: '](img/Figure_4.10_B17115.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B17115.jpg)'
- en: Figure 4.10 – Sign-in endpoint
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 登录端点
- en: 'The token consists of three parts separated by a dot. You can decode the token
    by going to [https://jwt.io/](https://jwt.io/) to return the following output
    (your results might look different):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌由三个部分组成，由点分隔。你可以通过访问 [https://jwt.io/](https://jwt.io/) 来解码令牌，返回以下输出（你的结果可能不同）：
- en: '![Figure 4.11 – Decoding a JWT token'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – 解码 JWT 令牌'
- en: '](img/Figure_4.11_B17115.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.11_B17115.jpg)'
- en: Figure 4.11 – Decoding a JWT token
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 解码 JWT 令牌
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The header and payload parts are Base64-encoded, but you can use the `base64`
    command to decode their value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 头部和有效负载部分是 Base64 编码的，但你可以使用 `base64` 命令来解码它们的值。
- en: 'Now, for further requests, you need to include the token in the `Authorization`
    header to be able to access secured endpoints such as posting a new recipe, as
    illustrated in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于后续请求，你需要将令牌包含在 `Authorization` 头部中，以便能够访问受保护的端点，例如发布新食谱，如下面的截图所示：
- en: '![Figure 4.12 – Posting a new recipe'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12 – 发布新食谱'
- en: '](img/Figure_4.12_B17115.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.12_B17115.jpg)'
- en: Figure 4.12 – Posting a new recipe
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 发布新食谱
- en: 'So far, everything is going well—however, in 10 minutes, the token will expire.
    If, for instance, you try to post a new recipe, a `401` unauthorized message will
    be thrown even though you have included the `Authorization` header, as we can
    see in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利——然而，10 分钟后，令牌将过期。例如，如果你尝试发布一个新的食谱，即使你包含了 `Authorization` 头部，也会抛出一个
    `401` 未授权消息，正如我们可以在下面的截图中所看到的：
- en: '![Figure 4.13 – Expired JWT'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13 – 过期 JWT'
- en: '](img/Figure_4.13_B17115.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.13_B17115.jpg)'
- en: Figure 4.13 – Expired JWT
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 过期 JWT
- en: So, let's check out how you can renew this token after it expires.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看如何在令牌过期后如何刷新此令牌。
- en: Renewing a JWT
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷新 JWT
- en: 'You can increase the expiration time to make a JWT token last; however, this
    is not a permanent solution. What you can do instead is to expose an endpoint
    to allow the user to refresh a token, which will let the client application refresh
    the token without asking the user for the username and password again. The function
    handler is shown in the following code snippet—it takes the previous token and
    returns a new token with a renewed expiry time:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将过期时间增加，使 JWT 令牌持续更长时间；然而，这并不是一个永久的解决方案。你可以做的另一件事是暴露一个端点，允许用户刷新令牌，这样客户端应用程序就可以刷新令牌，而无需再次要求用户输入用户名和密码。函数处理程序如下代码片段所示——它接受之前的令牌并返回一个新的令牌，具有更新的过期时间：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a web application, the `/refresh` endpoint can be used to refresh the JWT
    token in the background without asking the user to sign in every couple of minutes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个网络应用程序中，`/refresh` 端点可以用来在后台刷新 JWT 令牌，而无需每几分钟要求用户登录。
- en: 'Register the `RefreshHandler` handler on the `POST /refresh` endpoint with
    the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码在 `POST /refresh` 端点上注册 `RefreshHandler` 处理程序：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you rerun the app, the `/refresh` endpoint will be exposed, as shown in
    the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新运行应用程序，`/refresh` 端点将会暴露，如下面的截图所示：
- en: '![Figure 4.14 – /refresh endpoint'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14 – /refresh 端点'
- en: '](img/Figure_4.14_B17115.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.14_B17115.jpg)'
- en: Figure 4.14 – /refresh endpoint
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – /refresh 端点
- en: You can now issue a `POST` request on the `/refresh` endpoint, and a new token
    will be generated and returned.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在 `/refresh` 端点上发出 `POST` 请求，并将生成并返回一个新的令牌。
- en: 'Awesome—you now have a working authentication workflow! However, the user credentials
    are still hardcoded in the application code source. You can improve this by storing
    them in your **MongoDB** server. An updated sequence diagram is provided here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——你现在有一个工作的认证工作流程！然而，用户凭证仍然硬编码在应用程序代码源中。你可以通过将它们存储在 **MongoDB** 服务器上来改进这一点。这里提供了一个更新的序列图：
- en: '![Figure 4.15 – Storing credentials in MongoDB'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.15_B17115.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – Storing credentials in MongoDB
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to interact with the MongoDB server, you need to add the MongoDB
    collection to the `AuthHandler` struct in the `auth.go` file, as illustrated in
    the following code snippet. Then, you can issue a `FindOne` operation on the `users`
    collection to verify if the given credentials exist:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, update the `SignInHandler` method to verify if the user credentials are
    valid by comparing them with entries in the database. Here is how it should be
    done:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `init()` method, you need to set up a connection to the `users` collection
    then pass the collection instance to the `AuthHandler` instance, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make sure to save the `main.go` changes, and the API is then ready!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Hashing and salting passwords
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before running the app, we need to initialize the *users* collection with some
    users. Create a new project in `main.go` file with the following content:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code will insert three users (`admin`, `packt`, `mlabouardy`)
    into the `users`collection. The passwords are **hashed** and **salted** before
    they are saved into MongoDB using the *SHA256* algorithm for security purposes.
    The algorithm generates a unique 256-bit signature for the password that can be
    decrypted back to the original password. That way, sensitive information can remain
    secure.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Storing plaintext passwords in the database is not recommended. By hashing and
    salting users' passwords, we make sure that hackers are not able to sign in, as
    the stolen data won't contain the credentials.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the code with the `MONGO_URI="mongodb://admin:password@localhost:27017/test?authSource=admin"
    MONGO_DATABASE=demo go run main.go` command. Check if the users have been inserted
    using MongoDB Compass (for a step-by-step guide on how to use MongoDB Compass,
    head back to [*Chapter 3*](B17115_03_Final_JM_ePub.xhtml#_idTextAnchor054)*, Managing
    Data Persistence with MongoDB*), as illustrated in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Users collection'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.16_B17115.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – Users collection
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might notice, the passwords are hashed and salted. With the users being
    inserted into MongoDB, we can test out the sign-in endpoint by issuing a `POST`
    request with the following payload:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Sign-in endpoint'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.17_B17115.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – Sign-in endpoint
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: We can improve the JWT implementation by setting a cookie on the client side
    with the JWT value. That way, the cookie is sent along with the request.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: You can take this further and create a sign-up endpoint to create a new user
    and save it to the MongoDB database. You should now be familiar with how to implement
    an authentication mechanism with JWT.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Persisting client sessions and cookies
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, you had to include the `Authorization` header on each request. A
    better solution is to generate a **session cookie**. Session cookies allow users
    to be recognized within an application without having to authenticate every time.
    Without a cookie, every time you issue an API request, the server will treat you
    like a completely new visitor.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你必须在每个请求中都包含 `Authorization` 头。更好的解决方案是生成一个 **会话 cookie**。会话 cookie 允许用户在应用程序内被识别，而无需每次都进行身份验证。没有
    cookie，每次你发出 API 请求时，服务器都会把你当作一个全新的访客。
- en: 'To generate a session cookie, proceed as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成会话 cookie，请按照以下步骤操作：
- en: 'Install *Gin middleware* for session management with the following command:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 *Gin 中间件* 以进行会话管理：
- en: '[PRE20]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Configure *Redis* as a store for users'' sessions with the following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码将 *Redis* 配置为用户会话的存储：
- en: '[PRE21]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of hardcoding the Redis **Uniform Resource Identifier** (**URI**), you
    can use an environment variable. That way, you can keep configuration out of the
    API source code.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以不硬编码 Redis **统一资源标识符**（**URI**），而是使用环境变量。这样，你可以将配置从 API 源代码中分离出来。
- en: 'Then, update `SignInHandler` to generate a session with a unique ID, as illustrated
    in the following code snippet. The session starts once a user logs in and expires
    sometime after that. The session information of the logged-in user will be stored
    in the Redis cache:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新 `SignInHandler` 以生成一个具有唯一 ID 的会话，如下面的代码片段所示。会话在用户登录后开始，并在之后某个时间点过期。登录用户的会话信息将存储在
    Redis 缓存中：
- en: '[PRE22]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, update `AuthMiddleware` to obtain the token from the request cookie.
    If the cookie is not set, we return a `403` code (`Forbidden`) by returning an
    `http.StatusForbidden` response, as illustrated in the following code snippet:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `AuthMiddleware` 以从请求 cookie 中获取令牌。如果 cookie 未设置，我们通过返回 `http.StatusForbidden`
    响应来返回 `403` 代码（`Forbidden`），如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Start the server on port 8080, and issue a `POST` request on the `/signin`
    endpoint with a valid username and password. A cookie should be generated, like
    the one shown in the following screenshot:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口 8080 上启动服务器，并在 `/signin` 端点上使用有效的用户名和密码发出 `POST` 请求。应该会生成一个 cookie，如下面的截图所示：
- en: '![Figure 4.18 – Session cookie'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.18 – 会话 cookie'
- en: '](img/Figure_4.18_B17115.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.18_B17115.jpg)'
- en: Figure 4.18 – Session cookie
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 会话 cookie
- en: 'Now the session will be persisted across all other API routes. Therefore, you
    can interact with API endpoints without including any authorization header, as
    illustrated in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，会话将跨所有其他 API 路由持久化。因此，你可以与 API 端点交互，而无需包含任何授权头，如下面的截图所示：
- en: '![Figure 4.19 – Session-based authentication'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.19 – 基于会话的认证'
- en: '](img/Figure_4.19_B17115.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.19_B17115.jpg)'
- en: Figure 4.19 – Session-based authentication
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – 基于会话的认证
- en: 'The previous example uses the Postman client, but if you''re a `cURL` fan,
    do the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子使用了 Postman 客户端，但如果你是 `cURL` 粉丝，请按照以下步骤操作：
- en: 'Use the following command to store the generated cookie in a text file:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将生成的 cookie 存储到文本文件中：
- en: '[PRE24]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, inject the `cookies.txt` file in future requests, like this:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在未来的请求中注入 `cookies.txt` 文件，如下所示：
- en: '[PRE25]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can implement a refresh route to generate a new session cookie with a renewed
    expiry time.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以实现一个刷新路由来生成一个新的会话 cookie，并更新其过期时间。
- en: 'All the sessions generated by the API will be persisted in Redis. You can use
    the Redis Insight **user interface** (**UI**) (hosted on a Docker container) to
    browse the saved session, as illustrated in the following screenshot:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: API 生成的所有会话都将持久保存在 Redis 中。你可以使用 Redis Insight **用户界面**（**UI**）（托管在 Docker 容器中）来浏览保存的会话，如下面的截图所示：
- en: '![Figure 4.20 – List of sessions stored in Redis'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.20 – Redis 中存储的会话列表'
- en: '](img/Figure_4.20_B17115.jpg)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.20_B17115.jpg)'
- en: Figure 4.20 – List of sessions stored in Redis
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.20 – Redis 中存储的会话列表
- en: 'To log out, you can implement the `SignOutHandler` handler to clear the session
    cookie with the following command:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要注销，你可以实现 `SignOutHandler` 处理器来使用以下命令清除会话 cookie：
- en: '[PRE26]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Remember to register the handler on the `main.go` file, like so:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得在 `main.go` 文件上注册处理器，如下所示：
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the application, and a sign-out endpoint should be exposed, as illustrated
    in the following screenshot:![Figure 4.21 – Sign-out handler
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，应该会暴露一个注销端点，如下面的截图所示：![图 4.21 – 注销处理器
- en: '](img/Figure_4.21_B17115.jpg)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.21_B17115.jpg)'
- en: Figure 4.21 – Sign-out handler
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.21 – 注销处理器
- en: Now, test it out with the Postman client by executing a `POST` request, like
    so:![Figure 4.22 – Signing out
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用Postman客户端执行一个`POST`请求来测试它，如下所示：![图4.22 – 注销
- en: '](img/Figure_4.22_B17115.jpg)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.22_B17115.jpg)'
- en: Figure 4.22 – Signing out
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.22 – 注销
- en: 'The session cookie will be deleted, and if you now try to add a new recipe,
    a `403` error will be returned, as illustrated in the following screenshot:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 会话cookie将被删除，如果你现在尝试添加一个新的食谱，将会返回一个`403`错误，如下截图所示：
- en: '![Figure 4.23 – Adding a new recipe'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.23 – 添加新食谱'
- en: '](img/Figure_4.23_B17115.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.23_B17115.jpg)'
- en: Figure 4.23 – Adding a new recipe
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.23 – 添加新食谱
- en: 'Make sure to commit the changes to GitHub by creating a new feature branch.
    Then, merge the branch into development mode, as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过创建一个新的功能分支将更改提交到GitHub。然后，将分支合并到开发模式，如下所示：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following screenshot shows the pull requests containing the JWT and cookie
    authentication features:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了包含JWT和cookie认证功能的拉取请求：
- en: '![Figure 4.24 – Pull requests on GitHub'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.24 – GitHub上的拉取请求'
- en: '](img/Figure_4.24_B17115.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.24_B17115.jpg)'
- en: Figure 4.24 – Pull requests on GitHub
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24 – GitHub上的拉取请求
- en: Awesome! The API endpoints are now secured and can be served to the public.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！API端点现在已安全，可以公开提供服务。
- en: Authenticating with Auth0
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Auth0进行认证
- en: So far, the authentication mechanism is built in within the application. Maintaining
    such a system might be a bottleneck in the long run, which is why you might need
    to consider an external service such as **Auth0**. This is an all-in-one authentication
    solution that gives you access to powerful reporting and analytics as well as
    a **role-based access control** (**RBAC**) system.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，认证机制已内置在应用程序中。维护这样一个系统可能会在长期成为瓶颈，这就是为什么你可能需要考虑使用外部服务，如**Auth0**。这是一个一站式认证解决方案，它为你提供了强大的报告和分析功能，以及一个**基于角色的访问控制**（**RBAC**）系统。
- en: 'To get started, follow these steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请按照以下步骤操作：
- en: Create a free account ([https://auth0.com/signup](https://auth0.com/signup)).
    Once created, set up a tenant domain in the region where you're located, as illustrated
    in the following screenshot:![Figure 4.25 – Auth0 tenant domain
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个免费账户([https://auth0.com/signup](https://auth0.com/signup))。创建后，在您所在的区域设置一个租户域，如下截图所示：![图4.25
    – Auth0租户域
- en: '](img/Figure_4.25_B17115.jpg)'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.25_B17115.jpg)'
- en: Figure 4.25 – Auth0 tenant domain
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.25 – Auth0租户域
- en: Then, create a new API called `Recipes API`. Set the identifier to [https://api.recipes](https://api.recipes)`.io`
    and the signing algorithm to `RS256`, as illustrated in the following screenshot:![Figure
    4.26 – Auth0 new API
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个新的API，命名为`Recipes API`。将标识符设置为[https://api.recipes](https://api.recipes)`.io`，并将签名算法设置为`RS256`，如下截图所示：![图4.26
    – Auth0新API
- en: '](img/Figure_4.26_B17115.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.26_B17115.jpg)'
- en: Figure 4.26 – Auth0 new API
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.26 – Auth0新API
- en: 'Once the API is created, you need to integrate the Auth0 service into the API.
    Download the following Go packages:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了API，你需要将Auth0服务集成到API中。下载以下Go包：
- en: '[PRE29]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, update `AuthMiddleware`, as illustrated in the following code snippet.
    The middleware will check if an access token exists and if this is valid. If it
    passes the checks, the request will proceed. If not, a `401 Authorization` error
    is returned:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`AuthMiddleware`，如下代码片段所示。中间件将检查是否存在访问令牌以及它是否有效。如果通过检查，请求将继续。如果不通过，将返回一个`401授权`错误：
- en: '[PRE30]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Auth0 uses RS256 algorithm-signing access tokens. The verification process uses
    a public key (located at `AUTH0_DOMAIN/.well-known/jwks.json`) in **JSON Web Key
    Set** (**JWKS**) format to verify the given token.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Auth0使用RS256算法签名访问令牌。验证过程使用位于`AUTH0_DOMAIN/.well-known/jwks.json`的公钥（以**JSON
    Web Key Set**（**JWKS**）格式），来验证给定的令牌。
- en: 'Run the application with `AUTH0_DOMAIN` and `AUTH0_API_IDENTIFIER`, as illustrated
    in the following code snippet. Make sure to replace those variables with the values
    you copied from your Auth0 dashboard:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AUTH0_DOMAIN`和`AUTH0_API_IDENTIFIER`运行应用程序，如下代码片段所示。确保用你在Auth0仪表板中复制的值替换这些变量：
- en: '[PRE31]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, if you try to issue a request to your API without sending an access token,
    you will see this message:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你尝试向你的API发送请求而不发送访问令牌，你会看到以下消息：
- en: '![Figure 4.27 – Unauthorized access'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.27 – 未授权访问'
- en: '](img/Figure_4.27_B17115.jpg)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.27_B17115.jpg)'
- en: Figure 4.27 – Unauthorized access
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.27 – 未授权访问
- en: To generate an access token. Head back to the **Auth0** dashboard, click on
    **APIs**, then select **Recipes API**. From there, click on the **Test** tab and
    copy the cURL command shown in the following screenshot:![Figure 4.28 – Generating  access
    token with cURL
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新您的API请求以包含访问令牌，如图所示：![图4.29 – 授权访问
- en: '](img/Figure_4.28_B17115.jpg)'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.28_B17115.jpg)'
- en: Figure 4.28 – Generating access token with cURL
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.28 – 使用cURL生成访问令牌
- en: 'Execute the following command on your terminal session to generate an access
    token that you can use to communicate with your backend API:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端会话中执行以下命令以生成一个可以用来与您的后端API通信的访问令牌：
- en: '[PRE32]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'An access token will be generated, as follows (you should have a different
    value):'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将生成一个访问令牌，如下所示（您应该有一个不同的值）：
- en: '[PRE33]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, update your API request to include the access token, as shown in the following
    screenshot:![Figure 4.29 – Authorized access
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意
- en: '](img/Figure_4.29_B17115.jpg)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.29_B17115.jpg)'
- en: Figure 4.29 – Authorized access
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.29 – 授权访问
- en: 'This can also be tested straight from the command line with cURL. Just replace
    the `ACCESS_TOKEN` value shown in the following code snippet with your test token
    and then paste it into your terminal:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也可以通过命令行使用cURL直接测试。只需将以下代码片段中显示的`ACCESS_TOKEN`值替换为您的测试令牌，然后将其粘贴到您的终端中：
- en: '[PRE34]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Awesome! You just developed a secure API with Go and the Gin framework.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你刚刚使用Go语言和Gin框架开发了一个安全的API。
- en: Building an HTTPS server
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要生成访问令牌，请返回到**Auth0**仪表板，点击**APIs**，然后选择**Recipes API**。从那里，点击**测试**选项卡并复制以下截图中的cURL命令：![图4.28
    – 使用cURL生成访问令牌
- en: So far, the API is served locally through HTTP, but for a real-world application,
    it should be served under a domain name through HTTPS.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTPS协议导航到转发URL。URL旁边应该显示**连接安全**消息，如图所示：
- en: 'To set this up, proceed as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.32 – 通过HTTPS提供服务
- en: Use the `ngrok` solution to serve our local web API with a public **Uniform
    Resource Locator** (**URL**) that supports both HTTP and HTTPS.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ngrok`解决方案以支持HTTP和HTTPS的公共**统一资源定位符**（**URL**）来提供我们的本地Web API。
- en: Note
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.31_B17115.jpg)'
- en: In advanced chapters, we will explore how to purchase a domain name and set
    up HTTPS for free on a cloud provider such as **Amazon Web Services** (**AWS**).
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在高级章节中，我们将探讨如何在云服务提供商如**亚马逊网络服务**（**AWS**）上免费购买域名并设置HTTPS。
- en: 'Download the ZIP file based on your **operating system** (**OS**) from the
    official Ngrok page at [https://ngrok.com/download](https://ngrok.com/download).
    In this book, we will work with version 2.3.35\. Once downloaded, unzip Ngrok
    from a terminal with the following commands:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://ngrok.com/download](https://ngrok.com/download)的官方Ngrok页面下载基于您的**操作系统**（**OS**）的ZIP文件。在这本书中，我们将使用版本2.3.35。下载后，使用以下命令在终端中解压Ngrok：
- en: '[PRE35]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Verify if it''s properly installed by executing the following command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令来验证是否正确安装：
- en: '[PRE36]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It should output the following message:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该输出以下消息：
- en: '![Figure 4.30 – Ngrok version'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.30 – Ngrok版本'
- en: '](img/Figure_4.30_B17115.jpg)'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.30_B17115.jpg)'
- en: Figure 4.30 – Ngrok version
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.30 – Ngrok版本
- en: 'Configure Ngrok to listen and forward requests into port 8080, which is the
    port where the RESTful API is exposed, by running the following command:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令配置Ngrok以监听并转发到8080端口，这是RESTful API暴露的端口：
- en: '[PRE37]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A public URL will be generated that can be used as a proxy to interact with
    the API from the internet, as illustrated here:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将生成一个公共URL，可以用作代理，从互联网上与API交互，如图所示：
- en: '![Figure 4.31 – Ngrok forwarding'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.30_B17115.jpg)'
- en: '](img/Figure_4.31_B17115.jpg)'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要设置此配置，请按照以下步骤操作：
- en: Figure 4.31 – Ngrok forwarding
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.31 – Ngrok转发
- en: 'Navigate to the forwarding URL using the HTTPS protocol. A **Connection is
    secure** message should be displayed next to the URL, as illustrated in the following
    screenshot:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建HTTPS服务器
- en: '![Figure 4.32 – Serving through HTTPS'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.32 – 通过HTTPS提供服务'
- en: '](img/Figure_4.32_B17115.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.32_B17115.jpg)'
- en: Figure 4.32 – Serving through HTTPS
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.31 – Ngrok转发'
- en: You can now access the API from another machine or device or share it with others.
    In the next section, we will cover how to create your own **Secure Sockets Layer**
    (**SSL**) certificates to secure a domain name running locally.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以从另一台机器或设备访问API，或者与他人共享。在下一节中，我们将介绍如何创建自己的**安全套接字层**（**SSL**）证书来保护本地运行的域名。
- en: Self-signed certificates
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自签名证书
- en: SSL certificates are what websites use to move from HTTP and HTTPS. The certificate
    uses SSL/**Transport Layer Security** (**TLS**) encryption to keep user data secure,
    verify ownership of the website, prevent attackers from creating a fake version
    of the site, and gain user trust.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'To create self-signed certificates, proceed as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory where the certificates will be stored and use the OpenSSL
    command line to generate public and private keys, as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You'll need to fill a simple questionnaire—make sure to set the fully qualified
    hostname to `localhost`, as shown here:![Figure 4.33 – Generating self-signed
    certificates
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.33_B17115.jpg)'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.33 – Generating self-signed certificates
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In doing so, two files will be generated, as follows:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`localhost.crt`: Self-signed certificate'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`localhost.key`: Private key'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In advanced chapters, we will cover how to retrieve a valid certificate for
    production with Let's Encrypt ([https://letsencrypt.org](https://letsencrypt.org))
    for free.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `main.go` to run the server on HTTPS by utilizing the self-signed certificates,
    as follows (note that we use port 443 now, which is the default HTTPS port):'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the application, and the logs will confirm the API is served through HTTPS,
    as illustrated here:![Figure 4.34 – Listening and serving HTTPS
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.34_B17115.jpg)'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.34 – Listening and serving HTTPS
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Head to your browser, and then navigate to [https://localhost/recipes](https://localhost/recipes).
    A secure-website icon will be shown on the left side of the URL bar, as illustrated
    in the following screenshot:![Figure 4.35 – Encrypted connection to localhost
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.35_B17115.jpg)'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Or, you can use a `–k` flag to skip the SSL verification, as follows (not recommended
    if interacting with external websites):'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For development, simply keep using the localhost, or access the API from a
    custom domain. You can create an alias with a domain name locally by adding the
    following entry to your `/etc/hosts` file:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once the changes are saved, you can test it out by executing a `ping` command
    on `api.recipes.io`, as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.37 – ping output'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.37_B17115.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.37 – ping output
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'The domain name is reachable and points to `127.0.0.1`. You can now access
    the RESTful API by navigating to [https://api.recipes.io:8080](https://api.recipes.io:8080),
    as illustrated in the following screenshot:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.38 – Alias domain name'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.38_B17115.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.38 – Alias domain name
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Great! You will now be able to secure your API endpoints with authentication
    and serve your API through a custom domain name locally.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we wrap up this chapter, you need to update the API documentation to
    include the authentication endpoints we implemented throughout the chapter, as
    follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update the general metadata to include an `Authorization` header in
    the API requests, as follows:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, write a `swagger:operation` annotation on top of the `SignInHandler`
    handler, as follows:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`SignInHandler`处理器上方编写一个`swagger:operation`注解，如下所示：
- en: '[PRE44]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Write a `swagger:operation` annotation on top of the `RefreshHandler` handler,
    as follows:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RefreshHandler`处理器上方编写一个`swagger:operation`注解，如下所示：
- en: '[PRE45]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The operation expects a request body with the following attributes:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该操作期望包含以下属性的请求体：
- en: '[PRE46]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Generate the OpenAPI specification, then serve the JSON file with the Swagger
    UI by executing the following commands:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成OpenAPI规范，然后通过执行以下命令使用Swagger UI提供JSON文件：
- en: '[PRE47]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, click on the `signin` endpoint, and you will be able to fill the username
    and password attributes directly from the Swagger UI, as illustrated in the following
    screenshot:![Figure 4.40 – Sign-in credentials
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击`signin`端点，你将能够直接从Swagger UI中填写用户名和密码属性，如下面的截图所示：![Figure 4.40 – Sign-in
    credentials
- en: '](img/Figure_4.40_B17115.jpg)'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 4.40 – Sign-in credentials](img/Figure_4.40_B17115.jpg)'
- en: Figure 4.40 – Sign-in credentials
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.40 – 登录凭证
- en: 'Next, click on `Authorization` header to interact with endpoints that require
    authorization, as illustrated in the following screenshot:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击`Authorization`头以与需要授权的端点交互，如下面的截图所示：
- en: '![Figure 4.41 – Authorization header'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.41 – Authorization header'
- en: '](img/Figure_4.41_B17115.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.41_B17115.jpg]'
- en: Figure 4.41 – Authorization header
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.41 – 授权头
- en: You now are able to build a secure Gin RESTful API and serve it through the
    HTTPS protocol.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经能够构建一个安全的Gin RESTful API并通过HTTPS协议提供服务。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a few of the best practices and recommendations
    for building a secure RESTful API based on the Gin web framework. You also covered
    how to implement JWT in Golang and how to persist session cookies across API requests.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了基于Gin Web框架构建安全RESTful API的一些最佳实践和建议。你还了解了如何在Golang中实现JWT以及如何在API请求之间持久化会话cookie。
- en: You have also explored how a third-party solution such as Auth0 can be used
    as an authentication provider and how it can be integrated with Golang to secure
    API endpoints. Finally, you learned how to serve an API through the HTTPS protocol.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你还探讨了如何使用第三方解决方案，如Auth0，作为身份验证提供者，以及如何将其与Golang集成以保护API端点。最后，你学习了如何通过HTTPS协议提供API。
- en: In the next chapter, we will build a user-friendly UI (also known as a frontend)
    on top of the RESTful API with the React web framework.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用React Web框架在RESTful API之上构建一个用户友好的UI（也称为前端）。
- en: Questions
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How would you implement a sign-up endpoint to create a new user account?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何实现一个注册端点来创建一个新的用户账户？
- en: How would you implement a profile endpoint to return a user profile?
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何实现一个个人资料端点以返回用户个人资料？
- en: How would you generate a Swagger specification for a sign-out endpoint?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何生成一个注销端点的Swagger规范？
- en: Further reading
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*OAuth 2.0 Cookbook* by Adolfo Eloy Nascimento, Packt Publishing'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《OAuth 2.0食谱》* 由阿道夫·埃洛伊·纳西メント著，Packt出版社'
- en: '*SSL Complete Guide -* HTTP to HTTPS by Bogdan Stashchuk, Packt Publishing'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《SSL完全指南 - HTTP到HTTPS》* 由博甘·斯塔什丘克著，Packt出版社'
