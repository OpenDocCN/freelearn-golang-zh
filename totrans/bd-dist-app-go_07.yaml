- en: 'Chapter 5: Serving Static HTML in Gin'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：在Gin中提供静态HTML
- en: In this chapter, you will learn how to build a **static web application** that
    consumes Gin-based **API** responses. Along the way, you will learn how to serve
    web assets (JavaScript, **Cascading Style Sheets** (**CSS**), and images) and
    render **HTML** templates with Gin. Finally, you will cover how to build a self-contained
    web application with Go and resolve **cross-origin resource sharing** (**CORS**)
    policy errors with a Gin middleware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何构建一个消费基于Gin的**API**响应的**静态Web应用**。在这个过程中，你将学习如何使用Gin提供Web资源（JavaScript、**层叠样式表**（**CSS**）和图片）以及渲染**HTML**模板。最后，你将了解如何使用Go构建一个自包含的Web应用，并使用Gin中间件解决**跨源资源共享**（**CORS**）策略错误。
- en: 'In this chapter, we will focus on the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注以下主题：
- en: Serving static files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: Rendering HTML templates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染HTML模板
- en: Building a self-contained web application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自包含的Web应用
- en: Building a **Single-Page Application** (**SPA**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建**单页应用**（**SPA**）
- en: By the end of this chapter, you will be able to build a SPA with React to consume
    your RESTful API endpoints.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用React构建SPA以消费你的RESTful API端点。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，你需要以下内容：
- en: A complete understanding of the previous chapter—this chapter is a follow-up
    of the previous one and it will use the same source code. Hence, some snippets
    won't be explained, to avoid repetition.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全理解前一章的内容——本章是前一章的后续，它将使用相同的源代码。因此，一些代码片段将不会解释，以避免重复。
- en: Previous experience with a frontend development, and ideally knowledge of a
    web framework such as Angular, React, or Vue.js.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具备前端开发经验，理想情况下了解Angular、React或Vue.js等Web框架。
- en: The code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter05](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter05).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包托管在GitHub上，网址为[https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter05](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter05)。
- en: Serving static files
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: In the previous chapters, you have seen how to render API responses in `index.html`
    file and then move on to serving static files, such as JavaScript, CSS files,
    and images from a filesystem, and eventually render HTML templates.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经看到了如何在`index.html`文件中渲染API响应，然后转到提供来自文件系统的静态文件，如JavaScript、CSS文件和图片，并最终渲染HTML模板。
- en: 'To start serving static files, follow these steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始提供静态文件，请按照以下步骤操作：
- en: 'Create a new project folder and open it with the `index.html` file to display
    a `Hello world` message with an `<h2>` tag, as follows:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目文件夹，并使用`index.html`文件打开它，以显示带有`<h2>`标签的`Hello world`消息，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, with the `go get` command, install `github.com/gin-gonic/gin`, write
    a `main.go` file, and define a router with the `gin.Default()` method. Then, define
    a route for the `index` page and register an `IndexHandler` handler on it. The
    route handler will serve the `index.html` file using the `c.File` method. The
    complete `main.go` file looks like this:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`go get`命令安装`github.com/gin-gonic/gin`，编写一个`main.go`文件，并使用`gin.Default()`方法定义一个路由器。然后，为`index`页面定义一个路由，并在其上注册一个`IndexHandler`处理器。路由处理器将使用`c.File`方法提供`index.html`文件。完整的`main.go`文件如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the application with the following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行应用程序：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using your favorite browser, head to [http://localhost:8080](http://localhost:8080),
    and you should see a **Hello world** message, as follows:![Figure 5.2 – Serving
    index.html
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的浏览器，转到[http://localhost:8080](http://localhost:8080)，你应该看到一条**Hello world**消息，如下所示：![图5.2
    – 提供index.html
- en: '](img/Figure_5.2_B17115.jpg)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B17115.jpg)'
- en: Figure 5.2 – Serving index.html
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.2 – 提供index.html
- en: 'Next, update the `index.html` file to display some recipes using the following
    code. It references static assets for page styling (`app.css`) and recipes'' images
    (`burger.jpg` and `pizza.jpg`):'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`index.html`文件以显示一些使用以下代码的食谱。它引用了页面样式的静态资源（`app.css`）和食谱图片（`burger.jpg`和`pizza.jpg`）：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The static files are stored under an `assets` folder in the project root repository.
    Create an `assets` folder with the following structure:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态文件存储在项目根存储库下的`assets`文件夹中。创建一个具有以下结构的`assets`文件夹：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To be able to load those assets from `index.html`, the server should serve
    them as well. That''s where the `router.Static` method comes into play. Add the
    following instruction to serve the `assets` folder under the `/assets` route:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够从 `index.html` 加载这些资产，服务器也应该提供它们。这就是 `router.Static` 方法发挥作用的地方。添加以下指令以在
    `/assets` 路由下提供 `assets` 文件夹：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rerun the application—the images and CSS file should now be accessible from
    http://localhost:8080/assets/PATH, as illustrated in the following screenshot:![Figure
    5.3 – Serving assets
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行应用程序——图片和 CSS 文件现在应该可以从 http://localhost:8080/assets/PATH 访问，如下截图所示：![Figure
    5.3 – 提供资产](img/Figure_5.3_B17115.jpg)
- en: '](img/Figure_5.3_B17115.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure_5.3_B17115.jpg](img/Figure_5.3_B17115.jpg)'
- en: Figure 5.3 – Serving assets
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 5.3 – 提供资产
- en: 'Head back to your browser and refresh the page—it should now display the following
    results:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回浏览器并刷新页面——现在应该会显示以下结果：
- en: '![Figure 5.4 – Serving CSS and images with Gin'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_5.4 – 使用 Gin 提供CSS和图片](img/Figure_5.4_B17115.jpg)'
- en: '](img/Figure_5.4_B17115.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_5.4_B17115.jpg](img/Figure_5.4_B17115.jpg)'
- en: Figure 5.4 – Serving CSS and images with Gin
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.4 – 使用 Gin 提供CSS和图片
- en: The page is pretty basic, as you can tell! You now can serve static assets with
    Gin.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从你所能看到的，页面相当基础！现在你可以使用 Gin 提供静态资源了。
- en: So far, you have seen how to serve HTML and static files from a Gin application.
    In the following section, we will cover how to create HTML templates and render
    dynamic content.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何在 Gin 应用程序中提供 HTML 和静态文件。在下一节中，我们将介绍如何创建 HTML 模板并渲染动态内容。
- en: Rendering HTML templates
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染 HTML 模板
- en: In this section, you will add the functionality to display a list of recipes
    dynamically by generating an `index.html` file from the server side. The Gin framework
    uses the Go standard `text/template` and `html/template` packages in the background
    to generate text and HTML outputs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将添加功能以通过从服务器端生成 `index.html` 文件来动态显示食谱列表。Gin 框架在后台使用 Go 标准的 `text/template`
    和 `html/template` 包来生成文本和 HTML 输出。
- en: 'To get started, proceed as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请按照以下步骤操作：
- en: 'Create a `Recipe` struct. The structure will hold just two fields: a name and
    picture. This can be represented as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Recipe` 结构体。该结构体将只包含两个字段：名称和图片。这可以表示如下：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, update the `IndexHandler` handler to create a `recipes` slice. Then,
    call the `c.HTML` method to render the `index.tmpl` file by passing the `recipes`
    slice. To keep things simple, the list of recipes is kept in memory, which is
    why we will initialize the `recipes` slice with two hardcoded recipes, as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `IndexHandler` 处理器以创建一个 `recipes` 切片。然后，通过传递 `recipes` 切片调用 `c.HTML`
    方法来渲染 `index.tmpl` 文件。为了简化问题，我们将食谱列表保存在内存中，因此我们将使用两个硬编码的食谱初始化 `recipes` 切片，如下所示：
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The `.tmpl` extension is not required; however, it's recommended to be consistent
    within a project for clarity.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.tmpl` 扩展名不是必需的；然而，为了清晰起见，建议在项目内保持一致性。'
- en: 'Create a `templates` folder in the root of the project folder, and write an
    `index.tmpl` file with the following content:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹的根目录下创建一个 `templates` 文件夹，并编写一个 `index.tmpl` 文件，内容如下：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `range` keyword is used to iterate over all recipes in the `recipes` slice.
    For each recipe in the range of recipes, display its picture and name. Within
    a range, each recipe becomes `{{.}}` and the recipe properties therefore become
    `{{.Name}}` or `{{.Picture}}`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`range` 关键字用于遍历 `recipes` 切片中的所有食谱。对于食谱范围内的每个食谱，显示其图片和名称。在范围内，每个食谱变为 `{{.}}`，因此食谱属性变为
    `{{.Name}}` 或 `{{.Picture}}`。'
- en: 'Next, tell Gin to load templates from the `templates` directory. The templates
    will be loaded once from disk at server startup; therefore, the application will
    serve the HTML pages faster. The code is illustrated in the following snippet:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，告诉 Gin 从 `templates` 目录加载模板。模板将在服务器启动时从磁盘加载一次；因此，应用程序将更快地提供 HTML 页面。以下代码片段展示了如何实现：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Rerun the application, and head once again to `localhost:8080`. A list of recipes
    will be displayed, as illustrated in the following screenshot:![Figure 5.5 – Iterating
    over items with range
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行应用程序，再次访问 `localhost:8080`。将显示一个食谱列表，如下截图所示：![Figure 5.5 – 使用 range 迭代项目](img/Figure_5.5_B17115.jpg)
- en: '](img/Figure_5.5_B17115.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure_5.5_B17115.jpg](img/Figure_5.5_B17115.jpg)'
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Update the `Recipe` struct to mirror the `recipe` fields, as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Recipe` 结构体更新为与 `recipe` 字段相对应，如下所示：
- en: '[PRE11]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `init()` method, read the JSON file and encode its content to the `recipes`
    slice using the `json.Unmarshal` method, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `init()` 方法中，读取 JSON 文件并使用 `json.Unmarshal` 方法将其内容编码到 `recipes` 切片中，如下所示：
- en: '[PRE12]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, update the `IndexHandler` handler to pass the `recipes` slice to the
    `index.tmpl` template in a variable named `recipes`, as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新`IndexHandler`处理器，将`recipes`切片传递给名为`recipes`的变量，并在`index.tmpl`模板中使用，如下所示：
- en: '[PRE13]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, customize the template file to display the recipe ingredients and
    steps using the `range` keyword. The recipe attributes are accessed using a *dot*
    with the field name (`{{ .FieldName }}`), as illustrated in the following code
    snippet:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，自定义模板文件，使用`range`关键字显示食谱的成分和步骤。使用字段名（`{{ .FieldName }}`）的点操作符访问食谱属性，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For further explanation about advanced template actions and operators, refer
    to the Go official documentation at [https://golang.org/pkg/text/template/](https://golang.org/pkg/text/template/).
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于高级模板操作符和运算符的进一步说明，请参阅Go官方文档[https://golang.org/pkg/text/template/](https://golang.org/pkg/text/template/)。
- en: 'Rerun the application, and refresh the page on your browser. This time, an
    aesthetically pleasing **user interface** (**UI**) will be displayed, as illustrated
    in the following screenshot:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行应用程序，并在浏览器中刷新页面。这次，将显示一个美观的**用户界面**（**UI**），如下面的屏幕截图所示：
- en: '![Figure 5.6 – Rendering data with Go templates'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6 – 使用Go模板渲染数据'
- en: '](img/B17115_05_06_v2.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_05_06_v2.jpg)'
- en: Figure 5.6 – Rendering data with Go templates
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 使用Go模板渲染数据
- en: As you can see, your application looks much nicer. All you did was add some
    CSS with the Bootstrap framework (To know more about the framework, refer [https://getbootstrap.com/](https://getbootstrap.com/));
    so, from a functionality point of view, nothing has changed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您的应用程序看起来更加美观。您所做的只是添加了一些Bootstrap框架的CSS（要了解更多关于框架的信息，请参阅[https://getbootstrap.com/](https://getbootstrap.com/));
    因此，从功能角度来看，没有任何变化。
- en: 'If you go back to the terminal, you will notice that the images and other assets
    were served from the HTTP server, as we can see here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回到终端，您会注意到图像和其他资源是从HTTP服务器提供的，如下所示：
- en: '![Figure 5.7 – Serving images'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7 – 服务器图像'
- en: '](img/Figure_5.7_B17115.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.7_B17115.jpg)'
- en: Figure 5.7 – Serving images
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 服务器图像
- en: Great! The assets are served from the Gin server, and you can now build a dynamic
    web page.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！资源是从Gin服务器提供的，现在您可以构建一个动态网页。
- en: Creating the view templates
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视图模板
- en: For now, the application we have built displays a list of recipes. You can take
    this further and create a recipe page where users can see the full recipe. To
    do so, you need to create a unique identifier for each recipe; that way, you can
    have a unique URL to access each recipe.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们构建的应用程序显示了一个食谱列表。您可以进一步创建一个食谱页面，让用户可以看到完整的食谱。为此，您需要为每个食谱创建一个唯一的标识符；这样，您就可以有一个唯一的URL来访问每个食谱。
- en: 'To get started, proceed as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请按照以下步骤操作：
- en: 'Add an `id` attribute to the recipe''s items in the `recipes.json` file as
    follows, or you can download the `recipes.json` file from the `chapter05` folder
    located in the book''s GitHub repository:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`recipes.json`文件中的食谱项中添加一个`id`属性，如下所示，或者您可以从书籍GitHub仓库中的`chapter05`文件夹下载`recipes.json`文件：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, add the `ID` field to the `Recipe` struct, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`ID`字段添加到`Recipe`结构体中，如下所示：
- en: '[PRE16]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To be able to navigate to the recipe page, add a button to each recipe item
    in the `index.tmpl` file. When clicking on the button, the user will be redirected
    to the target recipe page. The `{{ .ID }}` expression will be evaluated and replaced
    by the recipe ID. The code is illustrated in the following snippet:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要能够导航到食谱页面，请在`index.tmpl`文件中的每个食谱项中添加一个按钮。当点击按钮时，用户将被重定向到目标食谱页面。`{{ .ID }}`表达式将被评估并替换为食谱ID。代码如下所示：
- en: '[PRE17]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With that being said, serve the recipe page at `/recipes/:id`. Take note of
    the `:id` part in this route. The two *dots* at the beginning indicate that this
    is a dynamic route. The route will store the recipe `id` attribute in the route
    parameter named `ID`, which we can access in the `RecipeHandler` handler. Here''s
    the code you need:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 话虽如此，在`/recipes/:id`上提供食谱页面。请注意此路由中的`:id`部分。开头的两个*点*表示这是一个动态路由。该路由将存储食谱`id`属性在名为`ID`的路由参数中，我们可以在`RecipeHandler`处理器中访问它。以下是您需要的代码：
- en: '[PRE18]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code snippet contains the route-handler code, and is self-explanatory.
    It loops through the `recipes` slice, looking for a recipe that matches the ID
    given in the request parameter. If a match is found, then the `recipe.tmpl` file
    will be rendered with the data of the recipe. If not, the user will be redirected
    to a `404.html` error page will simply display a 404 illustration with a `Recipe
    not found` message. This can be done using the following code:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段包含路由处理程序代码，内容自解释。它遍历 `recipes` 切片，寻找与请求参数中给出的 ID 匹配的食谱。如果找到匹配项，则将使用食谱的数据渲染
    `recipe.tmpl` 文件。如果没有找到，用户将被重定向到 `404.html` 错误页面，该页面将简单地显示一个 404 插图和“食谱未找到”的消息。这可以通过以下代码实现：
- en: '[PRE19]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To test out the new changes, rerun the server, and head back to the browser
    and refresh the page. A list of recipes will be returned, but this time we have
    a **See recipe** button, as illustrated in the following screenshot:![Figure 5.8
    – Home page
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试新更改，重新运行服务器，然后返回浏览器并刷新页面。将返回食谱列表，但这次我们有一个 **查看食谱** 按钮，如图所示：![图 5.8 – 首页
- en: '](img/B17115_05_08_v2.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B17115_05_08_v2.jpg)'
- en: Figure 5.8 – Home page
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.8 – 首页
- en: Click on the **See recipe** button.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **查看食谱** 按钮。
- en: 'You''ll be redirected to the **Recipe** page, where you can see a complete
    recipe''s ingredients and instructions, as illustrated in the following screenshot:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将被重定向到 **食谱** 页面，在那里您可以查看完整的食谱成分和说明，如图所示：
- en: '![Figure 5.9 – Recipes page'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9 – 食谱页面'
- en: '](img/Figure_5.9_B17115.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.9_B17115.jpg)'
- en: Figure 5.9 – Recipe page
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 食谱页面
- en: 'You can also share your favorite recipes by sharing their URLs with your friends.
    If a particular recipe doesn''t exist anymore or you''ve shared a wrong ID for
    a recipe, then a 404 page will be displayed, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过与朋友分享它们的 URL 来分享您最喜欢的食谱。如果某个食谱不再存在或您分享了一个错误的食谱 ID，则将显示 404 页面，如下所示：
- en: '![Figure 5.10 – 404 error page'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – 404 错误页面'
- en: '](img/Figure_5.10_B17115.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.10_B17115.jpg)'
- en: Figure 5.10 – 404 error page
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 404 错误页面
- en: You might have noticed that you used a navigation bar to be able to switch easily
    between the home page (where a list of recipes is being displayed) and the recipe
    page. The same code is being used in two different template files. To avoid duplicating
    code, you can create **reusable templates**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，您使用了一个导航栏来能够轻松地在首页（显示食谱列表的页面）和食谱页面之间切换。相同的代码被用于两个不同的模板文件。为了避免代码重复，您可以创建
    **可重用模板**。
- en: Creating reusable templates
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可重用模板
- en: 'The **navbar** is a common functionality that will be reused across multiple
    pages of our application. In order to create a reusable template, proceed as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航栏** 是将在我们应用程序的多个页面中重用的常见功能。为了创建一个可重用模板，请按照以下步骤操作：'
- en: 'Create a `navbar.tmpl` file in the `templates` folder and place the navbar
    code in it, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `templates` 文件夹中创建一个 `navbar.tmpl` 文件，并将导航栏代码放入其中，如下所示：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, remove the navbar lines of code from the `index.tmpl` and `recipe.tmpl`
    files and import the `navbar` template from the `navbar.tmpl` file with the following
    instructions:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从 `index.tmpl` 和 `recipe.tmpl` 文件中删除导航栏代码，并按照以下说明从 `navbar.tmpl` 文件导入 `navbar`
    模板：
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Your reusable template is created.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您的可重用模板已创建。
- en: 'The line containing `{{template "navbar.tmpl"}}` is used to dynamically load
    the navbar. As with the navbar, you can create reusable templates from common
    pieces of your application such as header, footer, forms, and so on. The directory
    structure of your project at this stage should look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `{{template "navbar.tmpl"}}` 的行用于动态加载导航栏。与导航栏一样，您可以从应用程序的常见部分（如页眉、页脚、表单等）创建可重用模板。在此阶段，您项目的目录结构应如下所示：
- en: '![Figure 5.11 – Project structure'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11 – 项目结构'
- en: '](img/Figure_5.11_B17115.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.11_B17115.jpg)'
- en: Figure 5.11 – Project structure
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 项目结构
- en: So far, you have seen how to run the application locally by compiling the source
    code. But what if you wanted to build a binary of our web application so that
    we can deploy it remotely or share it with others? Let's have a look at how to
    do this.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了如何通过编译源代码在本地运行应用程序。但如果我们想构建 Web 应用程序的二进制文件以便远程部署或与他人共享呢？让我们看看如何做这件事。
- en: Building a self-contained web application
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自包含的 Web 应用程序
- en: 'Luckily, Go is a compiled language, which means that you can create an executable
    or binary with the needed dependencies, all with a single command, as illustrated
    here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go 是一种编译型语言，这意味着您可以使用单个命令创建包含所需依赖项的可执行文件或二进制文件，如下所示：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: You can build an executable for different architectures or platforms (Windows,
    macOS, Linux, and so on) with `GOOS` and `GOARCH` environment variables.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `GOOS` 和 `GOARCH` 环境变量为不同的架构或平台（Windows、macOS、Linux 等）构建可执行文件。
- en: The command creates an executable called `app` in your current directory. By
    default, Go uses the name of the application directory for naming the executable.
    However, you can specify a different name or location for the executable with
    a `-o` flag.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在您的当前目录中创建一个名为 `app` 的可执行文件。默认情况下，Go 使用应用程序目录的名称来命名可执行文件。但是，您可以使用 `-o` 标志指定不同的名称或位置。
- en: 'You can now execute the binary with the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用以下命令执行二进制文件：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The server will start on port `8080` as usual, and you can access the web application
    from `localhost:8080`, as illustrated in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将像往常一样在端口 `8080` 上启动，您可以从 `localhost:8080` 访问网络应用程序，如下面的截图所示：
- en: '![Figure 5.12 – Running an executable'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12 – 运行可执行文件'
- en: '](img/Figure_5.12_B17115.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.12_B17115.jpg)'
- en: Figure 5.12 – Running an executable
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 运行可执行文件
- en: The application is working as expected because the HTML templates and assets
    are located in the same folder where the executable is being executed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序按预期工作，因为 HTML 模板和资源位于正在执行可执行文件的同一文件夹中。
- en: 'What if you run the binary from a different directory? In that case, you would
    need to follow these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从不同的目录运行二进制文件，那么您需要遵循以下步骤：
- en: 'Copy the executable to your home directory with the following commands:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将可执行文件复制到您的主目录：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Rerun the application—it should crash immediately due to the `templates` folder
    not being found. You will see something that looks like this:![Figure 5.13 – Application
    stack traces
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行应用程序——它应该立即崩溃，因为找不到 `templates` 文件夹。您将看到类似以下的内容：![图 5.13 – 应用程序堆栈跟踪
- en: '](img/Figure_5.13_B17115.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_5.13_B17115.jpg)'
- en: Figure 5.13 – Application stack traces
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.13 – 应用程序堆栈跟踪
- en: You can copy the `templates` and `assets` folders to the home directory. However,
    it's often cumbersome to remember to update all the file references when upgrading
    or moving a binary to a new location. A better solution is to embed all static
    files in a single binary.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以将 `templates` 和 `assets` 文件夹复制到主目录。然而，在升级或将二进制文件移动到新位置时，记住更新所有文件引用通常很麻烦。更好的解决方案是将所有静态文件嵌入到一个单独的二进制文件中。
- en: '`go-assets-builder` is a tool that converts any text or binary file into Go
    source code, making it the perfect choice for embedding assets into Go applications.
    Install the `go-assets-builder` package with the following command:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go-assets-builder` 是一个工具，可以将任何文本或二进制文件转换为 Go 源代码，使其成为将资源嵌入 Go 应用程序的完美选择。使用以下命令安装
    `go-assets-builder` 包：'
- en: '[PRE25]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, invoke the `go-assets-builder` command to generate Go code from the static
    files, as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用 `go-assets-builder` 命令从静态文件生成 Go 代码，如下所示：
- en: '[PRE26]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: var Assets = assets.NewFileSystem(map[string][]string{
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var Assets = assets.NewFileSystem(map[string][]string{
- en: '"/": []string{"assets", "templates", "404.html",'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"/": []string{"assets", "templates", "404.html",'
- en: '"recipes.json"}, "/assets/css":'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"recipes.json"}, "/assets/css":'
- en: '[]string{"app.css"}, "/assets/images":'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[]string{"app.css"}, "/assets/images":'
- en: '[]string{"stuffed-cornsquash.jpg", "curry-chicken-'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[]string{"stuffed-cornsquash.jpg", "curry-chicken-'
- en: 'salad.jpg"}, "/templates": []string{"navbar.tmpl",'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'salad.jpg"}, "/templates": []string{"navbar.tmpl",'
- en: '"index.tmpl", "recipe.tmpl"}},'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"index.tmpl", "recipe.tmpl"}},'
- en: map[string]*assets.File{
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: map[string]*assets.File{
- en: '"/": &assets.File{'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"/": &assets.File{'
- en: Path:     "/",
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路径:     "/",
- en: 'FileMode: 0x800001ed,'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'FileMode: 0x800001ed,'
- en: Mtime:    time.Unix(1615118299,
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Mtime:    time.Unix(1615118299,
- en: 1615118299722824447),
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1615118299722824447),
- en: Data:     nil,
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据:     nil,
- en: '},  "/templates/navbar.tmpl": &assets.File{'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},  "/templates/navbar.tmpl": &assets.File{'
- en: Path:     "/templates/navbar.tmpl",
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路径:     "/templates/navbar.tmpl",
- en: 'FileMode: 0x1a4,'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'FileMode: 0x1a4,'
- en: Mtime:    time.Unix(1614862865,
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Mtime:    time.Unix(1614862865,
- en: 1614862865957528581),
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1614862865957528581),
- en: Data:     []byte(_Assets9a0a5c784c66e5609ac
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据:     []byte(_Assets9a0a5c784c66e5609ac
- en: d084702e97a6a733e0d56),
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d084702e97a6a733e0d56),
- en: '}, "/recipes.json": &assets.File{'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}, "/recipes.json": &assets.File{'
- en: Path:     "/recipes.json",
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路径:     "/recipes.json",
- en: 'FileMode: 0x1a4,'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'FileMode: 0x1a4,'
- en: "Mtime:    time.Unix(1614782782,  \t \t \t \t                           1614782782296236029),"
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: "Mtime:    time.Unix(1614782782,  \t \t \t \t                           1614782782296236029),"
- en: Data:     []byte(_Assets142ce9f9ba8b43eeb97b8
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据:     []byte(_Assets142ce9f9ba8b43eeb97b8
- en: 3c79ea872ed40e6cba1),
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3c79ea872ed40e6cba1),
- en: '}, "")'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}, "")'
- en: '[PRE27]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, update `main.go` to load the HTML files. The templates are accessible
    via the `Assets.Files` map structure. Make sure to import the `html/template`
    library. The code is illustrated in the following snippet:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`main.go`以加载HTML文件。模板可通过`Assets.Files`映射结构访问。确保导入`html/template`库。代码在以下代码片段中说明：
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, update the HTTP router to call the `loadTemplate` method when the server
    is asked to serve `index.tmpl`, `recipe.tmpl`, or `navbar.tmpl` templates, as
    follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新HTTP路由器，当服务器被要求提供`index.tmpl`、`recipe.tmpl`或`navbar.tmpl`模板时，调用`loadTemplate`方法，如下所示：
- en: '[PRE29]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For assets files (CSS and images), define a custom HTTP handler to serve the
    right asset based on the `filepath` parameter, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于资产文件（CSS和图像），定义一个自定义HTTP处理器，根据`filepath`参数提供正确的资产，如下所示：
- en: '[PRE30]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, define a route for the `assets` folder with a `filepath` parameter, as
    follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为`assets`文件夹定义一个带有`filepath`参数的路由，如下所示：
- en: '[PRE31]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Update the `recipes.json` file as well, to load it from the `Assets.Files`
    map instead of the disk, as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时更新`recipes.json`文件，从`Assets.Files`映射中加载它，如下所示：
- en: '[PRE32]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Make sure to update the `navbar` reference in `index.tmpl` and `recipe.tmpl`
    as well, like this:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保更新`index.tmpl`和`recipe.tmpl`中的`navbar`引用，如下所示：
- en: '[PRE33]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally, fix the `templates` path in both `RecipeHandler` and `IndexHandler`
    handlers.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`RecipeHandler`和`IndexHandler`处理器中修复`templates`路径。
- en: 'Now, build the application with the new changes. Issue the following command:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令构建应用程序，应用新更改：
- en: '[PRE34]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This time, the application will be functional, and all assets will be loaded
    from the binary. You can see the result here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，应用程序将是功能性的，所有资产都将从二进制文件中加载。你可以在这里看到结果：
- en: '![Figure 5.14 – Embedding web application assets'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.14 – 嵌入Web应用程序资源'
- en: '](img/B17115_05_14_v2.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_05_14_v2.jpg)'
- en: Figure 5.14 – Embedding web application assets
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 – 嵌入Web应用程序资源
- en: You can now share the binary with your friends and deploy it easily on a remote
    server.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以与你的朋友分享这个二进制文件，并轻松地在远程服务器上部署它。
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In [*Chapter 8*](B17115_08_Final_JM_ePub.xhtml#_idTextAnchor131)*, Deploying
    the Application on AWS*, we will explore how to deploy your distributed web application
    on the cloud with Docker and Kubernetes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B17115_08_Final_JM_ePub.xhtml#_idTextAnchor131)*，在AWS上部署应用程序*中，我们将探讨如何使用Docker和Kubernetes在云上部署你的分布式Web应用程序。
- en: Bundling static files
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态文件打包
- en: In this chapter, we are using Go 1.16, which comes with new features and enhancements
    such as embedded files being supported without the need for an external package
    such as `go-assets-builder`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Go 1.16，它带来了新的功能和改进，例如支持嵌入式文件，无需使用像`go-assets-builder`这样的外部包。
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can use `gvm install go1.16` command.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`gvm install go1.16`命令。
- en: 'Go 1.16 introduced a `//go:embed` directive that allows you to include contents
    of files and directories within a Go application. You can do so by implementing
    the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.16引入了`//go:embed`指令，允许你在Go应用程序中包含文件和目录的内容。你可以通过实现以下操作来完成：
- en: 'In `main.go`, define an `embed.FS` variable to hold a group of files. Then,
    define a comment just above the variable declaration, as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，定义一个`embed.FS`变量来保存一组文件。然后，在变量声明上方定义一个注释，如下所示：
- en: '[PRE35]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Update the `init()` function to read the `recipes.json` file from the `FS`
    variable, as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`init()`函数，从`FS`变量中读取`recipes.json`文件，如下所示：
- en: '[PRE36]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, use the `http.FS` file to create an HTTP filesystem to serve `assets`
    files, as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`http.FS`文件创建一个HTTP文件系统来提供`assets`文件，如下所示：
- en: '[PRE37]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Rebuild the binary with the `go build` command.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go build`命令重新构建二进制文件。
- en: Note
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to remove the `/templates` prefixes from the HTTP handlers and template
    files before building the binary.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在构建二进制文件之前，确保从HTTP处理器和模板文件中删除`/templates`前缀。
- en: The final result is a single web server binary ready for distribution!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是单个准备分发的Web服务器二进制文件！
- en: Building a SPA
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建SPA
- en: While you can build complete web applications with Gin by rendering HTML templates
    and serving the static files, as the application grows it becomes hard to maintain
    it. That's why you can adopt a popular frontend JavaScript framework such as Angular,
    React, or Vue.js to build your SPA. In this section we will go with React, but
    you can get the same results with other JavaScript frameworks as well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以通过渲染HTML模板和提供静态文件来使用Gin构建完整的Web应用程序，但随着应用程序的增长，维护它变得很困难。这就是为什么你可以采用流行的前端JavaScript框架，如Angular、React或Vue.js来构建你的SPA。在本节中，我们将使用React，但你也可以使用其他JavaScript框架获得相同的结果。
- en: 'The application we''ll build will do the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的应用程序将执行以下操作：
- en: Display the list of all recipes on the home page (for all users).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主页上显示所有食谱的列表（对所有用户）。
- en: Let users sign in with their username and password.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户使用用户名和密码登录。
- en: Let users create new recipes (logged-in users only).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户创建新的食谱（仅限已登录用户）。
- en: First of all, we will need to make sure that Node.js is installed on your system.
    You can install the **long-term support** (**LTS**) version (14.16.0) from the
    official page at [https://nodejs.org/en/download/](https://nodejs.org/en/download/),
    or you can use the **Node Version Manager** (**NVM**) to install Node.js easily,
    based on your **operating system** (**OS**).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保您的系统上已安装Node.js。您可以从[https://nodejs.org/en/download/](https://nodejs.org/en/download/)的官方网站安装**长期支持**（**LTS**）版本（14.16.0），或者您可以使用**Node版本管理器**（**NVM**）根据您的**操作系统**（**OS**）轻松安装Node.js。
- en: 'To install NVM, proceed as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装NVM，请按照以下步骤操作：
- en: 'Run the following script:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下脚本：
- en: '[PRE38]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This could take anywhere from a few seconds to a few minutes, but once your
    installation has completed, issue the following command to install the LTS version
    of Node.js:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可能需要几秒钟到几分钟的时间，但一旦安装完成，请发出以下命令以安装Node.js的LTS版本：
- en: '[PRE39]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With Node.js installed, we're ready to build our web application with React.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Node.js之后，我们就可以使用React构建我们的Web应用程序了。
- en: Getting started with React
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用React
- en: 'In this section, you will set up your React environment. To do so, apply the
    following steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将设置React环境。为此，请执行以下步骤：
- en: 'Open your terminal and navigate to your workspace. Then, install `create react
    app` with the following command. The **command-line interface** (**CLI**) simplifies
    the setup process of a React environment:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的终端并导航到您的工 作区。然后，使用以下命令安装`create react app`。**命令行界面**（**CLI**）简化了React环境的设置过程：
- en: '[PRE40]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, create a React project with the CRA CLI. The project name is `recipes-web`,
    as we can see here:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用CRA CLI创建一个React项目。项目名称为`recipes-web`，如下所示：
- en: '[PRE41]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is the command output:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是命令输出：
- en: '![Figure 5.15 – Setup of new React project'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.15 – 新建React项目的设置'
- en: '](img/Figure_5.15_B17115.jpg)'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_5.15_B17115.jpg)'
- en: Figure 5.15 – Setup of a new React project
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.15 – 新建React项目的设置
- en: 'After running the preceding command, the project structure will look like this.
    The project is created with all of the proper behind-the-scenes configurations
    automatically hooked up:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在运行前面的命令后，项目结构将如下所示。项目会自动创建所有必要的后台配置：
- en: '![Figure 5.16 – React project structure'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.16 – React项目结构'
- en: '](img/Figure_5.16_B17115.jpg)'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_5.16_B17115.jpg)'
- en: Figure 5.16 – React project structure
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.16 – React项目结构
- en: Note
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to create a GitHub repository for your web application and push all
    the changes to the remote repository.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保为您的Web应用程序创建一个GitHub仓库并将所有更改推送到远程仓库。
- en: 'Navigate to the `recipes-web` folder and enter the following commands to launch
    the application:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`recipes-web`文件夹并输入以下命令以启动应用程序：
- en: '[PRE42]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Head to your browser and navigate to `Localhost:3000.` `Apart` `from;` you
    will see something similar to the following screenshot:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中导航到`Localhost:3000`。`Apart` `from;`您将看到以下截图类似的内容：
- en: '![Figure 5.18 – React “Hello World” application'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.18 – React “Hello World”应用程序'
- en: '](img/Figure_5.18_B17115.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.18_B17115.jpg)'
- en: Figure 5.18 – React "Hello World" application
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18 – React "Hello World"应用程序
- en: Right now, your application doesn't do a whole lot. It doesn't look like much,
    either. Let's build the recipe listing, using React components.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您的应用程序并没有做很多。它看起来也不像什么。让我们使用React组件构建食谱列表。
- en: Exploring React components
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索React组件
- en: One of the basic foundations when building a SPA is the usage of components.
    Throughout this section, we'll explore how to build a **Recipes** dashboard based
    on React components.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建SPA时的一个基本基础是组件的使用。在本节中，我们将探讨如何基于React组件构建**食谱**仪表板。
- en: 'The first thing you''re going to do is create an `App` component to list the
    `recipes` array by referencing a `Recipe` element. To do so, proceed as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要做的第一件事是创建一个`App`组件，通过引用一个`Recipe`元素来列出`recipes`数组。为此，请按照以下步骤操作：
- en: 'Update the `App.js` file with the following content:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容更新`App.js`文件：
- en: '[PRE43]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The component constructor defines a `recipes` array in the `state` object. The
    array stores a list of hardcoded recipes.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组件构造函数在`state`对象中定义了一个`recipes`数组。该数组存储了一系列硬编码的食谱。
- en: 'Next, create a `Recipe` component to display the recipe properties (name, steps,
    ingredients, and so on). In the `src` directory, create a new file named `Recipe.js`
    and add the following content to it:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `Recipe` 组件来显示菜谱属性（名称、步骤、配料等）。在 `src` 目录下创建一个名为 `Recipe.js` 的新文件，并将以下内容添加到其中：
- en: '[PRE44]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Create a style sheet called `Recipe.css` and add the appropriate style rules
    to improve the look and feel of the UI elements. Then, import the style sheet
    in `Recipe.js`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Recipe.css` 的样式表，并添加适当的样式规则以改善 UI 元素的视觉效果。然后，在 `Recipe.js` 中导入样式表。
- en: 'Once you''ve done this, save all of your changes and preview it in your browser,
    and you''ll see something that looks like this:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些操作后，保存所有更改并在浏览器中预览，你应该会看到如下所示的内容：
- en: '![Figure 5.19 – Rendering App component'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.19 – 渲染 App 组件'
- en: '](img/Figure_5.19_B17115.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.19](img/Figure_5.19_B17115.jpg)'
- en: Figure 5.19 – Rendering the App component
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 渲染 App 组件
- en: Great! You have successfully built a SPA to list recipes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你已经成功构建了一个用于列出菜谱的单页应用 (SPA)。
- en: 'Right now, the list of recipes is static. You will fix that by calling the
    `Recipes` API, built in the previous chapter. To do so, proceed as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，菜谱列表是静态的。你将通过调用上一章中构建的 `Recipes` API 来修复这个问题。为此，请按照以下步骤操作：
- en: First, look here at the architecture you're going to build:![Figure 5.20 – Application
    architecture
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，看看你将要构建的架构：![图 5.20 – 应用程序架构
- en: '](img/Figure_5.20_B17115.jpg)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 5.20](img/Figure_5.20_B17115.jpg)'
- en: '[PRE45]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, call the method on the `App` component constructor with the following
    instruction:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下指令在 `App` 组件构造函数上调用方法：
- en: '[PRE46]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Make sure the API is being served on port `8080`, as follows:![Figure 5.21 –
    Recipes API logs
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保API正在端口 `8080` 上提供服务，如下所示：![图 5.21 – 菜谱 API 日志
- en: '](img/Figure_5.21_B17115.jpg)'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 5.21](img/Figure_5.21_B17115.jpg)'
- en: Figure 5.21 – Recipes API logs
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.21 – 菜谱 API 日志
- en: 'Head back to your browser, and you should see a blank page. If you open the
    browser debugging console, you''ll see that the call to the API has been blocked
    by a CORS policy, as illustrated in the following screenshot:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你的浏览器，你应该会看到一个空白页面。如果你打开浏览器调试控制台，你会看到 API 调用被 CORS 策略阻止，如下面的截图所示：
- en: '![Figure 5.22 – CORS errors'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.22 – CORS 错误'
- en: '](img/B17115_05_22_v2.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_05_22_v2](img/B17115_05_22_v2.jpg)'
- en: Figure 5.22 – CORS errors
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22 – CORS 错误
- en: Because the `Recipes` API and web application are running in different ports,
    you need to set some headers on the API to allow the **Cross-Origin Resource Sharing
    (CORS)**.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Recipes` API 和 Web 应用程序运行在不同的端口上，你需要在 API 上设置一些头信息以允许 **跨源资源共享 (CORS)**。
- en: Resolving cross-origin requests
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决跨源请求
- en: By default, the API uses a same-origin policy to limit the ability for the API
    to interact with resources outside of the source domain. We can bypass the same-origin
    policy with CORS.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，API 使用同源策略来限制 API 与源域外的资源交互的能力。我们可以通过 CORS 来绕过同源策略。
- en: 'To resolve the CORS issues, proceed as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决 CORS 问题，请按照以下步骤操作：
- en: 'Download the Gin official CORS middleware with the following command:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令下载 Gin 官方 CORS 中间件：
- en: '[PRE47]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, update the `main.go` file of the `Recipes` API project to allow all origins
    by defining the `cors.Default()` method as a middleware, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新 `Recipes` API 项目的 `main.go` 文件，通过将 `cors.Default()` 方法定义为中间件来允许所有来源，如下所示：
- en: '[PRE48]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The middleware will be executed before handling the incoming HTTP request.
    The `cors.Default()` method will allow all HTTP methods and origins, but you can
    restrict the requests to trusted origins. Define the origins and allow incoming
    HTTP methods with the following code:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间件将在处理传入的 HTTP 请求之前执行。`cors.Default()` 方法将允许所有 HTTP 方法和服务端点，但你也可以限制请求到受信任的服务端点。使用以下代码定义服务端点并允许传入的
    HTTP 方法：
- en: '[PRE49]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Rerun the API server and head back to your browser, and refresh the web application
    page.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动 API 服务器，并返回到你的浏览器，刷新 Web 应用程序页面。
- en: 'This time, the HTTP request should be successful, and you should see a list
    of recipes, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，HTTP 请求应该成功，你应该会看到一个菜谱列表，如下所示：
- en: '![Figure 5.23 – List of recipes'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.23 – 菜谱列表'
- en: '](img/Figure_5.23_B17115.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.23](img/Figure_5.23_B17115.jpg)'
- en: Figure 5.23 – List of recipes
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23 – 菜谱列表
- en: 'Now, you can take the project further and add an authentication layer with
    Auth0, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以进一步扩展项目，并添加一个使用 Auth0 的身份验证层，如下所示：
- en: Note
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For a step-by-step guide on how to enable authentication with Auth0, check the
    previous chapter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取如何使用 Auth0 启用身份验证的逐步指南，请查看上一章。
- en: Navigate to the **Auth0 dashboard** ([https://manage.auth0.com/dashboard](https://manage.auth0.com/dashboard)),
    and create an application of type **Single Page Web Applications**, as illustrated
    in the following screenshot:![Figure 5.24 – SPA on Auth0
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Auth0仪表板**([https://manage.auth0.com/dashboard](https://manage.auth0.com/dashboard))，并创建一个类型为**单页Web应用**的应用程序，如图5.24所示：![图5.24
    – Auth0上的SPA
- en: '](img/Figure_5.24_B17115.jpg)'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_5.24_B17115.jpg)'
- en: Figure 5.24 – SPA on Auth0
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.24 – Auth0上的SPA
- en: Next, click on `Localhost:3000.` `Apart` `from,` as illustrated in the following
    screenshot. The URL will be used by Auth0 to redirect users after they have authenticated:![Figure
    5.25 – Configuring allowed callback URLs
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击`Localhost:3000.` `除此之外，`如图5.25所示。该URL将在用户认证后由Auth0用于重定向用户：![图5.25 – 配置允许的回调URL
- en: '](img/Figure_5.25_B17115.jpg)'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_5.25_B17115.jpg)'
- en: Figure 5.25 – Configuring allowed callback URLs
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.25 – 配置允许的回调URL
- en: Set the `localhost:3000` to authorize the application to make requests to the
    Auth0 API.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`localhost:3000`设置为授权应用程序向Auth0 API发起请求。
- en: 'Now, to integrate Auth0 into your web application, install the Auth0 React
    **software development kit** (**SDK**). Run the following command within your
    project folder to install the SDK:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要将Auth0集成到您的Web应用程序中，安装Auth0 React**软件开发工具包**（**SDK**）。在项目文件夹内运行以下命令以安装SDK：
- en: '[PRE50]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, wrap the root component of the application with `Auth0Provider`. Update
    the `index.js` file, as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`Auth0Provider`包装应用程序的根组件。更新`index.js`文件，如下所示：
- en: '[PRE51]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The Auth0 component takes the following properties:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Auth0组件具有以下属性：
- en: '`a.` `domain`: The Auth0 domain. The value is available under the `b.` `clientId`:
    The Auth0 client ID. The value is also available under the `c.` `redirectUri`:
    The `ReactDOM.render` method looks for the root element defined in `index.html`
    (located inside the `public` folder) and loads the Auth0 component on it.'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`a.` `domain`: Auth0域名。该值可在`b.` `clientId`: Auth0客户端ID。该值也可在`c.` `redirectUri`:
    `ReactDOM.render`方法在`index.html`中查找根元素（位于`public`文件夹内）并在此上加载Auth0组件。'
- en: 'Then, create a `Navbar` component with a login button. When the user clicks
    on the login button, the `loginWithRedirect` method from the `useAuth0()` hook
    will be called. The method will redirect the user to the Auth0 login page, where
    they can authenticate. Upon successful authentication, Auth0 will redirect the
    user back to the application based on the redirection URL defined earlier. The
    code is illustrated in the following snippet:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个带有登录按钮的`Navbar`组件。当用户点击登录按钮时，`useAuth0()`钩子的`loginWithRedirect`方法将被调用。该方法将用户重定向到Auth0登录页面，在那里他们可以进行认证。认证成功后，Auth0将根据之前定义的重定向URL将用户重定向回应用程序。代码如下所示：
- en: '[PRE52]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To prevent any rendering errors, the `isAuthenticated` property is used to check
    if Auth0 has authenticated the user before displaying the logged-in username and
    picture using the `Profile` component.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了防止任何渲染错误，使用`isAuthenticated`属性检查Auth0是否在显示使用`Profile`组件的登录用户名和图片之前已认证用户。
- en: 'In the code, we''re using existing UI elements provided by the Bootstrap framework.
    The framework can be installed with the following command:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中，我们使用Bootstrap框架提供的现有UI元素。可以使用以下命令安装该框架：
- en: '[PRE53]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once installed, reference the framework with an `import` statement on top of
    `index.js`, as follows:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，在`index.js`顶部使用`import`语句引用框架，如下所示：
- en: '[PRE54]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, add the `Navbar` component to `App.js`, as follows:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`Navbar`组件添加到`App.js`中，如下所示：
- en: '[PRE55]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Preview your application after this change, and it should look like this:![Figure
    5.26 – Rendering list of recipes
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此更改后预览您的应用程序，它应该看起来像这样：![图5.26 – 渲染食谱列表
- en: '](img/Figure_5.26_B17115.jpg)'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_5.26_B17115.jpg)'
- en: Figure 5.26 – Rendering list of recipes
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.26 – 渲染食谱列表
- en: 'Now, click on **Login**. You''ll be redirected to the Auth0 login page, where
    you can sign up for a new account or sign in with an existing account, as illustrated
    in the following screenshot:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**登录**。您将被重定向到Auth0登录页面，在那里您可以注册新账户或使用现有账户登录，如图所示：![图5.26 – 渲染食谱列表
- en: '![Figure 5.27 – Auth0 universal login page'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.27 – Auth0通用登录页面'
- en: '](img/Figure_5.27_B17115.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.27_B17115.jpg)'
- en: Figure 5.27 – Auth0 universal login page
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.27 – Auth0通用登录页面
- en: 'Your authentication has been successful! You''ll be redirected to the home
    page, where you can browse through the list of recipes returned by the `Recipes`
    API, as illustrated in the following screenshot:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您的认证已成功！您将被重定向到主页，在那里您可以浏览由`Recipes` API返回的食谱列表，如下面的截图所示：
- en: '![Figure 5.28 – Page listing recipes for a logged-in user'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.28 – 列出登录用户食谱的页面'
- en: '](img/Figure_5.28_B17115.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.28 – 列出登录用户食谱的页面](img/Figure_5.28_B17115.jpg)'
- en: Figure 5.28 – Page listing recipes for a logged-in user
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28 – 列出登录用户食谱的页面
- en: The application also displays the logged-in username and profile picture. The
    information is available through the `user` property exposed by the `useAuth0()`
    hook. You have now successfully created a SPA.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序还显示了登录用户的用户名和头像。这些信息可通过`useAuth0()`钩子暴露的`user`属性获取。你现在已经成功创建了一个SPA。
- en: Your web application is pretty simple in what it does, but by building it from
    scratch, we covered almost every little interesting detail React brings to the
    table. You can take this further and implement a new recipe form for logged-in
    users to post new recipes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Web应用程序在功能上相当简单，但通过从头开始构建，我们几乎涵盖了React带来的每一个小细节。您可以进一步实现一个新的食谱表单，供登录用户发布新食谱。
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to serve HTML templates with the Gin framework
    and how to create reusable templates and serve static assets. We covered how to
    implement a SPA with the React framework to consume a Gin RESTful API and how
    to resolve CORS issues with Gin.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Gin框架提供HTML模板，以及如何创建可重用模板并提供静态资源。我们介绍了如何使用React框架实现SPA以消费Gin RESTful
    API，以及如何使用Gin解决CORS问题。
- en: We have also explored how Auth0 allows you to quickly add authentication to
    your React application. Finally, we learned how to build a self-contained web
    application by embedding the application assets during build time.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了Auth0如何让您快速为React应用程序添加身份验证。最后，我们学习了如何在构建时嵌入应用程序资源来构建一个自包含的Web应用程序。
- en: In the next chapter, we will explore tips and best practices to architect a
    scalable, distributed web application with Gin.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用Gin架构一个可扩展、分布式Web应用的技巧和最佳实践。
- en: Questions
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How would you create reusable templates for the header and footer?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何创建可重用的头部和尾部模板？
- en: How would you create a `NewRecipe` component with React?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何使用React创建一个`NewRecipe`组件？
- en: How would you build a self-contained binary for Windows, Mac, and Linux?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何构建适用于Windows、Mac和Linux的自包含二进制文件？
- en: Further reading
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Full-Stack React Projects - Second Edition*`,` by Shama Hoque, Packt Publishing'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全栈React项目 - 第二版*，由Shama Hoque著，Packt Publishing出版'
- en: '*Full-Stack React, TypeScript, and Node*, by David Choi, Packt Publishing'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全栈React、TypeScript和Node*，由David Choi著，Packt Publishing出版'
