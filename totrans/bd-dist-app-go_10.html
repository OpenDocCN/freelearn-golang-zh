<html><head></head><body>
		<div id="_idContainer260">
			<h1 id="_idParaDest-111"><a id="_idTextAnchor117"/>Chapter 7: Testing Gin HTTP Routes</h1>
			<p>In this chapter, you will learn how to test a Gin web-based application, which involves running Go unit and integration tests. Along the way, we will explore how to integrate external tools to identify potential security vulnerabilities within your Gin web application. Finally, we will cover how to test the <strong class="bold">API</strong> <strong class="bold">HTTP</strong> methods using the Postman Collection Runner feature.</p>
			<p>As such, we will cover the following topics:</p>
			<ul>
				<li>Testing Gin HTTP handlers</li>
				<li>Generating code coverage reports</li>
				<li>Discovering security vulnerabilities</li>
				<li>Running Postman collections</li>
			</ul>
			<p>By the end of this chapter, you should be able to write, execute, and automate tests for a Gin web application from scratch.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor118"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need the following:</p>
			<ul>
				<li>A complete understanding of the previous chapter—this chapter is a follow-up of the previous one and it will use the same source code. Hence, some snippets won't be explained, to avoid repetition.</li>
				<li>Previous experience using the Go testing package.</li>
			</ul>
			<p>The code bundle for this chapter is hosted on GitHub at <a href="https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter07">https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter07</a>.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor119"/>Testing Gin HTTP handlers</h1>
			<p>So far, we <a id="_idIndexMarker557"/>have learned how to design, build, and scale a distributed web application with Gin framework. In this chapter, we will cover how to integrate different types of tests to eliminate possible errors at release. We will start with <strong class="bold">unit testing</strong>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">It's worth mentioning that<a id="_idIndexMarker558"/> you need to adopt a <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>) approach beforehand to get a head start in writing testable code.</p>
			<p>To illustrate how to<a id="_idIndexMarker559"/> write a unit test<a id="_idIndexMarker560"/> for a Gin web application, you need to dive right into a basic example. Let's take the <strong class="source-inline">hello world</strong> example covered in <a href="B17115_02_Final_JM_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Setting up API Endpoints</em>. The router declaration and HTTP server setup have been extracted from the <strong class="source-inline">main</strong> function to prepare for the tests, as illustrated in the following code snippet:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">   "net/http"</p>
			<p class="source-code">   "github.com/gin-gonic/gin"</p>
			<p class="source-code">)</p>
			<p class="source-code">func IndexHandler(c *gin.Context) {</p>
			<p class="source-code">   c.JSON(http.StatusOK, gin.H{</p>
			<p class="source-code">       "message": "hello world",</p>
			<p class="source-code">   })</p>
			<p class="source-code">}</p>
			<p class="source-code">func SetupServer() *gin.Engine {</p>
			<p class="source-code">   r := gin.Default()</p>
			<p class="source-code">   r.GET("/", IndexHandler)</p>
			<p class="source-code">   return r</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">   SetupServer().Run()</p>
			<p class="source-code">}</p>
			<p>Run the <a id="_idIndexMarker561"/>application, then<a id="_idIndexMarker562"/> issue a <strong class="source-inline">GET</strong> request on <strong class="source-inline">localhost:8080</strong>. A <strong class="source-inline">hello world</strong> message will be returned, as follows:</p>
			<p class="source-code">curl localhost:8080</p>
			<p class="source-code">{"message":"hello world"}</p>
			<p>With the<a id="_idIndexMarker563"/> refactoring being done, write a unit <a id="_idIndexMarker564"/>test in the Go programming<a id="_idIndexMarker565"/> language. To do so, apply the following steps:</p>
			<ol>
				<li>Define a <strong class="source-inline">main_test.go</strong> file with the following code in the same project directory. The <strong class="source-inline">SetupServer()</strong> method we previously refactored is injected into a test server:<p class="source-code">package main</p><p class="source-code">func TestIndexHandler(t *testing.T) {</p><p class="source-code">   mockUserResp := `{"message":"hello world"}`</p><p class="source-code">   ts := httptest.NewServer(SetupServer())</p><p class="source-code">   defer ts.Close()</p><p class="source-code">   resp, err := http.Get(fmt.Sprintf("%s/", ts.URL))</p><p class="source-code">   if err != nil {</p><p class="source-code">       t.Fatalf("Expected no error, got %v", err)</p><p class="source-code">   }</p><p class="source-code">   defer resp.Body.Close()</p><p class="source-code">   if resp.StatusCode != http.StatusOK {</p><p class="source-code">       t.Fatalf("Expected status code 200, got %v", </p><p class="source-code">                resp.StatusCode)</p><p class="source-code">   }</p><p class="source-code">   responseData, _ := ioutil.ReadAll(resp.Body)</p><p class="source-code">   if string(responseData) != mockUserResp {</p><p class="source-code">       t.Fatalf("Expected hello world message, got %v", </p><p class="source-code">                 responseData)</p><p class="source-code">   }</p><p class="source-code">}</p><p>Each test <a id="_idIndexMarker566"/>method must start with <a id="_idIndexMarker567"/>a <strong class="source-inline">Test</strong> prefix—so, for <a id="_idIndexMarker568"/>example, <strong class="source-inline">TestXYZ</strong> will be a valid test. The previous code sets up a test server using the Gin engine and issues a <strong class="source-inline">GET </strong>request. Then, it checks the status code and response payload. If the actual results don't match the expected results, an error will be thrown. Hence, the test will fail.</p></li>
				<li>To run tests in Golang, execute the following command:<p class="source-code"><strong class="bold">go test</strong></p><p>The test will be<a id="_idIndexMarker569"/> successful, as seen in th<a id="_idIndexMarker570"/>e following screenshot:</p></li>
			</ol>
			<div>
				<div id="_idContainer232" class="IMG---Figure">
					<img src="image/Figure_7.1_B17115.jpg" alt="Figure 7.1 – Test execution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Test execution</p>
			<p>While you have<a id="_idIndexMarker571"/> the ability to write complete tests with the testing package, you can install a third-party package such as <strong class="bold">testify</strong> to <a id="_idIndexMarker572"/>use advanced assertions. To do so, follow these steps: </p>
			<ol>
				<li value="1">Download testify with the following command:<p class="source-code"><strong class="bold">Go get github.com/stretchr/testify</strong></p></li>
				<li>Next, update <strong class="source-inline">TestIndexHandler</strong> to use the <strong class="source-inline">assert</strong> property from the testify package to make some assertions about the correctness of the response, as follows:<p class="source-code">func TestIndexHandler(t *testing.T) {</p><p class="source-code">   mockUserResp := `{"message":"hello world"}`</p><p class="source-code">   ts := httptest.NewServer(SetupServer())</p><p class="source-code">   defer ts.Close()</p><p class="source-code">   resp, err := http.Get(fmt.Sprintf("%s/", ts.URL))</p><p class="source-code">   defer resp.Body.Close()</p><p class="source-code">   assert.Nil(t, err)</p><p class="source-code">   assert.Equal(t, http.StatusOK, resp.StatusCode)</p><p class="source-code">   responseData, _ := ioutil.ReadAll(resp.Body)</p><p class="source-code">   assert.Equal(t, mockUserResp, string(responseData))</p><p class="source-code">}</p></li>
				<li>Execute the <strong class="source-inline">go test</strong> command and you will have the same results.</li>
			</ol>
			<p>That's how<a id="_idIndexMarker573"/> you write a test for a Gin web application. </p>
			<p>Let's move <a id="_idIndexMarker574"/>forward and write unit tests for the HTTP handlers of the RESTful API covered in previous chapters. As a reminder, the following schema illustrates the operations exposed by the REST API:</p>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="image/Figure_7.2_B17115.jpg" alt="Figure 7.2 – API HTTP methods&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – API HTTP methods</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The API source code is available on the GitHub repository under the <strong class="source-inline">chapter07</strong> folder. It's recommended to start this chapter based on the source code available in the repository.</p>
			<p>The <a id="_idIndexMarker575"/>operations in the image are registered in the Gin default router and assigned to different HTTP handlers, as follows:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">   router := gin.Default()</p>
			<p class="source-code">   router.POST("/recipes", NewRecipeHandler)</p>
			<p class="source-code">   router.GET("/recipes", ListRecipesHandler)</p>
			<p class="source-code">   router.PUT("/recipes/:id", UpdateRecipeHandler)</p>
			<p class="source-code">   router.DELETE("/recipes/:id", DeleteRecipeHandler)</p>
			<p class="source-code">   router.GET("/recipes/:id", GetRecipeHandler)</p>
			<p class="source-code">   router.Run()</p>
			<p class="source-code">}</p>
			<p>Start with a <strong class="source-inline">main_test.go</strong> file, and define a method to return an instance of the Gin router. Then, write a test method for each HTTP handler. For instance, the <strong class="source-inline">TestListRecipesHandler</strong> handler is shown in the following code snippet:</p>
			<p class="source-code">func SetupRouter() *gin.Engine {</p>
			<p class="source-code">   router := gin.Default()</p>
			<p class="source-code">   return router</p>
			<p class="source-code">}</p>
			<p class="source-code">func TestListRecipesHandler(t *testing.T) {</p>
			<p class="source-code">   r := SetupRouter()</p>
			<p class="source-code">   r.GET("/recipes", ListRecipesHandler)</p>
			<p class="source-code">   req, _ := http.NewRequest("GET", "/recipes", nil)</p>
			<p class="source-code">   w := httptest.NewRecorder()</p>
			<p class="source-code">   r.ServeHTTP(w, req)</p>
			<p class="source-code">   var recipes []Recipe</p>
			<p class="source-code">   json.Unmarshal([]byte(w.Body.String()), &amp;recipes)</p>
			<p class="source-code">   assert.Equal(t, http.StatusOK, w.Code)</p>
			<p class="source-code">   assert.Equal(t, 492, len(recipes))</p>
			<p class="source-code">}</p>
			<p>It <a id="_idIndexMarker576"/>registers the <strong class="source-inline">ListRecipesHandler</strong> handler on the <strong class="source-inline">GET /recipes</strong> resource, then it issues a <strong class="source-inline">GET</strong> request. The request payload is then encoded into a <strong class="source-inline">recipes</strong> slice. If the number of recipes is equal to <strong class="source-inline">492</strong> and the status code is a <strong class="source-inline">200-OK</strong> response, then the test is considered successful. Otherwise, an error will be thrown, and the test will fail.</p>
			<p>Then, issue a <strong class="source-inline">go test</strong> command, but this time, disable the Gin debug logs and enable verbose mode with a <strong class="source-inline">–v </strong>flag, as follows:</p>
			<p class="source-code">GIN_MODE=release go test -v</p>
			<p>The command output is shown here:</p>
			<div>
				<div id="_idContainer234" class="IMG---Figure">
					<img src="image/Figure_7.3_B17115.jpg" alt="Figure 7.3 – Running tests with verbose output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Running tests with verbose output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <a href="B17115_10_Final_JM_ePub.xhtml#_idTextAnchor160"><em class="italic">Chapter 10</em></a><em class="italic">, Capturing Gin Application Metrics</em>, we will cover how to customize the Gin debug logs and how to ship them into a centralized logging platform.</p>
			<p>Similarly, write a test for the <strong class="source-inline">NewRecipeHandler</strong> handler. It will simply post a new recipe and check if the returned response code is a <strong class="source-inline">200-OK</strong> status. The <strong class="source-inline">TestNewRecipeHandler</strong> method is<a id="_idIndexMarker577"/> shown in the following code snippet:</p>
			<p class="source-code">func TestNewRecipeHandler(t *testing.T) {</p>
			<p class="source-code">   r := SetupRouter()</p>
			<p class="source-code">   r.POST("/recipes", NewRecipeHandler)</p>
			<p class="source-code">   recipe := Recipe{</p>
			<p class="source-code">       Name: "New York Pizza",</p>
			<p class="source-code">   }</p>
			<p class="source-code">   jsonValue, _ := json.Marshal(recipe)</p>
			<p class="source-code">   req, _ := http.NewRequest("POST", "/recipes", </p>
			<p class="source-code">                              bytes.NewBuffer(jsonValue))</p>
			<p class="source-code">   w := httptest.NewRecorder()</p>
			<p class="source-code">   r.ServeHTTP(w, req)</p>
			<p class="source-code">   assert.Equal(t, http.StatusOK, w.Code)</p>
			<p class="source-code">}</p>
			<p>In the preceding test method, you declared a recipe using the <strong class="source-inline">Recipe</strong> structure. The struct is then marshaled<a id="_idIndexMarker578"/> into <strong class="bold">JSON</strong> format and added as a third parameter of the <strong class="source-inline">NewRequest</strong> function.</p>
			<p>Execute the tests, and both <strong class="source-inline">TestListRecipesHandler</strong> and <strong class="source-inline">TestNewRecipeHandler</strong> should be successful, as follows:</p>
			<div>
				<div id="_idContainer235" class="IMG---Figure">
					<img src="image/Figure_7.4_B17115.jpg" alt="Figure 7.4 – Running multiple tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Running multiple tests</p>
			<p>You are now<a id="_idIndexMarker579"/> familiar with writing unit tests for Gin HTTP handlers. Go ahead and write the tests for the rest of the API endpoints.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor120"/>Generating code coverage reports</h1>
			<p>In this section, we will<a id="_idIndexMarker580"/> cover how to generate <strong class="bold">coverage reports</strong> with Go. Test coverage <a id="_idIndexMarker581"/>describes how much of a package's code is exercised by running the package's tests. </p>
			<p>Run the following command to generate a file that holds statistics about how much code is being covered by the tests you've written in the previous section:</p>
			<p class="source-code">GIN_MODE=release go test -v -coverprofile=coverage.out ./...</p>
			<p>The command will run the tests and display the percentage of statements covered with those tests. In the following example, we're covering 16.9% of statements:</p>
			<div>
				<div id="_idContainer236" class="IMG---Figure">
					<img src="image/Figure_7.5_B17115.jpg" alt="Figure 7.5 – Test coverage&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Test coverage</p>
			<p>The generated <strong class="source-inline">coverage.out</strong> file contains the number of lines covered by the unit tests. The full code has been cropped for brevity, but you can see an illustration of this here:</p>
			<p class="source-code">mode: set</p>
			<p class="source-code">/Users/mlabouardy/github/Building-Distributed-Applications-in-Gin/chapter7/api-without-db/main.go:51.41,53.2 1 1</p>
			<p class="source-code">/Users/mlabouardy/github/Building-Distributed-Applications-in-Gin/chapter7/api-without-db/main.go:65.39,67.50 2 1</p>
			<p class="source-code">/Users/mlabouardy/github/Building-Distributed-Applications-in-Gin/chapter7/api-without-db/main.go:72.2,77.31 4 1</p>
			<p class="source-code">/Users/mlabouardy/github/Building-Distributed-Applications-in-Gin/chapter7/api-without-db/main.go:67.50,70.3 2 0</p>
			<p class="source-code">/Users/mlabouardy/github/Building-Distributed-Applications-in-Gin/chapter7/api-without-db/main.go:98.42,101.50 3 0</p>
			<p class="source-code">/Users/mlabouardy/github/Building-Distributed-Applications-in-Gin/chapter7/api-without-db/main.go:106.2,107.36 2 0</p>
			<p>You <a id="_idIndexMarker582"/>can visualize<a id="_idIndexMarker583"/> the code coverage using a <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) presentation, using the <strong class="source-inline">go tool</strong> command, as follows:</p>
			<p class="source-code">go tool cover -html=coverage.out</p>
			<p>The command will open the HTML presentation on your default browser, showing the covered source code in green and the uncovered code in red, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="image/Figure_7.6_B17115.jpg" alt="Figure 7.6 – Viewing results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Viewing results</p>
			<p>Now that it's <a id="_idIndexMarker584"/>easier to spot which methods are covered with your tests, let's write an additional test for the HTTP handler, responsible for updating an existing recipe. To do so, proceed as follows:</p>
			<ol>
				<li value="1">Add the following code block to the <strong class="source-inline">main_test.go</strong> file:<p class="source-code">func TestUpdateRecipeHandler(t *testing.T) {</p><p class="source-code">   r := SetupRouter()</p><p class="source-code">   r.PUT("/recipes/:id", UpdateRecipeHandler)</p><p class="source-code">   recipe := Recipe{</p><p class="source-code">       ID:   "c0283p3d0cvuglq85lpg",</p><p class="source-code">       Name: "Gnocchi",</p><p class="source-code">       Ingredients: []string{</p><p class="source-code">           "5 large Idaho potatoes",</p><p class="source-code">           "2 egges",</p><p class="source-code">           "3/4 cup grated Parmesan",</p><p class="source-code">           "3 1/2 cup all-purpose flour",</p><p class="source-code">       },</p><p class="source-code">   }</p><p class="source-code">   jsonValue, _ := json.Marshal(recipe)</p><p class="source-code">   reqFound, _ := http.NewRequest("PUT", </p><p class="source-code">      "/recipes/"+recipe.ID, bytes.NewBuffer(jsonValue))</p><p class="source-code">   w := httptest.NewRecorder()</p><p class="source-code">   r.ServeHTTP(w, reqFound)</p><p class="source-code">   assert.Equal(t, http.StatusOK, w.Code)</p><p class="source-code">   reqNotFound, _ := http.NewRequest("PUT", "/recipes/1", </p><p class="source-code">      bytes.NewBuffer(jsonValue))</p><p class="source-code">   w = httptest.NewRecorder()</p><p class="source-code">   r.ServeHTTP(w, reqNotFound)</p><p class="source-code">   assert.Equal(t, http.StatusNotFound, w.Code)</p><p class="source-code">}</p><p>The code issues two HTTP <strong class="source-inline">PUT</strong> requests.</p><p>One of these has a valid recipe ID and checks for the HTTP response code (<strong class="source-inline">200-OK</strong>).</p><p>The other<a id="_idIndexMarker585"/> has an invalid recipe ID and checks for the HTTP response code (<strong class="source-inline">404-Not found</strong>).</p></li>
				<li>Re-execute the tests, and the coverage percentage should increase from 16.9% to 39.0%. The following output confirms this:</li>
			</ol>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="image/Figure_7.7_B17115.jpg" alt="Figure 7.7 – More code coverage&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – More code coverage</p>
			<p>Awesome! You are now able to run unit tests and get code coverage reports. So, go forth, test, and cover. </p>
			<p>While unit tests are an important part of software development, it is equally important that the code you write is not just tested in isolation. Integration and end-to-end tests give you that extra confidence by testing parts of your application together. These parts may work just fine on their own, but in a large system, units of code rarely work separately. That's why, in the next section, we will cover how to write and run integration tests.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor121"/>Performing integration tests with Docker</h2>
			<p>The<a id="_idIndexMarker586"/> purpose of <strong class="bold">integration tests</strong> is to verify that <a id="_idIndexMarker587"/>separated developed components work together properly. Unlike unit tests, integration tests can depend on databases and external services. </p>
			<p>The distributed web application written so far interacts with the external services MongoDB and Reddit, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="image/Figure_7.8_B17115.jpg" alt="Figure 7.8 – Distributed web application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – Distributed web application</p>
			<p>To get <a id="_idIndexMarker588"/>started with integration tests, proceed as<a id="_idIndexMarker589"/> follows:</p>
			<ol>
				<li value="1">Run the needed services for our integration tests with Docker Compose. The following <strong class="source-inline">docker-compose.yml</strong> file will start a MongoDB and Redis container:<p class="source-code">version: "3.9"</p><p class="source-code">services:</p><p class="source-code"> redis:</p><p class="source-code">   image: redis</p><p class="source-code">   ports:</p><p class="source-code">     - 6379:6379</p><p class="source-code"> mongodb:</p><p class="source-code">   image: mongo:4.4.3</p><p class="source-code">   ports:</p><p class="source-code">     - 27017:27017</p><p class="source-code">   environment:</p><p class="source-code">     - MONGO_INITDB_ROOT_USERNAME=admin</p><p class="source-code">     - MONGO_INITDB_ROOT_PASSWORD=password</p></li>
				<li>Now, test <a id="_idIndexMarker590"/>each endpoint exposed by the <a id="_idIndexMarker591"/>RESTful API. For example, to test out the endpoint responsible for listing all recipes, we can use the following code block:<p class="source-code">func TestListRecipesHandler(t *testing.T) {</p><p class="source-code">   ts := httptest.NewServer(SetupRouter())</p><p class="source-code">   defer ts.Close()</p><p class="source-code">   resp, err := http.Get(fmt.Sprintf("%s/recipes", 	 	                                     ts.URL))</p><p class="source-code">   defer resp.Body.Close()</p><p class="source-code">   assert.Nil(t, err)</p><p class="source-code">   assert.Equal(t, http.StatusOK, resp.StatusCode)</p><p class="source-code">   data, _ := ioutil.ReadAll(resp.Body)</p><p class="source-code">   var recipes []models.Recipe</p><p class="source-code">   json.Unmarshal(data, &amp;recipes)</p><p class="source-code">   assert.Equal(t, len(recipes), 10)</p><p class="source-code">}</p></li>
				<li>To run tests, provide the MongoDB <strong class="bold">Uniform Resource Identifier</strong> (<strong class="bold">URI</strong>) and database<a id="_idIndexMarker592"/> before the <strong class="source-inline">go test</strong> command, as<a id="_idIndexMarker593"/> follows:<p class="source-code"><strong class="bold">MONGO_URI="mongodb://admin:password@localhost:27017/test?authSource=admin&amp;readPreference=primary&amp;ssl=false" MONGO_DATABASE=demo REDIS_URI=localhost:6379 go test</strong></p></li>
			</ol>
			<p>Great! The test will pass successfully, as illustrated here:</p>
			<div>
				<div id="_idContainer240" class="IMG---Figure">
					<img src="image/Figure_7.9_B17115.jpg" alt="Figure 7.9 – Running integration tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9 – Running integration tests</p>
			<p>The test issues a <strong class="source-inline">GET</strong> request on the <strong class="source-inline">/recipes</strong> endpoint and verifies if the number of recipes returned by the endpoint is equal to 10.</p>
			<p>Another important but neglected test <a id="_idIndexMarker594"/>is the <strong class="bold">security test</strong>. It's mandatory to ensure your application is free from major security vulnerabilities, otherwise risks of data breaches and data leaks are high.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor122"/>Discovering security vulnerabilities</h1>
			<p>There are many<a id="_idIndexMarker595"/> tools that help in identifying major security vulnerabilities in your Gin web application. In this section, we will cover two tools, out of a few, that you can adopt while building a Gin application: <strong class="bold">Snyk</strong> and <strong class="bold">Golang Security Checker</strong> (<strong class="bold">Gosec</strong>).</p>
			<p>In the upcoming sections, we will demonstrate how to use these tools to inspect security vulnerabilities in a Gin application.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor123"/>Gosec</h2>
			<p><strong class="bold">Gosec</strong> is a <a id="_idIndexMarker596"/>tool written in Golang that inspects the source code for security problems<a id="_idIndexMarker597"/> by scanning the Go <strong class="bold">abstract syntax tree</strong> (<strong class="bold">AST</strong>). Before we inspect the Gin application code, we need to install the Gosec binary.</p>
			<p>The binary can be downloaded with the following cURL command. Here, version 2.7.0 is being used:</p>
			<p class="source-code">curl -sfL https://raw.githubusercontent.com/securego/gosec/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v2.7.0</p>
			<p>Once the command is installed, run the following command on your project folder. The <strong class="source-inline">./...</strong> argument is set to recursively scan all the Go packages:</p>
			<p class="source-code">gosec ./...</p>
			<p>The command will identify three major issues related to unhandled errors (<strong class="bold">Common Weakness Enumeration</strong> (<strong class="bold">CWE</strong>) <em class="italic">703</em> (https://cwe.mitre.org/data/definitions/703.html), as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer241" class="IMG---Figure">
					<img src="image/Figure_7.10_B17115.jpg" alt="Figure 7.10 – Unhandled errors&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10 – Unhandled errors</p>
			<p>By default, Gosec <a id="_idIndexMarker598"/>will scan your project and validate it against the rules. However, it's possible to exclude some rules. For instance, to exclude the rule responsible for the Errors unhandled issue, issue the following command:</p>
			<p class="source-code">gosec -exclude=G104 ./...</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A complete list of available rules can be found here: </p>
			<p class="callout"><a href="https://github.com/securego/gosec#available-rules">https://github.com/securego/gosec#available-rules</a></p>
			<p>The command output is shown here:</p>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="image/Figure_7.11_B17115.jpg" alt="Figure 7.11 – Excluding Gosec rules&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11 – Excluding Gosec rules</p>
			<p>You should now be able to scan your application source code for potential security vulnerabilities or sources of errors.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor124"/>Securing Go modules with Snyk</h2>
			<p>Another way to<a id="_idIndexMarker599"/> detect potential security vulnerabilities is by <a id="_idIndexMarker600"/>scanning the Go modules. The <strong class="source-inline">go.mod</strong> file <a id="_idIndexMarker601"/>holds all the dependencies used by the Gin web application. <strong class="bold">Snyk</strong> (<a href="https://snyk.io">https://snyk.io</a>) is a <strong class="bold">software-as-a-service</strong> (<strong class="bold">SaaS</strong>) solution used to identify and fix security <a id="_idIndexMarker602"/>vulnerabilities in your Go application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Snyk supports all main programming languages including Java, Python, Node.js, Ruby, Scala, and so on.</p>
			<p>The solution is pretty simple. To get started, proceed as follows:</p>
			<ol>
				<li value="1">Create a free account by signing in with your GitHub account.</li>
				<li>Then, install the Snyk official <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) using <strong class="bold">Node Package Manager</strong> (<strong class="bold">npm</strong>), as follows:<p class="source-code"><strong class="bold">npm install -g snyk</strong></p></li>
				<li>Next, associate your Snyk account with the CLI by running the following command:<p class="source-code"><strong class="bold">snyk auth</strong></p><p>The preceding command will open a browser tab and redirect you to authenticate the CLI with your Snyk account.</p></li>
				<li>Now, you should<a id="_idIndexMarker603"/> be ready to scan the project vulnerabilities with the following command:<p class="source-code"><strong class="bold">snyk test</strong></p><p>The <a id="_idIndexMarker604"/>preceding command will list all identified vulnerabilities (major or minor), including their path and remediation guidance, as illustrated in the following screenshot:</p><div id="_idContainer243" class="IMG---Figure"><img src="image/Figure_7.12_B17115.jpg" alt="Figure 7.12 – Snyk vulnerability findings&#13;&#10;"/></div><p class="figure-caption">Figure 7.12 – Snyk vulnerability findings</p></li>
				<li>According to the output, Snyk identified two major issues. One of them is with the current version of the Gin framework. Click on the <strong class="source-inline">Info</strong> URL—you will be redirected to a dedicated page where you can learn more about the vulnerability, as illustrated in the following screenshot:<div id="_idContainer244" class="IMG---Figure"><img src="image/Figure_7.13_B17115.jpg" alt="Figure 7.13 – HTTP Response Splitting page&#13;&#10;"/></div><p class="figure-caption">Figure 7.13 – HTTP Response Splitting page</p></li>
				<li>Most<a id="_idIndexMarker605"/> security vulnerabilities can be fixed by upgrading <a id="_idIndexMarker606"/>the packages to the latest stable version. Run the following command to upgrade your project dependencies:<p class="source-code"><strong class="bold">go get -u</strong></p><p>All dependencies listed in your <strong class="source-inline">go.mod</strong> file will be upgraded to the latest available version, as illustrated in the following screenshot:</p></li>
			</ol>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="image/Figure_7.14_B17115.jpg" alt="Figure 7.14 – Upgrading Go packages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.14 – Upgrading Go packages</p>
			<p>For the <a id="_idIndexMarker607"/>spotted vulnerabilities, there's an open pull<a id="_idIndexMarker608"/> request on GitHub that is merged and available in the Gin 1.7 version, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/Figure_7.15_B17115.jpg" alt="Figure 7.15 – Vulnerability fix&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.15 – Vulnerability fix</p>
			<p>That's it—you <a id="_idIndexMarker609"/>now know how to scan your Go modules with Snyk <a id="_idIndexMarker610"/>as well!</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We'll cover how to embed Snyk in the <strong class="bold">continuous integration/continuous deployment</strong> (<strong class="bold">CI/CD</strong>) pipeline in <a href="B17115_09_Final_JM_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a><em class="italic">, Implementing a CI/CD pipeline</em>, to continuously inspect the application's source code for security vulnerabilities.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor125"/>Running Postman collections</h1>
			<p>Throughout <a id="_idIndexMarker611"/>the book, you have learned how to use the <strong class="bold">Postman</strong> REST client to test out the API endpoints. In addition to sending API requests, Postman can be used to build test suites by defining a group of API requests within a collection. </p>
			<p>To set this up, proceed as follows:</p>
			<ol>
				<li value="1">Open the Postman client and click on the <strong class="bold">New</strong> button from the header bar, then select <strong class="bold">Collection</strong>, as illustrated in the following screenshot:<div id="_idContainer247" class="IMG---Figure"><img src="image/Figure_7.16_B17115.jpg" alt="Figure 7.16 – New Postman collection&#13;&#10;"/></div><p class="figure-caption">Figure 7.16 – New Postman collection</p></li>
				<li>A new window will pop up— name your collection <strong class="source-inline">Recipes API</strong> and click on the <strong class="bold">Create</strong> button<a id="_idIndexMarker612"/> to save the collection. Then, click on <strong class="bold">Add request</strong> to create a new API request and call it <strong class="source-inline">List Recipes</strong>, as illustrated in the following screenshot:<div id="_idContainer248" class="IMG---Figure"><img src="image/Figure_7.17_B17115.jpg" alt="Figure 7.17 – New request&#13;&#10;"/></div><p class="figure-caption">Figure 7.17 – New request</p></li>
				<li>Click on the <strong class="bold">Save</strong> button—a new tab will open with your given request name. Enter <strong class="source-inline">http://localhost:8080/recipes</strong> in the address bar and select a <strong class="source-inline">GET</strong> method. </li>
			</ol>
			<p>All right—now, once <a id="_idIndexMarker613"/>that is done, you will write some JavaScript code in the <strong class="bold">Tests</strong> section.</p>
			<p>In Postman, you can write JavaScript code that will be executed before sending a request (pre-request script) or after receiving a response. Let's explore how to achieve that in the next section.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor126"/>Scripting in Postman</h2>
			<p>Test scripts <a id="_idIndexMarker614"/>can be used to test whether your API is working accordingly or not or to check that new features have not affected any functionality of existing requests.</p>
			<p>To write a <a id="_idIndexMarker615"/>script, proceed as follows:</p>
			<ol>
				<li value="1">Click on the <strong class="bold">Tests</strong> section and paste the following code:<p class="source-code">pm.test("More than 10 recipes", function () {</p><p class="source-code">   var jsonData = pm.response.json();</p><p class="source-code">   pm.expect(jsonData.length).to.least(10)</p><p class="source-code">});</p><p>The script will check if the number of recipes returned by the API requests is equal to 10 recipes, as illustrated in the following screenshot:</p><div id="_idContainer249" class="IMG---Figure"><img src="image/Figure_7.18_B17115.jpg" alt="Figure 7.18 – Scripting in Postman&#13;&#10;"/></div><p class="figure-caption">Figure 7.18 – Scripting in Postman</p></li>
				<li>Press the <strong class="bold">Send</strong> button and check the Postman console, which is shown in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="image/Figure_7.19_B17115.jpg" alt="Figure 7.19 – Running a test script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.19 – Running a test script</p>
			<p>You can see in <em class="italic">Figure 7.19</em> that the test script has passed.</p>
			<p>You may have <a id="_idIndexMarker616"/>noticed that the API URL is hardcoded in the address bar. While<a id="_idIndexMarker617"/> this is working fine, if you're maintaining multiple environments (sandbox, staging, and production), you'll need some way to test your API endpoints without duplicating your collection requests. Luckily, you can create environment variables in Postman.</p>
			<p>To use the URL parameter, proceed as follows:</p>
			<ol>
				<li value="1">Click the <em class="italic">eye</em> icon available in the top-right corner and click on <strong class="bold">Edit</strong>. In the <strong class="bold">VARIABLE</strong> column, set the name and the URL, which is <strong class="source-inline">http://localhost:8080</strong>, as illustrated in the following screenshot. Click on <strong class="bold">Save</strong>:<div id="_idContainer251" class="IMG---Figure"><img src="image/Figure_7.20_B17115.jpg" alt="Figure 7.20 – Environment variables&#13;&#10;"/></div><p class="figure-caption">Figure 7.20 – Environment variables</p></li>
				<li>Go back to your <strong class="source-inline">GET</strong> request and use the following URL variable. Make sure to select the <strong class="bold">Testing</strong> environment from the drop-down menu in the top-right corner, as <a id="_idIndexMarker618"/>illustrated in<a id="_idIndexMarker619"/> the following screenshot:<div id="_idContainer252" class="IMG---Figure"><img src="image/Figure_7.21_B17115.jpg" alt="Figure 7.21 – Parameterizing request&#13;&#10;"/></div><p class="figure-caption">Figure 7.21 – Parameterizing request</p></li>
				<li>Now, go ahead and add another test script for the API request. The following script will look for a particular recipe in the response payload:<p class="source-code">pm.test("Gnocchi recipe", function () {</p><p class="source-code">   var jsonData = pm.response.json();</p><p class="source-code">   var found = false;</p><p class="source-code">   jsonData.forEach(recipe =&gt; {</p><p class="source-code">       if (recipe.name == 'Gnocchi') {</p><p class="source-code">           found = true;</p><p class="source-code">       }</p><p class="source-code">   })</p><p class="source-code">   pm.expect(found).to.true</p><p class="source-code">});</p></li>
				<li>Press the <strong class="bold">Send</strong> button, and both test scripts should be successful, as depicted here:</li>
			</ol>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="image/Figure_7.22_B17115.jpg" alt="Figure 7.22 – Running multiple test scripts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.22 – Running multiple test scripts</p>
			<p>You can now <a id="_idIndexMarker620"/>define multiple test case scenarios for your API endpoints.</p>
			<p>Let's take this further and <a id="_idIndexMarker621"/>create another API request, this time for the endpoint responsible for adding a new recipe, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer254" class="IMG---Figure">
					<img src="image/Figure_7.23_B17115.jpg" alt="Figure 7.23 – New recipe request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.23 – New recipe request</p>
			<p>To do so, proceed as follows: </p>
			<ol>
				<li value="1">Define a test script to check if the HTTP status code returned upon successful insert operation is a <strong class="source-inline">200-OK</strong> code, as follows:<p class="source-code">pm.test("Status code is 200", function () {</p><p class="source-code">   pm.response.to.have.status(200);</p><p class="source-code">});</p></li>
				<li>Define another one to check if the ID of inserted is a string of 24 characters, as follows:<p class="source-code">pm.test("Recipe ID is not null", function(){</p><p class="source-code">   var id = pm.response.json().id;</p><p class="source-code">   pm.expect(id).to.be.a("string");</p><p class="source-code">   pm.expect(id.length).to.eq(24);</p><p class="source-code">})</p></li>
				<li>Click the <strong class="bold">Send</strong> button. The test script will fail because the actual status code is <strong class="source-inline">401 – Unauthorized</strong>, which is normal because the endpoint expects an authorization <a id="_idIndexMarker622"/>header in the HTTP request. You can see the output in the<a id="_idIndexMarker623"/> following screenshot:<div id="_idContainer255" class="IMG---Figure"><img src="image/Figure_7.24_B17115.jpg" alt="Figure 7.24 – 401 Unauthorized response&#13;&#10;"/></div><p class="figure-caption">Figure 7.24 – 401 Unauthorized response</p><p class="callout-heading">Note</p><p class="callout">To learn more about API authentication, head back to <a href="B17115_04_Final_JM_ePub.xhtml#_idTextAnchor073"><em class="italic">Chapter 4</em></a>, <em class="italic">Building API Authentication</em>, for a step-by-step guide.</p></li>
				<li>Add an <strong class="source-inline">Authorization</strong> header with a valid <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>). This time, the test scripts pass successfully!</li>
				<li>You now have two different API requests in a collection. Run the collection by clicking on the <strong class="bold">Run</strong> button. A new window will pop up, as illustrated in the following screenshot:<div id="_idContainer256" class="IMG---Figure"><img src="image/Figure_7.25_B17115.jpg" alt="Figure 7.25 – Collection Runner&#13;&#10;"/></div><p class="figure-caption">Figure 7.25 – Collection Runner</p></li>
				<li>Click <a id="_idIndexMarker624"/>on the <strong class="bold">Run Recipes API</strong> button, and both API requests will<a id="_idIndexMarker625"/> be executed sequentially, as illustrated in the following screenshot:<div id="_idContainer257" class="IMG---Figure"><img src="image/Figure_7.26_B17115.jpg" alt=""/></div><p class="figure-caption">Figure 7.26 – Run Results screen</p></li>
				<li>You can export the collection and all API requests by clicking the <strong class="bold">Export</strong> button. A JSON file<a id="_idIndexMarker626"/> should be<a id="_idIndexMarker627"/> created with the following structure:<p class="source-code">{</p><p class="source-code">   "info": {},</p><p class="source-code">   "item": [</p><p class="source-code">       {</p><p class="source-code">           "name": "New Recipe",</p><p class="source-code">           "event": [</p><p class="source-code">               {</p><p class="source-code">                   "listen": "test",</p><p class="source-code">                   "script": {</p><p class="source-code">                       "exec": [</p><p class="source-code">                           "pm.test(\"Recipe ID is not </p><p class="source-code">                               null\", function(){",</p><p class="source-code">                           "var id = pm.response</p><p class="source-code">                                 .json().id;",</p><p class="source-code">                           "pm.expect(id).</p><p class="source-code">                                   to.be.a(\"string\");",</p><p class="source-code">                           "pm.expect(id.length)</p><p class="source-code">                                   .to.eq(24);",</p><p class="source-code">                           "})"</p><p class="source-code">                       ],</p><p class="source-code">                       "type": "text/javascript"</p><p class="source-code">                   }</p><p class="source-code">               }</p><p class="source-code">           ],</p><p class="source-code">           "request": {</p><p class="source-code">               "method": "POST",</p><p class="source-code">               "header": [],</p><p class="source-code">               "body": {</p><p class="source-code">                   "mode": "raw",</p><p class="source-code">                   "raw": "{\n    \"name\": \"New York </p><p class="source-code">                            Pizza\"\n}",</p><p class="source-code">                   "options": {</p><p class="source-code">                       "raw": {</p><p class="source-code">                           "language": "json"</p><p class="source-code">                       }</p><p class="source-code">                   }</p><p class="source-code">               },</p><p class="source-code">               "url": {</p><p class="source-code">                   "raw": "{{url}}/recipes",</p><p class="source-code">                   "host": [</p><p class="source-code">                       "{{url}}"</p><p class="source-code">                   ],</p><p class="source-code">                   "path": [</p><p class="source-code">                       "recipes"</p><p class="source-code">                   ]</p><p class="source-code">               }</p><p class="source-code">           },</p><p class="source-code">           "response": []</p><p class="source-code">       }</p><p class="source-code">   ],</p><p class="source-code">   "auth": {}</p><p class="source-code">}</p></li>
			</ol>
			<p>With the <a id="_idIndexMarker628"/>Postman collection<a id="_idIndexMarker629"/> exported, you can run it from the terminal <a id="_idIndexMarker630"/>using <strong class="bold">Newman</strong> (<a href="https://github.com/postmanlabs/newman">https://github.com/postmanlabs/newman</a>).</p>
			<p>In the next section, we will run the previous Postman collection with the Newman CLI.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor127"/>Running collections with Newman</h2>
			<p>With all<a id="_idIndexMarker631"/> tests being defined, let's execute them using the <a id="_idIndexMarker632"/>Newman command line. It's worth mentioning that you can take this further and run those tests within your CI/CD workflow as post-integration tests to ensure the new API changes and that the features are not generating any regression.</p>
			<p>To get started, proceed as follows: </p>
			<ol>
				<li value="1">Install <strong class="bold">Newman</strong> with npm. Here, we are using version 5.2.2: <p class="source-code"><strong class="bold">npm install -g newman</strong></p></li>
				<li>Once installed, run Newman with the exported collection file as an argument, as follows:<p class="source-code"><strong class="bold">newman run postman.json</strong></p><p>The API requests should fail because the URL parameter isn't being defined, as illustrated in the following screenshot:</p><div id="_idContainer258" class="IMG---Figure"><img src="image/Figure_7.27_B17115.jpg" alt="Figure 7.27 – Collection with failing tests&#13;&#10;"/></div><p class="figure-caption">Figure 7.27 – Collection with failing tests</p></li>
				<li>You <a id="_idIndexMarker633"/>can set its value using a <strong class="source-inline">--env-var</strong> flag, as <a id="_idIndexMarker634"/>follows:<p class="source-code"><strong class="bold">newman run postman.json --env-var "url=http://localhost:8080"</strong></p><p>This should be the output if all calls are passed:</p></li>
			</ol>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="image/Figure_7.28_B17115.jpg" alt="Figure 7.28 – Collection with successful tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.28 – Collection with successful tests</p>
			<p>You <a id="_idIndexMarker635"/>should now be able to automate your API endpoints testing <a id="_idIndexMarker636"/>with Postman.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <a href="B17115_10_Final_JM_ePub.xhtml#_idTextAnchor160"><em class="italic">Chapter 10</em></a><em class="italic">, Capturing Gin Application Metrics</em>, we will cover how to trigger <strong class="source-inline">newman</strong> <strong class="source-inline">run</strong> commands within a CI/CD pipeline upon a successful application release. </p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor128"/>Summary</h1>
			<p>In this chapter, you have learned how to run different automated tests for a Gin web application. You have also explored how to integrate external tools such as Gosec and Snyk to inspect code quality, detect bugs, and find potential security vulnerabilities.</p>
			<p>In the next chapter, we will cover our distributed web application on the cloud, mainly on <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>) using Docker and Kubernetes. You should now be able to ship an almost bug-free applications and spot potential security vulnerabilities ahead of releasing new features to production.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor129"/>Questions</h1>
			<ol>
				<li value="1">Write a unit test for the <strong class="source-inline">UpdateRecipeHandler</strong> HTTP handler.</li>
				<li>Write a unit test for the <strong class="source-inline">DeleteRecipeHandler</strong> HTTP handler.</li>
				<li>Write a unit test for the <strong class="source-inline">FindRecipeHandler</strong> HTTP handler.</li>
			</ol>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor130"/>Further reading</h1>
			<p><em class="italic">Go Design Patterns</em> by Mario Castro Contreras, Packt Publishing</p>
		</div>
	</body></html>