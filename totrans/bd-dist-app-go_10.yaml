- en: 'Chapter 7: Testing Gin HTTP Routes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：测试 Gin HTTP 路由
- en: In this chapter, you will learn how to test a Gin web-based application, which
    involves running Go unit and integration tests. Along the way, we will explore
    how to integrate external tools to identify potential security vulnerabilities
    within your Gin web application. Finally, we will cover how to test the **API**
    **HTTP** methods using the Postman Collection Runner feature.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何测试基于 Gin 的 Web 应用程序，这涉及到运行 Go 单元和集成测试。在这个过程中，我们将探讨如何集成外部工具来识别 Gin
    Web 应用程序中的潜在安全漏洞。最后，我们将介绍如何使用 Postman 集合运行器功能测试 **API** **HTTP** 方法。
- en: 'As such, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将涵盖以下主题：
- en: Testing Gin HTTP handlers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 Gin HTTP 处理器
- en: Generating code coverage reports
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成代码覆盖率报告
- en: Discovering security vulnerabilities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现安全漏洞
- en: Running Postman collections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 Postman 集合
- en: By the end of this chapter, you should be able to write, execute, and automate
    tests for a Gin web application from scratch.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该能够从头开始编写、执行和自动化 Gin Web 应用程序的测试。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，您需要以下内容：
- en: A complete understanding of the previous chapter—this chapter is a follow-up
    of the previous one and it will use the same source code. Hence, some snippets
    won't be explained, to avoid repetition.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全理解前一章的内容——本章是前一章的后续，它将使用相同的源代码。因此，一些代码片段将不会进行解释，以避免重复。
- en: Previous experience using the Go testing package.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go 测试包的先前经验。
- en: The code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter07](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter07).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包托管在 GitHub 上，网址为 [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter07](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter07)。
- en: Testing Gin HTTP handlers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Gin HTTP 处理器
- en: So far, we have learned how to design, build, and scale a distributed web application
    with Gin framework. In this chapter, we will cover how to integrate different
    types of tests to eliminate possible errors at release. We will start with **unit
    testing**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用 Gin 框架设计、构建和扩展分布式 Web 应用程序。在本章中，我们将介绍如何集成不同类型的测试以消除发布时可能出现的错误。我们将从
    **单元测试** 开始。
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It's worth mentioning that you need to adopt a **test-driven development** (**TDD**)
    approach beforehand to get a head start in writing testable code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，您需要事先采用 **测试驱动开发**（**TDD**）的方法，以便在编写可测试的代码方面取得领先。
- en: 'To illustrate how to write a unit test for a Gin web application, you need
    to dive right into a basic example. Let''s take the `hello world` example covered
    in [*Chapter 2*](B17115_02_Final_JM_ePub.xhtml#_idTextAnchor037), *Setting up
    API Endpoints*. The router declaration and HTTP server setup have been extracted
    from the `main` function to prepare for the tests, as illustrated in the following
    code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何为 Gin Web 应用程序编写单元测试，您需要直接进入一个基本示例。让我们以 [*第 2 章*](B17115_02_Final_JM_ePub.xhtml#_idTextAnchor037)
    中涵盖的“设置 API 端点”为例，即 `hello world` 示例。路由声明和 HTTP 服务器设置已从 `main` 函数中提取出来，以便为测试做准备，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the application, then issue a `GET` request on `localhost:8080`. A `hello
    world` message will be returned, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，然后在 `localhost:8080` 上发出一个 `GET` 请求。将返回一个 `hello world` 消息，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the refactoring being done, write a unit test in the Go programming language.
    To do so, apply the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构完成后，用 Go 编程语言编写一个单元测试。为此，请执行以下步骤：
- en: 'Define a `main_test.go` file with the following code in the same project directory.
    The `SetupServer()` method we previously refactored is injected into a test server:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一项目目录中定义一个 `main_test.go` 文件，并包含以下代码。我们之前重构的 `SetupServer()` 方法被注入到一个测试服务器中：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each test method must start with a `Test` prefix—so, for example, `TestXYZ`
    will be a valid test. The previous code sets up a test server using the Gin engine
    and issues a `GET` request. Then, it checks the status code and response payload.
    If the actual results don't match the expected results, an error will be thrown.
    Hence, the test will fail.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个测试方法都必须以 `Test` 前缀开始——例如，`TestXYZ` 将是一个有效的测试。前面的代码使用 Gin 引擎设置了一个测试服务器并发出一个
    `GET` 请求。然后，它检查状态码和响应负载。如果实际结果与预期结果不匹配，将抛出一个错误。因此，测试将失败。
- en: 'To run tests in Golang, execute the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 Golang 中运行测试，请执行以下命令：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The test will be successful, as seen in the following screenshot:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Test execution'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B17115.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Test execution
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'While you have the ability to write complete tests with the testing package,
    you can install a third-party package such as **testify** to use advanced assertions.
    To do so, follow these steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Download testify with the following command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, update `TestIndexHandler` to use the `assert` property from the testify
    package to make some assertions about the correctness of the response, as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Execute the `go test` command and you will have the same results.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's how you write a test for a Gin web application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move forward and write unit tests for the HTTP handlers of the RESTful
    API covered in previous chapters. As a reminder, the following schema illustrates
    the operations exposed by the REST API:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – API HTTP methods'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B17115.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – API HTTP methods
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The API source code is available on the GitHub repository under the `chapter07`
    folder. It's recommended to start this chapter based on the source code available
    in the repository.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The operations in the image are registered in the Gin default router and assigned
    to different HTTP handlers, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Start with a `main_test.go` file, and define a method to return an instance
    of the Gin router. Then, write a test method for each HTTP handler. For instance,
    the `TestListRecipesHandler` handler is shown in the following code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It registers the `ListRecipesHandler` handler on the `GET /recipes` resource,
    then it issues a `GET` request. The request payload is then encoded into a `recipes`
    slice. If the number of recipes is equal to `492` and the status code is a `200-OK`
    response, then the test is considered successful. Otherwise, an error will be
    thrown, and the test will fail.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, issue a `go test` command, but this time, disable the Gin debug logs
    and enable verbose mode with a `–v` flag, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The command output is shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Running tests with verbose output'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B17115.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Running tests with verbose output
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B17115_10_Final_JM_ePub.xhtml#_idTextAnchor160)*, Capturing
    Gin Application Metrics*, we will cover how to customize the Gin debug logs and
    how to ship them into a centralized logging platform.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, write a test for the `NewRecipeHandler` handler. It will simply
    post a new recipe and check if the returned response code is a `200-OK` status.
    The `TestNewRecipeHandler` method is shown in the following code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding test method, you declared a recipe using the `Recipe` structure.
    The struct is then marshaled into `NewRequest` function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the tests, and both `TestListRecipesHandler` and `TestNewRecipeHandler`
    should be successful, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Running multiple tests'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B17115.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Running multiple tests
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: You are now familiar with writing unit tests for Gin HTTP handlers. Go ahead
    and write the tests for the rest of the API endpoints.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经熟悉了为Gin HTTP处理器编写单元测试。接下来，继续编写其余API端点的测试。
- en: Generating code coverage reports
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成代码覆盖率报告
- en: In this section, we will cover how to generate **coverage reports** with Go.
    Test coverage describes how much of a package's code is exercised by running the
    package's tests.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何使用Go生成**覆盖率报告**。测试覆盖率描述了通过运行包的测试来执行包中代码的程度。
- en: 'Run the following command to generate a file that holds statistics about how
    much code is being covered by the tests you''ve written in the previous section:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以生成一个文件，该文件包含有关您在上一节中编写的测试覆盖了多少代码的统计信息：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The command will run the tests and display the percentage of statements covered
    with those tests. In the following example, we''re covering 16.9% of statements:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将运行测试并显示测试覆盖的语句百分比。在以下示例中，我们覆盖了16.9%的语句：
- en: '![Figure 7.5 – Test coverage'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – 测试覆盖率'
- en: '](img/Figure_7.5_B17115.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.5_B17115.jpg)'
- en: Figure 7.5 – Test coverage
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 测试覆盖率
- en: 'The generated `coverage.out` file contains the number of lines covered by the
    unit tests. The full code has been cropped for brevity, but you can see an illustration
    of this here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`coverage.out`文件包含单元测试覆盖的行数。为了简洁，已裁剪完整代码，但您可以在以下示例中看到说明：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can visualize the code coverage using a `go tool` command, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`go tool`命令可视化代码覆盖率，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The command will open the HTML presentation on your default browser, showing
    the covered source code in green and the uncovered code in red, as illustrated
    in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将在您的默认浏览器中打开HTML演示文稿，显示绿色覆盖的源代码和红色未覆盖的代码，如下截图所示：
- en: '![Figure 7.6 – Viewing results'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – 查看结果'
- en: '](img/Figure_7.6_B17115.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.6_B17115.jpg)'
- en: Figure 7.6 – Viewing results
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 查看结果
- en: 'Now that it''s easier to spot which methods are covered with your tests, let''s
    write an additional test for the HTTP handler, responsible for updating an existing
    recipe. To do so, proceed as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更容易发现哪些方法被测试覆盖了，让我们为负责更新现有配方的HTTP处理器编写一个额外的测试。为此，请按照以下步骤操作：
- en: 'Add the following code block to the `main_test.go` file:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码块添加到`main_test.go`文件中：
- en: '[PRE13]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code issues two HTTP `PUT` requests.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码发出两个HTTP `PUT`请求。
- en: One of these has a valid recipe ID and checks for the HTTP response code (`200-OK`).
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中一个具有有效的配方ID，并检查HTTP响应代码（`200-OK`）。
- en: The other has an invalid recipe ID and checks for the HTTP response code (`404-Not
    found`).
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个具有无效的配方ID，并检查HTTP响应代码（`404-Not found`）。
- en: 'Re-execute the tests, and the coverage percentage should increase from 16.9%
    to 39.0%. The following output confirms this:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新执行测试，覆盖率百分比应从16.9%增加到39.0%。以下输出证实了这一点：
- en: '![Figure 7.7 – More code coverage'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – 更多代码覆盖率'
- en: '](img/Figure_7.7_B17115.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.7_B17115.jpg)'
- en: Figure 7.7 – More code coverage
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 更多代码覆盖率
- en: Awesome! You are now able to run unit tests and get code coverage reports. So,
    go forth, test, and cover.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您现在能够运行单元测试并获取代码覆盖率报告。所以，继续前进，测试并覆盖。
- en: While unit tests are an important part of software development, it is equally
    important that the code you write is not just tested in isolation. Integration
    and end-to-end tests give you that extra confidence by testing parts of your application
    together. These parts may work just fine on their own, but in a large system,
    units of code rarely work separately. That's why, in the next section, we will
    cover how to write and run integration tests.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试是软件开发的重要部分，但同样重要的是，您编写的代码不仅要在隔离状态下进行测试。集成和端到端测试通过测试应用程序的各个部分来提供额外的信心。这些部分可能单独工作得很好，但在大型系统中，代码单元很少单独工作。这就是为什么在下一节中，我们将介绍如何编写和运行集成测试。
- en: Performing integration tests with Docker
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker执行集成测试
- en: The purpose of **integration tests** is to verify that separated developed components
    work together properly. Unlike unit tests, integration tests can depend on databases
    and external services.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**的目的是验证分离开发的组件是否能够正确地协同工作。与单元测试不同，集成测试可以依赖于数据库和外部服务。'
- en: 'The distributed web application written so far interacts with the external
    services MongoDB and Reddit, as illustrated in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止编写的分布式Web应用程序与外部服务MongoDB和Reddit进行交互，如下截图所示：
- en: '![Figure 7.8 – Distributed web application'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8 – 分布式Web应用程序'
- en: '](img/Figure_7.8_B17115.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.8_B17115.jpg)'
- en: Figure 7.8 – Distributed web application
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 分布式 Web 应用程序
- en: 'To get started with integration tests, proceed as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始进行集成测试，请按照以下步骤操作：
- en: 'Run the needed services for our integration tests with Docker Compose. The
    following `docker-compose.yml` file will start a MongoDB and Redis container:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 运行我们集成测试所需的服务。以下 `docker-compose.yml` 文件将启动 MongoDB 和 Redis
    容器：
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, test each endpoint exposed by the RESTful API. For example, to test out
    the endpoint responsible for listing all recipes, we can use the following code
    block:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测试 RESTful API 暴露的每个端点。例如，要测试列出所有菜谱的端点，我们可以使用以下代码块：
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To run tests, provide the MongoDB `go test` command, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行测试，请提供 MongoDB `go test` 命令，如下所示：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Great! The test will pass successfully, as illustrated here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！测试将成功通过，如下所示：
- en: '![Figure 7.9 – Running integration tests'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.9 – 运行集成测试]'
- en: '](img/Figure_7.9_B17115.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 7.9](img/Figure_7.9_B17115.jpg)'
- en: Figure 7.9 – Running integration tests
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.9 – 运行集成测试]'
- en: The test issues a `GET` request on the `/recipes` endpoint and verifies if the
    number of recipes returned by the endpoint is equal to 10.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 测试向 `/recipes` 端点发出 `GET` 请求，并验证端点返回的菜谱数量是否等于 10。
- en: Another important but neglected test is the **security test**. It's mandatory
    to ensure your application is free from major security vulnerabilities, otherwise
    risks of data breaches and data leaks are high.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要但常被忽视的测试是 **安全测试**。确保您的应用程序没有主要安全漏洞是强制性的，否则数据泄露和数据泄露的风险很高。
- en: Discovering security vulnerabilities
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现安全漏洞
- en: 'There are many tools that help in identifying major security vulnerabilities
    in your Gin web application. In this section, we will cover two tools, out of
    a few, that you can adopt while building a Gin application: **Snyk** and **Golang
    Security Checker** (**Gosec**).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以帮助您识别 Gin Web 应用程序中的主要安全漏洞。在本节中，我们将介绍两个工具，这些工具是您在构建 Gin 应用程序时可以采用的几个工具之一：**Snyk**
    和 **Golang 安全检查器**（**Gosec**）。
- en: In the upcoming sections, we will demonstrate how to use these tools to inspect
    security vulnerabilities in a Gin application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将展示如何使用这些工具来检查 Gin 应用程序中的安全漏洞。
- en: Gosec
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gosec
- en: '**Gosec** is a tool written in Golang that inspects the source code for security
    problems by scanning the Go **abstract syntax tree** (**AST**). Before we inspect
    the Gin application code, we need to install the Gosec binary.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gosec** 是一个用 Golang 编写的工具，通过扫描 Go **抽象语法树**（**AST**）来检查源代码中的安全问题。在我们检查 Gin
    应用程序代码之前，我们需要安装 Gosec 二进制文件。'
- en: 'The binary can be downloaded with the following cURL command. Here, version
    2.7.0 is being used:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下 cURL 命令下载二进制文件。这里使用的是版本 2.7.0：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the command is installed, run the following command on your project folder.
    The `./...` argument is set to recursively scan all the Go packages:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了命令，请在项目文件夹中运行以下命令。`./...` 参数设置为递归扫描所有 Go 包：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The command will identify three major issues related to unhandled errors (**Common
    Weakness Enumeration** (**CWE**) *703* (https://cwe.mitre.org/data/definitions/703.html),
    as illustrated in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将识别与未处理错误相关的三个主要问题（**常见弱点枚举**（**CWE**）*703*（https://cwe.mitre.org/data/definitions/703.html），如下截图所示：
- en: '![Figure 7.10 – Unhandled errors'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.10 – 未处理的错误]'
- en: '](img/Figure_7.10_B17115.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 7.10](img/Figure_7.10_B17115.jpg)'
- en: Figure 7.10 – Unhandled errors
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.10 – 未处理的错误]'
- en: 'By default, Gosec will scan your project and validate it against the rules.
    However, it''s possible to exclude some rules. For instance, to exclude the rule
    responsible for the Errors unhandled issue, issue the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Gosec 将扫描您的项目并对其规则进行验证。但是，您可以排除一些规则。例如，要排除负责未处理错误问题的规则，请发出以下命令：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A complete list of available rules can be found here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可用规则的完整列表可以在以下位置找到：
- en: '[https://github.com/securego/gosec#available-rules](https://github.com/securego/gosec#available-rules)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/securego/gosec#available-rules](https://github.com/securego/gosec#available-rules)'
- en: 'The command output is shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 命令输出如下所示：
- en: '![Figure 7.11 – Excluding Gosec rules'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.11 – 排除 Gosec 规则]'
- en: '](img/Figure_7.11_B17115.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 7.11](img/Figure_7.11_B17115.jpg)'
- en: Figure 7.11 – Excluding Gosec rules
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.11 – 排除 Gosec 规则]'
- en: You should now be able to scan your application source code for potential security
    vulnerabilities or sources of errors.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够扫描应用程序源代码以查找潜在的安全漏洞或错误来源。
- en: Securing Go modules with Snyk
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Snyk 保护 Go 模块
- en: Another way to detect potential security vulnerabilities is by scanning the
    Go modules. The `go.mod` file holds all the dependencies used by the Gin web application.
    **Snyk** ([https://snyk.io](https://snyk.io)) is a **software-as-a-service** (**SaaS**)
    solution used to identify and fix security vulnerabilities in your Go application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种检测潜在安全漏洞的方法是扫描 Go 模块。`go.mod` 文件包含了 Gin 网络应用程序所使用的所有依赖项。**Snyk** ([https://snyk.io](https://snyk.io))
    是一种用于识别和修复 Go 应用程序中安全漏洞的 **软件即服务** (**SaaS**) 解决方案。
- en: Note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Snyk supports all main programming languages including Java, Python, Node.js,
    Ruby, Scala, and so on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Snyk 支持包括 Java、Python、Node.js、Ruby、Scala 等在内的所有主要编程语言。
- en: 'The solution is pretty simple. To get started, proceed as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案相当简单。要开始，请按照以下步骤操作：
- en: Create a free account by signing in with your GitHub account.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的 GitHub 账户登录创建一个免费账户。
- en: 'Then, install the Snyk official **command-line interface** (**CLI**) using
    **Node Package Manager** (**npm**), as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 **Node 包管理器** (**npm**) 安装 Snyk 官方 **命令行界面** (**CLI**)，如下所示：
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, associate your Snyk account with the CLI by running the following command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过运行以下命令将您的 Snyk 账户与 CLI 关联：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding command will open a browser tab and redirect you to authenticate
    the CLI with your Snyk account.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述命令将打开一个浏览器标签页，并重定向您使用 Snyk 账户验证 CLI。
- en: 'Now, you should be ready to scan the project vulnerabilities with the following
    command:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您应该准备好使用以下命令扫描项目漏洞：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding command will list all identified vulnerabilities (major or minor),
    including their path and remediation guidance, as illustrated in the following
    screenshot:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述命令将列出所有识别出的漏洞（主要或次要），包括它们的路径和修复指南，如下截图所示：
- en: '![Figure 7.12 – Snyk vulnerability findings'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.12 – Snyk 漏洞发现'
- en: '](img/Figure_7.12_B17115.jpg)'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.12_B17115.jpg)'
- en: Figure 7.12 – Snyk vulnerability findings
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.12 – Snyk 漏洞发现
- en: According to the output, Snyk identified two major issues. One of them is with
    the current version of the Gin framework. Click on the `Info` URL—you will be
    redirected to a dedicated page where you can learn more about the vulnerability,
    as illustrated in the following screenshot:![Figure 7.13 – HTTP Response Splitting
    page
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据输出，Snyk 识别出两个主要问题。其中一个是与当前版本的 Gin 框架有关。点击 `Info` URL—you will be redirected
    to a dedicated page where you can learn more about the vulnerability, as illustrated
    in the following screenshot:![图 7.13 – HTTP 响应拆分页面
- en: '](img/Figure_7.13_B17115.jpg)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.13_B17115.jpg)'
- en: Figure 7.13 – HTTP Response Splitting page
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.13 – HTTP 响应拆分页面
- en: 'Most security vulnerabilities can be fixed by upgrading the packages to the
    latest stable version. Run the following command to upgrade your project dependencies:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数安全漏洞可以通过升级到最新稳定版本来解决。运行以下命令升级您的项目依赖项：
- en: '[PRE23]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Figure 7.14 – Upgrading Go packages'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.14 – 升级 Go 包'
- en: '](img/Figure_7.14_B17115.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.14_B17115.jpg)'
- en: Figure 7.14 – Upgrading Go packages
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 升级 Go 包
- en: 'For the spotted vulnerabilities, there''s an open pull request on GitHub that
    is merged and available in the Gin 1.7 version, as illustrated in the following
    screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于发现的漏洞，GitHub 上有一个已合并并可在 Gin 1.7 版本中找到的公开拉取请求，如下截图所示：
- en: '![Figure 7.15 – Vulnerability fix'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.15 – 漏洞修复'
- en: '](img/Figure_7.15_B17115.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.15_B17115.jpg)'
- en: Figure 7.15 – Vulnerability fix
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 漏洞修复
- en: That's it—you now know how to scan your Go modules with Snyk as well!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了——现在您已经知道如何使用 Snyk 扫描您的 Go 模块了！
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We'll cover how to embed Snyk in the **continuous integration/continuous deployment**
    (**CI/CD**) pipeline in [*Chapter 9*](B17115_09_Final_JM_ePub.xhtml#_idTextAnchor146)*,
    Implementing a CI/CD pipeline*, to continuously inspect the application's source
    code for security vulnerabilities.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 9 章*](B17115_09_Final_JM_ePub.xhtml#_idTextAnchor146)*，实现 CI/CD 流水线*
    中介绍如何将 Snyk 集成到 **持续集成/持续部署** (**CI/CD**) 流水线中，以持续检查应用程序的源代码中的安全漏洞。
- en: Running Postman collections
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Postman 集合
- en: Throughout the book, you have learned how to use the **Postman** REST client
    to test out the API endpoints. In addition to sending API requests, Postman can
    be used to build test suites by defining a group of API requests within a collection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您已经学习了如何使用 **Postman** REST 客户端测试 API 端点。除了发送 API 请求外，Postman 还可以通过在集合中定义一组
    API 请求来构建测试套件。
- en: 'To set this up, proceed as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置此功能，请按照以下步骤操作：
- en: Open the Postman client and click on the **New** button from the header bar,
    then select **Collection**, as illustrated in the following screenshot:![Figure
    7.16 – New Postman collection
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Postman客户端，然后从标题栏点击**新建**按钮，然后选择**集合**，如图下所示截图：![图7.16 – 新建Postman集合
- en: '](img/Figure_7.16_B17115.jpg)'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.16_B17115.jpg)'
- en: Figure 7.16 – New Postman collection
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.16 – 新建Postman集合
- en: A new window will pop up— name your collection `Recipes API` and click on the
    `List Recipes`, as illustrated in the following screenshot:![Figure 7.17 – New
    request
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹出一个新窗口——将集合命名为`Recipes API`，然后点击`List Recipes`，如图下所示截图：![图7.17 – 新建请求
- en: '](img/Figure_7.17_B17115.jpg)'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.17_B17115.jpg)'
- en: Figure 7.17 – New request
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.17 – 新建请求
- en: Click on the `http://localhost:8080/recipes` in the address bar and select a
    `GET` method.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地址栏中点击`http://localhost:8080/recipes`并选择`GET`方法。
- en: All right—now, once that is done, you will write some JavaScript code in the
    **Tests** section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——现在，一旦完成这些，你将在**测试**部分编写一些JavaScript代码。
- en: In Postman, you can write JavaScript code that will be executed before sending
    a request (pre-request script) or after receiving a response. Let's explore how
    to achieve that in the next section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman中，你可以编写将在发送请求之前（预请求脚本）或接收响应之后执行的JavaScript代码。让我们在下一节中探讨如何实现这一点。
- en: Scripting in Postman
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Postman中的脚本编写
- en: Test scripts can be used to test whether your API is working accordingly or
    not or to check that new features have not affected any functionality of existing
    requests.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本可以用来测试你的API是否按预期工作，或者检查新功能是否影响了现有请求的功能。
- en: 'To write a script, proceed as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写脚本，请按以下步骤操作：
- en: 'Click on the **Tests** section and paste the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**测试**部分，粘贴以下代码：
- en: '[PRE24]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The script will check if the number of recipes returned by the API requests
    is equal to 10 recipes, as illustrated in the following screenshot:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 脚本将检查API请求返回的菜谱数量是否等于10个菜谱，如图下所示截图：
- en: '![Figure 7.18 – Scripting in Postman'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.18 – Postman中的脚本编写'
- en: '](img/Figure_7.18_B17115.jpg)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.18_B17115.jpg)'
- en: Figure 7.18 – Scripting in Postman
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.18 – Postman中的脚本编写
- en: 'Press the **Send** button and check the Postman console, which is shown in
    the following screenshot:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**按钮，并检查Postman控制台，如图下所示截图：
- en: '![Figure 7.19 – Running a test script'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.19 – 运行测试脚本'
- en: '](img/Figure_7.19_B17115.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.19_B17115.jpg)'
- en: Figure 7.19 – Running a test script
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 – 运行测试脚本
- en: You can see in *Figure 7.19* that the test script has passed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*图7.19*中看到测试脚本已通过。
- en: You may have noticed that the API URL is hardcoded in the address bar. While
    this is working fine, if you're maintaining multiple environments (sandbox, staging,
    and production), you'll need some way to test your API endpoints without duplicating
    your collection requests. Luckily, you can create environment variables in Postman.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到API URL硬编码在地址栏中。虽然这样工作得很好，但如果你在维护多个环境（沙盒、预发布和生产），你需要一种方式来测试你的API端点而不必复制你的集合请求。幸运的是，你可以在Postman中创建环境变量。
- en: 'To use the URL parameter, proceed as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用URL参数，请按以下步骤操作：
- en: Click the *eye* icon available in the top-right corner and click on `http://localhost:8080`,
    as illustrated in the following screenshot. Click on **Save**:![Figure 7.20 –
    Environment variables
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的*眼睛*图标，然后点击`http://localhost:8080`，如图下所示截图。点击**保存**：![图7.20 – 环境变量
- en: '](img/Figure_7.20_B17115.jpg)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.20_B17115.jpg)'
- en: Figure 7.20 – Environment variables
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.20 – 环境变量
- en: Go back to your `GET` request and use the following URL variable. Make sure
    to select the **Testing** environment from the drop-down menu in the top-right
    corner, as illustrated in the following screenshot:![Figure 7.21 – Parameterizing
    request
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你的`GET`请求，并使用以下URL变量。确保从右上角的下拉菜单中选择**测试**环境，如图下所示截图：![图7.21 – 参数化请求
- en: '](img/Figure_7.21_B17115.jpg)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.21_B17115.jpg)'
- en: Figure 7.21 – Parameterizing request
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.21 – 参数化请求
- en: 'Now, go ahead and add another test script for the API request. The following
    script will look for a particular recipe in the response payload:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，继续添加另一个API请求的测试脚本。以下脚本将在响应负载中查找特定的菜谱：
- en: '[PRE25]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Press the **Send** button, and both test scripts should be successful, as depicted
    here:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**按钮，两个测试脚本都应成功，如图所示：
- en: '![Figure 7.22 – Running multiple test scripts'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.22 – 运行多个测试脚本'
- en: '](img/Figure_7.22_B17115.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.22_B17115.jpg)'
- en: Figure 7.22 – Running multiple test scripts
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22 – 运行多个测试脚本
- en: You can now define multiple test case scenarios for your API endpoints.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以为您的API端点定义多个测试用例场景。
- en: 'Let''s take this further and create another API request, this time for the
    endpoint responsible for adding a new recipe, as illustrated in the following
    screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，创建另一个API请求，这次是为添加新食谱的端点，如下面的截图所示：
- en: '![Figure 7.23 – New recipe request'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.23 – 新食谱请求'
- en: '](img/Figure_7.23_B17115.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.23_B17115.jpg](img/Figure_7.23_B17115.jpg)'
- en: Figure 7.23 – New recipe request
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.23 – 新食谱请求
- en: 'To do so, proceed as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请按照以下步骤操作：
- en: 'Define a test script to check if the HTTP status code returned upon successful
    insert operation is a `200-OK` code, as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个测试脚本，以检查在成功插入操作返回的HTTP状态码是否为`200-OK`代码，如下所示：
- en: '[PRE26]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define another one to check if the ID of inserted is a string of 24 characters,
    as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个来检查插入的ID是否为24个字符的字符串，如下所示：
- en: '[PRE27]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Click the `401 – Unauthorized`, which is normal because the endpoint expects
    an authorization header in the HTTP request. You can see the output in the following
    screenshot:![Figure 7.24 – 401 Unauthorized response
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`401 – Unauthorized`，这是正常的，因为端点期望在HTTP请求中有一个授权头。您可以在以下截图中看到输出：![Figure 7.24
    – 401 Unauthorized response
- en: '](img/Figure_7.24_B17115.jpg)'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 7.24_B17115.jpg](img/Figure_7.24_B17115.jpg)'
- en: Figure 7.24 – 401 Unauthorized response
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.24 – 401未授权响应
- en: Note
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about API authentication, head back to [*Chapter 4*](B17115_04_Final_JM_ePub.xhtml#_idTextAnchor073),
    *Building API Authentication*, for a step-by-step guide.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要了解更多关于API认证的信息，请回到[*第4章*](B17115_04_Final_JM_ePub.xhtml#_idTextAnchor073)，*构建API认证*，以获取逐步指南。
- en: Add an `Authorization` header with a valid **JSON Web Token** (**JWT**). This
    time, the test scripts pass successfully!
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个有效的**JSON Web Token**（**JWT**）的`Authorization`头。这次，测试脚本成功通过！
- en: You now have two different API requests in a collection. Run the collection
    by clicking on the **Run** button. A new window will pop up, as illustrated in
    the following screenshot:![Figure 7.25 – Collection Runner
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在在集合中有两个不同的API请求。通过点击**运行**按钮来运行集合。将弹出一个新窗口，如下面的截图所示：![Figure 7.25 – 集合运行器
- en: '](img/Figure_7.25_B17115.jpg)'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 7.25_B17115.jpg](img/Figure_7.25_B17115.jpg)'
- en: Figure 7.25 – Collection Runner
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.25 – 集合运行器
- en: Click on the **Run Recipes API** button, and both API requests will be executed
    sequentially, as illustrated in the following screenshot:![](img/Figure_7.26_B17115.jpg)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行食谱API**按钮，两个API请求将按顺序执行，如下面的截图所示！![Figure 7.26_B17115.jpg](img/Figure_7.26_B17115.jpg)
- en: Figure 7.26 – Run Results screen
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.26 – 运行结果屏幕
- en: 'You can export the collection and all API requests by clicking the **Export**
    button. A JSON file should be created with the following structure:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过点击**导出**按钮导出集合和所有API请求。应该会创建一个具有以下结构的JSON文件：
- en: '[PRE28]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the Postman collection exported, you can run it from the terminal using
    **Newman** ([https://github.com/postmanlabs/newman](https://github.com/postmanlabs/newman)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 导出Postman集合后，您可以使用**Newman**从终端运行它（[https://github.com/postmanlabs/newman](https://github.com/postmanlabs/newman)）。
- en: In the next section, we will run the previous Postman collection with the Newman
    CLI.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用Newman CLI运行之前的Postman集合。
- en: Running collections with Newman
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Newman运行集合
- en: With all tests being defined, let's execute them using the Newman command line.
    It's worth mentioning that you can take this further and run those tests within
    your CI/CD workflow as post-integration tests to ensure the new API changes and
    that the features are not generating any regression.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有测试后，让我们使用Newman命令行执行它们。值得一提的是，您可以将这些测试进一步运行在您的CI/CD工作流程中作为后集成测试，以确保新的API更改并且功能没有生成任何回归。
- en: 'To get started, proceed as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请按照以下步骤操作：
- en: 'Install **Newman** with npm. Here, we are using version 5.2.2:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用npm安装**Newman**。这里我们使用版本5.2.2：
- en: '[PRE29]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once installed, run Newman with the exported collection file as an argument,
    as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，使用导出的集合文件作为参数运行Newman，如下所示：
- en: '[PRE30]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The API requests should fail because the URL parameter isn''t being defined,
    as illustrated in the following screenshot:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于URL参数没有被定义，API请求应该失败，如下面的截图所示：
- en: '![Figure 7.27 – Collection with failing tests'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 7.27 – 包含失败测试的集合'
- en: '](img/Figure_7.27_B17115.jpg)'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 7.27_B17115.jpg](img/Figure_7.27_B17115.jpg)'
- en: Figure 7.27 – Collection with failing tests
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.27 – 包含失败测试的集合
- en: 'You can set its value using a `--env-var` flag, as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`--env-var`标志来设置其值，如下所示：
- en: '[PRE31]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This should be the output if all calls are passed:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果所有调用都通过，则应该是以下输出：
- en: '![Figure 7.28 – Collection with successful tests'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.28 – 包含成功测试的集合'
- en: '](img/Figure_7.28_B17115.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.28_B17115.jpg](img/Figure_7.28_B17115.jpg)'
- en: Figure 7.28 – Collection with successful tests
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28 – 成功测试的集合
- en: You should now be able to automate your API endpoints testing with Postman.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够使用Postman自动化API端点测试。
- en: Note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In [*Chapter 10*](B17115_10_Final_JM_ePub.xhtml#_idTextAnchor160)*, Capturing
    Gin Application Metrics*, we will cover how to trigger `newman` `run` commands
    within a CI/CD pipeline upon a successful application release.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B17115_10_Final_JM_ePub.xhtml#_idTextAnchor160)“捕获Gin应用程序指标”中，我们将介绍如何在CI/CD管道中成功发布应用程序后触发`newman`
    `run`命令。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how to run different automated tests for a
    Gin web application. You have also explored how to integrate external tools such
    as Gosec and Snyk to inspect code quality, detect bugs, and find potential security
    vulnerabilities.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何为Gin Web应用程序运行不同的自动化测试。你还探讨了如何集成外部工具，如Gosec和Snyk，以检查代码质量、检测错误和发现潜在的安全漏洞。
- en: In the next chapter, we will cover our distributed web application on the cloud,
    mainly on **Amazon Web Services** (**AWS**) using Docker and Kubernetes. You should
    now be able to ship an almost bug-free applications and spot potential security
    vulnerabilities ahead of releasing new features to production.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍我们在云上的分布式Web应用程序，主要使用Docker和Kubernetes在**Amazon Web Services**（**AWS**）上。你现在应该能够发布几乎无错误的程序，并在发布新功能到生产环境之前发现潜在的安全漏洞。
- en: Questions
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Write a unit test for the `UpdateRecipeHandler` HTTP handler.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`UpdateRecipeHandler` HTTP处理器编写单元测试。
- en: Write a unit test for the `DeleteRecipeHandler` HTTP handler.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`DeleteRecipeHandler` HTTP处理器编写单元测试。
- en: Write a unit test for the `FindRecipeHandler` HTTP handler.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`FindRecipeHandler` HTTP处理器编写单元测试。
- en: Further reading
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Go Design Patterns* by Mario Castro Contreras, Packt Publishing'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 《*Go设计模式*》由Mario Castro Contreras著，Packt Publishing出版
