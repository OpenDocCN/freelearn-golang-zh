- en: 'Chapter 7: Testing Gin HTTP Routes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to test a Gin web-based application, which
    involves running Go unit and integration tests. Along the way, we will explore
    how to integrate external tools to identify potential security vulnerabilities
    within your Gin web application. Finally, we will cover how to test the **API**
    **HTTP** methods using the Postman Collection Runner feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing Gin HTTP handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating code coverage reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering security vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Postman collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to write, execute, and automate
    tests for a Gin web application from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A complete understanding of the previous chapter—this chapter is a follow-up
    of the previous one and it will use the same source code. Hence, some snippets
    won't be explained, to avoid repetition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previous experience using the Go testing package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter07](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Testing Gin HTTP handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how to design, build, and scale a distributed web application
    with Gin framework. In this chapter, we will cover how to integrate different
    types of tests to eliminate possible errors at release. We will start with **unit
    testing**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It's worth mentioning that you need to adopt a **test-driven development** (**TDD**)
    approach beforehand to get a head start in writing testable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how to write a unit test for a Gin web application, you need
    to dive right into a basic example. Let''s take the `hello world` example covered
    in [*Chapter 2*](B17115_02_Final_JM_ePub.xhtml#_idTextAnchor037), *Setting up
    API Endpoints*. The router declaration and HTTP server setup have been extracted
    from the `main` function to prepare for the tests, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application, then issue a `GET` request on `localhost:8080`. A `hello
    world` message will be returned, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the refactoring being done, write a unit test in the Go programming language.
    To do so, apply the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `main_test.go` file with the following code in the same project directory.
    The `SetupServer()` method we previously refactored is injected into a test server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each test method must start with a `Test` prefix—so, for example, `TestXYZ`
    will be a valid test. The previous code sets up a test server using the Gin engine
    and issues a `GET` request. Then, it checks the status code and response payload.
    If the actual results don't match the expected results, an error will be thrown.
    Hence, the test will fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run tests in Golang, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The test will be successful, as seen in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Test execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Test execution
  prefs: []
  type: TYPE_NORMAL
- en: 'While you have the ability to write complete tests with the testing package,
    you can install a third-party package such as **testify** to use advanced assertions.
    To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download testify with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update `TestIndexHandler` to use the `assert` property from the testify
    package to make some assertions about the correctness of the response, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute the `go test` command and you will have the same results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's how you write a test for a Gin web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move forward and write unit tests for the HTTP handlers of the RESTful
    API covered in previous chapters. As a reminder, the following schema illustrates
    the operations exposed by the REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – API HTTP methods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – API HTTP methods
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The API source code is available on the GitHub repository under the `chapter07`
    folder. It's recommended to start this chapter based on the source code available
    in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operations in the image are registered in the Gin default router and assigned
    to different HTTP handlers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Start with a `main_test.go` file, and define a method to return an instance
    of the Gin router. Then, write a test method for each HTTP handler. For instance,
    the `TestListRecipesHandler` handler is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It registers the `ListRecipesHandler` handler on the `GET /recipes` resource,
    then it issues a `GET` request. The request payload is then encoded into a `recipes`
    slice. If the number of recipes is equal to `492` and the status code is a `200-OK`
    response, then the test is considered successful. Otherwise, an error will be
    thrown, and the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, issue a `go test` command, but this time, disable the Gin debug logs
    and enable verbose mode with a `–v` flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The command output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Running tests with verbose output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Running tests with verbose output
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B17115_10_Final_JM_ePub.xhtml#_idTextAnchor160)*, Capturing
    Gin Application Metrics*, we will cover how to customize the Gin debug logs and
    how to ship them into a centralized logging platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, write a test for the `NewRecipeHandler` handler. It will simply
    post a new recipe and check if the returned response code is a `200-OK` status.
    The `TestNewRecipeHandler` method is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test method, you declared a recipe using the `Recipe` structure.
    The struct is then marshaled into `NewRequest` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the tests, and both `TestListRecipesHandler` and `TestNewRecipeHandler`
    should be successful, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Running multiple tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Running multiple tests
  prefs: []
  type: TYPE_NORMAL
- en: You are now familiar with writing unit tests for Gin HTTP handlers. Go ahead
    and write the tests for the rest of the API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Generating code coverage reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover how to generate **coverage reports** with Go.
    Test coverage describes how much of a package's code is exercised by running the
    package's tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to generate a file that holds statistics about how
    much code is being covered by the tests you''ve written in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will run the tests and display the percentage of statements covered
    with those tests. In the following example, we''re covering 16.9% of statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Test coverage'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.5_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Test coverage
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated `coverage.out` file contains the number of lines covered by the
    unit tests. The full code has been cropped for brevity, but you can see an illustration
    of this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can visualize the code coverage using a `go tool` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will open the HTML presentation on your default browser, showing
    the covered source code in green and the uncovered code in red, as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Viewing results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.6_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Viewing results
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that it''s easier to spot which methods are covered with your tests, let''s
    write an additional test for the HTTP handler, responsible for updating an existing
    recipe. To do so, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code block to the `main_test.go` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code issues two HTTP `PUT` requests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One of these has a valid recipe ID and checks for the HTTP response code (`200-OK`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The other has an invalid recipe ID and checks for the HTTP response code (`404-Not
    found`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Re-execute the tests, and the coverage percentage should increase from 16.9%
    to 39.0%. The following output confirms this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.7 – More code coverage'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.7_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – More code coverage
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! You are now able to run unit tests and get code coverage reports. So,
    go forth, test, and cover.
  prefs: []
  type: TYPE_NORMAL
- en: While unit tests are an important part of software development, it is equally
    important that the code you write is not just tested in isolation. Integration
    and end-to-end tests give you that extra confidence by testing parts of your application
    together. These parts may work just fine on their own, but in a large system,
    units of code rarely work separately. That's why, in the next section, we will
    cover how to write and run integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Performing integration tests with Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of **integration tests** is to verify that separated developed components
    work together properly. Unlike unit tests, integration tests can depend on databases
    and external services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The distributed web application written so far interacts with the external
    services MongoDB and Reddit, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Distributed web application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.8_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Distributed web application
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with integration tests, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the needed services for our integration tests with Docker Compose. The
    following `docker-compose.yml` file will start a MongoDB and Redis container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, test each endpoint exposed by the RESTful API. For example, to test out
    the endpoint responsible for listing all recipes, we can use the following code
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run tests, provide the MongoDB `go test` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Great! The test will pass successfully, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Running integration tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.9_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – Running integration tests
  prefs: []
  type: TYPE_NORMAL
- en: The test issues a `GET` request on the `/recipes` endpoint and verifies if the
    number of recipes returned by the endpoint is equal to 10.
  prefs: []
  type: TYPE_NORMAL
- en: Another important but neglected test is the **security test**. It's mandatory
    to ensure your application is free from major security vulnerabilities, otherwise
    risks of data breaches and data leaks are high.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering security vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many tools that help in identifying major security vulnerabilities
    in your Gin web application. In this section, we will cover two tools, out of
    a few, that you can adopt while building a Gin application: **Snyk** and **Golang
    Security Checker** (**Gosec**).'
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will demonstrate how to use these tools to inspect
    security vulnerabilities in a Gin application.
  prefs: []
  type: TYPE_NORMAL
- en: Gosec
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Gosec** is a tool written in Golang that inspects the source code for security
    problems by scanning the Go **abstract syntax tree** (**AST**). Before we inspect
    the Gin application code, we need to install the Gosec binary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The binary can be downloaded with the following cURL command. Here, version
    2.7.0 is being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the command is installed, run the following command on your project folder.
    The `./...` argument is set to recursively scan all the Go packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will identify three major issues related to unhandled errors (**Common
    Weakness Enumeration** (**CWE**) *703* (https://cwe.mitre.org/data/definitions/703.html),
    as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Unhandled errors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Unhandled errors
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Gosec will scan your project and validate it against the rules.
    However, it''s possible to exclude some rules. For instance, to exclude the rule
    responsible for the Errors unhandled issue, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete list of available rules can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/securego/gosec#available-rules](https://github.com/securego/gosec#available-rules)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Excluding Gosec rules'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Excluding Gosec rules
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to scan your application source code for potential security
    vulnerabilities or sources of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Go modules with Snyk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to detect potential security vulnerabilities is by scanning the
    Go modules. The `go.mod` file holds all the dependencies used by the Gin web application.
    **Snyk** ([https://snyk.io](https://snyk.io)) is a **software-as-a-service** (**SaaS**)
    solution used to identify and fix security vulnerabilities in your Go application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Snyk supports all main programming languages including Java, Python, Node.js,
    Ruby, Scala, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is pretty simple. To get started, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a free account by signing in with your GitHub account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, install the Snyk official **command-line interface** (**CLI**) using
    **Node Package Manager** (**npm**), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, associate your Snyk account with the CLI by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command will open a browser tab and redirect you to authenticate
    the CLI with your Snyk account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you should be ready to scan the project vulnerabilities with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command will list all identified vulnerabilities (major or minor),
    including their path and remediation guidance, as illustrated in the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Snyk vulnerability findings'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.12 – Snyk vulnerability findings
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: According to the output, Snyk identified two major issues. One of them is with
    the current version of the Gin framework. Click on the `Info` URL—you will be
    redirected to a dedicated page where you can learn more about the vulnerability,
    as illustrated in the following screenshot:![Figure 7.13 – HTTP Response Splitting
    page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.13_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.13 – HTTP Response Splitting page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Most security vulnerabilities can be fixed by upgrading the packages to the
    latest stable version. Run the following command to upgrade your project dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 7.14 – Upgrading Go packages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.14_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.14 – Upgrading Go packages
  prefs: []
  type: TYPE_NORMAL
- en: 'For the spotted vulnerabilities, there''s an open pull request on GitHub that
    is merged and available in the Gin 1.7 version, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Vulnerability fix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.15_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.15 – Vulnerability fix
  prefs: []
  type: TYPE_NORMAL
- en: That's it—you now know how to scan your Go modules with Snyk as well!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We'll cover how to embed Snyk in the **continuous integration/continuous deployment**
    (**CI/CD**) pipeline in [*Chapter 9*](B17115_09_Final_JM_ePub.xhtml#_idTextAnchor146)*,
    Implementing a CI/CD pipeline*, to continuously inspect the application's source
    code for security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Running Postman collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, you have learned how to use the **Postman** REST client
    to test out the API endpoints. In addition to sending API requests, Postman can
    be used to build test suites by defining a group of API requests within a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set this up, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Postman client and click on the **New** button from the header bar,
    then select **Collection**, as illustrated in the following screenshot:![Figure
    7.16 – New Postman collection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.16_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.16 – New Postman collection
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A new window will pop up— name your collection `Recipes API` and click on the
    `List Recipes`, as illustrated in the following screenshot:![Figure 7.17 – New
    request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.17_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.17 – New request
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the `http://localhost:8080/recipes` in the address bar and select a
    `GET` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All right—now, once that is done, you will write some JavaScript code in the
    **Tests** section.
  prefs: []
  type: TYPE_NORMAL
- en: In Postman, you can write JavaScript code that will be executed before sending
    a request (pre-request script) or after receiving a response. Let's explore how
    to achieve that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting in Postman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test scripts can be used to test whether your API is working accordingly or
    not or to check that new features have not affected any functionality of existing
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a script, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Tests** section and paste the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The script will check if the number of recipes returned by the API requests
    is equal to 10 recipes, as illustrated in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.18 – Scripting in Postman'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.18_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.18 – Scripting in Postman
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Press the **Send** button and check the Postman console, which is shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Running a test script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.19_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.19 – Running a test script
  prefs: []
  type: TYPE_NORMAL
- en: You can see in *Figure 7.19* that the test script has passed.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the API URL is hardcoded in the address bar. While
    this is working fine, if you're maintaining multiple environments (sandbox, staging,
    and production), you'll need some way to test your API endpoints without duplicating
    your collection requests. Luckily, you can create environment variables in Postman.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the URL parameter, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the *eye* icon available in the top-right corner and click on `http://localhost:8080`,
    as illustrated in the following screenshot. Click on **Save**:![Figure 7.20 –
    Environment variables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.20_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.20 – Environment variables
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go back to your `GET` request and use the following URL variable. Make sure
    to select the **Testing** environment from the drop-down menu in the top-right
    corner, as illustrated in the following screenshot:![Figure 7.21 – Parameterizing
    request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.21_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.21 – Parameterizing request
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, go ahead and add another test script for the API request. The following
    script will look for a particular recipe in the response payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Press the **Send** button, and both test scripts should be successful, as depicted
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Running multiple test scripts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.22_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.22 – Running multiple test scripts
  prefs: []
  type: TYPE_NORMAL
- en: You can now define multiple test case scenarios for your API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take this further and create another API request, this time for the
    endpoint responsible for adding a new recipe, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23 – New recipe request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.23_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.23 – New recipe request
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a test script to check if the HTTP status code returned upon successful
    insert operation is a `200-OK` code, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define another one to check if the ID of inserted is a string of 24 characters,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click the `401 – Unauthorized`, which is normal because the endpoint expects
    an authorization header in the HTTP request. You can see the output in the following
    screenshot:![Figure 7.24 – 401 Unauthorized response
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.24_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.24 – 401 Unauthorized response
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To learn more about API authentication, head back to [*Chapter 4*](B17115_04_Final_JM_ePub.xhtml#_idTextAnchor073),
    *Building API Authentication*, for a step-by-step guide.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add an `Authorization` header with a valid **JSON Web Token** (**JWT**). This
    time, the test scripts pass successfully!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now have two different API requests in a collection. Run the collection
    by clicking on the **Run** button. A new window will pop up, as illustrated in
    the following screenshot:![Figure 7.25 – Collection Runner
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.25_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.25 – Collection Runner
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Run Recipes API** button, and both API requests will be executed
    sequentially, as illustrated in the following screenshot:![](img/Figure_7.26_B17115.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 7.26 – Run Results screen
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can export the collection and all API requests by clicking the **Export**
    button. A JSON file should be created with the following structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the Postman collection exported, you can run it from the terminal using
    **Newman** ([https://github.com/postmanlabs/newman](https://github.com/postmanlabs/newman)).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will run the previous Postman collection with the Newman
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Running collections with Newman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all tests being defined, let's execute them using the Newman command line.
    It's worth mentioning that you can take this further and run those tests within
    your CI/CD workflow as post-integration tests to ensure the new API changes and
    that the features are not generating any regression.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install **Newman** with npm. Here, we are using version 5.2.2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once installed, run Newman with the exported collection file as an argument,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The API requests should fail because the URL parameter isn''t being defined,
    as illustrated in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.27 – Collection with failing tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.27_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.27 – Collection with failing tests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can set its value using a `--env-var` flag, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should be the output if all calls are passed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.28 – Collection with successful tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.28_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.28 – Collection with successful tests
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to automate your API endpoints testing with Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B17115_10_Final_JM_ePub.xhtml#_idTextAnchor160)*, Capturing
    Gin Application Metrics*, we will cover how to trigger `newman` `run` commands
    within a CI/CD pipeline upon a successful application release.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to run different automated tests for a
    Gin web application. You have also explored how to integrate external tools such
    as Gosec and Snyk to inspect code quality, detect bugs, and find potential security
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover our distributed web application on the cloud,
    mainly on **Amazon Web Services** (**AWS**) using Docker and Kubernetes. You should
    now be able to ship an almost bug-free applications and spot potential security
    vulnerabilities ahead of releasing new features to production.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a unit test for the `UpdateRecipeHandler` HTTP handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a unit test for the `DeleteRecipeHandler` HTTP handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a unit test for the `FindRecipeHandler` HTTP handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Go Design Patterns* by Mario Castro Contreras, Packt Publishing'
  prefs: []
  type: TYPE_NORMAL
