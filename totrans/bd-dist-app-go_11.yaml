- en: 'Chapter 8: Deploying the Application on AWS'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will teach you how to deploy the **API** on **Amazon Web Services**
    (**AWS**). It also goes on to explain how to serve the application through **HTTPS**
    using a custom domain name, and scale the Gin-based API on Kubernetes and **Amazon
    Elastic Container Service** (**Amazon ECS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, we will focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Gin web application on an **Amazon Elastic Compute Cloud** (**Amazon
    EC2**) instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying on Amazon **ECS** (**Elastic Container Service**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying on Kubernetes with **Amazon Elastic Kubernetes Service** (**Amazon
    EKS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A complete understanding of the previous chapter—this chapter is a follow-up
    to the previous one and it will use the same source code. Hence, some snippets
    won't be explained, to avoid repetition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previous experience of using AWS is mandatory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic understanding of Kubernetes is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter08](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying on EC2 instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the course of the book, you have learned how to build a distributed
    web application using the Gin framework and how to scale the API for loading and
    testing it locally. In this section, we will cover how to deploy the following
    architecture on the cloud and serve it to external users.
  prefs: []
  type: TYPE_NORMAL
- en: 'An overview of the application architecture can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Application architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17115_08_01_v2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Application architecture
  prefs: []
  type: TYPE_NORMAL
- en: AWS is the leader when it comes to cloud providers—it offers a huge range of
    infrastructure services such as load balancers, servers, databases, and network
    services.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, create an AWS account ([https://aws.amazon.com](https://aws.amazon.com)).
    Most AWS services offer an abundance of Free Tier resources, so deploying your
    application will cost you little or nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Launching an EC2 instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the AWS account created, you are now ready to launch an EC2 instance.
    To do so, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the **AWS Management Console** ([https://console.aws.amazon.com](https://console.aws.amazon.com))
    and search for **EC2**. In the **EC2** dashboard, click on the **Launch Instance**
    button to provision a new EC2 instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Amazon Linux 2 AMI** as an **Amazon Machine Image** (**AMI**). This
    is the **operating system** (**OS**) that will run the EC2 instance. The following
    screenshot provides an overview of this:![Figure 8.2 – AMI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17115_08_02_v2.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.2 – AMI
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, select an instance type. You can start with a `t2.micro` instance and
    upgrade later if needed. Then, click on **Configure Instance Details** and leave
    the settings at their defaults, as illustrated in the following screenshot:![Figure
    8.3 – Instance configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17115_08_03_v2.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.3 – Instance configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, click on the `GP2` to `GP3` or provisioned IOPS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: MongoDB requires fast storage. Therefore, if you're planning to host a MongoDB
    container on EC2, an EBS-optimized type can improve the **input/output** (**I/O**)
    operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, click on `Name=application-sg`, as illustrated in the following screenshot.
    Leave the security group at its default setting (allow inbound traffic on port
    22 for SSH). Then, click on **Review and launch**:![Figure 8.4 – Security group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17115_08_04_v2.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.4 – Security group
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As a best practice, you should always restrict **Secure Shell** (**SSH**) solely
    to known static **Internet Protocol** (**IP**) addresses or networks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on **Launch** and assign a key pair or create a new SSH key pair. Then,
    click on **Create instance**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Head back to the **Instances** dashboard by clicking on the **View instances**
    button—it will take a few seconds for the instance to be up and running but you
    should then see it on the screen, as per the following screenshot:![Figure 8.5
    – EC2 dashboard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.5_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.5 – EC2 dashboard
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the instance is ready, open your terminal session and SSH to the instance
    using the public `key.pem` with your SSH key pair, as illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A confirmation message will appear—enter `Yes`. Then, issue the following commands
    to install Git, `sudo su` command is used to provide the privileges at the root
    level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we are using the Docker `19.03.13-ce` and Docker Compose `1.29.0` versions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Docker version'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.6_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Docker version
  prefs: []
  type: TYPE_NORMAL
- en: You have successfully provisioned and launched an EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the EC2 instance up and running, you can deploy your **Docker Compose**
    stack covered in [*Chapter 6*](B17115_06_Final_JM_ePub.xhtml#_idTextAnchor103),
    *Scaling a Gin Application*. To do so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the following GitHub repository, which includes the components and files
    for the distributed Gin web application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'version: "3.9"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'services:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'api:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image: api'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'environment:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- MONGO_URI=mongodb://admin:password'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@mongodb:27017/test?authSource=admin'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '&readPreference=primary&ssl=false'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- MONGO_DATABASE=demo'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- REDIS_URI=redis:6379'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'external_links:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- mongodb'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- redis'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'scale: 5'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'dashboard:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image: dashboard'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'redis:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image: redis'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mongodb:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image: mongo:4.4.3'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'environment:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- MONGO_INITDB_ROOT_USERNAME=admin'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- MONGO_INITDB_ROOT_PASSWORD=password'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'nginx:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image: nginx'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ports:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- 80:80'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'volumes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- $PWD/nginx.conf:/etc/nginx/nginx.conf'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'depends_on:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- api'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- dashboard'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before deploying the stack, build the Docker images for the RESTful API and
    the web dashboard. Head to the corresponding folder of each service and run the
    `docker build` command. For instance, the following commands are used to build
    the Docker image for the RESTful API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The command output is shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Docker build logs'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.7_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.7 – Docker build logs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After building the images, issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The services will be deployed, and five instances of the API will be created,
    as illustrated in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Docker application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.8_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Docker application
  prefs: []
  type: TYPE_NORMAL
- en: 'With the application up and running, go to the web browser and paste the IP
    address that is used to connect to your EC2 instance. You should then see the
    following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Request timeout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.9_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – Request timeout
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix that, you need to allow inbound traffic on port 80, which is the port
    the nginx proxy is exposed to. Head to **Security Groups** from the EC2 dashboard
    and search for the security group assigned to the EC2 instance in which the application
    is running. Once found, add an inbound rule, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Inbound rule on port 80'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.10_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Inbound rule on port 80
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to your web browser and issue an HTTP request to the instance IP.
    This time, the nginx proxy will be hit and a response will be returned. If you
    issue a request to the `/api/recipes` endpoint, an empty array should be returned,
    as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – RESTful API response'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.11_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – RESTful API response
  prefs: []
  type: TYPE_NORMAL
- en: 'The MongoDB `recipes` collection is empty. So, create a new recipe by issuing
    a `POST` request on the `/api/recipes` endpoint with the following JSON payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – A POST request to create a new recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.12_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – A POST request to create a new recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to include an `Authorization` header in the `POST` request. Refresh
    the web browser page and a recipe should then be returned on the web dashboard,
    as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – New recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.13_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – New recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click on the **Login** button, and you should have an unsecure origin
    error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Auth0 requires the client to be run though HTTPS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.14_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Auth0 requires the client to be run though HTTPS
  prefs: []
  type: TYPE_NORMAL
- en: The error is due to Auth0 needing to be run on a web application served through
    the HTTPS protocol. You can serve the application through HTTPS by setting up
    a **load balancer** on top of the EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: SSL offloading with an application load balancer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the API through HTTPS, we need a **Secure Sockets Layer** (**SSL**)
    certificate. You can easily get an SSL certificate with **AWS Certificate Manager**
    (**ACM**). This service makes it easy to provision, manage, and deploy SSL/**Transport
    Layer Security** (**TLS**) certificates on AWS-managed resources. To generate
    an SSL certificate, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Head to the ACM dashboard and request a free SSL certificate for your domain
    name by clicking on the **Request a certificate** button and choosing **Request
    a public certificate**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `domain.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `domain.com` domain name can have multiple subdomains, such as `sandbox.domain.com`,
    `production.domain.com`, and `api.domain.com`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the **Select validation method** page, choose **DNS validation** and add
    a **Canonical Name** (**CNAME**) record provided by ACM to your **Domain Name
    System** (**DNS**) configuration. Issuing public certificates might take a few
    minutes, but once the domain name is validated, the certificate will be issued
    and will appear in the ACM dashboard with the status set to **Issued**, as illustrated
    in the following screenshot:![Figure 8.15 – Requesting a public certificate with
    ACM
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.15_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.15 – Requesting a public certificate with ACM
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, create an application load balancer from the **Load Balancers** section
    within the EC2 dashboard, as illustrated in the following screenshot:![Figure
    8.16 – Application load balancer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.16_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.16 – Application load balancer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the subsequent page, enter a name for the load balancer and specify the scheme
    as **Internet facing** from the drop-down list. In the **Availability Zones**
    section, select a subnet from each **availability zone** (**AZ**) for resiliency.
    Then, under the **Listeners** section, add an HTTPS listener and an HTTP listener
    on ports 443 and 80, respectively, as illustrated in the following screenshot:![Figure
    8.17 – HTTP and HTTPS listeners
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17115_08_17_v2.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.17 – HTTP and HTTPS listeners
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Configure Security Settings** button to proceed and select the
    certificate created in ACM from the drop-down list, as illustrated in the following
    screenshot:![Figure 8.18 – Certificate configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17115_08_18_v2.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.18 – Certificate configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, click on **Configure Routing** and create a new target group called **application**.
    Ensure the protocol is set to HTTP and the port to 80 because the nginx proxy
    is listening on port 80\. With this configuration, traffic between the load balancer
    and the instance will be transmitted using HTTP, even for HTTPS requests made
    by the client to the load balancer. You can see the configuration in the following
    screenshot:![Figure 8.19 – Configuring a target group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17115_08_19_v2.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.19 – Configuring a target group
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `HTTP` and the path as `/api/recipes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Register Targets**, select the EC2 instance on which the application
    is running, and click on **Add to registered**, as follows:![Figure 8.20 – Registering
    an EC2 instance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.20_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.20 – Registering an EC2 instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you have finished selecting instances, choose **Next: Review**. Review
    the settings that you selected and click on the **Create** button. The provisioning
    process should take a few minutes, but you should then see a screen like this:![Figure
    8.21 – Load balancer DNS name'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.21_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.21 – Load balancer DNS name
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the state is `A` record that points to the public DNS name of the load
    balancer in Route 53 ([https://aws.amazon.com/route53/](https://aws.amazon.com/route53/))
    or in your DNS registrar, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Route 53 new A record'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.22_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – Route 53 new A record
  prefs: []
  type: TYPE_NORMAL
- en: Once you make the necessary changes, it can take up to 48 hours for the change
    to propagate across other DNS servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the changes to your domain name record have propagated by browsing
    to [HTTPS://recipes.domain.com](HTTPS://recipes.domain.com). This should result
    in the load balancer displaying the secure web dashboard of the application. Click
    on the *padlock* icon in the browser address bar and it should display the details
    of the domain and the SSL certificate, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – Serving through HTTPS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.23_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – Serving through HTTPS
  prefs: []
  type: TYPE_NORMAL
- en: Your application load balancer has now been configured with an SSL certificate
    for your Gin application running on AWS. You can use the Auth0 service to sign
    in and add new recipes from the web dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying on Amazon ECS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we learned how to deploy an EC2 instance and configure
    it to run our Gin application on it. In this section, we will learn how to get
    the same results without managing an EC2 instance. AWS proposes two container
    orchestration services: **ECS** and **EKS**.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn about ECS, which is a fully managed container
    orchestration service. Before deploying our application to ECS, we need to store
    the application Docker images in a remote repository. That's where an **Elastic
    Container Registry** (**ECR**) repository comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Storing images in a private repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ECR is a widely used private Docker registry. To store images in a private
    repository, you need to create a repository in ECR first. To achieve that, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Jump to the ECR dashboard from the `mlabouardy/recipes-api` as a name for your
    Gin RESTful API repository, as illustrated in the following screenshot:![Figure
    8.24 – New ECR repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.24_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.24 – New ECR repository
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can host your Docker images in Docker Hub. If you go with this approach,
    you can skip this part.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Create repository** button, and then select the repository and
    click on **View push commands**. Copy the commands to authenticate and push the
    API image to the repository, as illustrated in the following screenshot:![Figure
    8.25 – ECR login and push commands
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.25_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.25 – ECR login and push commands
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For a step-by-step guide on how to install the AWS **command-line interface**
    (**CLI**), refer to the official documentation at [https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Follow the commands shown in *Figure 8.25* to authenticate with ECR. Tag the
    image and push it to the remote repository, as follows (substitute the `ID`, `REGION`,
    and `USER` variables with your own values):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The command logs are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.26 – Pushing an image to ECR'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.26_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.26 – Pushing an image to ECR
  prefs: []
  type: TYPE_NORMAL
- en: 'The image will now be available on ECR, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27 – Image stored on ECR'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.27_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.27 – Image stored on ECR
  prefs: []
  type: TYPE_NORMAL
- en: With the Docker image stored in ECR, you can go ahead and deploy the application
    in ECS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, update the `docker-compose.yml` file to reference the ECR repository URI
    in the `image` section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating an ECS cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `docker-compose.yml` file now references the images stored in ECR. We're
    ready to spin up the ECS cluster and deploy the application on it.
  prefs: []
  type: TYPE_NORMAL
- en: You can deploy an ECS cluster either manually from the **AWS Management Console**
    or through the AWS ECS CLI. Follow the official instructions to install the Amazon
    ECS CLI based on your OS from [https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_CLI_installation.htm](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_CLI_installation.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, configure the Amazon ECS CLI by providing the AWS credentials
    and the AWS region in which to create the cluster, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before provisioning an ECS cluster, define a task execution `IAM` role to allow
    the Amazon ECS container agent to make AWS API calls on our behalf. Create a file
    named `task-execution-assule-role.json` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a task execution role using the JSON file, and attach the `AmazonECSTaskExecutionRolePolicy`
    task execution role policy to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Complete the configuration with the following command, the default cluster
    name, and launch type. Then, create an Amazon ECS cluster with the `ecs-cli` `up`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This command may take a few minutes to complete as your resources (EC2 instances,
    load balancers, security groups, and so on) are created. The output of this command
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.28 – Creating an ECS cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.28_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.28 – Creating an ECS cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'Jump to the ECS dashboard—the sandbox cluster should be up and running, as
    it is in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.29 – Sandbox cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.29_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.29 – Sandbox cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy the application, you can use the `docker-compose` file provided in
    the previous section. In addition to that, there are certain parameters specific
    to Amazon ECS that you need to provide in the config file, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subnets**: To be replaced with a list of public subnets where the EC2 instances
    should be deployed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security group and resource usage**: **Central processing unit** (**CPU**)
    and memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create an `ecs-params.yml` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, deploy the `docker compose` file to the cluster with the following command.
    The `--create-log-groups` option creates the CloudWatch log groups for the container
    logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The deployment logs are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.30 – Task deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.30_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.30 – Task deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'An `application` task will be created. A **task** is a set of metadata (memory,
    CPU, port mapping, environment variables) that describes how a container should
    be deployed. You can see an overview of this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.31 – Task definition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.31_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.31 – Task definition
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the AWS CLI, add a security group rule to allow inbound traffic on port
    80, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Issue the following command to view the containers that are running in ECS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The command will list the containers running and also the IP address and port
    of the nginx service. If you point your web browser at that address, you should
    see the web dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Great! You now have a running ECS cluster with the Dockerized Gin application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying on Kubernetes with Amazon EKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ECS might be a good solution for beginners and small workloads. However, for
    large deployment and at a certain scale, you might want to consider shifting to
    Kubernetes (also known as **K8s**). For those of you who are AWS power users,
    Amazon EKS is a natural fit.
  prefs: []
  type: TYPE_NORMAL
- en: AWS offers a managed Kubernetes solution under the EKS service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we need to deploy an EKS cluster, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Jump to the EKS dashboard and create a new cluster with the following parameters:![Figure
    8.32 – EKS cluster creation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.32_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.32 – EKS cluster creation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The cluster `IAM` role should include the following `AmazonEKSWorkerNodePolicy`,
    `AmazonEKS_CNI_Policy`, and `AmazonEC2ContainerRegistryReadOnly`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the **Specify networking** page, select an existing **virtual private cloud**
    (**VPC**) to use for the cluster and subnets, as illustrated in the following
    screenshot. Leave the rest at their default settings:![Figure 8.33 – EKS network
    configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.33_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.33 – EKS network configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For cluster endpoint access, enable public access for simplicity. For a production
    usage, restrict access to your network **Classless Inter-Domain Routing** (**CIDR**)
    or enable only private access to the cluster API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, on the **Configure Logging** page, enable all log types to be able to
    troubleshoot or debug network issues from the CloudWatch console easily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the information and click on `eksctl`, head over to the official guide
    at [https://docs.aws.amazon.com/eks/latest/userguide/create-cluster.html](https://docs.aws.amazon.com/eks/latest/userguide/create-cluster.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the cluster is in an **Active** state, create a managed Node Group on which
    the containers will be running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the cluster name and select the `workers` and create a Node IAM role,
    as illustrated in the following screenshot:![Figure 8.35 – EKS Node Group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.35_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.35 – EKS Node Group
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For more information on how to configure a Node Group, refer to the official
    documentation at [https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html#create-worker-node-role](https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html#create-worker-node-role).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the subsequent page, choose `Amazon Linux 2` as an AMI and select `t3.medium`
    `On-Demand` instances, as illustrated in the following screenshot:![Figure 8.36
    – Workers configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.36_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.36 – Workers configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For a production usage, you might use `Spot-Instances` instead of `On-Demand`.
    `Spot-Instances` usually comes with a good discount in price because of possibile
    spontaneous interruptions. Those interruptions can be gracefully handled by Kubernetes,
    leaving you with extra money.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following figure shows how configuration is scaled:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.37 – Scaling configuration'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.37_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.37 – Scaling configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, specify the subnets where the two nodes will be deployed. On the **Review
    and create** page, review your managed Node Group configuration and click on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you've provisioned your EKS cluster, you need to configure `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring kubectl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`kubectl` is a command-line utility for communicating with the cluster API
    server. To install the utility, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this book, we are using the latest version of `kubectl`, which is 1.21.0,
    as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, generate a `kubeconfig` file with the needed credentials for `kubectl`
    to interact with the EKS cluster, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now test the credentials by listing the nodes of the cluster with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will list two nodes as expected, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.38 – EKS nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.38_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.38 – EKS nodes
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! You have successfully configured `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've set up your EKS cluster, to run services on Kubernetes, you
    will need to translate your `compose service` definition to Kubernetes objects.
    **Kompose** is an open source tool that can speed up the translation process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing multiple Kubernetes **YAML Ain't Markup Language** (**YAML**)
    files, you can package your whole application in a Helm chart ([https://docs.helm.sh/](https://docs.helm.sh/))
    and store it in a remote registry for distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating a Docker Compose workflow to Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kompose is an open source tool that converts `docker-compose.yml` files into
    Kubernetes deployment files. To get started with Kompose, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the project''s GitHub release page ([https://github.com/kubernetes/kompose/releases](https://github.com/kubernetes/kompose/releases))
    and download the binary based on your OS. Here, version 1.22.0 is used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With Kompose installed, convert your service definitions with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After running this command, Kompose will output information about the files
    it has created, as follows:![Figure 8.39 – Translating Docker Compose to Kubernetes
    resources with Kompose
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.39_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create Kubernetes objects and test whether your application is working
    as expected by issuing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output, indicating that the objects have been created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.40 – Deployments and services'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.40_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.40 – Deployments and services
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To check that your Pods are running, deploy the Kubernetes dashboard with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create an `eks-admin` service account and cluster role binding that you
    can use to securely connect to the dashboard with admin-level permissions, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the content in an `eks-admin-service-account.yml` file and apply the service
    account to your cluster with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before connecting to the dashboard, retrieve an authentication token with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s how the Kubernetes dashboard token looks like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.41 – Kubernetes dashboard token'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.41_B17115.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.41 – Kubernetes dashboard token
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the proxy locally with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to `http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#!/login`
    and paste the authentication token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should be redirected to the dashboard where you can view the distributed
    application containers, as well as their metrics and status, as illustrated in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.42 – Kubernetes dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.42_B17115.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.42 – Kubernetes dashboard
  prefs: []
  type: TYPE_NORMAL
- en: You can monitor your application running in EKS easily and scale the API Pods
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When you're done experimenting with EKS, it's a good idea to remove all the
    resources you created so that AWS doesn't charge you for them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to run a Gin web application on AWS using the
    Amazon EC2 service and how to serve it though HTTPS with an application load balancer
    and ACM.
  prefs: []
  type: TYPE_NORMAL
- en: You have also explored how to deploy the application to a managed cluster with
    ECS without managing the underlying EC2 nodes. Along the way, you covered how
    to store the Docker images in a remote registry with ECR, and how to deploy the
    application for scale with Amazon EKS.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will see how to automate the deployment of your Gin
    application on AWS with a **continuous integration/continuous deployment** (**CI/CD**)
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How will you configure a persistent volume for MongoDB container data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy RabbitMQ on AWS EC2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create MongoDB credentials with Kubernetes Secrets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale the API pods with `kubectl` to five instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Docker for Developers,* by Richard Bullington-McGuire, Andrew K. Dennis, and
    Michael Schwartz. Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Kubernetes – Third Edition,* by Gigi Sayfan. Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Docker on Amazon Web Services,* by Justin Menga. Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
