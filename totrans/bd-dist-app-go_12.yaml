- en: 'Chapter 9: Implementing a CI/CD Pipeline'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：实现CI/CD管道
- en: This chapter will show you how to build a CI/CD workflow to automate the deployment
    of a Gin service. We will also discuss the importance of embracing a GitFlow approach
    while building a Gin-based API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何构建一个CI/CD工作流程来自动化Gin服务的部署。我们还将讨论在构建基于Gin的API时采用GitFlow方法的重要性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring CI/CD practices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索CI/CD实践
- en: Building a continuous integration workflow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建持续集成工作流程
- en: Maintaining multiple runtime environments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护多个运行时环境
- en: Implementing continuous delivery
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现持续交付
- en: By the end of this chapter, you will be able to automate the test, build, and
    deploy process of a Gin web application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够自动化Gin网络应用的测试、构建和部署过程。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the content in this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章的内容，您需要以下条件：
- en: A complete understanding of the previous chapter. This chapter is a follow-up
    of the previous one as it will be using the same source code. Hence, some snippets
    won't be explained to avoid repetition.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对上一章内容的完整理解。本章是上一章的后续，因为它将使用相同的源代码。因此，为了避免重复，一些代码片段将不会进行解释。
- en: Previous experience with CI/CD practices is highly recommended so that you can
    follow this chapter with ease.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐您有CI/CD实践的前期经验，这样您就可以轻松地跟随本章内容。
- en: The code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter09](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter09).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包托管在GitHub上，网址为[https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter09](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter09)。
- en: Exploring CI/CD practices
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索CI/CD实践
- en: In the previous chapters, you learned how to design, build, and deploy a Gin
    web application on AWS. Currently, deploying new changes can be a time-consuming
    process. When deploying to an EC2 instance, Kubernetes, or **Platform as a Service**
    (**PaaS**), there are manual steps involved that help the new changes be pushed
    out of the door.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您学习了如何在AWS上设计、构建和部署Gin网络应用。目前，部署新更改可能是一个耗时的过程。当部署到EC2实例、Kubernetes或**平台即服务**（**PaaS**）时，涉及一些手动步骤，这些步骤有助于将新更改推出去。
- en: Luckily, many of these deployment steps can be automated, thus saving development
    time, removing possibilities for human errors, and reducing release cycle times.
    That's why in this section, you will learn how to embrace **continuous integration**
    (**CI**), **continuous deployment** (**CD**) and **continuous delivery** to accelerate
    the **time to market** (**TTM**) of your application, as well as to ensure high-quality
    features shipment through each iteration. But first, what do these practices mean?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，许多这些部署步骤可以自动化，从而节省开发时间，消除人为错误的可能性，并减少发布周期时间。这就是为什么在本节中，您将学习如何采用**持续集成**（**CI**）、**持续部署**（**CD**）和**持续交付**来加速您应用程序的**上市时间**（**TTM**），以及确保每个迭代都发送高质量的功能。但首先，这些实践意味着什么？
- en: Continuous integration
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成
- en: '**Continuous integration** (**CI**) is the process of having a centralized
    code repository (for example, GitHub, Bitbucket, GitLab, and so on) and making
    all the changes and features go through a pipeline before integrating them into
    the remote repository. A classic pipeline triggers a build whenever a code commit
    (or push event) occurs, runs pre-integrations tests, builds the artifact (for
    example, Docker image, JAR, an npm package, and so on), and pushes the results
    into a private registry for versioning:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）是一个拥有集中式代码仓库（例如，GitHub、Bitbucket、GitLab等）的过程，并且所有更改和功能在集成到远程仓库之前都需要通过一个管道。一个经典的管道会在代码提交（或推送事件）发生时触发构建，运行预集成测试，构建工件（例如，Docker镜像、JAR、npm包等），并将结果推送到私有注册库进行版本控制：'
- en: '![Figure 9.1 – CI/CD practices'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – CI/CD实践'
- en: '](img/Figure_9.1_B17115.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – CI/CD实践](img/Figure_9.1_B17115.jpg)'
- en: Figure 9.1 – CI/CD practices
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – CI/CD实践
- en: 'As shown in the preceding diagram, the CI workflow consists of the following
    stages: **Checkout**, **Test**, **Build**, and **Push**.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，CI工作流程包括以下阶段：**检出**、**测试**、**构建**和**推送**。
- en: Continuous deployment
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续部署
- en: '**Continuous deployment** (**CD**), on the other hand, is an extension of the
    CI workflow. Every change that passes through all the stages of the CI pipeline
    is released automatically placed onto a staging or preprod environment, where
    the QA team can run validation and acceptance tests.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Continuous delivery** is similar to CD but requires human intervention or
    business validation before you can deploy the new release to a production environment.
    This human involvement could include manual deployment, which is typically performed
    by a QA engineer, or something as simple as clicking a button. This differs from
    CD, where every successful build is released to the staging environment.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Embracing these three practices can help in improving the code's quality and
    testability, and also helps reduce the risk of shipping broken releases to production.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand what these three components are, by the end of this
    chapter, you will be able to build an end-to-end deployment process for our Gin
    web application, similar to the one shown in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – CI/CD pipeline'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B17115.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – CI/CD pipeline
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding pipeline is divided into the following stages:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkout**: Pulls the latest changes from the project''s GitHub repository.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test**: Runs unit and quality tests within a Docker container.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: Compiles and builds a Docker image from a Dockerfile.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push**: Tags the image and stores it in a private registry.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy**: Deploys and promotes the changes to an AWS environment (EC2, EKS,
    or ECS).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We're using CircleCI as a CI server, but the same workflow can be implemented
    with other CI solutions such as Jenkins, Travis CI, GitHub Actions, and so on.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Building a CI workflow
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application we built for this book is versioned in a GitHub repository.
    This repository uses the GitFlow model as a branching strategy, where three main
    branches are used. Each branch represents a runtime environment for the application:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Master branch**: This branch corresponds to the code running in the production
    environment.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preprod branch**: The staging environment – a mirror of the production environment.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Develop branch**: The sandbox or development environment.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To promote the application from one environment to another, you can create **feature
    branches**. You can also create **hotfix branches** for major bugs or issues.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about GitFlow workflows and best practices, check out the official
    documentation: [https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows what your Project''s GitHub repository would look
    like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Project''s GitHub repository'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.3_B17115.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Project's GitHub repository
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be using **CircleCI** to automate the CI/CD workflow. If you don''t
    have a CircleCI account already, sign up for free using your GitHub account at
    https://circleci.com. The principles of CI/CD remain the same, regardless of the
    CI server:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – CircleCI landing page'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.4_B17115.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – CircleCI landing page
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Once you've signed up, you need to configure CircleCI to run the application
    tests and build the Docker image. To do so, you need to describe all the steps
    in a template file and save it within the code's GitHub repository. This approach
    is called **Pipeline as Code**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline as Code
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a CircleCI build is triggered, it looks for a `.circleci/config.yml` file.
    This file contains the instructions to be executed on the CI server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a `.circleci` folder and a `.config.yml` file with the following
    content:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code snippet will run the workflow inside an environment powered
    by a Golang v1.15.6 Docker image. Most of the CI/CD steps will be performed with
    Docker, which makes running builds locally a breeze and keeps our options open
    if we want to migrate to a different CI server in the future (versus vendor lock-in).
    The first job to be run is the test stage, which consists of the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `test` job will fetch the latest changes from this project''s GitHub repository
    using the `checkout` instruction. Then, it will download the project dependencies
    and cache them for future usage (to reduce the workflow duration), after which,
    it will run a series of tests:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '**Code linting**: This checks if the code respects standard coding conventions.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit tests**: This executes the unit tests we wrote in previous chapters.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the CircleCI config ready, let''s create a project on CircleCI for the
    Gin application. To do so, follow these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Jump to the CircleCI console and click on **Set up Project**, next to the project's
    repository:![Figure 9.5 – Setting up a CircleCI project
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.5_B17115.jpg)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.5 – Setting up a CircleCI project
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Use Existing Config** button, since we already have a CircleCI
    configuration, and click on **Start Building**:![Figure 9.6 – CircleCI configuration
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.6_B17115.jpg)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.6 – CircleCI configuration
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A new pipeline will start; however, it will fail due to no `config.yml` file
    existing in the code repository. This error is shown in the following screenshot:![Figure
    9.7 – Pipeline failed
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.7_B17115.jpg)'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.7 – Pipeline failed
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Push the CircleCI configuration to the GitHub repository on the develop branch
    by running the following commands:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A new pipeline will be triggered automatically. The output will be something
    similar to the following:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Pipeline has been triggered automatically'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_9.8_B17115.jpg)'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.8 – Pipeline has been triggered automatically
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the `config.yml` file. All the tests will pass, and you will be able
    to build your Docker image:![Figure 9.9 – Running automated tests
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.9_B17115.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.9 – Running automated tests
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It''s worth mentioning that the pipeline was triggered automatically because
    upon setting up the CircleCI project, a webhook was created automatically in the
    project''s GitHub repository. This way, for each push event, a notification is
    sent to CircleCI servers to trigger the corresponding CircleCI pipeline:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.10 – GitHub Webhook'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_9.10_B17115.jpg)'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.10 – GitHub Webhook
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's move on to the next step of integrating the application by building a
    Docker image.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a `build` job to the CI/CD workflow:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `build` job is responsible for building a Docker image based on our `Dockerfile`,
    which is stored within the code repository. Then, it tags the built image and
    stores it in a remote Docker registry for versioning:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you're interested in the Dockerfile, you can find it in this book's GitHub
    repository at [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter10/Dockerfile](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter10/Dockerfile).
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To tag the image, we will be using semantic versioning ([https://semver.org](https://semver.org)).
    The version''s format is three digits, separated by a dot:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Semantic versioning'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_9.11_B17115.jpg)'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.11 – Semantic versioning
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The major version is increased when new changes break the API (backward-incompatible
    changes). The minor version is incremented when new features are released, while
    the patch version is incremented with bug fixes.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the CircleCI configuration, you're using the `$CIRCLE_BUILD_NUM` environment
    variable to create a unique version for each Docker image that's built via the
    development cycle of our Gin application. Another alternative is using the `CIRCLE_SHA1`
    variable, which is the SHA1 hash of the Git commit that triggered the CI build.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the image has been tagged, store it in a private registry. In the previous
    example, you were using an **Elastic Container Registry** (**ECR**) as a private
    repository, but another solution such as DockerHub can be used as well.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Push the changes to the develop branch with the following command:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A new pipeline will be triggered. Once the `test` job has completed, the `build`
    job will be executed, as shown in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Running a "build" job'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.12_B17115.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – Running a "build" job
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the `build` job''s steps. The test should fail at the **Push
    image** step because CircleCI wasn''t able to push the image to ECR due to a lack
    of AWS permissions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Push image step'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.13_B17115.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – Push image step
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see how you can configure your CI and CD workflows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: To allow CircleCI to interact with your ECR repository, create a dedicated IAM
    user with proper IAM policies.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jump to the AWS Management Console ([https://console.aws.amazon.com/](https://console.aws.amazon.com/))
    and navigate to the **Identity and Access Management** (**IAM**) console. Then,
    create a new IAM user for CircleCI. Check the **Programmatic access** box, as
    shown in the following screenshot:![Figure 9.14 – CircleCI IAM user
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.14_B17115.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.14 – CircleCI IAM user
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Attach the following IAM policy to the IAM user. This statement allows CircleCI
    to push a Docker image to the ECR repository. Make sure that you substitute `ID`
    as needed:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once the IAM user has been created, create an access key from the **Security
    credentials** tab. Then, head back to the CircleCI dashboard and jump to **Project
    Settings**:![Figure 9.15 – CircleCI environment variables
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.15_B17115.jpg)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.15 – CircleCI environment variables
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Under the **Environment Variables** section, click on the **Add Environment
    Variable** button and add the following variables:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**AWS_ACCESS_KEY_ID**: Specifies an AWS access key associated with the CircleCI
    IAM user.'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**AWS_SECRET_ACCESS_KEY**: Specifies an AWS secret access key associated with
    the CircleCI IAM user.'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**AWS_DEFAULT_REGION**: Specifies the AWS region where the ECR repository is
    located:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.16 – AWS credentials as environment variables'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_9.16_B17115.jpg)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.16 – AWS credentials as environment variables
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the environment variables have been set up, update the CircleCI configuration
    by adding an instruction to authenticate with ECR, before executing the `docker
    push` commands. The new changes will look as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Substitute the `USER`, `ID`, and `REGION` variables appropriately with your
    own values and, once again, push the changes to the remote repository, under the
    develop branch:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similar to the previous jobs, add a `deploy` job to the current workflow:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `deploy` job will simply use the `docker-compose.yml` file we covered in
    the previous chapter to deploy the application stack on an EC2 instance. The file
    will look as follows (the full YAML file has been cropped for brevity):'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To deploy the new changes to the EC2 instance where the containers are running,
    you will have to SSH to the remote server and issue two `docker-compose` commands
    – `pull` and `up`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Make sure that you substitute the `IP` variable with the IP or the DNS name
    of the EC2 instance where the sandbox environment is running.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To SSH to the EC2 instance, add the SSH key pair you used to deploy the EC2
    instance in AWS to your CircleCI project settings. Under **SSH Keys**, click on
    **Add SSH Key** and paste the content of the SSH key pair:![Figure 9.20 – Adding
    an SSH key pair
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.20_B17115.jpg)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.20 – Adding an SSH key pair
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Commit and push the new CircleCI config to GitHub with the following commands:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A new pipeline will be triggered, and the test, build, and deploy jobs will
    be executed sequentially. At the end of the **deploy** job, the newly built image
    will be deployed to the sandbox environment:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Continuous deployment'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.21_B17115.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.21 – Continuous deployment
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re running **Elastic Container Service** (**ECS**), you can force ECS
    to pull the new image with the following CircleCI config:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you assign ECS permissions to the CircleCI IAM user to perform
    the task update successfully.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The major change is that we're using CircleCI orbs instead of Docker images
    as a runtime environment. By using orbs, we can use pre-built commands, which
    reduces the lines of code in our config file. The deploy job will deploy the updated
    image to a sandbox ECS cluster.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re running Kubernetes, you can use the following CircleCI specification
    file to update the image:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With your CI and CD workflows configured, you can test them out by building
    a new feature for the Gin RESTful API. You can do so by implementing the following
    steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `main.go` file and expose a new endpoint on the `/version` resource
    using the Gin router. The endpoint will display the running API version:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The HTTP handler is self-explanatory; it returns the value of the `API_VERSION`
    environment variable:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To inject the environment variable dynamically, you can use the Docker arguments
    feature, which allows you to pass values at build time. Update our `Dockerfile`
    and declare `API_VERSION` as a build argument and environment variable:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, update the `Build image` step by injecting the `$TAG` variable as a value
    for the `API_VERSION` build argument:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Push the new changes to the develop branch with the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To test out the new changes, navigate to the instance IP address and point
    your browser to the `/api/version` resource path:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.23 – API running version'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.23_B17115.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.23 – API running version
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: This will return the version of the running Docker image of the Gin RESTful
    API.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth mentioning that the current CirlceCI config doesn''t guarantee
    the jobs will always run in the same order (test -> build -> deploy). To maintain
    the CI/CD order, use the `requires` keyword, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This way, you can ensure the deploy job is only executed if both the test and
    build jobs are successful:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – CI/CD workflow'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.24_B17115.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.24 – CI/CD workflow
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! Now, we have a complete CI/CD pipeline for our Gin application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining multiple runtime environments
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a real-world scenario, you'll need multiple environments to avoid pushing
    broken features or major bugs to a sandbox or staging environment (or worse, a
    production environment) before validating them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create an EC2 instance to host the staging environment by running a
    new EC2 instance based on the sandbox environment we created in previous chapters:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Select the **sandbox** instance and click on **Actions** from the action bar.
    Then, click on **Launch more like this** from the **Image and template** drop-down
    list:![Figure 9.25 – Replicating the sandbox environment
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.25_B17115.jpg)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.25 – Replicating the sandbox environment
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This option will automatically populate the Amazon EC2 launch wizard with configuration
    details from the selected instance.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Update the `Name` tag value to `staging` and click on **Launch** to provision
    the instance:![Figure 9.26 – Staging environment running in an EC2 instance
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.26_B17115.jpg)'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.26 – Staging environment running in an EC2 instance
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the instance is up and running, update CircleCI so that it tags the Docker
    image based on the branch name where the pipeline is running. In addition to the
    `dynamic` tag we created via the `CIRCLE_BUILD_NUM` environment variable, push
    a `fixed` tag (develop, preprod, or master) if the current branch is either develop,
    preprod, or master:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, update the `deploy` job so that you can SSH it to the right EC2 instance
    IP address based on the current Git branch name:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The IP addresses (`IP_PROD`, `IP_STAGING`, and `IP_SANDBOX`) should be defined
    as environment variables in the CircleCI project's settings.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, update the workflow so that it deploys the changes, but only if the
    current Git branch is a `develop`, `preprod`, or `master` branch:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Commit and store the changes in GitHub using the following commands:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A new pipeline will be triggered automatically on the develop branch, where
    the changes will be deployed to a sandbox environment:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.27 – Deploying to a sandbox environment'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.27_B17115.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.27 – Deploying to a sandbox environment
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Once the new changes have been validated in the sandbox environment, you should
    be ready to promote the code to the staging environment.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy to the staging environment, follow these steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Create a **pull request** (**PR**) to merge the develop branch into the preprod
    branch, as follows:![Figure 9.28 – Creating a pull request
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.28_B17115.jpg)'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.28 – Creating a pull request
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Notice that the PR is ready to be merged because all the checks have passed:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.29 – Successful Git checks'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_9.29_B17115.jpg)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.29 – Successful Git checks
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Merge pull request** button. A new pipeline will be triggered
    on the preprod branch and three jobs – **test**, **build**, and **deploy** – will
    be executed one by one:![Figure 9.30 – Deploying to a staging environment
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.30_B17115.jpg)'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.30 – Deploying to a staging environment
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the end of the **build** stage, a new image from the preprod branch, as well
    as its CircleCI build number, will be stored in the ECR repository, as follows:![Figure
    9.31 – Preprod Docker image
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.31_B17115.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.31 – Preprod Docker image
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, deploy the image to the staging environment using the `docker-compose
    up` command. Hit the IP address of the staging environment; you should see the
    version of the running Docker image:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.32 – Docker image version.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.32_B17115.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.32 – Docker image version.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Great! You now have a staging environment where you can validate your API functionalities
    before promoting them to production.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have learned how to achieve continuous deployment via a push event.
    However, in a production environment, you might want to add extra validation before
    shipping a new release to production. That's where **continuous delivery practices**
    come into play.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Implementing continuous delivery
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To deploy the Gin application to production, you need to spin up a dedicated
    EC2 instance or EKS cluster. You must ask for manual validation before deploying
    to production.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'With CircleCI, you can use the `pause_workflow` job to interact with the user
    and ask for approval before resuming the pipeline. To do so, follow these steps:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `pause_workflow` job before the `deploy` job and define a `release`
    job, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Push the changes to the develop branch. A new pipeline will be triggered and
    the changes will be deployed to your sandbox environment. Next, create a pull
    request and merge the develop and preprod branches. Now, raise a pull request
    to merge the preprod branch and the master branch:![Figure 9.33 – Pull request
    to merge into the master branch
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.33_B17115.jpg)'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.33 – Pull request to merge into the master branch
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the PR has been merged, a new pipeline will be triggered on the master
    branch and both the test and build jobs will be executed:![Figure 9.34 – Running
    a CI/CD workflow on the master branch
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.34_B17115.jpg)'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.34 – Running a CI/CD workflow on the master branch
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the `pause_workflow` job is reached, the pipeline will be paused, as follows:![Figure
    9.35 – Asking the user for approval
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.35_B17115.jpg)'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.35 – Asking the user for approval
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you click on the **pause_workflow** box, a confirmation dialog will pop up,
    where you can allow the workflow to continue running:![Figure 9.36 – Approving
    the deployment
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.36_B17115.jpg)'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.36 – Approving the deployment
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once approved, the pipeline will resume, and the deploy stage will be executed.
    At the end of the CI/CD pipeline, the application will be deployed into a production
    environment:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.37 – Deploying an application to production'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.37_B17115.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.37 – Deploying an application to production
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! With that, you have achieved continuous delivery!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Before wrapping up, you can improve the workflow by adding a **Slack** notification
    to raise awareness within the development team when a new build is being triggered
    on CircleCI.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Improving the feedback loop with Slack
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the **Slack RESTful API** to post a notification on a Slack channel
    or use the CircleCI Slack orb with pre-built Slack commands to improve the feedback
    loop.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, follow these steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code block to the `test` job:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, create a new Slack application on your Slack workspace by navigating to
    [https://api.slack.com/apps](https://api.slack.com/apps) and clicking on **Build
    app** from the page's header:![Figure 9.38 – New Slack application
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.38_B17115.jpg)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.38 – New Slack application
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Give the application a meaningful name and click on the **Create App** button.
    On the **OAuth & Permissions** page, add the following permissions under **Bot
    Token Scopes**:![Figure 9.39 – Slack bot permissions
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.39_B17115.jpg)'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.39 – Slack bot permissions
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the left navigation menu, click on **OAuth & Permissions** and copy the
    OAuth token:![Figure 9.40 – Bot user OAuth token
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.40_B17115.jpg)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.40 – Bot user OAuth token
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go back to the CircleCI project settings and add the following environment
    variables:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SLACK_ACCESS_TOKEN**: The OAuth Token we generated previously.'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**SLACK_DEFAULT_CHANNEL**: The Slack channel where you want to post CircleCI
    build notifications.'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.41 – Slack environment variables'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_9.41_B17115.jpg)'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.41 – Slack environment variables
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Push the new CircleCI config updates to GitHub. At this point, a new pipeline
    will be executed:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.42 – Slack notification when the pipeline starts'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.42_B17115.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.42 – Slack notification when the pipeline starts
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'A Slack notification will be sent on the configured Slack channel containing
    the name of the project and the name of the Git branch:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.43 – Sending a Slack notification'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.43_B17115.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.43 – Sending a Slack notification
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'You can take this even further and send a notification based on the pipeline''s
    status. For instance, add the following code if you want to be alerted when the
    pipeline fails (the full JSON has been cropped for brevity):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can simulate a pipeline failure by throwing an error with a code error
    different than `0`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, push the changes to the develop branch. When the pipeline reaches the
    `Unit tests` step, an error will be thrown, and the pipeline will fail:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.44 – Throwing an error programmatically'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.44_B17115.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.44 – Throwing an error programmatically
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Slack channel, you should receive a notification similar to the one
    shown in the following screenshot:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.45 – Sending a notification when the pipeline fails'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.45_B17115.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.45 – Sending a notification when the pipeline fails
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: That's pretty much it. This chapter has merely scratched the surface of what
    can be done with the CI/CD pipeline. However, it should provide enough of a foundation
    for you to start experimenting and building your own end-to-end workflows for
    your Gin applications.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to set up a CI/CD pipeline from scratch to
    automate the deployment process of a Gin application with CircleCI. Additionally,
    using CircleCI orbs improves productivity by simplifying how we write our Pipeline
    as Code configuration.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: You also explored how to run automated tests with Docker and how to achieve
    continuous deployment with GitFlow and multiple AWS environments. Along the way,
    you set up Slack notifications so that you're alerted about a build failure or
    success.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The final chapter in this book will cover how to troubleshoot and debug Gin
    applications running in production.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build a CI/CD pipeline to automate the deployment process for the React web
    application we built in [*Chapter 5*](B17115_05_Final_JM_ePub.xhtml#_idTextAnchor088),
    *Serving Static HTML in Gin*.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Slack notification for when a successful production deployment is made.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Hands-On Serverless Applications with Go* by Mohamed Labouardy, Packt publishing'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementing DevOps with AWS* by Salle Ingle, Packt publishing'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
