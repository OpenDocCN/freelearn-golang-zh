<html><head></head><body>
		<div id="_idContainer395">
			<h1 id="_idParaDest-166"><a id="_idTextAnchor173"/>Assessments</h1>
			<p>This section contains answers to the questions from all chapters.</p>
			<h1 id="_idParaDest-167"><em class="italic"><a id="_idTextAnchor174"/></em><a href="B17115_01_Final_JM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a> – Getting started with Gin</h1>
			<ol>
				<li><strong class="bold">Golang</strong> is currently one of the fastest growing programming languages in the software development industry. It is a lightweight, open-source language suited for today's microservices architectures.</li>
				<li>Multiple web frameworks exist, the most popular are <strong class="bold">Gin</strong>, <strong class="bold">Martini</strong>, and <strong class="bold">Gorilla</strong>.</li>
				<li>A Go module is a way to group together a set of packages and give it a version number to mark its existence at a specific point in time.</li>
				<li>The default port of an HTTP server backed by Gin framework is <strong class="source-inline">8080</strong>.</li>
				<li>You can use the <strong class="source-inline">c.JSON()</strong> or <strong class="source-inline">c.XML()</strong> methods to return literal JSON or XML structs.</li>
			</ol>
			<h1 id="_idParaDest-168"><em class="italic"><a id="_idTextAnchor175"/></em><a href="B17115_02_Final_JM_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a> – Setting up API Endpoints</h1>
			<ol>
				<li value="1"><strong class="bold">GitFlow</strong> is a branching strategy that developers can follow when using version control. To apply the GitFlow model, you need a central Git repository with two main branches: <p> <strong class="bold">Master</strong>: It stores the official release history.</p><p> <strong class="bold">Develop</strong>: It serves as an integration branch for features.</p></li>
				<li>A model is a normal structs with basic Go types. To declare a struct in Go, use the following format:<p class="source-code">Type ModelName struct{ </p><p class="source-code">    Field1 TYPE </p><p class="source-code">    Fiel2 TYPE </p><p class="source-code">}</p></li>
				<li>To bind a request body into a type, we use Gin model binding. Gin supports binding of JSON, XML and YAML. Gin provides two sets of methods for binding:<p>Should Bind: <strong class="source-inline">ShouldBindJSON()</strong>, <strong class="source-inline">ShouldBindXML()</strong>, <strong class="source-inline">ShouldBindYAML()</strong></p><p>Must Bind: Binds the struct pointer using the specified binding engine. It will abort the request with HTTP 400 if any error occurs.</p></li>
				<li>First, define a route with an ID as a path parameter:<p class="source-code">router.GET("/recipes/:id", GetRecipeHandler)</p><p>The <strong class="source-inline">GetRecipeHandler</strong> function parses the ID parameter and <strong class="source-inline">go</strong> loop through the recipes list. If the ID matches a recipe of the list, it will be returned, otherwise a <strong class="source-inline">404 error</strong> will be thrown as follows:</p><p class="source-code">func GetRecipeHandler(c *gin.Context) {</p><p class="source-code">     id := c.Query("id")</p><p class="source-code">     for i := 0; i &lt; len(recipes); i++ {</p><p class="source-code">          if recipes[i].ID == id {</p><p class="source-code">               c.JSON(http.StatusOK, recipes[i])</p><p class="source-code">          }</p><p class="source-code">     }</p><p class="source-code">     c.JSON(http.StatusNotFound, gin.H{"error": "Recipe  	                                       not found"})</p><p class="source-code">}</p></li>
				<li>To define a parameter, we use the swagger:parameters annotation:<p class="source-code">// swagger:parameters recipes newRecipe</p><p class="source-code">type Recipe struct {</p><p class="source-code">     //swagger:ignore</p><p class="source-code">     ID string `json:"id"`</p><p class="source-code">     Name string `json:"name"`</p><p class="source-code">     Tags []string `json:"tags"`</p><p class="source-code">     Ingredients []string `json:"ingredients"`</p><p class="source-code">     Instructions []string `json:"instructions"`</p><p class="source-code">     PublishedAt time.Time `json:"publishedAt"`</p><p class="source-code">}</p><p>Generate the specification with <strong class="source-inline">swagger</strong> generate command and load the results on <strong class="bold">Swagger UI</strong>.</p><p>You can now issue a POST request by filling the recipe fields directly from the Swagger UI.</p></li>
			</ol>
			<h1 id="_idParaDest-169"><em class="italic"><a id="_idTextAnchor176"/></em><a href="B17115_03_Final_JM_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a> – Managing Data Persistence with MongoDB</h1>
			<ol>
				<li value="1">You can delete recipes using <strong class="source-inline">collection.DeleteOne()</strong> or <strong class="source-inline">collection.DeleteMany()</strong>. Here you pass <strong class="source-inline">bson.D({})</strong> as the filter argument, which will match all documents in the collection.<p>Update the <strong class="source-inline">DeleteRecipeHandler</strong> as follows: </p><p class="source-code">func (handler *RecipesHandler) DeleteRecipeHandler(c *gin.Context) {</p><p class="source-code">   id := c.Param("id")</p><p class="source-code">   objectId, _ := primitive.ObjectIDFromHex(id)</p><p class="source-code">   _, err := handler.collection.DeleteOne(handler.ctx, bson.M{</p><p class="source-code">       "_id": objectId,</p><p class="source-code">   })</p><p class="source-code">   if err != nil {</p><p class="source-code">       c.JSON(http.StatusInternalServerError,  	 	 	              gin.H{"error": err.Error()})</p><p class="source-code">       return</p><p class="source-code">   }</p><p class="source-code">   c.JSON(http.StatusOK, gin.H{"message": "Recipe has  	                               been deleted"})</p><p class="source-code">}</p><p>Make sure to register the handler on <strong class="source-inline">DELETE /recipes/{id}</strong> resource as follows:</p><p class="source-code">router.DELETE("/recipes/:id", recipesHandler.DeleteRecipeHandler)</p></li>
				<li>To find a recipe, you will need a filter document, as well as a pointer to value into which the result can be decoded. To find a single recipe, use <strong class="source-inline">collection.FindOne()</strong>. This method returns a single result which can be decoded into a Recipe struct. You'll use the same filter variable you used in the update query to match a recipe where ID is <strong class="source-inline">600dcc85a65917cbd1f201b0</strong>.<p>Register a handler on the <strong class="source-inline">main.go</strong> file:</p><p class="source-code">router.GET("/recipes/:id", recipesHandler.GetOneRecipeHandler)</p><p>Then, declare the <strong class="source-inline">GetOneRecipeHandler</strong> in <strong class="source-inline">handler.go</strong> with the following content:</p><p class="source-code">func (handler *RecipesHandler) GetOneRecipeHandler(c *gin.Context) {</p><p class="source-code">   id := c.Param("id")</p><p class="source-code">   objectId, _ := primitive.ObjectIDFromHex(id)</p><p class="source-code">   cur := handler.collection.FindOne(handler.ctx, bson.M{</p><p class="source-code">       "_id": objectId,</p><p class="source-code">   })</p><p class="source-code">   var recipe models.Recipe</p><p class="source-code">   err := cur.Decode(&amp;recipe)</p><p class="source-code">   if err != nil {</p><p class="source-code">       c.JSON(http.StatusInternalServerError, 	 	 	              gin.H{"error": err.Error()})</p><p class="source-code">       return</p><p class="source-code">   }</p><p class="source-code">   c.JSON(http.StatusOK, recipe)</p><p class="source-code">}</p></li>
				<li>JSON documents in MongoDB are stored in a binary representation called <strong class="bold">BSON</strong> (<strong class="bold">Binary-encoded JSON</strong>). This format includes additional types such as:<p>a. Double</p><p>b. String</p><p>c. Object</p><p>d. Array</p><p>e. Binary data</p><p>f. Undefined</p><p>g. Object ID</p><p>h. Boolean</p><p>i. Date</p><p>j. Null</p><p>This makes it much easier for applications to reliably process, sort, and compare data.</p></li>
				<li><strong class="bold">Least Recently Used</strong> (<strong class="bold">LRU</strong>) algorithm uses the recent past to approximate the near future. It simply deletes the keys that has not been used for the longest period of time.</li>
			</ol>
			<h1 id="_idParaDest-170"><em class="italic"><a id="_idTextAnchor177"/></em><a href="B17115_04_Final_JM_ePub.xhtml#_idTextAnchor073"><em class="italic">Chapter 4</em></a> – Building API Authentication</h1>
			<ol>
				<li value="1">In order to create a user or sign them up, we need to define a HTTP handler with <strong class="source-inline">SignUpHandle</strong>r as follows:<p class="source-code">func (handler *AuthHandler) SignUpHandler(c *gin.Context) {</p><p class="source-code">   var user models.User</p><p class="source-code">   if err := c.ShouldBindJSON(&amp;user); err != nil {</p><p class="source-code">       c.JSON(http.StatusBadRequest, gin.H{"error":                                            err.Error()})</p><p class="source-code">       return</p><p class="source-code">   }</p><p class="source-code">   cur := handler.collection.FindOne(handler.ctx, bson.M{</p><p class="source-code">       "username": user.Username,</p><p class="source-code">   })</p><p class="source-code">   if curTalent.Err() == mongo.ErrNoDocuments {</p><p class="source-code">       err := handler.collection.InsertOne(handler.ctx,  	                                           user)</p><p class="source-code">       if err != nil {</p><p class="source-code">           c.JSON(http.StatusInternalServerError, 	 	                  gin.H{"error": err.Error()})</p><p class="source-code">           return</p><p class="source-code">       }</p><p class="source-code">       c.JSON(http.StatusAccepted, gin.H{"message": 	 	              "Account has been created"})</p><p class="source-code">   }</p><p class="source-code">   c.JSON(http.StatusInternalServerError, gin.H{"error":  	          "Username already taken"})</p><p class="source-code">}</p><p class="source-code">Then, register the handler on POST /signup route:</p><p class="source-code">router.POST("/signup", authHandler.SignUpHandler)</p><p>To ensure the username field is unique in all your users' entries, you can create a unique index for the username field.</p></li>
				<li>Define a <strong class="source-inline">ProfileHandler</strong> with the following body:<p class="source-code">func (handler *AuthHandler) ProfileHandler(c *gin.Context) {</p><p class="source-code">   var user models.User</p><p class="source-code">   username, _ := c.Get("username")</p><p class="source-code">   cur := handler.collection.FindOne(handler.ctx, bson.M{</p><p class="source-code">       "username": user.Username,</p><p class="source-code">   })</p><p class="source-code">   cur.Decode(&amp;user)</p><p class="source-code">   c.JSON(http.StatusAccepted, user)</p><p class="source-code">}</p><p class="source-code">Register the HTTP handler on the router group as below:</p><p class="source-code">authorized := router.Group("/")</p><p class="source-code">authorized.Use(authHandler.AuthMiddleware()){</p><p class="source-code">       authorized.POST("/recipes",                        recipesHandler.NewRecipeHandler)</p><p class="source-code">       authorized.PUT("/recipes/:id",                       recipesHandler.UpdateRecipeHandler)</p><p class="source-code">       authorized.DELETE("/recipes/:id",                       recipesHandler.DeleteRecipeHandler)</p><p class="source-code">       authorized.GET("/recipes/:id",                       recipesHandler.GetOneRecipeHandler)</p><p class="source-code">       authorized.GET("/profile",                       authHandler.ProfileHandler)</p><p class="source-code">}</p></li>
				<li>Add the following Swagger annotation in top of <strong class="source-inline">SignOutHandler</strong> signature:<p class="source-code">// swagger:operation POST /signout auth signOut</p><p class="source-code">// Signing out</p><p class="source-code">// ---</p><p class="source-code">// responses:</p><p class="source-code">//     '200':</p><p class="source-code">//         description: Successful operation</p><p class="source-code">func (handler *AuthHandler) SignOutHandler(c *gin.Context) {}</p></li>
			</ol>
			<h1 id="_idParaDest-171"><em class="italic"><a id="_idTextAnchor178"/></em><a href="B17115_05_Final_JM_ePub.xhtml#_idTextAnchor088"><em class="italic">Chapter 5</em></a> – Serving Static HTML in Gin</h1>
			<ol>
				<li value="1">Create a <strong class="source-inline">header.tmpl</strong> file with the following content:<p class="source-code">&lt;head&gt;</p><p class="source-code">    &lt;title&gt;Recipes&lt;/title&gt;</p><p class="source-code">    &lt;link rel="stylesheet" href="/assets/css/app.css"&gt;</p><p class="source-code">    &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet"&gt;</p><p class="source-code">&lt;/head&gt;</p><p>Then, reference the file in the <strong class="source-inline">recipe.tmpl</strong> with the following code block:</p><p class="source-code">{{template "/templates/header.tmpl.tmpl"}}</p><p>Follow the same approach to create a reusable template for the footer part.</p></li>
				<li>The full-source code of the <strong class="source-inline">NewRecipe.js</strong> component is available on the GitHub repository under the folder for <a href="B17115_05_Final_JM_ePub.xhtml#_idTextAnchor088"><em class="italic">Chapter 5</em></a>, <em class="italic">Serving static HTML in Gin</em>.</li>
				<li>Cross-compiling works by setting required environment variables that specify the target operating system and architecture. We use the variable <strong class="source-inline">GOOS</strong> for the target operating system, and <strong class="source-inline">GOARCH </strong>for the target architecture. To build an executable, the command would take this form:<p class="source-code"><strong class="bold">GOOS=target-OS GOARCH=target-architecture go build –o main *.go</strong></p><p>For instance, to build the binary for Windows, you can use the following command:</p><p class="source-code"><strong class="bold">GOOS=windows GOARCH=amd64 go build –o main main.go</strong></p></li>
			</ol>
			<h1 id="_idParaDest-172"><em class="italic"><a id="_idTextAnchor179"/></em><a href="B17115_07_Final_JM_ePub.xhtml#_idTextAnchor117"><em class="italic">Chapter 7</em></a> – Testing Gin HTTP Routes</h1>
			<ol>
				<li value="1">Define a <strong class="source-inline">TestUpdateRecipeHandler</strong> in <strong class="source-inline">main_test.go</strong> as follows: <p class="source-code">func TestUpdateRecipeHandler(t *testing.T) { </p><p class="source-code">   ts := httptest.NewServer(SetupServer()) </p><p class="source-code">   defer ts.Close() </p><p class="source-code"> </p><p class="source-code">   recipe := Recipe{ </p><p class="source-code">       ID:   "c0283p3d0cvuglq85log", </p><p class="source-code">       Name: "Oregano Marinated Chicken", </p><p class="source-code">   } </p><p class="source-code"> </p><p class="source-code">   raw, _ := json.Marshal(recipe) </p><p class="source-code">   resp, err := http.PUT(fmt.Sprintf("%s/recipes/%s", ts.URL, recipe.ID), bytes.NewBuffer(raw)) </p><p class="source-code">   defer resp.Body.Close() </p><p class="source-code">   assert.Nil(t, err) </p><p class="source-code">   assert.Equal(t, http.StatusOK, resp.StatusCode) </p><p class="source-code">   data, _ := ioutil.ReadAll(resp.Body) </p><p class="source-code"> </p><p class="source-code">   var payload map[string]string </p><p class="source-code">   json.Unmarshal(data, &amp;payload) </p><p class="source-code"> </p><p class="source-code">   assert.Equal(t, payload["message"], "Recipe has been updated") </p><p class="source-code">} </p><p class="source-code">Define TestDeleteRecipeHandler in main_test.go as follows: </p><p class="source-code">func TestDeleteRecipeHandler(t *testing.T) { </p><p class="source-code">   ts := httptest.NewServer(SetupServer()) </p><p class="source-code">   defer ts.Close() </p><p class="source-code"> </p><p class="source-code">   resp, err := http.DELETE(fmt.Sprintf("%s/recipes/c0283p3d0cvuglq85log", ts.URL)) </p><p class="source-code">   defer resp.Body.Close() </p><p class="source-code">   assert.Nil(t, err) </p><p class="source-code">   assert.Equal(t, http.StatusOK, resp.StatusCode) </p><p class="source-code">   data, _ := ioutil.ReadAll(resp.Body) </p><p class="source-code"> </p><p class="source-code">   var payload map[string]string </p><p class="source-code">   json.Unmarshal(data, &amp;payload) </p><p class="source-code"> </p><p class="source-code">   assert.Equal(t, payload["message"],                 "Recipe has been deleted") </p><p class="source-code">} </p></li>
				<li>Define <strong class="source-inline">TestFindRecipeHandler</strong> in <strong class="source-inline">main_test.go</strong> as follows: <p class="source-code">func TestDeleteRecipeHandler(t *testing.T) { </p><p class="source-code">   ts := httptest.NewServer(SetupServer()) </p><p class="source-code">   defer ts.Close() </p><p class="source-code"> </p><p class="source-code">   resp, err := http.DELETE(fmt.Sprintf("%s/recipes          /c0283p3d0cvuglq85log", ts.URL)) </p><p class="source-code">   defer resp.Body.Close() </p><p class="source-code">   assert.Nil(t, err) </p><p class="source-code">   assert.Equal(t, http.StatusOK, resp.StatusCode) </p><p class="source-code">   data, _ := ioutil.ReadAll(resp.Body) </p><p class="source-code"> </p><p class="source-code">   var payload map[string]string </p><p class="source-code">   json.Unmarshal(data, &amp;payload) </p><p class="source-code"> </p><p class="source-code">   assert.Equal(t, payload["message"],                 "Recipe has been deleted") </p><p class="source-code">}</p></li>
				<li>Define <strong class="source-inline">TestFindRecipeHandler</strong> in <strong class="source-inline">main_test.go</strong> as follows: <p class="source-code">func TestFindRecipeHandler(t *testing.T) { </p><p class="source-code">   ts := httptest.NewServer(SetupServer()) </p><p class="source-code">   defer ts.Close() </p><p class="source-code"> </p><p class="source-code">   expectedRecipe := Recipe{ </p><p class="source-code">       ID:   "c0283p3d0cvuglq85log", </p><p class="source-code">       Name: "Oregano Marinated Chicken", </p><p class="source-code">       Tags: []string{"main", "chicken"}, </p><p class="source-code">   } </p><p class="source-code"> </p><p class="source-code">   resp, err := http.GET(fmt.Sprintf("%s/recipes/c0283p3d0cvuglq85log", ts.URL)) </p><p class="source-code">   defer resp.Body.Close() </p><p class="source-code">   assert.Nil(t, err) </p><p class="source-code">   assert.Equal(t, http.StatusOK, resp.StatusCode) </p><p class="source-code">   data, _ := ioutil.ReadAll(resp.Body) </p><p class="source-code"> </p><p class="source-code">   var actualRecipe Recipe </p><p class="source-code">   json.Unmarshal(data, &amp;actualRecipe) </p><p class="source-code"> </p><p class="source-code">   assert.Equal(t, expectedRecipe.Name,                 actualRecipe.Name) </p><p class="source-code">   assert.Equal(t, len(expectedRecipe.Tags), len(actualRecipe.Tags)) </p><p class="source-code">}</p></li>
			</ol>
			<h1 id="_idParaDest-173"><em class="italic"><a id="_idTextAnchor180"/></em><a href="B17115_08_Final_JM_ePub.xhtml#_idTextAnchor131"><em class="italic">Chapter 8</em></a> – Deploying the Application on AWS</h1>
			<ol>
				<li value="1">Create a Docker volume with the following command:<p class="source-code"><strong class="bold">docker volume create mongodata</strong></p><p>Then mount the volume while running the Docker container:</p><p class="source-code"><strong class="bold">docker run -d -p 27017:27017 -v mongodata:/data/db --name mongodb mongodb:4.4.3</strong></p></li>
				<li>To deploy RabbitMQ, you can use the docker-compose.yml to deploy an additional service based on the RabbitMQ official image as follows:<p class="source-code">rabbitmq:</p><p class="source-code">     image: rabbitmq:3-management</p><p class="source-code">     ports:</p><p class="source-code">       - 8080:15672</p><p class="source-code">     environment:</p><p class="source-code">       - RABBITMQ_DEFAULT_USER=admin</p><p class="source-code">       - RABBITMQ_DEFAULT_PASS=password</p></li>
				<li>Create the user's credentials in the form of a Kubernetes secret:<p class="source-code"><strong class="bold">kubectl create secret generic mongodb-password --from-literal="password=YOUR_PASSWORD"</strong></p><p>Once we have created the secret, we need to update <strong class="source-inline">mongodb-deployment.yaml</strong> to use the Kubernetes secret:</p><p class="source-code">apiVersion: apps/v1</p><p class="source-code">kind: Deployment</p><p class="source-code">metadata:</p><p class="source-code"> annotations:</p><p class="source-code">   kompose.cmd: kompose convert</p><p class="source-code">   kompose.version: 1.22.0 (955b78124)</p><p class="source-code"> creationTimestamp: null</p><p class="source-code"> labels:</p><p class="source-code">   io.kompose.service: mongodb</p><p class="source-code"> name: mongodb</p><p class="source-code">spec:</p><p class="source-code"> replicas: 1</p><p class="source-code"> selector:</p><p class="source-code">   matchLabels:</p><p class="source-code">     io.kompose.service: mongodb</p><p class="source-code"> strategy: {}</p><p class="source-code"> template:</p><p class="source-code">   metadata:</p><p class="source-code">     annotations:</p><p class="source-code">       kompose.cmd: kompose convert</p><p class="source-code">       kompose.version: 1.22.0 (955b78124)</p><p class="source-code">     creationTimestamp: null</p><p class="source-code">     labels:</p><p class="source-code">       io.kompose.service: mongodb</p><p class="source-code">   spec:</p><p class="source-code">     containers:</p><p class="source-code">       - env:</p><p class="source-code">           - name: MONGO_INITDB_ROOT_PASSWORD</p><p class="source-code">             valueFrom:</p><p class="source-code">               secretKeyRef:</p><p class="source-code">                 name: mongodb-password</p><p class="source-code">                 key: password</p><p class="source-code">           - name: MONGO_INITDB_ROOT_USERNAME</p><p class="source-code">             value: admin</p><p class="source-code">         image: mongo:4.4.3</p><p class="source-code">         name: mongodb</p><p class="source-code">         ports:</p><p class="source-code">           - containerPort: 27017</p><p class="source-code">         resources: {}</p><p class="source-code">     restartPolicy: Always</p><p class="source-code">status: {}</p></li>
				<li>To scale the API pods with <strong class="source-inline">kubectl</strong>, issue the following command:<p class="source-code"><strong class="bold">kubectl scale deploy</strong></p></li>
			</ol>
			<h1 id="_idParaDest-174"><em class="italic"><a id="_idTextAnchor181"/></em><a href="B17115_09_Final_JM_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a> – Implementing a CI/CD Pipeline</h1>
			<ol>
				<li value="1">The pipeline will have the following stages:<p>a. Checkout the source code from the GitHub repository.</p><p>b. Install the NPM packages with <strong class="source-inline">npm install</strong> command.</p><p>c. Generate the assets with <strong class="source-inline">npm run build</strong> command.</p><p>d. Install the AWS CLI and push the new assets to an S3 bucket.</p><p>e. The <strong class="source-inline">config.yml</strong> is given here:</p><p class="source-code">version: 2.1</p><p class="source-code">executors:</p><p class="source-code"> environment:</p><p class="source-code">   docker:</p><p class="source-code">     - image: node:lts</p><p class="source-code">   working_directory: /dashboard</p><p class="source-code">jobs:</p><p class="source-code"> build:</p><p class="source-code">   executor: environment</p><p class="source-code">   steps:</p><p class="source-code">     - checkout</p><p class="source-code">     - restore_cache:</p><p class="source-code">         key: node-modules-{{checksum "package.json"}}</p><p class="source-code">     - run:</p><p class="source-code">         name: Install dependencies</p><p class="source-code">         command: npm install</p><p class="source-code">     - save_cache:</p><p class="source-code">         key: node-modules-{{checksum "package.json"}}</p><p class="source-code">         paths:</p><p class="source-code">           - node_modules</p><p class="source-code">     - run:</p><p class="source-code">         name: Build artifact</p><p class="source-code">         command: CI=false npm run build</p><p class="source-code">     - persist_to_workspace:</p><p class="source-code">         root: .</p><p class="source-code">         paths:</p><p class="source-code">           - build</p><p class="source-code"> deploy:</p><p class="source-code">   executor: environment</p><p class="source-code">   steps:</p><p class="source-code">     - attach_workspace:</p><p class="source-code">         at: dist</p><p class="source-code">     - run:</p><p class="source-code">         name: Install AWS CLI</p><p class="source-code">         command: |</p><p class="source-code">           apt-get update</p><p class="source-code">           apt-get install -y python3-pip</p><p class="source-code">           pip3 install awscli</p><p class="source-code">     - run:</p><p class="source-code">         name: Push to S3 bucket</p><p class="source-code">         command: |</p><p class="source-code">           cd dist/build/dashboard/</p><p class="source-code">           aws configure set preview.cloudfront true</p><p class="source-code">           aws s3 cp --recursive . s3://YOUR_S3_BUCKET/ --region YOUR_AWS_REGION</p><p class="source-code">workflows:</p><p class="source-code"> ci_cd:</p><p class="source-code">   jobs:</p><p class="source-code">     - build</p><p class="source-code">     - deploy:</p><p class="source-code">         requires:</p><p class="source-code">           - build</p><p class="source-code">         filters:</p><p class="source-code">           branches:</p><p class="source-code">             only:</p><p class="source-code">               - master</p><p>Before running the pipeline, you will need to give access <strong class="source-inline">S3:PutObject</strong> permission to the <strong class="bold">CircleCI IAM</strong> user.</p></li>
				<li>You can configure the Slack ORB to send a notification on a successful pipeline as follows:<p class="source-code">- slack/notify:</p><p class="source-code">     event: pass</p><p class="source-code">     custom: |</p><p class="source-code">      {</p><p class="source-code">        "blocks": [</p><p class="source-code">          {</p><p class="source-code">            "type": "section",</p><p class="source-code">            "text": {</p><p class="source-code">              "type": "mrkdwn",</p><p class="source-code">              "text": "Current Job: $CIRCLE_JOB"</p><p class="source-code">            }</p><p class="source-code">          },</p><p class="source-code">          {</p><p class="source-code">            "type": "section",</p><p class="source-code">            "text": {</p><p class="source-code">              "type": "mrkdwn",</p><p class="source-code">              "text": "New release has been successfully  	                       deployed!"</p><p class="source-code">            }</p><p class="source-code">          }</p><p class="source-code">         ]</p><p class="source-code">      }</p></li>
			</ol>
		</div>
	</body></html>