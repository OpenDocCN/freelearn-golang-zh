["```go\n    Type ModelName struct{ \n        Field1 TYPE \n        Fiel2 TYPE \n    }\n    ```", "```go\n    router.GET(\"/recipes/:id\", GetRecipeHandler)\n    ```", "```go\n    func GetRecipeHandler(c *gin.Context) {\n         id := c.Query(\"id\")\n         for i := 0; i < len(recipes); i++ {\n              if recipes[i].ID == id {\n                   c.JSON(http.StatusOK, recipes[i])\n              }\n         }\n         c.JSON(http.StatusNotFound, gin.H{\"error\": \"Recipe  \t                                       not found\"})\n    }\n    ```", "```go\n    // swagger:parameters recipes newRecipe\n    type Recipe struct {\n         //swagger:ignore\n         ID string `json:\"id\"`\n         Name string `json:\"name\"`\n         Tags []string `json:\"tags\"`\n         Ingredients []string `json:\"ingredients\"`\n         Instructions []string `json:\"instructions\"`\n         PublishedAt time.Time `json:\"publishedAt\"`\n    }\n    ```", "```go\n    func (handler *RecipesHandler) DeleteRecipeHandler(c *gin.Context) {\n       id := c.Param(\"id\")\n       objectId, _ := primitive.ObjectIDFromHex(id)\n       _, err := handler.collection.DeleteOne(handler.ctx, bson.M{\n           \"_id\": objectId,\n       })\n       if err != nil {\n           c.JSON(http.StatusInternalServerError,  \t \t \t              gin.H{\"error\": err.Error()})\n           return\n       }\n       c.JSON(http.StatusOK, gin.H{\"message\": \"Recipe has  \t                               been deleted\"})\n    }\n    ```", "```go\n    router.DELETE(\"/recipes/:id\", recipesHandler.DeleteRecipeHandler)\n    ```", "```go\n    router.GET(\"/recipes/:id\", recipesHandler.GetOneRecipeHandler)\n    ```", "```go\n    func (handler *RecipesHandler) GetOneRecipeHandler(c *gin.Context) {\n       id := c.Param(\"id\")\n       objectId, _ := primitive.ObjectIDFromHex(id)\n       cur := handler.collection.FindOne(handler.ctx, bson.M{\n           \"_id\": objectId,\n       })\n       var recipe models.Recipe\n       err := cur.Decode(&recipe)\n       if err != nil {\n           c.JSON(http.StatusInternalServerError, \t \t \t              gin.H{\"error\": err.Error()})\n           return\n       }\n       c.JSON(http.StatusOK, recipe)\n    }\n    ```", "```go\n    func (handler *AuthHandler) SignUpHandler(c *gin.Context) {\n       var user models.User\n       if err := c.ShouldBindJSON(&user); err != nil {\n           c.JSON(http.StatusBadRequest, gin.H{\"error\":                                            err.Error()})\n           return\n       }\n       cur := handler.collection.FindOne(handler.ctx, bson.M{\n           \"username\": user.Username,\n       })\n       if curTalent.Err() == mongo.ErrNoDocuments {\n           err := handler.collection.InsertOne(handler.ctx,  \t                                           user)\n           if err != nil {\n               c.JSON(http.StatusInternalServerError, \t \t                  gin.H{\"error\": err.Error()})\n               return\n           }\n           c.JSON(http.StatusAccepted, gin.H{\"message\": \t \t              \"Account has been created\"})\n       }\n       c.JSON(http.StatusInternalServerError, gin.H{\"error\":  \t          \"Username already taken\"})\n    }\n    Then, register the handler on POST /signup route:\n    router.POST(\"/signup\", authHandler.SignUpHandler)\n    ```", "```go\n    func (handler *AuthHandler) ProfileHandler(c *gin.Context) {\n       var user models.User\n       username, _ := c.Get(\"username\")\n       cur := handler.collection.FindOne(handler.ctx, bson.M{\n           \"username\": user.Username,\n       })\n       cur.Decode(&user)\n       c.JSON(http.StatusAccepted, user)\n    }\n    Register the HTTP handler on the router group as below:\n    authorized := router.Group(\"/\")\n    authorized.Use(authHandler.AuthMiddleware()){\n           authorized.POST(\"/recipes\",                        recipesHandler.NewRecipeHandler)\n           authorized.PUT(\"/recipes/:id\",                       recipesHandler.UpdateRecipeHandler)\n           authorized.DELETE(\"/recipes/:id\",                       recipesHandler.DeleteRecipeHandler)\n           authorized.GET(\"/recipes/:id\",                       recipesHandler.GetOneRecipeHandler)\n           authorized.GET(\"/profile\",                       authHandler.ProfileHandler)\n    }\n    ```", "```go\n    // swagger:operation POST /signout auth signOut\n    // Signing out\n    // ---\n    // responses:\n    //     '200':\n    //         description: Successful operation\n    func (handler *AuthHandler) SignOutHandler(c *gin.Context) {}\n    ```", "```go\n    <head>\n        <title>Recipes</title>\n        <link rel=\"stylesheet\" href=\"/assets/css/app.css\">\n        <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n    </head>\n    ```", "```go\n    {{template \"/templates/header.tmpl.tmpl\"}}\n    ```", "```go\n    GOOS=target-OS GOARCH=target-architecture go build –o main *.go\n    ```", "```go\n    GOOS=windows GOARCH=amd64 go build –o main main.go\n    ```", "```go\n    func TestUpdateRecipeHandler(t *testing.T) { \n       ts := httptest.NewServer(SetupServer()) \n       defer ts.Close() \n\n       recipe := Recipe{ \n           ID:   \"c0283p3d0cvuglq85log\", \n           Name: \"Oregano Marinated Chicken\", \n       } \n\n       raw, _ := json.Marshal(recipe) \n       resp, err := http.PUT(fmt.Sprintf(\"%s/recipes/%s\", ts.URL, recipe.ID), bytes.NewBuffer(raw)) \n       defer resp.Body.Close() \n       assert.Nil(t, err) \n       assert.Equal(t, http.StatusOK, resp.StatusCode) \n       data, _ := ioutil.ReadAll(resp.Body) \n\n       var payload map[string]string \n       json.Unmarshal(data, &payload) \n\n       assert.Equal(t, payload[\"message\"], \"Recipe has been updated\") \n    } \n    Define TestDeleteRecipeHandler in main_test.go as follows: \n    func TestDeleteRecipeHandler(t *testing.T) { \n       ts := httptest.NewServer(SetupServer()) \n       defer ts.Close() \n\n       resp, err := http.DELETE(fmt.Sprintf(\"%s/recipes/c0283p3d0cvuglq85log\", ts.URL)) \n       defer resp.Body.Close() \n       assert.Nil(t, err) \n       assert.Equal(t, http.StatusOK, resp.StatusCode) \n       data, _ := ioutil.ReadAll(resp.Body) \n\n       var payload map[string]string \n       json.Unmarshal(data, &payload) \n\n       assert.Equal(t, payload[\"message\"],                 \"Recipe has been deleted\") \n    } \n    ```", "```go\n    func TestDeleteRecipeHandler(t *testing.T) { \n       ts := httptest.NewServer(SetupServer()) \n       defer ts.Close() \n\n       resp, err := http.DELETE(fmt.Sprintf(\"%s/recipes          /c0283p3d0cvuglq85log\", ts.URL)) \n       defer resp.Body.Close() \n       assert.Nil(t, err) \n       assert.Equal(t, http.StatusOK, resp.StatusCode) \n       data, _ := ioutil.ReadAll(resp.Body) \n\n       var payload map[string]string \n       json.Unmarshal(data, &payload) \n\n       assert.Equal(t, payload[\"message\"],                 \"Recipe has been deleted\") \n    }\n    ```", "```go\n    func TestFindRecipeHandler(t *testing.T) { \n       ts := httptest.NewServer(SetupServer()) \n       defer ts.Close() \n\n       expectedRecipe := Recipe{ \n           ID:   \"c0283p3d0cvuglq85log\", \n           Name: \"Oregano Marinated Chicken\", \n           Tags: []string{\"main\", \"chicken\"}, \n       } \n\n       resp, err := http.GET(fmt.Sprintf(\"%s/recipes/c0283p3d0cvuglq85log\", ts.URL)) \n       defer resp.Body.Close() \n       assert.Nil(t, err) \n       assert.Equal(t, http.StatusOK, resp.StatusCode) \n       data, _ := ioutil.ReadAll(resp.Body) \n\n       var actualRecipe Recipe \n       json.Unmarshal(data, &actualRecipe) \n\n       assert.Equal(t, expectedRecipe.Name,                 actualRecipe.Name) \n       assert.Equal(t, len(expectedRecipe.Tags), len(actualRecipe.Tags)) \n    }\n    ```", "```go\n    docker volume create mongodata\n    ```", "```go\n    docker run -d -p 27017:27017 -v mongodata:/data/db --name mongodb mongodb:4.4.3\n    ```", "```go\n    rabbitmq:\n         image: rabbitmq:3-management\n         ports:\n           - 8080:15672\n         environment:\n           - RABBITMQ_DEFAULT_USER=admin\n           - RABBITMQ_DEFAULT_PASS=password\n    ```", "```go\n    mongodb-deployment.yaml to use the Kubernetes secret:\n\n    ```", "```go\n\n    ```", "```go\n    kubectl scale deploy\n    ```", "```go\n    version: 2.1\n    executors:\n     environment:\n       docker:\n         - image: node:lts\n       working_directory: /dashboard\n    jobs:\n     build:\n       executor: environment\n       steps:\n         - checkout\n         - restore_cache:\n             key: node-modules-{{checksum \"package.json\"}}\n         - run:\n             name: Install dependencies\n             command: npm install\n         - save_cache:\n             key: node-modules-{{checksum \"package.json\"}}\n             paths:\n               - node_modules\n         - run:\n             name: Build artifact\n             command: CI=false npm run build\n         - persist_to_workspace:\n             root: .\n             paths:\n               - build\n     deploy:\n       executor: environment\n       steps:\n         - attach_workspace:\n             at: dist\n         - run:\n             name: Install AWS CLI\n             command: |\n               apt-get update\n               apt-get install -y python3-pip\n               pip3 install awscli\n         - run:\n             name: Push to S3 bucket\n             command: |\n               cd dist/build/dashboard/\n               aws configure set preview.cloudfront true\n               aws s3 cp --recursive . s3://YOUR_S3_BUCKET/ --region YOUR_AWS_REGION\n    workflows:\n     ci_cd:\n       jobs:\n         - build\n         - deploy:\n             requires:\n               - build\n             filters:\n               branches:\n                 only:\n                   - master\n    ```", "```go\n    - slack/notify:\n         event: pass\n         custom: |\n          {\n            \"blocks\": [\n              {\n                \"type\": \"section\",\n                \"text\": {\n                  \"type\": \"mrkdwn\",\n                  \"text\": \"Current Job: $CIRCLE_JOB\"\n                }\n              },\n              {\n                \"type\": \"section\",\n                \"text\": {\n                  \"type\": \"mrkdwn\",\n                  \"text\": \"New release has been successfully  \t                       deployed!\"\n                }\n              }\n             ]\n          }\n    ```"]