<html><head></head><body>
		<div id="_idContainer011">
			<h1 id="_idParaDest-17" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor015"/>Understanding CLI Standards</h1>
			<p>The <strong class="bold">Command-Line Interface</strong> (<strong class="bold">CLI</strong>) is a text-based interface for humans, and computer interaction was initially designed as a way of interacting with an <strong class="bold">Operating System</strong> (<strong class="bold">OS</strong>) before the desktop graphical interface was invented. <a id="_idTextAnchor016"/>The CLI, as we know it today, was in popular use in the 1960s until the graphical desktop interface was developed a decade later. However, although most computer users are used to the <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) and web, there’s been a resurgence of CLI development circa 2017. Popular and new use cases for the retro CLI vary, but its most popular usage is as an additional offering alongside a company’s API for increased <span class="No-Break">platform usage.</span></p>
			<p>In this chapter, you will learn about the comprehensive history of the CLI, what it is today, and a breakdown of its anatomy. You will learn about UNIX’s philosophy and how following its principles will guide you toward the creation of a <span class="No-Break">successful CLI.</span></p>
			<p>By the end of this chapter, you’ll have a deeper understanding of the CLI, how best to design and implement proven, time-tested standards, and why Go, which has become an increasingly popular language, has a compelling case for being the best language to build <span class="No-Break">your CLI.</span></p>
			<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>A brief introduction and history of the <span class="No-Break">command line</span></li>
				<li>The philosophy of <span class="No-Break">CLI development</span></li>
				<li>Modern <span class="No-Break">CLI guidelines</span></li>
				<li>Go <span class="No-Break">for CLIs</span></li>
			</ul>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor017"/>A brief introduction and history of the command line</h1>
			<p>The CLI is the result of the evolution <a id="_idIndexMarker000"/>of a much broader human-computer interaction, specifically communication and language processing. Let’s begin the story with the creation of the first compiler, which took us from using punch cards to <span class="No-Break">programming languages.</span></p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor018"/>About the history</h2>
			<p>The first computer compiler <a id="_idIndexMarker001"/>was written by Grace Hopper. A compiler was able to translate written code to machine code and lifted the great burden off programmers of the time consumption of writing machine code manually. Grace Hopper also invented the COBOL programming language in 1959. In that era, punch cards were used for data processing applications or to control machinery. They would contain COBOL, Fortran, and Assembly code. The compiler and advancement of new programming languages eased the task <span class="No-Break">of programming.</span></p>
			<p>The same year, the microchip was invented by Jack Kilby and Robert Noyce. Much less expensive, small-scale computers were made possible and, finally, <em class="italic">human-in-the-loop</em>, a back-and-forth interaction between the human and computer, became feasible. Computers were now multitasking and <span class="No-Break">time-sharing systems.</span></p>
			<p>At this point, keyboards became the main method of interacting with computers. By the early 1960s, engineers had<a id="_idIndexMarker002"/> attached a <strong class="bold">Cathode Ray Tube</strong> (<strong class="bold">CRT</strong>) monitor to<a id="_idIndexMarker003"/> the <strong class="bold">TeleTYpewriter </strong>(<strong class="bold">TTY</strong>) machine. This combination of the CRT and TTY was called a <em class="italic">glass TTY</em> and marked the <a id="_idIndexMarker004"/>beginning of what we consider the <span class="No-Break">modern monitor.</span></p>
			<p>In 1966, the CRT and teletype machine, which combined the technologies of the electric telegraph, telephone, and typewriter, were about to merge with the final missing puzzle piece, the computer. The teletype computer interface was born. Users would type a command, hit the <em class="italic">Enter</em> key, and the computer would respond. These were called <span class="No-Break"><em class="italic">command-line interfaces</em></span><span class="No-Break">!</span></p>
			<p>There were so many more exciting developments that followed, from the invention of ASCII characters in 1963 to the internet in 1969, UNIX in 1971, and email in 1972. Lexical analysis parsers in 1975 played a major part in the development of programming languages. Text-based adventure games provided amusement for the tech savvy by 1977, and the beginnings of the GUI emerged in <span class="No-Break">the 1970s.</span></p>
			<p>A network of these computers would not have been possible if not for the evolution of the telephone. In 1964, the <a id="_idIndexMarker005"/>acoustic <strong class="bold">modulator/demodulator</strong> (<strong class="bold">modem</strong>) was used to transmit data between a telephone line and a computer. The acoustic modem <a id="_idIndexMarker006"/>brought us the <strong class="bold">wide area network</strong> (<strong class="bold">WAN</strong>), <strong class="bold">local area network</strong> (<strong class="bold">LAN</strong>), and the <a id="_idIndexMarker007"/>broadband we know of today. LAN parties peaked in the 1990s and carried on well into the <span class="No-Break">early 2000s.</span></p>
			<p>In 1978, the first<a id="_idIndexMarker008"/> public dial-up <strong class="bold">bulletin board system</strong> (<strong class="bold">BBS</strong>) was developed by Ward Christensen and Randy Suess, who also created the <strong class="bold">computerized bulletin board system</strong> (<strong class="bold">CBBS</strong>). With a modem, users could dial into servers running the CBBS <a id="_idIndexMarker009"/>software and connect via a terminal program. Throughout the 1980s, BBS’s popularity grew to fantastic heights, and even in the mid-1990s, BBSs served the greater collective market compared to emerging online service providers such as CompuServe and <strong class="bold">America </strong><span class="No-Break"><strong class="bold">Online</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">AOL</strong></span><span class="No-Break">).</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">This deeper understanding of the history of the CLI may give you a greater appreciation for what it is. The terminal is a bit of a time machine. The use of many UNIX and DOS commands feels like you’re standing on the shoulders of giants, looking down at the long computing history <span class="No-Break">beneath it.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor019"/>Introducing the CLI</h2>
			<p>Based on the history of the <a id="_idIndexMarker010"/>CLI, it’s clear to see that it is a text-based interface that allows communication from user to computer, computer to computer, and computer back to user. It requires the same specific instructions and clear language as the earlier machines it evolved from. Now, let’s dig deeper into CLIs to learn about the different kinds, how they are generally structured, and how and why they <span class="No-Break">are used.</span></p>
			<h3>Anatomy</h3>
			<p>For any CLI, regardless of<a id="_idIndexMarker011"/> the specific type, it’s important to understand the<a id="_idIndexMarker012"/> anatomy of the commands themselves. Without a particular structure, the computer would not be able to properly parse and understand its instructions. The following is a simple example that we will use to distinguish the different components of <span class="No-Break">a command:</span></p>
			<pre class="source-code">
<strong class="source-inline">~ cat -b transcript</strong></pre>
			<p>In the context of this example, the UNIX command, <strong class="source-inline">cat</strong>, is used to view the contents of the file, <strong class="source-inline">transcript</strong>. The addition of the <strong class="source-inline">–b</strong> flag tells the command to print the line number next to non-empty output<a id="_idIndexMarker013"/> lines. We will go into each component of the command in detail in the <span class="No-Break">following subsections.</span></p>
			<h4>The prompt</h4>
			<p>A symbol on the <a id="_idIndexMarker014"/>terminal indicates to the user that the computer is ready to receive a command. The preceding example shows <strong class="source-inline">~</strong> as the command prompt; however, this can differ depending on <span class="No-Break">the OS.</span></p>
			<h4>The command</h4>
			<p>There are two types <span class="No-Break">of commands:</span></p>
			<ul>
				<li><strong class="bold">Internal commands</strong> are commands<a id="_idIndexMarker015"/> that are built into the OS shell, stored within internal memory, and execute faster. A few examples include folder<a id="_idIndexMarker016"/> and environment manipulation commands, such as <strong class="source-inline">cd</strong>, <strong class="source-inline">date</strong>, and <strong class="source-inline">time</strong> commands. They do not require a search of the <strong class="source-inline">PATH</strong> variable to find <span class="No-Break">the executable.</span></li>
				<li><strong class="bold">External commands</strong> are commands that are not built into the OS and are only available through software or <a id="_idIndexMarker017"/>applications installed by other parties. These commands are stored within secondary memory and do not execute as quickly as internal commands. A few examples include <strong class="source-inline">ls</strong> and <strong class="source-inline">cat</strong>. These are usually located in <strong class="source-inline">/bin</strong> or <strong class="source-inline">/usr/bin</strong> in UNIX and require a search of the <strong class="source-inline">PATH</strong> variable to find <span class="No-Break">the executable.</span></li>
			</ul>
			<p>The previous example uses <strong class="source-inline">cat</strong> as the <span class="No-Break">external command.</span></p>
			<h4>Arguments and options</h4>
			<p>Commands usually take in <a id="_idIndexMarker018"/>parameters for input that consist of one or many arguments <span class="No-Break">and/or options:</span></p>
			<ul>
				<li>Arguments are parameters that pass information to the command, for example, <span class="No-Break"><strong class="source-inline">mkdir test/</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>In the preceding code snippet, <strong class="source-inline">test/</strong> is the input parameter to the <span class="No-Break"><strong class="source-inline">mkdir</strong></span><span class="No-Break"> command.</span></p>
			<ul>
				<li>Options are flags, or switches, that modify the operation of a command, for example <strong class="source-inline">mkdir -</strong><span class="No-Break"><strong class="source-inline">p test/files/</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>In the preceding example, <strong class="source-inline">-p</strong> is an option to make parent directories <span class="No-Break">if needed.</span></p>
			<p>In the example at the start of this section, <strong class="source-inline">-b</strong> is an optional flag, shorthand for <strong class="source-inline">--number-nonblank</strong>, which tells the command to print the line number next to non-empty lines, and the filename, <strong class="source-inline">transcript</strong>, is an argument passed into <span class="No-Break">the command.</span></p>
			<h4>Whitespace</h4>
			<p>For the OS or application to properly<a id="_idIndexMarker019"/> parse these commands, arguments, and options, each is delimited by whitespace. Special attention must be paid to the fact that whitespaces may exist within the parameter itself. This can cause a bit of ambiguity for the <span class="No-Break">command-line interpreter.</span></p>
			<p>Take care to resolve this ambiguity by replacing spaces within parameters. In the following example, we replace the spaces <span class="No-Break">with underscores:</span></p>
			<pre class="source-code">
cat Screen_Shot_2021-06-05_at_10.23.16_PM.png</pre>
			<p>You can also decide to put quotes around the parameter, as in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
cat "Screen Shot 2021-06-05 at 10.23.16 PM.png"</pre>
			<p>Finally, resolve ambiguity by adding an escape character before each space, as in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
cat Screen\ Shot\ 2021-06-05\ at\ 10.23.16\ PM.png</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Although whitespace is the most widely used delimiter, it is <span class="No-Break">not universal.</span></p>
			<h4>Syntax and semantics</h4>
			<p>The CLI provides the<a id="_idIndexMarker020"/> language for communicating with the OS or application. Thus, like any language, to be properly interpreted, it requires syntax and semantics. The syntax is the grammar defined by the OS or the application vendor. Semantics define what operations <span class="No-Break">are possible.</span></p>
			<p>When you look at some command-line applications, you can see the language being used. Sometimes, the syntax differs between tools; I will go over the specifics later in this chapter, but, for example, <strong class="source-inline">cat -b transcript</strong> is a command we’ve looked at before. The command, <strong class="source-inline">cat</strong>, is a verb, the flag, <strong class="source-inline">-b</strong>, is an adjective, and <strong class="source-inline">transcript</strong> is a noun. This is the defined syntax of the <strong class="source-inline">cat</strong> UNIX command: verb, <span class="No-Break">adjective, noun.</span></p>
			<p>The semantics of the command are defined by what operations are possible. You can see this by viewing the options of, for example, the <strong class="source-inline">cat</strong> command, which are usually shown in the <strong class="bold">usage </strong>section of the help page, which is output when a user uses the <span class="No-Break">application incorrectly.</span></p>
			<h4>Help pages</h4>
			<p>Because the CLI is entirely<a id="_idIndexMarker021"/> text-based and lacking in visual cues, its usage may be ambiguous or unknown. A <strong class="bold">help page</strong> is essential to<a id="_idIndexMarker022"/> every CLI. To view a list of valid parameters and options, users may run the command followed by the help option, typically <strong class="source-inline">-help</strong>, <strong class="source-inline">--help</strong>, or <strong class="source-inline">-h</strong>. The <strong class="source-inline">-h</strong> option is an example of an abbreviated shortcut for the <span class="No-Break">help command.</span></p>
			<p>There’s a common syntax used in built-in help and man pages and following this standard will allow users familiar with the standard to easily use <span class="No-Break">your CLI:</span></p>
			<ul>
				<li>Required parameters are typically represented within angled brackets, for example, <span class="No-Break"><strong class="source-inline">ping &lt;hostname&gt;</strong></span></li>
				<li>Optional parameters are represented within square brackets, for example, <strong class="source-inline">mkdir [</strong><span class="No-Break"><strong class="source-inline">option] &lt;dirname&gt;</strong></span></li>
				<li>Ellipses represent repeated items, for example, <strong class="source-inline">cp [option]... &lt;</strong><span class="No-Break"><strong class="source-inline">source&gt;... &lt;directory&gt;</strong></span></li>
				<li>Vertical bars<a id="_idIndexMarker023"/> represent a choice of items, for example, <strong class="source-inline">netstat {-t | -</strong><span class="No-Break"><strong class="source-inline">u}</strong></span></li>
			</ul>
			<h3>Usage</h3>
			<p>The CLI was the first interface between the user and the OS used primarily for numerical computation, but in time, its usage has <a id="_idIndexMarker024"/>expanded in many more practical and <span class="No-Break">fun ways.</span></p>
			<p>Let us see some of <span class="No-Break">the uses:</span></p>
			<ul>
				<li><strong class="bold">Editor MACroS</strong> (<strong class="bold">Emacs</strong>), one of the earliest forms of a text editor provided in UNIX, is a CLI in the form of <a id="_idIndexMarker025"/>a mini buffer. Commands and arguments are entered as a combination of key presses: either a <em class="italic">Ctrl </em>character plus a key or a key prefixed by a <em class="italic">Ctrl </em>character and the output displayed within <span class="No-Break">another buffer.</span></li>
				<li><strong class="bold">Read-Evaluate-Print Loop</strong> (<strong class="bold">REPL</strong>) is a Python<a id="_idIndexMarker026"/> interactive shell that offers a CLI, and according to its name can read, evaluate, print, and loop. It allows users a play environment to validate <span class="No-Break">Python commands.</span></li>
				<li><strong class="bold">MajorMUD</strong> and <strong class="bold">Lunatix</strong> are just a couple of <a id="_idIndexMarker027"/>popular games that were available on bulletin board systems. As soon as programmers could turn CLIs into play, they did, and while these games were entirely text-based, they were certainly not lacking <span class="No-Break">in fun!</span></li>
				<li>Modern video games call their CLI a gaming console. From the console, mod developers can run commands to debug, cheat, or skip part of <span class="No-Break">the game.</span></li>
				<li>Helper programs often take in parameters to launch a program in a particular way. For example, Microsoft Visual Code has a command-line option: <span class="No-Break"><strong class="source-inline">code &lt;filename&gt;</strong></span><span class="No-Break">.</span></li>
				<li>Some CLIs are embedded into a web application, for example, web-based <span class="No-Break">SSH programs.</span></li>
				<li>Companies such as AWS offer CLIs alongside their API as an additional way of interacting with <span class="No-Break">their platform.</span></li>
			</ul>
			<p>Last but not least, scripting<a id="_idIndexMarker028"/> has allowed engineers to take their CLIs to a more interactive level. Within a shell scripting language, programmers can script calls to the CLI and capture and manipulate output. The output of one command may also be passed as input into another. This makes the CLI a very powerful resource <span class="No-Break">for developers.</span></p>
			<h3>Types</h3>
			<p>There are two<a id="_idIndexMarker029"/> main types <span class="No-Break">of CLIs:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">OS CLIs</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Application CLIs</strong></span></li>
			</ul>
			<h4>OS CLIs</h4>
			<p>OS CLIs are often provided alongside the OS. This kind <a id="_idIndexMarker030"/>of CLI is referred to as a <strong class="bold">shell</strong>. It is the command-line<a id="_idIndexMarker031"/> interpreter that sits a layer above the kernel interpreting and <a id="_idIndexMarker032"/>processing commands entered by the user and outputting results and a text-based method of interacting with the OS as an alternative to the <span class="No-Break">graphical display.</span></p>
			<h4>Application CLIs</h4>
			<p>The second type of CLI allows<a id="_idIndexMarker033"/> interaction with a specific application running on <span class="No-Break">the OS.</span></p>
			<p>There are three main types of ways users may interact with an <span class="No-Break">application’s CLI:</span></p>
			<ul>
				<li><strong class="bold">Parameters</strong>: They provide<a id="_idIndexMarker034"/> input to launch the application in a <span class="No-Break">particular way</span></li>
				<li><strong class="bold">Interactive command-line sessions</strong>: They are launched after the application as an independent and text-alternative method <span class="No-Break">of control</span></li>
				<li><strong class="bold">Inter-process communication</strong>: This allows users to stream or pipe data from the output of one program <span class="No-Break">into another</span></li>
			</ul>
			<h3>GUI versus CLI example</h3>
			<p>Let’s give a clear example of how the CLI can reign over the GUI in speed. Suppose we have a folder full of screenshots. The<a id="_idIndexMarker035"/> names of each contain a space and we’d like to rename these files to replace the whitespace with <span class="No-Break">an underscore.</span></p>
			<h4>GUI</h4>
			<p>With a GUI, there’d be several manual steps for renaming a folder full of screenshots that contain whitespaces throughout the filename. Let’s show these steps within macOS, <span class="No-Break">or Darwin:</span></p>
			<ol>
				<li>First, we’d need to open the folder containing all <span class="No-Break">the screenshots:</span></li>
			</ol>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/Figure_1.01.jpg" alt="Figure 1.1 – Folder containing the screenshots where each filename contains numerous spaces"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Folder containing the screenshots where each filename contains numerous spaces</p>
			<ol>
				<li value="2">Second, we’d press the <a id="_idIndexMarker036"/>control button and left-click on a filename, then from the context menu that pops up, select the <span class="No-Break"><strong class="bold">Rename</strong></span><span class="No-Break"> option.</span></li>
			</ol>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/Figure_1.02.jpg" alt="Figure 1.2 – From the context menu, click on the Rename option"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – From the context menu, click on the Rename option</p>
			<ol>
				<li value="3">Finally, manually replace each of the whitespaces with <span class="No-Break">an underscore.</span></li>
			</ol>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/Figure_1.03.jpg" alt="Figure 1.3 – Replaced whitespaces with underscores in filename"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Replaced whitespaces with underscores in filename</p>
			<p>Repeat steps 1-3 for each file in the folder. We’re lucky this folder only contains four screenshots. It can quickly get repetitive<a id="_idIndexMarker037"/> and tiresome with a folder of <span class="No-Break">more files.</span></p>
			<h4>CLI</h4>
			<p>Let’s see how much<a id="_idIndexMarker038"/> faster the CLI can be. Let’s open the terminal and navigate to the folder with <span class="No-Break">the files:</span></p>
			<pre class="console">
cd ~/Desktop/screenshots/</pre>
			<p>Let’s view what currently exists in the folder by typing the <span class="No-Break"><strong class="source-inline">ls</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
mmontagnino@Marians-MacBook-Pro screenshots % ls
Screen Shot 2022-12-20 at 10.27.55 PM.png
Screen Shot 2022-12-20 at 10.32.48 PM.png
Screen Shot 2022-12-26 at 5.24.48 PM.png
Screen Shot 2022-12-27 at 12.08.12 AM.png</pre>
			<p>Let’s run a cleverly crafted command that loops through each file in the current directory and renames it (using <strong class="source-inline">mv</strong>) to translate the whitespace to <span class="No-Break">an underscore:</span></p>
			<pre class="console">
for file in *; do mv "$file" `echo $file | tr ' ' '_'` ; done</pre>
			<p>Let’s run the <strong class="source-inline">ls</strong> command <a id="_idIndexMarker039"/>again to see <span class="No-Break">what’s changed:</span></p>
			<pre class="console">
mmontagnino@Marians-MacBook-Pro screenshots % ls
Screen_Shot_2022-12-20_at_10.27.55_PM.png
Screen_Shot_2022-12-20_at_10.32.48_PM.png
Screen_Shot_2022-12-26_at_5.24.48_PM.png
Screen_Shot_2022-12-27_at_12.08.12_AM.png</pre>
			<p>Wow! We’ve just run a single command and the files are automatically renamed! This is just one example to show the power <a id="_idIndexMarker040"/>of CLIs and how much faster tasks can be executed compared to <span class="No-Break">a GUI.</span></p>
			<h3>The comeback</h3>
			<p>The reason there’s been a comeback of<a id="_idIndexMarker041"/> the CLI within recent years is because of these many benefits. The GUI can be resource-intensive, tedious when performing repetitive tasks, and <span class="No-Break">sometimes slow.</span></p>
			<p>The CLI, on the other end of the spectrum, is lightweight, scriptable, and fast. The advantages don’t end there. The CLI might even offer commands and parameters that are not available, or are unthinkable, within the GUI. There’s much to be admired and it’s also a <span class="No-Break">little mysterious.</span></p>
			<p>I’m crushing a little on the CLI here! Jokes aside, to be fair to the attractive GUI, it has visual cues that allow the user to be self-guided. The all-too-mysterious CLI, on the other hand, requires help and man pages to understand its available parameters <span class="No-Break">and options.</span></p>
			<p>Though it may appear difficult to understand, once understood, the power of the CLI becomes apparent <span class="No-Break">and inspiring.</span></p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor020"/>The philosophy of CLI development</h1>
			<p><strong class="bold">Philosophy</strong> plays a major role in the development of computer science. Throughout history, there have been many great contributions to computer science through philosophy, partially<a id="_idIndexMarker042"/> because many computer scientists were and are also philosophers. It is no surprise that each OS has its own <span class="No-Break">distinct philosophy.</span></p>
			<p><strong class="bold">Windows</strong>, for example, hardcodes <a id="_idIndexMarker043"/>most of its intelligence within the program or OS, assuming users’ ignorance and limiting their flexibility. Although the barrier to understanding is lower, users interact with the program without understanding how <span class="No-Break">it works.</span></p>
			<p>The developers of <strong class="bold">UNIX</strong> had an opposing philosophy: provide the user with almost limitless possibilities to empower them. Although the learning curve is steep, much more can be developed within an environment that doesn’t shield its users from the complexity <span class="No-Break">of freedom.</span></p>
			<p>There have been many books written about UNIX’s philosophy and implementing it in real life is an art form. I am sure, therefore, many people view coding as a craft. Although there are many other philosophies to review, the focus in this section will be on <span class="No-Break">UNIX’s </span><span class="No-Break"><a id="_idIndexMarker044"/></span><span class="No-Break">philosophy.</span></p>
			<p>The legendary designers of the Go programming language, Ken Thompson, Robert Griesemer, and Rob Pike, share a long history with UNIX, and it feels fitting to discuss the philosophy within the context of its creators since Go was built <span class="No-Break">around it.</span></p>
			<p><strong class="bold">UNIX’s philosophy</strong> advocates for simple and modular designs that are both extensible and composable. The <a id="_idIndexMarker045"/>basis is that the relationships between numerous small programs are more powerful than the programs themselves. For example, many UNIX programs handle simple tasks in isolation, but when combined, these simple tools can be orchestrated in a very <span class="No-Break">powerful way.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor021"/>Checklist for a successful CLI</h2>
			<p>The following are <a id="_idIndexMarker046"/>some principles inspired by this UNIX philosophy that when followed will help create a <span class="No-Break">successful CLI:</span></p>
			<ul>
				<li><strong class="bold">Building a </strong><span class="No-Break"><strong class="bold">modular program</strong></span></li>
			</ul>
			<p>Design your CLI with standardization in mind to ensure it can be easily composed with other applications. Specifically utilizing standard in and out, standardized errors, signals, and exit codes helps to build a program that is both modular and easily composable. Composability can be handled simply with pipes and shell scripts, but there are also programming languages that can help piece programs together. <strong class="bold">Continuous Integration/Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>), orchestration, and <a id="_idIndexMarker047"/>configuration management tools are often built on top of command-line execution and scripts to automate code integration or deployment or to configure machines. Consider the data output from your program and how easily composable it is. The best options are plain text or JSON when structure <span class="No-Break">is needed.</span></p>
			<ul>
				<li><strong class="bold">Building for </strong><span class="No-Break"><strong class="bold">humans first</strong></span></li>
			</ul>
			<p>The first CLI commands were written with the assumption that they’d only be used by other programs. This is no longer the case, and so programs should be built with humans first <span class="No-Break">in mind.</span></p>
			<p>Conversation<a id="_idIndexMarker048"/> will be the main method of human-computer interaction. Imagine the natural flow of human conversation and how that concept can be applied to help a user who has misunderstood the program design. In natural language, your program can suggest possible corrections, the current state in a multi-step process, and request confirmation before continuing to do something risky. In the best-case scenario, your user has had a pleasant experience with your CLI, feeling empowered to discover operations and receiving assistance when needed. In the worst-case scenario, your user feels ignored and frustrated with no help in sight. Don’t be <span class="No-Break">that CLI!</span></p>
			<p>Finally, write readable code so other developers can easily maintain your program in <span class="No-Break">the future.</span></p>
			<ul>
				<li><strong class="bold">Separating interfaces from engines and policies </strong><span class="No-Break"><strong class="bold">from mechanisms</strong></span></li>
			</ul>
			<p>Decoupling these allows different applications to use the same engine through interfaces or use the same mechanism with <span class="No-Break">different policies.</span></p>
			<ul>
				<li><strong class="bold">Keeping </strong><span class="No-Break"><strong class="bold">it simple</strong></span></li>
			</ul>
			<p>Only add complexity when it’s necessary. When complexity does occur, fold it into the data instead of the logic. Where usability is not compromised, use <span class="No-Break">existing patterns.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Staying small</strong></span></li>
			</ul>
			<p>Don’t write a big program unless there’s no <span class="No-Break">other way.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Being transparent</strong></span></li>
			</ul>
			<p>Be as transparent as possible so users can understand how to use the program and what’s going on. Transparent programs have comprehensive help texts and provide lots of examples allowing users to easily discover the parameters and options they need and have the confidence to execute them. The GUI certainly has a leg up in terms of transparency and visibility; however, we can learn from it and see what can be incorporated to make the CLI easier to learn and use. Users resorting to Google or Stack Overflow is an <span class="No-Break">anti-pattern here.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Being robust</strong></span></li>
			</ul>
			<p>Robustness<a id="_idIndexMarker049"/> is the result of the former principle: transparency and simplicity. The program should work in a way that the user expects, and when errors occur, explain what is happening clearly with suggestions for resolution. Immediately printing stack traces or not informing the user with a clear and immediate response leaves the user feeling like they are on <span class="No-Break">shaky ground.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">No surprises</strong></span></li>
			</ul>
			<p>Keep your program intuitive by building on top of a user’s existing knowledge. For example, a logical operator such as <strong class="source-inline">+</strong> should always mean addition and <strong class="source-inline">-</strong> should always mean subtraction. Make your program intuitive by staying consistent with pre-existing knowledge and patterns <span class="No-Break">of behavior.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Being succinct</strong></span></li>
			</ul>
			<p>Don’t print output unnecessarily and don’t be completely silent, leaving the user to wonder what’s going on. There’s a balance in communication required to say exactly what needs to be said; no more, no less. Too much is a large block of verbose text that forces the user to parse through it to find useful information. Too little is when the command prompt hangs in silence leaving the user to assume a state about <span class="No-Break">the program.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Failing noisily</strong></span></li>
			</ul>
			<p>Repair what can be repaired, and when the program fails, fail noisily and as soon as possible. This will prevent incorrect output from corrupting other programs depending <span class="No-Break">on it.</span></p>
			<ul>
				<li><strong class="bold">Saving </strong><span class="No-Break"><strong class="bold">your time</strong></span></li>
			</ul>
			<p>Build code to save developers’ time as opposed to the machine’s time, which is relatively cheap these days. Also, write programs that generate programs. It’s much faster and less error-prone for computers to generate code <span class="No-Break">over hand-hacking.</span></p>
			<ul>
				<li><strong class="bold">Building a prototype first, </strong><span class="No-Break"><strong class="bold">then optimizing</strong></span></li>
			</ul>
			<p>Sometimes, programmers spend too much time optimizing early on for marginal gains. First, get it<a id="_idIndexMarker050"/> working, and then <span class="No-Break">polish it.</span></p>
			<ul>
				<li><strong class="bold">Building </strong><span class="No-Break"><strong class="bold">flexible programs</strong></span></li>
			</ul>
			<p>Programs may be used in ways the developers did not intend. Therefore, making the design flexible and open will allow the program to be used in <span class="No-Break">ways unintended.</span></p>
			<ul>
				<li><strong class="bold">Designing </strong><span class="No-Break"><strong class="bold">for extensibility</strong></span></li>
			</ul>
			<p>Extend the lifespan of your program by allowing protocols to <span class="No-Break">be extensible.</span></p>
			<ul>
				<li><strong class="bold">Being a good </strong><span class="No-Break"><strong class="bold">CLI citizen</strong></span></li>
			</ul>
			<p>Bring empathy into the design and peacefully coexist with the rest of the <span class="No-Break">CLI ecosystem.</span></p>
			<p>The philosophy directly influences the guidelines for creating a CLI. In the next section, you will clearly see the link to satisfy the philosophy tenets discussed, and if anything, following the guidelines will increase the odds of creating a <span class="No-Break">successful CLI.</span></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor022"/>The guidelines</h1>
			<p>These guidelines have been formulated since the first CLI and have continued to evolve through the many years of developer and user experience. Following these guidelines will increase your chances of CLI success; however, there may be times when you decide to go your own way<a id="_idIndexMarker051"/> and follow an anti-pattern. There could be many reasons to choose an unconventional route. Remember that these are just guidelines and there are no hard and <span class="No-Break">fast rules.</span></p>
			<p>For life, and building CLIs, to be fun, we must allow a little chaos and the freedom necessary to <span class="No-Break">be creative.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor023"/>Name</h2>
			<p>The <strong class="bold">name</strong> of the CLI holds significant weight as the name may convey symbolic ideas beyond the initial intention. People<a id="_idIndexMarker052"/> do not like to think more than necessary, so it’s best to choose a name that is simple, memorable, and easy to pronounce. It’s amazing how many CLI program names have been chosen so arbitrarily without <span class="No-Break">much thought.</span></p>
			<p>There have been studies that support the linguistic Heisenberg principle: <em class="italic">labeling a concept changes how people </em><span class="No-Break"><em class="italic">perceive it</em></span><span class="No-Break">.</span></p>
			<p>Hence, keep it short and easy to type. Use entirely lowercase variables in the name and only use dashes when <span class="No-Break">absolutely necessary.</span></p>
			<p>Some of my favorite application names are clear in the way that they plainly describe the application’s purpose in a creative manner. For <a id="_idIndexMarker053"/>example, <strong class="bold">Homebrew</strong> is a package manager for installing applications on macOS. A brew is a concoction of various ingredients, like a recipe, or in this particular case, a formula, to describe how to install an application. Another great example is <strong class="source-inline">imagemagick</strong>, a command-line application that lets you read, process, or create images magically! Truly, as Arthur C. Clark writes, “<em class="italic">Any sufficiently advanced technology is indistinguishable from magic</em>.” Other internal commands we are familiar with are <strong class="source-inline">mkdir</strong>, for make directory, <strong class="source-inline">rm</strong>, for remove, and <strong class="source-inline">mv</strong>, for move. Their popularity is partially a result of the transparent nature of their names, rendering them <span class="No-Break">nearly unforgettable.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor024"/>Help and documentation</h2>
			<p>One of the tenets of the UNIX philosophy is transparency, possible mainly through the help and <a id="_idIndexMarker054"/>documentation present within the CLI. For new users of the CLI that are in discovery mode, the help and documentation are one of the first sections they will visit. There are a few guidelines to make the help and documentation more easily accessible to <span class="No-Break">the user.</span></p>
			<h3>Help</h3>
			<p>It is a good practice to display help by default when just the command name is entered or with either the <strong class="source-inline">-h</strong> or <strong class="source-inline">–help</strong> flag. When you <a id="_idIndexMarker055"/>display the help text, make sure it’s formatted and concise with the most frequently used arguments and flag options at the top. Offer usage examples, and if a user misuses the CLI, the program can guess what the user tried to attempt, providing suggestions and <span class="No-Break">next steps.</span></p>
			<h3>Documentation</h3>
			<p>Provide either man pages or terminal-based or web-based documentation, which can provide additional examples of usage. These types of documentation may be linked from the help page as an extension of the resources for gaining an understanding of how the <span class="No-Break">CLI works.</span></p>
			<h3>Support</h3>
			<p>Oftentimes, users will <a id="_idIndexMarker056"/>have suggestions or questions on how to use the CLI. Providing a support path for feedback and questions will allow users to give the CLI designer a new perspective on the usage of their CLI. When collecting analytics, be transparent and don’t collect users’ address, phone, or usage data <span class="No-Break">without consent.</span></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor025"/>Input</h2>
			<p>There are several <a id="_idIndexMarker057"/>ways a CLI retrieves input, but mainly through arguments, flags, and subcommands. There is a general preference for using flags over arguments and making the default the right thing for <span class="No-Break">most users.</span></p>
			<h3>Flags</h3>
			<p>The guideline for flags is that ideally, there exists a full-length version for all flags. For example, <strong class="source-inline">-h</strong> has <strong class="source-inline">--help</strong>. Only use <strong class="source-inline">–</strong>, a single dash, or shorthand notation for commonly used flags and <a id="_idIndexMarker058"/>use standard names where there <span class="No-Break">is one.</span></p>
			<p>The following is a list of some standard flags that <span class="No-Break">already exist:</span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Flag</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Usage</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">a</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">--all</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">All</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">d</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">–debug</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Debug</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">f</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">--force</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Force</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">json</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Display <span class="No-Break">JSON output</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">h</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">--help</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Help</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">no-input</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Disable prompt <span class="No-Break">and interactivity</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">o</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">--output</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Output file</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">p</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">--port</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Port</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">q</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">--quiet</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Quiet mode</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">u</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">--user</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">User</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">version</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Version</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-v</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Version <span class="No-Break">or verbose</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-d</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Verbose</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1: Standard flags</p>
			<h3>Arguments</h3>
			<p>Multiple arguments are fine for simple actions taken on several files. For example, the <strong class="source-inline">rm</strong> command runs <a id="_idIndexMarker059"/>against more than one file. Although, if there exist two or more arguments for different things, you might need to rethink the structure of your command and choose a flag option over an <span class="No-Break">additional argument.</span></p>
			<h3>Subcommands</h3>
			<p>The guidelines for <a id="_idIndexMarker060"/>subcommands are that they remain consistent and unambiguous. Be consistent with the structure of subcommands; either <em class="italic">noun-verb</em> or <em class="italic">verb-noun</em> order works, but <em class="italic">noun-verb</em> is much more common. Sometimes, a program offers ambiguous subcommands, such as <strong class="source-inline">apt update</strong> versus <strong class="source-inline">apt upgrade</strong>, which causes many, including myself, confusion. Try to <span class="No-Break">avoid this!</span></p>
			<p>Validate the user’s input early, and if it’s invalid, fail early before anything bad happens. Later in this book, we will guide you through using Cobra, a popular and highly recommended command-line parser for Go, to validate <span class="No-Break">user input.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor026"/>Output</h2>
			<p>Because CLIs are built for<a id="_idIndexMarker061"/> humans and machines, we need to consider that output must be easily consumed by both. I will break down guidelines for both <strong class="source-inline">stdout</strong> and <strong class="source-inline">stderr</strong> streams for both humans and machines. Standard output, <strong class="source-inline">stdout</strong>, is the default file descriptor where a process can write output, and standard error, <strong class="source-inline">stderr</strong>, is the default file descriptor where a process can write <span class="No-Break">error messages:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">stdout</strong></span></li>
			</ul>
			<p>A guideline for standard output for humans is to make the responses clear, brief, and comprehensible for<a id="_idIndexMarker062"/> the user. Utilize ASCII art, symbols, emojis, and color to improve information density. Finally, consider simple machine-readable output where usability is <span class="No-Break">not impacted.</span></p>
			<p>A guideline for standard output for machines is to extract any extraneous substance from the above response so that it is simply formatted machine-readable text to be piped into another command. When simple machine-readable text is not output by default, utilize the <strong class="source-inline">-q</strong> flag to suppress non-essential output and <strong class="source-inline">--plain</strong> to display machine-readable text. Disable color with the <strong class="source-inline">--no-color</strong> option, by setting the <strong class="source-inline">NO_COLOR</strong> environment variable, or a custom <strong class="source-inline">MYAPP_NO_COLOR</strong> environment variable specific to <span class="No-Break">your program.</span></p>
			<p>Additionally, don’t use<a id="_idIndexMarker063"/> animations in <strong class="source-inline">stdout</strong> because it’s not an <span class="No-Break">interactive terminal.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">stderr</strong></span></li>
			</ul>
			<p>Things can go wrong during the execution of a command, but it doesn’t have to feel like a catastrophic event. Sometimes<a id="_idIndexMarker064"/> loud full stack traces are the response to a command failure, and that can make the heart skip a beat. Catch errors and gracefully respond to the user with rewritten error messages that can offer a clear understanding of what happened and suggestions for the next steps. Make sure there’s no irrelevant or noisy output, considering we want it to be easy to understand the error. Also, provide users with additional debug and traceback information and an option to submit bugs. Non-error messages should not go to <strong class="source-inline">stderr</strong>, and debug and warning messages should go to <span class="No-Break"><strong class="source-inline">stdout</strong></span><span class="No-Break"> instead.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">As for general guidelines for CLI output, return a zero exit code on success and a non-zero code that the machine can interpret as not just a failure but even a particular type of failure on which to take <span class="No-Break">further action.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor027"/>Configuration</h2>
			<p>Users may configure their <a id="_idIndexMarker065"/>CLI by using flags, environment variables, and files to determine how specifically to invoke the command and stabilize it across different users <span class="No-Break">and environments:</span></p>
			<ul>
				<li><strong class="bold">Flags and </strong><span class="No-Break"><strong class="bold">environment variables</strong></span></li>
			</ul>
			<p>By using flags or environment variables, users may configure how to run <span class="No-Break">a command.</span></p>
			<p>Examples include <span class="No-Break">the following:</span></p>
			<ul>
				<li>A specified level of <span class="No-Break">debug output</span></li>
				<li>Dry <span class="No-Break">run commands</span></li>
			</ul>
			<p>Alternatively, they can be used to configure between <span class="No-Break">different environments.</span></p>
			<p>Examples include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Providing a<a id="_idIndexMarker066"/> non-default path to files required for the program <span class="No-Break">to execute</span></li>
				<li>Specifying the type of output (text <span class="No-Break">versus JSON)</span></li>
				<li>Specifying an HTTP proxy server to route <span class="No-Break">requests through</span></li>
			</ul>
			<p>When using environment variables in configuration, set names appropriately, using a combination of all uppercase text, numbers, and underscores, and take the time to ensure you are not using the name of an already-existing <span class="No-Break">environment variable.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">XDG Spec</strong></span></li>
			</ul>
			<p>Configure stability across multiple environments by following the XDG Spec (X Desktop Group, <a href="http://freedesktop.org">freedesktop.org</a>), which specifies<a id="_idIndexMarker067"/> the location for base directories where configuration files may be located. This spec is supported by many popular tools, such as Yarn, Emacs, and tmux, to name <span class="No-Break">a few.</span></p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor028"/>Security</h2>
			<p>Do not store secrets and <a id="_idIndexMarker068"/>passwords in environment variables or pass them in via an argument or flag. Instead, store them in a file and use the <strong class="source-inline">--password-file</strong> argument to allow the secret to be passed <span class="No-Break">in discretely.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor029"/>Open source community</h2>
			<p>Once your CLI is complete and ready to be distributed, there are several guidelines to follow. If possible, distribute it within a single binary targeted to a user’s specific platform and architecture. If the user no longer wants or needs your program, make sure it’s easy to <span class="No-Break">uninstall too!</span></p>
			<p>Since you’ll be <a id="_idIndexMarker069"/>writing your CLI in Go, it would be great to encourage contributions to your program. You may offer a contribution guideline doc that guides users toward commit syntax, code quality, required tests, and other standards. You could also choose to allow users to extend the CLI by writing plugins that can work with your CLI, break up functionality across more modular components, and <span class="No-Break">increase composability.</span></p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor030"/>Software lifespan and robustness</h2>
			<p>To ensure your CLI will <a id="_idIndexMarker070"/>continue to work well in the future, there are a few guidelines to follow specific to robustness to make sure your program has a <span class="No-Break">long lifespan:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Future-proofing</strong></span></li>
			</ul>
			<p>When you make any changes to your CLI, over time, it’s best to make these changes additive, but if not, warn your users of the change. Changing human-readable output is usually fine, but it’s best to keep the machine-readable output stable. Consider how external dependencies may cut short your program’s lifespan and think of ways to make your application stable amidst external <span class="No-Break">dependency failures.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Robustness</strong></span></li>
			</ul>
			<p>For a CLI to achieve maximum robustness, the CLI must be designed with full transparency. The program needs to feel responsible for the user; so, show progress if something takes a long time and don’t let the program hang. Make programs timeout when they are taking a long time. When the user inputs a command, validate the usage immediately, giving clear feedback when there’s apparent misuse. When there’s a failure due to some transient reason, exit the program immediately upon failure or interruption. When the program is invoked again, it should pick up immediately where it <span class="No-Break">left off.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Empathy</strong></span></li>
			</ul>
			<p>Adding some thoughtful detail to the command-line design will create a pleasant experience for the user. CLIs should be fun to use! Even when things go wrong, with a supportive design, the users can feel encouraged on their pathway to successfully <a id="_idIndexMarker071"/>using the CLI. The modern CLI philosophy and guidelines reflect a level of empathy toward humans already and, thank goodness, we’ve come a long way from the initial command-line tools and will continue to <span class="No-Break">do better.</span></p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor031"/>Go for CLIs</h1>
			<p>The very same overarching<a id="_idIndexMarker072"/> reasons I suggest engineers learn Go are the very same reasons I suggest using Go to build your CLI, but the very history of modern CLIs, which began in the 1960s with the UNIX shell, invented at Bell Labs by Ken Thompson, co-inventor of Golang, holds much weight. The UNIX philosophy, which inspires our modern CLI philosophy and guidelines, is built into the language, and it’s clear that many <a id="_idIndexMarker073"/>benefits have been born out of this way <span class="No-Break">of thinking:</span></p>
			<ul>
				<li><strong class="bold">Performance, scalability, </strong><span class="No-Break"><strong class="bold">and power</strong></span></li>
			</ul>
			<p>Golang is quite fast in its compilation and execution. For example, Kubernetes, which is written in Go, has 5 million lines of application code that compile within a couple of minutes. Any other language would take 10 minutes to several hours to compile. Go translates its source code to machine code within its own optimized compiler, allowing easier dependency management. Also, because Golang is still a young language, it’s built for contemporary <span class="No-Break">hardware requirements.</span></p>
			<p><em class="italic">Goroutines</em> are lightweight threads that run concurrently. In my experience programming, I have not seen simplicity and multi-threading go hand in hand, but Golang achieves this extremely well. This feature won <span class="No-Break">my heart.</span></p>
			<p>The performance and scalability of Go are an obvious draw to the cloud computing community. Many CLIs for cloud computing were written in Go, Docker and<a id="_idIndexMarker074"/> Kubernetes included. Any application with a growing user base or a high number of traffic requests needs to consider Golang. Companies such as Uber and Comcast have chosen Go for this reason <span class="No-Break">as well.</span></p>
			<ul>
				<li><strong class="bold">Simplification </strong><span class="No-Break"><strong class="bold">of development</strong></span></li>
			</ul>
			<p>Golang felt easier to learn than any other language I’ve ever encountered. The language supports a clean, simple, and fast environment, which is impressive, considering the powerful tools that Go has created. Golang also has many tools that allow the speed and accuracy of development, including formatting tools, testing frameworks, a great linter, and tools to perform <span class="No-Break">static analysis.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Versatility</strong></span></li>
			</ul>
			<p>Go makes cross-compilation so easy. You can build your application for many different OSs and architectures, increasing accessibility to your CLI. Although executing within different environments, if properly configured, it will work similarly. This will ease users’ minds. Later on in this book, we will discuss how to create binaries for <span class="No-Break">different platforms.</span></p>
			<ul>
				<li><strong class="bold">Growing </strong><span class="No-Break"><strong class="bold">your skillset</strong></span></li>
			</ul>
			<p>Golang is among the most popular languages to learn. Given its many apparent benefits, more start-ups and enterprises are choosing Golang and the demand for Golang developers <span class="No-Break">is growing.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Community</strong></span></li>
			</ul>
			<p>If you choose Go, you’ll be a part of a community of enthusiastic open source developers, willing to partake in the evolutionary journey of a young <span class="No-Break">programming language.</span></p>
			<p>For beginners who are building a <a id="_idIndexMarker075"/>CLI in Go for the first time, the next chapters ahead show how clear it is. Golang is an excellent choice for building a CLI, and when there’s a need for scalability, performance, and cross compilation, the choice will play in <span class="No-Break">your favor.</span></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor032"/>Summary</h1>
			<p>In this chapter, you learned about the scientific discoveries and inventions that led to the creation of the CLI and the remnants of the past that still exist within the <span class="No-Break">terminal today.</span></p>
			<p>Besides a detailed breakdown of the CLI into its parts, this chapter also discussed what a CLI is, overall, and what it is used for. The co-creator of UNIX and Golang, Ken Thompson, influences the philosophy around CLIs and programming in general. This philosophy has been influenced by human and computer interaction over the decades. As with anything with a long history, some ancestral baggage has followed. We learned that in the past, CLIs were primarily written for computers, and today are primarily written for humans. A new element to the UNIX philosophy had to be added: empathy as a <span class="No-Break">cultural norm.</span></p>
			<p>This chapter dug into the guidelines that ultimately embody the UNIX philosophy and why Golang is the best language to implement such <span class="No-Break">a design.</span></p>
			<p>In <a href="B18883_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Structuring Go Code for CLI Applications</em>, we will discuss the first step of project creation: <span class="No-Break"><strong class="bold">folder structure</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor033"/>Questions</h1>
			<ol>
				<li value="1">What is the TTY on a Linux machine and what is the history behind <span class="No-Break">this command?</span></li>
				<li>Which of the core elements of UNIX’s philosophy do you resonate with the <span class="No-Break">most? Why?</span></li>
				<li>Who are the co-creators of Golang and what is their relationship to the <span class="No-Break">UNIX OS?</span></li>
				<li>Can you still visit BBSs today and play some of the old text-based games of <span class="No-Break">the past?</span></li>
				<li>Which of the CLI guidelines feels second nature to you and which guidelines would require <span class="No-Break">extra effort?</span></li>
			</ol>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor034"/>Answers</h1>
			<ol>
				<li value="1">TTY is a command in UNIX and Linux to display the name of the terminal connected to standard input. TTY is derived from the word teletypewriter, which was the default form of interacting with large mini and <span class="No-Break">mainframe computers.</span></li>
				<li>This answer is subjective. However, I like the element of building a prototype first and optimizing second. I prefer the process of building a simple proof of concept that can be used as inspiration. Optimization and refinement can always <span class="No-Break">come later.</span></li>
				<li>Golang was created by Robert Griesemer, Rob Pike, and Ken Thompson. Ken Thompson also created the UNIX OS and Rob Pike was a member of the <span class="No-Break">UNIX team.</span></li>
				<li>You can still visit BBSs today by downloading a telnet client, for example, CGTerm, and connect to over 1,000 different BBSs still running today. View the list <span class="No-Break">at </span><a href="https://www.telnetbbsguide.com/"><span class="No-Break">https://www.telnetbbsguide.com/</span></a><span class="No-Break">.</span></li>
				<li>This answer is subjective. However, I find it second nature to put effort into building constructive help text. Conversely, I think it takes extra effort to write out complete and <span class="No-Break">up-to-date documentation.</span></li>
			</ol>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor035"/>Further reading</h1>
			<ul>
				<li>PhiloComp.net (<a href="https://philocomp.net/">https://philocomp.net/</a>) is an educational website for both computer scientists and philosophers to learn the links between the disciplines, expanding their view of the other and <span class="No-Break">of themselves</span></li>
				<li>Command Line Interface Guidelines (<a href="https://clig.dev">https://clig.dev</a>) is an excellent resource with plenty of examples of creating CLI applications that adhere strongly to the <span class="No-Break">UNIX philosophy</span></li>
			</ul>
		</div>
	</body></html>