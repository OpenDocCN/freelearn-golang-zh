- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding CLI Standards
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解CLI标准
- en: The **Command-Line Interface** (**CLI**) is a text-based interface for humans,
    and computer interaction was initially designed as a way of interacting with an
    **Operating System** (**OS**) before the desktop graphical interface was invented.
    The CLI, as we know it today, was in popular use in the 1960s until the graphical
    desktop interface was developed a decade later. However, although most computer
    users are used to the **graphical user interface** (**GUI**) and web, there’s
    been a resurgence of CLI development circa 2017\. Popular and new use cases for
    the retro CLI vary, but its most popular usage is as an additional offering alongside
    a company’s API for increased platform usage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行界面（CLI**）是供人类使用的基于文本的界面，计算机交互最初是为了在桌面图形界面发明之前与**操作系统（OS**）交互而设计的。正如我们所知，CLI在20世纪60年代非常流行，直到十年后图形桌面界面被开发出来。然而，尽管大多数计算机用户习惯于**图形用户界面（GUI**）和网页，但CLI开发在2017年左右出现了复兴。复古CLI的流行和新用途各不相同，但最流行的用途是作为公司API的附加服务，以增加平台的使用。'
- en: In this chapter, you will learn about the comprehensive history of the CLI,
    what it is today, and a breakdown of its anatomy. You will learn about UNIX’s
    philosophy and how following its principles will guide you toward the creation
    of a successful CLI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解CLI的全面历史、它今天的状况以及其结构的分解。你将了解UNIX的哲学以及遵循其原则将如何指导你创建一个成功的CLI。
- en: By the end of this chapter, you’ll have a deeper understanding of the CLI, how
    best to design and implement proven, time-tested standards, and why Go, which
    has become an increasingly popular language, has a compelling case for being the
    best language to build your CLI.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将更深入地了解CLI，如何最好地设计和实施经过验证、经得起时间考验的标准，以及为什么Go语言，它已经成为越来越受欢迎的语言，有充分的理由成为构建CLI的最佳语言。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: A brief introduction and history of the command line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行的简要介绍和历史
- en: The philosophy of CLI development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLI开发的哲学
- en: Modern CLI guidelines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代CLI指南
- en: Go for CLIs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择CLI
- en: A brief introduction and history of the command line
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行的简要介绍和历史
- en: The CLI is the result of the evolution of a much broader human-computer interaction,
    specifically communication and language processing. Let’s begin the story with
    the creation of the first compiler, which took us from using punch cards to programming
    languages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行界面（CLI）是人类与计算机交互进化的结果，特别是通信和语言处理。让我们从第一个编译器的创建开始讲起，它使我们从使用穿孔卡片过渡到编程语言。
- en: About the history
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于历史
- en: The first computer compiler was written by Grace Hopper. A compiler was able
    to translate written code to machine code and lifted the great burden off programmers
    of the time consumption of writing machine code manually. Grace Hopper also invented
    the COBOL programming language in 1959\. In that era, punch cards were used for
    data processing applications or to control machinery. They would contain COBOL,
    Fortran, and Assembly code. The compiler and advancement of new programming languages
    eased the task of programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一台计算机编译器是由格蕾丝·霍珀编写的。编译器能够将书面代码翻译成机器代码，从而减轻了当时程序员手动编写机器代码的巨大负担。格蕾丝·霍珀还在1959年发明了COBOL编程语言。在那个时代，穿孔卡片被用于数据处理应用或控制机械。它们会包含COBOL、Fortran和汇编代码。编译器和新编程语言的进步简化了编程任务。
- en: The same year, the microchip was invented by Jack Kilby and Robert Noyce. Much
    less expensive, small-scale computers were made possible and, finally, *human-in-the-loop*,
    a back-and-forth interaction between the human and computer, became feasible.
    Computers were now multitasking and time-sharing systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 同年，杰克·基尔比和罗伯特·诺伊斯发明了微芯片。这使得小型计算机的成本大幅降低，最终实现了人机交互，即人与计算机之间的双向互动，成为可能。计算机现在可以进行多任务处理和时间共享系统。
- en: At this point, keyboards became the main method of interacting with computers.
    By the early 1960s, engineers had attached a **Cathode Ray Tube** (**CRT**) monitor
    to the **TeleTYpewriter** (**TTY**) machine. This combination of the CRT and TTY
    was called a *glass TTY* and marked the beginning of what we consider the modern
    monitor.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，键盘成为了与计算机交互的主要方法。到20世纪60年代初，工程师们将阴极射线管（CRT）显示器连接到了电传打字机（TTY）机器上。这种CRT和TTY的组合被称为“玻璃TTY”，标志着我们认为是现代显示器时代的开始。
- en: In 1966, the CRT and teletype machine, which combined the technologies of the
    electric telegraph, telephone, and typewriter, were about to merge with the final
    missing puzzle piece, the computer. The teletype computer interface was born.
    Users would type a command, hit the *Enter* key, and the computer would respond.
    These were called *command-line interfaces*!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在1966年，阴极射线管和电传打字机，它们结合了电报、电话和打字机的技术，即将与最后一块缺失的拼图——计算机——合并。电传计算机接口应运而生。用户会输入一条命令，按下*Enter*键，然后计算机就会响应。这些被称为*命令行界面*！
- en: There were so many more exciting developments that followed, from the invention
    of ASCII characters in 1963 to the internet in 1969, UNIX in 1971, and email in
    1972\. Lexical analysis parsers in 1975 played a major part in the development
    of programming languages. Text-based adventure games provided amusement for the
    tech savvy by 1977, and the beginnings of the GUI emerged in the 1970s.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从1963年发明ASCII字符到1969年的互联网，1971年的UNIX和1972年的电子邮件，再到1975年的词法分析解析器在编程语言发展中的重要作用，以及1977年基于文本的冒险游戏为技术爱好者提供娱乐，以及1970年代图形用户界面（GUI）的诞生，之后还有许多令人兴奋的发展。
- en: A network of these computers would not have been possible if not for the evolution
    of the telephone. In 1964, the acoustic **modulator/demodulator** (**modem**)
    was used to transmit data between a telephone line and a computer. The acoustic
    modem brought us the **wide area network** (**WAN**), **local area network** (**LAN**),
    and the broadband we know of today. LAN parties peaked in the 1990s and carried
    on well into the early 2000s.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有电话的演变，这些计算机网络的建立是不可能的。在1964年，声学**调制解调器**（**modem**）被用来在电话线和计算机之间传输数据。声学调制解调器为我们带来了**广域网**（**WAN**）、**局域网**（**LAN**）以及我们今天所知道的宽带。局域网聚会达到顶峰是在1990年代，并且一直持续到21世纪初。
- en: In 1978, the first public dial-up **bulletin board system** (**BBS**) was developed
    by Ward Christensen and Randy Suess, who also created the **computerized bulletin
    board system** (**CBBS**). With a modem, users could dial into servers running
    the CBBS software and connect via a terminal program. Throughout the 1980s, BBS’s
    popularity grew to fantastic heights, and even in the mid-1990s, BBSs served the
    greater collective market compared to emerging online service providers such as
    CompuServe and **America** **Online** (**AOL**).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在1978年，第一个公开的拨号**公告板系统**（**BBS**）由沃德·克里斯滕森和兰迪·苏斯开发，他们还创建了**计算机化公告板系统**（**CBBS**）。有了调制解调器，用户可以通过终端程序拨入运行CBBS软件的服务器并连接。在整个1980年代，BBS的普及度达到了惊人的高度，甚至在1995年中期，BBS比新兴的在线服务提供商如CompuServe和**美国在线**（**AOL**）服务了更大的集体市场。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This deeper understanding of the history of the CLI may give you a greater appreciation
    for what it is. The terminal is a bit of a time machine. The use of many UNIX
    and DOS commands feels like you’re standing on the shoulders of giants, looking
    down at the long computing history beneath it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对命令行界面历史的深入了解可能会让你更加欣赏它的本质。终端有点像一台时光机。使用许多UNIX和DOS命令感觉就像站在巨人的肩膀上，俯瞰其下的漫长计算历史。
- en: Introducing the CLI
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行界面介绍
- en: Based on the history of the CLI, it’s clear to see that it is a text-based interface
    that allows communication from user to computer, computer to computer, and computer
    back to user. It requires the same specific instructions and clear language as
    the earlier machines it evolved from. Now, let’s dig deeper into CLIs to learn
    about the different kinds, how they are generally structured, and how and why
    they are used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基于命令行界面的历史，很明显它是一种基于文本的界面，允许用户与计算机、计算机与计算机以及计算机与用户之间的通信。它需要与它所演变而来的早期机器相同的特定指令和清晰的语言。现在，让我们更深入地了解命令行界面，了解它们的种类、一般结构以及它们的使用方式和原因。
- en: Anatomy
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解剖学
- en: 'For any CLI, regardless of the specific type, it’s important to understand
    the anatomy of the commands themselves. Without a particular structure, the computer
    would not be able to properly parse and understand its instructions. The following
    is a simple example that we will use to distinguish the different components of
    a command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何命令行界面，无论具体类型如何，理解命令本身的解剖结构都很重要。如果没有特定的结构，计算机就无法正确解析和理解其指令。以下是一个简单的例子，我们将用它来区分命令的不同组成部分：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the context of this example, the UNIX command, `cat`, is used to view the
    contents of the file, `transcript`. The addition of the `–b` flag tells the command
    to print the line number next to non-empty output lines. We will go into each
    component of the command in detail in the following subsections.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例的上下文中，UNIX 命令 `cat` 用于查看文件 `transcript` 的内容。添加 `-b` 标志告诉命令在非空输出行旁边打印行号。我们将在以下小节中详细讨论命令的每个组成部分。
- en: The prompt
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提示符
- en: A symbol on the terminal indicates to the user that the computer is ready to
    receive a command. The preceding example shows `~` as the command prompt; however,
    this can differ depending on the OS.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 终端上的符号指示用户计算机已准备好接收命令。前面的例子显示了 `~` 作为命令提示符；然而，这可能会根据操作系统而有所不同。
- en: The command
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命令
- en: 'There are two types of commands:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 命令有两种类型：
- en: '`cd`, `date`, and `time` commands. They do not require a search of the `PATH`
    variable to find the executable.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd`、`date` 和 `time` 命令。它们不需要搜索 `PATH` 变量以找到可执行文件。'
- en: '`ls` and `cat`. These are usually located in `/bin` or `/usr/bin` in UNIX and
    require a search of the `PATH` variable to find the executable.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls` 和 `cat`。这些通常位于 UNIX 的 `/bin` 或 `/usr/bin` 中，需要搜索 `PATH` 变量以找到可执行文件。'
- en: The previous example uses `cat` as the external command.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子使用 `cat` 作为外部命令。
- en: Arguments and options
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数和选项
- en: 'Commands usually take in parameters for input that consist of one or many arguments
    and/or options:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 命令通常接受一个或多个参数作为输入，这些参数可以是参数和/或选项：
- en: Arguments are parameters that pass information to the command, for example,
    `mkdir test/`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数是传递信息到命令的参数，例如，`mkdir test/`。
- en: In the preceding code snippet, `test/` is the input parameter to the `mkdir`
    command.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`test/` 是 `mkdir` 命令的输入参数。
- en: Options are flags, or switches, that modify the operation of a command, for
    example `mkdir -``p test/files/`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项是标志或开关，用于修改命令的操作，例如 `mkdir -p test/files/`。
- en: In the preceding example, `-p` is an option to make parent directories if needed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`-p` 是一个选项，如果需要，将创建父目录。
- en: In the example at the start of this section, `-b` is an optional flag, shorthand
    for `--number-nonblank`, which tells the command to print the line number next
    to non-empty lines, and the filename, `transcript`, is an argument passed into
    the command.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节开头示例中，`-b` 是一个可选标志，简写为 `--number-nonblank`，它告诉命令在非空行旁边打印行号，而文件名 `transcript`
    是传递给命令的参数。
- en: Whitespace
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空格
- en: For the OS or application to properly parse these commands, arguments, and options,
    each is delimited by whitespace. Special attention must be paid to the fact that
    whitespaces may exist within the parameter itself. This can cause a bit of ambiguity
    for the command-line interpreter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让操作系统或应用程序正确解析这些命令、参数和选项，每个都由空格分隔。必须特别注意参数本身可能存在空格的事实。这可能会给命令行解释器带来一些歧义。
- en: 'Take care to resolve this ambiguity by replacing spaces within parameters.
    In the following example, we replace the spaces with underscores:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过替换参数内的空格来解决这个问题。在以下示例中，我们用下划线替换空格：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also decide to put quotes around the parameter, as in the following
    example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以选择在参数周围放置引号，如下例所示：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, resolve ambiguity by adding an escape character before each space,
    as in the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过在每个空格之前添加转义字符来解决这个问题，如下例所示：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although whitespace is the most widely used delimiter, it is not universal.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然空格是最常用的分隔符，但它并不通用。
- en: Syntax and semantics
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 语法和语义
- en: The CLI provides the language for communicating with the OS or application.
    Thus, like any language, to be properly interpreted, it requires syntax and semantics.
    The syntax is the grammar defined by the OS or the application vendor. Semantics
    define what operations are possible.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行界面提供了与操作系统或应用程序通信的语言。因此，像任何语言一样，为了被正确解释，它需要语法和语义。语法是由操作系统或应用程序供应商定义的语法。语义定义了可能进行的操作。
- en: 'When you look at some command-line applications, you can see the language being
    used. Sometimes, the syntax differs between tools; I will go over the specifics
    later in this chapter, but, for example, `cat -b transcript` is a command we’ve
    looked at before. The command, `cat`, is a verb, the flag, `-b`, is an adjective,
    and `transcript` is a noun. This is the defined syntax of the `cat` UNIX command:
    verb, adjective, noun.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看一些命令行应用程序时，你可以看到正在使用的语言。有时，不同工具的语法有所不同；我将在本章后面详细说明具体内容，例如，`cat -b transcript`
    是我们之前看过的命令。命令 `cat` 是一个动词，标志 `-b` 是一个形容词，而 `transcript` 是一个名词。这是 `cat` UNIX 命令的既定语法：动词、形容词、名词。
- en: The semantics of the command are defined by what operations are possible. You
    can see this by viewing the options of, for example, the `cat` command, which
    are usually shown in the **usage** section of the help page, which is output when
    a user uses the application incorrectly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的语义由可能进行的操作定义。你可以通过查看 `cat` 命令的选项来看到这一点，这些选项通常显示在帮助页面的 **使用** 部分，当用户错误地使用应用程序时输出。
- en: Help pages
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 帮助页面
- en: Because the CLI is entirely text-based and lacking in visual cues, its usage
    may be ambiguous or unknown. A `-help`, `--help`, or `-h`. The `-h` option is
    an example of an abbreviated shortcut for the help command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CLI 完全是基于文本的，并且缺乏视觉提示，其使用可能是不明确的或未知的。例如 `-help`、`--help` 或 `-h`。`-h` 选项是帮助命令的缩写快捷方式。
- en: 'There’s a common syntax used in built-in help and man pages and following this
    standard will allow users familiar with the standard to easily use your CLI:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在内置帮助和 man 页面中使用的常见语法如下，遵循此标准将使用户熟悉标准，从而轻松使用您的 CLI：
- en: Required parameters are typically represented within angled brackets, for example,
    `ping <hostname>`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必需参数通常用尖括号表示，例如，`ping <hostname>`
- en: Optional parameters are represented within square brackets, for example, `mkdir
    [``option] <dirname>`
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数用方括号表示，例如，`mkdir [``option] <dirname>`
- en: Ellipses represent repeated items, for example, `cp [option]... <``source>...
    <directory>`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 省略号表示重复项，例如，`cp [option]... <``source>... <directory>`
- en: Vertical bars represent a choice of items, for example, `netstat {-t | -``u}`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竖线表示项目之间的选择，例如，`netstat {-t | -``u}`
- en: Usage
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用方法
- en: The CLI was the first interface between the user and the OS used primarily for
    numerical computation, but in time, its usage has expanded in many more practical
    and fun ways.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行界面（CLI）是用户与操作系统之间的第一个接口，主要用于数值计算，但随着时间的推移，其使用方式已经扩展到更多实用和有趣的方式。
- en: 'Let us see some of the uses:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些用法：
- en: '**Editor MACroS** (**Emacs**), one of the earliest forms of a text editor provided
    in UNIX, is a CLI in the form of a mini buffer. Commands and arguments are entered
    as a combination of key presses: either a *Ctrl* character plus a key or a key
    prefixed by a *Ctrl* character and the output displayed within another buffer.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑器宏**（**Emacs**），UNIX 提供的最早的文本编辑器之一，是一种以迷你缓冲区形式的 CLI。命令和参数以按键组合的形式输入：要么是
    *Ctrl* 字符加上一个键，要么是带有 *Ctrl* 字符前缀的键，输出显示在另一个缓冲区中。'
- en: '**Read-Evaluate-Print Loop** (**REPL**) is a Python interactive shell that
    offers a CLI, and according to its name can read, evaluate, print, and loop. It
    allows users a play environment to validate Python commands.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取-评估-打印循环**（**REPL**）是 Python 的交互式外壳，它提供了一个 CLI，根据其名称可以读取、评估、打印和循环。它允许用户在一个游戏环境中验证
    Python 命令。'
- en: '**MajorMUD** and **Lunatix** are just a couple of popular games that were available
    on bulletin board systems. As soon as programmers could turn CLIs into play, they
    did, and while these games were entirely text-based, they were certainly not lacking
    in fun!'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MajorMUD** 和 **Lunatix** 是在公告板系统上可用的几款流行游戏。一旦程序员能够将 CLI 转变为游戏，他们就做到了，虽然这些游戏完全是基于文本的，但它们绝对不乏乐趣！'
- en: Modern video games call their CLI a gaming console. From the console, mod developers
    can run commands to debug, cheat, or skip part of the game.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代视频游戏将他们的 CLI 称为游戏控制台。从控制台，模开发者可以运行命令进行调试、作弊或跳过游戏的一部分。
- en: 'Helper programs often take in parameters to launch a program in a particular
    way. For example, Microsoft Visual Code has a command-line option: `code <filename>`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助程序通常接受参数以以特定方式启动程序。例如，Microsoft Visual Code 有一个命令行选项：`code <filename>`.
- en: Some CLIs are embedded into a web application, for example, web-based SSH programs.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 CLI 集成到网络应用程序中，例如，基于网络的 SSH 程序。
- en: Companies such as AWS offer CLIs alongside their API as an additional way of
    interacting with their platform.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，AWS 这样的公司提供 CLI，作为其 API 之外与平台交互的额外方式。
- en: Last but not least, scripting has allowed engineers to take their CLIs to a
    more interactive level. Within a shell scripting language, programmers can script
    calls to the CLI and capture and manipulate output. The output of one command
    may also be passed as input into another. This makes the CLI a very powerful resource
    for developers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，脚本允许工程师将他们的 CLI 带到更交互化的水平。在 shell 脚本语言中，程序员可以编写对 CLI 的调用脚本，并捕获和操作输出。一个命令的输出也可以作为输入传递给另一个命令。这使得
    CLI 成为开发者非常强大的资源。
- en: Types
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型
- en: 'There are two main types of CLIs:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有两种类型的 CLI：
- en: '**OS CLIs**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统 CLI**'
- en: '**Application CLIs**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序 CLI**'
- en: OS CLIs
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 操作系统 CLI
- en: OS CLIs are often provided alongside the OS. This kind of CLI is referred to
    as a **shell**. It is the command-line interpreter that sits a layer above the
    kernel interpreting and processing commands entered by the user and outputting
    results and a text-based method of interacting with the OS as an alternative to
    the graphical display.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统 CLI 通常与操作系统一起提供。这种 CLI 被称为 **shell**。它是位于内核之上的一层命令行解释器，解释并处理用户输入的命令，并以基于文本的方式与操作系统交互，作为图形显示的替代方案。
- en: Application CLIs
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用程序 CLI
- en: The second type of CLI allows interaction with a specific application running
    on the OS.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型的 CLI 允许与操作系统上运行的具体应用程序进行交互。
- en: 'There are three main types of ways users may interact with an application’s
    CLI:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能以三种主要方式与应用程序的 CLI 交互：
- en: '**Parameters**: They provide input to launch the application in a particular
    way'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：它们为以特定方式启动应用程序提供输入'
- en: '**Interactive command-line sessions**: They are launched after the application
    as an independent and text-alternative method of control'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互式命令行会话**：它们作为独立于应用程序的文本替代控制方法在应用程序之后启动'
- en: '**Inter-process communication**: This allows users to stream or pipe data from
    the output of one program into another'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程间通信**：这允许用户将一个程序输出的数据流或管道传输到另一个程序'
- en: GUI versus CLI example
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图形用户界面 (GUI) 与命令行界面 (CLI) 示例
- en: Let’s give a clear example of how the CLI can reign over the GUI in speed. Suppose
    we have a folder full of screenshots. The names of each contain a space and we’d
    like to rename these files to replace the whitespace with an underscore.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给出一个清晰的例子，看看 CLI 如何在速度上超越 GUI。假设我们有一个包含截图的文件夹。每个截图的名称都包含空格，我们希望将这些文件重命名为用下划线替换空格。
- en: GUI
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GUI
- en: 'With a GUI, there’d be several manual steps for renaming a folder full of screenshots
    that contain whitespaces throughout the filename. Let’s show these steps within
    macOS, or Darwin:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GUI，重命名包含文件名中空格的整个截图文件夹需要几个手动步骤。让我们在 macOS 或 Darwin 中展示这些步骤：
- en: 'First, we’d need to open the folder containing all the screenshots:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要打开包含所有截图的文件夹：
- en: '![Figure 1.1 – Folder containing the screenshots where each filename contains
    numerous spaces](img/Figure_1.01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 包含每个文件名包含多个空格的截图的文件夹](img/Figure_1.01.jpg)'
- en: Figure 1.1 – Folder containing the screenshots where each filename contains
    numerous spaces
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 包含每个文件名包含多个空格的截图的文件夹
- en: Second, we’d press the control button and left-click on a filename, then from
    the context menu that pops up, select the **Rename** option.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，我们会按下控制按钮并左键点击一个文件名，然后从弹出的上下文菜单中选择 **重命名** 选项。
- en: '![Figure 1.2 – From the context menu, click on the Rename option](img/Figure_1.02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 在上下文菜单中，点击重命名选项](img/Figure_1.02.jpg)'
- en: Figure 1.2 – From the context menu, click on the Rename option
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 在上下文菜单中，点击重命名选项
- en: Finally, manually replace each of the whitespaces with an underscore.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，手动将每个空格替换为下划线。
- en: '![Figure 1.3 – Replaced whitespaces with underscores in filename](img/Figure_1.03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 在文件名中用下划线替换了空格](img/Figure_1.03.jpg)'
- en: Figure 1.3 – Replaced whitespaces with underscores in filename
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 在文件名中用下划线替换了空格
- en: Repeat steps 1-3 for each file in the folder. We’re lucky this folder only contains
    four screenshots. It can quickly get repetitive and tiresome with a folder of
    more files.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对文件夹中的每个文件重复步骤 1-3。我们很幸运这个文件夹只包含四个截图。如果文件夹中有更多文件，这个过程会很快变得重复且令人疲倦。
- en: CLI
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CLI
- en: 'Let’s see how much faster the CLI can be. Let’s open the terminal and navigate
    to the folder with the files:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 CLI 可以有多快。让我们打开终端并导航到包含文件的文件夹：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s view what currently exists in the folder by typing the `ls` command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过输入 `ls` 命令来查看文件夹中当前存在的内容：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s run a cleverly crafted command that loops through each file in the current
    directory and renames it (using `mv`) to translate the whitespace to an underscore:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个精心设计的命令，该命令会遍历当前目录中的每个文件，并使用`mv`将其重命名（将空格转换为下划线）：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s run the `ls` command again to see what’s changed:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行`ls`命令，看看有什么变化：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Wow! We’ve just run a single command and the files are automatically renamed!
    This is just one example to show the power of CLIs and how much faster tasks can
    be executed compared to a GUI.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们刚刚运行了一个命令，文件就自动重命名了！这只是一个例子，展示了命令行界面（CLIs）的力量以及与GUI相比任务执行速度有多快。
- en: The comeback
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复兴
- en: The reason there’s been a comeback of the CLI within recent years is because
    of these many benefits. The GUI can be resource-intensive, tedious when performing
    repetitive tasks, and sometimes slow.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，命令行界面（CLI）的复兴归功于这些许多好处。图形用户界面（GUI）可能资源密集，执行重复性任务时可能繁琐，有时还可能缓慢。
- en: The CLI, on the other end of the spectrum, is lightweight, scriptable, and fast.
    The advantages don’t end there. The CLI might even offer commands and parameters
    that are not available, or are unthinkable, within the GUI. There’s much to be
    admired and it’s also a little mysterious.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端，命令行界面（CLI）轻量级、可脚本化且快速。优势远不止于此。CLI甚至可能提供GUI中不可用或难以想象的命令和参数。有很多值得钦佩的地方，它也有一点神秘。
- en: I’m crushing a little on the CLI here! Jokes aside, to be fair to the attractive
    GUI, it has visual cues that allow the user to be self-guided. The all-too-mysterious
    CLI, on the other hand, requires help and man pages to understand its available
    parameters and options.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里对CLI有点小迷恋！开个玩笑，为了公平起见，对于吸引人的GUI，它有视觉提示，使用户能够自我引导。而过于神秘的CLI，另一方面，则需要帮助文档和man页面来理解其可用的参数和选项。
- en: Though it may appear difficult to understand, once understood, the power of
    the CLI becomes apparent and inspiring.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来可能难以理解，但一旦理解，命令行界面的力量就会变得明显并鼓舞人心。
- en: The philosophy of CLI development
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行界面（CLI）开发的哲学
- en: '**Philosophy** plays a major role in the development of computer science. Throughout
    history, there have been many great contributions to computer science through
    philosophy, partially because many computer scientists were and are also philosophers.
    It is no surprise that each OS has its own distinct philosophy.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**哲学**在计算机科学的发展中起着重要作用。历史上，许多计算机科学家通过哲学对计算机科学做出了重大贡献，部分原因是因为许多计算机科学家同时也是哲学家。每个操作系统都有自己的独特哲学，这并不奇怪。'
- en: '**Windows**, for example, hardcodes most of its intelligence within the program
    or OS, assuming users’ ignorance and limiting their flexibility. Although the
    barrier to understanding is lower, users interact with the program without understanding
    how it works.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**Windows**将大部分智能硬编码在程序或操作系统中，假设用户的无知并限制了他们的灵活性。尽管理解门槛较低，但用户与程序交互时并不了解它是如何工作的。
- en: 'The developers of **UNIX** had an opposing philosophy: provide the user with
    almost limitless possibilities to empower them. Although the learning curve is
    steep, much more can be developed within an environment that doesn’t shield its
    users from the complexity of freedom.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**UNIX**的开发者持有相反的哲学：为用户提供几乎无限的选项来赋予他们权力。尽管学习曲线陡峭，但在一个不屏蔽用户对自由复杂性的环境中，可以开发出更多内容。'
- en: There have been many books written about UNIX’s philosophy and implementing
    it in real life is an art form. I am sure, therefore, many people view coding
    as a craft. Although there are many other philosophies to review, the focus in
    this section will be on UNIX’s philosophy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关于UNIX的哲学和将其应用于现实生活的书籍已经有很多了。因此，我相信许多人将编码视为一种手艺。尽管还有许多其他哲学需要审查，但本节的重点将放在UNIX的哲学上。
- en: The legendary designers of the Go programming language, Ken Thompson, Robert
    Griesemer, and Rob Pike, share a long history with UNIX, and it feels fitting
    to discuss the philosophy within the context of its creators since Go was built
    around it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Go编程语言的传奇设计师，肯·汤普森（Ken Thompson）、罗伯特·格里泽默（Robert Griesemer）和罗布·派克（Rob Pike），与UNIX有着悠久的历史，因此讨论其哲学时，将其置于其创造者的背景下是合适的，因为Go就是围绕它构建的。
- en: '**UNIX’s philosophy** advocates for simple and modular designs that are both
    extensible and composable. The basis is that the relationships between numerous
    small programs are more powerful than the programs themselves. For example, many
    UNIX programs handle simple tasks in isolation, but when combined, these simple
    tools can be orchestrated in a very powerful way.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**UNIX的哲学**主张简单和模块化的设计，这些设计既可扩展又可组合。其基础是众多小型程序之间的关系比程序本身更强大。例如，许多UNIX程序独立处理简单任务，但当它们结合在一起时，这些简单的工具可以以非常强大的方式进行编排。'
- en: Checklist for a successful CLI
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成功CLI的清单
- en: 'The following are some principles inspired by this UNIX philosophy that when
    followed will help create a successful CLI:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些受UNIX哲学启发的原则，遵循这些原则将有助于创建一个成功的CLI：
- en: '**Building a** **modular program**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建模块化程序**'
- en: Design your CLI with standardization in mind to ensure it can be easily composed
    with other applications. Specifically utilizing standard in and out, standardized
    errors, signals, and exit codes helps to build a program that is both modular
    and easily composable. Composability can be handled simply with pipes and shell
    scripts, but there are also programming languages that can help piece programs
    together. **Continuous Integration/Continuous Delivery** (**CI/CD**), orchestration,
    and configuration management tools are often built on top of command-line execution
    and scripts to automate code integration or deployment or to configure machines.
    Consider the data output from your program and how easily composable it is. The
    best options are plain text or JSON when structure is needed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 设计您的CLI时，要考虑标准化，以确保它可以轻松与其他应用程序组合。具体来说，利用标准输入和输出、标准错误、信号和退出代码有助于构建既模块化又易于组合的程序。组合性可以通过管道和shell脚本简单地处理，但也有一些编程语言可以帮助将程序拼接在一起。**持续集成/持续交付**（**CI/CD**）、编排和配置管理工具通常建立在命令行执行和脚本之上，以自动化代码集成或部署或配置机器。考虑您程序的数据输出以及其组合的容易程度。当需要结构时，最佳选项是纯文本或JSON。
- en: '**Building for** **humans first**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以人为本** **构建**'
- en: The first CLI commands were written with the assumption that they’d only be
    used by other programs. This is no longer the case, and so programs should be
    built with humans first in mind.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的CLI命令是假设它们只会被其他程序使用而编写的。现在情况不再是这样了，因此程序应该首先以人为设计。
- en: Conversation will be the main method of human-computer interaction. Imagine
    the natural flow of human conversation and how that concept can be applied to
    help a user who has misunderstood the program design. In natural language, your
    program can suggest possible corrections, the current state in a multi-step process,
    and request confirmation before continuing to do something risky. In the best-case
    scenario, your user has had a pleasant experience with your CLI, feeling empowered
    to discover operations and receiving assistance when needed. In the worst-case
    scenario, your user feels ignored and frustrated with no help in sight. Don’t
    be that CLI!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对话将成为人机交互的主要方法。想象一下人类对话的自然流程以及这一概念如何应用于帮助误解程序设计的用户。在自然语言中，您的程序可以建议可能的纠正，多步骤过程中的当前状态，并在继续进行有风险的操作之前请求确认。在最佳情况下，您的用户在使用您的CLI时感到愉快，感觉有力量去发现操作，并在需要时获得帮助。在最坏的情况下，您的用户感到被忽视和沮丧，看不到任何帮助。不要成为那样的CLI！
- en: Finally, write readable code so other developers can easily maintain your program
    in the future.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编写可读的代码，以便其他开发人员可以轻松地在将来维护您的程序。
- en: '**Separating interfaces from engines and policies** **from mechanisms**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将接口与引擎和政策** **从机制中分离**'
- en: Decoupling these allows different applications to use the same engine through
    interfaces or use the same mechanism with different policies.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解耦这些，不同的应用程序可以通过接口使用相同的引擎，或者使用不同的策略使用相同的机制。
- en: '**Keeping** **it simple**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持简单**'
- en: Only add complexity when it’s necessary. When complexity does occur, fold it
    into the data instead of the logic. Where usability is not compromised, use existing
    patterns.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在必要时才添加复杂性。当复杂性发生时，将其折叠到数据中而不是逻辑中。在不损害可用性的情况下，使用现有模式。
- en: '**Staying small**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持小巧**'
- en: Don’t write a big program unless there’s no other way.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除非没有其他方法，否则不要编写大型程序。
- en: '**Being transparent**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持透明**'
- en: Be as transparent as possible so users can understand how to use the program
    and what’s going on. Transparent programs have comprehensive help texts and provide
    lots of examples allowing users to easily discover the parameters and options
    they need and have the confidence to execute them. The GUI certainly has a leg
    up in terms of transparency and visibility; however, we can learn from it and
    see what can be incorporated to make the CLI easier to learn and use. Users resorting
    to Google or Stack Overflow is an anti-pattern here.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地保持透明，让用户能够理解如何使用程序以及正在发生什么。透明的程序具有全面的帮助文本，并提供大量示例，使用户能够轻松发现他们需要的参数和选项，并对其执行有信心。GUI在透明度和可见性方面确实有优势；然而，我们可以从中学习，看看可以吸收哪些内容来使CLI更容易学习和使用。用户求助于Google或Stack
    Overflow在这里是一种反模式。
- en: '**Being robust**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持稳健**'
- en: 'Robustness is the result of the former principle: transparency and simplicity.
    The program should work in a way that the user expects, and when errors occur,
    explain what is happening clearly with suggestions for resolution. Immediately
    printing stack traces or not informing the user with a clear and immediate response
    leaves the user feeling like they are on shaky ground.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 稳健性是前述原则的结果：透明性和简单性。程序应以用户期望的方式运行，当出现错误时，应清楚地解释正在发生的情况，并提供解决方案的建议。立即打印堆栈跟踪或不对用户进行清晰且及时的响应，会让用户感觉不稳定。
- en: '**No surprises**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有惊喜**'
- en: Keep your program intuitive by building on top of a user’s existing knowledge.
    For example, a logical operator such as `+` should always mean addition and `-`
    should always mean subtraction. Make your program intuitive by staying consistent
    with pre-existing knowledge and patterns of behavior.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过建立在使用者现有知识的基础上来保持程序直观。例如，逻辑运算符如`+`应始终表示加法，而`-`应始终表示减法。通过保持与现有知识和行为模式的一致性，使程序直观。
- en: '**Being succinct**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁**'
- en: Don’t print output unnecessarily and don’t be completely silent, leaving the
    user to wonder what’s going on. There’s a balance in communication required to
    say exactly what needs to be said; no more, no less. Too much is a large block
    of verbose text that forces the user to parse through it to find useful information.
    Too little is when the command prompt hangs in silence leaving the user to assume
    a state about the program.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不要无谓地打印输出，也不要完全沉默，让用户猜测发生了什么。在沟通中需要找到平衡，准确地说出需要说的内容；不多也不少。太多会导致一大块冗长的文本，迫使用户从中解析出有用的信息。太少则是指命令提示符在沉默中挂起，让用户猜测程序的状态。
- en: '**Failing noisily**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**明显地失败**'
- en: Repair what can be repaired, and when the program fails, fail noisily and as
    soon as possible. This will prevent incorrect output from corrupting other programs
    depending on it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 修复可以修复的部分，当程序失败时，应尽快且明显地报错。这将防止错误输出破坏依赖于它的其他程序。
- en: '**Saving** **your time**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节省你的时间**'
- en: Build code to save developers’ time as opposed to the machine’s time, which
    is relatively cheap these days. Also, write programs that generate programs. It’s
    much faster and less error-prone for computers to generate code over hand-hacking.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码以节省开发者的时间，而不是机器的时间，因为现在机器时间相对便宜。此外，编写生成程序的程序。对于计算机来说，生成代码比手动编写更快且错误更少。
- en: '**Building a prototype first,** **then optimizing**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先构建原型，然后优化**'
- en: Sometimes, programmers spend too much time optimizing early on for marginal
    gains. First, get it working, and then polish it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，程序员在早期为了微小的收益花费太多时间进行优化。首先，让它工作，然后再进行润色。
- en: '**Building** **flexible programs**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建灵活的程序**'
- en: Programs may be used in ways the developers did not intend. Therefore, making
    the design flexible and open will allow the program to be used in ways unintended.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可能以开发者未预料到的方式被使用。因此，使设计灵活和开放将允许程序以未预料到的方式被使用。
- en: '**Designing** **for extensibility**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计可扩展性**'
- en: Extend the lifespan of your program by allowing protocols to be extensible.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过允许协议可扩展来延长你程序的使用寿命。
- en: '**Being a good** **CLI citizen**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成为一个好的CLI公民**'
- en: Bring empathy into the design and peacefully coexist with the rest of the CLI
    ecosystem.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将同理心融入设计，并与CLI生态系统和平共处。
- en: The philosophy directly influences the guidelines for creating a CLI. In the
    next section, you will clearly see the link to satisfy the philosophy tenets discussed,
    and if anything, following the guidelines will increase the odds of creating a
    successful CLI.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种哲学直接影响了创建CLI的指南。在下一节中，你将清楚地看到与所讨论的哲学原则之间的联系，并且遵循这些指南将增加创建成功CLI的可能性。
- en: The guidelines
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指南
- en: These guidelines have been formulated since the first CLI and have continued
    to evolve through the many years of developer and user experience. Following these
    guidelines will increase your chances of CLI success; however, there may be times
    when you decide to go your own way and follow an anti-pattern. There could be
    many reasons to choose an unconventional route. Remember that these are just guidelines
    and there are no hard and fast rules.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南自第一个CLI以来就已经制定，并且随着多年的开发者和用户体验而不断演变。遵循这些指南将增加CLI成功的可能性；然而，有时你可能决定走自己的路，遵循反模式。选择非传统路线可能有多种原因。记住，这些只是指南，并没有硬性规定。
- en: For life, and building CLIs, to be fun, we must allow a little chaos and the
    freedom necessary to be creative.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生活，以及构建命令行界面（CLI），要使其变得有趣，我们必须允许一点混乱和必要的自由来发挥创造力。
- en: Name
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称
- en: The **name** of the CLI holds significant weight as the name may convey symbolic
    ideas beyond the initial intention. People do not like to think more than necessary,
    so it’s best to choose a name that is simple, memorable, and easy to pronounce.
    It’s amazing how many CLI program names have been chosen so arbitrarily without
    much thought.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: CLI的**名称**具有重大意义，因为名称可能传达超出最初意图的象征性思想。人们不喜欢无谓地思考，所以最好选择一个简单、易于记忆且易于发音的名字。令人惊讶的是，许多CLI程序名称被随意选择，几乎没有经过深思熟虑。
- en: 'There have been studies that support the linguistic Heisenberg principle: *labeling
    a concept changes how people* *perceive it*.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有研究表明支持语言海森堡原理：*给一个概念贴上标签会改变人们对它的感知*。
- en: Hence, keep it short and easy to type. Use entirely lowercase variables in the
    name and only use dashes when absolutely necessary.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让它简短且易于输入。在名称中使用完全小写的变量，并且只有在绝对必要时才使用破折号。
- en: Some of my favorite application names are clear in the way that they plainly
    describe the application’s purpose in a creative manner. For example, `imagemagick`,
    a command-line application that lets you read, process, or create images magically!
    Truly, as Arthur C. Clark writes, “*Any sufficiently advanced technology is indistinguishable
    from magic*.” Other internal commands we are familiar with are `mkdir`, for make
    directory, `rm`, for remove, and `mv`, for move. Their popularity is partially
    a result of the transparent nature of their names, rendering them nearly unforgettable.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的应用程序名称之一是它们以清晰的方式直接描述了应用程序的目的。例如，`imagemagick`，这是一个命令行应用程序，让你可以神奇地读取、处理或创建图像！确实，正如亚瑟·C·克拉克写道，“*任何足够先进的技术都与魔法无法区分*。”我们熟悉的内部命令还包括`mkdir`（创建目录）、`rm`（删除）和`mv`（移动）。它们的流行部分是由于它们名称的透明性，使得它们几乎难以忘记。
- en: Help and documentation
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帮助和文档
- en: One of the tenets of the UNIX philosophy is transparency, possible mainly through
    the help and documentation present within the CLI. For new users of the CLI that
    are in discovery mode, the help and documentation are one of the first sections
    they will visit. There are a few guidelines to make the help and documentation
    more easily accessible to the user.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX哲学的一个原则是透明性，这主要可以通过CLI中的帮助和文档来实现。对于处于探索模式的CLI新用户，帮助和文档是他们最早访问的部分之一。有一些指南可以使帮助和文档更容易为用户访问。
- en: Help
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帮助
- en: It is a good practice to display help by default when just the command name
    is entered or with either the `-h` or `–help` flag. When you display the help
    text, make sure it’s formatted and concise with the most frequently used arguments
    and flag options at the top. Offer usage examples, and if a user misuses the CLI,
    the program can guess what the user tried to attempt, providing suggestions and
    next steps.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当只输入命令名称或使用`-h`或`–help`标志时，默认显示帮助是一个好习惯。当你显示帮助文本时，确保它格式化良好且简洁，最常用的参数和标志选项放在最上面。提供使用示例，如果用户误用CLI，程序可以猜测用户试图尝试的操作，并提供建议和下一步操作。
- en: Documentation
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档
- en: Provide either man pages or terminal-based or web-based documentation, which
    can provide additional examples of usage. These types of documentation may be
    linked from the help page as an extension of the resources for gaining an understanding
    of how the CLI works.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 提供手册页面或基于终端或基于网页的文档，这些文档可以提供 CLI 使用示例。这些类型的文档可以作为了解 CLI 工作原理的资源扩展，从帮助页面链接。
- en: Support
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持功能
- en: Oftentimes, users will have suggestions or questions on how to use the CLI.
    Providing a support path for feedback and questions will allow users to give the
    CLI designer a new perspective on the usage of their CLI. When collecting analytics,
    be transparent and don’t collect users’ address, phone, or usage data without
    consent.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，用户会对如何使用 CLI 提出建议或问题。提供反馈和问题的支持路径将使用户能够为 CLI 设计师提供他们 CLI 使用的新视角。在收集分析数据时，要透明，不要未经用户同意收集用户的地址、电话或使用数据。
- en: Input
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入
- en: There are several ways a CLI retrieves input, but mainly through arguments,
    flags, and subcommands. There is a general preference for using flags over arguments
    and making the default the right thing for most users.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 获取输入的方式有多种，但主要通过参数、标志和子命令。普遍倾向于使用标志而不是参数，并使默认选项对大多数用户来说都是正确的。
- en: Flags
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标志
- en: The guideline for flags is that ideally, there exists a full-length version
    for all flags. For example, `-h` has `--help`. Only use `–`, a single dash, or
    shorthand notation for commonly used flags and use standard names where there
    is one.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 标志的指南是理想情况下，所有标志都应该有一个完整版本。例如，`-h` 对应 `--help`。仅使用单个连字符 `–` 或常用标志的缩写符号，并在存在标准名称时使用标准名称。
- en: 'The following is a list of some standard flags that already exist:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些已存在的标准标志列表：
- en: '| **Flag** | **Usage** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **用法** |'
- en: '| `-``a`, `--all` | All |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `-a`, `--all` | 所有 |'
- en: '| `-``d`, `–debug` | Debug |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `-d`, `–debug` | 调试 |'
- en: '| `-``f`, `--force` | Force |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `-f`, `--force` | 强制 |'
- en: '| `--``json` | Display JSON output |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `--json` | 显示 JSON 输出 |'
- en: '| `-``h`, `--help` | Help |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `-h`, `--help` | 帮助 |'
- en: '| `--``no-input` | Disable prompt and interactivity |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `--no-input` | 禁用提示和交互 |'
- en: '| `-``o`, `--output` | Output file |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `-o`, `--output` | 输出文件 |'
- en: '| `-``p`, `--port` | Port |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `-p`, `--port` | 端口 |'
- en: '| `-``q`, `--quiet` | Quiet mode |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `-q`, `--quiet` | 静默模式 |'
- en: '| `-``u`, `--user` | User |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `-u`, `--user` | 用户 |'
- en: '| `--``version` | Version |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `--version` | 版本 |'
- en: '| `-v` | Version or verbose |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `-v` | 版本或详细模式 |'
- en: '| `-d` | Verbose |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `-d` | 详细模式 |'
- en: 'Table 1.1: Standard flags'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1：标准标志
- en: Arguments
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: Multiple arguments are fine for simple actions taken on several files. For example,
    the `rm` command runs against more than one file. Although, if there exist two
    or more arguments for different things, you might need to rethink the structure
    of your command and choose a flag option over an additional argument.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在多个文件上执行简单操作的情况，多个参数是可以的。例如，`rm` 命令针对多个文件运行。尽管如此，如果存在两个或更多用于不同事物的参数，可能需要重新考虑命令的结构，并选择标志选项而不是额外的参数。
- en: Subcommands
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子命令
- en: The guidelines for subcommands are that they remain consistent and unambiguous.
    Be consistent with the structure of subcommands; either *noun-verb* or *verb-noun*
    order works, but *noun-verb* is much more common. Sometimes, a program offers
    ambiguous subcommands, such as `apt update` versus `apt upgrade`, which causes
    many, including myself, confusion. Try to avoid this!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 子命令的指南是它们应保持一致且无歧义。保持子命令的结构一致；无论是名词-动词还是动词-名词顺序都适用，但名词-动词顺序更为常见。有时，程序会提供模糊的子命令，例如
    `apt update` 与 `apt upgrade`，这会导致包括我自己在内的许多人感到困惑。尽量避免这种情况！
- en: Validate the user’s input early, and if it’s invalid, fail early before anything
    bad happens. Later in this book, we will guide you through using Cobra, a popular
    and highly recommended command-line parser for Go, to validate user input.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期验证用户的输入，如果无效，则在发生任何严重问题之前尽早失败。在本书的后续部分，我们将指导您使用 Cobra，这是一个流行的、高度推荐的 Go 语言命令行解析器，用于验证用户输入。
- en: Output
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出
- en: 'Because CLIs are built for humans and machines, we need to consider that output
    must be easily consumed by both. I will break down guidelines for both `stdout`
    and `stderr` streams for both humans and machines. Standard output, `stdout`,
    is the default file descriptor where a process can write output, and standard
    error, `stderr`, is the default file descriptor where a process can write error
    messages:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 CLI 是为人类和机器构建的，所以我们需要考虑输出必须易于两者消费。我将为人类和机器的 `stdout` 和 `stderr` 流提供指南。标准输出
    `stdout` 是进程可以写入输出的默认文件描述符，而标准错误 `stderr` 是进程可以写入错误信息的默认文件描述符：
- en: '**stdout**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**stdout**'
- en: A guideline for standard output for humans is to make the responses clear, brief,
    and comprehensible for the user. Utilize ASCII art, symbols, emojis, and color
    to improve information density. Finally, consider simple machine-readable output
    where usability is not impacted.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人类的标准输出指南是使响应清晰、简短且易于理解。利用ASCII艺术、符号、表情符号和颜色来提高信息密度。最后，考虑简单的机器可读输出，以确保不会影响可用性。
- en: A guideline for standard output for machines is to extract any extraneous substance
    from the above response so that it is simply formatted machine-readable text to
    be piped into another command. When simple machine-readable text is not output
    by default, utilize the `-q` flag to suppress non-essential output and `--plain`
    to display machine-readable text. Disable color with the `--no-color` option,
    by setting the `NO_COLOR` environment variable, or a custom `MYAPP_NO_COLOR` environment
    variable specific to your program.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于机器的标准输出指南是从上述响应中提取任何无关物质，使其成为简单的机器可读文本，以便将其管道传输到另一个命令。当默认情况下不输出简单的机器可读文本时，使用`-q`标志来抑制非必要输出，并使用`--plain`来显示机器可读文本。通过设置`NO_COLOR`环境变量或针对您程序的特定`MYAPP_NO_COLOR`环境变量来禁用颜色。
- en: Additionally, don’t use animations in `stdout` because it’s not an interactive
    terminal.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不要在`stdout`中使用动画，因为它不是一个交互式终端。
- en: '**stderr**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**stderr**'
- en: Things can go wrong during the execution of a command, but it doesn’t have to
    feel like a catastrophic event. Sometimes loud full stack traces are the response
    to a command failure, and that can make the heart skip a beat. Catch errors and
    gracefully respond to the user with rewritten error messages that can offer a
    clear understanding of what happened and suggestions for the next steps. Make
    sure there’s no irrelevant or noisy output, considering we want it to be easy
    to understand the error. Also, provide users with additional debug and traceback
    information and an option to submit bugs. Non-error messages should not go to
    `stderr`, and debug and warning messages should go to `stdout` instead.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令执行过程中可能会出错，但不必感觉像是一场灾难性事件。有时，响亮的完整堆栈跟踪是对命令失败的响应，这可能会让人心跳加速。捕获错误，并以重写的错误消息优雅地响应用户，这些错误消息可以提供对发生情况以及下一步建议的清晰理解。确保没有无关或嘈杂的输出，考虑到我们希望它易于理解错误。此外，向用户提供额外的调试和跟踪信息，以及提交错误报告的选项。非错误消息不应发送到`stderr`，调试和警告消息应发送到`stdout`。
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As for general guidelines for CLI output, return a zero exit code on success
    and a non-zero code that the machine can interpret as not just a failure but even
    a particular type of failure on which to take further action.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 关于CLI输出的通用指南，成功时返回零退出代码，失败时返回非零代码，机器可以将其解释为不仅仅是失败，甚至可以采取进一步行动的特定类型的失败。
- en: Configuration
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'Users may configure their CLI by using flags, environment variables, and files
    to determine how specifically to invoke the command and stabilize it across different
    users and environments:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过使用标志、环境变量和文件来配置他们的CLI，以确定如何具体调用命令并在不同的用户和环境之间稳定它：
- en: '**Flags and** **environment variables**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志和** **环境变量**'
- en: By using flags or environment variables, users may configure how to run a command.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用标志或环境变量，用户可以配置如何运行命令。
- en: 'Examples include the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: A specified level of debug output
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定调试输出级别
- en: Dry run commands
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 干运行命令
- en: Alternatively, they can be used to configure between different environments.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们可以用来在不同的环境中进行配置。
- en: 'Examples include the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: Providing a non-default path to files required for the program to execute
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供程序执行所需的非默认文件路径
- en: Specifying the type of output (text versus JSON)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定输出类型（文本或JSON）
- en: Specifying an HTTP proxy server to route requests through
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定HTTP代理服务器以路由请求
- en: When using environment variables in configuration, set names appropriately,
    using a combination of all uppercase text, numbers, and underscores, and take
    the time to ensure you are not using the name of an already-existing environment
    variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置中使用环境变量时，适当地设置名称，使用全部大写文本、数字和下划线的组合，并花时间确保您没有使用已存在的环境变量的名称。
- en: '**XDG Spec**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XDG规范**'
- en: Configure stability across multiple environments by following the XDG Spec (X
    Desktop Group, [freedesktop.org](http://freedesktop.org)), which specifies the
    location for base directories where configuration files may be located. This spec
    is supported by many popular tools, such as Yarn, Emacs, and tmux, to name a few.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循 XDG 规范（X Desktop Group，[freesdesktop.org](http://freesdesktop.org)）来配置跨多个环境的稳定性，该规范指定了配置文件可能存在的基目录的位置。这个规范得到了许多流行工具的支持，例如
    Yarn、Emacs 和 tmux 等。
- en: Security
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: Do not store secrets and passwords in environment variables or pass them in
    via an argument or flag. Instead, store them in a file and use the `--password-file`
    argument to allow the secret to be passed in discretely.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将机密信息和密码存储在环境变量中，也不要通过参数或标志传递它们。相反，将它们存储在文件中，并使用 `--password-file` 参数允许秘密信息被离散地传递。
- en: Open source community
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源社区
- en: Once your CLI is complete and ready to be distributed, there are several guidelines
    to follow. If possible, distribute it within a single binary targeted to a user’s
    specific platform and architecture. If the user no longer wants or needs your
    program, make sure it’s easy to uninstall too!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的 CLI 完成，准备分发，有一些指南需要遵循。如果可能，将程序作为针对用户特定平台和架构的单个二进制文件进行分发。如果用户不再需要或想要你的程序，确保它也易于卸载！
- en: Since you’ll be writing your CLI in Go, it would be great to encourage contributions
    to your program. You may offer a contribution guideline doc that guides users
    toward commit syntax, code quality, required tests, and other standards. You could
    also choose to allow users to extend the CLI by writing plugins that can work
    with your CLI, break up functionality across more modular components, and increase
    composability.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将在 Go 中编写 CLI，因此鼓励对程序做出贡献将是非常好的。你可以提供一个贡献指南文档，指导用户了解提交语法、代码质量、必需的测试和其他标准。你也可以选择允许用户通过编写与你的
    CLI 兼容的插件来扩展 CLI，将功能分解成更模块化的组件，并提高可组合性。
- en: Software lifespan and robustness
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件寿命和鲁棒性
- en: 'To ensure your CLI will continue to work well in the future, there are a few
    guidelines to follow specific to robustness to make sure your program has a long
    lifespan:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的 CLI 将来能够良好地工作，有一些特定的关于鲁棒性的指南需要遵循，以确保你的程序有一个长的寿命：
- en: '**Future-proofing**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未来兼容性**'
- en: When you make any changes to your CLI, over time, it’s best to make these changes
    additive, but if not, warn your users of the change. Changing human-readable output
    is usually fine, but it’s best to keep the machine-readable output stable. Consider
    how external dependencies may cut short your program’s lifespan and think of ways
    to make your application stable amidst external dependency failures.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对 CLI 进行任何更改时，随着时间的推移，最好是进行增量更改，但如果不是这样，应提醒用户更改。更改人类可读的输出通常是可以接受的，但最好保持机器可读输出的稳定性。考虑外部依赖可能缩短你的程序寿命的情况，并思考在外部依赖失败的情况下使你的应用程序保持稳定的方法。
- en: '**Robustness**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鲁棒性**'
- en: For a CLI to achieve maximum robustness, the CLI must be designed with full
    transparency. The program needs to feel responsible for the user; so, show progress
    if something takes a long time and don’t let the program hang. Make programs timeout
    when they are taking a long time. When the user inputs a command, validate the
    usage immediately, giving clear feedback when there’s apparent misuse. When there’s
    a failure due to some transient reason, exit the program immediately upon failure
    or interruption. When the program is invoked again, it should pick up immediately
    where it left off.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使命令行界面（CLI）达到最大的鲁棒性，CLI 必须以完全透明的方式进行设计。程序需要感觉对用户负责；因此，如果某项操作耗时较长，应显示进度，并确保程序不会挂起。当程序运行时间过长时，应设置超时。当用户输入命令时，应立即验证其使用情况，并在出现明显误用时提供清晰的反馈。当由于某些暂时性原因出现故障时，应立即在失败或中断时退出程序。当程序再次被调用时，它应立即从上次停止的地方继续执行。
- en: '**Empathy**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同理心**'
- en: Adding some thoughtful detail to the command-line design will create a pleasant
    experience for the user. CLIs should be fun to use! Even when things go wrong,
    with a supportive design, the users can feel encouraged on their pathway to successfully
    using the CLI. The modern CLI philosophy and guidelines reflect a level of empathy
    toward humans already and, thank goodness, we’ve come a long way from the initial
    command-line tools and will continue to do better.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行设计中加入一些深思熟虑的细节将为用户提供愉快的体验。CLI 应该是易于使用的！即使事情出错，有了支持性的设计，用户也可以在成功使用 CLI 的道路上感到鼓舞。现代
    CLI 哲学和指南已经体现了对人类的同理心，而且，感谢上帝，我们已经从最初的命令行工具走了很长的路，并将继续做得更好。
- en: Go for CLIs
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go for CLIs
- en: 'The very same overarching reasons I suggest engineers learn Go are the very
    same reasons I suggest using Go to build your CLI, but the very history of modern
    CLIs, which began in the 1960s with the UNIX shell, invented at Bell Labs by Ken
    Thompson, co-inventor of Golang, holds much weight. The UNIX philosophy, which
    inspires our modern CLI philosophy and guidelines, is built into the language,
    and it’s clear that many benefits have been born out of this way of thinking:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议工程师学习 Go 的所有主要原因，也是我建议使用 Go 来构建你的 CLI 的原因，但现代 CLIs 的历史，始于 20 世纪 60 年代的 UNIX
    shell，由贝尔实验室的 Ken Thompson 发明，Golang 的共同发明者，具有很大的分量。UNIX 哲学，它启发了我们的现代 CLI 哲学和指南，已经融入了语言中，并且很明显，许多好处都源于这种思维方式：
- en: '**Performance, scalability,** **and power**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能、可扩展性和力量**'
- en: Golang is quite fast in its compilation and execution. For example, Kubernetes,
    which is written in Go, has 5 million lines of application code that compile within
    a couple of minutes. Any other language would take 10 minutes to several hours
    to compile. Go translates its source code to machine code within its own optimized
    compiler, allowing easier dependency management. Also, because Golang is still
    a young language, it’s built for contemporary hardware requirements.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Golang 在编译和执行方面相当快。例如，用 Go 编写的 Kubernetes，有 500 万行应用程序代码，可以在几分钟内编译完成。任何其他语言都需要
    10 分钟到几个小时才能编译。Go 在其优化的编译器中将源代码转换为机器代码，这使得依赖关系管理更加容易。此外，由于 Golang 仍然是一个年轻的语言，它是为现代硬件需求而构建的。
- en: '*Goroutines* are lightweight threads that run concurrently. In my experience
    programming, I have not seen simplicity and multi-threading go hand in hand, but
    Golang achieves this extremely well. This feature won my heart.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*Goroutines* 是轻量级的线程，可以并发运行。在我的编程经验中，我没有看到简单性和多线程能够紧密结合，但 Golang 极好地实现了这一点。这个特性赢得了我的心。'
- en: The performance and scalability of Go are an obvious draw to the cloud computing
    community. Many CLIs for cloud computing were written in Go, Docker and Kubernetes
    included. Any application with a growing user base or a high number of traffic
    requests needs to consider Golang. Companies such as Uber and Comcast have chosen
    Go for this reason as well.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的性能和可扩展性对云计算社区来说是一个明显的吸引力。许多云计算 CLI 都是用 Go 编写的，包括 Docker 和 Kubernetes。任何拥有增长的用户基础或大量流量请求的应用程序都需要考虑
    Golang。像 Uber 和 Comcast 这样的公司也因为这个原因选择了 Go。
- en: '**Simplification** **of development**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发简化**'
- en: Golang felt easier to learn than any other language I’ve ever encountered. The
    language supports a clean, simple, and fast environment, which is impressive,
    considering the powerful tools that Go has created. Golang also has many tools
    that allow the speed and accuracy of development, including formatting tools,
    testing frameworks, a great linter, and tools to perform static analysis.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 与我遇到过的任何其他语言相比，Golang 感觉更容易学习。这种语言支持一个干净、简单、快速的环境，这在考虑到 Go 创建的强大工具时是非常令人印象深刻的。Golang
    还拥有许多工具，允许开发的速度和准确性，包括格式化工具、测试框架、出色的代码检查器和执行静态分析的工具。
- en: '**Versatility**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多功能性**'
- en: Go makes cross-compilation so easy. You can build your application for many
    different OSs and architectures, increasing accessibility to your CLI. Although
    executing within different environments, if properly configured, it will work
    similarly. This will ease users’ minds. Later on in this book, we will discuss
    how to create binaries for different platforms.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Go 使得交叉编译变得非常简单。你可以为许多不同的操作系统和架构构建你的应用程序，从而增加你的 CLI 的可访问性。尽管在不同的环境中执行，但如果配置得当，它将工作得非常相似。这将减轻用户的心理负担。在本书的后续部分，我们将讨论如何为不同的平台创建二进制文件。
- en: '**Growing** **your skillset**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升技能**'
- en: Golang is among the most popular languages to learn. Given its many apparent
    benefits, more start-ups and enterprises are choosing Golang and the demand for
    Golang developers is growing.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Golang 是学习最受欢迎的语言之一。鉴于其许多明显的优势，越来越多的初创公司和企业选择 Golang，对 Golang 开发者的需求也在增长。
- en: '**Community**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区**'
- en: If you choose Go, you’ll be a part of a community of enthusiastic open source
    developers, willing to partake in the evolutionary journey of a young programming
    language.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择 Go，你将成为一个充满热情的开源开发者社区的一员，愿意参与一个年轻编程语言的进化之旅。
- en: For beginners who are building a CLI in Go for the first time, the next chapters
    ahead show how clear it is. Golang is an excellent choice for building a CLI,
    and when there’s a need for scalability, performance, and cross compilation, the
    choice will play in your favor.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次在Go中构建CLI的初学者来说，接下来的章节将展示其清晰度。Golang是构建CLI的绝佳选择，当需要可扩展性、性能和交叉编译时，这个选择将对你有利。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the scientific discoveries and inventions
    that led to the creation of the CLI and the remnants of the past that still exist
    within the terminal today.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了导致CLI创建的科学发现和发明，以及今天终端中仍然存在的过去遗留下来的痕迹。
- en: 'Besides a detailed breakdown of the CLI into its parts, this chapter also discussed
    what a CLI is, overall, and what it is used for. The co-creator of UNIX and Golang,
    Ken Thompson, influences the philosophy around CLIs and programming in general.
    This philosophy has been influenced by human and computer interaction over the
    decades. As with anything with a long history, some ancestral baggage has followed.
    We learned that in the past, CLIs were primarily written for computers, and today
    are primarily written for humans. A new element to the UNIX philosophy had to
    be added: empathy as a cultural norm.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将CLI详细分解为其各个部分之外，本章还讨论了CLI的整体概念及其用途。UNIX和Golang的共同创造者Ken Thompson影响了CLI和编程的一般哲学。这种哲学受到了几十年来人与计算机交互的影响。与任何历史悠久的事物一样，一些祖先的负担也随之而来。我们了解到，过去CLI主要是为计算机编写的，而今天主要是为人类编写的。UNIX哲学中必须添加一个新的元素：同情作为一种文化规范。
- en: This chapter dug into the guidelines that ultimately embody the UNIX philosophy
    and why Golang is the best language to implement such a design.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了最终体现UNIX哲学的指南，以及为什么Golang是实施这种设计的最佳语言。
- en: 'In [*Chapter 2*](B18883_02.xhtml#_idTextAnchor036), *Structuring Go Code for
    CLI Applications*, we will discuss the first step of project creation: **folder
    structure**.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B18883_02.xhtml#_idTextAnchor036)《为CLI应用程序结构化Go代码》中，我们将讨论项目创建的第一步：**文件夹结构**。
- en: Questions
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the TTY on a Linux machine and what is the history behind this command?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux机器上的TTY是什么，这个命令背后的历史是什么？
- en: Which of the core elements of UNIX’s philosophy do you resonate with the most?
    Why?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你最认同UNIX哲学的哪些核心元素？为什么？
- en: Who are the co-creators of Golang and what is their relationship to the UNIX
    OS?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Golang的共同创造者是谁，他们与UNIX操作系统有什么关系？
- en: Can you still visit BBSs today and play some of the old text-based games of
    the past?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你今天还能访问BBS并玩一些过去基于文本的游戏吗？
- en: Which of the CLI guidelines feels second nature to you and which guidelines
    would require extra effort?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些CLI指南对你来说感觉像是第二本能，哪些指南需要额外的努力？
- en: Answers
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: TTY is a command in UNIX and Linux to display the name of the terminal connected
    to standard input. TTY is derived from the word teletypewriter, which was the
    default form of interacting with large mini and mainframe computers.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TTY是UNIX和Linux中的一个命令，用于显示连接到标准输入的终端名称。TTY一词来源于电传打字机，这是与大型迷你计算机和主计算机交互的默认形式。
- en: This answer is subjective. However, I like the element of building a prototype
    first and optimizing second. I prefer the process of building a simple proof of
    concept that can be used as inspiration. Optimization and refinement can always
    come later.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个答案具有主观性。然而，我喜欢先构建原型再进行优化的元素。我更喜欢构建一个简单的概念验证，它可以作为灵感的来源。优化和精炼总是可以稍后进行。
- en: Golang was created by Robert Griesemer, Rob Pike, and Ken Thompson. Ken Thompson
    also created the UNIX OS and Rob Pike was a member of the UNIX team.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Golang是由Robert Griesemer、Rob Pike和Ken Thompson共同创建的。Ken Thompson还创建了UNIX操作系统，而Rob
    Pike曾是UNIX团队的一员。
- en: You can still visit BBSs today by downloading a telnet client, for example,
    CGTerm, and connect to over 1,000 different BBSs still running today. View the
    list at [https://www.telnetbbsguide.com/](https://www.telnetbbsguide.com/).
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你仍然可以通过下载telnet客户端，例如CGTerm，连接到今天仍在运行的1000多个不同的BBS。查看列表请访问[https://www.telnetbbsguide.com/](https://www.telnetbbsguide.com/)。
- en: This answer is subjective. However, I find it second nature to put effort into
    building constructive help text. Conversely, I think it takes extra effort to
    write out complete and up-to-date documentation.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个答案具有主观性。然而，我发现投入精力构建建设性的帮助文本是自然而然的。相反，我认为编写完整且最新的文档需要额外的努力。
- en: Further reading
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: PhiloComp.net ([https://philocomp.net/](https://philocomp.net/)) is an educational
    website for both computer scientists and philosophers to learn the links between
    the disciplines, expanding their view of the other and of themselves
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PhiloComp.net ([https://philocomp.net/](https://philocomp.net/)) 是一个既面向计算机科学家也面向哲学家教育的网站，旨在学习学科之间的联系，拓展他们对彼此以及自身的视野
- en: Command Line Interface Guidelines ([https://clig.dev](https://clig.dev)) is
    an excellent resource with plenty of examples of creating CLI applications that
    adhere strongly to the UNIX philosophy
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行界面指南 ([https://clig.dev](https://clig.dev)) 是一个优秀的资源，提供了大量遵循UNIX哲学创建CLI应用程序的示例
