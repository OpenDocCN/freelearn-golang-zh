<html><head></head><body>
		<div id="_idContainer022">
			<h1 id="_idParaDest-38" class="chapter-number"><a id="_idTextAnchor036"/>2</h1>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor037"/>Structuring Go Code for CLI Applications</h1>
			<p>Programming is like any other creative process. It all begins with a blank slate. Unfortunately, when faced with a blank slate and minimal experience with programming applications from scratch, doubt can kick in – without knowing how to start, you may feel that it’s not possible <span class="No-Break">at all.</span></p>
			<p>This chapter is a guide on the first steps of creating a new application, beginning with some of the most popular ways to structure code, describing each, and weighing up their pros and cons. The concept of domain-driven design is discussed, as this can also influence the resulting structure of <span class="No-Break">an application.</span></p>
			<p>An example of an <em class="italic">audio metadata CLI application</em> gives us an idea of what some real-world use cases or requirements could look like. Learning how to define an application’s use cases and requirements is a tedious but necessary step to ensuring a successful project that also meets the needs of all <span class="No-Break">parties involved.</span></p>
			<p>By the end of this chapter, you will have learned all the skills needed to build your application based on your specific use cases <span class="No-Break">and requirements.</span></p>
			<p>This chapter will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Commonly used program layouts for <span class="No-Break">robust applications</span></li>
				<li>Determining use cases <span class="No-Break">and requirements</span></li>
				<li>Structuring an audio metadata <span class="No-Break">CLI application</span></li>
			</ul>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>You can find the program layout examples on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter02/Chapter-2"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter02/Chapter-2</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor039"/>Commonly used program layouts for robust applications</h1>
			<p>Along your <a id="_idIndexMarker076"/>programming journey, you may come across many different structures for applications. There is no standard programming layout for Go. Given all this freedom, however, the choice of the structure must be carefully made because it will dictate whether we understand and know how to maintain our application. The proper structure for the application will ideally also be simple, easy to test, and directly reflect the business design and how the <span class="No-Break">code works.</span></p>
			<p>When choosing a structure for your Go application, use your best judgment. Do not choose arbitrarily. Listen to the advice in context and learn to justify your choices. There’s no reason to choose a structure early, as your code will evolve over time and some structures work better for small applications while others are better for medium to <span class="No-Break">large applications.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor040"/>Program layouts</h2>
			<p>Let’s dig<a id="_idIndexMarker077"/> into some common and emerging structural patterns that have been developed for the Go language so far. Understanding each option will help you choose the best design structure for your <span class="No-Break">next application.</span></p>
			<h3>Flat structure</h3>
			<p>This is<a id="_idIndexMarker078"/> the simplest structure to start with and is the most<a id="_idIndexMarker079"/> common when you are starting with an application, only have a small number of files, and are still learning about the requirements. It’s much easier to evolve a flat structure into a modular structure, so it’s best to keep it simple at the start and partition it out later as the <span class="No-Break">project grows.</span></p>
			<p>Let us now see some<a id="_idIndexMarker080"/> advantages and disadvantages of <span class="No-Break">this structure:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Pros</strong></span><span class="No-Break">:</span><ul><li>It’s great for small applications <span class="No-Break">and libraries</span></li><li>There are no <span class="No-Break">circular dependencies</span></li><li>It’s easy to refactor into a <span class="No-Break">modular structure</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Cons</strong></span><span class="No-Break">:</span><ul><li>This can be <a id="_idIndexMarker081"/>complex and disorganized as the <span class="No-Break">project grows</span></li><li>Everything can be accessed and modified by <span class="No-Break">everything else</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Example</strong></span></li>
				<li>As the name<a id="_idIndexMarker082"/> implies, all the files reside in the root directory in a flat structure. There is no hierarchy or organization and this works well when there is a small number <span class="No-Break">of files:</span></li>
			</ul>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_2.1_B18883.jpg" alt="Figure 2.1 – Example of a flat code structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Example of a flat code structure</p>
			<p>As your project <a id="_idIndexMarker083"/>grows, there are several different ways to group your code to keep it organized, each with its advantages <span class="No-Break">and disadvantages.</span></p>
			<h3>Grouping code by function</h3>
			<p>Code is <a id="_idIndexMarker084"/>separated by its similar functionality. In a <em class="italic">Go REST API</em> project, as an example, Go files are commonly grouped by handlers <span class="No-Break">and models.</span></p>
			<p>Let us now see some <a id="_idIndexMarker085"/>advantages and disadvantages of <span class="No-Break">this structure:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Pros</strong></span><span class="No-Break">:</span><ul><li>It’s easy to refactor your code into other <span class="No-Break">modular structures</span></li><li>It’s easy <span class="No-Break">to organize</span></li><li>It discourages a <span class="No-Break">global state</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Cons</strong></span><span class="No-Break">:</span><ul><li>Shared variables<a id="_idIndexMarker086"/> or functionality may not have a clear place <span class="No-Break">to live</span></li><li>It can be unclear where <span class="No-Break">initialization occurs</span></li></ul></li>
			</ul>
			<p>To mitigate any confusion that can occur, it’s best to follow Go best practices. If you choose the <strong class="bold">group-by-function</strong> structure, use the <strong class="source-inline">main.go</strong> file to initialize the application from the project root. This structure, as implied by the name, separates code based on its function. The following figure is an example of groups by function and the types of code that would fall into these <span class="No-Break">different categories:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_2.2_B18883.jpg" alt="Figure 2.2 – Example of grouping by functionality"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Example of grouping by functionality</p>
			<ul>
				<li><strong class="bold">Example</strong>: The<a id="_idIndexMarker087"/> following is an example of folder organization that follows the group-by-function structure. Similar to the example grouping, folders associated with handlers contain code for each type of handler, folders associated with extractors contain code for each <a id="_idIndexMarker088"/>particular extraction type, and storage is also organized <span class="No-Break">by type:</span></li>
			</ul>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_2.3_B18883.jpg" alt="Figure 2.3 – Example of a group-by-function structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Example of a group-by-function structure</p>
			<h3>Grouping by module</h3>
			<p>Unfortunately, the<a id="_idIndexMarker089"/> title of <a id="_idIndexMarker090"/>this style of architecture is a bit redundant. To clarify, grouping by module means creating individual packages that each serve a function and contain everything necessary to accomplish these functions <span class="No-Break">within</span><span class="No-Break"><a id="_idIndexMarker091"/></span><span class="No-Break"> them:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Pros</strong></span><span class="No-Break">:</span><ul><li>It’s easier <span class="No-Break">to maintain</span></li><li>There is <span class="No-Break">faster development</span></li><li>There<a id="_idIndexMarker092"/> is low coupling and <span class="No-Break">high cohesion</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Cons</strong></span><span class="No-Break">:</span><ul><li>It’s <a id="_idIndexMarker093"/>complex and harder <span class="No-Break">to understand</span></li><li>It must have strict rules to remain <span class="No-Break">well organized</span></li><li>It may cause stuttering in package <span class="No-Break">method names</span></li><li>It can be unclear how to organize <span class="No-Break">aggregated functionality</span></li><li>Circular dependencies <span class="No-Break">may occur</span></li></ul></li>
			</ul>
			<p>The following is a visual representation of how packages can be grouped by module. In <a id="_idIndexMarker094"/>the following example, the code is grouped depending on the implementation of the <span class="No-Break">extractor interface:</span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_2.4_B18883.jpg" alt="Figure 2.4 – Visual representation of grouping by module"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Visual representation of grouping by module</p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Example</strong></span></li>
				<li>The <a id="_idIndexMarker095"/>following is an example of an organizational structure in which code is grouped into specific module folders. In the following example, the code to extract, store, and define the type, tags, transcript, and other metadata is stored within a single <span class="No-Break">defined folder:</span></li>
			</ul>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_2.5_B18883.jpg" alt="Figure 2.5 – Example of a group-by-module structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Example of a group-by-module structure</p>
			<h3>Grouping by context</h3>
			<p>This <a id="_idIndexMarker096"/>type of structure<a id="_idIndexMarker097"/> is typically driven by the domain or the specific subject for which the project is being developed. The common domain language used in communication between developers and domain experts is often referred to as ubiquitous language. It helps developers to understand the business and helps domain experts to understand the technical impact <span class="No-Break">of changes.</span></p>
			<p><strong class="bold">Hexagonal architecture</strong>, also called <strong class="bold">ports</strong> and <strong class="bold">adapters</strong>, is a popular domain-driven design<a id="_idIndexMarker098"/> architecture that conceptually divides the functional areas of an application across <a id="_idIndexMarker099"/>multiple layers. The boundaries between these layers are interfaces, also called ports, which define how they communicate with each other, and the adapters exist between the layers. In this layered architecture, the outer layers can only talk to the inner layers, not the other <span class="No-Break">way around:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Pros</strong></span><span class="No-Break">:</span><ul><li>There<a id="_idIndexMarker100"/> is increased communication between members of the business team <span class="No-Break">and developers</span></li><li>It’s flexible as business <span class="No-Break">requirements change</span></li><li>It’s easy <span class="No-Break">to maintain</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Cons</strong></span><span class="No-Break">:</span><ul><li>It <a id="_idIndexMarker101"/>requires domain expertise and for developers to understand the business first <span class="No-Break">before implementation</span></li><li>It’s costly since it requires longer initial <span class="No-Break">development times</span></li><li>It’s not suited to <span class="No-Break">short-term projects</span></li></ul></li>
			</ul>
			<p>The following provides a typical visual representation of a hexagonal structure. The arrows point inward toward entities to distinguish that the outer layers have access to the inner layers, but not the other <span class="No-Break">way around:</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_2.6_B18883.jpg" alt="Figure 2.6 – Visual representation of hexagonal architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Visual representation of hexagonal architecture</p>
			<ul>
				<li><strong class="bold">Example</strong>: The<a id="_idIndexMarker102"/> following is a folder structure organized by context. Services with individual business functions are separated into their <span class="No-Break">respective folders:</span></li>
			</ul>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_2.7_B18883.jpg" alt="Figure 2.7 – Example of a group-by-context structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Example of a group-by-context structure</p>
			<p>That wraps up<a id="_idIndexMarker103"/> the different types of organizational structures for a Go application. There’s not necessarily a right or wrong folder structure to use for your application; however, the business structure, the size of the project, and your general preference can play a part in the final decision. This is an important decision to make, so think carefully before <span class="No-Break">moving forward!</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor041"/>Common folders</h2>
			<p>No <a id="_idIndexMarker104"/>matter the chosen structure, there are commonly named folders across existing Go projects. Following this pattern will help to increase understanding for maintainers and future developers of <span class="No-Break">the application:</span></p>
			<ul>
				<li><strong class="bold">cmd</strong>: The <strong class="source-inline">cmd</strong> folder<a id="_idIndexMarker105"/> is the main entry point for the application. The directory name matches the name of <span class="No-Break">the application.</span></li>
				<li><strong class="bold">pkg</strong>: The <strong class="source-inline">pkg</strong> folder<a id="_idIndexMarker106"/> contains code that may be used by external applications. Although there is debate on the usefulness of this folder, <strong class="source-inline">pkg</strong> is explicit, and being explicit makes understanding crystal clear. I am a proponent of keeping this folder solely due to <span class="No-Break">its clarity.</span></li>
				<li><strong class="bold">internal</strong>: The <strong class="source-inline">internal</strong> folder <a id="_idIndexMarker107"/>contains private code and libraries that cannot be accessed by <span class="No-Break">external applications.</span></li>
				<li><strong class="bold">vendor</strong>: The <strong class="source-inline">vendor</strong> folder <a id="_idIndexMarker108"/>contains the application dependencies. It is created by the <strong class="source-inline">go mod vendor</strong> command. It’s usually not committed to a code repository unless you’re creating a library; however, some people feel safer having <span class="No-Break">a backup.</span></li>
				<li><strong class="bold">api</strong>: The <strong class="source-inline">api</strong> folder<a id="_idIndexMarker109"/> typically contains the code for an application’s <em class="italic">REST API</em>. It is also a place for Swagger specification, schema, and protocol <span class="No-Break">definition files.</span></li>
				<li><strong class="bold">web</strong>: The <strong class="source-inline">web</strong> folder <a id="_idIndexMarker110"/>contains specific web assets and <span class="No-Break">application components.</span></li>
				<li><strong class="bold">configs</strong>: The <strong class="source-inline">configs</strong> folder <a id="_idIndexMarker111"/>contains configuration files, including any <strong class="source-inline">confd </strong>or <span class="No-Break"><strong class="source-inline">consul-template</strong></span><span class="No-Break"> files.</span></li>
				<li><strong class="bold">init</strong>: The <strong class="source-inline">init</strong> folder <a id="_idIndexMarker112"/>contains any system initiation (start) and process management (stop/start) scripts with <span class="No-Break">supervisor configurations.</span></li>
				<li><strong class="bold">scripts</strong>: The <strong class="source-inline">scripts</strong> folder<a id="_idIndexMarker113"/> contains scripts to perform various builds, installations, analyses, and operations. Separating these scripts will help to keep the <strong class="bold">makefile </strong>small <span class="No-Break">and tidy.</span></li>
				<li><strong class="bold">build</strong>: The <strong class="source-inline">build</strong> folder<a id="_idIndexMarker114"/> contains files for packaging and continuous integration. Any cloud, container, or package configurations and scripts for packaging are usually stored under the <strong class="source-inline">/build/package</strong> folder, and continuous integration files are stored <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">build/ci</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">deployments</strong> (or <strong class="bold">deploy</strong>): The <strong class="source-inline">deployments</strong> folder <a id="_idIndexMarker115"/>stores configuration and template files related to system and <span class="No-Break">container orchestration.</span></li>
				<li><strong class="bold">test</strong>: There are<a id="_idIndexMarker116"/> different ways of storing test files. One method is to keep them all together under a <strong class="source-inline">test</strong> folder or to keep the test files right alongside the code files. This is a matter <span class="No-Break">of preference.</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">No matter what folders are contained within your project structure, use folder names that clearly indicate what is contained. This will help current and future maintainers and developers of the project find what they are looking for. Sometimes, it will be difficult to determine the best name for a package. Avoid overly used terms such as <em class="italic">util</em>, <em class="italic">common</em>, or <em class="italic">script</em>. Format the package name as all lowercase, do not use <strong class="source-inline">snake_case</strong> or <strong class="source-inline">camelCase</strong>, and consider the functional responsibility of the package and find a name that <span class="No-Break">reflects it.</span></p>
			<p>All of the aforementioned common folders and structural patterns described apply to building a CLI application. Depending on whether the CLI is a new feature of an existing application or not, you may be inheriting an existing structure. If there is an existing <strong class="source-inline">cmd</strong> folder, then it’s best to define an entry to your CLI there under a folder name that identifies your CLI application. If it is a new CLI application, start with a flat structure and grow into a modular structure from there. From the aforementioned examples, you can see how a flat structure naturally grows as the application extends to offer more features <span class="No-Break">over time.</span></p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor042"/>Determining use cases and requirements</h1>
			<p>Before <a id="_idIndexMarker117"/>building your CLI application, you’ll need to have an idea of the application’s purpose and responsibilities. The purpose of the application can be defined as an overarching description, but to start implementing, it’s necessary to break down the purpose into use cases and requirements. The goal of use cases and requirements is to drive effective discussion around what an application should do, with the result that everyone has a shared understanding of what is going to be built and continues these discussions as the <span class="No-Break">application evolves.</span></p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor043"/>Use cases</h2>
			<p><strong class="bold">Use cases</strong> are a <a id="_idIndexMarker118"/>way of documenting the functional requirements of a project. This step, at least for CLIs, is typically handled by an engineer after gathering some high-level requirements from their internal, or external, business customers. It’s important to have a clear picture of the application’s purpose and document the use cases before any technical implementation because the use cases themselves will not include any implementation-specific language or details about the interface. During any discussion of requirements with customers, topics related to implementation may crop up. Ideally, it’s best to steer the conversation back toward use case requirements and handle one thing at a time, staying focused on the right kind of discussion with the right people. The resulting use cases will reflect the goals of <span class="No-Break">the application.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor044"/>Requirements</h2>
			<p><strong class="bold">Requirements</strong> document <a id="_idIndexMarker119"/>all the nonfunctional restraints on how the system should perform the use cases. Although a system can still work without<a id="_idIndexMarker120"/> meeting these nonfunctional requirements, it may not meet user or consumer expectations as a result. There are some common <a id="_idIndexMarker121"/>categories for requirements, each discussed in <span class="No-Break">detail next:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Security</strong></span></li>
			</ul>
			<p>Security requirements <a id="_idIndexMarker122"/>ensure that sensitive information is securely transmitted and that the application adheres to secure coding standards and <span class="No-Break">best practices.</span></p>
			<p>A few example security requirements include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Exclude sensitive data related to sessions and systems <span class="No-Break">from logs</span></li>
				<li>Delete <span class="No-Break">unused accounts</span></li>
				<li>There are no default passwords in use for <span class="No-Break">the application</span></li>
			</ul>
			<ul>
				<li><span class="No-Break"><strong class="bold">Capacity</strong></span></li>
			</ul>
			<p>Capacity requirements <a id="_idIndexMarker123"/>deal with the size of data that must be handled by an application to achieve production goals. Determine the storage requirements of today and how your application will need to scale with increased volume demands. A few examples of capacity requirements include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Storage space requirements <span class="No-Break">for logging</span></li>
				<li>Several concurrent users can use the application at any <span class="No-Break">given time</span></li>
				<li>The limit on the amount of data that can be passed into <span class="No-Break">the application</span></li>
			</ul>
			<ul>
				<li><span class="No-Break"><strong class="bold">Compatibility</strong></span></li>
			</ul>
			<p>Compatibility requirements <a id="_idIndexMarker124"/>determine the minimum hardware and operating system requirements for the application to run as expected. Examples include stating the following in your <span class="No-Break">installation requirements:</span></p>
			<ul>
				<li>The <span class="No-Break">required architecture</span></li>
				<li>All compatible and <span class="No-Break">non-compatible hardware</span></li>
				<li>CPU and <span class="No-Break">memory requirements</span></li>
			</ul>
			<ul>
				<li><strong class="bold">Reliability </strong><span class="No-Break"><strong class="bold">and availability</strong></span></li>
			</ul>
			<p>Reliability and availability requirements define what happens during full or partial failure <a id="_idIndexMarker125"/>and set the standard for your application’s accessibility. A few examples would include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Minimum allowed failures per transaction or <span class="No-Break">time frame</span></li>
				<li>Defining accessibility hours for <span class="No-Break">your application</span></li>
			</ul>
			<ul>
				<li><strong class="bold">Maintainability </strong><span class="No-Break"><strong class="bold">and manageability</strong></span></li>
			</ul>
			<p>Maintainability requirements <a id="_idIndexMarker126"/>determine how easily the application can be fixed when a bug is discovered or enhanced when there are new feature requirements. Manageability requirements<a id="_idIndexMarker127"/> determine how easily an administrator can manage an application. Examples of maintainability requirements include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Bugs must be detected quickly and fixed within an <span class="No-Break">appropriate period</span></li>
				<li>The application should maintain compatibility with the latest hardware and operating <span class="No-Break">system versions</span></li>
			</ul>
			<ul>
				<li><span class="No-Break"><strong class="bold">Scalability</strong></span></li>
			</ul>
			<p>Scalability requirements <a id="_idIndexMarker128"/>determine the highest workload under which your application can still perform as expected. It is mainly driven by two factors: early software decisions and the infrastructure. Scaling can be horizontal or vertical, where horizontal scaling involves adding more nodes to the system and vertical scaling means adding more memory or faster CPUs to a machine. A couple of examples include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Several concurrently connected users can use the application with the <span class="No-Break">expected results</span></li>
				<li>The number of transactions per millisecond <span class="No-Break">is limited</span></li>
			</ul>
			<ul>
				<li><span class="No-Break"><strong class="bold">Usability</strong></span></li>
			</ul>
			<p>Usability requirements<a id="_idIndexMarker129"/> determine the quality of the user experience. A few simple examples include <span class="No-Break">the following:</span></p>
			<ul>
				<li>The application helps guide users toward the correct usage when they do the <span class="No-Break">wrong thing</span></li>
				<li>Help and documentation inform users about new arguments and flags <span class="No-Break">to use</span></li>
				<li>During a long operation, users are kept up to date on <span class="No-Break">its progress</span></li>
			</ul>
			<ul>
				<li><span class="No-Break"><strong class="bold">Performance</strong></span></li>
			</ul>
			<p>Performance requirements <a id="_idIndexMarker130"/>determine the responsiveness of an application. This includes <span class="No-Break">the following:</span></p>
			<ul>
				<li>The minimum required time for users to wait for specific operations <span class="No-Break">to complete</span></li>
				<li>Responsiveness to <span class="No-Break">users’ actions</span></li>
			</ul>
			<ul>
				<li><span class="No-Break"><strong class="bold">Environment</strong></span></li>
			</ul>
			<p>The environment requirements<a id="_idIndexMarker131"/> determine which environments the system will be expected to perform within. A few examples include <span class="No-Break">the following:</span></p>
			<ul>
				<li>The required environment variables that must <span class="No-Break">be set</span></li>
				<li>Dependencies on third-party software that need to be installed <span class="No-Break">alongside applications</span></li>
			</ul>
			<p>By taking the time to define the use cases and requirements, everyone involved will get a clear picture and have a shared understanding of the purpose and functionality of the application. A shared understanding will lead to a product that benefits in several ways, which we will <span class="No-Break">discuss now.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor045"/>Disadvantages and benefits of use cases and requirements</h2>
			<p>Having functional and nonfunctional requirements mapped through use cases and requirements can greatly benefit the outcome of <span class="No-Break">an application.</span></p>
			<p>Here are some<a id="_idIndexMarker132"/> disadvantages of determining <a id="_idIndexMarker133"/>use cases <span class="No-Break">and requirements:</span></p>
			<ul>
				<li>It slows down the development process because requirements require time to be <span class="No-Break">properly defined</span></li>
				<li>Use cases and requirements may change <span class="No-Break">over time</span></li>
			</ul>
			<p>Next, we have <a id="_idIndexMarker134"/>some advantages of determining<a id="_idIndexMarker135"/> the use cases <span class="No-Break">and requirements:</span></p>
			<ul>
				<li>It provides the best <span class="No-Break">possible outcome</span></li>
				<li>Engaging in problem-solving discussions with your team determines potential issues, misuse, <span class="No-Break">or misunderstanding</span></li>
				<li>It defines the application’s goals, future targets, and <span class="No-Break">estimated costs</span></li>
				<li>You can prioritize each of <span class="No-Break">the requirements</span></li>
			</ul>
			<p>The goal is to gain a level of clarity that helps developers focus on solving the problem with the least amount of ambiguity. Beneficial discussions and collaborative time spent with the team determining the goals of the application are necessary aspects of the process that can be achieved in parallel with defining the use cases <span class="No-Break">and requirements.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor046"/>Use cases, diagrams, and requirements for a CLI</h2>
			<p>Let’s discuss a <a id="_idIndexMarker136"/>theoretical scenario to illustrate how to build use cases and diagrams for a CLI. Suppose there is a large audio company with one particular team that <a id="_idIndexMarker137"/>focuses entirely on metadata extraction. This team provides audio metadata to their customers and other internal teams within the same audio company. Currently, they have an API available to anyone within the company’s internal network, but an operations team requests a CLI tool. The operations team recognizes the benefit of rapidly building scripts around a CLI application, which could open new opportunities for innovation for <span class="No-Break">the team.</span></p>
			<p>The existing customer-facing API use cases should be similar to the CLI since the implementation and the user interface are not a part of the documentation. Consider the use cases for the metadata team’s internal-facing CLI here. For record-keeping, we’ll number them and take the first several use cases <span class="No-Break">as examples:</span></p>
			<ol>
				<li><span class="No-Break">Uploading audio</span></li>
				<li><span class="No-Break">Requesting metadata</span></li>
				<li><span class="No-Break">Extract metadata</span></li>
				<li>Processing speech <span class="No-Break">to text</span></li>
				<li>Requesting <span class="No-Break">speech-to-text transcripts</span></li>
				<li>Listing audio metadata <span class="No-Break">in storage</span></li>
				<li>Searching audio metadata <span class="No-Break">in storage</span></li>
				<li>Deleting audio <span class="No-Break">from storage</span></li>
			</ol>
			<p>For record-keeping, we’ll number them and take the first three use cases <span class="No-Break">as examples.</span></p>
			<h3>Use case 1 – uploading audio</h3>
			<p>An authenticated member of the operations team can upload audio by providing a file path. The upload process will automatically save uploads to storage and trigger audio processing to extract the metadata, and the application will respond with a unique ID to use when requesting <span class="No-Break">the metadata.</span></p>
			<p>This use case can be broken down into some <span class="No-Break">common components:</span></p>
			<ul>
				<li><strong class="bold">The actors</strong> are the end users. This can be defined as a human or another machine process. The primary actor in this example use case is a member of the operations team, but since the team wants to use this CLI for scripting, another machine process is also <span class="No-Break">an actor.</span></li>
				<li><strong class="bold">Preconditions</strong> are statements that must take place for the use case to occur. In this example, the member must be authenticated before any of the use cases can run successfully. The preconditions in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.8</em> are represented by the solid line with an arrow pointing toward <strong class="bold">Verify TLS Certificate</strong>, which confirms through the <strong class="bold">Certificate Management Client</strong> that the user <span class="No-Break">is authenticated.</span></li>
				<li><strong class="bold">Triggers</strong> are events that start another use case. These triggers can be either internal or external. In this example use case, the trigger is external – when a user runs the <strong class="source-inline">upload</strong> command. This use case triggers another use case, <em class="italic">Use case 3, Extract Metadata</em>, internally to extract metadata from the audio file and save it to storage.  This is represented by the <strong class="bold">Metadata Extractor</strong> <span class="No-Break">process box.</span></li>
				<li>When everything happens as intended without exceptions or errors, the <strong class="bold">basic flow</strong> is activated. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.8</em>, the basic flow is a solid line. The user uploads the audio and eventually returns an ID in <span class="No-Break">response. Success!</span></li>
				<li>The <strong class="bold">alternative flow</strong> shows variations of the basic flow, in which errors or exceptions happen. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.8</em>, the alternative flow is a dotted line. The user uploads the audio, but an error occurs – for example, <em class="italic">the user is invalid</em> or <em class="italic">the audio file does </em><span class="No-Break"><em class="italic">not exist</em></span><span class="No-Break">.</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">The use case diagram <a id="_idIndexMarker138"/>for uploading audio is illustrated with the basic flow in a solid line and the alternative flow in a <span class="No-Break">dotted line.</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_2.8_B18883.jpg" alt="Figure 2.8: Use case diagram for uploading audio with a metadata CLI"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8: Use case diagram for uploading audio with a metadata CLI</p>
			<p>Alongside the diagram (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.8</em>), we can <a id="_idIndexMarker139"/>write out the use case entirely <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Use case 1 – </strong><span class="No-Break"><strong class="bold">uploading audio:</strong></span><ul><li><strong class="bold">Name</strong>: <span class="No-Break">Uploading audio.</span></li><li><strong class="bold">Description</strong>: The <strong class="bold">Actor </strong>uploads audio by providing a file path. The application returns a unique ID to use for requesting the audio metadata. The actor represents a member of the operations team or another <span class="No-Break">machine process.</span></li><li><strong class="bold">Precondition</strong>: The actor must be authenticated. In <em class="italic">Figure 2.8</em>, this is represented by the solid line from the <strong class="bold">Upload Audio</strong> box to the <strong class="bold">Verify TLS </strong><span class="No-Break"><strong class="bold">Certificate</strong></span><span class="No-Break"> diamond.</span></li><li><strong class="bold">Trigger</strong>: The <strong class="bold">Actor </strong>triggers the upload command while passing in a valid file path as a flag – in <em class="italic">Figure 2.8</em>, the arrow pointing from <strong class="bold">Actor</strong> to <span class="No-Break"><strong class="bold">Upload Audio</strong></span><span class="No-Break">.</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Basic flow:</strong></span></li>
			</ul>
			<p>The <a id="_idIndexMarker140"/>actor runs the <strong class="source-inline">upload</strong> command in the CLI – in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.8</em>, the arrow pointing from <strong class="bold">Actor</strong> to <span class="No-Break"><strong class="bold">Upload Audio</strong></span><span class="No-Break"><strong class="bold">:</strong></span></p>
			<ol>
				<li>Once <strong class="bold">Preconditions </strong>have been validated, the audio is vaildated. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.8</em>, this is represented by the <strong class="bold">Validate </strong><span class="No-Break"><strong class="bold">Audio</strong></span><span class="No-Break"> box.</span></li>
				<li>In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.8</em>, the validated audio moves to the <strong class="bold">Process Metadata</strong> step, which involves extracting the metadata, this is represented by the arrow pointed to the <strong class="bold">Metadata Extractor</strong> <span class="No-Break">process box.</span></li>
				<li>The validated audio moves to the next step of <strong class="bold">Upload Audio</strong>, which saves the audio to the <strong class="bold">database </strong>(<strong class="bold">DB</strong>), represented by the <strong class="bold">Upload to DB</strong> box in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">.</span></li>
				<li> In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.8</em>, the <strong class="bold">Return ID</strong> box represents the <strong class="bold">ID </strong>being returned from the database, which is later passed down to <span class="No-Break">the </span><span class="No-Break"><strong class="bold">Actor</strong></span><span class="No-Break">.</span></li>
			</ol>
			<ul>
				<li><span class="No-Break"><strong class="bold">Alternative flow:</strong></span><ol><li value="1"><strong class="bold">Error for an unauthenticated user</strong>: An error is returned to the actor when TLS <span class="No-Break">certification fails.</span><ul><li><strong class="bold">End use case</strong>: In <em class="italic">Figure 2.8</em>, if the user is invalid, the error is returned, as represented by the dotted line from the<strong class="bold"> Invalid User</strong> to <strong class="bold">Error </strong>box then arrow back to <span class="No-Break">the </span><span class="No-Break"><strong class="bold">Actor</strong></span><span class="No-Break">.</span></li></ul></li><li><strong class="bold">Error for invalid audio</strong>: An error is returned to the actor when audio fails to pass the <span class="No-Break">validation process.</span><ul><li><strong class="bold">End use case</strong>: In <em class="italic">Figure 2.8</em>, if the audio is invalid, an error is returned to the actor, represented by the <strong class="bold">Failed Validation </strong>to <strong class="bold">Error</strong> box then arrow back to <span class="No-Break">the </span><span class="No-Break"><strong class="bold">Actor</strong></span><span class="No-Break">.</span></li></ul></li><li><strong class="bold">Error uploading the validated audio to storage</strong>: An error is returned to the actor when audio upload to the <span class="No-Break">database fails.</span></li></ol><ul><li><strong class="bold">End use case</strong>: In <em class="italic">Figure 2.8</em>, the dotted line returned from <strong class="bold">Upload to DB</strong> to the <strong class="bold">Failed Upload</strong> to <strong class="bold">Error </strong>box then arrow back to <span class="No-Break">the </span><span class="No-Break"><strong class="bold">Actor</strong></span><span class="No-Break">.</span></li></ul></li>
			</ul>
			<h3>Use case 2 – requesting metadata</h3>
			<p>An<a id="_idIndexMarker141"/> authenticated member of the operations team can retrieve audio metadata by providing an <strong class="bold">ID </strong>that was either returned after the upload or found by listing or searching for audio. The <strong class="source-inline">get</strong> command will output the requested audio metadata, with matching ID, in the specified format – either plain text <span class="No-Break">or JSON.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The use case diagram for requesting audio is illustrated with the basic flow in a solid line and the alternative flow in a <span class="No-Break">dotted line.</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_2.9_B18883.jpg" alt="Figure 2.9: Use case diagram for the use case of requesting metadata"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9: Use case diagram for the use case of requesting metadata</p>
			<p>With the <a id="_idIndexMarker142"/>preceding diagram (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.9</em>) at hand, let’s get into the use case <span class="No-Break">as follows:</span></p>
			<p><strong class="bold">Use case 2 – </strong><span class="No-Break"><strong class="bold">requesting metadata:</strong></span></p>
			<ul>
				<li><strong class="bold">Name</strong>: <span class="No-Break">Requesting metadata.</span></li>
				<li><strong class="bold">Description</strong>: The <strong class="bold">Actor </strong>requests audio metadata by calling the <strong class="source-inline">get</strong> command and providing an <strong class="bold">ID </strong>for the audio. The application will output the requested audio metadata in plaintext or <span class="No-Break">JSON format.</span></li>
				<li><strong class="bold">Precondition</strong>: The <strong class="bold">Actor </strong>must be authenticated. In <em class="italic">Figure 2.9</em>, this is represented by the solid line from the <strong class="bold">Request Audio</strong> box to the <strong class="bold">Verify TLS </strong><span class="No-Break"><strong class="bold">Certificate</strong></span><span class="No-Break"> diamond.</span></li>
				<li><strong class="bold">Trigger</strong>: The <strong class="bold">Actor </strong>calls the <strong class="source-inline">get</strong> command while passing in the <strong class="bold">ID </strong>as an argument-  in <em class="italic">Figure 2.9</em>, the arrow pointing from <strong class="bold">Actor</strong> to the <strong class="bold">Request </strong><span class="No-Break"><strong class="bold">Audio</strong></span><span class="No-Break"> box.</span></li>
			</ul>
			<p>Note that different formatting levels were used for preceding Use case 1 - make consistent throughout chapter for all <span class="No-Break">use cases?</span></p>
			<p><span class="No-Break"><strong class="bold">Basic flow</strong></span></p>
			<ol>
				<li value="1">The actor <a id="_idIndexMarker143"/>runs the <strong class="source-inline">get</strong> command in the CLI. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.9</em>, the basic flow is represented in the solid line and starts with the arrow pointing from <strong class="bold">Actor</strong> to the <strong class="bold">Request </strong><span class="No-Break"><strong class="bold">Audio</strong></span><span class="No-Break"> box.</span></li>
				<li>Once <strong class="bold">Preconditions </strong>have been validated, the audio metadata is retrieved by its <strong class="bold">ID </strong>from the database. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.9</em>, this is represented by the solid line connecting <strong class="bold">Request Metadata By ID</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Database</strong></span><span class="No-Break">.</span></li>
				<li>The <strong class="bold">Database </strong>returns the metadata successfully. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.9</em>, this is represented by the line connecting <strong class="bold">Request Metadata By ID</strong> to the <span class="No-Break"><strong class="bold">Passed </strong></span><span class="No-Break">box.</span></li>
				<li>Finally, the formatted metadata is returned to the <strong class="bold">Actor</strong>. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.9</em>, this is represented by the solid line connecting <strong class="bold">Passed</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Actor</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p><span class="No-Break"><strong class="bold">Alternative flow</strong></span></p>
			<ol>
				<li value="1"><strong class="bold">Error for unauthenticated user</strong>: An error is returned to the actor when TLS <span class="No-Break">certification fails.</span><ul><li><strong class="bold">End use case</strong>: In <em class="italic">Figure 2.9</em>, if the user is invalid, the error is returned, as represented by the dotted line from the<strong class="bold"> Invalid User</strong> box to the <strong class="bold">Error </strong>box then the arrow back to <span class="No-Break">the </span><span class="No-Break"><strong class="bold">Actor</strong></span><span class="No-Break">.</span></li></ul></li>
				<li><strong class="bold">Error for not found</strong>: An error is returned if there is no matching metadata for <span class="No-Break">the </span><span class="No-Break"><strong class="bold">ID</strong></span><span class="No-Break">.</span></li>
			</ol>
			<ul>
				<li><strong class="bold">End use case</strong>: In <em class="italic">Figure 2.9</em>, the flow is represented by the dotted line from the <strong class="bold">Failed</strong> box to the <strong class="bold">Error</strong> box and then the arrow back <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Actor</strong></span><span class="No-Break">.</span></li>
			</ul>
			<h3>Use case 3 – extract metadata</h3>
			<p>Triggered by <strong class="bold">Upload Audio</strong>, metadata, including <a id="_idIndexMarker144"/>tags and transcript data, is extracted from the audio file and placed <span class="No-Break">in storage.</span></p>
			<p class="callout-heading"> Note</p>
			<p class="callout">The use case diagram for requesting audio is illustrated with the basic flow in a solid line and the alternative flow in a <span class="No-Break">dotted line.</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_2.10_B18883.jpg" alt="Figure 2.10: Use case diagram for processing metadata"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10: Use case diagram for processing metadata</p>
			<p>With the preceding diagram (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.10</em>) in mind, let’s get into the matching <span class="No-Break">use case:</span></p>
			<ul>
				<li><strong class="bold">Use case 3 – </strong><span class="No-Break"><strong class="bold">extract metadata:</strong></span><ul><li><strong class="bold">Name</strong>: <span class="No-Break">Extract metadata</span></li><li><strong class="bold">Description</strong>: The metadata extraction process consists of extracting specific metadata, including album, artist, year, and speech-to-text transcription, and storing it in a metadata object <span class="No-Break">in storage</span></li><li><strong class="bold">Precondition</strong>: <span class="No-Break">Validated audio</span></li><li><strong class="bold">Trigger</strong>: <span class="No-Break">Uploading audio</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Basic flow:</strong></span><ol><li value="1">Once<a id="_idIndexMarker145"/> the <strong class="bold">Preconditions </strong>are met, the <strong class="bold">Metadata Extractor</strong> process extracts tags and stores the data on the metadata object. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.10</em>, this is represented by the solid line from the successfully validated audio, with the <strong class="bold">Passed </strong>box to the <strong class="bold">Metadata Extractor</strong> process box, then from the <strong class="bold">Extract Tags</strong> box to the <span class="No-Break"><strong class="bold">Passed </strong></span><span class="No-Break">box.</span></li><li>Next, the transcript is extracted. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.10</em>, this is represented by the solid line from the <strong class="bold">Passed </strong>box to the <strong class="bold">Extract Transcript</strong> box to the next <span class="No-Break"><strong class="bold">Passed </strong></span><span class="No-Break">box.</span></li><li>The metadata extraction completes and updates the metadata object. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.10</em>, this step is represented by the solid line from the <strong class="bold">Passed </strong>box to <strong class="bold">Completed</strong> and the solid line that runs to the <span class="No-Break"><strong class="bold">Metadata Object</strong></span><span class="No-Break">.</span></li><li>The metadata object is stored. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.10</em>, this is represented by the solid line from <strong class="bold">Metadata Object</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Database</strong></span><span class="No-Break">.</span></li></ol></li>
				<li><span class="No-Break"><strong class="bold">Alternative flow:</strong></span></li>
			</ul>
			<p>Note that previous two use cases above used different formatting for "End use case" lines - check and make consistent throughout chapter for all <span class="No-Break">use cases</span></p>
			<ol>
				<li value="1"><strong class="bold">Error extracting tag data</strong>: In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.10</em>, this is represented by the dotted line from <strong class="bold">Extract Tags</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Error</strong></span><span class="No-Break">.</span><ul><li><strong class="bold">Stores an error on the metadata object</strong>: In <em class="italic">Figure 2.10</em>, this is represented by the dotted line from <strong class="bold">Error</strong> to <span class="No-Break"><strong class="bold">Metadata Object</strong></span><span class="No-Break">.</span></li><li><strong class="bold">End use case</strong>: In <em class="italic">Figure 2.10</em>, this is represented by the solid line from <strong class="bold">Metadata Object</strong> to <span class="No-Break">the </span><span class="No-Break"><strong class="bold">Database</strong></span><span class="No-Break">.</span></li></ul></li>
				<li><strong class="bold">Error extracting the transcript</strong>: An error when extracting transcript metadata occurs. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.10</em>, this is represented by the dotted line from <strong class="bold">Extract Transcript</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Error</strong></span><span class="No-Break">.</span></li>
			</ol>
			<ul>
				<li><strong class="bold">Stores an error on the metadata object</strong>: In <em class="italic">Figure 2.10</em>, this is represented by the dotted line from <strong class="bold">Error</strong> to <span class="No-Break"><strong class="bold">Metadata Object</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">End use case</strong>: In <em class="italic">Figure 2.10</em>, this is the solid line from <strong class="bold">Metadata Object</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Database</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>It’s not necessary to <a id="_idIndexMarker146"/>write out the full documentation for each use case in order to understand the concept. Typically, the functional requirements as described by their use cases are reviewed by the stakeholders, and they are discussed to ensure there is agreement across <span class="No-Break">the board.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor047"/>Requirements for a metadata CLI</h2>
			<p>Given<a id="_idIndexMarker147"/> our theoretical scenario of an internal team handling all audio metadata, a few nonfunctional requirements may also be requested and defined between the internal team and their customers. The requirements, for example, may include <span class="No-Break">the following:</span></p>
			<ul>
				<li>The application must run on Linux, macOS, <span class="No-Break">and Windows</span></li>
				<li>The ID returned from when the audio is uploaded must be <span class="No-Break">returned immediately</span></li>
				<li>The application must clearly state if the user misuses the application and uploads a file type other <span class="No-Break">than audio</span></li>
			</ul>
			<p>There <a id="_idIndexMarker148"/>are many more possible requirements for this metadata CLI application, but it is most important to understand what a requirement is, how to form your own, and how it differs from a use case. Use cases and requirements can be broken down into phases for more granularity, especially for scalability. Applications will grow over time and certain features will be added to match the growing requirements. To reference an earlier CLI guideline, <em class="italic">prototype first and optimize later</em>, it’s best just to get the application working first before optimizing. Depending on the type of issues encountered, whether slow processing, the inability to support a large number of concurrent users, or the inability to handle a certain number of transactions per minute, you will need to resolve them in different ways. For example, you can do load testing when optimizing for concurrent use, or use a memory cache along with a database to optimize the number of transactions handled <span class="No-Break">per minute.</span></p>
			<p>Building a simple prototype for your application can be done in parallel with defining use cases <span class="No-Break">and requirements.</span></p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor048"/>Structuring an audio metadata CLI application</h1>
			<p>The<a id="_idIndexMarker149"/> first step to building a CLI application is creating the folder structure, but if you aren’t starting from scratch, determine where the CLI application may be added. Suppose the existing structure for the audio metadata API application was built with a domain-driven architecture. To understand how it may be structured, let’s categorize the building blocks of <span class="No-Break">the application.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor049"/>Bounded context</h2>
			<p><strong class="bold">Bounded context</strong> brings<a id="_idIndexMarker150"/> a deeper meaning to entities and objects. In the case of our metadata application, consumers utilize the API to search for audio transcription. The operations team would like to search for audio metadata using a CLI. API consumers may be interested in both the metadata and audio transcription but other teams may be more focused on<a id="_idIndexMarker151"/> the results of audio transcription. Each team brings a different context to the metadata. However, since tags, album, artist, title, and transcription are all considered metadata, they can be encapsulated within a <span class="No-Break">single entity.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor050"/>Language</h2>
			<p>The <strong class="bold">language</strong> used <a id="_idIndexMarker152"/>to delineate between different contexts is<a id="_idIndexMarker153"/> called <strong class="bold">ubiquitous language</strong>. Because teams have slightly different meanings for different terms, this language helps to describe the application in terms that are agreed upon by all <span class="No-Break">involved parties.</span></p>
			<p>For the metadata application, the<a id="_idIndexMarker154"/> term <strong class="bold">metadata</strong> encompasses all the data extracted from audio, including <a id="_idIndexMarker155"/>transcription, and <strong class="bold">metadata extraction</strong> is the process of extracting technical metadata and transcription from audio. The term <strong class="bold">user</strong> refers to any member of an internal team within the larger organization, and the term <strong class="bold">audio</strong> to any recorded sound within a specific limit <span class="No-Break">on length.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor051"/>Entities and value objects</h2>
			<p><strong class="bold">Entities</strong> are <a id="_idIndexMarker156"/>models of objects defined by<a id="_idIndexMarker157"/> the language. Value objects <a id="_idIndexMarker158"/>are fields that exist within an entity. For example, the main entities for the metadata CLI are audio and metadata. Metadata is a value object within the audio entity. Also, each extraction type may be its own value object within the Metadata entity. The list of entity and value objects for this audio metadata CLI application includes <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Audio</span></li>
				<li><span class="No-Break">Metadata</span></li>
				<li><span class="No-Break">Tags</span></li>
				<li><span class="No-Break">Transcripts</span></li>
			</ul>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor052"/>Aggregation</h2>
			<p><strong class="bold">Aggregation</strong> is the <a id="_idIndexMarker159"/>merging<a id="_idIndexMarker160"/> of two separate entities. Suppose within the metadata team at an audio company users would like to make corrections to transcriptions, which is primarily handled by artificial intelligence. Although the transcription may be 95% accurate, there is a team of reviewers that can make corrections to transcriptions to reach 99-100% accuracy. There would be two microservices within the metadata application, one being metadata extraction and other being transcription review. A new<a id="_idIndexMarker161"/> aggregated entity may be <span class="No-Break">required: </span><span class="No-Break"><strong class="bold">TranscriptionReview</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor053"/>Service</h2>
			<p>The term<a id="_idIndexMarker162"/> service is generic, so this specifically refers to services within the context of the business domain. In the case of the metadata application, the domain services are the metadata service that extracts metadata from audio and a transcription review service that allows users to add corrections <span class="No-Break">to transcription.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor054"/>Events</h2>
			<p>In the <a id="_idIndexMarker163"/>context of domain-driven design, events are domain-specific and notify other processes within the same domain of their occurrence. In this particular case, when a user uploads audio, they receive an ID back immediately. However, the metadata extraction process is triggered behind the scenes and rather than continuously polling on the request metadata command or endpoint to retrieve the status of the metadata object, an event can be sent to an event listener service. The CLI could have a command that continuously listens for <span class="No-Break">process completion.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor055"/>Repository</h2>
			<p>A repository is <a id="_idIndexMarker164"/>a collection of the domain or entity objects. The repository has the responsibility of adding, updating, getting, and deleting objects. It makes aggregation possible. A repository is implemented within the domain layer, so there should be no knowledge of the specific database or storage – within the domain, the repository is only an interface. In the case of this metadata application, the repository can have different implementations – MongoDB, ElasticSearch, or <span class="No-Break">flat file.</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor056"/>Creating the structure</h2>
			<p>Understanding<a id="_idIndexMarker165"/> the components of a domain-driven design, specific to an audio metadata CLI, we can start structuring the folders specific to a metadata CLI. Here is an <span class="No-Break">example layout:</span></p>
			<pre class="source-code">
/Users/username/go/src/github.com/audiocompany/audiofile
   |--cmd
   |----api
   |----cli
   |--extractors
   |----tags
   |----transcript
   |--internal
   |----interfaces
   |--models
   |--services
   |----metadata
   |--storage
   |--vendor</pre>
			<h3>Main folders</h3>
			<p>Each folder is <span class="No-Break">is follows:</span></p>
			<ul>
				<li><strong class="source-inline">cmd</strong>: The<a id="_idIndexMarker166"/> command folder<a id="_idIndexMarker167"/> is the main entry point for two different applications that are a part of the audio metadata project: the API <span class="No-Break">and CLI.</span></li>
				<li><strong class="source-inline">extractors</strong>: This <a id="_idIndexMarker168"/>folder will hold the packages that will extract metadata from the audio. Although this extractor list will grow, we can start with a few extractor packages: <strong class="source-inline">tags</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">transcript</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">models</strong>: This<a id="_idIndexMarker169"/> folder will hold all the structs for the domain entities. The main entities to include are audio and metadata. Each of the extractors may also have its own data model and can be stored in <span class="No-Break">this folder.</span></li>
				<li><strong class="source-inline">services</strong>: Three <a id="_idIndexMarker170"/>services have been defined in our previous discussion – the metadata (extraction) service, the transcript review service, and an event listener service, which will listen for processing events and output notifications. Existing and new services exist within <span class="No-Break">this folder.</span></li>
				<li><strong class="source-inline">storage</strong>: The <a id="_idIndexMarker171"/>interface and individual implementations for storage exist within <span class="No-Break">this folder.</span></li>
			</ul>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor057"/>Summary</h1>
			<p>Throughout this chapter, we have learned how to create a structure for a new application based on the unique requirements of the business domain. We looked at the most popular folder structures for applications and the pros and cons of each, and how to write documentation on use cases and <span class="No-Break">nonfunctional requirements.</span></p>
			<p>While this chapter provided an example layout and the main folders that exist within that example, remember that this is an example of a more developed project. Start simple, always with a flat structure, but start organizing for your future folder structure as you continue to build. Just bear in mind that your code structure will take time. Rome wasn’t built in <span class="No-Break">a day.</span></p>
			<p>After covering these topics, we then discussed a hypothetical real-world example of a company with a team focused entirely on audio metadata. We followed this up with some of the potential use cases for a CLI offering, which would be a fast and efficient alternative to the <span class="No-Break">existing API.</span></p>
			<p>Finally, we discussed a folder structure that could satisfy the requirements of the CLI and API audio metadata application. In <a href="B18883_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Building an Audio Metadata CLI</em>, we will build out the folder structure with the models, interfaces, and implementations to get the CLI application working. That concludes this chapter on how to structure your Go CLI application! Hopefully, it will help you <span class="No-Break">get started.</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor058"/>Questions</h1>
			<ol>
				<li value="1">If you want to share packages with external applications or users, what common folder would these packages <span class="No-Break">reside in?</span></li>
				<li>In ports-and-adapters, or hexagonal, architecture, what are the ports and what are <span class="No-Break">the adapters?</span></li>
				<li>For listing audio, in a real-world example, how would you define the actors, preconditions, and triggers of this <span class="No-Break">use case?</span></li>
			</ol>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor059"/>Answers</h1>
			<ol>
				<li value="1">The <strong class="source-inline">pkg</strong> folder contains code that may be used by <span class="No-Break">external applications.</span></li>
				<li>Ports are the interfaces and the adapters are the implementations in a hexagonal architecture. Ports allow communication between different layers of the architecture while the adapters provide the <span class="No-Break">actual implementation.</span></li>
				<li>The actors are the operations team members or any user of the CLI. A precondition of the use case is that the user must be authenticated first. The use case is triggered by either the API’s /list endpoint for the metadata service or running the CLI command for <span class="No-Break">listing audio.</span></li>
			</ol>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor060"/>Further reading</h1>
			<ul>
				<li>Kat Zein – <em class="italic">How Do you Structure Your Go Apps</em> from GopherCon 2018 (<a href="https://www.youtube.com/watch?v=oL6JBUk6tj0">https://www.youtube.com/watch?v=oL6JBUk6tj0</a>) – an excellent talk about the most common folder structures for <span class="No-Break">Go applications</span></li>
			</ul>
		</div>
	</body></html>