- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Structuring Go Code for CLI Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为CLI应用程序结构化Go代码
- en: Programming is like any other creative process. It all begins with a blank slate.
    Unfortunately, when faced with a blank slate and minimal experience with programming
    applications from scratch, doubt can kick in – without knowing how to start, you
    may feel that it’s not possible at all.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编程就像任何其他创造性过程一样。它从一张白纸开始。不幸的是，当面对一张白纸并且对从头开始编程应用的经验有限时，可能会产生怀疑——如果您不知道如何开始，可能会觉得这根本不可能。
- en: This chapter is a guide on the first steps of creating a new application, beginning
    with some of the most popular ways to structure code, describing each, and weighing
    up their pros and cons. The concept of domain-driven design is discussed, as this
    can also influence the resulting structure of an application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于创建新应用程序的第一步指南，从一些最流行的代码结构方式开始，描述每种方式，权衡它们的优缺点。讨论了领域驱动设计，因为这也可以影响应用程序的最终结构。
- en: An example of an *audio metadata CLI application* gives us an idea of what some
    real-world use cases or requirements could look like. Learning how to define an
    application’s use cases and requirements is a tedious but necessary step to ensuring
    a successful project that also meets the needs of all parties involved.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*音频元数据CLI应用程序*的例子让我们了解一些现实世界的用例或需求可能看起来是什么样子。学习如何定义应用程序的用例和需求是确保项目成功并且满足所有相关方需求的繁琐但必要的步骤。
- en: By the end of this chapter, you will have learned all the skills needed to build
    your application based on your specific use cases and requirements.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会构建基于您特定用例和需求的应用程序所需的所有技能。
- en: 'This chapter will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Commonly used program layouts for robust applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于健壮应用的常用程序布局
- en: Determining use cases and requirements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定用例和需求
- en: Structuring an audio metadata CLI application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化音频元数据CLI应用程序
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the program layout examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter02/Chapter-2](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter02/Chapter-2).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到程序布局示例：[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter02/Chapter-2](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter02/Chapter-2)。
- en: Commonly used program layouts for robust applications
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用于健壮应用的常用程序布局
- en: Along your programming journey, you may come across many different structures
    for applications. There is no standard programming layout for Go. Given all this
    freedom, however, the choice of the structure must be carefully made because it
    will dictate whether we understand and know how to maintain our application. The
    proper structure for the application will ideally also be simple, easy to test,
    and directly reflect the business design and how the code works.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的编程旅程中，您可能会遇到许多不同的应用程序结构。对于Go来说，没有标准的编程布局。然而，鉴于所有这些自由，结构的选择必须谨慎做出，因为它将决定我们是否理解并且知道如何维护我们的应用程序。理想的应用程序结构也将是简单、易于测试，并且直接反映业务设计和代码的工作方式。
- en: When choosing a structure for your Go application, use your best judgment. Do
    not choose arbitrarily. Listen to the advice in context and learn to justify your
    choices. There’s no reason to choose a structure early, as your code will evolve
    over time and some structures work better for small applications while others
    are better for medium to large applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择Go应用程序的结构时，使用您的最佳判断。不要随意选择。听取上下文中的建议，并学会为您的选择辩护。没有理由过早地选择结构，因为随着时间的推移，您的代码会演变，某些结构更适合小型应用程序，而其他结构更适合中型到大型应用程序。
- en: Program layouts
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序布局
- en: Let’s dig into some common and emerging structural patterns that have been developed
    for the Go language so far. Understanding each option will help you choose the
    best design structure for your next application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解到目前为止为Go语言开发的常见和新兴的结构模式。理解每个选项将帮助您为您的下一个应用程序选择最佳的设计结构。
- en: Flat structure
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平面结构
- en: This is the simplest structure to start with and is the most common when you
    are starting with an application, only have a small number of files, and are still
    learning about the requirements. It’s much easier to evolve a flat structure into
    a modular structure, so it’s best to keep it simple at the start and partition
    it out later as the project grows.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是开始时最简单的结构，也是当你开始一个应用程序、只有少量文件并且仍在了解需求时最常见的情况。将平面结构演变为模块化结构要容易得多，因此最好在开始时保持简单，并在项目增长时再进行分区。
- en: 'Let us now see some advantages and disadvantages of this structure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这种结构的优点和缺点：
- en: '**Pros**:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: It’s great for small applications and libraries
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于小型应用程序和库来说非常好
- en: There are no circular dependencies
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有循环依赖
- en: It’s easy to refactor into a modular structure
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更容易重构为模块化结构
- en: '**Cons**:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: This can be complex and disorganized as the project grows
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着项目的增长，这可能会变得复杂和无序
- en: Everything can be accessed and modified by everything else
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何东西都可以被其他任何东西访问和修改
- en: '**Example**'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'As the name implies, all the files reside in the root directory in a flat structure.
    There is no hierarchy or organization and this works well when there is a small
    number of files:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如其名称所示，所有文件都位于根目录中，呈平面结构。没有层次结构或组织，当文件数量较少时，这种结构效果很好：
- en: '![Figure 2.1 – Example of a flat code structure](img/Figure_2.1_B18883.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 平面代码结构的示例](img/Figure_2.1_B18883.jpg)'
- en: Figure 2.1 – Example of a flat code structure
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 平面代码结构的示例
- en: As your project grows, there are several different ways to group your code to
    keep it organized, each with its advantages and disadvantages.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的项目增长，有几种不同的方式可以对你的代码进行分组以保持其组织性，每种方式都有其优点和缺点。
- en: Grouping code by function
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按功能分组代码
- en: Code is separated by its similar functionality. In a *Go REST API* project,
    as an example, Go files are commonly grouped by handlers and models.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码根据其相似功能进行分离。例如，在*Go REST API*项目中，Go文件通常根据处理器和模型进行分组。
- en: 'Let us now see some advantages and disadvantages of this structure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这种结构的优点和缺点：
- en: '**Pros**:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: It’s easy to refactor your code into other modular structures
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易将代码重构为其他模块化结构
- en: It’s easy to organize
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易组织
- en: It discourages a global state
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它阻止了全局状态
- en: '**Cons**:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: Shared variables or functionality may not have a clear place to live
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享变量或功能可能没有明确的位置可以存放
- en: It can be unclear where initialization occurs
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化发生的位置可能不清楚
- en: 'To mitigate any confusion that can occur, it’s best to follow Go best practices.
    If you choose the `main.go` file to initialize the application from the project
    root. This structure, as implied by the name, separates code based on its function.
    The following figure is an example of groups by function and the types of code
    that would fall into these different categories:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻可能出现的任何混淆，最好遵循Go的最佳实践。如果你选择从项目根目录的`main.go`文件初始化应用程序。这种结构，正如其名称所暗示的，是根据功能来分离代码的。以下图示是按功能分组和可能落入这些不同类别的代码类型的示例：
- en: '![Figure 2.2 – Example of grouping by functionality](img/Figure_2.2_B18883.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 按功能分组示例](img/Figure_2.2_B18883.jpg)'
- en: Figure 2.2 – Example of grouping by functionality
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 按功能分组的示例
- en: '**Example**: The following is an example of folder organization that follows
    the group-by-function structure. Similar to the example grouping, folders associated
    with handlers contain code for each type of handler, folders associated with extractors
    contain code for each particular extraction type, and storage is also organized
    by type:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：以下是一个遵循按功能分组结构的文件夹组织示例。类似于示例分组，与处理器相关的文件夹包含每种类型处理器的代码，与提取器相关的文件夹包含每种特定提取类型的代码，存储也按类型组织：'
- en: '![Figure 2.3 – Example of a group-by-function structure](img/Figure_2.3_B18883.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 按功能分组结构的示例](img/Figure_2.3_B18883.jpg)'
- en: Figure 2.3 – Example of a group-by-function structure
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 按功能分组结构的示例
- en: Grouping by module
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按模块分组
- en: 'Unfortunately, the title of this style of architecture is a bit redundant.
    To clarify, grouping by module means creating individual packages that each serve
    a function and contain everything necessary to accomplish these functions within
    them:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种架构风格的标题有点冗余。为了澄清，按模块分组意味着创建单独的包，每个包都服务于一个功能，并包含完成这些功能所需的所有内容：
- en: '**Pros**:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: It’s easier to maintain
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更容易维护
- en: There is faster development
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发速度更快
- en: There is low coupling and high cohesion
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在低耦合和高内聚
- en: '**Cons**:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: It’s complex and harder to understand
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它复杂且难以理解
- en: It must have strict rules to remain well organized
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须有严格的规则才能保持良好的组织
- en: It may cause stuttering in package method names
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会导致包方法名称的重复
- en: It can be unclear how to organize aggregated functionality
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能不清楚如何组织聚合功能
- en: Circular dependencies may occur
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会出现循环依赖
- en: 'The following is a visual representation of how packages can be grouped by
    module. In the following example, the code is grouped depending on the implementation
    of the extractor interface:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何按模块分组包的视觉表示。在以下示例中，代码根据提取器接口的实现进行分组：
- en: '![Figure 2.4 – Visual representation of grouping by module](img/Figure_2.4_B18883.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 模块分组视觉表示](img/Figure_2.4_B18883.jpg)'
- en: Figure 2.4 – Visual representation of grouping by module
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 模块分组的视觉表示
- en: '**Example**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'The following is an example of an organizational structure in which code is
    grouped into specific module folders. In the following example, the code to extract,
    store, and define the type, tags, transcript, and other metadata is stored within
    a single defined folder:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个示例，说明如何在特定的模块文件夹中组织代码。在以下示例中，提取、存储和定义类型、标签、转录和其他元数据的代码存储在单个定义的文件夹中：
- en: '![Figure 2.5 – Example of a group-by-module structure](img/Figure_2.5_B18883.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 基于模块结构的示例](img/Figure_2.5_B18883.jpg)'
- en: Figure 2.5 – Example of a group-by-module structure
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 基于模块结构的示例
- en: Grouping by context
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于上下文分组
- en: This type of structure is typically driven by the domain or the specific subject
    for which the project is being developed. The common domain language used in communication
    between developers and domain experts is often referred to as ubiquitous language.
    It helps developers to understand the business and helps domain experts to understand
    the technical impact of changes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构通常由项目开发的领域或特定主题驱动。在开发者和领域专家之间通信中使用的通用领域语言通常被称为通用语言。它有助于开发者理解业务，并帮助领域专家理解变化的技術影响。
- en: '**Hexagonal architecture**, also called **ports** and **adapters**, is a popular
    domain-driven design architecture that conceptually divides the functional areas
    of an application across multiple layers. The boundaries between these layers
    are interfaces, also called ports, which define how they communicate with each
    other, and the adapters exist between the layers. In this layered architecture,
    the outer layers can only talk to the inner layers, not the other way around:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**六边形架构**，也称为**端口**和**适配器**，是一种流行的领域驱动设计架构，在概念上将应用程序的功能区域划分为多个层次。这些层次之间的边界是接口，也称为端口，它们定义了它们如何相互通信，适配器存在于层次之间。在这个分层架构中，外层只能与内层通信，反之则不行：'
- en: '**Pros**:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: There is increased communication between members of the business team and developers
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务团队成员和开发者之间的沟通增加
- en: It’s flexible as business requirements change
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当业务需求变化时，它具有灵活性
- en: It’s easy to maintain
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于维护
- en: '**Cons**:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: It requires domain expertise and for developers to understand the business first
    before implementation
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要领域专业知识，并且开发者在实施之前必须首先理解业务
- en: It’s costly since it requires longer initial development times
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它需要更长的初始开发时间，因此成本较高
- en: It’s not suited to short-term projects
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不适合短期项目
- en: 'The following provides a typical visual representation of a hexagonal structure.
    The arrows point inward toward entities to distinguish that the outer layers have
    access to the inner layers, but not the other way around:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下提供了一个典型的六边形结构的视觉表示。箭头指向内部实体，以区分外层可以访问内层，但反之则不行：
- en: '![Figure 2.6 – Visual representation of hexagonal architecture](img/Figure_2.6_B18883.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 六边形架构的视觉表示](img/Figure_2.6_B18883.jpg)'
- en: Figure 2.6 – Visual representation of hexagonal architecture
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 六边形架构的视觉表示
- en: '**Example**: The following is a folder structure organized by context. Services
    with individual business functions are separated into their respective folders:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：以下是一个按上下文组织的文件夹结构。具有单个业务功能的服务被分别放入各自的文件夹中：'
- en: '![Figure 2.7 – Example of a group-by-context structure](img/Figure_2.7_B18883.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 基于上下文结构的示例](img/Figure_2.7_B18883.jpg)'
- en: Figure 2.7 – Example of a group-by-context structure
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 基于上下文结构的示例
- en: That wraps up the different types of organizational structures for a Go application.
    There’s not necessarily a right or wrong folder structure to use for your application;
    however, the business structure, the size of the project, and your general preference
    can play a part in the final decision. This is an important decision to make,
    so think carefully before moving forward!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这就总结了 Go 应用程序的不同类型的组织结构。对于你的应用程序来说，不一定有一个正确或错误的文件夹结构可以使用；然而，业务结构、项目大小以及你的总体偏好可能会在最终决策中发挥作用。这是一个重要的决定，所以在继续之前要仔细思考！
- en: Common folders
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见文件夹
- en: 'No matter the chosen structure, there are commonly named folders across existing
    Go projects. Following this pattern will help to increase understanding for maintainers
    and future developers of the application:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 无论选择哪种结构，现有的 Go 项目中通常都有一些命名文件夹。遵循这种模式将有助于维护者和未来的开发者更好地理解应用程序：
- en: '`cmd` folder is the main entry point for the application. The directory name
    matches the name of the application.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd` 文件夹是应用程序的主要入口点。目录名称与应用程序名称匹配。'
- en: '`pkg` folder contains code that may be used by external applications. Although
    there is debate on the usefulness of this folder, `pkg` is explicit, and being
    explicit makes understanding crystal clear. I am a proponent of keeping this folder
    solely due to its clarity.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg` 文件夹包含可能被外部应用程序使用的代码。尽管关于这个文件夹的有用性存在争议，但 `pkg` 是明确的，明确性使得理解变得清晰。我之所以支持只保留这个文件夹，是因为它的清晰性。'
- en: '`internal` folder contains private code and libraries that cannot be accessed
    by external applications.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`internal` 文件夹包含私有代码和库，这些代码和库不能被外部应用程序访问。'
- en: '`vendor` folder contains the application dependencies. It is created by the
    `go mod vendor` command. It’s usually not committed to a code repository unless
    you’re creating a library; however, some people feel safer having a backup.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vendor` 文件夹包含应用程序的依赖项。它是由 `go mod vendor` 命令创建的。除非你正在创建一个库，否则通常不会将其提交到代码仓库；然而，有些人觉得有一个备份会更安全。'
- en: '`api` folder typically contains the code for an application’s *REST API*. It
    is also a place for Swagger specification, schema, and protocol definition files.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api` 文件夹通常包含应用程序的 *REST API* 代码。它也是 Swagger 规范、模式定义文件和协议定义文件的地方。'
- en: '`web` folder contains specific web assets and application components.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web` 文件夹包含特定的网络资源和应用程序组件。'
- en: '`configs` folder contains configuration files, including any `confd` or `consul-template`
    files.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configs` 文件夹包含配置文件，包括任何 `confd` 或 `consul-template` 文件。'
- en: '`init` folder contains any system initiation (start) and process management
    (stop/start) scripts with supervisor configurations.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init` 文件夹包含任何系统初始化（启动）和进程管理（停止/启动）脚本以及监督配置。'
- en: '`scripts` folder contains scripts to perform various builds, installations,
    analyses, and operations. Separating these scripts will help to keep the **makefile**
    small and tidy.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts` 文件夹包含执行各种构建、安装、分析和操作的脚本。将这些脚本分离出来将有助于保持 **makefile** 小而整洁。'
- en: '`build` folder contains files for packaging and continuous integration. Any
    cloud, container, or package configurations and scripts for packaging are usually
    stored under the `/build/package` folder, and continuous integration files are
    stored under `build/ci`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build` 文件夹包含用于打包和持续集成的文件。任何云、容器或打包配置和脚本通常存储在 `/build/package` 文件夹下，而持续集成文件存储在
    `build/ci` 下。'
- en: '`deployments` folder stores configuration and template files related to system
    and container orchestration.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deployments` 文件夹存储与系统和容器编排相关的配置和模板文件。'
- en: '`test` folder or to keep the test files right alongside the code files. This
    is a matter of preference.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test` 文件夹或把测试文件直接放在代码文件旁边。这是一个个人偏好的问题。'
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: No matter what folders are contained within your project structure, use folder
    names that clearly indicate what is contained. This will help current and future
    maintainers and developers of the project find what they are looking for. Sometimes,
    it will be difficult to determine the best name for a package. Avoid overly used
    terms such as *util*, *common*, or *script*. Format the package name as all lowercase,
    do not use `snake_case` or `camelCase`, and consider the functional responsibility
    of the package and find a name that reflects it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的项目结构中包含哪些文件夹，使用清楚地表明包含内容的文件夹名称。这将帮助当前和未来的项目维护者和开发者找到他们需要的东西。有时，确定包的最佳名称可能会有困难。避免过度使用的术语，如
    *util*、*common* 或 *script*。将包名格式化为全部小写，不要使用 `snake_case` 或 `camelCase`，并考虑包的功能责任，找到一个反映它的名称。
- en: All of the aforementioned common folders and structural patterns described apply
    to building a CLI application. Depending on whether the CLI is a new feature of
    an existing application or not, you may be inheriting an existing structure. If
    there is an existing `cmd` folder, then it’s best to define an entry to your CLI
    there under a folder name that identifies your CLI application. If it is a new
    CLI application, start with a flat structure and grow into a modular structure
    from there. From the aforementioned examples, you can see how a flat structure
    naturally grows as the application extends to offer more features over time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所述的所有上述常见文件夹和结构模式都适用于构建CLI应用程序。根据CLI是否是现有应用程序的新功能，你可能正在继承现有的结构。如果存在一个现有的`cmd`文件夹，那么最好在该文件夹下定义一个CLI的入口，并使用一个标识CLI应用程序的文件夹名称。如果是一个新的CLI应用程序，从扁平结构开始，并从那里发展成模块化结构。从上述示例中，你可以看到扁平结构如何随着应用程序扩展到提供更多功能而自然增长。
- en: Determining use cases and requirements
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定用例和需求
- en: Before building your CLI application, you’ll need to have an idea of the application’s
    purpose and responsibilities. The purpose of the application can be defined as
    an overarching description, but to start implementing, it’s necessary to break
    down the purpose into use cases and requirements. The goal of use cases and requirements
    is to drive effective discussion around what an application should do, with the
    result that everyone has a shared understanding of what is going to be built and
    continues these discussions as the application evolves.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建CLI应用程序之前，你需要对应用程序的目的和职责有一个概念。应用程序的目的可以定义为一种总体描述，但为了开始实施，有必要将目的分解为用例和需求。用例和需求的目标是围绕应用程序应该做什么进行有效讨论，结果是每个人都对将要构建的内容有一个共同的理解，并且随着应用程序的发展继续这些讨论。
- en: Use cases
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: '**Use cases** are a way of documenting the functional requirements of a project.
    This step, at least for CLIs, is typically handled by an engineer after gathering
    some high-level requirements from their internal, or external, business customers.
    It’s important to have a clear picture of the application’s purpose and document
    the use cases before any technical implementation because the use cases themselves
    will not include any implementation-specific language or details about the interface.
    During any discussion of requirements with customers, topics related to implementation
    may crop up. Ideally, it’s best to steer the conversation back toward use case
    requirements and handle one thing at a time, staying focused on the right kind
    of discussion with the right people. The resulting use cases will reflect the
    goals of the application.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**用例**是记录项目功能性需求的一种方式。对于CLI来说，这一步通常是在从内部或外部业务客户那里收集了一些高级需求后由工程师处理的。在技术实施之前，对应用程序的目的有一个清晰的了解并记录用例是很重要的，因为用例本身不会包含任何特定于实现的术语或关于界面的细节。在与客户讨论需求的过程中，可能会出现与实现相关的话题。理想情况下，最好将对话引导回用例需求，一次处理一个问题，并专注于与正确的人进行正确的讨论。结果产生的用例将反映应用程序的目标。'
- en: Requirements
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求
- en: '**Requirements** document all the nonfunctional restraints on how the system
    should perform the use cases. Although a system can still work without meeting
    these nonfunctional requirements, it may not meet user or consumer expectations
    as a result. There are some common categories for requirements, each discussed
    in detail next:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**需求**文档记录了系统在执行用例时所有非功能性约束。尽管系统可以在不满足这些非功能性需求的情况下仍然工作，但结果可能无法满足用户或消费者的期望。以下是一些常见的需求类别，接下来将逐一详细讨论：'
- en: '**Security**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**'
- en: Security requirements ensure that sensitive information is securely transmitted
    and that the application adheres to secure coding standards and best practices.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 安全需求确保敏感信息得到安全传输，并且应用程序遵守安全的编码标准和最佳实践。
- en: 'A few example security requirements include the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例安全需求包括以下内容：
- en: Exclude sensitive data related to sessions and systems from logs
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从日志中排除与会话和系统相关的敏感数据
- en: Delete unused accounts
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除未使用的账户
- en: There are no default passwords in use for the application
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中没有使用默认密码
- en: '**Capacity**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容量**'
- en: 'Capacity requirements deal with the size of data that must be handled by an
    application to achieve production goals. Determine the storage requirements of
    today and how your application will need to scale with increased volume demands.
    A few examples of capacity requirements include the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 容量需求处理应用程序必须处理以实现生产目标的数据量大小。确定今天的存储需求以及您的应用程序如何随着增加的容量需求而扩展。以下是一些容量需求的例子：
- en: Storage space requirements for logging
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志存储空间需求
- en: Several concurrent users can use the application at any given time
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个并发用户可以在任何给定时间使用该应用程序
- en: The limit on the amount of data that can be passed into the application
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以传递到应用程序中的数据量的限制
- en: '**Compatibility**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性**'
- en: 'Compatibility requirements determine the minimum hardware and operating system
    requirements for the application to run as expected. Examples include stating
    the following in your installation requirements:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 兼容性需求确定了应用程序正常运行所需的最小硬件和操作系统要求。以下是一些例子，包括在安装要求中声明以下内容：
- en: The required architecture
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的架构
- en: All compatible and non-compatible hardware
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有兼容和非兼容的硬件
- en: CPU and memory requirements
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU和内存需求
- en: '**Reliability** **and availability**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性和可用性**'
- en: 'Reliability and availability requirements define what happens during full or
    partial failure and set the standard for your application’s accessibility. A few
    examples would include the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠性和可用性需求定义了在完全或部分故障期间会发生什么，并设定了您应用程序可访问性的标准。以下是一些例子：
- en: Minimum allowed failures per transaction or time frame
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个交易或时间框架允许的最小失败次数
- en: Defining accessibility hours for your application
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序定义可访问时间
- en: '**Maintainability** **and manageability**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性** **和可管理性**'
- en: 'Maintainability requirements determine how easily the application can be fixed
    when a bug is discovered or enhanced when there are new feature requirements.
    Manageability requirements determine how easily an administrator can manage an
    application. Examples of maintainability requirements include the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性需求决定了当发现错误或需要新功能时，应用程序可以被修复或增强的难易程度。可管理性需求决定了管理员管理应用程序的难易程度。以下是一些可维护性需求的例子：
- en: Bugs must be detected quickly and fixed within an appropriate period
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须快速检测错误并在适当的时间内修复
- en: The application should maintain compatibility with the latest hardware and operating
    system versions
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应与最新的硬件和操作系统版本保持兼容
- en: '**Scalability**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**'
- en: 'Scalability requirements determine the highest workload under which your application
    can still perform as expected. It is mainly driven by two factors: early software
    decisions and the infrastructure. Scaling can be horizontal or vertical, where
    horizontal scaling involves adding more nodes to the system and vertical scaling
    means adding more memory or faster CPUs to a machine. A couple of examples include
    the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性需求决定了您的应用程序在还能按预期运行的最高工作量。这主要受两个因素驱动：早期的软件决策和基础设施。扩展可以是横向的或纵向的，其中横向扩展涉及向系统中添加更多节点，而纵向扩展意味着向机器添加更多内存或更快的CPU。以下是一些例子：
- en: Several concurrently connected users can use the application with the expected
    results
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个并发连接的用户可以使用该应用程序并得到预期的结果
- en: The number of transactions per millisecond is limited
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每毫秒的交易数量是有限的
- en: '**Usability**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**'
- en: 'Usability requirements determine the quality of the user experience. A few
    simple examples include the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性需求决定了用户体验的质量。以下是一些简单的例子：
- en: The application helps guide users toward the correct usage when they do the
    wrong thing
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户做错事时，应用程序帮助引导用户使用正确的操作
- en: Help and documentation inform users about new arguments and flags to use
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助和文档告知用户使用新参数和标志
- en: During a long operation, users are kept up to date on its progress
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在长时间操作期间，用户可以了解其进度
- en: '**Performance**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**'
- en: 'Performance requirements determine the responsiveness of an application. This
    includes the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 性能需求决定了应用程序的响应性。这包括以下内容：
- en: The minimum required time for users to wait for specific operations to complete
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户等待特定操作完成的最低所需时间
- en: Responsiveness to users’ actions
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对用户操作的响应性
- en: '**Environment**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**'
- en: 'The environment requirements determine which environments the system will be
    expected to perform within. A few examples include the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 环境需求决定了系统预期将在哪些环境中运行。以下是一些例子：
- en: The required environment variables that must be set
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须设置的所需环境变量
- en: Dependencies on third-party software that need to be installed alongside applications
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要与应用程序一起安装的第三方软件的依赖性
- en: By taking the time to define the use cases and requirements, everyone involved
    will get a clear picture and have a shared understanding of the purpose and functionality
    of the application. A shared understanding will lead to a product that benefits
    in several ways, which we will discuss now.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过花时间定义用例和需求，所有相关人员都将获得清晰的画面，并对应用程序的目的和功能有一个共同的理解。共同的理解将导致一个在多个方面受益的产品，我们现在将讨论这些。
- en: Disadvantages and benefits of use cases and requirements
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例和需求的不利因素和优势
- en: Having functional and nonfunctional requirements mapped through use cases and
    requirements can greatly benefit the outcome of an application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用例和需求映射功能性和非功能性需求可以极大地提高应用程序的结果。
- en: 'Here are some disadvantages of determining use cases and requirements:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 确定用例和需求的一些不利因素：
- en: It slows down the development process because requirements require time to be
    properly defined
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于需求需要时间来正确定义，这会减慢开发过程
- en: Use cases and requirements may change over time
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例和需求可能会随时间变化
- en: 'Next, we have some advantages of determining the use cases and requirements:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一些确定用例和需求的优势：
- en: It provides the best possible outcome
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了最佳的可能结果
- en: Engaging in problem-solving discussions with your team determines potential
    issues, misuse, or misunderstanding
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与你的团队进行问题解决讨论确定潜在问题、误用或误解
- en: It defines the application’s goals, future targets, and estimated costs
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了应用程序的目标、未来目标和估计成本
- en: You can prioritize each of the requirements
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以对每个需求进行优先级排序
- en: The goal is to gain a level of clarity that helps developers focus on solving
    the problem with the least amount of ambiguity. Beneficial discussions and collaborative
    time spent with the team determining the goals of the application are necessary
    aspects of the process that can be achieved in parallel with defining the use
    cases and requirements.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是获得一种清晰度，帮助开发者专注于以最少的不确定性解决问题。与团队一起确定应用程序目标所花费的有益讨论和协作时间是过程中必要的方面，这些方面可以在定义用例和需求的同时实现。
- en: Use cases, diagrams, and requirements for a CLI
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CLI的用例、图表和需求
- en: Let’s discuss a theoretical scenario to illustrate how to build use cases and
    diagrams for a CLI. Suppose there is a large audio company with one particular
    team that focuses entirely on metadata extraction. This team provides audio metadata
    to their customers and other internal teams within the same audio company. Currently,
    they have an API available to anyone within the company’s internal network, but
    an operations team requests a CLI tool. The operations team recognizes the benefit
    of rapidly building scripts around a CLI application, which could open new opportunities
    for innovation for the team.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个理论场景，以说明如何为CLI构建用例和图表。假设有一家大型音频公司，有一个团队完全专注于元数据提取。这个团队向他们的客户和同一音频公司内的其他内部团队提供音频元数据。目前，他们有一个可供公司内部网络中任何人使用的API，但一个运维团队请求一个CLI工具。运维团队认识到围绕CLI应用程序快速构建脚本的益处，这可能为团队开辟新的创新机会。
- en: 'The existing customer-facing API use cases should be similar to the CLI since
    the implementation and the user interface are not a part of the documentation.
    Consider the use cases for the metadata team’s internal-facing CLI here. For record-keeping,
    we’ll number them and take the first several use cases as examples:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的面向客户的API用例应与CLI相似，因为实现和用户界面不是文档的一部分。考虑一下元数据团队面向内部的CLI用例。为了记录，我们将对它们进行编号，并取前几个用例作为例子：
- en: Uploading audio
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传音频
- en: Requesting metadata
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求元数据
- en: Extract metadata
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取元数据
- en: Processing speech to text
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将语音转换为文本
- en: Requesting speech-to-text transcripts
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求语音到文本的转录本
- en: Listing audio metadata in storage
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储中列出音频元数据
- en: Searching audio metadata in storage
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储中搜索音频元数据
- en: Deleting audio from storage
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从存储中删除音频
- en: For record-keeping, we’ll number them and take the first three use cases as
    examples.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录，我们将对它们进行编号，并取前三个用例作为例子。
- en: Use case 1 – uploading audio
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例1 – 上传音频
- en: An authenticated member of the operations team can upload audio by providing
    a file path. The upload process will automatically save uploads to storage and
    trigger audio processing to extract the metadata, and the application will respond
    with a unique ID to use when requesting the metadata.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经过身份验证的操作团队成员可以通过提供文件路径来上传音频。上传过程将自动将上传保存到存储并触发音频处理以提取元数据，并且应用程序将响应一个唯一的ID，用于请求元数据。
- en: 'This use case can be broken down into some common components:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用例可以被分解成一些常见的组件：
- en: '**The actors** are the end users. This can be defined as a human or another
    machine process. The primary actor in this example use case is a member of the
    operations team, but since the team wants to use this CLI for scripting, another
    machine process is also an actor.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行动者**是最终用户。这可以定义为人类或另一个机器过程。在这个示例用例中，主要行动者是操作团队成员，但由于团队希望使用此CLI进行脚本编写，另一个机器过程也是一个行动者。'
- en: '**Preconditions** are statements that must take place for the use case to occur.
    In this example, the member must be authenticated before any of the use cases
    can run successfully. The preconditions in *Figure 2**.8* are represented by the
    solid line with an arrow pointing toward **Verify TLS Certificate**, which confirms
    through the **Certificate Management Client** that the user is authenticated.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前提条件**是必须发生以使用例发生的陈述。在这个例子中，成员必须在任何用例成功运行之前进行身份验证。*图 2**.8*中的前提条件由指向**验证TLS证书**的实线箭头表示，它通过**证书管理客户端**确认用户已通过身份验证。'
- en: '`upload` command. This use case triggers another use case, *Use case 3, Extract
    Metadata*, internally to extract metadata from the audio file and save it to storage.
    This is represented by the **Metadata Extractor** process box.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upload`命令。此用例触发另一个用例，即内部提取音频文件元数据并将其保存到存储的*用例 3，提取元数据*。这由**元数据提取器**过程框表示。'
- en: When everything happens as intended without exceptions or errors, the **basic
    flow** is activated. In *Figure 2**.8*, the basic flow is a solid line. The user
    uploads the audio and eventually returns an ID in response. Success!
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一切按预期进行，没有异常或错误时，**基本流程**被激活。在*图 2**.8*中，基本流程是一条实线。用户上传音频，并最终返回一个ID作为响应。成功！
- en: The **alternative flow** shows variations of the basic flow, in which errors
    or exceptions happen. In *Figure 2**.8*, the alternative flow is a dotted line.
    The user uploads the audio, but an error occurs – for example, *the user is invalid*
    or *the audio file does* *not exist*.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替代流程**显示了基本流程的变体，其中发生错误或异常。在*图 2**.8*中，替代流程是一条虚线。用户上传音频，但发生错误 – 例如，*用户无效*或*音频文件不存在*。'
- en: Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The use case diagram for uploading audio is illustrated with the basic flow
    in a solid line and the alternative flow in a dotted line.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用例图通过实线表示基本流程，虚线表示替代流程来展示上传音频的用例。
- en: '![Figure 2.8: Use case diagram for uploading audio with a metadata CLI](img/Figure_2.8_B18883.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8：使用元数据CLI上传音频的用例图](img/Figure_2.8_B18883.jpg)'
- en: 'Figure 2.8: Use case diagram for uploading audio with a metadata CLI'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：使用元数据CLI上传音频的用例图
- en: 'Alongside the diagram (*Figure 2**.8*), we can write out the use case entirely
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与图(*图 2**.8*）一起，我们可以将用例完全写出来如下：
- en: '**Use case 1 –** **uploading audio:**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例 1 –** **上传音频**：'
- en: '**Name**: Uploading audio.'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：上传音频。'
- en: '**Description**: The **Actor** uploads audio by providing a file path. The
    application returns a unique ID to use for requesting the audio metadata. The
    actor represents a member of the operations team or another machine process.'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：**行动者**通过提供文件路径上传音频。应用程序返回一个唯一的ID，用于请求音频元数据。行动者代表操作团队成员或另一个机器过程。'
- en: '**Precondition**: The actor must be authenticated. In *Figure 2.8*, this is
    represented by the solid line from the **Upload Audio** box to the **Verify TLS**
    **Certificate** diamond.'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前提条件**：行动者必须经过身份验证。在*图 2.8*中，这由从**上传音频**框到**验证TLS** **证书**菱形的实线表示。'
- en: '**Trigger**: The **Actor** triggers the upload command while passing in a valid
    file path as a flag – in *Figure 2.8*, the arrow pointing from **Actor** to **Upload
    Audio**.'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发**：**行动者**在传递有效文件路径作为标志时触发上传命令 – 在*图 2.8*中，指向**行动者**到**上传音频**的箭头。'
- en: '**Basic flow:**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本流程**：'
- en: The actor runs the `upload` command in the CLI – in *Figure 2**.8*, the arrow
    pointing from **Actor** to **Upload Audio****:**
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 行动者通过CLI运行`upload`命令 – 在*图 2**.8*中，指向**行动者**到**上传音频**的箭头：**
- en: Once **Preconditions** have been validated, the audio is vaildated. In *Figure
    2**.8*, this is represented by the **Validate** **Audio** box.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦**前提条件**得到验证，音频将被验证。在*图2.8*中，这通过**验证音频**框表示。
- en: In *Figure 2**.8*, the validated audio moves to the **Process Metadata** step,
    which involves extracting the metadata, this is represented by the arrow pointed
    to the **Metadata Extractor** process box.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*图2.8*中，验证后的音频移动到**处理元数据**步骤，这涉及到提取元数据，这通过指向**元数据提取器**过程框的箭头表示。
- en: The validated audio moves to the next step of **Upload Audio**, which saves
    the audio to the **database** (**DB**), represented by the **Upload to DB** box
    in *Figure 2**.8*.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证后的音频移动到**上传音频**的下一个步骤，将音频保存到**数据库**（**DB**），在*图2.8*中由**上传到数据库**框表示。
- en: In *Figure 2**.8*, the **Return ID** box represents the **ID** being returned
    from the database, which is later passed down to the **Actor**.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*图2.8*中，**返回ID**框表示从数据库返回的**ID**，稍后传递给**参与者**。
- en: '**Alternative flow:**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备选流程**:'
- en: '**Error for an unauthenticated user**: An error is returned to the actor when
    TLS certification fails.'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未认证用户的错误**: 当TLS证书失败时，错误返回给参与者。'
- en: '**End use case**: In *Figure 2.8*, if the user is invalid, the error is returned,
    as represented by the dotted line from the **Invalid User** to **Error** box then
    arrow back to the **Actor**.'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终用例**: 在*图2.8*中，如果用户无效，错误返回，如虚线从**无效用户**到**错误**框，然后箭头回到**参与者**。'
- en: '**Error for invalid audio**: An error is returned to the actor when audio fails
    to pass the validation process.'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**无效音频的错误**: 当音频未能通过验证过程时，错误返回给参与者。'
- en: '**End use case**: In *Figure 2.8*, if the audio is invalid, an error is returned
    to the actor, represented by the **Failed Validation** to **Error** box then arrow
    back to the **Actor**.'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终用例**: 在*图2.8*中，如果音频无效，错误返回给参与者，如**验证失败**到**错误**框，然后箭头回到**参与者**。'
- en: '**Error uploading the validated audio to storage**: An error is returned to
    the actor when audio upload to the database fails.'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将验证后的音频上传到存储时出错**: 当音频上传到数据库失败时，错误返回给参与者。'
- en: '**End use case**: In *Figure 2.8*, the dotted line returned from **Upload to
    DB** to the **Failed Upload** to **Error** box then arrow back to the **Actor**.'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终用例**: 在*图2.8*中，从**上传到数据库**返回的虚线连接到**失败上传**，然后箭头回到**参与者**的**错误**框。'
- en: Use case 2 – requesting metadata
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例2 - 请求元数据
- en: An authenticated member of the operations team can retrieve audio metadata by
    providing an `get` command will output the requested audio metadata, with matching
    ID, in the specified format – either plain text or JSON.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 操作团队成员的认证成员可以通过提供`get`命令检索音频元数据，将输出请求的音频元数据，匹配的ID，以指定的格式（纯文本或JSON）。
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The use case diagram for requesting audio is illustrated with the basic flow
    in a solid line and the alternative flow in a dotted line.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请求音频用例的用例图用实线表示基本流程，用虚线表示备选流程。
- en: '![Figure 2.9: Use case diagram for the use case of requesting metadata](img/Figure_2.9_B18883.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9：请求元数据用例的使用情况图](img/Figure_2.9_B18883.jpg)'
- en: 'Figure 2.9: Use case diagram for the use case of requesting metadata'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：请求元数据用例的使用情况图
- en: 'With the preceding diagram (*Figure 2**.9*) at hand, let’s get into the use
    case as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在手头有先前的图（*图2.9*）的情况下，让我们进入以下用例：
- en: '**Use case 2 –** **requesting metadata:**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**用例2 - 请求元数据**:'
- en: '**Name**: Requesting metadata.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**: 请求元数据。'
- en: '`get` command and providing an **ID** for the audio. The application will output
    the requested audio metadata in plaintext or JSON format.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`命令并提供音频的**ID**。应用程序将以纯文本或JSON格式输出请求的音频元数据。'
- en: '**Precondition**: The **Actor** must be authenticated. In *Figure 2.9*, this
    is represented by the solid line from the **Request Audio** box to the **Verify
    TLS** **Certificate** diamond.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前提条件**: **参与者**必须经过认证。在*图2.9*中，这通过从**请求音频**框到**验证TLS** **证书**菱形的实线表示。'
- en: '`get` command while passing in the **ID** as an argument- in *Figure 2.9*,
    the arrow pointing from **Actor** to the **Request** **Audio** box.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`命令并传入**ID**作为参数-在*图2.9*中，指向**请求音频**框的箭头。'
- en: Note that different formatting levels were used for preceding Use case 1 - make
    consistent throughout chapter for all use cases?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在先前的用例1中使用了不同的格式级别 - 在整个章节中对所有用例保持一致？
- en: '**Basic flow**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本流程**'
- en: The actor runs the `get` command in the CLI. In *Figure 2**.9*, the basic flow
    is represented in the solid line and starts with the arrow pointing from **Actor**
    to the **Request** **Audio** box.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 演员在CLI中运行`get`命令。在*图2.9*中，基本流程由实线表示，并从指向**演员**到**请求** **音频**框的箭头开始。
- en: Once **Preconditions** have been validated, the audio metadata is retrieved
    by its **ID** from the database. In *Figure 2**.9*, this is represented by the
    solid line connecting **Request Metadata By ID** to **Database**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦**前提条件**得到验证，音频元数据就通过其**ID**从数据库中检索。在*图2.9*中，这由连接**通过**到**请求通过ID获取元数据**到**数据库**的实线表示。
- en: The **Database** returns the metadata successfully. In *Figure 2**.9*, this
    is represented by the line connecting **Request Metadata By ID** to the **Passed**
    box.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据库**成功返回元数据。在*图2.9*中，这由连接**请求通过ID获取元数据**到**通过**框的线表示。'
- en: Finally, the formatted metadata is returned to the **Actor**. In *Figure 2**.9*,
    this is represented by the solid line connecting **Passed** to **Actor**.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，格式化的元数据返回给**演员**。在*图2.9*中，这由连接**通过**到**演员**的实线表示。
- en: '**Alternative flow**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**备选流程**'
- en: '**Error for unauthenticated user**: An error is returned to the actor when
    TLS certification fails.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未认证用户的错误**：当TLS证书失败时，向演员返回错误。'
- en: '**End use case**: In *Figure 2.9*, if the user is invalid, the error is returned,
    as represented by the dotted line from the **Invalid User** box to the **Error**
    box then the arrow back to the **Actor**.'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终用途**：在*图2.9*中，如果用户无效，则返回错误，如从**无效用户**框到**错误**框然后返回到**演员**的虚线所示。'
- en: '**Error for not found**: An error is returned if there is no matching metadata
    for the **ID**.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未找到错误**：如果没有匹配的元数据与**ID**相匹配，则返回错误。'
- en: '**End use case**: In *Figure 2.9*, the flow is represented by the dotted line
    from the **Failed** box to the **Error** box and then the arrow back to **Actor**.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终用途**：在*图2.9*中，流程由从**失败**框到**错误**框的虚线和然后返回到**演员**的箭头表示。'
- en: Use case 3 – extract metadata
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例3 – 提取元数据
- en: Triggered by **Upload Audio**, metadata, including tags and transcript data,
    is extracted from the audio file and placed in storage.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由**上传音频**触发，从音频文件中提取元数据，包括标签和文本数据，并将其放置在存储中。
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The use case diagram for requesting audio is illustrated with the basic flow
    in a solid line and the alternative flow in a dotted line.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请求音频的用例图用实线表示基本流程，用虚线表示备选流程。
- en: '![Figure 2.10: Use case diagram for processing metadata](img/Figure_2.10_B18883.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10：处理元数据的用例图](img/Figure_2.10_B18883.jpg)'
- en: 'Figure 2.10: Use case diagram for processing metadata'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：处理元数据的用例图
- en: 'With the preceding diagram (*Figure 2**.10*) in mind, let’s get into the matching
    use case:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面的图（*图2.10*），让我们进入匹配的用例：
- en: '**Use case 3 –** **extract metadata:**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例3 –** **提取元数据**：'
- en: '**Name**: Extract metadata'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：提取元数据'
- en: '**Description**: The metadata extraction process consists of extracting specific
    metadata, including album, artist, year, and speech-to-text transcription, and
    storing it in a metadata object in storage'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：元数据提取过程包括提取特定的元数据，包括专辑、艺术家、年份和语音到文本转录，并将其存储在存储中的元数据对象中。'
- en: '**Precondition**: Validated audio'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前提条件**：验证过的音频'
- en: '**Trigger**: Uploading audio'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发器**：上传音频'
- en: '**Basic flow:**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本流程**：'
- en: Once the **Preconditions** are met, the **Metadata Extractor** process extracts
    tags and stores the data on the metadata object. In *Figure 2**.10*, this is represented
    by the solid line from the successfully validated audio, with the **Passed** box
    to the **Metadata Extractor** process box, then from the **Extract Tags** box
    to the **Passed** box.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦满足**前提条件**，**元数据提取器**过程提取标签并将数据存储在元数据对象上。在*图2.10*中，这由成功验证的音频，从**通过**框到**元数据提取器**过程框，然后从**提取标签**框到**通过**框的实线表示。
- en: Next, the transcript is extracted. In *Figure 2**.10*, this is represented by
    the solid line from the **Passed** box to the **Extract Transcript** box to the
    next **Passed** box.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，提取文本。在*图2.10*中，这由从**通过**框到**提取文本**框再到下一个**通过**框的实线表示。
- en: The metadata extraction completes and updates the metadata object. In *Figure
    2**.10*, this step is represented by the solid line from the **Passed** box to
    **Completed** and the solid line that runs to the **Metadata Object**.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元数据提取完成并更新元数据对象。在*图2.10*中，这一步由从**通过**框到**完成**的实线和连接到**元数据对象**的实线表示。
- en: The metadata object is stored. In *Figure 2**.10*, this is represented by the
    solid line from **Metadata Object** to **Database**.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元数据对象被存储。在 *图 2**.10* 中，这由从 **元数据对象** 到 **数据库** 的实线表示。
- en: '**Alternative flow:**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备选流程**：'
- en: Note that previous two use cases above used different formatting for "End use
    case" lines - check and make consistent throughout chapter for all use cases
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上述两个用例中“结束用例”的格式不同 - 检查并确保章节中所有用例的一致性
- en: '**Error extracting tag data**: In *Figure 2**.10*, this is represented by the
    dotted line from **Extract Tags** to **Error**.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提取标签数据错误**：在 *图 2**.10* 中，这由从 **提取标签** 到 **错误** 的虚线表示。'
- en: '**Stores an error on the metadata object**: In *Figure 2.10*, this is represented
    by the dotted line from **Error** to **Metadata Object**.'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在元数据对象上存储错误**：在 *图 2.10* 中，这由从 **错误** 到 **元数据对象** 的虚线表示。'
- en: '**End use case**: In *Figure 2.10*, this is represented by the solid line from
    **Metadata Object** to the **Database**.'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结束用例**：在 *图 2.10* 中，这由从 **元数据对象** 到 **数据库** 的实线表示。'
- en: '**Error extracting the transcript**: An error when extracting transcript metadata
    occurs. In *Figure 2**.10*, this is represented by the dotted line from **Extract
    Transcript** to **Error**.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提取转录错误**：在提取转录元数据时发生错误。在 *图 2**.10* 中，这由从 **提取转录** 到 **错误** 的虚线表示。'
- en: '**Stores an error on the metadata object**: In *Figure 2.10*, this is represented
    by the dotted line from **Error** to **Metadata Object**.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在元数据对象上存储错误**：在 *图 2.10* 中，这由从 **错误** 到 **元数据对象** 的虚线表示。'
- en: '**End use case**: In *Figure 2.10*, this is the solid line from **Metadata
    Object** to **Database**.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结束用例**：在 *图 2.10* 中，这是从 **元数据对象** 到 **数据库** 的实线。'
- en: It’s not necessary to write out the full documentation for each use case in
    order to understand the concept. Typically, the functional requirements as described
    by their use cases are reviewed by the stakeholders, and they are discussed to
    ensure there is agreement across the board.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解概念，没有必要为每个用例编写完整的文档。通常，由用例描述的功能性要求由利益相关者审查，并讨论以确保达成一致。
- en: Requirements for a metadata CLI
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元数据 CLI 的要求
- en: 'Given our theoretical scenario of an internal team handling all audio metadata,
    a few nonfunctional requirements may also be requested and defined between the
    internal team and their customers. The requirements, for example, may include
    the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们处理所有音频元数据的内部团队的理论场景，内部团队和他们的客户之间可能还会请求和定义一些非功能性要求。例如，这些要求可能包括以下内容：
- en: The application must run on Linux, macOS, and Windows
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序必须在 Linux、macOS 和 Windows 上运行
- en: The ID returned from when the audio is uploaded must be returned immediately
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当音频上传时返回的 ID 必须立即返回
- en: The application must clearly state if the user misuses the application and uploads
    a file type other than audio
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序必须明确指出用户误用应用程序并上传了除音频以外的文件类型
- en: There are many more possible requirements for this metadata CLI application,
    but it is most important to understand what a requirement is, how to form your
    own, and how it differs from a use case. Use cases and requirements can be broken
    down into phases for more granularity, especially for scalability. Applications
    will grow over time and certain features will be added to match the growing requirements.
    To reference an earlier CLI guideline, *prototype first and optimize later*, it’s
    best just to get the application working first before optimizing. Depending on
    the type of issues encountered, whether slow processing, the inability to support
    a large number of concurrent users, or the inability to handle a certain number
    of transactions per minute, you will need to resolve them in different ways. For
    example, you can do load testing when optimizing for concurrent use, or use a
    memory cache along with a database to optimize the number of transactions handled
    per minute.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个元数据 CLI 应用程序，可能有更多可能的要求，但最重要的是理解什么是要求，如何形成自己的要求，以及它与用例的不同。用例和要求可以分解为阶段以获得更多粒度，特别是对于可扩展性。应用程序会随着时间的推移而增长，并且某些功能将被添加以匹配不断增长的要求。为了参考早期的
    CLI 指南，“先原型设计，后优化”，最好的做法是先让应用程序运行起来，然后再进行优化。根据遇到的问题类型，无论是处理速度慢、无法支持大量并发用户，还是无法处理每分钟的特定数量的交易，您需要以不同的方式解决这些问题。例如，在优化并发使用时可以进行负载测试，或者使用内存缓存与数据库一起优化每分钟处理的交易数量。
- en: Building a simple prototype for your application can be done in parallel with
    defining use cases and requirements.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义用例和需求的同时，可以并行构建您应用程序的简单原型。
- en: Structuring an audio metadata CLI application
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化音频元数据CLI应用程序
- en: The first step to building a CLI application is creating the folder structure,
    but if you aren’t starting from scratch, determine where the CLI application may
    be added. Suppose the existing structure for the audio metadata API application
    was built with a domain-driven architecture. To understand how it may be structured,
    let’s categorize the building blocks of the application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 构建CLI应用程序的第一步是创建文件夹结构，但如果您不是从头开始，请确定CLI应用程序可能添加的位置。假设音频元数据API应用程序的现有结构是使用领域驱动架构构建的。为了了解其结构，让我们将应用程序的构建块进行分类。
- en: Bounded context
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限界上下文
- en: '**Bounded context** brings a deeper meaning to entities and objects. In the
    case of our metadata application, consumers utilize the API to search for audio
    transcription. The operations team would like to search for audio metadata using
    a CLI. API consumers may be interested in both the metadata and audio transcription
    but other teams may be more focused on the results of audio transcription. Each
    team brings a different context to the metadata. However, since tags, album, artist,
    title, and transcription are all considered metadata, they can be encapsulated
    within a single entity.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**限界上下文**为实体和对象带来了更深的含义。在我们的元数据应用程序中，消费者使用API搜索音频转录。操作团队希望使用CLI搜索音频元数据。API消费者可能对元数据和音频转录都感兴趣，但其他团队可能更关注音频转录的结果。每个团队都为元数据带来了不同的上下文。然而，由于标签、专辑、艺术家、标题和转录都被视为元数据，它们可以封装在一个单一实体中。'
- en: Language
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言
- en: The **language** used to delineate between different contexts is called **ubiquitous
    language**. Because teams have slightly different meanings for different terms,
    this language helps to describe the application in terms that are agreed upon
    by all involved parties.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 用于区分不同上下文的**语言**被称为**通用语言**。因为团队对不同的术语有不同的理解，这种语言有助于以所有相关方都同意的术语描述应用程序。
- en: For the metadata application, the term **metadata** encompasses all the data
    extracted from audio, including transcription, and **metadata extraction** is
    the process of extracting technical metadata and transcription from audio. The
    term **user** refers to any member of an internal team within the larger organization,
    and the term **audio** to any recorded sound within a specific limit on length.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于元数据应用程序，术语**元数据**包括从音频中提取的所有数据，包括转录，**元数据提取**是从音频中提取技术元数据和转录的过程。术语**用户**指代更大组织内部团队中的任何成员，而术语**音频**指代在特定长度限制内的任何录音。
- en: Entities and value objects
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体和值对象
- en: '**Entities** are models of objects defined by the language. Value objects are
    fields that exist within an entity. For example, the main entities for the metadata
    CLI are audio and metadata. Metadata is a value object within the audio entity.
    Also, each extraction type may be its own value object within the Metadata entity.
    The list of entity and value objects for this audio metadata CLI application includes
    the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体**是由语言定义的对象模型。值对象是存在于实体中的字段。例如，元数据CLI的主要实体是音频和元数据。元数据是音频实体中的一个值对象。此外，每种提取类型可能都是元数据实体中的一个值对象。此音频元数据CLI应用程序的实体和值对象列表包括以下内容：'
- en: Audio
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频
- en: Metadata
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据
- en: Tags
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: Transcripts
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转录
- en: Aggregation
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合
- en: '**Aggregation** is the merging of two separate entities. Suppose within the
    metadata team at an audio company users would like to make corrections to transcriptions,
    which is primarily handled by artificial intelligence. Although the transcription
    may be 95% accurate, there is a team of reviewers that can make corrections to
    transcriptions to reach 99-100% accuracy. There would be two microservices within
    the metadata application, one being metadata extraction and other being transcription
    review. A new aggregated entity may be required: **TranscriptionReview**.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合**是指两个独立实体的合并。假设在音频公司的元数据团队中，用户希望对转录进行更正，这主要是由人工智能处理的。尽管转录可能达到95%的准确率，但有一个审阅团队可以对转录进行更正，以达到99-100%的准确率。元数据应用程序中可能需要两个微服务，一个是元数据提取，另一个是转录审阅。可能需要一个新聚合的实体：**TranscriptionReview**。'
- en: Service
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: The term service is generic, so this specifically refers to services within
    the context of the business domain. In the case of the metadata application, the
    domain services are the metadata service that extracts metadata from audio and
    a transcription review service that allows users to add corrections to transcription.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 术语服务是通用的，所以这特别指的是业务领域的服务。在元数据应用程序的情况下，领域服务是从音频中提取元数据的元数据服务以及允许用户添加更正的转录审查服务。
- en: Events
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: In the context of domain-driven design, events are domain-specific and notify
    other processes within the same domain of their occurrence. In this particular
    case, when a user uploads audio, they receive an ID back immediately. However,
    the metadata extraction process is triggered behind the scenes and rather than
    continuously polling on the request metadata command or endpoint to retrieve the
    status of the metadata object, an event can be sent to an event listener service.
    The CLI could have a command that continuously listens for process completion.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域驱动设计的背景下，事件是领域特定的，并通知同一领域内的其他进程其发生。在这种情况下，当用户上传音频时，他们会立即收到一个ID。然而，元数据提取过程在幕后被触发，而不是不断地轮询请求元数据命令或端点以检索元数据对象的状态，可以向事件监听服务发送一个事件。CLI可以有一个命令，持续监听处理完成。
- en: Repository
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓库
- en: A repository is a collection of the domain or entity objects. The repository
    has the responsibility of adding, updating, getting, and deleting objects. It
    makes aggregation possible. A repository is implemented within the domain layer,
    so there should be no knowledge of the specific database or storage – within the
    domain, the repository is only an interface. In the case of this metadata application,
    the repository can have different implementations – MongoDB, ElasticSearch, or
    flat file.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库是领域或实体对象的集合。仓库有添加、更新、获取和删除对象的责任。它使聚合成为可能。仓库在领域层中实现，因此不应了解特定的数据库或存储 – 在领域内，仓库只是一个接口。在这种情况下，这个元数据应用程序的仓库可以有不同的实现
    – MongoDB、ElasticSearch或平面文件。
- en: Creating the structure
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建结构
- en: 'Understanding the components of a domain-driven design, specific to an audio
    metadata CLI, we can start structuring the folders specific to a metadata CLI.
    Here is an example layout:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 理解特定于音频元数据CLI的领域驱动设计组件，我们可以开始构建特定于元数据CLI的文件夹结构。以下是一个示例布局：
- en: '[PRE0]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Main folders
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要文件夹
- en: 'Each folder is is follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件夹如下：
- en: '`cmd`: The command folder is the main entry point for two different applications
    that are a part of the audio metadata project: the API and CLI.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd`：命令文件夹是音频元数据项目中两个不同应用程序的主要入口点：API和CLI。'
- en: '`extractors`: This folder will hold the packages that will extract metadata
    from the audio. Although this extractor list will grow, we can start with a few
    extractor packages: `tags` and `transcript`.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extractors`：此文件夹将包含从音频中提取元数据的包。尽管这个提取器列表会增长，但我们可以从几个提取器包开始：`tags`和`transcript`。'
- en: '`models`: This folder will hold all the structs for the domain entities. The
    main entities to include are audio and metadata. Each of the extractors may also
    have its own data model and can be stored in this folder.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models`：此文件夹将包含所有领域实体的结构。要包含的主要实体是音频和元数据。每个提取器也可能有自己的数据模型，可以存储在这个文件夹中。'
- en: '`services`: Three services have been defined in our previous discussion – the
    metadata (extraction) service, the transcript review service, and an event listener
    service, which will listen for processing events and output notifications. Existing
    and new services exist within this folder.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services`：在我们的前一次讨论中定义了三个服务 – 元数据（提取）服务、转录审查服务以及一个事件监听服务，该服务将监听处理事件并输出通知。现有和新服务都存在于这个文件夹中。'
- en: '`storage`: The interface and individual implementations for storage exist within
    this folder.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage`：存储的接口和个别实现都存在于这个文件夹中。'
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have learned how to create a structure for a new
    application based on the unique requirements of the business domain. We looked
    at the most popular folder structures for applications and the pros and cons of
    each, and how to write documentation on use cases and nonfunctional requirements.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何根据业务领域的独特需求创建新应用程序的结构。我们探讨了应用程序最流行的文件夹结构以及每种结构的优缺点，以及如何编写用例和非功能性需求的文档。
- en: While this chapter provided an example layout and the main folders that exist
    within that example, remember that this is an example of a more developed project.
    Start simple, always with a flat structure, but start organizing for your future
    folder structure as you continue to build. Just bear in mind that your code structure
    will take time. Rome wasn’t built in a day.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一章提供了一个示例布局和该示例中存在的文件夹，但请记住，这是一个更发达项目的示例。开始时要简单，始终使用扁平结构，但随着你继续构建，开始组织你的未来文件夹结构。只需记住，你的代码结构需要时间。罗马不是一天建成的。
- en: After covering these topics, we then discussed a hypothetical real-world example
    of a company with a team focused entirely on audio metadata. We followed this
    up with some of the potential use cases for a CLI offering, which would be a fast
    and efficient alternative to the existing API.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了这些主题之后，我们接着讨论了一个假设的现实世界例子，即一家完全专注于音频元数据的团队的公司。随后，我们讨论了一些CLI提供的潜在用例，这将是一个快速高效的现有API的替代方案。
- en: Finally, we discussed a folder structure that could satisfy the requirements
    of the CLI and API audio metadata application. In [*Chapter 3*](B18883_03.xhtml#_idTextAnchor061),
    *Building an Audio Metadata CLI*, we will build out the folder structure with
    the models, interfaces, and implementations to get the CLI application working.
    That concludes this chapter on how to structure your Go CLI application! Hopefully,
    it will help you get started.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了一种文件夹结构，它可以满足CLI和API音频元数据应用程序的需求。在[*第3章*](B18883_03.xhtml#_idTextAnchor061)
    *构建音频元数据CLI* 中，我们将构建包含模型、接口和实现的文件夹结构，以使CLI应用程序工作。这标志着本章节关于如何结构化你的Go CLI应用程序的结束！希望这能帮助你开始。
- en: Questions
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: If you want to share packages with external applications or users, what common
    folder would these packages reside in?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想与外部应用程序或用户共享包，这些包通常会驻留在哪个常见的文件夹中？
- en: In ports-and-adapters, or hexagonal, architecture, what are the ports and what
    are the adapters?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口和适配器，或六边形架构中，端口和适配器是什么？
- en: For listing audio, in a real-world example, how would you define the actors,
    preconditions, and triggers of this use case?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于列出音频，在一个现实世界的例子中，你将如何定义这个用例的参与者、前提条件和触发器？
- en: Answers
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The `pkg` folder contains code that may be used by external applications.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pkg`文件夹包含可能被外部应用程序使用的代码。'
- en: Ports are the interfaces and the adapters are the implementations in a hexagonal
    architecture. Ports allow communication between different layers of the architecture
    while the adapters provide the actual implementation.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在六边形架构中，端口是接口，适配器是实现。端口允许架构的不同层之间进行通信，而适配器提供实际的实现。
- en: The actors are the operations team members or any user of the CLI. A precondition
    of the use case is that the user must be authenticated first. The use case is
    triggered by either the API’s /list endpoint for the metadata service or running
    the CLI command for listing audio.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参与者是操作团队成员或任何CLI用户。用例的前提是用户必须首先进行身份验证。该用例由API的/list端点（用于元数据服务）或运行列出音频的CLI命令触发。
- en: Further reading
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Kat Zein – *How Do you Structure Your Go Apps* from GopherCon 2018 ([https://www.youtube.com/watch?v=oL6JBUk6tj0](https://www.youtube.com/watch?v=oL6JBUk6tj0))
    – an excellent talk about the most common folder structures for Go applications
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kat Zein – *如何结构化你的Go应用* 来自2018年的GopherCon ([https://www.youtube.com/watch?v=oL6JBUk6tj0](https://www.youtube.com/watch?v=oL6JBUk6tj0))
    – 一场关于Go应用程序最常见文件夹结构的精彩演讲
