<html><head></head><body>
		<div id="_idContainer027">
			<h1 id="_idParaDest-63" class="chapter-number"><a id="_idTextAnchor061"/>3</h1>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor062"/>Building an Audio Metadata CLI</h1>
			<p><em class="italic">Hands-on learning</em> is one of the best ways to learn. So, in this chapter, we will build out a few of our example audio metadata CLI use cases from start to finish. The code is available online and can be explored alongside this chapter or independently. Forking the GitHub repo and playing around with the code, adding in new use cases and tests, are encouraged as these are excellent ways to learn before diving into some of the ways to refine your CLI in the <span class="No-Break">following chapters.</span></p>
			<p>Although this example covered in this chapter is not built on an empty code base – it is built on top of an existing REST API – it’s worth noting that the implementation of commands does not necessarily rely on an API. This is only an example and it’s encouraged that you use your imagination in this chapter on how commands could be implemented if not relying on an API. This chapter will give you an experimental code base and you’ll learn about the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Defining <span class="No-Break">the components</span></li>
				<li>Implementing <span class="No-Break">use cases</span></li>
				<li>Testing <span class="No-Break">and mocking</span></li>
			</ul>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor063"/>Technical requirements</h1>
			<p>Download the following code to <span class="No-Break">follow along:</span></p>
			<p><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter03/audiofile"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter03/audiofile</span></a><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter03"/></p>
			<p>Install the latest version of VS Code with the latest <span class="No-Break">Go tools.</span></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor064"/>Defining the components</h1>
			<p>The following is the folder structure for our audio metadata CLI. The main folders in this structure were described in<a id="_idIndexMarker172"/> the last chapter. Here, we will go into further detail on what each folder contains, and the files and code that exist within them, in order from top <span class="No-Break">to bottom:</span></p>
			<pre class="console">
   |--cmd
   |----api
   |----cli
   |------command
   |--extractors
   |----tags
   |----transcript
   |--internal
   |----interfaces
   |--models
   |--services
   |----metadata
   |--storage
   |--vendor</pre>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor065"/>cmd/</h2>
			<p>As previously <a id="_idIndexMarker173"/>mentioned in <a href="B18883_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Structuring Go Code for CLI Applications</em> in the <em class="italic">Commonly used program layouts for robust applications</em> section, the <strong class="source-inline">cmd</strong> folder is the main entry point for <a id="_idIndexMarker174"/>the different applications of <span class="No-Break">the project.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor066"/>cmd/api/</h2>
			<p>The <strong class="source-inline">main.go</strong> file, which in found in the <strong class="source-inline">cmd/api/</strong> folder, will start to run the audio metadata API locally on<a id="_idIndexMarker175"/> the machine. It takes in a port number as an optional<a id="_idIndexMarker176"/> flag, defaulting to <strong class="source-inline">8000</strong>, and passes the port number into a <strong class="source-inline">Run</strong> method within the <strong class="source-inline">services</strong> method that starts the <span class="No-Break">metadata service:</span></p>
			<pre class="source-code">
package main
import (
    metadataService "audiofile/services/metadata"
    "flag"
    "fmt"
)
func main() {
    var port int
    flag.IntVar(&amp;port, "p", 8000, "Port for metadata
      service")
    flag.Parse()
    fmt.Printf("Starting API at http://localhost:%d\n",
      port)
    metadataService.Run(port)
}</pre>
			<p>We make use of the <strong class="source-inline">flag</strong> package, which implements simple command-line flag parsing. There are different flag types that can be defined, such as <strong class="source-inline">String</strong>, <strong class="source-inline">Bool</strong>, and <strong class="source-inline">Int</strong>. In the preceding example, a <strong class="source-inline">-p</strong> flag is defined to override the default port of <strong class="source-inline">8000</strong>. <strong class="source-inline">flag.Parse()</strong> is called after all the flags are defined to parse the line into defined flags. There are a few syntactical methods allowed for passing flags to the command using Go’s <strong class="source-inline">flag</strong> package. The value <strong class="source-inline">8080</strong> will be parsed <span class="No-Break">either way:</span></p>
			<pre class="console">
-p=8080
-p 8080  // this works for non-boolean flags only</pre>
			<p>Sometimes, a flag does not require an argument and is enough on its own for the code to know exactly what <span class="No-Break">to do:</span></p>
			<pre class="console">
-p</pre>
			<p>Action can be taken on the flag that’s passed in, but the variable will contain the default value, <strong class="source-inline">8000</strong>, <span class="No-Break">when defined.</span></p>
			<p>To start the API<a id="_idIndexMarker177"/> from the<a id="_idIndexMarker178"/> project’s root directory, run <strong class="source-inline">go run cmd/api/main.go</strong> and you will see the <span class="No-Break">following output:</span></p>
			<pre class="console">
<img src="image/01.png" alt=""/>audiofile go run cmd/api/main.go
Starting API at http://localhost:8000</pre>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor067"/>cmd/cli/</h2>
			<p>This <strong class="source-inline">main.go</strong> file, in the <strong class="source-inline">cmd/cli/</strong> folder, runs the CLI, and like many other CLIs, this one will utilize the API by making calls to <a id="_idIndexMarker179"/>it. Since <a id="_idIndexMarker180"/>the API will need to be running for the CLI to work, run the API first in a separate terminal or in the background. The <strong class="source-inline">cmd/cli/main.go</strong> file contains the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
package main
import (
    "audiofile/internal/command"
    "audiofile/internal/interfaces"
    "fmt"
    "net/http"
    "os"
)
func main() {
    client := &amp;http.Client{}
    cmds := []interfaces.Command{
        command.NewGetCommand(client),
        command.NewUploadCommand(client),
        command.NewListCommand(client),
    }
    parser := command.NewParser(cmds)
    if err := parser.Parse(os.Args[1:]); err != nil {
        os.Stderr.WriteString(fmt.Sprintf("error: %v",
          err.Error()))
        os.Exit(1)
    }
}</pre>
			<p>Within the <strong class="source-inline">main.go</strong> file, the commands are added to a slice of interface <strong class="source-inline">Command </strong>type. Each command is defined <a id="_idIndexMarker181"/><span class="No-Break">and added:</span></p>
			<pre class="source-code">
command.NewGetCommand(client),
command.NewUploadCommand(client),
command.NewListCommand(client),</pre>
			<p>Each command takes the <strong class="source-inline">client</strong> variable, a default <strong class="source-inline">http.Client</strong> as a parameter to use to make HTTP requests to the audio<a id="_idIndexMarker182"/> metadata API endpoints. Passing in the <strong class="source-inline">client</strong> command allows it to be easily mocked for testing, which we will discuss in the <span class="No-Break">next section.</span></p>
			<p>The commands are then passed into a <strong class="source-inline">NewParser</strong> method, which creates a pointer <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">command.Parser</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
parser := command.NewParser(cmds)</pre>
			<p>This <strong class="source-inline">Parse</strong> function receives all arguments after the application name via the <strong class="source-inline">os.Args[1:]</strong> parameter value. For example, say the command line is called <span class="No-Break">as follows:</span></p>
			<pre class="console">
 ./audiofile-cli upload -filename recording.m4v</pre>
			<p>Then, the first argument, <strong class="source-inline">os.Args[0]</strong>, returns the <span class="No-Break">following value:</span></p>
			<pre class="console">
 audiofile-cli</pre>
			<p>To explain this further, let’s look <a id="_idIndexMarker183"/>at the <strong class="source-inline">Command</strong> struct and the<a id="_idIndexMarker184"/> fields present <span class="No-Break">within it:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_3.01.jpg" alt="Figure 3.1 – Command struct and flag.FlagSet entities"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Command struct and flag.FlagSet entities</p>
			<p>Let us look at the <strong class="source-inline">GetCommand</strong> struct depicted in <span class="No-Break">the figure:</span></p>
			<pre class="source-code">
type GetCommand struct {
    fs *flag.FlagSet
    client interfaces.Client
    id string
}</pre>
			<p>Each of the commands has a flag set, which contains a name for the command and error handling, a client, and <span class="No-Break">an ID.</span></p>
			<p>The arguments to a Go program are stored in the <strong class="source-inline">os.Args </strong>slice, which is a collection of strings. The name of the executable being run is stored in the first element of the <strong class="source-inline">os.Args </strong>slice (i.e., <strong class="source-inline">os.Args[0]</strong>), while the arguments passed to the executable are stored in the subsequent <span class="No-Break">elements (</span><span class="No-Break"><strong class="source-inline">os.Args[1:]</strong></span><span class="No-Break">).</span></p>
			<p>When you see the code,  <strong class="source-inline">parser.Parse(os.Args[1:])</strong>, it means you’re passing the remainder of the command-line arguments to <strong class="source-inline">parse.Parse</strong> function, skipping the first <a id="_idIndexMarker185"/>argument (the name of the program). All the arguments on the command line, besides the program’s name, will be passed to the function in <span class="No-Break">this case.</span></p>
			<p>That means when we pass in <strong class="source-inline">os.Args[1:]</strong>, we are passing into <strong class="source-inline">parse.Parse</strong> all the arguments after the <a id="_idIndexMarker186"/><span class="No-Break">program name:</span></p>
			<pre class="console">
 upload –filename recording.m4v</pre>
			<p>Parse takes <strong class="source-inline">args</strong>, a string list, and returns an <strong class="source-inline">error </strong>type. The function converts command-line parameters into <span class="No-Break">executable commands.</span></p>
			<p>Let’s walk through the code <a id="_idIndexMarker187"/>alongside the following <span class="No-Break">flow chart:</span></p>
			<ul>
				<li>It checks for less than 1 args. If so, <strong class="source-inline">help()</strong> <span class="No-Break">returns n</span><span class="No-Break"><strong class="source-inline">il.</strong></span></li>
				<li><strong class="source-inline">Args[0]</strong> is assigned to subcommand if the slice has at least one item. This shows the <span class="No-Break">user’s command.</span></li>
				<li>The function then cycles over the <strong class="source-inline">Parser</strong> struct’s <strong class="source-inline">p.commands</strong> property. It checks each command’s name (obtained by executing the <strong class="source-inline">Name()</strong> method) against the <span class="No-Break"><strong class="source-inline">subcommand </strong></span><span class="No-Break">variable.</span></li>
				<li>The function executes the command’s <strong class="source-inline">ParseFlags</strong> method with the rest of the <strong class="source-inline">args</strong> slice if a match is found (<strong class="source-inline">args[1:]</strong>). Finally, the function runs the command and returns <span class="No-Break">the result.</span></li>
				<li>If no match is found, the method returns an unknown subcommand error message using the <span class="No-Break"><strong class="source-inline">fmt.Errorf</strong></span><span class="No-Break"> function.</span></li>
			</ul>
			<p>Essentially, the code finds and executes a command from command line arguments. Then, the matching command <span class="No-Break">is run.</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_3.02.jpg" alt="Figure 3.2 – Flow diagram for the Parse method"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Flow diagram for the Parse method</p>
			<p>A command exists for each API endpoint. For example, <strong class="source-inline">UploadCommand</strong> will call the <strong class="source-inline">/upload</strong> endpoint, <strong class="source-inline">ListCommand</strong> will call the <strong class="source-inline">/list</strong> endpoint, and <strong class="source-inline">GetCommand</strong> will call the <strong class="source-inline">/get</strong> endpoint of the <span class="No-Break">REST API.</span></p>
			<p>Within the <strong class="source-inline">Parse</strong> method, the<a id="_idIndexMarker188"/> length of <strong class="source-inline">args</strong> is checked. If no<a id="_idIndexMarker189"/> arguments are passed, then help is printed and the program <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">nil</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
audiofile ./audiofile-cli
usage: ./audiofile-cli &lt;command&gt; [&lt;args&gt;]
These are a few Audiofile commands:
    get      Get metadata for a particular audio file by id
    list     List all metadata
    upload   Upload audio file</pre>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor068"/>cmd/cli/command</h2>
			<p>In the <strong class="source-inline">cmd/cli/command</strong> folder, there are commands to match each of the audiofile API endpoints. In the next <a id="_idIndexMarker190"/>section, we will code the <strong class="source-inline">upload</strong>, <strong class="source-inline">list</strong>, and <strong class="source-inline">get</strong> commands to implement a couple of the<a id="_idIndexMarker191"/> use cases described in the previous chapter. Rather than defining the code for one of these commands here, I’ll provide a structure used to define a random command that satisfies the <span class="No-Break"><strong class="source-inline">Command</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
package command
import (
    "github.com/marianina8/ audiofile/internal/cli"
    "github.com/marianina8/ audiofile/internal/interfaces"
    "flag"
    "fmt"
)
func NewRandomCommand(client interfaces.Client)
    *RandomCommand {
    gc := &amp;RandomCommand{
        fs: flag.NewFlagSet("random",
           flag.ContinueOnError),
        client: client,
    }
    gc.fs.StringVar(&amp;gc.flag, "flag", "", "string flag for
      random command")
    return gc
}
type RandomCommand struct {
    fs *flag.FlagSet
    flag string
}
func (cmd *RandomCommand) Name() string {
    return cmd.fs.Name()
}
func (cmd *RandomCommand) ParseFlags(flags []string) error {
    return cmd.fs.Parse(flags)
}
func (cmd *RandomCommand) Run() error {
    fmt.Println(rand.Intn(100))
    return nil
}</pre>
			<p>The <strong class="source-inline">upload</strong>, <strong class="source-inline">get</strong>, and <strong class="source-inline">list</strong> commands follow the same structure, but the implementation of the<a id="_idIndexMarker192"/> constructor and <strong class="source-inline">Run</strong> <span class="No-Break">methods differ.</span></p>
			<p>Also, in the <strong class="source-inline">cmd/cli/command</strong> folder, there is a parser of the struct type with a method to parse the arguments, match <a id="_idIndexMarker193"/>them with the commands, and parse any flags found after the subcommand. The <strong class="source-inline">NewParser</strong> function creates a new instance of the <strong class="source-inline">Parser</strong> struct. It takes a slice of type <strong class="source-inline">[]interfaces.Command</strong> as input and returns a pointer to a <strong class="source-inline">Parser</strong> struct. This initialization method provides an easy way to set up the struct with a set of<a id="_idIndexMarker194"/> desired commands. The following<a id="_idIndexMarker195"/> is the code <span class="No-Break">inside </span><span class="No-Break"><strong class="source-inline">parser.go</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package command
import (
    "github.com/marianina8/audiofile/internal/interfaces"
    "fmt"
)
type Parser struct {
    commands []interfaces.Command
}
func NewParser(commands []interfaces.Command) *Parser {
    return &amp;Parser{commands: commands}
}
func (p *Parser) Parse(args []string) error {
    if len(args) &lt; 1 {
        help()
        return nil
    }
    subcommand := args[0]
    for _, cmd := range p.commands {
        if cmd.Name() == subcommand {
            cmd.ParseFlags(args[1:])
            return cmd.Run()
        }
    }
    return fmt.Errorf("Unknown subcommand: %s", subcommand)
}</pre>
			<p>The code checks the number of arguments passed to the <strong class="source-inline">Parse</strong> method. If the number of arguments is less than 1, a <strong class="source-inline">help</strong> function from a separate <strong class="source-inline">help.go</strong> file is called to print the help text<a id="_idIndexMarker196"/> to guide the user on<a id="_idIndexMarker197"/> <span class="No-Break">proper usage:</span></p>
			<pre class="source-code">
func help() {
    help := `usage: ./audiofile-cli &lt;command&gt; [&lt;flags&gt;]
These are a few Audiofile commands:
    get      Get metadata for a particular audio file by id
    list     List all metadata
    upload   Upload audio file
    `
    fmt.Println(help)
}</pre>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor069"/>extractors/</h2>
			<p>This folder contains<a id="_idIndexMarker198"/> implementations for the different <a id="_idIndexMarker199"/>extractors of audio metadata. In this case, subfolders exist for the <strong class="source-inline">tags</strong> and <span class="No-Break"><strong class="source-inline">transcript</strong></span><span class="No-Break"> implementations.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor070"/>extractors/tags</h2>
			<p>The <strong class="source-inline">tags</strong> package is implemented <a id="_idIndexMarker200"/>within the <strong class="source-inline">extractors/tags</strong> folder. Tags <a id="_idIndexMarker201"/>metadata may include title, album, artists, composer, genre, release year, lyrics, and any additional comments. The code is available within the GitHub repository and utilizes the <strong class="source-inline">github.com/dhowden/tag</strong> <span class="No-Break">Go package.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor071"/>extractors/transcript</h2>
			<p>The <strong class="source-inline">transcript</strong> package is implemented within the <strong class="source-inline">extractors/transcript</strong> folder. Like the other extraction<a id="_idIndexMarker202"/> package, the code<a id="_idIndexMarker203"/> can be found in the GitHub repository. However, transcript analysis is handled by AssemblyAI, a third-party API, and requires an API key, which can be set locally <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">ASSEMBLY_API_KEY</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor072"/>internal/interfaces</h2>
			<p>The <strong class="source-inline">internal/interfaces</strong> folder holds<a id="_idIndexMarker204"/> interfaces utilized by the application. It includes both the <strong class="source-inline">Command</strong> and <strong class="source-inline">Storage</strong> interfaces. Interfaces <a id="_idIndexMarker205"/>provide a way for developers to create multiple types that meet the same interface specifications allowing flexibility and modularity in the design of the application. The <strong class="source-inline">storage.go</strong> file defines the <span class="No-Break">storage interface:</span></p>
			<pre class="source-code">
package interfaces
import (
    "audiofile/models"
)
type Storage interface {
    Upload(bytes []byte, filename string) (string, string,
      error)
    SaveMetadata(audio *models.Audio) error
    List() ([]*models.Audio, error)
    GetByID(id string) (*models.Audio, error)
    Delete(id string, tag string) error
}</pre>
			<p>The preceding interface satisfies all possible use cases. Specific implementations can be defined in the <strong class="source-inline">storage</strong> folder. If you choose to define the storage type within a configuration, you can easily swap out implementations and switch from one storage type to another. In this example, we define flat file storage with an implementation of each method to satisfy <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker206"/></span><span class="No-Break"> interface.</span></p>
			<p>First utilized in<a id="_idIndexMarker207"/> the <strong class="source-inline">cmd/cli/main.go</strong> file, the <strong class="source-inline">Command</strong> interface is defined by the following code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">internal/interfaces/command.go</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type <strong class="bold">Command</strong> interface {
   <strong class="bold">ParseFlags</strong>([]string) error
   <strong class="bold">Run</strong>() error
   <strong class="bold">Name</strong>() string
}</pre>
			<p>Notice how each of the commands in the <strong class="source-inline">cmd/cli/command/</strong> folder implements the <span class="No-Break">preceding interface.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor073"/>models/</h2>
			<p>The <strong class="source-inline">models</strong> folder contains a <a id="_idIndexMarker208"/>structs shared across the different<a id="_idIndexMarker209"/> applications. The first struct defined for the <strong class="source-inline">audiofile</strong> application <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Audio</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type Audio struct {
    Id       string
    Path     string
    Metadata Metadata
    Status   string
    Error    []error
}</pre>
			<p>The <strong class="source-inline">Id</strong> variable<a id="_idIndexMarker210"/> contains the unique <strong class="bold">identifier(ID)</strong>, of the <strong class="source-inline">Audio</strong> file. The path the stored local copy of the audio file. The <strong class="source-inline">Metadata</strong> variable contains the data extracted from the audio file. In the following example, tags and speech-to-text transcript data are <span class="No-Break">being stored:</span></p>
			<pre class="source-code">
type Metadata struct {
    Tags         Tags         `json:"tags"`
    Transcript   string       `json:"transcript"`
}</pre>
			<p>It’s not necessary<a id="_idIndexMarker211"/> to know the struct for each extraction type. The most important thing is the main entity type, <strong class="source-inline">Audio</strong>, and its value <span class="No-Break">field, </span><span class="No-Break"><strong class="source-inline">Metadata</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor074"/>services/metadata</h2>
			<p>Although multiple <a id="_idIndexMarker212"/>services could be implemented in the <strong class="source-inline">services</strong> folder, we’re currently only utilizing <a id="_idIndexMarker213"/>one API service, the audio metadata service. The only method that exists in the <strong class="source-inline">metadata.go</strong> file is the <strong class="source-inline">CreateMetadataServer</strong> method, which is called in the <strong class="source-inline">metadata</strong> package, and the <strong class="source-inline">Run</strong> method, which is called from the <strong class="source-inline">cmd/api/main.go</strong> file. This file also contains the struct <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">MetadataService</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type MetadataService struct {
    Server *http.Server
    Storage interfaces.Storage
}</pre>
			<p><strong class="source-inline">CreateMetadataService</strong> takes an argument, a port of the <strong class="source-inline">int</strong> type, to define the server’s port running on localhost. It also takes an argument, <strong class="source-inline">storage</strong>, which is an implementation of the <strong class="source-inline">Storage</strong> interface. The handlers that declare each endpoint of the API server are also defined. This function returns a pointer <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">MetadataService</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func CreateMetadataService(port int, storage
   interfaces.Storage) *MetadataService {
    mux := http.NewServeMux()
    metadataService := &amp;MetadataService{
        Server: &amp;http.Server{
            Addr:    fmt.Sprintf(":%v", port),
            Handler: mux,
        },
        Storage: storage,
    }
    mux.HandleFunc("/upload",
      metadataService.uploadHandler)
    mux.HandleFunc("/request",
      metadataService.getByIDHandler)
    mux.HandleFunc("/list", metadataService.listHandler)
    return metadataService
}</pre>
			<p>The <strong class="source-inline">Run</strong> method, which takes an argument, <strong class="source-inline">port</strong>, defined by the value of the <strong class="source-inline">p</strong> flag or the default value of <strong class="source-inline">8000</strong>, calls the <strong class="source-inline">CreateMetadataService</strong> method and initiates running the server by <a id="_idIndexMarker214"/>calling the <strong class="source-inline">ListenAndServer</strong> method on the server. Any error with starting the API will <a id="_idIndexMarker215"/>be <span class="No-Break">returned immediately:</span></p>
			<pre class="source-code">
func Run(port int) {
    flatfileStorage := storage.FlatFile{}
    service:= CreateMetadataService(port, flatfileStorage)
    err := service.Server.ListenAndServe()
    if err != nil {
        fmt.Println("error starting api: ", err)
    }
}</pre>
			<p>Implementations of each<a id="_idIndexMarker216"/> of the handlers will be discussed in the next section when handling a few <span class="No-Break">use cases.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor075"/>storage/</h2>
			<p>In the <strong class="source-inline">storage</strong> folder, there is the <strong class="source-inline">flatfile.go</strong> file, which implements a method of storing metadata locally to a flat <a id="_idIndexMarker217"/>file organized via ID on the<a id="_idIndexMarker218"/> local disk. The code implementation of this will not be discussed in this book because it goes beyond the scope of focus on the CLI. However, you can view the code in the <span class="No-Break">GitHub repository.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor076"/>vendor/</h2>
			<p>The <strong class="source-inline">vendor</strong> directory holds all <a id="_idIndexMarker219"/>direct and <span class="No-Break">indirect </span><span class="No-Break"><a id="_idIndexMarker220"/></span><span class="No-Break">dependencies.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor077"/>Implementing use cases</h1>
			<p>Remember the<a id="_idIndexMarker221"/> use cases defined in the previous chapter? Let’s try to implement a couple <span class="No-Break">of them:</span></p>
			<ul>
				<li>UC-01 <span class="No-Break">Upload audio</span></li>
				<li>UC-02 <span class="No-Break">Request metadata</span></li>
			</ul>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor078"/>Uploading audio</h2>
			<p>In this use case, an <a id="_idIndexMarker222"/>authenticated user uploads an audio file by giving the location of the file on their device for the purpose<a id="_idIndexMarker223"/> of extracting its metadata. Under the hood, the upload process will save a local copy and run the metadata extraction process on the audio file. A unique ID for the audio file is <span class="No-Break">returned immediately.</span></p>
			<p>Before we begin to implement this use case, let’s consider what the command for uploading may look like. Suppose we’ve settled on the following final <span class="No-Break">command structure:</span></p>
			<pre class="console">
./audiofile-cli upload -filename &lt;filepath&gt;</pre>
			<p>Since <strong class="source-inline">/cmd/cli/main.go</strong> is already defined, we’ll just need to make sure that the <strong class="source-inline">upload</strong> command exists and <a id="_idIndexMarker224"/>satisfies the <strong class="source-inline">command</strong> interface, with <a id="_idIndexMarker225"/>the <strong class="source-inline">ParseFlags</strong>, <strong class="source-inline">Run</strong>, and <strong class="source-inline">Name</strong> methods. In the <strong class="source-inline">internal/command</strong> folder, we define the <strong class="source-inline">upload</strong> command in the <strong class="source-inline">upload.go</strong> file within the <span class="No-Break"><strong class="source-inline">command</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
package command
import (
    "github.com/marianina8/audiofile/internal/interfaces"
    "bytes"
    "flag"
    "fmt"
    "io"
    "io"
    "mime/multipart"
    "net/http"
    "os"
    "path/filepath"
)
func NewUploadCommand(client interfaces.Client)
    *UploadCommand {
    gc := &amp;UploadCommand{
        fs:     flag.NewFlagSet("upload",
                  flag.ContinueOnError),
        client: client,
    }
    gc.fs.StringVar(&amp;gc.filename, "filename", "", "full
      path of filename to be uploaded")
    return gc
}
type UploadCommand struct {
    fs       *flag.FlagSet
    client   interfaces.Client
    filename string
}
func (cmd *UploadCommand) Name() string {
    return cmd.fs.Name()
}
func (cmd *UploadCommand) ParseFlags(flags []string)
  error {
    if len(flags) == 0 {
        fmt.Println("usage: ./audiofile-cli
          upload -filename &lt;filename&gt;")
        return fmt.Errorf("missing flags")
    }
    return cmd.fs.Parse(flags)
}
func (cmd *UploadCommand) Run() error {
    // implementation for upload command
    return nil
}</pre>
			<p>The <strong class="source-inline">NewUploadCommand</strong> method implements our desired command structure by defining a new flag set for the <span class="No-Break"><strong class="source-inline">upload</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
flag.NewFlagSet("upload", flag.ContinueOnError)</pre>
			<p>This method call passes the string, <strong class="source-inline">upload</strong>, into the method’s <strong class="source-inline">name</strong> parameter and flag. <strong class="source-inline">ContinueOnError</strong> in the <strong class="source-inline">flag.ErrorHandling</strong> parameter defines how the application should react if<a id="_idIndexMarker226"/> an error occurs when parsing the flag. The different, and mostly self-explanatory, options for handling <a id="_idIndexMarker227"/>errors upon parsing include <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">flag.ContinueOnError</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">flag.ExitOnError</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">flag.PanicOnError</strong></span></li>
			</ul>
			<p>Now that we’ve defined and added the <strong class="source-inline">upload</strong> command, we can test it out. Upon testing, you’ll see that the <strong class="source-inline">upload</strong> command runs without an error but exits immediately with no response. Now, we are ready to implement the <strong class="source-inline">Run</strong> method of the <span class="No-Break"><strong class="source-inline">upload</strong></span><span class="No-Break"> command.</span></p>
			<p>When we first started implementing a CLI for the audiofile application, an API already existed. We discussed how this API starts and runs <strong class="source-inline">MetadataServer</strong>, which handles requests to a few existing endpoints. For this use case, we are concerned with the <span class="No-Break"><strong class="source-inline">http://localhost/upload</strong></span><span class="No-Break"> endpoint.</span></p>
			<p>With this in mind, let’s delve deeper into the documentation for the upload endpoint of this REST API so we will know<a id="_idIndexMarker228"/> exactly how to construct a <span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break"> command.</span></p>
			<h3>Uploading audio</h3>
			<p>In order to upload audio, we’ll need to know how to communicate with the API to handle certain tasks. Here are the details required to design a request to handle <span class="No-Break">uploading audio:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Method</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">POST</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Endpoint</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">http://localhost/upload</strong></span></li>
				<li><strong class="bold">Header</strong>: <span class="No-Break"><strong class="source-inline">Content-Type: multipart/form-data</strong></span></li>
				<li><strong class="bold">Form data</strong>: <strong class="source-inline">Key ("file") Value (bytes) Name(base </strong><span class="No-Break"><strong class="source-inline">of filename)</strong></span></li>
			</ul>
			<p>Make sure that the <a id="_idIndexMarker229"/>API is running, and then test out the endpoint using <strong class="source-inline">curl</strong>. Immediately, the ID of the uploaded file <span class="No-Break">is returned:</span></p>
			<pre class="console">
curl --location --request POST 'http://localhost/upload' \
--form 'file=@"recording.mp3"'
8a6dc954-d6df-4fc0-882e-14eb1581d968%</pre>
			<p>After successfully testing out the API endpoint, we can write the Go code that handles the same functionality as the previous <strong class="source-inline">curl</strong> command within the <strong class="source-inline">Run</strong> method <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">UploadCommand</strong></span><span class="No-Break">.</span></p>
			<p>The new <strong class="source-inline">Run</strong> method can now be defined. The method supplies the filename that’s been passed into the <strong class="source-inline">upload</strong> command as a flag parameter and saves the bytes of that file to a multipart form <strong class="source-inline">POST</strong> request to the <span class="No-Break"><strong class="source-inline">http://localhost/upload</strong></span><span class="No-Break"> endpoint:</span></p>
			<pre class="source-code">
func (cmd *UploadCommand) Run() error {
    if cmd.filename == "" {
        return fmt.Errorf("missing filename")
    }
    fmt.Println("Uploading", cmd.filename, "...")
    url := "http://localhost/upload"
    method := "POST"
    payload := &amp;bytes.Buffer{}
    multipartWriter := multipart.NewWriter(payload)
    file, err := os.Open(cmd.filename)
    if err != nil {
        return err
    }
    defer file.Close()
    partWriter, err := multipartWriter
      .CreateFormFile("file", filepath.Base(cmd.filename))
    if err != nil {
        return err
    }
    _, err = io.Copy(partWriter, file)
    if err != nil {
        return err
    }
    err = multipartWriter.Close()
    if err != nil {
        return err
    }
    client := cmd.client
    req, err := http.NewRequest(method, url, payload)
    if err != nil {
        return err
    }
    req.Header.Set("Content-Type",
      multipartWriter.FormDataContentType())
    res, err := client.Do(req)
    if err != nil {
        return err
    }
    defer res.Body.Close()
    body, err := io.ReadAll(res.Body)
    if err != nil {
        return err
    }
    fmt.Println("Audiofile ID: ", string(body))
    return err
}</pre>
			<p>The first CLI <a id="_idIndexMarker230"/>command, <strong class="source-inline">upload</strong>, has been<a id="_idIndexMarker231"/> implemented! Let’s implement another use case, requesting metadata <span class="No-Break">by ID.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor079"/>Requesting metadata</h2>
			<p>In the requesting metadata use case, an authenticated user requests audio metadata by the audio file’s ID. Under the<a id="_idIndexMarker232"/> hood, the request metadata process will, within the flat file storage implementation, search<a id="_idIndexMarker233"/> for the <strong class="source-inline">metadata.json</strong> file corresponding with the audio file and decode its contents into the <span class="No-Break"><strong class="source-inline">Audio</strong></span><span class="No-Break"> struct.</span></p>
			<p>Before implementing the request metadata use case, let’s consider what the command for requesting metadata will look like. The final command structure will look <span class="No-Break">like this:</span></p>
			<pre class="console">
./audiofile-cli get -id &lt;ID&gt;</pre>
			<p>For simplification, <strong class="source-inline">get</strong> is the command to request metadata. Let’s define the new <strong class="source-inline">get</strong> command, and in <strong class="source-inline">/cmd/cli/main.go</strong>, confirm that it is present in the list of commands to recognize when the application is run. The structure for defining the <strong class="source-inline">get</strong> command is similar to that of the first <span class="No-Break">command, </span><span class="No-Break"><strong class="source-inline">upload</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package command
import (
    "github.com/marianina8/audiofile/internal/interfaces"
    "bytes"
    "flag"
    "fmt"
    "io"
    "net/http"
    "net/url"
)
func NewGetCommand(client interfaces.Client) *GetCommand {
    gc := &amp;GetCommand{
        fs:     flag.NewFlagSet("get",
                  flag.ContinueOnError),
        client: client,
    }
    gc.fs.StringVar(&amp;gc.id, "id", "", "id of audiofile
      requested")
    return gc
}
type GetCommand struct {
    fs     *flag.FlagSet
    client interfaces.Client
    id     string
}
func (cmd *GetCommand) Name() string {
    return cmd.fs.Name()
}
func (cmd *GetCommand) ParseFlags(flags []string) error {
    if len(flags) == 0 {
        fmt.Println("usage: ./audiofile-cli get -id &lt;id&gt;")
        return fmt.Errorf("missing flags")
    }
    return cmd.fs.Parse(flags)
}
func (cmd *GetCommand) Run() error {
    // implement get command
    return nil
}</pre>
			<p>The <strong class="source-inline">NewGetCommand</strong> method implements our desired command structure by defining a new flag set for the <strong class="source-inline">get</strong> command, <strong class="source-inline">flag.NewFlagSet("get", flag.ContinueOnError)</strong>. This method receives the string, <strong class="source-inline">get</strong>, in the method’s <strong class="source-inline">name</strong> parameter and <strong class="source-inline">flag.ContinueOnError</strong> in the <span class="No-Break"><strong class="source-inline">flag.ErrorHandling</strong></span><span class="No-Break"> parameter.</span></p>
			<p>Let’s delve deeper into the<a id="_idIndexMarker234"/> documentation for the get  endpoint of this REST API so we will know exactly how to construct a <span class="No-Break">curl command.</span></p>
			<h3>Requesting metadata</h3>
			<p>In order to request audio metadata, we’ll<a id="_idIndexMarker235"/> need to know how to communicate with the API to handle this task. Here are the details required to design a request for <span class="No-Break">audio metadata:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Method</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">GET</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Endpoint</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">http://localhost/get</strong></span></li>
				<li><strong class="bold">Query parameter</strong>: <strong class="source-inline">id</strong> – ID of <span class="No-Break">audio file</span></li>
			</ul>
			<p>Make sure that the API is running, and then test out the <strong class="source-inline">get</strong> endpoint using <strong class="source-inline">curl</strong>. Immediately, the metadata of the requested audio file is returned in JSON format. This data could be returned in different formats, and we could add an additional flag to determine the format of the <span class="No-Break">returned metadata:</span></p>
			<pre class="console">
curl --location --request GET
'http://localhost/request?id=270c3952-0b48-4122-bf2a-
 e4a005303ecb'
{audiofile metadata in JSON format}</pre>
			<p>After confirming that the API <a id="_idIndexMarker236"/>endpoint works as expected, we can write the Go code that handles the same functionality<a id="_idIndexMarker237"/> as the preceding <strong class="source-inline">curl</strong> command within the <strong class="source-inline">Run</strong> method of <strong class="source-inline">GetCommand</strong>. The new <strong class="source-inline">Run</strong> method can now <span class="No-Break">be defined:</span></p>
			<pre class="source-code">
func (cmd *GetCommand) Run() error {
    if cmd.id == "" {
        return fmt.Errorf("missing id")
    }
    params := "id=" + url.QueryEscape(cmd.id)
    path := fmt.Sprintf("http://localhost/request?%s",
      params)
    payload := &amp;bytes.Buffer{}
    method := "GET"
    client := cmd.client
    req, err := http.NewRequest(method, path, payload)
    if err != nil {
        return err
    }
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    b, err := io.ReadAll(resp.Body)
    if err != nil {
        fmt.Println("error reading response: ",
          err.Error())
        return err
    }
    fmt.Println(string(b))
    return nil
}</pre>
			<p>Now that the request metadata use case has been implemented, let’s compile the code and test out the first couple of CLI commands: <strong class="source-inline">upload</strong>, for uploading and processing audio metadata, and <strong class="source-inline">get</strong>, for requesting metadata by <span class="No-Break">audiofile ID.</span></p>
			<p>Giving the CLI a<a id="_idIndexMarker238"/> more specific name, <strong class="source-inline">audiofile-cli</strong>, let’s generate the build by running the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker239"/></span><span class="No-Break"> command:</span></p>
			<pre class="console">
go build -o audiofile-cli cmd/cli/main.go</pre>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor080"/>Testing a CLI</h1>
			<p>Now that we have <a id="_idIndexMarker240"/>successfully built the CLI application, we can do some testing to make sure that it’s working. We can test out the commands we’ve created and then write out proper tests to make sure any future changes don’t break the <span class="No-Break">current functionality.</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor081"/>Manual testing</h2>
			<p>To upload an audio file, we’ll run<a id="_idIndexMarker241"/> the <span class="No-Break">following command:</span></p>
			<pre class="console">
./audiofile-cli upload -filename audio/beatdoctor.mp3</pre>
			<p>The result is <span class="No-Break">as expected:</span></p>
			<pre class="console">
Uploading audio/beatdoctor.mp3 ...
Audiofile ID:  8a6a8942-161e-4b10-bf59-9d21785c9bd9</pre>
			<p>Now that we have the audiofile ID, we can immediately get the metadata, which will change as the metadata updates after each extraction process. The command for requesting<a id="_idIndexMarker242"/> metadata is <span class="No-Break">as follows:</span></p>
			<pre class="console">
./audiofile-cli get -id=8a6a8942-161e-4b10-bf59-
9d21785c9bd9</pre>
			<p>The result is the populated <strong class="source-inline">Audio</strong> struct in <span class="No-Break">JSON format:</span></p>
			<pre class="console">
{
    "Id": "8a6a8942-161e-4b10-bf59-9d21785c9bd9",
    "Path": "/Users/marian/audiofile/8a6a8942-161e-4b10-
    bf59-9d21785c9bd9/beatdoctor.mp3",
    "Metadata": {
        "tags": {
            "title": "Shot In The Dark",
            "album": "Best Bytes Volume 4",
            "artist": "Beat Doctor",
            "album_artist": "Toucan Music (Various
              Artists)",
            "genre": "Electro House",
            "comment": "URL: http://freemusicarchive.org/
            music/Beat_Doctor/Best_Bytes_Volume_4/
            09_beat_doctor_shot_in_the_dark\r\nComments:
            http://freemusicarchive.org/\r\nCurator: Toucan
            Music\r\nCopyright: Attribution-NonCommercial
            3.0 International: http://creativecommons.org/
            licenses/by-nc/3.0/"
        },
        "transcript": "This is Sharon."
    },
    "Status": "Complete",
    "Error": null
}</pre>
			<p>The results are as expected. However, not all audio passed into the CLI will return the same data. This is just an example. Some audio may not have any tags at all and transcription will be skipped if you don’t have the <strong class="source-inline">ASSEMBLYAI_API_KEY</strong> environment variable set with an AssemblyAI API key. Ideally, API keys should not be set as environment variables, which can be leaked easily, but this is a temporary option. In <a href="B18883_04.xhtml#_idTextAnchor087"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Popular Frameworks for Building CLIs</em>, you will learn about Viper, which is a configuration<a id="_idIndexMarker243"/> library that pairs perfectly with the Cobra <span class="No-Break">CLI framework.</span></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor082"/>Testing and mocking</h2>
			<p>Now, we can start writing<a id="_idIndexMarker244"/> some unit tests. In the <strong class="source-inline">main.go</strong> file, there is a root function that parses the arguments passed into the application. Using VS Code and the extension for Go support, you can right-click on a function and see an option for generating unit tests, <strong class="bold">Go: Generate Unit Tests </strong><span class="No-Break"><strong class="bold">For Function</strong></span><span class="No-Break">.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_3.03.jpg" alt="Figure 3.3 –Screenshot of VS Code menu of Go options"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 –Screenshot of VS Code menu of Go options</p>
			<p>Select the <strong class="source-inline">Parse</strong> function in the <strong class="source-inline">commands</strong> package and then click on the option to generate the following table-driven unit tests inside the <strong class="source-inline">parser_test.go</strong> file, we can see the test function for<a id="_idIndexMarker245"/> the <span class="No-Break">parsing functionality:</span></p>
			<pre class="source-code">
func TestParser_Parse(t *testing.T) {
    type fields struct {
        commands []interfaces.Command
    }
    type args struct {
        args []string
    }
    tests := []struct {
        name    string
        fields  fields
        args    args
        wantErr bool
    }{
        // TODO: Add test cases.
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            p := &amp;Parser{
                commands: tt.fields.commands,
            }
            if err := p.Parse(tt.args.args); (err != nil)
              != tt.wantErr {
                t.Errorf("Parser.Parse() error = %v,
                  wantErr %v", err, tt.wantErr)
            }
        })
    }
}</pre>
			<p>This provides a great template for us to implement some tests given different argument and flag combinations utilized in the method. When running the tests, we don’t want the client to call the<a id="_idIndexMarker246"/> REST endpoints, so we mock the client and fake responses. We do all this inside the <strong class="source-inline">parser_test.go</strong> file. Since each of the commands takes in a client, we can easily mock the interface. This is done in the file using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
type MockClient struct {
    DoFunc func(req *http.Request) (*http.Response, error)
}
func (m *MockClient) Do(req *http.Request) (*http.Response,
    error) {
    if strings.Contains(req.URL.String(), "/upload") {
        return &amp;http.Response{
            StatusCode: 200,
            Body:       io.NopCloser
              (strings.NewReader("123")),
        }, nil
    }
    if strings.Contains(req.URL.String(), "/request") {
        value, ok := req.URL.Query()["id"]
        if !ok || len(value[0]) &lt; 1 {
             return &amp;http.Response{
    StatusCode: 500,
    Body: io.NopCloser(strings.NewReader("url param 'id' is 
    missing")),
    }, fmt.Errorf("url param 'id' is missing")
        }
        if value[0] != "123" {
            return &amp;http.Response{
                StatusCode: 500,
                Body:       io.NopCloser
               (strings.NewReader("audiofile id does not
                 exist")),
            }, fmt.Errorf("audiofile id does not exist")
        }
        file, err := os.ReadFile("testdata/audio.json")
        if err != nil {
            return nil, err
        }
        return &amp;http.Response{
            StatusCode: 200,
            Body:       io.NopCloser
              (strings.NewReader(string(file))),
        }, nil
    }
    return nil, nil
}</pre>
			<p>The <strong class="source-inline">MockClient</strong> interface is satisfied by <strong class="source-inline">http.DefaultClient</strong>. The <strong class="source-inline">Do</strong> method is mocked. Within the <strong class="source-inline">Do</strong> method, we check which endpoint is being called (<strong class="source-inline">/upload</strong> or<strong class="source-inline">/get</strong>) and respond with the mock response. In the preceding example, any call to the <strong class="source-inline">/upload</strong> endpoint responds with an <strong class="source-inline">OK</strong> status and a string, <strong class="source-inline">123</strong>, representing the ID of the audio file. A call to the <strong class="source-inline">/get</strong> endpoint checks the IDs passed in as a URL parameter. If the ID matches the audiofile ID of <strong class="source-inline">123</strong>, then the mocked client will return a successful response with the audio JSON in the body of the response. If there is a request for any ID other<a id="_idIndexMarker247"/> than <strong class="source-inline">123</strong>, then a status code of 500 is returned with an error message that the ID does <span class="No-Break">not exist.</span></p>
			<p>Now that the mocked client is complete, we fill in success and failure cases for each command, <strong class="source-inline">upload</strong> and <strong class="source-inline">get</strong>, within the <strong class="source-inline">Parse</strong> function’s <span class="No-Break">unit tests:</span></p>
			<pre class="source-code">
func TestParser_Parse(t *testing.T) {
    mockClient := &amp;MockClient{}
    type fields struct {
        commands []interfaces.Command
    }
    type args struct {
        args []string
    }</pre>
			<p>The <strong class="source-inline">tests</strong> variable contains an array of data that contains the name of the test, the fields or commands available, the string arguments potentially passed into the command-line application, and a <strong class="source-inline">wantErr</strong> Boolean value that is set depending on whether we expect an error to be returned in the test or not. Let’s go over <span class="No-Break">each test:</span></p>
			<pre class="source-code">
   tests := []struct {
        name    string
        fields  fields
        args    args
        wantErr bool
    }{</pre>
			<p>The first test, named <strong class="source-inline">upload – failure – does not exist</strong>, simulates the <span class="No-Break">following command:</span></p>
			<pre class="console">
./audiofile-cli upload -filename doesNotExist.mp3</pre>
			<p>The filename, <strong class="source-inline">doesNotExist.mp3</strong>, is a file that does not exist in the root folder. Within the <strong class="source-inline">Run()</strong> method of the <strong class="source-inline">upload</strong> command, the file is opened. This is where the error occurs and the output <a id="_idIndexMarker248"/>is an error message, <strong class="source-inline">file does </strong><span class="No-Break"><strong class="source-inline">not exist</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        {
            name: "upload - failure - does not exist",
            fields: fields{
                commands: []interfaces.Command{
                    NewUploadCommand(mockClient),
                },
            },
            args: args{
                args: []string{"upload", "-filename",
                  "doesNotExist.mp3"},
            },
            wantErr: true, // error = open
              doesNotExist.mp3: no such file or directory
        },</pre>
			<p>The test named <strong class="source-inline">upload – success – uploaded</strong> checks the successful case of a file being uploaded to storage with an audiofile ID being returned in response. In order to get this test to work, there is a <strong class="source-inline">testdata</strong> folder in the <strong class="source-inline">command</strong> package, and within it exists a small audio file to test with, simulating the <span class="No-Break">following command:</span></p>
			<pre class="console">
./audiofile-cli upload -filename testdata/exists.mp3</pre>
			<p>This file is successfully opened and sent to the <strong class="source-inline">/upload</strong> endpoint. The mocked client’s <strong class="source-inline">Do</strong> function sees that the request is to the <strong class="source-inline">/upload</strong> endpoint and sends an <strong class="source-inline">OK</strong> status along with the audiofile ID of <strong class="source-inline">123</strong> within the body of the response and no error. This matches the <strong class="source-inline">wantErr</strong> value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        {
            name: "upload - success - uploaded",
            fields: fields{
                commands: []interfaces.Command{
                    NewUploadCommand(mockClient),
                },
            },
            args: args{
                args: []string{"upload", "-filename", "
                  testdata/exists.mp3"},
            },
            wantErr: false,
        },</pre>
			<p>After uploading, we can now <em class="italic">get</em> the metadata associated with the audiofile. The next test case, <strong class="source-inline">get – failure – id does not exist</strong>, tests a request for an audiofile ID that does not exist. Instead<a id="_idIndexMarker249"/> of passing in <strong class="source-inline">123</strong>, that is, that ID of an audiofile that exists, we pass in an ID that does not exist, simulating the following command via <span class="No-Break">the CLI:</span></p>
			<pre class="console">
./audiofile-cli get -id 567</pre>
			<p><strong class="source-inline">wantErr</strong> is set to <strong class="source-inline">true</strong> and we get the expected error, <strong class="source-inline">audiofile id does not exist</strong>. The response from the <strong class="source-inline">/request</strong> endpoint returns the error message in the body of <span class="No-Break">the response.</span></p>
			<pre class="source-code">
        {
            name: "get - failure - id does not exist",
            fields: fields{
                commands: []interfaces.Command{
                    NewGetCommand(mockClient),
                },
            },
            args: args{
                args: []string{"get", "-id", "567"},
            },
            wantE<a id="_idTextAnchor083"/>rr: true, // error = audiofile id does not
              exist
        },</pre>
			<p>The test named <strong class="source-inline">get – success – requested</strong> checks whether the <strong class="source-inline">get</strong> command was successful in retrieving an ID of an audiofile that exists. The ID passed is <strong class="source-inline">"123"</strong>, and in the mocked client, you <a id="_idIndexMarker250"/>can see that when that specific ID is passed into the request, the API endpoint returns a 200 success code with the body of the <span class="No-Break">audiofile metadata.</span></p>
			<p>This is simulated with the <span class="No-Break">following command:</span></p>
			<pre class="console">
./audiofile-cli get -id 123
        {
            name: "get - success - requested",
            fields: fields{
                commands: []interfaces.Command{
                    NewGetCommand(mockClient),
                },
            },
            args: args{
                args: []string{"get", "-id", "123"},
            },
            wantErr: false,
        },
    }</pre>
			<p>The following code loops through the previously described <strong class="source-inline">tests</strong> array to run each test with the arguments passed<a id="_idIndexMarker251"/> into the command and checks whether the final <strong class="source-inline">wantErr</strong> value matches the <span class="No-Break">expected error:</span></p>
			<pre class="source-code">
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            p := &amp;Parser{
                commands: tt.fields.commands,
            }
            if err := p.Parse(tt.args.args); (err != nil)
              != tt.wantErr {
                t.Errorf("Parser.Parse() error = %v,
                  wantErr %v", err, tt.wantErr)
            }
        })
    }
}</pre>
			<p>To run these tests, from the repository type <span class="No-Break">the following:</span></p>
			<pre class="console">
go test ./cmd/cli/command -v</pre>
			<p>This will execute all the preceding tests and print the <span class="No-Break">following output:</span></p>
			<pre class="console">
--- PASS: TestParser_Parse (0.06s)
    --- PASS: TestParser_Parse/upload_-_failure_-
    _does_not_exist (0.00s)
    --- PASS: TestParser_Parse/upload_-_success_-_uploaded
    (0.06s)
    --- PASS: TestParser_Parse/get_-_failure_-
    _id_does_not_exist (0.00s)
    --- PASS: TestParser_Parse/get_-_success_-_requested
    (0.00s)
PASS
ok      github.com/marianina8/audiofile/cmd/cli/command
(cached)</pre>
			<p>It’s important to test success and failure cases for all the commands. Although this was just a starting example; more test cases could be added. For example, in the previous chapter, we discussed the upload use case in more detail. You could test it with large files that exceed the limit, or whether the file passed into the <strong class="source-inline">upload</strong> command is an audio file. In the state that the current implementation is in, a large file would successfully upload. Since this is not what we want, we can modify the <strong class="source-inline">UploadCommand</strong> <strong class="source-inline">Run</strong> method to check the <a id="_idIndexMarker252"/>size of the file before calling the request to the <strong class="source-inline">/upload</strong> endpoint. However, this is just an example and hopefully gives you an idea of how a CLI can be built alongside an <span class="No-Break">existing API.</span></p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Summary</h1>
			<p>Throughout this chapter, we have gone through an example of building an audio metadata CLI. Going through each of the different components that make up this CLI has helped us to determine how a CLI could be structured and how files are structured, whether as part of an existing code base or as a <span class="No-Break">new CLI.</span></p>
			<p>We learned how to implement the first two main use cases of the CLI, uploading audio and getting audio metadata. The details provided on the structure of the commands gave you an idea of how commands could be built out without the use of any additional parsing packages. You also learned how to implement a use case, test your CLI, and mock a <span class="No-Break">client interface.</span></p>
			<p>While this chapter gave you an idea of how to build a CLI, some commands such as nested subcommands and flag combinations can get complicated. In the next chapter, we’ll discuss how to use some popular frameworks to help parse complicated commands and improve the CLI development process overall. You’ll see how these frameworks can exponentially speed up the development of a <span class="No-Break">new CLI!</span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Questions</h1>
			<ol>
				<li>What are the benefits of using a storage interface? If you were to use a different storage option, how easy would it be to swap out for the current flat file <span class="No-Break">storage implementation?</span></li>
				<li>What’s the difference between an argument and a flag? In the following real-world example, what qualifies as an argument or <span class="No-Break">a flag?</span><pre class="source-code">
./audiofile-cli upload -filename music.mp3</pre></li>
				<li>Suppose you’d like to create an additional test for when a user runs the <strong class="source-inline">get</strong> command without passing in any arguments <span class="No-Break">or flags:</span><pre class="source-code">
./audiofile-cli get</pre></li>
			</ol>
			<p>What would an additional entry to the <strong class="source-inline">tests</strong> array <span class="No-Break">look like?</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>Answers</h1>
			<ol>
				<li value="1">Interfaces benefit us when writing modular code that’s decoupled and reduces dependency across different parts of the code base. Since we have an interface, it’s much easier to swap out the implementation. In the existing code, you’d swap the implementation type in the <strong class="source-inline">Run</strong> method of the <span class="No-Break"><strong class="source-inline">metadata</strong></span><span class="No-Break"> package.</span></li>
				<li>In <span class="No-Break">this example:</span><pre class="source-code">
<strong class="bold"> ./audiofile-cli upload -filename music.mp3</strong></pre></li>
			</ol>
			<p> <strong class="source-inline">upload</strong>, <strong class="source-inline">-filename</strong>, and <strong class="source-inline">music.mp3</strong> are all considered arguments. However, flags are specific arguments that are specifically marked by a specific syntax. In this case, <strong class="source-inline">-filename</strong> is <span class="No-Break">a flag.</span></p>
			<ol>
				<li value="3">An additional test for when a user runs the <strong class="source-inline">get</strong> command without passing in any arguments or flags would look <span class="No-Break">like this:</span><pre class="source-code">
     {
        name: "get - failure - missing required id flag",
        fields: fields{
            commands: cmds,
        },
        args: args{
            args: []string{"get"},
        },
        wantErr: true,
     },</pre></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer028" class="IMG---Figure">
			</div>
		</div>
	</body></html>