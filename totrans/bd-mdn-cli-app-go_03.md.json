["```go\n   |--cmd\n   |----api\n   |----cli\n   |------command\n   |--extractors\n   |----tags\n   |----transcript\n   |--internal\n   |----interfaces\n   |--models\n   |--services\n   |----metadata\n   |--storage\n   |--vendor\n```", "```go\npackage main\nimport (\n    metadataService \"audiofile/services/metadata\"\n    \"flag\"\n    \"fmt\"\n)\nfunc main() {\n    var port int\n    flag.IntVar(&port, \"p\", 8000, \"Port for metadata\n      service\")\n    flag.Parse()\n    fmt.Printf(\"Starting API at http://localhost:%d\\n\",\n      port)\n    metadataService.Run(port)\n}\n```", "```go\n-p=8080\n-p 8080  // this works for non-boolean flags only\n```", "```go\n-p\n```", "```go\naudiofile go run cmd/api/main.go\nStarting API at http://localhost:8000\n```", "```go\npackage main\nimport (\n    \"audiofile/internal/command\"\n    \"audiofile/internal/interfaces\"\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n)\nfunc main() {\n    client := &http.Client{}\n    cmds := []interfaces.Command{\n        command.NewGetCommand(client),\n        command.NewUploadCommand(client),\n        command.NewListCommand(client),\n    }\n    parser := command.NewParser(cmds)\n    if err := parser.Parse(os.Args[1:]); err != nil {\n        os.Stderr.WriteString(fmt.Sprintf(\"error: %v\",\n          err.Error()))\n        os.Exit(1)\n    }\n}\n```", "```go\ncommand.NewGetCommand(client),\ncommand.NewUploadCommand(client),\ncommand.NewListCommand(client),\n```", "```go\nparser := command.NewParser(cmds)\n```", "```go\n ./audiofile-cli upload -filename recording.m4v\n```", "```go\n audiofile-cli\n```", "```go\ntype GetCommand struct {\n    fs *flag.FlagSet\n    client interfaces.Client\n    id string\n}\n```", "```go\n upload –filename recording.m4v\n```", "```go\naudiofile ./audiofile-cli\nusage: ./audiofile-cli <command> [<args>]\nThese are a few Audiofile commands:\n    get      Get metadata for a particular audio file by id\n    list     List all metadata\n    upload   Upload audio file\n```", "```go\npackage command\nimport (\n    \"github.com/marianina8/ audiofile/internal/cli\"\n    \"github.com/marianina8/ audiofile/internal/interfaces\"\n    \"flag\"\n    \"fmt\"\n)\nfunc NewRandomCommand(client interfaces.Client)\n    *RandomCommand {\n    gc := &RandomCommand{\n        fs: flag.NewFlagSet(\"random\",\n           flag.ContinueOnError),\n        client: client,\n    }\n    gc.fs.StringVar(&gc.flag, \"flag\", \"\", \"string flag for\n      random command\")\n    return gc\n}\ntype RandomCommand struct {\n    fs *flag.FlagSet\n    flag string\n}\nfunc (cmd *RandomCommand) Name() string {\n    return cmd.fs.Name()\n}\nfunc (cmd *RandomCommand) ParseFlags(flags []string) error {\n    return cmd.fs.Parse(flags)\n}\nfunc (cmd *RandomCommand) Run() error {\n    fmt.Println(rand.Intn(100))\n    return nil\n}\n```", "```go\npackage command\nimport (\n    \"github.com/marianina8/audiofile/internal/interfaces\"\n    \"fmt\"\n)\ntype Parser struct {\n    commands []interfaces.Command\n}\nfunc NewParser(commands []interfaces.Command) *Parser {\n    return &Parser{commands: commands}\n}\nfunc (p *Parser) Parse(args []string) error {\n    if len(args) < 1 {\n        help()\n        return nil\n    }\n    subcommand := args[0]\n    for _, cmd := range p.commands {\n        if cmd.Name() == subcommand {\n            cmd.ParseFlags(args[1:])\n            return cmd.Run()\n        }\n    }\n    return fmt.Errorf(\"Unknown subcommand: %s\", subcommand)\n}\n```", "```go\nfunc help() {\n    help := `usage: ./audiofile-cli <command> [<flags>]\nThese are a few Audiofile commands:\n    get      Get metadata for a particular audio file by id\n    list     List all metadata\n    upload   Upload audio file\n    `\n    fmt.Println(help)\n}\n```", "```go\npackage interfaces\nimport (\n    \"audiofile/models\"\n)\ntype Storage interface {\n    Upload(bytes []byte, filename string) (string, string,\n      error)\n    SaveMetadata(audio *models.Audio) error\n    List() ([]*models.Audio, error)\n    GetByID(id string) (*models.Audio, error)\n    Delete(id string, tag string) error\n}\n```", "```go\ntype Command interface {\n   ParseFlags([]string) error\n   Run() error\n   Name() string\n}\n```", "```go\ntype Audio struct {\n    Id       string\n    Path     string\n    Metadata Metadata\n    Status   string\n    Error    []error\n}\n```", "```go\ntype Metadata struct {\n    Tags         Tags         `json:\"tags\"`\n    Transcript   string       `json:\"transcript\"`\n}\n```", "```go\ntype MetadataService struct {\n    Server *http.Server\n    Storage interfaces.Storage\n}\n```", "```go\nfunc CreateMetadataService(port int, storage\n   interfaces.Storage) *MetadataService {\n    mux := http.NewServeMux()\n    metadataService := &MetadataService{\n        Server: &http.Server{\n            Addr:    fmt.Sprintf(\":%v\", port),\n            Handler: mux,\n        },\n        Storage: storage,\n    }\n    mux.HandleFunc(\"/upload\",\n      metadataService.uploadHandler)\n    mux.HandleFunc(\"/request\",\n      metadataService.getByIDHandler)\n    mux.HandleFunc(\"/list\", metadataService.listHandler)\n    return metadataService\n}\n```", "```go\nfunc Run(port int) {\n    flatfileStorage := storage.FlatFile{}\n    service:= CreateMetadataService(port, flatfileStorage)\n    err := service.Server.ListenAndServe()\n    if err != nil {\n        fmt.Println(\"error starting api: \", err)\n    }\n}\n```", "```go\n./audiofile-cli upload -filename <filepath>\n```", "```go\npackage command\nimport (\n    \"github.com/marianina8/audiofile/internal/interfaces\"\n    \"bytes\"\n    \"flag\"\n    \"fmt\"\n    \"io\"\n    \"io\"\n    \"mime/multipart\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n)\nfunc NewUploadCommand(client interfaces.Client)\n    *UploadCommand {\n    gc := &UploadCommand{\n        fs:     flag.NewFlagSet(\"upload\",\n                  flag.ContinueOnError),\n        client: client,\n    }\n    gc.fs.StringVar(&gc.filename, \"filename\", \"\", \"full\n      path of filename to be uploaded\")\n    return gc\n}\ntype UploadCommand struct {\n    fs       *flag.FlagSet\n    client   interfaces.Client\n    filename string\n}\nfunc (cmd *UploadCommand) Name() string {\n    return cmd.fs.Name()\n}\nfunc (cmd *UploadCommand) ParseFlags(flags []string)\n  error {\n    if len(flags) == 0 {\n        fmt.Println(\"usage: ./audiofile-cli\n          upload -filename <filename>\")\n        return fmt.Errorf(\"missing flags\")\n    }\n    return cmd.fs.Parse(flags)\n}\nfunc (cmd *UploadCommand) Run() error {\n    // implementation for upload command\n    return nil\n}\n```", "```go\nflag.NewFlagSet(\"upload\", flag.ContinueOnError)\n```", "```go\ncurl --location --request POST 'http://localhost/upload' \\\n--form 'file=@\"recording.mp3\"'\n8a6dc954-d6df-4fc0-882e-14eb1581d968%\n```", "```go\nfunc (cmd *UploadCommand) Run() error {\n    if cmd.filename == \"\" {\n        return fmt.Errorf(\"missing filename\")\n    }\n    fmt.Println(\"Uploading\", cmd.filename, \"...\")\n    url := \"http://localhost/upload\"\n    method := \"POST\"\n    payload := &bytes.Buffer{}\n    multipartWriter := multipart.NewWriter(payload)\n    file, err := os.Open(cmd.filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n    partWriter, err := multipartWriter\n      .CreateFormFile(\"file\", filepath.Base(cmd.filename))\n    if err != nil {\n        return err\n    }\n    _, err = io.Copy(partWriter, file)\n    if err != nil {\n        return err\n    }\n    err = multipartWriter.Close()\n    if err != nil {\n        return err\n    }\n    client := cmd.client\n    req, err := http.NewRequest(method, url, payload)\n    if err != nil {\n        return err\n    }\n    req.Header.Set(\"Content-Type\",\n      multipartWriter.FormDataContentType())\n    res, err := client.Do(req)\n    if err != nil {\n        return err\n    }\n    defer res.Body.Close()\n    body, err := io.ReadAll(res.Body)\n    if err != nil {\n        return err\n    }\n    fmt.Println(\"Audiofile ID: \", string(body))\n    return err\n}\n```", "```go\n./audiofile-cli get -id <ID>\n```", "```go\npackage command\nimport (\n    \"github.com/marianina8/audiofile/internal/interfaces\"\n    \"bytes\"\n    \"flag\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"net/url\"\n)\nfunc NewGetCommand(client interfaces.Client) *GetCommand {\n    gc := &GetCommand{\n        fs:     flag.NewFlagSet(\"get\",\n                  flag.ContinueOnError),\n        client: client,\n    }\n    gc.fs.StringVar(&gc.id, \"id\", \"\", \"id of audiofile\n      requested\")\n    return gc\n}\ntype GetCommand struct {\n    fs     *flag.FlagSet\n    client interfaces.Client\n    id     string\n}\nfunc (cmd *GetCommand) Name() string {\n    return cmd.fs.Name()\n}\nfunc (cmd *GetCommand) ParseFlags(flags []string) error {\n    if len(flags) == 0 {\n        fmt.Println(\"usage: ./audiofile-cli get -id <id>\")\n        return fmt.Errorf(\"missing flags\")\n    }\n    return cmd.fs.Parse(flags)\n}\nfunc (cmd *GetCommand) Run() error {\n    // implement get command\n    return nil\n}\n```", "```go\ncurl --location --request GET\n'http://localhost/request?id=270c3952-0b48-4122-bf2a-\n e4a005303ecb'\n{audiofile metadata in JSON format}\n```", "```go\nfunc (cmd *GetCommand) Run() error {\n    if cmd.id == \"\" {\n        return fmt.Errorf(\"missing id\")\n    }\n    params := \"id=\" + url.QueryEscape(cmd.id)\n    path := fmt.Sprintf(\"http://localhost/request?%s\",\n      params)\n    payload := &bytes.Buffer{}\n    method := \"GET\"\n    client := cmd.client\n    req, err := http.NewRequest(method, path, payload)\n    if err != nil {\n        return err\n    }\n    resp, err := client.Do(req)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n    b, err := io.ReadAll(resp.Body)\n    if err != nil {\n        fmt.Println(\"error reading response: \",\n          err.Error())\n        return err\n    }\n    fmt.Println(string(b))\n    return nil\n}\n```", "```go\ngo build -o audiofile-cli cmd/cli/main.go\n```", "```go\n./audiofile-cli upload -filename audio/beatdoctor.mp3\n```", "```go\nUploading audio/beatdoctor.mp3 ...\nAudiofile ID:  8a6a8942-161e-4b10-bf59-9d21785c9bd9\n```", "```go\n./audiofile-cli get -id=8a6a8942-161e-4b10-bf59-\n9d21785c9bd9\n```", "```go\n{\n    \"Id\": \"8a6a8942-161e-4b10-bf59-9d21785c9bd9\",\n    \"Path\": \"/Users/marian/audiofile/8a6a8942-161e-4b10-\n    bf59-9d21785c9bd9/beatdoctor.mp3\",\n    \"Metadata\": {\n        \"tags\": {\n            \"title\": \"Shot In The Dark\",\n            \"album\": \"Best Bytes Volume 4\",\n            \"artist\": \"Beat Doctor\",\n            \"album_artist\": \"Toucan Music (Various\n              Artists)\",\n            \"genre\": \"Electro House\",\n            \"comment\": \"URL: http://freemusicarchive.org/\n            music/Beat_Doctor/Best_Bytes_Volume_4/\n            09_beat_doctor_shot_in_the_dark\\r\\nComments:\n            http://freemusicarchive.org/\\r\\nCurator: Toucan\n            Music\\r\\nCopyright: Attribution-NonCommercial\n            3.0 International: http://creativecommons.org/\n            licenses/by-nc/3.0/\"\n        },\n        \"transcript\": \"This is Sharon.\"\n    },\n    \"Status\": \"Complete\",\n    \"Error\": null\n}\n```", "```go\nfunc TestParser_Parse(t *testing.T) {\n    type fields struct {\n        commands []interfaces.Command\n    }\n    type args struct {\n        args []string\n    }\n    tests := []struct {\n        name    string\n        fields  fields\n        args    args\n        wantErr bool\n    }{\n        // TODO: Add test cases.\n    }\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            p := &Parser{\n                commands: tt.fields.commands,\n            }\n            if err := p.Parse(tt.args.args); (err != nil)\n              != tt.wantErr {\n                t.Errorf(\"Parser.Parse() error = %v,\n                  wantErr %v\", err, tt.wantErr)\n            }\n        })\n    }\n}\n```", "```go\ntype MockClient struct {\n    DoFunc func(req *http.Request) (*http.Response, error)\n}\nfunc (m *MockClient) Do(req *http.Request) (*http.Response,\n    error) {\n    if strings.Contains(req.URL.String(), \"/upload\") {\n        return &http.Response{\n            StatusCode: 200,\n            Body:       io.NopCloser\n              (strings.NewReader(\"123\")),\n        }, nil\n    }\n    if strings.Contains(req.URL.String(), \"/request\") {\n        value, ok := req.URL.Query()[\"id\"]\n        if !ok || len(value[0]) < 1 {\n             return &http.Response{\n    StatusCode: 500,\n    Body: io.NopCloser(strings.NewReader(\"url param 'id' is \n    missing\")),\n    }, fmt.Errorf(\"url param 'id' is missing\")\n        }\n        if value[0] != \"123\" {\n            return &http.Response{\n                StatusCode: 500,\n                Body:       io.NopCloser\n               (strings.NewReader(\"audiofile id does not\n                 exist\")),\n            }, fmt.Errorf(\"audiofile id does not exist\")\n        }\n        file, err := os.ReadFile(\"testdata/audio.json\")\n        if err != nil {\n            return nil, err\n        }\n        return &http.Response{\n            StatusCode: 200,\n            Body:       io.NopCloser\n              (strings.NewReader(string(file))),\n        }, nil\n    }\n    return nil, nil\n}\n```", "```go\nfunc TestParser_Parse(t *testing.T) {\n    mockClient := &MockClient{}\n    type fields struct {\n        commands []interfaces.Command\n    }\n    type args struct {\n        args []string\n    }\n```", "```go\n   tests := []struct {\n        name    string\n        fields  fields\n        args    args\n        wantErr bool\n    }{\n```", "```go\n./audiofile-cli upload -filename doesNotExist.mp3\n```", "```go\n        {\n            name: \"upload - failure - does not exist\",\n            fields: fields{\n                commands: []interfaces.Command{\n                    NewUploadCommand(mockClient),\n                },\n            },\n            args: args{\n                args: []string{\"upload\", \"-filename\",\n                  \"doesNotExist.mp3\"},\n            },\n            wantErr: true, // error = open\n              doesNotExist.mp3: no such file or directory\n        },\n```", "```go\n./audiofile-cli upload -filename testdata/exists.mp3\n```", "```go\n        {\n            name: \"upload - success - uploaded\",\n            fields: fields{\n                commands: []interfaces.Command{\n                    NewUploadCommand(mockClient),\n                },\n            },\n            args: args{\n                args: []string{\"upload\", \"-filename\", \"\n                  testdata/exists.mp3\"},\n            },\n            wantErr: false,\n        },\n```", "```go\n./audiofile-cli get -id 567\n```", "```go\n        {\n            name: \"get - failure - id does not exist\",\n            fields: fields{\n                commands: []interfaces.Command{\n                    NewGetCommand(mockClient),\n                },\n            },\n            args: args{\n                args: []string{\"get\", \"-id\", \"567\"},\n            },\n            wantErr: true, // error = audiofile id does not\n              exist\n        },\n```", "```go\n./audiofile-cli get -id 123\n        {\n            name: \"get - success - requested\",\n            fields: fields{\n                commands: []interfaces.Command{\n                    NewGetCommand(mockClient),\n                },\n            },\n            args: args{\n                args: []string{\"get\", \"-id\", \"123\"},\n            },\n            wantErr: false,\n        },\n    }\n```", "```go\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            p := &Parser{\n                commands: tt.fields.commands,\n            }\n            if err := p.Parse(tt.args.args); (err != nil)\n              != tt.wantErr {\n                t.Errorf(\"Parser.Parse() error = %v,\n                  wantErr %v\", err, tt.wantErr)\n            }\n        })\n    }\n}\n```", "```go\ngo test ./cmd/cli/command -v\n```", "```go\n--- PASS: TestParser_Parse (0.06s)\n    --- PASS: TestParser_Parse/upload_-_failure_-\n    _does_not_exist (0.00s)\n    --- PASS: TestParser_Parse/upload_-_success_-_uploaded\n    (0.06s)\n    --- PASS: TestParser_Parse/get_-_failure_-\n    _id_does_not_exist (0.00s)\n    --- PASS: TestParser_Parse/get_-_success_-_requested\n    (0.00s)\nPASS\nok      github.com/marianina8/audiofile/cmd/cli/command\n(cached)\n```", "```go\n    ./audiofile-cli upload -filename music.mp3\n    ```", "```go\n    ./audiofile-cli get\n    ```", "```go\n     ./audiofile-cli upload -filename music.mp3\n    ```", "```go\n         {\n            name: \"get - failure - missing required id flag\",\n            fields: fields{\n                commands: cmds,\n            },\n            args: args{\n                args: []string{\"get\"},\n            },\n            wantErr: true,\n         },\n    ```"]