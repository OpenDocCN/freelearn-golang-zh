- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Building an Audio Metadata CLI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建音频元数据 CLI
- en: '*Hands-on learning* is one of the best ways to learn. So, in this chapter,
    we will build out a few of our example audio metadata CLI use cases from start
    to finish. The code is available online and can be explored alongside this chapter
    or independently. Forking the GitHub repo and playing around with the code, adding
    in new use cases and tests, are encouraged as these are excellent ways to learn
    before diving into some of the ways to refine your CLI in the following chapters.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*动手学习* 是最好的学习方法之一。因此，在本章中，我们将从头到尾构建一些示例音频元数据 CLI 用例。代码可在网上找到，可以与本章一起或独立探索。鼓励你分叉
    GitHub 仓库并玩弄代码，添加新的用例和测试，因为这些是在下一章深入探讨如何改进 CLI 之前学习的好方法。'
- en: 'Although this example covered in this chapter is not built on an empty code
    base – it is built on top of an existing REST API – it’s worth noting that the
    implementation of commands does not necessarily rely on an API. This is only an
    example and it’s encouraged that you use your imagination in this chapter on how
    commands could be implemented if not relying on an API. This chapter will give
    you an experimental code base and you’ll learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章中的示例并非基于空代码库构建——它是基于现有的 REST API 构建的——但值得注意的是，命令的实现并不一定依赖于 API。这只是一个示例，并鼓励你在本章中发挥想象力，思考如果不依赖
    API，命令应该如何实现。本章将提供一个实验性的代码库，你将学习以下主题：
- en: Defining the components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义组件
- en: Implementing use cases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现用例
- en: Testing and mocking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和模拟
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Download the following code to follow along:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下载以下代码以进行跟随：
- en: '[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter03/audiofile](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter03/audiofile)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter03/audiofile](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter03/audiofile)'
- en: Install the latest version of VS Code with the latest Go tools.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安装最新版本的 VS Code 并带有最新的 Go 工具。
- en: Defining the components
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义组件
- en: 'The following is the folder structure for our audio metadata CLI. The main
    folders in this structure were described in the last chapter. Here, we will go
    into further detail on what each folder contains, and the files and code that
    exist within them, in order from top to bottom:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们音频元数据 CLI 的文件夹结构。在上一个章节中描述了该结构中的主要文件夹。在这里，我们将进一步详细说明每个文件夹包含的内容，以及从上到下存在的文件和代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: cmd/
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cmd/
- en: As previously mentioned in [*Chapter 2*](B18883_02.xhtml#_idTextAnchor036),
    *Structuring Go Code for CLI Applications* in the *Commonly used program layouts
    for robust applications* section, the `cmd` folder is the main entry point for
    the different applications of the project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在[*第 2 章*](B18883_02.xhtml#_idTextAnchor036)的“*为 CLI 应用程序结构化 Go 代码*”部分中，在“*常用程序布局以构建健壮应用程序*”一节中，`cmd`
    文件夹是项目不同应用程序的主要入口点。
- en: cmd/api/
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cmd/api/
- en: 'The `main.go` file, which in found in the `cmd/api/` folder, will start to
    run the audio metadata API locally on the machine. It takes in a port number as
    an optional flag, defaulting to `8000`, and passes the port number into a `Run`
    method within the `services` method that starts the metadata service:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 位于 `cmd/api/` 文件夹中的 `main.go` 文件将开始在本地机器上运行音频元数据 API。它接受一个可选的端口号标志，默认为 `8000`，并将端口号传递到
    `services` 方法中的 `Run` 方法，以启动元数据服务：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We make use of the `flag` package, which implements simple command-line flag
    parsing. There are different flag types that can be defined, such as `String`,
    `Bool`, and `Int`. In the preceding example, a `-p` flag is defined to override
    the default port of `8000`. `flag.Parse()` is called after all the flags are defined
    to parse the line into defined flags. There are a few syntactical methods allowed
    for passing flags to the command using Go’s `flag` package. The value `8080` will
    be parsed either way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `flag` 包，该包实现了简单的命令行标志解析。可以定义不同的标志类型，例如 `String`、`Bool` 和 `Int`。在先前的示例中，定义了一个
    `-p` 标志来覆盖默认端口 `8000`。在定义所有标志之后调用 `flag.Parse()` 来解析行到定义的标志。使用 Go 的 `flag` 包允许通过几种语法方法将标志传递给命令。无论哪种方式，`8080`
    的值都将被解析：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sometimes, a flag does not require an argument and is enough on its own for
    the code to know exactly what to do:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个标志不需要参数，仅凭它本身就足以让代码知道确切要做什么：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Action can be taken on the flag that’s passed in, but the variable will contain
    the default value, `8000`, when defined.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对传递的标志采取行动，但变量将在定义时包含默认值`8000`。
- en: 'To start the API from the project’s root directory, run `go run cmd/api/main.go`
    and you will see the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要从项目的根目录启动API，请运行`go run cmd/api/main.go`，你将看到以下输出：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: cmd/cli/
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cmd/cli/
- en: 'This `main.go` file, in the `cmd/cli/` folder, runs the CLI, and like many
    other CLIs, this one will utilize the API by making calls to it. Since the API
    will need to be running for the CLI to work, run the API first in a separate terminal
    or in the background. The `cmd/cli/main.go` file contains the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cmd/cli/`文件夹中的这个`main.go`文件运行CLI，像许多其他CLI一样，这个CLI将通过调用它来利用API。由于CLI需要API运行才能工作，因此请在单独的终端或后台首先运行API。`cmd/cli/main.go`文件包含以下代码：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Within the `main.go` file, the commands are added to a slice of interface `Command`
    type. Each command is defined and added:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.go`文件中，命令被添加到`interface`类型的`Command`切片中。每个命令被定义并添加：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each command takes the `client` variable, a default `http.Client` as a parameter
    to use to make HTTP requests to the audio metadata API endpoints. Passing in the
    `client` command allows it to be easily mocked for testing, which we will discuss
    in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令都接受一个`client`变量，一个默认的`http.Client`，作为参数来使用，以便向音频元数据API端点发送HTTP请求。传递`client`命令允许它轻松地进行模拟测试，我们将在下一节中讨论。
- en: 'The commands are then passed into a `NewParser` method, which creates a pointer
    to `command.Parser`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将命令传递给`NewParser`方法，该方法创建一个指向`command.Parser`的指针：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This `Parse` function receives all arguments after the application name via
    the `os.Args[1:]` parameter value. For example, say the command line is called
    as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Parse`函数通过`os.Args[1:]`参数值接收应用程序名称之后的全部参数。例如，假设命令行如下调用：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, the first argument, `os.Args[0]`, returns the following value:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第一个参数`os.Args[0]`返回以下值：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To explain this further, let’s look at the `Command` struct and the fields
    present within it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步解释，让我们看看`Command`结构体及其中的字段：
- en: '![Figure 3.1 – Command struct and flag.FlagSet entities](img/Figure_3.01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 命令结构体和flag.FlagSet实体](img/Figure_3.01.jpg)'
- en: Figure 3.1 – Command struct and flag.FlagSet entities
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 命令结构体和flag.FlagSet实体
- en: 'Let us look at the `GetCommand` struct depicted in the figure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看图中所示的`GetCommand`结构体：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each of the commands has a flag set, which contains a name for the command and
    error handling, a client, and an ID.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令都有一个标志集，其中包含命令的名称、错误处理、客户端和ID。
- en: The arguments to a Go program are stored in the `os.Args` slice, which is a
    collection of strings. The name of the executable being run is stored in the first
    element of the `os.Args` slice (i.e., `os.Args[0]`), while the arguments passed
    to the executable are stored in the subsequent elements (`os.Args[1:]`).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序的参数存储在`os.Args`切片中，它是一组字符串的集合。正在运行的可执行文件名称存储在`os.Args`切片的第一个元素中（即`os.Args[0]`），而传递给可执行文件的参数存储在后续元素中（`os.Args[1:]`）。
- en: When you see the code, `parser.Parse(os.Args[1:])`, it means you’re passing
    the remainder of the command-line arguments to `parse.Parse` function, skipping
    the first argument (the name of the program). All the arguments on the command
    line, besides the program’s name, will be passed to the function in this case.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到代码`parser.Parse(os.Args[1:])`时，这意味着你正在将命令行参数的其余部分传递给`parse.Parse`函数，跳过了第一个参数（程序名称）。在这种情况下，除了程序名称之外的所有命令行参数都将传递给该函数。
- en: 'That means when we pass in `os.Args[1:]`, we are passing into `parse.Parse`
    all the arguments after the program name:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们传递`os.Args[1:]`时，我们正在将程序名称之后的全部参数传递给`parse.Parse`：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Parse takes `args`, a string list, and returns an `error` type. The function
    converts command-line parameters into executable commands.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parse`函数接收一个字符串列表`args`，并返回一个`error`类型。该函数将命令行参数转换为可执行命令。'
- en: 'Let’s walk through the code alongside the following flow chart:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们结合以下流程图来逐步分析代码：
- en: It checks for less than 1 args. If so, `help()` returns n`il.`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查参数是否少于1个。如果是这样，`help()`返回`nil`。
- en: '`Args[0]` is assigned to subcommand if the slice has at least one item. This
    shows the user’s command.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果切片中至少有一个项目，则`Args[0]`被分配给子命令。这显示了用户的命令。
- en: The function then cycles over the `Parser` struct’s `p.commands` property. It
    checks each command’s name (obtained by executing the `Name()` method) against
    the `subcommand` variable.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数随后遍历`Parser`结构体的`p.commands`属性。它通过执行`Name()`方法来检查每个命令的名称，并与`subcommand`变量进行比较。
- en: The function executes the command’s `ParseFlags` method with the rest of the
    `args` slice if a match is found (`args[1:]`). Finally, the function runs the
    command and returns the result.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到匹配项，则函数使用`args[1:]`的其余`args`切片执行命令的`ParseFlags`方法。最后，函数运行命令并返回结果。
- en: If no match is found, the method returns an unknown subcommand error message
    using the `fmt.Errorf` function.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有找到匹配项，则方法使用`fmt.Errorf`函数返回一个未知子命令错误信息。
- en: Essentially, the code finds and executes a command from command line arguments.
    Then, the matching command is run.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，代码从命令行参数中查找并执行一个命令。然后，运行匹配的命令。
- en: '![Figure 3.2 – Flow diagram for the Parse method](img/Figure_3.02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 解析方法的流程图](img/Figure_3.02.jpg)'
- en: Figure 3.2 – Flow diagram for the Parse method
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 解析方法的流程图
- en: A command exists for each API endpoint. For example, `UploadCommand` will call
    the `/upload` endpoint, `ListCommand` will call the `/list` endpoint, and `GetCommand`
    will call the `/get` endpoint of the REST API.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个API端点都存在一个命令。例如，`UploadCommand`将调用`/upload`端点，`ListCommand`将调用`/list`端点，而`GetCommand`将调用REST
    API的`/get`端点。
- en: 'Within the `Parse` method, the length of `args` is checked. If no arguments
    are passed, then help is printed and the program returns `nil`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Parse`方法中，检查`args`的长度。如果没有传递任何参数，则打印帮助信息，程序返回`nil`：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: cmd/cli/command
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cmd/cli/command
- en: 'In the `cmd/cli/command` folder, there are commands to match each of the audiofile
    API endpoints. In the next section, we will code the `upload`, `list`, and `get`
    commands to implement a couple of the use cases described in the previous chapter.
    Rather than defining the code for one of these commands here, I’ll provide a structure
    used to define a random command that satisfies the `Command` interface:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cmd/cli/command`文件夹中，有与每个audiofile API端点匹配的命令。在下一节中，我们将编写`upload`、`list`和`get`命令以实现上一章中描述的几个用例。而不是在这里定义这些命令中的任何一个的代码，我将提供一个用于定义满足`Command`接口的随机命令的结构：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `upload`, `get`, and `list` commands follow the same structure, but the
    implementation of the constructor and `Run` methods differ.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`upload`、`get`和`list`命令遵循相同的结构，但构造函数和`Run`方法的实现不同。'
- en: 'Also, in the `cmd/cli/command` folder, there is a parser of the struct type
    with a method to parse the arguments, match them with the commands, and parse
    any flags found after the subcommand. The `NewParser` function creates a new instance
    of the `Parser` struct. It takes a slice of type `[]interfaces.Command` as input
    and returns a pointer to a `Parser` struct. This initialization method provides
    an easy way to set up the struct with a set of desired commands. The following
    is the code inside `parser.go`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`cmd/cli/command`文件夹中，还有一个结构类型的解析器，它具有解析参数、将它们与命令匹配以及解析子命令之后找到的任何标志的方法。`NewParser`函数创建一个`Parser`结构的新实例。它接受一个类型为`[]interfaces.Command`的切片作为输入，并返回一个指向`Parser`结构的指针。此初始化方法提供了一种轻松设置具有一组所需命令的结构的方法。以下是在`parser.go`文件内的代码：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code checks the number of arguments passed to the `Parse` method. If the
    number of arguments is less than 1, a `help` function from a separate `help.go`
    file is called to print the help text to guide the user on proper usage:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查传递给`Parse`方法的参数数量。如果参数数量少于1，则调用来自单独的`help.go`文件的`help`函数以打印帮助文本，指导用户正确使用：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: extractors/
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: extractors/
- en: This folder contains implementations for the different extractors of audio metadata.
    In this case, subfolders exist for the `tags` and `transcript` implementations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹包含不同音频元数据的提取器实现。在这种情况下，存在用于`tags`和`transcript`实现的子文件夹。
- en: extractors/tags
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: extractors/tags
- en: The `tags` package is implemented within the `extractors/tags` folder. Tags
    metadata may include title, album, artists, composer, genre, release year, lyrics,
    and any additional comments. The code is available within the GitHub repository
    and utilizes the `github.com/dhowden/tag` Go package.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags`包在`extractors/tags`文件夹中实现。标签元数据可能包括标题、专辑、艺术家、作曲家、流派、发行年份、歌词以及任何附加注释。代码可在GitHub仓库中找到，并使用`github.com/dhowden/tag`
    Go包。'
- en: extractors/transcript
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: extractors/transcript
- en: The `transcript` package is implemented within the `extractors/transcript` folder.
    Like the other extraction package, the code can be found in the GitHub repository.
    However, transcript analysis is handled by AssemblyAI, a third-party API, and
    requires an API key, which can be set locally to `ASSEMBLY_API_KEY`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`transcript`包在`extractors/transcript`文件夹中实现。与其他提取包一样，代码可以在GitHub仓库中找到。然而，转录分析由第三方API
    AssemblyAI处理，需要API密钥，该密钥可以设置为本地的`ASSEMBLY_API_KEY`。'
- en: internal/interfaces
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: internal/interfaces
- en: 'The `internal/interfaces` folder holds interfaces utilized by the application.
    It includes both the `Command` and `Storage` interfaces. Interfaces provide a
    way for developers to create multiple types that meet the same interface specifications
    allowing flexibility and modularity in the design of the application. The `storage.go`
    file defines the storage interface:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`internal/interfaces`文件夹包含应用程序使用的接口。它包括`Command`和`Storage`接口。接口为开发者提供了一种创建满足相同接口规范的多种类型的方式，这允许在应用程序的设计中具有灵活性和模块化。`storage.go`文件定义了存储接口：'
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding interface satisfies all possible use cases. Specific implementations
    can be defined in the `storage` folder. If you choose to define the storage type
    within a configuration, you can easily swap out implementations and switch from
    one storage type to another. In this example, we define flat file storage with
    an implementation of each method to satisfy the interface.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的接口满足所有可能的用例。具体的实现可以在`storage`文件夹中定义。如果你选择在配置中定义存储类型，你可以轻松地更换实现，并从一种存储类型切换到另一种。在这个例子中，我们定义了平面文件存储，并为每个方法实现了一个实现来满足接口。
- en: 'First utilized in the `cmd/cli/main.go` file, the `Command` interface is defined
    by the following code in `internal/interfaces/command.go`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首次在`cmd/cli/main.go`文件中使用，`Command`接口在`internal/interfaces/command.go`文件中通过以下代码定义：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how each of the commands in the `cmd/cli/command/` folder implements
    the preceding interface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`cmd/cli/command/`文件夹中的每个命令是如何实现前面提到的接口的。
- en: models/
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: models/
- en: 'The `models` folder contains a structs shared across the different applications.
    The first struct defined for the `audiofile` application is `Audio`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`models`文件夹包含在不同应用程序之间共享的结构。为`audiofile`应用程序定义的第一个结构是`Audio`：'
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Id` variable contains the unique `Audio` file. The path the stored local
    copy of the audio file. The `Metadata` variable contains the data extracted from
    the audio file. In the following example, tags and speech-to-text transcript data
    are being stored:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Id`变量包含唯一的`Audio`文件。该路径存储了音频文件的本地副本。`Metadata`变量包含从音频文件中提取的数据。在以下示例中，存储了标签和语音到文本的转录数据：'
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It’s not necessary to know the struct for each extraction type. The most important
    thing is the main entity type, `Audio`, and its value field, `Metadata`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不必了解每种提取类型的结构。最重要的是主要实体类型`Audio`及其值字段`Metadata`。
- en: services/metadata
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: services/metadata
- en: 'Although multiple services could be implemented in the `services` folder, we’re
    currently only utilizing one API service, the audio metadata service. The only
    method that exists in the `metadata.go` file is the `CreateMetadataServer` method,
    which is called in the `metadata` package, and the `Run` method, which is called
    from the `cmd/api/main.go` file. This file also contains the struct for `MetadataService`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以在`services`文件夹中实现多个服务，但我们目前只使用了一个API服务，即音频元数据服务。`metadata.go`文件中只存在一个方法，即`CreateMetadataServer`方法，它在`metadata`包中被调用，以及`Run`方法，它在`cmd/api/main.go`文件中被调用。此文件还包含了`MetadataService`的结构：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`CreateMetadataService` takes an argument, a port of the `int` type, to define
    the server’s port running on localhost. It also takes an argument, `storage`,
    which is an implementation of the `Storage` interface. The handlers that declare
    each endpoint of the API server are also defined. This function returns a pointer
    to `MetadataService`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateMetadataService`接受一个参数，即`int`类型的端口，用于定义在本地主机上运行的服务器端口。它还接受一个参数`storage`，它是`Storage`接口的一个实现。声明API服务器每个端点的处理程序也被定义。此函数返回`MetadataService`的指针：'
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Run` method, which takes an argument, `port`, defined by the value of
    the `p` flag or the default value of `8000`, calls the `CreateMetadataService`
    method and initiates running the server by calling the `ListenAndServer` method
    on the server. Any error with starting the API will be returned immediately:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run`方法接受一个参数`port`，该参数由`p`标志的值或默认值`8000`定义，调用`CreateMetadataService`方法，并通过在服务器上调用`ListenAndServer`方法来启动服务器。启动API时出现的任何错误将立即返回：'
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Implementations of each of the handlers will be discussed in the next section
    when handling a few use cases.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理器的实现将在下一节中讨论，当处理一些用例时。
- en: storage/
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: storage/
- en: In the `storage` folder, there is the `flatfile.go` file, which implements a
    method of storing metadata locally to a flat file organized via ID on the local
    disk. The code implementation of this will not be discussed in this book because
    it goes beyond the scope of focus on the CLI. However, you can view the code in
    the GitHub repository.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`storage`文件夹中，有`flatfile.go`文件，它实现了一种将元数据本地存储到本地磁盘上按ID组织的平面文件的方法。由于这超出了CLI关注的范围，本书将不讨论代码实现。然而，你可以在GitHub仓库中查看代码。
- en: vendor/
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: vendor/
- en: The `vendor` directory holds all direct and indirect dependencies.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`vendor`目录包含所有直接和间接依赖。'
- en: Implementing use cases
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现用例
- en: 'Remember the use cases defined in the previous chapter? Let’s try to implement
    a couple of them:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 记得上一章中定义的用例吗？让我们尝试实现其中的一些：
- en: UC-01 Upload audio
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UC-01 上传音频
- en: UC-02 Request metadata
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UC-02 请求元数据
- en: Uploading audio
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传音频
- en: In this use case, an authenticated user uploads an audio file by giving the
    location of the file on their device for the purpose of extracting its metadata.
    Under the hood, the upload process will save a local copy and run the metadata
    extraction process on the audio file. A unique ID for the audio file is returned
    immediately.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本用例中，经过身份验证的用户通过提供设备上文件的存储位置来上传音频文件，目的是提取其元数据。在底层，上传过程将保存本地副本并在音频文件上运行元数据提取过程。立即返回音频文件的唯一ID。
- en: 'Before we begin to implement this use case, let’s consider what the command
    for uploading may look like. Suppose we’ve settled on the following final command
    structure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现此用例之前，让我们考虑一下上传命令可能的样子。假设我们已经确定了以下最终的命令结构：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since `/cmd/cli/main.go` is already defined, we’ll just need to make sure that
    the `upload` command exists and satisfies the `command` interface, with the `ParseFlags`,
    `Run`, and `Name` methods. In the `internal/command` folder, we define the `upload`
    command in the `upload.go` file within the `command` package:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`/cmd/cli/main.go`已经定义，我们只需确保`upload`命令存在并满足`command`接口，包括`ParseFlags`、`Run`和`Name`方法。在`internal/command`文件夹中，我们在`command`包内的`upload.go`文件中定义了`upload`命令：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `NewUploadCommand` method implements our desired command structure by defining
    a new flag set for the `upload` command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewUploadCommand`方法通过为`upload`命令定义一个新的标志集来实现我们期望的命令结构：'
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This method call passes the string, `upload`, into the method’s `name` parameter
    and flag. `ContinueOnError` in the `flag.ErrorHandling` parameter defines how
    the application should react if an error occurs when parsing the flag. The different,
    and mostly self-explanatory, options for handling errors upon parsing include
    the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用将字符串`upload`传递到方法的`name`参数和标志。`flag.ErrorHandling`参数中的`ContinueOnError`定义了如果解析标志时发生错误，应用程序应该如何反应。处理解析错误的不同选项，大多数都是自我解释的，包括以下内容：
- en: '`flag.ContinueOnError`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flag.ContinueOnError`'
- en: '`flag.ExitOnError`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flag.ExitOnError`'
- en: '`flag.PanicOnError`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flag.PanicOnError`'
- en: Now that we’ve defined and added the `upload` command, we can test it out. Upon
    testing, you’ll see that the `upload` command runs without an error but exits
    immediately with no response. Now, we are ready to implement the `Run` method
    of the `upload` command.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义并添加了`upload`命令，我们可以测试它。在测试过程中，你会看到`upload`命令运行无误，但立即退出且没有响应。现在，我们准备实现`upload`命令的`Run`方法。
- en: When we first started implementing a CLI for the audiofile application, an API
    already existed. We discussed how this API starts and runs `MetadataServer`, which
    handles requests to a few existing endpoints. For this use case, we are concerned
    with the `http://localhost/upload` endpoint.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初开始为audiofile应用程序实现CLI时，API已经存在。我们讨论了API如何启动和运行`MetadataServer`，该服务器处理对一些现有端点的请求。对于此用例，我们关注的是`http://localhost/upload`端点。
- en: With this in mind, let’s delve deeper into the documentation for the upload
    endpoint of this REST API so we will know exactly how to construct a `curl` command.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们深入了解这个REST API上传端点的文档，这样我们就可以确切地知道如何构造`curl`命令。
- en: Uploading audio
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上传音频
- en: 'In order to upload audio, we’ll need to know how to communicate with the API
    to handle certain tasks. Here are the details required to design a request to
    handle uploading audio:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了上传音频，我们需要知道如何与API通信以处理某些任务。以下是设计请求以处理上传音频所需的具体细节：
- en: '`POST`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`'
- en: '`http://localhost/upload`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost/upload`'
- en: '`Content-Type: multipart/form-data`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type: multipart/form-data`'
- en: '`Key ("file") Value (bytes) Name(base` `of filename)`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`键 ("file") 值 (bytes) 文件名的基础名(base)`'
- en: 'Make sure that the API is running, and then test out the endpoint using `curl`.
    Immediately, the ID of the uploaded file is returned:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 确保API正在运行，然后使用`curl`测试端点。立即返回上传文件的ID：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After successfully testing out the API endpoint, we can write the Go code that
    handles the same functionality as the previous `curl` command within the `Run`
    method of `UploadCommand`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功测试了API端点之后，我们可以在`UploadCommand`的`Run`方法中编写Go代码，以实现与之前`curl`命令相同的功能。
- en: 'The new `Run` method can now be defined. The method supplies the filename that’s
    been passed into the `upload` command as a flag parameter and saves the bytes
    of that file to a multipart form `POST` request to the `http://localhost/upload`
    endpoint:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以定义新的`Run`方法。该方法提供传递给`upload`命令的作为标志参数的文件名，并将该文件的字节保存到`http://localhost/upload`端点的multipart表单`POST`请求中：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first CLI command, `upload`, has been implemented! Let’s implement another
    use case, requesting metadata by ID.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个CLI命令`upload`已经实现！让我们实现另一个用例，通过ID请求元数据。
- en: Requesting metadata
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求元数据
- en: In the requesting metadata use case, an authenticated user requests audio metadata
    by the audio file’s ID. Under the hood, the request metadata process will, within
    the flat file storage implementation, search for the `metadata.json` file corresponding
    with the audio file and decode its contents into the `Audio` struct.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求元数据用例中，认证用户通过音频文件的ID请求音频元数据。在底层，请求元数据的过程将在平面文件存储实现中搜索与音频文件对应的`metadata.json`文件，并将其内容解码到`Audio`结构体中。
- en: 'Before implementing the request metadata use case, let’s consider what the
    command for requesting metadata will look like. The final command structure will
    look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现请求元数据用例之前，让我们考虑请求元数据的命令将是什么样子。最终的命令结构将如下所示：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For simplification, `get` is the command to request metadata. Let’s define
    the new `get` command, and in `/cmd/cli/main.go`, confirm that it is present in
    the list of commands to recognize when the application is run. The structure for
    defining the `get` command is similar to that of the first command, `upload`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，`get`是请求元数据的命令。让我们定义新的`get`命令，并在`/cmd/cli/main.go`中确认当应用程序运行时它存在于可识别的命令列表中。定义`get`命令的结构与第一个命令`upload`类似：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `NewGetCommand` method implements our desired command structure by defining
    a new flag set for the `get` command, `flag.NewFlagSet("get", flag.ContinueOnError)`.
    This method receives the string, `get`, in the method’s `name` parameter and `flag.ContinueOnError`
    in the `flag.ErrorHandling` parameter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewGetCommand`方法通过为`get`命令定义一个新的标志集`flag.NewFlagSet("get", flag.ContinueOnError)`来实现我们想要的命令结构。此方法接收方法参数`name`中的字符串`get`和`flag.ErrorHandling`参数中的`flag.ContinueOnError`。'
- en: Let’s delve deeper into the documentation for the get endpoint of this REST
    API so we will know exactly how to construct a curl command.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入查阅这个REST API的get端点文档，以便我们确切知道如何构造curl命令。
- en: Requesting metadata
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求元数据
- en: 'In order to request audio metadata, we’ll need to know how to communicate with
    the API to handle this task. Here are the details required to design a request
    for audio metadata:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了请求音频元数据，我们需要知道如何与API通信以处理此任务。以下是设计音频元数据请求所需的相关细节：
- en: '`GET`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`'
- en: '`http://localhost/get`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost/get`'
- en: '`id` – ID of audio file'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id` – 音频文件ID'
- en: 'Make sure that the API is running, and then test out the `get` endpoint using
    `curl`. Immediately, the metadata of the requested audio file is returned in JSON
    format. This data could be returned in different formats, and we could add an
    additional flag to determine the format of the returned metadata:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 确保API正在运行，然后使用`curl`测试`get`端点。立即以JSON格式返回请求的音频文件的元数据。这些数据可以以不同的格式返回，我们可以添加一个额外的标志来决定返回元数据的格式：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After confirming that the API endpoint works as expected, we can write the
    Go code that handles the same functionality as the preceding `curl` command within
    the `Run` method of `GetCommand`. The new `Run` method can now be defined:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认API端点按预期工作后，我们可以在`GetCommand`的`Run`方法中编写Go代码，以实现与之前的`curl`命令相同的功能。现在可以定义新的`Run`方法：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that the request metadata use case has been implemented, let’s compile
    the code and test out the first couple of CLI commands: `upload`, for uploading
    and processing audio metadata, and `get`, for requesting metadata by audiofile
    ID.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请求元数据用例已经实现，让我们编译代码并测试前几个 CLI 命令：`upload` 用于上传和处理音频元数据，以及 `get` 用于通过音频文件 ID
    请求元数据。
- en: 'Giving the CLI a more specific name, `audiofile-cli`, let’s generate the build
    by running the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 给 CLI 起一个更具体的名字，`audiofile-cli`，然后运行以下命令来生成构建：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Testing a CLI
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 CLI
- en: Now that we have successfully built the CLI application, we can do some testing
    to make sure that it’s working. We can test out the commands we’ve created and
    then write out proper tests to make sure any future changes don’t break the current
    functionality.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功构建了 CLI 应用程序，我们可以进行一些测试以确保它正在正常工作。我们可以测试我们创建的命令，然后编写适当的测试以确保未来的更改不会破坏当前的功能。
- en: Manual testing
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动测试
- en: 'To upload an audio file, we’ll run the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要上传音频文件，我们将运行以下命令：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result is as expected:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 结果正如预期：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we have the audiofile ID, we can immediately get the metadata, which
    will change as the metadata updates after each extraction process. The command
    for requesting metadata is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了音频文件 ID，我们可以立即获取元数据，这些元数据将在每次提取过程更新后发生变化。请求元数据的命令如下：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result is the populated `Audio` struct in JSON format:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是填充的 `Audio` 结构体，以 JSON 格式呈现：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The results are as expected. However, not all audio passed into the CLI will
    return the same data. This is just an example. Some audio may not have any tags
    at all and transcription will be skipped if you don’t have the `ASSEMBLYAI_API_KEY`
    environment variable set with an AssemblyAI API key. Ideally, API keys should
    not be set as environment variables, which can be leaked easily, but this is a
    temporary option. In [*Chapter 4*](B18883_04.xhtml#_idTextAnchor087), *Popular
    Frameworks for Building CLIs*, you will learn about Viper, which is a configuration
    library that pairs perfectly with the Cobra CLI framework.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果正如预期。然而，并非所有传入 CLI 的音频都会返回相同的数据。这只是一个例子。有些音频可能没有任何标签，如果你没有设置带有 AssemblyAI
    API 密钥的 `ASSEMBLYAI_API_KEY` 环境变量，转录将被跳过。理想情况下，API 密钥不应作为环境变量设置，因为它们很容易泄露，但这是一个临时的选项。在
    [*第 4 章*](B18883_04.xhtml#_idTextAnchor087) *构建 CLIs 的流行框架* 中，你将了解 Viper，这是一个与
    Cobra CLI 框架完美搭配的配置库。
- en: Testing and mocking
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和模拟
- en: 'Now, we can start writing some unit tests. In the `main.go` file, there is
    a root function that parses the arguments passed into the application. Using VS
    Code and the extension for Go support, you can right-click on a function and see
    an option for generating unit tests, **Go: Generate Unit Tests** **For Function**.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们可以开始编写一些单元测试。在 `main.go` 文件中，有一个解析传递给应用程序的参数的根函数。使用 VS Code 和 Go 支持的扩展，你可以右键单击一个函数并看到一个用于生成单元测试的选项，**Go:
    Generate Unit Tests** **For Function**。'
- en: '![Figure 3.3 –Screenshot of VS Code menu of Go options](img/Figure_3.03.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 –VS Code 中 Go 选项菜单的截图](img/Figure_3.03.jpg)'
- en: Figure 3.3 –Screenshot of VS Code menu of Go options
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 –VS Code 中 Go 选项菜单的截图
- en: 'Select the `Parse` function in the `commands` package and then click on the
    option to generate the following table-driven unit tests inside the `parser_test.go`
    file, we can see the test function for the parsing functionality:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `commands` 包中选择 `Parse` 函数，然后点击选项在 `parser_test.go` 文件内生成以下表驱动的单元测试，我们可以看到解析功能的测试函数：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This provides a great template for us to implement some tests given different
    argument and flag combinations utilized in the method. When running the tests,
    we don’t want the client to call the REST endpoints, so we mock the client and
    fake responses. We do all this inside the `parser_test.go` file. Since each of
    the commands takes in a client, we can easily mock the interface. This is done
    in the file using the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个很好的模板，我们可以根据方法中使用的不同参数和标志组合来实现一些测试。在运行测试时，我们不希望客户端调用 REST 端点，因此我们模拟客户端并伪造响应。我们都在
    `parser_test.go` 文件中完成这些操作。由于每个命令都接受一个客户端，我们可以轻松地模拟接口。这是通过以下代码在文件中完成的：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `MockClient` interface is satisfied by `http.DefaultClient`. The `Do` method
    is mocked. Within the `Do` method, we check which endpoint is being called (`/upload`
    or`/get`) and respond with the mock response. In the preceding example, any call
    to the `/upload` endpoint responds with an `OK` status and a string, `123`, representing
    the ID of the audio file. A call to the `/get` endpoint checks the IDs passed
    in as a URL parameter. If the ID matches the audiofile ID of `123`, then the mocked
    client will return a successful response with the audio JSON in the body of the
    response. If there is a request for any ID other than `123`, then a status code
    of 500 is returned with an error message that the ID does not exist.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockClient` 接口由 `http.DefaultClient` 满足。`Do` 方法被模拟。在 `Do` 方法中，我们检查哪个端点被调用（`/upload`
    或 `/get`）并返回模拟响应。在上一个示例中，对 `/upload` 端点的任何调用都返回一个 `OK` 状态和一个字符串，`123`，表示音频文件的ID。对
    `/get` 端点的调用检查作为URL参数传递的ID。如果ID与 `123` 的音频文件ID匹配，则模拟客户端将返回一个包含响应体中音频JSON的成功响应。如果请求的ID不是
    `123`，则返回一个状态码为500的错误消息，指出ID不存在。'
- en: 'Now that the mocked client is complete, we fill in success and failure cases
    for each command, `upload` and `get`, within the `Parse` function’s unit tests:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模拟客户端已经完成，我们在 `Parse` 函数的单元测试中为每个命令，`upload` 和 `get`，填写成功和失败的情况：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `tests` variable contains an array of data that contains the name of the
    test, the fields or commands available, the string arguments potentially passed
    into the command-line application, and a `wantErr` Boolean value that is set depending
    on whether we expect an error to be returned in the test or not. Let’s go over
    each test:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests` 变量包含一个数组，其中包含测试名称、可用的字段或命令、可能传递到命令行应用程序的字符串参数，以及一个 `wantErr` 布尔值，该值根据我们是否期望在测试中返回错误而设置。让我们逐一过一下每个测试：'
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The first test, named `upload – failure – does not exist`, simulates the following
    command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次测试，名为 `upload – failure – does not exist`，模拟以下命令：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The filename, `doesNotExist.mp3`, is a file that does not exist in the root
    folder. Within the `Run()` method of the `upload` command, the file is opened.
    This is where the error occurs and the output is an error message, `file does`
    `not exist`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名 `doesNotExist.mp3` 是一个在根文件夹中不存在的文件。在 `upload` 命令的 `Run()` 方法中打开文件。这就是错误发生的地方，输出是一个错误消息，`file
    does not exist`：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The test named `upload – success – uploaded` checks the successful case of
    a file being uploaded to storage with an audiofile ID being returned in response.
    In order to get this test to work, there is a `testdata` folder in the `command`
    package, and within it exists a small audio file to test with, simulating the
    following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 `upload – success – uploaded` 的测试检查文件成功上传到存储的情况，并返回一个音频文件ID作为响应。为了使这个测试能够运行，`command`
    包中有一个 `testdata` 文件夹，其中包含一个用于测试的小型音频文件，模拟以下命令：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This file is successfully opened and sent to the `/upload` endpoint. The mocked
    client’s `Do` function sees that the request is to the `/upload` endpoint and
    sends an `OK` status along with the audiofile ID of `123` within the body of the
    response and no error. This matches the `wantErr` value of `false`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件成功打开并发送到 `/upload` 端点。模拟客户端的 `Do` 函数看到请求是到 `/upload` 端点，并发送一个 `OK` 状态，以及响应体中的音频文件ID
    `123` 和没有错误。这与 `wantErr` 的值 `false` 匹配：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After uploading, we can now *get* the metadata associated with the audiofile.
    The next test case, `get – failure – id does not exist`, tests a request for an
    audiofile ID that does not exist. Instead of passing in `123`, that is, that ID
    of an audiofile that exists, we pass in an ID that does not exist, simulating
    the following command via the CLI:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上传后，我们现在可以 *获取* 与音频文件相关的元数据。下一个测试用例 `get – failure – id does not exist` 测试对不存在音频文件ID的请求。我们不是传递
    `123`，即存在的音频文件ID，而是传递一个不存在的ID，通过CLI模拟以下命令：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`wantErr` is set to `true` and we get the expected error, `audiofile id does
    not exist`. The response from the `/request` endpoint returns the error message
    in the body of the response.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`wantErr` 设置为 `true`，我们得到了预期的错误，`audiofile id does not exist`。来自 `/request`
    端点的响应在响应体中返回错误消息。'
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The test named `get – success – requested` checks whether the `get` command
    was successful in retrieving an ID of an audiofile that exists. The ID passed
    is `"123"`, and in the mocked client, you can see that when that specific ID is
    passed into the request, the API endpoint returns a 200 success code with the
    body of the audiofile metadata.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'This is simulated with the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following code loops through the previously described `tests` array to
    run each test with the arguments passed into the command and checks whether the
    final `wantErr` value matches the expected error:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To run these tests, from the repository type the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will execute all the preceding tests and print the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It’s important to test success and failure cases for all the commands. Although
    this was just a starting example; more test cases could be added. For example,
    in the previous chapter, we discussed the upload use case in more detail. You
    could test it with large files that exceed the limit, or whether the file passed
    into the `upload` command is an audio file. In the state that the current implementation
    is in, a large file would successfully upload. Since this is not what we want,
    we can modify the `UploadCommand` `Run` method to check the size of the file before
    calling the request to the `/upload` endpoint. However, this is just an example
    and hopefully gives you an idea of how a CLI can be built alongside an existing
    API.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have gone through an example of building an audio
    metadata CLI. Going through each of the different components that make up this
    CLI has helped us to determine how a CLI could be structured and how files are
    structured, whether as part of an existing code base or as a new CLI.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to implement the first two main use cases of the CLI, uploading
    audio and getting audio metadata. The details provided on the structure of the
    commands gave you an idea of how commands could be built out without the use of
    any additional parsing packages. You also learned how to implement a use case,
    test your CLI, and mock a client interface.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: While this chapter gave you an idea of how to build a CLI, some commands such
    as nested subcommands and flag combinations can get complicated. In the next chapter,
    we’ll discuss how to use some popular frameworks to help parse complicated commands
    and improve the CLI development process overall. You’ll see how these frameworks
    can exponentially speed up the development of a new CLI!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the benefits of using a storage interface? If you were to use a different
    storage option, how easy would it be to swap out for the current flat file storage
    implementation?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between an argument and a flag? In the following real-world
    example, what qualifies as an argument or a flag?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Suppose you’d like to create an additional test for when a user runs the `get`
    command without passing in any arguments or flags:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What would an additional entry to the `tests` array look like?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests` 数组中添加一个额外的条目会是什么样子？'
- en: Answers
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Interfaces benefit us when writing modular code that’s decoupled and reduces
    dependency across different parts of the code base. Since we have an interface,
    it’s much easier to swap out the implementation. In the existing code, you’d swap
    the implementation type in the `Run` method of the `metadata` package.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口在编写模块化代码时对我们有益，这种代码是解耦的，并且减少了代码库不同部分之间的依赖。由于我们有一个接口，替换实现就变得容易得多。在现有代码中，你会在
    `metadata` 包的 `Run` 方法中替换实现类型。
- en: 'In this example:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中：
- en: '[PRE53]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`upload`, `-filename`, and `music.mp3` are all considered arguments. However,
    flags are specific arguments that are specifically marked by a specific syntax.
    In this case, `-filename` is a flag.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`upload`、`-filename` 和 `music.mp3` 都被视为参数。然而，标志是特定参数，它们通过特定的语法进行特别标记。在这种情况下，`-filename`
    是一个标志。'
- en: 'An additional test for when a user runs the `get` command without passing in
    any arguments or flags would look like this:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在未传递任何参数或标志的情况下运行 `get` 命令时，一个额外的测试看起来会是这样：
- en: '[PRE54]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
