- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an Audio Metadata CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Hands-on learning* is one of the best ways to learn. So, in this chapter,
    we will build out a few of our example audio metadata CLI use cases from start
    to finish. The code is available online and can be explored alongside this chapter
    or independently. Forking the GitHub repo and playing around with the code, adding
    in new use cases and tests, are encouraged as these are excellent ways to learn
    before diving into some of the ways to refine your CLI in the following chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this example covered in this chapter is not built on an empty code
    base – it is built on top of an existing REST API – it’s worth noting that the
    implementation of commands does not necessarily rely on an API. This is only an
    example and it’s encouraged that you use your imagination in this chapter on how
    commands could be implemented if not relying on an API. This chapter will give
    you an experimental code base and you’ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and mocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download the following code to follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter03/audiofile](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter03/audiofile)'
  prefs: []
  type: TYPE_NORMAL
- en: Install the latest version of VS Code with the latest Go tools.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the folder structure for our audio metadata CLI. The main
    folders in this structure were described in the last chapter. Here, we will go
    into further detail on what each folder contains, and the files and code that
    exist within them, in order from top to bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: cmd/
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously mentioned in [*Chapter 2*](B18883_02.xhtml#_idTextAnchor036),
    *Structuring Go Code for CLI Applications* in the *Commonly used program layouts
    for robust applications* section, the `cmd` folder is the main entry point for
    the different applications of the project.
  prefs: []
  type: TYPE_NORMAL
- en: cmd/api/
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `main.go` file, which in found in the `cmd/api/` folder, will start to
    run the audio metadata API locally on the machine. It takes in a port number as
    an optional flag, defaulting to `8000`, and passes the port number into a `Run`
    method within the `services` method that starts the metadata service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We make use of the `flag` package, which implements simple command-line flag
    parsing. There are different flag types that can be defined, such as `String`,
    `Bool`, and `Int`. In the preceding example, a `-p` flag is defined to override
    the default port of `8000`. `flag.Parse()` is called after all the flags are defined
    to parse the line into defined flags. There are a few syntactical methods allowed
    for passing flags to the command using Go’s `flag` package. The value `8080` will
    be parsed either way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, a flag does not require an argument and is enough on its own for
    the code to know exactly what to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Action can be taken on the flag that’s passed in, but the variable will contain
    the default value, `8000`, when defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the API from the project’s root directory, run `go run cmd/api/main.go`
    and you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: cmd/cli/
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `main.go` file, in the `cmd/cli/` folder, runs the CLI, and like many
    other CLIs, this one will utilize the API by making calls to it. Since the API
    will need to be running for the CLI to work, run the API first in a separate terminal
    or in the background. The `cmd/cli/main.go` file contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `main.go` file, the commands are added to a slice of interface `Command`
    type. Each command is defined and added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each command takes the `client` variable, a default `http.Client` as a parameter
    to use to make HTTP requests to the audio metadata API endpoints. Passing in the
    `client` command allows it to be easily mocked for testing, which we will discuss
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands are then passed into a `NewParser` method, which creates a pointer
    to `command.Parser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This `Parse` function receives all arguments after the application name via
    the `os.Args[1:]` parameter value. For example, say the command line is called
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the first argument, `os.Args[0]`, returns the following value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To explain this further, let’s look at the `Command` struct and the fields
    present within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Command struct and flag.FlagSet entities](img/Figure_3.01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Command struct and flag.FlagSet entities
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the `GetCommand` struct depicted in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Each of the commands has a flag set, which contains a name for the command and
    error handling, a client, and an ID.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments to a Go program are stored in the `os.Args` slice, which is a
    collection of strings. The name of the executable being run is stored in the first
    element of the `os.Args` slice (i.e., `os.Args[0]`), while the arguments passed
    to the executable are stored in the subsequent elements (`os.Args[1:]`).
  prefs: []
  type: TYPE_NORMAL
- en: When you see the code, `parser.Parse(os.Args[1:])`, it means you’re passing
    the remainder of the command-line arguments to `parse.Parse` function, skipping
    the first argument (the name of the program). All the arguments on the command
    line, besides the program’s name, will be passed to the function in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'That means when we pass in `os.Args[1:]`, we are passing into `parse.Parse`
    all the arguments after the program name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Parse takes `args`, a string list, and returns an `error` type. The function
    converts command-line parameters into executable commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through the code alongside the following flow chart:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks for less than 1 args. If so, `help()` returns n`il.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Args[0]` is assigned to subcommand if the slice has at least one item. This
    shows the user’s command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function then cycles over the `Parser` struct’s `p.commands` property. It
    checks each command’s name (obtained by executing the `Name()` method) against
    the `subcommand` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function executes the command’s `ParseFlags` method with the rest of the
    `args` slice if a match is found (`args[1:]`). Finally, the function runs the
    command and returns the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no match is found, the method returns an unknown subcommand error message
    using the `fmt.Errorf` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essentially, the code finds and executes a command from command line arguments.
    Then, the matching command is run.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Flow diagram for the Parse method](img/Figure_3.02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Flow diagram for the Parse method
  prefs: []
  type: TYPE_NORMAL
- en: A command exists for each API endpoint. For example, `UploadCommand` will call
    the `/upload` endpoint, `ListCommand` will call the `/list` endpoint, and `GetCommand`
    will call the `/get` endpoint of the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `Parse` method, the length of `args` is checked. If no arguments
    are passed, then help is printed and the program returns `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: cmd/cli/command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `cmd/cli/command` folder, there are commands to match each of the audiofile
    API endpoints. In the next section, we will code the `upload`, `list`, and `get`
    commands to implement a couple of the use cases described in the previous chapter.
    Rather than defining the code for one of these commands here, I’ll provide a structure
    used to define a random command that satisfies the `Command` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `upload`, `get`, and `list` commands follow the same structure, but the
    implementation of the constructor and `Run` methods differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in the `cmd/cli/command` folder, there is a parser of the struct type
    with a method to parse the arguments, match them with the commands, and parse
    any flags found after the subcommand. The `NewParser` function creates a new instance
    of the `Parser` struct. It takes a slice of type `[]interfaces.Command` as input
    and returns a pointer to a `Parser` struct. This initialization method provides
    an easy way to set up the struct with a set of desired commands. The following
    is the code inside `parser.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The code checks the number of arguments passed to the `Parse` method. If the
    number of arguments is less than 1, a `help` function from a separate `help.go`
    file is called to print the help text to guide the user on proper usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: extractors/
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This folder contains implementations for the different extractors of audio metadata.
    In this case, subfolders exist for the `tags` and `transcript` implementations.
  prefs: []
  type: TYPE_NORMAL
- en: extractors/tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `tags` package is implemented within the `extractors/tags` folder. Tags
    metadata may include title, album, artists, composer, genre, release year, lyrics,
    and any additional comments. The code is available within the GitHub repository
    and utilizes the `github.com/dhowden/tag` Go package.
  prefs: []
  type: TYPE_NORMAL
- en: extractors/transcript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `transcript` package is implemented within the `extractors/transcript` folder.
    Like the other extraction package, the code can be found in the GitHub repository.
    However, transcript analysis is handled by AssemblyAI, a third-party API, and
    requires an API key, which can be set locally to `ASSEMBLY_API_KEY`.
  prefs: []
  type: TYPE_NORMAL
- en: internal/interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `internal/interfaces` folder holds interfaces utilized by the application.
    It includes both the `Command` and `Storage` interfaces. Interfaces provide a
    way for developers to create multiple types that meet the same interface specifications
    allowing flexibility and modularity in the design of the application. The `storage.go`
    file defines the storage interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding interface satisfies all possible use cases. Specific implementations
    can be defined in the `storage` folder. If you choose to define the storage type
    within a configuration, you can easily swap out implementations and switch from
    one storage type to another. In this example, we define flat file storage with
    an implementation of each method to satisfy the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'First utilized in the `cmd/cli/main.go` file, the `Command` interface is defined
    by the following code in `internal/interfaces/command.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice how each of the commands in the `cmd/cli/command/` folder implements
    the preceding interface.
  prefs: []
  type: TYPE_NORMAL
- en: models/
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `models` folder contains a structs shared across the different applications.
    The first struct defined for the `audiofile` application is `Audio`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Id` variable contains the unique `Audio` file. The path the stored local
    copy of the audio file. The `Metadata` variable contains the data extracted from
    the audio file. In the following example, tags and speech-to-text transcript data
    are being stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It’s not necessary to know the struct for each extraction type. The most important
    thing is the main entity type, `Audio`, and its value field, `Metadata`.
  prefs: []
  type: TYPE_NORMAL
- en: services/metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although multiple services could be implemented in the `services` folder, we’re
    currently only utilizing one API service, the audio metadata service. The only
    method that exists in the `metadata.go` file is the `CreateMetadataServer` method,
    which is called in the `metadata` package, and the `Run` method, which is called
    from the `cmd/api/main.go` file. This file also contains the struct for `MetadataService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`CreateMetadataService` takes an argument, a port of the `int` type, to define
    the server’s port running on localhost. It also takes an argument, `storage`,
    which is an implementation of the `Storage` interface. The handlers that declare
    each endpoint of the API server are also defined. This function returns a pointer
    to `MetadataService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Run` method, which takes an argument, `port`, defined by the value of
    the `p` flag or the default value of `8000`, calls the `CreateMetadataService`
    method and initiates running the server by calling the `ListenAndServer` method
    on the server. Any error with starting the API will be returned immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Implementations of each of the handlers will be discussed in the next section
    when handling a few use cases.
  prefs: []
  type: TYPE_NORMAL
- en: storage/
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `storage` folder, there is the `flatfile.go` file, which implements a
    method of storing metadata locally to a flat file organized via ID on the local
    disk. The code implementation of this will not be discussed in this book because
    it goes beyond the scope of focus on the CLI. However, you can view the code in
    the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: vendor/
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `vendor` directory holds all direct and indirect dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember the use cases defined in the previous chapter? Let’s try to implement
    a couple of them:'
  prefs: []
  type: TYPE_NORMAL
- en: UC-01 Upload audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UC-02 Request metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this use case, an authenticated user uploads an audio file by giving the
    location of the file on their device for the purpose of extracting its metadata.
    Under the hood, the upload process will save a local copy and run the metadata
    extraction process on the audio file. A unique ID for the audio file is returned
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin to implement this use case, let’s consider what the command
    for uploading may look like. Suppose we’ve settled on the following final command
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `/cmd/cli/main.go` is already defined, we’ll just need to make sure that
    the `upload` command exists and satisfies the `command` interface, with the `ParseFlags`,
    `Run`, and `Name` methods. In the `internal/command` folder, we define the `upload`
    command in the `upload.go` file within the `command` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NewUploadCommand` method implements our desired command structure by defining
    a new flag set for the `upload` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This method call passes the string, `upload`, into the method’s `name` parameter
    and flag. `ContinueOnError` in the `flag.ErrorHandling` parameter defines how
    the application should react if an error occurs when parsing the flag. The different,
    and mostly self-explanatory, options for handling errors upon parsing include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flag.ContinueOnError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flag.ExitOnError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flag.PanicOnError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve defined and added the `upload` command, we can test it out. Upon
    testing, you’ll see that the `upload` command runs without an error but exits
    immediately with no response. Now, we are ready to implement the `Run` method
    of the `upload` command.
  prefs: []
  type: TYPE_NORMAL
- en: When we first started implementing a CLI for the audiofile application, an API
    already existed. We discussed how this API starts and runs `MetadataServer`, which
    handles requests to a few existing endpoints. For this use case, we are concerned
    with the `http://localhost/upload` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, let’s delve deeper into the documentation for the upload
    endpoint of this REST API so we will know exactly how to construct a `curl` command.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading audio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to upload audio, we’ll need to know how to communicate with the API
    to handle certain tasks. Here are the details required to design a request to
    handle uploading audio:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/upload`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-Type: multipart/form-data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Key ("file") Value (bytes) Name(base` `of filename)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make sure that the API is running, and then test out the endpoint using `curl`.
    Immediately, the ID of the uploaded file is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After successfully testing out the API endpoint, we can write the Go code that
    handles the same functionality as the previous `curl` command within the `Run`
    method of `UploadCommand`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `Run` method can now be defined. The method supplies the filename that’s
    been passed into the `upload` command as a flag parameter and saves the bytes
    of that file to a multipart form `POST` request to the `http://localhost/upload`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first CLI command, `upload`, has been implemented! Let’s implement another
    use case, requesting metadata by ID.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the requesting metadata use case, an authenticated user requests audio metadata
    by the audio file’s ID. Under the hood, the request metadata process will, within
    the flat file storage implementation, search for the `metadata.json` file corresponding
    with the audio file and decode its contents into the `Audio` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before implementing the request metadata use case, let’s consider what the
    command for requesting metadata will look like. The final command structure will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For simplification, `get` is the command to request metadata. Let’s define
    the new `get` command, and in `/cmd/cli/main.go`, confirm that it is present in
    the list of commands to recognize when the application is run. The structure for
    defining the `get` command is similar to that of the first command, `upload`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `NewGetCommand` method implements our desired command structure by defining
    a new flag set for the `get` command, `flag.NewFlagSet("get", flag.ContinueOnError)`.
    This method receives the string, `get`, in the method’s `name` parameter and `flag.ContinueOnError`
    in the `flag.ErrorHandling` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s delve deeper into the documentation for the get endpoint of this REST
    API so we will know exactly how to construct a curl command.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting metadata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to request audio metadata, we’ll need to know how to communicate with
    the API to handle this task. Here are the details required to design a request
    for audio metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/get`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id` – ID of audio file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make sure that the API is running, and then test out the `get` endpoint using
    `curl`. Immediately, the metadata of the requested audio file is returned in JSON
    format. This data could be returned in different formats, and we could add an
    additional flag to determine the format of the returned metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After confirming that the API endpoint works as expected, we can write the
    Go code that handles the same functionality as the preceding `curl` command within
    the `Run` method of `GetCommand`. The new `Run` method can now be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the request metadata use case has been implemented, let’s compile
    the code and test out the first couple of CLI commands: `upload`, for uploading
    and processing audio metadata, and `get`, for requesting metadata by audiofile
    ID.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Giving the CLI a more specific name, `audiofile-cli`, let’s generate the build
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Testing a CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have successfully built the CLI application, we can do some testing
    to make sure that it’s working. We can test out the commands we’ve created and
    then write out proper tests to make sure any future changes don’t break the current
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Manual testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To upload an audio file, we’ll run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the audiofile ID, we can immediately get the metadata, which
    will change as the metadata updates after each extraction process. The command
    for requesting metadata is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the populated `Audio` struct in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The results are as expected. However, not all audio passed into the CLI will
    return the same data. This is just an example. Some audio may not have any tags
    at all and transcription will be skipped if you don’t have the `ASSEMBLYAI_API_KEY`
    environment variable set with an AssemblyAI API key. Ideally, API keys should
    not be set as environment variables, which can be leaked easily, but this is a
    temporary option. In [*Chapter 4*](B18883_04.xhtml#_idTextAnchor087), *Popular
    Frameworks for Building CLIs*, you will learn about Viper, which is a configuration
    library that pairs perfectly with the Cobra CLI framework.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and mocking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can start writing some unit tests. In the `main.go` file, there is
    a root function that parses the arguments passed into the application. Using VS
    Code and the extension for Go support, you can right-click on a function and see
    an option for generating unit tests, **Go: Generate Unit Tests** **For Function**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 –Screenshot of VS Code menu of Go options](img/Figure_3.03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 –Screenshot of VS Code menu of Go options
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `Parse` function in the `commands` package and then click on the
    option to generate the following table-driven unit tests inside the `parser_test.go`
    file, we can see the test function for the parsing functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides a great template for us to implement some tests given different
    argument and flag combinations utilized in the method. When running the tests,
    we don’t want the client to call the REST endpoints, so we mock the client and
    fake responses. We do all this inside the `parser_test.go` file. Since each of
    the commands takes in a client, we can easily mock the interface. This is done
    in the file using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `MockClient` interface is satisfied by `http.DefaultClient`. The `Do` method
    is mocked. Within the `Do` method, we check which endpoint is being called (`/upload`
    or`/get`) and respond with the mock response. In the preceding example, any call
    to the `/upload` endpoint responds with an `OK` status and a string, `123`, representing
    the ID of the audio file. A call to the `/get` endpoint checks the IDs passed
    in as a URL parameter. If the ID matches the audiofile ID of `123`, then the mocked
    client will return a successful response with the audio JSON in the body of the
    response. If there is a request for any ID other than `123`, then a status code
    of 500 is returned with an error message that the ID does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the mocked client is complete, we fill in success and failure cases
    for each command, `upload` and `get`, within the `Parse` function’s unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tests` variable contains an array of data that contains the name of the
    test, the fields or commands available, the string arguments potentially passed
    into the command-line application, and a `wantErr` Boolean value that is set depending
    on whether we expect an error to be returned in the test or not. Let’s go over
    each test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The first test, named `upload – failure – does not exist`, simulates the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The filename, `doesNotExist.mp3`, is a file that does not exist in the root
    folder. Within the `Run()` method of the `upload` command, the file is opened.
    This is where the error occurs and the output is an error message, `file does`
    `not exist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The test named `upload – success – uploaded` checks the successful case of
    a file being uploaded to storage with an audiofile ID being returned in response.
    In order to get this test to work, there is a `testdata` folder in the `command`
    package, and within it exists a small audio file to test with, simulating the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This file is successfully opened and sent to the `/upload` endpoint. The mocked
    client’s `Do` function sees that the request is to the `/upload` endpoint and
    sends an `OK` status along with the audiofile ID of `123` within the body of the
    response and no error. This matches the `wantErr` value of `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After uploading, we can now *get* the metadata associated with the audiofile.
    The next test case, `get – failure – id does not exist`, tests a request for an
    audiofile ID that does not exist. Instead of passing in `123`, that is, that ID
    of an audiofile that exists, we pass in an ID that does not exist, simulating
    the following command via the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`wantErr` is set to `true` and we get the expected error, `audiofile id does
    not exist`. The response from the `/request` endpoint returns the error message
    in the body of the response.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The test named `get – success – requested` checks whether the `get` command
    was successful in retrieving an ID of an audiofile that exists. The ID passed
    is `"123"`, and in the mocked client, you can see that when that specific ID is
    passed into the request, the API endpoint returns a 200 success code with the
    body of the audiofile metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is simulated with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code loops through the previously described `tests` array to
    run each test with the arguments passed into the command and checks whether the
    final `wantErr` value matches the expected error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To run these tests, from the repository type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute all the preceding tests and print the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to test success and failure cases for all the commands. Although
    this was just a starting example; more test cases could be added. For example,
    in the previous chapter, we discussed the upload use case in more detail. You
    could test it with large files that exceed the limit, or whether the file passed
    into the `upload` command is an audio file. In the state that the current implementation
    is in, a large file would successfully upload. Since this is not what we want,
    we can modify the `UploadCommand` `Run` method to check the size of the file before
    calling the request to the `/upload` endpoint. However, this is just an example
    and hopefully gives you an idea of how a CLI can be built alongside an existing
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have gone through an example of building an audio
    metadata CLI. Going through each of the different components that make up this
    CLI has helped us to determine how a CLI could be structured and how files are
    structured, whether as part of an existing code base or as a new CLI.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to implement the first two main use cases of the CLI, uploading
    audio and getting audio metadata. The details provided on the structure of the
    commands gave you an idea of how commands could be built out without the use of
    any additional parsing packages. You also learned how to implement a use case,
    test your CLI, and mock a client interface.
  prefs: []
  type: TYPE_NORMAL
- en: While this chapter gave you an idea of how to build a CLI, some commands such
    as nested subcommands and flag combinations can get complicated. In the next chapter,
    we’ll discuss how to use some popular frameworks to help parse complicated commands
    and improve the CLI development process overall. You’ll see how these frameworks
    can exponentially speed up the development of a new CLI!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the benefits of using a storage interface? If you were to use a different
    storage option, how easy would it be to swap out for the current flat file storage
    implementation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between an argument and a flag? In the following real-world
    example, what qualifies as an argument or a flag?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Suppose you’d like to create an additional test for when a user runs the `get`
    command without passing in any arguments or flags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What would an additional entry to the `tests` array look like?
  prefs: []
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces benefit us when writing modular code that’s decoupled and reduces
    dependency across different parts of the code base. Since we have an interface,
    it’s much easier to swap out the implementation. In the existing code, you’d swap
    the implementation type in the `Run` method of the `metadata` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`upload`, `-filename`, and `music.mp3` are all considered arguments. However,
    flags are specific arguments that are specifically marked by a specific syntax.
    In this case, `-filename` is a flag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An additional test for when a user runs the `get` command without passing in
    any arguments or flags would look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
