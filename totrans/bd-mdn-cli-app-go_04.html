<html><head></head><body>
		<div id="_idContainer037">
			<h1 id="_idParaDest-88" class="chapter-number"><a id="_idTextAnchor087"/>4</h1>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Popular Frameworks for Building CLIs</h1>
			<p>This chapter will explore the most popular frameworks available to assist you with rapidly developing modern CLI applications. After seeing all the code that it takes to manually create a command and structure a CLI application, you’ll see how Cobra allows developers to quickly generate all the scaffolding needed for a CLI application and add new <span class="No-Break">commands easily.</span></p>
			<p>Viper easily integrates with Cobra to configure your applications locally or remotely using multiple formats. The options are extensive, and developers can choose what they feel works best for their project and what they are comfortable with. This chapter will give you an in-depth look at Cobra and Viper through the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Cobra – a library for building modern <span class="No-Break">CLI applications</span></li>
				<li>Viper – easy configuration <span class="No-Break">for CLIs</span></li>
				<li>Basic calculator CLI using Cobra <span class="No-Break">and Viper</span></li>
			</ul>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Technical requirements</h1>
			<p>To easily follow along with the code in this chapter, you will need to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Install the Cobra <span class="No-Break">CLI: </span><a href="https://github.com/spf13/cobra-cli"><span class="No-Break">https://github.com/spf13/cobra-cli</span></a><a href="https://github.com/spf13/cobra-cli&#13;"/></li>
				<li>Get the Cobra <span class="No-Break">package: </span><a href="https://github.com/spf13/cobra"><span class="No-Break">https://github.com/spf13/cobra</span></a><a href="https://github.com/spf13/cobra&#13;"/></li>
				<li>Get the Viper <span class="No-Break">package: </span><a href="https://github.com/spf13/viper"><span class="No-Break">https://github.com/spf13/viper</span></a></li>
				<li>Download the following <span class="No-Break">code: </span><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter04</span></a></li>
			</ul>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Cobra – a library for building modern CLI applications</h1>
			<p>Cobra is a Go <a id="_idIndexMarker253"/>library for building powerful and modern CLI applications. It makes defining both simple and complex nested commands easy. The extensive <a id="_idIndexMarker254"/>field list for the Cobra <strong class="source-inline">Command</strong> object allows you to access the complete self-documenting help and man pages. Cobra <a id="_idIndexMarker255"/>also offers some fun additional benefits, including intelligent shell autocomplete, CLI scaffolding, code generation, and integration with the Viper <span class="No-Break">configuration solution.</span></p>
			<p>The Cobra library provides a much more powerful command structure than one written from scratch. As mentioned, there are many advantages to using the Cobra CLI, so we will dive into a few examples to exhibit its power. Starting a CLI with Cobra from scratch only requires three steps. First, make sure that <strong class="source-inline">cobra-cli</strong> is properly installed. Create a new folder for your project and follow these steps in sequence to set up your <span class="No-Break">new CLI:</span></p>
			<ol>
				<li>Change directories into your project <span class="No-Break">folder, </span><span class="No-Break"><strong class="source-inline">audiofile-cli</strong></span><span class="No-Break">:</span></li>
			</ol>
			<p><span class="No-Break"><strong class="source-inline">cd audiofile-cli</strong></span></p>
			<ol>
				<li value="2">Create a module and initialize your <span class="No-Break">current directory:</span></li>
			</ol>
			<p><strong class="source-inline">go mod init &lt;</strong><span class="No-Break"><strong class="source-inline">module path&gt;</strong></span></p>
			<ol>
				<li value="3">Initialize your <span class="No-Break">Cobra CLI:</span></li>
			</ol>
			<p><span class="No-Break"><strong class="source-inline">cobra-cli init</strong></span></p>
			<p>After running just three commands, <strong class="source-inline">ls</strong> shows that the folder structure is already created, and commands are ready to be added. Running the <strong class="source-inline">main.go</strong> file returns the default long description, but once commands are added, the audiofile CLI usage will be displayed with help and <span class="No-Break">examples instead.</span></p>
			<p>If you run <strong class="source-inline">cobra-cli</strong> on its own to see the options available, you’ll see there are only four commands, <strong class="source-inline">add</strong>, <strong class="source-inline">completion</strong>, <strong class="source-inline">help</strong>, and <strong class="source-inline">init</strong>. Since we’ve already used <strong class="source-inline">init</strong> to initialize our project, next, we’ll use <strong class="source-inline">add</strong> to create the template code for a <span class="No-Break">new command.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Creating subcommands</h2>
			<p>The fastest <a id="_idIndexMarker256"/>way to add a new command from the Cobra CLI is to run the <strong class="source-inline">cobra-cli</strong> command, <strong class="source-inline">add</strong>. To get more details on this command, we run <strong class="source-inline">cobra-cli</strong> <strong class="source-inline">add</strong> <strong class="source-inline">–help</strong>, which shows us the syntax for running the <span class="No-Break"><strong class="source-inline">add</strong></span><span class="No-Break"> command.</span></p>
			<p>To try to create the example<em class="italic"> </em><strong class="source-inline">upload</strong> command from the previous chapter, we would run <span class="No-Break">the following:</span></p>
			<pre class="console">
cobra-cli add upload</pre>
			<p>Let’s quickly try calling the code that was generated for the <span class="No-Break"><strong class="source-inline">upload</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
<img src="image/011.png" alt=""/>  audiofile-cli go run main.go upload
upload called</pre>
			<p>By default, the <strong class="source-inline">upload called</strong> output is returned. Now, let’s take a look at the generated code. Within the same file for the command is an <strong class="source-inline">init</strong> function that adds this command to the <strong class="source-inline">root</strong> or <span class="No-Break"><strong class="source-inline">entry</strong></span><span class="No-Break"> command.</span></p>
			<p>Let’s clean this file up and fill in some details for our <span class="No-Break"><strong class="source-inline">upload</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
package cmd
import (
    "github.com/spf13/cobra"
)
// uploadCmd represents the upload command
var uploadCmd = &amp;cobra.Command{
    Use:   "upload [audio|video] [-f|--filename]
      &lt;filename&gt;",
    Short: "upload an audio or video file",
    Long: `This command allows you to upload either an
      audio or video file for metadata extraction.
    To pass in a filename, use the -f or --filename flag
     followed by the path of the file.
    Examples:
    ./audiofile-cli upload audio -f audio/beatdoctor.mp3
    ./audiofile-cli upload video --filename video/
      musicvideo.mp4`,
}
func init() {
    rootCmd.AddCommand(uploadCmd)
}</pre>
			<p>Now, let’s create <a id="_idIndexMarker257"/>these two new subcommands for the <strong class="source-inline">upload</strong> command to specify either audio <span class="No-Break">or video:</span></p>
			<pre class="console">
<img src="image/011.png" alt=""/>  cobra-cli add audio
audio created at /Users/marian/go/src/github.com/
  marianina8/audiofile-cli
<img src="image/011.png" alt=""/>  cobra-cli add video
video created at /Users/marian/go/src/github.com/
  marianina8/audiofile-cli</pre>
			<p>We add <strong class="source-inline">audioCmd</strong> and <strong class="source-inline">videoCmd</strong> as subcommands to <strong class="source-inline">uploadCmd</strong>. The <strong class="source-inline">audio</strong> command, which contains only the generated code, needs to be modified in order to be recognized as a subcommand. Also, we need to define the filename flag for the <strong class="source-inline">audio</strong> subcommand. The <strong class="source-inline">init </strong>function of the <strong class="source-inline">audio</strong> command will look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
func init() {
    audioCmd.Flags().StringP("filename", "f", "", "audio
      file")
    uploadCmd.AddCommand(audioCmd)
}</pre>
			<p>Parsing the <a id="_idIndexMarker258"/>filename flag happens within the <strong class="source-inline">Run</strong> function. However, we want to return an error if the filename flag is missing, so we change the function on <strong class="source-inline">audioCmd</strong> to return an error and use the <strong class="source-inline">RunE </strong><span class="No-Break">method instead:</span></p>
			<pre class="source-code">
    RunE: func(cmd *cobra.Command, args []string) error {
        filename, err := cmd.Flags().GetString("filename")
        if err != nil {
            fmt.Printf("error retrieving filename: %s\n",
            err.Error())
            return err
        }
        if filename == "" {
            return errors.New("missing filename")
        }
        fmt.Println("uploading audio file, ", filename)
        return nil
    },</pre>
			<p>Let’s try this code out first to see whether we get an error when we don’t pass in the subcommand, and when we run the proper <span class="No-Break">example command:</span></p>
			<pre class="console">
cobra-cli add upload</pre>
			<p>We now get an error message relating to the usage of the <span class="No-Break"><strong class="source-inline">upload</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
<img src="image/011.png" alt=""/>  go run main.go upload
This command allows you to upload either an audio or video
  file for metadata extraction.
    To pass in a filename, use the -f or --filename flag
  followed by the path of the file.
     Examples:
     ./audiofile-cli upload audio -f audio/beatdoctor.mp3
     ./audiofile-cli upload video --filename video/musicvideo.mp4
Usage:
  audiofile-cli upload [command]
Available Commands:
  audio       sets audio as the upload type
  video       sets video as the upload type</pre>
			<p>Let’s <a id="_idIndexMarker259"/>correctly run the command with either the shorthand or longhand <span class="No-Break">flag name:</span></p>
			<pre class="console">
cobra-cli add upload audio [-f|--filename]
  audio/beatdoctor.mp3</pre>
			<p>The command then returns the <span class="No-Break">expected output:</span></p>
			<pre class="console">
<img src="image/011.png" alt=""/>  go run main.go upload audio -f audio/beatdoctor.mp3
uploading audio file,audio/beatdoctor.mp3</pre>
			<p>We’ve created a subcommand, <strong class="source-inline">audio</strong>, of the <strong class="source-inline">upload</strong> command. Now the implementations for video and audio are called using <span class="No-Break">separate subcommands.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Global, local, and required flags</h2>
			<p>Cobra allows <a id="_idIndexMarker260"/>users to define different types of flags: global <a id="_idIndexMarker261"/>and local flags. Let’s quickly define <span class="No-Break">each type:</span></p>
			<ul>
				<li>Global: A global flag is <a id="_idIndexMarker262"/>available to the command it is assigned to and every subcommand of <span class="No-Break">that command</span></li>
				<li>Local: A local flag is <a id="_idIndexMarker263"/>only available to the command it is <span class="No-Break">assigned to</span></li>
			</ul>
			<p>Notice that <a id="_idIndexMarker264"/>both the video and <strong class="source-inline">audio</strong> subcommands require a flag to parse the <strong class="source-inline">filename</strong> string. It would probably be easier to set this flag as a global flag on <strong class="source-inline">uploadCmd</strong>. Let’s remove the flag definition from the <strong class="source-inline">init </strong>function <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">audioCmd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func init() {
    uploadCmd.AddCommand(audioCmd)
}</pre>
			<p>Instead, let’s add it as a global command on <strong class="source-inline">uploadCmd</strong> so that it can also be used by <strong class="source-inline">videoCmd</strong>. The <strong class="source-inline">init</strong> function of <strong class="source-inline">uploadCmd</strong> will now look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var (
    Filename = ""
)
func init() {
    uploadCmd.PersistentFlags().StringVarP(&amp;Filename,
      "filename", "f", "", "file to upload")
    rootCmd.AddCommand(uploadCmd)
}</pre>
			<p>This <strong class="source-inline">PersistentFlags()</strong> method sets a flag as global and persistent for all subcommands. Running the command to <strong class="source-inline">upload</strong> an audio file still works <span class="No-Break">as expected:</span></p>
			<pre class="console">
<img src="image/011.png" alt=""/>  go run main.go upload audio -f audio/beatdoctor.mp3
uploading audio file,  audio/beatdoctor.mp3</pre>
			<p>In the <a id="_idIndexMarker265"/><strong class="source-inline">audio</strong> subcommand implementation, we check to see whether <a id="_idIndexMarker266"/>the filename is set. This is an unnecessary <a id="_idIndexMarker267"/>step if we make the file required. Let’s change <strong class="source-inline">init</strong> to <span class="No-Break">do that:</span></p>
			<pre class="source-code">
func init() {
    uploadCmd.PersistentFlags().StringVarP(&amp;Filename,
      "filename", "f", "", "file to upload")
    uploadCmd.MarkPersistentFlagRequired("filename")
    rootCmd.AddCommand(uploadCmd)
}</pre>
			<p>For local flags, the command would be <strong class="source-inline">MarkFlagRequired("filename")</strong>. Now let’s try to run the command without passing in the <span class="No-Break">filename flag:</span></p>
			<pre class="console">
<img src="image/011.png" alt=""/>  go run main.go upload audio
Error: required flag(s) "filename" not set
Usage:
  audiofile-cli upload audio [flags]
Flags:
  -h, --help   help for audio
Global Flags:
  -f, --filename string   file to upload
exit status 1</pre>
			<p>An error is thrown by Cobra without having to manually check whether the filename flag is parsed. Because the audio and video commands are subcommands to the <strong class="source-inline">upload</strong> command, they <a id="_idIndexMarker268"/>require the newly defined, persistent filename flag. As expected, an <a id="_idIndexMarker269"/>error is thrown to remind the <a id="_idIndexMarker270"/>user that the filename flag is not set. Another way that your CLI application can help guide users is when they incorrectly type in <span class="No-Break">a command.</span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Intelligent suggestions</h2>
			<p>By default, Cobra <a id="_idIndexMarker271"/>will provide command suggestions if the user has mistyped a command. An example is when the command <span class="No-Break">is entered:</span></p>
			<pre class="console">
<img src="image/011.png" alt=""/>  go run main.go uload audio
Cobra will automatically respond with some intelligent
  suggestions:
Error: unknown command "uload" for "audiofile-cli"
Did you mean this?
     upload
Run 'audiofile-cli --help' for usage.
exit status 1</pre>
			<p>To disable intelligent suggestions, just add the <strong class="source-inline">rootCmd.DisableSuggestions = true</strong> line to the <strong class="source-inline">init </strong>function for the root command. To change the Levenshtein distance for suggestions, modify the value of <strong class="source-inline">SuggestionsMinimumDistance </strong>on the command. You can also use the <strong class="source-inline">SuggestFor </strong>attribute on a command to explicitly state suggestions, which makes sense for commands that are logical substitutes but aren’t close in terms of the Levenshtein distance. Another way to guide first-time users of your CLI is to provide help and man pages for your application. The Cobra framework provides an easy way to automatically generate not only help but also <span class="No-Break">man pages.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Automatically generated help and man pages</h2>
			<p>As we’ve <a id="_idIndexMarker272"/>already seen, entering a wrong command, or adding the <strong class="source-inline">-h</strong> or <strong class="source-inline">–help</strong> flag to the command, will cause the CLI to return the help documentation, automatically generated from the details set within the <strong class="source-inline">cobra.Command</strong> structure. Also, man pages may be generated with the addition of the following <span class="No-Break">import: </span><span class="No-Break"><strong class="source-inline">"github.com/spf13/cobra/doc"</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Specifics on how to generate man page documentation will be detailed in <a href="B18883_09.xhtml#_idTextAnchor190"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">The Empathic Side of Development</em>, which includes how to write proper help <span class="No-Break">and documentation.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Powering your CLI</h2>
			<p>As you can see, there are many benefits to using the Cobra library to power your CLI, giving many <a id="_idIndexMarker273"/>features by default. The library also comes with its own CLI for generating scaffolding for a new application and for adding commands, which, with all the options available in the <strong class="source-inline">cobra.Command</strong> struct, gives you everything needed to build a robust and highly <span class="No-Break">customizable CLI.</span></p>
			<p>Compared to writing your CLI from scratch without a framework, you can save hours of your time with many of the built-in advantages: command scaffolding, excellent command, argument, and flag parsing, intelligent suggestions, and autogenerated help text and man pages. You can also pair your Cobra CLI with Viper to configure your application for <span class="No-Break">additional benefits.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Viper – easy configuration for CLIs</h1>
			<p>Steve Francia, author <a id="_idIndexMarker274"/>of Cobra, also created a configuration tool, Viper, to easily integrate with Cobra. For a simple application that you’re running locally on your machine, you may not initially need a configuration tool. However, if your application may run within different environments that require different integrations, API keys, or general customizations that are better in a config file versus hardcoded, Viper will help ease the process of configuring <span class="No-Break">your app.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Configuration types</h2>
			<p>There are <a id="_idIndexMarker275"/>many ways Viper allows you to set your <span class="No-Break">application’s configuration:</span></p>
			<ul>
				<li>Reading from <span class="No-Break">configuration files</span></li>
				<li>With <span class="No-Break">environment variables</span></li>
				<li>With remote <span class="No-Break">config systems</span></li>
				<li>With <span class="No-Break">command-line flags</span></li>
				<li>With <span class="No-Break">a buffer</span></li>
			</ul>
			<p>The configuration formats accepted from these configuration types include JSON, TOML, YAML, HCL, INI, envfile, and Java properties formats. To get a better understanding, let’s go over an example of each <span class="No-Break">configuration type.</span></p>
			<h3>Config file</h3>
			<p>Suppose we have <a id="_idIndexMarker276"/>different URL and port values to connect to <a id="_idIndexMarker277"/>depending on different environments. We could set up a YAML configuration file, <strong class="source-inline">config.yml</strong>, that looks like this and is stored within the main folder of <span class="No-Break">our application:</span></p>
			<pre class="source-code">
environments:
  test:
    url: 89.45.23.123
    port: 1234
  prod:
    url: 123.23.45.89
    port: 5678
loglevel: 1
keys:
  assemblyai: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</pre>
			<p>Use the <a id="_idIndexMarker278"/>code to read in the configuration and test, printing out the prod <span class="No-Break">environment’s URL:</span></p>
			<pre class="source-code">
viper.SetConfigName("config) // config filename, omit
  extension
viper.AddConfigPath(".")      // optional locations for
  searching for config files
err = viper.ReadInConfig()    // using the previous
  settings above, attempt to find and read in the
    configuration
if err != nil { // Handle errors
    panic(fmt.Errorf("err: %w \n", err))
}
fmt.Println("prod environment url:",
  viper.Get("environments.prod.url"))</pre>
			<p>Running the <a id="_idIndexMarker279"/>code confirms that <strong class="source-inline">Println </strong>will return <strong class="source-inline">environments.prod.url</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">123.23.45.89</strong></span><span class="No-Break">.</span></p>
			<h3>Environment variable</h3>
			<p>Configuration may also be set via environment variables; just note that Viper’s recognition <a id="_idIndexMarker280"/>of environment variables is case sensitive. There are <a id="_idIndexMarker281"/>a few methods that can be used when working with <span class="No-Break">environment variables.</span></p>
			<p><strong class="source-inline">SetEnvPrefix </strong>tells Viper that the environment variables used with the <strong class="source-inline">BindEnv </strong>and <strong class="source-inline">AutomaticEnv </strong>methods will be prefixed with a specific unique value. For example, say the test URL is set within an <span class="No-Break">environment variable:</span></p>
			<pre class="source-code">
viper.SetEnvPrefix("AUDIOFILE")
viper.BindEnv("TEST_URL")
os.Setenv("AUDIOFILE_TEST_URL", "89.45.23.123") //sets the
  environment variable
fmt.Println("test environment url from environment
  variable:", viper.Get("TEST_URL"))</pre>
			<p>As mentioned, the prefix, <strong class="source-inline">AUDIOFILE</strong>, affixes to the start of each environment variable <a id="_idIndexMarker282"/>passed into the <strong class="source-inline">BindEnv </strong>or <strong class="source-inline">Get </strong>method. When the <a id="_idIndexMarker283"/>preceding code is run, the value printed for the test environment URL from the <strong class="source-inline">AUDIOFILE_TEST_URL</strong> environment variable is <strong class="source-inline">89.45.23.123</strong>, <span class="No-Break">as expected.</span></p>
			<h3>Command-line flags</h3>
			<p>Viper supports <a id="_idIndexMarker284"/>configuration via several different <a id="_idIndexMarker285"/>types <span class="No-Break">of flags:</span></p>
			<ul>
				<li>Flags: Flags defined using the standard Go library <span class="No-Break">flag package</span></li>
				<li>Pflags: Flags defined using Cobra/Viper’s <span class="No-Break"><strong class="source-inline">pflag</strong></span><span class="No-Break"> definition</span></li>
				<li>Flag interfaces: Custom structures that satisfy a flag interface required <span class="No-Break">by Viper</span></li>
			</ul>
			<p>Let’s check out each of these <span class="No-Break">in detail.</span></p>
			<h4>Flags</h4>
			<p>Building on <a id="_idIndexMarker286"/>top of the standard Go flag package. The Viper <strong class="source-inline">flags </strong>package extends the functionality of the standard flag package, providing additional features such as environment variable support and the ability to set default values for flags. With Viper flags, you can define flags for string, Boolean, integer, and floating-point types, as well as for arrays of <span class="No-Break">these types.</span></p>
			<p>Some example code may look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
viper.SetDefault("host", "localhost")
viper.SetDefault("port", 1234)
viper.BindEnv("host", "AUDIOFILE_HOST")
viper.BindEnv("port", "AUDIOFILE_PORT")</pre>
			<p>In the preceding example, we set default values for the “<strong class="source-inline">host</strong>” and “<strong class="source-inline">port</strong>” flags and then bind them <a id="_idIndexMarker287"/>to environment variables using <strong class="source-inline">viper.BindEnv</strong>. After setting the environment variables, we can access the values of the flags using <strong class="source-inline">viper.GetString("host")</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">viper.GetInt("port")</strong></span><span class="No-Break">.</span></p>
			<h4>Pflags</h4>
			<p><strong class="source-inline">pflag </strong>is the flag <a id="_idIndexMarker288"/>package specific to Cobra and Viper. The values can be parsed and bound. <strong class="source-inline">viper.BindPFFlag</strong>, for individual flags, and <strong class="source-inline">viper.BindPFFlags</strong>, for flag sets, are used to bind the value of the flag when it is accessed rather <span class="No-Break">than defined.</span></p>
			<p>Once the flags are parsed and bound, the values can be accessed anywhere in the code using Viper’s <strong class="source-inline">Get </strong>methods. For retrieving the port, we’d use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
<strong class="source-inline">port := viper.GetInt("port")</strong></pre>
			<p>Within the <strong class="source-inline">init</strong> function, you can define a command-line flag set and bind the values once they are accessed. Take the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
pflag.CommandLine.AddGoFlagSet(flag.CommandLine)
pflag.Int("port", 1234, "port")
pflag.String("url", "12.34.567.123", "url")
plag.Parse()
viper.BindPFlags(pflag.CommandLine)</pre>
			<h4>Flag interfaces</h4>
			<p>Viper also <a id="_idIndexMarker289"/>allows custom flags that satisfy the following Go interfaces: <strong class="source-inline">FlagValue </strong><span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">FlagValueSet</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">FlagValue </strong>interface is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
type FlagValue interface {
    HasChanged() bool
    Name() string
    ValueString() string
    ValueType() string
}</pre>
			<p>The second interface that Viper accepts <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">FlagValueSet</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type FlagValueSet interface {
    VisitAll(fn func(FlagValue))
}</pre>
			<p>An example <a id="_idIndexMarker290"/>of code that satisfies this interface is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
type customFlagSet struct {
    flags []customFlag
}
func (set customFlagSet) VisitAll(fn func(FlagValue)) {
    for i, flag := range set.flags {
fmt.Printf("%d: %v\n", i, flag)
        fn(flag)
    }
}</pre>
			<h3>Buffer</h3>
			<p>Finally, Viper allows <a id="_idIndexMarker291"/>users to configure their applications with a buffer. Using the same value that exists within the configuration file in the first example, we pass the YAML data in as a raw string into a <span class="No-Break">byte slice:</span></p>
			<pre class="source-code">
var config = []byte(`
    environments:
    test:
      url: 89.45.23.123
      port: 1234
    prod:
      url: 123.23.45.89
      port: 5678
  loglevel: 1
  keys:
    assemblyai: ad915a59802309238234892390482304
`)
viper.SetConfigType("yaml")
viper.ReadConfig(bytes.NewBuffer(config))
viper.Get("environments.test.url") // 89.45.23.123</pre>
			<p>Now that you <a id="_idIndexMarker292"/>know the different types or ways of configuring your command-line application – from a file, environment variable, flags, or buffer – let’s see how to watch for live changes on these <span class="No-Break">configuration types.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Watching for live config changes</h2>
			<p>Both remote and local configurations can be watched. After making sure all configuration <a id="_idIndexMarker293"/>paths are added, call the <strong class="source-inline">WatchConfig </strong>method to watch for any live changes and take action by implementing a function to pass into the <span class="No-Break"><strong class="source-inline">OnConfigChange</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
viper.OnConfigChange(func(event fsnotify.Event) {
    fmt.Println("Config modified:", event)
})
viper.WatchConfig()</pre>
			<p>To watch for changes on a remote config, first, read in the remote config using <strong class="source-inline">ReadRemoteConfig()</strong>, and on the instance of the Viper configuration, call the <strong class="source-inline">WatchRemoteConfig() </strong>method. Some sample code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
var remoteConfig = viper.New()
remoteConfig.AddRemoteProvider("consul",
  "http://127.0.0.1:2380", "/config/audiofile-cli.json")
remoteConfig.SetConfigType("json")
err := remoteConfig.ReadRemoteConfig()
if err != nil {
    return err
}
remoteConfig.Unmarshal(&amp;remote_conf)</pre>
			<p>The following <a id="_idIndexMarker294"/>is an example of a goroutine that will continuously watch for remote <span class="No-Break">configuration changes:</span></p>
			<pre class="source-code">
go func(){
    for {
        time.Sleep(time.Second * 1)
        _:= remoteConfig.WatchRemoteConfig()
        remoteConfig.Unmarshal(&amp;remote_conf)
    }
}()</pre>
			<p>I think that there’s much to benefit from utilizing a configuration library rather than starting from scratch, which again can save you hours and expedite your development process. Besides the different ways you can configure your application, you can also provide remote configuration and watch for any changes live. This further creates a more <span class="No-Break">robust application.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Basic calculator CLI using Cobra and Viper</h1>
			<p>Let us pull some of the pieces together and create a separate and simple CLI using the Cobra CLI framework and Viper for configuration. A simple idea that we can easily implement is a basic calculator that can add, subtract, multiply, and divide values. The code for this demo exists within the <strong class="source-inline">Chapter-4-Demo</strong> repository for you to <span class="No-Break">follow along.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>The Cobra CLI commands</h2>
			<p>The commands <a id="_idIndexMarker295"/>are created with the following <strong class="source-inline">cobra-cli</strong> <span class="No-Break">command calls:</span></p>
			<pre class="console">
cobra-cli add add
cobra-cli add subtract
cobra-cli add multiply
cobra-cli add divide</pre>
			<p>Calling these commands successfully generates the code for each command, ready for us to fill in the details. Let us show each command and how they each are similar <span class="No-Break">and different.</span></p>
			<h3>The add command</h3>
			<p>The <strong class="source-inline">add</strong> <a id="_idIndexMarker296"/>command, <strong class="source-inline">addCmd</strong>, is defined as a pointer to the <strong class="source-inline">cobra.Command</strong> type. Here, we set the fields for <span class="No-Break">the command:</span></p>
			<pre class="source-code">
// addCmd represents the add command
var addCmd = &amp;cobra.Command{
    Use: "add number",
    Short: "Add value",
    Run: func(cmd *cobra.Command, args []string) {
        if len(args) &gt; 1 {
            fmt.Println("only accepts a single argument")
            return
        }
        if len(args) == 0 {
            fmt.Println("command requires input value")
            return
        }
        floatVal, err := strconv.ParseFloat(args[0], 64)
        if err != nil {
            fmt.Printf("unable to parse input[%s]: %v",
              args[0], err)
            return
        }
        value = storage.GetValue()
        value += floatVal
        storage.SetValue(value)
        fmt.Printf("%f\n", value)
    },
}</pre>
			<p>Let us take <a id="_idIndexMarker297"/>a quick walk through the <strong class="source-inline">Run</strong> field, which is a first-class function. Before doing any calculations, we check <strong class="source-inline">args</strong>. The command only takes one numerical field; any more or less will print a usage statement and return <span class="No-Break">the following:</span></p>
			<pre class="source-code">
if len(args) &gt; 1 {
    fmt.Println("only accepts a single argument")
    return
}
if len(args) == 0 {
    fmt.Println("command requires input value")
    return
}</pre>
			<p>We take the first and only argument, return it, set it within <strong class="source-inline">args[0]</strong>, and parse it to a flat variable using the following code. If the conversion to a <strong class="source-inline">float64</strong> value fails, then the command prints out a message about being unable to parse the input and <span class="No-Break">then returns:</span></p>
			<pre class="source-code">
floatVal, err := strconv.ParseFloat(args[0], 64)
if err != nil {
    fmt.Printf("unable to parse input[%s]: %v", args[0],
      err)
    return
}</pre>
			<p>If the conversion is successful, and no errors are returned from the string conversion, then we <a id="_idIndexMarker298"/>have a value set for <strong class="source-inline">floatVal</strong>. In our basic calculator CLI, we are storing the value in a file, which is the simplest way to store it for this example. The <strong class="source-inline">storage </strong>package and how Viper is used in configuration will be discussed after the commands. At an elevated level, we get the current value from storage and apply the operation to <strong class="source-inline">floatVal</strong>, and then save it back <span class="No-Break">into storage:</span></p>
			<pre class="source-code">
value = storage.GetValue()
value += floatVal
storage.SetValue(value)</pre>
			<p>Last but not least, the value is printed back to <span class="No-Break">the user:</span></p>
			<pre class="source-code">
fmt.Printf("%f\n", value)</pre>
			<p>That concludes our look at the <strong class="source-inline">Run</strong> function of the <strong class="source-inline">add</strong> command. The <strong class="source-inline">Use</strong> field describes the usage, and the <strong class="source-inline">Short</strong> field gives a brief description of the command. This concludes the walk-through of the add command. The subtract, multiply, and divide <strong class="source-inline">Run</strong> functions on their respective commands are remarkably similar, so I will just point out some differences <span class="No-Break">to note.</span></p>
			<h3>The subtract command</h3>
			<p>The same code is used for <strong class="source-inline">subtractCmd</strong>’s <strong class="source-inline">Run</strong> function with just a small exception. Instead of <a id="_idIndexMarker299"/>adding the value to <strong class="source-inline">floatVal</strong>, we subtract it with the <span class="No-Break">following line:</span></p>
			<pre class="source-code">
value -= floatVal</pre>
			<h3>The multiply command</h3>
			<p>The same <a id="_idIndexMarker300"/>code is used for <strong class="source-inline">multiplyCmd</strong>’s <strong class="source-inline">Run</strong> function, except we multiply it with t<a id="_idTextAnchor101"/>he <span class="No-Break">following line:</span></p>
			<pre class="source-code">
value *= floatVal</pre>
			<h3>The divide command</h3>
			<p>Finally, the <a id="_idIndexMarker301"/>same code is used for <strong class="source-inline">divideCmd</strong>’s <strong class="source-inline">Run</strong> function, except for dividing it <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">floatVal</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
value /= floatVal</pre>
			<h3>The clear command</h3>
			<p>The <strong class="source-inline">clear</strong> <a id="_idIndexMarker302"/>command resets the stored value to <strong class="source-inline">0</strong>. The code for <strong class="source-inline">clearCmd</strong> is short <span class="No-Break">and simple:</span></p>
			<pre class="source-code">
// clearCmd represents the clear command
var clearCmd = &amp;cobra.Command{
    Use: "clear",
    Short: "Clear result",
    Run: func(cmd *cobra.Command, args []string) {
        if len(args) &gt; 0 {
            fmt.Println("command does not accept args")
            return
        }
        storage.SetValue(0)
        fmt.Println(0.0)
    },
}</pre>
			<p>We check <a id="_idIndexMarker303"/>whether any <strong class="source-inline">args</strong> are passed in, and if so, we print that the command does not accept any arguments and return. If the command is called <strong class="source-inline">./calculator clear</strong>, then the <strong class="source-inline">0</strong> value is stored and then printed back to <span class="No-Break">the user.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor102"/>The Viper configuration</h2>
			<p>Let’s now <a id="_idIndexMarker304"/>discuss a simple way to use Viper configuration. In order to keep track of the value that has operations applied to it, we need to store this value. The easiest way to store data is in <span class="No-Break">a file.</span></p>
			<h3>The storage package</h3>
			<p>Within the <a id="_idIndexMarker305"/>repository, there’s a file, <strong class="source-inline">storage/storage.go</strong>, with the following code to set <span class="No-Break">the value:</span></p>
			<pre class="source-code">
func SetValue(floatVal float64) error {
    f, err := os.OpenFile(viper.GetString("filename"),
       os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
    if err != nil {
        return err
    }
    defer f.Close()
    _, err = f.WriteString(fmt.Sprintf("%f", floatVal))
    if err != nil {
        return err
    }
    return nil
}</pre>
			<p>This code will write the data to the filename returned from <strong class="source-inline">viper.GetString("filename")</strong>. The code to get the value from the file is defined <a id="_idIndexMarker306"/>with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
func GetValue() float64 {
    dat, err := os.ReadFile(viper.GetString("filename"))
    if err != nil {
        fmt.Println("unable to read from storage")
        return 0
    }
    floatVal, err := strconv.ParseFloat(string(dat), 64)
    if err != nil {
        return 0
    }
    return floatVal
}</pre>
			<p>Again, the same method is used to get the filename, to read, parse, and then return the <span class="No-Break">data contained.</span></p>
			<h3>Initializing the configuration</h3>
			<p>Inside the <a id="_idIndexMarker307"/><strong class="source-inline">main</strong> function, we call the Viper methods to initialize our configuration right before we execute <span class="No-Break">the command:</span></p>
			<pre class="source-code">
func main() {
    viper.AddConfigPath(".")
    viper.SetConfigName("config")
    viper.SetConfigType("json")
    err := viper.ReadInConfig()
    if err != nil {
        fmt.Println("error reading in config: ", err)
    }
    cmd.Execute()
}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">AddConfigPath</strong> method is used to set the path for Viper to search for the configuration file. The <strong class="source-inline">SetConfigName</strong> method allows you to set the name of the configuration file, without <a id="_idIndexMarker308"/>the extension. The actual configuration file is <strong class="source-inline">config.json</strong>, but we pass in <strong class="source-inline">config</strong>. Finally, the <strong class="source-inline">ReadInConfig</strong> method reads in the configuration to make it available throughout <span class="No-Break">the application.</span></p>
			<h3>The configuration file</h3>
			<p>Finally, the <a id="_idIndexMarker309"/>configuration file, <strong class="source-inline">config.json</strong>, stores the value for <span class="No-Break">the filename:</span></p>
			<pre class="source-code">
{
   "filename": "storage/result"
}</pre>
			<p>This file location can work for a UNIX- or Linux-based system. Change this to suit your platform and try the demo out <span class="No-Break">for yourself!</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor103"/>Running the basic calculator</h2>
			<p>To quickly build <a id="_idIndexMarker310"/>the basic calculator on UNIX or Linux, run <strong class="source-inline">go build -o calculator main.go</strong>. On Windows, run <strong class="source-inline">go build -o </strong><span class="No-Break"><strong class="source-inline">calculator.exe main.go</strong></span><span class="No-Break">.</span></p>
			<p>I ran this application on my UNIX-based terminal and got the <span class="No-Break">following output:</span></p>
			<pre class="console">
% ./calculator clear
0
% ./calculator add 123456789
123456789.000000
% ./calculator add 987654321
1111111110.000000
% ./calculator add 1
1111111111.000000
% ./calculator multiply 8
8888888888.000000
% ./calculator divide 222222222
40.000000
% ./calculator subtract 40
0.000000</pre>
			<p>Hopefully, this simple <a id="_idIndexMarker311"/>demo has provided you with a good understanding of how you can use the Cobra CLI to help speed up development and Viper for a simple way to configure <span class="No-Break">your application.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor104"/>Summary</h1>
			<p>This chapter took you through the most popular library for building modern CLIs – Cobra – and its partner library for configuration – Viper. The Cobra package was explained in detail and the CLI’s usage with examples was also described. We went through examples to take you through generating your initial application code with the Cobra CLI, adding new commands and modifying the scaffolding, to autogenerate useful help and man pages. Viper, as a configuration tool that fits perfectly alongside Cobra, was also described, along with many of its options, <span class="No-Break">in detail.</span></p>
			<p>In the next chapter, we’ll discuss how to handle input to a CLI – whether it’s text in the form of commands, arguments, or flags, or the control characters that allow you to quit out of a terminal dashboard. We’ll also discuss different ways this input is processed and how to output results back to <span class="No-Break">the user.</span></p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor105"/>Questions</h1>
			<ol>
				<li>If you want to have a flag that is accessible to a command and all its subcommands, what kind of flag would be defined <span class="No-Break">and how?</span></li>
				<li>What formatting options does Viper accept <span class="No-Break">for configuration?</span></li>
			</ol>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor106"/>Answers</h1>
			<ol>
				<li value="1">A global flag using the <strong class="source-inline">PersistentFlag()</strong> method when defining a flag on <span class="No-Break">a command.</span></li>
				<li>JSON, TOML, YAML, HCL, INI, envfile, and Java <span class="No-Break">properties formats.</span></li>
			</ol>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/>Further reading</h1>
			<ul>
				<li><em class="italic">Cobra – A Framework for Modern CLI Apps in Go</em> (<a href="https://cobra.dev/">https://cobra.dev/</a>) provides extensive documentation for Cobra with examples utilizing Cobra and links to the <span class="No-Break">Viper documentation</span></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer038" class="IMG---Figure">
			</div>
		</div>
	

		<div id="_idContainer039" class="Content">
			<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/>Part 2: The Ins and Outs of a CLI</h1>
			<p>This part focuses on the anatomy of a command-line application and the different types of inputs it can receive, such as subcommands, arguments, and flags, as well as other inputs such as stdin, signals, and control characters. It also covers various methods for processing data and how to return the result, including handling errors and timeouts when interacting with external commands or API services. The chapter also highlights Go’s cross-platform capabilities using packages such as os, time, path, <span class="No-Break">and runtime.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18883_05.xhtml#_idTextAnchor109"><em class="italic">Chapter 5</em></a>, <em class="italic">Defining the Command-Line Process</em></li>
				<li><a href="B18883_06.xhtml#_idTextAnchor123"><em class="italic">Chapter 6</em></a>, <em class="italic">Calling External Processes, Handling Errors and Timeouts</em></li>
				<li><a href="B18883_07.xhtml#_idTextAnchor143"><em class="italic">Chapter 7</em></a>, <em class="italic">Developing for Different Platforms</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer040">
			</div>
		</div>
	</body></html>