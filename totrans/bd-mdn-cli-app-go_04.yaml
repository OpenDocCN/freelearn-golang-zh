- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Popular Frameworks for Building CLIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will explore the most popular frameworks available to assist you
    with rapidly developing modern CLI applications. After seeing all the code that
    it takes to manually create a command and structure a CLI application, you’ll
    see how Cobra allows developers to quickly generate all the scaffolding needed
    for a CLI application and add new commands easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Viper easily integrates with Cobra to configure your applications locally or
    remotely using multiple formats. The options are extensive, and developers can
    choose what they feel works best for their project and what they are comfortable
    with. This chapter will give you an in-depth look at Cobra and Viper through the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Cobra – a library for building modern CLI applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viper – easy configuration for CLIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic calculator CLI using Cobra and Viper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To easily follow along with the code in this chapter, you will need to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Cobra CLI: [https://github.com/spf13/cobra-cli](https://github.com/spf13/cobra-cli)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get the Cobra package: [https://github.com/spf13/cobra](https://github.com/spf13/cobra)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get the Viper package: [https://github.com/spf13/viper](https://github.com/spf13/viper)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download the following code: [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter04](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter04)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cobra – a library for building modern CLI applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cobra is a Go library for building powerful and modern CLI applications. It
    makes defining both simple and complex nested commands easy. The extensive field
    list for the Cobra `Command` object allows you to access the complete self-documenting
    help and man pages. Cobra also offers some fun additional benefits, including
    intelligent shell autocomplete, CLI scaffolding, code generation, and integration
    with the Viper configuration solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Cobra library provides a much more powerful command structure than one
    written from scratch. As mentioned, there are many advantages to using the Cobra
    CLI, so we will dive into a few examples to exhibit its power. Starting a CLI
    with Cobra from scratch only requires three steps. First, make sure that `cobra-cli`
    is properly installed. Create a new folder for your project and follow these steps
    in sequence to set up your new CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change directories into your project folder, `audiofile-cli`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cd audiofile-cli`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a module and initialize your current directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`go mod init <``module path>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize your Cobra CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cobra-cli init`'
  prefs: []
  type: TYPE_NORMAL
- en: After running just three commands, `ls` shows that the folder structure is already
    created, and commands are ready to be added. Running the `main.go` file returns
    the default long description, but once commands are added, the audiofile CLI usage
    will be displayed with help and examples instead.
  prefs: []
  type: TYPE_NORMAL
- en: If you run `cobra-cli` on its own to see the options available, you’ll see there
    are only four commands, `add`, `completion`, `help`, and `init`. Since we’ve already
    used `init` to initialize our project, next, we’ll use `add` to create the template
    code for a new command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating subcommands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fastest way to add a new command from the Cobra CLI is to run the `cobra-cli`
    command, `add`. To get more details on this command, we run `cobra-cli` `add`
    `–help`, which shows us the syntax for running the `add` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try to create the example`upload` command from the previous chapter, we
    would run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s quickly try calling the code that was generated for the `upload` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `upload called` output is returned. Now, let’s take a look at
    the generated code. Within the same file for the command is an `init` function
    that adds this command to the `root` or `entry` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s clean this file up and fill in some details for our `upload` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create these two new subcommands for the `upload` command to specify
    either audio or video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We add `audioCmd` and `videoCmd` as subcommands to `uploadCmd`. The `audio`
    command, which contains only the generated code, needs to be modified in order
    to be recognized as a subcommand. Also, we need to define the filename flag for
    the `audio` subcommand. The `init` function of the `audio` command will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Parsing the filename flag happens within the `Run` function. However, we want
    to return an error if the filename flag is missing, so we change the function
    on `audioCmd` to return an error and use the `RunE` method instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try this code out first to see whether we get an error when we don’t
    pass in the subcommand, and when we run the proper example command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We now get an error message relating to the usage of the `upload` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s correctly run the command with either the shorthand or longhand flag
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The command then returns the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We’ve created a subcommand, `audio`, of the `upload` command. Now the implementations
    for video and audio are called using separate subcommands.
  prefs: []
  type: TYPE_NORMAL
- en: Global, local, and required flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cobra allows users to define different types of flags: global and local flags.
    Let’s quickly define each type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Global: A global flag is available to the command it is assigned to and every
    subcommand of that command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Local: A local flag is only available to the command it is assigned to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice that both the video and `audio` subcommands require a flag to parse
    the `filename` string. It would probably be easier to set this flag as a global
    flag on `uploadCmd`. Let’s remove the flag definition from the `init` function
    of `audioCmd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, let’s add it as a global command on `uploadCmd` so that it can also
    be used by `videoCmd`. The `init` function of `uploadCmd` will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This `PersistentFlags()` method sets a flag as global and persistent for all
    subcommands. Running the command to `upload` an audio file still works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `audio` subcommand implementation, we check to see whether the filename
    is set. This is an unnecessary step if we make the file required. Let’s change
    `init` to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For local flags, the command would be `MarkFlagRequired("filename")`. Now let’s
    try to run the command without passing in the filename flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: An error is thrown by Cobra without having to manually check whether the filename
    flag is parsed. Because the audio and video commands are subcommands to the `upload`
    command, they require the newly defined, persistent filename flag. As expected,
    an error is thrown to remind the user that the filename flag is not set. Another
    way that your CLI application can help guide users is when they incorrectly type
    in a command.
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent suggestions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Cobra will provide command suggestions if the user has mistyped
    a command. An example is when the command is entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To disable intelligent suggestions, just add the `rootCmd.DisableSuggestions
    = true` line to the `init` function for the root command. To change the Levenshtein
    distance for suggestions, modify the value of `SuggestionsMinimumDistance` on
    the command. You can also use the `SuggestFor` attribute on a command to explicitly
    state suggestions, which makes sense for commands that are logical substitutes
    but aren’t close in terms of the Levenshtein distance. Another way to guide first-time
    users of your CLI is to provide help and man pages for your application. The Cobra
    framework provides an easy way to automatically generate not only help but also
    man pages.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically generated help and man pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we’ve already seen, entering a wrong command, or adding the `-h` or `–help`
    flag to the command, will cause the CLI to return the help documentation, automatically
    generated from the details set within the `cobra.Command` structure. Also, man
    pages may be generated with the addition of the following import: `"github.com/spf13/cobra/doc"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Specifics on how to generate man page documentation will be detailed in [*Chapter
    9*](B18883_09.xhtml#_idTextAnchor190), *The Empathic Side of Development*, which
    includes how to write proper help and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Powering your CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, there are many benefits to using the Cobra library to power
    your CLI, giving many features by default. The library also comes with its own
    CLI for generating scaffolding for a new application and for adding commands,
    which, with all the options available in the `cobra.Command` struct, gives you
    everything needed to build a robust and highly customizable CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to writing your CLI from scratch without a framework, you can save
    hours of your time with many of the built-in advantages: command scaffolding,
    excellent command, argument, and flag parsing, intelligent suggestions, and autogenerated
    help text and man pages. You can also pair your Cobra CLI with Viper to configure
    your application for additional benefits.'
  prefs: []
  type: TYPE_NORMAL
- en: Viper – easy configuration for CLIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steve Francia, author of Cobra, also created a configuration tool, Viper, to
    easily integrate with Cobra. For a simple application that you’re running locally
    on your machine, you may not initially need a configuration tool. However, if
    your application may run within different environments that require different
    integrations, API keys, or general customizations that are better in a config
    file versus hardcoded, Viper will help ease the process of configuring your app.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many ways Viper allows you to set your application’s configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading from configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With remote config systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With command-line flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration formats accepted from these configuration types include JSON,
    TOML, YAML, HCL, INI, envfile, and Java properties formats. To get a better understanding,
    let’s go over an example of each configuration type.
  prefs: []
  type: TYPE_NORMAL
- en: Config file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose we have different URL and port values to connect to depending on different
    environments. We could set up a YAML configuration file, `config.yml`, that looks
    like this and is stored within the main folder of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the code to read in the configuration and test, printing out the prod environment’s
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Running the code confirms that `Println` will return `environments.prod.url`
    as `123.23.45.89`.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configuration may also be set via environment variables; just note that Viper’s
    recognition of environment variables is case sensitive. There are a few methods
    that can be used when working with environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: '`SetEnvPrefix` tells Viper that the environment variables used with the `BindEnv`
    and `AutomaticEnv` methods will be prefixed with a specific unique value. For
    example, say the test URL is set within an environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned, the prefix, `AUDIOFILE`, affixes to the start of each environment
    variable passed into the `BindEnv` or `Get` method. When the preceding code is
    run, the value printed for the test environment URL from the `AUDIOFILE_TEST_URL`
    environment variable is `89.45.23.123`, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Viper supports configuration via several different types of flags:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flags: Flags defined using the standard Go library flag package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pflags: Flags defined using Cobra/Viper’s `pflag` definition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flag interfaces: Custom structures that satisfy a flag interface required by
    Viper'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s check out each of these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Flags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Building on top of the standard Go flag package. The Viper `flags` package extends
    the functionality of the standard flag package, providing additional features
    such as environment variable support and the ability to set default values for
    flags. With Viper flags, you can define flags for string, Boolean, integer, and
    floating-point types, as well as for arrays of these types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some example code may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we set default values for the “`host`” and “`port`”
    flags and then bind them to environment variables using `viper.BindEnv`. After
    setting the environment variables, we can access the values of the flags using
    `viper.GetString("host")` and `viper.GetInt("port")`.
  prefs: []
  type: TYPE_NORMAL
- en: Pflags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`pflag` is the flag package specific to Cobra and Viper. The values can be
    parsed and bound. `viper.BindPFFlag`, for individual flags, and `viper.BindPFFlags`,
    for flag sets, are used to bind the value of the flag when it is accessed rather
    than defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the flags are parsed and bound, the values can be accessed anywhere in
    the code using Viper’s `Get` methods. For retrieving the port, we’d use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `init` function, you can define a command-line flag set and bind
    the values once they are accessed. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Flag interfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Viper also allows custom flags that satisfy the following Go interfaces: `FlagValue`
    and `FlagValueSet`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FlagValue` interface is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The second interface that Viper accepts is `FlagValueSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of code that satisfies this interface is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Buffer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, Viper allows users to configure their applications with a buffer.
    Using the same value that exists within the configuration file in the first example,
    we pass the YAML data in as a raw string into a byte slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know the different types or ways of configuring your command-line
    application – from a file, environment variable, flags, or buffer – let’s see
    how to watch for live changes on these configuration types.
  prefs: []
  type: TYPE_NORMAL
- en: Watching for live config changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both remote and local configurations can be watched. After making sure all
    configuration paths are added, call the `WatchConfig` method to watch for any
    live changes and take action by implementing a function to pass into the `OnConfigChange`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To watch for changes on a remote config, first, read in the remote config using
    `ReadRemoteConfig()`, and on the instance of the Viper configuration, call the
    `WatchRemoteConfig()` method. Some sample code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of a goroutine that will continuously watch for
    remote configuration changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: I think that there’s much to benefit from utilizing a configuration library
    rather than starting from scratch, which again can save you hours and expedite
    your development process. Besides the different ways you can configure your application,
    you can also provide remote configuration and watch for any changes live. This
    further creates a more robust application.
  prefs: []
  type: TYPE_NORMAL
- en: Basic calculator CLI using Cobra and Viper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us pull some of the pieces together and create a separate and simple CLI
    using the Cobra CLI framework and Viper for configuration. A simple idea that
    we can easily implement is a basic calculator that can add, subtract, multiply,
    and divide values. The code for this demo exists within the `Chapter-4-Demo` repository
    for you to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: The Cobra CLI commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The commands are created with the following `cobra-cli` command calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Calling these commands successfully generates the code for each command, ready
    for us to fill in the details. Let us show each command and how they each are
    similar and different.
  prefs: []
  type: TYPE_NORMAL
- en: The add command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `add` command, `addCmd`, is defined as a pointer to the `cobra.Command`
    type. Here, we set the fields for the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us take a quick walk through the `Run` field, which is a first-class function.
    Before doing any calculations, we check `args`. The command only takes one numerical
    field; any more or less will print a usage statement and return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We take the first and only argument, return it, set it within `args[0]`, and
    parse it to a flat variable using the following code. If the conversion to a `float64`
    value fails, then the command prints out a message about being unable to parse
    the input and then returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the conversion is successful, and no errors are returned from the string
    conversion, then we have a value set for `floatVal`. In our basic calculator CLI,
    we are storing the value in a file, which is the simplest way to store it for
    this example. The `storage` package and how Viper is used in configuration will
    be discussed after the commands. At an elevated level, we get the current value
    from storage and apply the operation to `floatVal`, and then save it back into
    storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, the value is printed back to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our look at the `Run` function of the `add` command. The `Use`
    field describes the usage, and the `Short` field gives a brief description of
    the command. This concludes the walk-through of the add command. The subtract,
    multiply, and divide `Run` functions on their respective commands are remarkably
    similar, so I will just point out some differences to note.
  prefs: []
  type: TYPE_NORMAL
- en: The subtract command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The same code is used for `subtractCmd`’s `Run` function with just a small
    exception. Instead of adding the value to `floatVal`, we subtract it with the
    following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The multiply command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The same code is used for `multiplyCmd`’s `Run` function, except we multiply
    it with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The divide command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, the same code is used for `divideCmd`’s `Run` function, except for
    dividing it by `floatVal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The clear command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `clear` command resets the stored value to `0`. The code for `clearCmd`
    is short and simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We check whether any `args` are passed in, and if so, we print that the command
    does not accept any arguments and return. If the command is called `./calculator
    clear`, then the `0` value is stored and then printed back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The Viper configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s now discuss a simple way to use Viper configuration. In order to keep
    track of the value that has operations applied to it, we need to store this value.
    The easiest way to store data is in a file.
  prefs: []
  type: TYPE_NORMAL
- en: The storage package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within the repository, there’s a file, `storage/storage.go`, with the following
    code to set the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will write the data to the filename returned from `viper.GetString("filename")`.
    The code to get the value from the file is defined with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Again, the same method is used to get the filename, to read, parse, and then
    return the data contained.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the `main` function, we call the Viper methods to initialize our configuration
    right before we execute the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `AddConfigPath` method is used to set the path for Viper to search for the
    configuration file. The `SetConfigName` method allows you to set the name of the
    configuration file, without the extension. The actual configuration file is `config.json`,
    but we pass in `config`. Finally, the `ReadInConfig` method reads in the configuration
    to make it available throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, the configuration file, `config.json`, stores the value for the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This file location can work for a UNIX- or Linux-based system. Change this to
    suit your platform and try the demo out for yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Running the basic calculator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To quickly build the basic calculator on UNIX or Linux, run `go build -o calculator
    main.go`. On Windows, run `go build -o` `calculator.exe main.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I ran this application on my UNIX-based terminal and got the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, this simple demo has provided you with a good understanding of how
    you can use the Cobra CLI to help speed up development and Viper for a simple
    way to configure your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter took you through the most popular library for building modern CLIs
    – Cobra – and its partner library for configuration – Viper. The Cobra package
    was explained in detail and the CLI’s usage with examples was also described.
    We went through examples to take you through generating your initial application
    code with the Cobra CLI, adding new commands and modifying the scaffolding, to
    autogenerate useful help and man pages. Viper, as a configuration tool that fits
    perfectly alongside Cobra, was also described, along with many of its options,
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll discuss how to handle input to a CLI – whether it’s
    text in the form of commands, arguments, or flags, or the control characters that
    allow you to quit out of a terminal dashboard. We’ll also discuss different ways
    this input is processed and how to output results back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to have a flag that is accessible to a command and all its subcommands,
    what kind of flag would be defined and how?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What formatting options does Viper accept for configuration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A global flag using the `PersistentFlag()` method when defining a flag on a
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JSON, TOML, YAML, HCL, INI, envfile, and Java properties formats.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Cobra – A Framework for Modern CLI Apps in Go* ([https://cobra.dev/](https://cobra.dev/))
    provides extensive documentation for Cobra with examples utilizing Cobra and links
    to the Viper documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: The Ins and Outs of a CLI'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part focuses on the anatomy of a command-line application and the different
    types of inputs it can receive, such as subcommands, arguments, and flags, as
    well as other inputs such as stdin, signals, and control characters. It also covers
    various methods for processing data and how to return the result, including handling
    errors and timeouts when interacting with external commands or API services. The
    chapter also highlights Go’s cross-platform capabilities using packages such as
    os, time, path, and runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18883_05.xhtml#_idTextAnchor109), *Defining the Command-Line
    Process*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18883_06.xhtml#_idTextAnchor123), *Calling External Processes,
    Handling Errors and Timeouts*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18883_07.xhtml#_idTextAnchor143), *Developing for Different
    Platforms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
