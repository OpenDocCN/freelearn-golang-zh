- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Popular Frameworks for Building CLIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 CLIs 的流行框架
- en: This chapter will explore the most popular frameworks available to assist you
    with rapidly developing modern CLI applications. After seeing all the code that
    it takes to manually create a command and structure a CLI application, you’ll
    see how Cobra allows developers to quickly generate all the scaffolding needed
    for a CLI application and add new commands easily.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨可用于快速开发现代 CLI 应用程序的最受欢迎的框架。在看到手动创建命令和结构化 CLI 应用程序所需的所有代码后，您将看到 Cobra 如何使开发者能够快速生成
    CLI 应用程序所需的全部框架，并轻松添加新命令。
- en: 'Viper easily integrates with Cobra to configure your applications locally or
    remotely using multiple formats. The options are extensive, and developers can
    choose what they feel works best for their project and what they are comfortable
    with. This chapter will give you an in-depth look at Cobra and Viper through the
    following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Viper 可以轻松与 Cobra 集成，以多种格式在本地或远程配置您的应用程序。选项非常广泛，开发者可以选择他们认为最适合他们项目且他们感到舒适的方式。本章将通过以下主题深入探讨
    Cobra 和 Viper：
- en: Cobra – a library for building modern CLI applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cobra – 用于构建现代 CLI 应用程序的库
- en: Viper – easy configuration for CLIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Viper – 为 CLI 提供简单配置
- en: Basic calculator CLI using Cobra and Viper
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cobra 和 Viper 的基本计算器 CLI
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To easily follow along with the code in this chapter, you will need to do the
    following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松跟随本章中的代码，您需要执行以下操作：
- en: 'Install the Cobra CLI: [https://github.com/spf13/cobra-cli](https://github.com/spf13/cobra-cli)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Cobra CLI：[https://github.com/spf13/cobra-cli](https://github.com/spf13/cobra-cli)
- en: 'Get the Cobra package: [https://github.com/spf13/cobra](https://github.com/spf13/cobra)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 Cobra 包：[https://github.com/spf13/cobra](https://github.com/spf13/cobra)
- en: 'Get the Viper package: [https://github.com/spf13/viper](https://github.com/spf13/viper)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 Viper 包：[https://github.com/spf13/viper](https://github.com/spf13/viper)
- en: 'Download the following code: [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter04](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter04)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载以下代码：[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter04](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter04)
- en: Cobra – a library for building modern CLI applications
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cobra – 用于构建现代 CLI 应用程序的库
- en: Cobra is a Go library for building powerful and modern CLI applications. It
    makes defining both simple and complex nested commands easy. The extensive field
    list for the Cobra `Command` object allows you to access the complete self-documenting
    help and man pages. Cobra also offers some fun additional benefits, including
    intelligent shell autocomplete, CLI scaffolding, code generation, and integration
    with the Viper configuration solution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Cobra 是一个 Go 库，用于构建强大且现代的 CLI 应用程序。它使得定义简单和复杂的嵌套命令变得容易。Cobra `Command` 对象的广泛字段列表允许您访问完整的自文档帮助和
    man 页面。Cobra 还提供了一些额外的有趣功能，包括智能 shell 自动完成、CLI 框架、代码生成以及与 Viper 配置解决方案的集成。
- en: 'The Cobra library provides a much more powerful command structure than one
    written from scratch. As mentioned, there are many advantages to using the Cobra
    CLI, so we will dive into a few examples to exhibit its power. Starting a CLI
    with Cobra from scratch only requires three steps. First, make sure that `cobra-cli`
    is properly installed. Create a new folder for your project and follow these steps
    in sequence to set up your new CLI:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Cobra 库提供的命令结构比从头开始编写的命令结构要强大得多。正如之前提到的，使用 Cobra CLI 有许多优点，因此我们将通过一些示例来展示其功能。从头开始使用
    Cobra 创建 CLI 只需要三个步骤。首先，确保 `cobra-cli` 已正确安装。为您的项目创建一个新的文件夹，并按顺序执行以下步骤以设置新的 CLI：
- en: 'Change directories into your project folder, `audiofile-cli`:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到您的项目文件夹，`audiofile-cli`：
- en: '`cd audiofile-cli`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`cd audiofile-cli`'
- en: 'Create a module and initialize your current directory:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模块并初始化您的当前目录：
- en: '`go mod init <``module path>`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`go mod init <模块路径>`'
- en: 'Initialize your Cobra CLI:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化您的 Cobra CLI：
- en: '`cobra-cli init`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`cobra-cli init`'
- en: After running just three commands, `ls` shows that the folder structure is already
    created, and commands are ready to be added. Running the `main.go` file returns
    the default long description, but once commands are added, the audiofile CLI usage
    will be displayed with help and examples instead.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行三个命令，`ls` 就会显示文件夹结构已经创建，并且可以添加命令。运行 `main.go` 文件会返回默认的长描述，但一旦添加了命令，audiofile
    CLI 的用法将显示帮助和示例。
- en: If you run `cobra-cli` on its own to see the options available, you’ll see there
    are only four commands, `add`, `completion`, `help`, and `init`. Since we’ve already
    used `init` to initialize our project, next, we’ll use `add` to create the template
    code for a new command.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你单独运行`cobra-cli`以查看可用的选项，你会看到只有四个命令，`add`、`completion`、`help`和`init`。由于我们已经使用`init`初始化了我们的项目，接下来，我们将使用`add`来创建新命令的模板代码。
- en: Creating subcommands
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建子命令
- en: The fastest way to add a new command from the Cobra CLI is to run the `cobra-cli`
    command, `add`. To get more details on this command, we run `cobra-cli` `add`
    `–help`, which shows us the syntax for running the `add` command.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Cobra CLI 添加新命令最快的方法是运行`cobra-cli`命令，`add`。要获取有关此命令的更多详细信息，我们运行`cobra-cli`
    `add` `–help`，这显示了运行`add`命令的语法。
- en: 'To try to create the example`upload` command from the previous chapter, we
    would run the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试从上一章创建示例`upload`命令，我们会运行以下命令：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s quickly try calling the code that was generated for the `upload` command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速尝试调用为`upload`命令生成的代码：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By default, the `upload called` output is returned. Now, let’s take a look at
    the generated code. Within the same file for the command is an `init` function
    that adds this command to the `root` or `entry` command.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，返回`upload called`输出。现在，让我们看看生成的代码。在同一个文件中，有一个`init`函数，它将此命令添加到`root`或`entry`命令。
- en: 'Let’s clean this file up and fill in some details for our `upload` command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们清理这个文件并为我们`upload`命令填写一些细节：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let’s create these two new subcommands for the `upload` command to specify
    either audio or video:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为`upload`命令创建这两个新的子命令，以指定音频或视频：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We add `audioCmd` and `videoCmd` as subcommands to `uploadCmd`. The `audio`
    command, which contains only the generated code, needs to be modified in order
    to be recognized as a subcommand. Also, we need to define the filename flag for
    the `audio` subcommand. The `init` function of the `audio` command will look as
    follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`audioCmd`和`videoCmd`添加为`uploadCmd`的子命令。仅包含生成代码的`audio`命令需要修改，以便被识别为子命令。此外，我们还需要为`audio`子命令定义文件名标志。`audio`命令的`init`函数将如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Parsing the filename flag happens within the `Run` function. However, we want
    to return an error if the filename flag is missing, so we change the function
    on `audioCmd` to return an error and use the `RunE` method instead:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名标志的解析发生在`Run`函数中。然而，我们希望在文件名标志缺失时返回错误，因此我们将`audioCmd`上的函数更改为返回错误并使用`RunE`方法：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s try this code out first to see whether we get an error when we don’t
    pass in the subcommand, and when we run the proper example command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先尝试这段代码，看看我们是否在未传递子命令时得到错误，以及当我们运行正确的示例命令时：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now get an error message relating to the usage of the `upload` command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在得到一个与`upload`命令使用相关的错误消息：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s correctly run the command with either the shorthand or longhand flag
    name:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们正确地使用简写或长写标志名称运行命令：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The command then returns the expected output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 命令随后返回预期的输出：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ve created a subcommand, `audio`, of the `upload` command. Now the implementations
    for video and audio are called using separate subcommands.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为`upload`命令创建了一个子命令`audio`。现在，视频和音频的实现通过单独的子命令调用。
- en: Global, local, and required flags
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局、本地和必需标志
- en: 'Cobra allows users to define different types of flags: global and local flags.
    Let’s quickly define each type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Cobra 允许用户定义不同类型的标志：全局和本地标志。让我们快速定义每种类型：
- en: 'Global: A global flag is available to the command it is assigned to and every
    subcommand of that command'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局：全局标志对分配给它的命令及其所有子命令可用
- en: 'Local: A local flag is only available to the command it is assigned to'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地：本地标志仅对分配给它的命令可用
- en: 'Notice that both the video and `audio` subcommands require a flag to parse
    the `filename` string. It would probably be easier to set this flag as a global
    flag on `uploadCmd`. Let’s remove the flag definition from the `init` function
    of `audioCmd`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到视频和`audio`子命令都需要一个标志来解析`filename`字符串。可能更容易将此标志设置为`uploadCmd`的全局标志。让我们从`audioCmd`的`init`函数中删除标志定义：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Instead, let’s add it as a global command on `uploadCmd` so that it can also
    be used by `videoCmd`. The `init` function of `uploadCmd` will now look like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们将其添加为`uploadCmd`的全局命令，以便它也可以被`videoCmd`使用。现在`uploadCmd`的`init`函数将如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This `PersistentFlags()` method sets a flag as global and persistent for all
    subcommands. Running the command to `upload` an audio file still works as expected:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `PersistentFlags()` 方法将标志设置为全局和持久，适用于所有子命令。运行命令以 `upload` 音频文件仍然按预期工作：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `audio` subcommand implementation, we check to see whether the filename
    is set. This is an unnecessary step if we make the file required. Let’s change
    `init` to do that:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `audio` 子命令实现中，我们检查文件名是否已设置。如果我们使文件成为必需的，这是一个不必要的步骤。让我们将 `init` 改成这样：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For local flags, the command would be `MarkFlagRequired("filename")`. Now let’s
    try to run the command without passing in the filename flag:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地标志，命令将是 `MarkFlagRequired("filename")`。现在让我们尝试不传递文件名标志来运行该命令：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: An error is thrown by Cobra without having to manually check whether the filename
    flag is parsed. Because the audio and video commands are subcommands to the `upload`
    command, they require the newly defined, persistent filename flag. As expected,
    an error is thrown to remind the user that the filename flag is not set. Another
    way that your CLI application can help guide users is when they incorrectly type
    in a command.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Cobra 会抛出错误，而无需手动检查是否解析了文件名标志。因为音频和视频命令是 `upload` 命令的子命令，它们需要新定义的持久文件名标志。正如预期的那样，会抛出一个错误来提醒用户文件名标志尚未设置。CLI
    应用程序还可以在用户输入命令错误时帮助指导用户。
- en: Intelligent suggestions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能建议
- en: 'By default, Cobra will provide command suggestions if the user has mistyped
    a command. An example is when the command is entered:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果用户输入了错误的命令，Cobra 将提供命令建议。一个例子是当命令输入为：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To disable intelligent suggestions, just add the `rootCmd.DisableSuggestions
    = true` line to the `init` function for the root command. To change the Levenshtein
    distance for suggestions, modify the value of `SuggestionsMinimumDistance` on
    the command. You can also use the `SuggestFor` attribute on a command to explicitly
    state suggestions, which makes sense for commands that are logical substitutes
    but aren’t close in terms of the Levenshtein distance. Another way to guide first-time
    users of your CLI is to provide help and man pages for your application. The Cobra
    framework provides an easy way to automatically generate not only help but also
    man pages.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用智能建议，只需在根命令的 `init` 函数中添加 `rootCmd.DisableSuggestions = true` 行。要更改建议的 Levenshtein
    距离，修改命令上的 `SuggestionsMinimumDistance` 的值。您还可以使用命令上的 `SuggestFor` 属性来明确指定建议，这对于逻辑上是替代品但
    Levenshtein 距离不接近的命令是有意义的。另一种指导 CLI 的首次用户的方法是提供您应用程序的帮助和 man 页面。Cobra 框架提供了一个简单的方法来自动生成帮助和
    man 页面。
- en: Automatically generated help and man pages
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动生成的帮助和 man 页面
- en: 'As we’ve already seen, entering a wrong command, or adding the `-h` or `–help`
    flag to the command, will cause the CLI to return the help documentation, automatically
    generated from the details set within the `cobra.Command` structure. Also, man
    pages may be generated with the addition of the following import: `"github.com/spf13/cobra/doc"`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，输入错误的命令，或者将 `-h` 或 `–help` 标志添加到命令中，将导致 CLI 返回帮助文档，这些文档是自动从 `cobra.Command`
    结构内设置的详细信息生成的。此外，通过添加以下导入可以生成 man 页面：`"github.com/spf13/cobra/doc"`。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Specifics on how to generate man page documentation will be detailed in [*Chapter
    9*](B18883_09.xhtml#_idTextAnchor190), *The Empathic Side of Development*, which
    includes how to write proper help and documentation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如何生成 man 页面文档的详细信息将在 [*第 9 章*](B18883_09.xhtml#_idTextAnchor190) 中详细说明，*开发的同理心一面*，其中包括如何编写正确的帮助和文档。
- en: Powering your CLI
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 CLI 提供动力
- en: As you can see, there are many benefits to using the Cobra library to power
    your CLI, giving many features by default. The library also comes with its own
    CLI for generating scaffolding for a new application and for adding commands,
    which, with all the options available in the `cobra.Command` struct, gives you
    everything needed to build a robust and highly customizable CLI.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用 Cobra 库为 CLI 提供动力有许多好处，默认提供了许多功能。该库还附带了自己的 CLI，用于为新的应用程序生成脚手架以及添加命令，这些命令在
    `cobra.Command` 结构中提供了所有可用的选项，使您能够构建一个强大且高度可定制的 CLI。
- en: 'Compared to writing your CLI from scratch without a framework, you can save
    hours of your time with many of the built-in advantages: command scaffolding,
    excellent command, argument, and flag parsing, intelligent suggestions, and autogenerated
    help text and man pages. You can also pair your Cobra CLI with Viper to configure
    your application for additional benefits.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与从头开始编写 CLI 而不使用框架相比，您可以使用许多内置优势节省数小时的时间：命令脚手架、优秀的命令、参数和标志解析、智能建议以及自动生成的帮助文本和
    man 页面。您还可以将 Cobra CLI 与 Viper 配对，以获得额外的优势来配置您的应用程序。
- en: Viper – easy configuration for CLIs
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Viper – CLI 的简单配置
- en: Steve Francia, author of Cobra, also created a configuration tool, Viper, to
    easily integrate with Cobra. For a simple application that you’re running locally
    on your machine, you may not initially need a configuration tool. However, if
    your application may run within different environments that require different
    integrations, API keys, or general customizations that are better in a config
    file versus hardcoded, Viper will help ease the process of configuring your app.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Steve Francia，Cobra 的作者，还创建了一个配置工具 Viper，以便轻松与 Cobra 集成。对于您在本地机器上运行的单个简单应用程序，您可能最初不需要配置工具。然而，如果您的应用程序可能运行在不同的环境中，这些环境需要不同的集成、API
    密钥或更适用于配置文件而不是硬编码的一般自定义，Viper 将帮助简化配置应用程序的过程。
- en: Configuration types
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置类型
- en: 'There are many ways Viper allows you to set your application’s configuration:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Viper 允许您以多种方式设置应用程序的配置：
- en: Reading from configuration files
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从配置文件中读取
- en: With environment variables
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: With remote config systems
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程配置系统
- en: With command-line flags
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行标志
- en: With a buffer
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓冲区
- en: The configuration formats accepted from these configuration types include JSON,
    TOML, YAML, HCL, INI, envfile, and Java properties formats. To get a better understanding,
    let’s go over an example of each configuration type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置类型接受的配置格式包括 JSON、TOML、YAML、HCL、INI、envfile 和 Java 属性格式。为了更好地理解，让我们逐一介绍每种配置类型。
- en: Config file
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置文件
- en: 'Suppose we have different URL and port values to connect to depending on different
    environments. We could set up a YAML configuration file, `config.yml`, that looks
    like this and is stored within the main folder of our application:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们根据不同的环境需要连接到不同的 URL 和端口值。我们可以设置一个 YAML 配置文件 `config.yml`，其外观如下，并存储在我们的应用程序的主文件夹中：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use the code to read in the configuration and test, printing out the prod environment’s
    URL:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码读取配置并测试，打印出生产环境的 URL：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Running the code confirms that `Println` will return `environments.prod.url`
    as `123.23.45.89`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码确认 `Println` 将返回 `environments.prod.url` 为 `123.23.45.89`。
- en: Environment variable
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量
- en: Configuration may also be set via environment variables; just note that Viper’s
    recognition of environment variables is case sensitive. There are a few methods
    that can be used when working with environment variables.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 配置也可以通过环境变量设置；请注意，Viper 对环境变量的识别是区分大小写的。在处理环境变量时，可以使用几种方法。
- en: '`SetEnvPrefix` tells Viper that the environment variables used with the `BindEnv`
    and `AutomaticEnv` methods will be prefixed with a specific unique value. For
    example, say the test URL is set within an environment variable:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetEnvPrefix` 告诉 Viper，使用 `BindEnv` 和 `AutomaticEnv` 方法时使用的环境变量将被添加一个特定的唯一前缀。例如，假设测试
    URL 是通过环境变量设置的：'
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As mentioned, the prefix, `AUDIOFILE`, affixes to the start of each environment
    variable passed into the `BindEnv` or `Get` method. When the preceding code is
    run, the value printed for the test environment URL from the `AUDIOFILE_TEST_URL`
    environment variable is `89.45.23.123`, as expected.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，前缀 `AUDIOFILE` 附加到传递给 `BindEnv` 或 `Get` 方法的每个环境变量的开头。当运行前面的代码时，从 `AUDIOFILE_TEST_URL`
    环境变量打印出的测试环境 URL 值为 `89.45.23.123`，正如预期的那样。
- en: Command-line flags
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行标志
- en: 'Viper supports configuration via several different types of flags:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Viper 支持通过几种不同类型的标志进行配置。
- en: 'Flags: Flags defined using the standard Go library flag package'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志：使用标准 Go 库 flag 包定义的标志
- en: 'Pflags: Flags defined using Cobra/Viper’s `pflag` definition'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pflags：使用 Cobra/Viper 的 `pflag` 定义定义的标志
- en: 'Flag interfaces: Custom structures that satisfy a flag interface required by
    Viper'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志接口：满足 Viper 所需的标志接口的自定义结构
- en: Let’s check out each of these in detail.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查这些内容。
- en: Flags
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标志
- en: Building on top of the standard Go flag package. The Viper `flags` package extends
    the functionality of the standard flag package, providing additional features
    such as environment variable support and the ability to set default values for
    flags. With Viper flags, you can define flags for string, Boolean, integer, and
    floating-point types, as well as for arrays of these types.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准 Go 标志包的基础上构建。Viper 的 `flags` 包扩展了标准标志包的功能，提供了额外的特性，例如环境变量支持和为标志设置默认值的能力。使用
    Viper 标志，您可以定义字符串、布尔值、整数和浮点数类型的标志，以及这些类型的数组。
- en: 'Some example code may look as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例代码可能如下所示：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, we set default values for the “`host`” and “`port`”
    flags and then bind them to environment variables using `viper.BindEnv`. After
    setting the environment variables, we can access the values of the flags using
    `viper.GetString("host")` and `viper.GetInt("port")`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们为“`host`”和“`port`”标志设置了默认值，然后使用 `viper.BindEnv` 将它们绑定到环境变量。设置环境变量后，我们可以使用
    `viper.GetString("host")` 和 `viper.GetInt("port")` 访问标志的值。
- en: Pflags
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pflags
- en: '`pflag` is the flag package specific to Cobra and Viper. The values can be
    parsed and bound. `viper.BindPFFlag`, for individual flags, and `viper.BindPFFlags`,
    for flag sets, are used to bind the value of the flag when it is accessed rather
    than defined.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`pflag` 是 Cobra 和 Viper 特定的标志包。值可以被解析和绑定。`viper.BindPFFlag` 用于单个标志，而 `viper.BindPFFlags`
    用于标志集，用于在访问时绑定标志的值，而不是在定义时。'
- en: 'Once the flags are parsed and bound, the values can be accessed anywhere in
    the code using Viper’s `Get` methods. For retrieving the port, we’d use the following
    code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解析并绑定标志，就可以使用 Viper 的 `Get` 方法在任何代码位置访问这些值。为了检索端口，我们会使用以下代码：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Within the `init` function, you can define a command-line flag set and bind
    the values once they are accessed. Take the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init` 函数中，您可以定义一个命令行标志集，并在访问值后绑定它们。以下是一个示例：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Flag interfaces
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标志接口
- en: 'Viper also allows custom flags that satisfy the following Go interfaces: `FlagValue`
    and `FlagValueSet`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Viper 还允许自定义标志，这些标志满足以下 Go 接口：`FlagValue` 和 `FlagValueSet`。
- en: 'The `FlagValue` interface is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlagValue` 接口如下：'
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The second interface that Viper accepts is `FlagValueSet`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Viper 接受的第二个接口是 `FlagValueSet`：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'An example of code that satisfies this interface is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 满足此接口的代码示例如下：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Buffer
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲区
- en: 'Finally, Viper allows users to configure their applications with a buffer.
    Using the same value that exists within the configuration file in the first example,
    we pass the YAML data in as a raw string into a byte slice:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Viper 允许用户使用缓冲区来配置他们的应用程序。使用第一个示例中配置文件中存在的相同值，我们将 YAML 数据作为原始字符串传递到一个字节切片中：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that you know the different types or ways of configuring your command-line
    application – from a file, environment variable, flags, or buffer – let’s see
    how to watch for live changes on these configuration types.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了配置您的命令行应用程序的不同类型或方式——从文件、环境变量、标志或缓冲区——让我们看看如何监视这些配置类型的实时更改。
- en: Watching for live config changes
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视实时配置更改
- en: 'Both remote and local configurations can be watched. After making sure all
    configuration paths are added, call the `WatchConfig` method to watch for any
    live changes and take action by implementing a function to pass into the `OnConfigChange`
    method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可以监视远程和本地配置。确保所有配置路径都已添加后，调用 `WatchConfig` 方法来监视任何实时更改，并通过实现一个函数传递给 `OnConfigChange`
    方法来采取行动：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To watch for changes on a remote config, first, read in the remote config using
    `ReadRemoteConfig()`, and on the instance of the Viper configuration, call the
    `WatchRemoteConfig()` method. Some sample code is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要监视远程配置的更改，首先使用 `ReadRemoteConfig()` 读取远程配置，然后在 Viper 配置实例上调用 `WatchRemoteConfig()`
    方法。以下是一些示例代码：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is an example of a goroutine that will continuously watch for
    remote configuration changes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例 goroutine，它将连续监视远程配置的更改：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I think that there’s much to benefit from utilizing a configuration library
    rather than starting from scratch, which again can save you hours and expedite
    your development process. Besides the different ways you can configure your application,
    you can also provide remote configuration and watch for any changes live. This
    further creates a more robust application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为利用配置库而不是从头开始有很多好处，这再次可以节省您数小时并加快您的开发过程。除了您可以为应用程序配置的不同方式外，您还可以提供远程配置并实时监视任何更改。这进一步创建了一个更健壮的应用程序。
- en: Basic calculator CLI using Cobra and Viper
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cobra和Viper的基本计算器CLI
- en: Let us pull some of the pieces together and create a separate and simple CLI
    using the Cobra CLI framework and Viper for configuration. A simple idea that
    we can easily implement is a basic calculator that can add, subtract, multiply,
    and divide values. The code for this demo exists within the `Chapter-4-Demo` repository
    for you to follow along.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一些部分组合起来，使用Cobra CLI框架和Viper创建一个独立且简单的CLI。一个我们可以轻松实现的基本想法是能够进行加、减、乘、除的基本计算器。这个演示的代码位于`Chapter-4-Demo`仓库中，供您参考。
- en: The Cobra CLI commands
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cobra CLI命令
- en: 'The commands are created with the following `cobra-cli` command calls:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是通过以下`cobra-cli`命令调用来创建的：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Calling these commands successfully generates the code for each command, ready
    for us to fill in the details. Let us show each command and how they each are
    similar and different.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用这些命令将生成每个命令的代码，以便我们填充细节。让我们展示每个命令以及它们各自相似和不同的地方。
- en: The add command
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加命令
- en: 'The `add` command, `addCmd`, is defined as a pointer to the `cobra.Command`
    type. Here, we set the fields for the command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`命令`addCmd`被定义为`cobra.Command`类型的指针。在这里，我们设置了命令的字段：'
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let us take a quick walk through the `Run` field, which is a first-class function.
    Before doing any calculations, we check `args`. The command only takes one numerical
    field; any more or less will print a usage statement and return the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下`Run`字段，它是一个一等函数。在进行任何计算之前，我们检查`args`。命令只接受一个数值字段；如果更多或更少，将打印用法说明并返回以下内容：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We take the first and only argument, return it, set it within `args[0]`, and
    parse it to a flat variable using the following code. If the conversion to a `float64`
    value fails, then the command prints out a message about being unable to parse
    the input and then returns:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取第一个且唯一的参数，返回它，将其设置在`args[0]`中，并使用以下代码将其解析为一个扁平变量。如果转换到`float64`值失败，则命令会打印出无法解析输入的消息，然后返回：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the conversion is successful, and no errors are returned from the string
    conversion, then we have a value set for `floatVal`. In our basic calculator CLI,
    we are storing the value in a file, which is the simplest way to store it for
    this example. The `storage` package and how Viper is used in configuration will
    be discussed after the commands. At an elevated level, we get the current value
    from storage and apply the operation to `floatVal`, and then save it back into
    storage:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果转换成功，并且字符串转换没有返回错误，那么我们为`floatVal`设置了一个值。在我们的基本计算器CLI中，我们将其存储在文件中，这是本例中存储它的最简单方式。`storage`包和Viper在配置中的使用将在命令之后讨论。在更高层次上，我们从存储中获取当前值，将其应用于`floatVal`，然后将其保存回存储：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Last but not least, the value is printed back to the user:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，将值打印回用户：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That concludes our look at the `Run` function of the `add` command. The `Use`
    field describes the usage, and the `Short` field gives a brief description of
    the command. This concludes the walk-through of the add command. The subtract,
    multiply, and divide `Run` functions on their respective commands are remarkably
    similar, so I will just point out some differences to note.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对`add`命令的`Run`函数的探讨。`Use`字段描述了用法，`Short`字段给出了命令的简要描述。这就结束了添加命令的浏览。在各自的命令上，减法、乘法和除法的`Run`函数非常相似，所以我只会指出一些需要注意的差异。
- en: The subtract command
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减法命令
- en: 'The same code is used for `subtractCmd`’s `Run` function with just a small
    exception. Instead of adding the value to `floatVal`, we subtract it with the
    following line:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`subtractCmd`的`Run`函数使用了相同的代码，只有一个小的例外。我们不是将值添加到`floatVal`，而是用以下行进行减法操作：'
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The multiply command
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘法命令
- en: 'The same code is used for `multiplyCmd`’s `Run` function, except we multiply
    it with the following line:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的代码用于`multiplyCmd`的`Run`函数，除了我们用以下行进行乘法操作：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The divide command
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除法命令
- en: 'Finally, the same code is used for `divideCmd`’s `Run` function, except for
    dividing it by `floatVal`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，同样的代码用于`divideCmd`的`Run`函数，除了用`floatVal`进行除法操作：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The clear command
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除命令
- en: 'The `clear` command resets the stored value to `0`. The code for `clearCmd`
    is short and simple:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear`命令将存储的值重置为`0`。`clearCmd`的代码简短且简单：'
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We check whether any `args` are passed in, and if so, we print that the command
    does not accept any arguments and return. If the command is called `./calculator
    clear`, then the `0` value is stored and then printed back to the user.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查是否传递了任何 `args`，如果是，则打印该命令不接受任何参数并返回。如果命令是 `./calculator clear`，则存储 `0` 值并将其打印回用户。
- en: The Viper configuration
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Viper 配置
- en: Let’s now discuss a simple way to use Viper configuration. In order to keep
    track of the value that has operations applied to it, we need to store this value.
    The easiest way to store data is in a file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论使用 Viper 配置的简单方法。为了跟踪对其应用了操作的值，我们需要存储此值。存储数据的最简单方法是将其保存在文件中。
- en: The storage package
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储包
- en: 'Within the repository, there’s a file, `storage/storage.go`, with the following
    code to set the value:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，有一个名为 `storage/storage.go` 的文件，其中包含以下代码来设置值：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This code will write the data to the filename returned from `viper.GetString("filename")`.
    The code to get the value from the file is defined with the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将数据写入 `viper.GetString("filename")` 返回的文件名。从文件获取值的代码如下：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Again, the same method is used to get the filename, to read, parse, and then
    return the data contained.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，获取文件名、读取、解析然后返回包含的数据的方法是相同的。
- en: Initializing the configuration
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化配置
- en: 'Inside the `main` function, we call the Viper methods to initialize our configuration
    right before we execute the command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们在执行命令之前调用 Viper 方法来初始化我们的配置：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `AddConfigPath` method is used to set the path for Viper to search for the
    configuration file. The `SetConfigName` method allows you to set the name of the
    configuration file, without the extension. The actual configuration file is `config.json`,
    but we pass in `config`. Finally, the `ReadInConfig` method reads in the configuration
    to make it available throughout the application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddConfigPath` 方法用于设置 Viper 搜索配置文件的路径。`SetConfigName` 方法允许你设置配置文件名，不带扩展名。实际的配置文件是
    `config.json`，但我们传递 `config`。最后，`ReadInConfig` 方法读取配置，使其在整个应用程序中可用。'
- en: The configuration file
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置文件
- en: 'Finally, the configuration file, `config.json`, stores the value for the filename:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，配置文件 `config.json` 存储文件名值：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This file location can work for a UNIX- or Linux-based system. Change this to
    suit your platform and try the demo out for yourself!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件位置适用于基于 UNIX 或 Linux 的系统。根据您的平台进行更改，并亲自尝试演示！
- en: Running the basic calculator
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行基本计算器
- en: To quickly build the basic calculator on UNIX or Linux, run `go build -o calculator
    main.go`. On Windows, run `go build -o` `calculator.exe main.go`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 UNIX 或 Linux 上快速构建基本计算器，请运行 `go build -o calculator main.go`。在 Windows 上，请运行
    `go build -o calculator.exe main.go`。
- en: 'I ran this application on my UNIX-based terminal and got the following output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的基于 UNIX 的终端上运行了这个应用程序，并得到了以下输出：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Hopefully, this simple demo has provided you with a good understanding of how
    you can use the Cobra CLI to help speed up development and Viper for a simple
    way to configure your application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个简单的演示能让你对如何使用 Cobra CLI 加速开发以及 Viper 以简单方式配置应用程序有一个良好的理解。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter took you through the most popular library for building modern CLIs
    – Cobra – and its partner library for configuration – Viper. The Cobra package
    was explained in detail and the CLI’s usage with examples was also described.
    We went through examples to take you through generating your initial application
    code with the Cobra CLI, adding new commands and modifying the scaffolding, to
    autogenerate useful help and man pages. Viper, as a configuration tool that fits
    perfectly alongside Cobra, was also described, along with many of its options,
    in detail.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了构建现代 CLI 最受欢迎的库——Cobra——及其配置伙伴库——Viper。详细解释了 Cobra 包，并使用示例描述了 CLI 的用法。我们通过示例引导你使用
    Cobra CLI 生成初始应用程序代码，添加新命令和修改脚手架，以自动生成有用的帮助和 man 页面。Viper 作为与 Cobra 完美搭配的配置工具，其许多选项也进行了详细描述。
- en: In the next chapter, we’ll discuss how to handle input to a CLI – whether it’s
    text in the form of commands, arguments, or flags, or the control characters that
    allow you to quit out of a terminal dashboard. We’ll also discuss different ways
    this input is processed and how to output results back to the user.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何处理 CLI 的输入——无论是命令、参数或标志形式的文本，还是允许你退出终端仪表板的控制字符。我们还将讨论处理这种输入的不同方式以及如何将结果输出给用户。
- en: Questions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: If you want to have a flag that is accessible to a command and all its subcommands,
    what kind of flag would be defined and how?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想定义一个可以被命令及其所有子命令访问的标志，应该定义什么样的标志以及如何定义？
- en: What formatting options does Viper accept for configuration?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Viper接受哪些配置格式选项？
- en: Answers
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A global flag using the `PersistentFlag()` method when defining a flag on a
    command.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义命令上的标志时使用`PersistentFlag()`方法创建的全局标志。
- en: JSON, TOML, YAML, HCL, INI, envfile, and Java properties formats.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON、TOML、YAML、HCL、INI、envfile和Java属性格式。
- en: Further reading
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Cobra – A Framework for Modern CLI Apps in Go* ([https://cobra.dev/](https://cobra.dev/))
    provides extensive documentation for Cobra with examples utilizing Cobra and links
    to the Viper documentation'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cobra – Go中现代CLI应用程序的框架* ([https://cobra.dev/](https://cobra.dev/)) 为Cobra提供了广泛的文档，包括使用Cobra的示例以及指向Viper文档的链接'
- en: 'Part 2: The Ins and Outs of a CLI'
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：CLI的内外
- en: This part focuses on the anatomy of a command-line application and the different
    types of inputs it can receive, such as subcommands, arguments, and flags, as
    well as other inputs such as stdin, signals, and control characters. It also covers
    various methods for processing data and how to return the result, including handling
    errors and timeouts when interacting with external commands or API services. The
    chapter also highlights Go’s cross-platform capabilities using packages such as
    os, time, path, and runtime.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分重点介绍命令行应用程序的解剖结构以及它可以接收的不同类型的输入，例如子命令、参数和标志，以及其他输入，如标准输入、信号和控制字符。它还涵盖了处理数据的不同方法以及如何返回结果，包括与外部命令或API服务交互时处理错误和超时。本章还突出了Go的跨平台能力，使用诸如os、time、path和runtime等包。
- en: 'This part has the following chapters:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B18883_05.xhtml#_idTextAnchor109), *Defining the Command-Line
    Process*'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18883_05.xhtml#_idTextAnchor109)，*定义命令行进程*'
- en: '[*Chapter 6*](B18883_06.xhtml#_idTextAnchor123), *Calling External Processes,
    Handling Errors and Timeouts*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18883_06.xhtml#_idTextAnchor123)，*调用外部进程，处理错误和超时*'
- en: '[*Chapter 7*](B18883_07.xhtml#_idTextAnchor143), *Developing for Different
    Platforms*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18883_07.xhtml#_idTextAnchor143)，*为不同平台开发*'
