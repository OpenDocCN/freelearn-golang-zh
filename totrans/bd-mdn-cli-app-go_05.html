<html><head></head><body>
		<div id="_idContainer042">
			<h1 id="_idParaDest-109" class="chapter-number"><a id="_idTextAnchor109"/>5</h1>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Defining the Command-Line Process</h1>
			<p>At the core of a command-line application is its ability to process user input and return a result that either a user can easily comprehend or that another process can read as standard input. In <a href="B18883_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Understanding CLI Standards</em>, we discussed the anatomy of a command-line application, but this chapter will go into detail on each aspect of its anatomy, breaking down the different types of input: subcommands, arguments, and flags. Additionally, other inputs will be discussed: <strong class="source-inline">stdin</strong>, signals, and <span class="No-Break">control characters.</span></p>
			<p>Just as there are many types of input that a command-line application can receive, there are many types of methods for processing data. This chapter won’t leave you hanging – examples of processing for each input type <span class="No-Break">will follow.</span></p>
			<p>Finally, it’s just as important to understand how to return the result, either data if successful or an error on failure, in a way that both humans and computers can <span class="No-Break">easily interpret.</span></p>
			<p>This chapter will cover how to output the data for each end user and the best practices for CLI success. We will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Receiving the input and <span class="No-Break">user interaction</span></li>
				<li><span class="No-Break">Processing data</span></li>
				<li>Returning the resulting output and defining <span class="No-Break">best practices</span></li>
			</ul>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/>Technical requirements</h1>
			<p>To easily follow along with the code in this chapter, you will need to do <span class="No-Break">the following:</span></p>
			<p>Download the following <span class="No-Break">code: </span><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-In-Go/tree/main/Chapter05/application"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-CLI-Applications-In-Go/tree/main/Chapter05/application</span></a><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-In-Go/tree/main/Chapter05 "/></p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>Receiving the input and user interaction</h1>
			<p>The primary <a id="_idIndexMarker312"/>methods for receiving input via a command-line application are through its subcommands, arguments, and options, also <a id="_idIndexMarker313"/>known as <strong class="bold">flags</strong>. However, additional input can come in the form of <strong class="source-inline">stdin</strong>, signals, and control characters. In this <a id="_idIndexMarker314"/>section, we’ll break down each different input type and when and how to interact with <span class="No-Break">the user.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/>Defining subcommands, arguments, and flags</h2>
			<p>Before we start characterizing the main types of input, let’s reiterate the structural pattern that explains the<a id="_idIndexMarker315"/> generalized location for each input type in terms of its predictability and familiarity. There’s an excellent description of the pattern within the <strong class="bold">Cobra Framework documentation</strong>. This is one of the best explanations because it compares the structure to natural language and, just like speaking and writing, the syntax needs to be <span class="No-Break">properly interpreted:</span></p>
			<pre class="source-code">
APPNAME NOUN VERB –ADJECTIVE</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="bold">argument</strong> is <a id="_idIndexMarker316"/>the noun and the <strong class="bold">command or subcommand(s)</strong> is the verb. Like any modifier, the <strong class="bold">flag</strong> is an adjective and <span class="No-Break">adds description.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Most other programming languages suggest using two dashes instead of one. Go is unique in the fact that the single dash and double dash are equivalent to the internal flag package. It is important to note, however, that the Cobra CLI flag does differentiate between single and double dashes, where a single dash is for a short-form flag, and the double dash is for a <span class="No-Break">long-form flag.</span></p>
			<p>In the preceding example, the command and argument, or <strong class="source-inline">NOUN VERB</strong>, can also be ordered as <strong class="source-inline">VERB NOUN</strong>. However, <strong class="source-inline">NOUN VERB</strong> is more commonly used.  Use what makes sense <span class="No-Break">to you:</span></p>
			<pre class="source-code">
APPNAME ARGUMENT &lt;COMMAND | SUBCOMMANDS&gt; --FLAG</pre>
			<p>You might run up against limitations depending on your command-line parser. However, if possible, make arguments, flags, and subcommands order-independent. Now, let’s define each in more detail next and use <strong class="bold">Cobra</strong> to create a command that utilizes each <span class="No-Break">input type.</span></p>
			<h3>Commands and subcommands</h3>
			<p>At a very<a id="_idIndexMarker317"/> basic level, a<a id="_idIndexMarker318"/> command is a specific instruction<a id="_idIndexMarker319"/> given to a command-line application. In the pattern we just looked at, these are verbs. Think of the way we naturally speak. If we were to talk to a dog, we’d give it commands such as “<em class="italic">roll over</em>,” “<em class="italic">speak</em>,” or “<em class="italic">stay</em>.” Since you define the <a id="_idIndexMarker320"/>application, you can choose the verbs to define instructions. However, the most important thing to remember when choosing a command (and subcommand) is for names to be clear <span class="No-Break">and consistent.</span></p>
			<p>Ambiguity can cause a lot of stress for a new user. Suppose you have two commands: <strong class="source-inline">yarn update</strong> and <strong class="source-inline">yarn upgrade</strong>. For a developer who is using <strong class="source-inline">yarn</strong> for the first time, do you think it’s clear how these commands are different? Clarity is paramount. Not only does it make your application easier to use but it also puts your developer <span class="No-Break">at ease.</span></p>
			<p>As you gain a broad view of your application, you can intuitively determine more clear and more concise language when defining your commands. If your application feels a bit complex, you can utilize subcommands for simplification, and whenever possible, use familiar words for both commands <span class="No-Break">and subcommands.</span></p>
			<p>Let’s use the <strong class="bold">Docker</strong> application as an example of how subcommands are clearly defined. Docker has a list of management commands such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">container</strong> to <span class="No-Break">manage containers</span></li>
				<li><strong class="source-inline">image</strong> to <span class="No-Break">manage images</span></li>
			</ul>
			<p>You’ll notice that when you run <strong class="source-inline">docker</strong> <strong class="source-inline">container</strong> or <strong class="source-inline">docker</strong> <strong class="source-inline">image</strong>, the usage is printed out, along with a list of subcommands, and you’ll also notice that there are several subcommands used across these two commands. They <span class="No-Break">remain consistent.</span></p>
			<p>Users of Docker know that the action (<strong class="source-inline">ls</strong>, <strong class="source-inline">rm</strong>, or <strong class="source-inline">inspect</strong>, for example) is related to the subject (<strong class="source-inline">image</strong> or <strong class="source-inline">container</strong>). The command follows the expected pattern of <strong class="source-inline">"APPNAME ARGUMENT COMMAND"</strong> – <strong class="source-inline">docker</strong> <strong class="source-inline">image</strong> <strong class="source-inline">ls</strong> and <strong class="source-inline">docker</strong> <strong class="source-inline">container</strong> <strong class="source-inline">ls</strong> too. Notice that <strong class="source-inline">docker</strong> also uses familiar Unix commands – <strong class="source-inline">ls</strong> and <strong class="source-inline">rm</strong>. Always use a familiar command where <span class="No-Break">you can.</span></p>
			<p>Using the Cobra CLI, let’s make two commands, with one as a subcommand of the other. Here’s the first command <span class="No-Break">we’ll add:</span></p>
			<pre class="console">
cobra-cli add command
command created at /Users/marian/go/src/github.com/
  marianina8/application</pre>
			<p>Then, add <a id="_idIndexMarker321"/><span class="No-Break">the subcommand:</span></p>
			<pre class="console">
cobra-cli add subcommand
subcommand created at /Users/marian/go/src/github.com/
  marianina8/application</pre>
			<p>Then, create it as a <a id="_idIndexMarker322"/>subcommand by modifying the default line to run <strong class="source-inline">AddCommand</strong> <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">commandCmd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func init() {
    commandCmd.AddCommand(subcommandCmd)
}</pre>
			<p>The Cobra CLI makes it incredibly easy not only to create commands but also subcommands as well. Now, when the command is called with the subcommand, we get confirmation that the subcommand <span class="No-Break">is called:</span></p>
			<pre class="console">
./application command subcommand
subcommand called</pre>
			<p>Now, let us <span class="No-Break">understand arguments.</span></p>
			<h3>Arguments</h3>
			<p>Arguments<a id="_idIndexMarker323"/> are nouns – things – that are acted upon by the command. They <a id="_idIndexMarker324"/>are positional to the command and usually come before the command. The order is not strict; just be consistent with the order throughout your application. However, the very first argument is the <span class="No-Break">application name.</span></p>
			<p>Multiple arguments are okay for actions against multiple files, or multiple strings of input. Take, for example, the <strong class="source-inline">rm</strong> command and removing multiple files. For example, <strong class="source-inline">rm arg1.txt arg2.txt arg3.txt</strong> would act on (by removing) the multiple files listed after the command. Allow globbing where it makes sense. If a user wants to remove all the text files in the current directory, then an example of <strong class="source-inline">rm *.txt</strong> would also be <a id="_idIndexMarker325"/>expected to work. Now, consider the <strong class="source-inline">mv</strong> command, which requires two arguments for the source and target files. An example of <strong class="source-inline">mv old.txt new.txt</strong> will move <strong class="source-inline">old.txt</strong>, the source, to the target, <strong class="source-inline">new.txt</strong>. Globs may also be used with <span class="No-Break">this</span><span class="No-Break"><a id="_idIndexMarker326"/></span><span class="No-Break"> command.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Having multiple arguments for <em class="italic">different</em> things might mean rethinking the way that you’re structuring your command. It could also mean that you could be utilizing flags <span class="No-Break">here instead.</span></p>
			<p>Again, familiarity plays in your favor. Use the standard name if there is one and your users will thank you. Here are examples of some common arguments: <strong class="source-inline">history</strong>, <strong class="source-inline">tag</strong>, <strong class="source-inline">volume</strong>, <strong class="source-inline">log</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">service</strong></span><span class="No-Break">.</span></p>
			<p>Let’s modify the subcommand’s generated <strong class="source-inline">Run</strong> field to identify and print out <span class="No-Break">its arguments:</span></p>
			<pre class="source-code">
Run: func(cmd *cobra.Command, args []string) {
    if len(args) == 0 {
        fmt.Println("subcommand called")
    } else {
        fmt.Println("subcommand called with arguments: ",
          args)
    }
},</pre>
			<p>Now, when we run the same subcommand with arguments, the following output is <span class="No-Break">printed out:</span></p>
			<pre class="console">
  ./application command subcommand argument1 argument2
subcommand called with arguments:  [argument1 argument2]</pre>
			<p>Interestingly, flags can provide more clarity over arguments. In general, it does require more typing, but flags can make it more clear what’s going on. Another additional benefit is if<a id="_idIndexMarker327"/> you <a id="_idIndexMarker328"/>decide to make changes to how you receive input, it’s much easier to add or remove a flag than it is to modify an existing command, which can <span class="No-Break">break things.</span></p>
			<h3>Flags</h3>
			<p>Flags are<a id="_idIndexMarker329"/> adjectives<a id="_idIndexMarker330"/> that add a description to an action or command. They are named parameters and can be denoted in different ways, with or without a <span class="No-Break">user-specified value:</span></p>
			<ul>
				<li>A <strong class="bold">hyphen with a single-letter </strong><span class="No-Break"><strong class="bold">name</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">-h</strong></span><span class="No-Break">)</span></li>
				<li>A <strong class="bold">double-hyphen with a multiple-letter </strong><span class="No-Break"><strong class="bold">name</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">--help</strong></span><span class="No-Break">)</span></li>
				<li>A <strong class="bold">double-hyphen with a multiple-letter name and a user-specified value</strong> (<strong class="source-inline">--file audio.txt</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">–-file=audio.txt</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>It’s important to have full-length versions of all flags – single letters are only useful for commonly used flags. If you use single letters for all available flags, there may be more than one flag that starts with that same letter, and that single letter would make sense intuitively for more than one flag. This can add confusion, so it’s best not to clutter the list of <span class="No-Break">single-letter flags.</span></p>
			<p>Single-letter flags may also be concatenated together. For example, take the <strong class="source-inline">ls</strong> command. You can run <strong class="source-inline">ls -l -h -F</strong> or <strong class="source-inline">ls -lhF</strong> and the result is the same. Obviously, this depends on the command-line parser used, but because CLI applications typically allow you to concatenate single-letter flags, it’s a good idea to allow this <span class="No-Break">as well.</span></p>
			<p>Finally, the flag order is typically not strict, so whether a user runs <strong class="source-inline">ls –lhF</strong>, <strong class="source-inline">ls –hFl</strong>, or <strong class="source-inline">ls –Flh</strong>, the result is <span class="No-Break">the same.</span></p>
			<p>As an example, we can add a couple of flags to the root command, one local and another persistent, meaning that it’s available to the command and all subcommands. In <strong class="source-inline">commandCmd</strong>, within the <strong class="source-inline">init()</strong> function, the following lines do <span class="No-Break">just that:</span></p>
			<pre class="console">
commandCmd.Flags().String("localFlag", "", "a local string
  flag")
commandCmd.PersistentFlags().Bool("persistentFlag", false,
  "a persistent boolean flag")</pre>
			<p>In <strong class="source-inline">commandCmd</strong>’s <strong class="source-inline">Run</strong> field, we add <span class="No-Break">these lines:</span></p>
			<pre class="source-code">
localFlag, _ := cmd.Flags().GetString("localFlag")
if localFlag != "" {
    fmt.Printf("localFlag is set to %s\n", localFlag)
}</pre>
			<p>In <strong class="source-inline">subcommandCmd</strong>’s <strong class="source-inline">Run</strong> field, we also add the <span class="No-Break">following lines:</span></p>
			<pre class="source-code">
persistentFlag, _ := cmd.Flags().GetBool("persistentFlag")
fmt.Printf("persistentFlag is set to %v\n", persistentFlag)</pre>
			<p>Now, when <a id="_idIndexMarker331"/>we <a id="_idIndexMarker332"/>compile the code and run it again, we can test out both flags. Notice that there are multiple ways of passing in flags and in both cases, the results are <span class="No-Break">the same:</span></p>
			<pre class="source-code">
  ./application command --localFlag=”123”
command called
localFlag is set to 123
  ./application command --localFlag “123”
command called
localFlag is set to 123</pre>
			<p>The persistent flag, although defined at the <strong class="source-inline">commandCmd</strong> level, is available within <strong class="source-inline">subcommandCmd</strong>, and when the flag is missing, the default value <span class="No-Break">is used:</span></p>
			<pre class="source-code">
  ./application command subcommand
subcommand called
persistentFlag is set to false
  ./application command subcommand --persistentFlag
subcommand called
persistentFlag is set to true</pre>
			<p>Now, we’ve covered the most common methods of receiving input to your CLI: commands, arguments, and flags. The next methods of input include piping, signal and control characters, and direct user interaction. Let’s dive into <span class="No-Break">these now.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>Piping</h2>
			<p>In Unix, piping <a id="_idIndexMarker333"/>redirects the standard output of one command-line application into the standard input of another. It is represented by the ‘<strong class="source-inline">|</strong>’ character, which combines two or more commands. The general structure is <strong class="source-inline">cmd1 | cmd2 |cmd3 | .... | cmdN</strong>, the standard output from <strong class="source-inline">cmd1</strong> is the standard input for <strong class="source-inline">cmd2</strong>, and <span class="No-Break">so on.</span></p>
			<p>Creating a simple command-line application that does one thing and one thing well follows the Unix philosophy. It reduces the complexity of a single CLI, so you’ll see many examples of different applications that can be chained together by pipes. Here are a <span class="No-Break">few examples:</span></p>
			<ul>
				<li><strong class="source-inline">cat file.txt | grep "word" | </strong><span class="No-Break"><strong class="source-inline">sort</strong></span></li>
				<li><strong class="source-inline">sort list.txt | </strong><span class="No-Break"><strong class="source-inline">uniq</strong></span></li>
				<li><strong class="source-inline">find . -type f –name main.go | </strong><span class="No-Break"><strong class="source-inline">grep audio</strong></span></li>
			</ul>
			<p>As an example, let’s create a command that takes in standard input from a common application.  Let’s call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">piper</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
cobra-cli add piper
piper created at /Users/marian/go/src/github.com/
  marianina8/application</pre>
			<p>For the newly generated <strong class="source-inline">piperCmd</strong>’s <strong class="source-inline">Run</strong> field, add the <span class="No-Break">following lines:</span></p>
			<pre class="source-code">
reader := bufio.NewReader(os.Stdin)
s, _ := reader.ReadString('\n')
fmt.Printf("piped in: %s\n", s)</pre>
			<p>Now, compile and run the <strong class="source-inline">piper</strong> command with some <span class="No-Break">piped-in input:</span></p>
			<pre class="source-code">
  echo “hello world” | ./application piper
piper called
piped in: hello world</pre>
			<p>Now, suppose your command has a standard output that is written to a broken pipe; the kernel will raise a <strong class="source-inline">SIGPIPE</strong> signal. This is received as input to the command-line application, which<a id="_idIndexMarker334"/> can then output an error regarding the broken pipe. Besides receiving signals from the kernel, other signals, such as <strong class="source-inline">SIGINT</strong>, can be triggered by users who press control character key combinations such as <em class="italic">Ctrl + C</em> that interrupt the application. This is just one type of signal and control character, but more will be discussed in the <span class="No-Break">following section.</span></p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/>Signals and control characters</h2>
			<p>As the name implies, signals<a id="_idIndexMarker335"/> are another way to communicate specific and actionable input by<a id="_idIndexMarker336"/> signaling to a command-line application. Sometimes, these signals can be from the kernel, or from users that press control characters key combinations and<a id="_idIndexMarker337"/> trigger signals to the application. There are two different<a id="_idIndexMarker338"/> types <span class="No-Break">of signals:</span></p>
			<ul>
				<li><strong class="bold">Synchronous signals</strong> – triggered by errors that occur when the program executes. These signals include <strong class="source-inline">SIGBUS</strong>, <strong class="source-inline">SIGFPE</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">SIGSEGV</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Asynchronous signals</strong> – triggered from the kernel or another application.  These signals include <strong class="source-inline">SIGHUP</strong>, <strong class="source-inline">SIGINT</strong>, <strong class="source-inline">SIGQUIT</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">SIGPIPE</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">A few signals, such as <strong class="source-inline">SIGKILL</strong> and <strong class="source-inline">SIGSTOP</strong>, may not be caught by a program, so utilizing the <strong class="source-inline">os/signal</strong> package for custom handling will not affect <span class="No-Break">the result.</span></p>
			<p>There is a lot to discuss in depth on signals, but the main point is that they are just another method of receiving input. We’ll stay focused on how this data is received by the command-line application. The following is a table explaining some of the most commonly used signals, control character combinations, and <span class="No-Break">their descriptions:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_5.01.jpg" alt="Figure ﻿5.1 – Table of signals with related key combinations and descriptions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Table of signals with related key combinations and descriptions</p>
			<p>The following <a id="_idIndexMarker339"/>are two function calls added to <strong class="source-inline">rootCmd</strong> to handle exiting your application with grace when a <strong class="source-inline">SIGINT</strong> or <strong class="source-inline">SIGTSTP</strong> signal is received. The <strong class="source-inline">Execute</strong> function<a id="_idIndexMarker340"/> that calls <strong class="source-inline">rootCmd</strong> now looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func Execute() {
    SetupInterruptHandler()
    SetupStopHandler()
    err := rootCmd.Execute()
    if err != nil {
        os.Exit(1)
    }
}</pre>
			<p>The <strong class="source-inline">SetupInterruptHandler</strong> code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
func SetupInterruptHandler() {
    c := make(chan os.Signal)
    signal.Notify(c, os.Interrupt, syscall.SIGINT)
    go func() {
        &lt;-c
        fmt.Println("\r- Wake up! Sleep has been
          interrupted.")
        os.Exit(0)
    }()
}</pre>
			<p>Similarly, the <strong class="source-inline">SetupStopHandler</strong> code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
func SetupStopHandler() {
    c := make(chan os.Signal)
    signal.Notify(c, os.Interrupt, syscall.SIGTSTP)
    go func() {
        &lt;-c
        fmt.Println("\r- Wake up! Stopped sleeping.")
        os.Exit(0)
    }()
}</pre>
			<p>Now, we’ll need a<a id="_idIndexMarker341"/> command to interrupt or stop the application. Let’s use the Cobra CLI <a id="_idIndexMarker342"/>and add a <span class="No-Break"><strong class="source-inline">sleep</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
  cobra-cli add sleep
sleep created at /Users/marian/go/src/github.com/
  marianina8/application</pre>
			<p>The <strong class="source-inline">Run</strong> field of <strong class="source-inline">sleepCmd</strong> is changed to run an infinite loop that prints out some Zs (<strong class="source-inline">Zzz</strong>) until a signal interrupts the <strong class="source-inline">sleep</strong> command and wakes <span class="No-Break">it up:</span></p>
			<pre class="source-code">
Run: func(cmd *cobra.Command, args []string) {
    fmt.Println("sleep called")
    for {
        fmt.Println("Zzz")
        time.Sleep(time.Second)
    }
},</pre>
			<p>By running the <strong class="source-inline">sleep</strong> command and then using <em class="italic">Ctrl + C</em>, we get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
  ./application sleep
sleep called
Zzz
Zzz
- Wake up!  Sleep has been interrupted.
- Wake up!  Stopped sleeping.</pre>
			<p>Trying again but <a id="_idIndexMarker343"/>now using <em class="italic">Ctrl + Z</em>, we get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
  ./application sleep
sleep called
Zzz
Zzz
Zzz
- Wake up!  Stopped sleeping.</pre>
			<p>You can utilize signals <a id="_idIndexMarker344"/>to interrupt or quit your application gracefully or take action when an alarm is triggered. While commands, arguments, and flags are the most commonly known types of input for command-line applications, it is important to consider handling these signal inputs to create a more robust application. If a terminal hangs and <strong class="source-inline">SIGHUP</strong> is received, your application can save information on the last state and handle cleanup where necessary. In this case, while it’s not as common, it’s just <span class="No-Break">as important.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>User interaction</h2>
			<p>Although your <a id="_idIndexMarker345"/>user input can be in the form of commands, arguments, and flags, user interaction is more of a back-and-forth interaction between the user and the application. Suppose a user misses a required flag for a particular subcommand – your application can prompt the user and receive the value for that flag via standard input. Sometimes, rather than utilizing the more standard input of commands, arguments, and flags, an interactive command-line application can be <span class="No-Break">built instead.</span></p>
			<p>An <a id="_idIndexMarker346"/>interactive CLI would prompt for input and then receive it through <strong class="source-inline">stdin</strong>. There are some useful packages for building interactive and accessible prompts in Go. For the following examples, we’ll use the <a href="https://github.com/AlecAivazis/survey">https://github.com/AlecAivazis/survey</a> package. There are multiple fun ways to prompt input using the <strong class="source-inline">survey</strong> package. A <strong class="source-inline">survey</strong> command will ask questions that need to be stored in a variable. Let’s define it as <strong class="source-inline">qs</strong>, a slice of the <strong class="source-inline">*</strong><span class="No-Break"><strong class="source-inline">survey.Question</strong></span><span class="No-Break"> type:</span></p>
			<pre class="source-code">
var qs = []*survey.Question{}</pre>
			<p><strong class="source-inline">survey</strong> can prompt the user for different types of input, as <span class="No-Break">defined here:</span></p>
			<ul>
				<li><strong class="bold">Simple </strong><span class="No-Break"><strong class="bold">text input</strong></span></li>
			</ul>
			<p>At a<a id="_idIndexMarker347"/> very basic level, users can receive basic <span class="No-Break">text input:</span></p>
			<pre class="source-code">
{
    Name: "firstname",
    Prompt: &amp;survey.Input{Message: "What is your first
      name?"},
    Validate: survey.Required,
    Transform: survey.Title,
},
<strong class="bold">Output:</strong>
<strong class="bold">  ? What is your first name?</strong></pre>
			<ul>
				<li><span class="No-Break"><strong class="bold">Suggesting options</strong></span></li>
			</ul>
			<p>This<a id="_idIndexMarker348"/> terminal option allows you to give the user suggestions for the <span class="No-Break">prompted question:</span></p>
			<pre class="source-code">
{
    Name: "favoritecolor",
    Prompt: &amp;survey.Select{
    Message: "What's your favorite color?",
    Options: []string{"red", "orange", "yellow",
      "green", "blue", "purple", "black", "brown",
        "white"},
    Default: "white",
},
<strong class="bold">Output:</strong>
<strong class="bold">  </strong><strong class="bold">? What is your favorite color? [tab for suggestions]</strong></pre>
			<p>Hitting the <em class="italic">Tab</em> key<a id="_idIndexMarker349"/> will show the <span class="No-Break">available</span><span class="No-Break"><a id="_idIndexMarker350"/></span><span class="No-Break"> options:</span></p>
			<pre class="source-code">
<strong class="bold">? What is your favorite color? [Use arrows to</strong>
<strong class="bold">  navigate, enter to select, type to complement</strong>
<strong class="bold">    answer]</strong>
<strong class="bold">red</strong>
<strong class="bold">orange</strong>
<strong class="bold">yellow</strong>
<strong class="bold">green</strong>
<strong class="bold">blue</strong>
<strong class="bold">purple</strong>
<strong class="bold">black</strong>
<strong class="bold">brown</strong>
<strong class="bold">white</strong></pre>
			<ul>
				<li><strong class="bold">Inputting </strong><span class="No-Break"><strong class="bold">multiple lines</strong></span></li>
			</ul>
			<p>When <a id="_idIndexMarker351"/>receiving input, sometimes, pressing the <em class="italic">Return</em> key will immediately pass any text received before directly as input to the program. Utilizing the <strong class="source-inline">survey</strong> package allows you to enter multiple lines before<a id="_idIndexMarker352"/> <span class="No-Break">receiving input:</span></p>
			<pre class="source-code">
{
    Name: "story",
    Prompt: &amp;survey.Multiline{
    Message: "Tell me a story.",
    },
},
<strong class="bold">Output:</strong>
<strong class="bold">  </strong><strong class="bold">? Tell me a story [Enter 2 empty lines to finish]</strong>
A long line time ago in a faraway town, there lived a
  princess who lived in a castle far away from the
    city.  She was always sleeping, until one day…</pre>
			<ul>
				<li><strong class="bold">Protecting </strong><span class="No-Break"><strong class="bold">password input</strong></span></li>
			</ul>
			<p>To keep <a id="_idIndexMarker353"/>data private, when inputting private information, the <strong class="source-inline">survey</strong> package will replace the characters with <strong class="source-inline">*</strong> <span class="No-Break">symbols:</span></p>
			<pre class="source-code">
{
    Name: "secret",
    Prompt: &amp;survey.Password{
    Message: "Tell me a secret",
    },
},
<strong class="bold">Output:</strong>
<strong class="bold">? Tell me a secret: ************</strong></pre>
			<ul>
				<li><strong class="bold">Confirming with Yes </strong><span class="No-Break"><strong class="bold">or No</strong></span></li>
			</ul>
			<p>Users<a id="_idIndexMarker354"/> can respond with a simple yes or no to the <span class="No-Break">command prompt:</span></p>
			<pre class="source-code">
{
    Name: "good",
    Prompt: &amp;survey.Confirm{
    Message: "Are you having a good day?",
    },
},
<strong class="bold">Output:</strong>
<strong class="bold">? Are you having a good day? (Y/n)</strong></pre>
			<p>Now, let us see how<a id="_idIndexMarker355"/> to select from a <span class="No-Break">checkbox option.</span></p>
			<ul>
				<li><strong class="bold">Selecting from a </strong><span class="No-Break"><strong class="bold">checkbox option</strong></span></li>
			</ul>
			<p>Multiple options<a id="_idIndexMarker356"/> can be selected within a vertical checkbox option. Navigating the options is done with the up and down arrows, and selecting is done with <span class="No-Break">the spacebar:</span></p>
			<pre class="source-code">
{
    Name: "favoritepies",
    Prompt: &amp;survey.MultiSelect{
    Message: "What pies do you like:",
    Options: []string{"Pumpkin", "Lemon Meringue",
      "Cherry", "Apple", "Key Lime", "Pecan", "Boston
        Cream", "Rhubarb", "Blackberry"},
    },
},
<strong class="bold">Output:</strong>
<strong class="bold">? What pies do you like: [Use arrows to move, space to</strong>
<strong class="bold">select, &lt;right&gt; to all, &lt;left&gt; to none, type to</strong>
<strong class="bold">filter]</strong>
<strong class="bold">&gt; [ ] Pumpkin</strong>
<strong class="bold">  [ ] Lemon Meringue</strong>
<strong class="bold">  [ ] Cherry</strong>
<strong class="bold">  [ ] Apple</strong>
<strong class="bold">  [ ] Key Lime</strong>
<strong class="bold">  [ ] Pecan</strong>
<strong class="bold">….</strong></pre>
			<p>Create a<a id="_idIndexMarker357"/> new <strong class="source-inline">survey</strong> command with <span class="No-Break">the following:</span></p>
			<p><strong class="source-inline">cobra-cli </strong><span class="No-Break"><strong class="source-inline">add survey</strong></span></p>
			<p>The <strong class="source-inline">Run</strong> field of <strong class="source-inline">surveyCmd</strong> creates a struct that receives all the answers to <span class="No-Break">questions asked:</span></p>
			<pre class="source-code">
Run: func(cmd *cobra.Command, args []string) {
    fmt.Println("survey called")
    answers := struct {
        FirstName string
        FavoriteColor string
        Story string
        Secret string
        Good bool
        FavoritePies []string
    }{}</pre>
			<p>The <strong class="source-inline">Ask</strong> method then takes in the questions, <strong class="source-inline">qs</strong>, and then receives all the answers to the questions asked<a id="_idIndexMarker358"/> into a pointer to the <span class="No-Break"><strong class="source-inline">answers</strong></span><span class="No-Break"> struct:</span></p>
			<pre class="source-code">
    err := survey.Ask(qs, &amp;answers)
    if err != nil {
        fmt.Println(err.Error())
        return
    }</pre>
			<p>Finally, the results are <span class="No-Break">printed out:</span></p>
			<pre class="source-code">
    fmt.Println("*********** SURVEY RESULTS ***********")
    fmt.Printf("First Name: %s\n", answers.FirstName)
    fmt.Printf("Favorite Color: %s\n",
        answers.FavoriteColor)
    fmt.Printf("Story: %s\n", answers.Story)
    fmt.Printf("Secret: %s\n", answers.Secret)
    fmt.Printf("It's a good day: %v\n", answers.Good)
    fmt.Printf("Favorite Pies: %s\n", answers.FavoritePies)
},</pre>
			<p>Testing out the <strong class="source-inline">survey</strong> command, we get <span class="No-Break">the following:</span></p>
			<pre class="source-code">
  ./application survey
survey called
? What is your first name? Marian
? What's your favorite color? white
? Tell me a story.
I went to the dodgers game last night and
they lost, but I still had fun!
? Tell me a secret ********
? Are you having a good day? Yes
? What pies do you prefer: Pumpkin, Lemon Meringue, Key
    Lime, Pecan, Boston Cream
*********** SURVEY RESULTS ***********
First Name: Marian
Favorite Color: white
Story: I went to the dodgers game last night and
they lost, but I still had fun!
Secret: a secret
It's a good day: true
Favorite Pies: [Pumpkin Lemon Meringue Key Lime Pecan
    Boston Cream]</pre>
			<p>Although these examples<a id="_idIndexMarker359"/> are just a selection of the many input prompts provided by the <strong class="source-inline">survey</strong> package, you can visit the GitHub page to view examples of all the possible options. Playing around with prompts reminds me of early text-based RPG games that used them to prompt the gamer’s character. Having learned about the many different types of input, whether user-based, from the kernel, or from other piped applications, let’s discuss how to process this <span class="No-Break">incoming data.</span></p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/>Processing data</h1>
			<p><strong class="bold">Data processing</strong> is <a id="_idIndexMarker360"/>when raw data is fed into a process, analyzed, and then used to generate useful information or output. At a very general level, this can include sorting data, searching or querying for data, and converting data from one type of input into another. For a CLI, the input can be received in the different ways discussed in the previous section. When receiving arguments using the Cobra framework, all the values are read in as string input. However, given a string of <strong class="source-inline">123</strong>, we can do a type check by utilizing the <strong class="source-inline">strconv</strong> package’s <strong class="source-inline">Atoi</strong> method, which converts an ASCII string into <span class="No-Break">an integer:</span></p>
			<pre class="source-code">
val, err := strconv.Atoi("123")</pre>
			<p>If the string value cannot be converted because it isn’t a string representation of an integer, then an error will be thrown. If the string is a representation of an integer, then the integer value will be stored in the <span class="No-Break"><strong class="source-inline">val</strong></span><span class="No-Break"> variable.</span></p>
			<p>The <strong class="source-inline">strconv</strong> package can be used to check, with conversion, many other types, including Boolean, float, and <strong class="source-inline">uint</strong> values <span class="No-Break">as well.</span></p>
			<p>Flags, on the<a id="_idIndexMarker361"/> other hand, can have predefined types. Within the Cobra framework, the <strong class="source-inline">pflag</strong> package is used, which is just an extension of the standard go <strong class="source-inline">flag</strong> package.  For example, when a flag is defined, you can define it specifically as a <strong class="source-inline">String</strong>, <strong class="source-inline">Bool</strong>, <strong class="source-inline">Int</strong>, or custom type. The preceding <strong class="source-inline">123</strong> value, if read in as an <strong class="source-inline">Int</strong> flag, could be defined with the following lines <span class="No-Break">of code:</span></p>
			<pre class="source-code">
var intValue int
flag.IntVar(&amp;intValue, "flagName", 123, "help message")</pre>
			<p>This can be done similarly for <strong class="source-inline">String</strong> and <strong class="source-inline">Bool</strong> flags. You can even create a flag with a custom, specific interface using the <span class="No-Break"><strong class="source-inline">Var</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
var value Custom
flag.Var(&amp;value, "name", "help message")</pre>
			<p>Just ensure that the <strong class="source-inline">Custom</strong> struct satisfies the following interface defined within the <strong class="source-inline">pflag</strong> package for <span class="No-Break">custom flags:</span></p>
			<pre class="source-code">
// (The default value is represented as a string.)
type Value interface {
    String() string
    Set(string) error
    Type() string
}</pre>
			<p>I defined the <strong class="source-inline">Custom</strong> struct as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
type Custom struct {
    Value string
}</pre>
			<p>Therefore, the <strong class="source-inline">Set</strong> method is simply defined <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
func (c *Custom) Set(value string) error {
    c.Value = value
    return nil
}</pre>
			<p>Passing the value<a id="_idIndexMarker362"/> into the flag was handled by <strong class="source-inline">flag: --name="custom value</strong>. The <strong class="source-inline">String</strong> method is then used to print <span class="No-Break">the value:</span></p>
			<pre class="source-code">
fmt.Println(cmd.Flag("name<strong class="source-inline">").Value.String())</strong></pre>
			<p>It looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
custom value</pre>
			<p>Besides passing in string values that can be converted into different types, oftentimes, a path to a file is passed in. There are multiple ways of reading data from files. Let’s list each, along with a<a id="_idIndexMarker363"/> method to handle this way of reading in a file and a pro and a con <span class="No-Break">for each:</span></p>
			<ul>
				<li><strong class="bold">In its entirety, all at once</strong>: The <strong class="source-inline">os.ReadFile</strong> method reads the entire file and returns its contents. It <a id="_idIndexMarker364"/>does not error when encountering the <strong class="bold">end of </strong><span class="No-Break"><strong class="bold">file</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">EOF</strong></span><span class="No-Break">):</span><pre class="source-code">
func all(filename string) {

    content, err := os.ReadFile(filename)

    if err != nil {

        fmt.Printf("Error reading file: %s\n", err)

        return

    }

    fmt.Printf("content: %s\n", content)

}</pre></li>
				<li><strong class="bold">Pros</strong>: <span class="No-Break">Faster performance</span></li>
				<li><strong class="bold">Cons</strong>: Consumes more memory in a shorter amount <span class="No-Break">of time</span></li>
				<li><strong class="bold">In predefined chunks</strong>: The <strong class="source-inline">file.Read</strong> method reads in the buffer at its predetermined size and returns the bytes, which can be printed after being cast as a string. Unlike the <strong class="source-inline">ioutil.ReadFile</strong> method, <strong class="source-inline">file.Read</strong> from the buffer will <a id="_idIndexMarker365"/>error when it reaches <span class="No-Break">the EOF:</span><pre class="source-code">
func chunk(file *os.File) {

    const size = 8 // chunk size

    buff := make([]byte, size)

    fmt.Println("content: ")

    for {

        // read content to buffer of size, 8 bytes

        read8Bytes, err := file.Read(buff)

        if err != nil {

            if err != io.EOF {

                fmt.Println(err)

            }

            break

        }

        // print content from buffer

        fmt.Println(string(buff[:read8Bytes]))

    }</pre></li>
				<li><strong class="bold">Pros</strong>: Easy to implement, consumes <span class="No-Break">little memory</span></li>
				<li><strong class="bold">Cons</strong>: If the chunks are not properly chosen, you may have inaccurate results, increased complexity when comparing or analyzing the data, and potential <span class="No-Break">error propagation.</span></li>
				<li><strong class="bold">Line by line</strong>: By default, a new scanner will split the text up by lines, so it’s not necessary to define the <strong class="source-inline">split</strong> function. The <strong class="source-inline">scanner.Text()</strong> method reads into <a id="_idIndexMarker366"/>the next token that delimits each scan – in the following example, line by line. Finally, <strong class="source-inline">scanner.Scan()</strong> does not return an error when it encounters <span class="No-Break">the EOF:</span><pre class="source-code">
func line(file *os.File) {

    scanner := bufio.NewScanner(file)

    lineCount := 0

    for scanner.Scan() {

        fmt.Printf("%d: %s\n", lineCount,

          scanner.Text())

        lineCount++

    }

    if err := scanner.Err(); err != nil {

        fmt.Printf("error scanning line by line:

            %s\n", err)

    }

}</pre></li>
				<li><strong class="bold">Pros</strong>: Easy to implement – an intuitive way to read in data and <span class="No-Break">output data.</span></li>
				<li><strong class="bold">Cons</strong>: Processing an extremely large file may cause memory constraints. Increased complexity may cause inaccurate results, if the data is not well suited to line by <span class="No-Break">line processing.</span></li>
				<li><strong class="bold">Word by word  </strong>To overwrite<a id="_idIndexMarker367"/> the default <strong class="source-inline">Split</strong> function, pass <strong class="source-inline">bufio.ScanWords</strong> into the <strong class="source-inline">Split</strong> function. This will then define the tokens between each word and scan between each token. Again, scanning in this way will not encounter an error at the <span class="No-Break">EOF either:</span><pre class="source-code">
func word(file *os.File) {

    scanner := bufio.NewScanner(file)

    scanner.Split(bufio.ScanWords)

    wordCount := 0

    for scanner.Scan() {

        fmt.Printf("%d: %s\n", wordCount,

            scanner.Text())

      wordCount++

    }

    if err := scanner.Err(); err != nil {

        fmt.Printf("error scanning by words: %s\n",

            err)

    }

}</pre></li>
				<li><strong class="bold">Pros</strong>: Easy to implement – an intuitive way to read data and <span class="No-Break">output data</span></li>
				<li><strong class="bold">Cons</strong>: Inefficient and time consuming for large files. Increased complexity may cause inaccurate results, if the data is not well suited to word by <span class="No-Break">word processing</span></li>
			</ul>
			<p>Choosing the way to handle processing the data received from the file depends on the use case. Additionally, there are three main types of data processing: batch, online, <span class="No-Break">and real-time.</span></p>
			<p>As you can guess from the name, batch processing<a id="_idIndexMarker368"/> takes similar tasks that are collected, or batched, and then runs them simultaneously. Online processing<a id="_idIndexMarker369"/> requires internet connectivity to reach an API endpoint to fully process data and return a<a id="_idIndexMarker370"/> result. Real-time processing is the execution of data in such a short period that the data is <span class="No-Break">instantaneously output.</span></p>
			<p>Examples of different<a id="_idIndexMarker371"/> use cases requiring a specific type of processing vary. Bank transactions, billing, and reporting often use <span class="No-Break">batch processing.</span></p>
			<p>A CLI that utilizes an API behind the scenes would often require internet access to handle online processing. Real-time processing is used when timeliness is of utmost importance, often in manufacturing, fraud detection, and computer <span class="No-Break">vision tools.</span></p>
			<p>Once the data has been processed, the result must be returned to the user or receiving process. In the next section, we will discuss the details of returning the output and defining the best practices for <span class="No-Break">returning data.</span></p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor118"/>Returning the resulting output and defining best practices</h1>
			<p>When <a id="_idIndexMarker372"/>returning output from a process, it’s important to know to who or what you’re returning data. It’s incredibly important to return output that’s human-readable. However, to<a id="_idIndexMarker373"/> determine whether you’re returning data to a human or a machine, check whether you’re writing to a TTY. Remember TTY? You can refer to <a href="B18883_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Understanding CLI Standards</em>, in which we discussed the history of the CLI interface and the term TTY, short for teletypewriter <span class="No-Break">or teletype.</span></p>
			<p>If writing to a TTY, we can check whether the <strong class="source-inline">stdout</strong> file descriptor refers to a terminal or not, and change the output depending on <span class="No-Break">the result.</span></p>
			<p>Let’s check out this block of code, which checks whether the <strong class="source-inline">stdout</strong> file descriptor is writing to a TTY <span class="No-Break">or not:</span></p>
			<pre class="source-code">
if fileInfo, _ := os.Stdout.Stat(); (fileInfo.Mode() &amp;
    os.ModeCharDevice) != 0 {
    fmt.Println("terminal")
} else {
    fmt.Println("not a terminal")
}</pre>
			<p>Let’s call it<a id="_idIndexMarker374"/> within the <strong class="source-inline">Run</strong> method of a command called <strong class="source-inline">tty</strong> using the <span class="No-Break">following command:</span></p>
			<pre class="console">
./application tty</pre>
			<p>Then, the output is <span class="No-Break">as follows,:</span></p>
			<pre class="console">
terminal</pre>
			<p>However, if we pipe the output to a file by calling <strong class="source-inline">./application tty &gt; file.txt</strong>, then the contents of the file are <span class="No-Break">as follows:</span></p>
			<pre class="console">
not a terminal</pre>
			<p>Certainly, it makes sense to add colored ASCII text when returning output to a human, but that’s often useless and extraneous information for output to a <span class="No-Break">machine process.</span></p>
			<p>When <a id="_idIndexMarker375"/>writing output, always put humans first, specifically in terms of usability. However, if the machine-readable output does not affect usability, then output in machine-readable output. Because streams of text are universal input in Unix, it’s typical for programs to be linked together by pipes. The output is typically lines of text, and programs expect input as lines of text as well. A user should expect to write output that can easily be grepped. You cannot know for sure where the output will be sent to and which other processes may be consuming the output. Always check whether the output is sent to a terminal and print for another program if it’s not. However, if using a machine-readable output breaks usability, but the human-readable output cannot be easily processed by another machine process, default to human-readable output and then define the <strong class="source-inline">–plain</strong> flag to display this output as machine-readable output. Clean lines of text in tabular format are easily integrated with <strong class="source-inline">grep</strong> and <strong class="source-inline">awk</strong>. This gives the user the choice to define the format of <span class="No-Break">the output.</span></p>
			<p>Beyond defining the output for humans versus machines, it’s standard to add a flag to define a specific format for the data returned. The <strong class="source-inline">–json</strong> flag is used when requesting data to be returned in JSON format and the <strong class="source-inline">–xml</strong> flag is used to request XML format. There’s a Unix tool, <strong class="source-inline">jq</strong>, that can be integrated with a program’s JSON output. In fact, this tool can manipulate any data returned in JSON format. Many tools within the Unix ecosystem take advantage of this and you <span class="No-Break">can too.</span></p>
			<p>Historically, because many of the older Unix programs were written for scripts or other programs, often, no output is returned on success. This can be confusing for users. Success cannot always be assumed, so it’s ideal to display output on success. There’s no reason to elaborate, so keep it brief and informative. Defining a <strong class="source-inline">–quit</strong> (or <strong class="source-inline">–q</strong>) flag can suppress unnecessary information <span class="No-Break">if necessary.</span></p>
			<p>Sometimes, a CLI <a id="_idIndexMarker376"/>can keep track of <a id="_idIndexMarker377"/>the state. The <strong class="bold">GitHub CLI</strong> is probably the best and most common example that many of you have already experienced. It does an excellent job of informing users of state changes and the current state using <strong class="source-inline">git status</strong>. This information needs to be transparent to the user, as it can often confirm the result of an action expected to change the state. The user understands their possible next steps by knowing <span class="No-Break">the state.</span></p>
			<p>Some of <a id="_idIndexMarker378"/>these next steps may also be suggested to the user. In fact, it’s ideal to give users suggestions because it feels like they are being guided along, rather than left alone in the wild with a new CLI application. When a user first interacts with a CLI, it’s best to make the learning experience similar to a guided adventure. Let’s give a quick example in regard to GitHub’s CLI. Consider when you have to merge the main branch into your current branch. Now and then, there’ll be conflicts after the merge, and the CLI guides you when you check <span class="No-Break"><strong class="source-inline">git status</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
On branch {branch name}
Your branch and 'origin/{branch name}' have diverged
And have 1 and 1 different commits each, respectively.
    (use "git pull" to merge the remote branch into yours)
You have unmerged paths.
    (fix conflicts and run "git commit")
    (use "git merge –abort" to abort the merge)
Unmerged paths:
    (use "git add &lt;file&gt;..." to mark resolution)
             Both modified:     merge.json</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The response reminds the user of their current branch and state, as well as suggesting different options that the user could take. Not all CLIs handle the state, but when you do, it’s best to make it well known and provide users with a clear <span class="No-Break">path forward.</span></p>
			<p>If there’s any <a id="_idIndexMarker379"/>communication with a remote server, reading or writing of files (except for a cache), or any other actions that cross the boundary of the program’s internals, communicate those actions to the user. I love HomeBrew’s <strong class="source-inline">install</strong> command on their CLI. It’s clear exactly what’s going on behind the scenes when you use <strong class="source-inline">brew install</strong> for <span class="No-Break">an application.</span></p>
			<p>When a file is being downloaded or created, it’s <span class="No-Break">clearly stated:</span></p>
			<pre class="console">
==&gt; Downloading https://ghcr.io/v2/homebrew/core/dav1d/manifests/1.0.0
###########################################################
############# 100.0%</pre>
			<p>And look<a id="_idIndexMarker380"/> how hashtags are used to designate progress – they utilize ASCII characters in a way that increases information density. I love the cold glass of beer icon next to files existing in<a id="_idIndexMarker381"/> the <strong class="source-inline">Cellar</strong> folder. It makes you think of all the brew formulas existing<a id="_idIndexMarker382"/> inside a beer cellar. <strong class="bold">Emojis</strong> are worth a <span class="No-Break">thousand words.</span></p>
			<p>When an error is evoked, the text is displayed in red, intending to evoke a sense of urgency and alertness. Color, if used, must be used intentionally. A green failure, or red success, is confusing for users. I’m certain, just like utilizing ASCII art to increase information density, color has the same purpose. A green success cannot be mistaken easily for a failure, and vice versa. Make sure to make important information stand out by using colors infrequently. Too many colors will make it difficult for anything to <span class="No-Break">stand out.</span></p>
			<p>However, while color may excite some of us, it annoys others. There may be any number of reasons why someone may want to disable the color in their CLI. For whatever reason to continue in a black-and-white world, there are specific times color should not <span class="No-Break">be used:</span></p>
			<ul>
				<li>When piping to <span class="No-Break">another program</span></li>
				<li>When the <strong class="source-inline">NO_COLOR</strong> environment variable <span class="No-Break">is set</span></li>
				<li>When the <strong class="source-inline">TERM</strong> environment variable is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">dumb</strong></span></li>
				<li>When the <strong class="source-inline">–no-color</strong> flag <span class="No-Break">is passed</span></li>
				<li>When your app’s <strong class="source-inline">MYAPP_NO_COLOR</strong> environment variable <span class="No-Break">is set</span></li>
			</ul>
			<p>It goes without <a id="_idIndexMarker383"/>saying that if we don’t allow colors, we don’t allow animations either! Well, I won’t tell you what to do, just try it for yourself – pipe an animation to a file via <strong class="source-inline">stdout</strong>. I dare you! You might end up with some great ASCII art, but it will be busy and difficult to understand the data. The goal is clarity. With ASCII art, color intent, and animations to <a id="_idIndexMarker384"/>increase the information density, we need to understand at some point that we need to use clear words that are understood by all. Consider your wording from the perspective of someone who is using your CLI for the first time. Guide users with <span class="No-Break">your words.</span></p>
			<p>As for printing log output, only do so under the verbose mode, represented by the <strong class="source-inline">–verbose</strong> flag and <strong class="source-inline">–v</strong> for short. Don’t use the <strong class="source-inline">stderr</strong> file descriptor as a <span class="No-Break">log file.</span></p>
			<p>If a CLI outputs a lot of text at once, such as <strong class="source-inline">git diff</strong>, a pager is used. Thank goodness. This makes it so much easier to page through the output to review differences rather than receiving all the text at once. This is just one of the many ways that GitHub has delivered a very thoughtful CLI to <span class="No-Break">its users.</span></p>
			<p>Finally, make errors stand out – use red text or a red <em class="italic">x</em> emoji to increase understanding if an error occurs. If colors are disabled, then use text to communicate that an error has occurred and offer some suggestions for the next steps to take – and, even better, an avenue toward support via email or <span class="No-Break">a website.</span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/>Summary</h1>
			<p>In this chapter, you learned about the command-line process – receiving input, processing data, and returning the output. The most popular different types of input have been discussed: from <strong class="bold">subcommands</strong>, <strong class="bold">arguments</strong>, and <strong class="bold">flags</strong>, to <strong class="bold">signals</strong> and <span class="No-Break"><strong class="bold">control characters</strong></span><span class="No-Break">.</span></p>
			<p>We created an interactive survey to receive input from a user and discussed data processing. We also learned how to take the first steps of processing: converting argument string data, converting and checking the type, receiving data from typed and custom flags, and finally, reading data from <span class="No-Break">a file.</span></p>
			<p>We also covered a brief explanation regarding the different types of processing: batch, online, and real-time processing. Ultimately, the use case will lead you to understand what sort of input you’ll require, and whether running tasks in batches, over the internet, or in real time <span class="No-Break">is required.</span></p>
			<p>Returning the output is just as important as receiving it, if not more! This is your chance to create a more pleasant experience for your user. Now that you’re developing for humans first, you have the opportunity to put yourself in <span class="No-Break">their shoes.</span></p>
			<p>How would you want to receive data in a way that makes you feel assured, understanding failures and what to do next, and where to find help? Not all processes run successfully, so let’s at least make users feel that they’re on the path to success. In <em class="italic">Part 2</em>, <a href="B18883_06.xhtml#_idTextAnchor123"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Calling External Processes, Handling Errors and Timeouts</em>, we will continue to discuss the command-line process in more detail, focusing on external processes and how to handle timeouts and errors and communicate them to the <span class="No-Break">user effectively.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor120"/>Questions</h1>
			<ol>
				<li>Are arguments or flags preferred for CLI <span class="No-Break">programs? Why?</span></li>
				<li>What key combination interrupts a <span class="No-Break">computer process?</span></li>
				<li>What flag can be added to your CLI to modify the output into plain output that can easily be integrated with tools such as <strong class="source-inline">grep</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">awk</strong></span><span class="No-Break">?</span></li>
			</ol>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor121"/>Answers</h1>
			<ol>
				<li value="1">Flags are preferred for CLI programs because they make it much easier to add or <span class="No-Break">remove functionality.</span></li>
				<li><em class="italic">Ctrl + </em><span class="No-Break"><em class="italic">C</em></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">–plain</strong> flag can be added to remove any unnecessary data from <span class="No-Break">the output.</span></li>
			</ol>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor122"/>Further reading</h1>
			<ul>
				<li>What is a <span class="No-Break">TTY? (</span><span class="No-Break">https://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con/4132#4132</span><span class="No-Break">)</span></li>
				<li><span class="No-Break">NO_COLOR (</span><span class="No-Break">https://no-color.org/</span><span class="No-Break">)</span></li>
				<li><em class="italic">12 Factor CLI </em><span class="No-Break"><em class="italic">Apps</em></span><span class="No-Break"> (</span><span class="No-Break">https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46</span><span class="No-Break">)</span></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer043" class="IMG---Figure">
			</div>
		</div>
	</body></html>