["```go\nAPPNAME NOUN VERB –ADJECTIVE\n```", "```go\nAPPNAME ARGUMENT <COMMAND | SUBCOMMANDS> --FLAG\n```", "```go\ncobra-cli add command\ncommand created at /Users/marian/go/src/github.com/\n  marianina8/application\n```", "```go\ncobra-cli add subcommand\nsubcommand created at /Users/marian/go/src/github.com/\n  marianina8/application\n```", "```go\nfunc init() {\n    commandCmd.AddCommand(subcommandCmd)\n}\n```", "```go\n./application command subcommand\nsubcommand called\n```", "```go\nRun: func(cmd *cobra.Command, args []string) {\n    if len(args) == 0 {\n        fmt.Println(\"subcommand called\")\n    } else {\n        fmt.Println(\"subcommand called with arguments: \",\n          args)\n    }\n},\n```", "```go\n  ./application command subcommand argument1 argument2\nsubcommand called with arguments:  [argument1 argument2]\n```", "```go\ncommandCmd.Flags().String(\"localFlag\", \"\", \"a local string\n  flag\")\ncommandCmd.PersistentFlags().Bool(\"persistentFlag\", false,\n  \"a persistent boolean flag\")\n```", "```go\nlocalFlag, _ := cmd.Flags().GetString(\"localFlag\")\nif localFlag != \"\" {\n    fmt.Printf(\"localFlag is set to %s\\n\", localFlag)\n}\n```", "```go\npersistentFlag, _ := cmd.Flags().GetBool(\"persistentFlag\")\nfmt.Printf(\"persistentFlag is set to %v\\n\", persistentFlag)\n```", "```go\n  ./application command --localFlag=”123”\ncommand called\nlocalFlag is set to 123\n  ./application command --localFlag “123”\ncommand called\nlocalFlag is set to 123\n```", "```go\n  ./application command subcommand\nsubcommand called\npersistentFlag is set to false\n  ./application command subcommand --persistentFlag\nsubcommand called\npersistentFlag is set to true\n```", "```go\ncobra-cli add piper\npiper created at /Users/marian/go/src/github.com/\n  marianina8/application\n```", "```go\nreader := bufio.NewReader(os.Stdin)\ns, _ := reader.ReadString('\\n')\nfmt.Printf(\"piped in: %s\\n\", s)\n```", "```go\n  echo “hello world” | ./application piper\npiper called\npiped in: hello world\n```", "```go\nfunc Execute() {\n    SetupInterruptHandler()\n    SetupStopHandler()\n    err := rootCmd.Execute()\n    if err != nil {\n        os.Exit(1)\n    }\n}\n```", "```go\nfunc SetupInterruptHandler() {\n    c := make(chan os.Signal)\n    signal.Notify(c, os.Interrupt, syscall.SIGINT)\n    go func() {\n        <-c\n        fmt.Println(\"\\r- Wake up! Sleep has been\n          interrupted.\")\n        os.Exit(0)\n    }()\n}\n```", "```go\nfunc SetupStopHandler() {\n    c := make(chan os.Signal)\n    signal.Notify(c, os.Interrupt, syscall.SIGTSTP)\n    go func() {\n        <-c\n        fmt.Println(\"\\r- Wake up! Stopped sleeping.\")\n        os.Exit(0)\n    }()\n}\n```", "```go\n  cobra-cli add sleep\nsleep created at /Users/marian/go/src/github.com/\n  marianina8/application\n```", "```go\nRun: func(cmd *cobra.Command, args []string) {\n    fmt.Println(\"sleep called\")\n    for {\n        fmt.Println(\"Zzz\")\n        time.Sleep(time.Second)\n    }\n},\n```", "```go\n  ./application sleep\nsleep called\nZzz\nZzz\n- Wake up!  Sleep has been interrupted.\n- Wake up!  Stopped sleeping.\n```", "```go\n  ./application sleep\nsleep called\nZzz\nZzz\nZzz\n- Wake up!  Stopped sleeping.\n```", "```go\nvar qs = []*survey.Question{}\n```", "```go\n{\n    Name: \"firstname\",\n    Prompt: &survey.Input{Message: \"What is your first\n      name?\"},\n    Validate: survey.Required,\n    Transform: survey.Title,\n},\nOutput:\n  ? What is your first name?\n```", "```go\n{\n    Name: \"favoritecolor\",\n    Prompt: &survey.Select{\n    Message: \"What's your favorite color?\",\n    Options: []string{\"red\", \"orange\", \"yellow\",\n      \"green\", \"blue\", \"purple\", \"black\", \"brown\",\n        \"white\"},\n    Default: \"white\",\n},\nOutput:\n? What is your favorite color? [tab for suggestions]\n```", "```go\n? What is your favorite color? [Use arrows to\n  navigate, enter to select, type to complement\n    answer]\nred\norange\nyellow\ngreen\nblue\npurple\nblack\nbrown\nwhite\n```", "```go\n{\n    Name: \"story\",\n    Prompt: &survey.Multiline{\n    Message: \"Tell me a story.\",\n    },\n},\nOutput:\n? Tell me a story [Enter 2 empty lines to finish]\nA long line time ago in a faraway town, there lived a\n  princess who lived in a castle far away from the\n    city.  She was always sleeping, until one day…\n```", "```go\n{\n    Name: \"secret\",\n    Prompt: &survey.Password{\n    Message: \"Tell me a secret\",\n    },\n},\nOutput:\n? Tell me a secret: ************\n```", "```go\n{\n    Name: \"good\",\n    Prompt: &survey.Confirm{\n    Message: \"Are you having a good day?\",\n    },\n},\nOutput:\n? Are you having a good day? (Y/n)\n```", "```go\n{\n    Name: \"favoritepies\",\n    Prompt: &survey.MultiSelect{\n    Message: \"What pies do you like:\",\n    Options: []string{\"Pumpkin\", \"Lemon Meringue\",\n      \"Cherry\", \"Apple\", \"Key Lime\", \"Pecan\", \"Boston\n        Cream\", \"Rhubarb\", \"Blackberry\"},\n    },\n},\nOutput:\n? What pies do you like: [Use arrows to move, space to\nselect, <right> to all, <left> to none, type to\nfilter]\n> [ ] Pumpkin\n  [ ] Lemon Meringue\n  [ ] Cherry\n  [ ] Apple\n  [ ] Key Lime\n  [ ] Pecan\n….\n```", "```go\nRun: func(cmd *cobra.Command, args []string) {\n    fmt.Println(\"survey called\")\n    answers := struct {\n        FirstName string\n        FavoriteColor string\n        Story string\n        Secret string\n        Good bool\n        FavoritePies []string\n    }{}\n```", "```go\n    err := survey.Ask(qs, &answers)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n```", "```go\n    fmt.Println(\"*********** SURVEY RESULTS ***********\")\n    fmt.Printf(\"First Name: %s\\n\", answers.FirstName)\n    fmt.Printf(\"Favorite Color: %s\\n\",\n        answers.FavoriteColor)\n    fmt.Printf(\"Story: %s\\n\", answers.Story)\n    fmt.Printf(\"Secret: %s\\n\", answers.Secret)\n    fmt.Printf(\"It's a good day: %v\\n\", answers.Good)\n    fmt.Printf(\"Favorite Pies: %s\\n\", answers.FavoritePies)\n},\n```", "```go\n  ./application survey\nsurvey called\n? What is your first name? Marian\n? What's your favorite color? white\n? Tell me a story.\nI went to the dodgers game last night and\nthey lost, but I still had fun!\n? Tell me a secret ********\n? Are you having a good day? Yes\n? What pies do you prefer: Pumpkin, Lemon Meringue, Key\n    Lime, Pecan, Boston Cream\n*********** SURVEY RESULTS ***********\nFirst Name: Marian\nFavorite Color: white\nStory: I went to the dodgers game last night and\nthey lost, but I still had fun!\nSecret: a secret\nIt's a good day: true\nFavorite Pies: [Pumpkin Lemon Meringue Key Lime Pecan\n    Boston Cream]\n```", "```go\nval, err := strconv.Atoi(\"123\")\n```", "```go\nvar intValue int\nflag.IntVar(&intValue, \"flagName\", 123, \"help message\")\n```", "```go\nvar value Custom\nflag.Var(&value, \"name\", \"help message\")\n```", "```go\n// (The default value is represented as a string.)\ntype Value interface {\n    String() string\n    Set(string) error\n    Type() string\n}\n```", "```go\ntype Custom struct {\n    Value string\n}\n```", "```go\nfunc (c *Custom) Set(value string) error {\n    c.Value = value\n    return nil\n}\n```", "```go\nfmt.Println(cmd.Flag(\"name\").Value.String())\n```", "```go\ncustom value\n```", "```go\n    func all(filename string) {\n\n        content, err := os.ReadFile(filename)\n\n        if err != nil {\n\n            fmt.Printf(\"Error reading file: %s\\n\", err)\n\n            return\n\n        }\n\n        fmt.Printf(\"content: %s\\n\", content)\n\n    }\n    ```", "```go\n    func chunk(file *os.File) {\n\n        const size = 8 // chunk size\n\n        buff := make([]byte, size)\n\n        fmt.Println(\"content: \")\n\n        for {\n\n            // read content to buffer of size, 8 bytes\n\n            read8Bytes, err := file.Read(buff)\n\n            if err != nil {\n\n                if err != io.EOF {\n\n                    fmt.Println(err)\n\n                }\n\n                break\n\n            }\n\n            // print content from buffer\n\n            fmt.Println(string(buff[:read8Bytes]))\n\n        }\n    ```", "```go\n    func line(file *os.File) {\n\n        scanner := bufio.NewScanner(file)\n\n        lineCount := 0\n\n        for scanner.Scan() {\n\n            fmt.Printf(\"%d: %s\\n\", lineCount,\n\n              scanner.Text())\n\n            lineCount++\n\n        }\n\n        if err := scanner.Err(); err != nil {\n\n            fmt.Printf(\"error scanning line by line:\n\n                %s\\n\", err)\n\n        }\n\n    }\n    ```", "```go\n    func word(file *os.File) {\n\n        scanner := bufio.NewScanner(file)\n\n        scanner.Split(bufio.ScanWords)\n\n        wordCount := 0\n\n        for scanner.Scan() {\n\n            fmt.Printf(\"%d: %s\\n\", wordCount,\n\n                scanner.Text())\n\n          wordCount++\n\n        }\n\n        if err := scanner.Err(); err != nil {\n\n            fmt.Printf(\"error scanning by words: %s\\n\",\n\n                err)\n\n        }\n\n    }\n    ```", "```go\nif fileInfo, _ := os.Stdout.Stat(); (fileInfo.Mode() &\n    os.ModeCharDevice) != 0 {\n    fmt.Println(\"terminal\")\n} else {\n    fmt.Println(\"not a terminal\")\n}\n```", "```go\n./application tty\n```", "```go\nterminal\n```", "```go\nnot a terminal\n```", "```go\nOn branch {branch name}\nYour branch and 'origin/{branch name}' have diverged\nAnd have 1 and 1 different commits each, respectively.\n    (use \"git pull\" to merge the remote branch into yours)\nYou have unmerged paths.\n    (fix conflicts and run \"git commit\")\n    (use \"git merge –abort\" to abort the merge)\nUnmerged paths:\n    (use \"git add <file>...\" to mark resolution)\n             Both modified:     merge.json\n```", "```go\n==> Downloading https://ghcr.io/v2/homebrew/core/dav1d/manifests/1.0.0\n###########################################################\n############# 100.0%\n```"]