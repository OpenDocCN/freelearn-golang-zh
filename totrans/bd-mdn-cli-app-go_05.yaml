- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Defining the Command-Line Process
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义命令行过程
- en: 'At the core of a command-line application is its ability to process user input
    and return a result that either a user can easily comprehend or that another process
    can read as standard input. In [*Chapter 1*](B18883_01.xhtml#_idTextAnchor014),
    *Understanding CLI Standards*, we discussed the anatomy of a command-line application,
    but this chapter will go into detail on each aspect of its anatomy, breaking down
    the different types of input: subcommands, arguments, and flags. Additionally,
    other inputs will be discussed: `stdin`, signals, and control characters.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行应用程序的核心能力是处理用户输入并返回一个结果，这个结果要么用户可以轻松理解，要么其他进程可以将其作为标准输入读取。在[*第一章*](B18883_01.xhtml#_idTextAnchor014)《理解CLI标准》中，我们讨论了命令行应用程序的解剖结构，但本章将详细探讨其解剖结构的每个方面，分解不同类型的输入：子命令、参数和标志。此外，还将讨论其他输入：`stdin`、信号和控制字符。
- en: Just as there are many types of input that a command-line application can receive,
    there are many types of methods for processing data. This chapter won’t leave
    you hanging – examples of processing for each input type will follow.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如命令行应用程序可以接收许多类型的输入一样，处理数据的方法也有很多。本章不会让你失望——每种输入类型的处理示例将会随后提供。
- en: Finally, it’s just as important to understand how to return the result, either
    data if successful or an error on failure, in a way that both humans and computers
    can easily interpret.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，了解如何以人类和计算机都容易理解的方式返回结果，无论是成功时的数据还是失败时的错误，同样重要。
- en: 'This chapter will cover how to output the data for each end user and the best
    practices for CLI success. We will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何为每个最终用户输出数据以及CLI成功的最佳实践。我们将涵盖以下主题：
- en: Receiving the input and user interaction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收输入和用户交互
- en: Processing data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数据
- en: Returning the resulting output and defining best practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回结果输出并定义最佳实践
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To easily follow along with the code in this chapter, you will need to do the
    following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松跟随本章中的代码，你需要做以下事情：
- en: 'Download the following code: [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-In-Go/tree/main/Chapter05/application](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-In-Go/tree/main/Chapter05/application)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下载以下代码：[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-In-Go/tree/main/Chapter05/application](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-In-Go/tree/main/Chapter05/application)
- en: Receiving the input and user interaction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收输入和用户交互
- en: The primary methods for receiving input via a command-line application are through
    its subcommands, arguments, and options, also known as `stdin`, signals, and control
    characters. In this section, we’ll break down each different input type and when
    and how to interact with the user.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命令行应用程序接收输入的主要方法是通过其子命令、参数和选项，也称为`stdin`、信号和控制字符。在本节中，我们将分解每种不同的输入类型以及何时以及如何与用户交互。
- en: Defining subcommands, arguments, and flags
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义子命令、参数和标志
- en: 'Before we start characterizing the main types of input, let’s reiterate the
    structural pattern that explains the generalized location for each input type
    in terms of its predictability and familiarity. There’s an excellent description
    of the pattern within the **Cobra Framework documentation**. This is one of the
    best explanations because it compares the structure to natural language and, just
    like speaking and writing, the syntax needs to be properly interpreted:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始描述主要输入类型之前，让我们重申一下解释每种输入类型在可预测性和熟悉性方面的通用位置的架构模式。在**Cobra框架文档**中有对这种模式的出色描述。这是最好的解释之一，因为它将结构比作自然语言，就像说话和写作一样，语法需要正确解释：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **argument** is the noun and the **command or subcommand(s)** is the verb.
    Like any modifier, the **flag** is an adjective and adds description.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数**是名词，**命令或子命令**是动词。像任何修饰语一样，**标志**是形容词，并添加描述。'
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Most other programming languages suggest using two dashes instead of one. Go
    is unique in the fact that the single dash and double dash are equivalent to the
    internal flag package. It is important to note, however, that the Cobra CLI flag
    does differentiate between single and double dashes, where a single dash is for
    a short-form flag, and the double dash is for a long-form flag.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数其他编程语言建议使用两个连字符而不是一个。Go 是独特的，因为单连字符和双连字符与内部标志包等价。然而，需要注意的是，Cobra CLI 标志区分单连字符和双连字符，其中单连字符用于短形式标志，双连字符用于长形式标志。
- en: 'In the preceding example, the command and argument, or `NOUN VERB`, can also
    be ordered as `VERB NOUN`. However, `NOUN VERB` is more commonly used. Use what
    makes sense to you:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，命令和参数，或 `NOUN VERB`，也可以按 `VERB NOUN` 的顺序排列。然而，`NOUN VERB` 更常用。使用对你有意义的：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You might run up against limitations depending on your command-line parser.
    However, if possible, make arguments, flags, and subcommands order-independent.
    Now, let’s define each in more detail next and use **Cobra** to create a command
    that utilizes each input type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到命令行解析器的限制。然而，如果可能的话，使参数、标志和子命令的顺序无关。现在，让我们更详细地定义每个部分，并使用 **Cobra** 创建一个利用每种输入类型的命令。
- en: Commands and subcommands
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令和子命令
- en: At a very basic level, a command is a specific instruction given to a command-line
    application. In the pattern we just looked at, these are verbs. Think of the way
    we naturally speak. If we were to talk to a dog, we’d give it commands such as
    “*roll over*,” “*speak*,” or “*stay*.” Since you define the application, you can
    choose the verbs to define instructions. However, the most important thing to
    remember when choosing a command (and subcommand) is for names to be clear and
    consistent.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常基本层面上，命令是对命令行应用程序给出的特定指令。在我们刚才看到的模式中，这些是动词。想想我们自然说话的方式。如果我们与狗交谈，我们会给它下达命令，比如“*roll
    over*”、“*speak*”或“*stay*”。由于你定义了应用程序，你可以选择动词来定义指令。然而，在选择命令（和子命令）时，最重要的是记住名称要清晰且一致。
- en: 'Ambiguity can cause a lot of stress for a new user. Suppose you have two commands:
    `yarn update` and `yarn upgrade`. For a developer who is using `yarn` for the
    first time, do you think it’s clear how these commands are different? Clarity
    is paramount. Not only does it make your application easier to use but it also
    puts your developer at ease.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊性会给新用户带来很多压力。假设你有两个命令：`yarn update` 和 `yarn upgrade`。对于一个第一次使用 `yarn` 的开发者来说，你认为这些命令的不同之处是否清晰？清晰至关重要。这不仅使你的应用程序更容易使用，而且还能让开发者感到安心。
- en: As you gain a broad view of your application, you can intuitively determine
    more clear and more concise language when defining your commands. If your application
    feels a bit complex, you can utilize subcommands for simplification, and whenever
    possible, use familiar words for both commands and subcommands.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对应用程序有一个广泛的了解时，你可以直观地确定在定义命令时更清晰、更简洁的语言。如果你的应用程序感觉有点复杂，你可以利用子命令进行简化，并在可能的情况下，为命令和子命令使用熟悉的单词。
- en: 'Let’s use the **Docker** application as an example of how subcommands are clearly
    defined. Docker has a list of management commands such as the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 **Docker** 应用程序为例，说明子命令是如何明确定义的。Docker 有以下一系列管理命令：
- en: '`container` to manage containers'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container` 用于管理容器'
- en: '`image` to manage images'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image` 用于管理镜像'
- en: You’ll notice that when you run `docker` `container` or `docker` `image`, the
    usage is printed out, along with a list of subcommands, and you’ll also notice
    that there are several subcommands used across these two commands. They remain
    consistent.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当你运行 `docker` `container` 或 `docker` `image` 时，会打印出用法，以及一系列子命令，你也会注意到，这两个命令中使用了几个子命令。它们保持一致。
- en: Users of Docker know that the action (`ls`, `rm`, or `inspect`, for example)
    is related to the subject (`image` or `container`). The command follows the expected
    pattern of `"APPNAME ARGUMENT COMMAND"` – `docker` `image` `ls` and `docker` `container`
    `ls` too. Notice that `docker` also uses familiar Unix commands – `ls` and `rm`.
    Always use a familiar command where you can.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的用户知道，动作（例如 `ls`、`rm` 或 `inspect`）与主题（例如 `image` 或 `container`）相关。命令遵循预期的模式
    `"APPNAME ARGUMENT COMMAND"` – `docker` `image` `ls` 和 `docker` `container` `ls`
    也是如此。请注意，`docker` 也使用了熟悉的 Unix 命令 – `ls` 和 `rm`。始终在可能的情况下使用熟悉的命令。
- en: 'Using the Cobra CLI, let’s make two commands, with one as a subcommand of the
    other. Here’s the first command we’ll add:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cobra CLI，让我们创建两个命令，其中一个作为另一个的子命令。以下是我们要添加的第一个命令：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, add the subcommand:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加子命令：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, create it as a subcommand by modifying the default line to run `AddCommand`
    on `commandCmd`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过修改默认行以在 `commandCmd` 上运行 `AddCommand` 来将其创建为子命令：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The Cobra CLI makes it incredibly easy not only to create commands but also
    subcommands as well. Now, when the command is called with the subcommand, we get
    confirmation that the subcommand is called:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Cobra CLI 使得创建命令及其子命令变得极其简单。现在，当使用子命令调用命令时，我们得到确认子命令已被调用的信息：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let us understand arguments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解参数。
- en: Arguments
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: Arguments are nouns – things – that are acted upon by the command. They are
    positional to the command and usually come before the command. The order is not
    strict; just be consistent with the order throughout your application. However,
    the very first argument is the application name.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是名词——被命令作用的对象。它们位于命令的位置，通常位于命令之前。顺序不是严格的；只需在整个应用程序中保持顺序的一致性即可。然而，第一个参数是应用程序名称。
- en: Multiple arguments are okay for actions against multiple files, or multiple
    strings of input. Take, for example, the `rm` command and removing multiple files.
    For example, `rm arg1.txt arg2.txt arg3.txt` would act on (by removing) the multiple
    files listed after the command. Allow globbing where it makes sense. If a user
    wants to remove all the text files in the current directory, then an example of
    `rm *.txt` would also be expected to work. Now, consider the `mv` command, which
    requires two arguments for the source and target files. An example of `mv old.txt
    new.txt` will move `old.txt`, the source, to the target, `new.txt`. Globs may
    also be used with this command.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于针对多个文件或多个输入字符串的操作，多个参数是可以接受的。以 `rm` 命令和删除多个文件为例。例如，`rm arg1.txt arg2.txt arg3.txt`
    将对命令之后列出的多个文件（通过删除）进行操作。允许在合理的地方使用通配符。如果用户想要删除当前目录中的所有文本文件，那么 `rm *.txt` 的例子也应该可以工作。现在，考虑
    `mv` 命令，它需要两个参数，用于源文件和目标文件。`mv old.txt new.txt` 的例子将把源文件 `old.txt` 移动到目标文件 `new.txt`。通配符也可以与这个命令一起使用。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Having multiple arguments for *different* things might mean rethinking the way
    that you’re structuring your command. It could also mean that you could be utilizing
    flags here instead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同的事情有多个参数可能意味着需要重新思考您构建命令的方式。这也可能意味着您可以使用标志来代替。
- en: 'Again, familiarity plays in your favor. Use the standard name if there is one
    and your users will thank you. Here are examples of some common arguments: `history`,
    `tag`, `volume`, `log`, and `service`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，熟悉对您有利。如果有标准名称，请使用它，您的用户会感谢您。以下是一些常见参数的例子：`history`、`tag`、`volume`、`log`
    和 `service`。
- en: 'Let’s modify the subcommand’s generated `Run` field to identify and print out
    its arguments:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改子命令生成的 `Run` 字段，以识别并打印出其参数：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, when we run the same subcommand with arguments, the following output is
    printed out:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们用参数运行相同的子命令时，以下输出将被打印出来：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Interestingly, flags can provide more clarity over arguments. In general, it
    does require more typing, but flags can make it more clear what’s going on. Another
    additional benefit is if you decide to make changes to how you receive input,
    it’s much easier to add or remove a flag than it is to modify an existing command,
    which can break things.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，标志可以为参数提供更多的清晰度。一般来说，它确实需要更多的输入，但标志可以使正在发生的事情更加清晰。另一个额外的优点是，如果您决定更改接收输入的方式，添加或删除标志比修改现有命令（这可能会破坏某些东西）要容易得多。
- en: Flags
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标志
- en: 'Flags are adjectives that add a description to an action or command. They are
    named parameters and can be denoted in different ways, with or without a user-specified
    value:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 标志是形容词，为动作或命令添加描述。它们是有名称的参数，可以用不同的方式表示，带有或不带有用户指定的值：
- en: A `-h`)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A `-h`)
- en: A `--help`)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A `--help`)
- en: A `--file audio.txt`, or `–-file=audio.txt`)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A `--file audio.txt`, 或 `–-file=audio.txt`)
- en: It’s important to have full-length versions of all flags – single letters are
    only useful for commonly used flags. If you use single letters for all available
    flags, there may be more than one flag that starts with that same letter, and
    that single letter would make sense intuitively for more than one flag. This can
    add confusion, so it’s best not to clutter the list of single-letter flags.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有所有标志的全长版本很重要——单个字母仅适用于常用标志。如果您为所有可用的标志使用单个字母，则可能有多个标志以相同的字母开头，并且这个单个字母对多个标志来说在直观上是有意义的。这可能会造成混淆，因此最好不要使单字母标志列表过于杂乱。
- en: Single-letter flags may also be concatenated together. For example, take the
    `ls` command. You can run `ls -l -h -F` or `ls -lhF` and the result is the same.
    Obviously, this depends on the command-line parser used, but because CLI applications
    typically allow you to concatenate single-letter flags, it’s a good idea to allow
    this as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单字母标志也可以连接在一起。例如，考虑`ls`命令。你可以运行`ls -l -h -F`或`ls -lhF`，结果是一样的。显然，这取决于所使用的命令行解析器，但由于CLI应用程序通常允许你连接单字母标志，因此允许这样做是个好主意。
- en: Finally, the flag order is typically not strict, so whether a user runs `ls
    –lhF`, `ls –hFl`, or `ls –Flh`, the result is the same.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，标志的顺序通常不是严格的，所以用户运行`ls –lhF`、`ls –hFl`或`ls –Flh`，结果都是相同的。
- en: 'As an example, we can add a couple of flags to the root command, one local
    and another persistent, meaning that it’s available to the command and all subcommands.
    In `commandCmd`, within the `init()` function, the following lines do just that:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们可以在根命令中添加一些标志，一个本地和一个持久，这意味着它对命令及其所有子命令都可用。在`commandCmd`中，在`init()`函数内，以下这些行正是这样做的：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In `commandCmd`’s `Run` field, we add these lines:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`commandCmd`的`Run`字段中，我们添加以下这些行：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `subcommandCmd`’s `Run` field, we also add the following lines:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`subcommandCmd`的`Run`字段中，我们也添加以下这些行：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, when we compile the code and run it again, we can test out both flags.
    Notice that there are multiple ways of passing in flags and in both cases, the
    results are the same:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们编译代码并再次运行它时，我们可以测试这两个标志。请注意，有几种传递标志的方式，在两种情况下，结果都是相同的：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The persistent flag, although defined at the `commandCmd` level, is available
    within `subcommandCmd`, and when the flag is missing, the default value is used:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 持久标志，尽管在`commandCmd`级别定义，但在`subcommandCmd`中可用，并且当标志缺失时，使用默认值：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we’ve covered the most common methods of receiving input to your CLI:
    commands, arguments, and flags. The next methods of input include piping, signal
    and control characters, and direct user interaction. Let’s dive into these now.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经介绍了接收CLI输入的最常见方法：命令、参数和标志。接下来要介绍的方法包括管道、信号和控制字符，以及直接的用户交互。让我们现在深入探讨这些内容。
- en: Piping
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道
- en: In Unix, piping redirects the standard output of one command-line application
    into the standard input of another. It is represented by the ‘`|`’ character,
    which combines two or more commands. The general structure is `cmd1 | cmd2 |cmd3
    | .... | cmdN`, the standard output from `cmd1` is the standard input for `cmd2`,
    and so on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix中，管道将一个命令行应用程序的标准输出重定向到另一个命令行应用程序的标准输入。它由`|`字符表示，它组合了两个或多个命令。一般结构是`cmd1
    | cmd2 |cmd3 | .... | cmdN`，`cmd1`的标准输出是`cmd2`的标准输入，依此类推。
- en: 'Creating a simple command-line application that does one thing and one thing
    well follows the Unix philosophy. It reduces the complexity of a single CLI, so
    you’ll see many examples of different applications that can be chained together
    by pipes. Here are a few examples:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的命令行应用程序，只做一件事并且做得很好，遵循Unix哲学。它简化了单个CLI的复杂性，因此你会看到许多可以将它们通过管道连接在一起的不同应用程序的示例。以下是一些示例：
- en: '`cat file.txt | grep "word" |` `sort`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cat file.txt | grep "word" | sort`'
- en: '`sort list.txt |` `uniq`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort list.txt | uniq`'
- en: '`find . -type f –name main.go |` `grep audio`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find . -type f –name main.go | grep audio`'
- en: 'As an example, let’s create a command that takes in standard input from a common
    application. Let’s call it `piper`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们创建一个从常见应用程序接收标准输入的命令。让我们称它为`piper`：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the newly generated `piperCmd`’s `Run` field, add the following lines:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新创建的`piperCmd`的`Run`字段，添加以下这些行：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, compile and run the `piper` command with some piped-in input:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用一些管道输入编译并运行`piper`命令：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, suppose your command has a standard output that is written to a broken
    pipe; the kernel will raise a `SIGPIPE` signal. This is received as input to the
    command-line application, which can then output an error regarding the broken
    pipe. Besides receiving signals from the kernel, other signals, such as `SIGINT`,
    can be triggered by users who press control character key combinations such as
    *Ctrl + C* that interrupt the application. This is just one type of signal and
    control character, but more will be discussed in the following section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你的命令有一个标准输出被写入一个损坏的管道；内核将引发一个`SIGPIPE`信号。这被作为命令行应用程序的输入接收，然后可以输出有关损坏管道的错误。除了从内核接收信号外，其他信号，如`SIGINT`，可以由按下控制字符键组合（如*Ctrl
    + C*）来中断应用程序的用户触发。这只是信号和控制字符的一种类型，但将在下一节中讨论更多。
- en: Signals and control characters
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号和控制字符
- en: 'As the name implies, signals are another way to communicate specific and actionable
    input by signaling to a command-line application. Sometimes, these signals can
    be from the kernel, or from users that press control characters key combinations
    and trigger signals to the application. There are two different types of signals:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，信号是通过向命令行应用程序发出信号来通过信号传递特定和可操作输入的另一种方式。有时，这些信号可能来自内核，或者来自按下控制字符键组合的用户，从而触发发送给应用程序的信号。有两种不同类型的信号：
- en: '`SIGBUS`, `SIGFPE`, and `SIGSEGV`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGBUS`、`SIGFPE`和`SIGSEGV`。'
- en: '`SIGHUP`, `SIGINT`, `SIGQUIT`, and `SIGPIPE`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGHUP`、`SIGINT`、`SIGQUIT`和`SIGPIPE`。'
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A few signals, such as `SIGKILL` and `SIGSTOP`, may not be caught by a program,
    so utilizing the `os/signal` package for custom handling will not affect the result.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一些信号，如`SIGKILL`和`SIGSTOP`，可能不会被程序捕获，因此使用`os/signal`包进行自定义处理不会影响结果。
- en: 'There is a lot to discuss in depth on signals, but the main point is that they
    are just another method of receiving input. We’ll stay focused on how this data
    is received by the command-line application. The following is a table explaining
    some of the most commonly used signals, control character combinations, and their
    descriptions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在信号方面有很多深入讨论的内容，但主要观点是它们只是接收输入的另一种方法。我们将专注于数据是如何被命令行应用程序接收的。以下是一个表格，解释了一些最常用的信号、控制字符组合及其描述：
- en: "![Figure \uFEFF5.1 – Table of signals with related key combinations and descriptions](img/Figure_5.01.jpg)"
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 信号及其相关键组合和描述的表格](img/Figure_5.01.jpg)'
- en: Figure 5.1 – Table of signals with related key combinations and descriptions
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 信号及其相关键组合和描述的表格
- en: 'The following are two function calls added to `rootCmd` to handle exiting your
    application with grace when a `SIGINT` or `SIGTSTP` signal is received. The `Execute`
    function that calls `rootCmd` now looks like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`rootCmd`中添加的两个函数调用，用于在接收到`SIGINT`或`SIGTSTP`信号时优雅地退出您的应用程序。现在调用`rootCmd`的`Execute`函数看起来是这样的：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `SetupInterruptHandler` code is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupInterruptHandler`代码如下：'
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similarly, the `SetupStopHandler` code is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`SetupStopHandler`代码如下：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we’ll need a command to interrupt or stop the application. Let’s use the
    Cobra CLI and add a `sleep` command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个命令来中断或停止应用程序。让我们使用Cobra CLI并添加一个`sleep`命令：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Run` field of `sleepCmd` is changed to run an infinite loop that prints
    out some Zs (`Zzz`) until a signal interrupts the `sleep` command and wakes it
    up:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleepCmd`的`Run`字段被更改为运行一个无限循环，打印出一些Z（`Zzz`），直到信号中断`sleep`命令并唤醒它：'
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By running the `sleep` command and then using *Ctrl + C*, we get the following
    output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`sleep`命令然后使用*Ctrl + C*，我们得到以下输出：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Trying again but now using *Ctrl + Z*, we get the following output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试，但现在使用*Ctrl + Z*，我们得到以下输出：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can utilize signals to interrupt or quit your application gracefully or
    take action when an alarm is triggered. While commands, arguments, and flags are
    the most commonly known types of input for command-line applications, it is important
    to consider handling these signal inputs to create a more robust application.
    If a terminal hangs and `SIGHUP` is received, your application can save information
    on the last state and handle cleanup where necessary. In this case, while it’s
    not as common, it’s just as important.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用信号来优雅地中断或退出您的应用程序，或者在警报触发时采取行动。虽然命令、参数和标志是命令行应用程序最常见类型的输入，但考虑处理这些信号输入以创建更健壮的应用程序是很重要的。如果一个终端挂起并且收到`SIGHUP`信号，您的应用程序可以保存最后状态的信息并在必要时处理清理。在这种情况下，虽然这种情况并不常见，但同样重要。
- en: User interaction
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户交互
- en: Although your user input can be in the form of commands, arguments, and flags,
    user interaction is more of a back-and-forth interaction between the user and
    the application. Suppose a user misses a required flag for a particular subcommand
    – your application can prompt the user and receive the value for that flag via
    standard input. Sometimes, rather than utilizing the more standard input of commands,
    arguments, and flags, an interactive command-line application can be built instead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您的用户输入可以是命令、参数和标志的形式，但用户交互更多的是用户与应用程序之间的来回交互。假设用户错过了一个特定子命令所需的标志，您的应用程序可以提示用户并通过标准输入接收该标志的值。有时，而不是使用更标准的命令、参数和标志的输入，可以构建一个交互式命令行应用程序。
- en: 'An interactive CLI would prompt for input and then receive it through `stdin`.
    There are some useful packages for building interactive and accessible prompts
    in Go. For the following examples, we’ll use the [https://github.com/AlecAivazis/survey](https://github.com/AlecAivazis/survey)
    package. There are multiple fun ways to prompt input using the `survey` package.
    A `survey` command will ask questions that need to be stored in a variable. Let’s
    define it as `qs`, a slice of the `*``survey.Question` type:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个交互式 CLI 会提示输入，然后通过 `stdin` 接收输入。在 Go 中有一些有用的包用于构建交互式和可访问的提示。在以下示例中，我们将使用 [https://github.com/AlecAivazis/survey](https://github.com/AlecAivazis/survey)
    包。使用 `survey` 包有多种提示输入的有趣方式。一个 `survey` 命令会询问需要存储在变量中的问题。让我们将其定义为 `qs`，一个 `*survey.Question`
    类型的切片：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`survey` can prompt the user for different types of input, as defined here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`survey` 可以提示用户输入不同类型的数据，如以下所示：'
- en: '**Simple** **text input**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单** **文本输入**'
- en: 'At a very basic level, users can receive basic text input:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常基本的层面上，用户可以接收基本的文本输入：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Suggesting options**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建议选项**'
- en: 'This terminal option allows you to give the user suggestions for the prompted
    question:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此终端选项允许您为提示问题提供用户建议：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Hitting the *Tab* key will show the available options:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 *Tab* 键将显示可用选项：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Inputting** **multiple lines**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入** **多行**'
- en: 'When receiving input, sometimes, pressing the *Return* key will immediately
    pass any text received before directly as input to the program. Utilizing the
    `survey` package allows you to enter multiple lines before receiving input:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收输入时，有时按下 *Return* 键会立即将接收到的任何文本直接作为输入传递给程序。利用 `survey` 包允许您在接收输入之前输入多行：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Protecting** **password input**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护** **密码输入**'
- en: 'To keep data private, when inputting private information, the `survey` package
    will replace the characters with `*` symbols:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护数据隐私，在输入个人信息时，`survey` 包会将字符替换为 `*` 符号：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Confirming with Yes** **or No**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确认** **是** **或** **否**'
- en: 'Users can respond with a simple yes or no to the command prompt:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以对命令提示符简单地回答是或否：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, let us see how to select from a checkbox option.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何从复选框选项中选择。
- en: '**Selecting from a** **checkbox option**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从复选框选项中选择**'
- en: 'Multiple options can be selected within a vertical checkbox option. Navigating
    the options is done with the up and down arrows, and selecting is done with the
    spacebar:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在垂直复选框选项中可以选择多个选项。使用上下箭头导航选项，使用空格键选择：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a new `survey` command with the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方式创建一个新的 `survey` 命令：
- en: '`cobra-cli` `add survey`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`cobra-cli` `add survey`'
- en: 'The `Run` field of `surveyCmd` creates a struct that receives all the answers
    to questions asked:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`surveyCmd` 的 `Run` 字段创建一个结构体，用于接收所有问题的答案：'
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `Ask` method then takes in the questions, `qs`, and then receives all the
    answers to the questions asked into a pointer to the `answers` struct:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `Ask` 方法接收问题 `qs`，并将所有问题的答案接收到一个指向 `answers` 结构体的指针中：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, the results are printed out:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，结果将被打印出来：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Testing out the `survey` command, we get the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 `survey` 命令，我们得到以下结果：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Although these examples are just a selection of the many input prompts provided
    by the `survey` package, you can visit the GitHub page to view examples of all
    the possible options. Playing around with prompts reminds me of early text-based
    RPG games that used them to prompt the gamer’s character. Having learned about
    the many different types of input, whether user-based, from the kernel, or from
    other piped applications, let’s discuss how to process this incoming data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些示例只是 `survey` 包提供的许多输入提示中的一部分，但您可以访问 GitHub 页面查看所有可能选项的示例。玩弄提示让我想起了早期基于文本的角色扮演游戏，它们使用它们来提示玩家的角色。在了解了多种不同类型的输入后，无论是基于用户的、来自内核的，还是来自其他管道应用程序的，让我们讨论如何处理这些传入的数据。
- en: Processing data
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据
- en: '`123`, we can do a type check by utilizing the `strconv` package’s `Atoi` method,
    which converts an ASCII string into an integer:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`123`，我们可以通过利用 `strconv` 包的 `Atoi` 方法进行类型检查，该方法将 ASCII 字符串转换为整数：'
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If the string value cannot be converted because it isn’t a string representation
    of an integer, then an error will be thrown. If the string is a representation
    of an integer, then the integer value will be stored in the `val` variable.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串值无法转换，因为它不是整数的字符串表示，则会抛出错误。如果字符串是整数的表示，则整数值将存储在 `val` 变量中。
- en: The `strconv` package can be used to check, with conversion, many other types,
    including Boolean, float, and `uint` values as well.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`strconv`包可用于检查、转换许多其他类型，包括布尔值、浮点值和`uint`值等。'
- en: 'Flags, on the other hand, can have predefined types. Within the Cobra framework,
    the `pflag` package is used, which is just an extension of the standard go `flag`
    package. For example, when a flag is defined, you can define it specifically as
    a `String`, `Bool`, `Int`, or custom type. The preceding `123` value, if read
    in as an `Int` flag, could be defined with the following lines of code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，标志可以具有预定义的类型。在Cobra框架中，使用的是`pflag`包，它只是标准go `flag`包的扩展。例如，当定义一个标志时，您可以将其明确定义为`String`、`Bool`、`Int`或自定义类型。如果将前面的`123`值作为`Int`标志读取，可以使用以下代码行定义：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This can be done similarly for `String` and `Bool` flags. You can even create
    a flag with a custom, specific interface using the `Var` method:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于`String`和`Bool`标志。您甚至可以使用`Var`方法创建具有自定义、特定接口的标志：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Just ensure that the `Custom` struct satisfies the following interface defined
    within the `pflag` package for custom flags:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`Custom`结构满足`pflag`包内定义的以下接口，以用于自定义标志：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'I defined the `Custom` struct as the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`Custom`结构定义为以下内容：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Therefore, the `Set` method is simply defined as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Set`方法简单地定义为以下内容：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Passing the value into the flag was handled by `flag: --name="custom value`.
    The `String` method is then used to print the value:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '将值传递给标志由`flag: --name="custom value"`处理。然后使用`String`方法打印值：'
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It looks like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Besides passing in string values that can be converted into different types,
    oftentimes, a path to a file is passed in. There are multiple ways of reading
    data from files. Let’s list each, along with a method to handle this way of reading
    in a file and a pro and a con for each:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传递可以转换为不同类型的字符串值之外，通常还会传递一个指向文件的路径。有多种从文件中读取数据的方法。让我们列出每种方法，以及处理这种读取文件方式的方法，以及每种方法的优缺点：
- en: '`os.ReadFile` method reads the entire file and returns its contents. It does
    not error when encountering the **end of** **file** (**EOF**):'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.ReadFile`方法读取整个文件并返回其内容。在遇到**文件结束**（**EOF**）时不会出错：'
- en: '[PRE43]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Pros**: Faster performance'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：性能更快'
- en: '**Cons**: Consumes more memory in a shorter amount of time'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：在较短时间内消耗更多内存'
- en: '`file.Read` method reads in the buffer at its predetermined size and returns
    the bytes, which can be printed after being cast as a string. Unlike the `ioutil.ReadFile`
    method, `file.Read` from the buffer will error when it reaches the EOF:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file.Read`方法以预定的缓冲区大小读取缓冲区，并返回字节，这些字节在转换为字符串后可以打印。与`ioutil.ReadFile`方法不同，从缓冲区读取`file.Read`会在达到EOF时出错：'
- en: '[PRE44]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Pros**: Easy to implement, consumes little memory'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：易于实现，消耗内存少'
- en: '**Cons**: If the chunks are not properly chosen, you may have inaccurate results,
    increased complexity when comparing or analyzing the data, and potential error
    propagation.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：如果选择的块不正确，可能会导致结果不准确，比较或分析数据时复杂性增加，以及潜在的错误传播。'
- en: '`split` function. The `scanner.Text()` method reads into the next token that
    delimits each scan – in the following example, line by line. Finally, `scanner.Scan()`
    does not return an error when it encounters the EOF:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split`函数。`scanner.Text()`方法读取到下一个分隔每个扫描的标记——在以下示例中，是逐行。最后，`scanner.Scan()`在遇到EOF时不会返回错误：'
- en: '[PRE45]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Pros**: Easy to implement – an intuitive way to read in data and output data.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：易于实现——一种直观的数据读取和输出方式。'
- en: '**Cons**: Processing an extremely large file may cause memory constraints.
    Increased complexity may cause inaccurate results, if the data is not well suited
    to line by line processing.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：处理非常大的文件可能会导致内存限制。如果数据不适合逐行处理，增加的复杂性可能会导致结果不准确。'
- en: '`Split` function, pass `bufio.ScanWords` into the `Split` function. This will
    then define the tokens between each word and scan between each token. Again, scanning
    in this way will not encounter an error at the EOF either:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Split`函数，将`bufio.ScanWords`传递给`Split`函数。这样就会定义每个单词之间的标记，并在每个标记之间进行扫描。再次强调，以这种方式扫描不会在EOF处遇到错误：'
- en: '[PRE46]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Pros**: Easy to implement – an intuitive way to read data and output data'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：易于实现——一种直观的数据读取和输出方式'
- en: '**Cons**: Inefficient and time consuming for large files. Increased complexity
    may cause inaccurate results, if the data is not well suited to word by word processing'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：对于大文件来说，效率低下且耗时。如果数据不适合逐词处理，增加的复杂性可能会导致结果不准确。'
- en: 'Choosing the way to handle processing the data received from the file depends
    on the use case. Additionally, there are three main types of data processing:
    batch, online, and real-time.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 选择处理从文件接收到的数据的方式取决于用例。此外，主要有三种数据处理类型：批量、在线和实时。
- en: As you can guess from the name, batch processing takes similar tasks that are
    collected, or batched, and then runs them simultaneously. Online processing requires
    internet connectivity to reach an API endpoint to fully process data and return
    a result. Real-time processing is the execution of data in such a short period
    that the data is instantaneously output.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从名称中可以猜到的，批量处理收集或分批收集的类似任务，然后同时运行它们。在线处理需要互联网连接以到达API端点，以完全处理数据并返回结果。实时处理是在极短的时间内执行数据，数据被即时输出。
- en: Examples of different use cases requiring a specific type of processing vary.
    Bank transactions, billing, and reporting often use batch processing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特定类型处理的不同用例的示例各不相同。银行交易、计费和报告通常使用批量处理。
- en: A CLI that utilizes an API behind the scenes would often require internet access
    to handle online processing. Real-time processing is used when timeliness is of
    utmost importance, often in manufacturing, fraud detection, and computer vision
    tools.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后使用API的CLI通常会需要互联网访问来处理在线处理。当及时性至关重要时，会使用实时处理，通常在制造业、欺诈检测和计算机视觉工具中。
- en: Once the data has been processed, the result must be returned to the user or
    receiving process. In the next section, we will discuss the details of returning
    the output and defining the best practices for returning data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被处理，结果必须返回给用户或接收进程。在下一节中，我们将讨论返回输出的细节和定义返回数据的最佳实践。
- en: Returning the resulting output and defining best practices
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回结果输出和定义最佳实践
- en: When returning output from a process, it’s important to know to who or what
    you’re returning data. It’s incredibly important to return output that’s human-readable.
    However, to determine whether you’re returning data to a human or a machine, check
    whether you’re writing to a TTY. Remember TTY? You can refer to [*Chapter 1*](B18883_01.xhtml#_idTextAnchor014),
    *Understanding CLI Standards*, in which we discussed the history of the CLI interface
    and the term TTY, short for teletypewriter or teletype.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当从进程返回输出时，了解您返回数据给谁或什么非常重要。返回可读性强的输出至关重要。然而，为了确定您是否将数据返回给人类或机器，请检查您是否正在写入TTY。还记得TTY吗？您可以参考[*第1章*](B18883_01.xhtml#_idTextAnchor014)，*理解CLI标准*，其中我们讨论了CLI界面的历史和TTY术语，即电传打字机或电传打字机。
- en: If writing to a TTY, we can check whether the `stdout` file descriptor refers
    to a terminal or not, and change the output depending on the result.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果写入TTY，我们可以检查`stdout`文件描述符是否指向一个终端，并根据结果更改输出。
- en: 'Let’s check out this block of code, which checks whether the `stdout` file
    descriptor is writing to a TTY or not:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下代码块，该代码块检查`stdout`文件描述符是否正在写入TTY：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s call it within the `Run` method of a command called `tty` using the following
    command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在名为`tty`的命令的`Run`方法中使用以下命令调用它：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, the output is as follows,:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输出如下：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'However, if we pipe the output to a file by calling `./application tty > file.txt`,
    then the contents of the file are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们通过调用`./application tty > file.txt`将输出管道到一个文件，那么文件的内容如下：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Certainly, it makes sense to add colored ASCII text when returning output to
    a human, but that’s often useless and extraneous information for output to a machine
    process.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当向人类返回输出时添加彩色ASCII文本是有意义的，但对于机器处理输出来说，这通常是无用的且是额外信息。
- en: When writing output, always put humans first, specifically in terms of usability.
    However, if the machine-readable output does not affect usability, then output
    in machine-readable output. Because streams of text are universal input in Unix,
    it’s typical for programs to be linked together by pipes. The output is typically
    lines of text, and programs expect input as lines of text as well. A user should
    expect to write output that can easily be grepped. You cannot know for sure where
    the output will be sent to and which other processes may be consuming the output.
    Always check whether the output is sent to a terminal and print for another program
    if it’s not. However, if using a machine-readable output breaks usability, but
    the human-readable output cannot be easily processed by another machine process,
    default to human-readable output and then define the `–plain` flag to display
    this output as machine-readable output. Clean lines of text in tabular format
    are easily integrated with `grep` and `awk`. This gives the user the choice to
    define the format of the output.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写输出时，始终将人类放在首位，特别是在可用性的方面。然而，如果机器可读的输出不影响可用性，那么输出机器可读的输出。由于文本流是 Unix 中的通用输入，程序通常通过管道链接在一起。输出通常是文本行，程序也期望以文本行作为输入。用户应该期望编写可以轻松使用
    `grep` 搜索的输出。你无法确定输出将被发送到何处，以及哪些其他进程可能正在消耗输出。始终检查输出是否发送到终端，如果不是，则为另一个程序打印。然而，如果使用机器可读的输出会破坏可用性，但人类可读的输出又不能被另一个机器进程轻松处理，则默认使用人类可读的输出，并定义
    `–plain` 标志以将此输出显示为机器可读的输出。以表格格式整洁的文本行可以轻松与 `grep` 和 `awk` 集成。这使用户可以选择定义输出的格式。
- en: Beyond defining the output for humans versus machines, it’s standard to add
    a flag to define a specific format for the data returned. The `–json` flag is
    used when requesting data to be returned in JSON format and the `–xml` flag is
    used to request XML format. There’s a Unix tool, `jq`, that can be integrated
    with a program’s JSON output. In fact, this tool can manipulate any data returned
    in JSON format. Many tools within the Unix ecosystem take advantage of this and
    you can too.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义针对人类和机器的输出之外，通常还会添加一个标志来定义返回数据的特定格式。当请求以 JSON 格式返回数据时，使用 `–json` 标志，而请求
    XML 格式时使用 `–xml` 标志。有一个 Unix 工具 `jq` 可以与程序的 JSON 输出集成。实际上，这个工具可以操作任何以 JSON 格式返回的数据。Unix
    生态系统中的许多工具都利用了这一点，你也可以这样做。
- en: Historically, because many of the older Unix programs were written for scripts
    or other programs, often, no output is returned on success. This can be confusing
    for users. Success cannot always be assumed, so it’s ideal to display output on
    success. There’s no reason to elaborate, so keep it brief and informative. Defining
    a `–quit` (or `–q`) flag can suppress unnecessary information if necessary.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，由于许多较老的 Unix 程序是为脚本或其他程序编写的，通常在成功时不会返回任何输出。这可能会使用户感到困惑。不能总是假设成功，因此显示输出是理想的。没有必要详细说明，所以保持简明扼要且信息丰富。如果需要，定义一个
    `–quit`（或 `–q`）标志可以抑制不必要的信息。
- en: Sometimes, a CLI can keep track of the state. The `git status`. This information
    needs to be transparent to the user, as it can often confirm the result of an
    action expected to change the state. The user understands their possible next
    steps by knowing the state.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，CLI 可以跟踪状态。例如 `git status`。这些信息需要对用户透明，因为它经常可以确认预期改变状态的预期结果。用户通过了解状态，可以理解他们可能的下一步行动。
- en: 'Some of these next steps may also be suggested to the user. In fact, it’s ideal
    to give users suggestions because it feels like they are being guided along, rather
    than left alone in the wild with a new CLI application. When a user first interacts
    with a CLI, it’s best to make the learning experience similar to a guided adventure.
    Let’s give a quick example in regard to GitHub’s CLI. Consider when you have to
    merge the main branch into your current branch. Now and then, there’ll be conflicts
    after the merge, and the CLI guides you when you check `git status`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些后续步骤中的一些也可能被建议给用户。事实上，向用户提供建议是理想的，因为这会给人一种被引导的感觉，而不是在野外独自使用一个新的 CLI 应用程序。当用户第一次与
    CLI 互动时，最好让学习体验类似于一个引导冒险。让我们以 GitHub 的 CLI 为例，快速给出一个例子。考虑当你需要将主分支合并到当前分支时。合并后，有时会出现冲突，当你在
    `git status` 中检查时，CLI 会引导你：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The response reminds the user of their current branch and state, as well as
    suggesting different options that the user could take. Not all CLIs handle the
    state, but when you do, it’s best to make it well known and provide users with
    a clear path forward.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 响应会提醒用户当前的分支和状态，以及建议用户可以采取的不同选项。并非所有CLI都处理状态，但当你这么做时，最好让它广为人知，并为用户提供清晰的下一步路径。
- en: If there’s any communication with a remote server, reading or writing of files
    (except for a cache), or any other actions that cross the boundary of the program’s
    internals, communicate those actions to the user. I love HomeBrew’s `install`
    command on their CLI. It’s clear exactly what’s going on behind the scenes when
    you use `brew install` for an application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何与远程服务器的通信，文件的读取或写入（除了缓存），或任何跨越程序内部边界的其他操作，都要将这些操作通知用户。我喜欢HomeBrew的CLI上的`install`命令。当你使用`brew
    install`安装应用程序时，幕后发生的事情非常清晰。
- en: 'When a file is being downloaded or created, it’s clearly stated:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当正在下载或创建文件时，会明确指出：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: And look how hashtags are used to designate progress – they utilize ASCII characters
    in a way that increases information density. I love the cold glass of beer icon
    next to files existing in the `Cellar` folder. It makes you think of all the brew
    formulas existing inside a beer cellar. **Emojis** are worth a thousand words.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 看看如何使用哈希标签来指定进度——它们以增加信息密度的这种方式使用ASCII字符。我喜欢`Cellar`文件夹中文件旁边的冰镇啤酒图标。这会让你想到啤酒地窖中存在的所有酿酒配方。**表情符号**价值千言万语。
- en: When an error is evoked, the text is displayed in red, intending to evoke a
    sense of urgency and alertness. Color, if used, must be used intentionally. A
    green failure, or red success, is confusing for users. I’m certain, just like
    utilizing ASCII art to increase information density, color has the same purpose.
    A green success cannot be mistaken easily for a failure, and vice versa. Make
    sure to make important information stand out by using colors infrequently. Too
    many colors will make it difficult for anything to stand out.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当引发错误时，文本以红色显示，目的是唤起紧迫感和警觉性。如果使用颜色，必须有意为之。绿色的失败或红色的成功对用户来说都是令人困惑的。我确信，就像利用ASCII艺术来增加信息密度一样，颜色也有同样的目的。绿色的成功不容易被误认为是失败，反之亦然。确保通过不频繁使用颜色来使重要信息突出。过多的颜色会使任何东西都难以突出。
- en: 'However, while color may excite some of us, it annoys others. There may be
    any number of reasons why someone may want to disable the color in their CLI.
    For whatever reason to continue in a black-and-white world, there are specific
    times color should not be used:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然颜色可能会让一些人兴奋，但它会惹恼其他人。可能有无数个原因让某人想在CLI中禁用颜色。无论出于什么原因继续在黑白世界中前行，都有特定的时候不应该使用颜色：
- en: When piping to another program
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将数据管道传输到另一个程序时
- en: When the `NO_COLOR` environment variable is set
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置`NO_COLOR`环境变量时
- en: When the `TERM` environment variable is set to `dumb`
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`TERM`环境变量设置为`dumb`时
- en: When the `–no-color` flag is passed
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递`–no-color`标志时
- en: When your app’s `MYAPP_NO_COLOR` environment variable is set
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的应用的`MYAPP_NO_COLOR`环境变量被设置时
- en: It goes without saying that if we don’t allow colors, we don’t allow animations
    either! Well, I won’t tell you what to do, just try it for yourself – pipe an
    animation to a file via `stdout`. I dare you! You might end up with some great
    ASCII art, but it will be busy and difficult to understand the data. The goal
    is clarity. With ASCII art, color intent, and animations to increase the information
    density, we need to understand at some point that we need to use clear words that
    are understood by all. Consider your wording from the perspective of someone who
    is using your CLI for the first time. Guide users with your words.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不允许使用颜色，那么动画也不允许！好吧，我不会告诉你该怎么做，只是让你亲自试试——通过`stdout`将动画管道传输到文件。我敢打赌！你可能会得到一些很棒的ASCII艺术，但它会显得很忙，难以理解数据。目标是清晰。使用ASCII艺术、颜色意图和动画来增加信息密度，我们最终需要明白我们需要使用所有人都理解清晰的文字。从第一次使用你的CLI的用户的角度考虑你的措辞。用你的话引导用户。
- en: As for printing log output, only do so under the verbose mode, represented by
    the `–verbose` flag and `–v` for short. Don’t use the `stderr` file descriptor
    as a log file.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 至于打印日志输出，只有在详细模式下才这么做，详细模式由`–verbose`标志和简写的`–v`表示。不要使用`stderr`文件描述符作为日志文件。
- en: If a CLI outputs a lot of text at once, such as `git diff`, a pager is used.
    Thank goodness. This makes it so much easier to page through the output to review
    differences rather than receiving all the text at once. This is just one of the
    many ways that GitHub has delivered a very thoughtful CLI to its users.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Finally, make errors stand out – use red text or a red *x* emoji to increase
    understanding if an error occurs. If colors are disabled, then use text to communicate
    that an error has occurred and offer some suggestions for the next steps to take
    – and, even better, an avenue toward support via email or a website.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about the command-line process – receiving input,
    processing data, and returning the output. The most popular different types of
    input have been discussed: from **subcommands**, **arguments**, and **flags**,
    to **signals** and **control characters**.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'We created an interactive survey to receive input from a user and discussed
    data processing. We also learned how to take the first steps of processing: converting
    argument string data, converting and checking the type, receiving data from typed
    and custom flags, and finally, reading data from a file.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'We also covered a brief explanation regarding the different types of processing:
    batch, online, and real-time processing. Ultimately, the use case will lead you
    to understand what sort of input you’ll require, and whether running tasks in
    batches, over the internet, or in real time is required.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Returning the output is just as important as receiving it, if not more! This
    is your chance to create a more pleasant experience for your user. Now that you’re
    developing for humans first, you have the opportunity to put yourself in their
    shoes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: How would you want to receive data in a way that makes you feel assured, understanding
    failures and what to do next, and where to find help? Not all processes run successfully,
    so let’s at least make users feel that they’re on the path to success. In *Part
    2*, [*Chapter 6*](B18883_06.xhtml#_idTextAnchor123), *Calling External Processes,
    Handling Errors and Timeouts*, we will continue to discuss the command-line process
    in more detail, focusing on external processes and how to handle timeouts and
    errors and communicate them to the user effectively.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are arguments or flags preferred for CLI programs? Why?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What key combination interrupts a computer process?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What flag can be added to your CLI to modify the output into plain output that
    can easily be integrated with tools such as `grep` and `awk`?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flags are preferred for CLI programs because they make it much easier to add
    or remove functionality.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Ctrl +* *C*.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `–plain` flag can be added to remove any unnecessary data from the output.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a TTY? (https://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con/4132#4132)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NO_COLOR (https://no-color.org/)
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*12 Factor CLI* *Apps* (https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*12 Factor CLI* *Apps* (https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46)'
