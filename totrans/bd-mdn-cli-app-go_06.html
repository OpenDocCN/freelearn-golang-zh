<html><head></head><body>
		<div id="_idContainer044">
			<h1 id="_idParaDest-123" class="chapter-number"><a id="_idTextAnchor123"/>6</h1>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor124"/>Calling External Processes and Handling Errors and Timeouts</h1>
			<p>Many command-line applications interact with other external commands or API services. This chapter will guide you through how to call these external processes and how to handle timeouts and other errors when they occur. The chapter will start with a deep dive into the <strong class="source-inline">os/exec</strong> package, which contains everything you need to create commands that call external processes that give you multiple options for creating and running commands. You’ll learn how to retrieve data from the standard output and standard error pipes, as well as creating additional file descriptors for <span class="No-Break">similar usage.</span></p>
			<p>Another external process involves calling external API service endpoints. The <strong class="source-inline">net/http</strong> package is discussed and is where we start defining the client, then create the requests that it executes. We will discuss the different ways requests can be both created <span class="No-Break">and executed.</span></p>
			<p>Timeouts and other errors can occur when calling either type of process. We will end the chapter by looking at how to capture when timeouts and errors occur in our code. It’s important to be mindful that these things can happen and so it’s important to write code that can handle them. The specific action taken upon error is dependent on the use case, so we’ll discuss the code to capture these cases only. To summarize, we’ll be covering the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Calling <span class="No-Break">external processes</span></li>
				<li>Interacting with <span class="No-Break">REST APIs</span></li>
				<li>Handling the expected – timeouts <span class="No-Break">and errors</span></li>
			</ul>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor125"/>Technical requirements</h1>
			<p>You’ll need a UNIX operating system to understand and run the examples shared in <span class="No-Break">the chapter.</span></p>
			<p>You can also find the code examples on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter06</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor126"/>Calling external processes</h1>
			<p>Within your <a id="_idIndexMarker385"/>command-line application, you may need to call some external processes. Sometimes, there are Golang libraries offered for third-party tools that function as a wrapper. For <a id="_idIndexMarker386"/>example, Go CV, <a href="https://gocv.io/">https://gocv.io/</a>, is a Golang wrapper offered for OpenCV, an open source computer vision library. Then, there’s GoFFmpeg, <a href="https://github.com/xfrr/goffmpeg">https://github.com/xfrr/goffmpeg</a>, which<a id="_idIndexMarker387"/> is a wrapper offered for FFmpeg, a library for recording, converting, and streaming audio and video files. Often, you need to install an underlying tool, such as OpenCV or FFmpeg, and then the library interacts with it. Calling these external processes then means importing the wrapper package and calling its methods within your code. Often, when you dive into the code, you’ll find that these libraries provide a wrapper for the <span class="No-Break">C code.</span></p>
			<p>Besides importing a wrapper for an external tool, you may call external applications using the <strong class="source-inline">os/exec</strong> Golang library. This is the main purpose of the library and in this section, we will be digging into how to use it to call <span class="No-Break">external applications.</span></p>
			<p>First, let’s review each of the variables, types, and functions that exist within the<strong class="bold"> </strong><strong class="source-inline">os/exec</strong> package <a id="_idIndexMarker388"/>with an example <span class="No-Break">of each.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor127"/>The os/exec package</h2>
			<p>By digging <a id="_idIndexMarker389"/>deeper into the <strong class="source-inline">exec</strong> package, you will find that it is a wrapper for the <strong class="source-inline">os.StartProcess</strong> method, making it easier to handle the remapping of standard in and standard out, connecting the input and output with pipes, and handling <span class="No-Break">other modifications.</span></p>
			<p>For clarity, it’s important to note that this package does not invoke the operating system’s shell and so doesn’t handle tasks handled typically by the shell: expanding glob patterns, pipelines, or redirections. If it is necessary to expand glob patterns, then you can call the shell directly and make sure to escape values to make it safe, or you can also use the path or file path’s <strong class="source-inline">Glob</strong> function. To expand any environment variables that exist in a string, use the <strong class="source-inline">os</strong> package’s <span class="No-Break"><strong class="source-inline">ExpandEnv</strong></span><span class="No-Break"> function.</span></p>
			<p>In the following subsections, we’ll start to discuss the different variables, types, functions, and methods that exist within the <span class="No-Break"><strong class="source-inline">os/exec</strong></span><span class="No-Break"> package.</span></p>
			<h3>Variables</h3>
			<p><strong class="source-inline">ErrNotFound</strong> is the error <a id="_idIndexMarker390"/>variable returned when an executable file is not found in the application’s <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">PATH</strong></span><span class="No-Break"> variables.</span></p>
			<h3>Types</h3>
			<p><strong class="source-inline">Cmd</strong> is a <a id="_idIndexMarker391"/>struct that represents an external command. Defining a variable of this type is just in preparation for the command to be run. Once this variable, of the <strong class="source-inline">Cmd</strong> type, is run via either the <strong class="source-inline">Run</strong>, <strong class="source-inline">Output</strong>, or <strong class="source-inline">CombinedOutput</strong> method, it cannot be reused. There are several fields on this <strong class="source-inline">Cmd</strong> struct that we can also<a id="_idIndexMarker392"/> <span class="No-Break">elaborate upon:</span></p>
			<ul>
				<li><strong class="source-inline">Path string</strong> This is the only required field. It is the path of the command to run; if the path is relative, then it will be relative to the value stored in the <span class="No-Break"><strong class="source-inline">Dir</strong></span><span class="No-Break"> field.</span></li>
				<li><strong class="source-inline">Args []string</strong> This field holds the arguments for the command. <strong class="source-inline">Args[0]</strong> represents the command. <strong class="source-inline">Path</strong> and <strong class="source-inline">Args</strong> are set when the command is run, but if <strong class="source-inline">Args</strong> is <strong class="source-inline">nil</strong> or empty, then just <strong class="source-inline">{Path}</strong> is used <span class="No-Break">during execution.</span></li>
				<li><strong class="source-inline">Env []string</strong> The <strong class="source-inline">Env</strong> field represents the environment for the command to run. Each value in the slice must be in the following format: <strong class="source-inline">"key=value"</strong>. If the value is empty or <strong class="source-inline">nil</strong>, then the command uses the current environment. If the slice has duplicate key values, then the last value for the duplicate key <span class="No-Break">is used.</span></li>
				<li><strong class="source-inline">Dir string</strong> The <strong class="source-inline">Dir</strong> field represents the working directory of the command. If it’s not set, then the current directory <span class="No-Break">is used.</span></li>
				<li><strong class="source-inline">Stdin io.Reader</strong> The <strong class="source-inline">Stdin</strong> field specifies the command process’ standard input. If the data is <strong class="source-inline">nil</strong>, then the process reads from <strong class="source-inline">os.DevNull</strong>, the null device. However, if the standard input is <strong class="source-inline">*os.File</strong>, then the contents are piped. During execution, a <a id="_idIndexMarker393"/>goroutine reads from standard input and then sends that data to the command. The <strong class="source-inline">Wait</strong> method will not complete until the goroutine starts copying. If it <a id="_idIndexMarker394"/>does not complete, then it could be because <a id="_idIndexMarker395"/>of an <strong class="bold">end-of-file</strong> (<strong class="bold">EOF</strong>), read, or <span class="No-Break">write-to-pipe error.</span></li>
				<li><strong class="source-inline">Stdout io.Writer</strong> The <strong class="source-inline">Stdout</strong> field specifies the command process’ standard output. If the standard output is <strong class="source-inline">nil</strong>, then the process connects to the <strong class="source-inline">os.DevNull</strong> null device. If the standard output is <strong class="source-inline">*os.File</strong>, then output is sent to it instead. During execution, a goroutine reads from the command process and sends data to <span class="No-Break">the writer.</span></li>
				<li><strong class="source-inline">Stderr io.Writer</strong> The <strong class="source-inline">Stderr</strong> field specifies the command process’ standard error output. If the standard error is <strong class="source-inline">nil</strong>, then the process connects to the <strong class="source-inline">os.DevNull</strong> null device. If the standard error is <strong class="source-inline">*os.File</strong>, then error output is sent to it instead. During execution, a goroutine reads from the command process and sends data to <span class="No-Break">the writer.</span></li>
				<li><strong class="source-inline">ExtraFiles []*os.File</strong> The <strong class="source-inline">ExtraFiles</strong> field specifies additional files inherited by the command process. It doesn’t include standard input, standard output, or standard error, so if not empty, entry <em class="italic">x</em> becomes the <em class="italic">3+x</em> file descriptor. This field is not supported <span class="No-Break">on Windows.</span></li>
				<li><strong class="source-inline">SysProcAttr *syscall.SysProcAttr</strong> <strong class="source-inline">SysProcAttr</strong> holds system-specific attributes that are passed down to <strong class="source-inline">os.StartProcess</strong> as an <strong class="source-inline">os.ProcAttr</strong>’s <span class="No-Break"><strong class="source-inline">Sys</strong></span><span class="No-Break"> field.</span></li>
				<li><strong class="source-inline">Process *os.Process</strong> The <strong class="source-inline">Process</strong> field holds the underlying process once the command <span class="No-Break">is run.</span></li>
				<li><strong class="source-inline">ProcessState *os.ProcessState</strong> The <strong class="source-inline">ProcessState</strong> field <a id="_idIndexMarker396"/>contains information about the process. It becomes available <a id="_idIndexMarker397"/>after the wait or run method <span class="No-Break">is called.</span></li>
			</ul>
			<h3>Methods</h3>
			<p>The<a id="_idIndexMarker398"/> following are the methods that exist on the <span class="No-Break"><strong class="source-inline">exec.Cmd</strong></span><span class="No-Break"> object:</span></p>
			<ul>
				<li><strong class="source-inline">func (c *Cmd) CombinedOutput() ([]byte, error)</strong> The <strong class="source-inline">CombinedOutput</strong> method returns both the standard output and standard error into 1-byte <span class="No-Break">string output.</span></li>
				<li><strong class="source-inline">func (c *Cmd) Output ([]byte, error)</strong> The <strong class="source-inline">Output</strong> method returns just the standard output. If an error occurs, it will usually be of the <strong class="source-inline">*ExitError</strong> type, and if the command’s standard error, <strong class="source-inline">c.Stderr</strong>, is <strong class="source-inline">nil</strong>, <strong class="source-inline">Output</strong> <span class="No-Break">populates </span><span class="No-Break"><strong class="source-inline">ExitError.Stderr</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">func (c *Cmd) Run() error</strong> The <strong class="source-inline">Run</strong> method starts executing the command and then waits for it to complete. If there was no problem copying standard input, standard output, or standard error and the command exits with a zero status, then the error returned will be <strong class="source-inline">nil</strong>. If the command exits with an error, it will usually be of the <strong class="source-inline">*ExitError</strong> type, but could be other error types <span class="No-Break">as well.</span></li>
				<li><strong class="source-inline">func (c *Cmd) </strong><span class="No-Break"><strong class="source-inline">Start() error</strong></span></li>
				<li>The <strong class="source-inline">Start</strong> method will start executing the command and not wait for it to complete. If the <strong class="source-inline">Start</strong> method runs successfully, then the <strong class="source-inline">c.Process</strong> field will be set. The <strong class="source-inline">c.Wait</strong> field will then return the exit code and release resources <span class="No-Break">once complete.</span></li>
				<li>f<strong class="source-inline">unc (c* Cmd) StderrPipe() (io.ReadCloser, error)</strong> <strong class="source-inline">StderrPipe</strong> returns a pipe that is connected to the command’s standard error. There won’t be a need to ever close the pipe because the <strong class="source-inline">Wait</strong> method will close the pipe once the command exits. Do not call the <strong class="source-inline">Wait</strong> method until all reads<a id="_idIndexMarker399"/> from the standard error pipe have completed. Do not use this command with the <strong class="source-inline">Run</strong> method for the <span class="No-Break">same reason.</span></li>
				<li><strong class="source-inline">func (c* Cmd) StdinPipe() (io.WriteCloser, error</strong>) <strong class="source-inline">StdinPipe</strong> returns a pipe that is connected to the command’s standard input. The pipe will be closed after <strong class="source-inline">Wait</strong>, and the command exits. However, sometimes the command will not run until the standard input pipe is closed, and thus you can call the <strong class="source-inline">Close</strong> method to close the <span class="No-Break">pipe sooner.</span></li>
				<li><strong class="source-inline">func (c *Cmd) StdoutPipe() (io.ReadCloser, error</strong>) The <strong class="source-inline">StdoutPipe</strong> method returns a pipe that is connected to the command’s standard output. There’s no need to close the pipe because <strong class="source-inline">Wait</strong> will close the pipe once the command exits. Again, do not call <strong class="source-inline">Wait</strong> until all reads from the standard output pipe have completed. Do not use this command with the <strong class="source-inline">Run</strong> method for the <span class="No-Break">same reason.</span></li>
				<li><strong class="source-inline">func (c *Cmd) String() string</strong> The <strong class="source-inline">String</strong> method returns a human-readable description of the command, <strong class="source-inline">c</strong>, for debugging purposes. The specific output may differ between Go version releases. Also, do not use this as input to a shell, as it’s not suitable for <span class="No-Break">that purpose.</span></li>
				<li><strong class="source-inline">func (c *Cmd) Wait() error</strong> The <strong class="source-inline">Wait</strong> method waits for any copying to standard input, for standard output or standard error to complete, and for the command to exit. To utilize the <strong class="source-inline">Wait</strong> method, the command must have been started by the <strong class="source-inline">Start</strong> method and not the <strong class="source-inline">Run</strong> method. If there are no errors with copying from pipes and the process exits with a <strong class="source-inline">0</strong> exit status code, then the error returned will be <strong class="source-inline">nil</strong>. If the command’s <strong class="source-inline">Stdin</strong>, <strong class="source-inline">Stdout</strong>, or <strong class="source-inline">Stderr</strong> field is not set to <strong class="source-inline">*os.File</strong>, then <strong class="source-inline">Wait</strong> also ensures that the respective input-output loop process completes <span class="No-Break">as well.</span></li>
			</ul>
			<p><strong class="source-inline">Error</strong> is a struct<a id="_idIndexMarker400"/> that represents an error returned from the <strong class="source-inline">LookPath</strong> function when it fails to recognize the file as an executable. There are a couple of fields and methods of this specific error type that we will define <span class="No-Break">in detail.</span></p>
			<p>The following are the methods that exist on the <span class="No-Break"><strong class="source-inline">Error</strong></span><span class="No-Break"> type:</span></p>
			<ul>
				<li><strong class="source-inline">func (e *Error) Unwrap() error</strong> If the error returned is a chain of errors, then you can utilize the <strong class="source-inline">Unwrap</strong> method to <em class="italic">unwrap</em> it and determine what kind of error <span class="No-Break">it is.</span></li>
			</ul>
			<p><strong class="source-inline">ExitError</strong> is a struct that represents an error when a command exits unsuccessfully. <strong class="source-inline">*os.ProcessState</strong> is embedded into this struct, so all values and fields will also be available to the <strong class="source-inline">ExitError</strong> type. Finally, there are a few fields of this type that we can define in <span class="No-Break">more detail:</span></p>
			<ul>
				<li><strong class="source-inline">Stderr []byte</strong> This field holds a set of the standard error output responses if not collected from the <strong class="source-inline">Cmd.Output</strong> method. <strong class="source-inline">Stderr</strong> may only contain the prefix and suffix of the error output if it’s sufficiently long. The middle will contain text about the number of omitted bytes. For debugging purposes, and if you want to include the entirety of the error messages, then redirect <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Cmd.Stderr</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>The following is the method that exists on the <span class="No-Break"><strong class="source-inline">ExitError</strong></span><span class="No-Break"> type:</span></p>
			<ul>
				<li><strong class="source-inline">func (e *ExitError) Error() string</strong> The <strong class="source-inline">Error</strong> method returns the exit error represented as <span class="No-Break">a string.</span></li>
			</ul>
			<h3>Functions</h3>
			<p>The following are<a id="_idIndexMarker401"/> functions that exist within the <span class="No-Break"><strong class="source-inline">os/exec</strong></span><span class="No-Break"> package:</span></p>
			<ul>
				<li><strong class="source-inline">func LookPath(file string) (string, error)</strong> The <strong class="source-inline">LookPath</strong> function checks to see whether the file is an executable and can be found. If the file is a relative path, then it is relative to the <span class="No-Break">current directory.</span></li>
				<li><strong class="source-inline">func Command(name string, arg ...string) *Cmd</strong> The <strong class="source-inline">Command</strong> function returns the <strong class="source-inline">Cmd</strong> struct with just the path and args set. If name has path separators, then the <strong class="source-inline">LookPath</strong> function is used to confirm the file is found and executable. Otherwise, <strong class="source-inline">name</strong> is used directly as the path. This function<a id="_idIndexMarker402"/> behaves slightly differently on Windows. For example, it will execute the whole command line as a single string, including quoted args, then handle its <span class="No-Break">own parsing.</span></li>
				<li><strong class="source-inline">func CommandContext(ctx context.Context, name string, arg ...string) *Cmd</strong> Similar to the <strong class="source-inline">Command</strong> function, but receives context. If the context is executed before the command completes, then it will kill the process by <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">os.Process.Kill</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Now that we’ve really dived deep into the <strong class="source-inline">os/exec</strong> package and the structs, functions, and methods needed to execute functions, let’s actually use them in code to execute a function externally. Let’s create commands using the <strong class="source-inline">Cmd</strong> struct, but also with the <strong class="source-inline">Command</strong> and <strong class="source-inline">CommandContext</strong> functions. We can then take one example command and run it using either the <strong class="source-inline">Run</strong>, <strong class="source-inline">Output</strong>, or <strong class="source-inline">CombinedOutput</strong> method. Finally, we will handle some errors typically returned from <span class="No-Break">these methods.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you want to follow along with the examples coming up, within the <strong class="source-inline">Chapter-6</strong> repository, install the necessary applications. In Windows, use the <strong class="source-inline">.\build-windows.p1</strong> PowerShell script. In Darwin, use the <strong class="source-inline">make install</strong> command. Once the applications are installed, run <strong class="source-inline">go </strong><span class="No-Break"><strong class="source-inline">run main.go</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor128"/>Creating commands using the Cmd struct</h2>
			<p>There<a id="_idIndexMarker403"/> are several different ways of <a id="_idIndexMarker404"/>creating commands. The first way is with the <strong class="source-inline">Cmd</strong> struct within the <span class="No-Break"><strong class="source-inline">exec</strong></span><span class="No-Break"> package.</span></p>
			<h3>Using the Cmd struct</h3>
			<p>We <a id="_idIndexMarker405"/>first define the <strong class="source-inline">cmd</strong> variable with an unset <strong class="source-inline">Cmd</strong> structure. The following code resides in <strong class="source-inline">/examples/command.go</strong> within the <span class="No-Break"><strong class="source-inline">CreateCommandUsingStruct</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
cmd := exec.Cmd{}</pre>
			<p>Each field is set separately. The path is set using <strong class="source-inline">filepath.Join</strong>, which is safe for use across different <span class="No-Break">operating systems:</span></p>
			<pre class="source-code">
cmd.Path = filepath.Join(os.Getenv("GOPATH"), "bin", "uppercase")</pre>
			<p>Each field is set separately. The <strong class="source-inline">Args</strong> field contains the command name in the <strong class="source-inline">Args[0]</strong> position, followed by the rest of the arguments to be <span class="No-Break">passed in:</span></p>
			<pre class="source-code">
cmd.Args = []string{"uppercase", "hack the planet"}</pre>
			<p>The following three file descriptors are set – <strong class="source-inline">Stdin</strong>, <strong class="source-inline">Stdout</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Stderr</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
cmd.Stdin = os.Stdin // io.Reader
cmd.Stdout = os.Stdout // io.Writer
cmd.Stderr = os.Stderr // io.Writer</pre>
			<p>However, there’s a <strong class="source-inline">writer</strong>, file descriptor that’s passed into the <strong class="source-inline">ExtraFiles</strong> field. This specific field is inherited by the command process. It’s important to note that a pipe won’t work if you don’t pass the writer in <strong class="source-inline">ExtraFiles</strong>, because the child must get the writer to be able to write <span class="No-Break">to it:</span></p>
			<pre class="source-code">
reader, writer, err := os.Pipe()
if err != nil {
    panic(err)
}
cmd.ExtraFiles = []*os.File{writer}
if err := cmd.Start(); err != nil {
    panic(err)
}</pre>
			<p>Within the <a id="_idIndexMarker406"/>actual uppercase command that’s called, there’s code in <strong class="source-inline">cmd/uppercase/uppercase.go</strong> that takes the first argument after the command name and changes the case to uppercase. The new uppercased text is then encoded into the pipe or extra <span class="No-Break">file descriptor:</span></p>
			<pre class="source-code">
input := os.Args[1:]
output := strings.ToUpper(strings.Join(input, ""))
pipe := os.NewFile(uintptr(3), "pipe")
err := json.NewEncoder(pipe).Encode(output)
if err != nil {
    panic(err)
}</pre>
			<p>Back to the <strong class="source-inline">CreateCommandUsingStruct</strong> function, the value that’s encoded into the pipe can now be read via the <strong class="source-inline">read</strong> file descriptor of the pipe and then output with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
var data string
decoder := json.NewDecoder(reader)
if err := decoder.Decode(&amp;data); err != nil {
    panic(err)
}
fmt.Println(data)</pre>
			<p>We now know one way of creating a command using the <strong class="source-inline">Cmd</strong> struct. Everything could have been defined at once at the same time as the command was initialized and depends on <span class="No-Break">your preference.</span></p>
			<h3>Using the Command function</h3>
			<p>Another <a id="_idIndexMarker407"/>way to create a command is with the <strong class="source-inline">exec.Command</strong> function. The<a id="_idIndexMarker408"/> following code resides in <strong class="source-inline">/examples/command.go</strong> <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">CreateCommandUsingCommandFunction</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
cmd := exec.Command(filepath.Join(os.Getenv("GOPATH"), "bin", "uppercase"), "hello world")
reader, writer, err := os.Pipe()
if err != nil {
    panic(err)
}</pre>
			<p>The <strong class="source-inline">exec.Command</strong> function takes the file path to the command as the first argument. A slice of strings representing the arguments is optionally passed for the remaining parameters. The rest of the function is the same. Because <strong class="source-inline">exec.Command</strong> does not take any additional parameters, we similarly define the <strong class="source-inline">ExtraFiles</strong> field outside the original <span class="No-Break">variable initialization.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor129"/>Running the command</h2>
			<p>Now that <a id="_idIndexMarker409"/>we know how to create commands, there are multiple different ways to run or start running a command. While each of these <a id="_idIndexMarker410"/>methods has already been described in detail earlier in this section, we’ll now share an example of <span class="No-Break">using each.</span></p>
			<h3>Using the Run method</h3>
			<p>The <strong class="source-inline">Run</strong> method, as<a id="_idIndexMarker411"/> mentioned earlier, starts the command process, and then waits for its completion. The code for this is called from the <strong class="source-inline">main.go</strong> file but can be found under <strong class="source-inline">/examples/running.go</strong>. In this example, we call a different command called <strong class="source-inline">lettercount</strong>, which counts the letters in a string and then prints out <span class="No-Break">the result:</span></p>
			<pre class="source-code">
cmd := exec.Command(filepath.Join(os.Getenv("GOPATH"), "bin", "lettercount"), "four")
cmd.Stdin = os.Stdin
cmd.Stdout = os.Stdout
cmd.Stderr = os.Stderr
var count int</pre>
			<p>Again, we<a id="_idIndexMarker412"/> use the <strong class="source-inline">ExtraFiles</strong> field to pass in an additional file descriptor to write the <span class="No-Break">result to:</span></p>
			<pre class="source-code">
reader, writer, err := os.Pipe()
if err != nil {
    panic(err)
}
cmd.ExtraFiles = []*os.File{writer}
if err := cmd.Run(); err != nil {
    panic(err)
}
if err := json.NewDecoder(reader).Decode(&amp;count); err != nil {
    panic(err)
}</pre>
			<p>The result is finally printed with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
fmt.Println("letter count: ", count)</pre>
			<h3>Using the Start command</h3>
			<p>The <strong class="source-inline">Start</strong> method<a id="_idIndexMarker413"/> is like the <strong class="source-inline">Run</strong> method; however, it doesn’t wait for the process to complete. You can find the code that uses the <strong class="source-inline">Start</strong> command in <strong class="source-inline">examples/running.go</strong>. For the most part, it’s identical, but you’ll be replacing the code block containing <strong class="source-inline">cmd.Run</strong> with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
if err := cmd.Start(); err != nil {
    panic(err)
}
err = cmd.Wait()
if err != nil {
    panic(err)
}</pre>
			<p>It’s very<a id="_idIndexMarker414"/> important to call the <strong class="source-inline">cmd.Wait</strong> method because it releases resources taken by the <span class="No-Break">command process.</span></p>
			<h3>Using the Output command</h3>
			<p>As the<a id="_idIndexMarker415"/> method name suggests, the <strong class="source-inline">Output</strong> method returns anything that’s been piped into the standard out pipe. The most common way to push from a command to the standard output pipe is through any of the print methods in the <strong class="source-inline">fmt</strong> package. An additional line is added to the end of the <strong class="source-inline">main</strong> function for the <span class="No-Break"><strong class="source-inline">lettercount</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
fmt.Printf("successfully counted the letters of \"%v\" as %d\n", input, len(runes))</pre>
			<p>The only difference within the code that utilizes this <strong class="source-inline">Output</strong> method, which can be found in the <strong class="source-inline">examples/running.go</strong> file under the <strong class="source-inline">OutputMethod</strong> function, is this line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
out, err := cmd.Output()</pre>
			<p>The <strong class="source-inline">out</strong> variable is a byte slice that can later be cast to a string to be printed out. This variable captures the standard out and when the function is run, the output displayed is <span class="No-Break">as follows:</span></p>
			<pre class="console">
output: successfully counted the letters of "four" as 4</pre>
			<h3>Using the CombinedOutput command</h3>
			<p>As the <a id="_idIndexMarker416"/>method name suggests, the <strong class="source-inline">CombinedOutput</strong> method returns a combined output of the standard output and standard error piped data. Add a line toward the end of the <strong class="source-inline">lettercount</strong> command’s <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
fmt.Fprintln(os.Stderr, "this is where the errors go")</pre>
			<p>The only<a id="_idIndexMarker417"/> big difference between the calls from the previous function and the current function, <strong class="source-inline">CombinedOutputMethod</strong>, is <span class="No-Break">this line:</span></p>
			<pre class="source-code">
CombinedOut<a id="_idTextAnchor130"/>put, err := cmd.CombinedOutput()</pre>
			<p>Similarly, it returns a byte slice, but now contains the combined output of standard error and <span class="No-Break">standard output.</span></p>
			<h3>Executing commands on Windows</h3>
			<p>Alongside the <a id="_idIndexMarker418"/>examples are similar files that end with <strong class="source-inline">_windows.go</strong>. The major thing to note, in the previous examples, is that <strong class="source-inline">ExtraFiles</strong> is not supported on Windows. These Windows-specific and simple examples execute an external <strong class="source-inline">ping</strong> command to <strong class="source-inline">google.com</strong>. Let’s take a look <span class="No-Break">at one:</span></p>
			<pre class="source-code">
func CreateCommandUsingCommandFunction() {
    cmd := exec.Command("cmd", "/C", "ping", "google.com")
    output, err := cmd.CombinedOutput()
    if err != nil {
        panic(err)
    }
    fmt.Println(string(output))
}</pre>
			<p>Like the commands we’ve written for Darwin, we can create commands using the <strong class="source-inline">exec.Command</strong> function or the struct and call <strong class="source-inline">Run</strong>, <strong class="source-inline">Start</strong>, <strong class="source-inline">Wait</strong>, <strong class="source-inline">Output</strong>, and <strong class="source-inline">CombinedOutput</strong> just <span class="No-Break">the same.</span></p>
			<p>Also, for pagination, <strong class="source-inline">less</strong> is used on Linux and UNIX machines, but <strong class="source-inline">more</strong> is used on Windows. Let’s quickly show <span class="No-Break">this code:</span></p>
			<pre class="source-code">
func Pagination() {
    moreCmd := exec.Command("cmd", "/C", "more")
    moreCmd.Stdin = strings.NewReader(blob)
    moreCmd.Stdout = os.Stdout
    moreCmd.Stderr = os.Stderr
    err := moreCmd.Run()
    if err != nil {
        panic(err)
    }
}
var (
    blob = `
    …
    `
)</pre>
			<p>Similarly, we <a id="_idIndexMarker419"/>can pass in the name and all arguments using the <strong class="source-inline">exec.Command</strong> method. We also pass the long text into the <span class="No-Break"><strong class="source-inline">moreCmd.Stdin</strong></span><span class="No-Break"> field.</span></p>
			<p>So, the <strong class="source-inline">os/exec</strong> package offers different ways to create and run external commands. Whether you create a quick command using the <strong class="source-inline">exec.Command</strong> method or directly create one with the <strong class="source-inline">exec.Cmd</strong> struct and then run the <strong class="source-inline">Start</strong> command, you have options. Finally, you can either retrieve the standard output and error output separately or together. Knowing all about the <strong class="source-inline">os/exec</strong> package will make it easy to successfully run external commands from your Go <span class="No-Break">command-line application.</span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor131"/>Interacting with REST APIs</h1>
			<p>Often, if a <a id="_idIndexMarker420"/>company or user has already created an API, the command-line application will send requests to either the REST API or the gRPC endpoints. Let’s first talk about using REST API endpoints. It is important to understand the <strong class="source-inline">net/http</strong> package. It’s quite a large package with many types, methods, and functions, many <a id="_idIndexMarker421"/>of which are used for development on the server side. In this context, the command-line application will be the client of the API, so we won’t discuss each in detail. We’ll go into a few basic use cases from the client <span class="No-Break">side though.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor132"/>Get request</h2>
			<p>Let’s revisit<a id="_idIndexMarker422"/> the code from <a href="B18883_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Building an Audio Metadata CLI</em>. Within the <strong class="source-inline">Run</strong> command of the CLI command code, found in the <strong class="source-inline">/cmd/cli/command/get.go</strong> file, is a snippet of code that calls the corresponding API request endpoint using the <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
params := "id=" + url.QueryEscape(cmd.id)
path := fmt.Sprintf("http://localhost/request?%s", params)
payload := &amp;bytes.Buffer{}
method := "GET"
client := cmd.client</pre>
			<p>Notice that in<a id="_idIndexMarker423"/> the preceding code, we take the field value, <strong class="source-inline">id</strong>, which has been set on the <strong class="source-inline">cmd</strong> variable, and pass it into the HTTP request as a parameter. Consider the flags and arguments to be passed which are to be used as parameters for your HTTP request. The following code executes <span class="No-Break">the request:</span></p>
			<pre class="source-code">
req, err := http.NewRequest(method, path, payload)
if err != nil {
    return err
}
resp, err := client.Do(req)
if err != nil {
    return err
}
defer resp.Body.Close()</pre>
			<p>Finally, the response is read into a byte string and printed. Prior to accessing the body of the response, check<a id="_idIndexMarker424"/> whether the response or body is <strong class="source-inline">nil</strong>. This can save you from some <span class="No-Break">future headaches:</span></p>
			<pre class="source-code">
b, err := io.ReadAll(resp.Body)
if err != nil {
    return err
}
fmt.Println(string(b))
return nil</pre>
			<p>However, in reality, there will<a id="_idIndexMarker425"/> be much more done with <span class="No-Break">the response:</span></p>
			<ol>
				<li><strong class="bold">Check the response status code</strong>: If the response is <strong class="source-inline">200</strong> <strong class="source-inline">OK</strong>, then we can return <a id="_idIndexMarker426"/>the output as it was a successful response. Otherwise, in the next section, <em class="italic">Handling the expected – timeouts and errors</em>, we’ll discuss how to handle <span class="No-Break">other responses.</span></li>
				<li><strong class="bold">Log the response</strong>: We may, ideally, log<a id="_idIndexMarker427"/> the response if it doesn’t contain any sensitive data. This detailed information can be written to a log file or output when in <span class="No-Break">verbose mode.</span></li>
				<li><strong class="bold">Store the response</strong>: Sometimes, the <a id="_idIndexMarker428"/>response may be stored in a local database <span class="No-Break">or cache.</span></li>
				<li><strong class="bold">Transform the data</strong>: This <a id="_idIndexMarker429"/>returned data may also be unmarshaled into a local data struct. The struct types of data returned must be defined and, preferably, would utilize the same struct models defined within the API. In that case, if <strong class="source-inline">Content-Type</strong> in the header is set to <strong class="source-inline">application/json</strong>, we would unmarshal the JSON response into <span class="No-Break">the struct.</span></li>
			</ol>
			<p>Currently, in the audiofile application, we transform the data into an <strong class="source-inline">Audio</strong> struct <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var audio Audio
If err := json.Unmarshal(b, &amp;audio); err != nil {
    fmt.Println("error unmarshalling JSON response"
}</pre>
			<p>But<a id="_idIndexMarker430"/> what if the <a id="_idIndexMarker431"/>response body isn’t in JSON format and the content type is something else? In a perfect world, we’d have API documentation that informs us of what to expect so we can handle it accordingly. Alternatively, you can check to confirm the type first using <span class="No-Break">the following:</span></p>
			<pre class="source-code">
contentType := http.DetectContentType(b) // b are the bytes from reading the resp.Body</pre>
			<p>A quick search on the internet for HTTP content types will return a large list. In the preceding example, the audio company might have decided to return a <strong class="source-inline">Content-Type</strong> value of <strong class="source-inline">audio/wave</strong>. In that case, we could either download or stream the result. There are also different<a id="_idIndexMarker432"/> HTTP method types defined as constants within the <span class="No-Break"><strong class="source-inline">net/http</strong></span><span class="No-Break"> package:</span></p>
			<ul>
				<li><strong class="source-inline">MethodGet</strong>: Used when <span class="No-Break">requesting data</span></li>
				<li><strong class="source-inline">MethodPost</strong>: Used for <span class="No-Break">inserting data</span></li>
				<li><strong class="source-inline">MethodPut</strong>: Request is idempotent, used for inserting or updating an <span class="No-Break">entire resource</span></li>
				<li><strong class="source-inline">MethodPatch</strong>: Similar to <strong class="source-inline">MethodPut</strong>, but sends only partial data to update without modifying the <span class="No-Break">entire resource</span></li>
				<li><strong class="source-inline">MethodDelete</strong>: Used for deleting or <span class="No-Break">removing data</span></li>
				<li><strong class="source-inline">MethodConnect</strong>: Used when talking to a proxy, when the URI begins <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">https://</strong></span></li>
				<li><strong class="source-inline">MethodOptions</strong>: Used to describe the communication options, or allowed methods, with <span class="No-Break">the target</span></li>
				<li><strong class="source-inline">MethodTrace</strong>: Used for debugging by providing a message loop-back along the path of <span class="No-Break">the target</span></li>
			</ul>
			<p>There are many possibilities for the method types and content types of data returned. In the preceding <strong class="source-inline">Get</strong> example, we use a client’s <strong class="source-inline">Do</strong> method to call the method. Another option is to use<a id="_idIndexMarker433"/> the <strong class="source-inline">http.Get</strong> method. If we use that method, then we would use this code instead to execute <span class="No-Break">the request:</span></p>
			<pre class="source-code">
resp, err := http.Get(path)
if err != nil {
    return err
}
defer resp.Body.Close()</pre>
			<p>Similarly, rather than using the <strong class="source-inline">client.Do</strong> method for a post or to post a form, there are specific <strong class="source-inline">http.Post</strong> and <strong class="source-inline">http.PostForm</strong> methods that can be used instead. There are times when one method works better for what you are doing. At this point, it’s just important to understand <span class="No-Break">your options.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor133"/>Pagination</h2>
			<p>Suppose<a id="_idIndexMarker434"/> there is a large amount of data being returned by the request. Rather than overloading the client by receiving the data all at once, often pagination is an option. There are two fields that can be passed in as parameters to <span class="No-Break">the call:</span></p>
			<ul>
				<li><strong class="source-inline">Limit</strong>: The number of objects to <span class="No-Break">be returned</span></li>
				<li><strong class="source-inline">Page</strong>: The cursor for multiple pages of <span class="No-Break">results returned</span></li>
			</ul>
			<p>We can define these internally and then formulate the path <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
path := fmt.Sprintf("http://localhost/request?limit=%d&amp;page=%d", limit, page)</pre>
			<p>Make sure, if you’re using an external API, to construct their documentation with the proper parameters for pagination and usage. This is just a general example. In fact, there are several other ways of doing pagination. You can send additional requests in a loop, incrementing the page until all data <span class="No-Break">is retrieved.</span></p>
			<p>From the command side, however, you could return all the data after pagination, but you can also handle pagination on the CLI side. A way to handle it on the client side after a large amount of data is collected from an HTTP <strong class="source-inline">Get</strong> request is to pipe the data. This data can be <a id="_idIndexMarker435"/>piped into the operating system’s pager command. For UNIX, <strong class="source-inline">less</strong> is the pager command. We create the command and then pipe the string output to the <strong class="source-inline">Stdin</strong> pipe. This code can be found in the <strong class="source-inline">examples/pagination.go</strong> file. Similar to the other examples we’ve shared when creating a command, we create a pipe and pass in the writer as an extra file descriptor to the command so that data may be <span class="No-Break">written out:</span></p>
			<pre class="source-code">
pagesCmd := exec.Command(filepath.Join(os.Getenv("GOPATH"), "bin", "pages"))
reader, writer, err := os.Pipe()
if err != nil {
    panic(err)
}
pagesCmd.Stdin = os.Stdin
pagesCmd.Stdout = os.Stdout
pagesCmd.Stderr = os.Stderr
pagesCmd.ExtraFiles = []*os.File{writer}
if err := pagesCmd.Run(); err != nil {
    panic(err)
}</pre>
			<p>Again, the data from the reader is decoded into the <strong class="source-inline">data</strong> <span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break"> variable:</span></p>
			<pre class="source-code">
var data string
decoder := json.NewDecoder(reader)
if err := decoder.Decode(&amp;data); err != nil {
    panic(err)
}</pre>
			<p>This string is then passed into the <strong class="source-inline">Strings.NewReader</strong> method and defined as the input <a id="_idIndexMarker436"/>for the <strong class="source-inline">less</strong> <span class="No-Break">UNIX command:</span></p>
			<pre class="source-code">
lessCmd := exec.Command("/usr/bin/less")
lessCmd.Stdin = strings.NewReader(data)
lessCmd.Stdout = os.Stdout
err = lessCmd.Run()
if err != nil {
    panic(err)
}</pre>
			<p>When the command is run, the data is output as pages. The user then can press the spacebar to continue to the next page or use any of the command keys to navigate the <span class="No-Break">data output.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor134"/>Rate limiting</h2>
			<p>Often, when<a id="_idIndexMarker437"/> dealing with third-party APIs, there’s a limit to how many requests can be handled within a particular time. This is commonly known as <strong class="bold">rate limiting</strong>. For a<a id="_idIndexMarker438"/> single command, you might require multiple requests to an HTTP endpoint and so you might prefer to limit how often you’re sending these requests. Most public APIs will inform users of their rate limits, but there are times when you’ll hit the rate limit of an API unexpectedly. We’ll discuss how to limit your requests to stay within <span class="No-Break">the limits.</span></p>
			<p>There is a useful library, <strong class="source-inline">x/time/rate</strong>, that can be used to define the limit, which is how often something should be executed, and limiters that control the process from executing within the limit. Let’s use some example code, supposing we want to execute something every <span class="No-Break">five seconds.</span></p>
			<p>The code for this particular example is located in the <strong class="source-inline">examples/limiting.go</strong> file. To reiterate, this is just an example and there are different ways to use <strong class="source-inline">runner</strong>. We’re going to cover just a basic use case. We start by defining a struct that contains a function, <strong class="source-inline">Run</strong>, and the <strong class="source-inline">limiter</strong> field, which controls how often it will run. The <strong class="source-inline">Limit()</strong> function will use the <strong class="source-inline">runner</strong> struct to call a function within a <span class="No-Break">rate limit:</span></p>
			<pre class="source-code">
type runner struct {
    Run func() bool
    limiter *rate.Limiter
}
func Limit() {
    thing := runner{}
    start := time.Now()</pre>
			<p>After <a id="_idIndexMarker439"/>defining <strong class="source-inline">thing</strong> as a <strong class="source-inline">runner</strong> instance, we get the start time and then <a id="_idIndexMarker440"/>define the function of <strong class="source-inline">thing</strong>. If the call is allowed within the time, because it does not exceed the limit, we print the current timestamp and return a <strong class="source-inline">false</strong> variable. We exit the function when at least 30 seconds <span class="No-Break">have passed:</span></p>
			<pre class="source-code">
    thing.Run = func() bool {
        if thing.limiter.Allow() {
            fmt.Println(time.Now()) // or call request
            return false
        }
        if time.Since(start) &gt; 30*time.Second {
            return true
        }
        return false
    }</pre>
			<p>We define the limiter for  <strong class="source-inline">thing</strong>. We’ve used a customer variable, which we’ll look at in more detail shortly. Simply, the <strong class="source-inline">NewLimiter</strong> method takes two variables. The first parameter is the limit, one event every five seconds, and the second parameter allows bursts for, at most, a <span class="No-Break">single token:</span></p>
			<pre class="source-code">
    thing.limiter = rate.NewLimiter(forEvery(1, 5*time.
    Second),     1)</pre>
			<p>For those not familiar with the difference between a limit and a burst, a burst defines the number of concurrent requests the API can handle. The rate limit is the number of requests allowed per the <span class="No-Break">defined time.</span></p>
			<p>Next, inside a <strong class="source-inline">for</strong> loop, we <a id="_idIndexMarker441"/>call the <strong class="source-inline">Run</strong> function and only break when it returns <strong class="source-inline">true</strong>, which<a id="_idIndexMarker442"/> should be after 30 seconds <span class="No-Break">have passed:</span></p>
			<pre class="source-code">
    for {
        if thing.Run() {
            break
        }
    }
}</pre>
			<p>As mentioned, the <strong class="source-inline">forEvery</strong> function, which returns a rate limit, is passed into the <strong class="source-inline">NewLimiter</strong> method. It simply calls the <strong class="source-inline">rate.Every</strong> method, which takes the minimum time interval between events and converts it into <span class="No-Break">a limit:</span></p>
			<pre class="source-code">
func forEvery(eventCount int, duration time.Duration) rate.Limit {
    return rate.Every(duration / time.Duration(eventCount))
}</pre>
			<p>We run this code and the timestamps are output. Notice that they are output every <span class="No-Break">five seconds:</span></p>
			<pre class="console">
2022-09-11 18:45:44.356917 -0700 PDT m=+0.000891459
2022-09-11 18:45:49.356877 -0700 PDT m=+5.000891042
2022-09-11 18:45:54.356837 -0700 PDT m=+10.000891084
2022-09-11 18:45:59.356797 -0700 PDT m=+15.000891084
2022-09-11 18:46:04.356757 -0700 PDT m=+20.000891167
2022-09-11 18:46:09.356718 -0700 PDT m=+25.000891167</pre>
			<p>There are other ways of handling limiting requests, such as using a <strong class="source-inline">time.Sleep(d Duration)</strong> method after the code that is called inside a loop. I suggest using the <strong class="source-inline">rate</strong><strong class="bold"> </strong>package because it is great for not only limiting executions but also handling bursts. It has a lot more<a id="_idIndexMarker443"/> functionality that can be used for more complex situations when you are<a id="_idIndexMarker444"/> sending requests to an <span class="No-Break">external API.</span></p>
			<p>You’ve now learned how to send requests to external APIs and how to handle the response, and when you receive a successful response, how to transform and paginate the results. Also, because rate limiting is commonly required for APIs, we’ve discussed how to do that. Since this section has only handled the case of success, let’s consider how to handle the case of failure in the <span class="No-Break">following section.</span></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor135"/>Handling the expected – timeouts and errors</h1>
			<p>When building a CLI that calls external commands or sends HTTP requests to an external API, with data<a id="_idIndexMarker445"/> that is passed in by the user, it’s a good idea to expect the unexpected. In a perfect world, you can guard against bad data. I’m sure you are familiar with the phrase <em class="italic">garbage in</em>,<em class="italic"> garbage out.</em> You can create tests that also ensure that your code is covered for as many bad cases as you can think of. However, timeouts and errors happen. It’s the nature of software, and as you come across them within your development and also in production, you can modify your code to handle <span class="No-Break">new cases.</span></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor136"/>Timeouts with external command processes</h2>
			<p>Let’s first <a id="_idIndexMarker446"/>discuss how to handle timeouts <a id="_idIndexMarker447"/>when calling external commands. The timeout code exists within the <strong class="source-inline">examples/timeout.go</strong> file. The following is the entire method, which calls the <strong class="source-inline">timeout</strong> command. If you take a look at the <strong class="source-inline">timeout</strong> command code, located within <strong class="source-inline">cmd/timeout/timeout.go</strong>, you’ll see that it contains a basic infinite loop. This command will time out, but we need to handle the timeout with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
func Timeout() {
    errChan := make(chan error, 1)
    cmd := exec.Command(filepath.Join(os.Getenv("GOPATH"), 
           "bin", "timeout"))
    if err := cmd.Start(); err != nil {
        panic(err)
    }
    go func() {
        errChan &lt;- cmd.Wait()
    }()
    select {
        case &lt;-time.After(time.Second * 10):
            fmt.Println("timeout command timed out")
            return
        case err := &lt;-errChan:
            if err != nil {
                fmt.Println("timeout error:", err)
            }
    }
}</pre>
			<p>We first <a id="_idIndexMarker448"/>define an error channel, <strong class="source-inline">errChan</strong>, which will receive any error returned from the <strong class="source-inline">cmd.Wait()</strong> method. The command, <strong class="source-inline">cmd</strong>, is <a id="_idIndexMarker449"/>then defined, and next <strong class="source-inline">cmd</strong>’s <strong class="source-inline">Start</strong> method is called to initiate the external process. Within a Go function, we wait for the command to return using the <strong class="source-inline">cmd.Wait()</strong> method. <strong class="source-inline">errChan</strong> will only receive the error value once the command has exited and the copying to standard input and standard error has completed. Within the following <strong class="source-inline">select</strong> block, we wait to receive from two different channels. The first case waits for the time returned after 10 seconds. The second case waits for the command to complete and receive the error value. This code allows us to gracefully handle any <span class="No-Break">timeout issues.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor137"/>Errors or panics with external command processes</h2>
			<p>First, let’s<a id="_idIndexMarker450"/> define the difference between errors and panics. Errors occur when the application can be recovered but is in an abnormal state. If a panic occurs, then something unexpected <a id="_idIndexMarker451"/>happened. For example, we try to access a field on a <strong class="source-inline">nil</strong> pointer or attempt to access an index that is out of bounds for an array. We can start by <span class="No-Break">handling errors.</span></p>
			<p>There are a couple of errors that exist within the <span class="No-Break"><strong class="source-inline">os/exec</strong></span><span class="No-Break"> package:</span></p>
			<ul>
				<li><strong class="source-inline">exec.ErrDot</strong>: Error when the file path of the command failed to resolve within the current directory, <strong class="source-inline">"."</strong>, hence the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">ErrDot</strong></span></li>
				<li><strong class="source-inline">exec.ErrNotFound</strong>: Error when the executable fails to resolve in the defined <span class="No-Break">file path</span></li>
			</ul>
			<p>You can check for the type to handle each <span class="No-Break">error uniquely.</span></p>
			<h3>Handling errors when a command’s path cannot be found</h3>
			<p>The following <a id="_idIndexMarker452"/>code exists within the <strong class="source-inline">examples/error.go</strong> file in the <span class="No-Break"><strong class="source-inline">HandlingDoesNotExistErrors</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
cmd := exec.Command("doesnotexist", "arg1")
if errors.Is(cmd.Err, exec.ErrDot) {
    fmt.Println("path lookup resolved to a local directory")
}
if err := cmd.Run(); err != nil {
    if errors.Is(err, exec.ErrNotFound) {
        fmt.Println("executable failed to resolve")
    }
}</pre>
			<p>When checking the type of the command, use the <strong class="source-inline">errors.Is</strong> method, rather than checking whether <strong class="source-inline">cmd.Err == exec.ErrDot</strong> because the error is not returned directly. The <strong class="source-inline">errors.Is</strong> method checks the error chain for any occurrence of the specific <span class="No-Break">error type.</span></p>
			<h3>Handling other errors</h3>
			<p>Also, within <a id="_idIndexMarker453"/>the <strong class="source-inline">examples/error.go</strong> file is handling an error thrown by the command process itself. This second method, <strong class="source-inline">HandlingOtherMethods</strong>, sets the command’s standard error to a buffer that we can later use if an error is returned from the command. Let’s take a look at <span class="No-Break">the code:</span></p>
			<pre class="source-code">
cmd := exec.Command(filepath.Join(os.Getenv("GOPATH"), "bin", "error"))
var out bytes.Buffer
var stderr bytes.Buffer
cmd.Stdout = &amp;out
cmd.Stderr = &amp;stderr
if err := cmd.Run(); err != nil {
    fmt.Println(fmt.Sprint(err) + ": " + stderr.String())
    return
}
fmt.Println(out.String())</pre>
			<p>When an error is encountered, we print not only the error, <strong class="source-inline">exit status 1</strong>, but also any data that has been piped into the standard error pipe, which should give the users more detail on why the <span class="No-Break">error occurred.</span></p>
			<p>To further understand how this code works, let’s take a look at the error command implementation that exists in the <span class="No-Break"><strong class="source-inline">cmd/error/error.go</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
func main() {
    if len(os.Args) != 0 { // not passing in any arguments in this example throws an error
        fmt.Fprintf(os.Stderr, "missing arguments\n")
        os.Exit(1)
    }
    fmt.Println("executing command with no errors")
}</pre>
			<p>Since we <a id="_idIndexMarker454"/>are not passing any arguments into the command function, after we check the length of <strong class="source-inline">os.Args</strong>, we print to the standard error pipe the reason we are exiting with a non-zero exit code. This is a very simple way to handle errors in an effective manner. When calling this external process, we just return the errors, but as we’ve all probably experienced, error messages can be a bit cryptic. In later chapters, we will talk about how we can rewrite these to be more human-readable and provide a <span class="No-Break">few examples.</span></p>
			<p>In <a href="B18883_04.xhtml#_idTextAnchor087"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Popular Frameworks for Building CLIs</em>, we discussed the use of the <strong class="source-inline">RunE</strong> function within the Cobra Command struct, which allows us to return an error value when the command is run. If you are calling an external process within the <strong class="source-inline">RunE</strong> method, then you can capture and return the error to the user, after rewriting it to a more human-readable format, <span class="No-Break">of course!</span></p>
			<p>Panics are handled differently than errors, but it is a good practice to, within your own code, provide a way to recover from a panic gracefully. You can see this code initiated within the <strong class="source-inline">examples/panic.go</strong> file within the <strong class="source-inline">Panic</strong> method. This calls the <strong class="source-inline">panic</strong> command, located in <strong class="source-inline">cmd/panic/panic.go</strong>. This command simply panics and then recovers. It returns the panic message to the standard error pipe, prints the stack, and exits with a non-zero <span class="No-Break">exit code:</span></p>
			<pre class="source-code">
defer func() {
    if panicMessage := recover(); panicMessage != nil {
        fmt.Fprintf(os.Stderr, "(panic) : %v\n", panicMessage)
        debug.PrintStack()
        os.Exit(1)
    }
}()
panic("help!")</pre>
			<p>On the side that runs this command, we handle it just like any other error by capturing the error<a id="_idIndexMarker455"/> and printing data piped into the <span class="No-Break">standard error.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor138"/>Timeouts and other errors with HTTP requests</h2>
			<p>Similarly, you<a id="_idIndexMarker456"/> could also experience errors when sending requests to an external API server. To be clear, timeouts are considered errors as well. The code for this example is located within <strong class="source-inline">examples/http.go</strong>, which contains <span class="No-Break">two functions:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">HTTPTimeout()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">HTTPError()</strong></span></li>
			</ul>
			<p>Before we dig into the previous methods, let’s talk about the code that needs to be running in order for these methods to <span class="No-Break">execute properly.</span></p>
			<p>The <strong class="source-inline">cmd/api/</strong> folder contains the code for defining the handlers and starting an HTTP server locally. The <strong class="source-inline">mux.HandleFunc</strong> method defines the request pattern and matches it to the <strong class="source-inline">handler</strong> function. The server is defined by its address, which runs on localhost, port <strong class="source-inline">8080</strong>, and the <strong class="source-inline">Handler</strong>, <strong class="source-inline">mux</strong>. Finally, the <strong class="source-inline">server.ListenAndServe()</strong> method is called on the <span class="No-Break">defined server:</span></p>
			<pre class="source-code">
func main() {
    mux := http.NewServeMux()
    server := &amp;http.Server{
        Addr: ":8080",
        Handler: mux,
    }
    mux.HandleFunc("/timeout", timeoutHandler)
    mux.HandleFunc("/error", errorHandler)
    err := server.ListenAndServe()
    if err != nil {
        fmt.Println("error starting api: ", err)
        os.Exit(1)
    }
}</pre>
			<p>The<a id="_idIndexMarker457"/> timeout handler is defined simply. It waits two seconds before sending the response by using the <span class="No-Break"><strong class="source-inline">time.After(time.Second*2)</strong></span><span class="No-Break"> channel:</span></p>
			<pre class="source-code">
func timeoutHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Println("got /timeout request")
    &lt;-time.After(time.Second * 2)
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("this took a long time"))
}</pre>
			<p>The error handler returns a status code <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">http.StatusInternalServerError</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func errorHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Println("got /error request")
    w.WriteHeader(http.StatusInternalServerError)
    w.Write([]byte("internal service error"))
}</pre>
			<p>In a separate terminal, run the <strong class="source-inline">make install</strong> command inside the root of the repository to start the API server. Now, let’s look at the code that calls each endpoint and show how we handle it. Let’s first discuss the first type of error – <span class="No-Break">the timeout:</span></p>
			<ul>
				<li><strong class="source-inline">HTTPTimeout</strong>: Inside the <strong class="source-inline">examples/http.go</strong> file resides the <strong class="source-inline">HTTPTimeout</strong> method. Let’s walk through the <span class="No-Break">code together:</span><ul><li>First, we <em class="italic">define the client</em> using the <strong class="source-inline">http.Client</strong> struct, specifying the timeout as one second. Remember that as the timeout handler on the API returns a response after two seconds, the request is sure <span class="No-Break">to timeout:</span></li></ul></li>
			</ul>
			<pre class="source-code">
client := http.Client{
    Timeout: 1 * time.Second,
}</pre>
			<ul>
				<li>Next, we <em class="italic">define the request</em>: a <strong class="source-inline">GET</strong> method to the <strong class="source-inline">/timeout</strong> endpoint. We pass in an <span class="No-Break">empty body:</span></li>
			</ul>
			<pre class="source-code">
body := &amp;bytes.Buffer{}
req, err := http.NewRequest(http.MethodGet, "http://localhost:8080/timeout", body)
if err != nil {
    panic(err)
}</pre>
			<ul>
				<li>The <a id="_idIndexMarker458"/>client <strong class="source-inline">Do</strong> method is called with the request variable passed in as a parameter. We wait for the server to respond within a second and if not, an error is returned. Any errors returned by the client’s <strong class="source-inline">Do</strong> method will be of the <strong class="source-inline">*url.Error</strong> type. You can access the different fields to this error type, but in the following code, we check whether the error’s <strong class="source-inline">Timeout</strong> method returns <strong class="source-inline">true</strong>. In this statement, we can act however we’d like. We can return the error for now. We can back off and retry or we can exit. It depends on what your specific use <span class="No-Break">case is:</span></li>
			</ul>
			<pre class="source-code">
resp, err := client.Do(req)
if err != nil {
    urlErr := err.(*url.Error)
    if urlErr.Timeout() {
        fmt.Println("timeout: ", err)
        return
    }
}
defer resp.Body.Close()</pre>
			<p>When this method is executed, the output <span class="No-Break">is printed:</span></p>
			<pre class="console">
timeout:  Get "http://localhost:8080/timeout": context deadline exceeded (Client.Timeout exceeded while awaiting headers)</pre>
			<p>A timeout <a id="_idIndexMarker459"/>is just one error, but there are many others you might encounter. Since the client <strong class="source-inline">Do</strong> method returns a particular error type in the <strong class="source-inline">net/url</strong> package, let’s discuss that. Inside the <strong class="source-inline">net/url</strong> package exists the <strong class="source-inline">url.Error</strong> <span class="No-Break">type definition:</span></p>
			<pre class="source-code">
type Error struct {
    Op  string // Operation
    URL string // URL
    Err error // Error
}</pre>
			<p>The error contains the <strong class="source-inline">Timeout()</strong>method, which returns <strong class="source-inline">true</strong> when a request times out, and it is important to note that when the response status is anything other than <strong class="source-inline">200 OK</strong>, the error is not set. However, the status code indicates an error response. Error responses can be split into two <span class="No-Break">different categories:</span></p>
			<ul>
				<li><strong class="bold">Client error responses</strong> (status codes range from <strong class="source-inline">400</strong> to <strong class="source-inline">499</strong>) indicate an error on the<a id="_idIndexMarker460"/> client’s side. A few examples of this include <strong class="source-inline">Bad Request (400)</strong>,<strong class="source-inline"> Unauthorized (401)</strong>, and <strong class="source-inline">Not </strong><span class="No-Break"><strong class="source-inline">Found (404)</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Server error messages</strong> (status codes range from <strong class="source-inline">500</strong> to <strong class="source-inline">599</strong>) indicate an error <a id="_idIndexMarker461"/>on the server side. A few common examples of this include <strong class="source-inline">Internal Server Error (500)</strong>, <strong class="source-inline">Bad Gateway (502)</strong>, and <strong class="source-inline">Service </strong><span class="No-Break"><strong class="source-inline">Unavailable (503)</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p><strong class="source-inline">HTTPErrors</strong>: Some sample code of how this can be handled exists within the <strong class="source-inline">examples/http.go</strong> file within the <strong class="source-inline">HTTPErrors</strong> method. Again, it’s important to make sure that the API server is running before executing <span class="No-Break">this code:</span></p>
			<ul>
				<li>The code within the method starts by calling a <strong class="source-inline">GET</strong> request to the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break"> endpoint:</span></li>
			</ul>
			<pre class="source-code">
resp, err := http.Get("http://localhost:8080/error")</pre>
			<ul>
				<li>If the<a id="_idIndexMarker462"/> error is not <strong class="source-inline">nil</strong>, then we cast it to the <strong class="source-inline">url.Error</strong> type to access the fields and methods within it. For example, we check whether <strong class="source-inline">urlError</strong> is a timeout or a temporary network error. If it is neither, then we can output as much information as we know about the error to standard output. This additional information can help us to determine what steps to <span class="No-Break">take next:</span></li>
			</ul>
			<pre class="source-code">
if err != nil {
    urlErr := err.(*url.Error)
    if urlErr.Timeout() {
         // a timeout is a type of error
        fmt.Println("timeout: ", err)
        return
    }
    if urlErr.Temporary() {
        // a temporary network error, retry later
        fmt.Println("temporary: ", err)
        return
    }
    fmt.Printf("operation: %s, url: %s, error: %s\n", urlErr.
        Op,        urlErr.URL, urlErr.Error())
    return
}</pre>
			<ul>
				<li>Since <a id="_idIndexMarker463"/>the status code error response isn’t considered a Golang error, the response body might have some useful information. If it’s not <strong class="source-inline">nil</strong>, then we can read the <span class="No-Break">status code:</span></li>
			</ul>
			<pre class="source-code">
if resp != nil {
    defer resp.Body.Close()</pre>
			<ul>
				<li>We initially check that <strong class="source-inline">StatusCode</strong> doesn’t equal <strong class="source-inline">http.StatusOK</strong>. From there, we can check for particular error messages and take the appropriate action. In this example, we only check for three different types of error responses, but you can check for whichever ones make sense for what <span class="No-Break">you’re doing:</span></li>
			</ul>
			<pre class="source-code">
if resp.StatusCode != http.StatusOK {
        // action for when status code is not okay
        switch resp.StatusCode {
        case http.StatusBadRequest:
            fmt.Printf("bad request: %v\n", resp.Status)
        case http.StatusInternalServerError:
            fmt.Printf("internal service error: %v\n", resp.
                Status)
        default:
            fmt.Printf("unexpected status code: %v\n", resp.
                StatusCode)
        }
    }</pre>
			<ul>
				<li>Finally, a client or server error status does not necessarily mean that the response body is <strong class="source-inline">nil</strong>. We can output the response body in case there’s any useful<a id="_idIndexMarker464"/> information we can <span class="No-Break">further gather:</span></li>
			</ul>
			<pre class="source-code">
    data, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println("err:", err)
    }
    fmt.Println("response body:", string(data))
}</pre>
			<p>This concludes the section for handling HTTP timeouts and other errors. Although the examples are simple, they give you the necessary information and guidance to handle timeouts, temporary networks, and <span class="No-Break">other errors.</span></p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor139"/>Summary</h1>
			<p>Over the course of this chapter, you’ve learned about the <strong class="source-inline">os/exec</strong> package in depth. This included learning about the different ways to create commands: using the <strong class="source-inline">command</strong> struct or the <strong class="source-inline">Command</strong> method. Not only have we created commands, but we’ve also passed file descriptors to them to receive information back. We learned about the different ways to run a command using the <strong class="source-inline">Run</strong> or <strong class="source-inline">Start</strong> method and the multiple ways of retrieving data from the standard output, standard error types, and other <span class="No-Break">file descriptors.</span></p>
			<p>In this chapter, we also discussed the <strong class="source-inline">net/http</strong> and <strong class="source-inline">net/url</strong> packages, which are important to be comfortable with when creating HTTP requests to external API servers. Several examples taught us how to create requests with the methods on <strong class="source-inline">http.Client</strong>, including <strong class="source-inline">Do</strong>, <strong class="source-inline">Get</strong>, <strong class="source-inline">Post</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">PostForm</strong></span><span class="No-Break">.</span></p>
			<p>It’s important to learn how to build robust code, and handling errors gracefully is part of the process. We need to know how to capture errors first, so we discussed how to detect some common errors that can occur when running an external process or sending a request to an external API server. Capturing and handling other errors gives us confidence that our code is ready to take appropriate action when they occur. Finally, we now know how to check for different status codes when the response is <span class="No-Break">not okay.</span></p>
			<p>With all the information learned in this chapter, we should now be more confident in building a CLI that interacts with external commands or sends requests to external APIs. In the next chapter, we’ll learn how to write code that can run on multiple different architectures and <span class="No-Break">operating systems.</span></p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor140"/>Questions</h1>
			<ol>
				<li>What method in the <strong class="source-inline">time</strong> package do we use to receive the time after a particular duration via <span class="No-Break">a channel?</span></li>
				<li>What is the error type returned from <strong class="source-inline">http.Client</strong>’s <span class="No-Break"><strong class="source-inline">Do</strong></span><span class="No-Break"> method?</span></li>
				<li>When an HTTP request receives a response with a status code other than <strong class="source-inline">StatusOK</strong>, is the error returned from the <span class="No-Break">request populated?</span></li>
			</ol>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor141"/>Answers</h1>
			<ol>
				<li value="1"><strong class="source-inline">time.After(d Duration) &lt;-</strong><span class="No-Break"><strong class="source-inline">chan Time</strong></span></li>
				<li><strong class="source-inline">*</strong><span class="No-Break"><strong class="source-inline">url.Error</strong></span></li>
				<li><span class="No-Break">No</span></li>
			</ol>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor142"/>Further reading</h1>
			<ul>
				<li>Visit the online documentation for <strong class="source-inline">net/http</strong> <strong class="source-inline">at</strong> <strong class="source-inline">h</strong><a href="https://pkg.go.dev/net/http">ttps://pkg.go.dev/net/http</a>, and for net/url <span class="No-Break">at h</span><a href="https://pkg.go.dev/net/url"><span class="No-Break">ttps://pkg.go.dev/net/url</span></a></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer045" class="IMG---Figure">
			</div>
		</div>
	</body></html>