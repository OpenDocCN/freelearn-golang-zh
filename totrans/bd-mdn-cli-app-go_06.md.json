["```go\ncmd := exec.Cmd{}\n```", "```go\ncmd.Path = filepath.Join(os.Getenv(\"GOPATH\"), \"bin\", \"uppercase\")\n```", "```go\ncmd.Args = []string{\"uppercase\", \"hack the planet\"}\n```", "```go\ncmd.Stdin = os.Stdin // io.Reader\ncmd.Stdout = os.Stdout // io.Writer\ncmd.Stderr = os.Stderr // io.Writer\n```", "```go\nreader, writer, err := os.Pipe()\nif err != nil {\n    panic(err)\n}\ncmd.ExtraFiles = []*os.File{writer}\nif err := cmd.Start(); err != nil {\n    panic(err)\n}\n```", "```go\ninput := os.Args[1:]\noutput := strings.ToUpper(strings.Join(input, \"\"))\npipe := os.NewFile(uintptr(3), \"pipe\")\nerr := json.NewEncoder(pipe).Encode(output)\nif err != nil {\n    panic(err)\n}\n```", "```go\nvar data string\ndecoder := json.NewDecoder(reader)\nif err := decoder.Decode(&data); err != nil {\n    panic(err)\n}\nfmt.Println(data)\n```", "```go\ncmd := exec.Command(filepath.Join(os.Getenv(\"GOPATH\"), \"bin\", \"uppercase\"), \"hello world\")\nreader, writer, err := os.Pipe()\nif err != nil {\n    panic(err)\n}\n```", "```go\ncmd := exec.Command(filepath.Join(os.Getenv(\"GOPATH\"), \"bin\", \"lettercount\"), \"four\")\ncmd.Stdin = os.Stdin\ncmd.Stdout = os.Stdout\ncmd.Stderr = os.Stderr\nvar count int\n```", "```go\nreader, writer, err := os.Pipe()\nif err != nil {\n    panic(err)\n}\ncmd.ExtraFiles = []*os.File{writer}\nif err := cmd.Run(); err != nil {\n    panic(err)\n}\nif err := json.NewDecoder(reader).Decode(&count); err != nil {\n    panic(err)\n}\n```", "```go\nfmt.Println(\"letter count: \", count)\n```", "```go\nif err := cmd.Start(); err != nil {\n    panic(err)\n}\nerr = cmd.Wait()\nif err != nil {\n    panic(err)\n}\n```", "```go\nfmt.Printf(\"successfully counted the letters of \\\"%v\\\" as %d\\n\", input, len(runes))\n```", "```go\nout, err := cmd.Output()\n```", "```go\noutput: successfully counted the letters of \"four\" as 4\n```", "```go\nfmt.Fprintln(os.Stderr, \"this is where the errors go\")\n```", "```go\nCombinedOutput, err := cmd.CombinedOutput()\n```", "```go\nfunc CreateCommandUsingCommandFunction() {\n    cmd := exec.Command(\"cmd\", \"/C\", \"ping\", \"google.com\")\n    output, err := cmd.CombinedOutput()\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(string(output))\n}\n```", "```go\nfunc Pagination() {\n    moreCmd := exec.Command(\"cmd\", \"/C\", \"more\")\n    moreCmd.Stdin = strings.NewReader(blob)\n    moreCmd.Stdout = os.Stdout\n    moreCmd.Stderr = os.Stderr\n    err := moreCmd.Run()\n    if err != nil {\n        panic(err)\n    }\n}\nvar (\n    blob = `\n    …\n    `\n)\n```", "```go\nparams := \"id=\" + url.QueryEscape(cmd.id)\npath := fmt.Sprintf(\"http://localhost/request?%s\", params)\npayload := &bytes.Buffer{}\nmethod := \"GET\"\nclient := cmd.client\n```", "```go\nreq, err := http.NewRequest(method, path, payload)\nif err != nil {\n    return err\n}\nresp, err := client.Do(req)\nif err != nil {\n    return err\n}\ndefer resp.Body.Close()\n```", "```go\nb, err := io.ReadAll(resp.Body)\nif err != nil {\n    return err\n}\nfmt.Println(string(b))\nreturn nil\n```", "```go\nvar audio Audio\nIf err := json.Unmarshal(b, &audio); err != nil {\n    fmt.Println(\"error unmarshalling JSON response\"\n}\n```", "```go\ncontentType := http.DetectContentType(b) // b are the bytes from reading the resp.Body\n```", "```go\nresp, err := http.Get(path)\nif err != nil {\n    return err\n}\ndefer resp.Body.Close()\n```", "```go\npath := fmt.Sprintf(\"http://localhost/request?limit=%d&page=%d\", limit, page)\n```", "```go\npagesCmd := exec.Command(filepath.Join(os.Getenv(\"GOPATH\"), \"bin\", \"pages\"))\nreader, writer, err := os.Pipe()\nif err != nil {\n    panic(err)\n}\npagesCmd.Stdin = os.Stdin\npagesCmd.Stdout = os.Stdout\npagesCmd.Stderr = os.Stderr\npagesCmd.ExtraFiles = []*os.File{writer}\nif err := pagesCmd.Run(); err != nil {\n    panic(err)\n}\n```", "```go\nvar data string\ndecoder := json.NewDecoder(reader)\nif err := decoder.Decode(&data); err != nil {\n    panic(err)\n}\n```", "```go\nlessCmd := exec.Command(\"/usr/bin/less\")\nlessCmd.Stdin = strings.NewReader(data)\nlessCmd.Stdout = os.Stdout\nerr = lessCmd.Run()\nif err != nil {\n    panic(err)\n}\n```", "```go\ntype runner struct {\n    Run func() bool\n    limiter *rate.Limiter\n}\nfunc Limit() {\n    thing := runner{}\n    start := time.Now()\n```", "```go\n    thing.Run = func() bool {\n        if thing.limiter.Allow() {\n            fmt.Println(time.Now()) // or call request\n            return false\n        }\n        if time.Since(start) > 30*time.Second {\n            return true\n        }\n        return false\n    }\n```", "```go\n    thing.limiter = rate.NewLimiter(forEvery(1, 5*time.\n    Second),     1)\n```", "```go\n    for {\n        if thing.Run() {\n            break\n        }\n    }\n}\n```", "```go\nfunc forEvery(eventCount int, duration time.Duration) rate.Limit {\n    return rate.Every(duration / time.Duration(eventCount))\n}\n```", "```go\n2022-09-11 18:45:44.356917 -0700 PDT m=+0.000891459\n2022-09-11 18:45:49.356877 -0700 PDT m=+5.000891042\n2022-09-11 18:45:54.356837 -0700 PDT m=+10.000891084\n2022-09-11 18:45:59.356797 -0700 PDT m=+15.000891084\n2022-09-11 18:46:04.356757 -0700 PDT m=+20.000891167\n2022-09-11 18:46:09.356718 -0700 PDT m=+25.000891167\n```", "```go\nfunc Timeout() {\n    errChan := make(chan error, 1)\n    cmd := exec.Command(filepath.Join(os.Getenv(\"GOPATH\"), \n           \"bin\", \"timeout\"))\n    if err := cmd.Start(); err != nil {\n        panic(err)\n    }\n    go func() {\n        errChan <- cmd.Wait()\n    }()\n    select {\n        case <-time.After(time.Second * 10):\n            fmt.Println(\"timeout command timed out\")\n            return\n        case err := <-errChan:\n            if err != nil {\n                fmt.Println(\"timeout error:\", err)\n            }\n    }\n}\n```", "```go\ncmd := exec.Command(\"doesnotexist\", \"arg1\")\nif errors.Is(cmd.Err, exec.ErrDot) {\n    fmt.Println(\"path lookup resolved to a local directory\")\n}\nif err := cmd.Run(); err != nil {\n    if errors.Is(err, exec.ErrNotFound) {\n        fmt.Println(\"executable failed to resolve\")\n    }\n}\n```", "```go\ncmd := exec.Command(filepath.Join(os.Getenv(\"GOPATH\"), \"bin\", \"error\"))\nvar out bytes.Buffer\nvar stderr bytes.Buffer\ncmd.Stdout = &out\ncmd.Stderr = &stderr\nif err := cmd.Run(); err != nil {\n    fmt.Println(fmt.Sprint(err) + \": \" + stderr.String())\n    return\n}\nfmt.Println(out.String())\n```", "```go\nfunc main() {\n    if len(os.Args) != 0 { // not passing in any arguments in this example throws an error\n        fmt.Fprintf(os.Stderr, \"missing arguments\\n\")\n        os.Exit(1)\n    }\n    fmt.Println(\"executing command with no errors\")\n}\n```", "```go\ndefer func() {\n    if panicMessage := recover(); panicMessage != nil {\n        fmt.Fprintf(os.Stderr, \"(panic) : %v\\n\", panicMessage)\n        debug.PrintStack()\n        os.Exit(1)\n    }\n}()\npanic(\"help!\")\n```", "```go\nfunc main() {\n    mux := http.NewServeMux()\n    server := &http.Server{\n        Addr: \":8080\",\n        Handler: mux,\n    }\n    mux.HandleFunc(\"/timeout\", timeoutHandler)\n    mux.HandleFunc(\"/error\", errorHandler)\n    err := server.ListenAndServe()\n    if err != nil {\n        fmt.Println(\"error starting api: \", err)\n        os.Exit(1)\n    }\n}\n```", "```go\nfunc timeoutHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Println(\"got /timeout request\")\n    <-time.After(time.Second * 2)\n    w.WriteHeader(http.StatusOK)\n    w.Write([]byte(\"this took a long time\"))\n}\n```", "```go\nfunc errorHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Println(\"got /error request\")\n    w.WriteHeader(http.StatusInternalServerError)\n    w.Write([]byte(\"internal service error\"))\n}\n```", "```go\nclient := http.Client{\n    Timeout: 1 * time.Second,\n}\n```", "```go\nbody := &bytes.Buffer{}\nreq, err := http.NewRequest(http.MethodGet, \"http://localhost:8080/timeout\", body)\nif err != nil {\n    panic(err)\n}\n```", "```go\nresp, err := client.Do(req)\nif err != nil {\n    urlErr := err.(*url.Error)\n    if urlErr.Timeout() {\n        fmt.Println(\"timeout: \", err)\n        return\n    }\n}\ndefer resp.Body.Close()\n```", "```go\ntimeout:  Get \"http://localhost:8080/timeout\": context deadline exceeded (Client.Timeout exceeded while awaiting headers)\n```", "```go\ntype Error struct {\n    Op  string // Operation\n    URL string // URL\n    Err error // Error\n}\n```", "```go\nresp, err := http.Get(\"http://localhost:8080/error\")\n```", "```go\nif err != nil {\n    urlErr := err.(*url.Error)\n    if urlErr.Timeout() {\n         // a timeout is a type of error\n        fmt.Println(\"timeout: \", err)\n        return\n    }\n    if urlErr.Temporary() {\n        // a temporary network error, retry later\n        fmt.Println(\"temporary: \", err)\n        return\n    }\n    fmt.Printf(\"operation: %s, url: %s, error: %s\\n\", urlErr.\n        Op,        urlErr.URL, urlErr.Error())\n    return\n}\n```", "```go\nif resp != nil {\n    defer resp.Body.Close()\n```", "```go\nif resp.StatusCode != http.StatusOK {\n        // action for when status code is not okay\n        switch resp.StatusCode {\n        case http.StatusBadRequest:\n            fmt.Printf(\"bad request: %v\\n\", resp.Status)\n        case http.StatusInternalServerError:\n            fmt.Printf(\"internal service error: %v\\n\", resp.\n                Status)\n        default:\n            fmt.Printf(\"unexpected status code: %v\\n\", resp.\n                StatusCode)\n        }\n    }\n```", "```go\n    data, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        fmt.Println(\"err:\", err)\n    }\n    fmt.Println(\"response body:\", string(data))\n}\n```"]